{"Smelly Sample":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2013 Sebastian Kaspari\nCopyright 2012 Daniel E. Moctezuma <democtezuma@gmail.com>\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage org.yaaic.irc;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Vector;\nimport java.util.regex.Pattern;\n\nimport org.jibble.pircbot.NickAlreadyInUseException;\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.command.CommandParser;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Query;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.ServerInfo;\nimport org.yaaic.model.Status;\n\nimport android.content.Intent;\nimport android.util.Log;\n\n/**\n * The class that actually handles the connection to an IRC server\n *\n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class IRCConnection extends PircBot\n{\n    private static final String TAG = \"Yaaic/IRCConnection\";\n    private final IRCService service;\n    private final Server server;\n    private ArrayList<String> autojoinChannels;\n    private Pattern mNickMatch;\n\n    private boolean ignoreMOTD = true;\n    private boolean debugTraffic = false;\n    private boolean isQuitting = false;\n    private boolean disposeRequested = false;\n    private final Object isQuittingLock = new Object();\n\n    /**\n     * Create a new connection\n     *\n     * @param service\n     * @param serverId\n     */\n    public IRCConnection(IRCService service, int serverId)\n    {\n        this.server = Yaaic.getInstance().getServerById(serverId);\n        this.service = service;\n\n        this.debugTraffic = service.getSettings().debugTraffic();\n\n        // XXX: Should be configurable via settings\n        this.setAutoNickChange(true);\n\n        this.setFinger(\"http://www.youtube.com/watch?v=oHg5SJYRHA0\");\n        this.updateNickMatchPattern();\n    }\n\n    /**\n     * This method handles events when any line of text arrives from the server.\n     *\n     * We are intercepting this method call for logging the IRC traffic if\n     * this debug option is set.\n     */\n    @Override\n    protected void handleLine(String line) throws NickAlreadyInUseException, IOException {\n        if (debugTraffic) {\n            Log.v(TAG, server.getTitle() + \" :: \" + line);\n        }\n\n        super.handleLine(line);\n    }\n\n    /**\n     * Set the nickname of the user\n     *\n     * @param nickname The nickname to use\n     */\n    public void setNickname(String nickname)\n    {\n        this.setName(nickname);\n        this.updateNickMatchPattern();\n    }\n\n    /**\n     * Set the real name of the user\n     *\n     * @param realname The realname to use\n     */\n    public void setRealName(String realname)\n    {\n        // XXX: Pircbot uses the version for \"real name\" and \"version\".\n        //      The real \"version\" value is provided by onVersion()\n        this.setVersion(realname);\n    }\n\n    /**\n     * Set channels to autojoin after connect\n     *\n     * @param channels\n     */\n    public void setAutojoinChannels(ArrayList<String> channels)\n    {\n        autojoinChannels = channels;\n    }\n\n    /**\n     * On version (CTCP version)\n     *\n     * This is a fix for pircbot as pircbot uses the version as \"real name\" and as \"version\"\n     */\n    @Override\n    protected void onVersion(String sourceNick, String sourceLogin,    String sourceHostname, String target)\n    {\n        this.sendRawLine(\n            \"NOTICE \" + sourceNick + \" :\\u0001VERSION \" +\n            \"Yaaic - Yet Another Android IRC Client - http://www.yaaic.org\" +\n            \"\\u0001\"\n        );\n    }\n\n    /**\n     * Set the ident of the user\n     *\n     * @param ident The ident to use\n     */\n    public void setIdent(String ident)\n    {\n        this.setLogin(ident);\n    }\n\n    /**\n     * On connect\n     */\n    @Override\n    public void onConnect()\n    {\n        server.setStatus(Status.CONNECTED);\n\n        server.setMayReconnect(true);\n\n        ignoreMOTD = service.getSettings().isIgnoreMOTDEnabled();\n\n        service.sendBroadcast(\n            Broadcast.createServerIntent(Broadcast.SERVER_UPDATE, server.getId())\n        );\n\n        service.notifyConnected(server.getTitle());\n\n        Message message = new Message(service.getString(R.string.message_connected, server.getTitle()));\n        message.setColor(Message.COLOR_GREEN);\n        server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n        Message infoMessage = new Message(service.getString(R.string.message_now_login));\n        infoMessage.setColor(Message.COLOR_GREY);\n        server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(infoMessage);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            ServerInfo.DEFAULT_NAME\n        );\n\n        if (server.getAuthentication().hasNickservCredentials()) {\n            identify(server.getAuthentication().getNickservPassword());\n        }\n\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On register\n     */\n    @Override\n    public void onRegister()\n    {\n        // Call parent method to ensure \"register\" status is tracked\n        super.onRegister();\n\n        // execute commands\n        CommandParser parser = CommandParser.getInstance();\n\n        this.updateNickMatchPattern();\n        for (String command : server.getConnectCommands()) {\n            parser.parse(command, server, server.getConversation(ServerInfo.DEFAULT_NAME), service);\n        }\n\n        // TODO: Detect \"You are now identified for <nick>\" notices from NickServ and handle\n        //       auto joins in onNotice instead if the user has chosen to wait for NickServ\n        //       identification before auto joining channels.\n\n        // delay 1 sec before auto joining channels\n        try {\n            Thread.sleep(1000);\n        } catch(InterruptedException e) {\n            // do nothing\n        }\n\n        // join channels\n        if (autojoinChannels != null) {\n            for (String channel : autojoinChannels) {\n                // Add support for channel keys\n                joinChannel(channel);\n            }\n        } else {\n            for (String channel : server.getAutoJoinChannels()) {\n                joinChannel(channel);\n            }\n        }\n\n        Message infoMessage = new Message(service.getString(R.string.message_login_done));\n        infoMessage.setColor(Message.COLOR_GREY);\n        server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(infoMessage);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            ServerInfo.DEFAULT_NAME\n        );\n\n        service.sendBroadcast(intent);\n    }\n    /**\n     * On channel action\n     */\n    @Override\n    protected void onAction(String sender, String login, String hostname, String target, String action)\n    {\n        Conversation conversation;\n\n        Message message = new Message(sender + \" \" + action);\n        message.setIcon(R.drawable.action);\n\n        String queryNick = target;\n        if (queryNick.equals(this.getNick())) {\n            // We are the target - this is an action in a query\n            queryNick = sender;\n        }\n        conversation = server.getConversation(queryNick);\n\n        if (conversation == null) {\n            // Open a query if there's none yet\n            conversation = new Query(queryNick);\n            conversation.setHistorySize(service.getSettings().getHistorySize());\n            server.addConversation(conversation);\n            conversation.addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_NEW,\n                server.getId(),\n                queryNick\n            );\n            service.sendBroadcast(intent);\n        } else {\n            conversation.addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                queryNick\n            );\n            service.sendBroadcast(intent);\n        }\n\n        if (sender.equals(this.getNick())) {\n            // Don't notify for something sent in our name\n            return;\n        }\n\n        boolean mentioned = isMentioned(action);\n        if (mentioned || target.equals(this.getNick())) {\n            if (conversation.getStatus() != Conversation.STATUS_SELECTED || !server.getIsForeground()) {\n                service.addNewMention(\n                    server.getId(),\n                    conversation,\n                    conversation.getName() + \": \" + sender + \" \" + action,\n                    service.getSettings().isVibrateHighlightEnabled(),\n                    service.getSettings().isSoundHighlightEnabled(),\n                    service.getSettings().isLedHighlightEnabled()\n                );\n            }\n        }\n\n        if (mentioned) {\n            // highlight\n            message.setColor(Message.COLOR_RED);\n            conversation.setStatus(Conversation.STATUS_HIGHLIGHT);\n        }\n    }\n\n    /**\n     * On Channel Info\n     */\n    @Override\n    protected void onChannelInfo(String channel, int userCount, String topic)\n    {\n    }\n\n    /**\n     * On Deop\n     */\n    @Override\n    protected void onDeop(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n    {\n        Message message = new Message(service.getString(R.string.message_deop, sourceNick, recipient));\n        message.setIcon(R.drawable.op);\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On DeVoice\n     */\n    @Override\n    protected void onDeVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n    {\n        Message message = new Message(service.getString(R.string.message_devoice, sourceNick, recipient));\n        message.setColor(Message.COLOR_BLUE);\n        message.setIcon(R.drawable.voice);\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On Invite\n     */\n    @Override\n    protected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String target)\n    {\n        if (targetNick.equals(this.getNick())) {\n            // We are invited\n            Message message = new Message(service.getString(R.string.message_invite_you, sourceNick, target));\n            server.getConversation(server.getSelectedConversation()).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                server.getSelectedConversation()\n            );\n            service.sendBroadcast(intent);\n        } else {\n            // Someone is invited\n            Message message = new Message(service.getString(R.string.message_invite_someone, sourceNick, targetNick, target));\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Join\n     */\n    @Override\n    protected void onJoin(String target, String sender, String login, String hostname)\n    {\n        if (sender.equalsIgnoreCase(getNick()) && server.getConversation(target) == null) {\n            // We joined a new channel\n            Conversation conversation = new Channel(target);\n            conversation.setHistorySize(service.getSettings().getHistorySize());\n            server.addConversation(conversation);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_NEW,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        } else if (service.getSettings().showJoinPartAndQuit()) {\n            Message message = new Message(\n                service.getString(R.string.message_join, sender),\n                Message.TYPE_MISC\n            );\n\n            message.setIcon(R.drawable.join);\n            message.setColor(Message.COLOR_GREEN);\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Kick\n     */\n    @Override\n    protected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n    {\n        if (recipientNick.equals(getNick())) {\n            // We are kicked\n            service.ackNewMentions(server.getId(), target);\n            server.removeConversation(target);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_REMOVE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        } else {\n            Message message = new Message(service.getString(R.string.message_kick, kickerNick, recipientNick));\n            message.setColor(Message.COLOR_GREEN);\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Message\n     */\n    @Override\n    protected void onMessage(String target, String sender, String login, String hostname, String text)\n    {\n        Message message = new Message(text, sender);\n        Conversation conversation = server.getConversation(target);\n\n        if (isMentioned(text)) {\n            // highlight\n            message.setColor(Message.COLOR_RED);\n            if (conversation.getStatus() != Conversation.STATUS_SELECTED || !server.getIsForeground()) {\n                service.addNewMention(\n                    server.getId(),\n                    conversation,\n                    target + \": <\" + sender + \"> \" + text,\n                    service.getSettings().isVibrateHighlightEnabled(),\n                    service.getSettings().isSoundHighlightEnabled(),\n                    service.getSettings().isLedHighlightEnabled()\n                );\n            }\n\n            conversation.setStatus(Conversation.STATUS_HIGHLIGHT);\n        }\n\n        conversation.addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On Mode\n     */\n    @Override\n    protected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n    {\n        // Disabled as it doubles events (e.g. onOp and onMode will be called)\n\n        /*\n        Message message = new Message(sourceNick + \" sets mode \" + mode);\n        server.getChannel(target).addMessage(message);\n\n        Intent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n        intent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n        intent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n        service.sendBroadcast(intent);\n         */\n    }\n\n    /**\n     * On Nick Change\n     */\n    @Override\n    protected void onNickChange(String oldNick, String login, String hostname, String newNick)\n    {\n        if (getNick().equalsIgnoreCase(newNick)) {\n            this.updateNickMatchPattern();\n\n            // Send message about own change to server info window\n            Message message = new Message(service.getString(R.string.message_self_rename, newNick));\n            message.setColor(Message.COLOR_GREEN);\n            server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                ServerInfo.DEFAULT_NAME\n            );\n\n            service.sendBroadcast(intent);\n        }\n\n        Vector<String> channels = getChannelsByNickname(newNick);\n\n        for (String target : channels) {\n            Message message = new Message(service.getString(R.string.message_rename, oldNick, newNick));\n            message.setColor(Message.COLOR_GREEN);\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Notice\n     */\n    @Override\n    protected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n    {\n        // Post notice to currently selected conversation\n        Conversation conversation;\n\n        if (service.getSettings().showNoticeInServerWindow()) {\n            conversation = server.getConversation(ServerInfo.DEFAULT_NAME);\n        } else {\n            conversation = server.getConversation(server.getSelectedConversation());\n\n            if (conversation == null) {\n                // Fallback: Use ServerInfo view\n                conversation = server.getConversation(ServerInfo.DEFAULT_NAME);\n            }\n        }\n\n        Message message = new Message(\"-\" + sourceNick + \"- \" + notice);\n        message.setIcon(R.drawable.info);\n        conversation.addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            conversation.getName()\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On Op\n     */\n    @Override\n    protected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n    {\n        Message message = new Message(service.getString(R.string.message_op, sourceNick, recipient));\n        message.setColor(Message.COLOR_BLUE);\n        message.setIcon(R.drawable.op);\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On Part\n     */\n    @Override\n    protected void onPart(String target, String sender, String login, String hostname)\n    {\n        if (sender.equals(getNick())) {\n            // We parted a channel\n            service.ackNewMentions(server.getId(), target);\n            server.removeConversation(target);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_REMOVE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        } else if (service.getSettings().showJoinPartAndQuit()) {\n            Message message = new Message(\n                service.getString(R.string.message_part, sender),\n                Message.TYPE_MISC\n            );\n\n            message.setColor(Message.COLOR_GREEN);\n            message.setIcon(R.drawable.part);\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Private Message\n     */\n    @Override\n    protected void onPrivateMessage(String sender, String login, String hostname, String target, String text)\n    {\n        Message message = new Message(\"<\" + sender + \"> \" + text);\n        String queryNick = sender;\n\n        if (queryNick.equals(this.getNick())) {\n            queryNick = target;\n        }\n        Conversation conversation = server.getConversation(queryNick);\n\n        if (conversation == null) {\n            // Open a query if there's none yet\n            conversation = new Query(queryNick);\n            conversation.setHistorySize(service.getSettings().getHistorySize());\n            conversation.addMessage(message);\n            server.addConversation(conversation);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_NEW,\n                server.getId(),\n                queryNick\n            );\n            service.sendBroadcast(intent);\n        } else {\n            conversation.addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                queryNick\n            );\n            service.sendBroadcast(intent);\n        }\n\n        if (sender.equals(this.getNick())) {\n            // Don't notify for something sent in our name\n            return;\n        }\n\n        if (conversation.getStatus() != Conversation.STATUS_SELECTED || !server.getIsForeground()) {\n            service.addNewMention(\n                server.getId(),\n                conversation,\n                \"<\" + sender + \"> \" + text,\n                service.getSettings().isVibrateHighlightEnabled(),\n                service.getSettings().isSoundHighlightEnabled(),\n                service.getSettings().isLedHighlightEnabled()\n            );\n        }\n\n        if (isMentioned(text)) {\n            message.setColor(Message.COLOR_RED);\n            conversation.setStatus(Conversation.STATUS_HIGHLIGHT);\n        }\n    }\n\n    /**\n     * On Quit\n     */\n    @Override\n    protected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n    {\n        if (sourceNick.equals(this.getNick())) {\n            return;\n        }\n\n        if (service.getSettings().showJoinPartAndQuit()) {\n            Vector<String> channels = getChannelsByNickname(sourceNick);\n\n            for (String target : channels) {\n                Message message = new Message(\n                    service.getString(R.string.message_quit, sourceNick, reason),\n                    Message.TYPE_MISC\n                );\n\n                message.setColor(Message.COLOR_GREEN);\n                message.setIcon(R.drawable.quit);\n                server.getConversation(target).addMessage(message);\n\n                Intent intent = Broadcast.createConversationIntent(\n                    Broadcast.CONVERSATION_MESSAGE,\n                    server.getId(),\n                    target\n                );\n                service.sendBroadcast(intent);\n            }\n\n            // Look if there's a query to update\n            Conversation conversation = server.getConversation(sourceNick);\n\n            if (conversation != null) {\n                Message message = new Message(\n                    service.getString(R.string.message_quit, sourceNick, reason),\n                    Message.TYPE_MISC\n                );\n\n                message.setColor(Message.COLOR_GREEN);\n                message.setIcon(R.drawable.quit);\n                conversation.addMessage(message);\n\n                Intent intent = Broadcast.createConversationIntent(\n                    Broadcast.CONVERSATION_MESSAGE,\n                    server.getId(),\n                    conversation.getName()\n                );\n                service.sendBroadcast(intent);\n            }\n        }\n    }\n\n    /**\n     * On Topic\n     */\n    @Override\n    public void onTopic(String target, String topic, String setBy, long date, boolean changed)\n    {\n        if (changed) {\n            Message message = new Message(service.getString(R.string.message_topic_set, setBy, topic));\n            message.setColor(Message.COLOR_YELLOW);\n            server.getConversation(target).addMessage(message);\n        } else {\n            Message message = new Message(service.getString(R.string.message_topic, topic));\n            message.setColor(Message.COLOR_YELLOW);\n            server.getConversation(target).addMessage(message);\n        }\n\n        // remember channel's topic\n        ((Channel) server.getConversation(target)).setTopic(topic);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n\n        // update the displayed conversation title if necessary\n        intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_TOPIC,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On User List\n     */\n    @Override\n    protected void onUserList(String channel, User[] users)\n    {\n        // XXX: Store user list somewhere and keep it updated or just broadcast some event?\n    }\n\n    /**\n     * On Voice\n     */\n    @Override\n    protected void onVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n    {\n        Message message = new Message(service.getString(R.string.message_voice, sourceNick, recipient));\n        message.setIcon(R.drawable.voice);\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On remove channel key\n     */\n    @Override\n    protected void onRemoveChannelKey(String target, String sourceNick, String sourceLogin, String sourceHostname, String key)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_channel_key, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set channel key\n     */\n    @Override\n    protected void onSetChannelKey(String target, String sourceNick, String sourceLogin, String sourceHostname, String key)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_key, sourceNick, key));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set secret\n     */\n    @Override\n    protected void onSetSecret(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_secret, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove secret\n     */\n    @Override\n    protected void onRemoveSecret(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_public, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set channel limit\n     */\n    @Override\n    protected void onSetChannelLimit(String target, String sourceNick, String sourceLogin, String sourceHostname, int limit)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_limit, sourceNick, limit));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove channel limit\n     */\n    @Override\n    protected void onRemoveChannelLimit(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_channel_limit, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set channel ban\n     */\n    @Override\n    protected void onSetChannelBan(String target, String sourceNick, String sourceLogin, String sourceHostname, String hostmask)\n    {\n        Message message = new Message(service.getString(R.string.message_set_ban, sourceNick, hostmask));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove channel ban\n     */\n    @Override\n    protected void onRemoveChannelBan(String target, String sourceNick, String sourceLogin, String sourceHostname, String hostmask)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_ban, sourceNick, hostmask));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set topic protection\n     */\n    @Override\n    protected void onSetTopicProtection(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_topic_protection, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove topic protection\n     */\n    @Override\n    protected void onRemoveTopicProtection(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_topic_protection, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set no external messages\n     */\n    @Override\n    protected void onSetNoExternalMessages(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_disable_external, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove no external messages\n     */\n    @Override\n    protected void onRemoveNoExternalMessages(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_enable_external, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set invite only\n     */\n    @Override\n    protected void onSetInviteOnly(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_invite_only, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove invite only\n     */\n    @Override\n    protected void onRemoveInviteOnly(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_invite_only, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set moderated\n     */\n    @Override\n    protected void onSetModerated(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_moderated, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove moderated\n     */\n    @Override\n    protected void onRemoveModerated(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_moderated, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set private\n     */\n    @Override\n    protected void onSetPrivate(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_private, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove private\n     */\n    @Override\n    protected void onRemovePrivate(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_public, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On unknown\n     */\n    @Override\n    protected void onUnknown(String line)\n    {\n        Message message = new Message(line);\n        message.setIcon(R.drawable.action);\n        message.setColor(Message.COLOR_GREY);\n        server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            ServerInfo.DEFAULT_NAME\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On server response\n     */\n    @Override\n    protected void onServerResponse(int code, String response)\n    {\n        if (code == 4) {\n            // User has registered with the server\n            onRegister();\n            return;\n        }\n        if ((code == 372 || code == 375) && ignoreMOTD) {\n            return;\n        }\n        if (code == 376 && ignoreMOTD) {\n            Message motdMessage = new Message(service.getString(R.string.message_motd_suppressed));\n            motdMessage.setColor(Message.COLOR_GREY);\n            server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(motdMessage);\n            ignoreMOTD = false;\n            return;\n        }\n\n        if (code >= 200 && code < 300) {\n            // Skip 2XX responses\n            return;\n        }\n\n        if (code == 353 || code == 366 || code == 332 || code == 333) {\n            return;\n        }\n\n        if (code < 10) {\n            // Skip server info\n            return;\n        }\n\n        // Currently disabled... to much text\n        Message message = new Message(response);\n        message.setColor(Message.COLOR_GREY);\n        server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            ServerInfo.DEFAULT_NAME\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On disconnect\n     */\n    @Override\n    public void onDisconnect()\n    {\n        // Call parent method to ensure \"register\" status is tracked\n        super.onDisconnect();\n\n        if (service.getSettings().isReconnectEnabled() && server.getStatus() != Status.DISCONNECTED) {\n            setAutojoinChannels(server.getCurrentChannelNames());\n\n            server.setStatus(Status.CONNECTING);\n            service.connect(server);\n        } else {\n            server.setStatus(Status.DISCONNECTED);\n        }\n\n        service.notifyDisconnected(server.getTitle());\n\n        Intent sIntent = Broadcast.createServerIntent(Broadcast.SERVER_UPDATE, server.getId());\n        service.sendBroadcast(sIntent);\n\n        Collection<Conversation> conversations = server.getConversations();\n\n        for (Conversation conversation : conversations) {\n            Message message = new Message(service.getString(R.string.message_disconnected));\n            message.setIcon(R.drawable.error);\n            message.setColor(Message.COLOR_RED);\n            server.getConversation(conversation.getName()).addMessage(message);\n\n            Intent cIntent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                conversation.getName()\n            );\n            service.sendBroadcast(cIntent);\n        }\n\n        synchronized(isQuittingLock) {\n            isQuitting = false;\n            if (disposeRequested) {\n                super.dispose();\n            }\n        }\n    }\n\n    /**\n     * Get all channels where the user with the given nickname is online\n     *\n     * @param nickname\n     * @return Array of channel names\n     */\n    private Vector<String> getChannelsByNickname(String nickname)\n    {\n        Vector<String> channels = new Vector<String>();\n        String[] channelArray = getChannels();\n\n        for (String channel : channelArray) {\n            User[] userArray = getUsers(channel);\n            for (User user : userArray) {\n                if (user.getNick().equals(nickname)) {\n                    channels.add(channel);\n                    break;\n                }\n            }\n        }\n\n        return channels;\n    }\n\n    /**\n     * Get list of users in a channel as array of strings\n     *\n     * @param channel Name of the channel\n     */\n    public String[] getUsersAsStringArray(String channel)\n    {\n        User[] userArray = getUsers(channel);\n        int mLength = userArray.length;\n        String[] users = new String[mLength];\n\n        for (int i = 0; i < mLength; i++) {\n            users[i] = userArray[i].getPrefix() + userArray[i].getNick();\n        }\n\n        return users;\n    }\n\n    /**\n     * Get a user by channel and nickname\n     *\n     * @param channel The channel the user is in\n     * @param nickname The nickname of the user (with or without prefix)\n     * @return the User object or null if user was not found\n     */\n    public User getUser(String channel, String nickname)\n    {\n        User[] users = getUsers(channel);\n        int mLength = users.length;\n\n        for (int i = 0; i < mLength; i++) {\n            if (nickname.equals(users[i].getNick())) {\n                return users[i];\n            }\n            if (nickname.equals(users[i].getPrefix() + users[i].getNick())) {\n                return users[i];\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Quits from the IRC server with default reason.\n     */\n    @Override\n    public void quitServer()\n    {\n        quitServer(service.getSettings().getQuitMessage());\n    }\n\n    @Override\n    public void quitServer(final String message)\n    {\n        synchronized(isQuittingLock) {\n            isQuitting = true;\n        }\n\n        new Thread() {\n            @Override\n            public void run() {\n                superClassQuitServer(message);\n            }\n        }.start();\n    }\n\n    private final void superClassQuitServer(String message)\n    {\n        super.quitServer(message);\n    }\n\n    /**\n     * Check whether the nickname has been mentioned.\n     *\n     * @param text The text to check for the nickname\n     * @return true if nickname was found, otherwise false\n     */\n    public boolean isMentioned(String text)\n    {\n        return mNickMatch.matcher(text).find();\n    }\n\n    /**\n     * Update the nick matching pattern, should be called when the nickname changes.\n     */\n    private void updateNickMatchPattern()\n    {\n        mNickMatch = Pattern.compile(\"(?:^|[\\\\s?!'�:;,.])\"+Pattern.quote(getNick())+\"(?:[\\\\s?!'�:;,.]|$)\", Pattern.CASE_INSENSITIVE);\n    }\n\n    @Override\n    public void dispose()\n    {\n        synchronized(isQuittingLock) {\n            if (isQuitting) {\n                disposeRequested = true;\n            } else {\n                super.dispose();\n            }\n        }\n    }\n}\n","Method after Refactoring":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2013 Sebastian Kaspari\nCopyright 2012 Daniel E. Moctezuma <democtezuma@gmail.com>\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage org.yaaic.irc;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Vector;\nimport java.util.regex.Pattern;\n\nimport org.jibble.pircbot.NickAlreadyInUseException;\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.command.CommandParser;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Query;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.ServerInfo;\nimport org.yaaic.model.Status;\n\nimport android.content.Intent;\nimport android.util.Log;\n\n/**\n * The class that actually handles the connection to an IRC server\n *\n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class IRCConnection extends PircBot\n{\n    private static final String TAG = \"Yaaic/IRCConnection\";\n    private final IRCService service;\n    private final Server server;\n    private ArrayList<String> autojoinChannels;\n    private Pattern mNickMatch;\n\n    private boolean ignoreMOTD = true;\n    private boolean debugTraffic = false;\n    private boolean isQuitting = false;\n    private boolean disposeRequested = false;\n    private final Object isQuittingLock = new Object();\n\n    /**\n     * Create a new connection\n     *\n     * @param service\n     * @param serverId\n     */\n    public IRCConnection(IRCService service, int serverId)\n    {\n        this.server = Yaaic.getInstance().getServerById(serverId);\n        this.service = service;\n\n        this.debugTraffic = service.getSettings().debugTraffic();\n\n        // XXX: Should be configurable via settings\n        this.setAutoNickChange(true);\n\n        this.setFinger(\"http://www.youtube.com/watch?v=oHg5SJYRHA0\");\n        this.updateNickMatchPattern();\n    }\n\n    /**\n     * This method handles events when any line of text arrives from the server.\n     *\n     * We are intercepting this method call for logging the IRC traffic if\n     * this debug option is set.\n     */\n    @Override\n    protected void handleLine(String line) throws NickAlreadyInUseException, IOException {\n        if (debugTraffic) {\n            Log.v(TAG, server.getTitle() + \" :: \" + line);\n        }\n\n        super.handleLine(line);\n    }\n\n    /**\n     * Set the nickname of the user\n     *\n     * @param nickname The nickname to use\n     */\n    public void setNickname(String nickname)\n    {\n        this.setName(nickname);\n        this.updateNickMatchPattern();\n    }\n\n    /**\n     * Set the real name of the user\n     *\n     * @param realname The realname to use\n     */\n    public void setRealName(String realname)\n    {\n        // XXX: Pircbot uses the version for \"real name\" and \"version\".\n        //      The real \"version\" value is provided by onVersion()\n        this.setVersion(realname);\n    }\n\n    /**\n     * Set channels to autojoin after connect\n     *\n     * @param channels\n     */\n    public void setAutojoinChannels(ArrayList<String> channels)\n    {\n        autojoinChannels = channels;\n    }\n\n    /**\n     * On version (CTCP version)\n     *\n     * This is a fix for pircbot as pircbot uses the version as \"real name\" and as \"version\"\n     */\n    @Override\n    protected void onVersion(String sourceNick, String sourceLogin,    String sourceHostname, String target)\n    {\n        this.sendRawLine(\n            \"NOTICE \" + sourceNick + \" :\\u0001VERSION \" +\n            \"Yaaic - Yet Another Android IRC Client - http://www.yaaic.org\" +\n            \"\\u0001\"\n        );\n    }\n\n    /**\n     * Set the ident of the user\n     *\n     * @param ident The ident to use\n     */\n    public void setIdent(String ident)\n    {\n        this.setLogin(ident);\n    }\n\n    /**\n     * On connect\n     */\n    @Override\n    public void onConnect()\n    {\n        server.setStatus(Status.CONNECTED);\n\n        server.setMayReconnect(true);\n\n        ignoreMOTD = service.getSettings().isIgnoreMOTDEnabled();\n\n        service.sendBroadcast(\n            Broadcast.createServerIntent(Broadcast.SERVER_UPDATE, server.getId())\n        );\n\n        service.notifyConnected(server.getTitle());\n\n        Message message = new Message(service.getString(R.string.message_connected, server.getTitle()));\n        message.setColor(Message.COLOR_GREEN);\n        server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n        Message infoMessage = new Message(service.getString(R.string.message_now_login));\n        infoMessage.setColor(Message.COLOR_GREY);\n        server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(infoMessage);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            ServerInfo.DEFAULT_NAME\n        );\n\n        if (server.getAuthentication().hasNickservCredentials()) {\n            identify(server.getAuthentication().getNickservPassword());\n        }\n\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On register\n     */\n    @Override\n    public void onRegister()\n    {\n        // Call parent method to ensure \"register\" status is tracked\n        super.onRegister();\n\n        // execute commands\n        CommandParser parser = CommandParser.getInstance();\n\n        this.updateNickMatchPattern();\n        for (String command : server.getConnectCommands()) {\n            parser.parse(command, server, server.getConversation(ServerInfo.DEFAULT_NAME), service);\n        }\n\n        // TODO: Detect \"You are now identified for <nick>\" notices from NickServ and handle\n        //       auto joins in onNotice instead if the user has chosen to wait for NickServ\n        //       identification before auto joining channels.\n\n        // delay 1 sec before auto joining channels\n        try {\n            Thread.sleep(1000);\n        } catch(InterruptedException e) {\n            // do nothing\n        }\n\n        // join channels\n        if (autojoinChannels != null) {\n            for (String channel : autojoinChannels) {\n                // Add support for channel keys\n                joinChannel(channel);\n            }\n        } else {\n            for (String channel : server.getAutoJoinChannels()) {\n                joinChannel(channel);\n            }\n        }\n\n        Message infoMessage = new Message(service.getString(R.string.message_login_done));\n        infoMessage.setColor(Message.COLOR_GREY);\n        server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(infoMessage);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            ServerInfo.DEFAULT_NAME\n        );\n\n        service.sendBroadcast(intent);\n    }\n    /**\n     * On channel action\n     */\n    @Override\n    protected void onAction(String sender, String login, String hostname, String target, String action)\n    {\n        Conversation conversation;\n\n        Message message = new Message(sender + \" \" + action);\n        message.setIcon(R.drawable.action);\n\n        String queryNick = target;\n        if (queryNick.equals(this.getNick())) {\n            // We are the target - this is an action in a query\n            queryNick = sender;\n        }\n        conversation = server.getConversation(queryNick);\n\n        if (conversation == null) {\n            // Open a query if there's none yet\n            conversation = new Query(queryNick);\n            conversation.setHistorySize(service.getSettings().getHistorySize());\n            server.addConversation(conversation);\n            conversation.addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_NEW,\n                server.getId(),\n                queryNick\n            );\n            service.sendBroadcast(intent);\n        } else {\n            conversation.addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                queryNick\n            );\n            service.sendBroadcast(intent);\n        }\n\n        if (sender.equals(this.getNick())) {\n            // Don't notify for something sent in our name\n            return;\n        }\n\n        boolean mentioned = isMentioned(action);\n        if (mentioned || target.equals(this.getNick()) || conversation.shouldAlwaysNotify()) {\n            if (conversation.getStatus() != Conversation.STATUS_SELECTED || !server.getIsForeground()) {\n                service.addNewMention(\n                    server.getId(),\n                    conversation,\n                    conversation.getName() + \": \" + sender + \" \" + action,\n                    service.getSettings().isVibrateHighlightEnabled(),\n                    service.getSettings().isSoundHighlightEnabled(),\n                    service.getSettings().isLedHighlightEnabled()\n                );\n            }\n        }\n\n        if (mentioned) {\n            // highlight\n            message.setColor(Message.COLOR_RED);\n            conversation.setStatus(Conversation.STATUS_HIGHLIGHT);\n        }\n    }\n\n    /**\n     * On Channel Info\n     */\n    @Override\n    protected void onChannelInfo(String channel, int userCount, String topic)\n    {\n    }\n\n    /**\n     * On Deop\n     */\n    @Override\n    protected void onDeop(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n    {\n        Message message = new Message(service.getString(R.string.message_deop, sourceNick, recipient));\n        message.setIcon(R.drawable.op);\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On DeVoice\n     */\n    @Override\n    protected void onDeVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n    {\n        Message message = new Message(service.getString(R.string.message_devoice, sourceNick, recipient));\n        message.setColor(Message.COLOR_BLUE);\n        message.setIcon(R.drawable.voice);\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On Invite\n     */\n    @Override\n    protected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String target)\n    {\n        if (targetNick.equals(this.getNick())) {\n            // We are invited\n            Message message = new Message(service.getString(R.string.message_invite_you, sourceNick, target));\n            server.getConversation(server.getSelectedConversation()).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                server.getSelectedConversation()\n            );\n            service.sendBroadcast(intent);\n        } else {\n            // Someone is invited\n            Message message = new Message(service.getString(R.string.message_invite_someone, sourceNick, targetNick, target));\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Join\n     */\n    @Override\n    protected void onJoin(String target, String sender, String login, String hostname)\n    {\n        if (sender.equalsIgnoreCase(getNick()) && server.getConversation(target) == null) {\n            // We joined a new channel\n            Conversation conversation = new Channel(target);\n            conversation.setHistorySize(service.getSettings().getHistorySize());\n            server.addConversation(conversation);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_NEW,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        } else if (service.getSettings().showJoinPartAndQuit()) {\n            Message message = new Message(\n                service.getString(R.string.message_join, sender),\n                Message.TYPE_MISC\n            );\n\n            message.setIcon(R.drawable.join);\n            message.setColor(Message.COLOR_GREEN);\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Kick\n     */\n    @Override\n    protected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n    {\n        if (recipientNick.equals(getNick())) {\n            // We are kicked\n            service.ackNewMentions(server.getId(), target);\n            server.removeConversation(target);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_REMOVE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        } else {\n            Message message = new Message(service.getString(R.string.message_kick, kickerNick, recipientNick));\n            message.setColor(Message.COLOR_GREEN);\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Message\n     */\n    @Override\n    protected void onMessage(String target, String sender, String login, String hostname, String text)\n    {\n        Message message = new Message(text, sender);\n        Conversation conversation = server.getConversation(target);\n\n        boolean isMentioned = isMentioned(text);\n\n        if (isMentioned) {\n            // highlight\n            message.setColor(Message.COLOR_RED);\n        }\n\n        if (isMentioned || conversation.shouldAlwaysNotify()) {\n            if (conversation.getStatus() != Conversation.STATUS_SELECTED || !server.getIsForeground()) {\n                service.addNewMention(\n                    server.getId(),\n                    conversation,\n                    target + \": <\" + sender + \"> \" + text,\n                    service.getSettings().isVibrateHighlightEnabled(),\n                    service.getSettings().isSoundHighlightEnabled(),\n                    service.getSettings().isLedHighlightEnabled()\n                );\n            }\n\n            conversation.setStatus(Conversation.STATUS_HIGHLIGHT);\n        }\n\n        conversation.addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On Mode\n     */\n    @Override\n    protected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n    {\n        // Disabled as it doubles events (e.g. onOp and onMode will be called)\n\n        /*\n        Message message = new Message(sourceNick + \" sets mode \" + mode);\n        server.getChannel(target).addMessage(message);\n\n        Intent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n        intent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n        intent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n        service.sendBroadcast(intent);\n         */\n    }\n\n    /**\n     * On Nick Change\n     */\n    @Override\n    protected void onNickChange(String oldNick, String login, String hostname, String newNick)\n    {\n        if (getNick().equalsIgnoreCase(newNick)) {\n            this.updateNickMatchPattern();\n\n            // Send message about own change to server info window\n            Message message = new Message(service.getString(R.string.message_self_rename, newNick));\n            message.setColor(Message.COLOR_GREEN);\n            server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                ServerInfo.DEFAULT_NAME\n            );\n\n            service.sendBroadcast(intent);\n        }\n\n        Vector<String> channels = getChannelsByNickname(newNick);\n\n        for (String target : channels) {\n            Message message = new Message(service.getString(R.string.message_rename, oldNick, newNick));\n            message.setColor(Message.COLOR_GREEN);\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Notice\n     */\n    @Override\n    protected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n    {\n        // Post notice to currently selected conversation\n        Conversation conversation;\n\n        if (service.getSettings().showNoticeInServerWindow()) {\n            conversation = server.getConversation(ServerInfo.DEFAULT_NAME);\n        } else {\n            conversation = server.getConversation(server.getSelectedConversation());\n\n            if (conversation == null) {\n                // Fallback: Use ServerInfo view\n                conversation = server.getConversation(ServerInfo.DEFAULT_NAME);\n            }\n        }\n\n        Message message = new Message(\"-\" + sourceNick + \"- \" + notice);\n        message.setIcon(R.drawable.info);\n        conversation.addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            conversation.getName()\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On Op\n     */\n    @Override\n    protected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n    {\n        Message message = new Message(service.getString(R.string.message_op, sourceNick, recipient));\n        message.setColor(Message.COLOR_BLUE);\n        message.setIcon(R.drawable.op);\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On Part\n     */\n    @Override\n    protected void onPart(String target, String sender, String login, String hostname)\n    {\n        if (sender.equals(getNick())) {\n            // We parted a channel\n            service.ackNewMentions(server.getId(), target);\n            server.removeConversation(target);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_REMOVE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        } else if (service.getSettings().showJoinPartAndQuit()) {\n            Message message = new Message(\n                service.getString(R.string.message_part, sender),\n                Message.TYPE_MISC\n            );\n\n            message.setColor(Message.COLOR_GREEN);\n            message.setIcon(R.drawable.part);\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Private Message\n     */\n    @Override\n    protected void onPrivateMessage(String sender, String login, String hostname, String target, String text)\n    {\n        Message message = new Message(\"<\" + sender + \"> \" + text);\n        String queryNick = sender;\n\n        if (queryNick.equals(this.getNick())) {\n            queryNick = target;\n        }\n        Conversation conversation = server.getConversation(queryNick);\n\n        if (conversation == null) {\n            // Open a query if there's none yet\n            conversation = new Query(queryNick);\n            conversation.setHistorySize(service.getSettings().getHistorySize());\n            conversation.addMessage(message);\n            server.addConversation(conversation);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_NEW,\n                server.getId(),\n                queryNick\n            );\n            service.sendBroadcast(intent);\n        } else {\n            conversation.addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                queryNick\n            );\n            service.sendBroadcast(intent);\n        }\n\n        if (sender.equals(this.getNick())) {\n            // Don't notify for something sent in our name\n            return;\n        }\n\n        if (conversation.getStatus() != Conversation.STATUS_SELECTED || !server.getIsForeground()) {\n            service.addNewMention(\n                server.getId(),\n                conversation,\n                \"<\" + sender + \"> \" + text,\n                service.getSettings().isVibrateHighlightEnabled(),\n                service.getSettings().isSoundHighlightEnabled(),\n                service.getSettings().isLedHighlightEnabled()\n            );\n        }\n\n        if (isMentioned(text)) {\n            message.setColor(Message.COLOR_RED);\n            conversation.setStatus(Conversation.STATUS_HIGHLIGHT);\n        }\n    }\n\n    /**\n     * On Quit\n     */\n    @Override\n    protected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n    {\n        if (sourceNick.equals(this.getNick())) {\n            return;\n        }\n\n        if (service.getSettings().showJoinPartAndQuit()) {\n            Vector<String> channels = getChannelsByNickname(sourceNick);\n\n            for (String target : channels) {\n                Message message = new Message(\n                    service.getString(R.string.message_quit, sourceNick, reason),\n                    Message.TYPE_MISC\n                );\n\n                message.setColor(Message.COLOR_GREEN);\n                message.setIcon(R.drawable.quit);\n                server.getConversation(target).addMessage(message);\n\n                Intent intent = Broadcast.createConversationIntent(\n                    Broadcast.CONVERSATION_MESSAGE,\n                    server.getId(),\n                    target\n                );\n                service.sendBroadcast(intent);\n            }\n\n            // Look if there's a query to update\n            Conversation conversation = server.getConversation(sourceNick);\n\n            if (conversation != null) {\n                Message message = new Message(\n                    service.getString(R.string.message_quit, sourceNick, reason),\n                    Message.TYPE_MISC\n                );\n\n                message.setColor(Message.COLOR_GREEN);\n                message.setIcon(R.drawable.quit);\n                conversation.addMessage(message);\n\n                Intent intent = Broadcast.createConversationIntent(\n                    Broadcast.CONVERSATION_MESSAGE,\n                    server.getId(),\n                    conversation.getName()\n                );\n                service.sendBroadcast(intent);\n            }\n        }\n    }\n\n    /**\n     * On Topic\n     */\n    @Override\n    public void onTopic(String target, String topic, String setBy, long date, boolean changed)\n    {\n        if (changed) {\n            Message message = new Message(service.getString(R.string.message_topic_set, setBy, topic));\n            message.setColor(Message.COLOR_YELLOW);\n            server.getConversation(target).addMessage(message);\n        } else {\n            Message message = new Message(service.getString(R.string.message_topic, topic));\n            message.setColor(Message.COLOR_YELLOW);\n            server.getConversation(target).addMessage(message);\n        }\n\n        // remember channel's topic\n        ((Channel) server.getConversation(target)).setTopic(topic);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n\n        // update the displayed conversation title if necessary\n        intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_TOPIC,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On User List\n     */\n    @Override\n    protected void onUserList(String channel, User[] users)\n    {\n        // XXX: Store user list somewhere and keep it updated or just broadcast some event?\n    }\n\n    /**\n     * On Voice\n     */\n    @Override\n    protected void onVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n    {\n        Message message = new Message(service.getString(R.string.message_voice, sourceNick, recipient));\n        message.setIcon(R.drawable.voice);\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On remove channel key\n     */\n    @Override\n    protected void onRemoveChannelKey(String target, String sourceNick, String sourceLogin, String sourceHostname, String key)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_channel_key, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set channel key\n     */\n    @Override\n    protected void onSetChannelKey(String target, String sourceNick, String sourceLogin, String sourceHostname, String key)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_key, sourceNick, key));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set secret\n     */\n    @Override\n    protected void onSetSecret(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_secret, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove secret\n     */\n    @Override\n    protected void onRemoveSecret(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_public, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set channel limit\n     */\n    @Override\n    protected void onSetChannelLimit(String target, String sourceNick, String sourceLogin, String sourceHostname, int limit)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_limit, sourceNick, limit));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove channel limit\n     */\n    @Override\n    protected void onRemoveChannelLimit(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_channel_limit, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set channel ban\n     */\n    @Override\n    protected void onSetChannelBan(String target, String sourceNick, String sourceLogin, String sourceHostname, String hostmask)\n    {\n        Message message = new Message(service.getString(R.string.message_set_ban, sourceNick, hostmask));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove channel ban\n     */\n    @Override\n    protected void onRemoveChannelBan(String target, String sourceNick, String sourceLogin, String sourceHostname, String hostmask)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_ban, sourceNick, hostmask));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set topic protection\n     */\n    @Override\n    protected void onSetTopicProtection(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_topic_protection, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove topic protection\n     */\n    @Override\n    protected void onRemoveTopicProtection(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_topic_protection, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set no external messages\n     */\n    @Override\n    protected void onSetNoExternalMessages(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_disable_external, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove no external messages\n     */\n    @Override\n    protected void onRemoveNoExternalMessages(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_enable_external, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set invite only\n     */\n    @Override\n    protected void onSetInviteOnly(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_invite_only, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove invite only\n     */\n    @Override\n    protected void onRemoveInviteOnly(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_invite_only, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set moderated\n     */\n    @Override\n    protected void onSetModerated(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_moderated, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove moderated\n     */\n    @Override\n    protected void onRemoveModerated(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_moderated, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set private\n     */\n    @Override\n    protected void onSetPrivate(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_private, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove private\n     */\n    @Override\n    protected void onRemovePrivate(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_public, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On unknown\n     */\n    @Override\n    protected void onUnknown(String line)\n    {\n        Message message = new Message(line);\n        message.setIcon(R.drawable.action);\n        message.setColor(Message.COLOR_GREY);\n        server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            ServerInfo.DEFAULT_NAME\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On server response\n     */\n    @Override\n    protected void onServerResponse(int code, String response)\n    {\n        if (code == 4) {\n            // User has registered with the server\n            onRegister();\n            return;\n        }\n        if ((code == 372 || code == 375) && ignoreMOTD) {\n            return;\n        }\n        if (code == 376 && ignoreMOTD) {\n            Message motdMessage = new Message(service.getString(R.string.message_motd_suppressed));\n            motdMessage.setColor(Message.COLOR_GREY);\n            server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(motdMessage);\n            ignoreMOTD = false;\n            return;\n        }\n\n        if (code >= 200 && code < 300) {\n            // Skip 2XX responses\n            return;\n        }\n\n        if (code == 353 || code == 366 || code == 332 || code == 333) {\n            return;\n        }\n\n        if (code < 10) {\n            // Skip server info\n            return;\n        }\n\n        // Currently disabled... to much text\n        Message message = new Message(response);\n        message.setColor(Message.COLOR_GREY);\n        server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            ServerInfo.DEFAULT_NAME\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On disconnect\n     */\n    @Override\n    public void onDisconnect()\n    {\n        // Call parent method to ensure \"register\" status is tracked\n        super.onDisconnect();\n\n        if (service.getSettings().isReconnectEnabled() && server.getStatus() != Status.DISCONNECTED) {\n            setAutojoinChannels(server.getCurrentChannelNames());\n\n            server.setStatus(Status.CONNECTING);\n            service.connect(server);\n        } else {\n            server.setStatus(Status.DISCONNECTED);\n        }\n\n        service.notifyDisconnected(server.getTitle());\n\n        Intent sIntent = Broadcast.createServerIntent(Broadcast.SERVER_UPDATE, server.getId());\n        service.sendBroadcast(sIntent);\n\n        Collection<Conversation> conversations = server.getConversations();\n\n        for (Conversation conversation : conversations) {\n            Message message = new Message(service.getString(R.string.message_disconnected));\n            message.setIcon(R.drawable.error);\n            message.setColor(Message.COLOR_RED);\n            server.getConversation(conversation.getName()).addMessage(message);\n\n            Intent cIntent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                conversation.getName()\n            );\n            service.sendBroadcast(cIntent);\n        }\n\n        synchronized(isQuittingLock) {\n            isQuitting = false;\n            if (disposeRequested) {\n                super.dispose();\n            }\n        }\n    }\n\n    /**\n     * Get all channels where the user with the given nickname is online\n     *\n     * @param nickname\n     * @return Array of channel names\n     */\n    private Vector<String> getChannelsByNickname(String nickname)\n    {\n        Vector<String> channels = new Vector<String>();\n        String[] channelArray = getChannels();\n\n        for (String channel : channelArray) {\n            User[] userArray = getUsers(channel);\n            for (User user : userArray) {\n                if (user.getNick().equals(nickname)) {\n                    channels.add(channel);\n                    break;\n                }\n            }\n        }\n\n        return channels;\n    }\n\n    /**\n     * Get list of users in a channel as array of strings\n     *\n     * @param channel Name of the channel\n     */\n    public String[] getUsersAsStringArray(String channel)\n    {\n        User[] userArray = getUsers(channel);\n        int mLength = userArray.length;\n        String[] users = new String[mLength];\n\n        for (int i = 0; i < mLength; i++) {\n            users[i] = userArray[i].getPrefix() + userArray[i].getNick();\n        }\n\n        return users;\n    }\n\n    /**\n     * Get a user by channel and nickname\n     *\n     * @param channel The channel the user is in\n     * @param nickname The nickname of the user (with or without prefix)\n     * @return the User object or null if user was not found\n     */\n    public User getUser(String channel, String nickname)\n    {\n        User[] users = getUsers(channel);\n        int mLength = users.length;\n\n        for (int i = 0; i < mLength; i++) {\n            if (nickname.equals(users[i].getNick())) {\n                return users[i];\n            }\n            if (nickname.equals(users[i].getPrefix() + users[i].getNick())) {\n                return users[i];\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Quits from the IRC server with default reason.\n     */\n    @Override\n    public void quitServer()\n    {\n        quitServer(service.getSettings().getQuitMessage());\n    }\n\n    @Override\n    public void quitServer(final String message)\n    {\n        synchronized(isQuittingLock) {\n            isQuitting = true;\n        }\n\n        new Thread() {\n            @Override\n            public void run() {\n                superClassQuitServer(message);\n            }\n        }.start();\n    }\n\n    private final void superClassQuitServer(String message)\n    {\n        super.quitServer(message);\n    }\n\n    /**\n     * Check whether the nickname has been mentioned.\n     *\n     * @param text The text to check for the nickname\n     * @return true if nickname was found, otherwise false\n     */\n    public boolean isMentioned(String text)\n    {\n        return mNickMatch.matcher(text).find();\n    }\n\n    /**\n     * Update the nick matching pattern, should be called when the nickname changes.\n     */\n    private void updateNickMatchPattern()\n    {\n        mNickMatch = Pattern.compile(\"(?:^|[\\\\s?!'�:;,.])\"+Pattern.quote(getNick())+\"(?:[\\\\s?!'�:;,.]|$)\", Pattern.CASE_INSENSITIVE);\n    }\n\n    @Override\n    public void dispose()\n    {\n        synchronized(isQuittingLock) {\n            if (isQuitting) {\n                disposeRequested = true;\n            } else {\n                super.dispose();\n            }\n        }\n    }\n}\n","lineNo":475}
{"Smelly Sample":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2015 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.activity;\n\nimport android.content.ComponentName;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.os.Bundle;\nimport android.os.IBinder;\nimport android.support.v4.app.Fragment;\nimport android.support.v4.content.ContextCompat;\nimport android.support.v4.widget.DrawerLayout;\nimport android.support.v7.app.ActionBarDrawerToggle;\nimport android.support.v7.app.AppCompatActivity;\nimport android.support.v7.widget.Toolbar;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.widget.LinearLayout;\nimport android.widget.TextView;\n\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.fragment.ConversationFragment;\nimport org.yaaic.fragment.OverviewFragment;\nimport org.yaaic.fragment.SettingsFragment;\nimport org.yaaic.irc.IRCBinder;\nimport org.yaaic.irc.IRCService;\nimport org.yaaic.listener.ServerListener;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Extra;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.Status;\nimport org.yaaic.receiver.ServerReceiver;\n\nimport java.util.List;\n\n/**\n * The main activity of Yaaic. We'll add, remove and replace fragments here.\n */\npublic class MainActivity extends AppCompatActivity implements YaaicActivity, ServiceConnection, ServerListener {\n    private ActionBarDrawerToggle toggle;\n    private Toolbar toolbar;\n    private DrawerLayout drawer;\n    private IRCBinder binder;\n    private ServerReceiver receiver;\n    private LinearLayout serverContainer;\n    private View drawerEmptyView;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        setContentView(R.layout.activity_main);\n\n        initializeToolbar();\n        initializeDrawer();\n\n        if (savedInstanceState == null) {\n            onOverview(null);\n        }\n    }\n\n    public void initializeToolbar() {\n        toolbar = (Toolbar) findViewById(R.id.toolbar);\n        setSupportActionBar(toolbar);\n    }\n\n    public void initializeDrawer() {\n        drawer = (DrawerLayout) findViewById(R.id.drawer);\n        toggle = new ActionBarDrawerToggle(this, drawer, toolbar, 0, 0);\n\n        drawer.setDrawerListener(toggle);\n\n        serverContainer = (LinearLayout) findViewById(R.id.server_container);\n\n        drawerEmptyView = findViewById(R.id.drawer_empty_servers);\n        drawerEmptyView.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                Intent intent = new Intent(MainActivity.this, AddServerActivity.class);\n                startActivity(intent);\n\n                drawer.closeDrawers();\n            }\n        });\n    }\n\n    public void updateDrawerServerList() {\n        List<Server> servers = Yaaic.getInstance().getServers();\n        drawerEmptyView.setVisibility(servers.size() > 0 ? View.GONE : View.VISIBLE);\n\n        serverContainer.removeAllViews();\n\n        for (final Server server : servers) {\n            TextView serverView = (TextView) getLayoutInflater().inflate(R.layout.item_drawer_server, drawer, false);\n            serverView.setText(server.getTitle());\n\n            serverView.setCompoundDrawablesWithIntrinsicBounds(\n                    getDrawable(server.isConnected()\n                        ? R.drawable.ic_navigation_server_connected\n                        : R.drawable.ic_navigation_server_disconnected),\n                    null,\n                    null,\n                    null\n            );\n\n            int colorResource = server.isConnected() ? R.color.connected : R.color.disconnected;\n            serverView.setTextColor(ContextCompat.getColor(this, colorResource));\n\n            serverView.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View v) {\n                    onServerSelected(server);\n\n                    drawer.closeDrawers();\n                }\n            });\n\n            serverContainer.addView(serverView, 0);\n        }\n    }\n\n    @Override\n    protected void onPostCreate(Bundle savedInstanceState) {\n        super.onPostCreate(savedInstanceState);\n\n        toggle.syncState();\n    }\n\n    @Override\n    protected void onResume() {\n        super.onResume();\n\n        receiver = new ServerReceiver(this);\n        registerReceiver(receiver, new IntentFilter(Broadcast.SERVER_UPDATE));\n\n        Intent intent = new Intent(this, IRCService.class);\n        intent.setAction(IRCService.ACTION_BACKGROUND);\n        startService(intent);\n\n        bindService(intent, this, 0);\n\n        updateDrawerServerList();\n    }\n\n    @Override\n    protected void onPause() {\n        super.onPause();\n\n        unregisterReceiver(receiver);\n\n        if (binder != null && binder.getService() != null) {\n            binder.getService().checkServiceStatus();\n        }\n\n        unbindService(this);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        if (toggle.onOptionsItemSelected(item)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    @Override\n    public void onServerSelected(Server server) {\n        Bundle arguments = new Bundle();\n\n        if (server.getStatus() == Status.DISCONNECTED && !server.mayReconnect()) {\n            server.setStatus(Status.PRE_CONNECTING);\n\n            arguments.putBoolean(Extra.CONNECT, true);\n        }\n\n        arguments.putInt(Extra.SERVER_ID, server.getId());\n\n        ConversationFragment fragment = new ConversationFragment();\n        fragment.setArguments(arguments);\n\n        switchToFragment(fragment, ConversationFragment.TRANSACTION_TAG);\n    }\n\n    public void onOverview(View view) {\n        switchToFragment(new OverviewFragment(), OverviewFragment.TRANSACTION_TAG);\n    }\n\n    public void onSettings(View view) {\n        switchToFragment(new SettingsFragment(), SettingsFragment.TRANSACTION_TAG);\n    }\n\n    private void switchToFragment(Fragment fragment, String tag) {\n        drawer.closeDrawers();\n\n        getSupportFragmentManager()\n                .beginTransaction()\n                .setCustomAnimations(R.anim.slide_in_left, R.anim.slide_out_left)\n                .replace(R.id.container, fragment, tag)\n                .commit();\n    }\n\n    public void onAbout(View view) {\n        drawer.closeDrawers();\n        startActivity(new Intent(this, AboutActivity.class));\n    }\n\n    @Override\n    public IRCBinder getBinder() {\n        return binder;\n    }\n\n    @Override\n    public Toolbar getToolbar() {\n        return toolbar;\n    }\n\n    @Override\n    public void setToolbarTitle(String title) {\n        if (toolbar != null) {\n            toolbar.setTitle(title);\n        }\n    }\n\n    @Override\n    public void onServiceConnected(ComponentName name, IBinder service) {\n        binder = (IRCBinder) service;\n    }\n\n    @Override\n    public void onServiceDisconnected(ComponentName name) {\n        binder = null;\n    }\n\n    @Override\n    public void onStatusUpdate() {\n        updateDrawerServerList();\n    }\n}\n","Method after Refactoring":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2015 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.activity;\n\nimport android.content.ComponentName;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.os.Bundle;\nimport android.os.IBinder;\nimport android.support.v4.app.Fragment;\nimport android.support.v4.app.FragmentManager;\nimport android.support.v4.content.ContextCompat;\nimport android.support.v4.widget.DrawerLayout;\nimport android.support.v7.app.ActionBarDrawerToggle;\nimport android.support.v7.app.AppCompatActivity;\nimport android.support.v7.widget.Toolbar;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.widget.LinearLayout;\nimport android.widget.TextView;\n\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.fragment.ConversationFragment;\nimport org.yaaic.fragment.OverviewFragment;\nimport org.yaaic.fragment.SettingsFragment;\nimport org.yaaic.irc.IRCBinder;\nimport org.yaaic.irc.IRCService;\nimport org.yaaic.listener.ServerListener;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Extra;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.Status;\nimport org.yaaic.receiver.ServerReceiver;\n\nimport java.util.List;\n\n/**\n * The main activity of Yaaic. We'll add, remove and replace fragments here.\n */\npublic class MainActivity extends AppCompatActivity implements YaaicActivity, ServiceConnection, ServerListener {\n    private ActionBarDrawerToggle toggle;\n    private Toolbar toolbar;\n    private DrawerLayout drawer;\n    private IRCBinder binder;\n    private ServerReceiver receiver;\n    private LinearLayout serverContainer;\n    private View drawerEmptyView;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        setContentView(R.layout.activity_main);\n\n        initializeToolbar();\n        initializeDrawer();\n\n        if (savedInstanceState == null) {\n            onOverview(null);\n        }\n    }\n\n    public void initializeToolbar() {\n        toolbar = (Toolbar) findViewById(R.id.toolbar);\n        setSupportActionBar(toolbar);\n    }\n\n    public void initializeDrawer() {\n        drawer = (DrawerLayout) findViewById(R.id.drawer);\n        toggle = new ActionBarDrawerToggle(this, drawer, toolbar, 0, 0);\n\n        drawer.setDrawerListener(toggle);\n\n        serverContainer = (LinearLayout) findViewById(R.id.server_container);\n\n        drawerEmptyView = findViewById(R.id.drawer_empty_servers);\n        drawerEmptyView.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                Intent intent = new Intent(MainActivity.this, AddServerActivity.class);\n                startActivity(intent);\n\n                drawer.closeDrawers();\n            }\n        });\n    }\n\n    public void updateDrawerServerList() {\n        List<Server> servers = Yaaic.getInstance().getServers();\n        drawerEmptyView.setVisibility(servers.size() > 0 ? View.GONE : View.VISIBLE);\n\n        serverContainer.removeAllViews();\n\n        for (final Server server : servers) {\n            TextView serverView = (TextView) getLayoutInflater().inflate(R.layout.item_drawer_server, drawer, false);\n            serverView.setText(server.getTitle());\n\n            serverView.setCompoundDrawablesWithIntrinsicBounds(\n                    getDrawable(server.isConnected()\n                        ? R.drawable.ic_navigation_server_connected\n                        : R.drawable.ic_navigation_server_disconnected),\n                    null,\n                    null,\n                    null\n            );\n\n            int colorResource = server.isConnected() ? R.color.connected : R.color.disconnected;\n            serverView.setTextColor(ContextCompat.getColor(this, colorResource));\n\n            serverView.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View v) {\n                    onServerSelected(server);\n\n                    drawer.closeDrawers();\n                }\n            });\n\n            serverContainer.addView(serverView, 0);\n        }\n    }\n\n    @Override\n    protected void onPostCreate(Bundle savedInstanceState) {\n        super.onPostCreate(savedInstanceState);\n\n        toggle.syncState();\n    }\n\n    @Override\n    protected void onResume() {\n        super.onResume();\n\n        receiver = new ServerReceiver(this);\n        registerReceiver(receiver, new IntentFilter(Broadcast.SERVER_UPDATE));\n\n        Intent intent = new Intent(this, IRCService.class);\n        intent.setAction(IRCService.ACTION_BACKGROUND);\n        startService(intent);\n\n        bindService(intent, this, 0);\n\n        updateDrawerServerList();\n    }\n\n    @Override\n    protected void onPause() {\n        super.onPause();\n\n        unregisterReceiver(receiver);\n\n        if (binder != null && binder.getService() != null) {\n            binder.getService().checkServiceStatus();\n        }\n\n        unbindService(this);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        if (toggle.onOptionsItemSelected(item)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    @Override\n    public void onServerSelected(Server server) {\n        Bundle arguments = new Bundle();\n\n        if (server.getStatus() == Status.DISCONNECTED && !server.mayReconnect()) {\n            server.setStatus(Status.PRE_CONNECTING);\n\n            arguments.putBoolean(Extra.CONNECT, true);\n        }\n\n        arguments.putInt(Extra.SERVER_ID, server.getId());\n\n        ConversationFragment fragment = new ConversationFragment();\n        fragment.setArguments(arguments);\n\n        switchToFragment(fragment, ConversationFragment.TRANSACTION_TAG + \"-\" + server.getId());\n    }\n\n    public void onOverview(View view) {\n        switchToFragment(new OverviewFragment(), OverviewFragment.TRANSACTION_TAG);\n    }\n\n    public void onSettings(View view) {\n        switchToFragment(new SettingsFragment(), SettingsFragment.TRANSACTION_TAG);\n    }\n\n    private void switchToFragment(Fragment fragment, String tag) {\n        drawer.closeDrawers();\n\n        FragmentManager fragmentManager = getSupportFragmentManager();\n\n        if (fragmentManager.findFragmentByTag(tag) != null) {\n            // We are already showing this fragment\n            return;\n        }\n\n        fragmentManager\n                .beginTransaction()\n                .setCustomAnimations(R.anim.slide_in_left, R.anim.slide_out_left)\n                .replace(R.id.container, fragment, tag)\n                .commit();\n    }\n\n    public void onAbout(View view) {\n        drawer.closeDrawers();\n        startActivity(new Intent(this, AboutActivity.class));\n    }\n\n    @Override\n    public IRCBinder getBinder() {\n        return binder;\n    }\n\n    @Override\n    public Toolbar getToolbar() {\n        return toolbar;\n    }\n\n    @Override\n    public void setToolbarTitle(String title) {\n        if (toolbar != null) {\n            toolbar.setTitle(title);\n        }\n    }\n\n    @Override\n    public void onServiceConnected(ComponentName name, IBinder service) {\n        binder = (IRCBinder) service;\n    }\n\n    @Override\n    public void onServiceDisconnected(ComponentName name) {\n        binder = null;\n    }\n\n    @Override\n    public void onStatusUpdate() {\n        updateDrawerServerList();\n    }\n}\n","lineNo":217}
{"Smelly Sample":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2013 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage org.yaaic.model;\n\nimport java.util.Date;\n\nimport org.yaaic.utils.MircColors;\nimport org.yaaic.utils.Smilies;\n\nimport android.annotation.TargetApi;\nimport android.content.Context;\nimport android.graphics.Typeface;\nimport android.graphics.drawable.Drawable;\nimport android.os.Build;\nimport android.text.Spannable;\nimport android.text.SpannableString;\nimport android.text.TextUtils;\nimport android.text.style.ForegroundColorSpan;\nimport android.text.style.ImageSpan;\nimport android.text.util.Linkify;\nimport android.view.View;\nimport android.widget.TextView;\n\n/**\n * A channel or server message\n *\n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class Message\n{\n    public static final int COLOR_GREEN   = 0xFF4caf50;\n    public static final int COLOR_RED     = 0xFFf44336;\n    public static final int COLOR_BLUE    = 0xFF3f51b5;\n    public static final int COLOR_YELLOW  = 0xFFffc107;\n    public static final int COLOR_GREY    = 0xFF607d8b;\n    public static final int COLOR_DEFAULT = 0xFF212121;\n\n    /* normal message, this is the default */\n    public static final int TYPE_MESSAGE = 0;\n\n    /* join, part or quit */\n    public static final int TYPE_MISC    = 1;\n\n    /* Some are light versions because dark colors hardly readable on\n     * Yaaic's dark background */\n    private static final int[] colors = {\n            0xFFf44336, // Red\n            0xFFe91e63, // Pink\n            0xFF9c27b0, // Purple\n            0xFF673ab7, // Deep Purple\n            0xFF3f51b5, // Indigo\n            0xFF2196f3, // Blue\n            0xFF03a9f4, // Light Blue\n            0xFF00bcd4, // Cyan\n            0xFF009688, // Teal\n            0xFF4caf50, // Green\n            0xFF8bc34a, // Light green\n            0xFFcddc39, // Lime\n            0xFFffeb3b, // Yellow\n            0xFFffc107, // Amber\n            0xFFff9800, // Orange\n            0xFFff5722, // Deep Orange\n            0xFF795548, // Brown\n    };\n\n    public static final int NO_ICON  = -1;\n    public static final int NO_TYPE  = -1;\n    public static final int NO_COLOR = -1;\n\n    private final String text;\n    private final String sender;\n    private SpannableString canvas;\n    private long timestamp;\n\n    private int color = NO_COLOR;\n    private int type  = NO_ICON;\n    private int icon  = NO_TYPE;\n\n    /**\n     * Create a new message without an icon defaulting to TYPE_MESSAGE\n     *\n     * @param text\n     */\n    public Message(String text)\n    {\n        this(text, null, TYPE_MESSAGE);\n    }\n\n    /**\n     * Create a new message without an icon with a specific type\n     *\n     * @param text\n     * @param type Message type\n     */\n    public Message(String text, int type)\n    {\n        this(text, null, type);\n    }\n\n    /**\n     * Create a new message sent by a user, without an icon,\n     * defaulting to TYPE_MESSAGE\n     *\n     * @param text\n     * @param sender\n     */\n    public Message(String text, String sender)\n    {\n        this(text, sender, TYPE_MESSAGE);\n    }\n\n    /**\n     * Create a new message sent by a user without an icon\n     *\n     * @param text\n     * @param sender\n     * @param type Message type\n     */\n    public Message(String text, String sender, int type)\n    {\n        this.text = text;\n        this.sender = sender;\n        this.timestamp = new Date().getTime();\n        this.type = type;\n    }\n\n    /**\n     * Set the message's icon\n     */\n    public void setIcon(int icon)\n    {\n        this.icon = icon;\n    }\n\n    /**\n     * Get the message's icon\n     *\n     * @return\n     */\n    public int getIcon()\n    {\n        return icon;\n    }\n\n    /**\n     * Get the text of this message\n     *\n     * @return\n     */\n    public String getText()\n    {\n        return text;\n    }\n\n    /**\n     * Get the type of this message\n     *\n     * @return One of Message.TYPE_*\n     */\n    public int getType()\n    {\n        return type;\n    }\n\n    /**\n     * Set the color of this message\n     */\n    public void setColor(int color)\n    {\n        this.color = color;\n    }\n\n    /**\n     * Set the timestamp of the message\n     *\n     * @param timestamp\n     */\n    public void setTimestamp(long timestamp)\n    {\n        this.timestamp = timestamp;\n    }\n\n    /**\n     * Associate a color with a sender name\n     *\n     * @return a color hexa\n     */\n    private int getSenderColor()\n    {\n        /* It might be worth to use some hash table here */\n        if (sender == null) {\n            return COLOR_DEFAULT;\n        }\n\n        int color = 0;\n\n        for(int i = 0; i < sender.length(); i++){\n            color += sender.charAt(i);\n        }\n\n        /* we dont want color[colors.length-1] which is black */\n        color = color % (colors.length - 1);\n\n        return colors[color];\n    }\n\n    /**\n     * Render message as spannable string\n     *\n     * @return\n     */\n    public SpannableString render(Context context)\n    {\n        Settings settings = new Settings(context);\n\n        if (canvas == null) {\n            String prefix    = hasIcon() && settings.showIcons() ? \"  \" : \"\";\n            String nick      = hasSender() ? \"<\" + sender + \"> \" : \"\";\n            String timestamp = settings.showTimestamp() ? renderTimeStamp(settings.use24hFormat(), settings.includeSeconds()) : \"\";\n\n            canvas = new SpannableString(prefix + timestamp + nick);\n            SpannableString renderedText;\n\n            if (settings.showMircColors()) {\n                renderedText = MircColors.toSpannable(text);\n            } else {\n                renderedText = new SpannableString(\n                    MircColors.removeStyleAndColors(text)\n                );\n            }\n\n            if (settings.showGraphicalSmilies()) {\n                renderedText = Smilies.toSpannable(renderedText, context);\n            }\n\n            canvas = new SpannableString(TextUtils.concat(canvas, renderedText));\n\n            if (hasSender()) {\n                int start = (prefix + timestamp).length() + 1;\n                int end = start + sender.length();\n\n                if (settings.showColorsNick()) {\n                    canvas.setSpan(new ForegroundColorSpan(getSenderColor()), start, end , Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n                }\n            }\n\n            if (hasIcon() && settings.showIcons()) {\n                Drawable drawable = context.getResources().getDrawable(icon);\n                drawable.setBounds(0, 0, drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight());\n                canvas.setSpan(new ImageSpan(drawable, ImageSpan.ALIGN_BOTTOM), 0, 1, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n            }\n\n            if (hasColor() && settings.showColors()) {\n                // Only apply the foreground color to areas that don't already have a foreground color.\n                ForegroundColorSpan[] spans = canvas.getSpans(0, canvas.length(), ForegroundColorSpan.class);\n                int start = 0;\n\n                for (int i = 0; i < spans.length; i++) {\n                    canvas.setSpan(new ForegroundColorSpan(color), start, canvas.getSpanStart(spans[i]), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n                    start = canvas.getSpanEnd(spans[i]);\n                }\n\n                canvas.setSpan(new ForegroundColorSpan(color), start, canvas.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n            }\n        }\n\n        return canvas;\n    }\n\n    /**\n     * Does this message have a sender?\n     *\n     * @return\n     */\n    private boolean hasSender()\n    {\n        return sender != null;\n    }\n\n    /**\n     * Does this message have a color assigned?\n     *\n     * @return\n     */\n    private boolean hasColor()\n    {\n        return color != NO_COLOR;\n    }\n\n    /**\n     * Does this message have an icon assigned?\n     *\n     * @return\n     */\n    private boolean hasIcon()\n    {\n        return icon != NO_ICON;\n    }\n\n    /**\n     * Render message as text view\n     *\n     * @param context\n     * @return\n     */\n    public TextView renderTextView(Context context, TextView view)\n    {\n        if (view == null) {\n            view = new TextView(context);\n        }\n\n        view.setAutoLinkMask(Linkify.ALL);\n        view.setLinksClickable(true);\n        view.setLinkTextColor(COLOR_BLUE);\n        view.setText(this.render(context));\n        view.setTextIsSelectable(true);\n\n        return view;\n    }\n\n    /**\n     * Generate a timestamp\n     *\n     * @param use24hFormat\n     * @return\n     */\n    public String renderTimeStamp(boolean use24hFormat, boolean includeSeconds)\n    {\n        Date date = new Date(timestamp);\n\n        int hours = date.getHours();\n        int minutes = date.getMinutes();\n        int seconds = date.getSeconds();\n\n        if (!use24hFormat) {\n            hours = Math.abs(12 - hours);\n            if (hours == 12) {\n                hours = 0;\n            }\n        }\n\n        if (includeSeconds) {\n            return String.format(\n                \"[%02d:%02d:%02d]\",\n                hours,\n                minutes,\n                seconds);\n        } else {\n            return String.format(\n                \"[%02d:%02d]\",\n                hours,\n                minutes);\n        }\n    }\n}\n","Method after Refactoring":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2013 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage org.yaaic.model;\n\nimport android.content.Context;\nimport android.graphics.drawable.Drawable;\nimport android.text.Spannable;\nimport android.text.SpannableString;\nimport android.text.TextUtils;\nimport android.text.style.ForegroundColorSpan;\nimport android.text.style.ImageSpan;\nimport android.text.util.Linkify;\nimport android.widget.TextView;\n\nimport org.yaaic.utils.Emojis;\nimport org.yaaic.utils.MircColors;\n\nimport java.util.Date;\n\n/**\n * A channel or server message\n *\n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class Message\n{\n    public static final int COLOR_GREEN   = 0xFF4caf50;\n    public static final int COLOR_RED     = 0xFFf44336;\n    public static final int COLOR_BLUE    = 0xFF3f51b5;\n    public static final int COLOR_YELLOW  = 0xFFffc107;\n    public static final int COLOR_GREY    = 0xFF607d8b;\n    public static final int COLOR_DEFAULT = 0xFF212121;\n\n    /* normal message, this is the default */\n    public static final int TYPE_MESSAGE = 0;\n\n    /* join, part or quit */\n    public static final int TYPE_MISC    = 1;\n\n    /* Some are light versions because dark colors hardly readable on\n     * Yaaic's dark background */\n    private static final int[] colors = {\n            0xFFf44336, // Red\n            0xFFe91e63, // Pink\n            0xFF9c27b0, // Purple\n            0xFF673ab7, // Deep Purple\n            0xFF3f51b5, // Indigo\n            0xFF2196f3, // Blue\n            0xFF03a9f4, // Light Blue\n            0xFF00bcd4, // Cyan\n            0xFF009688, // Teal\n            0xFF4caf50, // Green\n            0xFF8bc34a, // Light green\n            0xFFcddc39, // Lime\n            0xFFffeb3b, // Yellow\n            0xFFffc107, // Amber\n            0xFFff9800, // Orange\n            0xFFff5722, // Deep Orange\n            0xFF795548, // Brown\n    };\n\n    public static final int NO_ICON  = -1;\n    public static final int NO_TYPE  = -1;\n    public static final int NO_COLOR = -1;\n\n    private final String text;\n    private final String sender;\n    private SpannableString canvas;\n    private long timestamp;\n\n    private int color = NO_COLOR;\n    private int type  = NO_ICON;\n    private int icon  = NO_TYPE;\n\n    /**\n     * Create a new message without an icon defaulting to TYPE_MESSAGE\n     *\n     * @param text\n     */\n    public Message(String text)\n    {\n        this(text, null, TYPE_MESSAGE);\n    }\n\n    /**\n     * Create a new message without an icon with a specific type\n     *\n     * @param text\n     * @param type Message type\n     */\n    public Message(String text, int type)\n    {\n        this(text, null, type);\n    }\n\n    /**\n     * Create a new message sent by a user, without an icon,\n     * defaulting to TYPE_MESSAGE\n     *\n     * @param text\n     * @param sender\n     */\n    public Message(String text, String sender)\n    {\n        this(text, sender, TYPE_MESSAGE);\n    }\n\n    /**\n     * Create a new message sent by a user without an icon\n     *\n     * @param text\n     * @param sender\n     * @param type Message type\n     */\n    public Message(String text, String sender, int type)\n    {\n        this.text = text;\n        this.sender = sender;\n        this.timestamp = new Date().getTime();\n        this.type = type;\n    }\n\n    /**\n     * Set the message's icon\n     */\n    public void setIcon(int icon)\n    {\n        this.icon = icon;\n    }\n\n    /**\n     * Get the message's icon\n     *\n     * @return\n     */\n    public int getIcon()\n    {\n        return icon;\n    }\n\n    /**\n     * Get the text of this message\n     *\n     * @return\n     */\n    public String getText()\n    {\n        return text;\n    }\n\n    /**\n     * Get the type of this message\n     *\n     * @return One of Message.TYPE_*\n     */\n    public int getType()\n    {\n        return type;\n    }\n\n    /**\n     * Set the color of this message\n     */\n    public void setColor(int color)\n    {\n        this.color = color;\n    }\n\n    /**\n     * Set the timestamp of the message\n     *\n     * @param timestamp\n     */\n    public void setTimestamp(long timestamp)\n    {\n        this.timestamp = timestamp;\n    }\n\n    /**\n     * Associate a color with a sender name\n     *\n     * @return a color hexa\n     */\n    private int getSenderColor()\n    {\n        /* It might be worth to use some hash table here */\n        if (sender == null) {\n            return COLOR_DEFAULT;\n        }\n\n        int color = 0;\n\n        for(int i = 0; i < sender.length(); i++){\n            color += sender.charAt(i);\n        }\n\n        /* we dont want color[colors.length-1] which is black */\n        color = color % (colors.length - 1);\n\n        return colors[color];\n    }\n\n    /**\n     * Render message as spannable string\n     *\n     * @return\n     */\n    public SpannableString render(Context context)\n    {\n        Settings settings = new Settings(context);\n\n        if (canvas == null) {\n            String prefix    = hasIcon() && settings.showIcons() ? \"  \" : \"\";\n            String nick      = hasSender() ? \"<\" + sender + \"> \" : \"\";\n            String timestamp = settings.showTimestamp() ? renderTimeStamp(settings.use24hFormat(), settings.includeSeconds()) : \"\";\n\n            canvas = new SpannableString(prefix + timestamp + nick);\n            SpannableString renderedText;\n\n            String text = settings.showGraphicalSmilies() ? Emojis.convert(this.text) : this.text;\n\n            if (settings.showMircColors()) {\n                renderedText = MircColors.toSpannable(text);\n            } else {\n                renderedText = new SpannableString(\n                    MircColors.removeStyleAndColors(text)\n                );\n            }\n\n            canvas = new SpannableString(TextUtils.concat(canvas, renderedText));\n\n            if (hasSender()) {\n                int start = (prefix + timestamp).length() + 1;\n                int end = start + sender.length();\n\n                if (settings.showColorsNick()) {\n                    canvas.setSpan(new ForegroundColorSpan(getSenderColor()), start, end , Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n                }\n            }\n\n            if (hasIcon() && settings.showIcons()) {\n                Drawable drawable = context.getResources().getDrawable(icon);\n                drawable.setBounds(0, 0, drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight());\n                canvas.setSpan(new ImageSpan(drawable, ImageSpan.ALIGN_BOTTOM), 0, 1, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n            }\n\n            if (hasColor() && settings.showColors()) {\n                // Only apply the foreground color to areas that don't already have a foreground color.\n                ForegroundColorSpan[] spans = canvas.getSpans(0, canvas.length(), ForegroundColorSpan.class);\n                int start = 0;\n\n                for (int i = 0; i < spans.length; i++) {\n                    canvas.setSpan(new ForegroundColorSpan(color), start, canvas.getSpanStart(spans[i]), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n                    start = canvas.getSpanEnd(spans[i]);\n                }\n\n                canvas.setSpan(new ForegroundColorSpan(color), start, canvas.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n            }\n        }\n\n        return canvas;\n    }\n\n    /**\n     * Does this message have a sender?\n     *\n     * @return\n     */\n    private boolean hasSender()\n    {\n        return sender != null;\n    }\n\n    /**\n     * Does this message have a color assigned?\n     *\n     * @return\n     */\n    private boolean hasColor()\n    {\n        return color != NO_COLOR;\n    }\n\n    /**\n     * Does this message have an icon assigned?\n     *\n     * @return\n     */\n    private boolean hasIcon()\n    {\n        return icon != NO_ICON;\n    }\n\n    /**\n     * Render message as text view\n     *\n     * @param context\n     * @return\n     */\n    public TextView renderTextView(Context context, TextView view)\n    {\n        if (view == null) {\n            view = new TextView(context);\n        }\n\n        view.setAutoLinkMask(Linkify.ALL);\n        view.setLinksClickable(true);\n        view.setLinkTextColor(COLOR_BLUE);\n        view.setText(this.render(context));\n        view.setTextIsSelectable(true);\n\n        return view;\n    }\n\n    /**\n     * Generate a timestamp\n     *\n     * @param use24hFormat\n     * @return\n     */\n    public String renderTimeStamp(boolean use24hFormat, boolean includeSeconds)\n    {\n        Date date = new Date(timestamp);\n\n        int hours = date.getHours();\n        int minutes = date.getMinutes();\n        int seconds = date.getSeconds();\n\n        if (!use24hFormat) {\n            hours = Math.abs(12 - hours);\n            if (hours == 12) {\n                hours = 0;\n            }\n        }\n\n        if (includeSeconds) {\n            return String.format(\n                \"[%02d:%02d:%02d]\",\n                hours,\n                minutes,\n                seconds);\n        } else {\n            return String.format(\n                \"[%02d:%02d]\",\n                hours,\n                minutes);\n        }\n    }\n}\n","lineNo":238}
{"Smelly Sample":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2015 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.activity;\n\nimport android.app.Fragment;\nimport android.content.ComponentName;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.os.Bundle;\nimport android.os.IBinder;\nimport android.support.v4.content.ContextCompat;\nimport android.support.v4.widget.DrawerLayout;\nimport android.support.v7.app.ActionBarDrawerToggle;\nimport android.support.v7.app.AppCompatActivity;\nimport android.support.v7.widget.Toolbar;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.widget.LinearLayout;\nimport android.widget.TextView;\n\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.fragment.ConversationFragment;\nimport org.yaaic.fragment.OverviewFragment;\nimport org.yaaic.fragment.SettingsFragment;\nimport org.yaaic.irc.IRCBinder;\nimport org.yaaic.irc.IRCService;\nimport org.yaaic.listener.ServerListener;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Extra;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.Status;\nimport org.yaaic.receiver.ServerReceiver;\n\n/**\n * The main activity of Yaaic. We'll add, remove and replace fragments here.\n */\npublic class MainActivity extends AppCompatActivity implements YaaicActivity, ServiceConnection, ServerListener {\n    private ActionBarDrawerToggle toggle;\n    private Toolbar toolbar;\n    private DrawerLayout drawer;\n    private IRCBinder binder;\n    private ServerReceiver receiver;\n    private LinearLayout serverContainer;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        setContentView(R.layout.activity_main);\n\n        initializeToolbar();\n        initializeDrawer();\n\n        if (savedInstanceState == null) {\n            onOverview(null);\n        }\n    }\n\n    public void initializeToolbar() {\n        toolbar = (Toolbar) findViewById(R.id.toolbar);\n        setSupportActionBar(toolbar);\n    }\n\n    public void initializeDrawer() {\n        drawer = (DrawerLayout) findViewById(R.id.drawer);\n        toggle = new ActionBarDrawerToggle(this, drawer, toolbar, 0, 0);\n\n        drawer.setDrawerListener(toggle);\n\n        serverContainer = (LinearLayout) findViewById(R.id.server_container);\n    }\n\n    public void updateDrawerServerList() {\n        serverContainer.removeAllViews();\n\n        for (final Server server : Yaaic.getInstance().getServersAsArrayList()) {\n            TextView serverView = (TextView) getLayoutInflater().inflate(R.layout.item_drawer_server, drawer, false);\n            serverView.setText(server.getTitle());\n\n            serverView.setCompoundDrawablesWithIntrinsicBounds(\n                    getDrawable(server.isConnected()\n                        ? R.drawable.ic_navigation_server_connected\n                        : R.drawable.ic_navigation_server_disconnected),\n                    null,\n                    null,\n                    null\n            );\n\n            int colorResource = server.isConnected() ? R.color.connected : R.color.disconnected;\n            serverView.setTextColor(ContextCompat.getColor(this, colorResource));\n\n            serverView.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View v) {\n                    onServerSelected(server);\n\n                    drawer.closeDrawers();\n                }\n            });\n\n            serverContainer.addView(serverView, 0);\n        }\n    }\n\n    @Override\n    protected void onPostCreate(Bundle savedInstanceState) {\n        super.onPostCreate(savedInstanceState);\n\n        toggle.syncState();\n    }\n\n    @Override\n    protected void onResume() {\n        super.onResume();\n\n        receiver = new ServerReceiver(this);\n        registerReceiver(receiver, new IntentFilter(Broadcast.SERVER_UPDATE));\n\n        Intent intent = new Intent(this, IRCService.class);\n        intent.setAction(IRCService.ACTION_BACKGROUND);\n        startService(intent);\n\n        bindService(intent, this, 0);\n\n        updateDrawerServerList();\n    }\n\n    @Override\n    protected void onPause() {\n        super.onPause();\n\n        unregisterReceiver(receiver);\n\n        if (binder != null && binder.getService() != null) {\n            binder.getService().checkServiceStatus();\n        }\n\n        unbindService(this);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        if (toggle.onOptionsItemSelected(item)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    @Override\n    public void onServerSelected(Server server) {\n        Bundle arguments = new Bundle();\n\n        if (server.getStatus() == Status.DISCONNECTED && !server.mayReconnect()) {\n            server.setStatus(Status.PRE_CONNECTING);\n\n            arguments.putBoolean(Extra.CONNECT, true);\n        }\n\n        arguments.putInt(Extra.SERVER_ID, server.getId());\n\n        ConversationFragment fragment = new ConversationFragment();\n        fragment.setArguments(arguments);\n\n        switchToFragment(fragment, ConversationFragment.TRANSACTION_TAG);\n\n    }\n\n    public void onOverview(View view) {\n        switchToFragment(new OverviewFragment(), OverviewFragment.TRANSACTION_TAG);\n    }\n\n    public void onSettings(View view) {\n        switchToFragment(new SettingsFragment(), SettingsFragment.TRANSACTION_TAG);\n    }\n\n    private void switchToFragment(Fragment fragment, String tag) {\n        drawer.closeDrawers();\n\n        getFragmentManager()\n                .beginTransaction()\n                .setCustomAnimations(\n                        R.animator.card_flip_right_in, R.animator.card_flip_right_out,\n                        R.animator.card_flip_left_in, R.animator.card_flip_left_out)\n                .replace(R.id.container, fragment, tag)\n                .commit();\n    }\n\n    public void onAbout(View view) {\n        drawer.closeDrawers();\n        startActivity(new Intent(this, AboutActivity.class));\n    }\n\n    @Override\n    public IRCBinder getBinder() {\n        return binder;\n    }\n\n    @Override\n    public Toolbar getToolbar() {\n        return toolbar;\n    }\n\n    @Override\n    public void setToolbarTitle(String title) {\n        if (toolbar != null) {\n            toolbar.setTitle(title);\n        }\n    }\n\n    @Override\n    public void onServiceConnected(ComponentName name, IBinder service) {\n        binder = (IRCBinder) service;\n    }\n\n    @Override\n    public void onServiceDisconnected(ComponentName name) {\n        binder = null;\n    }\n\n    @Override\n    public void onStatusUpdate() {\n        updateDrawerServerList();\n    }\n}\n","Method after Refactoring":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2015 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.activity;\n\nimport android.app.Fragment;\nimport android.content.ComponentName;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.os.Bundle;\nimport android.os.IBinder;\nimport android.support.v4.content.ContextCompat;\nimport android.support.v4.widget.DrawerLayout;\nimport android.support.v7.app.ActionBarDrawerToggle;\nimport android.support.v7.app.AppCompatActivity;\nimport android.support.v7.widget.Toolbar;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.widget.LinearLayout;\nimport android.widget.TextView;\n\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.fragment.ConversationFragment;\nimport org.yaaic.fragment.OverviewFragment;\nimport org.yaaic.fragment.SettingsFragment;\nimport org.yaaic.irc.IRCBinder;\nimport org.yaaic.irc.IRCService;\nimport org.yaaic.listener.ServerListener;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Extra;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.Status;\nimport org.yaaic.receiver.ServerReceiver;\n\nimport java.util.ArrayList;\n\n/**\n * The main activity of Yaaic. We'll add, remove and replace fragments here.\n */\npublic class MainActivity extends AppCompatActivity implements YaaicActivity, ServiceConnection, ServerListener {\n    private ActionBarDrawerToggle toggle;\n    private Toolbar toolbar;\n    private DrawerLayout drawer;\n    private IRCBinder binder;\n    private ServerReceiver receiver;\n    private LinearLayout serverContainer;\n    private View drawerEmptyView;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        setContentView(R.layout.activity_main);\n\n        initializeToolbar();\n        initializeDrawer();\n\n        if (savedInstanceState == null) {\n            onOverview(null);\n        }\n    }\n\n    public void initializeToolbar() {\n        toolbar = (Toolbar) findViewById(R.id.toolbar);\n        setSupportActionBar(toolbar);\n    }\n\n    public void initializeDrawer() {\n        drawer = (DrawerLayout) findViewById(R.id.drawer);\n        toggle = new ActionBarDrawerToggle(this, drawer, toolbar, 0, 0);\n\n        drawer.setDrawerListener(toggle);\n\n        serverContainer = (LinearLayout) findViewById(R.id.server_container);\n\n        drawerEmptyView = findViewById(R.id.drawer_empty_servers);\n        drawerEmptyView.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                Intent intent = new Intent(MainActivity.this, AddServerActivity.class);\n                startActivity(intent);\n            }\n        });\n    }\n\n    public void updateDrawerServerList() {\n        ArrayList<Server> servers = Yaaic.getInstance().getServersAsArrayList();\n        drawerEmptyView.setVisibility(servers.size() > 0 ? View.GONE : View.VISIBLE);\n\n        serverContainer.removeAllViews();\n\n        for (final Server server : servers) {\n            TextView serverView = (TextView) getLayoutInflater().inflate(R.layout.item_drawer_server, drawer, false);\n            serverView.setText(server.getTitle());\n\n            serverView.setCompoundDrawablesWithIntrinsicBounds(\n                    getDrawable(server.isConnected()\n                        ? R.drawable.ic_navigation_server_connected\n                        : R.drawable.ic_navigation_server_disconnected),\n                    null,\n                    null,\n                    null\n            );\n\n            int colorResource = server.isConnected() ? R.color.connected : R.color.disconnected;\n            serverView.setTextColor(ContextCompat.getColor(this, colorResource));\n\n            serverView.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View v) {\n                    onServerSelected(server);\n\n                    drawer.closeDrawers();\n                }\n            });\n\n            serverContainer.addView(serverView, 0);\n        }\n    }\n\n    @Override\n    protected void onPostCreate(Bundle savedInstanceState) {\n        super.onPostCreate(savedInstanceState);\n\n        toggle.syncState();\n    }\n\n    @Override\n    protected void onResume() {\n        super.onResume();\n\n        receiver = new ServerReceiver(this);\n        registerReceiver(receiver, new IntentFilter(Broadcast.SERVER_UPDATE));\n\n        Intent intent = new Intent(this, IRCService.class);\n        intent.setAction(IRCService.ACTION_BACKGROUND);\n        startService(intent);\n\n        bindService(intent, this, 0);\n\n        updateDrawerServerList();\n    }\n\n    @Override\n    protected void onPause() {\n        super.onPause();\n\n        unregisterReceiver(receiver);\n\n        if (binder != null && binder.getService() != null) {\n            binder.getService().checkServiceStatus();\n        }\n\n        unbindService(this);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        if (toggle.onOptionsItemSelected(item)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    @Override\n    public void onServerSelected(Server server) {\n        Bundle arguments = new Bundle();\n\n        if (server.getStatus() == Status.DISCONNECTED && !server.mayReconnect()) {\n            server.setStatus(Status.PRE_CONNECTING);\n\n            arguments.putBoolean(Extra.CONNECT, true);\n        }\n\n        arguments.putInt(Extra.SERVER_ID, server.getId());\n\n        ConversationFragment fragment = new ConversationFragment();\n        fragment.setArguments(arguments);\n\n        switchToFragment(fragment, ConversationFragment.TRANSACTION_TAG);\n\n    }\n\n    public void onOverview(View view) {\n        switchToFragment(new OverviewFragment(), OverviewFragment.TRANSACTION_TAG);\n    }\n\n    public void onSettings(View view) {\n        switchToFragment(new SettingsFragment(), SettingsFragment.TRANSACTION_TAG);\n    }\n\n    private void switchToFragment(Fragment fragment, String tag) {\n        drawer.closeDrawers();\n\n        getFragmentManager()\n                .beginTransaction()\n                .setCustomAnimations(\n                        R.animator.card_flip_right_in, R.animator.card_flip_right_out,\n                        R.animator.card_flip_left_in, R.animator.card_flip_left_out)\n                .replace(R.id.container, fragment, tag)\n                .commit();\n    }\n\n    public void onAbout(View view) {\n        drawer.closeDrawers();\n        startActivity(new Intent(this, AboutActivity.class));\n    }\n\n    @Override\n    public IRCBinder getBinder() {\n        return binder;\n    }\n\n    @Override\n    public Toolbar getToolbar() {\n        return toolbar;\n    }\n\n    @Override\n    public void setToolbarTitle(String title) {\n        if (toolbar != null) {\n            toolbar.setTitle(title);\n        }\n    }\n\n    @Override\n    public void onServiceConnected(ComponentName name, IBinder service) {\n        binder = (IRCBinder) service;\n    }\n\n    @Override\n    public void onServiceDisconnected(ComponentName name) {\n        binder = null;\n    }\n\n    @Override\n    public void onStatusUpdate() {\n        updateDrawerServerList();\n    }\n}\n","lineNo":106}
{"Smelly Sample":"/*\n * Copyright (C) 2011 The Android Open Source Project\n * Copyright (C) 2011 Jake Wharton\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.viewpagerindicator;\n\nimport android.content.Context;\nimport android.support.v4.view.PagerAdapter;\nimport android.support.v4.view.ViewPager;\nimport android.support.v4.view.ViewPager.OnPageChangeListener;\nimport android.util.AttributeSet;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.HorizontalScrollView;\nimport android.widget.LinearLayout;\nimport android.widget.TextView;\n\n/**\n * This widget implements the dynamic action bar tab behavior that can change\n * across different configurations or circumstances.\n */\npublic class TabPageIndicator extends HorizontalScrollView implements PageIndicator {\n    Runnable mTabSelector;\n\n    private OnClickListener mTabClickListener = new OnClickListener() {\n        public void onClick(View view) {\n            TabView tabView = (TabView)view;\n            mViewPager.setCurrentItem(tabView.getIndex());\n        }\n    };\n\n    private LinearLayout mTabLayout;\n    private ViewPager mViewPager;\n    private ViewPager.OnPageChangeListener mListener;\n\n    private LayoutInflater mInflater;\n\n    int mMaxTabWidth;\n    private int mSelectedTabIndex;\n\n    public TabPageIndicator(Context context) {\n        this(context, null);\n    }\n\n    public TabPageIndicator(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        setHorizontalScrollBarEnabled(false);\n\n        mInflater = LayoutInflater.from(context);\n\n        mTabLayout = new LinearLayout(getContext());\n        addView(mTabLayout, new ViewGroup.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.FILL_PARENT));\n    }\n\n    @Override\n    public void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        final int widthMode = MeasureSpec.getMode(widthMeasureSpec);\n        final boolean lockedExpanded = widthMode == MeasureSpec.EXACTLY;\n        setFillViewport(lockedExpanded);\n\n        final int childCount = mTabLayout.getChildCount();\n        if (childCount > 1 && (widthMode == MeasureSpec.EXACTLY || widthMode == MeasureSpec.AT_MOST)) {\n            if (childCount > 2) {\n                mMaxTabWidth = (int)(MeasureSpec.getSize(widthMeasureSpec) * 0.4f);\n            } else {\n                mMaxTabWidth = MeasureSpec.getSize(widthMeasureSpec) / 2;\n            }\n        } else {\n            mMaxTabWidth = -1;\n        }\n\n        final int oldWidth = getMeasuredWidth();\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n        final int newWidth = getMeasuredWidth();\n\n        if (lockedExpanded && oldWidth != newWidth) {\n            // Recenter the tab display if we're at a new (scrollable) size.\n            setCurrentItem(mSelectedTabIndex);\n        }\n    }\n\n    private void animateToTab(final int position) {\n        final View tabView = mTabLayout.getChildAt(position);\n        if (mTabSelector != null) {\n            removeCallbacks(mTabSelector);\n        }\n        mTabSelector = new Runnable() {\n            public void run() {\n                final int scrollPos = tabView.getLeft() - (getWidth() - tabView.getWidth()) / 2;\n                smoothScrollTo(scrollPos, 0);\n                mTabSelector = null;\n            }\n        };\n        post(mTabSelector);\n    }\n\n    @Override\n    public void onAttachedToWindow() {\n        super.onAttachedToWindow();\n        if (mTabSelector != null) {\n            // Re-post the selector we saved\n            post(mTabSelector);\n        }\n    }\n\n    @Override\n    public void onDetachedFromWindow() {\n        super.onDetachedFromWindow();\n        if (mTabSelector != null) {\n            removeCallbacks(mTabSelector);\n        }\n    }\n\n    private void addTab(String text, int index) {\n        //Workaround for not being able to pass a defStyle on pre-3.0\n        final TabView tabView = (TabView)mInflater.inflate(R.layout.vpi__tab, null);\n        tabView.init(this, text, index);\n        tabView.setFocusable(true);\n        tabView.setOnClickListener(mTabClickListener);\n\n        mTabLayout.addView(tabView, new LinearLayout.LayoutParams(0, LayoutParams.FILL_PARENT, 1));\n    }\n\n    @Override\n    public void onPageScrollStateChanged(int arg0) {\n        if (mListener != null) {\n            mListener.onPageScrollStateChanged(arg0);\n        }\n    }\n\n    @Override\n    public void onPageScrolled(int arg0, float arg1, int arg2) {\n        if (mListener != null) {\n            mListener.onPageScrolled(arg0, arg1, arg2);\n        }\n    }\n\n    @Override\n    public void onPageSelected(int arg0) {\n        setCurrentItem(arg0);\n        if (mListener != null) {\n            mListener.onPageSelected(arg0);\n        }\n    }\n\n    @Override\n    public void setViewPager(ViewPager view) {\n        final PagerAdapter adapter = view.getAdapter();\n        if (adapter == null) {\n            throw new IllegalStateException(\"ViewPager does not have adapter instance.\");\n        }\n        if (!(adapter instanceof TitleProvider)) {\n            throw new IllegalStateException(\"ViewPager adapter must implement TitleProvider to be used with TitlePageIndicator.\");\n        }\n        mViewPager = view;\n        view.setOnPageChangeListener(this);\n        notifyDataSetChanged();\n    }\n\n    public void notifyDataSetChanged() {\n        mTabLayout.removeAllViews();\n        TitleProvider adapter = (TitleProvider)mViewPager.getAdapter();\n        final int count = ((PagerAdapter)adapter).getCount();\n        for (int i = 0; i < count; i++) {\n            addTab(adapter.getTitle(i), i);\n        }\n        if (mSelectedTabIndex > count) {\n            mSelectedTabIndex = count - 1;\n        }\n        setCurrentItem(mSelectedTabIndex);\n        requestLayout();\n    }\n\n    @Override\n    public void setViewPager(ViewPager view, int initialPosition) {\n        setViewPager(view);\n        setCurrentItem(initialPosition);\n    }\n\n    @Override\n    public void setCurrentItem(int item) {\n        if (mViewPager == null) {\n            throw new IllegalStateException(\"ViewPager has not been bound.\");\n        }\n        mSelectedTabIndex = item;\n        final int tabCount = mTabLayout.getChildCount();\n        for (int i = 0; i < tabCount; i++) {\n            final View child = mTabLayout.getChildAt(i);\n            final boolean isSelected = (i == item);\n            child.setSelected(isSelected);\n            if (isSelected) {\n                animateToTab(item);\n            }\n        }\n    }\n\n    @Override\n    public void setOnPageChangeListener(OnPageChangeListener listener) {\n        mListener = listener;\n    }\n\n    public static class TabView extends LinearLayout {\n        private TabPageIndicator mParent;\n        private int mIndex;\n\n        public TabView(Context context, AttributeSet attrs) {\n            super(context, attrs);\n        }\n\n        public void init(TabPageIndicator parent, String text, int index) {\n            mParent = parent;\n            mIndex = index;\n\n            TextView textView = (TextView)findViewById(android.R.id.text1);\n            textView.setText(text);\n        }\n\n        @Override\n        public void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n            super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n\n            // Re-measure if we went beyond our maximum size.\n            if (mParent.mMaxTabWidth > 0 && getMeasuredWidth() > mParent.mMaxTabWidth) {\n                super.onMeasure(MeasureSpec.makeMeasureSpec(mParent.mMaxTabWidth, MeasureSpec.EXACTLY),\n                        heightMeasureSpec);\n            }\n        }\n\n        public int getIndex() {\n            return mIndex;\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2011 The Android Open Source Project\n * Copyright (C) 2011 Jake Wharton\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.viewpagerindicator;\n\nimport android.content.Context;\nimport android.support.v4.view.PagerAdapter;\nimport android.support.v4.view.ViewPager;\nimport android.support.v4.view.ViewPager.OnPageChangeListener;\nimport android.util.AttributeSet;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.HorizontalScrollView;\nimport android.widget.LinearLayout;\nimport android.widget.TextView;\n\nimport static android.view.ViewGroup.LayoutParams.FILL_PARENT;\nimport static android.view.ViewGroup.LayoutParams.WRAP_CONTENT;\n\n/**\n * This widget implements the dynamic action bar tab behavior that can change\n * across different configurations or circumstances.\n */\npublic class TabPageIndicator extends HorizontalScrollView implements PageIndicator {\n    /** Title text used when no title is provided by the adapter. */\n    private static final CharSequence EMPTY_TITLE = \"\";\n\n    /**\n     * Interface for a callback when the selected tab has been reselected.\n     */\n    public interface OnTabReselectedListener {\n        /**\n         * Callback when the selected tab has been reselected.\n         *\n         * @param position Position of the current center item.\n         */\n        void onTabReselected(int position);\n    }\n\n    private Runnable mTabSelector;\n\n    private final OnClickListener mTabClickListener = new OnClickListener() {\n        public void onClick(View view) {\n            TabView tabView = (TabView)view;\n            final int oldSelected = mViewPager.getCurrentItem();\n            final int newSelected = tabView.getIndex();\n            mViewPager.setCurrentItem(newSelected);\n            if (oldSelected == newSelected && mTabReselectedListener != null) {\n                mTabReselectedListener.onTabReselected(newSelected);\n            }\n        }\n    };\n\n    private final LinearLayout mTabLayout;\n    private ViewPager mViewPager;\n    private ViewPager.OnPageChangeListener mListener;\n\n    private int mMaxTabWidth;\n    private int mSelectedTabIndex;\n\n    private OnTabReselectedListener mTabReselectedListener;\n\n    public TabPageIndicator(Context context) {\n        this(context, null);\n    }\n\n    public TabPageIndicator(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        setHorizontalScrollBarEnabled(false);\n\n        mTabLayout = new LinearLayout(getContext());\n        addView(mTabLayout, new ViewGroup.LayoutParams(WRAP_CONTENT, FILL_PARENT));\n    }\n\n    public void setOnTabReselectedListener(OnTabReselectedListener listener) {\n        mTabReselectedListener = listener;\n    }\n\n    @Override\n    public void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        final int widthMode = MeasureSpec.getMode(widthMeasureSpec);\n        final boolean lockedExpanded = widthMode == MeasureSpec.EXACTLY;\n        setFillViewport(lockedExpanded);\n\n        final int childCount = mTabLayout.getChildCount();\n        if (childCount > 1 && (widthMode == MeasureSpec.EXACTLY || widthMode == MeasureSpec.AT_MOST)) {\n            if (childCount > 2) {\n                mMaxTabWidth = (int)(MeasureSpec.getSize(widthMeasureSpec) * 0.4f);\n            } else {\n                mMaxTabWidth = MeasureSpec.getSize(widthMeasureSpec) / 2;\n            }\n        } else {\n            mMaxTabWidth = -1;\n        }\n\n        final int oldWidth = getMeasuredWidth();\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n        final int newWidth = getMeasuredWidth();\n\n        if (lockedExpanded && oldWidth != newWidth) {\n            // Recenter the tab display if we're at a new (scrollable) size.\n            setCurrentItem(mSelectedTabIndex);\n        }\n    }\n\n    private void animateToTab(final int position) {\n        final View tabView = mTabLayout.getChildAt(position);\n        if (mTabSelector != null) {\n            removeCallbacks(mTabSelector);\n        }\n        mTabSelector = new Runnable() {\n            public void run() {\n                final int scrollPos = tabView.getLeft() - (getWidth() - tabView.getWidth()) / 2;\n                smoothScrollTo(scrollPos, 0);\n                mTabSelector = null;\n            }\n        };\n        post(mTabSelector);\n    }\n\n    @Override\n    public void onAttachedToWindow() {\n        super.onAttachedToWindow();\n        if (mTabSelector != null) {\n            // Re-post the selector we saved\n            post(mTabSelector);\n        }\n    }\n\n    @Override\n    public void onDetachedFromWindow() {\n        super.onDetachedFromWindow();\n        if (mTabSelector != null) {\n            removeCallbacks(mTabSelector);\n        }\n    }\n\n    private void addTab(CharSequence text, int index) {\n        final TabView tabView = new TabView(getContext());\n        tabView.mIndex = index;\n        tabView.setFocusable(true);\n        tabView.setOnClickListener(mTabClickListener);\n        tabView.setText(text);\n\n        mTabLayout.addView(tabView, new LinearLayout.LayoutParams(0, FILL_PARENT, 1));\n    }\n\n    @Override\n    public void onPageScrollStateChanged(int arg0) {\n        if (mListener != null) {\n            mListener.onPageScrollStateChanged(arg0);\n        }\n    }\n\n    @Override\n    public void onPageScrolled(int arg0, float arg1, int arg2) {\n        if (mListener != null) {\n            mListener.onPageScrolled(arg0, arg1, arg2);\n        }\n    }\n\n    @Override\n    public void onPageSelected(int arg0) {\n        setCurrentItem(arg0);\n        if (mListener != null) {\n            mListener.onPageSelected(arg0);\n        }\n    }\n\n    @Override\n    public void setViewPager(ViewPager view) {\n        if (mViewPager == view) {\n            return;\n        }\n        if (mViewPager != null) {\n            mViewPager.setOnPageChangeListener(null);\n        }\n        final PagerAdapter adapter = view.getAdapter();\n        if (adapter == null) {\n            throw new IllegalStateException(\"ViewPager does not have adapter instance.\");\n        }\n        mViewPager = view;\n        view.setOnPageChangeListener(this);\n        notifyDataSetChanged();\n    }\n\n    public void notifyDataSetChanged() {\n        mTabLayout.removeAllViews();\n        PagerAdapter adapter = mViewPager.getAdapter();\n        final int count = adapter.getCount();\n        for (int i = 0; i < count; i++) {\n            CharSequence title = adapter.getPageTitle(i);\n            if (title == null) {\n                title = EMPTY_TITLE;\n            }\n            addTab(title, i);\n        }\n        if (mSelectedTabIndex > count) {\n            mSelectedTabIndex = count - 1;\n        }\n        setCurrentItem(mSelectedTabIndex);\n        requestLayout();\n    }\n\n    @Override\n    public void setViewPager(ViewPager view, int initialPosition) {\n        setViewPager(view);\n        setCurrentItem(initialPosition);\n    }\n\n    @Override\n    public void setCurrentItem(int item) {\n        if (mViewPager == null) {\n            throw new IllegalStateException(\"ViewPager has not been bound.\");\n        }\n        mSelectedTabIndex = item;\n        mViewPager.setCurrentItem(item);\n\n        final int tabCount = mTabLayout.getChildCount();\n        for (int i = 0; i < tabCount; i++) {\n            final View child = mTabLayout.getChildAt(i);\n            final boolean isSelected = (i == item);\n            child.setSelected(isSelected);\n            if (isSelected) {\n                animateToTab(item);\n            }\n        }\n    }\n\n    @Override\n    public void setOnPageChangeListener(OnPageChangeListener listener) {\n        mListener = listener;\n    }\n\n    private class TabView extends TextView {\n        private int mIndex;\n\n        public TabView(Context context) {\n            super(context, null, R.attr.vpiTabPageIndicatorStyle);\n        }\n\n        @Override\n        public void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n            super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n\n            // Re-measure if we went beyond our maximum size.\n            if (mMaxTabWidth > 0 && getMeasuredWidth() > mMaxTabWidth) {\n                super.onMeasure(MeasureSpec.makeMeasureSpec(mMaxTabWidth, MeasureSpec.EXACTLY),\n                        heightMeasureSpec);\n            }\n        }\n\n        public int getIndex() {\n            return mIndex;\n        }\n    }\n}\n","lineNo":59}
{"Smelly Sample":"/*\n * Copyright (C) 2011 Jake Wharton\n * Copyright (C) 2011 Patrik Akerfeldt\n * Copyright (C) 2011 Francisco Figueiredo Jr.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.viewpagerindicator;\n\nimport java.util.ArrayList;\nimport android.content.Context;\nimport android.content.res.Resources;\nimport android.content.res.TypedArray;\nimport android.graphics.Canvas;\nimport android.graphics.Paint;\nimport android.graphics.Path;\nimport android.graphics.RectF;\nimport android.graphics.Typeface;\nimport android.os.Parcel;\nimport android.os.Parcelable;\nimport android.support.v4.view.MotionEventCompat;\nimport android.support.v4.view.PagerAdapter;\nimport android.support.v4.view.ViewConfigurationCompat;\nimport android.support.v4.view.ViewPager;\nimport android.util.AttributeSet;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.view.ViewConfiguration;\n\n/**\n * A TitlePageIndicator is a PageIndicator which displays the title of left view\n * (if exist), the title of the current select view (centered) and the title of\n * the right view (if exist). When the user scrolls the ViewPager then titles are\n * also scrolled.\n */\npublic class TitlePageIndicator extends View implements PageIndicator {\n    /**\n     * Percentage indicating what percentage of the screen width away from\n     * center should the underline be fully faded. A value of 0.25 means that\n     * halfway between the center of the screen and an edge.\n     */\n    private static final float SELECTION_FADE_PERCENTAGE = 0.25f;\n\n    /**\n     * Percentage indicating what percentage of the screen width away from\n     * center should the selected text bold turn off. A value of 0.05 means\n     * that 10% between the center and an edge.\n     */\n    private static final float BOLD_FADE_PERCENTAGE = 0.05f;\n\n    /**\n     * Interface for a callback when the center item has been clicked.\n     */\n    public static interface OnCenterItemClickListener {\n        /**\n         * Callback when the center item has been clicked.\n         *\n         * @param position Position of the current center item.\n         */\n        public void onCenterItemClick(int position);\n    }\n\n    public enum IndicatorStyle {\n        None(0), Triangle(1), Underline(2);\n\n        public final int value;\n\n        private IndicatorStyle(int value) {\n            this.value = value;\n        }\n\n        public static IndicatorStyle fromValue(int value) {\n            for (IndicatorStyle style : IndicatorStyle.values()) {\n                if (style.value == value) {\n                    return style;\n                }\n            }\n            return null;\n        }\n    }\n\n    private ViewPager mViewPager;\n    private ViewPager.OnPageChangeListener mListener;\n    private TitleProvider mTitleProvider;\n    private int mCurrentPage;\n    private int mCurrentOffset;\n    private int mScrollState;\n    private final Paint mPaintText = new Paint();\n    private boolean mBoldText;\n    private int mColorText;\n    private int mColorSelected;\n    private Path mPath;\n    private final Paint mPaintFooterLine = new Paint();\n    private IndicatorStyle mFooterIndicatorStyle;\n    private final Paint mPaintFooterIndicator = new Paint();\n    private float mFooterIndicatorHeight;\n    private float mFooterIndicatorUnderlinePadding;\n    private float mFooterPadding;\n    private float mTitlePadding;\n    private float mTopPadding;\n    /** Left and right side padding for not active view titles. */\n    private float mClipPadding;\n    private float mFooterLineHeight;\n\n    private static final int INVALID_POINTER = -1;\n\n    private int mTouchSlop;\n    private float mLastMotionX = -1;\n    private int mActivePointerId = INVALID_POINTER;\n    private boolean mIsDragging;\n\n    private OnCenterItemClickListener mCenterItemClickListener;\n\n\n    public TitlePageIndicator(Context context) {\n        this(context, null);\n    }\n\n    public TitlePageIndicator(Context context, AttributeSet attrs) {\n        this(context, attrs, R.attr.vpiTitlePageIndicatorStyle);\n    }\n\n    public TitlePageIndicator(Context context, AttributeSet attrs, int defStyle) {\n        super(context, attrs, defStyle);\n\n        //Load defaults from resources\n        final Resources res = getResources();\n        final int defaultFooterColor = res.getColor(R.color.default_title_indicator_footer_color);\n        final float defaultFooterLineHeight = res.getDimension(R.dimen.default_title_indicator_footer_line_height);\n        final int defaultFooterIndicatorStyle = res.getInteger(R.integer.default_title_indicator_footer_indicator_style);\n        final float defaultFooterIndicatorHeight = res.getDimension(R.dimen.default_title_indicator_footer_indicator_height);\n        final float defaultFooterIndicatorUnderlinePadding = res.getDimension(R.dimen.default_title_indicator_footer_indicator_underline_padding);\n        final float defaultFooterPadding = res.getDimension(R.dimen.default_title_indicator_footer_padding);\n        final int defaultSelectedColor = res.getColor(R.color.default_title_indicator_selected_color);\n        final boolean defaultSelectedBold = res.getBoolean(R.bool.default_title_indicator_selected_bold);\n        final int defaultTextColor = res.getColor(R.color.default_title_indicator_text_color);\n        final float defaultTextSize = res.getDimension(R.dimen.default_title_indicator_text_size);\n        final float defaultTitlePadding = res.getDimension(R.dimen.default_title_indicator_title_padding);\n        final float defaultClipPadding = res.getDimension(R.dimen.default_title_indicator_clip_padding);\n        final float defaultTopPadding = res.getDimension(R.dimen.default_title_indicator_top_padding);\n\n        //Retrieve styles attributes\n        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.TitlePageIndicator, defStyle, R.style.Widget_TitlePageIndicator);\n\n        //Retrieve the colors to be used for this view and apply them.\n        mFooterLineHeight = a.getDimension(R.styleable.TitlePageIndicator_footerLineHeight, defaultFooterLineHeight);\n        mFooterIndicatorStyle = IndicatorStyle.fromValue(a.getInteger(R.styleable.TitlePageIndicator_footerIndicatorStyle, defaultFooterIndicatorStyle));\n        mFooterIndicatorHeight = a.getDimension(R.styleable.TitlePageIndicator_footerIndicatorHeight, defaultFooterIndicatorHeight);\n        mFooterIndicatorUnderlinePadding = a.getDimension(R.styleable.TitlePageIndicator_footerIndicatorUnderlinePadding, defaultFooterIndicatorUnderlinePadding);\n        mFooterPadding = a.getDimension(R.styleable.TitlePageIndicator_footerPadding, defaultFooterPadding);\n        mTopPadding = a.getDimension(R.styleable.TitlePageIndicator_topPadding, defaultTopPadding);\n        mTitlePadding = a.getDimension(R.styleable.TitlePageIndicator_titlePadding, defaultTitlePadding);\n        mClipPadding = a.getDimension(R.styleable.TitlePageIndicator_clipPadding, defaultClipPadding);\n        mColorSelected = a.getColor(R.styleable.TitlePageIndicator_selectedColor, defaultSelectedColor);\n        mColorText = a.getColor(R.styleable.TitlePageIndicator_textColor, defaultTextColor);\n        mBoldText = a.getBoolean(R.styleable.TitlePageIndicator_selectedBold, defaultSelectedBold);\n\n        final float textSize = a.getDimension(R.styleable.TitlePageIndicator_textSize, defaultTextSize);\n        final int footerColor = a.getColor(R.styleable.TitlePageIndicator_footerColor, defaultFooterColor);\n        mPaintText.setTextSize(textSize);\n        mPaintText.setAntiAlias(true);\n        mPaintFooterLine.setStyle(Paint.Style.FILL_AND_STROKE);\n        mPaintFooterLine.setStrokeWidth(mFooterLineHeight);\n        mPaintFooterLine.setColor(footerColor);\n        mPaintFooterIndicator.setStyle(Paint.Style.FILL_AND_STROKE);\n        mPaintFooterIndicator.setColor(footerColor);\n\n        a.recycle();\n\n        final ViewConfiguration configuration = ViewConfiguration.get(context);\n        mTouchSlop = ViewConfigurationCompat.getScaledPagingTouchSlop(configuration);\n    }\n\n\n    public int getFooterColor() {\n        return mPaintFooterLine.getColor();\n    }\n\n    public void setFooterColor(int footerColor) {\n        mPaintFooterLine.setColor(footerColor);\n        mPaintFooterIndicator.setColor(footerColor);\n        invalidate();\n    }\n\n    public float getFooterLineHeight() {\n        return mFooterLineHeight;\n    }\n\n    public void setFooterLineHeight(float footerLineHeight) {\n        mFooterLineHeight = footerLineHeight;\n        mPaintFooterLine.setStrokeWidth(mFooterLineHeight);\n        invalidate();\n    }\n\n    public float getFooterIndicatorHeight() {\n        return mFooterIndicatorHeight;\n    }\n\n    public void setFooterIndicatorHeight(float footerTriangleHeight) {\n        mFooterIndicatorHeight = footerTriangleHeight;\n        invalidate();\n    }\n\n    public float getFooterIndicatorPadding() {\n        return mFooterPadding;\n    }\n\n    public void setFooterIndicatorPadding(float footerIndicatorPadding) {\n        mFooterPadding = footerIndicatorPadding;\n        invalidate();\n    }\n\n    public IndicatorStyle getFooterIndicatorStyle() {\n        return mFooterIndicatorStyle;\n    }\n\n    public void setFooterIndicatorStyle(IndicatorStyle indicatorStyle) {\n        mFooterIndicatorStyle = indicatorStyle;\n        invalidate();\n    }\n\n    public int getSelectedColor() {\n        return mColorSelected;\n    }\n\n    public void setSelectedColor(int selectedColor) {\n        mColorSelected = selectedColor;\n        invalidate();\n    }\n\n    public boolean isSelectedBold() {\n        return mBoldText;\n    }\n\n    public void setSelectedBold(boolean selectedBold) {\n        mBoldText = selectedBold;\n        invalidate();\n    }\n\n    public int getTextColor() {\n        return mColorText;\n    }\n\n    public void setTextColor(int textColor) {\n        mPaintText.setColor(textColor);\n        mColorText = textColor;\n        invalidate();\n    }\n\n    public float getTextSize() {\n        return mPaintText.getTextSize();\n    }\n\n    public void setTextSize(float textSize) {\n        mPaintText.setTextSize(textSize);\n        invalidate();\n    }\n\n    public float getTitlePadding() {\n        return this.mTitlePadding;\n    }\n\n    public void setTitlePadding(float titlePadding) {\n        mTitlePadding = titlePadding;\n        invalidate();\n    }\n\n    public float getTopPadding() {\n        return this.mTopPadding;\n    }\n\n    public void setTopPadding(float topPadding) {\n        mTopPadding = topPadding;\n        invalidate();\n    }\n\n    public float getClipPadding() {\n        return this.mClipPadding;\n    }\n\n    public void setClipPadding(float clipPadding) {\n        mClipPadding = clipPadding;\n        invalidate();\n    }\n\n    public void setTypeface(Typeface typeface) {\n        mPaintText.setTypeface(typeface);\n        invalidate();\n    }\n\n    public Typeface getTypeface() {\n        return mPaintText.getTypeface();\n    }\n\n    /*\n     * (non-Javadoc)\n     *\n     * @see android.view.View#onDraw(android.graphics.Canvas)\n     */\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n\n        if (mViewPager == null) {\n            return;\n        }\n        final int count = mViewPager.getAdapter().getCount();\n        if (count == 0) {\n            return;\n        }\n\n        //Calculate views bounds\n        ArrayList<RectF> bounds = calculateAllBounds(mPaintText);\n        final int boundsSize = bounds.size();\n\n        //Make sure we're on a page that still exists\n        if (mCurrentPage >= boundsSize) {\n            setCurrentItem(boundsSize - 1);\n            return;\n        }\n\n        final int countMinusOne = count - 1;\n        final float halfWidth = getWidth() / 2f;\n        final int left = getLeft();\n        final float leftClip = left + mClipPadding;\n        final int width = getWidth();\n        final int height = getHeight();\n        final int right = left + width;\n        final float rightClip = right - mClipPadding;\n\n        int page = mCurrentPage;\n        float offsetPercent;\n        if (mCurrentOffset <= halfWidth) {\n            offsetPercent = 1.0f * mCurrentOffset / width;\n        } else {\n            page += 1;\n            offsetPercent = 1.0f * (width - mCurrentOffset) / width;\n        }\n        final boolean currentSelected = (offsetPercent <= SELECTION_FADE_PERCENTAGE);\n        final boolean currentBold = (offsetPercent <= BOLD_FADE_PERCENTAGE);\n        final float selectedPercent = (SELECTION_FADE_PERCENTAGE - offsetPercent) / SELECTION_FADE_PERCENTAGE;\n\n        //Verify if the current view must be clipped to the screen\n        RectF curPageBound = bounds.get(mCurrentPage);\n        float curPageWidth = curPageBound.right - curPageBound.left;\n        if (curPageBound.left < leftClip) {\n            //Try to clip to the screen (left side)\n            clipViewOnTheLeft(curPageBound, curPageWidth, left);\n        }\n        if (curPageBound.right > rightClip) {\n            //Try to clip to the screen (right side)\n            clipViewOnTheRight(curPageBound, curPageWidth, right);\n        }\n\n        //Left views starting from the current position\n        if (mCurrentPage > 0) {\n            for (int i = mCurrentPage - 1; i >= 0; i--) {\n                RectF bound = bounds.get(i);\n                //Is left side is outside the screen\n                if (bound.left < leftClip) {\n                    float w = bound.right - bound.left;\n                    //Try to clip to the screen (left side)\n                    clipViewOnTheLeft(bound, w, left);\n                    //Except if there's an intersection with the right view\n                    RectF rightBound = bounds.get(i + 1);\n                    //Intersection\n                    if (bound.right + mTitlePadding > rightBound.left) {\n                        bound.left = rightBound.left - w - mTitlePadding;\n                        bound.right = bound.left + w;\n                    }\n                }\n            }\n        }\n        //Right views starting from the current position\n        if (mCurrentPage < countMinusOne) {\n            for (int i = mCurrentPage + 1 ; i < count; i++) {\n                RectF bound = bounds.get(i);\n                //If right side is outside the screen\n                if (bound.right > rightClip) {\n                    float w = bound.right - bound.left;\n                    //Try to clip to the screen (right side)\n                    clipViewOnTheRight(bound, w, right);\n                    //Except if there's an intersection with the left view\n                    RectF leftBound = bounds.get(i - 1);\n                    //Intersection\n                    if (bound.left - mTitlePadding < leftBound.right) {\n                        bound.left = leftBound.right + mTitlePadding;\n                        bound.right = bound.left + w;\n                    }\n                }\n            }\n        }\n\n        //Now draw views\n        int colorTextAlpha = mColorText >>> 24;\n        for (int i = 0; i < count; i++) {\n            //Get the title\n            RectF bound = bounds.get(i);\n            //Only if one side is visible\n            if ((bound.left > left && bound.left < right) || (bound.right > left && bound.right < right)) {\n                final boolean currentPage = (i == page);\n                //Only set bold if we are within bounds\n                mPaintText.setFakeBoldText(currentPage && currentBold && mBoldText);\n\n                //Draw text as unselected\n                mPaintText.setColor(mColorText);\n                if(currentPage && currentSelected) {\n                    //Fade out/in unselected text as the selected text fades in/out\n                    mPaintText.setAlpha(colorTextAlpha - (int)(colorTextAlpha * selectedPercent));\n                }\n                canvas.drawText(mTitleProvider.getTitle(i), bound.left, bound.bottom + mTopPadding, mPaintText);\n\n                //If we are within the selected bounds draw the selected text\n                if (currentPage && currentSelected) {\n                    mPaintText.setColor(mColorSelected);\n                    mPaintText.setAlpha((int)((mColorSelected >>> 24) * selectedPercent));\n                    canvas.drawText(mTitleProvider.getTitle(i), bound.left, bound.bottom + mTopPadding, mPaintText);\n                }\n            }\n        }\n\n        //Draw the footer line\n        mPath = new Path();\n        mPath.moveTo(0, height - mFooterLineHeight / 2f);\n        mPath.lineTo(width, height - mFooterLineHeight / 2f);\n        mPath.close();\n        canvas.drawPath(mPath, mPaintFooterLine);\n\n        switch (mFooterIndicatorStyle) {\n            case Triangle:\n                mPath = new Path();\n                mPath.moveTo(halfWidth, height - mFooterLineHeight - mFooterIndicatorHeight);\n                mPath.lineTo(halfWidth + mFooterIndicatorHeight, height - mFooterLineHeight);\n                mPath.lineTo(halfWidth - mFooterIndicatorHeight, height - mFooterLineHeight);\n                mPath.close();\n                canvas.drawPath(mPath, mPaintFooterIndicator);\n                break;\n\n            case Underline:\n                if (!currentSelected || page >= boundsSize) {\n                    break;\n                }\n\n                RectF underlineBounds = bounds.get(page);\n                mPath = new Path();\n                mPath.moveTo(underlineBounds.left  - mFooterIndicatorUnderlinePadding, height - mFooterLineHeight);\n                mPath.lineTo(underlineBounds.right + mFooterIndicatorUnderlinePadding, height - mFooterLineHeight);\n                mPath.lineTo(underlineBounds.right + mFooterIndicatorUnderlinePadding, height - mFooterLineHeight - mFooterIndicatorHeight);\n                mPath.lineTo(underlineBounds.left  - mFooterIndicatorUnderlinePadding, height - mFooterLineHeight - mFooterIndicatorHeight);\n                mPath.close();\n\n                mPaintFooterIndicator.setAlpha((int)(0xFF * selectedPercent));\n                canvas.drawPath(mPath, mPaintFooterIndicator);\n                mPaintFooterIndicator.setAlpha(0xFF);\n                break;\n        }\n    }\n\n    public boolean onTouchEvent(android.view.MotionEvent ev) {\n        if (super.onTouchEvent(ev)) {\n            return true;\n        }\n        if ((mViewPager == null) || (mViewPager.getAdapter().getCount() == 0)) {\n            return false;\n        }\n\n        final int action = ev.getAction();\n\n        switch (action & MotionEventCompat.ACTION_MASK) {\n            case MotionEvent.ACTION_DOWN:\n                mActivePointerId = MotionEventCompat.getPointerId(ev, 0);\n                mLastMotionX = ev.getX();\n                break;\n\n            case MotionEvent.ACTION_MOVE: {\n                final int activePointerIndex = MotionEventCompat.findPointerIndex(ev, mActivePointerId);\n                final float x = MotionEventCompat.getX(ev, activePointerIndex);\n                final float deltaX = x - mLastMotionX;\n\n                if (!mIsDragging) {\n                    if (Math.abs(deltaX) > mTouchSlop) {\n                        mIsDragging = true;\n                    }\n                }\n\n                if (mIsDragging) {\n                    if (!mViewPager.isFakeDragging()) {\n                        mViewPager.beginFakeDrag();\n                    }\n\n                    mLastMotionX = x;\n\n                    mViewPager.fakeDragBy(deltaX);\n                }\n\n                break;\n            }\n\n            case MotionEvent.ACTION_CANCEL:\n            case MotionEvent.ACTION_UP:\n                if (!mIsDragging) {\n                    final int count = mViewPager.getAdapter().getCount();\n                    final int width = getWidth();\n                    final float halfWidth = width / 2f;\n                    final float sixthWidth = width / 6f;\n                    final float leftThird = halfWidth - sixthWidth;\n                    final float rightThird = halfWidth + sixthWidth;\n                    final float eventX = ev.getX();\n\n                    if (eventX < leftThird) {\n                        if (mCurrentPage > 0) {\n                            mViewPager.setCurrentItem(mCurrentPage - 1);\n                            return true;\n                        }\n                    } else if (eventX > rightThird) {\n                        if (mCurrentPage < count - 1) {\n                            mViewPager.setCurrentItem(mCurrentPage + 1);\n                            return true;\n                        }\n                    } else {\n                        //Middle third\n                        if (mCenterItemClickListener != null) {\n                            mCenterItemClickListener.onCenterItemClick(mCurrentPage);\n                        }\n                    }\n                }\n\n                mIsDragging = false;\n                mActivePointerId = INVALID_POINTER;\n                if (mViewPager.isFakeDragging()) mViewPager.endFakeDrag();\n                break;\n\n            case MotionEventCompat.ACTION_POINTER_DOWN: {\n                final int index = MotionEventCompat.getActionIndex(ev);\n                final float x = MotionEventCompat.getX(ev, index);\n                mLastMotionX = x;\n                mActivePointerId = MotionEventCompat.getPointerId(ev, index);\n                break;\n            }\n\n            case MotionEventCompat.ACTION_POINTER_UP:\n                final int pointerIndex = MotionEventCompat.getActionIndex(ev);\n                final int pointerId = MotionEventCompat.getPointerId(ev, pointerIndex);\n                if (pointerId == mActivePointerId) {\n                    final int newPointerIndex = pointerIndex == 0 ? 1 : 0;\n                    mActivePointerId = MotionEventCompat.getPointerId(ev, newPointerIndex);\n                }\n                mLastMotionX = MotionEventCompat.getX(ev, MotionEventCompat.findPointerIndex(ev, mActivePointerId));\n                break;\n        }\n\n        return true;\n    };\n\n    /**\n     * Set bounds for the right textView including clip padding.\n     *\n     * @param curViewBound\n     *            current bounds.\n     * @param curViewWidth\n     *            width of the view.\n     */\n    private void clipViewOnTheRight(RectF curViewBound, float curViewWidth, int right) {\n        curViewBound.right = right - mClipPadding;\n        curViewBound.left = curViewBound.right - curViewWidth;\n    }\n\n    /**\n     * Set bounds for the left textView including clip padding.\n     *\n     * @param curViewBound\n     *            current bounds.\n     * @param curViewWidth\n     *            width of the view.\n     */\n    private void clipViewOnTheLeft(RectF curViewBound, float curViewWidth, int left) {\n        curViewBound.left = left + mClipPadding;\n        curViewBound.right = mClipPadding + curViewWidth;\n    }\n\n    /**\n     * Calculate views bounds and scroll them according to the current index\n     *\n     * @param paint\n     * @param currentIndex\n     * @return\n     */\n    private ArrayList<RectF> calculateAllBounds(Paint paint) {\n        ArrayList<RectF> list = new ArrayList<RectF>();\n        //For each views (If no values then add a fake one)\n        final int count = mViewPager.getAdapter().getCount();\n        final int width = getWidth();\n        final int halfWidth = width / 2;\n        for (int i = 0; i < count; i++) {\n            RectF bounds = calcBounds(i, paint);\n            float w = (bounds.right - bounds.left);\n            float h = (bounds.bottom - bounds.top);\n            bounds.left = (halfWidth) - (w / 2) - mCurrentOffset + ((i - mCurrentPage) * width);\n            bounds.right = bounds.left + w;\n            bounds.top = 0;\n            bounds.bottom = h;\n            list.add(bounds);\n        }\n\n        return list;\n    }\n\n    /**\n     * Calculate the bounds for a view's title\n     *\n     * @param index\n     * @param paint\n     * @return\n     */\n    private RectF calcBounds(int index, Paint paint) {\n        //Calculate the text bounds\n        RectF bounds = new RectF();\n        bounds.right = paint.measureText(mTitleProvider.getTitle(index));\n        bounds.bottom = paint.descent() - paint.ascent();\n        return bounds;\n    }\n\n    @Override\n    public void setViewPager(ViewPager view) {\n        final PagerAdapter adapter = view.getAdapter();\n        if (adapter == null) {\n            throw new IllegalStateException(\"ViewPager does not have adapter instance.\");\n        }\n        if (!(adapter instanceof TitleProvider)) {\n            throw new IllegalStateException(\"ViewPager adapter must implement TitleProvider to be used with TitlePageIndicator.\");\n        }\n        mViewPager = view;\n        mViewPager.setOnPageChangeListener(this);\n        mTitleProvider = (TitleProvider)adapter;\n        invalidate();\n    }\n\n    @Override\n    public void setViewPager(ViewPager view, int initialPosition) {\n        setViewPager(view);\n        setCurrentItem(initialPosition);\n    }\n\n    @Override\n    public void notifyDataSetChanged() {\n        invalidate();\n    }\n\n    /**\n     * Set a callback listener for the center item click.\n     *\n     * @param listener Callback instance.\n     */\n    public void setOnCenterItemClickListener(OnCenterItemClickListener listener) {\n        mCenterItemClickListener = listener;\n    }\n\n    @Override\n    public void setCurrentItem(int item) {\n        if (mViewPager == null) {\n            throw new IllegalStateException(\"ViewPager has not been bound.\");\n        }\n        mViewPager.setCurrentItem(item);\n        mCurrentPage = item;\n        invalidate();\n    }\n\n    @Override\n    public void onPageScrollStateChanged(int state) {\n        mScrollState = state;\n\n        if (mListener != null) {\n            mListener.onPageScrollStateChanged(state);\n        }\n    }\n\n    @Override\n    public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {\n        mCurrentPage = position;\n        mCurrentOffset = positionOffsetPixels;\n        invalidate();\n\n        if (mListener != null) {\n            mListener.onPageScrolled(position, positionOffset, positionOffsetPixels);\n        }\n    }\n\n    @Override\n    public void onPageSelected(int position) {\n        if (mScrollState == ViewPager.SCROLL_STATE_IDLE) {\n            mCurrentPage = position;\n            invalidate();\n        }\n\n        if (mListener != null) {\n            mListener.onPageSelected(position);\n        }\n    }\n\n    @Override\n    public void setOnPageChangeListener(ViewPager.OnPageChangeListener listener) {\n        mListener = listener;\n    }\n\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        //Measure our width in whatever mode specified\n        final int measuredWidth = MeasureSpec.getSize(widthMeasureSpec);\n\n        //Determine our height\n        float height = 0;\n        final int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);\n        if (heightSpecMode == MeasureSpec.EXACTLY) {\n            //We were told how big to be\n            height = MeasureSpec.getSize(heightMeasureSpec);\n        } else {\n            //Calculate the text bounds\n            RectF bounds = new RectF();\n            bounds.bottom = mPaintText.descent()-mPaintText.ascent();\n            height = bounds.bottom - bounds.top + mFooterLineHeight + mFooterPadding + mTopPadding;\n            if (mFooterIndicatorStyle != IndicatorStyle.None) {\n                height += mFooterIndicatorHeight;\n            }\n        }\n        final int measuredHeight = (int)height;\n\n        setMeasuredDimension(measuredWidth, measuredHeight);\n    }\n\n    @Override\n    public void onRestoreInstanceState(Parcelable state) {\n        SavedState savedState = (SavedState)state;\n        super.onRestoreInstanceState(savedState.getSuperState());\n        mCurrentPage = savedState.currentPage;\n        requestLayout();\n    }\n\n    @Override\n    public Parcelable onSaveInstanceState() {\n        Parcelable superState = super.onSaveInstanceState();\n        SavedState savedState = new SavedState(superState);\n        savedState.currentPage = mCurrentPage;\n        return savedState;\n    }\n\n    static class SavedState extends BaseSavedState {\n        int currentPage;\n\n        public SavedState(Parcelable superState) {\n            super(superState);\n        }\n\n        private SavedState(Parcel in) {\n            super(in);\n            currentPage = in.readInt();\n        }\n\n        @Override\n        public void writeToParcel(Parcel dest, int flags) {\n            super.writeToParcel(dest, flags);\n            dest.writeInt(currentPage);\n        }\n\n        public static final Parcelable.Creator<SavedState> CREATOR = new Parcelable.Creator<SavedState>() {\n            @Override\n            public SavedState createFromParcel(Parcel in) {\n                return new SavedState(in);\n            }\n\n            @Override\n            public SavedState[] newArray(int size) {\n                return new SavedState[size];\n            }\n        };\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2011 Jake Wharton\n * Copyright (C) 2011 Patrik Akerfeldt\n * Copyright (C) 2011 Francisco Figueiredo Jr.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.viewpagerindicator;\n\nimport java.util.ArrayList;\nimport android.content.Context;\nimport android.content.res.Resources;\nimport android.content.res.TypedArray;\nimport android.graphics.Canvas;\nimport android.graphics.Paint;\nimport android.graphics.Path;\nimport android.graphics.Rect;\nimport android.graphics.Typeface;\nimport android.os.Parcel;\nimport android.os.Parcelable;\nimport android.support.v4.view.MotionEventCompat;\nimport android.support.v4.view.PagerAdapter;\nimport android.support.v4.view.ViewConfigurationCompat;\nimport android.support.v4.view.ViewPager;\nimport android.util.AttributeSet;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.view.ViewConfiguration;\n\n/**\n * A TitlePageIndicator is a PageIndicator which displays the title of left view\n * (if exist), the title of the current select view (centered) and the title of\n * the right view (if exist). When the user scrolls the ViewPager then titles are\n * also scrolled.\n */\npublic class TitlePageIndicator extends View implements PageIndicator {\n    /**\n     * Percentage indicating what percentage of the screen width away from\n     * center should the underline be fully faded. A value of 0.25 means that\n     * halfway between the center of the screen and an edge.\n     */\n    private static final float SELECTION_FADE_PERCENTAGE = 0.25f;\n\n    /**\n     * Percentage indicating what percentage of the screen width away from\n     * center should the selected text bold turn off. A value of 0.05 means\n     * that 10% between the center and an edge.\n     */\n    private static final float BOLD_FADE_PERCENTAGE = 0.05f;\n\n    /**\n     * Title text used when no title is provided by the adapter.\n     */\n    private static final String EMPTY_TITLE = \"\";\n\n    /**\n     * Interface for a callback when the center item has been clicked.\n     */\n    public interface OnCenterItemClickListener {\n        /**\n         * Callback when the center item has been clicked.\n         *\n         * @param position Position of the current center item.\n         */\n        void onCenterItemClick(int position);\n    }\n\n    public enum IndicatorStyle {\n        None(0), Triangle(1), Underline(2);\n\n        public final int value;\n\n        private IndicatorStyle(int value) {\n            this.value = value;\n        }\n\n        public static IndicatorStyle fromValue(int value) {\n            for (IndicatorStyle style : IndicatorStyle.values()) {\n                if (style.value == value) {\n                    return style;\n                }\n            }\n            return null;\n        }\n    }\n\n    private ViewPager mViewPager;\n    private ViewPager.OnPageChangeListener mListener;\n    private PagerAdapter mPagerAdapter;\n    private int mCurrentPage = -1;\n    private float mPageOffset;\n    private int mScrollState;\n    private final Paint mPaintText = new Paint();\n    private boolean mBoldText;\n    private int mColorText;\n    private int mColorSelected;\n    private Path mPath = new Path();\n    private final Rect mBounds = new Rect();\n    private final Paint mPaintFooterLine = new Paint();\n    private IndicatorStyle mFooterIndicatorStyle;\n    private final Paint mPaintFooterIndicator = new Paint();\n    private float mFooterIndicatorHeight;\n    private float mFooterIndicatorUnderlinePadding;\n    private float mFooterPadding;\n    private float mTitlePadding;\n    private float mTopPadding;\n    /** Left and right side padding for not active view titles. */\n    private float mClipPadding;\n    private float mFooterLineHeight;\n\n    private static final int INVALID_POINTER = -1;\n\n    private int mTouchSlop;\n    private float mLastMotionX = -1;\n    private int mActivePointerId = INVALID_POINTER;\n    private boolean mIsDragging;\n\n    private OnCenterItemClickListener mCenterItemClickListener;\n\n\n    public TitlePageIndicator(Context context) {\n        this(context, null);\n    }\n\n    public TitlePageIndicator(Context context, AttributeSet attrs) {\n        this(context, attrs, R.attr.vpiTitlePageIndicatorStyle);\n    }\n\n    public TitlePageIndicator(Context context, AttributeSet attrs, int defStyle) {\n        super(context, attrs, defStyle);\n        if (isInEditMode()) return;\n\n        //Load defaults from resources\n        final Resources res = getResources();\n        final int defaultFooterColor = res.getColor(R.color.default_title_indicator_footer_color);\n        final float defaultFooterLineHeight = res.getDimension(R.dimen.default_title_indicator_footer_line_height);\n        final int defaultFooterIndicatorStyle = res.getInteger(R.integer.default_title_indicator_footer_indicator_style);\n        final float defaultFooterIndicatorHeight = res.getDimension(R.dimen.default_title_indicator_footer_indicator_height);\n        final float defaultFooterIndicatorUnderlinePadding = res.getDimension(R.dimen.default_title_indicator_footer_indicator_underline_padding);\n        final float defaultFooterPadding = res.getDimension(R.dimen.default_title_indicator_footer_padding);\n        final int defaultSelectedColor = res.getColor(R.color.default_title_indicator_selected_color);\n        final boolean defaultSelectedBold = res.getBoolean(R.bool.default_title_indicator_selected_bold);\n        final int defaultTextColor = res.getColor(R.color.default_title_indicator_text_color);\n        final float defaultTextSize = res.getDimension(R.dimen.default_title_indicator_text_size);\n        final float defaultTitlePadding = res.getDimension(R.dimen.default_title_indicator_title_padding);\n        final float defaultClipPadding = res.getDimension(R.dimen.default_title_indicator_clip_padding);\n        final float defaultTopPadding = res.getDimension(R.dimen.default_title_indicator_top_padding);\n\n        //Retrieve styles attributes\n        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.TitlePageIndicator, defStyle, 0);\n\n        //Retrieve the colors to be used for this view and apply them.\n        mFooterLineHeight = a.getDimension(R.styleable.TitlePageIndicator_footerLineHeight, defaultFooterLineHeight);\n        mFooterIndicatorStyle = IndicatorStyle.fromValue(a.getInteger(R.styleable.TitlePageIndicator_footerIndicatorStyle, defaultFooterIndicatorStyle));\n        mFooterIndicatorHeight = a.getDimension(R.styleable.TitlePageIndicator_footerIndicatorHeight, defaultFooterIndicatorHeight);\n        mFooterIndicatorUnderlinePadding = a.getDimension(R.styleable.TitlePageIndicator_footerIndicatorUnderlinePadding, defaultFooterIndicatorUnderlinePadding);\n        mFooterPadding = a.getDimension(R.styleable.TitlePageIndicator_footerPadding, defaultFooterPadding);\n        mTopPadding = a.getDimension(R.styleable.TitlePageIndicator_topPadding, defaultTopPadding);\n        mTitlePadding = a.getDimension(R.styleable.TitlePageIndicator_titlePadding, defaultTitlePadding);\n        mClipPadding = a.getDimension(R.styleable.TitlePageIndicator_clipPadding, defaultClipPadding);\n        mColorSelected = a.getColor(R.styleable.TitlePageIndicator_selectedColor, defaultSelectedColor);\n        mColorText = a.getColor(R.styleable.TitlePageIndicator_android_textColor, defaultTextColor);\n        mBoldText = a.getBoolean(R.styleable.TitlePageIndicator_selectedBold, defaultSelectedBold);\n\n        final float textSize = a.getDimension(R.styleable.TitlePageIndicator_android_textSize, defaultTextSize);\n        final int footerColor = a.getColor(R.styleable.TitlePageIndicator_footerColor, defaultFooterColor);\n        mPaintText.setTextSize(textSize);\n        mPaintText.setAntiAlias(true);\n        mPaintFooterLine.setStyle(Paint.Style.FILL_AND_STROKE);\n        mPaintFooterLine.setStrokeWidth(mFooterLineHeight);\n        mPaintFooterLine.setColor(footerColor);\n        mPaintFooterIndicator.setStyle(Paint.Style.FILL_AND_STROKE);\n        mPaintFooterIndicator.setColor(footerColor);\n\n        a.recycle();\n\n        final ViewConfiguration configuration = ViewConfiguration.get(context);\n        mTouchSlop = ViewConfigurationCompat.getScaledPagingTouchSlop(configuration);\n    }\n\n\n    public int getFooterColor() {\n        return mPaintFooterLine.getColor();\n    }\n\n    public void setFooterColor(int footerColor) {\n        mPaintFooterLine.setColor(footerColor);\n        mPaintFooterIndicator.setColor(footerColor);\n        invalidate();\n    }\n\n    public float getFooterLineHeight() {\n        return mFooterLineHeight;\n    }\n\n    public void setFooterLineHeight(float footerLineHeight) {\n        mFooterLineHeight = footerLineHeight;\n        mPaintFooterLine.setStrokeWidth(mFooterLineHeight);\n        invalidate();\n    }\n\n    public float getFooterIndicatorHeight() {\n        return mFooterIndicatorHeight;\n    }\n\n    public void setFooterIndicatorHeight(float footerTriangleHeight) {\n        mFooterIndicatorHeight = footerTriangleHeight;\n        invalidate();\n    }\n\n    public float getFooterIndicatorPadding() {\n        return mFooterPadding;\n    }\n\n    public void setFooterIndicatorPadding(float footerIndicatorPadding) {\n        mFooterPadding = footerIndicatorPadding;\n        invalidate();\n    }\n\n    public IndicatorStyle getFooterIndicatorStyle() {\n        return mFooterIndicatorStyle;\n    }\n\n    public void setFooterIndicatorStyle(IndicatorStyle indicatorStyle) {\n        mFooterIndicatorStyle = indicatorStyle;\n        invalidate();\n    }\n\n    public int getSelectedColor() {\n        return mColorSelected;\n    }\n\n    public void setSelectedColor(int selectedColor) {\n        mColorSelected = selectedColor;\n        invalidate();\n    }\n\n    public boolean isSelectedBold() {\n        return mBoldText;\n    }\n\n    public void setSelectedBold(boolean selectedBold) {\n        mBoldText = selectedBold;\n        invalidate();\n    }\n\n    public int getTextColor() {\n        return mColorText;\n    }\n\n    public void setTextColor(int textColor) {\n        mPaintText.setColor(textColor);\n        mColorText = textColor;\n        invalidate();\n    }\n\n    public float getTextSize() {\n        return mPaintText.getTextSize();\n    }\n\n    public void setTextSize(float textSize) {\n        mPaintText.setTextSize(textSize);\n        invalidate();\n    }\n\n    public float getTitlePadding() {\n        return this.mTitlePadding;\n    }\n\n    public void setTitlePadding(float titlePadding) {\n        mTitlePadding = titlePadding;\n        invalidate();\n    }\n\n    public float getTopPadding() {\n        return this.mTopPadding;\n    }\n\n    public void setTopPadding(float topPadding) {\n        mTopPadding = topPadding;\n        invalidate();\n    }\n\n    public float getClipPadding() {\n        return this.mClipPadding;\n    }\n\n    public void setClipPadding(float clipPadding) {\n        mClipPadding = clipPadding;\n        invalidate();\n    }\n\n    public void setTypeface(Typeface typeface) {\n        mPaintText.setTypeface(typeface);\n        invalidate();\n    }\n\n    public Typeface getTypeface() {\n        return mPaintText.getTypeface();\n    }\n\n    /*\n     * (non-Javadoc)\n     *\n     * @see android.view.View#onDraw(android.graphics.Canvas)\n     */\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n\n        if (mViewPager == null) {\n            return;\n        }\n        final int count = mViewPager.getAdapter().getCount();\n        if (count == 0) {\n            return;\n        }\n\n        // mCurrentPage is -1 on first start and after orientation changed. If so, retrieve the correct index from viewpager.\n        if(mCurrentPage == -1 && mViewPager != null) mCurrentPage = mViewPager.getCurrentItem();\n\n        //Calculate views bounds\n        ArrayList<Rect> bounds = calculateAllBounds(mPaintText);\n        final int boundsSize = bounds.size();\n\n        //Make sure we're on a page that still exists\n        if (mCurrentPage >= boundsSize) {\n            setCurrentItem(boundsSize - 1);\n            return;\n        }\n\n        final int countMinusOne = count - 1;\n        final float halfWidth = getWidth() / 2f;\n        final int left = getLeft();\n        final float leftClip = left + mClipPadding;\n        final int width = getWidth();\n        final int height = getHeight();\n        final int right = left + width;\n        final float rightClip = right - mClipPadding;\n\n        int page = mCurrentPage;\n        float offsetPercent;\n        if (mPageOffset <= 0.5) {\n            offsetPercent = mPageOffset;\n        } else {\n            page += 1;\n            offsetPercent = 1 - mPageOffset;\n        }\n        final boolean currentSelected = (offsetPercent <= SELECTION_FADE_PERCENTAGE);\n        final boolean currentBold = (offsetPercent <= BOLD_FADE_PERCENTAGE);\n        final float selectedPercent = (SELECTION_FADE_PERCENTAGE - offsetPercent) / SELECTION_FADE_PERCENTAGE;\n\n        //Verify if the current view must be clipped to the screen\n        Rect curPageBound = bounds.get(mCurrentPage);\n        float curPageWidth = curPageBound.right - curPageBound.left;\n        if (curPageBound.left < leftClip) {\n            //Try to clip to the screen (left side)\n            clipViewOnTheLeft(curPageBound, curPageWidth, left);\n        }\n        if (curPageBound.right > rightClip) {\n            //Try to clip to the screen (right side)\n            clipViewOnTheRight(curPageBound, curPageWidth, right);\n        }\n\n        //Left views starting from the current position\n        if (mCurrentPage > 0) {\n            for (int i = mCurrentPage - 1; i >= 0; i--) {\n                Rect bound = bounds.get(i);\n                //Is left side is outside the screen\n                if (bound.left < leftClip) {\n                    int w = bound.right - bound.left;\n                    //Try to clip to the screen (left side)\n                    clipViewOnTheLeft(bound, w, left);\n                    //Except if there's an intersection with the right view\n                    Rect rightBound = bounds.get(i + 1);\n                    //Intersection\n                    if (bound.right + mTitlePadding > rightBound.left) {\n                        bound.left = (int) (rightBound.left - w - mTitlePadding);\n                        bound.right = bound.left + w;\n                    }\n                }\n            }\n        }\n        //Right views starting from the current position\n        if (mCurrentPage < countMinusOne) {\n            for (int i = mCurrentPage + 1 ; i < count; i++) {\n                Rect bound = bounds.get(i);\n                //If right side is outside the screen\n                if (bound.right > rightClip) {\n                    int w = bound.right - bound.left;\n                    //Try to clip to the screen (right side)\n                    clipViewOnTheRight(bound, w, right);\n                    //Except if there's an intersection with the left view\n                    Rect leftBound = bounds.get(i - 1);\n                    //Intersection\n                    if (bound.left - mTitlePadding < leftBound.right) {\n                        bound.left = (int) (leftBound.right + mTitlePadding);\n                        bound.right = bound.left + w;\n                    }\n                }\n            }\n        }\n\n        //Now draw views\n        int colorTextAlpha = mColorText >>> 24;\n        for (int i = 0; i < count; i++) {\n            //Get the title\n            Rect bound = bounds.get(i);\n            //Only if one side is visible\n            if ((bound.left > left && bound.left < right) || (bound.right > left && bound.right < right)) {\n                final boolean currentPage = (i == page);\n                final CharSequence pageTitle = getTitle(i);\n\n                //Only set bold if we are within bounds\n                mPaintText.setFakeBoldText(currentPage && currentBold && mBoldText);\n\n                //Draw text as unselected\n                mPaintText.setColor(mColorText);\n                if(currentPage && currentSelected) {\n                    //Fade out/in unselected text as the selected text fades in/out\n                    mPaintText.setAlpha(colorTextAlpha - (int)(colorTextAlpha * selectedPercent));\n                }\n                canvas.drawText(pageTitle, 0, pageTitle.length(), bound.left, bound.bottom + mTopPadding, mPaintText);\n\n                //If we are within the selected bounds draw the selected text\n                if (currentPage && currentSelected) {\n                    mPaintText.setColor(mColorSelected);\n                    mPaintText.setAlpha((int)((mColorSelected >>> 24) * selectedPercent));\n                    canvas.drawText(pageTitle, 0, pageTitle.length(), bound.left, bound.bottom + mTopPadding, mPaintText);\n                }\n            }\n        }\n\n        //Draw the footer line\n        mPath.reset();\n        mPath.moveTo(0, height - mFooterLineHeight / 2f);\n        mPath.lineTo(width, height - mFooterLineHeight / 2f);\n        mPath.close();\n        canvas.drawPath(mPath, mPaintFooterLine);\n\n        switch (mFooterIndicatorStyle) {\n            case Triangle:\n                mPath.reset();\n                mPath.moveTo(halfWidth, height - mFooterLineHeight - mFooterIndicatorHeight);\n                mPath.lineTo(halfWidth + mFooterIndicatorHeight, height - mFooterLineHeight);\n                mPath.lineTo(halfWidth - mFooterIndicatorHeight, height - mFooterLineHeight);\n                mPath.close();\n                canvas.drawPath(mPath, mPaintFooterIndicator);\n                break;\n\n            case Underline:\n                if (!currentSelected || page >= boundsSize) {\n                    break;\n                }\n\n                Rect underlineBounds = bounds.get(page);\n                mPath.reset();\n                mPath.moveTo(underlineBounds.left  - mFooterIndicatorUnderlinePadding, height - mFooterLineHeight);\n                mPath.lineTo(underlineBounds.right + mFooterIndicatorUnderlinePadding, height - mFooterLineHeight);\n                mPath.lineTo(underlineBounds.right + mFooterIndicatorUnderlinePadding, height - mFooterLineHeight - mFooterIndicatorHeight);\n                mPath.lineTo(underlineBounds.left  - mFooterIndicatorUnderlinePadding, height - mFooterLineHeight - mFooterIndicatorHeight);\n                mPath.close();\n\n                mPaintFooterIndicator.setAlpha((int)(0xFF * selectedPercent));\n                canvas.drawPath(mPath, mPaintFooterIndicator);\n                mPaintFooterIndicator.setAlpha(0xFF);\n                break;\n        }\n    }\n\n    public boolean onTouchEvent(android.view.MotionEvent ev) {\n        if (super.onTouchEvent(ev)) {\n            return true;\n        }\n        if ((mViewPager == null) || (mViewPager.getAdapter().getCount() == 0)) {\n            return false;\n        }\n\n        final int action = ev.getAction();\n\n        switch (action & MotionEventCompat.ACTION_MASK) {\n            case MotionEvent.ACTION_DOWN:\n                mActivePointerId = MotionEventCompat.getPointerId(ev, 0);\n                mLastMotionX = ev.getX();\n                break;\n\n            case MotionEvent.ACTION_MOVE: {\n                final int activePointerIndex = MotionEventCompat.findPointerIndex(ev, mActivePointerId);\n                final float x = MotionEventCompat.getX(ev, activePointerIndex);\n                final float deltaX = x - mLastMotionX;\n\n                if (!mIsDragging) {\n                    if (Math.abs(deltaX) > mTouchSlop) {\n                        mIsDragging = true;\n                    }\n                }\n\n                if (mIsDragging) {\n                    mLastMotionX = x;\n                    if (mViewPager.isFakeDragging() || mViewPager.beginFakeDrag()) {\n                        mViewPager.fakeDragBy(deltaX);\n                    }\n                }\n\n                break;\n            }\n\n            case MotionEvent.ACTION_CANCEL:\n            case MotionEvent.ACTION_UP:\n                if (!mIsDragging) {\n                    final int count = mViewPager.getAdapter().getCount();\n                    final int width = getWidth();\n                    final float halfWidth = width / 2f;\n                    final float sixthWidth = width / 6f;\n                    final float leftThird = halfWidth - sixthWidth;\n                    final float rightThird = halfWidth + sixthWidth;\n                    final float eventX = ev.getX();\n\n                    if (eventX < leftThird) {\n                        if (mCurrentPage > 0) {\n                            mViewPager.setCurrentItem(mCurrentPage - 1);\n                            return true;\n                        }\n                    } else if (eventX > rightThird) {\n                        if (mCurrentPage < count - 1) {\n                            mViewPager.setCurrentItem(mCurrentPage + 1);\n                            return true;\n                        }\n                    } else {\n                        //Middle third\n                        if (mCenterItemClickListener != null) {\n                            mCenterItemClickListener.onCenterItemClick(mCurrentPage);\n                        }\n                    }\n                }\n\n                mIsDragging = false;\n                mActivePointerId = INVALID_POINTER;\n                if (mViewPager.isFakeDragging()) mViewPager.endFakeDrag();\n                break;\n\n            case MotionEventCompat.ACTION_POINTER_DOWN: {\n                final int index = MotionEventCompat.getActionIndex(ev);\n                final float x = MotionEventCompat.getX(ev, index);\n                mLastMotionX = x;\n                mActivePointerId = MotionEventCompat.getPointerId(ev, index);\n                break;\n            }\n\n            case MotionEventCompat.ACTION_POINTER_UP:\n                final int pointerIndex = MotionEventCompat.getActionIndex(ev);\n                final int pointerId = MotionEventCompat.getPointerId(ev, pointerIndex);\n                if (pointerId == mActivePointerId) {\n                    final int newPointerIndex = pointerIndex == 0 ? 1 : 0;\n                    mActivePointerId = MotionEventCompat.getPointerId(ev, newPointerIndex);\n                }\n                mLastMotionX = MotionEventCompat.getX(ev, MotionEventCompat.findPointerIndex(ev, mActivePointerId));\n                break;\n        }\n\n        return true;\n    };\n\n    /**\n     * Set bounds for the right textView including clip padding.\n     *\n     * @param curViewBound\n     *            current bounds.\n     * @param curViewWidth\n     *            width of the view.\n     */\n    private void clipViewOnTheRight(Rect curViewBound, float curViewWidth, int right) {\n        curViewBound.right = (int) (right - mClipPadding);\n        curViewBound.left = (int) (curViewBound.right - curViewWidth);\n    }\n\n    /**\n     * Set bounds for the left textView including clip padding.\n     *\n     * @param curViewBound\n     *            current bounds.\n     * @param curViewWidth\n     *            width of the view.\n     */\n    private void clipViewOnTheLeft(Rect curViewBound, float curViewWidth, int left) {\n        curViewBound.left = (int) (left + mClipPadding);\n        curViewBound.right = (int) (mClipPadding + curViewWidth);\n    }\n\n    /**\n     * Calculate views bounds and scroll them according to the current index\n     *\n     * @param paint\n     * @return\n     */\n    private ArrayList<Rect> calculateAllBounds(Paint paint) {\n        ArrayList<Rect> list = new ArrayList<Rect>();\n        //For each views (If no values then add a fake one)\n        final int count = mViewPager.getAdapter().getCount();\n        final int width = getWidth();\n        final int halfWidth = width / 2;\n        for (int i = 0; i < count; i++) {\n            Rect bounds = calcBounds(i, paint);\n            int w = bounds.right - bounds.left;\n            int h = bounds.bottom - bounds.top;\n            bounds.left = (int)(halfWidth - (w / 2f) + ((i - mCurrentPage - mPageOffset) * width));\n            bounds.right = bounds.left + w;\n            bounds.top = 0;\n            bounds.bottom = h;\n            list.add(bounds);\n        }\n\n        return list;\n    }\n\n    /**\n     * Calculate the bounds for a view's title\n     *\n     * @param index\n     * @param paint\n     * @return\n     */\n    private Rect calcBounds(int index, Paint paint) {\n        //Calculate the text bounds\n        Rect bounds = new Rect();\n        CharSequence title = getTitle(index);\n        bounds.right = (int) paint.measureText(title, 0, title.length());\n        bounds.bottom = (int) (paint.descent() - paint.ascent());\n        return bounds;\n    }\n\n    @Override\n    public void setViewPager(ViewPager view) {\n        if (mViewPager == view) {\n            return;\n        }\n        if (mViewPager != null) {\n            mViewPager.setOnPageChangeListener(null);\n        }\n        mPagerAdapter = view.getAdapter();\n        if (mPagerAdapter == null) {\n            throw new IllegalStateException(\"ViewPager does not have adapter instance.\");\n        }\n        mViewPager = view;\n        mViewPager.setOnPageChangeListener(this);\n        invalidate();\n    }\n\n    @Override\n    public void setViewPager(ViewPager view, int initialPosition) {\n        setViewPager(view);\n        setCurrentItem(initialPosition);\n    }\n\n    @Override\n    public void notifyDataSetChanged() {\n        invalidate();\n    }\n\n    /**\n     * Set a callback listener for the center item click.\n     *\n     * @param listener Callback instance.\n     */\n    public void setOnCenterItemClickListener(OnCenterItemClickListener listener) {\n        mCenterItemClickListener = listener;\n    }\n\n    @Override\n    public void setCurrentItem(int item) {\n        if (mViewPager == null) {\n            throw new IllegalStateException(\"ViewPager has not been bound.\");\n        }\n        mViewPager.setCurrentItem(item);\n        mCurrentPage = item;\n        invalidate();\n    }\n\n    @Override\n    public void onPageScrollStateChanged(int state) {\n        mScrollState = state;\n\n        if (mListener != null) {\n            mListener.onPageScrollStateChanged(state);\n        }\n    }\n\n    @Override\n    public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {\n        mCurrentPage = position;\n        mPageOffset = positionOffset;\n        invalidate();\n\n        if (mListener != null) {\n            mListener.onPageScrolled(position, positionOffset, positionOffsetPixels);\n        }\n    }\n\n    @Override\n    public void onPageSelected(int position) {\n        if (mScrollState == ViewPager.SCROLL_STATE_IDLE) {\n            mCurrentPage = position;\n            invalidate();\n        }\n\n        if (mListener != null) {\n            mListener.onPageSelected(position);\n        }\n    }\n\n    @Override\n    public void setOnPageChangeListener(ViewPager.OnPageChangeListener listener) {\n        mListener = listener;\n    }\n\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        //Measure our width in whatever mode specified\n        final int measuredWidth = MeasureSpec.getSize(widthMeasureSpec);\n\n        //Determine our height\n        float height = 0;\n        final int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);\n        if (heightSpecMode == MeasureSpec.EXACTLY) {\n            //We were told how big to be\n            height = MeasureSpec.getSize(heightMeasureSpec);\n        } else {\n            //Calculate the text bounds\n            mBounds.setEmpty();\n            mBounds.bottom = (int) (mPaintText.descent() - mPaintText.ascent());\n            height = mBounds.bottom - mBounds.top + mFooterLineHeight + mFooterPadding + mTopPadding;\n            if (mFooterIndicatorStyle != IndicatorStyle.None) {\n                height += mFooterIndicatorHeight;\n            }\n        }\n        final int measuredHeight = (int)height;\n\n        setMeasuredDimension(measuredWidth, measuredHeight);\n    }\n\n    @Override\n    public void onRestoreInstanceState(Parcelable state) {\n        SavedState savedState = (SavedState)state;\n        super.onRestoreInstanceState(savedState.getSuperState());\n        mCurrentPage = savedState.currentPage;\n        requestLayout();\n    }\n\n    @Override\n    public Parcelable onSaveInstanceState() {\n        Parcelable superState = super.onSaveInstanceState();\n        SavedState savedState = new SavedState(superState);\n        savedState.currentPage = mCurrentPage;\n        return savedState;\n    }\n\n    static class SavedState extends BaseSavedState {\n        int currentPage;\n\n        public SavedState(Parcelable superState) {\n            super(superState);\n        }\n\n        private SavedState(Parcel in) {\n            super(in);\n            currentPage = in.readInt();\n        }\n\n        @Override\n        public void writeToParcel(Parcel dest, int flags) {\n            super.writeToParcel(dest, flags);\n            dest.writeInt(currentPage);\n        }\n\n        public static final Parcelable.Creator<SavedState> CREATOR = new Parcelable.Creator<SavedState>() {\n            @Override\n            public SavedState createFromParcel(Parcel in) {\n                return new SavedState(in);\n            }\n\n            @Override\n            public SavedState[] newArray(int size) {\n                return new SavedState[size];\n            }\n        };\n    }\n\n    private CharSequence getTitle(int i) {\n        CharSequence title = mPagerAdapter.getPageTitle(i);\n        if (title == null) {\n            title = EMPTY_TITLE;\n        }\n        return title.toString();\n    }\n}\n","lineNo":636}
{"Smelly Sample":"package com.actionbarsherlock.internal;\n\nimport static android.view.ViewGroup.LayoutParams.MATCH_PARENT;\nimport static com.actionbarsherlock.internal.ResourcesCompat.getResources_getBoolean;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport org.xmlpull.v1.XmlPullParser;\nimport android.app.Activity;\nimport android.content.Context;\nimport android.content.pm.ActivityInfo;\nimport android.content.res.AssetManager;\nimport android.content.res.Configuration;\nimport android.content.res.Resources;\nimport android.content.res.TypedArray;\nimport android.content.res.XmlResourceParser;\nimport android.os.Bundle;\nimport android.util.AndroidRuntimeException;\nimport android.util.Log;\nimport android.util.TypedValue;\nimport android.view.ContextThemeWrapper;\nimport android.view.KeyCharacterMap;\nimport android.view.KeyEvent;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.ViewStub;\nimport android.view.Window;\nimport android.view.accessibility.AccessibilityEvent;\nimport android.view.animation.Animation;\nimport android.view.animation.AnimationUtils;\nimport android.widget.FrameLayout;\nimport android.widget.TextView;\nimport com.actionbarsherlock.ActionBarSherlock;\nimport com.actionbarsherlock.R;\nimport com.actionbarsherlock.app.ActionBar;\nimport com.actionbarsherlock.internal.app.ActionBarImpl;\nimport com.actionbarsherlock.internal.view.StandaloneActionMode;\nimport com.actionbarsherlock.internal.view.menu.ActionMenuPresenter;\nimport com.actionbarsherlock.internal.view.menu.MenuBuilder;\nimport com.actionbarsherlock.internal.view.menu.MenuItemImpl;\nimport com.actionbarsherlock.internal.view.menu.MenuPresenter;\nimport com.actionbarsherlock.internal.widget.ActionBarContainer;\nimport com.actionbarsherlock.internal.widget.ActionBarContextView;\nimport com.actionbarsherlock.internal.widget.ActionBarView;\nimport com.actionbarsherlock.internal.widget.IcsProgressBar;\nimport com.actionbarsherlock.view.ActionMode;\nimport com.actionbarsherlock.view.Menu;\nimport com.actionbarsherlock.view.MenuItem;\n\n@ActionBarSherlock.Implementation(api = 7)\npublic class ActionBarSherlockCompat extends ActionBarSherlock implements MenuBuilder.Callback, com.actionbarsherlock.view.Window.Callback, MenuPresenter.Callback, android.view.MenuItem.OnMenuItemClickListener {\n    /** Window features which are enabled by default. */\n    protected static final int DEFAULT_FEATURES = 0;\n\n\n    public ActionBarSherlockCompat(Activity activity, int flags) {\n        super(activity, flags);\n    }\n\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Properties\n    ///////////////////////////////////////////////////////////////////////////\n\n    /** Whether or not the device has a dedicated menu key button. */\n    private boolean mReserveOverflow;\n    /** Lazy-load indicator for {@link #mReserveOverflow}. */\n    private boolean mReserveOverflowSet = false;\n\n    /** Current menu instance for managing action items. */\n    private MenuBuilder mMenu;\n    /** Map between native options items and sherlock items. */\n    protected HashMap<android.view.MenuItem, MenuItemImpl> mNativeItemMap;\n\n    /** Parent view of the window decoration (action bar, mode, etc.). */\n    private ViewGroup mDecor;\n    /** Parent view of the activity content. */\n    private ViewGroup mContentParent;\n\n    /** Whether or not the title is stable and can be displayed. */\n    private boolean mIsTitleReady = false;\n\n    /* Emulate PanelFeatureState */\n    private boolean mClosingActionMenu;\n    private boolean mMenuIsPrepared;\n    private boolean mMenuRefreshContent;\n    private Bundle mMenuFrozenActionViewState;\n\n    /** Implementation which backs the action bar interface API. */\n    private ActionBarImpl aActionBar;\n    /** Main action bar view which displays the core content. */\n    private ActionBarView wActionBar;\n    /** Relevant window and action bar features flags. */\n    private int mFeatures = DEFAULT_FEATURES;\n    /** Relevant user interface option flags. */\n    private int mUiOptions = 0;\n\n    /** Decor indeterminate progress indicator. */\n    private IcsProgressBar mCircularProgressBar;\n    /** Decor progress indicator. */\n    private IcsProgressBar mHorizontalProgressBar;\n\n    /** Current displayed context action bar, if any. */\n    private ActionMode mActionMode;\n    /** Parent view in which the context action bar is displayed. */\n    private ActionBarContextView mActionModeView;\n\n    /** Title view used with dialogs. */\n    private TextView mTitleView;\n    /** Current activity title. */\n    private CharSequence mTitle = null;\n    /** Whether or not this \"activity\" is floating (i.e., a dialog) */\n    private boolean mIsFloating;\n\n\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Instance methods\n    ///////////////////////////////////////////////////////////////////////////\n\n    @Override\n    public ActionBar getActionBar() {\n        if (DEBUG) Log.d(TAG, \"[getActionBar]\");\n\n        initActionBar();\n        return aActionBar;\n    }\n\n    private void initActionBar() {\n        if (DEBUG) Log.d(TAG, \"[initActionBar]\");\n\n        // Initializing the window decor can change window feature flags.\n        // Make sure that we have the correct set before performing the test below.\n        if (mDecor == null) {\n            installDecor();\n        }\n\n        if ((aActionBar != null) || !hasFeature(Window.FEATURE_ACTION_BAR) || hasFeature(Window.FEATURE_NO_TITLE) || mActivity.isChild()) {\n            return;\n        }\n\n        aActionBar = new ActionBarImpl(mActivity, mFeatures);\n\n        if (!mIsDelegate) {\n            //We may never get another chance to set the title\n            wActionBar.setWindowTitle(mActivity.getTitle());\n        }\n    }\n\n    @Override\n    protected Context getThemedContext() {\n        return aActionBar.getThemedContext();\n    }\n\n    @Override\n    public void setTitle(CharSequence title) {\n        if (DEBUG) Log.d(TAG, \"[setTitle] title: \" + title);\n\n        dispatchTitleChanged(title, 0);\n    }\n\n    @Override\n    public ActionMode startActionMode(ActionMode.Callback callback) {\n        if (DEBUG) Log.d(TAG, \"[startActionMode] callback: \" + callback);\n\n        if (mActionMode != null) {\n            mActionMode.finish();\n        }\n\n        final ActionMode.Callback wrappedCallback = new ActionModeCallbackWrapper(callback);\n        ActionMode mode = null;\n\n        //Emulate Activity's onWindowStartingActionMode:\n        initActionBar();\n        if (aActionBar != null) {\n            mode = aActionBar.startActionMode(wrappedCallback);\n        }\n\n        if (mode != null) {\n            mActionMode = mode;\n        } else {\n            if (mActionModeView == null) {\n                ViewStub stub = (ViewStub)mDecor.findViewById(R.id.abs__action_mode_bar_stub);\n                if (stub != null) {\n                    mActionModeView = (ActionBarContextView)stub.inflate();\n                }\n            }\n            if (mActionModeView != null) {\n                mActionModeView.killMode();\n                mode = new StandaloneActionMode(mActivity, mActionModeView, wrappedCallback, true);\n                if (callback.onCreateActionMode(mode, mode.getMenu())) {\n                    mode.invalidate();\n                    mActionModeView.initForMode(mode);\n                    mActionModeView.setVisibility(View.VISIBLE);\n                    mActionMode = mode;\n                    mActionModeView.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);\n                } else {\n                    mActionMode = null;\n                }\n            }\n        }\n        if (mActionMode != null && mActivity instanceof OnActionModeStartedListener) {\n            ((OnActionModeStartedListener)mActivity).onActionModeStarted(mActionMode);\n        }\n        return mActionMode;\n    }\n\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Lifecycle and interaction callbacks for delegation\n    ///////////////////////////////////////////////////////////////////////////\n\n    @Override\n    public void dispatchConfigurationChanged(Configuration newConfig) {\n        if (DEBUG) Log.d(TAG, \"[dispatchConfigurationChanged] newConfig: \" + newConfig);\n\n        if (aActionBar != null) {\n            aActionBar.onConfigurationChanged(newConfig);\n        }\n    }\n\n    @Override\n    public void dispatchPostResume() {\n        if (DEBUG) Log.d(TAG, \"[dispatchPostResume]\");\n\n        if (aActionBar != null) {\n            aActionBar.setShowHideAnimationEnabled(true);\n        }\n    }\n\n    @Override\n    public void dispatchPause() {\n        if (DEBUG) Log.d(TAG, \"[dispatchPause]\");\n\n        if (wActionBar != null && wActionBar.isOverflowMenuShowing()) {\n            wActionBar.hideOverflowMenu();\n        }\n    }\n\n    @Override\n    public void dispatchStop() {\n        if (DEBUG) Log.d(TAG, \"[dispatchStop]\");\n\n        if (aActionBar != null) {\n            aActionBar.setShowHideAnimationEnabled(false);\n        }\n    }\n\n    @Override\n    public void dispatchInvalidateOptionsMenu() {\n        if (DEBUG) Log.d(TAG, \"[dispatchInvalidateOptionsMenu]\");\n\n        Bundle savedActionViewStates = null;\n        if (mMenu != null) {\n            savedActionViewStates = new Bundle();\n            mMenu.saveActionViewStates(savedActionViewStates);\n            if (savedActionViewStates.size() > 0) {\n                mMenuFrozenActionViewState = savedActionViewStates;\n            }\n            // This will be started again when the panel is prepared.\n            mMenu.stopDispatchingItemsChanged();\n            mMenu.clear();\n        }\n        mMenuRefreshContent = true;\n\n        // Prepare the options panel if we have an action bar\n        if (wActionBar != null) {\n            mMenuIsPrepared = false;\n            preparePanel();\n        }\n    }\n\n    @Override\n    public boolean dispatchOpenOptionsMenu() {\n        if (DEBUG) Log.d(TAG, \"[dispatchOpenOptionsMenu]\");\n\n        if (!isReservingOverflow()) {\n            return false;\n        }\n\n        return wActionBar.showOverflowMenu();\n    }\n\n    @Override\n    public boolean dispatchCloseOptionsMenu() {\n        if (DEBUG) Log.d(TAG, \"[dispatchCloseOptionsMenu]\");\n\n        if (!isReservingOverflow()) {\n            return false;\n        }\n\n        return wActionBar.hideOverflowMenu();\n    }\n\n    @Override\n    public void dispatchPostCreate(Bundle savedInstanceState) {\n        if (DEBUG) Log.d(TAG, \"[dispatchOnPostCreate]\");\n\n        if (mIsDelegate) {\n            mIsTitleReady = true;\n        }\n\n        if (mDecor == null) {\n            initActionBar();\n        }\n    }\n\n    @Override\n    public boolean dispatchCreateOptionsMenu(android.view.Menu menu) {\n        if (DEBUG) {\n            Log.d(TAG, \"[dispatchCreateOptionsMenu] android.view.Menu: \" + menu);\n            Log.d(TAG, \"[dispatchCreateOptionsMenu] returning true\");\n        }\n        return true;\n    }\n\n    @Override\n    public boolean dispatchPrepareOptionsMenu(android.view.Menu menu) {\n        if (DEBUG) Log.d(TAG, \"[dispatchPrepareOptionsMenu] android.view.Menu: \" + menu);\n\n        if (mActionMode != null) {\n            return false;\n        }\n\n        mMenuIsPrepared = false;\n        if (!preparePanel()) {\n            return false;\n        }\n\n        if (isReservingOverflow()) {\n            return false;\n        }\n\n        if (mNativeItemMap == null) {\n            mNativeItemMap = new HashMap<android.view.MenuItem, MenuItemImpl>();\n        } else {\n            mNativeItemMap.clear();\n        }\n\n        if (mMenu == null) {\n            return false;\n        }\n\n        boolean result = mMenu.bindNativeOverflow(menu, this, mNativeItemMap);\n        if (DEBUG) Log.d(TAG, \"[dispatchPrepareOptionsMenu] returning \" + result);\n        return result;\n    }\n\n    @Override\n    public boolean dispatchOptionsItemSelected(android.view.MenuItem item) {\n        throw new IllegalStateException(\"Native callback invoked. Create a test case and report!\");\n    }\n\n    @Override\n    public boolean dispatchMenuOpened(int featureId, android.view.Menu menu) {\n        if (DEBUG) Log.d(TAG, \"[dispatchMenuOpened] featureId: \" + featureId + \", menu: \" + menu);\n\n        if (featureId == Window.FEATURE_ACTION_BAR || featureId == Window.FEATURE_OPTIONS_PANEL) {\n            if (aActionBar != null) {\n                aActionBar.dispatchMenuVisibilityChanged(true);\n            }\n            return true;\n        }\n\n        return false;\n    }\n\n    @Override\n    public void dispatchPanelClosed(int featureId, android.view.Menu menu){\n        if (DEBUG) Log.d(TAG, \"[dispatchPanelClosed] featureId: \" + featureId + \", menu: \" + menu);\n\n        if (featureId == Window.FEATURE_ACTION_BAR || featureId == Window.FEATURE_OPTIONS_PANEL) {\n            if (aActionBar != null) {\n                aActionBar.dispatchMenuVisibilityChanged(false);\n            }\n        }\n    }\n\n    @Override\n    public void dispatchTitleChanged(CharSequence title, int color) {\n        if (DEBUG) Log.d(TAG, \"[dispatchTitleChanged] title: \" + title + \", color: \" + color);\n\n        if (!mIsDelegate || mIsTitleReady) {\n            if (mTitleView != null) {\n                mTitleView.setText(title);\n            } else if (wActionBar != null) {\n                wActionBar.setWindowTitle(title);\n            }\n        }\n\n        mTitle = title;\n    }\n\n    @Override\n    public boolean dispatchKeyEvent(KeyEvent event) {\n        if (DEBUG) Log.d(TAG, \"[dispatchKeyEvent] event: \" + event);\n\n        final int keyCode = event.getKeyCode();\n\n        // Not handled by the view hierarchy, does the action bar want it\n        // to cancel out of something special?\n        if (keyCode == KeyEvent.KEYCODE_BACK) {\n            final int action = event.getAction();\n            // Back cancels action modes first.\n            if (mActionMode != null) {\n                if (action == KeyEvent.ACTION_UP) {\n                    mActionMode.finish();\n                }\n                if (DEBUG) Log.d(TAG, \"[dispatchKeyEvent] returning true\");\n                return true;\n            }\n\n            // Next collapse any expanded action views.\n            if (aActionBar != null && wActionBar.hasExpandedActionView()) {\n                if (action == KeyEvent.ACTION_UP) {\n                    wActionBar.collapseActionView();\n                }\n                if (DEBUG) Log.d(TAG, \"[dispatchKeyEvent] returning true\");\n                return true;\n            }\n        }\n\n        if (keyCode == KeyEvent.KEYCODE_MENU && event.getAction() == KeyEvent.ACTION_UP && isReservingOverflow()) {\n            if (mActionMode == null) {\n                if (wActionBar.isOverflowMenuShowing()) {\n                    wActionBar.hideOverflowMenu();\n                } else {\n                    wActionBar.showOverflowMenu();\n                }\n            }\n            if (DEBUG) Log.d(TAG, \"[dispatchKeyEvent] returning true\");\n            return true;\n        }\n\n        if (DEBUG) Log.d(TAG, \"[dispatchKeyEvent] returning false\");\n        return false;\n    }\n\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Menu callback lifecycle and creation\n    ///////////////////////////////////////////////////////////////////////////\n\n    private boolean preparePanel() {\n        // Already prepared (isPrepared will be reset to false later)\n        if (mMenuIsPrepared) {\n            return true;\n        }\n\n        // Init the panel state's menu--return false if init failed\n        if (mMenu == null || mMenuRefreshContent) {\n            if (mMenu == null) {\n                if (!initializePanelMenu() || (mMenu == null)) {\n                    return false;\n                }\n            }\n\n            if (wActionBar != null) {\n                wActionBar.setMenu(mMenu, this);\n            }\n\n            // Call callback, and return if it doesn't want to display menu.\n\n            // Creating the panel menu will involve a lot of manipulation;\n            // don't dispatch change events to presenters until we're done.\n            mMenu.stopDispatchingItemsChanged();\n            if (!callbackCreateOptionsMenu(mMenu)) {\n                // Ditch the menu created above\n                mMenu = null;\n\n                if (wActionBar != null) {\n                    // Don't show it in the action bar either\n                    wActionBar.setMenu(null, this);\n                }\n\n                return false;\n            }\n\n            mMenuRefreshContent = false;\n        }\n\n        // Callback and return if the callback does not want to show the menu\n\n        // Preparing the panel menu can involve a lot of manipulation;\n        // don't dispatch change events to presenters until we're done.\n        mMenu.stopDispatchingItemsChanged();\n\n        // Restore action view state before we prepare. This gives apps\n        // an opportunity to override frozen/restored state in onPrepare.\n        if (mMenuFrozenActionViewState != null) {\n            mMenu.restoreActionViewStates(mMenuFrozenActionViewState);\n            mMenuFrozenActionViewState = null;\n        }\n\n        if (!callbackPrepareOptionsMenu(mMenu)) {\n            if (wActionBar != null) {\n                // The app didn't want to show the menu for now but it still exists.\n                // Clear it out of the action bar.\n                wActionBar.setMenu(null, this);\n            }\n            mMenu.startDispatchingItemsChanged();\n            return false;\n        }\n\n        // Set the proper keymap\n        KeyCharacterMap kmap = KeyCharacterMap.load(KeyCharacterMap.VIRTUAL_KEYBOARD);\n        mMenu.setQwertyMode(kmap.getKeyboardType() != KeyCharacterMap.NUMERIC);\n        mMenu.startDispatchingItemsChanged();\n\n        // Set other state\n        mMenuIsPrepared = true;\n\n        return true;\n    }\n\n    public boolean onMenuItemSelected(MenuBuilder menu, MenuItem item) {\n        return callbackOptionsItemSelected(item);\n    }\n\n    public void onMenuModeChange(MenuBuilder menu) {\n        reopenMenu(true);\n    }\n\n    private void reopenMenu(boolean toggleMenuMode) {\n        if (wActionBar != null && wActionBar.isOverflowReserved()) {\n            if (!wActionBar.isOverflowMenuShowing() || !toggleMenuMode) {\n                if (wActionBar.getVisibility() == View.VISIBLE) {\n                    if (callbackPrepareOptionsMenu(mMenu)) {\n                        wActionBar.showOverflowMenu();\n                    }\n                }\n            } else {\n                wActionBar.hideOverflowMenu();\n            }\n            return;\n        }\n    }\n\n    private boolean initializePanelMenu() {\n        Context context = mActivity;//getContext();\n\n        // If we have an action bar, initialize the menu with a context themed for it.\n        if (wActionBar != null) {\n            TypedValue outValue = new TypedValue();\n            Resources.Theme currentTheme = context.getTheme();\n            currentTheme.resolveAttribute(R.attr.actionBarWidgetTheme,\n                    outValue, true);\n            final int targetThemeRes = outValue.resourceId;\n\n            if (targetThemeRes != 0 /*&& context.getThemeResId() != targetThemeRes*/) {\n                context = new ContextThemeWrapper(context, targetThemeRes);\n            }\n        }\n\n        mMenu = new MenuBuilder(context);\n        mMenu.setCallback(this);\n\n        return true;\n    }\n\n    void checkCloseActionMenu(Menu menu) {\n        if (mClosingActionMenu) {\n            return;\n        }\n\n        mClosingActionMenu = true;\n        wActionBar.dismissPopupMenus();\n        //Callback cb = getCallback();\n        //if (cb != null && !isDestroyed()) {\n        //    cb.onPanelClosed(FEATURE_ACTION_BAR, menu);\n        //}\n        mClosingActionMenu = false;\n    }\n\n    @Override\n    public boolean onOpenSubMenu(MenuBuilder subMenu) {\n        return true;\n    }\n\n    @Override\n    public void onCloseMenu(MenuBuilder menu, boolean allMenusAreClosing) {\n        checkCloseActionMenu(menu);\n    }\n\n    @Override\n    public boolean onMenuItemClick(android.view.MenuItem item) {\n        if (DEBUG) Log.d(TAG, \"[mNativeItemListener.onMenuItemClick] item: \" + item);\n\n        final MenuItemImpl sherlockItem = mNativeItemMap.get(item);\n        if (sherlockItem != null) {\n            sherlockItem.invoke();\n        } else {\n            Log.e(TAG, \"Options item \\\"\" + item + \"\\\" not found in mapping\");\n        }\n\n        return true; //Do not allow continuation of native handling\n    }\n\n    @Override\n    public boolean onMenuItemSelected(int featureId, MenuItem item) {\n        return callbackOptionsItemSelected(item);\n    }\n\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Progress bar interaction and internal handling\n    ///////////////////////////////////////////////////////////////////////////\n\n    @Override\n    public void setProgressBarVisibility(boolean visible) {\n        if (DEBUG) Log.d(TAG, \"[setProgressBarVisibility] visible: \" + visible);\n\n        setFeatureInt(Window.FEATURE_PROGRESS, visible ? Window.PROGRESS_VISIBILITY_ON :\n            Window.PROGRESS_VISIBILITY_OFF);\n    }\n\n    @Override\n    public void setProgressBarIndeterminateVisibility(boolean visible) {\n        if (DEBUG) Log.d(TAG, \"[setProgressBarIndeterminateVisibility] visible: \" + visible);\n\n        setFeatureInt(Window.FEATURE_INDETERMINATE_PROGRESS,\n                visible ? Window.PROGRESS_VISIBILITY_ON : Window.PROGRESS_VISIBILITY_OFF);\n    }\n\n    @Override\n    public void setProgressBarIndeterminate(boolean indeterminate) {\n        if (DEBUG) Log.d(TAG, \"[setProgressBarIndeterminate] indeterminate: \" + indeterminate);\n\n        setFeatureInt(Window.FEATURE_PROGRESS,\n                indeterminate ? Window.PROGRESS_INDETERMINATE_ON : Window.PROGRESS_INDETERMINATE_OFF);\n    }\n\n    @Override\n    public void setProgress(int progress) {\n        if (DEBUG) Log.d(TAG, \"[setProgress] progress: \" + progress);\n\n        setFeatureInt(Window.FEATURE_PROGRESS, progress + Window.PROGRESS_START);\n    }\n\n    @Override\n    public void setSecondaryProgress(int secondaryProgress) {\n        if (DEBUG) Log.d(TAG, \"[setSecondaryProgress] secondaryProgress: \" + secondaryProgress);\n\n        setFeatureInt(Window.FEATURE_PROGRESS,\n                secondaryProgress + Window.PROGRESS_SECONDARY_START);\n    }\n\n    private void setFeatureInt(int featureId, int value) {\n        updateInt(featureId, value, false);\n    }\n\n    private void updateInt(int featureId, int value, boolean fromResume) {\n        // Do nothing if the decor is not yet installed... an update will\n        // need to be forced when we eventually become active.\n        if (mContentParent == null) {\n            return;\n        }\n\n        final int featureMask = 1 << featureId;\n\n        if ((getFeatures() & featureMask) == 0 && !fromResume) {\n            return;\n        }\n\n        onIntChanged(featureId, value);\n    }\n\n    private void onIntChanged(int featureId, int value) {\n        if (featureId == Window.FEATURE_PROGRESS || featureId == Window.FEATURE_INDETERMINATE_PROGRESS) {\n            updateProgressBars(value);\n        }\n    }\n\n    private void updateProgressBars(int value) {\n        IcsProgressBar circularProgressBar = getCircularProgressBar(true);\n        IcsProgressBar horizontalProgressBar = getHorizontalProgressBar(true);\n\n        final int features = mFeatures;//getLocalFeatures();\n        if (value == Window.PROGRESS_VISIBILITY_ON) {\n            if ((features & (1 << Window.FEATURE_PROGRESS)) != 0) {\n                int level = horizontalProgressBar.getProgress();\n                int visibility = (horizontalProgressBar.isIndeterminate() || level < 10000) ?\n                        View.VISIBLE : View.INVISIBLE;\n                horizontalProgressBar.setVisibility(visibility);\n            }\n            if ((features & (1 << Window.FEATURE_INDETERMINATE_PROGRESS)) != 0) {\n                circularProgressBar.setVisibility(View.VISIBLE);\n            }\n        } else if (value == Window.PROGRESS_VISIBILITY_OFF) {\n            if ((features & (1 << Window.FEATURE_PROGRESS)) != 0) {\n                horizontalProgressBar.setVisibility(View.GONE);\n            }\n            if ((features & (1 << Window.FEATURE_INDETERMINATE_PROGRESS)) != 0) {\n                circularProgressBar.setVisibility(View.GONE);\n            }\n        } else if (value == Window.PROGRESS_INDETERMINATE_ON) {\n            horizontalProgressBar.setIndeterminate(true);\n        } else if (value == Window.PROGRESS_INDETERMINATE_OFF) {\n            horizontalProgressBar.setIndeterminate(false);\n        } else if (Window.PROGRESS_START <= value && value <= Window.PROGRESS_END) {\n            // We want to set the progress value before testing for visibility\n            // so that when the progress bar becomes visible again, it has the\n            // correct level.\n            horizontalProgressBar.setProgress(value - Window.PROGRESS_START);\n\n            if (value < Window.PROGRESS_END) {\n                showProgressBars(horizontalProgressBar, circularProgressBar);\n            } else {\n                hideProgressBars(horizontalProgressBar, circularProgressBar);\n            }\n        } else if (Window.PROGRESS_SECONDARY_START <= value && value <= Window.PROGRESS_SECONDARY_END) {\n            horizontalProgressBar.setSecondaryProgress(value - Window.PROGRESS_SECONDARY_START);\n\n            showProgressBars(horizontalProgressBar, circularProgressBar);\n        }\n    }\n\n    private void showProgressBars(IcsProgressBar horizontalProgressBar, IcsProgressBar spinnyProgressBar) {\n        final int features = mFeatures;//getLocalFeatures();\n        if ((features & (1 << Window.FEATURE_INDETERMINATE_PROGRESS)) != 0 &&\n                spinnyProgressBar.getVisibility() == View.INVISIBLE) {\n            spinnyProgressBar.setVisibility(View.VISIBLE);\n        }\n        // Only show the progress bars if the primary progress is not complete\n        if ((features & (1 << Window.FEATURE_PROGRESS)) != 0 &&\n                horizontalProgressBar.getProgress() < 10000) {\n            horizontalProgressBar.setVisibility(View.VISIBLE);\n        }\n    }\n\n    private void hideProgressBars(IcsProgressBar horizontalProgressBar, IcsProgressBar spinnyProgressBar) {\n        final int features = mFeatures;//getLocalFeatures();\n        Animation anim = AnimationUtils.loadAnimation(mActivity, android.R.anim.fade_out);\n        anim.setDuration(1000);\n        if ((features & (1 << Window.FEATURE_INDETERMINATE_PROGRESS)) != 0 &&\n                spinnyProgressBar.getVisibility() == View.VISIBLE) {\n            spinnyProgressBar.startAnimation(anim);\n            spinnyProgressBar.setVisibility(View.INVISIBLE);\n        }\n        if ((features & (1 << Window.FEATURE_PROGRESS)) != 0 &&\n                horizontalProgressBar.getVisibility() == View.VISIBLE) {\n            horizontalProgressBar.startAnimation(anim);\n            horizontalProgressBar.setVisibility(View.INVISIBLE);\n        }\n    }\n\n    private IcsProgressBar getCircularProgressBar(boolean shouldInstallDecor) {\n        if (mCircularProgressBar != null) {\n            return mCircularProgressBar;\n        }\n        if (mContentParent == null && shouldInstallDecor) {\n            installDecor();\n        }\n        mCircularProgressBar = (IcsProgressBar)mDecor.findViewById(R.id.abs__progress_circular);\n        if (mCircularProgressBar != null) {\n            mCircularProgressBar.setVisibility(View.INVISIBLE);\n        }\n        return mCircularProgressBar;\n    }\n\n    private IcsProgressBar getHorizontalProgressBar(boolean shouldInstallDecor) {\n        if (mHorizontalProgressBar != null) {\n            return mHorizontalProgressBar;\n        }\n        if (mContentParent == null && shouldInstallDecor) {\n            installDecor();\n        }\n        mHorizontalProgressBar = (IcsProgressBar)mDecor.findViewById(R.id.abs__progress_horizontal);\n        if (mHorizontalProgressBar != null) {\n            mHorizontalProgressBar.setVisibility(View.INVISIBLE);\n        }\n        return mHorizontalProgressBar;\n    }\n\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Feature management and content interaction and creation\n    ///////////////////////////////////////////////////////////////////////////\n\n    private int getFeatures() {\n        if (DEBUG) Log.d(TAG, \"[getFeatures] returning \" + mFeatures);\n\n        return mFeatures;\n    }\n\n    @Override\n    public boolean hasFeature(int featureId) {\n        if (DEBUG) Log.d(TAG, \"[hasFeature] featureId: \" + featureId);\n\n        boolean result = (mFeatures & (1 << featureId)) != 0;\n        if (DEBUG) Log.d(TAG, \"[hasFeature] returning \" + result);\n        return result;\n    }\n\n    @Override\n    public boolean requestFeature(int featureId) {\n        if (DEBUG) Log.d(TAG, \"[requestFeature] featureId: \" + featureId);\n\n        if (mContentParent != null) {\n            throw new AndroidRuntimeException(\"requestFeature() must be called before adding content\");\n        }\n\n        switch (featureId) {\n            case Window.FEATURE_ACTION_BAR:\n            case Window.FEATURE_ACTION_BAR_OVERLAY:\n            case Window.FEATURE_ACTION_MODE_OVERLAY:\n            case Window.FEATURE_INDETERMINATE_PROGRESS:\n            case Window.FEATURE_NO_TITLE:\n            case Window.FEATURE_PROGRESS:\n                mFeatures |= (1 << featureId);\n                return true;\n\n            default:\n                return false;\n        }\n    }\n\n    @Override\n    public void setUiOptions(int uiOptions) {\n        if (DEBUG) Log.d(TAG, \"[setUiOptions] uiOptions: \" + uiOptions);\n\n        mUiOptions = uiOptions;\n    }\n\n    @Override\n    public void setUiOptions(int uiOptions, int mask) {\n        if (DEBUG) Log.d(TAG, \"[setUiOptions] uiOptions: \" + uiOptions + \", mask: \" + mask);\n\n        mUiOptions = (mUiOptions & ~mask) | (uiOptions & mask);\n    }\n\n    @Override\n    public void setContentView(int layoutResId) {\n        if (DEBUG) Log.d(TAG, \"[setContentView] layoutResId: \" + layoutResId);\n\n        if (mContentParent == null) {\n            installDecor();\n        } else {\n            mContentParent.removeAllViews();\n        }\n        mActivity.getLayoutInflater().inflate(layoutResId, mContentParent);\n\n        android.view.Window.Callback callback = mActivity.getWindow().getCallback();\n        if (callback != null) {\n            callback.onContentChanged();\n        }\n\n        initActionBar();\n    }\n\n    @Override\n    public void setContentView(View view, ViewGroup.LayoutParams params) {\n        if (DEBUG) Log.d(TAG, \"[setContentView] view: \" + view + \", params: \" + params);\n\n        if (mContentParent == null) {\n            installDecor();\n        } else {\n            mContentParent.removeAllViews();\n        }\n        mContentParent.addView(view, params);\n\n        android.view.Window.Callback callback = mActivity.getWindow().getCallback();\n        if (callback != null) {\n            callback.onContentChanged();\n        }\n\n        initActionBar();\n    }\n\n    @Override\n    public void addContentView(View view, ViewGroup.LayoutParams params) {\n        if (DEBUG) Log.d(TAG, \"[addContentView] view: \" + view + \", params: \" + params);\n\n        if (mContentParent == null) {\n            installDecor();\n        }\n        mContentParent.addView(view, params);\n\n        initActionBar();\n    }\n\n    private void installDecor() {\n        if (DEBUG) Log.d(TAG, \"[installDecor]\");\n\n        if (mDecor == null) {\n            mDecor = (ViewGroup)mActivity.getWindow().getDecorView().findViewById(android.R.id.content);\n        }\n        if (mContentParent == null) {\n            //Since we are not operating at the window level we need to take\n            //into account the fact that the true decor may have already been\n            //initialized and had content attached to it. If that is the case,\n            //copy over its children to our new content container.\n            List<View> views = null;\n            if (mDecor.getChildCount() > 0) {\n                views = new ArrayList<View>(1); //Usually there's only one child\n                for (int i = 0, children = mDecor.getChildCount(); i < children; i++) {\n                    View child = mDecor.getChildAt(0);\n                    mDecor.removeView(child);\n                    views.add(child);\n                }\n            }\n\n            mContentParent = generateLayout();\n\n            //Copy over the old children. See above for explanation.\n            if (views != null) {\n                for (View child : views) {\n                    mContentParent.addView(child);\n                }\n            }\n\n            mTitleView = (TextView)mDecor.findViewById(android.R.id.title);\n            if (mTitleView != null) {\n                if (hasFeature(Window.FEATURE_NO_TITLE)) {\n                    mTitleView.setVisibility(View.GONE);\n                    if (mContentParent instanceof FrameLayout) {\n                        ((FrameLayout)mContentParent).setForeground(null);\n                    }\n                } else {\n                    mTitleView.setText(mTitle);\n                }\n            } else {\n                wActionBar = (ActionBarView)mDecor.findViewById(R.id.abs__action_bar);\n                if (wActionBar != null) {\n                    wActionBar.setWindowCallback(this);\n                    if (wActionBar.getTitle() == null) {\n                        wActionBar.setWindowTitle(mActivity.getTitle());\n                    }\n                    if (hasFeature(Window.FEATURE_PROGRESS)) {\n                        wActionBar.initProgress();\n                    }\n                    if (hasFeature(Window.FEATURE_INDETERMINATE_PROGRESS)) {\n                        wActionBar.initIndeterminateProgress();\n                    }\n\n                    //Since we don't require onCreate dispatching, parse for uiOptions here\n                    int uiOptions = loadUiOptionsFromManifest(mActivity);\n                    if (uiOptions != 0) {\n                        mUiOptions = uiOptions;\n                    }\n\n                    boolean splitActionBar = false;\n                    final boolean splitWhenNarrow = (mUiOptions & ActivityInfo.UIOPTION_SPLIT_ACTION_BAR_WHEN_NARROW) != 0;\n                    if (splitWhenNarrow) {\n                        splitActionBar = getResources_getBoolean(mActivity, R.bool.abs__split_action_bar_is_narrow);\n                    } else {\n                        splitActionBar = mActivity.getTheme()\n                                .obtainStyledAttributes(R.styleable.SherlockTheme)\n                                .getBoolean(R.styleable.SherlockTheme_windowSplitActionBar, false);\n                    }\n                    final ActionBarContainer splitView = (ActionBarContainer)mDecor.findViewById(R.id.abs__split_action_bar);\n                    if (splitView != null) {\n                        wActionBar.setSplitView(splitView);\n                        wActionBar.setSplitActionBar(splitActionBar);\n                        wActionBar.setSplitWhenNarrow(splitWhenNarrow);\n\n                        mActionModeView = (ActionBarContextView)mDecor.findViewById(R.id.abs__action_context_bar);\n                        mActionModeView.setSplitView(splitView);\n                        mActionModeView.setSplitActionBar(splitActionBar);\n                        mActionModeView.setSplitWhenNarrow(splitWhenNarrow);\n                    } else if (splitActionBar) {\n                        Log.e(TAG, \"Requested split action bar with incompatible window decor! Ignoring request.\");\n                    }\n\n                    // Post the panel invalidate for later; avoid application onCreateOptionsMenu\n                    // being called in the middle of onCreate or similar.\n                    mDecor.post(new Runnable() {\n                        @Override\n                        public void run() {\n                            //Invalidate if the panel menu hasn't been created before this.\n                            if (mMenu == null) {\n                                dispatchInvalidateOptionsMenu();\n                            }\n                        }\n                    });\n                }\n            }\n        }\n    }\n\n    private ViewGroup generateLayout() {\n        if (DEBUG) Log.d(TAG, \"[generateLayout]\");\n\n        // Apply data from current theme.\n\n        TypedArray a = mActivity.getTheme().obtainStyledAttributes(R.styleable.SherlockTheme);\n\n        mIsFloating = a.getBoolean(R.styleable.SherlockTheme_android_windowIsFloating, false);\n\n        if (!a.hasValue(R.styleable.SherlockTheme_windowActionBar)) {\n            throw new IllegalStateException(\"You must use Theme.Sherlock, Theme.Sherlock.Light, Theme.Sherlock.Light.DarkActionBar, or a derivative.\");\n        }\n\n        if (a.getBoolean(R.styleable.SherlockTheme_windowNoTitle, false)) {\n            requestFeature(Window.FEATURE_NO_TITLE);\n        } else if (a.getBoolean(R.styleable.SherlockTheme_windowActionBar, false)) {\n            // Don't allow an action bar if there is no title.\n            requestFeature(Window.FEATURE_ACTION_BAR);\n        }\n\n        if (a.getBoolean(R.styleable.SherlockTheme_windowActionBarOverlay, false)) {\n            requestFeature(Window.FEATURE_ACTION_BAR_OVERLAY);\n        }\n\n        if (a.getBoolean(R.styleable.SherlockTheme_windowActionModeOverlay, false)) {\n            requestFeature(Window.FEATURE_ACTION_MODE_OVERLAY);\n        }\n\n        a.recycle();\n\n        int layoutResource;\n        if (!hasFeature(Window.FEATURE_NO_TITLE)) {\n            if (mIsFloating) {\n                //Trash original dialog LinearLayout\n                mDecor = (ViewGroup)mDecor.getParent();\n                mDecor.removeAllViews();\n\n                layoutResource = R.layout.abs__dialog_title_holo;\n            } else {\n                if (hasFeature(Window.FEATURE_ACTION_BAR_OVERLAY)) {\n                    layoutResource = R.layout.abs__screen_action_bar_overlay;\n                } else {\n                    layoutResource = R.layout.abs__screen_action_bar;\n                }\n            }\n        } else if (hasFeature(Window.FEATURE_ACTION_MODE_OVERLAY) && !hasFeature(Window.FEATURE_NO_TITLE)) {\n            layoutResource = R.layout.abs__screen_simple_overlay_action_mode;\n        } else {\n            layoutResource = R.layout.abs__screen_simple;\n        }\n\n        if (DEBUG) Log.d(TAG, \"[generateLayout] using screen XML \" + mActivity.getResources().getString(layoutResource));\n        View in = mActivity.getLayoutInflater().inflate(layoutResource, null);\n        mDecor.addView(in, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));\n\n        ViewGroup contentParent = (ViewGroup)mDecor.findViewById(R.id.abs__content);\n        if (contentParent == null) {\n            throw new RuntimeException(\"Couldn't find content container view\");\n        }\n\n        //Make our new child the true content view (for fragments). VERY VOLATILE!\n        mDecor.setId(View.NO_ID);\n        contentParent.setId(android.R.id.content);\n\n        if (hasFeature(Window.FEATURE_INDETERMINATE_PROGRESS)) {\n            IcsProgressBar progress = getCircularProgressBar(false);\n            if (progress != null) {\n                progress.setIndeterminate(true);\n            }\n        }\n\n        return contentParent;\n    }\n\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Miscellaneous\n    ///////////////////////////////////////////////////////////////////////////\n\n    /**\n     * Determine whether or not the device has a dedicated menu key.\n     *\n     * @return {@code true} if native menu key is present.\n     */\n    private boolean isReservingOverflow() {\n        if (!mReserveOverflowSet) {\n            mReserveOverflow = ActionMenuPresenter.reserveOverflow(mActivity);\n            mReserveOverflowSet = true;\n        }\n        return mReserveOverflow;\n    }\n\n    private static int loadUiOptionsFromManifest(Activity activity) {\n        int uiOptions = 0;\n        try {\n            final String thisPackage = activity.getClass().getName();\n            if (DEBUG) Log.i(TAG, \"Parsing AndroidManifest.xml for \" + thisPackage);\n\n            final String packageName = activity.getApplicationInfo().packageName;\n            final AssetManager am = activity.createPackageContext(packageName, 0).getAssets();\n            final XmlResourceParser xml = am.openXmlResourceParser(\"AndroidManifest.xml\");\n\n            int eventType = xml.getEventType();\n            while (eventType != XmlPullParser.END_DOCUMENT) {\n                if (eventType == XmlPullParser.START_TAG) {\n                    String name = xml.getName();\n\n                    if (\"application\".equals(name)) {\n                        //Check if the <application> has the attribute\n                        if (DEBUG) Log.d(TAG, \"Got <application>\");\n\n                        for (int i = xml.getAttributeCount() - 1; i >= 0; i--) {\n                            if (DEBUG) Log.d(TAG, xml.getAttributeName(i) + \": \" + xml.getAttributeValue(i));\n\n                            if (\"uiOptions\".equals(xml.getAttributeName(i))) {\n                                uiOptions = xml.getAttributeIntValue(i, 0);\n                                break; //out of for loop\n                            }\n                        }\n                    } else if (\"activity\".equals(name)) {\n                        //Check if the <activity> is us and has the attribute\n                        if (DEBUG) Log.d(TAG, \"Got <activity>\");\n                        Integer activityUiOptions = null;\n                        String activityPackage = null;\n                        boolean isOurActivity = false;\n\n                        for (int i = xml.getAttributeCount() - 1; i >= 0; i--) {\n                            if (DEBUG) Log.d(TAG, xml.getAttributeName(i) + \": \" + xml.getAttributeValue(i));\n\n                            //We need both uiOptions and name attributes\n                            String attrName = xml.getAttributeName(i);\n                            if (\"uiOptions\".equals(attrName)) {\n                                activityUiOptions = xml.getAttributeIntValue(i, 0);\n                            } else if (\"name\".equals(attrName)) {\n                                activityPackage = cleanActivityName(packageName, xml.getAttributeValue(i));\n                                if (!thisPackage.equals(activityPackage)) {\n                                    break; //out of for loop\n                                }\n                                isOurActivity = true;\n                            }\n\n                            //Make sure we have both attributes before processing\n                            if ((activityUiOptions != null) && (activityPackage != null)) {\n                                //Our activity, uiOptions specified, override with our value\n                                uiOptions = activityUiOptions.intValue();\n                            }\n                        }\n                        if (isOurActivity) {\n                            //If we matched our activity but it had no logo don't\n                            //do any more processing of the manifest\n                            break;\n                        }\n                    }\n                }\n                eventType = xml.nextToken();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        if (DEBUG) Log.i(TAG, \"Returning \" + Integer.toHexString(uiOptions));\n        return uiOptions;\n    }\n\n    public static String cleanActivityName(String manifestPackage, String activityName) {\n        if (activityName.charAt(0) == '.') {\n            //Relative activity name (e.g., android:name=\".ui.SomeClass\")\n            return manifestPackage + activityName;\n        }\n        if (activityName.indexOf('.', 1) == -1) {\n            //Unqualified activity name (e.g., android:name=\"SomeClass\")\n            return manifestPackage + \".\" + activityName;\n        }\n        //Fully-qualified activity name (e.g., \"com.my.package.SomeClass\")\n        return activityName;\n    }\n\n    /**\n     * Clears out internal reference when the action mode is destroyed.\n     */\n    private class ActionModeCallbackWrapper implements ActionMode.Callback {\n        private final ActionMode.Callback mWrapped;\n\n        public ActionModeCallbackWrapper(ActionMode.Callback wrapped) {\n            mWrapped = wrapped;\n        }\n\n        public boolean onCreateActionMode(ActionMode mode, Menu menu) {\n            return mWrapped.onCreateActionMode(mode, menu);\n        }\n\n        public boolean onPrepareActionMode(ActionMode mode, Menu menu) {\n            return mWrapped.onPrepareActionMode(mode, menu);\n        }\n\n        public boolean onActionItemClicked(ActionMode mode, MenuItem item) {\n            return mWrapped.onActionItemClicked(mode, item);\n        }\n\n        public void onDestroyActionMode(ActionMode mode) {\n            mWrapped.onDestroyActionMode(mode);\n            if (mActionModeView != null) {\n                mActionModeView.setVisibility(View.GONE);\n                mActionModeView.removeAllViews();\n            }\n            if (mActivity instanceof OnActionModeFinishedListener) {\n                ((OnActionModeFinishedListener)mActivity).onActionModeFinished(mActionMode);\n            }\n            mActionMode = null;\n        }\n    }\n}\n","Method after Refactoring":"package com.actionbarsherlock.internal;\n\nimport static android.view.ViewGroup.LayoutParams.MATCH_PARENT;\nimport static com.actionbarsherlock.internal.ResourcesCompat.getResources_getBoolean;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport org.xmlpull.v1.XmlPullParser;\nimport android.app.Activity;\nimport android.content.Context;\nimport android.content.pm.ActivityInfo;\nimport android.content.res.AssetManager;\nimport android.content.res.Configuration;\nimport android.content.res.Resources;\nimport android.content.res.TypedArray;\nimport android.content.res.XmlResourceParser;\nimport android.os.Bundle;\nimport android.util.AndroidRuntimeException;\nimport android.util.Log;\nimport android.util.TypedValue;\nimport android.view.ContextThemeWrapper;\nimport android.view.KeyCharacterMap;\nimport android.view.KeyEvent;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.ViewStub;\nimport android.view.Window;\nimport android.view.accessibility.AccessibilityEvent;\nimport android.view.animation.Animation;\nimport android.view.animation.AnimationUtils;\nimport android.widget.FrameLayout;\nimport android.widget.TextView;\nimport com.actionbarsherlock.ActionBarSherlock;\nimport com.actionbarsherlock.R;\nimport com.actionbarsherlock.app.ActionBar;\nimport com.actionbarsherlock.internal.app.ActionBarImpl;\nimport com.actionbarsherlock.internal.view.StandaloneActionMode;\nimport com.actionbarsherlock.internal.view.menu.ActionMenuPresenter;\nimport com.actionbarsherlock.internal.view.menu.MenuBuilder;\nimport com.actionbarsherlock.internal.view.menu.MenuItemImpl;\nimport com.actionbarsherlock.internal.view.menu.MenuPresenter;\nimport com.actionbarsherlock.internal.widget.ActionBarContainer;\nimport com.actionbarsherlock.internal.widget.ActionBarContextView;\nimport com.actionbarsherlock.internal.widget.ActionBarView;\nimport com.actionbarsherlock.internal.widget.IcsProgressBar;\nimport com.actionbarsherlock.view.ActionMode;\nimport com.actionbarsherlock.view.Menu;\nimport com.actionbarsherlock.view.MenuItem;\n\n@ActionBarSherlock.Implementation(api = 7)\npublic class ActionBarSherlockCompat extends ActionBarSherlock implements MenuBuilder.Callback, com.actionbarsherlock.view.Window.Callback, MenuPresenter.Callback, android.view.MenuItem.OnMenuItemClickListener {\n    /** Window features which are enabled by default. */\n    protected static final int DEFAULT_FEATURES = 0;\n\n\n    public ActionBarSherlockCompat(Activity activity, int flags) {\n        super(activity, flags);\n    }\n\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Properties\n    ///////////////////////////////////////////////////////////////////////////\n\n    /** Whether or not the device has a dedicated menu key button. */\n    private boolean mReserveOverflow;\n    /** Lazy-load indicator for {@link #mReserveOverflow}. */\n    private boolean mReserveOverflowSet = false;\n\n    /** Current menu instance for managing action items. */\n    private MenuBuilder mMenu;\n    /** Map between native options items and sherlock items. */\n    protected HashMap<android.view.MenuItem, MenuItemImpl> mNativeItemMap;\n    /** Indication of a long-press on the hardware menu key. */\n    private boolean mMenuKeyIsLongPress = false;\n\n    /** Parent view of the window decoration (action bar, mode, etc.). */\n    private ViewGroup mDecor;\n    /** Parent view of the activity content. */\n    private ViewGroup mContentParent;\n\n    /** Whether or not the title is stable and can be displayed. */\n    private boolean mIsTitleReady = false;\n    /** Whether or not the parent activity has been destroyed. */\n    private boolean mIsDestroyed = false;\n\n    /* Emulate PanelFeatureState */\n    private boolean mClosingActionMenu;\n    private boolean mMenuIsPrepared;\n    private boolean mMenuRefreshContent;\n    private Bundle mMenuFrozenActionViewState;\n\n    /** Implementation which backs the action bar interface API. */\n    private ActionBarImpl aActionBar;\n    /** Main action bar view which displays the core content. */\n    private ActionBarView wActionBar;\n    /** Relevant window and action bar features flags. */\n    private int mFeatures = DEFAULT_FEATURES;\n    /** Relevant user interface option flags. */\n    private int mUiOptions = 0;\n\n    /** Decor indeterminate progress indicator. */\n    private IcsProgressBar mCircularProgressBar;\n    /** Decor progress indicator. */\n    private IcsProgressBar mHorizontalProgressBar;\n\n    /** Current displayed context action bar, if any. */\n    private ActionMode mActionMode;\n    /** Parent view in which the context action bar is displayed. */\n    private ActionBarContextView mActionModeView;\n\n    /** Title view used with dialogs. */\n    private TextView mTitleView;\n    /** Current activity title. */\n    private CharSequence mTitle = null;\n    /** Whether or not this \"activity\" is floating (i.e., a dialog) */\n    private boolean mIsFloating;\n\n\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Instance methods\n    ///////////////////////////////////////////////////////////////////////////\n\n    @Override\n    public ActionBar getActionBar() {\n        if (DEBUG) Log.d(TAG, \"[getActionBar]\");\n\n        initActionBar();\n        return aActionBar;\n    }\n\n    private void initActionBar() {\n        if (DEBUG) Log.d(TAG, \"[initActionBar]\");\n\n        // Initializing the window decor can change window feature flags.\n        // Make sure that we have the correct set before performing the test below.\n        if (mDecor == null) {\n            installDecor();\n        }\n\n        if ((aActionBar != null) || !hasFeature(Window.FEATURE_ACTION_BAR) || hasFeature(Window.FEATURE_NO_TITLE) || mActivity.isChild()) {\n            return;\n        }\n\n        aActionBar = new ActionBarImpl(mActivity, mFeatures);\n\n        if (!mIsDelegate) {\n            //We may never get another chance to set the title\n            wActionBar.setWindowTitle(mActivity.getTitle());\n        }\n    }\n\n    @Override\n    protected Context getThemedContext() {\n        return aActionBar.getThemedContext();\n    }\n\n    @Override\n    public void setTitle(CharSequence title) {\n        if (DEBUG) Log.d(TAG, \"[setTitle] title: \" + title);\n\n        dispatchTitleChanged(title, 0);\n    }\n\n    @Override\n    public ActionMode startActionMode(ActionMode.Callback callback) {\n        if (DEBUG) Log.d(TAG, \"[startActionMode] callback: \" + callback);\n\n        if (mActionMode != null) {\n            mActionMode.finish();\n        }\n\n        final ActionMode.Callback wrappedCallback = new ActionModeCallbackWrapper(callback);\n        ActionMode mode = null;\n\n        //Emulate Activity's onWindowStartingActionMode:\n        initActionBar();\n        if (aActionBar != null) {\n            mode = aActionBar.startActionMode(wrappedCallback);\n        }\n\n        if (mode != null) {\n            mActionMode = mode;\n        } else {\n            if (mActionModeView == null) {\n                ViewStub stub = (ViewStub)mDecor.findViewById(R.id.abs__action_mode_bar_stub);\n                if (stub != null) {\n                    mActionModeView = (ActionBarContextView)stub.inflate();\n                }\n            }\n            if (mActionModeView != null) {\n                mActionModeView.killMode();\n                mode = new StandaloneActionMode(mActivity, mActionModeView, wrappedCallback, true);\n                if (callback.onCreateActionMode(mode, mode.getMenu())) {\n                    mode.invalidate();\n                    mActionModeView.initForMode(mode);\n                    mActionModeView.setVisibility(View.VISIBLE);\n                    mActionMode = mode;\n                    mActionModeView.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);\n                } else {\n                    mActionMode = null;\n                }\n            }\n        }\n        if (mActionMode != null && mActivity instanceof OnActionModeStartedListener) {\n            ((OnActionModeStartedListener)mActivity).onActionModeStarted(mActionMode);\n        }\n        return mActionMode;\n    }\n\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Lifecycle and interaction callbacks for delegation\n    ///////////////////////////////////////////////////////////////////////////\n\n    @Override\n    public void dispatchConfigurationChanged(Configuration newConfig) {\n        if (DEBUG) Log.d(TAG, \"[dispatchConfigurationChanged] newConfig: \" + newConfig);\n\n        if (aActionBar != null) {\n            aActionBar.onConfigurationChanged(newConfig);\n        }\n    }\n\n    @Override\n    public void dispatchPostResume() {\n        if (DEBUG) Log.d(TAG, \"[dispatchPostResume]\");\n\n        if (aActionBar != null) {\n            aActionBar.setShowHideAnimationEnabled(true);\n        }\n    }\n\n    @Override\n    public void dispatchPause() {\n        if (DEBUG) Log.d(TAG, \"[dispatchPause]\");\n\n        if (wActionBar != null && wActionBar.isOverflowMenuShowing()) {\n            wActionBar.hideOverflowMenu();\n        }\n    }\n\n    @Override\n    public void dispatchStop() {\n        if (DEBUG) Log.d(TAG, \"[dispatchStop]\");\n\n        if (aActionBar != null) {\n            aActionBar.setShowHideAnimationEnabled(false);\n        }\n    }\n\n    @Override\n    public void dispatchInvalidateOptionsMenu() {\n        if (DEBUG) Log.d(TAG, \"[dispatchInvalidateOptionsMenu]\");\n\n        Bundle savedActionViewStates = null;\n        if (mMenu != null) {\n            savedActionViewStates = new Bundle();\n            mMenu.saveActionViewStates(savedActionViewStates);\n            if (savedActionViewStates.size() > 0) {\n                mMenuFrozenActionViewState = savedActionViewStates;\n            }\n            // This will be started again when the panel is prepared.\n            mMenu.stopDispatchingItemsChanged();\n            mMenu.clear();\n        }\n        mMenuRefreshContent = true;\n\n        // Prepare the options panel if we have an action bar\n        if (wActionBar != null) {\n            mMenuIsPrepared = false;\n            preparePanel();\n        }\n    }\n\n    @Override\n    public boolean dispatchOpenOptionsMenu() {\n        if (DEBUG) Log.d(TAG, \"[dispatchOpenOptionsMenu]\");\n\n        if (!isReservingOverflow()) {\n            return false;\n        }\n\n        return wActionBar.showOverflowMenu();\n    }\n\n    @Override\n    public boolean dispatchCloseOptionsMenu() {\n        if (DEBUG) Log.d(TAG, \"[dispatchCloseOptionsMenu]\");\n\n        if (!isReservingOverflow()) {\n            return false;\n        }\n\n        return wActionBar.hideOverflowMenu();\n    }\n\n    @Override\n    public void dispatchPostCreate(Bundle savedInstanceState) {\n        if (DEBUG) Log.d(TAG, \"[dispatchOnPostCreate]\");\n\n        if (mIsDelegate) {\n            mIsTitleReady = true;\n        }\n\n        if (mDecor == null) {\n            initActionBar();\n        }\n    }\n\n    @Override\n    public boolean dispatchCreateOptionsMenu(android.view.Menu menu) {\n        if (DEBUG) {\n            Log.d(TAG, \"[dispatchCreateOptionsMenu] android.view.Menu: \" + menu);\n            Log.d(TAG, \"[dispatchCreateOptionsMenu] returning true\");\n        }\n        return true;\n    }\n\n    @Override\n    public boolean dispatchPrepareOptionsMenu(android.view.Menu menu) {\n        if (DEBUG) Log.d(TAG, \"[dispatchPrepareOptionsMenu] android.view.Menu: \" + menu);\n\n        if (mActionMode != null) {\n            return false;\n        }\n\n        mMenuIsPrepared = false;\n        if (!preparePanel()) {\n            return false;\n        }\n\n        if (isReservingOverflow()) {\n            return false;\n        }\n\n        if (mNativeItemMap == null) {\n            mNativeItemMap = new HashMap<android.view.MenuItem, MenuItemImpl>();\n        } else {\n            mNativeItemMap.clear();\n        }\n\n        if (mMenu == null) {\n            return false;\n        }\n\n        boolean result = mMenu.bindNativeOverflow(menu, this, mNativeItemMap);\n        if (DEBUG) Log.d(TAG, \"[dispatchPrepareOptionsMenu] returning \" + result);\n        return result;\n    }\n\n    @Override\n    public boolean dispatchOptionsItemSelected(android.view.MenuItem item) {\n        throw new IllegalStateException(\"Native callback invoked. Create a test case and report!\");\n    }\n\n    @Override\n    public boolean dispatchMenuOpened(int featureId, android.view.Menu menu) {\n        if (DEBUG) Log.d(TAG, \"[dispatchMenuOpened] featureId: \" + featureId + \", menu: \" + menu);\n\n        if (featureId == Window.FEATURE_ACTION_BAR || featureId == Window.FEATURE_OPTIONS_PANEL) {\n            if (aActionBar != null) {\n                aActionBar.dispatchMenuVisibilityChanged(true);\n            }\n            return true;\n        }\n\n        return false;\n    }\n\n    @Override\n    public void dispatchPanelClosed(int featureId, android.view.Menu menu){\n        if (DEBUG) Log.d(TAG, \"[dispatchPanelClosed] featureId: \" + featureId + \", menu: \" + menu);\n\n        if (featureId == Window.FEATURE_ACTION_BAR || featureId == Window.FEATURE_OPTIONS_PANEL) {\n            if (aActionBar != null) {\n                aActionBar.dispatchMenuVisibilityChanged(false);\n            }\n        }\n    }\n\n    @Override\n    public void dispatchTitleChanged(CharSequence title, int color) {\n        if (DEBUG) Log.d(TAG, \"[dispatchTitleChanged] title: \" + title + \", color: \" + color);\n\n        if (!mIsDelegate || mIsTitleReady) {\n            if (mTitleView != null) {\n                mTitleView.setText(title);\n            } else if (wActionBar != null) {\n                wActionBar.setWindowTitle(title);\n            }\n        }\n\n        mTitle = title;\n    }\n\n    @Override\n    public boolean dispatchKeyEvent(KeyEvent event) {\n        if (DEBUG) Log.d(TAG, \"[dispatchKeyEvent] event: \" + event);\n\n        final int keyCode = event.getKeyCode();\n\n        // Not handled by the view hierarchy, does the action bar want it\n        // to cancel out of something special?\n        if (keyCode == KeyEvent.KEYCODE_BACK) {\n            final int action = event.getAction();\n            // Back cancels action modes first.\n            if (mActionMode != null) {\n                if (action == KeyEvent.ACTION_UP) {\n                    mActionMode.finish();\n                }\n                if (DEBUG) Log.d(TAG, \"[dispatchKeyEvent] returning true\");\n                return true;\n            }\n\n            // Next collapse any expanded action views.\n            if (wActionBar != null && wActionBar.hasExpandedActionView()) {\n                if (action == KeyEvent.ACTION_UP) {\n                    wActionBar.collapseActionView();\n                }\n                if (DEBUG) Log.d(TAG, \"[dispatchKeyEvent] returning true\");\n                return true;\n            }\n        }\n\n        boolean result = false;\n        if (keyCode == KeyEvent.KEYCODE_MENU && isReservingOverflow()) {\n            if (event.getAction() == KeyEvent.ACTION_DOWN && event.isLongPress()) {\n                mMenuKeyIsLongPress = true;\n            } else if (event.getAction() == KeyEvent.ACTION_UP) {\n                if (!mMenuKeyIsLongPress) {\n                    if (mActionMode == null && wActionBar != null) {\n                        if (wActionBar.isOverflowMenuShowing()) {\n                            wActionBar.hideOverflowMenu();\n                        } else {\n                            wActionBar.showOverflowMenu();\n                        }\n                    }\n                    result = true;\n                }\n                mMenuKeyIsLongPress = false;\n            }\n        }\n\n        if (DEBUG) Log.d(TAG, \"[dispatchKeyEvent] returning \" + result);\n        return result;\n    }\n\n    @Override\n    public void dispatchDestroy() {\n        mIsDestroyed = true;\n    }\n\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Menu callback lifecycle and creation\n    ///////////////////////////////////////////////////////////////////////////\n\n    private boolean preparePanel() {\n        // Already prepared (isPrepared will be reset to false later)\n        if (mMenuIsPrepared) {\n            return true;\n        }\n\n        // Init the panel state's menu--return false if init failed\n        if (mMenu == null || mMenuRefreshContent) {\n            if (mMenu == null) {\n                if (!initializePanelMenu() || (mMenu == null)) {\n                    return false;\n                }\n            }\n\n            if (wActionBar != null) {\n                wActionBar.setMenu(mMenu, this);\n            }\n\n            // Call callback, and return if it doesn't want to display menu.\n\n            // Creating the panel menu will involve a lot of manipulation;\n            // don't dispatch change events to presenters until we're done.\n            mMenu.stopDispatchingItemsChanged();\n            if (!callbackCreateOptionsMenu(mMenu)) {\n                // Ditch the menu created above\n                mMenu = null;\n\n                if (wActionBar != null) {\n                    // Don't show it in the action bar either\n                    wActionBar.setMenu(null, this);\n                }\n\n                return false;\n            }\n\n            mMenuRefreshContent = false;\n        }\n\n        // Callback and return if the callback does not want to show the menu\n\n        // Preparing the panel menu can involve a lot of manipulation;\n        // don't dispatch change events to presenters until we're done.\n        mMenu.stopDispatchingItemsChanged();\n\n        // Restore action view state before we prepare. This gives apps\n        // an opportunity to override frozen/restored state in onPrepare.\n        if (mMenuFrozenActionViewState != null) {\n            mMenu.restoreActionViewStates(mMenuFrozenActionViewState);\n            mMenuFrozenActionViewState = null;\n        }\n\n        if (!callbackPrepareOptionsMenu(mMenu)) {\n            if (wActionBar != null) {\n                // The app didn't want to show the menu for now but it still exists.\n                // Clear it out of the action bar.\n                wActionBar.setMenu(null, this);\n            }\n            mMenu.startDispatchingItemsChanged();\n            return false;\n        }\n\n        // Set the proper keymap\n        KeyCharacterMap kmap = KeyCharacterMap.load(KeyCharacterMap.VIRTUAL_KEYBOARD);\n        mMenu.setQwertyMode(kmap.getKeyboardType() != KeyCharacterMap.NUMERIC);\n        mMenu.startDispatchingItemsChanged();\n\n        // Set other state\n        mMenuIsPrepared = true;\n\n        return true;\n    }\n\n    public boolean onMenuItemSelected(MenuBuilder menu, MenuItem item) {\n        return callbackOptionsItemSelected(item);\n    }\n\n    public void onMenuModeChange(MenuBuilder menu) {\n        reopenMenu(true);\n    }\n\n    private void reopenMenu(boolean toggleMenuMode) {\n        if (wActionBar != null && wActionBar.isOverflowReserved()) {\n            if (!wActionBar.isOverflowMenuShowing() || !toggleMenuMode) {\n                if (wActionBar.getVisibility() == View.VISIBLE) {\n                    if (callbackPrepareOptionsMenu(mMenu)) {\n                        wActionBar.showOverflowMenu();\n                    }\n                }\n            } else {\n                wActionBar.hideOverflowMenu();\n            }\n            return;\n        }\n    }\n\n    private boolean initializePanelMenu() {\n        Context context = mActivity;//getContext();\n\n        // If we have an action bar, initialize the menu with a context themed for it.\n        if (wActionBar != null) {\n            TypedValue outValue = new TypedValue();\n            Resources.Theme currentTheme = context.getTheme();\n            currentTheme.resolveAttribute(R.attr.actionBarWidgetTheme,\n                    outValue, true);\n            final int targetThemeRes = outValue.resourceId;\n\n            if (targetThemeRes != 0 /*&& context.getThemeResId() != targetThemeRes*/) {\n                context = new ContextThemeWrapper(context, targetThemeRes);\n            }\n        }\n\n        mMenu = new MenuBuilder(context);\n        mMenu.setCallback(this);\n\n        return true;\n    }\n\n    void checkCloseActionMenu(Menu menu) {\n        if (mClosingActionMenu) {\n            return;\n        }\n\n        mClosingActionMenu = true;\n        wActionBar.dismissPopupMenus();\n        //Callback cb = getCallback();\n        //if (cb != null && !isDestroyed()) {\n        //    cb.onPanelClosed(FEATURE_ACTION_BAR, menu);\n        //}\n        mClosingActionMenu = false;\n    }\n\n    @Override\n    public boolean onOpenSubMenu(MenuBuilder subMenu) {\n        return true;\n    }\n\n    @Override\n    public void onCloseMenu(MenuBuilder menu, boolean allMenusAreClosing) {\n        checkCloseActionMenu(menu);\n    }\n\n    @Override\n    public boolean onMenuItemClick(android.view.MenuItem item) {\n        if (DEBUG) Log.d(TAG, \"[mNativeItemListener.onMenuItemClick] item: \" + item);\n\n        final MenuItemImpl sherlockItem = mNativeItemMap.get(item);\n        if (sherlockItem != null) {\n            sherlockItem.invoke();\n        } else {\n            Log.e(TAG, \"Options item \\\"\" + item + \"\\\" not found in mapping\");\n        }\n\n        return true; //Do not allow continuation of native handling\n    }\n\n    @Override\n    public boolean onMenuItemSelected(int featureId, MenuItem item) {\n        return callbackOptionsItemSelected(item);\n    }\n\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Progress bar interaction and internal handling\n    ///////////////////////////////////////////////////////////////////////////\n\n    @Override\n    public void setProgressBarVisibility(boolean visible) {\n        if (DEBUG) Log.d(TAG, \"[setProgressBarVisibility] visible: \" + visible);\n\n        setFeatureInt(Window.FEATURE_PROGRESS, visible ? Window.PROGRESS_VISIBILITY_ON :\n            Window.PROGRESS_VISIBILITY_OFF);\n    }\n\n    @Override\n    public void setProgressBarIndeterminateVisibility(boolean visible) {\n        if (DEBUG) Log.d(TAG, \"[setProgressBarIndeterminateVisibility] visible: \" + visible);\n\n        setFeatureInt(Window.FEATURE_INDETERMINATE_PROGRESS,\n                visible ? Window.PROGRESS_VISIBILITY_ON : Window.PROGRESS_VISIBILITY_OFF);\n    }\n\n    @Override\n    public void setProgressBarIndeterminate(boolean indeterminate) {\n        if (DEBUG) Log.d(TAG, \"[setProgressBarIndeterminate] indeterminate: \" + indeterminate);\n\n        setFeatureInt(Window.FEATURE_PROGRESS,\n                indeterminate ? Window.PROGRESS_INDETERMINATE_ON : Window.PROGRESS_INDETERMINATE_OFF);\n    }\n\n    @Override\n    public void setProgress(int progress) {\n        if (DEBUG) Log.d(TAG, \"[setProgress] progress: \" + progress);\n\n        setFeatureInt(Window.FEATURE_PROGRESS, progress + Window.PROGRESS_START);\n    }\n\n    @Override\n    public void setSecondaryProgress(int secondaryProgress) {\n        if (DEBUG) Log.d(TAG, \"[setSecondaryProgress] secondaryProgress: \" + secondaryProgress);\n\n        setFeatureInt(Window.FEATURE_PROGRESS,\n                secondaryProgress + Window.PROGRESS_SECONDARY_START);\n    }\n\n    private void setFeatureInt(int featureId, int value) {\n        updateInt(featureId, value, false);\n    }\n\n    private void updateInt(int featureId, int value, boolean fromResume) {\n        // Do nothing if the decor is not yet installed... an update will\n        // need to be forced when we eventually become active.\n        if (mContentParent == null) {\n            return;\n        }\n\n        final int featureMask = 1 << featureId;\n\n        if ((getFeatures() & featureMask) == 0 && !fromResume) {\n            return;\n        }\n\n        onIntChanged(featureId, value);\n    }\n\n    private void onIntChanged(int featureId, int value) {\n        if (featureId == Window.FEATURE_PROGRESS || featureId == Window.FEATURE_INDETERMINATE_PROGRESS) {\n            updateProgressBars(value);\n        }\n    }\n\n    private void updateProgressBars(int value) {\n        IcsProgressBar circularProgressBar = getCircularProgressBar(true);\n        IcsProgressBar horizontalProgressBar = getHorizontalProgressBar(true);\n\n        final int features = mFeatures;//getLocalFeatures();\n        if (value == Window.PROGRESS_VISIBILITY_ON) {\n            if ((features & (1 << Window.FEATURE_PROGRESS)) != 0) {\n                int level = horizontalProgressBar.getProgress();\n                int visibility = (horizontalProgressBar.isIndeterminate() || level < 10000) ?\n                        View.VISIBLE : View.INVISIBLE;\n                horizontalProgressBar.setVisibility(visibility);\n            }\n            if ((features & (1 << Window.FEATURE_INDETERMINATE_PROGRESS)) != 0) {\n                circularProgressBar.setVisibility(View.VISIBLE);\n            }\n        } else if (value == Window.PROGRESS_VISIBILITY_OFF) {\n            if ((features & (1 << Window.FEATURE_PROGRESS)) != 0) {\n                horizontalProgressBar.setVisibility(View.GONE);\n            }\n            if ((features & (1 << Window.FEATURE_INDETERMINATE_PROGRESS)) != 0) {\n                circularProgressBar.setVisibility(View.GONE);\n            }\n        } else if (value == Window.PROGRESS_INDETERMINATE_ON) {\n            horizontalProgressBar.setIndeterminate(true);\n        } else if (value == Window.PROGRESS_INDETERMINATE_OFF) {\n            horizontalProgressBar.setIndeterminate(false);\n        } else if (Window.PROGRESS_START <= value && value <= Window.PROGRESS_END) {\n            // We want to set the progress value before testing for visibility\n            // so that when the progress bar becomes visible again, it has the\n            // correct level.\n            horizontalProgressBar.setProgress(value - Window.PROGRESS_START);\n\n            if (value < Window.PROGRESS_END) {\n                showProgressBars(horizontalProgressBar, circularProgressBar);\n            } else {\n                hideProgressBars(horizontalProgressBar, circularProgressBar);\n            }\n        } else if (Window.PROGRESS_SECONDARY_START <= value && value <= Window.PROGRESS_SECONDARY_END) {\n            horizontalProgressBar.setSecondaryProgress(value - Window.PROGRESS_SECONDARY_START);\n\n            showProgressBars(horizontalProgressBar, circularProgressBar);\n        }\n    }\n\n    private void showProgressBars(IcsProgressBar horizontalProgressBar, IcsProgressBar spinnyProgressBar) {\n        final int features = mFeatures;//getLocalFeatures();\n        if ((features & (1 << Window.FEATURE_INDETERMINATE_PROGRESS)) != 0 &&\n                spinnyProgressBar.getVisibility() == View.INVISIBLE) {\n            spinnyProgressBar.setVisibility(View.VISIBLE);\n        }\n        // Only show the progress bars if the primary progress is not complete\n        if ((features & (1 << Window.FEATURE_PROGRESS)) != 0 &&\n                horizontalProgressBar.getProgress() < 10000) {\n            horizontalProgressBar.setVisibility(View.VISIBLE);\n        }\n    }\n\n    private void hideProgressBars(IcsProgressBar horizontalProgressBar, IcsProgressBar spinnyProgressBar) {\n        final int features = mFeatures;//getLocalFeatures();\n        Animation anim = AnimationUtils.loadAnimation(mActivity, android.R.anim.fade_out);\n        anim.setDuration(1000);\n        if ((features & (1 << Window.FEATURE_INDETERMINATE_PROGRESS)) != 0 &&\n                spinnyProgressBar.getVisibility() == View.VISIBLE) {\n            spinnyProgressBar.startAnimation(anim);\n            spinnyProgressBar.setVisibility(View.INVISIBLE);\n        }\n        if ((features & (1 << Window.FEATURE_PROGRESS)) != 0 &&\n                horizontalProgressBar.getVisibility() == View.VISIBLE) {\n            horizontalProgressBar.startAnimation(anim);\n            horizontalProgressBar.setVisibility(View.INVISIBLE);\n        }\n    }\n\n    private IcsProgressBar getCircularProgressBar(boolean shouldInstallDecor) {\n        if (mCircularProgressBar != null) {\n            return mCircularProgressBar;\n        }\n        if (mContentParent == null && shouldInstallDecor) {\n            installDecor();\n        }\n        mCircularProgressBar = (IcsProgressBar)mDecor.findViewById(R.id.abs__progress_circular);\n        if (mCircularProgressBar != null) {\n            mCircularProgressBar.setVisibility(View.INVISIBLE);\n        }\n        return mCircularProgressBar;\n    }\n\n    private IcsProgressBar getHorizontalProgressBar(boolean shouldInstallDecor) {\n        if (mHorizontalProgressBar != null) {\n            return mHorizontalProgressBar;\n        }\n        if (mContentParent == null && shouldInstallDecor) {\n            installDecor();\n        }\n        mHorizontalProgressBar = (IcsProgressBar)mDecor.findViewById(R.id.abs__progress_horizontal);\n        if (mHorizontalProgressBar != null) {\n            mHorizontalProgressBar.setVisibility(View.INVISIBLE);\n        }\n        return mHorizontalProgressBar;\n    }\n\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Feature management and content interaction and creation\n    ///////////////////////////////////////////////////////////////////////////\n\n    private int getFeatures() {\n        if (DEBUG) Log.d(TAG, \"[getFeatures] returning \" + mFeatures);\n\n        return mFeatures;\n    }\n\n    @Override\n    public boolean hasFeature(int featureId) {\n        if (DEBUG) Log.d(TAG, \"[hasFeature] featureId: \" + featureId);\n\n        boolean result = (mFeatures & (1 << featureId)) != 0;\n        if (DEBUG) Log.d(TAG, \"[hasFeature] returning \" + result);\n        return result;\n    }\n\n    @Override\n    public boolean requestFeature(int featureId) {\n        if (DEBUG) Log.d(TAG, \"[requestFeature] featureId: \" + featureId);\n\n        if (mContentParent != null) {\n            throw new AndroidRuntimeException(\"requestFeature() must be called before adding content\");\n        }\n\n        switch (featureId) {\n            case Window.FEATURE_ACTION_BAR:\n            case Window.FEATURE_ACTION_BAR_OVERLAY:\n            case Window.FEATURE_ACTION_MODE_OVERLAY:\n            case Window.FEATURE_INDETERMINATE_PROGRESS:\n            case Window.FEATURE_NO_TITLE:\n            case Window.FEATURE_PROGRESS:\n                mFeatures |= (1 << featureId);\n                return true;\n\n            default:\n                return false;\n        }\n    }\n\n    @Override\n    public void setUiOptions(int uiOptions) {\n        if (DEBUG) Log.d(TAG, \"[setUiOptions] uiOptions: \" + uiOptions);\n\n        mUiOptions = uiOptions;\n    }\n\n    @Override\n    public void setUiOptions(int uiOptions, int mask) {\n        if (DEBUG) Log.d(TAG, \"[setUiOptions] uiOptions: \" + uiOptions + \", mask: \" + mask);\n\n        mUiOptions = (mUiOptions & ~mask) | (uiOptions & mask);\n    }\n\n    @Override\n    public void setContentView(int layoutResId) {\n        if (DEBUG) Log.d(TAG, \"[setContentView] layoutResId: \" + layoutResId);\n\n        if (mContentParent == null) {\n            installDecor();\n        } else {\n            mContentParent.removeAllViews();\n        }\n        mActivity.getLayoutInflater().inflate(layoutResId, mContentParent);\n\n        android.view.Window.Callback callback = mActivity.getWindow().getCallback();\n        if (callback != null) {\n            callback.onContentChanged();\n        }\n\n        initActionBar();\n    }\n\n    @Override\n    public void setContentView(View view, ViewGroup.LayoutParams params) {\n        if (DEBUG) Log.d(TAG, \"[setContentView] view: \" + view + \", params: \" + params);\n\n        if (mContentParent == null) {\n            installDecor();\n        } else {\n            mContentParent.removeAllViews();\n        }\n        mContentParent.addView(view, params);\n\n        android.view.Window.Callback callback = mActivity.getWindow().getCallback();\n        if (callback != null) {\n            callback.onContentChanged();\n        }\n\n        initActionBar();\n    }\n\n    @Override\n    public void addContentView(View view, ViewGroup.LayoutParams params) {\n        if (DEBUG) Log.d(TAG, \"[addContentView] view: \" + view + \", params: \" + params);\n\n        if (mContentParent == null) {\n            installDecor();\n        }\n        mContentParent.addView(view, params);\n\n        initActionBar();\n    }\n\n    private void installDecor() {\n        if (DEBUG) Log.d(TAG, \"[installDecor]\");\n\n        if (mDecor == null) {\n            mDecor = (ViewGroup)mActivity.getWindow().getDecorView().findViewById(android.R.id.content);\n        }\n        if (mContentParent == null) {\n            //Since we are not operating at the window level we need to take\n            //into account the fact that the true decor may have already been\n            //initialized and had content attached to it. If that is the case,\n            //copy over its children to our new content container.\n            List<View> views = null;\n            if (mDecor.getChildCount() > 0) {\n                views = new ArrayList<View>(1); //Usually there's only one child\n                for (int i = 0, children = mDecor.getChildCount(); i < children; i++) {\n                    View child = mDecor.getChildAt(0);\n                    mDecor.removeView(child);\n                    views.add(child);\n                }\n            }\n\n            mContentParent = generateLayout();\n\n            //Copy over the old children. See above for explanation.\n            if (views != null) {\n                for (View child : views) {\n                    mContentParent.addView(child);\n                }\n            }\n\n            mTitleView = (TextView)mDecor.findViewById(android.R.id.title);\n            if (mTitleView != null) {\n                if (hasFeature(Window.FEATURE_NO_TITLE)) {\n                    mTitleView.setVisibility(View.GONE);\n                    if (mContentParent instanceof FrameLayout) {\n                        ((FrameLayout)mContentParent).setForeground(null);\n                    }\n                } else {\n                    mTitleView.setText(mTitle);\n                }\n            } else {\n                wActionBar = (ActionBarView)mDecor.findViewById(R.id.abs__action_bar);\n                if (wActionBar != null) {\n                    wActionBar.setWindowCallback(this);\n                    if (wActionBar.getTitle() == null) {\n                        wActionBar.setWindowTitle(mActivity.getTitle());\n                    }\n                    if (hasFeature(Window.FEATURE_PROGRESS)) {\n                        wActionBar.initProgress();\n                    }\n                    if (hasFeature(Window.FEATURE_INDETERMINATE_PROGRESS)) {\n                        wActionBar.initIndeterminateProgress();\n                    }\n\n                    //Since we don't require onCreate dispatching, parse for uiOptions here\n                    int uiOptions = loadUiOptionsFromManifest(mActivity);\n                    if (uiOptions != 0) {\n                        mUiOptions = uiOptions;\n                    }\n\n                    boolean splitActionBar = false;\n                    final boolean splitWhenNarrow = (mUiOptions & ActivityInfo.UIOPTION_SPLIT_ACTION_BAR_WHEN_NARROW) != 0;\n                    if (splitWhenNarrow) {\n                        splitActionBar = getResources_getBoolean(mActivity, R.bool.abs__split_action_bar_is_narrow);\n                    } else {\n                        splitActionBar = mActivity.getTheme()\n                                .obtainStyledAttributes(R.styleable.SherlockTheme)\n                                .getBoolean(R.styleable.SherlockTheme_windowSplitActionBar, false);\n                    }\n                    final ActionBarContainer splitView = (ActionBarContainer)mDecor.findViewById(R.id.abs__split_action_bar);\n                    if (splitView != null) {\n                        wActionBar.setSplitView(splitView);\n                        wActionBar.setSplitActionBar(splitActionBar);\n                        wActionBar.setSplitWhenNarrow(splitWhenNarrow);\n\n                        mActionModeView = (ActionBarContextView)mDecor.findViewById(R.id.abs__action_context_bar);\n                        mActionModeView.setSplitView(splitView);\n                        mActionModeView.setSplitActionBar(splitActionBar);\n                        mActionModeView.setSplitWhenNarrow(splitWhenNarrow);\n                    } else if (splitActionBar) {\n                        Log.e(TAG, \"Requested split action bar with incompatible window decor! Ignoring request.\");\n                    }\n\n                    // Post the panel invalidate for later; avoid application onCreateOptionsMenu\n                    // being called in the middle of onCreate or similar.\n                    mDecor.post(new Runnable() {\n                        @Override\n                        public void run() {\n                            //Invalidate if the panel menu hasn't been created before this.\n                            if (!mIsDestroyed && !mActivity.isFinishing() && mMenu == null) {\n                                dispatchInvalidateOptionsMenu();\n                            }\n                        }\n                    });\n                }\n            }\n        }\n    }\n\n    private ViewGroup generateLayout() {\n        if (DEBUG) Log.d(TAG, \"[generateLayout]\");\n\n        // Apply data from current theme.\n\n        TypedArray a = mActivity.getTheme().obtainStyledAttributes(R.styleable.SherlockTheme);\n\n        mIsFloating = a.getBoolean(R.styleable.SherlockTheme_android_windowIsFloating, false);\n\n        if (!a.hasValue(R.styleable.SherlockTheme_windowActionBar)) {\n            throw new IllegalStateException(\"You must use Theme.Sherlock, Theme.Sherlock.Light, Theme.Sherlock.Light.DarkActionBar, or a derivative.\");\n        }\n\n        if (a.getBoolean(R.styleable.SherlockTheme_windowNoTitle, false)) {\n            requestFeature(Window.FEATURE_NO_TITLE);\n        } else if (a.getBoolean(R.styleable.SherlockTheme_windowActionBar, false)) {\n            // Don't allow an action bar if there is no title.\n            requestFeature(Window.FEATURE_ACTION_BAR);\n        }\n\n        if (a.getBoolean(R.styleable.SherlockTheme_windowActionBarOverlay, false)) {\n            requestFeature(Window.FEATURE_ACTION_BAR_OVERLAY);\n        }\n\n        if (a.getBoolean(R.styleable.SherlockTheme_windowActionModeOverlay, false)) {\n            requestFeature(Window.FEATURE_ACTION_MODE_OVERLAY);\n        }\n\n        a.recycle();\n\n        int layoutResource;\n        if (!hasFeature(Window.FEATURE_NO_TITLE)) {\n            if (mIsFloating) {\n                //Trash original dialog LinearLayout\n                mDecor = (ViewGroup)mDecor.getParent();\n                mDecor.removeAllViews();\n\n                layoutResource = R.layout.abs__dialog_title_holo;\n            } else {\n                if (hasFeature(Window.FEATURE_ACTION_BAR_OVERLAY)) {\n                    layoutResource = R.layout.abs__screen_action_bar_overlay;\n                } else {\n                    layoutResource = R.layout.abs__screen_action_bar;\n                }\n            }\n        } else if (hasFeature(Window.FEATURE_ACTION_MODE_OVERLAY) && !hasFeature(Window.FEATURE_NO_TITLE)) {\n            layoutResource = R.layout.abs__screen_simple_overlay_action_mode;\n        } else {\n            layoutResource = R.layout.abs__screen_simple;\n        }\n\n        if (DEBUG) Log.d(TAG, \"[generateLayout] using screen XML \" + mActivity.getResources().getString(layoutResource));\n        View in = mActivity.getLayoutInflater().inflate(layoutResource, null);\n        mDecor.addView(in, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));\n\n        ViewGroup contentParent = (ViewGroup)mDecor.findViewById(R.id.abs__content);\n        if (contentParent == null) {\n            throw new RuntimeException(\"Couldn't find content container view\");\n        }\n\n        //Make our new child the true content view (for fragments). VERY VOLATILE!\n        mDecor.setId(View.NO_ID);\n        contentParent.setId(android.R.id.content);\n\n        if (hasFeature(Window.FEATURE_INDETERMINATE_PROGRESS)) {\n            IcsProgressBar progress = getCircularProgressBar(false);\n            if (progress != null) {\n                progress.setIndeterminate(true);\n            }\n        }\n\n        return contentParent;\n    }\n\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Miscellaneous\n    ///////////////////////////////////////////////////////////////////////////\n\n    /**\n     * Determine whether or not the device has a dedicated menu key.\n     *\n     * @return {@code true} if native menu key is present.\n     */\n    private boolean isReservingOverflow() {\n        if (!mReserveOverflowSet) {\n            mReserveOverflow = ActionMenuPresenter.reserveOverflow(mActivity);\n            mReserveOverflowSet = true;\n        }\n        return mReserveOverflow;\n    }\n\n    private static int loadUiOptionsFromManifest(Activity activity) {\n        int uiOptions = 0;\n        try {\n            final String thisPackage = activity.getClass().getName();\n            if (DEBUG) Log.i(TAG, \"Parsing AndroidManifest.xml for \" + thisPackage);\n\n            final String packageName = activity.getApplicationInfo().packageName;\n            final AssetManager am = activity.createPackageContext(packageName, 0).getAssets();\n            final XmlResourceParser xml = am.openXmlResourceParser(\"AndroidManifest.xml\");\n\n            int eventType = xml.getEventType();\n            while (eventType != XmlPullParser.END_DOCUMENT) {\n                if (eventType == XmlPullParser.START_TAG) {\n                    String name = xml.getName();\n\n                    if (\"application\".equals(name)) {\n                        //Check if the <application> has the attribute\n                        if (DEBUG) Log.d(TAG, \"Got <application>\");\n\n                        for (int i = xml.getAttributeCount() - 1; i >= 0; i--) {\n                            if (DEBUG) Log.d(TAG, xml.getAttributeName(i) + \": \" + xml.getAttributeValue(i));\n\n                            if (\"uiOptions\".equals(xml.getAttributeName(i))) {\n                                uiOptions = xml.getAttributeIntValue(i, 0);\n                                break; //out of for loop\n                            }\n                        }\n                    } else if (\"activity\".equals(name)) {\n                        //Check if the <activity> is us and has the attribute\n                        if (DEBUG) Log.d(TAG, \"Got <activity>\");\n                        Integer activityUiOptions = null;\n                        String activityPackage = null;\n                        boolean isOurActivity = false;\n\n                        for (int i = xml.getAttributeCount() - 1; i >= 0; i--) {\n                            if (DEBUG) Log.d(TAG, xml.getAttributeName(i) + \": \" + xml.getAttributeValue(i));\n\n                            //We need both uiOptions and name attributes\n                            String attrName = xml.getAttributeName(i);\n                            if (\"uiOptions\".equals(attrName)) {\n                                activityUiOptions = xml.getAttributeIntValue(i, 0);\n                            } else if (\"name\".equals(attrName)) {\n                                activityPackage = cleanActivityName(packageName, xml.getAttributeValue(i));\n                                if (!thisPackage.equals(activityPackage)) {\n                                    break; //out of for loop\n                                }\n                                isOurActivity = true;\n                            }\n\n                            //Make sure we have both attributes before processing\n                            if ((activityUiOptions != null) && (activityPackage != null)) {\n                                //Our activity, uiOptions specified, override with our value\n                                uiOptions = activityUiOptions.intValue();\n                            }\n                        }\n                        if (isOurActivity) {\n                            //If we matched our activity but it had no logo don't\n                            //do any more processing of the manifest\n                            break;\n                        }\n                    }\n                }\n                eventType = xml.nextToken();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        if (DEBUG) Log.i(TAG, \"Returning \" + Integer.toHexString(uiOptions));\n        return uiOptions;\n    }\n\n    public static String cleanActivityName(String manifestPackage, String activityName) {\n        if (activityName.charAt(0) == '.') {\n            //Relative activity name (e.g., android:name=\".ui.SomeClass\")\n            return manifestPackage + activityName;\n        }\n        if (activityName.indexOf('.', 1) == -1) {\n            //Unqualified activity name (e.g., android:name=\"SomeClass\")\n            return manifestPackage + \".\" + activityName;\n        }\n        //Fully-qualified activity name (e.g., \"com.my.package.SomeClass\")\n        return activityName;\n    }\n\n    /**\n     * Clears out internal reference when the action mode is destroyed.\n     */\n    private class ActionModeCallbackWrapper implements ActionMode.Callback {\n        private final ActionMode.Callback mWrapped;\n\n        public ActionModeCallbackWrapper(ActionMode.Callback wrapped) {\n            mWrapped = wrapped;\n        }\n\n        public boolean onCreateActionMode(ActionMode mode, Menu menu) {\n            return mWrapped.onCreateActionMode(mode, menu);\n        }\n\n        public boolean onPrepareActionMode(ActionMode mode, Menu menu) {\n            return mWrapped.onPrepareActionMode(mode, menu);\n        }\n\n        public boolean onActionItemClicked(ActionMode mode, MenuItem item) {\n            return mWrapped.onActionItemClicked(mode, item);\n        }\n\n        public void onDestroyActionMode(ActionMode mode) {\n            mWrapped.onDestroyActionMode(mode);\n            if (mActionModeView != null) {\n                mActionModeView.setVisibility(View.GONE);\n                mActionModeView.removeAllViews();\n            }\n            if (mActivity instanceof OnActionModeFinishedListener) {\n                ((OnActionModeFinishedListener)mActivity).onActionModeFinished(mActionMode);\n            }\n            mActionMode = null;\n        }\n    }\n}\n","lineNo":427}
{"Smelly Sample":"/*\n * Copyright (C) 2011 Jake Wharton\n * Copyright (C) 2011 Patrik Akerfeldt\n * Copyright (C) 2011 Francisco Figueiredo Jr.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.viewpagerindicator;\n\nimport java.util.ArrayList;\nimport android.content.Context;\nimport android.content.res.Resources;\nimport android.content.res.TypedArray;\nimport android.graphics.Canvas;\nimport android.graphics.Paint;\nimport android.graphics.Path;\nimport android.graphics.RectF;\nimport android.graphics.Typeface;\nimport android.os.Parcel;\nimport android.os.Parcelable;\nimport android.support.v4.view.MotionEventCompat;\nimport android.support.v4.view.PagerAdapter;\nimport android.support.v4.view.ViewConfigurationCompat;\nimport android.support.v4.view.ViewPager;\nimport android.util.AttributeSet;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.view.ViewConfiguration;\n\n/**\n * A TitlePageIndicator is a PageIndicator which displays the title of left view\n * (if exist), the title of the current select view (centered) and the title of\n * the right view (if exist). When the user scrolls the ViewPager then titles are\n * also scrolled.\n */\npublic class TitlePageIndicator extends View implements PageIndicator {\n    /**\n     * Percentage indicating what percentage of the screen width away from\n     * center should the underline be fully faded. A value of 0.25 means that\n     * halfway between the center of the screen and an edge.\n     */\n    private static final float SELECTION_FADE_PERCENTAGE = 0.25f;\n\n    /**\n     * Percentage indicating what percentage of the screen width away from\n     * center should the selected text bold turn off. A value of 0.05 means\n     * that 10% between the center and an edge.\n     */\n    private static final float BOLD_FADE_PERCENTAGE = 0.05f;\n\n    /**\n     * Interface for a callback when the center item has been clicked.\n     */\n    public static interface OnCenterItemClickListener {\n        /**\n         * Callback when the center item has been clicked.\n         *\n         * @param position Position of the current center item.\n         */\n        public void onCenterItemClick(int position);\n    }\n\n    public enum IndicatorStyle {\n        None(0), Triangle(1), Underline(2);\n\n        public final int value;\n\n        private IndicatorStyle(int value) {\n            this.value = value;\n        }\n\n        public static IndicatorStyle fromValue(int value) {\n            for (IndicatorStyle style : IndicatorStyle.values()) {\n                if (style.value == value) {\n                    return style;\n                }\n            }\n            return null;\n        }\n    }\n\n    private ViewPager mViewPager;\n    private ViewPager.OnPageChangeListener mListener;\n    private TitleProvider mTitleProvider;\n    private int mCurrentPage;\n    private int mCurrentOffset;\n    private int mScrollState;\n    private final Paint mPaintText = new Paint();\n    private boolean mBoldText;\n    private int mColorText;\n    private int mColorSelected;\n    private Path mPath;\n    private final Paint mPaintFooterLine = new Paint();\n    private IndicatorStyle mFooterIndicatorStyle;\n    private final Paint mPaintFooterIndicator = new Paint();\n    private float mFooterIndicatorHeight;\n    private float mFooterIndicatorUnderlinePadding;\n    private float mFooterPadding;\n    private float mTitlePadding;\n    private float mTopPadding;\n    /** Left and right side padding for not active view titles. */\n    private float mClipPadding;\n    private float mFooterLineHeight;\n\n    private static final int INVALID_POINTER = -1;\n\n    private int mTouchSlop;\n    private float mLastMotionX = -1;\n    private int mActivePointerId = INVALID_POINTER;\n    private boolean mIsDragging;\n\n    private OnCenterItemClickListener mCenterItemClickListener;\n\n\n    public TitlePageIndicator(Context context) {\n        this(context, null);\n    }\n\n    public TitlePageIndicator(Context context, AttributeSet attrs) {\n        this(context, attrs, R.attr.vpiTitlePageIndicatorStyle);\n    }\n\n    public TitlePageIndicator(Context context, AttributeSet attrs, int defStyle) {\n        super(context, attrs, defStyle);\n\n        //Load defaults from resources\n        final Resources res = getResources();\n        final int defaultFooterColor = res.getColor(R.color.default_title_indicator_footer_color);\n        final float defaultFooterLineHeight = res.getDimension(R.dimen.default_title_indicator_footer_line_height);\n        final int defaultFooterIndicatorStyle = res.getInteger(R.integer.default_title_indicator_footer_indicator_style);\n        final float defaultFooterIndicatorHeight = res.getDimension(R.dimen.default_title_indicator_footer_indicator_height);\n        final float defaultFooterIndicatorUnderlinePadding = res.getDimension(R.dimen.default_title_indicator_footer_indicator_underline_padding);\n        final float defaultFooterPadding = res.getDimension(R.dimen.default_title_indicator_footer_padding);\n        final int defaultSelectedColor = res.getColor(R.color.default_title_indicator_selected_color);\n        final boolean defaultSelectedBold = res.getBoolean(R.bool.default_title_indicator_selected_bold);\n        final int defaultTextColor = res.getColor(R.color.default_title_indicator_text_color);\n        final float defaultTextSize = res.getDimension(R.dimen.default_title_indicator_text_size);\n        final float defaultTitlePadding = res.getDimension(R.dimen.default_title_indicator_title_padding);\n        final float defaultClipPadding = res.getDimension(R.dimen.default_title_indicator_clip_padding);\n        final float defaultTopPadding = res.getDimension(R.dimen.default_title_indicator_top_padding);\n\n        //Retrieve styles attributes\n        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.TitlePageIndicator, defStyle, R.style.Widget_TitlePageIndicator);\n\n        //Retrieve the colors to be used for this view and apply them.\n        mFooterLineHeight = a.getDimension(R.styleable.TitlePageIndicator_footerLineHeight, defaultFooterLineHeight);\n        mFooterIndicatorStyle = IndicatorStyle.fromValue(a.getInteger(R.styleable.TitlePageIndicator_footerIndicatorStyle, defaultFooterIndicatorStyle));\n        mFooterIndicatorHeight = a.getDimension(R.styleable.TitlePageIndicator_footerIndicatorHeight, defaultFooterIndicatorHeight);\n        mFooterIndicatorUnderlinePadding = a.getDimension(R.styleable.TitlePageIndicator_footerIndicatorUnderlinePadding, defaultFooterIndicatorUnderlinePadding);\n        mFooterPadding = a.getDimension(R.styleable.TitlePageIndicator_footerPadding, defaultFooterPadding);\n        mTopPadding = a.getDimension(R.styleable.TitlePageIndicator_topPadding, defaultTopPadding);\n        mTitlePadding = a.getDimension(R.styleable.TitlePageIndicator_titlePadding, defaultTitlePadding);\n        mClipPadding = a.getDimension(R.styleable.TitlePageIndicator_clipPadding, defaultClipPadding);\n        mColorSelected = a.getColor(R.styleable.TitlePageIndicator_selectedColor, defaultSelectedColor);\n        mColorText = a.getColor(R.styleable.TitlePageIndicator_textColor, defaultTextColor);\n        mBoldText = a.getBoolean(R.styleable.TitlePageIndicator_selectedBold, defaultSelectedBold);\n\n        final float textSize = a.getDimension(R.styleable.TitlePageIndicator_textSize, defaultTextSize);\n        final int footerColor = a.getColor(R.styleable.TitlePageIndicator_footerColor, defaultFooterColor);\n        mPaintText.setTextSize(textSize);\n        mPaintText.setAntiAlias(true);\n        mPaintFooterLine.setStyle(Paint.Style.FILL_AND_STROKE);\n        mPaintFooterLine.setStrokeWidth(mFooterLineHeight);\n        mPaintFooterLine.setColor(footerColor);\n        mPaintFooterIndicator.setStyle(Paint.Style.FILL_AND_STROKE);\n        mPaintFooterIndicator.setColor(footerColor);\n\n        a.recycle();\n\n        final ViewConfiguration configuration = ViewConfiguration.get(context);\n        mTouchSlop = ViewConfigurationCompat.getScaledPagingTouchSlop(configuration);\n    }\n\n\n    public int getFooterColor() {\n        return mPaintFooterLine.getColor();\n    }\n\n    public void setFooterColor(int footerColor) {\n        mPaintFooterLine.setColor(footerColor);\n        mPaintFooterIndicator.setColor(footerColor);\n        invalidate();\n    }\n\n    public float getFooterLineHeight() {\n        return mFooterLineHeight;\n    }\n\n    public void setFooterLineHeight(float footerLineHeight) {\n        mFooterLineHeight = footerLineHeight;\n        mPaintFooterLine.setStrokeWidth(mFooterLineHeight);\n        invalidate();\n    }\n\n    public float getFooterIndicatorHeight() {\n        return mFooterIndicatorHeight;\n    }\n\n    public void setFooterIndicatorHeight(float footerTriangleHeight) {\n        mFooterIndicatorHeight = footerTriangleHeight;\n        invalidate();\n    }\n\n    public float getFooterIndicatorPadding() {\n        return mFooterPadding;\n    }\n\n    public void setFooterIndicatorPadding(float footerIndicatorPadding) {\n        mFooterPadding = footerIndicatorPadding;\n        invalidate();\n    }\n\n    public IndicatorStyle getFooterIndicatorStyle() {\n        return mFooterIndicatorStyle;\n    }\n\n    public void setFooterIndicatorStyle(IndicatorStyle indicatorStyle) {\n        mFooterIndicatorStyle = indicatorStyle;\n        invalidate();\n    }\n\n    public int getSelectedColor() {\n        return mColorSelected;\n    }\n\n    public void setSelectedColor(int selectedColor) {\n        mColorSelected = selectedColor;\n        invalidate();\n    }\n\n    public boolean isSelectedBold() {\n        return mBoldText;\n    }\n\n    public void setSelectedBold(boolean selectedBold) {\n        mBoldText = selectedBold;\n        invalidate();\n    }\n\n    public int getTextColor() {\n        return mColorText;\n    }\n\n    public void setTextColor(int textColor) {\n        mPaintText.setColor(textColor);\n        mColorText = textColor;\n        invalidate();\n    }\n\n    public float getTextSize() {\n        return mPaintText.getTextSize();\n    }\n\n    public void setTextSize(float textSize) {\n        mPaintText.setTextSize(textSize);\n        invalidate();\n    }\n\n    public float getTitlePadding() {\n        return this.mTitlePadding;\n    }\n\n    public void setTitlePadding(float titlePadding) {\n        mTitlePadding = titlePadding;\n        invalidate();\n    }\n\n    public float getTopPadding() {\n        return this.mTopPadding;\n    }\n\n    public void setTopPadding(float topPadding) {\n        mTopPadding = topPadding;\n        invalidate();\n    }\n\n    public float getClipPadding() {\n        return this.mClipPadding;\n    }\n\n    public void setClipPadding(float clipPadding) {\n        mClipPadding = clipPadding;\n        invalidate();\n    }\n\n    public void setTypeface(Typeface typeface) {\n        mPaintText.setTypeface(typeface);\n        invalidate();\n    }\n\n    public Typeface getTypeface() {\n        return mPaintText.getTypeface();\n    }\n\n    /*\n     * (non-Javadoc)\n     *\n     * @see android.view.View#onDraw(android.graphics.Canvas)\n     */\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n\n        if (mViewPager == null) {\n            return;\n        }\n        final int count = mViewPager.getAdapter().getCount();\n        if (count == 0) {\n            return;\n        }\n\n        //Calculate views bounds\n        ArrayList<RectF> bounds = calculateAllBounds(mPaintText);\n\n        //Make sure we're on a page that still exists\n        if (mCurrentPage >= bounds.size()) {\n            setCurrentItem(bounds.size()-1);\n        }\n\n        final int countMinusOne = count - 1;\n        final float halfWidth = getWidth() / 2f;\n        final int left = getLeft();\n        final float leftClip = left + mClipPadding;\n        final int width = getWidth();\n        final int height = getHeight();\n        final int right = left + width;\n        final float rightClip = right - mClipPadding;\n\n        int page = mCurrentPage;\n        float offsetPercent;\n        if (mCurrentOffset <= halfWidth) {\n            offsetPercent = 1.0f * mCurrentOffset / width;\n        } else {\n            page += 1;\n            offsetPercent = 1.0f * (width - mCurrentOffset) / width;\n        }\n        final boolean currentSelected = (offsetPercent <= SELECTION_FADE_PERCENTAGE);\n        final boolean currentBold = (offsetPercent <= BOLD_FADE_PERCENTAGE);\n        final float selectedPercent = (SELECTION_FADE_PERCENTAGE - offsetPercent) / SELECTION_FADE_PERCENTAGE;\n\n        //Verify if the current view must be clipped to the screen\n        RectF curPageBound = bounds.get(mCurrentPage);\n        float curPageWidth = curPageBound.right - curPageBound.left;\n        if (curPageBound.left < leftClip) {\n            //Try to clip to the screen (left side)\n            clipViewOnTheLeft(curPageBound, curPageWidth, left);\n        }\n        if (curPageBound.right > rightClip) {\n            //Try to clip to the screen (right side)\n            clipViewOnTheRight(curPageBound, curPageWidth, right);\n        }\n\n        //Left views starting from the current position\n        if (mCurrentPage > 0) {\n            for (int i = mCurrentPage - 1; i >= 0; i--) {\n                RectF bound = bounds.get(i);\n                //Is left side is outside the screen\n                if (bound.left < leftClip) {\n                    float w = bound.right - bound.left;\n                    //Try to clip to the screen (left side)\n                    clipViewOnTheLeft(bound, w, left);\n                    //Except if there's an intersection with the right view\n                    RectF rightBound = bounds.get(i + 1);\n                    //Intersection\n                    if (bound.right + mTitlePadding > rightBound.left) {\n                        bound.left = rightBound.left - w - mTitlePadding;\n                        bound.right = bound.left + w;\n                    }\n                }\n            }\n        }\n        //Right views starting from the current position\n        if (mCurrentPage < countMinusOne) {\n            for (int i = mCurrentPage + 1 ; i < count; i++) {\n                RectF bound = bounds.get(i);\n                //If right side is outside the screen\n                if (bound.right > rightClip) {\n                    float w = bound.right - bound.left;\n                    //Try to clip to the screen (right side)\n                    clipViewOnTheRight(bound, w, right);\n                    //Except if there's an intersection with the left view\n                    RectF leftBound = bounds.get(i - 1);\n                    //Intersection\n                    if (bound.left - mTitlePadding < leftBound.right) {\n                        bound.left = leftBound.right + mTitlePadding;\n                        bound.right = bound.left + w;\n                    }\n                }\n            }\n        }\n\n        //Now draw views\n        for (int i = 0; i < count; i++) {\n            //Get the title\n            RectF bound = bounds.get(i);\n            //Only if one side is visible\n            if ((bound.left > left && bound.left < right) || (bound.right > left && bound.right < right)) {\n                final boolean currentPage = (i == page);\n                //Only set bold if we are within bounds\n                mPaintText.setFakeBoldText(currentPage && currentBold && mBoldText);\n\n                //Draw text as unselected\n                mPaintText.setColor(mColorText);\n                canvas.drawText(mTitleProvider.getTitle(i), bound.left, bound.bottom + mTopPadding, mPaintText);\n\n                //If we are within the selected bounds draw the selected text\n                if (currentPage && currentSelected) {\n                    mPaintText.setColor(mColorSelected);\n                    mPaintText.setAlpha((int)((mColorSelected >>> 24) * selectedPercent));\n                    canvas.drawText(mTitleProvider.getTitle(i), bound.left, bound.bottom + mTopPadding, mPaintText);\n                }\n            }\n        }\n\n        //Draw the footer line\n        mPath = new Path();\n        mPath.moveTo(0, height - mFooterLineHeight / 2f);\n        mPath.lineTo(width, height - mFooterLineHeight / 2f);\n        mPath.close();\n        canvas.drawPath(mPath, mPaintFooterLine);\n\n        switch (mFooterIndicatorStyle) {\n            case Triangle:\n                mPath = new Path();\n                mPath.moveTo(halfWidth, height - mFooterLineHeight - mFooterIndicatorHeight);\n                mPath.lineTo(halfWidth + mFooterIndicatorHeight, height - mFooterLineHeight);\n                mPath.lineTo(halfWidth - mFooterIndicatorHeight, height - mFooterLineHeight);\n                mPath.close();\n                canvas.drawPath(mPath, mPaintFooterIndicator);\n                break;\n\n            case Underline:\n                if (!currentSelected) {\n                    break;\n                }\n\n                RectF underlineBounds = bounds.get(page);\n                mPath = new Path();\n                mPath.moveTo(underlineBounds.left  - mFooterIndicatorUnderlinePadding, height - mFooterLineHeight);\n                mPath.lineTo(underlineBounds.right + mFooterIndicatorUnderlinePadding, height - mFooterLineHeight);\n                mPath.lineTo(underlineBounds.right + mFooterIndicatorUnderlinePadding, height - mFooterLineHeight - mFooterIndicatorHeight);\n                mPath.lineTo(underlineBounds.left  - mFooterIndicatorUnderlinePadding, height - mFooterLineHeight - mFooterIndicatorHeight);\n                mPath.close();\n\n                mPaintFooterIndicator.setAlpha((int)(0xFF * selectedPercent));\n                canvas.drawPath(mPath, mPaintFooterIndicator);\n                mPaintFooterIndicator.setAlpha(0xFF);\n                break;\n        }\n    }\n\n    public boolean onTouchEvent(android.view.MotionEvent ev) {\n        if ((mViewPager == null) || (mViewPager.getAdapter().getCount() == 0)) {\n            return false;\n        }\n\n        final int action = ev.getAction();\n\n        switch (action & MotionEventCompat.ACTION_MASK) {\n            case MotionEvent.ACTION_DOWN:\n                mActivePointerId = MotionEventCompat.getPointerId(ev, 0);\n                mLastMotionX = ev.getX();\n                break;\n\n            case MotionEvent.ACTION_MOVE: {\n                final int activePointerIndex = MotionEventCompat.findPointerIndex(ev, mActivePointerId);\n                final float x = MotionEventCompat.getX(ev, activePointerIndex);\n                final float deltaX = x - mLastMotionX;\n\n                if (!mIsDragging) {\n                    if (Math.abs(deltaX) > mTouchSlop) {\n                        mIsDragging = true;\n                    }\n                }\n\n                if (mIsDragging) {\n                    if (!mViewPager.isFakeDragging()) {\n                        mViewPager.beginFakeDrag();\n                    }\n\n                    mLastMotionX = x;\n\n                    mViewPager.fakeDragBy(deltaX);\n                }\n\n                break;\n            }\n\n            case MotionEvent.ACTION_CANCEL:\n            case MotionEvent.ACTION_UP:\n                if (!mIsDragging) {\n                    final int count = mViewPager.getAdapter().getCount();\n                    final int width = getWidth();\n                    final float halfWidth = width / 2f;\n                    final float sixthWidth = width / 6f;\n                    final float leftThird = halfWidth - sixthWidth;\n                    final float rightThird = halfWidth + sixthWidth;\n                    final float eventX = ev.getX();\n\n                    if (eventX < leftThird) {\n                        if (mCurrentPage > 0) {\n                            mViewPager.setCurrentItem(mCurrentPage - 1);\n                            return true;\n                        }\n                    } else if (eventX > rightThird) {\n                        if (mCurrentPage < count - 1) {\n                            mViewPager.setCurrentItem(mCurrentPage + 1);\n                            return true;\n                        }\n                    } else {\n                        //Middle third\n                        if (mCenterItemClickListener != null) {\n                            mCenterItemClickListener.onCenterItemClick(mCurrentPage);\n                        }\n                    }\n                }\n\n                mIsDragging = false;\n                mActivePointerId = INVALID_POINTER;\n                if (mViewPager.isFakeDragging()) mViewPager.endFakeDrag();\n                break;\n\n            case MotionEventCompat.ACTION_POINTER_DOWN: {\n                final int index = MotionEventCompat.getActionIndex(ev);\n                final float x = MotionEventCompat.getX(ev, index);\n                mLastMotionX = x;\n                mActivePointerId = MotionEventCompat.getPointerId(ev, index);\n                break;\n            }\n\n            case MotionEventCompat.ACTION_POINTER_UP:\n                final int pointerIndex = MotionEventCompat.getActionIndex(ev);\n                final int pointerId = MotionEventCompat.getPointerId(ev, pointerIndex);\n                if (pointerId == mActivePointerId) {\n                    final int newPointerIndex = pointerIndex == 0 ? 1 : 0;\n                    mActivePointerId = MotionEventCompat.getPointerId(ev, newPointerIndex);\n                }\n                mLastMotionX = MotionEventCompat.getX(ev, MotionEventCompat.findPointerIndex(ev, mActivePointerId));\n                break;\n        }\n\n        return true;\n    };\n\n    /**\n     * Set bounds for the right textView including clip padding.\n     *\n     * @param curViewBound\n     *            current bounds.\n     * @param curViewWidth\n     *            width of the view.\n     */\n    private void clipViewOnTheRight(RectF curViewBound, float curViewWidth, int right) {\n        curViewBound.right = right - mClipPadding;\n        curViewBound.left = curViewBound.right - curViewWidth;\n    }\n\n    /**\n     * Set bounds for the left textView including clip padding.\n     *\n     * @param curViewBound\n     *            current bounds.\n     * @param curViewWidth\n     *            width of the view.\n     */\n    private void clipViewOnTheLeft(RectF curViewBound, float curViewWidth, int left) {\n        curViewBound.left = left + mClipPadding;\n        curViewBound.right = mClipPadding + curViewWidth;\n    }\n\n    /**\n     * Calculate views bounds and scroll them according to the current index\n     *\n     * @param paint\n     * @param currentIndex\n     * @return\n     */\n    private ArrayList<RectF> calculateAllBounds(Paint paint) {\n        ArrayList<RectF> list = new ArrayList<RectF>();\n        //For each views (If no values then add a fake one)\n        final int count = mViewPager.getAdapter().getCount();\n        final int width = getWidth();\n        final int halfWidth = width / 2;\n        for (int i = 0; i < count; i++) {\n            RectF bounds = calcBounds(i, paint);\n            float w = (bounds.right - bounds.left);\n            float h = (bounds.bottom - bounds.top);\n            bounds.left = (halfWidth) - (w / 2) - mCurrentOffset + ((i - mCurrentPage) * width);\n            bounds.right = bounds.left + w;\n            bounds.top = 0;\n            bounds.bottom = h;\n            list.add(bounds);\n        }\n\n        return list;\n    }\n\n    /**\n     * Calculate the bounds for a view's title\n     *\n     * @param index\n     * @param paint\n     * @return\n     */\n    private RectF calcBounds(int index, Paint paint) {\n        //Calculate the text bounds\n        RectF bounds = new RectF();\n        bounds.right = paint.measureText(mTitleProvider.getTitle(index));\n        bounds.bottom = paint.descent() - paint.ascent();\n        return bounds;\n    }\n\n    @Override\n    public void setViewPager(ViewPager view) {\n        final PagerAdapter adapter = view.getAdapter();\n        if (adapter == null) {\n            throw new IllegalStateException(\"ViewPager does not have adapter instance.\");\n        }\n        if (!(adapter instanceof TitleProvider)) {\n            throw new IllegalStateException(\"ViewPager adapter must implement TitleProvider to be used with TitlePageIndicator.\");\n        }\n        mViewPager = view;\n        mViewPager.setOnPageChangeListener(this);\n        mTitleProvider = (TitleProvider)adapter;\n        invalidate();\n    }\n\n    @Override\n    public void setViewPager(ViewPager view, int initialPosition) {\n        setViewPager(view);\n        setCurrentItem(initialPosition);\n    }\n\n    @Override\n    public void notifyDataSetChanged() {\n        invalidate();\n    }\n\n    /**\n     * Set a callback listener for the center item click.\n     *\n     * @param listener Callback instance.\n     */\n    public void setOnCenterItemClickListener(OnCenterItemClickListener listener) {\n        mCenterItemClickListener = listener;\n    }\n\n    @Override\n    public void setCurrentItem(int item) {\n        if (mViewPager == null) {\n            throw new IllegalStateException(\"ViewPager has not been bound.\");\n        }\n        mViewPager.setCurrentItem(item);\n        mCurrentPage = item;\n        invalidate();\n    }\n\n    @Override\n    public void onPageScrollStateChanged(int state) {\n        mScrollState = state;\n\n        if (mListener != null) {\n            mListener.onPageScrollStateChanged(state);\n        }\n    }\n\n    @Override\n    public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {\n        mCurrentPage = position;\n        mCurrentOffset = positionOffsetPixels;\n        invalidate();\n\n        if (mListener != null) {\n            mListener.onPageScrolled(position, positionOffset, positionOffsetPixels);\n        }\n    }\n\n    @Override\n    public void onPageSelected(int position) {\n        if (mScrollState == ViewPager.SCROLL_STATE_IDLE) {\n            mCurrentPage = position;\n            invalidate();\n        }\n\n        if (mListener != null) {\n            mListener.onPageSelected(position);\n        }\n    }\n\n    @Override\n    public void setOnPageChangeListener(ViewPager.OnPageChangeListener listener) {\n        mListener = listener;\n    }\n\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        //Measure our width in whatever mode specified\n        final int measuredWidth = MeasureSpec.getSize(widthMeasureSpec);\n\n        //Determine our height\n        float height = 0;\n        final int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);\n        if (heightSpecMode == MeasureSpec.EXACTLY) {\n            //We were told how big to be\n            height = MeasureSpec.getSize(heightMeasureSpec);\n        } else {\n            //Calculate the text bounds\n            RectF bounds = new RectF();\n            bounds.bottom = mPaintText.descent()-mPaintText.ascent();\n            height = bounds.bottom - bounds.top + mFooterLineHeight + mFooterPadding + mTopPadding;\n            if (mFooterIndicatorStyle != IndicatorStyle.None) {\n                height += mFooterIndicatorHeight;\n            }\n        }\n        final int measuredHeight = (int)height;\n\n        setMeasuredDimension(measuredWidth, measuredHeight);\n    }\n\n    @Override\n    public void onRestoreInstanceState(Parcelable state) {\n        SavedState savedState = (SavedState)state;\n        super.onRestoreInstanceState(savedState.getSuperState());\n        mCurrentPage = savedState.currentPage;\n        requestLayout();\n    }\n\n    @Override\n    public Parcelable onSaveInstanceState() {\n        Parcelable superState = super.onSaveInstanceState();\n        SavedState savedState = new SavedState(superState);\n        savedState.currentPage = mCurrentPage;\n        return savedState;\n    }\n\n    static class SavedState extends BaseSavedState {\n        int currentPage;\n\n        public SavedState(Parcelable superState) {\n            super(superState);\n        }\n\n        private SavedState(Parcel in) {\n            super(in);\n            currentPage = in.readInt();\n        }\n\n        @Override\n        public void writeToParcel(Parcel dest, int flags) {\n            super.writeToParcel(dest, flags);\n            dest.writeInt(currentPage);\n        }\n\n        public static final Parcelable.Creator<SavedState> CREATOR = new Parcelable.Creator<SavedState>() {\n            @Override\n            public SavedState createFromParcel(Parcel in) {\n                return new SavedState(in);\n            }\n\n            @Override\n            public SavedState[] newArray(int size) {\n                return new SavedState[size];\n            }\n        };\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2011 Jake Wharton\n * Copyright (C) 2011 Patrik Akerfeldt\n * Copyright (C) 2011 Francisco Figueiredo Jr.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.viewpagerindicator;\n\nimport java.util.ArrayList;\nimport android.content.Context;\nimport android.content.res.Resources;\nimport android.content.res.TypedArray;\nimport android.graphics.Canvas;\nimport android.graphics.Paint;\nimport android.graphics.Path;\nimport android.graphics.RectF;\nimport android.graphics.Typeface;\nimport android.os.Parcel;\nimport android.os.Parcelable;\nimport android.support.v4.view.MotionEventCompat;\nimport android.support.v4.view.PagerAdapter;\nimport android.support.v4.view.ViewConfigurationCompat;\nimport android.support.v4.view.ViewPager;\nimport android.util.AttributeSet;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.view.ViewConfiguration;\n\n/**\n * A TitlePageIndicator is a PageIndicator which displays the title of left view\n * (if exist), the title of the current select view (centered) and the title of\n * the right view (if exist). When the user scrolls the ViewPager then titles are\n * also scrolled.\n */\npublic class TitlePageIndicator extends View implements PageIndicator {\n    /**\n     * Percentage indicating what percentage of the screen width away from\n     * center should the underline be fully faded. A value of 0.25 means that\n     * halfway between the center of the screen and an edge.\n     */\n    private static final float SELECTION_FADE_PERCENTAGE = 0.25f;\n\n    /**\n     * Percentage indicating what percentage of the screen width away from\n     * center should the selected text bold turn off. A value of 0.05 means\n     * that 10% between the center and an edge.\n     */\n    private static final float BOLD_FADE_PERCENTAGE = 0.05f;\n\n    /**\n     * Interface for a callback when the center item has been clicked.\n     */\n    public static interface OnCenterItemClickListener {\n        /**\n         * Callback when the center item has been clicked.\n         *\n         * @param position Position of the current center item.\n         */\n        public void onCenterItemClick(int position);\n    }\n\n    public enum IndicatorStyle {\n        None(0), Triangle(1), Underline(2);\n\n        public final int value;\n\n        private IndicatorStyle(int value) {\n            this.value = value;\n        }\n\n        public static IndicatorStyle fromValue(int value) {\n            for (IndicatorStyle style : IndicatorStyle.values()) {\n                if (style.value == value) {\n                    return style;\n                }\n            }\n            return null;\n        }\n    }\n\n    private ViewPager mViewPager;\n    private ViewPager.OnPageChangeListener mListener;\n    private TitleProvider mTitleProvider;\n    private int mCurrentPage;\n    private int mCurrentOffset;\n    private int mScrollState;\n    private final Paint mPaintText = new Paint();\n    private boolean mBoldText;\n    private int mColorText;\n    private int mColorSelected;\n    private Path mPath;\n    private final Paint mPaintFooterLine = new Paint();\n    private IndicatorStyle mFooterIndicatorStyle;\n    private final Paint mPaintFooterIndicator = new Paint();\n    private float mFooterIndicatorHeight;\n    private float mFooterIndicatorUnderlinePadding;\n    private float mFooterPadding;\n    private float mTitlePadding;\n    private float mTopPadding;\n    /** Left and right side padding for not active view titles. */\n    private float mClipPadding;\n    private float mFooterLineHeight;\n\n    private static final int INVALID_POINTER = -1;\n\n    private int mTouchSlop;\n    private float mLastMotionX = -1;\n    private int mActivePointerId = INVALID_POINTER;\n    private boolean mIsDragging;\n\n    private OnCenterItemClickListener mCenterItemClickListener;\n\n\n    public TitlePageIndicator(Context context) {\n        this(context, null);\n    }\n\n    public TitlePageIndicator(Context context, AttributeSet attrs) {\n        this(context, attrs, R.attr.vpiTitlePageIndicatorStyle);\n    }\n\n    public TitlePageIndicator(Context context, AttributeSet attrs, int defStyle) {\n        super(context, attrs, defStyle);\n\n        //Load defaults from resources\n        final Resources res = getResources();\n        final int defaultFooterColor = res.getColor(R.color.default_title_indicator_footer_color);\n        final float defaultFooterLineHeight = res.getDimension(R.dimen.default_title_indicator_footer_line_height);\n        final int defaultFooterIndicatorStyle = res.getInteger(R.integer.default_title_indicator_footer_indicator_style);\n        final float defaultFooterIndicatorHeight = res.getDimension(R.dimen.default_title_indicator_footer_indicator_height);\n        final float defaultFooterIndicatorUnderlinePadding = res.getDimension(R.dimen.default_title_indicator_footer_indicator_underline_padding);\n        final float defaultFooterPadding = res.getDimension(R.dimen.default_title_indicator_footer_padding);\n        final int defaultSelectedColor = res.getColor(R.color.default_title_indicator_selected_color);\n        final boolean defaultSelectedBold = res.getBoolean(R.bool.default_title_indicator_selected_bold);\n        final int defaultTextColor = res.getColor(R.color.default_title_indicator_text_color);\n        final float defaultTextSize = res.getDimension(R.dimen.default_title_indicator_text_size);\n        final float defaultTitlePadding = res.getDimension(R.dimen.default_title_indicator_title_padding);\n        final float defaultClipPadding = res.getDimension(R.dimen.default_title_indicator_clip_padding);\n        final float defaultTopPadding = res.getDimension(R.dimen.default_title_indicator_top_padding);\n\n        //Retrieve styles attributes\n        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.TitlePageIndicator, defStyle, R.style.Widget_TitlePageIndicator);\n\n        //Retrieve the colors to be used for this view and apply them.\n        mFooterLineHeight = a.getDimension(R.styleable.TitlePageIndicator_footerLineHeight, defaultFooterLineHeight);\n        mFooterIndicatorStyle = IndicatorStyle.fromValue(a.getInteger(R.styleable.TitlePageIndicator_footerIndicatorStyle, defaultFooterIndicatorStyle));\n        mFooterIndicatorHeight = a.getDimension(R.styleable.TitlePageIndicator_footerIndicatorHeight, defaultFooterIndicatorHeight);\n        mFooterIndicatorUnderlinePadding = a.getDimension(R.styleable.TitlePageIndicator_footerIndicatorUnderlinePadding, defaultFooterIndicatorUnderlinePadding);\n        mFooterPadding = a.getDimension(R.styleable.TitlePageIndicator_footerPadding, defaultFooterPadding);\n        mTopPadding = a.getDimension(R.styleable.TitlePageIndicator_topPadding, defaultTopPadding);\n        mTitlePadding = a.getDimension(R.styleable.TitlePageIndicator_titlePadding, defaultTitlePadding);\n        mClipPadding = a.getDimension(R.styleable.TitlePageIndicator_clipPadding, defaultClipPadding);\n        mColorSelected = a.getColor(R.styleable.TitlePageIndicator_selectedColor, defaultSelectedColor);\n        mColorText = a.getColor(R.styleable.TitlePageIndicator_textColor, defaultTextColor);\n        mBoldText = a.getBoolean(R.styleable.TitlePageIndicator_selectedBold, defaultSelectedBold);\n\n        final float textSize = a.getDimension(R.styleable.TitlePageIndicator_textSize, defaultTextSize);\n        final int footerColor = a.getColor(R.styleable.TitlePageIndicator_footerColor, defaultFooterColor);\n        mPaintText.setTextSize(textSize);\n        mPaintText.setAntiAlias(true);\n        mPaintFooterLine.setStyle(Paint.Style.FILL_AND_STROKE);\n        mPaintFooterLine.setStrokeWidth(mFooterLineHeight);\n        mPaintFooterLine.setColor(footerColor);\n        mPaintFooterIndicator.setStyle(Paint.Style.FILL_AND_STROKE);\n        mPaintFooterIndicator.setColor(footerColor);\n\n        a.recycle();\n\n        final ViewConfiguration configuration = ViewConfiguration.get(context);\n        mTouchSlop = ViewConfigurationCompat.getScaledPagingTouchSlop(configuration);\n    }\n\n\n    public int getFooterColor() {\n        return mPaintFooterLine.getColor();\n    }\n\n    public void setFooterColor(int footerColor) {\n        mPaintFooterLine.setColor(footerColor);\n        mPaintFooterIndicator.setColor(footerColor);\n        invalidate();\n    }\n\n    public float getFooterLineHeight() {\n        return mFooterLineHeight;\n    }\n\n    public void setFooterLineHeight(float footerLineHeight) {\n        mFooterLineHeight = footerLineHeight;\n        mPaintFooterLine.setStrokeWidth(mFooterLineHeight);\n        invalidate();\n    }\n\n    public float getFooterIndicatorHeight() {\n        return mFooterIndicatorHeight;\n    }\n\n    public void setFooterIndicatorHeight(float footerTriangleHeight) {\n        mFooterIndicatorHeight = footerTriangleHeight;\n        invalidate();\n    }\n\n    public float getFooterIndicatorPadding() {\n        return mFooterPadding;\n    }\n\n    public void setFooterIndicatorPadding(float footerIndicatorPadding) {\n        mFooterPadding = footerIndicatorPadding;\n        invalidate();\n    }\n\n    public IndicatorStyle getFooterIndicatorStyle() {\n        return mFooterIndicatorStyle;\n    }\n\n    public void setFooterIndicatorStyle(IndicatorStyle indicatorStyle) {\n        mFooterIndicatorStyle = indicatorStyle;\n        invalidate();\n    }\n\n    public int getSelectedColor() {\n        return mColorSelected;\n    }\n\n    public void setSelectedColor(int selectedColor) {\n        mColorSelected = selectedColor;\n        invalidate();\n    }\n\n    public boolean isSelectedBold() {\n        return mBoldText;\n    }\n\n    public void setSelectedBold(boolean selectedBold) {\n        mBoldText = selectedBold;\n        invalidate();\n    }\n\n    public int getTextColor() {\n        return mColorText;\n    }\n\n    public void setTextColor(int textColor) {\n        mPaintText.setColor(textColor);\n        mColorText = textColor;\n        invalidate();\n    }\n\n    public float getTextSize() {\n        return mPaintText.getTextSize();\n    }\n\n    public void setTextSize(float textSize) {\n        mPaintText.setTextSize(textSize);\n        invalidate();\n    }\n\n    public float getTitlePadding() {\n        return this.mTitlePadding;\n    }\n\n    public void setTitlePadding(float titlePadding) {\n        mTitlePadding = titlePadding;\n        invalidate();\n    }\n\n    public float getTopPadding() {\n        return this.mTopPadding;\n    }\n\n    public void setTopPadding(float topPadding) {\n        mTopPadding = topPadding;\n        invalidate();\n    }\n\n    public float getClipPadding() {\n        return this.mClipPadding;\n    }\n\n    public void setClipPadding(float clipPadding) {\n        mClipPadding = clipPadding;\n        invalidate();\n    }\n\n    public void setTypeface(Typeface typeface) {\n        mPaintText.setTypeface(typeface);\n        invalidate();\n    }\n\n    public Typeface getTypeface() {\n        return mPaintText.getTypeface();\n    }\n\n    /*\n     * (non-Javadoc)\n     *\n     * @see android.view.View#onDraw(android.graphics.Canvas)\n     */\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n\n        if (mViewPager == null) {\n            return;\n        }\n        final int count = mViewPager.getAdapter().getCount();\n        if (count == 0) {\n            return;\n        }\n\n        //Calculate views bounds\n        ArrayList<RectF> bounds = calculateAllBounds(mPaintText);\n        final int boundsSize = bounds.size();\n\n        //Make sure we're on a page that still exists\n        if (mCurrentPage >= boundsSize) {\n            setCurrentItem(boundsSize - 1);\n            return;\n        }\n\n        final int countMinusOne = count - 1;\n        final float halfWidth = getWidth() / 2f;\n        final int left = getLeft();\n        final float leftClip = left + mClipPadding;\n        final int width = getWidth();\n        final int height = getHeight();\n        final int right = left + width;\n        final float rightClip = right - mClipPadding;\n\n        int page = mCurrentPage;\n        float offsetPercent;\n        if (mCurrentOffset <= halfWidth) {\n            offsetPercent = 1.0f * mCurrentOffset / width;\n        } else {\n            page += 1;\n            offsetPercent = 1.0f * (width - mCurrentOffset) / width;\n        }\n        final boolean currentSelected = (offsetPercent <= SELECTION_FADE_PERCENTAGE);\n        final boolean currentBold = (offsetPercent <= BOLD_FADE_PERCENTAGE);\n        final float selectedPercent = (SELECTION_FADE_PERCENTAGE - offsetPercent) / SELECTION_FADE_PERCENTAGE;\n\n        //Verify if the current view must be clipped to the screen\n        RectF curPageBound = bounds.get(mCurrentPage);\n        float curPageWidth = curPageBound.right - curPageBound.left;\n        if (curPageBound.left < leftClip) {\n            //Try to clip to the screen (left side)\n            clipViewOnTheLeft(curPageBound, curPageWidth, left);\n        }\n        if (curPageBound.right > rightClip) {\n            //Try to clip to the screen (right side)\n            clipViewOnTheRight(curPageBound, curPageWidth, right);\n        }\n\n        //Left views starting from the current position\n        if (mCurrentPage > 0) {\n            for (int i = mCurrentPage - 1; i >= 0; i--) {\n                RectF bound = bounds.get(i);\n                //Is left side is outside the screen\n                if (bound.left < leftClip) {\n                    float w = bound.right - bound.left;\n                    //Try to clip to the screen (left side)\n                    clipViewOnTheLeft(bound, w, left);\n                    //Except if there's an intersection with the right view\n                    RectF rightBound = bounds.get(i + 1);\n                    //Intersection\n                    if (bound.right + mTitlePadding > rightBound.left) {\n                        bound.left = rightBound.left - w - mTitlePadding;\n                        bound.right = bound.left + w;\n                    }\n                }\n            }\n        }\n        //Right views starting from the current position\n        if (mCurrentPage < countMinusOne) {\n            for (int i = mCurrentPage + 1 ; i < count; i++) {\n                RectF bound = bounds.get(i);\n                //If right side is outside the screen\n                if (bound.right > rightClip) {\n                    float w = bound.right - bound.left;\n                    //Try to clip to the screen (right side)\n                    clipViewOnTheRight(bound, w, right);\n                    //Except if there's an intersection with the left view\n                    RectF leftBound = bounds.get(i - 1);\n                    //Intersection\n                    if (bound.left - mTitlePadding < leftBound.right) {\n                        bound.left = leftBound.right + mTitlePadding;\n                        bound.right = bound.left + w;\n                    }\n                }\n            }\n        }\n\n        //Now draw views\n        int colorTextAlpha = mColorText >>> 24;\n        for (int i = 0; i < count; i++) {\n            //Get the title\n            RectF bound = bounds.get(i);\n            //Only if one side is visible\n            if ((bound.left > left && bound.left < right) || (bound.right > left && bound.right < right)) {\n                final boolean currentPage = (i == page);\n                //Only set bold if we are within bounds\n                mPaintText.setFakeBoldText(currentPage && currentBold && mBoldText);\n\n                //Draw text as unselected\n                mPaintText.setColor(mColorText);\n                if(currentPage && currentSelected) {\n                    //Fade out/in unselected text as the selected text fades in/out\n                    mPaintText.setAlpha(colorTextAlpha - (int)(colorTextAlpha * selectedPercent));\n                }\n                canvas.drawText(mTitleProvider.getTitle(i), bound.left, bound.bottom + mTopPadding, mPaintText);\n\n                //If we are within the selected bounds draw the selected text\n                if (currentPage && currentSelected) {\n                    mPaintText.setColor(mColorSelected);\n                    mPaintText.setAlpha((int)((mColorSelected >>> 24) * selectedPercent));\n                    canvas.drawText(mTitleProvider.getTitle(i), bound.left, bound.bottom + mTopPadding, mPaintText);\n                }\n            }\n        }\n\n        //Draw the footer line\n        mPath = new Path();\n        mPath.moveTo(0, height - mFooterLineHeight / 2f);\n        mPath.lineTo(width, height - mFooterLineHeight / 2f);\n        mPath.close();\n        canvas.drawPath(mPath, mPaintFooterLine);\n\n        switch (mFooterIndicatorStyle) {\n            case Triangle:\n                mPath = new Path();\n                mPath.moveTo(halfWidth, height - mFooterLineHeight - mFooterIndicatorHeight);\n                mPath.lineTo(halfWidth + mFooterIndicatorHeight, height - mFooterLineHeight);\n                mPath.lineTo(halfWidth - mFooterIndicatorHeight, height - mFooterLineHeight);\n                mPath.close();\n                canvas.drawPath(mPath, mPaintFooterIndicator);\n                break;\n\n            case Underline:\n                if (!currentSelected || page >= boundsSize) {\n                    break;\n                }\n\n                RectF underlineBounds = bounds.get(page);\n                mPath = new Path();\n                mPath.moveTo(underlineBounds.left  - mFooterIndicatorUnderlinePadding, height - mFooterLineHeight);\n                mPath.lineTo(underlineBounds.right + mFooterIndicatorUnderlinePadding, height - mFooterLineHeight);\n                mPath.lineTo(underlineBounds.right + mFooterIndicatorUnderlinePadding, height - mFooterLineHeight - mFooterIndicatorHeight);\n                mPath.lineTo(underlineBounds.left  - mFooterIndicatorUnderlinePadding, height - mFooterLineHeight - mFooterIndicatorHeight);\n                mPath.close();\n\n                mPaintFooterIndicator.setAlpha((int)(0xFF * selectedPercent));\n                canvas.drawPath(mPath, mPaintFooterIndicator);\n                mPaintFooterIndicator.setAlpha(0xFF);\n                break;\n        }\n    }\n\n    public boolean onTouchEvent(android.view.MotionEvent ev) {\n        if (super.onTouchEvent(ev)) {\n            return true;\n        }\n        if ((mViewPager == null) || (mViewPager.getAdapter().getCount() == 0)) {\n            return false;\n        }\n\n        final int action = ev.getAction();\n\n        switch (action & MotionEventCompat.ACTION_MASK) {\n            case MotionEvent.ACTION_DOWN:\n                mActivePointerId = MotionEventCompat.getPointerId(ev, 0);\n                mLastMotionX = ev.getX();\n                break;\n\n            case MotionEvent.ACTION_MOVE: {\n                final int activePointerIndex = MotionEventCompat.findPointerIndex(ev, mActivePointerId);\n                final float x = MotionEventCompat.getX(ev, activePointerIndex);\n                final float deltaX = x - mLastMotionX;\n\n                if (!mIsDragging) {\n                    if (Math.abs(deltaX) > mTouchSlop) {\n                        mIsDragging = true;\n                    }\n                }\n\n                if (mIsDragging) {\n                    if (!mViewPager.isFakeDragging()) {\n                        mViewPager.beginFakeDrag();\n                    }\n\n                    mLastMotionX = x;\n\n                    mViewPager.fakeDragBy(deltaX);\n                }\n\n                break;\n            }\n\n            case MotionEvent.ACTION_CANCEL:\n            case MotionEvent.ACTION_UP:\n                if (!mIsDragging) {\n                    final int count = mViewPager.getAdapter().getCount();\n                    final int width = getWidth();\n                    final float halfWidth = width / 2f;\n                    final float sixthWidth = width / 6f;\n                    final float leftThird = halfWidth - sixthWidth;\n                    final float rightThird = halfWidth + sixthWidth;\n                    final float eventX = ev.getX();\n\n                    if (eventX < leftThird) {\n                        if (mCurrentPage > 0) {\n                            mViewPager.setCurrentItem(mCurrentPage - 1);\n                            return true;\n                        }\n                    } else if (eventX > rightThird) {\n                        if (mCurrentPage < count - 1) {\n                            mViewPager.setCurrentItem(mCurrentPage + 1);\n                            return true;\n                        }\n                    } else {\n                        //Middle third\n                        if (mCenterItemClickListener != null) {\n                            mCenterItemClickListener.onCenterItemClick(mCurrentPage);\n                        }\n                    }\n                }\n\n                mIsDragging = false;\n                mActivePointerId = INVALID_POINTER;\n                if (mViewPager.isFakeDragging()) mViewPager.endFakeDrag();\n                break;\n\n            case MotionEventCompat.ACTION_POINTER_DOWN: {\n                final int index = MotionEventCompat.getActionIndex(ev);\n                final float x = MotionEventCompat.getX(ev, index);\n                mLastMotionX = x;\n                mActivePointerId = MotionEventCompat.getPointerId(ev, index);\n                break;\n            }\n\n            case MotionEventCompat.ACTION_POINTER_UP:\n                final int pointerIndex = MotionEventCompat.getActionIndex(ev);\n                final int pointerId = MotionEventCompat.getPointerId(ev, pointerIndex);\n                if (pointerId == mActivePointerId) {\n                    final int newPointerIndex = pointerIndex == 0 ? 1 : 0;\n                    mActivePointerId = MotionEventCompat.getPointerId(ev, newPointerIndex);\n                }\n                mLastMotionX = MotionEventCompat.getX(ev, MotionEventCompat.findPointerIndex(ev, mActivePointerId));\n                break;\n        }\n\n        return true;\n    };\n\n    /**\n     * Set bounds for the right textView including clip padding.\n     *\n     * @param curViewBound\n     *            current bounds.\n     * @param curViewWidth\n     *            width of the view.\n     */\n    private void clipViewOnTheRight(RectF curViewBound, float curViewWidth, int right) {\n        curViewBound.right = right - mClipPadding;\n        curViewBound.left = curViewBound.right - curViewWidth;\n    }\n\n    /**\n     * Set bounds for the left textView including clip padding.\n     *\n     * @param curViewBound\n     *            current bounds.\n     * @param curViewWidth\n     *            width of the view.\n     */\n    private void clipViewOnTheLeft(RectF curViewBound, float curViewWidth, int left) {\n        curViewBound.left = left + mClipPadding;\n        curViewBound.right = mClipPadding + curViewWidth;\n    }\n\n    /**\n     * Calculate views bounds and scroll them according to the current index\n     *\n     * @param paint\n     * @param currentIndex\n     * @return\n     */\n    private ArrayList<RectF> calculateAllBounds(Paint paint) {\n        ArrayList<RectF> list = new ArrayList<RectF>();\n        //For each views (If no values then add a fake one)\n        final int count = mViewPager.getAdapter().getCount();\n        final int width = getWidth();\n        final int halfWidth = width / 2;\n        for (int i = 0; i < count; i++) {\n            RectF bounds = calcBounds(i, paint);\n            float w = (bounds.right - bounds.left);\n            float h = (bounds.bottom - bounds.top);\n            bounds.left = (halfWidth) - (w / 2) - mCurrentOffset + ((i - mCurrentPage) * width);\n            bounds.right = bounds.left + w;\n            bounds.top = 0;\n            bounds.bottom = h;\n            list.add(bounds);\n        }\n\n        return list;\n    }\n\n    /**\n     * Calculate the bounds for a view's title\n     *\n     * @param index\n     * @param paint\n     * @return\n     */\n    private RectF calcBounds(int index, Paint paint) {\n        //Calculate the text bounds\n        RectF bounds = new RectF();\n        bounds.right = paint.measureText(mTitleProvider.getTitle(index));\n        bounds.bottom = paint.descent() - paint.ascent();\n        return bounds;\n    }\n\n    @Override\n    public void setViewPager(ViewPager view) {\n        final PagerAdapter adapter = view.getAdapter();\n        if (adapter == null) {\n            throw new IllegalStateException(\"ViewPager does not have adapter instance.\");\n        }\n        if (!(adapter instanceof TitleProvider)) {\n            throw new IllegalStateException(\"ViewPager adapter must implement TitleProvider to be used with TitlePageIndicator.\");\n        }\n        mViewPager = view;\n        mViewPager.setOnPageChangeListener(this);\n        mTitleProvider = (TitleProvider)adapter;\n        invalidate();\n    }\n\n    @Override\n    public void setViewPager(ViewPager view, int initialPosition) {\n        setViewPager(view);\n        setCurrentItem(initialPosition);\n    }\n\n    @Override\n    public void notifyDataSetChanged() {\n        invalidate();\n    }\n\n    /**\n     * Set a callback listener for the center item click.\n     *\n     * @param listener Callback instance.\n     */\n    public void setOnCenterItemClickListener(OnCenterItemClickListener listener) {\n        mCenterItemClickListener = listener;\n    }\n\n    @Override\n    public void setCurrentItem(int item) {\n        if (mViewPager == null) {\n            throw new IllegalStateException(\"ViewPager has not been bound.\");\n        }\n        mViewPager.setCurrentItem(item);\n        mCurrentPage = item;\n        invalidate();\n    }\n\n    @Override\n    public void onPageScrollStateChanged(int state) {\n        mScrollState = state;\n\n        if (mListener != null) {\n            mListener.onPageScrollStateChanged(state);\n        }\n    }\n\n    @Override\n    public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {\n        mCurrentPage = position;\n        mCurrentOffset = positionOffsetPixels;\n        invalidate();\n\n        if (mListener != null) {\n            mListener.onPageScrolled(position, positionOffset, positionOffsetPixels);\n        }\n    }\n\n    @Override\n    public void onPageSelected(int position) {\n        if (mScrollState == ViewPager.SCROLL_STATE_IDLE) {\n            mCurrentPage = position;\n            invalidate();\n        }\n\n        if (mListener != null) {\n            mListener.onPageSelected(position);\n        }\n    }\n\n    @Override\n    public void setOnPageChangeListener(ViewPager.OnPageChangeListener listener) {\n        mListener = listener;\n    }\n\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        //Measure our width in whatever mode specified\n        final int measuredWidth = MeasureSpec.getSize(widthMeasureSpec);\n\n        //Determine our height\n        float height = 0;\n        final int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);\n        if (heightSpecMode == MeasureSpec.EXACTLY) {\n            //We were told how big to be\n            height = MeasureSpec.getSize(heightMeasureSpec);\n        } else {\n            //Calculate the text bounds\n            RectF bounds = new RectF();\n            bounds.bottom = mPaintText.descent()-mPaintText.ascent();\n            height = bounds.bottom - bounds.top + mFooterLineHeight + mFooterPadding + mTopPadding;\n            if (mFooterIndicatorStyle != IndicatorStyle.None) {\n                height += mFooterIndicatorHeight;\n            }\n        }\n        final int measuredHeight = (int)height;\n\n        setMeasuredDimension(measuredWidth, measuredHeight);\n    }\n\n    @Override\n    public void onRestoreInstanceState(Parcelable state) {\n        SavedState savedState = (SavedState)state;\n        super.onRestoreInstanceState(savedState.getSuperState());\n        mCurrentPage = savedState.currentPage;\n        requestLayout();\n    }\n\n    @Override\n    public Parcelable onSaveInstanceState() {\n        Parcelable superState = super.onSaveInstanceState();\n        SavedState savedState = new SavedState(superState);\n        savedState.currentPage = mCurrentPage;\n        return savedState;\n    }\n\n    static class SavedState extends BaseSavedState {\n        int currentPage;\n\n        public SavedState(Parcelable superState) {\n            super(superState);\n        }\n\n        private SavedState(Parcel in) {\n            super(in);\n            currentPage = in.readInt();\n        }\n\n        @Override\n        public void writeToParcel(Parcel dest, int flags) {\n            super.writeToParcel(dest, flags);\n            dest.writeInt(currentPage);\n        }\n\n        public static final Parcelable.Creator<SavedState> CREATOR = new Parcelable.Creator<SavedState>() {\n            @Override\n            public SavedState createFromParcel(Parcel in) {\n                return new SavedState(in);\n            }\n\n            @Override\n            public SavedState[] newArray(int size) {\n                return new SavedState[size];\n            }\n        };\n    }\n}\n","lineNo":324}
{"Smelly Sample":"package com.actionbarsherlock.internal.nineoldandroids.view.animation;\n\nimport android.graphics.Matrix;\nimport android.os.Build;\nimport android.view.View;\nimport android.view.animation.Animation;\nimport android.view.animation.Transformation;\n\npublic final class AnimatorProxy extends Animation {\n    public static final boolean NEEDS_PROXY = Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB;\n\n    public static AnimatorProxy wrap(View view) {\n        return new AnimatorProxy(view);\n    }\n\n    private final View mView;\n\n    private float mAlpha = 1f;\n    private float mTranslationX = 0f;\n    private float mTranslationY = 0f;\n    private float mScaleX = 1f;\n    private float mScaleY = 1f;\n\n    private AnimatorProxy(View view) {\n        super();\n        setDuration(0); //perform transformation immediately\n        setFillAfter(true); //persist transformation beyond duration\n        view.setAnimation(this);\n        mView = view;\n    }\n\n    public float getAlpha() {\n        return mAlpha;\n    }\n    public void setAlpha(float alpha) {\n        if (mAlpha != alpha) {\n            mAlpha = alpha;\n            invalidateParent();\n        }\n    }\n    public float getTranslationX() {\n        return mTranslationX;\n    }\n    public void setTranslationX(float translationX) {\n        if (mTranslationX != translationX) {\n            mTranslationX = translationX;\n            invalidateParent();\n        }\n    }\n    public float getTranslationY() {\n        return mTranslationY;\n    }\n    public void setTranslationY(float translationY) {\n        if (mTranslationY != translationY) {\n            mTranslationY = translationY;\n            invalidateParent();\n        }\n    }\n    public float getScaleX() {\n        return mScaleX;\n    }\n    public void setScaleX(float scale) {\n        if (mScaleX != scale) {\n            mScaleX = scale;\n            invalidateParent();\n        }\n    }\n    public float getScaleY() {\n        return mScaleY;\n    }\n    public void setScaleY(float scaleY) {\n        if (mScaleY != scaleY) {\n            mScaleY = scaleY;\n            invalidateParent();\n        }\n    }\n\n    private void invalidateParent() {\n        //TODO only invalidate what we need to change\n        ((View)mView.getParent()).invalidate();\n    }\n\n    @Override\n    protected void applyTransformation(float interpolatedTime, Transformation t) {\n        t.setAlpha(mAlpha);\n\n        final Matrix m = t.getMatrix();\n        m.postTranslate(mTranslationX, mTranslationY);\n        m.postScale(mScaleX, mScaleY);\n    }\n}\n","Method after Refactoring":"package com.actionbarsherlock.internal.nineoldandroids.view.animation;\n\nimport java.lang.ref.WeakReference;\nimport java.util.WeakHashMap;\nimport android.graphics.Matrix;\nimport android.graphics.RectF;\nimport android.os.Build;\nimport android.util.FloatMath;\nimport android.view.View;\nimport android.view.animation.Animation;\nimport android.view.animation.Transformation;\n\npublic final class AnimatorProxy extends Animation {\n    public static final boolean NEEDS_PROXY = Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB;\n\n    private static final WeakHashMap<View, AnimatorProxy> PROXIES =\n            new WeakHashMap<View, AnimatorProxy>();\n\n    public static AnimatorProxy wrap(View view) {\n        AnimatorProxy proxy = PROXIES.get(view);\n        if (proxy == null) {\n            proxy = new AnimatorProxy(view);\n            PROXIES.put(view, proxy);\n        }\n        return proxy;\n    }\n\n    private final WeakReference<View> mView;\n\n    private float mAlpha = 1;\n    private float mScaleX = 1;\n    private float mScaleY = 1;\n    private float mTranslationX;\n    private float mTranslationY;\n\n    private final RectF mBefore = new RectF();\n    private final RectF mAfter = new RectF();\n    private final Matrix mTempMatrix = new Matrix();\n\n    private AnimatorProxy(View view) {\n        setDuration(0); //perform transformation immediately\n        setFillAfter(true); //persist transformation beyond duration\n        view.setAnimation(this);\n        mView = new WeakReference<View>(view);\n    }\n\n    public float getAlpha() {\n        return mAlpha;\n    }\n    public void setAlpha(float alpha) {\n        if (mAlpha != alpha) {\n            mAlpha = alpha;\n            View view = mView.get();\n            if (view != null) {\n                view.invalidate();\n            }\n        }\n    }\n    public float getScaleX() {\n        return mScaleX;\n    }\n    public void setScaleX(float scaleX) {\n        if (mScaleX != scaleX) {\n            prepareForUpdate();\n            mScaleX = scaleX;\n            invalidateAfterUpdate();\n        }\n    }\n    public float getScaleY() {\n        return mScaleY;\n    }\n    public void setScaleY(float scaleY) {\n        if (mScaleY != scaleY) {\n            prepareForUpdate();\n            mScaleY = scaleY;\n            invalidateAfterUpdate();\n        }\n    }\n    public int getScrollX() {\n        View view = mView.get();\n        if (view == null) {\n            return 0;\n        }\n        return view.getScrollX();\n    }\n    public void setScrollX(int value) {\n        View view = mView.get();\n        if (view != null) {\n            view.scrollTo(value, view.getScrollY());\n        }\n    }\n    public int getScrollY() {\n        View view = mView.get();\n        if (view == null) {\n            return 0;\n        }\n        return view.getScrollY();\n    }\n    public void setScrollY(int value) {\n        View view = mView.get();\n        if (view != null) {\n            view.scrollTo(view.getScrollY(), value);\n        }\n    }\n\n    public float getTranslationX() {\n        return mTranslationX;\n    }\n    public void setTranslationX(float translationX) {\n        if (mTranslationX != translationX) {\n            prepareForUpdate();\n            mTranslationX = translationX;\n            invalidateAfterUpdate();\n        }\n    }\n    public float getTranslationY() {\n        return mTranslationY;\n    }\n    public void setTranslationY(float translationY) {\n        if (mTranslationY != translationY) {\n            prepareForUpdate();\n            mTranslationY = translationY;\n            invalidateAfterUpdate();\n        }\n    }\n\n    private void prepareForUpdate() {\n        View view = mView.get();\n        if (view != null) {\n            computeRect(mBefore, view);\n        }\n    }\n    private void invalidateAfterUpdate() {\n        View view = mView.get();\n        if (view == null) {\n            return;\n        }\n        View parent = (View)view.getParent();\n        if (parent == null) {\n            return;\n        }\n\n        final RectF after = mAfter;\n        computeRect(after, view);\n        after.union(mBefore);\n\n        parent.invalidate(\n                (int) FloatMath.floor(after.left),\n                (int) FloatMath.floor(after.top),\n                (int) FloatMath.ceil(after.right),\n                (int) FloatMath.ceil(after.bottom));\n    }\n\n    private void computeRect(final RectF r, View view) {\n        // compute current rectangle according to matrix transformation\n        final float w = view.getWidth();\n        final float h = view.getHeight();\n\n        // use a rectangle at 0,0 to make sure we don't run into issues with scaling\n        r.set(0, 0, w, h);\n\n        final Matrix m = mTempMatrix;\n        m.reset();\n        transformMatrix(m, view);\n        mTempMatrix.mapRect(r);\n\n        r.offset(view.getLeft(), view.getTop());\n\n        // Straighten coords if rotations flipped them\n        if (r.right < r.left) {\n            final float f = r.right;\n            r.right = r.left;\n            r.left = f;\n        }\n        if (r.bottom < r.top) {\n            final float f = r.top;\n            r.top = r.bottom;\n            r.bottom = f;\n        }\n    }\n\n    private void transformMatrix(Matrix m, View view) {\n        final float w = view.getWidth();\n        final float h = view.getHeight();\n\n        final float sX = mScaleX;\n        final float sY = mScaleY;\n        if ((sX != 1.0f) || (sY != 1.0f)) {\n            final float deltaSX = ((sX * w) - w) / 2f;\n            final float deltaSY = ((sY * h) - h) / 2f;\n            m.postScale(sX, sY);\n            m.postTranslate(-deltaSX, -deltaSY);\n        }\n        m.postTranslate(mTranslationX, mTranslationY);\n    }\n\n    @Override\n    protected void applyTransformation(float interpolatedTime, Transformation t) {\n        View view = mView.get();\n        if (view != null) {\n            t.setAlpha(mAlpha);\n            transformMatrix(t.getMatrix(), view);\n        }\n    }\n}\n","lineNo":186}
{"Smelly Sample":"package com.actionbarsherlock.internal.nineoldandroids.view.animation;\n\nimport android.graphics.Matrix;\nimport android.os.Build;\nimport android.view.View;\nimport android.view.animation.Animation;\nimport android.view.animation.Transformation;\n\npublic final class AnimatorProxy extends Animation {\n    public static final boolean NEEDS_PROXY = Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB;\n\n    public static AnimatorProxy wrap(View view) {\n        return new AnimatorProxy(view);\n    }\n\n    private final View mView;\n\n    private float mAlpha = 1f;\n    private float mTranslationX = 0f;\n    private float mTranslationY = 0f;\n    private float mScaleX = 1f;\n    private float mScaleY = 1f;\n\n    private AnimatorProxy(View view) {\n        super();\n        setDuration(0); //perform transformation immediately\n        setFillAfter(true); //persist transformation beyond duration\n        view.setAnimation(this);\n        mView = view;\n    }\n\n    public float getAlpha() {\n        return mAlpha;\n    }\n    public void setAlpha(float alpha) {\n        if (mAlpha != alpha) {\n            mAlpha = alpha;\n            invalidateParent();\n        }\n    }\n    public float getTranslationX() {\n        return mTranslationX;\n    }\n    public void setTranslationX(float translationX) {\n        if (mTranslationX != translationX) {\n            mTranslationX = translationX;\n            invalidateParent();\n        }\n    }\n    public float getTranslationY() {\n        return mTranslationY;\n    }\n    public void setTranslationY(float translationY) {\n        if (mTranslationY != translationY) {\n            mTranslationY = translationY;\n            invalidateParent();\n        }\n    }\n    public float getScaleX() {\n        return mScaleX;\n    }\n    public void setScaleX(float scale) {\n        if (mScaleX != scale) {\n            mScaleX = scale;\n            invalidateParent();\n        }\n    }\n    public float getScaleY() {\n        return mScaleY;\n    }\n    public void setScaleY(float scaleY) {\n        if (mScaleY != scaleY) {\n            mScaleY = scaleY;\n            invalidateParent();\n        }\n    }\n\n    private void invalidateParent() {\n        //TODO only invalidate what we need to change\n        ((View)mView.getParent()).invalidate();\n    }\n\n    @Override\n    protected void applyTransformation(float interpolatedTime, Transformation t) {\n        t.setAlpha(mAlpha);\n\n        final Matrix m = t.getMatrix();\n        m.postTranslate(mTranslationX, mTranslationY);\n        m.postScale(mScaleX, mScaleY);\n    }\n}\n","Method after Refactoring":"package com.actionbarsherlock.internal.nineoldandroids.view.animation;\n\nimport java.lang.ref.WeakReference;\nimport java.util.WeakHashMap;\nimport android.graphics.Matrix;\nimport android.graphics.RectF;\nimport android.os.Build;\nimport android.util.FloatMath;\nimport android.view.View;\nimport android.view.animation.Animation;\nimport android.view.animation.Transformation;\n\npublic final class AnimatorProxy extends Animation {\n    public static final boolean NEEDS_PROXY = Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB;\n\n    private static final WeakHashMap<View, AnimatorProxy> PROXIES =\n            new WeakHashMap<View, AnimatorProxy>();\n\n    public static AnimatorProxy wrap(View view) {\n        AnimatorProxy proxy = PROXIES.get(view);\n        if (proxy == null) {\n            proxy = new AnimatorProxy(view);\n            PROXIES.put(view, proxy);\n        }\n        return proxy;\n    }\n\n    private final WeakReference<View> mView;\n\n    private float mAlpha = 1;\n    private float mScaleX = 1;\n    private float mScaleY = 1;\n    private float mTranslationX;\n    private float mTranslationY;\n\n    private final RectF mBefore = new RectF();\n    private final RectF mAfter = new RectF();\n    private final Matrix mTempMatrix = new Matrix();\n\n    private AnimatorProxy(View view) {\n        setDuration(0); //perform transformation immediately\n        setFillAfter(true); //persist transformation beyond duration\n        view.setAnimation(this);\n        mView = new WeakReference<View>(view);\n    }\n\n    public float getAlpha() {\n        return mAlpha;\n    }\n    public void setAlpha(float alpha) {\n        if (mAlpha != alpha) {\n            mAlpha = alpha;\n            View view = mView.get();\n            if (view != null) {\n                view.invalidate();\n            }\n        }\n    }\n    public float getScaleX() {\n        return mScaleX;\n    }\n    public void setScaleX(float scaleX) {\n        if (mScaleX != scaleX) {\n            prepareForUpdate();\n            mScaleX = scaleX;\n            invalidateAfterUpdate();\n        }\n    }\n    public float getScaleY() {\n        return mScaleY;\n    }\n    public void setScaleY(float scaleY) {\n        if (mScaleY != scaleY) {\n            prepareForUpdate();\n            mScaleY = scaleY;\n            invalidateAfterUpdate();\n        }\n    }\n    public int getScrollX() {\n        View view = mView.get();\n        if (view == null) {\n            return 0;\n        }\n        return view.getScrollX();\n    }\n    public void setScrollX(int value) {\n        View view = mView.get();\n        if (view != null) {\n            view.scrollTo(value, view.getScrollY());\n        }\n    }\n    public int getScrollY() {\n        View view = mView.get();\n        if (view == null) {\n            return 0;\n        }\n        return view.getScrollY();\n    }\n    public void setScrollY(int value) {\n        View view = mView.get();\n        if (view != null) {\n            view.scrollTo(view.getScrollY(), value);\n        }\n    }\n\n    public float getTranslationX() {\n        return mTranslationX;\n    }\n    public void setTranslationX(float translationX) {\n        if (mTranslationX != translationX) {\n            prepareForUpdate();\n            mTranslationX = translationX;\n            invalidateAfterUpdate();\n        }\n    }\n    public float getTranslationY() {\n        return mTranslationY;\n    }\n    public void setTranslationY(float translationY) {\n        if (mTranslationY != translationY) {\n            prepareForUpdate();\n            mTranslationY = translationY;\n            invalidateAfterUpdate();\n        }\n    }\n\n    private void prepareForUpdate() {\n        View view = mView.get();\n        if (view != null) {\n            computeRect(mBefore, view);\n        }\n    }\n    private void invalidateAfterUpdate() {\n        View view = mView.get();\n        if (view == null) {\n            return;\n        }\n        View parent = (View)view.getParent();\n        if (parent == null) {\n            return;\n        }\n\n        final RectF after = mAfter;\n        computeRect(after, view);\n        after.union(mBefore);\n\n        parent.invalidate(\n                (int) FloatMath.floor(after.left),\n                (int) FloatMath.floor(after.top),\n                (int) FloatMath.ceil(after.right),\n                (int) FloatMath.ceil(after.bottom));\n    }\n\n    private void computeRect(final RectF r, View view) {\n        // compute current rectangle according to matrix transformation\n        final float w = view.getWidth();\n        final float h = view.getHeight();\n\n        // use a rectangle at 0,0 to make sure we don't run into issues with scaling\n        r.set(0, 0, w, h);\n\n        final Matrix m = mTempMatrix;\n        m.reset();\n        transformMatrix(m, view);\n        mTempMatrix.mapRect(r);\n\n        r.offset(view.getLeft(), view.getTop());\n\n        // Straighten coords if rotations flipped them\n        if (r.right < r.left) {\n            final float f = r.right;\n            r.right = r.left;\n            r.left = f;\n        }\n        if (r.bottom < r.top) {\n            final float f = r.top;\n            r.top = r.bottom;\n            r.bottom = f;\n        }\n    }\n\n    private void transformMatrix(Matrix m, View view) {\n        final float w = view.getWidth();\n        final float h = view.getHeight();\n\n        final float sX = mScaleX;\n        final float sY = mScaleY;\n        if ((sX != 1.0f) || (sY != 1.0f)) {\n            final float deltaSX = ((sX * w) - w) / 2f;\n            final float deltaSY = ((sY * h) - h) / 2f;\n            m.postScale(sX, sY);\n            m.postTranslate(-deltaSX, -deltaSY);\n        }\n        m.postTranslate(mTranslationX, mTranslationY);\n    }\n\n    @Override\n    protected void applyTransformation(float interpolatedTime, Transformation t) {\n        View view = mView.get();\n        if (view != null) {\n            t.setAlpha(mAlpha);\n            transformMatrix(t.getMatrix(), view);\n        }\n    }\n}\n","lineNo":187}
{"Smelly Sample":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2011 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage org.yaaic.activity;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.adapter.ConversationPagerAdapter;\nimport org.yaaic.adapter.MessageListAdapter;\nimport org.yaaic.command.CommandParser;\nimport org.yaaic.irc.IRCBinder;\nimport org.yaaic.irc.IRCConnection;\nimport org.yaaic.irc.IRCService;\nimport org.yaaic.listener.ConversationListener;\nimport org.yaaic.listener.ServerListener;\nimport org.yaaic.listener.SpeechClickListener;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.model.Extra;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Query;\nimport org.yaaic.model.Scrollback;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.ServerInfo;\nimport org.yaaic.model.Settings;\nimport org.yaaic.model.Status;\nimport org.yaaic.model.User;\nimport org.yaaic.receiver.ConversationReceiver;\nimport org.yaaic.receiver.ServerReceiver;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.content.ComponentName;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.content.pm.PackageManager;\nimport android.content.pm.ResolveInfo;\nimport android.content.res.Configuration;\nimport android.graphics.Typeface;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.speech.RecognizerIntent;\nimport android.support.v4.view.ViewPager;\nimport android.text.InputType;\nimport android.util.DisplayMetrics;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.View.OnKeyListener;\nimport android.view.Window;\nimport android.view.WindowManager;\nimport android.view.inputmethod.EditorInfo;\nimport android.view.inputmethod.InputMethodManager;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.Toast;\n\nimport com.viewpagerindicator.TitlePageIndicator;\n\n/**\n * The server view with a scrollable list of all channels\n *\n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class ConversationActivity extends Activity implements ServiceConnection, ServerListener, ConversationListener\n{\n    public static final int REQUEST_CODE_SPEECH = 99;\n\n    private static final int REQUEST_CODE_JOIN = 1;\n    private static final int REQUEST_CODE_USERS = 2;\n    private static final int REQUEST_CODE_USER = 3;\n    private static final int REQUEST_CODE_NICK_COMPLETION= 4;\n\n    private int serverId;\n    private Server server;\n    private IRCBinder binder;\n    private ConversationReceiver channelReceiver;\n    private ServerReceiver serverReceiver;\n\n    private ViewPager pager;\n    private ConversationPagerAdapter pagerAdapter;\n\n    private Scrollback scrollback;\n\n    // XXX: This is ugly. This is a buffer for a channel that should be joined after showing the\n    //      JoinActivity. As onActivityResult() is called before onResume() a \"channel joined\"\n    //      broadcast may get lost as the broadcast receivers are registered in onResume() but the\n    //      join command would be called in onActivityResult(). joinChannelBuffer will save the\n    //      channel name in onActivityResult() and run the join command in onResume().\n    private String joinChannelBuffer;\n\n    private int historySize;\n\n    private boolean reconnectDialogActive = false;\n\n    OnKeyListener inputKeyListener = new OnKeyListener() {\n        /**\n         * On key pressed (input line)\n         */\n        @Override\n        public boolean onKey(View view, int keyCode, KeyEvent event)\n        {\n            EditText input = (EditText) view;\n\n            if (event.getAction() != KeyEvent.ACTION_DOWN) {\n                return false;\n            }\n\n            if (keyCode == KeyEvent.KEYCODE_DPAD_UP) {\n                String message = scrollback.goBack();\n                if (message != null) {\n                    input.setText(message);\n                }\n                return true;\n            }\n\n            if (keyCode == KeyEvent.KEYCODE_DPAD_DOWN) {\n                String message = scrollback.goForward();\n                if (message != null) {\n                    input.setText(message);\n                }\n                return true;\n            }\n\n            if (keyCode == KeyEvent.KEYCODE_ENTER) {\n                sendMessage(input.getText().toString());\n                input.setText(\"\");\n                return true;\n            }\n\n            // Nick completion\n            if (keyCode == KeyEvent.KEYCODE_SEARCH) {\n                doNickCompletion(input);\n                return true;\n            }\n\n            return false;\n        }\n    };\n\n    /**\n     * On create\n     */\n    @Override\n    protected void onCreate(Bundle savedInstanceState)\n    {\n        super.onCreate(savedInstanceState);\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n\n        serverId = getIntent().getExtras().getInt(\"serverId\");\n        server = Yaaic.getInstance().getServerById(serverId);\n        Settings settings = new Settings(this);\n\n        // Finish activity if server does not exist anymore - See #55\n        if (server == null) {\n            this.finish();\n        }\n\n        setTitle(\"Yaaic - \" + server.getTitle());\n\n        setContentView(R.layout.conversations);\n        if (settings.fullscreenConversations()){\n            getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);\n        }\n\n        boolean isLandscape = (getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE);\n\n        EditText input = (EditText) findViewById(R.id.input);\n        input.setOnKeyListener(inputKeyListener);\n\n        pager = (ViewPager) findViewById(R.id.pager);\n\n        pagerAdapter = new ConversationPagerAdapter(server);\n        pager.setAdapter(pagerAdapter);\n\n        TitlePageIndicator indicator = (TitlePageIndicator) findViewById(R.id.titleIndicator);\n        indicator.setTypeface(Typeface.MONOSPACE);\n        indicator.setViewPager(pager);\n\n        historySize = settings.getHistorySize();\n\n        if (server.getStatus() == Status.PRE_CONNECTING) {\n            server.clearConversations();\n            pagerAdapter.clearConversations();\n            server.getConversation(ServerInfo.DEFAULT_NAME).setHistorySize(historySize);\n        }\n\n        DisplayMetrics dm = new DisplayMetrics();\n        getWindowManager().getDefaultDisplay().getMetrics(dm);\n        indicator.setTextSize(settings.getFontSize() * dm.scaledDensity);\n\n        // Optimization : cache field lookups\n        Collection<Conversation> mConversations = server.getConversations();\n\n        for (Conversation conversation : mConversations) {\n            // Only scroll to new conversation if it was selected before\n            if (conversation.getStatus() == Conversation.STATUS_SELECTED) {\n                onNewConversation(conversation.getName());\n            } else {\n                createNewConversation(conversation.getName());\n            }\n        }\n\n        int setInputTypeFlags = 0;\n\n        if (settings.autoCorrectText()) {\n            setInputTypeFlags |= InputType.TYPE_TEXT_FLAG_AUTO_CORRECT;\n        } else {\n            // keep compatibility with api level 3\n            if ((android.os.Build.VERSION.SDK.charAt(0) - '0') >= 5) {\n                setInputTypeFlags |= 0x80000; // InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS\n            }\n        }\n        if (settings.autoCapSentences()) {\n            setInputTypeFlags |= InputType.TYPE_TEXT_FLAG_CAP_SENTENCES;\n        }\n\n        if (isLandscape && settings.imeExtract()) {\n            setInputTypeFlags |= InputType.TYPE_TEXT_VARIATION_SHORT_MESSAGE;\n        }\n\n        if (!settings.imeExtract()) {\n            input.setImeOptions(input.getImeOptions() | EditorInfo.IME_FLAG_NO_EXTRACT_UI);\n        }\n\n        input.setInputType(input.getInputType() | setInputTypeFlags);\n\n        // Create a new scrollback history\n        scrollback = new Scrollback();\n    }\n\n    /**\n     * On resume\n     */\n    @Override\n    public void onResume()\n    {\n        // register the receivers as early as possible, otherwise we may loose a broadcast message\n        channelReceiver = new ConversationReceiver(server.getId(), this);\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_MESSAGE));\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_NEW));\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_REMOVE));\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_TOPIC));\n\n        serverReceiver = new ServerReceiver(this);\n        registerReceiver(serverReceiver, new IntentFilter(Broadcast.SERVER_UPDATE));\n\n        super.onResume();\n\n        // Check if speech recognition is enabled and available\n        if (new Settings(this).isVoiceRecognitionEnabled()) {\n            PackageManager pm = getPackageManager();\n            Button speechButton = (Button) findViewById(R.id.speech);\n            List<ResolveInfo> activities = pm.queryIntentActivities(new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH), 0);\n\n            if (activities.size() != 0) {\n                ((Button) findViewById(R.id.speech)).setOnClickListener(new SpeechClickListener(this));\n                speechButton.setVisibility(View.VISIBLE);\n            }\n        }\n\n        // Start service\n        Intent intent = new Intent(this, IRCService.class);\n        intent.setAction(IRCService.ACTION_FOREGROUND);\n        startService(intent);\n        bindService(intent, this, 0);\n\n        if (!server.isConnected()) {\n            ((EditText) findViewById(R.id.input)).setEnabled(false);\n        } else {\n            ((EditText) findViewById(R.id.input)).setEnabled(true);\n        }\n\n        // Optimization - cache field lookup\n        Collection<Conversation> mConversations = server.getConversations();\n        MessageListAdapter mAdapter;\n\n        // Fill view with messages that have been buffered while paused\n        for (Conversation conversation : mConversations) {\n            String name = conversation.getName();\n            mAdapter = pagerAdapter.getItemAdapter(name);\n\n            if (mAdapter != null) {\n                mAdapter.addBulkMessages(conversation.getBuffer());\n                conversation.clearBuffer();\n            } else {\n                // Was conversation created while we were paused?\n                if (pagerAdapter.getPositionByName(name) == -1) {\n                    onNewConversation(name);\n                }\n            }\n\n            // Clear new message notifications for the selected conversation\n            if (conversation.getStatus() == Conversation.STATUS_SELECTED && conversation.getNewMentions() > 0) {\n                Intent ackIntent = new Intent(this, IRCService.class);\n                ackIntent.setAction(IRCService.ACTION_ACK_NEW_MENTIONS);\n                ackIntent.putExtra(IRCService.EXTRA_ACK_SERVERID, serverId);\n                ackIntent.putExtra(IRCService.EXTRA_ACK_CONVTITLE, name);\n                startService(ackIntent);\n            }\n        }\n\n        // Remove views for conversations that ended while we were paused\n        int numViews = pagerAdapter.getCount();\n        if (numViews > mConversations.size()) {\n            for (int i = 0; i < numViews; ++i) {\n                if (!mConversations.contains(pagerAdapter.getItem(i))) {\n                    pagerAdapter.removeConversation(i--);\n                    --numViews;\n                }\n            }\n        }\n\n        // Join channel that has been selected in JoinActivity (onActivityResult())\n        if (joinChannelBuffer != null) {\n            new Thread() {\n                @Override\n                public void run() {\n                    binder.getService().getConnection(serverId).joinChannel(joinChannelBuffer);\n                    joinChannelBuffer = null;\n                }\n            }.start();\n        }\n\n        server.setIsForeground(true);\n    }\n\n    /**\n     * On Pause\n     */\n    @Override\n    public void onPause()\n    {\n        super.onPause();\n\n        server.setIsForeground(false);\n\n        if (binder != null && binder.getService() != null) {\n            binder.getService().checkServiceStatus();\n        }\n\n        unbindService(this);\n        unregisterReceiver(channelReceiver);\n        unregisterReceiver(serverReceiver);\n    }\n\n    /**\n     * On service connected\n     */\n    @Override\n    public void onServiceConnected(ComponentName name, IBinder service)\n    {\n        this.binder = (IRCBinder) service;\n\n        // connect to irc server if connect has been requested\n        if (server.getStatus() == Status.PRE_CONNECTING && getIntent().hasExtra(\"connect\")) {\n            server.setStatus(Status.CONNECTING);\n            binder.connect(server);\n        } else {\n            onStatusUpdate();\n        }\n    }\n\n    /**\n     * On service disconnected\n     */\n    @Override\n    public void onServiceDisconnected(ComponentName name)\n    {\n        this.binder = null;\n    }\n\n    /**\n     * On options menu requested\n     */\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu)\n    {\n        super.onCreateOptionsMenu(menu);\n\n        // inflate from xml\n        MenuInflater inflater = getMenuInflater();\n        inflater.inflate(R.menu.conversations, menu);\n\n        return true;\n    }\n\n    /**\n     * On prepare options menu\n     */\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu)\n    {\n        menu.getItem(0).setEnabled(server.isConnected()); // join\n        menu.getItem(1).setEnabled(server.isConnected()); // users\n        menu.getItem(2).setEnabled(server.isConnected()); // close\n\n        return true;\n    }\n\n    /**\n     * On menu item selected\n     */\n    @Override\n    public boolean onMenuItemSelected(int featureId, MenuItem item)\n    {\n        switch (item.getItemId()) {\n            case R.id.disconnect:\n                server.setStatus(Status.DISCONNECTED);\n                server.setMayReconnect(false);\n                binder.getService().getConnection(serverId).quitServer();\n                server.clearConversations();\n                setResult(RESULT_OK);\n                finish();\n                break;\n\n            case R.id.close:\n                Conversation conversationToClose = pagerAdapter.getItem(pager.getCurrentItem());\n                // Make sure we part a channel when closing the channel conversation\n                if (conversationToClose.getType() == Conversation.TYPE_CHANNEL) {\n                    binder.getService().getConnection(serverId).partChannel(conversationToClose.getName());\n                }\n                else if (conversationToClose.getType() == Conversation.TYPE_QUERY) {\n                    server.removeConversation(conversationToClose.getName());\n                    onRemoveConversation(conversationToClose.getName());\n                } else {\n                    Toast.makeText(this, getResources().getString(R.string.close_server_window), Toast.LENGTH_SHORT).show();\n                }\n                break;\n\n            case R.id.join:\n                startActivityForResult(new Intent(this, JoinActivity.class), REQUEST_CODE_JOIN);\n                break;\n\n            case R.id.users:\n                Conversation conversationForUserList = pagerAdapter.getItem(pager.getCurrentItem());\n                if (conversationForUserList.getType() == Conversation.TYPE_CHANNEL) {\n                    Intent intent = new Intent(this, UsersActivity.class);\n                    intent.putExtra(\n                            Extra.USERS,\n                            binder.getService().getConnection(server.getId()).getUsersAsStringArray(\n                                    conversationForUserList.getName()\n                                    )\n                            );\n                    startActivityForResult(intent, REQUEST_CODE_USERS);\n                } else {\n                    Toast.makeText(this, getResources().getString(R.string.only_usable_from_channel), Toast.LENGTH_SHORT).show();\n                }\n                break;\n        }\n\n        return true;\n    }\n\n    /**\n     * Get server object assigned to this activity\n     *\n     * @return the server object\n     */\n    public Server getServer()\n    {\n        return server;\n    }\n\n    /**\n     * On conversation message\n     */\n    @Override\n    public void onConversationMessage(String target)\n    {\n        Conversation conversation = server.getConversation(target);\n\n        if (conversation == null) {\n            // In an early state it can happen that the conversation object\n            // is not created yet.\n            return;\n        }\n\n        MessageListAdapter adapter = pagerAdapter.getItemAdapter(target);\n\n        while(conversation.hasBufferedMessages()) {\n            Message message = conversation.pollBufferedMessage();\n\n            if (adapter != null && message != null) {\n                adapter.addMessage(message);\n                int status;\n\n                switch (message.getType())\n                {\n                    case Message.TYPE_MISC:\n                        status = Conversation.STATUS_MISC;\n                        break;\n\n                    default:\n                        status = Conversation.STATUS_MESSAGE;\n                        break;\n                }\n                conversation.setStatus(status);\n            }\n        }\n    }\n\n    /**\n     * On new conversation\n     */\n    @Override\n    public void onNewConversation(String target)\n    {\n        createNewConversation(target);\n\n        pager.setCurrentItem(pagerAdapter.getCount() - 1);\n    }\n\n    /**\n     * Create a new conversation in the pager adapter for the\n     * given target conversation.\n     *\n     * @param target\n     */\n    public void createNewConversation(String target)\n    {\n        pagerAdapter.addConversation(server.getConversation(target));\n    }\n\n    /**\n     * On conversation remove\n     */\n    @Override\n    public void onRemoveConversation(String target)\n    {\n        int position = pagerAdapter.getPositionByName(target);\n\n        if (position != -1) {\n            pagerAdapter.removeConversation(position);\n        }\n    }\n\n    /**\n     * On topic change\n     */\n    @Override\n    public void onTopicChanged(String target)\n    {\n        // No implementation\n    }\n\n    /**\n     * On server status update\n     */\n    @Override\n    public void onStatusUpdate()\n    {\n        EditText input = (EditText) findViewById(R.id.input);\n\n        if (server.isConnected()) {\n            input.setEnabled(true);\n        } else {\n            input.setEnabled(false);\n\n            if (server.getStatus() == Status.CONNECTING) {\n                return;\n            }\n\n            // Service is not connected or initialized yet - See #54\n            if (binder == null || binder.getService() == null || binder.getService().getSettings() == null) {\n                return;\n            }\n\n            if (!binder.getService().getSettings().isReconnectEnabled() && !reconnectDialogActive) {\n                reconnectDialogActive = true;\n                AlertDialog.Builder builder = new AlertDialog.Builder(this);\n                builder.setMessage(getResources().getString(R.string.reconnect_after_disconnect, server.getTitle()))\n                .setCancelable(false)\n                .setPositiveButton(\"Yes\", new DialogInterface.OnClickListener() {\n                    @Override\n                    public void onClick(DialogInterface dialog, int id) {\n                        if (!server.isDisconnected()) {\n                            reconnectDialogActive = false;\n                            return;\n                        }\n                        binder.getService().getConnection(server.getId()).setAutojoinChannels(\n                                server.getCurrentChannelNames()\n                                );\n                        server.setStatus(Status.CONNECTING);\n                        binder.connect(server);\n                        reconnectDialogActive = false;\n                    }\n                })\n                .setNegativeButton(getString(R.string.negative_button), new DialogInterface.OnClickListener() {\n                    @Override\n                    public void onClick(DialogInterface dialog, int id) {\n                        server.setMayReconnect(false);\n                        reconnectDialogActive = false;\n                        dialog.cancel();\n                    }\n                });\n                AlertDialog alert = builder.create();\n                alert.show();\n            }\n        }\n    }\n\n    /**\n     * On activity result\n     */\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent data)\n    {\n        if (resultCode != RESULT_OK) {\n            // ignore other result codes\n            return;\n        }\n\n        switch (requestCode) {\n            case REQUEST_CODE_SPEECH:\n                ArrayList<String> matches = data.getStringArrayListExtra(RecognizerIntent.EXTRA_RESULTS);\n                if (matches.size() > 0) {\n                    ((EditText) findViewById(R.id.input)).setText(matches.get(0));\n                }\n                break;\n            case REQUEST_CODE_JOIN:\n                joinChannelBuffer = data.getExtras().getString(\"channel\");\n                break;\n            case REQUEST_CODE_USERS:\n                Intent intent = new Intent(this, UserActivity.class);\n                intent.putExtra(Extra.USER, data.getStringExtra(Extra.USER));\n                startActivityForResult(intent, REQUEST_CODE_USER);\n                break;\n            case REQUEST_CODE_NICK_COMPLETION:\n                insertNickCompletion((EditText) findViewById(R.id.input), data.getExtras().getString(Extra.USER));\n                break;\n            case REQUEST_CODE_USER:\n                final int actionId = data.getExtras().getInt(Extra.ACTION);\n                final String nickname = data.getExtras().getString(Extra.USER);\n                final IRCConnection connection = binder.getService().getConnection(server.getId());\n                final String conversation = server.getSelectedConversation();\n                final Handler handler = new Handler();\n\n                // XXX: Implement me - The action should be handled after onResume()\n                //                     to catch the broadcasts... now we just wait a second\n                // Yes .. that's very ugly - we need some kind of queue that is handled after onResume()\n\n                new Thread() {\n                    @Override\n                    public void run() {\n                        try {\n                            Thread.sleep(1000);\n                        } catch (InterruptedException e) {\n                            // Do nothing\n                        }\n\n                        String nicknameWithoutPrefix = nickname;\n\n                        while (\n                                nicknameWithoutPrefix.startsWith(\"@\") ||\n                                nicknameWithoutPrefix.startsWith(\"+\") ||\n                                nicknameWithoutPrefix.startsWith(\".\") ||\n                                nicknameWithoutPrefix.startsWith(\"%\")\n                                ) {\n                            // Strip prefix(es) now\n                            nicknameWithoutPrefix = nicknameWithoutPrefix.substring(1);\n                        }\n\n                        switch (actionId) {\n                            case User.ACTION_REPLY:\n                                final String replyText = nicknameWithoutPrefix + \": \";\n                                handler.post(new Runnable() {\n                                    @Override\n                                    public void run() {\n                                        EditText input = (EditText) findViewById(R.id.input);\n                                        input.setText(replyText);\n                                        input.setSelection(replyText.length());\n                                    }\n                                });\n                                break;\n                            case User.ACTION_QUERY:\n                                Conversation query = server.getConversation(nicknameWithoutPrefix);\n                                if (query == null) {\n                                    // Open a query if there's none yet\n                                    query = new Query(nicknameWithoutPrefix);\n                                    query.setHistorySize(binder.getService().getSettings().getHistorySize());\n                                    server.addConversation(query);\n\n                                    Intent intent = Broadcast.createConversationIntent(\n                                            Broadcast.CONVERSATION_NEW,\n                                            server.getId(),\n                                            nicknameWithoutPrefix\n                                            );\n                                    binder.getService().sendBroadcast(intent);\n                                }\n                                break;\n                            case User.ACTION_OP:\n                                connection.op(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_DEOP:\n                                connection.deOp(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_VOICE:\n                                connection.voice(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_DEVOICE:\n                                connection.deVoice(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_KICK:\n                                connection.kick(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_BAN:\n                                connection.ban(conversation, nicknameWithoutPrefix + \"!*@*\");\n                                break;\n                        }\n                    }\n                }.start();\n\n                break;\n        }\n    }\n\n    /**\n     * Send a message in this conversation\n     *\n     * @param text The text of the message\n     */\n    private void sendMessage(String text) {\n        if (text.equals(\"\")) {\n            // ignore empty messages\n            return;\n        }\n\n        if (!server.isConnected()) {\n            Message message = new Message(getString(R.string.message_not_connected));\n            message.setColor(Message.COLOR_RED);\n            message.setIcon(R.drawable.error);\n            server.getConversation(server.getSelectedConversation()).addMessage(message);\n            onConversationMessage(server.getSelectedConversation());\n        }\n\n        scrollback.addMessage(text);\n\n        Conversation conversation = pagerAdapter.getItem(pager.getCurrentItem());\n\n        if (conversation != null) {\n            if (!text.trim().startsWith(\"/\")) {\n                if (conversation.getType() != Conversation.TYPE_SERVER) {\n                    String nickname = binder.getService().getConnection(serverId).getNick();\n                    //conversation.addMessage(new Message(\"<\" + nickname + \"> \" + text));\n                    conversation.addMessage(new Message(text, nickname));\n                    binder.getService().getConnection(serverId).sendMessage(conversation.getName(), text);\n                } else {\n                    Message message = new Message(getString(R.string.chat_only_form_channel));\n                    message.setColor(Message.COLOR_YELLOW);\n                    message.setIcon(R.drawable.warning);\n                    conversation.addMessage(message);\n                }\n                onConversationMessage(conversation.getName());\n            } else {\n                CommandParser.getInstance().parse(text, server, conversation, binder.getService());\n            }\n        }\n    }\n\n    /**\n     * Complete a nick in the input line\n     */\n    private void doNickCompletion(EditText input) {\n        String text = input.getText().toString();\n\n        if (text.length() <= 0) {\n            return;\n        }\n\n        String[] tokens = text.split(\"[\\\\s,.-]+\");\n\n        if (tokens.length <= 0) {\n            return;\n        }\n\n        String word = tokens[tokens.length - 1].toLowerCase();\n        tokens[tokens.length - 1] = null;\n\n        int begin   = input.getSelectionStart();\n        int end     = input.getSelectionEnd();\n        int cursor  = Math.min(begin, end);\n        int sel_end = Math.max(begin, end);\n\n        boolean in_selection = (cursor != sel_end);\n\n        if (in_selection) {\n            word = text.substring(cursor, sel_end);\n        } else {\n            // use the word at the curent cursor position\n            while (true) {\n                cursor -= 1;\n                if (cursor <= 0 || text.charAt(cursor) == ' ') {\n                    break;\n                }\n            }\n\n            if (cursor < 0) {\n                cursor = 0;\n            }\n\n            if (text.charAt(cursor) == ' ') {\n                cursor += 1;\n            }\n\n            sel_end = text.indexOf(' ', cursor);\n\n            if (sel_end == -1) {\n                sel_end = text.length();\n            }\n\n            word = text.substring(cursor, sel_end);\n        }\n        // Log.d(\"Yaaic\", \"Trying to complete nick: \" + word);\n\n        Conversation conversationForUserList = pagerAdapter.getItem(pager.getCurrentItem());\n\n        String[] users = null;\n\n        if (conversationForUserList.getType() == Conversation.TYPE_CHANNEL) {\n            users = binder.getService().getConnection(server.getId()).getUsersAsStringArray(\n                    conversationForUserList.getName()\n                    );\n        }\n\n        // go through users and add matches\n        if (users != null) {\n            List<Integer> result = new ArrayList<Integer>();\n\n            for (int i = 0; i < users.length; i++) {\n                String nick = removeStatusChar(users[i].toLowerCase());\n                if (nick.startsWith(word.toLowerCase())) {\n                    result.add(Integer.valueOf(i));\n                }\n            }\n\n            if (result.size() == 1) {\n                input.setSelection(cursor, sel_end);\n                insertNickCompletion(input, users[result.get(0).intValue()]);\n            } else if (result.size() > 0) {\n                Intent intent  = new Intent(this, UsersActivity.class);\n                String[] extra = new String[result.size()];\n                int i = 0;\n\n                for (Integer n : result) {\n                    extra[i++] = users[n.intValue()];\n                }\n\n                input.setSelection(cursor, sel_end);\n                intent.putExtra(Extra.USERS, extra);\n                startActivityForResult(intent, REQUEST_CODE_NICK_COMPLETION);\n            }\n        }\n    }\n\n    /**\n     * Insert a given nick completion into the input line\n     *\n     * @param input The input line widget, with the incomplete nick selected\n     * @param nick The completed nick\n     */\n    private void insertNickCompletion(EditText input, String nick) {\n        int start = input.getSelectionStart();\n        int end  = input.getSelectionEnd();\n        nick = removeStatusChar(nick);\n\n        if (start == 0) {\n            nick += \":\";\n        }\n\n        nick += \" \";\n        input.getText().replace(start, end, nick, 0, nick.length());\n        // put cursor after inserted text\n        input.setSelection(start + nick.length());\n        input.clearComposingText();\n        input.post(new Runnable() {\n            @Override\n            public void run() {\n                // make the softkeyboard come up again (only if no hw keyboard is attached)\n                EditText input = (EditText) findViewById(R.id.input);\n                openSoftKeyboard(input);\n            }\n        });\n\n        input.requestFocus();\n    }\n\n    /**\n     * Open the soft keyboard (helper function)\n     */\n    private void openSoftKeyboard(View view) {\n        ((InputMethodManager) getSystemService(INPUT_METHOD_SERVICE)).showSoftInput(view, InputMethodManager.SHOW_IMPLICIT);\n    }\n\n    /**\n     * Remove the status char off the front of a nick if one is present\n     *\n     * @param nick\n     * @return nick without statuschar\n     */\n    private String removeStatusChar(String nick)\n    {\n        /* Discard status characters */\n        if (nick.startsWith(\"@\") || nick.startsWith(\"+\")\n                || nick.startsWith(\"%\")) {\n            nick = nick.substring(1);\n        }\n        return nick;\n    }\n}\n","Method after Refactoring":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2011 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage org.yaaic.activity;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.adapter.ConversationPagerAdapter;\nimport org.yaaic.adapter.MessageListAdapter;\nimport org.yaaic.command.CommandParser;\nimport org.yaaic.irc.IRCBinder;\nimport org.yaaic.irc.IRCConnection;\nimport org.yaaic.irc.IRCService;\nimport org.yaaic.listener.ConversationListener;\nimport org.yaaic.listener.ServerListener;\nimport org.yaaic.listener.SpeechClickListener;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.model.Extra;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Query;\nimport org.yaaic.model.Scrollback;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.ServerInfo;\nimport org.yaaic.model.Settings;\nimport org.yaaic.model.Status;\nimport org.yaaic.model.User;\nimport org.yaaic.receiver.ConversationReceiver;\nimport org.yaaic.receiver.ServerReceiver;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.content.ComponentName;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.content.pm.PackageManager;\nimport android.content.pm.ResolveInfo;\nimport android.content.res.Configuration;\nimport android.graphics.Typeface;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.speech.RecognizerIntent;\nimport android.support.v4.view.ViewPager;\nimport android.text.InputType;\nimport android.util.DisplayMetrics;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.View.OnKeyListener;\nimport android.view.Window;\nimport android.view.WindowManager;\nimport android.view.inputmethod.EditorInfo;\nimport android.view.inputmethod.InputMethodManager;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.Toast;\n\nimport com.viewpagerindicator.TitlePageIndicator;\n\n/**\n * The server view with a scrollable list of all channels\n *\n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class ConversationActivity extends Activity implements ServiceConnection, ServerListener, ConversationListener\n{\n    public static final int REQUEST_CODE_SPEECH = 99;\n\n    private static final int REQUEST_CODE_JOIN = 1;\n    private static final int REQUEST_CODE_USERS = 2;\n    private static final int REQUEST_CODE_USER = 3;\n    private static final int REQUEST_CODE_NICK_COMPLETION= 4;\n\n    private int serverId;\n    private Server server;\n    private IRCBinder binder;\n    private ConversationReceiver channelReceiver;\n    private ServerReceiver serverReceiver;\n\n    private ViewPager pager;\n    private ConversationPagerAdapter pagerAdapter;\n\n    private Scrollback scrollback;\n\n    // XXX: This is ugly. This is a buffer for a channel that should be joined after showing the\n    //      JoinActivity. As onActivityResult() is called before onResume() a \"channel joined\"\n    //      broadcast may get lost as the broadcast receivers are registered in onResume() but the\n    //      join command would be called in onActivityResult(). joinChannelBuffer will save the\n    //      channel name in onActivityResult() and run the join command in onResume().\n    private String joinChannelBuffer;\n\n    private int historySize;\n\n    private boolean reconnectDialogActive = false;\n\n    OnKeyListener inputKeyListener = new OnKeyListener() {\n        /**\n         * On key pressed (input line)\n         */\n        @Override\n        public boolean onKey(View view, int keyCode, KeyEvent event)\n        {\n            EditText input = (EditText) view;\n\n            if (event.getAction() != KeyEvent.ACTION_DOWN) {\n                return false;\n            }\n\n            if (keyCode == KeyEvent.KEYCODE_DPAD_UP) {\n                String message = scrollback.goBack();\n                if (message != null) {\n                    input.setText(message);\n                }\n                return true;\n            }\n\n            if (keyCode == KeyEvent.KEYCODE_DPAD_DOWN) {\n                String message = scrollback.goForward();\n                if (message != null) {\n                    input.setText(message);\n                }\n                return true;\n            }\n\n            if (keyCode == KeyEvent.KEYCODE_ENTER) {\n                sendMessage(input.getText().toString());\n                input.setText(\"\");\n                return true;\n            }\n\n            // Nick completion\n            if (keyCode == KeyEvent.KEYCODE_SEARCH) {\n                doNickCompletion(input);\n                return true;\n            }\n\n            return false;\n        }\n    };\n\n    /**\n     * On create\n     */\n    @Override\n    protected void onCreate(Bundle savedInstanceState)\n    {\n        super.onCreate(savedInstanceState);\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n\n        serverId = getIntent().getExtras().getInt(\"serverId\");\n        server = Yaaic.getInstance().getServerById(serverId);\n        Settings settings = new Settings(this);\n\n        // Finish activity if server does not exist anymore - See #55\n        if (server == null) {\n            this.finish();\n        }\n\n        setTitle(\"Yaaic - \" + server.getTitle());\n\n        setContentView(R.layout.conversations);\n        if (settings.fullscreenConversations()){\n            getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);\n        }\n\n        boolean isLandscape = (getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE);\n\n        EditText input = (EditText) findViewById(R.id.input);\n        input.setOnKeyListener(inputKeyListener);\n\n        pager = (ViewPager) findViewById(R.id.pager);\n\n        pagerAdapter = new ConversationPagerAdapter(server);\n        pager.setAdapter(pagerAdapter);\n\n        TitlePageIndicator indicator = (TitlePageIndicator) findViewById(R.id.titleIndicator);\n        indicator.setTypeface(Typeface.MONOSPACE);\n        indicator.setViewPager(pager);\n\n        historySize = settings.getHistorySize();\n\n        if (server.getStatus() == Status.PRE_CONNECTING) {\n            server.clearConversations();\n            pagerAdapter.clearConversations();\n            server.getConversation(ServerInfo.DEFAULT_NAME).setHistorySize(historySize);\n        }\n\n        DisplayMetrics dm = new DisplayMetrics();\n        getWindowManager().getDefaultDisplay().getMetrics(dm);\n        float fontSize = settings.getFontSize() * dm.scaledDensity;\n        indicator.setTextSize(fontSize);\n\n        int padding = (int) (5 * dm.scaledDensity);\n        input.setPadding(padding, padding, padding, padding);\n        indicator.setTypeface(Typeface.MONOSPACE);\n\n        // Optimization : cache field lookups\n        Collection<Conversation> mConversations = server.getConversations();\n\n        for (Conversation conversation : mConversations) {\n            // Only scroll to new conversation if it was selected before\n            if (conversation.getStatus() == Conversation.STATUS_SELECTED) {\n                onNewConversation(conversation.getName());\n            } else {\n                createNewConversation(conversation.getName());\n            }\n        }\n\n        int setInputTypeFlags = 0;\n\n        if (settings.autoCorrectText()) {\n            setInputTypeFlags |= InputType.TYPE_TEXT_FLAG_AUTO_CORRECT;\n        } else {\n            // keep compatibility with api level 3\n            if ((android.os.Build.VERSION.SDK.charAt(0) - '0') >= 5) {\n                setInputTypeFlags |= 0x80000; // InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS\n            }\n        }\n        if (settings.autoCapSentences()) {\n            setInputTypeFlags |= InputType.TYPE_TEXT_FLAG_CAP_SENTENCES;\n        }\n\n        if (isLandscape && settings.imeExtract()) {\n            setInputTypeFlags |= InputType.TYPE_TEXT_VARIATION_SHORT_MESSAGE;\n        }\n\n        if (!settings.imeExtract()) {\n            input.setImeOptions(input.getImeOptions() | EditorInfo.IME_FLAG_NO_EXTRACT_UI);\n        }\n\n        input.setInputType(input.getInputType() | setInputTypeFlags);\n\n        // Create a new scrollback history\n        scrollback = new Scrollback();\n    }\n\n    /**\n     * On resume\n     */\n    @Override\n    public void onResume()\n    {\n        // register the receivers as early as possible, otherwise we may loose a broadcast message\n        channelReceiver = new ConversationReceiver(server.getId(), this);\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_MESSAGE));\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_NEW));\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_REMOVE));\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_TOPIC));\n\n        serverReceiver = new ServerReceiver(this);\n        registerReceiver(serverReceiver, new IntentFilter(Broadcast.SERVER_UPDATE));\n\n        super.onResume();\n\n        // Check if speech recognition is enabled and available\n        if (new Settings(this).isVoiceRecognitionEnabled()) {\n            PackageManager pm = getPackageManager();\n            Button speechButton = (Button) findViewById(R.id.speech);\n            List<ResolveInfo> activities = pm.queryIntentActivities(new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH), 0);\n\n            if (activities.size() != 0) {\n                ((Button) findViewById(R.id.speech)).setOnClickListener(new SpeechClickListener(this));\n                speechButton.setVisibility(View.VISIBLE);\n            }\n        }\n\n        // Start service\n        Intent intent = new Intent(this, IRCService.class);\n        intent.setAction(IRCService.ACTION_FOREGROUND);\n        startService(intent);\n        bindService(intent, this, 0);\n\n        if (!server.isConnected()) {\n            ((EditText) findViewById(R.id.input)).setEnabled(false);\n        } else {\n            ((EditText) findViewById(R.id.input)).setEnabled(true);\n        }\n\n        // Optimization - cache field lookup\n        Collection<Conversation> mConversations = server.getConversations();\n        MessageListAdapter mAdapter;\n\n        // Fill view with messages that have been buffered while paused\n        for (Conversation conversation : mConversations) {\n            String name = conversation.getName();\n            mAdapter = pagerAdapter.getItemAdapter(name);\n\n            if (mAdapter != null) {\n                mAdapter.addBulkMessages(conversation.getBuffer());\n                conversation.clearBuffer();\n            } else {\n                // Was conversation created while we were paused?\n                if (pagerAdapter.getPositionByName(name) == -1) {\n                    onNewConversation(name);\n                }\n            }\n\n            // Clear new message notifications for the selected conversation\n            if (conversation.getStatus() == Conversation.STATUS_SELECTED && conversation.getNewMentions() > 0) {\n                Intent ackIntent = new Intent(this, IRCService.class);\n                ackIntent.setAction(IRCService.ACTION_ACK_NEW_MENTIONS);\n                ackIntent.putExtra(IRCService.EXTRA_ACK_SERVERID, serverId);\n                ackIntent.putExtra(IRCService.EXTRA_ACK_CONVTITLE, name);\n                startService(ackIntent);\n            }\n        }\n\n        // Remove views for conversations that ended while we were paused\n        int numViews = pagerAdapter.getCount();\n        if (numViews > mConversations.size()) {\n            for (int i = 0; i < numViews; ++i) {\n                if (!mConversations.contains(pagerAdapter.getItem(i))) {\n                    pagerAdapter.removeConversation(i--);\n                    --numViews;\n                }\n            }\n        }\n\n        // Join channel that has been selected in JoinActivity (onActivityResult())\n        if (joinChannelBuffer != null) {\n            new Thread() {\n                @Override\n                public void run() {\n                    binder.getService().getConnection(serverId).joinChannel(joinChannelBuffer);\n                    joinChannelBuffer = null;\n                }\n            }.start();\n        }\n\n        server.setIsForeground(true);\n    }\n\n    /**\n     * On Pause\n     */\n    @Override\n    public void onPause()\n    {\n        super.onPause();\n\n        server.setIsForeground(false);\n\n        if (binder != null && binder.getService() != null) {\n            binder.getService().checkServiceStatus();\n        }\n\n        unbindService(this);\n        unregisterReceiver(channelReceiver);\n        unregisterReceiver(serverReceiver);\n    }\n\n    /**\n     * On service connected\n     */\n    @Override\n    public void onServiceConnected(ComponentName name, IBinder service)\n    {\n        this.binder = (IRCBinder) service;\n\n        // connect to irc server if connect has been requested\n        if (server.getStatus() == Status.PRE_CONNECTING && getIntent().hasExtra(\"connect\")) {\n            server.setStatus(Status.CONNECTING);\n            binder.connect(server);\n        } else {\n            onStatusUpdate();\n        }\n    }\n\n    /**\n     * On service disconnected\n     */\n    @Override\n    public void onServiceDisconnected(ComponentName name)\n    {\n        this.binder = null;\n    }\n\n    /**\n     * On options menu requested\n     */\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu)\n    {\n        super.onCreateOptionsMenu(menu);\n\n        // inflate from xml\n        MenuInflater inflater = getMenuInflater();\n        inflater.inflate(R.menu.conversations, menu);\n\n        return true;\n    }\n\n    /**\n     * On prepare options menu\n     */\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu)\n    {\n        menu.getItem(0).setEnabled(server.isConnected()); // join\n        menu.getItem(1).setEnabled(server.isConnected()); // users\n        menu.getItem(2).setEnabled(server.isConnected()); // close\n\n        return true;\n    }\n\n    /**\n     * On menu item selected\n     */\n    @Override\n    public boolean onMenuItemSelected(int featureId, MenuItem item)\n    {\n        switch (item.getItemId()) {\n            case R.id.disconnect:\n                server.setStatus(Status.DISCONNECTED);\n                server.setMayReconnect(false);\n                binder.getService().getConnection(serverId).quitServer();\n                server.clearConversations();\n                setResult(RESULT_OK);\n                finish();\n                break;\n\n            case R.id.close:\n                Conversation conversationToClose = pagerAdapter.getItem(pager.getCurrentItem());\n                // Make sure we part a channel when closing the channel conversation\n                if (conversationToClose.getType() == Conversation.TYPE_CHANNEL) {\n                    binder.getService().getConnection(serverId).partChannel(conversationToClose.getName());\n                }\n                else if (conversationToClose.getType() == Conversation.TYPE_QUERY) {\n                    server.removeConversation(conversationToClose.getName());\n                    onRemoveConversation(conversationToClose.getName());\n                } else {\n                    Toast.makeText(this, getResources().getString(R.string.close_server_window), Toast.LENGTH_SHORT).show();\n                }\n                break;\n\n            case R.id.join:\n                startActivityForResult(new Intent(this, JoinActivity.class), REQUEST_CODE_JOIN);\n                break;\n\n            case R.id.users:\n                Conversation conversationForUserList = pagerAdapter.getItem(pager.getCurrentItem());\n                if (conversationForUserList.getType() == Conversation.TYPE_CHANNEL) {\n                    Intent intent = new Intent(this, UsersActivity.class);\n                    intent.putExtra(\n                            Extra.USERS,\n                            binder.getService().getConnection(server.getId()).getUsersAsStringArray(\n                                    conversationForUserList.getName()\n                                    )\n                            );\n                    startActivityForResult(intent, REQUEST_CODE_USERS);\n                } else {\n                    Toast.makeText(this, getResources().getString(R.string.only_usable_from_channel), Toast.LENGTH_SHORT).show();\n                }\n                break;\n        }\n\n        return true;\n    }\n\n    /**\n     * Get server object assigned to this activity\n     *\n     * @return the server object\n     */\n    public Server getServer()\n    {\n        return server;\n    }\n\n    /**\n     * On conversation message\n     */\n    @Override\n    public void onConversationMessage(String target)\n    {\n        Conversation conversation = server.getConversation(target);\n\n        if (conversation == null) {\n            // In an early state it can happen that the conversation object\n            // is not created yet.\n            return;\n        }\n\n        MessageListAdapter adapter = pagerAdapter.getItemAdapter(target);\n\n        while(conversation.hasBufferedMessages()) {\n            Message message = conversation.pollBufferedMessage();\n\n            if (adapter != null && message != null) {\n                adapter.addMessage(message);\n                int status;\n\n                switch (message.getType())\n                {\n                    case Message.TYPE_MISC:\n                        status = Conversation.STATUS_MISC;\n                        break;\n\n                    default:\n                        status = Conversation.STATUS_MESSAGE;\n                        break;\n                }\n                conversation.setStatus(status);\n            }\n        }\n    }\n\n    /**\n     * On new conversation\n     */\n    @Override\n    public void onNewConversation(String target)\n    {\n        createNewConversation(target);\n\n        pager.setCurrentItem(pagerAdapter.getCount() - 1);\n    }\n\n    /**\n     * Create a new conversation in the pager adapter for the\n     * given target conversation.\n     *\n     * @param target\n     */\n    public void createNewConversation(String target)\n    {\n        pagerAdapter.addConversation(server.getConversation(target));\n    }\n\n    /**\n     * On conversation remove\n     */\n    @Override\n    public void onRemoveConversation(String target)\n    {\n        int position = pagerAdapter.getPositionByName(target);\n\n        if (position != -1) {\n            pagerAdapter.removeConversation(position);\n        }\n    }\n\n    /**\n     * On topic change\n     */\n    @Override\n    public void onTopicChanged(String target)\n    {\n        // No implementation\n    }\n\n    /**\n     * On server status update\n     */\n    @Override\n    public void onStatusUpdate()\n    {\n        EditText input = (EditText) findViewById(R.id.input);\n\n        if (server.isConnected()) {\n            input.setEnabled(true);\n        } else {\n            input.setEnabled(false);\n\n            if (server.getStatus() == Status.CONNECTING) {\n                return;\n            }\n\n            // Service is not connected or initialized yet - See #54\n            if (binder == null || binder.getService() == null || binder.getService().getSettings() == null) {\n                return;\n            }\n\n            if (!binder.getService().getSettings().isReconnectEnabled() && !reconnectDialogActive) {\n                reconnectDialogActive = true;\n                AlertDialog.Builder builder = new AlertDialog.Builder(this);\n                builder.setMessage(getResources().getString(R.string.reconnect_after_disconnect, server.getTitle()))\n                .setCancelable(false)\n                .setPositiveButton(\"Yes\", new DialogInterface.OnClickListener() {\n                    @Override\n                    public void onClick(DialogInterface dialog, int id) {\n                        if (!server.isDisconnected()) {\n                            reconnectDialogActive = false;\n                            return;\n                        }\n                        binder.getService().getConnection(server.getId()).setAutojoinChannels(\n                                server.getCurrentChannelNames()\n                                );\n                        server.setStatus(Status.CONNECTING);\n                        binder.connect(server);\n                        reconnectDialogActive = false;\n                    }\n                })\n                .setNegativeButton(getString(R.string.negative_button), new DialogInterface.OnClickListener() {\n                    @Override\n                    public void onClick(DialogInterface dialog, int id) {\n                        server.setMayReconnect(false);\n                        reconnectDialogActive = false;\n                        dialog.cancel();\n                    }\n                });\n                AlertDialog alert = builder.create();\n                alert.show();\n            }\n        }\n    }\n\n    /**\n     * On activity result\n     */\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent data)\n    {\n        if (resultCode != RESULT_OK) {\n            // ignore other result codes\n            return;\n        }\n\n        switch (requestCode) {\n            case REQUEST_CODE_SPEECH:\n                ArrayList<String> matches = data.getStringArrayListExtra(RecognizerIntent.EXTRA_RESULTS);\n                if (matches.size() > 0) {\n                    ((EditText) findViewById(R.id.input)).setText(matches.get(0));\n                }\n                break;\n            case REQUEST_CODE_JOIN:\n                joinChannelBuffer = data.getExtras().getString(\"channel\");\n                break;\n            case REQUEST_CODE_USERS:\n                Intent intent = new Intent(this, UserActivity.class);\n                intent.putExtra(Extra.USER, data.getStringExtra(Extra.USER));\n                startActivityForResult(intent, REQUEST_CODE_USER);\n                break;\n            case REQUEST_CODE_NICK_COMPLETION:\n                insertNickCompletion((EditText) findViewById(R.id.input), data.getExtras().getString(Extra.USER));\n                break;\n            case REQUEST_CODE_USER:\n                final int actionId = data.getExtras().getInt(Extra.ACTION);\n                final String nickname = data.getExtras().getString(Extra.USER);\n                final IRCConnection connection = binder.getService().getConnection(server.getId());\n                final String conversation = server.getSelectedConversation();\n                final Handler handler = new Handler();\n\n                // XXX: Implement me - The action should be handled after onResume()\n                //                     to catch the broadcasts... now we just wait a second\n                // Yes .. that's very ugly - we need some kind of queue that is handled after onResume()\n\n                new Thread() {\n                    @Override\n                    public void run() {\n                        try {\n                            Thread.sleep(1000);\n                        } catch (InterruptedException e) {\n                            // Do nothing\n                        }\n\n                        String nicknameWithoutPrefix = nickname;\n\n                        while (\n                                nicknameWithoutPrefix.startsWith(\"@\") ||\n                                nicknameWithoutPrefix.startsWith(\"+\") ||\n                                nicknameWithoutPrefix.startsWith(\".\") ||\n                                nicknameWithoutPrefix.startsWith(\"%\")\n                                ) {\n                            // Strip prefix(es) now\n                            nicknameWithoutPrefix = nicknameWithoutPrefix.substring(1);\n                        }\n\n                        switch (actionId) {\n                            case User.ACTION_REPLY:\n                                final String replyText = nicknameWithoutPrefix + \": \";\n                                handler.post(new Runnable() {\n                                    @Override\n                                    public void run() {\n                                        EditText input = (EditText) findViewById(R.id.input);\n                                        input.setText(replyText);\n                                        input.setSelection(replyText.length());\n                                    }\n                                });\n                                break;\n                            case User.ACTION_QUERY:\n                                Conversation query = server.getConversation(nicknameWithoutPrefix);\n                                if (query == null) {\n                                    // Open a query if there's none yet\n                                    query = new Query(nicknameWithoutPrefix);\n                                    query.setHistorySize(binder.getService().getSettings().getHistorySize());\n                                    server.addConversation(query);\n\n                                    Intent intent = Broadcast.createConversationIntent(\n                                            Broadcast.CONVERSATION_NEW,\n                                            server.getId(),\n                                            nicknameWithoutPrefix\n                                            );\n                                    binder.getService().sendBroadcast(intent);\n                                }\n                                break;\n                            case User.ACTION_OP:\n                                connection.op(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_DEOP:\n                                connection.deOp(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_VOICE:\n                                connection.voice(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_DEVOICE:\n                                connection.deVoice(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_KICK:\n                                connection.kick(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_BAN:\n                                connection.ban(conversation, nicknameWithoutPrefix + \"!*@*\");\n                                break;\n                        }\n                    }\n                }.start();\n\n                break;\n        }\n    }\n\n    /**\n     * Send a message in this conversation\n     *\n     * @param text The text of the message\n     */\n    private void sendMessage(String text) {\n        if (text.equals(\"\")) {\n            // ignore empty messages\n            return;\n        }\n\n        if (!server.isConnected()) {\n            Message message = new Message(getString(R.string.message_not_connected));\n            message.setColor(Message.COLOR_RED);\n            message.setIcon(R.drawable.error);\n            server.getConversation(server.getSelectedConversation()).addMessage(message);\n            onConversationMessage(server.getSelectedConversation());\n        }\n\n        scrollback.addMessage(text);\n\n        Conversation conversation = pagerAdapter.getItem(pager.getCurrentItem());\n\n        if (conversation != null) {\n            if (!text.trim().startsWith(\"/\")) {\n                if (conversation.getType() != Conversation.TYPE_SERVER) {\n                    String nickname = binder.getService().getConnection(serverId).getNick();\n                    //conversation.addMessage(new Message(\"<\" + nickname + \"> \" + text));\n                    conversation.addMessage(new Message(text, nickname));\n                    binder.getService().getConnection(serverId).sendMessage(conversation.getName(), text);\n                } else {\n                    Message message = new Message(getString(R.string.chat_only_form_channel));\n                    message.setColor(Message.COLOR_YELLOW);\n                    message.setIcon(R.drawable.warning);\n                    conversation.addMessage(message);\n                }\n                onConversationMessage(conversation.getName());\n            } else {\n                CommandParser.getInstance().parse(text, server, conversation, binder.getService());\n            }\n        }\n    }\n\n    /**\n     * Complete a nick in the input line\n     */\n    private void doNickCompletion(EditText input) {\n        String text = input.getText().toString();\n\n        if (text.length() <= 0) {\n            return;\n        }\n\n        String[] tokens = text.split(\"[\\\\s,.-]+\");\n\n        if (tokens.length <= 0) {\n            return;\n        }\n\n        String word = tokens[tokens.length - 1].toLowerCase();\n        tokens[tokens.length - 1] = null;\n\n        int begin   = input.getSelectionStart();\n        int end     = input.getSelectionEnd();\n        int cursor  = Math.min(begin, end);\n        int sel_end = Math.max(begin, end);\n\n        boolean in_selection = (cursor != sel_end);\n\n        if (in_selection) {\n            word = text.substring(cursor, sel_end);\n        } else {\n            // use the word at the curent cursor position\n            while (true) {\n                cursor -= 1;\n                if (cursor <= 0 || text.charAt(cursor) == ' ') {\n                    break;\n                }\n            }\n\n            if (cursor < 0) {\n                cursor = 0;\n            }\n\n            if (text.charAt(cursor) == ' ') {\n                cursor += 1;\n            }\n\n            sel_end = text.indexOf(' ', cursor);\n\n            if (sel_end == -1) {\n                sel_end = text.length();\n            }\n\n            word = text.substring(cursor, sel_end);\n        }\n        // Log.d(\"Yaaic\", \"Trying to complete nick: \" + word);\n\n        Conversation conversationForUserList = pagerAdapter.getItem(pager.getCurrentItem());\n\n        String[] users = null;\n\n        if (conversationForUserList.getType() == Conversation.TYPE_CHANNEL) {\n            users = binder.getService().getConnection(server.getId()).getUsersAsStringArray(\n                    conversationForUserList.getName()\n                    );\n        }\n\n        // go through users and add matches\n        if (users != null) {\n            List<Integer> result = new ArrayList<Integer>();\n\n            for (int i = 0; i < users.length; i++) {\n                String nick = removeStatusChar(users[i].toLowerCase());\n                if (nick.startsWith(word.toLowerCase())) {\n                    result.add(Integer.valueOf(i));\n                }\n            }\n\n            if (result.size() == 1) {\n                input.setSelection(cursor, sel_end);\n                insertNickCompletion(input, users[result.get(0).intValue()]);\n            } else if (result.size() > 0) {\n                Intent intent  = new Intent(this, UsersActivity.class);\n                String[] extra = new String[result.size()];\n                int i = 0;\n\n                for (Integer n : result) {\n                    extra[i++] = users[n.intValue()];\n                }\n\n                input.setSelection(cursor, sel_end);\n                intent.putExtra(Extra.USERS, extra);\n                startActivityForResult(intent, REQUEST_CODE_NICK_COMPLETION);\n            }\n        }\n    }\n\n    /**\n     * Insert a given nick completion into the input line\n     *\n     * @param input The input line widget, with the incomplete nick selected\n     * @param nick The completed nick\n     */\n    private void insertNickCompletion(EditText input, String nick) {\n        int start = input.getSelectionStart();\n        int end  = input.getSelectionEnd();\n        nick = removeStatusChar(nick);\n\n        if (start == 0) {\n            nick += \":\";\n        }\n\n        nick += \" \";\n        input.getText().replace(start, end, nick, 0, nick.length());\n        // put cursor after inserted text\n        input.setSelection(start + nick.length());\n        input.clearComposingText();\n        input.post(new Runnable() {\n            @Override\n            public void run() {\n                // make the softkeyboard come up again (only if no hw keyboard is attached)\n                EditText input = (EditText) findViewById(R.id.input);\n                openSoftKeyboard(input);\n            }\n        });\n\n        input.requestFocus();\n    }\n\n    /**\n     * Open the soft keyboard (helper function)\n     */\n    private void openSoftKeyboard(View view) {\n        ((InputMethodManager) getSystemService(INPUT_METHOD_SERVICE)).showSoftInput(view, InputMethodManager.SHOW_IMPLICIT);\n    }\n\n    /**\n     * Remove the status char off the front of a nick if one is present\n     *\n     * @param nick\n     * @return nick without statuschar\n     */\n    private String removeStatusChar(String nick)\n    {\n        /* Discard status characters */\n        if (nick.startsWith(\"@\") || nick.startsWith(\"+\")\n                || nick.startsWith(\"%\")) {\n            nick = nick.substring(1);\n        }\n        return nick;\n    }\n}\n","lineNo":216}
{"Smelly Sample":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2011 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage org.yaaic.activity;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.adapter.DeckAdapter;\nimport org.yaaic.adapter.MessageListAdapter;\nimport org.yaaic.command.CommandParser;\nimport org.yaaic.irc.IRCBinder;\nimport org.yaaic.irc.IRCConnection;\nimport org.yaaic.irc.IRCService;\nimport org.yaaic.layout.NonScalingBackgroundDrawable;\nimport org.yaaic.listener.ConversationClickListener;\nimport org.yaaic.listener.ConversationListener;\nimport org.yaaic.listener.ConversationSelectedListener;\nimport org.yaaic.listener.ServerListener;\nimport org.yaaic.listener.SpeechClickListener;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.model.Extra;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Query;\nimport org.yaaic.model.Scrollback;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.ServerInfo;\nimport org.yaaic.model.Settings;\nimport org.yaaic.model.Status;\nimport org.yaaic.model.User;\nimport org.yaaic.receiver.ConversationReceiver;\nimport org.yaaic.receiver.ServerReceiver;\nimport org.yaaic.view.ConversationSwitcher;\nimport org.yaaic.view.MessageListView;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.content.ComponentName;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.content.pm.PackageManager;\nimport android.content.pm.ResolveInfo;\nimport android.content.res.Configuration;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.speech.RecognizerIntent;\nimport android.text.InputType;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.Window;\nimport android.view.WindowManager;\nimport android.view.View.OnKeyListener;\nimport android.view.inputmethod.EditorInfo;\nimport android.view.inputmethod.InputMethodManager;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.Gallery;\nimport android.widget.ImageView;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport android.widget.ViewSwitcher;\n\n/**\n * The server view with a scrollable list of all channels\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class ConversationActivity extends Activity implements ServiceConnection, ServerListener, ConversationListener\n{\n    public static final int REQUEST_CODE_SPEECH = 99;\n\n    private static final int REQUEST_CODE_JOIN = 1;\n    private static final int REQUEST_CODE_USERS = 2;\n    private static final int REQUEST_CODE_USER = 3;\n    private static final int REQUEST_CODE_NICK_COMPLETION= 4;\n\n    private int serverId;\n    private Server server;\n    private IRCBinder binder;\n    private ConversationReceiver channelReceiver;\n    private ServerReceiver serverReceiver;\n\n    private ViewSwitcher switcher;\n    private Gallery deck;\n    private DeckAdapter deckAdapter;\n    private Scrollback scrollback;\n    private ConversationSwitcher dots;\n\n    // XXX: This is ugly. This is a buffer for a channel that should be joined after showing the\n    //      JoinActivity. As onActivityResult() is called before onResume() a \"channel joined\"\n    //      broadcast may get lost as the broadcast receivers are registered in onResume() but the\n    //      join command would be called in onActivityResult(). joinChannelBuffer will save the\n    //      channel name in onActivityResult() and run the join command in onResume().\n    private String joinChannelBuffer;\n\n    private int historySize;\n\n    private boolean reconnectDialogActive = false;\n\n    OnKeyListener inputKeyListener = new OnKeyListener() {\n        /**\n         * On key pressed (input line)\n         */\n        @Override\n        public boolean onKey(View view, int keyCode, KeyEvent event)\n        {\n            EditText input = (EditText) view;\n\n            if (event.getAction() != KeyEvent.ACTION_DOWN) {\n                return false;\n            }\n\n            if (keyCode == KeyEvent.KEYCODE_DPAD_UP) {\n                String message = scrollback.goBack();\n                if (message != null) {\n                    input.setText(message);\n                }\n                return true;\n            }\n\n            if (keyCode == KeyEvent.KEYCODE_DPAD_DOWN) {\n                String message = scrollback.goForward();\n                if (message != null) {\n                    input.setText(message);\n                }\n                return true;\n            }\n\n            if (keyCode == KeyEvent.KEYCODE_ENTER) {\n                sendMessage(input.getText().toString());\n                input.setText(\"\");\n                return true;\n            }\n\n            // Nick completion\n            if (keyCode == KeyEvent.KEYCODE_SEARCH) {\n                doNickCompletion(input);\n                return true;\n            }\n\n            return false;\n        }\n    };\n\n    /**\n     * On create\n     */\n    @Override\n    protected void onCreate(Bundle savedInstanceState)\n    {\n        super.onCreate(savedInstanceState);\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n\n        serverId = getIntent().getExtras().getInt(\"serverId\");\n        server = Yaaic.getInstance().getServerById(serverId);\n        Settings settings = new Settings(this);\n\n        // Finish activity if server does not exist anymore - See #55\n        if (server == null) {\n            this.finish();\n        }\n\n        setTitle(\"Yaaic - \" + server.getTitle());\n\n        setContentView(R.layout.conversations);\n        if (settings.fullscreenConversations()){\n            getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);\n        }\n\n        boolean isLandscape = (getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE);\n\n        ((TextView) findViewById(R.id.title)).setText(server.getTitle());\n\n        EditText input = (EditText) findViewById(R.id.input);\n        input.setOnKeyListener(inputKeyListener);\n\n        switcher = (ViewSwitcher) findViewById(R.id.switcher);\n\n        dots = (ConversationSwitcher) findViewById(R.id.dots);\n        dots.setServer(server);\n\n        deckAdapter = new DeckAdapter();\n        deck = (Gallery) findViewById(R.id.deck);\n        deck.setOnItemSelectedListener(new ConversationSelectedListener(this, server, (TextView) findViewById(R.id.title), dots));\n        deck.setAdapter(deckAdapter);\n        deck.setOnItemClickListener(new ConversationClickListener(deckAdapter, switcher));\n        deck.setBackgroundDrawable(new NonScalingBackgroundDrawable(this, deck, R.drawable.background));\n\n        historySize = settings.getHistorySize();\n\n        if (server.getStatus() == Status.PRE_CONNECTING) {\n            server.clearConversations();\n            deckAdapter.clearConversations();\n            server.getConversation(ServerInfo.DEFAULT_NAME).setHistorySize(historySize);\n        }\n\n        // Optimization : cache field lookups\n        Collection<Conversation> mConversations = server.getConversations();\n\n        for (Conversation conversation : mConversations) {\n            // Only scroll to new conversation if it was selected before\n            if (conversation.getStatus() == Conversation.STATUS_SELECTED) {\n                onNewConversation(conversation.getName());\n            } else {\n                createNewConversation(conversation.getName());\n            }\n        }\n\n        int setInputTypeFlags = 0;\n\n        if (settings.autoCorrectText()) {\n            setInputTypeFlags |= InputType.TYPE_TEXT_FLAG_AUTO_CORRECT;\n        } else {\n            // keep compatibility with api level 3\n            if ((android.os.Build.VERSION.SDK.charAt(0) - '0') >= 5) {\n                setInputTypeFlags |= 0x80000; // InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS\n            }\n        }\n        if (settings.autoCapSentences()) {\n            setInputTypeFlags |= InputType.TYPE_TEXT_FLAG_CAP_SENTENCES;\n        }\n\n        if (isLandscape && settings.imeExtract()) {\n            setInputTypeFlags |= InputType.TYPE_TEXT_VARIATION_SHORT_MESSAGE;\n        }\n\n        if (!settings.imeExtract()) {\n            input.setImeOptions(input.getImeOptions() | EditorInfo.IME_FLAG_NO_EXTRACT_UI);\n        }\n\n        input.setInputType(input.getInputType() | setInputTypeFlags);\n\n        // Create a new scrollback history\n        scrollback = new Scrollback();\n    }\n\n    /**\n     * On resume\n     */\n    @Override\n    public void onResume()\n    {\n        // register the receivers as early as possible, otherwise we may loose a broadcast message\n        channelReceiver = new ConversationReceiver(server.getId(), this);\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_MESSAGE));\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_NEW));\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_REMOVE));\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_TOPIC));\n\n        serverReceiver = new ServerReceiver(this);\n        registerReceiver(serverReceiver, new IntentFilter(Broadcast.SERVER_UPDATE));\n\n        super.onResume();\n\n        // Check if speech recognition is enabled and available\n        if (new Settings(this).isVoiceRecognitionEnabled()) {\n            PackageManager pm = getPackageManager();\n            Button speechButton = (Button) findViewById(R.id.speech);\n            List<ResolveInfo> activities = pm.queryIntentActivities(new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH), 0);\n\n            if (activities.size() != 0) {\n                ((Button) findViewById(R.id.speech)).setOnClickListener(new SpeechClickListener(this));\n                speechButton.setVisibility(View.VISIBLE);\n            }\n        }\n\n        ((ImageView) findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\n        // Start service\n        Intent intent = new Intent(this, IRCService.class);\n        intent.setAction(IRCService.ACTION_FOREGROUND);\n        startService(intent);\n        bindService(intent, this, 0);\n\n        if (!server.isConnected()) {\n            ((EditText) findViewById(R.id.input)).setEnabled(false);\n        } else {\n            ((EditText) findViewById(R.id.input)).setEnabled(true);\n        }\n\n        // Optimization - cache field lookup\n        Collection<Conversation> mConversations = server.getConversations();\n        MessageListAdapter mAdapter;\n\n        // Fill view with messages that have been buffered while paused\n        for (Conversation conversation : mConversations) {\n            mAdapter = deckAdapter.getItemAdapter(conversation.getName());\n\n            if (mAdapter != null) {\n                mAdapter.addBulkMessages(conversation.getBuffer());\n                conversation.clearBuffer();\n            }\n\n            // Clear new message notifications for the selected conversation\n            if (conversation.getStatus() == Conversation.STATUS_SELECTED && conversation.getNewMentions() > 0) {\n                Intent ackIntent = new Intent(this, IRCService.class);\n                ackIntent.setAction(IRCService.ACTION_ACK_NEW_MENTIONS);\n                ackIntent.putExtra(IRCService.EXTRA_ACK_SERVERID, serverId);\n                ackIntent.putExtra(IRCService.EXTRA_ACK_CONVTITLE, conversation.getName());\n                startService(ackIntent);\n            }\n        }\n\n        // Join channel that has been selected in JoinActivity (onActivityResult())\n        if (joinChannelBuffer != null) {\n            new Thread() {\n                @Override\n                public void run() {\n                    binder.getService().getConnection(serverId).joinChannel(joinChannelBuffer);\n                    joinChannelBuffer = null;\n                }\n            }.start();\n        }\n\n        server.setIsForeground(true);\n    }\n\n    /**\n     * On Pause\n     */\n    @Override\n    public void onPause()\n    {\n        super.onPause();\n\n        server.setIsForeground(false);\n\n        if (binder != null && binder.getService() != null) {\n            binder.getService().checkServiceStatus();\n        }\n\n        unbindService(this);\n        unregisterReceiver(channelReceiver);\n        unregisterReceiver(serverReceiver);\n    }\n\n    /**\n     * On save instance state (e.g. before a configuration change)\n     */\n    @Override\n    protected void onSaveInstanceState(Bundle outState)\n    {\n        super.onSaveInstanceState(outState);\n\n        if (deckAdapter.isSwitched()) {\n            outState.putBoolean(\"isSwitched\", deckAdapter.isSwitched());\n            outState.putString(\"switchedName\", deckAdapter.getSwitchedName());\n        }\n    }\n\n    /**\n     * On restore instance state (e.g. after a configuration change)\n     */\n    @Override\n    protected void onRestoreInstanceState(Bundle inState)\n    {\n        super.onRestoreInstanceState(inState);\n\n        if (inState.getBoolean(\"isSwitched\")) {\n            deckAdapter.setSwitched(inState.getString(\"switchedName\"), null);\n        }\n    }\n\n    /**\n     * On service connected\n     */\n    @Override\n    public void onServiceConnected(ComponentName name, IBinder service)\n    {\n        this.binder = (IRCBinder) service;\n\n        // connect to irc server if connect has been requested\n        if (server.getStatus() == Status.PRE_CONNECTING && getIntent().hasExtra(\"connect\")) {\n            server.setStatus(Status.CONNECTING);\n            binder.connect(server);\n        } else {\n            onStatusUpdate();\n        }\n    }\n\n    /**\n     * On service disconnected\n     */\n    @Override\n    public void onServiceDisconnected(ComponentName name)\n    {\n        this.binder = null;\n    }\n\n    /**\n     * On options menu requested\n     */\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu)\n    {\n        super.onCreateOptionsMenu(menu);\n\n        // inflate from xml\n        MenuInflater inflater = getMenuInflater();\n        inflater.inflate(R.menu.conversations, menu);\n\n        return true;\n    }\n\n    /**\n     * On prepare options menu\n     */\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu)\n    {\n        menu.getItem(0).setEnabled(server.isConnected()); // join\n        menu.getItem(1).setEnabled(server.isConnected()); // users\n        menu.getItem(2).setEnabled(server.isConnected()); // close\n\n        return true;\n    }\n\n    /**\n     * On menu item selected\n     */\n    @Override\n    public boolean onMenuItemSelected(int featureId, MenuItem item)\n    {\n        switch (item.getItemId()) {\n            case R.id.disconnect:\n                server.setStatus(Status.DISCONNECTED);\n                server.setMayReconnect(false);\n                binder.getService().getConnection(serverId).quitServer();\n                server.clearConversations();\n                setResult(RESULT_OK);\n                finish();\n                break;\n\n            case R.id.close:\n                Conversation conversationToClose = deckAdapter.getItem(deck.getSelectedItemPosition());\n                // Make sure we part a channel when closing the channel conversation\n                if (conversationToClose.getType() == Conversation.TYPE_CHANNEL) {\n                    binder.getService().getConnection(serverId).partChannel(conversationToClose.getName());\n                }\n                else if (conversationToClose.getType() == Conversation.TYPE_QUERY) {\n                    server.removeConversation(conversationToClose.getName());\n                    onRemoveConversation(conversationToClose.getName());\n                } else {\n                    Toast.makeText(this, getResources().getString(R.string.close_server_window), Toast.LENGTH_SHORT).show();\n                }\n                break;\n\n            case R.id.join:\n                startActivityForResult(new Intent(this, JoinActivity.class), REQUEST_CODE_JOIN);\n                break;\n\n            case R.id.users:\n                Conversation conversationForUserList = deckAdapter.getItem(deck.getSelectedItemPosition());\n                if (conversationForUserList.getType() == Conversation.TYPE_CHANNEL) {\n                    Intent intent = new Intent(this, UsersActivity.class);\n                    intent.putExtra(\n                        Extra.USERS,\n                        binder.getService().getConnection(server.getId()).getUsersAsStringArray(\n                            conversationForUserList.getName()\n                        )\n                    );\n                    startActivityForResult(intent, REQUEST_CODE_USERS);\n                } else {\n                    Toast.makeText(this, getResources().getString(R.string.only_usable_from_channel), Toast.LENGTH_SHORT).show();\n                }\n                break;\n        }\n\n        return true;\n    }\n\n    /**\n     * Get server object assigned to this activity\n     * \n     * @return the server object\n     */\n    public Server getServer()\n    {\n        return server;\n    }\n\n    /**\n     * On conversation message\n     */\n    @Override\n    public void onConversationMessage(String target)\n    {\n        Conversation conversation = server.getConversation(target);\n\n        if (conversation == null) {\n            // In an early state it can happen that the conversation object\n            // is not created yet.\n            return;\n        }\n\n        MessageListAdapter adapter = deckAdapter.getItemAdapter(target);\n\n        while(conversation.hasBufferedMessages()) {\n            Message message = conversation.pollBufferedMessage();\n\n            if (adapter != null && message != null) {\n                adapter.addMessage(message);\n                int status;\n\n                switch (message.getType())\n                {\n                    case Message.TYPE_MISC:\n                        status = Conversation.STATUS_MISC;\n                        break;\n\n                    default:\n                        status = Conversation.STATUS_MESSAGE;\n                        break;\n                }\n                conversation.setStatus(status);\n            }\n        }\n\n        if (dots != null) {\n            dots.invalidate();\n        }\n    }\n\n    /**\n     * On new conversation\n     */\n    @Override\n    public void onNewConversation(String target)\n    {\n        createNewConversation(target);\n\n        if (!deckAdapter.isSwitched()) {\n            // Scroll to new conversation\n            deck.setSelection(deckAdapter.getCount() - 1);\n        }\n    }\n    public void createNewConversation(String target)\n    {\n        deckAdapter.addItem(server.getConversation(target));\n    }\n\n    /**\n     * On conversation remove\n     */\n    @Override\n    public void onRemoveConversation(String target)\n    {\n        deckAdapter.removeItem(target);\n\n        if (deckAdapter.isSwitched()) {\n            switcher.showNext();\n            switcher.removeView(deckAdapter.getSwitchedView());\n            deckAdapter.setSwitched(null, null);\n        }\n    }\n\n    /**\n     * On topic change\n     */\n    public void onTopicChanged(String target)\n    {\n        String selected = server.getSelectedConversation();\n        if (selected.equals(target)) {\n            // onTopicChanged is only called for channels\n            Channel channel = (Channel) server.getConversation(selected);\n            StringBuilder sb = new StringBuilder();\n            sb.append(server.getTitle() + \" - \" + channel.getName());\n            if (!(channel.getTopic()).equals(\"\")) {\n                sb.append(\" - \" + channel.getTopic());\n            }\n            ((TextView) findViewById(R.id.title)).setText(sb.toString());\n        }\n    }\n\n    /**\n     * On server status update\n     */\n    @Override\n    public void onStatusUpdate()\n    {\n        ((ImageView) findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\n        EditText input = (EditText) findViewById(R.id.input);\n\n        if (server.isConnected()) {\n            input.setEnabled(true);\n        } else {\n            input.setEnabled(false);\n\n            if (server.getStatus() == Status.CONNECTING) {\n                return;\n            }\n\n            // Service is not connected or initialized yet - See #54\n            if (binder == null || binder.getService() == null || binder.getService().getSettings() == null) {\n                return;\n            }\n\n            if (!binder.getService().getSettings().isReconnectEnabled() && !reconnectDialogActive) {\n                reconnectDialogActive = true;\n                AlertDialog.Builder builder = new AlertDialog.Builder(this);\n                builder.setMessage(getResources().getString(R.string.reconnect_after_disconnect, server.getTitle()))\n                .setCancelable(false)\n                .setPositiveButton(\"Yes\", new DialogInterface.OnClickListener() {\n                    @Override\n                    public void onClick(DialogInterface dialog, int id) {\n                        if (!server.isDisconnected()) {\n                            reconnectDialogActive = false;\n                            return;\n                        }\n                        binder.getService().getConnection(server.getId()).setAutojoinChannels(\n                            server.getCurrentChannelNames()\n                        );\n                        server.setStatus(Status.CONNECTING);\n                        binder.connect(server);\n                        reconnectDialogActive = false;\n                    }\n                })\n                .setNegativeButton(getString(R.string.negative_button), new DialogInterface.OnClickListener() {\n                    @Override\n                    public void onClick(DialogInterface dialog, int id) {\n                        server.setMayReconnect(false);\n                        reconnectDialogActive = false;\n                        dialog.cancel();\n                    }\n                });\n                AlertDialog alert = builder.create();\n                alert.show();\n            }\n        }\n    }\n\n    /**\n     * On key down\n     *\n     * XXX: As we only track the back key: Android >= 2.0 will call a method called onBackPressed()\n     */\n    @Override\n    public boolean onKeyDown(int keyCode, KeyEvent event)\n    {\n        if (keyCode == KeyEvent.KEYCODE_BACK && event.getRepeatCount() == 0) {\n            if (deckAdapter.isSwitched()) {\n                MessageListView canvas = (MessageListView) deckAdapter.getView(deckAdapter.getPositionByName(deckAdapter.getSwitchedName()), null, switcher);\n                canvas.setSwitched(false);\n                deckAdapter.setSwitched(null, null);\n                return true;\n            }\n        }\n        return super.onKeyDown(keyCode, event);\n    }\n\n    /**\n     * On activity result\n     */\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent data)\n    {\n        if (resultCode != RESULT_OK) {\n            // ignore other result codes\n            return;\n        }\n\n        switch (requestCode) {\n            case REQUEST_CODE_SPEECH:\n                ArrayList<String> matches = data.getStringArrayListExtra(RecognizerIntent.EXTRA_RESULTS);\n                if (matches.size() > 0) {\n                    ((EditText) findViewById(R.id.input)).setText(matches.get(0));\n                }\n                break;\n            case REQUEST_CODE_JOIN:\n                joinChannelBuffer = data.getExtras().getString(\"channel\");\n                break;\n            case REQUEST_CODE_USERS:\n                Intent intent = new Intent(this, UserActivity.class);\n                intent.putExtra(Extra.USER, data.getStringExtra(Extra.USER));\n                startActivityForResult(intent, REQUEST_CODE_USER);\n                break;\n            case REQUEST_CODE_NICK_COMPLETION:\n                insertNickCompletion((EditText) findViewById(R.id.input), data.getExtras().getString(Extra.USER));\n                break;\n            case REQUEST_CODE_USER:\n                final int actionId = data.getExtras().getInt(Extra.ACTION);\n                final String nickname = data.getExtras().getString(Extra.USER);\n                final IRCConnection connection = binder.getService().getConnection(server.getId());\n                final String conversation = server.getSelectedConversation();\n                final Handler handler = new Handler();\n\n                // XXX: Implement me - The action should be handled after onResume()\n                //                     to catch the broadcasts... now we just wait a second\n                // Yes .. that's very ugly - we need some kind of queue that is handled after onResume()\n\n                new Thread() {\n                    @Override\n                    public void run() {\n                        try {\n                            Thread.sleep(1000);\n                        } catch (InterruptedException e) {\n                            // Do nothing\n                        }\n\n                        String nicknameWithoutPrefix = nickname;\n\n                        while (\n                            nicknameWithoutPrefix.startsWith(\"@\") ||\n                            nicknameWithoutPrefix.startsWith(\"+\") ||\n                            nicknameWithoutPrefix.startsWith(\".\") ||\n                            nicknameWithoutPrefix.startsWith(\"%\")\n                        ) {\n                            // Strip prefix(es) now\n                            nicknameWithoutPrefix = nicknameWithoutPrefix.substring(1);\n                        }\n\n                        switch (actionId) {\n                            case User.ACTION_REPLY:\n                                final String replyText = nicknameWithoutPrefix + \": \";\n                                handler.post(new Runnable() {\n                                    @Override\n                                    public void run() {\n                                        EditText input = (EditText) findViewById(R.id.input);\n                                        input.setText(replyText);\n                                        input.setSelection(replyText.length());\n                                    }\n                                });\n                                break;\n                            case User.ACTION_QUERY:\n                                Conversation query = server.getConversation(nicknameWithoutPrefix);\n                                if (query == null) {\n                                    // Open a query if there's none yet\n                                    query = new Query(nicknameWithoutPrefix);\n                                    query.setHistorySize(binder.getService().getSettings().getHistorySize());\n                                    server.addConversation(query);\n\n                                    Intent intent = Broadcast.createConversationIntent(\n                                        Broadcast.CONVERSATION_NEW,\n                                        server.getId(),\n                                        nicknameWithoutPrefix\n                                    );\n                                    binder.getService().sendBroadcast(intent);\n                                }\n                                break;\n                            case User.ACTION_OP:\n                                connection.op(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_DEOP:\n                                connection.deOp(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_VOICE:\n                                connection.voice(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_DEVOICE:\n                                connection.deVoice(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_KICK:\n                                connection.kick(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_BAN:\n                                connection.ban(conversation, nicknameWithoutPrefix + \"!*@*\");\n                                break;\n                        }\n                    }\n                }.start();\n\n                break;\n        }\n    }\n\n    /**\n     * Send a message in this conversation\n     *\n     * @param text The text of the message\n     */\n    private void sendMessage(String text) {\n        if (text.equals(\"\")) {\n            // ignore empty messages\n            return;\n        }\n\n        if (!server.isConnected()) {\n            Message message = new Message(getString(R.string.message_not_connected));\n            message.setColor(Message.COLOR_RED);\n            message.setIcon(R.drawable.error);\n            server.getConversation(server.getSelectedConversation()).addMessage(message);\n            onConversationMessage(server.getSelectedConversation());\n        }\n\n        scrollback.addMessage(text);\n\n        Conversation conversation = deckAdapter.getItem(deck.getSelectedItemPosition());\n\n        if (conversation != null) {\n            if (!text.trim().startsWith(\"/\")) {\n                if (conversation.getType() != Conversation.TYPE_SERVER) {\n                    String nickname = binder.getService().getConnection(serverId).getNick();\n                    //conversation.addMessage(new Message(\"<\" + nickname + \"> \" + text));\n                    conversation.addMessage(new Message(text, nickname));\n                    binder.getService().getConnection(serverId).sendMessage(conversation.getName(), text);\n                } else {\n                    Message message = new Message(getString(R.string.chat_only_form_channel));\n                    message.setColor(Message.COLOR_YELLOW);\n                    message.setIcon(R.drawable.warning);\n                    conversation.addMessage(message);\n                }\n                onConversationMessage(conversation.getName());\n            } else {\n                CommandParser.getInstance().parse(text, server, conversation, binder.getService());\n            }\n        }\n    }\n\n    /**\n     * Complete a nick in the input line\n     */\n    private void doNickCompletion(EditText input) {\n        String text = input.getText().toString();\n\n        if (text.length() <= 0) {\n            return;\n        }\n\n        String[] tokens = text.split(\"[\\\\s,.-]+\");\n\n        if (tokens.length <= 0) {\n            return;\n        }\n\n        String word = tokens[tokens.length - 1].toLowerCase();\n        tokens[tokens.length - 1] = null;\n\n        int begin   = input.getSelectionStart();\n        int end     = input.getSelectionEnd();\n        int cursor  = Math.min(begin, end);\n        int sel_end = Math.max(begin, end);\n\n        boolean in_selection = (cursor != sel_end);\n\n        if (in_selection) {\n            word = text.substring(cursor, sel_end);\n        } else {\n            // use the word at the curent cursor position\n            while(true) {\n                cursor -= 1;\n                if (cursor <= 0 || text.charAt(cursor) == ' ') {\n                    break;\n                }\n            }\n\n            if (cursor < 0) {\n                cursor = 0;\n            }\n\n            if (text.charAt(cursor) == ' ') {\n                cursor += 1;\n            }\n\n            sel_end = text.indexOf(' ', cursor);\n\n            if (sel_end == -1) {\n                sel_end = text.length();\n            }\n\n            word = text.substring(cursor, sel_end);\n        }\n        // Log.d(\"Yaaic\", \"Trying to complete nick: \" + word);\n\n        Conversation conversationForUserList = deckAdapter.getItem(deck.getSelectedItemPosition());\n\n        String[] users = null;\n\n        if (conversationForUserList.getType() == Conversation.TYPE_CHANNEL) {\n            users = binder.getService().getConnection(server.getId()).getUsersAsStringArray(\n                conversationForUserList.getName()\n            );\n        }\n\n        // go through users and add matches\n        if (users != null) {\n            List<Integer> result = new ArrayList<Integer>();\n\n            for (int i = 0; i < users.length; i++) {\n                String nick = removeStatusChar(users[i].toLowerCase());\n                if (nick.startsWith(word)) {\n                    result.add(Integer.valueOf(i));\n                }\n            }\n\n            if (result.size() == 1) {\n                input.setSelection(cursor, sel_end);\n                insertNickCompletion(input, users[result.get(0).intValue()]);\n            } else if (result.size() > 0) {\n                Intent intent  = new Intent(this, UsersActivity.class);\n                String[] extra = new String[result.size()];\n                int i = 0;\n\n                for (Integer n : result) {\n                    extra[i++] = users[n.intValue()];\n                }\n\n                input.setSelection(cursor, sel_end);\n                intent.putExtra(Extra.USERS, extra);\n                startActivityForResult(intent, REQUEST_CODE_NICK_COMPLETION);\n            }\n        }\n    }\n\n    /**\n     * Insert a given nick completion into the input line\n     *\n     * @param input The input line widget, with the incomplete nick selected\n     * @param nick The completed nick\n     */\n    private void insertNickCompletion(EditText input, String nick) {\n        int start = input.getSelectionStart();\n        int end  = input.getSelectionEnd();\n        nick = removeStatusChar(nick);\n\n        if (start == 0) {\n            nick += \":\";\n        }\n\n        nick += \" \";\n        input.getText().replace(start, end, nick, 0, nick.length());\n        // put cursor after inserted text\n        input.setSelection(start + nick.length());\n        input.clearComposingText();\n        input.post(new Runnable() {\n            @Override\n            public void run() {\n                // make the softkeyboard come up again (only if no hw keyboard is attached)\n                EditText input = (EditText) findViewById(R.id.input);\n                openSoftKeyboard(input);\n            }\n        });\n        input.requestFocus();\n    }\n\n    /**\n     * Open the soft keyboard (helper function)\n     */\n    private void openSoftKeyboard(View view) {\n        ((InputMethodManager) getSystemService(INPUT_METHOD_SERVICE)).showSoftInput(view, InputMethodManager.SHOW_IMPLICIT);\n    }\n\n    /**\n     * Remove the status char off the front of a nick if one is present\n     * \n     * @param nick\n     * @return nick without statuschar\n     */\n    private String removeStatusChar(String nick)\n    {\n        /* Discard status characters */\n        if (nick.startsWith(\"@\") || nick.startsWith(\"+\")\n            || nick.startsWith(\"%\")) {\n            nick = nick.substring(1);\n        }\n        return nick;\n    }\n}\n","Method after Refactoring":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2011 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage org.yaaic.activity;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.adapter.DeckAdapter;\nimport org.yaaic.adapter.MessageListAdapter;\nimport org.yaaic.command.CommandParser;\nimport org.yaaic.irc.IRCBinder;\nimport org.yaaic.irc.IRCConnection;\nimport org.yaaic.irc.IRCService;\nimport org.yaaic.layout.NonScalingBackgroundDrawable;\nimport org.yaaic.listener.ConversationClickListener;\nimport org.yaaic.listener.ConversationListener;\nimport org.yaaic.listener.ConversationSelectedListener;\nimport org.yaaic.listener.ServerListener;\nimport org.yaaic.listener.SpeechClickListener;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.model.Extra;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Query;\nimport org.yaaic.model.Scrollback;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.ServerInfo;\nimport org.yaaic.model.Settings;\nimport org.yaaic.model.Status;\nimport org.yaaic.model.User;\nimport org.yaaic.receiver.ConversationReceiver;\nimport org.yaaic.receiver.ServerReceiver;\nimport org.yaaic.view.ConversationSwitcher;\nimport org.yaaic.view.MessageListView;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.content.ComponentName;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.content.pm.PackageManager;\nimport android.content.pm.ResolveInfo;\nimport android.content.res.Configuration;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.speech.RecognizerIntent;\nimport android.text.InputType;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.Window;\nimport android.view.WindowManager;\nimport android.view.View.OnKeyListener;\nimport android.view.inputmethod.EditorInfo;\nimport android.view.inputmethod.InputMethodManager;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.Gallery;\nimport android.widget.ImageView;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport android.widget.ViewSwitcher;\n\n/**\n * The server view with a scrollable list of all channels\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class ConversationActivity extends Activity implements ServiceConnection, ServerListener, ConversationListener\n{\n    public static final int REQUEST_CODE_SPEECH = 99;\n\n    private static final int REQUEST_CODE_JOIN = 1;\n    private static final int REQUEST_CODE_USERS = 2;\n    private static final int REQUEST_CODE_USER = 3;\n    private static final int REQUEST_CODE_NICK_COMPLETION= 4;\n\n    private int serverId;\n    private Server server;\n    private IRCBinder binder;\n    private ConversationReceiver channelReceiver;\n    private ServerReceiver serverReceiver;\n\n    private ViewSwitcher switcher;\n    private Gallery deck;\n    private DeckAdapter deckAdapter;\n    private Scrollback scrollback;\n    private ConversationSwitcher dots;\n\n    // XXX: This is ugly. This is a buffer for a channel that should be joined after showing the\n    //      JoinActivity. As onActivityResult() is called before onResume() a \"channel joined\"\n    //      broadcast may get lost as the broadcast receivers are registered in onResume() but the\n    //      join command would be called in onActivityResult(). joinChannelBuffer will save the\n    //      channel name in onActivityResult() and run the join command in onResume().\n    private String joinChannelBuffer;\n\n    private int historySize;\n\n    private boolean reconnectDialogActive = false;\n\n    OnKeyListener inputKeyListener = new OnKeyListener() {\n        /**\n         * On key pressed (input line)\n         */\n        @Override\n        public boolean onKey(View view, int keyCode, KeyEvent event)\n        {\n            EditText input = (EditText) view;\n\n            if (event.getAction() != KeyEvent.ACTION_DOWN) {\n                return false;\n            }\n\n            if (keyCode == KeyEvent.KEYCODE_DPAD_UP) {\n                String message = scrollback.goBack();\n                if (message != null) {\n                    input.setText(message);\n                }\n                return true;\n            }\n\n            if (keyCode == KeyEvent.KEYCODE_DPAD_DOWN) {\n                String message = scrollback.goForward();\n                if (message != null) {\n                    input.setText(message);\n                }\n                return true;\n            }\n\n            if (keyCode == KeyEvent.KEYCODE_ENTER) {\n                sendMessage(input.getText().toString());\n                input.setText(\"\");\n                return true;\n            }\n\n            // Nick completion\n            if (keyCode == KeyEvent.KEYCODE_SEARCH) {\n                doNickCompletion(input);\n                return true;\n            }\n\n            return false;\n        }\n    };\n\n    /**\n     * On create\n     */\n    @Override\n    protected void onCreate(Bundle savedInstanceState)\n    {\n        super.onCreate(savedInstanceState);\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n\n        serverId = getIntent().getExtras().getInt(\"serverId\");\n        server = Yaaic.getInstance().getServerById(serverId);\n        Settings settings = new Settings(this);\n\n        // Finish activity if server does not exist anymore - See #55\n        if (server == null) {\n            this.finish();\n        }\n\n        setTitle(\"Yaaic - \" + server.getTitle());\n\n        setContentView(R.layout.conversations);\n        if (settings.fullscreenConversations()){\n            getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);\n        }\n\n        boolean isLandscape = (getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE);\n\n        ((TextView) findViewById(R.id.title)).setText(server.getTitle());\n\n        EditText input = (EditText) findViewById(R.id.input);\n        input.setOnKeyListener(inputKeyListener);\n\n        switcher = (ViewSwitcher) findViewById(R.id.switcher);\n\n        dots = (ConversationSwitcher) findViewById(R.id.dots);\n        dots.setServer(server);\n\n        deckAdapter = new DeckAdapter();\n        deck = (Gallery) findViewById(R.id.deck);\n        deck.setOnItemSelectedListener(new ConversationSelectedListener(this, server, (TextView) findViewById(R.id.title), dots));\n        deck.setAdapter(deckAdapter);\n        deck.setOnItemClickListener(new ConversationClickListener(deckAdapter, switcher));\n        deck.setBackgroundDrawable(new NonScalingBackgroundDrawable(this, deck, R.drawable.background));\n\n        historySize = settings.getHistorySize();\n\n        if (server.getStatus() == Status.PRE_CONNECTING) {\n            server.clearConversations();\n            deckAdapter.clearConversations();\n            server.getConversation(ServerInfo.DEFAULT_NAME).setHistorySize(historySize);\n        }\n\n        // Optimization : cache field lookups\n        Collection<Conversation> mConversations = server.getConversations();\n\n        for (Conversation conversation : mConversations) {\n            // Only scroll to new conversation if it was selected before\n            if (conversation.getStatus() == Conversation.STATUS_SELECTED) {\n                onNewConversation(conversation.getName());\n            } else {\n                createNewConversation(conversation.getName());\n            }\n        }\n\n        int setInputTypeFlags = 0;\n\n        if (settings.autoCorrectText()) {\n            setInputTypeFlags |= InputType.TYPE_TEXT_FLAG_AUTO_CORRECT;\n        } else {\n            // keep compatibility with api level 3\n            if ((android.os.Build.VERSION.SDK.charAt(0) - '0') >= 5) {\n                setInputTypeFlags |= 0x80000; // InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS\n            }\n        }\n        if (settings.autoCapSentences()) {\n            setInputTypeFlags |= InputType.TYPE_TEXT_FLAG_CAP_SENTENCES;\n        }\n\n        if (isLandscape && settings.imeExtract()) {\n            setInputTypeFlags |= InputType.TYPE_TEXT_VARIATION_SHORT_MESSAGE;\n        }\n\n        if (!settings.imeExtract()) {\n            input.setImeOptions(input.getImeOptions() | EditorInfo.IME_FLAG_NO_EXTRACT_UI);\n        }\n\n        input.setInputType(input.getInputType() | setInputTypeFlags);\n\n        // Create a new scrollback history\n        scrollback = new Scrollback();\n    }\n\n    /**\n     * On resume\n     */\n    @Override\n    public void onResume()\n    {\n        // register the receivers as early as possible, otherwise we may loose a broadcast message\n        channelReceiver = new ConversationReceiver(server.getId(), this);\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_MESSAGE));\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_NEW));\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_REMOVE));\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_TOPIC));\n\n        serverReceiver = new ServerReceiver(this);\n        registerReceiver(serverReceiver, new IntentFilter(Broadcast.SERVER_UPDATE));\n\n        super.onResume();\n\n        // Check if speech recognition is enabled and available\n        if (new Settings(this).isVoiceRecognitionEnabled()) {\n            PackageManager pm = getPackageManager();\n            Button speechButton = (Button) findViewById(R.id.speech);\n            List<ResolveInfo> activities = pm.queryIntentActivities(new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH), 0);\n\n            if (activities.size() != 0) {\n                ((Button) findViewById(R.id.speech)).setOnClickListener(new SpeechClickListener(this));\n                speechButton.setVisibility(View.VISIBLE);\n            }\n        }\n\n        ((ImageView) findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\n        // Start service\n        Intent intent = new Intent(this, IRCService.class);\n        intent.setAction(IRCService.ACTION_FOREGROUND);\n        startService(intent);\n        bindService(intent, this, 0);\n\n        if (!server.isConnected()) {\n            ((EditText) findViewById(R.id.input)).setEnabled(false);\n        } else {\n            ((EditText) findViewById(R.id.input)).setEnabled(true);\n        }\n\n        // Optimization - cache field lookup\n        Collection<Conversation> mConversations = server.getConversations();\n        MessageListAdapter mAdapter;\n\n        // Fill view with messages that have been buffered while paused\n        for (Conversation conversation : mConversations) {\n            String name = conversation.getName();\n            mAdapter = deckAdapter.getItemAdapter(name);\n\n            if (mAdapter != null) {\n                mAdapter.addBulkMessages(conversation.getBuffer());\n                conversation.clearBuffer();\n            } else {\n                // Was conversation created while we were paused?\n                if (deckAdapter.getPositionByName(name) == -1) {\n                    onNewConversation(name);\n                }\n            }\n\n            // Clear new message notifications for the selected conversation\n            if (conversation.getStatus() == Conversation.STATUS_SELECTED && conversation.getNewMentions() > 0) {\n                Intent ackIntent = new Intent(this, IRCService.class);\n                ackIntent.setAction(IRCService.ACTION_ACK_NEW_MENTIONS);\n                ackIntent.putExtra(IRCService.EXTRA_ACK_SERVERID, serverId);\n                ackIntent.putExtra(IRCService.EXTRA_ACK_CONVTITLE, name);\n                startService(ackIntent);\n            }\n        }\n\n        // Join channel that has been selected in JoinActivity (onActivityResult())\n        if (joinChannelBuffer != null) {\n            new Thread() {\n                @Override\n                public void run() {\n                    binder.getService().getConnection(serverId).joinChannel(joinChannelBuffer);\n                    joinChannelBuffer = null;\n                }\n            }.start();\n        }\n\n        server.setIsForeground(true);\n    }\n\n    /**\n     * On Pause\n     */\n    @Override\n    public void onPause()\n    {\n        super.onPause();\n\n        server.setIsForeground(false);\n\n        if (binder != null && binder.getService() != null) {\n            binder.getService().checkServiceStatus();\n        }\n\n        unbindService(this);\n        unregisterReceiver(channelReceiver);\n        unregisterReceiver(serverReceiver);\n    }\n\n    /**\n     * On save instance state (e.g. before a configuration change)\n     */\n    @Override\n    protected void onSaveInstanceState(Bundle outState)\n    {\n        super.onSaveInstanceState(outState);\n\n        if (deckAdapter.isSwitched()) {\n            outState.putBoolean(\"isSwitched\", deckAdapter.isSwitched());\n            outState.putString(\"switchedName\", deckAdapter.getSwitchedName());\n        }\n    }\n\n    /**\n     * On restore instance state (e.g. after a configuration change)\n     */\n    @Override\n    protected void onRestoreInstanceState(Bundle inState)\n    {\n        super.onRestoreInstanceState(inState);\n\n        if (inState.getBoolean(\"isSwitched\")) {\n            deckAdapter.setSwitched(inState.getString(\"switchedName\"), null);\n        }\n    }\n\n    /**\n     * On service connected\n     */\n    @Override\n    public void onServiceConnected(ComponentName name, IBinder service)\n    {\n        this.binder = (IRCBinder) service;\n\n        // connect to irc server if connect has been requested\n        if (server.getStatus() == Status.PRE_CONNECTING && getIntent().hasExtra(\"connect\")) {\n            server.setStatus(Status.CONNECTING);\n            binder.connect(server);\n        } else {\n            onStatusUpdate();\n        }\n    }\n\n    /**\n     * On service disconnected\n     */\n    @Override\n    public void onServiceDisconnected(ComponentName name)\n    {\n        this.binder = null;\n    }\n\n    /**\n     * On options menu requested\n     */\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu)\n    {\n        super.onCreateOptionsMenu(menu);\n\n        // inflate from xml\n        MenuInflater inflater = getMenuInflater();\n        inflater.inflate(R.menu.conversations, menu);\n\n        return true;\n    }\n\n    /**\n     * On prepare options menu\n     */\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu)\n    {\n        menu.getItem(0).setEnabled(server.isConnected()); // join\n        menu.getItem(1).setEnabled(server.isConnected()); // users\n        menu.getItem(2).setEnabled(server.isConnected()); // close\n\n        return true;\n    }\n\n    /**\n     * On menu item selected\n     */\n    @Override\n    public boolean onMenuItemSelected(int featureId, MenuItem item)\n    {\n        switch (item.getItemId()) {\n            case R.id.disconnect:\n                server.setStatus(Status.DISCONNECTED);\n                server.setMayReconnect(false);\n                binder.getService().getConnection(serverId).quitServer();\n                server.clearConversations();\n                setResult(RESULT_OK);\n                finish();\n                break;\n\n            case R.id.close:\n                Conversation conversationToClose = deckAdapter.getItem(deck.getSelectedItemPosition());\n                // Make sure we part a channel when closing the channel conversation\n                if (conversationToClose.getType() == Conversation.TYPE_CHANNEL) {\n                    binder.getService().getConnection(serverId).partChannel(conversationToClose.getName());\n                }\n                else if (conversationToClose.getType() == Conversation.TYPE_QUERY) {\n                    server.removeConversation(conversationToClose.getName());\n                    onRemoveConversation(conversationToClose.getName());\n                } else {\n                    Toast.makeText(this, getResources().getString(R.string.close_server_window), Toast.LENGTH_SHORT).show();\n                }\n                break;\n\n            case R.id.join:\n                startActivityForResult(new Intent(this, JoinActivity.class), REQUEST_CODE_JOIN);\n                break;\n\n            case R.id.users:\n                Conversation conversationForUserList = deckAdapter.getItem(deck.getSelectedItemPosition());\n                if (conversationForUserList.getType() == Conversation.TYPE_CHANNEL) {\n                    Intent intent = new Intent(this, UsersActivity.class);\n                    intent.putExtra(\n                        Extra.USERS,\n                        binder.getService().getConnection(server.getId()).getUsersAsStringArray(\n                            conversationForUserList.getName()\n                        )\n                    );\n                    startActivityForResult(intent, REQUEST_CODE_USERS);\n                } else {\n                    Toast.makeText(this, getResources().getString(R.string.only_usable_from_channel), Toast.LENGTH_SHORT).show();\n                }\n                break;\n        }\n\n        return true;\n    }\n\n    /**\n     * Get server object assigned to this activity\n     * \n     * @return the server object\n     */\n    public Server getServer()\n    {\n        return server;\n    }\n\n    /**\n     * On conversation message\n     */\n    @Override\n    public void onConversationMessage(String target)\n    {\n        Conversation conversation = server.getConversation(target);\n\n        if (conversation == null) {\n            // In an early state it can happen that the conversation object\n            // is not created yet.\n            return;\n        }\n\n        MessageListAdapter adapter = deckAdapter.getItemAdapter(target);\n\n        while(conversation.hasBufferedMessages()) {\n            Message message = conversation.pollBufferedMessage();\n\n            if (adapter != null && message != null) {\n                adapter.addMessage(message);\n                int status;\n\n                switch (message.getType())\n                {\n                    case Message.TYPE_MISC:\n                        status = Conversation.STATUS_MISC;\n                        break;\n\n                    default:\n                        status = Conversation.STATUS_MESSAGE;\n                        break;\n                }\n                conversation.setStatus(status);\n            }\n        }\n\n        if (dots != null) {\n            dots.invalidate();\n        }\n    }\n\n    /**\n     * On new conversation\n     */\n    @Override\n    public void onNewConversation(String target)\n    {\n        createNewConversation(target);\n\n        if (!deckAdapter.isSwitched()) {\n            // Scroll to new conversation\n            deck.setSelection(deckAdapter.getCount() - 1);\n        }\n    }\n    public void createNewConversation(String target)\n    {\n        deckAdapter.addItem(server.getConversation(target));\n    }\n\n    /**\n     * On conversation remove\n     */\n    @Override\n    public void onRemoveConversation(String target)\n    {\n        deckAdapter.removeItem(target);\n\n        if (deckAdapter.isSwitched()) {\n            switcher.showNext();\n            switcher.removeView(deckAdapter.getSwitchedView());\n            deckAdapter.setSwitched(null, null);\n        }\n    }\n\n    /**\n     * On topic change\n     */\n    public void onTopicChanged(String target)\n    {\n        String selected = server.getSelectedConversation();\n        if (selected.equals(target)) {\n            // onTopicChanged is only called for channels\n            Channel channel = (Channel) server.getConversation(selected);\n            StringBuilder sb = new StringBuilder();\n            sb.append(server.getTitle() + \" - \" + channel.getName());\n            if (!(channel.getTopic()).equals(\"\")) {\n                sb.append(\" - \" + channel.getTopic());\n            }\n            ((TextView) findViewById(R.id.title)).setText(sb.toString());\n        }\n    }\n\n    /**\n     * On server status update\n     */\n    @Override\n    public void onStatusUpdate()\n    {\n        ((ImageView) findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\n        EditText input = (EditText) findViewById(R.id.input);\n\n        if (server.isConnected()) {\n            input.setEnabled(true);\n        } else {\n            input.setEnabled(false);\n\n            if (server.getStatus() == Status.CONNECTING) {\n                return;\n            }\n\n            // Service is not connected or initialized yet - See #54\n            if (binder == null || binder.getService() == null || binder.getService().getSettings() == null) {\n                return;\n            }\n\n            if (!binder.getService().getSettings().isReconnectEnabled() && !reconnectDialogActive) {\n                reconnectDialogActive = true;\n                AlertDialog.Builder builder = new AlertDialog.Builder(this);\n                builder.setMessage(getResources().getString(R.string.reconnect_after_disconnect, server.getTitle()))\n                .setCancelable(false)\n                .setPositiveButton(\"Yes\", new DialogInterface.OnClickListener() {\n                    @Override\n                    public void onClick(DialogInterface dialog, int id) {\n                        if (!server.isDisconnected()) {\n                            reconnectDialogActive = false;\n                            return;\n                        }\n                        binder.getService().getConnection(server.getId()).setAutojoinChannels(\n                            server.getCurrentChannelNames()\n                        );\n                        server.setStatus(Status.CONNECTING);\n                        binder.connect(server);\n                        reconnectDialogActive = false;\n                    }\n                })\n                .setNegativeButton(getString(R.string.negative_button), new DialogInterface.OnClickListener() {\n                    @Override\n                    public void onClick(DialogInterface dialog, int id) {\n                        server.setMayReconnect(false);\n                        reconnectDialogActive = false;\n                        dialog.cancel();\n                    }\n                });\n                AlertDialog alert = builder.create();\n                alert.show();\n            }\n        }\n    }\n\n    /**\n     * On key down\n     *\n     * XXX: As we only track the back key: Android >= 2.0 will call a method called onBackPressed()\n     */\n    @Override\n    public boolean onKeyDown(int keyCode, KeyEvent event)\n    {\n        if (keyCode == KeyEvent.KEYCODE_BACK && event.getRepeatCount() == 0) {\n            if (deckAdapter.isSwitched()) {\n                MessageListView canvas = (MessageListView) deckAdapter.getView(deckAdapter.getPositionByName(deckAdapter.getSwitchedName()), null, switcher);\n                canvas.setSwitched(false);\n                deckAdapter.setSwitched(null, null);\n                return true;\n            }\n        }\n        return super.onKeyDown(keyCode, event);\n    }\n\n    /**\n     * On activity result\n     */\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent data)\n    {\n        if (resultCode != RESULT_OK) {\n            // ignore other result codes\n            return;\n        }\n\n        switch (requestCode) {\n            case REQUEST_CODE_SPEECH:\n                ArrayList<String> matches = data.getStringArrayListExtra(RecognizerIntent.EXTRA_RESULTS);\n                if (matches.size() > 0) {\n                    ((EditText) findViewById(R.id.input)).setText(matches.get(0));\n                }\n                break;\n            case REQUEST_CODE_JOIN:\n                joinChannelBuffer = data.getExtras().getString(\"channel\");\n                break;\n            case REQUEST_CODE_USERS:\n                Intent intent = new Intent(this, UserActivity.class);\n                intent.putExtra(Extra.USER, data.getStringExtra(Extra.USER));\n                startActivityForResult(intent, REQUEST_CODE_USER);\n                break;\n            case REQUEST_CODE_NICK_COMPLETION:\n                insertNickCompletion((EditText) findViewById(R.id.input), data.getExtras().getString(Extra.USER));\n                break;\n            case REQUEST_CODE_USER:\n                final int actionId = data.getExtras().getInt(Extra.ACTION);\n                final String nickname = data.getExtras().getString(Extra.USER);\n                final IRCConnection connection = binder.getService().getConnection(server.getId());\n                final String conversation = server.getSelectedConversation();\n                final Handler handler = new Handler();\n\n                // XXX: Implement me - The action should be handled after onResume()\n                //                     to catch the broadcasts... now we just wait a second\n                // Yes .. that's very ugly - we need some kind of queue that is handled after onResume()\n\n                new Thread() {\n                    @Override\n                    public void run() {\n                        try {\n                            Thread.sleep(1000);\n                        } catch (InterruptedException e) {\n                            // Do nothing\n                        }\n\n                        String nicknameWithoutPrefix = nickname;\n\n                        while (\n                            nicknameWithoutPrefix.startsWith(\"@\") ||\n                            nicknameWithoutPrefix.startsWith(\"+\") ||\n                            nicknameWithoutPrefix.startsWith(\".\") ||\n                            nicknameWithoutPrefix.startsWith(\"%\")\n                        ) {\n                            // Strip prefix(es) now\n                            nicknameWithoutPrefix = nicknameWithoutPrefix.substring(1);\n                        }\n\n                        switch (actionId) {\n                            case User.ACTION_REPLY:\n                                final String replyText = nicknameWithoutPrefix + \": \";\n                                handler.post(new Runnable() {\n                                    @Override\n                                    public void run() {\n                                        EditText input = (EditText) findViewById(R.id.input);\n                                        input.setText(replyText);\n                                        input.setSelection(replyText.length());\n                                    }\n                                });\n                                break;\n                            case User.ACTION_QUERY:\n                                Conversation query = server.getConversation(nicknameWithoutPrefix);\n                                if (query == null) {\n                                    // Open a query if there's none yet\n                                    query = new Query(nicknameWithoutPrefix);\n                                    query.setHistorySize(binder.getService().getSettings().getHistorySize());\n                                    server.addConversation(query);\n\n                                    Intent intent = Broadcast.createConversationIntent(\n                                        Broadcast.CONVERSATION_NEW,\n                                        server.getId(),\n                                        nicknameWithoutPrefix\n                                    );\n                                    binder.getService().sendBroadcast(intent);\n                                }\n                                break;\n                            case User.ACTION_OP:\n                                connection.op(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_DEOP:\n                                connection.deOp(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_VOICE:\n                                connection.voice(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_DEVOICE:\n                                connection.deVoice(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_KICK:\n                                connection.kick(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_BAN:\n                                connection.ban(conversation, nicknameWithoutPrefix + \"!*@*\");\n                                break;\n                        }\n                    }\n                }.start();\n\n                break;\n        }\n    }\n\n    /**\n     * Send a message in this conversation\n     *\n     * @param text The text of the message\n     */\n    private void sendMessage(String text) {\n        if (text.equals(\"\")) {\n            // ignore empty messages\n            return;\n        }\n\n        if (!server.isConnected()) {\n            Message message = new Message(getString(R.string.message_not_connected));\n            message.setColor(Message.COLOR_RED);\n            message.setIcon(R.drawable.error);\n            server.getConversation(server.getSelectedConversation()).addMessage(message);\n            onConversationMessage(server.getSelectedConversation());\n        }\n\n        scrollback.addMessage(text);\n\n        Conversation conversation = deckAdapter.getItem(deck.getSelectedItemPosition());\n\n        if (conversation != null) {\n            if (!text.trim().startsWith(\"/\")) {\n                if (conversation.getType() != Conversation.TYPE_SERVER) {\n                    String nickname = binder.getService().getConnection(serverId).getNick();\n                    //conversation.addMessage(new Message(\"<\" + nickname + \"> \" + text));\n                    conversation.addMessage(new Message(text, nickname));\n                    binder.getService().getConnection(serverId).sendMessage(conversation.getName(), text);\n                } else {\n                    Message message = new Message(getString(R.string.chat_only_form_channel));\n                    message.setColor(Message.COLOR_YELLOW);\n                    message.setIcon(R.drawable.warning);\n                    conversation.addMessage(message);\n                }\n                onConversationMessage(conversation.getName());\n            } else {\n                CommandParser.getInstance().parse(text, server, conversation, binder.getService());\n            }\n        }\n    }\n\n    /**\n     * Complete a nick in the input line\n     */\n    private void doNickCompletion(EditText input) {\n        String text = input.getText().toString();\n\n        if (text.length() <= 0) {\n            return;\n        }\n\n        String[] tokens = text.split(\"[\\\\s,.-]+\");\n\n        if (tokens.length <= 0) {\n            return;\n        }\n\n        String word = tokens[tokens.length - 1].toLowerCase();\n        tokens[tokens.length - 1] = null;\n\n        int begin   = input.getSelectionStart();\n        int end     = input.getSelectionEnd();\n        int cursor  = Math.min(begin, end);\n        int sel_end = Math.max(begin, end);\n\n        boolean in_selection = (cursor != sel_end);\n\n        if (in_selection) {\n            word = text.substring(cursor, sel_end);\n        } else {\n            // use the word at the curent cursor position\n            while(true) {\n                cursor -= 1;\n                if (cursor <= 0 || text.charAt(cursor) == ' ') {\n                    break;\n                }\n            }\n\n            if (cursor < 0) {\n                cursor = 0;\n            }\n\n            if (text.charAt(cursor) == ' ') {\n                cursor += 1;\n            }\n\n            sel_end = text.indexOf(' ', cursor);\n\n            if (sel_end == -1) {\n                sel_end = text.length();\n            }\n\n            word = text.substring(cursor, sel_end);\n        }\n        // Log.d(\"Yaaic\", \"Trying to complete nick: \" + word);\n\n        Conversation conversationForUserList = deckAdapter.getItem(deck.getSelectedItemPosition());\n\n        String[] users = null;\n\n        if (conversationForUserList.getType() == Conversation.TYPE_CHANNEL) {\n            users = binder.getService().getConnection(server.getId()).getUsersAsStringArray(\n                conversationForUserList.getName()\n            );\n        }\n\n        // go through users and add matches\n        if (users != null) {\n            List<Integer> result = new ArrayList<Integer>();\n\n            for (int i = 0; i < users.length; i++) {\n                String nick = removeStatusChar(users[i].toLowerCase());\n                if (nick.startsWith(word)) {\n                    result.add(Integer.valueOf(i));\n                }\n            }\n\n            if (result.size() == 1) {\n                input.setSelection(cursor, sel_end);\n                insertNickCompletion(input, users[result.get(0).intValue()]);\n            } else if (result.size() > 0) {\n                Intent intent  = new Intent(this, UsersActivity.class);\n                String[] extra = new String[result.size()];\n                int i = 0;\n\n                for (Integer n : result) {\n                    extra[i++] = users[n.intValue()];\n                }\n\n                input.setSelection(cursor, sel_end);\n                intent.putExtra(Extra.USERS, extra);\n                startActivityForResult(intent, REQUEST_CODE_NICK_COMPLETION);\n            }\n        }\n    }\n\n    /**\n     * Insert a given nick completion into the input line\n     *\n     * @param input The input line widget, with the incomplete nick selected\n     * @param nick The completed nick\n     */\n    private void insertNickCompletion(EditText input, String nick) {\n        int start = input.getSelectionStart();\n        int end  = input.getSelectionEnd();\n        nick = removeStatusChar(nick);\n\n        if (start == 0) {\n            nick += \":\";\n        }\n\n        nick += \" \";\n        input.getText().replace(start, end, nick, 0, nick.length());\n        // put cursor after inserted text\n        input.setSelection(start + nick.length());\n        input.clearComposingText();\n        input.post(new Runnable() {\n            @Override\n            public void run() {\n                // make the softkeyboard come up again (only if no hw keyboard is attached)\n                EditText input = (EditText) findViewById(R.id.input);\n                openSoftKeyboard(input);\n            }\n        });\n        input.requestFocus();\n    }\n\n    /**\n     * Open the soft keyboard (helper function)\n     */\n    private void openSoftKeyboard(View view) {\n        ((InputMethodManager) getSystemService(INPUT_METHOD_SERVICE)).showSoftInput(view, InputMethodManager.SHOW_IMPLICIT);\n    }\n\n    /**\n     * Remove the status char off the front of a nick if one is present\n     * \n     * @param nick\n     * @return nick without statuschar\n     */\n    private String removeStatusChar(String nick)\n    {\n        /* Discard status characters */\n        if (nick.startsWith(\"@\") || nick.startsWith(\"+\")\n            || nick.startsWith(\"%\")) {\n            nick = nick.substring(1);\n        }\n        return nick;\n    }\n}\n","lineNo":315}
{"Smelly Sample":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2011 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage org.yaaic.activity;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.adapter.DeckAdapter;\nimport org.yaaic.adapter.MessageListAdapter;\nimport org.yaaic.command.CommandParser;\nimport org.yaaic.irc.IRCBinder;\nimport org.yaaic.irc.IRCConnection;\nimport org.yaaic.irc.IRCService;\nimport org.yaaic.layout.NonScalingBackgroundDrawable;\nimport org.yaaic.listener.ConversationClickListener;\nimport org.yaaic.listener.ConversationListener;\nimport org.yaaic.listener.ConversationSelectedListener;\nimport org.yaaic.listener.ServerListener;\nimport org.yaaic.listener.SpeechClickListener;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.model.Extra;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Query;\nimport org.yaaic.model.Scrollback;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.ServerInfo;\nimport org.yaaic.model.Settings;\nimport org.yaaic.model.Status;\nimport org.yaaic.model.User;\nimport org.yaaic.receiver.ConversationReceiver;\nimport org.yaaic.receiver.ServerReceiver;\nimport org.yaaic.view.ConversationSwitcher;\nimport org.yaaic.view.MessageListView;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.content.ComponentName;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.content.pm.PackageManager;\nimport android.content.pm.ResolveInfo;\nimport android.content.res.Configuration;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.speech.RecognizerIntent;\nimport android.text.InputType;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.Window;\nimport android.view.View.OnKeyListener;\nimport android.view.inputmethod.InputMethodManager;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.Gallery;\nimport android.widget.ImageView;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport android.widget.ViewSwitcher;\n\n/**\n * The server view with a scrollable list of all channels\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class ConversationActivity extends Activity implements ServiceConnection, ServerListener, ConversationListener\n{\n    public static final int REQUEST_CODE_SPEECH = 99;\n\n    private static final int REQUEST_CODE_JOIN = 1;\n    private static final int REQUEST_CODE_USERS = 2;\n    private static final int REQUEST_CODE_USER = 3;\n    private static final int REQUEST_CODE_NICK_COMPLETION= 4;\n\n    private int serverId;\n    private Server server;\n    private IRCBinder binder;\n    private ConversationReceiver channelReceiver;\n    private ServerReceiver serverReceiver;\n\n    private ViewSwitcher switcher;\n    private Gallery deck;\n    private DeckAdapter deckAdapter;\n    private Scrollback scrollback;\n    private ConversationSwitcher dots;\n\n    // XXX: This is ugly. This is a buffer for a channel that should be joined after showing the\n    //      JoinActivity. As onActivityResult() is called before onResume() a \"channel joined\"\n    //      broadcast may get lost as the broadcast receivers are registered in onResume() but the\n    //      join command would be called in onActivityResult(). joinChannelBuffer will save the\n    //      channel name in onActivityResult() and run the join command in onResume().\n    private String joinChannelBuffer;\n\n    private int historySize;\n\n    OnKeyListener inputKeyListener = new OnKeyListener() {\n        /**\n         * On key pressed (input line)\n         */\n        @Override\n        public boolean onKey(View view, int keyCode, KeyEvent event)\n        {\n            EditText input = (EditText) view;\n\n            if (event.getAction() != KeyEvent.ACTION_DOWN) {\n                return false;\n            }\n\n            if (keyCode == KeyEvent.KEYCODE_DPAD_UP) {\n                String message = scrollback.goBack();\n                if (message != null) {\n                    input.setText(message);\n                }\n                return true;\n            }\n\n            if (keyCode == KeyEvent.KEYCODE_DPAD_DOWN) {\n                String message = scrollback.goForward();\n                if (message != null) {\n                    input.setText(message);\n                }\n                return true;\n            }\n\n            if (keyCode == KeyEvent.KEYCODE_ENTER) {\n                sendMessage(input.getText().toString());\n                input.setText(\"\");\n                return true;\n            }\n\n            // Nick completion\n            if (keyCode == KeyEvent.KEYCODE_SEARCH) {\n                doNickCompletion(input);\n                return true;\n            }\n\n            return false;\n        }\n    };\n\n    /**\n     * On create\n     */\n    @Override\n    protected void onCreate(Bundle savedInstanceState)\n    {\n        super.onCreate(savedInstanceState);\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n\n        serverId = getIntent().getExtras().getInt(\"serverId\");\n        server = Yaaic.getInstance().getServerById(serverId);\n\n        // Finish activity if server does not exist anymore - See #55\n        if (server == null) {\n            this.finish();\n        }\n\n        setTitle(\"Yaaic - \" + server.getTitle());\n\n        setContentView(R.layout.conversations);\n\n        boolean isLandscape = (getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE);\n\n        ((TextView) findViewById(R.id.title)).setText(server.getTitle());\n\n        EditText input = (EditText) findViewById(R.id.input);\n        input.setOnKeyListener(inputKeyListener);\n\n        switcher = (ViewSwitcher) findViewById(R.id.switcher);\n\n        dots = (ConversationSwitcher) findViewById(R.id.dots);\n        dots.setServer(server);\n\n        deckAdapter = new DeckAdapter();\n        deck = (Gallery) findViewById(R.id.deck);\n        deck.setOnItemSelectedListener(new ConversationSelectedListener(this, server, (TextView) findViewById(R.id.title), dots));\n        deck.setAdapter(deckAdapter);\n        deck.setOnItemClickListener(new ConversationClickListener(deckAdapter, switcher));\n        deck.setBackgroundDrawable(new NonScalingBackgroundDrawable(this, deck, R.drawable.background));\n\n        Settings settings = new Settings(this);\n        historySize = settings.getHistorySize();\n\n        if (server.getStatus() == Status.PRE_CONNECTING) {\n            server.clearConversations();\n            deckAdapter.clearConversations();\n            server.getConversation(ServerInfo.DEFAULT_NAME).setHistorySize(historySize);\n        }\n\n        // Optimization : cache field lookups\n        Collection<Conversation> mConversations = server.getConversations();\n\n        for (Conversation conversation : mConversations) {\n            // Only scroll to new conversation if it was selected before\n            if (conversation.getStatus() == Conversation.STATUS_SELECTED) {\n                onNewConversation(conversation.getName());\n            } else {\n                createNewConversation(conversation.getName());\n            }\n        }\n\n        int setInputTypeFlags = 0;\n\n        if (settings.autoCorrectText()) {\n            setInputTypeFlags |= InputType.TYPE_TEXT_FLAG_AUTO_CORRECT;\n        } else {\n            // keep compatibility with api level 3\n            if ((android.os.Build.VERSION.SDK.charAt(0) - '0') >= 5) {\n                setInputTypeFlags |= 0x80000; // InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS\n            }\n        }\n        if (settings.autoCapSentences()) {\n            setInputTypeFlags |= InputType.TYPE_TEXT_FLAG_CAP_SENTENCES;\n        }\n        if (isLandscape) {\n            /* Replace the Enter key with a smiley instead of Send, to make it\n               more difficult to accidentally hit send\n               We'd like to do this in portrait too, but wouldn't have a Send\n               button in that case */\n            setInputTypeFlags |= InputType.TYPE_TEXT_VARIATION_SHORT_MESSAGE;\n        }\n        input.setInputType(input.getInputType() | setInputTypeFlags);\n\n        // Create a new scrollback history\n        scrollback = new Scrollback();\n    }\n\n    /**\n     * On resume\n     */\n    @Override\n    public void onResume()\n    {\n        // register the receivers as early as possible, otherwise we may loose a broadcast message\n        channelReceiver = new ConversationReceiver(server.getId(), this);\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_MESSAGE));\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_NEW));\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_REMOVE));\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_TOPIC));\n\n        serverReceiver = new ServerReceiver(this);\n        registerReceiver(serverReceiver, new IntentFilter(Broadcast.SERVER_UPDATE));\n\n        super.onResume();\n\n        // Check if speech recognition is enabled and available\n        if (new Settings(this).isVoiceRecognitionEnabled()) {\n            PackageManager pm = getPackageManager();\n            Button speechButton = (Button) findViewById(R.id.speech);\n            List<ResolveInfo> activities = pm.queryIntentActivities(new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH), 0);\n\n            if (activities.size() != 0) {\n                ((Button) findViewById(R.id.speech)).setOnClickListener(new SpeechClickListener(this));\n                speechButton.setVisibility(View.VISIBLE);\n            }\n        }\n\n        ((ImageView) findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\n        // Start service\n        Intent intent = new Intent(this, IRCService.class);\n        intent.setAction(IRCService.ACTION_FOREGROUND);\n        startService(intent);\n        bindService(intent, this, 0);\n\n        if (!server.isConnected()) {\n            ((EditText) findViewById(R.id.input)).setEnabled(false);\n        } else {\n            ((EditText) findViewById(R.id.input)).setEnabled(true);\n        }\n\n        // Optimization - cache field lookup\n        Collection<Conversation> mConversations = server.getConversations();\n        MessageListAdapter mAdapter;\n\n        // Fill view with messages that have been buffered while paused\n        for (Conversation conversation : mConversations) {\n            mAdapter = deckAdapter.getItemAdapter(conversation.getName());\n\n            if (mAdapter != null) {\n                mAdapter.addBulkMessages(conversation.getBuffer());\n                conversation.clearBuffer();\n            }\n\n            // Clear new message notifications for the selected conversation\n            if (conversation.getStatus() == Conversation.STATUS_SELECTED && conversation.getNewMentions() > 0) {\n                Intent ackIntent = new Intent(this, IRCService.class);\n                ackIntent.setAction(IRCService.ACTION_ACK_NEW_MENTIONS);\n                ackIntent.putExtra(IRCService.EXTRA_ACK_SERVERID, serverId);\n                ackIntent.putExtra(IRCService.EXTRA_ACK_CONVTITLE, conversation.getName());\n                startService(ackIntent);\n            }\n        }\n\n        // Join channel that has been selected in JoinActivity (onActivityResult())\n        if (joinChannelBuffer != null) {\n            new Thread() {\n                @Override\n                public void run() {\n                    binder.getService().getConnection(serverId).joinChannel(joinChannelBuffer);\n                    joinChannelBuffer = null;\n                }\n            }.start();\n        }\n\n        server.setIsForeground(true);\n    }\n\n    /**\n     * On Pause\n     */\n    @Override\n    public void onPause()\n    {\n        super.onPause();\n\n        server.setIsForeground(false);\n\n        if (binder != null && binder.getService() != null) {\n            binder.getService().checkServiceStatus();\n        }\n\n        unbindService(this);\n        unregisterReceiver(channelReceiver);\n        unregisterReceiver(serverReceiver);\n    }\n\n    /**\n     * On save instance state (e.g. before a configuration change)\n     */\n    @Override\n    protected void onSaveInstanceState(Bundle outState)\n    {\n        super.onSaveInstanceState(outState);\n\n        if (deckAdapter.isSwitched()) {\n            outState.putBoolean(\"isSwitched\", deckAdapter.isSwitched());\n            outState.putString(\"switchedName\", deckAdapter.getSwitchedName());\n        }\n    }\n\n    /**\n     * On restore instance state (e.g. after a configuration change)\n     */\n    @Override\n    protected void onRestoreInstanceState(Bundle inState)\n    {\n        super.onRestoreInstanceState(inState);\n\n        if (inState.getBoolean(\"isSwitched\")) {\n            deckAdapter.setSwitched(inState.getString(\"switchedName\"), null);\n        }\n    }\n\n    /**\n     * On service connected\n     */\n    @Override\n    public void onServiceConnected(ComponentName name, IBinder service)\n    {\n        this.binder = (IRCBinder) service;\n\n        // connect to irc server if connect has been requested\n        if (server.getStatus() == Status.PRE_CONNECTING && getIntent().hasExtra(\"connect\")) {\n            server.setStatus(Status.CONNECTING);\n            binder.connect(server);\n        }\n    }\n\n    /**\n     * On service disconnected\n     */\n    @Override\n    public void onServiceDisconnected(ComponentName name)\n    {\n        this.binder = null;\n    }\n\n    /**\n     * On options menu requested\n     */\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu)\n    {\n        super.onCreateOptionsMenu(menu);\n\n        // inflate from xml\n        MenuInflater inflater = getMenuInflater();\n        inflater.inflate(R.menu.conversations, menu);\n\n        return true;\n    }\n\n    /**\n     * On prepare options menu\n     */\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu)\n    {\n        menu.getItem(0).setEnabled(server.isConnected()); // join\n        menu.getItem(1).setEnabled(server.isConnected()); // users\n        menu.getItem(2).setEnabled(server.isConnected()); // close\n\n        return true;\n    }\n\n    /**\n     * On menu item selected\n     */\n    @Override\n    public boolean onMenuItemSelected(int featureId, MenuItem item)\n    {\n        switch (item.getItemId()) {\n            case R.id.disconnect:\n                server.setStatus(Status.DISCONNECTED);\n                binder.getService().getConnection(serverId).quitServer();\n                server.clearConversations();\n                setResult(RESULT_OK);\n                finish();\n                break;\n\n            case R.id.close:\n                Conversation conversationToClose = deckAdapter.getItem(deck.getSelectedItemPosition());\n                // Make sure we part a channel when closing the channel conversation\n                if (conversationToClose.getType() == Conversation.TYPE_CHANNEL) {\n                    binder.getService().getConnection(serverId).partChannel(conversationToClose.getName());\n                }\n                else if (conversationToClose.getType() == Conversation.TYPE_QUERY) {\n                    server.removeConversation(conversationToClose.getName());\n                    onRemoveConversation(conversationToClose.getName());\n                } else {\n                    Toast.makeText(this, getResources().getString(R.string.close_server_window), Toast.LENGTH_SHORT).show();\n                }\n                break;\n\n            case R.id.join:\n                startActivityForResult(new Intent(this, JoinActivity.class), REQUEST_CODE_JOIN);\n                break;\n\n            case R.id.users:\n                Conversation conversationForUserList = deckAdapter.getItem(deck.getSelectedItemPosition());\n                if (conversationForUserList.getType() == Conversation.TYPE_CHANNEL) {\n                    Intent intent = new Intent(this, UsersActivity.class);\n                    intent.putExtra(\n                        Extra.USERS,\n                        binder.getService().getConnection(server.getId()).getUsersAsStringArray(\n                            conversationForUserList.getName()\n                        )\n                    );\n                    startActivityForResult(intent, REQUEST_CODE_USERS);\n                } else {\n                    Toast.makeText(this, getResources().getString(R.string.only_usable_from_channel), Toast.LENGTH_SHORT).show();\n                }\n                break;\n        }\n\n        return true;\n    }\n\n    /**\n     * Get server object assigned to this activity\n     * \n     * @return the server object\n     */\n    public Server getServer()\n    {\n        return server;\n    }\n\n    /**\n     * On conversation message\n     */\n    @Override\n    public void onConversationMessage(String target)\n    {\n        Conversation conversation = server.getConversation(target);\n\n        if (conversation == null) {\n            // In an early state it can happen that the conversation object\n            // is not created yet.\n            return;\n        }\n\n        MessageListAdapter adapter = deckAdapter.getItemAdapter(target);\n\n        while(conversation.hasBufferedMessages()) {\n            Message message = conversation.pollBufferedMessage();\n\n            if (adapter != null && message != null) {\n                adapter.addMessage(message);\n                int status;\n\n                switch (message.getType())\n                {\n                    case Message.TYPE_MISC:\n                        status = Conversation.STATUS_MISC;\n                        break;\n\n                    default:\n                        status = Conversation.STATUS_MESSAGE;\n                        break;\n                }\n                conversation.setStatus(status);\n            }\n        }\n\n        if (dots != null) {\n            dots.invalidate();\n        }\n    }\n\n    /**\n     * On new conversation\n     */\n    @Override\n    public void onNewConversation(String target)\n    {\n        createNewConversation(target);\n\n        if (!deckAdapter.isSwitched()) {\n            // Scroll to new conversation\n            deck.setSelection(deckAdapter.getCount() - 1);\n        }\n    }\n    public void createNewConversation(String target)\n    {\n        deckAdapter.addItem(server.getConversation(target));\n    }\n\n    /**\n     * On conversation remove\n     */\n    @Override\n    public void onRemoveConversation(String target)\n    {\n        deckAdapter.removeItem(target);\n\n        if (deckAdapter.isSwitched()) {\n            switcher.showNext();\n            switcher.removeView(deckAdapter.getSwitchedView());\n            deckAdapter.setSwitched(null, null);\n        }\n    }\n\n    /**\n     * On topic change\n     */\n    public void onTopicChanged(String target)\n    {\n        String selected = server.getSelectedConversation();\n        if (selected.equals(target)) {\n            // onTopicChanged is only called for channels\n            Channel channel = (Channel) server.getConversation(selected);\n            StringBuilder sb = new StringBuilder();\n            sb.append(server.getTitle() + \" - \" + channel.getName());\n            if (!(channel.getTopic()).equals(\"\")) {\n                sb.append(\" - \" + channel.getTopic());\n            }\n            ((TextView) findViewById(R.id.title)).setText(sb.toString());\n        }\n    }\n\n    /**\n     * On server status update\n     */\n    @Override\n    public void onStatusUpdate()\n    {\n        ((ImageView) findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\n        EditText input = (EditText) findViewById(R.id.input);\n\n        if (server.isConnected()) {\n            input.setEnabled(true);\n        } else {\n            input.setEnabled(false);\n\n            if (server.getStatus() == Status.CONNECTING) {\n                deckAdapter.clearConversations();\n                Conversation serverInfo = server.getConversation(ServerInfo.DEFAULT_NAME);\n                serverInfo.setHistorySize(historySize);\n                deckAdapter.addItem(serverInfo);\n                return;\n            }\n\n            // Service is not connected or initialized yet - See #54\n            if (binder == null || binder.getService() == null || binder.getService().getSettings() == null) {\n                return;\n            }\n\n            if (!binder.getService().getSettings().isReconnectEnabled()) {\n                AlertDialog.Builder builder = new AlertDialog.Builder(this);\n                builder.setMessage(getResources().getString(R.string.reconnect_after_disconnect, server.getTitle()))\n                .setCancelable(false)\n                .setPositiveButton(\"Yes\", new DialogInterface.OnClickListener() {\n                    @Override\n                    public void onClick(DialogInterface dialog, int id) {\n                        binder.getService().getConnection(server.getId()).setAutojoinChannels(\n                            server.getCurrentChannelNames()\n                        );\n                        server.clearConversations();\n                        deckAdapter.clearConversations();\n                        Conversation serverInfo = server.getConversation(ServerInfo.DEFAULT_NAME);\n                        serverInfo.setHistorySize(historySize);\n                        deckAdapter.addItem(serverInfo);\n                        binder.connect(server);\n                    }\n                })\n                .setNegativeButton(getString(R.string.negative_button), new DialogInterface.OnClickListener() {\n                    @Override\n                    public void onClick(DialogInterface dialog, int id) {\n                        dialog.cancel();\n                    }\n                });\n                AlertDialog alert = builder.create();\n                alert.show();\n            }\n        }\n    }\n\n    /**\n     * On key down\n     *\n     * XXX: As we only track the back key: Android >= 2.0 will call a method called onBackPressed()\n     */\n    @Override\n    public boolean onKeyDown(int keyCode, KeyEvent event)\n    {\n        if (keyCode == KeyEvent.KEYCODE_BACK && event.getRepeatCount() == 0) {\n            if (deckAdapter.isSwitched()) {\n                MessageListView canvas = (MessageListView) deckAdapter.getView(deckAdapter.getPositionByName(deckAdapter.getSwitchedName()), null, switcher);\n                canvas.setSwitched(false);\n                deckAdapter.setSwitched(null, null);\n                return true;\n            }\n        }\n        return super.onKeyDown(keyCode, event);\n    }\n\n    /**\n     * On activity result\n     */\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent data)\n    {\n        if (resultCode != RESULT_OK) {\n            // ignore other result codes\n            return;\n        }\n\n        switch (requestCode) {\n            case REQUEST_CODE_SPEECH:\n                ArrayList<String> matches = data.getStringArrayListExtra(RecognizerIntent.EXTRA_RESULTS);\n                if (matches.size() > 0) {\n                    ((EditText) findViewById(R.id.input)).setText(matches.get(0));\n                }\n                break;\n            case REQUEST_CODE_JOIN:\n                joinChannelBuffer = data.getExtras().getString(\"channel\");\n                break;\n            case REQUEST_CODE_USERS:\n                Intent intent = new Intent(this, UserActivity.class);\n                intent.putExtra(Extra.USER, data.getStringExtra(Extra.USER));\n                startActivityForResult(intent, REQUEST_CODE_USER);\n                break;\n            case REQUEST_CODE_NICK_COMPLETION:\n                insertNickCompletion((EditText) findViewById(R.id.input), data.getExtras().getString(Extra.USER));\n                break;\n            case REQUEST_CODE_USER:\n                final int actionId = data.getExtras().getInt(Extra.ACTION);\n                final String nickname = data.getExtras().getString(Extra.USER);\n                final IRCConnection connection = binder.getService().getConnection(server.getId());\n                final String conversation = server.getSelectedConversation();\n                final Handler handler = new Handler();\n\n                // XXX: Implement me - The action should be handled after onResume()\n                //                     to catch the broadcasts... now we just wait a second\n                // Yes .. that's very ugly - we need some kind of queue that is handled after onResume()\n\n                new Thread() {\n                    @Override\n                    public void run() {\n                        try {\n                            Thread.sleep(1000);\n                        } catch (InterruptedException e) {\n                            // Do nothing\n                        }\n\n                        String nicknameWithoutPrefix = nickname;\n\n                        while (\n                            nicknameWithoutPrefix.startsWith(\"@\") ||\n                            nicknameWithoutPrefix.startsWith(\"+\") ||\n                            nicknameWithoutPrefix.startsWith(\".\") ||\n                            nicknameWithoutPrefix.startsWith(\"%\")\n                        ) {\n                            // Strip prefix(es) now\n                            nicknameWithoutPrefix = nicknameWithoutPrefix.substring(1);\n                        }\n\n                        switch (actionId) {\n                            case User.ACTION_REPLY:\n                                final String replyText = nicknameWithoutPrefix + \": \";\n                                handler.post(new Runnable() {\n                                    @Override\n                                    public void run() {\n                                        EditText input = (EditText) findViewById(R.id.input);\n                                        input.setText(replyText);\n                                        input.setSelection(replyText.length());\n                                    }\n                                });\n                                break;\n                            case User.ACTION_QUERY:\n                                Conversation query = server.getConversation(nicknameWithoutPrefix);\n                                if (query == null) {\n                                    // Open a query if there's none yet\n                                    query = new Query(nicknameWithoutPrefix);\n                                    query.setHistorySize(binder.getService().getSettings().getHistorySize());\n                                    server.addConversation(query);\n\n                                    Intent intent = Broadcast.createConversationIntent(\n                                        Broadcast.CONVERSATION_NEW,\n                                        server.getId(),\n                                        nicknameWithoutPrefix\n                                    );\n                                    binder.getService().sendBroadcast(intent);\n                                }\n                                break;\n                            case User.ACTION_OP:\n                                connection.op(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_DEOP:\n                                connection.deOp(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_VOICE:\n                                connection.voice(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_DEVOICE:\n                                connection.deVoice(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_KICK:\n                                connection.kick(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_BAN:\n                                connection.ban(conversation, nicknameWithoutPrefix + \"!*@*\");\n                                break;\n                        }\n                    }\n                }.start();\n\n                break;\n        }\n    }\n\n    /**\n     * Send a message in this conversation\n     *\n     * @param text The text of the message\n     */\n    private void sendMessage(String text) {\n        if (text.equals(\"\")) {\n            // ignore empty messages\n            return;\n        }\n\n        if (!server.isConnected()) {\n            Message message = new Message(getString(R.string.message_not_connected));\n            message.setColor(Message.COLOR_RED);\n            message.setIcon(R.drawable.error);\n            server.getConversation(server.getSelectedConversation()).addMessage(message);\n            onConversationMessage(server.getSelectedConversation());\n        }\n\n        scrollback.addMessage(text);\n\n        Conversation conversation = deckAdapter.getItem(deck.getSelectedItemPosition());\n\n        if (conversation != null) {\n            if (!text.trim().startsWith(\"/\")) {\n                if (conversation.getType() != Conversation.TYPE_SERVER) {\n                    String nickname = binder.getService().getConnection(serverId).getNick();\n                    //conversation.addMessage(new Message(\"<\" + nickname + \"> \" + text));\n                    conversation.addMessage(new Message(text, nickname));\n                    binder.getService().getConnection(serverId).sendMessage(conversation.getName(), text);\n                } else {\n                    Message message = new Message(getString(R.string.chat_only_form_channel));\n                    message.setColor(Message.COLOR_YELLOW);\n                    message.setIcon(R.drawable.warning);\n                    conversation.addMessage(message);\n                }\n                onConversationMessage(conversation.getName());\n            } else {\n                CommandParser.getInstance().parse(text, server, conversation, binder.getService());\n            }\n        }\n    }\n\n    /**\n     * Complete a nick in the input line\n     */\n    private void doNickCompletion(EditText input) {\n        String text = input.getText().toString();\n\n        if (text.length() <= 0) {\n            return;\n        }\n\n        String[] tokens = text.split(\"[\\\\s,.-]+\");\n\n        if (tokens.length <= 0) {\n            return;\n        }\n\n        String word = tokens[tokens.length - 1].toLowerCase();\n        tokens[tokens.length - 1] = null;\n\n        int begin   = input.getSelectionStart();\n        int end     = input.getSelectionEnd();\n        int cursor  = Math.min(begin, end);\n        int sel_end = Math.max(begin, end);\n\n        boolean in_selection = (cursor != sel_end);\n\n        if (in_selection) {\n            word = text.substring(cursor, sel_end);\n        } else {\n            // use the word at the curent cursor position\n            while(true) {\n                cursor -= 1;\n                if (cursor <= 0 || text.charAt(cursor) == ' ') {\n                    break;\n                }\n            }\n\n            if (cursor < 0) {\n                cursor = 0;\n            }\n\n            if (text.charAt(cursor) == ' ') {\n                cursor += 1;\n            }\n\n            sel_end = text.indexOf(' ', cursor);\n\n            if (sel_end == -1) {\n                sel_end = text.length();\n            }\n\n            word = text.substring(cursor, sel_end);\n        }\n        // Log.d(\"Yaaic\", \"Trying to complete nick: \" + word);\n\n        Conversation conversationForUserList = deckAdapter.getItem(deck.getSelectedItemPosition());\n\n        String[] users = null;\n\n        if (conversationForUserList.getType() == Conversation.TYPE_CHANNEL) {\n            users = binder.getService().getConnection(server.getId()).getUsersAsStringArray(\n                conversationForUserList.getName()\n            );\n        }\n\n        // go through users and add matches\n        if (users != null) {\n            List<Integer> result = new ArrayList<Integer>();\n\n            for (int i = 0; i < users.length; i++) {\n                if (users[i].toLowerCase().startsWith(word)) {\n                    result.add(Integer.valueOf(i));\n                }\n            }\n\n            if (result.size() == 1) {\n                input.setSelection(cursor, sel_end);\n                insertNickCompletion(input, users[result.get(0).intValue()]);\n            } else if (result.size() > 0) {\n                Intent intent  = new Intent(this, UsersActivity.class);\n                String[] extra = new String[result.size()];\n                int i = 0;\n\n                for (Integer n : result) {\n                    extra[i++] = users[n.intValue()];\n                }\n\n                input.setSelection(cursor, sel_end);\n                intent.putExtra(Extra.USERS, extra);\n                startActivityForResult(intent, REQUEST_CODE_NICK_COMPLETION);\n            }\n        }\n    }\n\n    /**\n     * Insert a given nick completion into the input line\n     *\n     * @param input The input line widget, with the incomplete nick selected\n     * @param nick The completed nick\n     */\n    private void insertNickCompletion(EditText input, String nick) {\n        int start = input.getSelectionStart();\n        int end  = input.getSelectionEnd();\n\n        if (start == 0) {\n            nick += \":\";\n        }\n\n        nick += \" \";\n        input.getText().replace(start, end, nick, 0, nick.length());\n        // put cursor after inserted text\n        input.setSelection(start + nick.length());\n        input.clearComposingText();\n        input.post(new Runnable() {\n            @Override\n            public void run() {\n                // make the softkeyboard come up again (only if no hw keyboard is attached)\n                EditText input = (EditText) findViewById(R.id.input);\n                openSoftKeyboard(input);\n            }\n        });\n        input.requestFocus();\n    }\n\n    /**\n     * Open the soft keyboard (helper function)\n     */\n    private void openSoftKeyboard(View view) {\n        ((InputMethodManager) getSystemService(INPUT_METHOD_SERVICE)).showSoftInput(view, InputMethodManager.SHOW_IMPLICIT);\n    }\n}\n","Method after Refactoring":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2011 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage org.yaaic.activity;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.adapter.DeckAdapter;\nimport org.yaaic.adapter.MessageListAdapter;\nimport org.yaaic.command.CommandParser;\nimport org.yaaic.irc.IRCBinder;\nimport org.yaaic.irc.IRCConnection;\nimport org.yaaic.irc.IRCService;\nimport org.yaaic.layout.NonScalingBackgroundDrawable;\nimport org.yaaic.listener.ConversationClickListener;\nimport org.yaaic.listener.ConversationListener;\nimport org.yaaic.listener.ConversationSelectedListener;\nimport org.yaaic.listener.ServerListener;\nimport org.yaaic.listener.SpeechClickListener;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.model.Extra;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Query;\nimport org.yaaic.model.Scrollback;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.ServerInfo;\nimport org.yaaic.model.Settings;\nimport org.yaaic.model.Status;\nimport org.yaaic.model.User;\nimport org.yaaic.receiver.ConversationReceiver;\nimport org.yaaic.receiver.ServerReceiver;\nimport org.yaaic.view.ConversationSwitcher;\nimport org.yaaic.view.MessageListView;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.content.ComponentName;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.content.pm.PackageManager;\nimport android.content.pm.ResolveInfo;\nimport android.content.res.Configuration;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.speech.RecognizerIntent;\nimport android.text.InputType;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.Window;\nimport android.view.View.OnKeyListener;\nimport android.view.inputmethod.InputMethodManager;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.Gallery;\nimport android.widget.ImageView;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport android.widget.ViewSwitcher;\n\n/**\n * The server view with a scrollable list of all channels\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class ConversationActivity extends Activity implements ServiceConnection, ServerListener, ConversationListener\n{\n    public static final int REQUEST_CODE_SPEECH = 99;\n\n    private static final int REQUEST_CODE_JOIN = 1;\n    private static final int REQUEST_CODE_USERS = 2;\n    private static final int REQUEST_CODE_USER = 3;\n    private static final int REQUEST_CODE_NICK_COMPLETION= 4;\n\n    private int serverId;\n    private Server server;\n    private IRCBinder binder;\n    private ConversationReceiver channelReceiver;\n    private ServerReceiver serverReceiver;\n\n    private ViewSwitcher switcher;\n    private Gallery deck;\n    private DeckAdapter deckAdapter;\n    private Scrollback scrollback;\n    private ConversationSwitcher dots;\n\n    // XXX: This is ugly. This is a buffer for a channel that should be joined after showing the\n    //      JoinActivity. As onActivityResult() is called before onResume() a \"channel joined\"\n    //      broadcast may get lost as the broadcast receivers are registered in onResume() but the\n    //      join command would be called in onActivityResult(). joinChannelBuffer will save the\n    //      channel name in onActivityResult() and run the join command in onResume().\n    private String joinChannelBuffer;\n\n    private int historySize;\n\n    OnKeyListener inputKeyListener = new OnKeyListener() {\n        /**\n         * On key pressed (input line)\n         */\n        @Override\n        public boolean onKey(View view, int keyCode, KeyEvent event)\n        {\n            EditText input = (EditText) view;\n\n            if (event.getAction() != KeyEvent.ACTION_DOWN) {\n                return false;\n            }\n\n            if (keyCode == KeyEvent.KEYCODE_DPAD_UP) {\n                String message = scrollback.goBack();\n                if (message != null) {\n                    input.setText(message);\n                }\n                return true;\n            }\n\n            if (keyCode == KeyEvent.KEYCODE_DPAD_DOWN) {\n                String message = scrollback.goForward();\n                if (message != null) {\n                    input.setText(message);\n                }\n                return true;\n            }\n\n            if (keyCode == KeyEvent.KEYCODE_ENTER) {\n                sendMessage(input.getText().toString());\n                input.setText(\"\");\n                return true;\n            }\n\n            // Nick completion\n            if (keyCode == KeyEvent.KEYCODE_SEARCH) {\n                doNickCompletion(input);\n                return true;\n            }\n\n            return false;\n        }\n    };\n\n    /**\n     * On create\n     */\n    @Override\n    protected void onCreate(Bundle savedInstanceState)\n    {\n        super.onCreate(savedInstanceState);\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n\n        serverId = getIntent().getExtras().getInt(\"serverId\");\n        server = Yaaic.getInstance().getServerById(serverId);\n\n        // Finish activity if server does not exist anymore - See #55\n        if (server == null) {\n            this.finish();\n        }\n\n        setTitle(\"Yaaic - \" + server.getTitle());\n\n        setContentView(R.layout.conversations);\n\n        boolean isLandscape = (getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE);\n\n        ((TextView) findViewById(R.id.title)).setText(server.getTitle());\n\n        EditText input = (EditText) findViewById(R.id.input);\n        input.setOnKeyListener(inputKeyListener);\n\n        switcher = (ViewSwitcher) findViewById(R.id.switcher);\n\n        dots = (ConversationSwitcher) findViewById(R.id.dots);\n        dots.setServer(server);\n\n        deckAdapter = new DeckAdapter();\n        deck = (Gallery) findViewById(R.id.deck);\n        deck.setOnItemSelectedListener(new ConversationSelectedListener(this, server, (TextView) findViewById(R.id.title), dots));\n        deck.setAdapter(deckAdapter);\n        deck.setOnItemClickListener(new ConversationClickListener(deckAdapter, switcher));\n        deck.setBackgroundDrawable(new NonScalingBackgroundDrawable(this, deck, R.drawable.background));\n\n        Settings settings = new Settings(this);\n        historySize = settings.getHistorySize();\n\n        if (server.getStatus() == Status.PRE_CONNECTING) {\n            server.clearConversations();\n            deckAdapter.clearConversations();\n            server.getConversation(ServerInfo.DEFAULT_NAME).setHistorySize(historySize);\n        }\n\n        // Optimization : cache field lookups\n        Collection<Conversation> mConversations = server.getConversations();\n\n        for (Conversation conversation : mConversations) {\n            // Only scroll to new conversation if it was selected before\n            if (conversation.getStatus() == Conversation.STATUS_SELECTED) {\n                onNewConversation(conversation.getName());\n            } else {\n                createNewConversation(conversation.getName());\n            }\n        }\n\n        int setInputTypeFlags = 0;\n\n        if (settings.autoCorrectText()) {\n            setInputTypeFlags |= InputType.TYPE_TEXT_FLAG_AUTO_CORRECT;\n        } else {\n            // keep compatibility with api level 3\n            if ((android.os.Build.VERSION.SDK.charAt(0) - '0') >= 5) {\n                setInputTypeFlags |= 0x80000; // InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS\n            }\n        }\n        if (settings.autoCapSentences()) {\n            setInputTypeFlags |= InputType.TYPE_TEXT_FLAG_CAP_SENTENCES;\n        }\n        if (isLandscape) {\n            /* Replace the Enter key with a smiley instead of Send, to make it\n               more difficult to accidentally hit send\n               We'd like to do this in portrait too, but wouldn't have a Send\n               button in that case */\n            setInputTypeFlags |= InputType.TYPE_TEXT_VARIATION_SHORT_MESSAGE;\n        }\n        input.setInputType(input.getInputType() | setInputTypeFlags);\n\n        // Create a new scrollback history\n        scrollback = new Scrollback();\n    }\n\n    /**\n     * On resume\n     */\n    @Override\n    public void onResume()\n    {\n        // register the receivers as early as possible, otherwise we may loose a broadcast message\n        channelReceiver = new ConversationReceiver(server.getId(), this);\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_MESSAGE));\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_NEW));\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_REMOVE));\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_TOPIC));\n\n        serverReceiver = new ServerReceiver(this);\n        registerReceiver(serverReceiver, new IntentFilter(Broadcast.SERVER_UPDATE));\n\n        super.onResume();\n\n        // Check if speech recognition is enabled and available\n        if (new Settings(this).isVoiceRecognitionEnabled()) {\n            PackageManager pm = getPackageManager();\n            Button speechButton = (Button) findViewById(R.id.speech);\n            List<ResolveInfo> activities = pm.queryIntentActivities(new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH), 0);\n\n            if (activities.size() != 0) {\n                ((Button) findViewById(R.id.speech)).setOnClickListener(new SpeechClickListener(this));\n                speechButton.setVisibility(View.VISIBLE);\n            }\n        }\n\n        ((ImageView) findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\n        // Start service\n        Intent intent = new Intent(this, IRCService.class);\n        intent.setAction(IRCService.ACTION_FOREGROUND);\n        startService(intent);\n        bindService(intent, this, 0);\n\n        if (!server.isConnected()) {\n            ((EditText) findViewById(R.id.input)).setEnabled(false);\n        } else {\n            ((EditText) findViewById(R.id.input)).setEnabled(true);\n        }\n\n        // Optimization - cache field lookup\n        Collection<Conversation> mConversations = server.getConversations();\n        MessageListAdapter mAdapter;\n\n        // Fill view with messages that have been buffered while paused\n        for (Conversation conversation : mConversations) {\n            mAdapter = deckAdapter.getItemAdapter(conversation.getName());\n\n            if (mAdapter != null) {\n                mAdapter.addBulkMessages(conversation.getBuffer());\n                conversation.clearBuffer();\n            }\n\n            // Clear new message notifications for the selected conversation\n            if (conversation.getStatus() == Conversation.STATUS_SELECTED && conversation.getNewMentions() > 0) {\n                Intent ackIntent = new Intent(this, IRCService.class);\n                ackIntent.setAction(IRCService.ACTION_ACK_NEW_MENTIONS);\n                ackIntent.putExtra(IRCService.EXTRA_ACK_SERVERID, serverId);\n                ackIntent.putExtra(IRCService.EXTRA_ACK_CONVTITLE, conversation.getName());\n                startService(ackIntent);\n            }\n        }\n\n        // Join channel that has been selected in JoinActivity (onActivityResult())\n        if (joinChannelBuffer != null) {\n            new Thread() {\n                @Override\n                public void run() {\n                    binder.getService().getConnection(serverId).joinChannel(joinChannelBuffer);\n                    joinChannelBuffer = null;\n                }\n            }.start();\n        }\n\n        server.setIsForeground(true);\n    }\n\n    /**\n     * On Pause\n     */\n    @Override\n    public void onPause()\n    {\n        super.onPause();\n\n        server.setIsForeground(false);\n\n        if (binder != null && binder.getService() != null) {\n            binder.getService().checkServiceStatus();\n        }\n\n        unbindService(this);\n        unregisterReceiver(channelReceiver);\n        unregisterReceiver(serverReceiver);\n    }\n\n    /**\n     * On save instance state (e.g. before a configuration change)\n     */\n    @Override\n    protected void onSaveInstanceState(Bundle outState)\n    {\n        super.onSaveInstanceState(outState);\n\n        if (deckAdapter.isSwitched()) {\n            outState.putBoolean(\"isSwitched\", deckAdapter.isSwitched());\n            outState.putString(\"switchedName\", deckAdapter.getSwitchedName());\n        }\n    }\n\n    /**\n     * On restore instance state (e.g. after a configuration change)\n     */\n    @Override\n    protected void onRestoreInstanceState(Bundle inState)\n    {\n        super.onRestoreInstanceState(inState);\n\n        if (inState.getBoolean(\"isSwitched\")) {\n            deckAdapter.setSwitched(inState.getString(\"switchedName\"), null);\n        }\n    }\n\n    /**\n     * On service connected\n     */\n    @Override\n    public void onServiceConnected(ComponentName name, IBinder service)\n    {\n        this.binder = (IRCBinder) service;\n\n        // connect to irc server if connect has been requested\n        if (server.getStatus() == Status.PRE_CONNECTING && getIntent().hasExtra(\"connect\")) {\n            server.setStatus(Status.CONNECTING);\n            binder.connect(server);\n        }\n    }\n\n    /**\n     * On service disconnected\n     */\n    @Override\n    public void onServiceDisconnected(ComponentName name)\n    {\n        this.binder = null;\n    }\n\n    /**\n     * On options menu requested\n     */\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu)\n    {\n        super.onCreateOptionsMenu(menu);\n\n        // inflate from xml\n        MenuInflater inflater = getMenuInflater();\n        inflater.inflate(R.menu.conversations, menu);\n\n        return true;\n    }\n\n    /**\n     * On prepare options menu\n     */\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu)\n    {\n        menu.getItem(0).setEnabled(server.isConnected()); // join\n        menu.getItem(1).setEnabled(server.isConnected()); // users\n        menu.getItem(2).setEnabled(server.isConnected()); // close\n\n        return true;\n    }\n\n    /**\n     * On menu item selected\n     */\n    @Override\n    public boolean onMenuItemSelected(int featureId, MenuItem item)\n    {\n        switch (item.getItemId()) {\n            case R.id.disconnect:\n                server.setStatus(Status.DISCONNECTED);\n                binder.getService().getConnection(serverId).quitServer();\n                server.clearConversations();\n                setResult(RESULT_OK);\n                finish();\n                break;\n\n            case R.id.close:\n                Conversation conversationToClose = deckAdapter.getItem(deck.getSelectedItemPosition());\n                // Make sure we part a channel when closing the channel conversation\n                if (conversationToClose.getType() == Conversation.TYPE_CHANNEL) {\n                    binder.getService().getConnection(serverId).partChannel(conversationToClose.getName());\n                }\n                else if (conversationToClose.getType() == Conversation.TYPE_QUERY) {\n                    server.removeConversation(conversationToClose.getName());\n                    onRemoveConversation(conversationToClose.getName());\n                } else {\n                    Toast.makeText(this, getResources().getString(R.string.close_server_window), Toast.LENGTH_SHORT).show();\n                }\n                break;\n\n            case R.id.join:\n                startActivityForResult(new Intent(this, JoinActivity.class), REQUEST_CODE_JOIN);\n                break;\n\n            case R.id.users:\n                Conversation conversationForUserList = deckAdapter.getItem(deck.getSelectedItemPosition());\n                if (conversationForUserList.getType() == Conversation.TYPE_CHANNEL) {\n                    Intent intent = new Intent(this, UsersActivity.class);\n                    intent.putExtra(\n                        Extra.USERS,\n                        binder.getService().getConnection(server.getId()).getUsersAsStringArray(\n                            conversationForUserList.getName()\n                        )\n                    );\n                    startActivityForResult(intent, REQUEST_CODE_USERS);\n                } else {\n                    Toast.makeText(this, getResources().getString(R.string.only_usable_from_channel), Toast.LENGTH_SHORT).show();\n                }\n                break;\n        }\n\n        return true;\n    }\n\n    /**\n     * Get server object assigned to this activity\n     * \n     * @return the server object\n     */\n    public Server getServer()\n    {\n        return server;\n    }\n\n    /**\n     * On conversation message\n     */\n    @Override\n    public void onConversationMessage(String target)\n    {\n        Conversation conversation = server.getConversation(target);\n\n        if (conversation == null) {\n            // In an early state it can happen that the conversation object\n            // is not created yet.\n            return;\n        }\n\n        MessageListAdapter adapter = deckAdapter.getItemAdapter(target);\n\n        while(conversation.hasBufferedMessages()) {\n            Message message = conversation.pollBufferedMessage();\n\n            if (adapter != null && message != null) {\n                adapter.addMessage(message);\n                int status;\n\n                switch (message.getType())\n                {\n                    case Message.TYPE_MISC:\n                        status = Conversation.STATUS_MISC;\n                        break;\n\n                    default:\n                        status = Conversation.STATUS_MESSAGE;\n                        break;\n                }\n                conversation.setStatus(status);\n            }\n        }\n\n        if (dots != null) {\n            dots.invalidate();\n        }\n    }\n\n    /**\n     * On new conversation\n     */\n    @Override\n    public void onNewConversation(String target)\n    {\n        createNewConversation(target);\n\n        if (!deckAdapter.isSwitched()) {\n            // Scroll to new conversation\n            deck.setSelection(deckAdapter.getCount() - 1);\n        }\n    }\n    public void createNewConversation(String target)\n    {\n        deckAdapter.addItem(server.getConversation(target));\n    }\n\n    /**\n     * On conversation remove\n     */\n    @Override\n    public void onRemoveConversation(String target)\n    {\n        deckAdapter.removeItem(target);\n\n        if (deckAdapter.isSwitched()) {\n            switcher.showNext();\n            switcher.removeView(deckAdapter.getSwitchedView());\n            deckAdapter.setSwitched(null, null);\n        }\n    }\n\n    /**\n     * On topic change\n     */\n    public void onTopicChanged(String target)\n    {\n        String selected = server.getSelectedConversation();\n        if (selected.equals(target)) {\n            // onTopicChanged is only called for channels\n            Channel channel = (Channel) server.getConversation(selected);\n            StringBuilder sb = new StringBuilder();\n            sb.append(server.getTitle() + \" - \" + channel.getName());\n            if (!(channel.getTopic()).equals(\"\")) {\n                sb.append(\" - \" + channel.getTopic());\n            }\n            ((TextView) findViewById(R.id.title)).setText(sb.toString());\n        }\n    }\n\n    /**\n     * On server status update\n     */\n    @Override\n    public void onStatusUpdate()\n    {\n        ((ImageView) findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\n        EditText input = (EditText) findViewById(R.id.input);\n\n        if (server.isConnected()) {\n            input.setEnabled(true);\n        } else {\n            input.setEnabled(false);\n\n            if (server.getStatus() == Status.CONNECTING) {\n                deckAdapter.clearConversations();\n                Conversation serverInfo = server.getConversation(ServerInfo.DEFAULT_NAME);\n                serverInfo.setHistorySize(historySize);\n                deckAdapter.addItem(serverInfo);\n                return;\n            }\n\n            // Service is not connected or initialized yet - See #54\n            if (binder == null || binder.getService() == null || binder.getService().getSettings() == null) {\n                return;\n            }\n\n            if (!binder.getService().getSettings().isReconnectEnabled()) {\n                AlertDialog.Builder builder = new AlertDialog.Builder(this);\n                builder.setMessage(getResources().getString(R.string.reconnect_after_disconnect, server.getTitle()))\n                .setCancelable(false)\n                .setPositiveButton(\"Yes\", new DialogInterface.OnClickListener() {\n                    @Override\n                    public void onClick(DialogInterface dialog, int id) {\n                        binder.getService().getConnection(server.getId()).setAutojoinChannels(\n                            server.getCurrentChannelNames()\n                        );\n                        server.clearConversations();\n                        deckAdapter.clearConversations();\n                        Conversation serverInfo = server.getConversation(ServerInfo.DEFAULT_NAME);\n                        serverInfo.setHistorySize(historySize);\n                        deckAdapter.addItem(serverInfo);\n                        binder.connect(server);\n                    }\n                })\n                .setNegativeButton(getString(R.string.negative_button), new DialogInterface.OnClickListener() {\n                    @Override\n                    public void onClick(DialogInterface dialog, int id) {\n                        dialog.cancel();\n                    }\n                });\n                AlertDialog alert = builder.create();\n                alert.show();\n            }\n        }\n    }\n\n    /**\n     * On key down\n     *\n     * XXX: As we only track the back key: Android >= 2.0 will call a method called onBackPressed()\n     */\n    @Override\n    public boolean onKeyDown(int keyCode, KeyEvent event)\n    {\n        if (keyCode == KeyEvent.KEYCODE_BACK && event.getRepeatCount() == 0) {\n            if (deckAdapter.isSwitched()) {\n                MessageListView canvas = (MessageListView) deckAdapter.getView(deckAdapter.getPositionByName(deckAdapter.getSwitchedName()), null, switcher);\n                canvas.setSwitched(false);\n                deckAdapter.setSwitched(null, null);\n                return true;\n            }\n        }\n        return super.onKeyDown(keyCode, event);\n    }\n\n    /**\n     * On activity result\n     */\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent data)\n    {\n        if (resultCode != RESULT_OK) {\n            // ignore other result codes\n            return;\n        }\n\n        switch (requestCode) {\n            case REQUEST_CODE_SPEECH:\n                ArrayList<String> matches = data.getStringArrayListExtra(RecognizerIntent.EXTRA_RESULTS);\n                if (matches.size() > 0) {\n                    ((EditText) findViewById(R.id.input)).setText(matches.get(0));\n                }\n                break;\n            case REQUEST_CODE_JOIN:\n                joinChannelBuffer = data.getExtras().getString(\"channel\");\n                break;\n            case REQUEST_CODE_USERS:\n                Intent intent = new Intent(this, UserActivity.class);\n                intent.putExtra(Extra.USER, data.getStringExtra(Extra.USER));\n                startActivityForResult(intent, REQUEST_CODE_USER);\n                break;\n            case REQUEST_CODE_NICK_COMPLETION:\n                insertNickCompletion((EditText) findViewById(R.id.input), data.getExtras().getString(Extra.USER));\n                break;\n            case REQUEST_CODE_USER:\n                final int actionId = data.getExtras().getInt(Extra.ACTION);\n                final String nickname = data.getExtras().getString(Extra.USER);\n                final IRCConnection connection = binder.getService().getConnection(server.getId());\n                final String conversation = server.getSelectedConversation();\n                final Handler handler = new Handler();\n\n                // XXX: Implement me - The action should be handled after onResume()\n                //                     to catch the broadcasts... now we just wait a second\n                // Yes .. that's very ugly - we need some kind of queue that is handled after onResume()\n\n                new Thread() {\n                    @Override\n                    public void run() {\n                        try {\n                            Thread.sleep(1000);\n                        } catch (InterruptedException e) {\n                            // Do nothing\n                        }\n\n                        String nicknameWithoutPrefix = nickname;\n\n                        while (\n                            nicknameWithoutPrefix.startsWith(\"@\") ||\n                            nicknameWithoutPrefix.startsWith(\"+\") ||\n                            nicknameWithoutPrefix.startsWith(\".\") ||\n                            nicknameWithoutPrefix.startsWith(\"%\")\n                        ) {\n                            // Strip prefix(es) now\n                            nicknameWithoutPrefix = nicknameWithoutPrefix.substring(1);\n                        }\n\n                        switch (actionId) {\n                            case User.ACTION_REPLY:\n                                final String replyText = nicknameWithoutPrefix + \": \";\n                                handler.post(new Runnable() {\n                                    @Override\n                                    public void run() {\n                                        EditText input = (EditText) findViewById(R.id.input);\n                                        input.setText(replyText);\n                                        input.setSelection(replyText.length());\n                                    }\n                                });\n                                break;\n                            case User.ACTION_QUERY:\n                                Conversation query = server.getConversation(nicknameWithoutPrefix);\n                                if (query == null) {\n                                    // Open a query if there's none yet\n                                    query = new Query(nicknameWithoutPrefix);\n                                    query.setHistorySize(binder.getService().getSettings().getHistorySize());\n                                    server.addConversation(query);\n\n                                    Intent intent = Broadcast.createConversationIntent(\n                                        Broadcast.CONVERSATION_NEW,\n                                        server.getId(),\n                                        nicknameWithoutPrefix\n                                    );\n                                    binder.getService().sendBroadcast(intent);\n                                }\n                                break;\n                            case User.ACTION_OP:\n                                connection.op(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_DEOP:\n                                connection.deOp(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_VOICE:\n                                connection.voice(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_DEVOICE:\n                                connection.deVoice(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_KICK:\n                                connection.kick(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_BAN:\n                                connection.ban(conversation, nicknameWithoutPrefix + \"!*@*\");\n                                break;\n                        }\n                    }\n                }.start();\n\n                break;\n        }\n    }\n\n    /**\n     * Send a message in this conversation\n     *\n     * @param text The text of the message\n     */\n    private void sendMessage(String text) {\n        if (text.equals(\"\")) {\n            // ignore empty messages\n            return;\n        }\n\n        if (!server.isConnected()) {\n            Message message = new Message(getString(R.string.message_not_connected));\n            message.setColor(Message.COLOR_RED);\n            message.setIcon(R.drawable.error);\n            server.getConversation(server.getSelectedConversation()).addMessage(message);\n            onConversationMessage(server.getSelectedConversation());\n        }\n\n        scrollback.addMessage(text);\n\n        Conversation conversation = deckAdapter.getItem(deck.getSelectedItemPosition());\n\n        if (conversation != null) {\n            if (!text.trim().startsWith(\"/\")) {\n                if (conversation.getType() != Conversation.TYPE_SERVER) {\n                    String nickname = binder.getService().getConnection(serverId).getNick();\n                    //conversation.addMessage(new Message(\"<\" + nickname + \"> \" + text));\n                    conversation.addMessage(new Message(text, nickname));\n                    binder.getService().getConnection(serverId).sendMessage(conversation.getName(), text);\n                } else {\n                    Message message = new Message(getString(R.string.chat_only_form_channel));\n                    message.setColor(Message.COLOR_YELLOW);\n                    message.setIcon(R.drawable.warning);\n                    conversation.addMessage(message);\n                }\n                onConversationMessage(conversation.getName());\n            } else {\n                CommandParser.getInstance().parse(text, server, conversation, binder.getService());\n            }\n        }\n    }\n\n    /**\n     * Complete a nick in the input line\n     */\n    private void doNickCompletion(EditText input) {\n        String text = input.getText().toString();\n\n        if (text.length() <= 0) {\n            return;\n        }\n\n        String[] tokens = text.split(\"[\\\\s,.-]+\");\n\n        if (tokens.length <= 0) {\n            return;\n        }\n\n        String word = tokens[tokens.length - 1].toLowerCase();\n        tokens[tokens.length - 1] = null;\n\n        int begin   = input.getSelectionStart();\n        int end     = input.getSelectionEnd();\n        int cursor  = Math.min(begin, end);\n        int sel_end = Math.max(begin, end);\n\n        boolean in_selection = (cursor != sel_end);\n\n        if (in_selection) {\n            word = text.substring(cursor, sel_end);\n        } else {\n            // use the word at the curent cursor position\n            while(true) {\n                cursor -= 1;\n                if (cursor <= 0 || text.charAt(cursor) == ' ') {\n                    break;\n                }\n            }\n\n            if (cursor < 0) {\n                cursor = 0;\n            }\n\n            if (text.charAt(cursor) == ' ') {\n                cursor += 1;\n            }\n\n            sel_end = text.indexOf(' ', cursor);\n\n            if (sel_end == -1) {\n                sel_end = text.length();\n            }\n\n            word = text.substring(cursor, sel_end);\n        }\n        // Log.d(\"Yaaic\", \"Trying to complete nick: \" + word);\n\n        Conversation conversationForUserList = deckAdapter.getItem(deck.getSelectedItemPosition());\n\n        String[] users = null;\n\n        if (conversationForUserList.getType() == Conversation.TYPE_CHANNEL) {\n            users = binder.getService().getConnection(server.getId()).getUsersAsStringArray(\n                conversationForUserList.getName()\n            );\n        }\n\n        // go through users and add matches\n        if (users != null) {\n            List<Integer> result = new ArrayList<Integer>();\n\n            for (int i = 0; i < users.length; i++) {\n                String nick = removeStatusChar(users[i].toLowerCase());\n                if (nick.startsWith(word)) {\n                    result.add(Integer.valueOf(i));\n                }\n            }\n\n            if (result.size() == 1) {\n                input.setSelection(cursor, sel_end);\n                insertNickCompletion(input, users[result.get(0).intValue()]);\n            } else if (result.size() > 0) {\n                Intent intent  = new Intent(this, UsersActivity.class);\n                String[] extra = new String[result.size()];\n                int i = 0;\n\n                for (Integer n : result) {\n                    extra[i++] = users[n.intValue()];\n                }\n\n                input.setSelection(cursor, sel_end);\n                intent.putExtra(Extra.USERS, extra);\n                startActivityForResult(intent, REQUEST_CODE_NICK_COMPLETION);\n            }\n        }\n    }\n\n    /**\n     * Insert a given nick completion into the input line\n     *\n     * @param input The input line widget, with the incomplete nick selected\n     * @param nick The completed nick\n     */\n    private void insertNickCompletion(EditText input, String nick) {\n        int start = input.getSelectionStart();\n        int end  = input.getSelectionEnd();\n        nick = removeStatusChar(nick);\n\n        if (start == 0) {\n            nick += \":\";\n        }\n\n        nick += \" \";\n        input.getText().replace(start, end, nick, 0, nick.length());\n        // put cursor after inserted text\n        input.setSelection(start + nick.length());\n        input.clearComposingText();\n        input.post(new Runnable() {\n            @Override\n            public void run() {\n                // make the softkeyboard come up again (only if no hw keyboard is attached)\n                EditText input = (EditText) findViewById(R.id.input);\n                openSoftKeyboard(input);\n            }\n        });\n        input.requestFocus();\n    }\n\n    /**\n     * Open the soft keyboard (helper function)\n     */\n    private void openSoftKeyboard(View view) {\n        ((InputMethodManager) getSystemService(INPUT_METHOD_SERVICE)).showSoftInput(view, InputMethodManager.SHOW_IMPLICIT);\n    }\n\n    /**\n     * Remove the status char off the front of a nick if one is present\n     * \n     * @param nick\n     * @return nick without statuschar\n     */\n    private String removeStatusChar(String nick)\n    {\n        /* Discard status characters */\n        if (nick.startsWith(\"@\") || nick.startsWith(\"+\")\n            || nick.startsWith(\"%\")) {\n            nick = nick.substring(1);\n        }\n        return nick;\n    }\n}\n","lineNo":896}
{"Smelly Sample":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2011 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage org.yaaic.activity;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.adapter.DeckAdapter;\nimport org.yaaic.adapter.MessageListAdapter;\nimport org.yaaic.command.CommandParser;\nimport org.yaaic.irc.IRCBinder;\nimport org.yaaic.irc.IRCConnection;\nimport org.yaaic.irc.IRCService;\nimport org.yaaic.layout.NonScalingBackgroundDrawable;\nimport org.yaaic.listener.ConversationClickListener;\nimport org.yaaic.listener.ConversationListener;\nimport org.yaaic.listener.ConversationSelectedListener;\nimport org.yaaic.listener.ServerListener;\nimport org.yaaic.listener.SpeechClickListener;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.model.Extra;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Query;\nimport org.yaaic.model.Scrollback;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.ServerInfo;\nimport org.yaaic.model.Settings;\nimport org.yaaic.model.Status;\nimport org.yaaic.model.User;\nimport org.yaaic.receiver.ConversationReceiver;\nimport org.yaaic.receiver.ServerReceiver;\nimport org.yaaic.view.ConversationSwitcher;\nimport org.yaaic.view.MessageListView;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.content.pm.PackageManager;\nimport android.content.pm.ResolveInfo;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.speech.RecognizerIntent;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.View.OnKeyListener;\nimport android.view.Window;\nimport android.view.inputmethod.InputMethodManager;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.Gallery;\nimport android.widget.ImageView;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport android.widget.ViewSwitcher;\n\n/**\n * The server view with a scrollable list of all channels\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class ConversationActivity extends Activity implements ServiceConnection, ServerListener, ConversationListener, OnKeyListener\n{\n    public static final int REQUEST_CODE_SPEECH = 99;\n\n    private static final int REQUEST_CODE_JOIN = 1;\n    private static final int REQUEST_CODE_USERS = 2;\n    private static final int REQUEST_CODE_USER = 3;\n    private static final int REQUEST_CODE_NICK_COMPLETION= 4;\n\n    private int serverId;\n    private Server server;\n    private IRCBinder binder;\n    private ConversationReceiver channelReceiver;\n    private ServerReceiver serverReceiver;\n\n    private ViewSwitcher switcher;\n    private Gallery deck;\n    private DeckAdapter deckAdapter;\n    private Scrollback scrollback;\n    private ConversationSwitcher dots;\n\n    // XXX: This is ugly. This is a buffer for a channel that should be joined after showing the\n    //      JoinActivity. As onActivityResult() is called before onResume() a \"channel joined\"\n    //      broadcast may get lost as the broadcast receivers are registered in onResume() but the\n    //      join command would be called in onActivityResult(). joinChannelBuffer will save the\n    //      channel name in onActivityResult() and run the join command in onResume().\n    private String joinChannelBuffer;\n\n    // flag passed to setInputType later\n    // shall be TYPE_TEXT_FLAG_NO_SUGGESTIONS but it's not supported in all API levels (only in 5+)\n    // We'll set it to 0 if it's not supported\n    private int setInputTypeFlag;\n\n    private int historySize;\n\n    /**\n     * On create\n     */\n    @Override\n    protected void onCreate(Bundle savedInstanceState)\n    {\n        super.onCreate(savedInstanceState);\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n\n        serverId = getIntent().getExtras().getInt(\"serverId\");\n        server = Yaaic.getInstance().getServerById(serverId);\n\n        // Finish activity if server does not exist anymore - See #55\n        if (server == null) {\n            this.finish();\n        }\n\n        setTitle(\"Yaaic - \" + server.getTitle());\n\n        setContentView(R.layout.conversations);\n\n        ((TextView) findViewById(R.id.title)).setText(server.getTitle());\n        ((EditText) findViewById(R.id.input)).setOnKeyListener(this);\n\n        switcher = (ViewSwitcher) findViewById(R.id.switcher);\n\n        dots = (ConversationSwitcher) findViewById(R.id.dots);\n        dots.setServer(server);\n\n        deckAdapter = new DeckAdapter();\n        deck = (Gallery) findViewById(R.id.deck);\n        deck.setOnItemSelectedListener(new ConversationSelectedListener(this, server, (TextView) findViewById(R.id.title), dots));\n        deck.setAdapter(deckAdapter);\n        deck.setOnItemClickListener(new ConversationClickListener(deckAdapter, switcher));\n        deck.setBackgroundDrawable(new NonScalingBackgroundDrawable(this, deck, R.drawable.background));\n\n        Settings settings = new Settings(this);\n        historySize = settings.getHistorySize();\n\n        if (server.getStatus() == Status.PRE_CONNECTING) {\n            server.clearConversations();\n            deckAdapter.clearConversations();\n            server.getConversation(ServerInfo.DEFAULT_NAME).setHistorySize(historySize);\n        }\n\n        // Optimization : cache field lookups\n        Collection<Conversation> mConversations = server.getConversations();\n\n        for (Conversation conversation : mConversations) {\n            // Only scroll to new conversation if it was selected before\n            if (conversation.getStatus() == Conversation.STATUS_SELECTED) {\n                onNewConversation(conversation.getName());\n            } else {\n                createNewConversation(conversation.getName());\n            }\n        }\n\n        // keep compatibility with api level 3\n        if ((android.os.Build.VERSION.SDK.charAt(0) - '0') >= 5) {\n            setInputTypeFlag = 0x80000; // InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS\n        }\n        else {\n            setInputTypeFlag = 0;\n        }\n\n        // Create a new scrollback history\n        scrollback = new Scrollback();\n    }\n\n    /**\n     * On resume\n     */\n    @Override\n    public void onResume()\n    {\n        // register the receivers as early as possible, otherwise we may loose a broadcast message\n        channelReceiver = new ConversationReceiver(server.getId(), this);\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_MESSAGE));\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_NEW));\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_REMOVE));\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_TOPIC));\n\n        serverReceiver = new ServerReceiver(this);\n        registerReceiver(serverReceiver, new IntentFilter(Broadcast.SERVER_UPDATE));\n\n        super.onResume();\n\n        // Check if speech recognition is enabled and available\n        if (new Settings(this).isVoiceRecognitionEnabled()) {\n            PackageManager pm = getPackageManager();\n            Button speechButton = (Button) findViewById(R.id.speech);\n            List<ResolveInfo> activities = pm.queryIntentActivities(new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH), 0);\n\n            if (activities.size() != 0) {\n                ((Button) findViewById(R.id.speech)).setOnClickListener(new SpeechClickListener(this));\n                speechButton.setVisibility(View.VISIBLE);\n            }\n        }\n\n        ((ImageView) findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\n        // Start service\n        Intent intent = new Intent(this, IRCService.class);\n        intent.setAction(IRCService.ACTION_FOREGROUND);\n        startService(intent);\n        bindService(intent, this, 0);\n\n        if (!server.isConnected()) {\n            ((EditText) findViewById(R.id.input)).setEnabled(false);\n        } else {\n            ((EditText) findViewById(R.id.input)).setEnabled(true);\n        }\n\n        // Optimization - cache field lookup\n        Collection<Conversation> mConversations = server.getConversations();\n        MessageListAdapter mAdapter;\n\n        // Fill view with messages that have been buffered while paused\n        for (Conversation conversation : mConversations) {\n            mAdapter = deckAdapter.getItemAdapter(conversation.getName());\n\n            if (mAdapter != null) {\n                mAdapter.addBulkMessages(conversation.getBuffer());\n                conversation.clearBuffer();\n            }\n\n            // Clear new message notifications for the selected conversation\n            if (conversation.getStatus() == Conversation.STATUS_SELECTED && conversation.getNewMentions() > 0) {\n                Intent ackIntent = new Intent(this, IRCService.class);\n                ackIntent.setAction(IRCService.ACTION_ACK_NEW_MENTIONS);\n                ackIntent.putExtra(IRCService.EXTRA_ACK_CONVTITLE, conversation.getName());\n                startService(ackIntent);\n            }\n        }\n\n        // Join channel that has been selected in JoinActivity (onActivityResult())\n        if (joinChannelBuffer != null) {\n            new Thread() {\n                @Override\n                public void run() {\n                    binder.getService().getConnection(serverId).joinChannel(joinChannelBuffer);\n                    joinChannelBuffer = null;\n                }\n            }.start();\n        }\n\n        server.setIsForeground(true);\n    }\n\n    /**\n     * On Pause\n     */\n    @Override\n    public void onPause()\n    {\n        super.onPause();\n\n        server.setIsForeground(false);\n\n        if (binder != null && binder.getService() != null) {\n            binder.getService().checkServiceStatus();\n        }\n\n        unbindService(this);\n        unregisterReceiver(channelReceiver);\n        unregisterReceiver(serverReceiver);\n    }\n\n    /**\n     * On save instance state (e.g. before a configuration change)\n     */\n    @Override\n    protected void onSaveInstanceState(Bundle outState)\n    {\n        super.onSaveInstanceState(outState);\n\n        if (deckAdapter.isSwitched()) {\n            outState.putBoolean(\"isSwitched\", deckAdapter.isSwitched());\n            outState.putString(\"switchedName\", deckAdapter.getSwitchedName());\n        }\n    }\n\n    /**\n     * On restore instance state (e.g. after a configuration change)\n     */\n    @Override\n    protected void onRestoreInstanceState(Bundle inState)\n    {\n        super.onRestoreInstanceState(inState);\n\n        if (inState.getBoolean(\"isSwitched\")) {\n            deckAdapter.setSwitched(inState.getString(\"switchedName\"), null);\n        }\n    }\n\n    /**\n     * On service connected\n     */\n    @Override\n    public void onServiceConnected(ComponentName name, IBinder service)\n    {\n        this.binder = (IRCBinder) service;\n\n        // connect to irc server if connect has been requested\n        if (server.getStatus() == Status.PRE_CONNECTING && getIntent().hasExtra(\"connect\")) {\n            server.setStatus(Status.CONNECTING);\n            binder.connect(server);\n        }\n    }\n\n    /**\n     * On service disconnected\n     */\n    @Override\n    public void onServiceDisconnected(ComponentName name)\n    {\n        this.binder = null;\n    }\n\n    /**\n     * On options menu requested\n     */\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu)\n    {\n        super.onCreateOptionsMenu(menu);\n\n        // inflate from xml\n        MenuInflater inflater = getMenuInflater();\n        inflater.inflate(R.menu.conversations, menu);\n\n        return true;\n    }\n\n    /**\n     * On prepare options menu\n     */\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu)\n    {\n        menu.getItem(0).setEnabled(server.isConnected()); // join\n        menu.getItem(1).setEnabled(server.isConnected()); // users\n        menu.getItem(2).setEnabled(server.isConnected()); // close\n\n        return true;\n    }\n\n    /**\n     * On menu item selected\n     */\n    @Override\n    public boolean onMenuItemSelected(int featureId, MenuItem item)\n    {\n        switch (item.getItemId()) {\n            case R.id.disconnect:\n                server.setStatus(Status.DISCONNECTED);\n                binder.getService().getConnection(serverId).quitServer();\n                server.clearConversations();\n                setResult(RESULT_OK);\n                finish();\n                break;\n\n            case R.id.close:\n                Conversation conversationToClose = deckAdapter.getItem(deck.getSelectedItemPosition());\n                // Make sure we part a channel when closing the channel conversation\n                if (conversationToClose.getType() == Conversation.TYPE_CHANNEL) {\n                    binder.getService().getConnection(serverId).partChannel(conversationToClose.getName());\n                }\n                else if (conversationToClose.getType() == Conversation.TYPE_QUERY) {\n                    server.removeConversation(conversationToClose.getName());\n                    onRemoveConversation(conversationToClose.getName());\n                } else {\n                    Toast.makeText(this, getResources().getString(R.string.close_server_window), Toast.LENGTH_SHORT).show();\n                }\n                break;\n\n            case R.id.join:\n                startActivityForResult(new Intent(this, JoinActivity.class), REQUEST_CODE_JOIN);\n                break;\n\n            case R.id.users:\n                Conversation conversationForUserList = deckAdapter.getItem(deck.getSelectedItemPosition());\n                if (conversationForUserList.getType() == Conversation.TYPE_CHANNEL) {\n                    Intent intent = new Intent(this, UsersActivity.class);\n                    intent.putExtra(\n                        Extra.USERS,\n                        binder.getService().getConnection(server.getId()).getUsersAsStringArray(\n                            conversationForUserList.getName()\n                        )\n                    );\n                    startActivityForResult(intent, REQUEST_CODE_USERS);\n                } else {\n                    Toast.makeText(this, getResources().getString(R.string.only_usable_from_channel), Toast.LENGTH_SHORT).show();\n                }\n                break;\n        }\n\n        return true;\n    }\n\n    /**\n     * Get server object assigned to this activity\n     * \n     * @return the server object\n     */\n    public Server getServer()\n    {\n        return server;\n    }\n\n    /**\n     * On conversation message\n     */\n    @Override\n    public void onConversationMessage(String target)\n    {\n        Conversation conversation = server.getConversation(target);\n\n        if (conversation == null) {\n            // In an early state it can happen that the conversation object\n            // is not created yet.\n            return;\n        }\n\n        MessageListAdapter adapter = deckAdapter.getItemAdapter(target);\n\n        while(conversation.hasBufferedMessages()) {\n            Message message = conversation.pollBufferedMessage();\n\n            if (adapter != null && message != null) {\n                adapter.addMessage(message);\n                int status;\n\n                switch (message.getType())\n                {\n                    case Message.TYPE_MISC:\n                        status = Conversation.STATUS_MISC;\n                        break;\n\n                    default:\n                        status = Conversation.STATUS_MESSAGE;\n                        break;\n                }\n                conversation.setStatus(status);\n            }\n        }\n\n        if (dots != null) {\n            dots.invalidate();\n        }\n    }\n\n    /**\n     * On new conversation\n     */\n    @Override\n    public void onNewConversation(String target)\n    {\n        createNewConversation(target);\n\n        if (!deckAdapter.isSwitched()) {\n            // Scroll to new conversation\n            deck.setSelection(deckAdapter.getCount() - 1);\n        }\n    }\n    public void createNewConversation(String target)\n    {\n        deckAdapter.addItem(server.getConversation(target));\n    }\n\n    /**\n     * On conversation remove\n     */\n    @Override\n    public void onRemoveConversation(String target)\n    {\n        deckAdapter.removeItem(target);\n\n        if (deckAdapter.isSwitched()) {\n            switcher.showNext();\n            switcher.removeView(deckAdapter.getSwitchedView());\n            deckAdapter.setSwitched(null, null);\n        }\n    }\n\n    /**\n     * On topic change\n     */\n    public void onTopicChanged(String target)\n    {\n        String selected = server.getSelectedConversation();\n        if (selected.equals(target)) {\n            // onTopicChanged is only called for channels\n            Channel channel = (Channel) server.getConversation(selected);\n            StringBuilder sb = new StringBuilder();\n            sb.append(server.getTitle() + \" - \" + channel.getName());\n            if (!(channel.getTopic()).equals(\"\"))\n                sb.append(\" - \" + channel.getTopic());\n            ((TextView) findViewById(R.id.title)).setText(sb.toString());\n        }\n    }\n\n    /**\n     * On server status update\n     */\n    @Override\n    public void onStatusUpdate()\n    {\n        ((ImageView) findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\n        EditText input = (EditText) findViewById(R.id.input);\n\n        if (server.isConnected()) {\n            input.setEnabled(true);\n        } else {\n            input.setEnabled(false);\n\n            if (server.getStatus() == Status.CONNECTING) {\n                deckAdapter.clearConversations();\n                Conversation serverInfo = server.getConversation(ServerInfo.DEFAULT_NAME);\n                serverInfo.setHistorySize(historySize);\n                deckAdapter.addItem(serverInfo);\n                return;\n            }\n\n            // Service is not connected or initialized yet - See #54\n            if (binder == null || binder.getService() == null || binder.getService().getSettings() == null) {\n                return;\n            }\n\n            if (!binder.getService().getSettings().isReconnectEnabled()) {\n                AlertDialog.Builder builder = new AlertDialog.Builder(this);\n                builder.setMessage(getResources().getString(R.string.reconnect_after_disconnect, server.getTitle()))\n                .setCancelable(false)\n                .setPositiveButton(\"Yes\", new DialogInterface.OnClickListener() {\n                    @Override\n                    public void onClick(DialogInterface dialog, int id) {\n                        binder.getService().getConnection(server.getId()).setAutojoinChannels(\n                            server.getCurrentChannelNames()\n                        );\n                        server.clearConversations();\n                        deckAdapter.clearConversations();\n                        Conversation serverInfo = server.getConversation(ServerInfo.DEFAULT_NAME);\n                        serverInfo.setHistorySize(historySize);\n                        deckAdapter.addItem(serverInfo);\n                        binder.connect(server);\n                    }\n                })\n                .setNegativeButton(getString(R.string.negative_button), new DialogInterface.OnClickListener() {\n                    @Override\n                    public void onClick(DialogInterface dialog, int id) {\n                        dialog.cancel();\n                    }\n                });\n                AlertDialog alert = builder.create();\n                alert.show();\n            }\n        }\n    }\n\n    /**\n     * On key down\n     *\n     * XXX: As we only track the back key: Android >= 2.0 will call a method called onBackPressed()\n     */\n    @Override\n    public boolean onKeyDown(int keyCode, KeyEvent event)\n    {\n        if (keyCode == KeyEvent.KEYCODE_BACK && event.getRepeatCount() == 0) {\n            if (deckAdapter.isSwitched()) {\n                MessageListView canvas = (MessageListView) deckAdapter.getView(deckAdapter.getPositionByName(deckAdapter.getSwitchedName()), null, switcher);\n                canvas.setSwitched(false);\n                deckAdapter.setSwitched(null, null);\n                return true;\n            }\n        }\n        return super.onKeyDown(keyCode, event);\n    }\n\n    /**\n     * On key pressed (input line)\n     */\n    @Override\n    public boolean onKey(View view, int keyCode, KeyEvent event)\n    {\n        EditText input = (EditText) view;\n\n        if (keyCode == KeyEvent.KEYCODE_DPAD_UP && event.getAction() == KeyEvent.ACTION_DOWN) {\n            String message = scrollback.goBack();\n            if (message != null) {\n                input.setText(message);\n            }\n            return true;\n        }\n\n        if (keyCode == KeyEvent.KEYCODE_DPAD_DOWN && event.getAction() == KeyEvent.ACTION_DOWN) {\n            String message = scrollback.goForward();\n            if (message != null) {\n                input.setText(message);\n            }\n            return true;\n        }\n\n        // Nick completion\n        if (keyCode == KeyEvent.KEYCODE_SEARCH && event.getAction() == KeyEvent.ACTION_DOWN) {\n            String text = input.getText().toString();\n\n            if (text.length() <= 0) {\n                return true;\n            }\n\n            String[] tokens = text.split(\"[\\\\s,.-]+\");\n\n            if (tokens.length <= 0) {\n                return true;\n            }\n\n            String word = tokens[tokens.length - 1].toLowerCase();\n            tokens[tokens.length - 1] = null;\n\n            int begin   = input.getSelectionStart();\n            int end     = input.getSelectionEnd();\n            int cursor  = Math.min(begin, end);\n            int sel_end = Math.max(begin, end);\n\n            boolean in_selection = cursor != sel_end;\n\n            if (in_selection) {\n                word = text.substring(cursor, sel_end);\n            } else {\n                // use the word at the curent cursor position\n                while(true) {\n                    cursor -= 1;\n                    if (cursor <= 0 || text.charAt(cursor) == ' ') {\n                        break;\n                    }\n                }\n\n                if (cursor < 0) {\n                    cursor = 0;\n                }\n\n                if (text.charAt(cursor) == ' ') {\n                    cursor += 1;\n                }\n\n                sel_end = text.indexOf(' ', cursor);\n\n                if (sel_end == -1) {\n                    sel_end = text.length();\n                }\n\n                word = text.substring(cursor, sel_end);\n            }\n            // Log.d(\"Yaaic\", \"Trying to complete nick: \" + word);\n\n            Conversation conversationForUserList = deckAdapter.getItem(deck.getSelectedItemPosition());\n\n            String[] users = null;\n\n            if (conversationForUserList.getType() == Conversation.TYPE_CHANNEL) {\n                users = binder.getService().getConnection(server.getId()).getUsersAsStringArray(\n                    conversationForUserList.getName()\n                );\n            }\n\n            // go through users and add matches\n            if (users != null) {\n                List<Integer> result = new ArrayList<Integer>();\n\n                for (int i = 0; i < users.length; i++) {\n                    if (users[i].toLowerCase().startsWith(word)) {\n                        result.add(Integer.valueOf(i));\n                    }\n                }\n\n                if (result.size() == 1) {\n                    String text1 = users[result.get(0).intValue()];\n\n                    if (cursor == 0) {\n                        text1 += \":\";\n                    }\n\n                    text1 += \" \";\n                    input.getText().replace(cursor, sel_end, text1, 0, text1.length());\n                    int old = input.getInputType();\n                    input.setInputType(old | setInputTypeFlag);\n                } else if (result.size() > 0) {\n                    Intent intent  = new Intent(this, UsersActivity.class);\n                    String[] extra = new String[result.size()];\n                    int i = 0;\n\n                    for (Integer n : result) {\n                        extra[i++] = users[n.intValue()];\n                    }\n\n                    input.setSelection(cursor, sel_end);\n                    intent.putExtra(Extra.USERS, extra);\n                    startActivityForResult(intent, REQUEST_CODE_NICK_COMPLETION);\n                }\n            }\n            return true;\n        }\n\n        if (keyCode == KeyEvent.KEYCODE_ENTER && event.getAction() == KeyEvent.ACTION_DOWN) {\n            if (!server.isConnected()) {\n                Message message = new Message(getString(R.string.message_not_connected));\n                message.setColor(Message.COLOR_RED);\n                message.setIcon(R.drawable.error);\n                server.getConversation(server.getSelectedConversation()).addMessage(message);\n                onConversationMessage(server.getSelectedConversation());\n            }\n\n            String text = input.getText().toString();\n            input.setText(\"\");\n\n            if (text.equals(\"\")) {\n                // ignore empty messages\n                return true;\n            }\n\n            scrollback.addMessage(text);\n\n            Conversation conversation = deckAdapter.getItem(deck.getSelectedItemPosition());\n\n            if (conversation != null) {\n                if (!text.trim().startsWith(\"/\")) {\n                    if (conversation.getType() != Conversation.TYPE_SERVER) {\n                        String nickname = binder.getService().getConnection(serverId).getNick();\n                        //conversation.addMessage(new Message(\"<\" + nickname + \"> \" + text));\n                        conversation.addMessage(new Message(text, nickname));\n                        binder.getService().getConnection(serverId).sendMessage(conversation.getName(), text);\n                    } else {\n                        Message message = new Message(getString(R.string.chat_only_form_channel));\n                        message.setColor(Message.COLOR_YELLOW);\n                        message.setIcon(R.drawable.warning);\n                        conversation.addMessage(message);\n                    }\n                    onConversationMessage(conversation.getName());\n                } else {\n                    CommandParser.getInstance().parse(text, server, conversation, binder.getService());\n                }\n            }\n\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * On activity result\n     */\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent data)\n    {\n        if (resultCode != RESULT_OK) {\n            // ignore other result codes\n            return;\n        }\n\n        switch (requestCode) {\n            case REQUEST_CODE_SPEECH:\n                ArrayList<String> matches = data.getStringArrayListExtra(RecognizerIntent.EXTRA_RESULTS);\n                if (matches.size() > 0) {\n                    ((EditText) findViewById(R.id.input)).setText(matches.get(0));\n                }\n                break;\n            case REQUEST_CODE_JOIN:\n                joinChannelBuffer = data.getExtras().getString(\"channel\");\n                break;\n            case REQUEST_CODE_USERS:\n                Intent intent = new Intent(this, UserActivity.class);\n                intent.putExtra(Extra.USER, data.getStringExtra(Extra.USER));\n                startActivityForResult(intent, REQUEST_CODE_USER);\n                break;\n            case REQUEST_CODE_NICK_COMPLETION:\n                EditText input = (EditText) findViewById(R.id.input);\n                String src        = data.getExtras().getString(Extra.USER);\n                int start        = input.getSelectionStart();\n                int end        = input.getSelectionEnd();\n\n                if (start == 0) {\n                    src += \":\";\n                }\n\n                src += \" \";\n                input.getText().replace(start, end, src, 0, src.length());\n                // put cursor after inserted text\n                input.setSelection(start + src.length());\n                input.post(new Runnable() {\n                    @Override\n                    public void run() {\n                        // make the softkeyboard come up again (only if no hw keyboard is attached)\n                        EditText input = (EditText) findViewById(R.id.input);\n                        InputMethodManager mgr = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);\n                        mgr.showSoftInput(input, InputMethodManager.SHOW_IMPLICIT);\n                    }\n                });\n                input.requestFocus();\n                break;\n            case REQUEST_CODE_USER:\n                final int actionId = data.getExtras().getInt(Extra.ACTION);\n                final String nickname = data.getExtras().getString(Extra.USER);\n                final IRCConnection connection = binder.getService().getConnection(server.getId());\n                final String conversation = server.getSelectedConversation();\n                final Handler handler = new Handler();\n\n                // XXX: Implement me - The action should be handled after onResume()\n                //                     to catch the broadcasts... now we just wait a second\n                // Yes .. that's very ugly - we need some kind of queue that is handled after onResume()\n\n                new Thread() {\n                    @Override\n                    public void run() {\n                        try {\n                            Thread.sleep(1000);\n                        } catch (InterruptedException e) {\n                            // Do nothing\n                        }\n\n                        String nicknameWithoutPrefix = nickname;\n\n                        while (\n                            nicknameWithoutPrefix.startsWith(\"@\") ||\n                            nicknameWithoutPrefix.startsWith(\"+\") ||\n                            nicknameWithoutPrefix.startsWith(\".\") ||\n                            nicknameWithoutPrefix.startsWith(\"%\")\n                        ) {\n                            // Strip prefix(es) now\n                            nicknameWithoutPrefix = nicknameWithoutPrefix.substring(1);\n                        }\n\n                        switch (actionId) {\n                            case User.ACTION_REPLY:\n                                final String replyText = nicknameWithoutPrefix + \": \";\n                                handler.post(new Runnable() {\n                                    @Override\n                                    public void run() {\n                                        EditText input = (EditText) findViewById(R.id.input);\n                                        input.setText(replyText);\n                                        input.setSelection(replyText.length());\n                                    }\n                                });\n                                break;\n                            case User.ACTION_QUERY:\n                                Conversation query = server.getConversation(nicknameWithoutPrefix);\n                                if (query == null) {\n                                    // Open a query if there's none yet\n                                    query = new Query(nicknameWithoutPrefix);\n                                    query.setHistorySize(binder.getService().getSettings().getHistorySize());\n                                    server.addConversation(query);\n\n                                    Intent intent = Broadcast.createConversationIntent(\n                                        Broadcast.CONVERSATION_NEW,\n                                        server.getId(),\n                                        nicknameWithoutPrefix\n                                    );\n                                    binder.getService().sendBroadcast(intent);\n                                }\n                                break;\n                            case User.ACTION_OP:\n                                connection.op(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_DEOP:\n                                connection.deOp(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_VOICE:\n                                connection.voice(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_DEVOICE:\n                                connection.deVoice(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_KICK:\n                                connection.kick(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_BAN:\n                                connection.ban(conversation, nicknameWithoutPrefix + \"!*@*\");\n                                break;\n                        }\n                    }\n                }.start();\n\n                break;\n        }\n    }\n}\n","Method after Refactoring":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2011 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage org.yaaic.activity;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.adapter.DeckAdapter;\nimport org.yaaic.adapter.MessageListAdapter;\nimport org.yaaic.command.CommandParser;\nimport org.yaaic.irc.IRCBinder;\nimport org.yaaic.irc.IRCConnection;\nimport org.yaaic.irc.IRCService;\nimport org.yaaic.layout.NonScalingBackgroundDrawable;\nimport org.yaaic.listener.ConversationClickListener;\nimport org.yaaic.listener.ConversationListener;\nimport org.yaaic.listener.ConversationSelectedListener;\nimport org.yaaic.listener.ServerListener;\nimport org.yaaic.listener.SpeechClickListener;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.model.Extra;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Query;\nimport org.yaaic.model.Scrollback;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.ServerInfo;\nimport org.yaaic.model.Settings;\nimport org.yaaic.model.Status;\nimport org.yaaic.model.User;\nimport org.yaaic.receiver.ConversationReceiver;\nimport org.yaaic.receiver.ServerReceiver;\nimport org.yaaic.view.ConversationSwitcher;\nimport org.yaaic.view.MessageListView;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.content.pm.PackageManager;\nimport android.content.pm.ResolveInfo;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.speech.RecognizerIntent;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.View.OnKeyListener;\nimport android.view.Window;\nimport android.view.inputmethod.InputMethodManager;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.Gallery;\nimport android.widget.ImageView;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport android.widget.ViewSwitcher;\n\n/**\n * The server view with a scrollable list of all channels\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class ConversationActivity extends Activity implements ServiceConnection, ServerListener, ConversationListener\n{\n    public static final int REQUEST_CODE_SPEECH = 99;\n\n    private static final int REQUEST_CODE_JOIN = 1;\n    private static final int REQUEST_CODE_USERS = 2;\n    private static final int REQUEST_CODE_USER = 3;\n    private static final int REQUEST_CODE_NICK_COMPLETION= 4;\n\n    private int serverId;\n    private Server server;\n    private IRCBinder binder;\n    private ConversationReceiver channelReceiver;\n    private ServerReceiver serverReceiver;\n\n    private ViewSwitcher switcher;\n    private Gallery deck;\n    private DeckAdapter deckAdapter;\n    private Scrollback scrollback;\n    private ConversationSwitcher dots;\n\n    // XXX: This is ugly. This is a buffer for a channel that should be joined after showing the\n    //      JoinActivity. As onActivityResult() is called before onResume() a \"channel joined\"\n    //      broadcast may get lost as the broadcast receivers are registered in onResume() but the\n    //      join command would be called in onActivityResult(). joinChannelBuffer will save the\n    //      channel name in onActivityResult() and run the join command in onResume().\n    private String joinChannelBuffer;\n\n    // flag passed to setInputType later\n    // shall be TYPE_TEXT_FLAG_NO_SUGGESTIONS but it's not supported in all API levels (only in 5+)\n    // We'll set it to 0 if it's not supported\n    private int setInputTypeFlag;\n\n    private int historySize;\n\n    OnKeyListener inputKeyListener = new OnKeyListener() {\n        /**\n         * On key pressed (input line)\n         */\n        @Override\n        public boolean onKey(View view, int keyCode, KeyEvent event)\n        {\n            EditText input = (EditText) view;\n\n            if (event.getAction() != KeyEvent.ACTION_DOWN) {\n                return false;\n            }\n\n            if (keyCode == KeyEvent.KEYCODE_DPAD_UP) {\n                String message = scrollback.goBack();\n                if (message != null) {\n                    input.setText(message);\n                }\n                return true;\n            }\n\n            if (keyCode == KeyEvent.KEYCODE_DPAD_DOWN) {\n                String message = scrollback.goForward();\n                if (message != null) {\n                    input.setText(message);\n                }\n                return true;\n            }\n\n            if (keyCode == KeyEvent.KEYCODE_ENTER) {\n                sendMessage(input.getText().toString());\n                input.setText(\"\");\n                return true;\n            }\n\n            // Nick completion\n            if (keyCode == KeyEvent.KEYCODE_SEARCH) {\n                doNickCompletion(input);\n                return true;\n            }\n\n            return false;\n        }\n    };\n\n    /**\n     * On create\n     */\n    @Override\n    protected void onCreate(Bundle savedInstanceState)\n    {\n        super.onCreate(savedInstanceState);\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n\n        serverId = getIntent().getExtras().getInt(\"serverId\");\n        server = Yaaic.getInstance().getServerById(serverId);\n\n        // Finish activity if server does not exist anymore - See #55\n        if (server == null) {\n            this.finish();\n        }\n\n        setTitle(\"Yaaic - \" + server.getTitle());\n\n        setContentView(R.layout.conversations);\n\n        ((TextView) findViewById(R.id.title)).setText(server.getTitle());\n\n        EditText input = (EditText) findViewById(R.id.input);\n        input.setOnKeyListener(inputKeyListener);\n\n        switcher = (ViewSwitcher) findViewById(R.id.switcher);\n\n        dots = (ConversationSwitcher) findViewById(R.id.dots);\n        dots.setServer(server);\n\n        deckAdapter = new DeckAdapter();\n        deck = (Gallery) findViewById(R.id.deck);\n        deck.setOnItemSelectedListener(new ConversationSelectedListener(this, server, (TextView) findViewById(R.id.title), dots));\n        deck.setAdapter(deckAdapter);\n        deck.setOnItemClickListener(new ConversationClickListener(deckAdapter, switcher));\n        deck.setBackgroundDrawable(new NonScalingBackgroundDrawable(this, deck, R.drawable.background));\n\n        Settings settings = new Settings(this);\n        historySize = settings.getHistorySize();\n\n        if (server.getStatus() == Status.PRE_CONNECTING) {\n            server.clearConversations();\n            deckAdapter.clearConversations();\n            server.getConversation(ServerInfo.DEFAULT_NAME).setHistorySize(historySize);\n        }\n\n        // Optimization : cache field lookups\n        Collection<Conversation> mConversations = server.getConversations();\n\n        for (Conversation conversation : mConversations) {\n            // Only scroll to new conversation if it was selected before\n            if (conversation.getStatus() == Conversation.STATUS_SELECTED) {\n                onNewConversation(conversation.getName());\n            } else {\n                createNewConversation(conversation.getName());\n            }\n        }\n\n        // keep compatibility with api level 3\n        if ((android.os.Build.VERSION.SDK.charAt(0) - '0') >= 5) {\n            setInputTypeFlag = 0x80000; // InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS\n        }\n        else {\n            setInputTypeFlag = 0;\n        }\n\n        // Create a new scrollback history\n        scrollback = new Scrollback();\n    }\n\n    /**\n     * On resume\n     */\n    @Override\n    public void onResume()\n    {\n        // register the receivers as early as possible, otherwise we may loose a broadcast message\n        channelReceiver = new ConversationReceiver(server.getId(), this);\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_MESSAGE));\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_NEW));\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_REMOVE));\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_TOPIC));\n\n        serverReceiver = new ServerReceiver(this);\n        registerReceiver(serverReceiver, new IntentFilter(Broadcast.SERVER_UPDATE));\n\n        super.onResume();\n\n        // Check if speech recognition is enabled and available\n        if (new Settings(this).isVoiceRecognitionEnabled()) {\n            PackageManager pm = getPackageManager();\n            Button speechButton = (Button) findViewById(R.id.speech);\n            List<ResolveInfo> activities = pm.queryIntentActivities(new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH), 0);\n\n            if (activities.size() != 0) {\n                ((Button) findViewById(R.id.speech)).setOnClickListener(new SpeechClickListener(this));\n                speechButton.setVisibility(View.VISIBLE);\n            }\n        }\n\n        ((ImageView) findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\n        // Start service\n        Intent intent = new Intent(this, IRCService.class);\n        intent.setAction(IRCService.ACTION_FOREGROUND);\n        startService(intent);\n        bindService(intent, this, 0);\n\n        if (!server.isConnected()) {\n            ((EditText) findViewById(R.id.input)).setEnabled(false);\n        } else {\n            ((EditText) findViewById(R.id.input)).setEnabled(true);\n        }\n\n        // Optimization - cache field lookup\n        Collection<Conversation> mConversations = server.getConversations();\n        MessageListAdapter mAdapter;\n\n        // Fill view with messages that have been buffered while paused\n        for (Conversation conversation : mConversations) {\n            mAdapter = deckAdapter.getItemAdapter(conversation.getName());\n\n            if (mAdapter != null) {\n                mAdapter.addBulkMessages(conversation.getBuffer());\n                conversation.clearBuffer();\n            }\n\n            // Clear new message notifications for the selected conversation\n            if (conversation.getStatus() == Conversation.STATUS_SELECTED && conversation.getNewMentions() > 0) {\n                Intent ackIntent = new Intent(this, IRCService.class);\n                ackIntent.setAction(IRCService.ACTION_ACK_NEW_MENTIONS);\n                ackIntent.putExtra(IRCService.EXTRA_ACK_CONVTITLE, conversation.getName());\n                startService(ackIntent);\n            }\n        }\n\n        // Join channel that has been selected in JoinActivity (onActivityResult())\n        if (joinChannelBuffer != null) {\n            new Thread() {\n                @Override\n                public void run() {\n                    binder.getService().getConnection(serverId).joinChannel(joinChannelBuffer);\n                    joinChannelBuffer = null;\n                }\n            }.start();\n        }\n\n        server.setIsForeground(true);\n    }\n\n    /**\n     * On Pause\n     */\n    @Override\n    public void onPause()\n    {\n        super.onPause();\n\n        server.setIsForeground(false);\n\n        if (binder != null && binder.getService() != null) {\n            binder.getService().checkServiceStatus();\n        }\n\n        unbindService(this);\n        unregisterReceiver(channelReceiver);\n        unregisterReceiver(serverReceiver);\n    }\n\n    /**\n     * On save instance state (e.g. before a configuration change)\n     */\n    @Override\n    protected void onSaveInstanceState(Bundle outState)\n    {\n        super.onSaveInstanceState(outState);\n\n        if (deckAdapter.isSwitched()) {\n            outState.putBoolean(\"isSwitched\", deckAdapter.isSwitched());\n            outState.putString(\"switchedName\", deckAdapter.getSwitchedName());\n        }\n    }\n\n    /**\n     * On restore instance state (e.g. after a configuration change)\n     */\n    @Override\n    protected void onRestoreInstanceState(Bundle inState)\n    {\n        super.onRestoreInstanceState(inState);\n\n        if (inState.getBoolean(\"isSwitched\")) {\n            deckAdapter.setSwitched(inState.getString(\"switchedName\"), null);\n        }\n    }\n\n    /**\n     * On service connected\n     */\n    @Override\n    public void onServiceConnected(ComponentName name, IBinder service)\n    {\n        this.binder = (IRCBinder) service;\n\n        // connect to irc server if connect has been requested\n        if (server.getStatus() == Status.PRE_CONNECTING && getIntent().hasExtra(\"connect\")) {\n            server.setStatus(Status.CONNECTING);\n            binder.connect(server);\n        }\n    }\n\n    /**\n     * On service disconnected\n     */\n    @Override\n    public void onServiceDisconnected(ComponentName name)\n    {\n        this.binder = null;\n    }\n\n    /**\n     * On options menu requested\n     */\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu)\n    {\n        super.onCreateOptionsMenu(menu);\n\n        // inflate from xml\n        MenuInflater inflater = getMenuInflater();\n        inflater.inflate(R.menu.conversations, menu);\n\n        return true;\n    }\n\n    /**\n     * On prepare options menu\n     */\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu)\n    {\n        menu.getItem(0).setEnabled(server.isConnected()); // join\n        menu.getItem(1).setEnabled(server.isConnected()); // users\n        menu.getItem(2).setEnabled(server.isConnected()); // close\n\n        return true;\n    }\n\n    /**\n     * On menu item selected\n     */\n    @Override\n    public boolean onMenuItemSelected(int featureId, MenuItem item)\n    {\n        switch (item.getItemId()) {\n            case R.id.disconnect:\n                server.setStatus(Status.DISCONNECTED);\n                binder.getService().getConnection(serverId).quitServer();\n                server.clearConversations();\n                setResult(RESULT_OK);\n                finish();\n                break;\n\n            case R.id.close:\n                Conversation conversationToClose = deckAdapter.getItem(deck.getSelectedItemPosition());\n                // Make sure we part a channel when closing the channel conversation\n                if (conversationToClose.getType() == Conversation.TYPE_CHANNEL) {\n                    binder.getService().getConnection(serverId).partChannel(conversationToClose.getName());\n                }\n                else if (conversationToClose.getType() == Conversation.TYPE_QUERY) {\n                    server.removeConversation(conversationToClose.getName());\n                    onRemoveConversation(conversationToClose.getName());\n                } else {\n                    Toast.makeText(this, getResources().getString(R.string.close_server_window), Toast.LENGTH_SHORT).show();\n                }\n                break;\n\n            case R.id.join:\n                startActivityForResult(new Intent(this, JoinActivity.class), REQUEST_CODE_JOIN);\n                break;\n\n            case R.id.users:\n                Conversation conversationForUserList = deckAdapter.getItem(deck.getSelectedItemPosition());\n                if (conversationForUserList.getType() == Conversation.TYPE_CHANNEL) {\n                    Intent intent = new Intent(this, UsersActivity.class);\n                    intent.putExtra(\n                        Extra.USERS,\n                        binder.getService().getConnection(server.getId()).getUsersAsStringArray(\n                            conversationForUserList.getName()\n                        )\n                    );\n                    startActivityForResult(intent, REQUEST_CODE_USERS);\n                } else {\n                    Toast.makeText(this, getResources().getString(R.string.only_usable_from_channel), Toast.LENGTH_SHORT).show();\n                }\n                break;\n        }\n\n        return true;\n    }\n\n    /**\n     * Get server object assigned to this activity\n     * \n     * @return the server object\n     */\n    public Server getServer()\n    {\n        return server;\n    }\n\n    /**\n     * On conversation message\n     */\n    @Override\n    public void onConversationMessage(String target)\n    {\n        Conversation conversation = server.getConversation(target);\n\n        if (conversation == null) {\n            // In an early state it can happen that the conversation object\n            // is not created yet.\n            return;\n        }\n\n        MessageListAdapter adapter = deckAdapter.getItemAdapter(target);\n\n        while(conversation.hasBufferedMessages()) {\n            Message message = conversation.pollBufferedMessage();\n\n            if (adapter != null && message != null) {\n                adapter.addMessage(message);\n                int status;\n\n                switch (message.getType())\n                {\n                    case Message.TYPE_MISC:\n                        status = Conversation.STATUS_MISC;\n                        break;\n\n                    default:\n                        status = Conversation.STATUS_MESSAGE;\n                        break;\n                }\n                conversation.setStatus(status);\n            }\n        }\n\n        if (dots != null) {\n            dots.invalidate();\n        }\n    }\n\n    /**\n     * On new conversation\n     */\n    @Override\n    public void onNewConversation(String target)\n    {\n        createNewConversation(target);\n\n        if (!deckAdapter.isSwitched()) {\n            // Scroll to new conversation\n            deck.setSelection(deckAdapter.getCount() - 1);\n        }\n    }\n    public void createNewConversation(String target)\n    {\n        deckAdapter.addItem(server.getConversation(target));\n    }\n\n    /**\n     * On conversation remove\n     */\n    @Override\n    public void onRemoveConversation(String target)\n    {\n        deckAdapter.removeItem(target);\n\n        if (deckAdapter.isSwitched()) {\n            switcher.showNext();\n            switcher.removeView(deckAdapter.getSwitchedView());\n            deckAdapter.setSwitched(null, null);\n        }\n    }\n\n    /**\n     * On topic change\n     */\n    public void onTopicChanged(String target)\n    {\n        String selected = server.getSelectedConversation();\n        if (selected.equals(target)) {\n            // onTopicChanged is only called for channels\n            Channel channel = (Channel) server.getConversation(selected);\n            StringBuilder sb = new StringBuilder();\n            sb.append(server.getTitle() + \" - \" + channel.getName());\n            if (!(channel.getTopic()).equals(\"\"))\n                sb.append(\" - \" + channel.getTopic());\n            ((TextView) findViewById(R.id.title)).setText(sb.toString());\n        }\n    }\n\n    /**\n     * On server status update\n     */\n    @Override\n    public void onStatusUpdate()\n    {\n        ((ImageView) findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\n        EditText input = (EditText) findViewById(R.id.input);\n\n        if (server.isConnected()) {\n            input.setEnabled(true);\n        } else {\n            input.setEnabled(false);\n\n            if (server.getStatus() == Status.CONNECTING) {\n                deckAdapter.clearConversations();\n                Conversation serverInfo = server.getConversation(ServerInfo.DEFAULT_NAME);\n                serverInfo.setHistorySize(historySize);\n                deckAdapter.addItem(serverInfo);\n                return;\n            }\n\n            // Service is not connected or initialized yet - See #54\n            if (binder == null || binder.getService() == null || binder.getService().getSettings() == null) {\n                return;\n            }\n\n            if (!binder.getService().getSettings().isReconnectEnabled()) {\n                AlertDialog.Builder builder = new AlertDialog.Builder(this);\n                builder.setMessage(getResources().getString(R.string.reconnect_after_disconnect, server.getTitle()))\n                .setCancelable(false)\n                .setPositiveButton(\"Yes\", new DialogInterface.OnClickListener() {\n                    @Override\n                    public void onClick(DialogInterface dialog, int id) {\n                        binder.getService().getConnection(server.getId()).setAutojoinChannels(\n                            server.getCurrentChannelNames()\n                        );\n                        server.clearConversations();\n                        deckAdapter.clearConversations();\n                        Conversation serverInfo = server.getConversation(ServerInfo.DEFAULT_NAME);\n                        serverInfo.setHistorySize(historySize);\n                        deckAdapter.addItem(serverInfo);\n                        binder.connect(server);\n                    }\n                })\n                .setNegativeButton(getString(R.string.negative_button), new DialogInterface.OnClickListener() {\n                    @Override\n                    public void onClick(DialogInterface dialog, int id) {\n                        dialog.cancel();\n                    }\n                });\n                AlertDialog alert = builder.create();\n                alert.show();\n            }\n        }\n    }\n\n    /**\n     * On key down\n     *\n     * XXX: As we only track the back key: Android >= 2.0 will call a method called onBackPressed()\n     */\n    @Override\n    public boolean onKeyDown(int keyCode, KeyEvent event)\n    {\n        if (keyCode == KeyEvent.KEYCODE_BACK && event.getRepeatCount() == 0) {\n            if (deckAdapter.isSwitched()) {\n                MessageListView canvas = (MessageListView) deckAdapter.getView(deckAdapter.getPositionByName(deckAdapter.getSwitchedName()), null, switcher);\n                canvas.setSwitched(false);\n                deckAdapter.setSwitched(null, null);\n                return true;\n            }\n        }\n        return super.onKeyDown(keyCode, event);\n    }\n\n    /**\n     * On activity result\n     */\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent data)\n    {\n        if (resultCode != RESULT_OK) {\n            // ignore other result codes\n            return;\n        }\n\n        switch (requestCode) {\n            case REQUEST_CODE_SPEECH:\n                ArrayList<String> matches = data.getStringArrayListExtra(RecognizerIntent.EXTRA_RESULTS);\n                if (matches.size() > 0) {\n                    ((EditText) findViewById(R.id.input)).setText(matches.get(0));\n                }\n                break;\n            case REQUEST_CODE_JOIN:\n                joinChannelBuffer = data.getExtras().getString(\"channel\");\n                break;\n            case REQUEST_CODE_USERS:\n                Intent intent = new Intent(this, UserActivity.class);\n                intent.putExtra(Extra.USER, data.getStringExtra(Extra.USER));\n                startActivityForResult(intent, REQUEST_CODE_USER);\n                break;\n            case REQUEST_CODE_NICK_COMPLETION:\n                insertNickCompletion((EditText) findViewById(R.id.input), data.getExtras().getString(Extra.USER));\n                break;\n            case REQUEST_CODE_USER:\n                final int actionId = data.getExtras().getInt(Extra.ACTION);\n                final String nickname = data.getExtras().getString(Extra.USER);\n                final IRCConnection connection = binder.getService().getConnection(server.getId());\n                final String conversation = server.getSelectedConversation();\n                final Handler handler = new Handler();\n\n                // XXX: Implement me - The action should be handled after onResume()\n                //                     to catch the broadcasts... now we just wait a second\n                // Yes .. that's very ugly - we need some kind of queue that is handled after onResume()\n\n                new Thread() {\n                    @Override\n                    public void run() {\n                        try {\n                            Thread.sleep(1000);\n                        } catch (InterruptedException e) {\n                            // Do nothing\n                        }\n\n                        String nicknameWithoutPrefix = nickname;\n\n                        while (\n                            nicknameWithoutPrefix.startsWith(\"@\") ||\n                            nicknameWithoutPrefix.startsWith(\"+\") ||\n                            nicknameWithoutPrefix.startsWith(\".\") ||\n                            nicknameWithoutPrefix.startsWith(\"%\")\n                        ) {\n                            // Strip prefix(es) now\n                            nicknameWithoutPrefix = nicknameWithoutPrefix.substring(1);\n                        }\n\n                        switch (actionId) {\n                            case User.ACTION_REPLY:\n                                final String replyText = nicknameWithoutPrefix + \": \";\n                                handler.post(new Runnable() {\n                                    @Override\n                                    public void run() {\n                                        EditText input = (EditText) findViewById(R.id.input);\n                                        input.setText(replyText);\n                                        input.setSelection(replyText.length());\n                                    }\n                                });\n                                break;\n                            case User.ACTION_QUERY:\n                                Conversation query = server.getConversation(nicknameWithoutPrefix);\n                                if (query == null) {\n                                    // Open a query if there's none yet\n                                    query = new Query(nicknameWithoutPrefix);\n                                    query.setHistorySize(binder.getService().getSettings().getHistorySize());\n                                    server.addConversation(query);\n\n                                    Intent intent = Broadcast.createConversationIntent(\n                                        Broadcast.CONVERSATION_NEW,\n                                        server.getId(),\n                                        nicknameWithoutPrefix\n                                    );\n                                    binder.getService().sendBroadcast(intent);\n                                }\n                                break;\n                            case User.ACTION_OP:\n                                connection.op(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_DEOP:\n                                connection.deOp(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_VOICE:\n                                connection.voice(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_DEVOICE:\n                                connection.deVoice(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_KICK:\n                                connection.kick(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_BAN:\n                                connection.ban(conversation, nicknameWithoutPrefix + \"!*@*\");\n                                break;\n                        }\n                    }\n                }.start();\n\n                break;\n        }\n    }\n\n    /**\n     * Send a message in this conversation\n     *\n     * @param text The text of the message\n     */\n    private void sendMessage(String text) {\n        if (text.equals(\"\")) {\n            // ignore empty messages\n            return;\n        }\n\n        if (!server.isConnected()) {\n            Message message = new Message(getString(R.string.message_not_connected));\n            message.setColor(Message.COLOR_RED);\n            message.setIcon(R.drawable.error);\n            server.getConversation(server.getSelectedConversation()).addMessage(message);\n            onConversationMessage(server.getSelectedConversation());\n        }\n\n        scrollback.addMessage(text);\n\n        Conversation conversation = deckAdapter.getItem(deck.getSelectedItemPosition());\n\n        if (conversation != null) {\n            if (!text.trim().startsWith(\"/\")) {\n                if (conversation.getType() != Conversation.TYPE_SERVER) {\n                    String nickname = binder.getService().getConnection(serverId).getNick();\n                    //conversation.addMessage(new Message(\"<\" + nickname + \"> \" + text));\n                    conversation.addMessage(new Message(text, nickname));\n                    binder.getService().getConnection(serverId).sendMessage(conversation.getName(), text);\n                } else {\n                    Message message = new Message(getString(R.string.chat_only_form_channel));\n                    message.setColor(Message.COLOR_YELLOW);\n                    message.setIcon(R.drawable.warning);\n                    conversation.addMessage(message);\n                }\n                onConversationMessage(conversation.getName());\n            } else {\n                CommandParser.getInstance().parse(text, server, conversation, binder.getService());\n            }\n        }\n    }\n\n    /**\n     * Complete a nick in the input line\n     */\n    private void doNickCompletion(EditText input) {\n        String text = input.getText().toString();\n\n        if (text.length() <= 0) {\n            return;\n        }\n\n        String[] tokens = text.split(\"[\\\\s,.-]+\");\n\n        if (tokens.length <= 0) {\n            return;\n        }\n\n        String word = tokens[tokens.length - 1].toLowerCase();\n        tokens[tokens.length - 1] = null;\n\n        int begin   = input.getSelectionStart();\n        int end     = input.getSelectionEnd();\n        int cursor  = Math.min(begin, end);\n        int sel_end = Math.max(begin, end);\n\n        boolean in_selection = (cursor != sel_end);\n\n        if (in_selection) {\n            word = text.substring(cursor, sel_end);\n        } else {\n            // use the word at the curent cursor position\n            while(true) {\n                cursor -= 1;\n                if (cursor <= 0 || text.charAt(cursor) == ' ') {\n                    break;\n                }\n            }\n\n            if (cursor < 0) {\n                cursor = 0;\n            }\n\n            if (text.charAt(cursor) == ' ') {\n                cursor += 1;\n            }\n\n            sel_end = text.indexOf(' ', cursor);\n\n            if (sel_end == -1) {\n                sel_end = text.length();\n            }\n\n            word = text.substring(cursor, sel_end);\n        }\n        // Log.d(\"Yaaic\", \"Trying to complete nick: \" + word);\n\n        Conversation conversationForUserList = deckAdapter.getItem(deck.getSelectedItemPosition());\n\n        String[] users = null;\n\n        if (conversationForUserList.getType() == Conversation.TYPE_CHANNEL) {\n            users = binder.getService().getConnection(server.getId()).getUsersAsStringArray(\n                conversationForUserList.getName()\n            );\n        }\n\n        // go through users and add matches\n        if (users != null) {\n            List<Integer> result = new ArrayList<Integer>();\n\n            for (int i = 0; i < users.length; i++) {\n                if (users[i].toLowerCase().startsWith(word)) {\n                    result.add(Integer.valueOf(i));\n                }\n            }\n\n            if (result.size() == 1) {\n                input.setSelection(cursor, sel_end);\n                insertNickCompletion(input, users[result.get(0).intValue()]);\n            } else if (result.size() > 0) {\n                Intent intent  = new Intent(this, UsersActivity.class);\n                String[] extra = new String[result.size()];\n                int i = 0;\n\n                for (Integer n : result) {\n                    extra[i++] = users[n.intValue()];\n                }\n\n                input.setSelection(cursor, sel_end);\n                intent.putExtra(Extra.USERS, extra);\n                startActivityForResult(intent, REQUEST_CODE_NICK_COMPLETION);\n            }\n        }\n    }\n\n    /**\n     * Insert a given nick completion into the input line\n     *\n     * @param input The input line widget, with the incomplete nick selected\n     * @param nick The completed nick\n     */\n    private void insertNickCompletion(EditText input, String nick) {\n        int start = input.getSelectionStart();\n        int end  = input.getSelectionEnd();\n\n        if (start == 0) {\n            nick += \":\";\n        }\n\n        nick += \" \";\n        input.getText().replace(start, end, nick, 0, nick.length());\n        // put cursor after inserted text\n        input.setSelection(start + nick.length());\n        input.post(new Runnable() {\n            @Override\n            public void run() {\n                // make the softkeyboard come up again (only if no hw keyboard is attached)\n                EditText input = (EditText) findViewById(R.id.input);\n                openSoftKeyboard(input);\n            }\n        });\n        input.requestFocus();\n    }\n\n    /**\n     * Open the soft keyboard (helper function)\n     */\n    private void openSoftKeyboard(View view) {\n        ((InputMethodManager) getSystemService(INPUT_METHOD_SERVICE)).showSoftInput(view, InputMethodManager.SHOW_IMPLICIT);\n    }\n}\n","lineNo":196}
{"Smelly Sample":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2011 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage org.yaaic.activity;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.adapter.DeckAdapter;\nimport org.yaaic.adapter.MessageListAdapter;\nimport org.yaaic.command.CommandParser;\nimport org.yaaic.irc.IRCBinder;\nimport org.yaaic.irc.IRCConnection;\nimport org.yaaic.irc.IRCService;\nimport org.yaaic.layout.NonScalingBackgroundDrawable;\nimport org.yaaic.listener.ConversationClickListener;\nimport org.yaaic.listener.ConversationListener;\nimport org.yaaic.listener.ConversationSelectedListener;\nimport org.yaaic.listener.ServerListener;\nimport org.yaaic.listener.SpeechClickListener;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.model.Extra;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Query;\nimport org.yaaic.model.Scrollback;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.ServerInfo;\nimport org.yaaic.model.Settings;\nimport org.yaaic.model.Status;\nimport org.yaaic.model.User;\nimport org.yaaic.receiver.ConversationReceiver;\nimport org.yaaic.receiver.ServerReceiver;\nimport org.yaaic.view.ConversationSwitcher;\nimport org.yaaic.view.MessageListView;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.content.pm.PackageManager;\nimport android.content.pm.ResolveInfo;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.speech.RecognizerIntent;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.View.OnKeyListener;\nimport android.view.Window;\nimport android.view.inputmethod.InputMethodManager;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.Gallery;\nimport android.widget.ImageView;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport android.widget.ViewSwitcher;\n\n/**\n * The server view with a scrollable list of all channels\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class ConversationActivity extends Activity implements ServiceConnection, ServerListener, ConversationListener, OnKeyListener\n{\n    public static final int REQUEST_CODE_SPEECH = 99;\n\n    private static final int REQUEST_CODE_JOIN = 1;\n    private static final int REQUEST_CODE_USERS = 2;\n    private static final int REQUEST_CODE_USER = 3;\n    private static final int REQUEST_CODE_NICK_COMPLETION= 4;\n\n    private int serverId;\n    private Server server;\n    private IRCBinder binder;\n    private ConversationReceiver channelReceiver;\n    private ServerReceiver serverReceiver;\n\n    private ViewSwitcher switcher;\n    private Gallery deck;\n    private DeckAdapter deckAdapter;\n    private Scrollback scrollback;\n    private ConversationSwitcher dots;\n\n    // XXX: This is ugly. This is a buffer for a channel that should be joined after showing the\n    //      JoinActivity. As onActivityResult() is called before onResume() a \"channel joined\"\n    //      broadcast may get lost as the broadcast receivers are registered in onResume() but the\n    //      join command would be called in onActivityResult(). joinChannelBuffer will save the\n    //      channel name in onActivityResult() and run the join command in onResume().\n    private String joinChannelBuffer;\n\n    // flag passed to setInputType later\n    // shall be TYPE_TEXT_FLAG_NO_SUGGESTIONS but it's not supported in all API levels (only in 5+)\n    // We'll set it to 0 if it's not supported\n    private int setInputTypeFlag;\n\n    /**\n     * On create\n     */\n    @Override\n    protected void onCreate(Bundle savedInstanceState)\n    {\n        super.onCreate(savedInstanceState);\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n\n        serverId = getIntent().getExtras().getInt(\"serverId\");\n        server = Yaaic.getInstance().getServerById(serverId);\n\n        // Finish activity if server does not exist anymore - See #55\n        if (server == null) {\n            this.finish();\n        }\n\n        setTitle(\"Yaaic - \" + server.getTitle());\n\n        setContentView(R.layout.conversations);\n\n        ((TextView) findViewById(R.id.title)).setText(server.getTitle());\n        ((EditText) findViewById(R.id.input)).setOnKeyListener(this);\n\n        switcher = (ViewSwitcher) findViewById(R.id.switcher);\n\n        dots = (ConversationSwitcher) findViewById(R.id.dots);\n        dots.setServer(server);\n\n        deckAdapter = new DeckAdapter();\n        deck = (Gallery) findViewById(R.id.deck);\n        deck.setOnItemSelectedListener(new ConversationSelectedListener(this, server, (TextView) findViewById(R.id.title), dots));\n        deck.setAdapter(deckAdapter);\n        deck.setOnItemClickListener(new ConversationClickListener(deckAdapter, switcher));\n        deck.setBackgroundDrawable(new NonScalingBackgroundDrawable(this, deck, R.drawable.background));\n\n        if (server.getStatus() == Status.PRE_CONNECTING) {\n            server.clearConversations();\n            deckAdapter.clearConversations();\n        }\n\n        // Optimization : cache field lookups\n        Collection<Conversation> mConversations = server.getConversations();\n\n        for (Conversation conversation : mConversations) {\n            // Only scroll to new conversation if it was selected before\n            if (conversation.getStatus() == Conversation.STATUS_SELECTED) {\n                onNewConversation(conversation.getName());\n            } else {\n                createNewConversation(conversation.getName());\n            }\n        }\n\n        // keep compatibility with api level 3\n        if ((android.os.Build.VERSION.SDK.charAt(0) - '0') >= 5) {\n            setInputTypeFlag = 0x80000; // InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS\n        }\n        else {\n            setInputTypeFlag = 0;\n        }\n\n        // Create a new scrollback history\n        scrollback = new Scrollback();\n    }\n\n    /**\n     * On resume\n     */\n    @Override\n    public void onResume()\n    {\n        // register the receivers as early as possible, otherwise we may loose a broadcast message\n        channelReceiver = new ConversationReceiver(server.getId(), this);\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_MESSAGE));\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_NEW));\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_REMOVE));\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_TOPIC));\n\n        serverReceiver = new ServerReceiver(this);\n        registerReceiver(serverReceiver, new IntentFilter(Broadcast.SERVER_UPDATE));\n\n        super.onResume();\n\n        // Check if speech recognition is enabled and available\n        if (new Settings(this).isVoiceRecognitionEnabled()) {\n            PackageManager pm = getPackageManager();\n            Button speechButton = (Button) findViewById(R.id.speech);\n            List<ResolveInfo> activities = pm.queryIntentActivities(new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH), 0);\n\n            if (activities.size() != 0) {\n                ((Button) findViewById(R.id.speech)).setOnClickListener(new SpeechClickListener(this));\n                speechButton.setVisibility(View.VISIBLE);\n            }\n        }\n\n        ((ImageView) findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\n        // Start service\n        Intent intent = new Intent(this, IRCService.class);\n        intent.setAction(IRCService.ACTION_FOREGROUND);\n        startService(intent);\n        bindService(intent, this, 0);\n\n        if (!server.isConnected()) {\n            ((EditText) findViewById(R.id.input)).setEnabled(false);\n        } else {\n            ((EditText) findViewById(R.id.input)).setEnabled(true);\n        }\n\n        // Optimization - cache field lookup\n        Collection<Conversation> mConversations = server.getConversations();\n        MessageListAdapter mAdapter;\n\n        // Fill view with messages that have been buffered while paused\n        for (Conversation conversation : mConversations) {\n            mAdapter = deckAdapter.getItemAdapter(conversation.getName());\n\n            if (mAdapter != null) {\n                mAdapter.addBulkMessages(conversation.getBuffer());\n                conversation.clearBuffer();\n            }\n\n            // Clear new message notifications for the selected conversation\n            if (conversation.getStatus() == Conversation.STATUS_SELECTED && conversation.getNewMentions() > 0) {\n                Intent ackIntent = new Intent(this, IRCService.class);\n                ackIntent.setAction(IRCService.ACTION_ACK_NEW_MENTIONS);\n                ackIntent.putExtra(IRCService.EXTRA_ACK_CONVTITLE, conversation.getName());\n                startService(ackIntent);\n            }\n        }\n\n        // Join channel that has been selected in JoinActivity (onActivityResult())\n        if (joinChannelBuffer != null) {\n            new Thread() {\n                @Override\n                public void run() {\n                    binder.getService().getConnection(serverId).joinChannel(joinChannelBuffer);\n                    joinChannelBuffer = null;\n                }\n            }.start();\n        }\n\n        server.setIsForeground(true);\n    }\n\n    /**\n     * On Pause\n     */\n    @Override\n    public void onPause()\n    {\n        super.onPause();\n\n        server.setIsForeground(false);\n\n        if (binder != null && binder.getService() != null) {\n            binder.getService().checkServiceStatus();\n        }\n\n        unbindService(this);\n        unregisterReceiver(channelReceiver);\n        unregisterReceiver(serverReceiver);\n    }\n\n    /**\n     * On save instance state (e.g. before a configuration change)\n     */\n    @Override\n    protected void onSaveInstanceState(Bundle outState)\n    {\n        super.onSaveInstanceState(outState);\n\n        if (deckAdapter.isSwitched()) {\n            outState.putBoolean(\"isSwitched\", deckAdapter.isSwitched());\n            outState.putString(\"switchedName\", deckAdapter.getSwitchedName());\n        }\n    }\n\n    /**\n     * On restore instance state (e.g. after a configuration change)\n     */\n    @Override\n    protected void onRestoreInstanceState(Bundle inState)\n    {\n        super.onRestoreInstanceState(inState);\n\n        if (inState.getBoolean(\"isSwitched\")) {\n            deckAdapter.setSwitched(inState.getString(\"switchedName\"), null);\n        }\n    }\n\n    /**\n     * On service connected\n     */\n    @Override\n    public void onServiceConnected(ComponentName name, IBinder service)\n    {\n        this.binder = (IRCBinder) service;\n\n        // connect to irc server if connect has been requested\n        if (server.getStatus() == Status.PRE_CONNECTING && getIntent().hasExtra(\"connect\")) {\n            server.setStatus(Status.CONNECTING);\n            binder.connect(server);\n        }\n    }\n\n    /**\n     * On service disconnected\n     */\n    @Override\n    public void onServiceDisconnected(ComponentName name)\n    {\n        this.binder = null;\n    }\n\n    /**\n     * On options menu requested\n     */\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu)\n    {\n        super.onCreateOptionsMenu(menu);\n\n        // inflate from xml\n        MenuInflater inflater = getMenuInflater();\n        inflater.inflate(R.menu.conversations, menu);\n\n        return true;\n    }\n\n    /**\n     * On prepare options menu\n     */\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu)\n    {\n        menu.getItem(0).setEnabled(server.isConnected()); // join\n        menu.getItem(1).setEnabled(server.isConnected()); // users\n        menu.getItem(2).setEnabled(server.isConnected()); // close\n\n        return true;\n    }\n\n    /**\n     * On menu item selected\n     */\n    @Override\n    public boolean onMenuItemSelected(int featureId, MenuItem item)\n    {\n        switch (item.getItemId()) {\n            case R.id.disconnect:\n                server.setStatus(Status.DISCONNECTED);\n                binder.getService().getConnection(serverId).quitServer();\n                server.clearConversations();\n                setResult(RESULT_OK);\n                finish();\n                break;\n\n            case R.id.close:\n                Conversation conversationToClose = deckAdapter.getItem(deck.getSelectedItemPosition());\n                // Make sure we part a channel when closing the channel conversation\n                if (conversationToClose.getType() == Conversation.TYPE_CHANNEL) {\n                    binder.getService().getConnection(serverId).partChannel(conversationToClose.getName());\n                }\n                else if (conversationToClose.getType() == Conversation.TYPE_QUERY) {\n                    server.removeConversation(conversationToClose.getName());\n                    onRemoveConversation(conversationToClose.getName());\n                } else {\n                    Toast.makeText(this, getResources().getString(R.string.close_server_window), Toast.LENGTH_SHORT).show();\n                }\n                break;\n\n            case R.id.join:\n                startActivityForResult(new Intent(this, JoinActivity.class), REQUEST_CODE_JOIN);\n                break;\n\n            case R.id.users:\n                Conversation conversationForUserList = deckAdapter.getItem(deck.getSelectedItemPosition());\n                if (conversationForUserList.getType() == Conversation.TYPE_CHANNEL) {\n                    Intent intent = new Intent(this, UsersActivity.class);\n                    intent.putExtra(\n                        Extra.USERS,\n                        binder.getService().getConnection(server.getId()).getUsersAsStringArray(\n                            conversationForUserList.getName()\n                        )\n                    );\n                    startActivityForResult(intent, REQUEST_CODE_USERS);\n                } else {\n                    Toast.makeText(this, getResources().getString(R.string.only_usable_from_channel), Toast.LENGTH_SHORT).show();\n                }\n                break;\n        }\n\n        return true;\n    }\n\n    /**\n     * Get server object assigned to this activity\n     * \n     * @return the server object\n     */\n    public Server getServer()\n    {\n        return server;\n    }\n\n    /**\n     * On conversation message\n     */\n    @Override\n    public void onConversationMessage(String target)\n    {\n        Conversation conversation = server.getConversation(target);\n\n        if (conversation == null) {\n            // In an early state it can happen that the conversation object\n            // is not created yet.\n            return;\n        }\n\n        MessageListAdapter adapter = deckAdapter.getItemAdapter(target);\n\n        while(conversation.hasBufferedMessages()) {\n            Message message = conversation.pollBufferedMessage();\n\n            if (adapter != null && message != null) {\n                adapter.addMessage(message);\n                int status;\n\n                switch (message.getType())\n                {\n                    case Message.TYPE_MISC:\n                        status = Conversation.STATUS_MISC;\n                        break;\n\n                    default:\n                        status = Conversation.STATUS_MESSAGE;\n                        break;\n                }\n                conversation.setStatus(status);\n            }\n        }\n\n        if (dots != null) {\n            dots.invalidate();\n        }\n    }\n\n    /**\n     * On new conversation\n     */\n    @Override\n    public void onNewConversation(String target)\n    {\n        createNewConversation(target);\n\n        if (!deckAdapter.isSwitched()) {\n            // Scroll to new conversation\n            deck.setSelection(deckAdapter.getCount() - 1);\n        }\n    }\n    public void createNewConversation(String target)\n    {\n        deckAdapter.addItem(server.getConversation(target));\n    }\n\n    /**\n     * On conversation remove\n     */\n    @Override\n    public void onRemoveConversation(String target)\n    {\n        deckAdapter.removeItem(target);\n\n        if (deckAdapter.isSwitched()) {\n            switcher.showNext();\n            switcher.removeView(deckAdapter.getSwitchedView());\n            deckAdapter.setSwitched(null, null);\n        }\n    }\n\n    /**\n     * On topic change\n     */\n    public void onTopicChanged(String target)\n    {\n        String selected = server.getSelectedConversation();\n        if (selected.equals(target)) {\n            // onTopicChanged is only called for channels\n            Channel channel = (Channel) server.getConversation(selected);\n            StringBuilder sb = new StringBuilder();\n            sb.append(server.getTitle() + \" - \" + channel.getName());\n            if (!(channel.getTopic()).equals(\"\"))\n                sb.append(\" - \" + channel.getTopic());\n            ((TextView) findViewById(R.id.title)).setText(sb.toString());\n        }\n    }\n\n    /**\n     * On server status update\n     */\n    @Override\n    public void onStatusUpdate()\n    {\n        ((ImageView) findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\n        EditText input = (EditText) findViewById(R.id.input);\n\n        if (server.isConnected()) {\n            input.setEnabled(true);\n        } else {\n            input.setEnabled(false);\n\n            if (server.getStatus() == Status.CONNECTING) {\n                deckAdapter.clearConversations();\n                deckAdapter.addItem(server.getConversation(ServerInfo.DEFAULT_NAME));\n                return;\n            }\n\n            // Service is not connected or initialized yet - See #54\n            if (binder == null || binder.getService() == null || binder.getService().getSettings() == null) {\n                return;\n            }\n\n            if (!binder.getService().getSettings().isReconnectEnabled()) {\n                AlertDialog.Builder builder = new AlertDialog.Builder(this);\n                builder.setMessage(getResources().getString(R.string.reconnect_after_disconnect, server.getTitle()))\n                .setCancelable(false)\n                .setPositiveButton(\"Yes\", new DialogInterface.OnClickListener() {\n                    @Override\n                    public void onClick(DialogInterface dialog, int id) {\n                        binder.getService().getConnection(server.getId()).setAutojoinChannels(\n                            server.getCurrentChannelNames()\n                        );\n                        server.clearConversations();\n                        deckAdapter.clearConversations();\n                        deckAdapter.addItem(server.getConversation(ServerInfo.DEFAULT_NAME));\n                        binder.connect(server);\n                    }\n                })\n                .setNegativeButton(getString(R.string.negative_button), new DialogInterface.OnClickListener() {\n                    @Override\n                    public void onClick(DialogInterface dialog, int id) {\n                        dialog.cancel();\n                    }\n                });\n                AlertDialog alert = builder.create();\n                alert.show();\n            }\n        }\n    }\n\n    /**\n     * On key down\n     *\n     * XXX: As we only track the back key: Android >= 2.0 will call a method called onBackPressed()\n     */\n    @Override\n    public boolean onKeyDown(int keyCode, KeyEvent event)\n    {\n        if (keyCode == KeyEvent.KEYCODE_BACK && event.getRepeatCount() == 0) {\n            if (deckAdapter.isSwitched()) {\n                MessageListView canvas = (MessageListView) deckAdapter.getView(deckAdapter.getPositionByName(deckAdapter.getSwitchedName()), null, switcher);\n                canvas.setSwitched(false);\n                deckAdapter.setSwitched(null, null);\n                return true;\n            }\n        }\n        return super.onKeyDown(keyCode, event);\n    }\n\n    /**\n     * On key pressed (input line)\n     */\n    @Override\n    public boolean onKey(View view, int keyCode, KeyEvent event)\n    {\n        EditText input = (EditText) view;\n\n        if (keyCode == KeyEvent.KEYCODE_DPAD_UP && event.getAction() == KeyEvent.ACTION_DOWN) {\n            String message = scrollback.goBack();\n            if (message != null) {\n                input.setText(message);\n            }\n            return true;\n        }\n\n        if (keyCode == KeyEvent.KEYCODE_DPAD_DOWN && event.getAction() == KeyEvent.ACTION_DOWN) {\n            String message = scrollback.goForward();\n            if (message != null) {\n                input.setText(message);\n            }\n            return true;\n        }\n\n        // Nick completion\n        if (keyCode == KeyEvent.KEYCODE_SEARCH && event.getAction() == KeyEvent.ACTION_DOWN) {\n            String text = input.getText().toString();\n\n            if (text.length() <= 0) {\n                return true;\n            }\n\n            String[] tokens = text.split(\"[\\\\s,.-]+\");\n\n            if (tokens.length <= 0) {\n                return true;\n            }\n\n            String word = tokens[tokens.length - 1].toLowerCase();\n            tokens[tokens.length - 1] = null;\n\n            int begin   = input.getSelectionStart();\n            int end     = input.getSelectionEnd();\n            int cursor  = Math.min(begin, end);\n            int sel_end = Math.max(begin, end);\n\n            boolean in_selection = cursor != sel_end;\n\n            if (in_selection) {\n                word = text.substring(cursor, sel_end);\n            } else {\n                // use the word at the curent cursor position\n                while(true) {\n                    cursor -= 1;\n                    if (cursor <= 0 || text.charAt(cursor) == ' ') {\n                        break;\n                    }\n                }\n\n                if (cursor < 0) {\n                    cursor = 0;\n                }\n\n                if (text.charAt(cursor) == ' ') {\n                    cursor += 1;\n                }\n\n                sel_end = text.indexOf(' ', cursor);\n\n                if (sel_end == -1) {\n                    sel_end = text.length();\n                }\n\n                word = text.substring(cursor, sel_end);\n            }\n            // Log.d(\"Yaaic\", \"Trying to complete nick: \" + word);\n\n            Conversation conversationForUserList = deckAdapter.getItem(deck.getSelectedItemPosition());\n\n            String[] users = null;\n\n            if (conversationForUserList.getType() == Conversation.TYPE_CHANNEL) {\n                users = binder.getService().getConnection(server.getId()).getUsersAsStringArray(\n                    conversationForUserList.getName()\n                );\n            }\n\n            // go through users and add matches\n            if (users != null) {\n                List<Integer> result = new ArrayList<Integer>();\n\n                for (int i = 0; i < users.length; i++) {\n                    if (users[i].toLowerCase().startsWith(word)) {\n                        result.add(Integer.valueOf(i));\n                    }\n                }\n\n                if (result.size() == 1) {\n                    String text1 = users[result.get(0).intValue()];\n\n                    if (cursor == 0) {\n                        text1 += \":\";\n                    }\n\n                    text1 += \" \";\n                    input.getText().replace(cursor, sel_end, text1, 0, text1.length());\n                    int old = input.getInputType();\n                    input.setInputType(old | setInputTypeFlag);\n                } else if (result.size() > 0) {\n                    Intent intent  = new Intent(this, UsersActivity.class);\n                    String[] extra = new String[result.size()];\n                    int i = 0;\n\n                    for (Integer n : result) {\n                        extra[i++] = users[n.intValue()];\n                    }\n\n                    input.setSelection(cursor, sel_end);\n                    intent.putExtra(Extra.USERS, extra);\n                    startActivityForResult(intent, REQUEST_CODE_NICK_COMPLETION);\n                }\n            }\n            return true;\n        }\n\n        if (keyCode == KeyEvent.KEYCODE_ENTER && event.getAction() == KeyEvent.ACTION_DOWN) {\n            if (!server.isConnected()) {\n                Message message = new Message(getString(R.string.message_not_connected));\n                message.setColor(Message.COLOR_RED);\n                message.setIcon(R.drawable.error);\n                server.getConversation(server.getSelectedConversation()).addMessage(message);\n                onConversationMessage(server.getSelectedConversation());\n            }\n\n            String text = input.getText().toString();\n            input.setText(\"\");\n\n            if (text.equals(\"\")) {\n                // ignore empty messages\n                return true;\n            }\n\n            scrollback.addMessage(text);\n\n            Conversation conversation = deckAdapter.getItem(deck.getSelectedItemPosition());\n\n            if (conversation != null) {\n                if (!text.trim().startsWith(\"/\")) {\n                    if (conversation.getType() != Conversation.TYPE_SERVER) {\n                        String nickname = binder.getService().getConnection(serverId).getNick();\n                        //conversation.addMessage(new Message(\"<\" + nickname + \"> \" + text));\n                        conversation.addMessage(new Message(text, nickname));\n                        binder.getService().getConnection(serverId).sendMessage(conversation.getName(), text);\n                    } else {\n                        Message message = new Message(getString(R.string.chat_only_form_channel));\n                        message.setColor(Message.COLOR_YELLOW);\n                        message.setIcon(R.drawable.warning);\n                        conversation.addMessage(message);\n                    }\n                    onConversationMessage(conversation.getName());\n                } else {\n                    CommandParser.getInstance().parse(text, server, conversation, binder.getService());\n                }\n            }\n\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * On activity result\n     */\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent data)\n    {\n        if (resultCode != RESULT_OK) {\n            // ignore other result codes\n            return;\n        }\n\n        switch (requestCode) {\n            case REQUEST_CODE_SPEECH:\n                ArrayList<String> matches = data.getStringArrayListExtra(RecognizerIntent.EXTRA_RESULTS);\n                if (matches.size() > 0) {\n                    ((EditText) findViewById(R.id.input)).setText(matches.get(0));\n                }\n                break;\n            case REQUEST_CODE_JOIN:\n                joinChannelBuffer = data.getExtras().getString(\"channel\");\n                break;\n            case REQUEST_CODE_USERS:\n                Intent intent = new Intent(this, UserActivity.class);\n                intent.putExtra(Extra.USER, data.getStringExtra(Extra.USER));\n                startActivityForResult(intent, REQUEST_CODE_USER);\n                break;\n            case REQUEST_CODE_NICK_COMPLETION:\n                EditText input = (EditText) findViewById(R.id.input);\n                String src        = data.getExtras().getString(Extra.USER);\n                int start        = input.getSelectionStart();\n                int end        = input.getSelectionEnd();\n\n                if (start == 0) {\n                    src += \":\";\n                }\n\n                src += \" \";\n                input.getText().replace(start, end, src, 0, src.length());\n                // put cursor after inserted text\n                input.setSelection(start + src.length());\n                input.post(new Runnable() {\n                    @Override\n                    public void run() {\n                        // make the softkeyboard come up again (only if no hw keyboard is attached)\n                        EditText input = (EditText) findViewById(R.id.input);\n                        InputMethodManager mgr = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);\n                        mgr.showSoftInput(input, InputMethodManager.SHOW_IMPLICIT);\n                    }\n                });\n                input.requestFocus();\n                break;\n            case REQUEST_CODE_USER:\n                final int actionId = data.getExtras().getInt(Extra.ACTION);\n                final String nickname = data.getExtras().getString(Extra.USER);\n                final IRCConnection connection = binder.getService().getConnection(server.getId());\n                final String conversation = server.getSelectedConversation();\n                final Handler handler = new Handler();\n\n                // XXX: Implement me - The action should be handled after onResume()\n                //                     to catch the broadcasts... now we just wait a second\n                // Yes .. that's very ugly - we need some kind of queue that is handled after onResume()\n\n                new Thread() {\n                    @Override\n                    public void run() {\n                        try {\n                            Thread.sleep(1000);\n                        } catch (InterruptedException e) {\n                            // Do nothing\n                        }\n\n                        String nicknameWithoutPrefix = nickname;\n\n                        while (\n                            nicknameWithoutPrefix.startsWith(\"@\") ||\n                            nicknameWithoutPrefix.startsWith(\"+\") ||\n                            nicknameWithoutPrefix.startsWith(\".\") ||\n                            nicknameWithoutPrefix.startsWith(\"%\")\n                        ) {\n                            // Strip prefix(es) now\n                            nicknameWithoutPrefix = nicknameWithoutPrefix.substring(1);\n                        }\n\n                        switch (actionId) {\n                            case User.ACTION_REPLY:\n                                final String replyText = nicknameWithoutPrefix + \": \";\n                                handler.post(new Runnable() {\n                                    @Override\n                                    public void run() {\n                                        EditText input = (EditText) findViewById(R.id.input);\n                                        input.setText(replyText);\n                                        input.setSelection(replyText.length());\n                                    }\n                                });\n                                break;\n                            case User.ACTION_QUERY:\n                                Conversation query = server.getConversation(nicknameWithoutPrefix);\n                                if (query == null) {\n                                    // Open a query if there's none yet\n                                    query = new Query(nicknameWithoutPrefix);\n                                    server.addConversation(query);\n\n                                    Intent intent = Broadcast.createConversationIntent(\n                                        Broadcast.CONVERSATION_NEW,\n                                        server.getId(),\n                                        nicknameWithoutPrefix\n                                    );\n                                    binder.getService().sendBroadcast(intent);\n                                }\n                                break;\n                            case User.ACTION_OP:\n                                connection.op(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_DEOP:\n                                connection.deOp(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_VOICE:\n                                connection.voice(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_DEVOICE:\n                                connection.deVoice(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_KICK:\n                                connection.kick(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_BAN:\n                                connection.ban(conversation, nicknameWithoutPrefix + \"!*@*\");\n                                break;\n                        }\n                    }\n                }.start();\n\n                break;\n        }\n    }\n}\n","Method after Refactoring":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2011 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage org.yaaic.activity;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.adapter.DeckAdapter;\nimport org.yaaic.adapter.MessageListAdapter;\nimport org.yaaic.command.CommandParser;\nimport org.yaaic.irc.IRCBinder;\nimport org.yaaic.irc.IRCConnection;\nimport org.yaaic.irc.IRCService;\nimport org.yaaic.layout.NonScalingBackgroundDrawable;\nimport org.yaaic.listener.ConversationClickListener;\nimport org.yaaic.listener.ConversationListener;\nimport org.yaaic.listener.ConversationSelectedListener;\nimport org.yaaic.listener.ServerListener;\nimport org.yaaic.listener.SpeechClickListener;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.model.Extra;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Query;\nimport org.yaaic.model.Scrollback;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.ServerInfo;\nimport org.yaaic.model.Settings;\nimport org.yaaic.model.Status;\nimport org.yaaic.model.User;\nimport org.yaaic.receiver.ConversationReceiver;\nimport org.yaaic.receiver.ServerReceiver;\nimport org.yaaic.view.ConversationSwitcher;\nimport org.yaaic.view.MessageListView;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.content.pm.PackageManager;\nimport android.content.pm.ResolveInfo;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.speech.RecognizerIntent;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.View.OnKeyListener;\nimport android.view.Window;\nimport android.view.inputmethod.InputMethodManager;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.Gallery;\nimport android.widget.ImageView;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport android.widget.ViewSwitcher;\n\n/**\n * The server view with a scrollable list of all channels\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class ConversationActivity extends Activity implements ServiceConnection, ServerListener, ConversationListener, OnKeyListener\n{\n    public static final int REQUEST_CODE_SPEECH = 99;\n\n    private static final int REQUEST_CODE_JOIN = 1;\n    private static final int REQUEST_CODE_USERS = 2;\n    private static final int REQUEST_CODE_USER = 3;\n    private static final int REQUEST_CODE_NICK_COMPLETION= 4;\n\n    private int serverId;\n    private Server server;\n    private IRCBinder binder;\n    private ConversationReceiver channelReceiver;\n    private ServerReceiver serverReceiver;\n\n    private ViewSwitcher switcher;\n    private Gallery deck;\n    private DeckAdapter deckAdapter;\n    private Scrollback scrollback;\n    private ConversationSwitcher dots;\n\n    // XXX: This is ugly. This is a buffer for a channel that should be joined after showing the\n    //      JoinActivity. As onActivityResult() is called before onResume() a \"channel joined\"\n    //      broadcast may get lost as the broadcast receivers are registered in onResume() but the\n    //      join command would be called in onActivityResult(). joinChannelBuffer will save the\n    //      channel name in onActivityResult() and run the join command in onResume().\n    private String joinChannelBuffer;\n\n    // flag passed to setInputType later\n    // shall be TYPE_TEXT_FLAG_NO_SUGGESTIONS but it's not supported in all API levels (only in 5+)\n    // We'll set it to 0 if it's not supported\n    private int setInputTypeFlag;\n\n    private int historySize;\n\n    /**\n     * On create\n     */\n    @Override\n    protected void onCreate(Bundle savedInstanceState)\n    {\n        super.onCreate(savedInstanceState);\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n\n        serverId = getIntent().getExtras().getInt(\"serverId\");\n        server = Yaaic.getInstance().getServerById(serverId);\n\n        // Finish activity if server does not exist anymore - See #55\n        if (server == null) {\n            this.finish();\n        }\n\n        setTitle(\"Yaaic - \" + server.getTitle());\n\n        setContentView(R.layout.conversations);\n\n        ((TextView) findViewById(R.id.title)).setText(server.getTitle());\n        ((EditText) findViewById(R.id.input)).setOnKeyListener(this);\n\n        switcher = (ViewSwitcher) findViewById(R.id.switcher);\n\n        dots = (ConversationSwitcher) findViewById(R.id.dots);\n        dots.setServer(server);\n\n        deckAdapter = new DeckAdapter();\n        deck = (Gallery) findViewById(R.id.deck);\n        deck.setOnItemSelectedListener(new ConversationSelectedListener(this, server, (TextView) findViewById(R.id.title), dots));\n        deck.setAdapter(deckAdapter);\n        deck.setOnItemClickListener(new ConversationClickListener(deckAdapter, switcher));\n        deck.setBackgroundDrawable(new NonScalingBackgroundDrawable(this, deck, R.drawable.background));\n\n        Settings settings = new Settings(this);\n        historySize = settings.getHistorySize();\n\n        if (server.getStatus() == Status.PRE_CONNECTING) {\n            server.clearConversations();\n            deckAdapter.clearConversations();\n            server.getConversation(ServerInfo.DEFAULT_NAME).setHistorySize(historySize);\n        }\n\n        // Optimization : cache field lookups\n        Collection<Conversation> mConversations = server.getConversations();\n\n        for (Conversation conversation : mConversations) {\n            // Only scroll to new conversation if it was selected before\n            if (conversation.getStatus() == Conversation.STATUS_SELECTED) {\n                onNewConversation(conversation.getName());\n            } else {\n                createNewConversation(conversation.getName());\n            }\n        }\n\n        // keep compatibility with api level 3\n        if ((android.os.Build.VERSION.SDK.charAt(0) - '0') >= 5) {\n            setInputTypeFlag = 0x80000; // InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS\n        }\n        else {\n            setInputTypeFlag = 0;\n        }\n\n        // Create a new scrollback history\n        scrollback = new Scrollback();\n    }\n\n    /**\n     * On resume\n     */\n    @Override\n    public void onResume()\n    {\n        // register the receivers as early as possible, otherwise we may loose a broadcast message\n        channelReceiver = new ConversationReceiver(server.getId(), this);\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_MESSAGE));\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_NEW));\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_REMOVE));\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_TOPIC));\n\n        serverReceiver = new ServerReceiver(this);\n        registerReceiver(serverReceiver, new IntentFilter(Broadcast.SERVER_UPDATE));\n\n        super.onResume();\n\n        // Check if speech recognition is enabled and available\n        if (new Settings(this).isVoiceRecognitionEnabled()) {\n            PackageManager pm = getPackageManager();\n            Button speechButton = (Button) findViewById(R.id.speech);\n            List<ResolveInfo> activities = pm.queryIntentActivities(new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH), 0);\n\n            if (activities.size() != 0) {\n                ((Button) findViewById(R.id.speech)).setOnClickListener(new SpeechClickListener(this));\n                speechButton.setVisibility(View.VISIBLE);\n            }\n        }\n\n        ((ImageView) findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\n        // Start service\n        Intent intent = new Intent(this, IRCService.class);\n        intent.setAction(IRCService.ACTION_FOREGROUND);\n        startService(intent);\n        bindService(intent, this, 0);\n\n        if (!server.isConnected()) {\n            ((EditText) findViewById(R.id.input)).setEnabled(false);\n        } else {\n            ((EditText) findViewById(R.id.input)).setEnabled(true);\n        }\n\n        // Optimization - cache field lookup\n        Collection<Conversation> mConversations = server.getConversations();\n        MessageListAdapter mAdapter;\n\n        // Fill view with messages that have been buffered while paused\n        for (Conversation conversation : mConversations) {\n            mAdapter = deckAdapter.getItemAdapter(conversation.getName());\n\n            if (mAdapter != null) {\n                mAdapter.addBulkMessages(conversation.getBuffer());\n                conversation.clearBuffer();\n            }\n\n            // Clear new message notifications for the selected conversation\n            if (conversation.getStatus() == Conversation.STATUS_SELECTED && conversation.getNewMentions() > 0) {\n                Intent ackIntent = new Intent(this, IRCService.class);\n                ackIntent.setAction(IRCService.ACTION_ACK_NEW_MENTIONS);\n                ackIntent.putExtra(IRCService.EXTRA_ACK_CONVTITLE, conversation.getName());\n                startService(ackIntent);\n            }\n        }\n\n        // Join channel that has been selected in JoinActivity (onActivityResult())\n        if (joinChannelBuffer != null) {\n            new Thread() {\n                @Override\n                public void run() {\n                    binder.getService().getConnection(serverId).joinChannel(joinChannelBuffer);\n                    joinChannelBuffer = null;\n                }\n            }.start();\n        }\n\n        server.setIsForeground(true);\n    }\n\n    /**\n     * On Pause\n     */\n    @Override\n    public void onPause()\n    {\n        super.onPause();\n\n        server.setIsForeground(false);\n\n        if (binder != null && binder.getService() != null) {\n            binder.getService().checkServiceStatus();\n        }\n\n        unbindService(this);\n        unregisterReceiver(channelReceiver);\n        unregisterReceiver(serverReceiver);\n    }\n\n    /**\n     * On save instance state (e.g. before a configuration change)\n     */\n    @Override\n    protected void onSaveInstanceState(Bundle outState)\n    {\n        super.onSaveInstanceState(outState);\n\n        if (deckAdapter.isSwitched()) {\n            outState.putBoolean(\"isSwitched\", deckAdapter.isSwitched());\n            outState.putString(\"switchedName\", deckAdapter.getSwitchedName());\n        }\n    }\n\n    /**\n     * On restore instance state (e.g. after a configuration change)\n     */\n    @Override\n    protected void onRestoreInstanceState(Bundle inState)\n    {\n        super.onRestoreInstanceState(inState);\n\n        if (inState.getBoolean(\"isSwitched\")) {\n            deckAdapter.setSwitched(inState.getString(\"switchedName\"), null);\n        }\n    }\n\n    /**\n     * On service connected\n     */\n    @Override\n    public void onServiceConnected(ComponentName name, IBinder service)\n    {\n        this.binder = (IRCBinder) service;\n\n        // connect to irc server if connect has been requested\n        if (server.getStatus() == Status.PRE_CONNECTING && getIntent().hasExtra(\"connect\")) {\n            server.setStatus(Status.CONNECTING);\n            binder.connect(server);\n        }\n    }\n\n    /**\n     * On service disconnected\n     */\n    @Override\n    public void onServiceDisconnected(ComponentName name)\n    {\n        this.binder = null;\n    }\n\n    /**\n     * On options menu requested\n     */\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu)\n    {\n        super.onCreateOptionsMenu(menu);\n\n        // inflate from xml\n        MenuInflater inflater = getMenuInflater();\n        inflater.inflate(R.menu.conversations, menu);\n\n        return true;\n    }\n\n    /**\n     * On prepare options menu\n     */\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu)\n    {\n        menu.getItem(0).setEnabled(server.isConnected()); // join\n        menu.getItem(1).setEnabled(server.isConnected()); // users\n        menu.getItem(2).setEnabled(server.isConnected()); // close\n\n        return true;\n    }\n\n    /**\n     * On menu item selected\n     */\n    @Override\n    public boolean onMenuItemSelected(int featureId, MenuItem item)\n    {\n        switch (item.getItemId()) {\n            case R.id.disconnect:\n                server.setStatus(Status.DISCONNECTED);\n                binder.getService().getConnection(serverId).quitServer();\n                server.clearConversations();\n                setResult(RESULT_OK);\n                finish();\n                break;\n\n            case R.id.close:\n                Conversation conversationToClose = deckAdapter.getItem(deck.getSelectedItemPosition());\n                // Make sure we part a channel when closing the channel conversation\n                if (conversationToClose.getType() == Conversation.TYPE_CHANNEL) {\n                    binder.getService().getConnection(serverId).partChannel(conversationToClose.getName());\n                }\n                else if (conversationToClose.getType() == Conversation.TYPE_QUERY) {\n                    server.removeConversation(conversationToClose.getName());\n                    onRemoveConversation(conversationToClose.getName());\n                } else {\n                    Toast.makeText(this, getResources().getString(R.string.close_server_window), Toast.LENGTH_SHORT).show();\n                }\n                break;\n\n            case R.id.join:\n                startActivityForResult(new Intent(this, JoinActivity.class), REQUEST_CODE_JOIN);\n                break;\n\n            case R.id.users:\n                Conversation conversationForUserList = deckAdapter.getItem(deck.getSelectedItemPosition());\n                if (conversationForUserList.getType() == Conversation.TYPE_CHANNEL) {\n                    Intent intent = new Intent(this, UsersActivity.class);\n                    intent.putExtra(\n                        Extra.USERS,\n                        binder.getService().getConnection(server.getId()).getUsersAsStringArray(\n                            conversationForUserList.getName()\n                        )\n                    );\n                    startActivityForResult(intent, REQUEST_CODE_USERS);\n                } else {\n                    Toast.makeText(this, getResources().getString(R.string.only_usable_from_channel), Toast.LENGTH_SHORT).show();\n                }\n                break;\n        }\n\n        return true;\n    }\n\n    /**\n     * Get server object assigned to this activity\n     * \n     * @return the server object\n     */\n    public Server getServer()\n    {\n        return server;\n    }\n\n    /**\n     * On conversation message\n     */\n    @Override\n    public void onConversationMessage(String target)\n    {\n        Conversation conversation = server.getConversation(target);\n\n        if (conversation == null) {\n            // In an early state it can happen that the conversation object\n            // is not created yet.\n            return;\n        }\n\n        MessageListAdapter adapter = deckAdapter.getItemAdapter(target);\n\n        while(conversation.hasBufferedMessages()) {\n            Message message = conversation.pollBufferedMessage();\n\n            if (adapter != null && message != null) {\n                adapter.addMessage(message);\n                int status;\n\n                switch (message.getType())\n                {\n                    case Message.TYPE_MISC:\n                        status = Conversation.STATUS_MISC;\n                        break;\n\n                    default:\n                        status = Conversation.STATUS_MESSAGE;\n                        break;\n                }\n                conversation.setStatus(status);\n            }\n        }\n\n        if (dots != null) {\n            dots.invalidate();\n        }\n    }\n\n    /**\n     * On new conversation\n     */\n    @Override\n    public void onNewConversation(String target)\n    {\n        createNewConversation(target);\n\n        if (!deckAdapter.isSwitched()) {\n            // Scroll to new conversation\n            deck.setSelection(deckAdapter.getCount() - 1);\n        }\n    }\n    public void createNewConversation(String target)\n    {\n        deckAdapter.addItem(server.getConversation(target));\n    }\n\n    /**\n     * On conversation remove\n     */\n    @Override\n    public void onRemoveConversation(String target)\n    {\n        deckAdapter.removeItem(target);\n\n        if (deckAdapter.isSwitched()) {\n            switcher.showNext();\n            switcher.removeView(deckAdapter.getSwitchedView());\n            deckAdapter.setSwitched(null, null);\n        }\n    }\n\n    /**\n     * On topic change\n     */\n    public void onTopicChanged(String target)\n    {\n        String selected = server.getSelectedConversation();\n        if (selected.equals(target)) {\n            // onTopicChanged is only called for channels\n            Channel channel = (Channel) server.getConversation(selected);\n            StringBuilder sb = new StringBuilder();\n            sb.append(server.getTitle() + \" - \" + channel.getName());\n            if (!(channel.getTopic()).equals(\"\"))\n                sb.append(\" - \" + channel.getTopic());\n            ((TextView) findViewById(R.id.title)).setText(sb.toString());\n        }\n    }\n\n    /**\n     * On server status update\n     */\n    @Override\n    public void onStatusUpdate()\n    {\n        ((ImageView) findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\n        EditText input = (EditText) findViewById(R.id.input);\n\n        if (server.isConnected()) {\n            input.setEnabled(true);\n        } else {\n            input.setEnabled(false);\n\n            if (server.getStatus() == Status.CONNECTING) {\n                deckAdapter.clearConversations();\n                Conversation serverInfo = server.getConversation(ServerInfo.DEFAULT_NAME);\n                serverInfo.setHistorySize(historySize);\n                deckAdapter.addItem(serverInfo);\n                return;\n            }\n\n            // Service is not connected or initialized yet - See #54\n            if (binder == null || binder.getService() == null || binder.getService().getSettings() == null) {\n                return;\n            }\n\n            if (!binder.getService().getSettings().isReconnectEnabled()) {\n                AlertDialog.Builder builder = new AlertDialog.Builder(this);\n                builder.setMessage(getResources().getString(R.string.reconnect_after_disconnect, server.getTitle()))\n                .setCancelable(false)\n                .setPositiveButton(\"Yes\", new DialogInterface.OnClickListener() {\n                    @Override\n                    public void onClick(DialogInterface dialog, int id) {\n                        binder.getService().getConnection(server.getId()).setAutojoinChannels(\n                            server.getCurrentChannelNames()\n                        );\n                        server.clearConversations();\n                        deckAdapter.clearConversations();\n                        Conversation serverInfo = server.getConversation(ServerInfo.DEFAULT_NAME);\n                        serverInfo.setHistorySize(historySize);\n                        deckAdapter.addItem(serverInfo);\n                        binder.connect(server);\n                    }\n                })\n                .setNegativeButton(getString(R.string.negative_button), new DialogInterface.OnClickListener() {\n                    @Override\n                    public void onClick(DialogInterface dialog, int id) {\n                        dialog.cancel();\n                    }\n                });\n                AlertDialog alert = builder.create();\n                alert.show();\n            }\n        }\n    }\n\n    /**\n     * On key down\n     *\n     * XXX: As we only track the back key: Android >= 2.0 will call a method called onBackPressed()\n     */\n    @Override\n    public boolean onKeyDown(int keyCode, KeyEvent event)\n    {\n        if (keyCode == KeyEvent.KEYCODE_BACK && event.getRepeatCount() == 0) {\n            if (deckAdapter.isSwitched()) {\n                MessageListView canvas = (MessageListView) deckAdapter.getView(deckAdapter.getPositionByName(deckAdapter.getSwitchedName()), null, switcher);\n                canvas.setSwitched(false);\n                deckAdapter.setSwitched(null, null);\n                return true;\n            }\n        }\n        return super.onKeyDown(keyCode, event);\n    }\n\n    /**\n     * On key pressed (input line)\n     */\n    @Override\n    public boolean onKey(View view, int keyCode, KeyEvent event)\n    {\n        EditText input = (EditText) view;\n\n        if (keyCode == KeyEvent.KEYCODE_DPAD_UP && event.getAction() == KeyEvent.ACTION_DOWN) {\n            String message = scrollback.goBack();\n            if (message != null) {\n                input.setText(message);\n            }\n            return true;\n        }\n\n        if (keyCode == KeyEvent.KEYCODE_DPAD_DOWN && event.getAction() == KeyEvent.ACTION_DOWN) {\n            String message = scrollback.goForward();\n            if (message != null) {\n                input.setText(message);\n            }\n            return true;\n        }\n\n        // Nick completion\n        if (keyCode == KeyEvent.KEYCODE_SEARCH && event.getAction() == KeyEvent.ACTION_DOWN) {\n            String text = input.getText().toString();\n\n            if (text.length() <= 0) {\n                return true;\n            }\n\n            String[] tokens = text.split(\"[\\\\s,.-]+\");\n\n            if (tokens.length <= 0) {\n                return true;\n            }\n\n            String word = tokens[tokens.length - 1].toLowerCase();\n            tokens[tokens.length - 1] = null;\n\n            int begin   = input.getSelectionStart();\n            int end     = input.getSelectionEnd();\n            int cursor  = Math.min(begin, end);\n            int sel_end = Math.max(begin, end);\n\n            boolean in_selection = cursor != sel_end;\n\n            if (in_selection) {\n                word = text.substring(cursor, sel_end);\n            } else {\n                // use the word at the curent cursor position\n                while(true) {\n                    cursor -= 1;\n                    if (cursor <= 0 || text.charAt(cursor) == ' ') {\n                        break;\n                    }\n                }\n\n                if (cursor < 0) {\n                    cursor = 0;\n                }\n\n                if (text.charAt(cursor) == ' ') {\n                    cursor += 1;\n                }\n\n                sel_end = text.indexOf(' ', cursor);\n\n                if (sel_end == -1) {\n                    sel_end = text.length();\n                }\n\n                word = text.substring(cursor, sel_end);\n            }\n            // Log.d(\"Yaaic\", \"Trying to complete nick: \" + word);\n\n            Conversation conversationForUserList = deckAdapter.getItem(deck.getSelectedItemPosition());\n\n            String[] users = null;\n\n            if (conversationForUserList.getType() == Conversation.TYPE_CHANNEL) {\n                users = binder.getService().getConnection(server.getId()).getUsersAsStringArray(\n                    conversationForUserList.getName()\n                );\n            }\n\n            // go through users and add matches\n            if (users != null) {\n                List<Integer> result = new ArrayList<Integer>();\n\n                for (int i = 0; i < users.length; i++) {\n                    if (users[i].toLowerCase().startsWith(word)) {\n                        result.add(Integer.valueOf(i));\n                    }\n                }\n\n                if (result.size() == 1) {\n                    String text1 = users[result.get(0).intValue()];\n\n                    if (cursor == 0) {\n                        text1 += \":\";\n                    }\n\n                    text1 += \" \";\n                    input.getText().replace(cursor, sel_end, text1, 0, text1.length());\n                    int old = input.getInputType();\n                    input.setInputType(old | setInputTypeFlag);\n                } else if (result.size() > 0) {\n                    Intent intent  = new Intent(this, UsersActivity.class);\n                    String[] extra = new String[result.size()];\n                    int i = 0;\n\n                    for (Integer n : result) {\n                        extra[i++] = users[n.intValue()];\n                    }\n\n                    input.setSelection(cursor, sel_end);\n                    intent.putExtra(Extra.USERS, extra);\n                    startActivityForResult(intent, REQUEST_CODE_NICK_COMPLETION);\n                }\n            }\n            return true;\n        }\n\n        if (keyCode == KeyEvent.KEYCODE_ENTER && event.getAction() == KeyEvent.ACTION_DOWN) {\n            if (!server.isConnected()) {\n                Message message = new Message(getString(R.string.message_not_connected));\n                message.setColor(Message.COLOR_RED);\n                message.setIcon(R.drawable.error);\n                server.getConversation(server.getSelectedConversation()).addMessage(message);\n                onConversationMessage(server.getSelectedConversation());\n            }\n\n            String text = input.getText().toString();\n            input.setText(\"\");\n\n            if (text.equals(\"\")) {\n                // ignore empty messages\n                return true;\n            }\n\n            scrollback.addMessage(text);\n\n            Conversation conversation = deckAdapter.getItem(deck.getSelectedItemPosition());\n\n            if (conversation != null) {\n                if (!text.trim().startsWith(\"/\")) {\n                    if (conversation.getType() != Conversation.TYPE_SERVER) {\n                        String nickname = binder.getService().getConnection(serverId).getNick();\n                        //conversation.addMessage(new Message(\"<\" + nickname + \"> \" + text));\n                        conversation.addMessage(new Message(text, nickname));\n                        binder.getService().getConnection(serverId).sendMessage(conversation.getName(), text);\n                    } else {\n                        Message message = new Message(getString(R.string.chat_only_form_channel));\n                        message.setColor(Message.COLOR_YELLOW);\n                        message.setIcon(R.drawable.warning);\n                        conversation.addMessage(message);\n                    }\n                    onConversationMessage(conversation.getName());\n                } else {\n                    CommandParser.getInstance().parse(text, server, conversation, binder.getService());\n                }\n            }\n\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * On activity result\n     */\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent data)\n    {\n        if (resultCode != RESULT_OK) {\n            // ignore other result codes\n            return;\n        }\n\n        switch (requestCode) {\n            case REQUEST_CODE_SPEECH:\n                ArrayList<String> matches = data.getStringArrayListExtra(RecognizerIntent.EXTRA_RESULTS);\n                if (matches.size() > 0) {\n                    ((EditText) findViewById(R.id.input)).setText(matches.get(0));\n                }\n                break;\n            case REQUEST_CODE_JOIN:\n                joinChannelBuffer = data.getExtras().getString(\"channel\");\n                break;\n            case REQUEST_CODE_USERS:\n                Intent intent = new Intent(this, UserActivity.class);\n                intent.putExtra(Extra.USER, data.getStringExtra(Extra.USER));\n                startActivityForResult(intent, REQUEST_CODE_USER);\n                break;\n            case REQUEST_CODE_NICK_COMPLETION:\n                EditText input = (EditText) findViewById(R.id.input);\n                String src        = data.getExtras().getString(Extra.USER);\n                int start        = input.getSelectionStart();\n                int end        = input.getSelectionEnd();\n\n                if (start == 0) {\n                    src += \":\";\n                }\n\n                src += \" \";\n                input.getText().replace(start, end, src, 0, src.length());\n                // put cursor after inserted text\n                input.setSelection(start + src.length());\n                input.post(new Runnable() {\n                    @Override\n                    public void run() {\n                        // make the softkeyboard come up again (only if no hw keyboard is attached)\n                        EditText input = (EditText) findViewById(R.id.input);\n                        InputMethodManager mgr = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);\n                        mgr.showSoftInput(input, InputMethodManager.SHOW_IMPLICIT);\n                    }\n                });\n                input.requestFocus();\n                break;\n            case REQUEST_CODE_USER:\n                final int actionId = data.getExtras().getInt(Extra.ACTION);\n                final String nickname = data.getExtras().getString(Extra.USER);\n                final IRCConnection connection = binder.getService().getConnection(server.getId());\n                final String conversation = server.getSelectedConversation();\n                final Handler handler = new Handler();\n\n                // XXX: Implement me - The action should be handled after onResume()\n                //                     to catch the broadcasts... now we just wait a second\n                // Yes .. that's very ugly - we need some kind of queue that is handled after onResume()\n\n                new Thread() {\n                    @Override\n                    public void run() {\n                        try {\n                            Thread.sleep(1000);\n                        } catch (InterruptedException e) {\n                            // Do nothing\n                        }\n\n                        String nicknameWithoutPrefix = nickname;\n\n                        while (\n                            nicknameWithoutPrefix.startsWith(\"@\") ||\n                            nicknameWithoutPrefix.startsWith(\"+\") ||\n                            nicknameWithoutPrefix.startsWith(\".\") ||\n                            nicknameWithoutPrefix.startsWith(\"%\")\n                        ) {\n                            // Strip prefix(es) now\n                            nicknameWithoutPrefix = nicknameWithoutPrefix.substring(1);\n                        }\n\n                        switch (actionId) {\n                            case User.ACTION_REPLY:\n                                final String replyText = nicknameWithoutPrefix + \": \";\n                                handler.post(new Runnable() {\n                                    @Override\n                                    public void run() {\n                                        EditText input = (EditText) findViewById(R.id.input);\n                                        input.setText(replyText);\n                                        input.setSelection(replyText.length());\n                                    }\n                                });\n                                break;\n                            case User.ACTION_QUERY:\n                                Conversation query = server.getConversation(nicknameWithoutPrefix);\n                                if (query == null) {\n                                    // Open a query if there's none yet\n                                    query = new Query(nicknameWithoutPrefix);\n                                    query.setHistorySize(binder.getService().getSettings().getHistorySize());\n                                    server.addConversation(query);\n\n                                    Intent intent = Broadcast.createConversationIntent(\n                                        Broadcast.CONVERSATION_NEW,\n                                        server.getId(),\n                                        nicknameWithoutPrefix\n                                    );\n                                    binder.getService().sendBroadcast(intent);\n                                }\n                                break;\n                            case User.ACTION_OP:\n                                connection.op(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_DEOP:\n                                connection.deOp(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_VOICE:\n                                connection.voice(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_DEVOICE:\n                                connection.deVoice(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_KICK:\n                                connection.kick(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_BAN:\n                                connection.ban(conversation, nicknameWithoutPrefix + \"!*@*\");\n                                break;\n                        }\n                    }\n                }.start();\n\n                break;\n        }\n    }\n}\n","lineNo":547}
{"Smelly Sample":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2011 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage org.yaaic.activity;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.adapter.DeckAdapter;\nimport org.yaaic.adapter.MessageListAdapter;\nimport org.yaaic.command.CommandParser;\nimport org.yaaic.irc.IRCBinder;\nimport org.yaaic.irc.IRCConnection;\nimport org.yaaic.irc.IRCService;\nimport org.yaaic.layout.NonScalingBackgroundDrawable;\nimport org.yaaic.listener.ConversationClickListener;\nimport org.yaaic.listener.ConversationListener;\nimport org.yaaic.listener.ConversationSelectedListener;\nimport org.yaaic.listener.ServerListener;\nimport org.yaaic.listener.SpeechClickListener;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.model.Extra;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Query;\nimport org.yaaic.model.Scrollback;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.ServerInfo;\nimport org.yaaic.model.Settings;\nimport org.yaaic.model.Status;\nimport org.yaaic.model.User;\nimport org.yaaic.receiver.ConversationReceiver;\nimport org.yaaic.receiver.ServerReceiver;\nimport org.yaaic.view.ConversationSwitcher;\nimport org.yaaic.view.MessageListView;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.content.pm.PackageManager;\nimport android.content.pm.ResolveInfo;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.speech.RecognizerIntent;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.View.OnKeyListener;\nimport android.view.Window;\nimport android.view.inputmethod.InputMethodManager;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.Gallery;\nimport android.widget.ImageView;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport android.widget.ViewSwitcher;\n\n/**\n * The server view with a scrollable list of all channels\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class ConversationActivity extends Activity implements ServiceConnection, ServerListener, ConversationListener, OnKeyListener\n{\n    public static final int REQUEST_CODE_SPEECH = 99;\n\n    private static final int REQUEST_CODE_JOIN = 1;\n    private static final int REQUEST_CODE_USERS = 2;\n    private static final int REQUEST_CODE_USER = 3;\n    private static final int REQUEST_CODE_NICK_COMPLETION= 4;\n\n    private int serverId;\n    private Server server;\n    private IRCBinder binder;\n    private ConversationReceiver channelReceiver;\n    private ServerReceiver serverReceiver;\n\n    private ViewSwitcher switcher;\n    private Gallery deck;\n    private DeckAdapter deckAdapter;\n    private Scrollback scrollback;\n    private ConversationSwitcher dots;\n\n    // XXX: This is ugly. This is a buffer for a channel that should be joined after showing the\n    //      JoinActivity. As onActivityResult() is called before onResume() a \"channel joined\"\n    //      broadcast may get lost as the broadcast receivers are registered in onResume() but the\n    //      join command would be called in onActivityResult(). joinChannelBuffer will save the\n    //      channel name in onActivityResult() and run the join command in onResume().\n    private String joinChannelBuffer;\n\n    // flag passed to setInputType later\n    // shall be TYPE_TEXT_FLAG_NO_SUGGESTIONS but it's not supported in all API levels (only in 5+)\n    // We'll set it to 0 if it's not supported\n    private int setInputTypeFlag;\n\n    /**\n     * On create\n     */\n    @Override\n    protected void onCreate(Bundle savedInstanceState)\n    {\n        super.onCreate(savedInstanceState);\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n\n        serverId = getIntent().getExtras().getInt(\"serverId\");\n        server = Yaaic.getInstance().getServerById(serverId);\n\n        // Finish activity if server does not exist anymore - See #55\n        if (server == null) {\n            this.finish();\n        }\n\n        setTitle(\"Yaaic - \" + server.getTitle());\n\n        setContentView(R.layout.conversations);\n\n        ((TextView) findViewById(R.id.title)).setText(server.getTitle());\n        ((EditText) findViewById(R.id.input)).setOnKeyListener(this);\n\n        switcher = (ViewSwitcher) findViewById(R.id.switcher);\n\n        dots = (ConversationSwitcher) findViewById(R.id.dots);\n        dots.setServer(server);\n\n        deckAdapter = new DeckAdapter();\n        deck = (Gallery) findViewById(R.id.deck);\n        deck.setOnItemSelectedListener(new ConversationSelectedListener(this, server, (TextView) findViewById(R.id.title), dots));\n        deck.setAdapter(deckAdapter);\n        deck.setOnItemClickListener(new ConversationClickListener(deckAdapter, switcher));\n        deck.setBackgroundDrawable(new NonScalingBackgroundDrawable(this, deck, R.drawable.background));\n\n        if (server.getStatus() == Status.PRE_CONNECTING) {\n            server.clearConversations();\n            deckAdapter.clearConversations();\n        }\n\n        // Optimization : cache field lookups\n        Collection<Conversation> mConversations = server.getConversations();\n\n        for (Conversation conversation : mConversations) {\n            // Only scroll to new conversation if it was selected before\n            if (conversation.getStatus() == Conversation.STATUS_SELECTED) {\n                onNewConversation(conversation.getName());\n            } else {\n                createNewConversation(conversation.getName());\n            }\n        }\n\n        // keep compatibility with api level 3\n        if ((android.os.Build.VERSION.SDK.charAt(0) - '0') >= 5) {\n            setInputTypeFlag = 0x80000; // InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS\n        }\n        else {\n            setInputTypeFlag = 0;\n        }\n\n        // Create a new scrollback history\n        scrollback = new Scrollback();\n    }\n\n    /**\n     * On resume\n     */\n    @Override\n    public void onResume()\n    {\n        // register the receivers as early as possible, otherwise we may loose a broadcast message\n        channelReceiver = new ConversationReceiver(server.getId(), this);\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_MESSAGE));\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_NEW));\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_REMOVE));\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_TOPIC));\n\n        serverReceiver = new ServerReceiver(this);\n        registerReceiver(serverReceiver, new IntentFilter(Broadcast.SERVER_UPDATE));\n\n        super.onResume();\n\n        // Check if speech recognition is enabled and available\n        if (new Settings(this).isVoiceRecognitionEnabled()) {\n            PackageManager pm = getPackageManager();\n            Button speechButton = (Button) findViewById(R.id.speech);\n            List<ResolveInfo> activities = pm.queryIntentActivities(new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH), 0);\n\n            if (activities.size() != 0) {\n                ((Button) findViewById(R.id.speech)).setOnClickListener(new SpeechClickListener(this));\n                speechButton.setVisibility(View.VISIBLE);\n            }\n        }\n\n        ((ImageView) findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\n        // Start service\n        Intent intent = new Intent(this, IRCService.class);\n        intent.setAction(IRCService.ACTION_FOREGROUND);\n        startService(intent);\n        bindService(intent, this, 0);\n\n        if (!server.isConnected()) {\n            ((EditText) findViewById(R.id.input)).setEnabled(false);\n        } else {\n            ((EditText) findViewById(R.id.input)).setEnabled(true);\n        }\n\n        // Optimization - cache field lookup\n        Collection<Conversation> mConversations = server.getConversations();\n        MessageListAdapter mAdapter;\n\n        // Fill view with messages that have been buffered while paused\n        for (Conversation conversation : mConversations) {\n            mAdapter = deckAdapter.getItemAdapter(conversation.getName());\n\n            if (mAdapter != null) {\n                mAdapter.addBulkMessages(conversation.getBuffer());\n                conversation.clearBuffer();\n            }\n\n            // Clear new message notifications for the selected conversation\n            if (conversation.getStatus() == Conversation.STATUS_SELECTED && conversation.getNewMentions() > 0) {\n                Intent ackIntent = new Intent(this, IRCService.class);\n                ackIntent.setAction(IRCService.ACTION_ACK_NEW_MENTIONS);\n                ackIntent.putExtra(IRCService.EXTRA_ACK_CONVTITLE, conversation.getName());\n                startService(ackIntent);\n            }\n        }\n\n        // Join channel that has been selected in JoinActivity (onActivityResult())\n        if (joinChannelBuffer != null) {\n            new Thread() {\n                @Override\n                public void run() {\n                    binder.getService().getConnection(serverId).joinChannel(joinChannelBuffer);\n                    joinChannelBuffer = null;\n                }\n            }.start();\n        }\n\n        server.setIsForeground(true);\n    }\n\n    /**\n     * On Pause\n     */\n    @Override\n    public void onPause()\n    {\n        super.onPause();\n\n        server.setIsForeground(false);\n\n        if (binder != null && binder.getService() != null) {\n            binder.getService().checkServiceStatus();\n        }\n\n        unbindService(this);\n        unregisterReceiver(channelReceiver);\n        unregisterReceiver(serverReceiver);\n    }\n\n    /**\n     * On save instance state (e.g. before a configuration change)\n     */\n    @Override\n    protected void onSaveInstanceState(Bundle outState)\n    {\n        super.onSaveInstanceState(outState);\n\n        if (deckAdapter.isSwitched()) {\n            outState.putBoolean(\"isSwitched\", deckAdapter.isSwitched());\n            outState.putString(\"switchedName\", deckAdapter.getSwitchedName());\n        }\n    }\n\n    /**\n     * On restore instance state (e.g. after a configuration change)\n     */\n    @Override\n    protected void onRestoreInstanceState(Bundle inState)\n    {\n        super.onRestoreInstanceState(inState);\n\n        if (inState.getBoolean(\"isSwitched\")) {\n            deckAdapter.setSwitched(inState.getString(\"switchedName\"), null);\n        }\n    }\n\n    /**\n     * On service connected\n     */\n    @Override\n    public void onServiceConnected(ComponentName name, IBinder service)\n    {\n        this.binder = (IRCBinder) service;\n\n        // connect to irc server if connect has been requested\n        if (server.getStatus() == Status.PRE_CONNECTING && getIntent().hasExtra(\"connect\")) {\n            server.setStatus(Status.CONNECTING);\n            binder.connect(server);\n        }\n    }\n\n    /**\n     * On service disconnected\n     */\n    @Override\n    public void onServiceDisconnected(ComponentName name)\n    {\n        this.binder = null;\n    }\n\n    /**\n     * On options menu requested\n     */\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu)\n    {\n        super.onCreateOptionsMenu(menu);\n\n        // inflate from xml\n        MenuInflater inflater = getMenuInflater();\n        inflater.inflate(R.menu.conversations, menu);\n\n        return true;\n    }\n\n    /**\n     * On prepare options menu\n     */\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu)\n    {\n        menu.getItem(0).setEnabled(server.isConnected()); // join\n        menu.getItem(1).setEnabled(server.isConnected()); // users\n        menu.getItem(2).setEnabled(server.isConnected()); // close\n\n        return true;\n    }\n\n    /**\n     * On menu item selected\n     */\n    @Override\n    public boolean onMenuItemSelected(int featureId, MenuItem item)\n    {\n        switch (item.getItemId()) {\n            case R.id.disconnect:\n                server.setStatus(Status.DISCONNECTED);\n                binder.getService().getConnection(serverId).quitServer();\n                server.clearConversations();\n                setResult(RESULT_OK);\n                finish();\n                break;\n\n            case R.id.close:\n                Conversation conversationToClose = deckAdapter.getItem(deck.getSelectedItemPosition());\n                // Make sure we part a channel when closing the channel conversation\n                if (conversationToClose.getType() == Conversation.TYPE_CHANNEL) {\n                    binder.getService().getConnection(serverId).partChannel(conversationToClose.getName());\n                }\n                else if (conversationToClose.getType() == Conversation.TYPE_QUERY) {\n                    server.removeConversation(conversationToClose.getName());\n                    onRemoveConversation(conversationToClose.getName());\n                } else {\n                    Toast.makeText(this, getResources().getString(R.string.close_server_window), Toast.LENGTH_SHORT).show();\n                }\n                break;\n\n            case R.id.join:\n                startActivityForResult(new Intent(this, JoinActivity.class), REQUEST_CODE_JOIN);\n                break;\n\n            case R.id.users:\n                Conversation conversationForUserList = deckAdapter.getItem(deck.getSelectedItemPosition());\n                if (conversationForUserList.getType() == Conversation.TYPE_CHANNEL) {\n                    Intent intent = new Intent(this, UsersActivity.class);\n                    intent.putExtra(\n                        Extra.USERS,\n                        binder.getService().getConnection(server.getId()).getUsersAsStringArray(\n                            conversationForUserList.getName()\n                        )\n                    );\n                    startActivityForResult(intent, REQUEST_CODE_USERS);\n                } else {\n                    Toast.makeText(this, getResources().getString(R.string.only_usable_from_channel), Toast.LENGTH_SHORT).show();\n                }\n                break;\n        }\n\n        return true;\n    }\n\n    /**\n     * Get server object assigned to this activity\n     * \n     * @return the server object\n     */\n    public Server getServer()\n    {\n        return server;\n    }\n\n    /**\n     * On conversation message\n     */\n    @Override\n    public void onConversationMessage(String target)\n    {\n        Conversation conversation = server.getConversation(target);\n\n        if (conversation == null) {\n            // In an early state it can happen that the conversation object\n            // is not created yet.\n            return;\n        }\n\n        MessageListAdapter adapter = deckAdapter.getItemAdapter(target);\n\n        while(conversation.hasBufferedMessages()) {\n            Message message = conversation.pollBufferedMessage();\n\n            if (adapter != null && message != null) {\n                adapter.addMessage(message);\n                int status;\n\n                switch (message.getType())\n                {\n                    case Message.TYPE_MISC:\n                        status = Conversation.STATUS_MISC;\n                        break;\n\n                    default:\n                        status = Conversation.STATUS_MESSAGE;\n                        break;\n                }\n                conversation.setStatus(status);\n            }\n        }\n\n        if (dots != null) {\n            dots.invalidate();\n        }\n    }\n\n    /**\n     * On new conversation\n     */\n    @Override\n    public void onNewConversation(String target)\n    {\n        createNewConversation(target);\n\n        if (!deckAdapter.isSwitched()) {\n            // Scroll to new conversation\n            deck.setSelection(deckAdapter.getCount() - 1);\n        }\n    }\n    public void createNewConversation(String target)\n    {\n        deckAdapter.addItem(server.getConversation(target));\n    }\n\n    /**\n     * On conversation remove\n     */\n    @Override\n    public void onRemoveConversation(String target)\n    {\n        deckAdapter.removeItem(target);\n\n        if (deckAdapter.isSwitched()) {\n            switcher.showNext();\n            switcher.removeView(deckAdapter.getSwitchedView());\n            deckAdapter.setSwitched(null, null);\n        }\n    }\n\n    /**\n     * On topic change\n     */\n    public void onTopicChanged(String target)\n    {\n        String selected = server.getSelectedConversation();\n        if (selected.equals(target)) {\n            // onTopicChanged is only called for channels\n            Channel channel = (Channel) server.getConversation(selected);\n            StringBuilder sb = new StringBuilder();\n            sb.append(server.getTitle() + \" - \" + channel.getName());\n            if (!(channel.getTopic()).equals(\"\"))\n                sb.append(\" - \" + channel.getTopic());\n            ((TextView) findViewById(R.id.title)).setText(sb.toString());\n        }\n    }\n\n    /**\n     * On server status update\n     */\n    @Override\n    public void onStatusUpdate()\n    {\n        ((ImageView) findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\n        EditText input = (EditText) findViewById(R.id.input);\n\n        if (server.isConnected()) {\n            input.setEnabled(true);\n        } else {\n            input.setEnabled(false);\n\n            if (server.getStatus() == Status.CONNECTING) {\n                deckAdapter.clearConversations();\n                deckAdapter.addItem(server.getConversation(ServerInfo.DEFAULT_NAME));\n                return;\n            }\n\n            // Service is not connected or initialized yet - See #54\n            if (binder == null || binder.getService() == null || binder.getService().getSettings() == null) {\n                return;\n            }\n\n            if (!binder.getService().getSettings().isReconnectEnabled()) {\n                AlertDialog.Builder builder = new AlertDialog.Builder(this);\n                builder.setMessage(getResources().getString(R.string.reconnect_after_disconnect, server.getTitle()))\n                .setCancelable(false)\n                .setPositiveButton(\"Yes\", new DialogInterface.OnClickListener() {\n                    @Override\n                    public void onClick(DialogInterface dialog, int id) {\n                        binder.getService().getConnection(server.getId()).setAutojoinChannels(\n                            server.getCurrentChannelNames()\n                        );\n                        server.clearConversations();\n                        deckAdapter.clearConversations();\n                        deckAdapter.addItem(server.getConversation(ServerInfo.DEFAULT_NAME));\n                        binder.connect(server);\n                    }\n                })\n                .setNegativeButton(getString(R.string.negative_button), new DialogInterface.OnClickListener() {\n                    @Override\n                    public void onClick(DialogInterface dialog, int id) {\n                        dialog.cancel();\n                    }\n                });\n                AlertDialog alert = builder.create();\n                alert.show();\n            }\n        }\n    }\n\n    /**\n     * On key down\n     *\n     * XXX: As we only track the back key: Android >= 2.0 will call a method called onBackPressed()\n     */\n    @Override\n    public boolean onKeyDown(int keyCode, KeyEvent event)\n    {\n        if (keyCode == KeyEvent.KEYCODE_BACK && event.getRepeatCount() == 0) {\n            if (deckAdapter.isSwitched()) {\n                MessageListView canvas = (MessageListView) deckAdapter.getView(deckAdapter.getPositionByName(deckAdapter.getSwitchedName()), null, switcher);\n                canvas.setSwitched(false);\n                deckAdapter.setSwitched(null, null);\n                return true;\n            }\n        }\n        return super.onKeyDown(keyCode, event);\n    }\n\n    /**\n     * On key pressed (input line)\n     */\n    @Override\n    public boolean onKey(View view, int keyCode, KeyEvent event)\n    {\n        EditText input = (EditText) view;\n\n        if (keyCode == KeyEvent.KEYCODE_DPAD_UP && event.getAction() == KeyEvent.ACTION_DOWN) {\n            String message = scrollback.goBack();\n            if (message != null) {\n                input.setText(message);\n            }\n            return true;\n        }\n\n        if (keyCode == KeyEvent.KEYCODE_DPAD_DOWN && event.getAction() == KeyEvent.ACTION_DOWN) {\n            String message = scrollback.goForward();\n            if (message != null) {\n                input.setText(message);\n            }\n            return true;\n        }\n\n        // Nick completion\n        if (keyCode == KeyEvent.KEYCODE_SEARCH && event.getAction() == KeyEvent.ACTION_DOWN) {\n            String text = input.getText().toString();\n\n            if (text.length() <= 0) {\n                return true;\n            }\n\n            String[] tokens = text.split(\"[\\\\s,.-]+\");\n\n            if (tokens.length <= 0) {\n                return true;\n            }\n\n            String word = tokens[tokens.length - 1].toLowerCase();\n            tokens[tokens.length - 1] = null;\n\n            int begin   = input.getSelectionStart();\n            int end     = input.getSelectionEnd();\n            int cursor  = Math.min(begin, end);\n            int sel_end = Math.max(begin, end);\n\n            boolean in_selection = cursor != sel_end;\n\n            if (in_selection) {\n                word = text.substring(cursor, sel_end);\n            } else {\n                // use the word at the curent cursor position\n                while(true) {\n                    cursor -= 1;\n                    if (cursor <= 0 || text.charAt(cursor) == ' ') {\n                        break;\n                    }\n                }\n\n                if (cursor < 0) {\n                    cursor = 0;\n                }\n\n                if (text.charAt(cursor) == ' ') {\n                    cursor += 1;\n                }\n\n                sel_end = text.indexOf(' ', cursor);\n\n                if (sel_end == -1) {\n                    sel_end = text.length();\n                }\n\n                word = text.substring(cursor, sel_end);\n            }\n            // Log.d(\"Yaaic\", \"Trying to complete nick: \" + word);\n\n            Conversation conversationForUserList = deckAdapter.getItem(deck.getSelectedItemPosition());\n\n            String[] users = null;\n\n            if (conversationForUserList.getType() == Conversation.TYPE_CHANNEL) {\n                users = binder.getService().getConnection(server.getId()).getUsersAsStringArray(\n                    conversationForUserList.getName()\n                );\n            }\n\n            // go through users and add matches\n            if (users != null) {\n                List<Integer> result = new ArrayList<Integer>();\n\n                for (int i = 0; i < users.length; i++) {\n                    if (users[i].toLowerCase().startsWith(word)) {\n                        result.add(Integer.valueOf(i));\n                    }\n                }\n\n                if (result.size() == 1) {\n                    String text1 = users[result.get(0).intValue()];\n\n                    if (cursor == 0) {\n                        text1 += \":\";\n                    }\n\n                    text1 += \" \";\n                    input.getText().replace(cursor, sel_end, text1, 0, text1.length());\n                    int old = input.getInputType();\n                    input.setInputType(old | setInputTypeFlag);\n                } else if (result.size() > 0) {\n                    Intent intent  = new Intent(this, UsersActivity.class);\n                    String[] extra = new String[result.size()];\n                    int i = 0;\n\n                    for (Integer n : result) {\n                        extra[i++] = users[n.intValue()];\n                    }\n\n                    input.setSelection(cursor, sel_end);\n                    intent.putExtra(Extra.USERS, extra);\n                    startActivityForResult(intent, REQUEST_CODE_NICK_COMPLETION);\n                }\n            }\n            return true;\n        }\n\n        if (keyCode == KeyEvent.KEYCODE_ENTER && event.getAction() == KeyEvent.ACTION_DOWN) {\n            if (!server.isConnected()) {\n                Message message = new Message(getString(R.string.message_not_connected));\n                message.setColor(Message.COLOR_RED);\n                message.setIcon(R.drawable.error);\n                server.getConversation(server.getSelectedConversation()).addMessage(message);\n                onConversationMessage(server.getSelectedConversation());\n            }\n\n            String text = input.getText().toString();\n            input.setText(\"\");\n\n            if (text.equals(\"\")) {\n                // ignore empty messages\n                return true;\n            }\n\n            scrollback.addMessage(text);\n\n            Conversation conversation = deckAdapter.getItem(deck.getSelectedItemPosition());\n\n            if (conversation != null) {\n                if (!text.trim().startsWith(\"/\")) {\n                    if (conversation.getType() != Conversation.TYPE_SERVER) {\n                        String nickname = binder.getService().getConnection(serverId).getNick();\n                        //conversation.addMessage(new Message(\"<\" + nickname + \"> \" + text));\n                        conversation.addMessage(new Message(text, nickname));\n                        binder.getService().getConnection(serverId).sendMessage(conversation.getName(), text);\n                    } else {\n                        Message message = new Message(getString(R.string.chat_only_form_channel));\n                        message.setColor(Message.COLOR_YELLOW);\n                        message.setIcon(R.drawable.warning);\n                        conversation.addMessage(message);\n                    }\n                    onConversationMessage(conversation.getName());\n                } else {\n                    CommandParser.getInstance().parse(text, server, conversation, binder.getService());\n                }\n            }\n\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * On activity result\n     */\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent data)\n    {\n        if (resultCode != RESULT_OK) {\n            // ignore other result codes\n            return;\n        }\n\n        switch (requestCode) {\n            case REQUEST_CODE_SPEECH:\n                ArrayList<String> matches = data.getStringArrayListExtra(RecognizerIntent.EXTRA_RESULTS);\n                if (matches.size() > 0) {\n                    ((EditText) findViewById(R.id.input)).setText(matches.get(0));\n                }\n                break;\n            case REQUEST_CODE_JOIN:\n                joinChannelBuffer = data.getExtras().getString(\"channel\");\n                break;\n            case REQUEST_CODE_USERS:\n                Intent intent = new Intent(this, UserActivity.class);\n                intent.putExtra(Extra.USER, data.getStringExtra(Extra.USER));\n                startActivityForResult(intent, REQUEST_CODE_USER);\n                break;\n            case REQUEST_CODE_NICK_COMPLETION:\n                EditText input = (EditText) findViewById(R.id.input);\n                String src        = data.getExtras().getString(Extra.USER);\n                int start        = input.getSelectionStart();\n                int end        = input.getSelectionEnd();\n\n                if (start == 0) {\n                    src += \":\";\n                }\n\n                src += \" \";\n                input.getText().replace(start, end, src, 0, src.length());\n                // put cursor after inserted text\n                input.setSelection(start + src.length());\n                input.post(new Runnable() {\n                    @Override\n                    public void run() {\n                        // make the softkeyboard come up again (only if no hw keyboard is attached)\n                        EditText input = (EditText) findViewById(R.id.input);\n                        InputMethodManager mgr = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);\n                        mgr.showSoftInput(input, InputMethodManager.SHOW_IMPLICIT);\n                    }\n                });\n                input.requestFocus();\n                break;\n            case REQUEST_CODE_USER:\n                final int actionId = data.getExtras().getInt(Extra.ACTION);\n                final String nickname = data.getExtras().getString(Extra.USER);\n                final IRCConnection connection = binder.getService().getConnection(server.getId());\n                final String conversation = server.getSelectedConversation();\n                final Handler handler = new Handler();\n\n                // XXX: Implement me - The action should be handled after onResume()\n                //                     to catch the broadcasts... now we just wait a second\n                // Yes .. that's very ugly - we need some kind of queue that is handled after onResume()\n\n                new Thread() {\n                    @Override\n                    public void run() {\n                        try {\n                            Thread.sleep(1000);\n                        } catch (InterruptedException e) {\n                            // Do nothing\n                        }\n\n                        String nicknameWithoutPrefix = nickname;\n\n                        while (\n                            nicknameWithoutPrefix.startsWith(\"@\") ||\n                            nicknameWithoutPrefix.startsWith(\"+\") ||\n                            nicknameWithoutPrefix.startsWith(\".\") ||\n                            nicknameWithoutPrefix.startsWith(\"%\")\n                        ) {\n                            // Strip prefix(es) now\n                            nicknameWithoutPrefix = nicknameWithoutPrefix.substring(1);\n                        }\n\n                        switch (actionId) {\n                            case User.ACTION_REPLY:\n                                final String replyText = nicknameWithoutPrefix + \": \";\n                                handler.post(new Runnable() {\n                                    @Override\n                                    public void run() {\n                                        EditText input = (EditText) findViewById(R.id.input);\n                                        input.setText(replyText);\n                                        input.setSelection(replyText.length());\n                                    }\n                                });\n                                break;\n                            case User.ACTION_QUERY:\n                                Conversation query = server.getConversation(nicknameWithoutPrefix);\n                                if (query == null) {\n                                    // Open a query if there's none yet\n                                    query = new Query(nicknameWithoutPrefix);\n                                    server.addConversation(query);\n\n                                    Intent intent = Broadcast.createConversationIntent(\n                                        Broadcast.CONVERSATION_NEW,\n                                        server.getId(),\n                                        nicknameWithoutPrefix\n                                    );\n                                    binder.getService().sendBroadcast(intent);\n                                }\n                                break;\n                            case User.ACTION_OP:\n                                connection.op(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_DEOP:\n                                connection.deOp(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_VOICE:\n                                connection.voice(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_DEVOICE:\n                                connection.deVoice(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_KICK:\n                                connection.kick(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_BAN:\n                                connection.ban(conversation, nicknameWithoutPrefix + \"!*@*\");\n                                break;\n                        }\n                    }\n                }.start();\n\n                break;\n        }\n    }\n}\n","Method after Refactoring":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2011 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage org.yaaic.activity;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.adapter.DeckAdapter;\nimport org.yaaic.adapter.MessageListAdapter;\nimport org.yaaic.command.CommandParser;\nimport org.yaaic.irc.IRCBinder;\nimport org.yaaic.irc.IRCConnection;\nimport org.yaaic.irc.IRCService;\nimport org.yaaic.layout.NonScalingBackgroundDrawable;\nimport org.yaaic.listener.ConversationClickListener;\nimport org.yaaic.listener.ConversationListener;\nimport org.yaaic.listener.ConversationSelectedListener;\nimport org.yaaic.listener.ServerListener;\nimport org.yaaic.listener.SpeechClickListener;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.model.Extra;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Query;\nimport org.yaaic.model.Scrollback;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.ServerInfo;\nimport org.yaaic.model.Settings;\nimport org.yaaic.model.Status;\nimport org.yaaic.model.User;\nimport org.yaaic.receiver.ConversationReceiver;\nimport org.yaaic.receiver.ServerReceiver;\nimport org.yaaic.view.ConversationSwitcher;\nimport org.yaaic.view.MessageListView;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.content.pm.PackageManager;\nimport android.content.pm.ResolveInfo;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.speech.RecognizerIntent;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.View.OnKeyListener;\nimport android.view.Window;\nimport android.view.inputmethod.InputMethodManager;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.Gallery;\nimport android.widget.ImageView;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport android.widget.ViewSwitcher;\n\n/**\n * The server view with a scrollable list of all channels\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class ConversationActivity extends Activity implements ServiceConnection, ServerListener, ConversationListener, OnKeyListener\n{\n    public static final int REQUEST_CODE_SPEECH = 99;\n\n    private static final int REQUEST_CODE_JOIN = 1;\n    private static final int REQUEST_CODE_USERS = 2;\n    private static final int REQUEST_CODE_USER = 3;\n    private static final int REQUEST_CODE_NICK_COMPLETION= 4;\n\n    private int serverId;\n    private Server server;\n    private IRCBinder binder;\n    private ConversationReceiver channelReceiver;\n    private ServerReceiver serverReceiver;\n\n    private ViewSwitcher switcher;\n    private Gallery deck;\n    private DeckAdapter deckAdapter;\n    private Scrollback scrollback;\n    private ConversationSwitcher dots;\n\n    // XXX: This is ugly. This is a buffer for a channel that should be joined after showing the\n    //      JoinActivity. As onActivityResult() is called before onResume() a \"channel joined\"\n    //      broadcast may get lost as the broadcast receivers are registered in onResume() but the\n    //      join command would be called in onActivityResult(). joinChannelBuffer will save the\n    //      channel name in onActivityResult() and run the join command in onResume().\n    private String joinChannelBuffer;\n\n    // flag passed to setInputType later\n    // shall be TYPE_TEXT_FLAG_NO_SUGGESTIONS but it's not supported in all API levels (only in 5+)\n    // We'll set it to 0 if it's not supported\n    private int setInputTypeFlag;\n\n    private int historySize;\n\n    /**\n     * On create\n     */\n    @Override\n    protected void onCreate(Bundle savedInstanceState)\n    {\n        super.onCreate(savedInstanceState);\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n\n        serverId = getIntent().getExtras().getInt(\"serverId\");\n        server = Yaaic.getInstance().getServerById(serverId);\n\n        // Finish activity if server does not exist anymore - See #55\n        if (server == null) {\n            this.finish();\n        }\n\n        setTitle(\"Yaaic - \" + server.getTitle());\n\n        setContentView(R.layout.conversations);\n\n        ((TextView) findViewById(R.id.title)).setText(server.getTitle());\n        ((EditText) findViewById(R.id.input)).setOnKeyListener(this);\n\n        switcher = (ViewSwitcher) findViewById(R.id.switcher);\n\n        dots = (ConversationSwitcher) findViewById(R.id.dots);\n        dots.setServer(server);\n\n        deckAdapter = new DeckAdapter();\n        deck = (Gallery) findViewById(R.id.deck);\n        deck.setOnItemSelectedListener(new ConversationSelectedListener(this, server, (TextView) findViewById(R.id.title), dots));\n        deck.setAdapter(deckAdapter);\n        deck.setOnItemClickListener(new ConversationClickListener(deckAdapter, switcher));\n        deck.setBackgroundDrawable(new NonScalingBackgroundDrawable(this, deck, R.drawable.background));\n\n        Settings settings = new Settings(this);\n        historySize = settings.getHistorySize();\n\n        if (server.getStatus() == Status.PRE_CONNECTING) {\n            server.clearConversations();\n            deckAdapter.clearConversations();\n            server.getConversation(ServerInfo.DEFAULT_NAME).setHistorySize(historySize);\n        }\n\n        // Optimization : cache field lookups\n        Collection<Conversation> mConversations = server.getConversations();\n\n        for (Conversation conversation : mConversations) {\n            // Only scroll to new conversation if it was selected before\n            if (conversation.getStatus() == Conversation.STATUS_SELECTED) {\n                onNewConversation(conversation.getName());\n            } else {\n                createNewConversation(conversation.getName());\n            }\n        }\n\n        // keep compatibility with api level 3\n        if ((android.os.Build.VERSION.SDK.charAt(0) - '0') >= 5) {\n            setInputTypeFlag = 0x80000; // InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS\n        }\n        else {\n            setInputTypeFlag = 0;\n        }\n\n        // Create a new scrollback history\n        scrollback = new Scrollback();\n    }\n\n    /**\n     * On resume\n     */\n    @Override\n    public void onResume()\n    {\n        // register the receivers as early as possible, otherwise we may loose a broadcast message\n        channelReceiver = new ConversationReceiver(server.getId(), this);\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_MESSAGE));\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_NEW));\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_REMOVE));\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_TOPIC));\n\n        serverReceiver = new ServerReceiver(this);\n        registerReceiver(serverReceiver, new IntentFilter(Broadcast.SERVER_UPDATE));\n\n        super.onResume();\n\n        // Check if speech recognition is enabled and available\n        if (new Settings(this).isVoiceRecognitionEnabled()) {\n            PackageManager pm = getPackageManager();\n            Button speechButton = (Button) findViewById(R.id.speech);\n            List<ResolveInfo> activities = pm.queryIntentActivities(new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH), 0);\n\n            if (activities.size() != 0) {\n                ((Button) findViewById(R.id.speech)).setOnClickListener(new SpeechClickListener(this));\n                speechButton.setVisibility(View.VISIBLE);\n            }\n        }\n\n        ((ImageView) findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\n        // Start service\n        Intent intent = new Intent(this, IRCService.class);\n        intent.setAction(IRCService.ACTION_FOREGROUND);\n        startService(intent);\n        bindService(intent, this, 0);\n\n        if (!server.isConnected()) {\n            ((EditText) findViewById(R.id.input)).setEnabled(false);\n        } else {\n            ((EditText) findViewById(R.id.input)).setEnabled(true);\n        }\n\n        // Optimization - cache field lookup\n        Collection<Conversation> mConversations = server.getConversations();\n        MessageListAdapter mAdapter;\n\n        // Fill view with messages that have been buffered while paused\n        for (Conversation conversation : mConversations) {\n            mAdapter = deckAdapter.getItemAdapter(conversation.getName());\n\n            if (mAdapter != null) {\n                mAdapter.addBulkMessages(conversation.getBuffer());\n                conversation.clearBuffer();\n            }\n\n            // Clear new message notifications for the selected conversation\n            if (conversation.getStatus() == Conversation.STATUS_SELECTED && conversation.getNewMentions() > 0) {\n                Intent ackIntent = new Intent(this, IRCService.class);\n                ackIntent.setAction(IRCService.ACTION_ACK_NEW_MENTIONS);\n                ackIntent.putExtra(IRCService.EXTRA_ACK_CONVTITLE, conversation.getName());\n                startService(ackIntent);\n            }\n        }\n\n        // Join channel that has been selected in JoinActivity (onActivityResult())\n        if (joinChannelBuffer != null) {\n            new Thread() {\n                @Override\n                public void run() {\n                    binder.getService().getConnection(serverId).joinChannel(joinChannelBuffer);\n                    joinChannelBuffer = null;\n                }\n            }.start();\n        }\n\n        server.setIsForeground(true);\n    }\n\n    /**\n     * On Pause\n     */\n    @Override\n    public void onPause()\n    {\n        super.onPause();\n\n        server.setIsForeground(false);\n\n        if (binder != null && binder.getService() != null) {\n            binder.getService().checkServiceStatus();\n        }\n\n        unbindService(this);\n        unregisterReceiver(channelReceiver);\n        unregisterReceiver(serverReceiver);\n    }\n\n    /**\n     * On save instance state (e.g. before a configuration change)\n     */\n    @Override\n    protected void onSaveInstanceState(Bundle outState)\n    {\n        super.onSaveInstanceState(outState);\n\n        if (deckAdapter.isSwitched()) {\n            outState.putBoolean(\"isSwitched\", deckAdapter.isSwitched());\n            outState.putString(\"switchedName\", deckAdapter.getSwitchedName());\n        }\n    }\n\n    /**\n     * On restore instance state (e.g. after a configuration change)\n     */\n    @Override\n    protected void onRestoreInstanceState(Bundle inState)\n    {\n        super.onRestoreInstanceState(inState);\n\n        if (inState.getBoolean(\"isSwitched\")) {\n            deckAdapter.setSwitched(inState.getString(\"switchedName\"), null);\n        }\n    }\n\n    /**\n     * On service connected\n     */\n    @Override\n    public void onServiceConnected(ComponentName name, IBinder service)\n    {\n        this.binder = (IRCBinder) service;\n\n        // connect to irc server if connect has been requested\n        if (server.getStatus() == Status.PRE_CONNECTING && getIntent().hasExtra(\"connect\")) {\n            server.setStatus(Status.CONNECTING);\n            binder.connect(server);\n        }\n    }\n\n    /**\n     * On service disconnected\n     */\n    @Override\n    public void onServiceDisconnected(ComponentName name)\n    {\n        this.binder = null;\n    }\n\n    /**\n     * On options menu requested\n     */\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu)\n    {\n        super.onCreateOptionsMenu(menu);\n\n        // inflate from xml\n        MenuInflater inflater = getMenuInflater();\n        inflater.inflate(R.menu.conversations, menu);\n\n        return true;\n    }\n\n    /**\n     * On prepare options menu\n     */\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu)\n    {\n        menu.getItem(0).setEnabled(server.isConnected()); // join\n        menu.getItem(1).setEnabled(server.isConnected()); // users\n        menu.getItem(2).setEnabled(server.isConnected()); // close\n\n        return true;\n    }\n\n    /**\n     * On menu item selected\n     */\n    @Override\n    public boolean onMenuItemSelected(int featureId, MenuItem item)\n    {\n        switch (item.getItemId()) {\n            case R.id.disconnect:\n                server.setStatus(Status.DISCONNECTED);\n                binder.getService().getConnection(serverId).quitServer();\n                server.clearConversations();\n                setResult(RESULT_OK);\n                finish();\n                break;\n\n            case R.id.close:\n                Conversation conversationToClose = deckAdapter.getItem(deck.getSelectedItemPosition());\n                // Make sure we part a channel when closing the channel conversation\n                if (conversationToClose.getType() == Conversation.TYPE_CHANNEL) {\n                    binder.getService().getConnection(serverId).partChannel(conversationToClose.getName());\n                }\n                else if (conversationToClose.getType() == Conversation.TYPE_QUERY) {\n                    server.removeConversation(conversationToClose.getName());\n                    onRemoveConversation(conversationToClose.getName());\n                } else {\n                    Toast.makeText(this, getResources().getString(R.string.close_server_window), Toast.LENGTH_SHORT).show();\n                }\n                break;\n\n            case R.id.join:\n                startActivityForResult(new Intent(this, JoinActivity.class), REQUEST_CODE_JOIN);\n                break;\n\n            case R.id.users:\n                Conversation conversationForUserList = deckAdapter.getItem(deck.getSelectedItemPosition());\n                if (conversationForUserList.getType() == Conversation.TYPE_CHANNEL) {\n                    Intent intent = new Intent(this, UsersActivity.class);\n                    intent.putExtra(\n                        Extra.USERS,\n                        binder.getService().getConnection(server.getId()).getUsersAsStringArray(\n                            conversationForUserList.getName()\n                        )\n                    );\n                    startActivityForResult(intent, REQUEST_CODE_USERS);\n                } else {\n                    Toast.makeText(this, getResources().getString(R.string.only_usable_from_channel), Toast.LENGTH_SHORT).show();\n                }\n                break;\n        }\n\n        return true;\n    }\n\n    /**\n     * Get server object assigned to this activity\n     * \n     * @return the server object\n     */\n    public Server getServer()\n    {\n        return server;\n    }\n\n    /**\n     * On conversation message\n     */\n    @Override\n    public void onConversationMessage(String target)\n    {\n        Conversation conversation = server.getConversation(target);\n\n        if (conversation == null) {\n            // In an early state it can happen that the conversation object\n            // is not created yet.\n            return;\n        }\n\n        MessageListAdapter adapter = deckAdapter.getItemAdapter(target);\n\n        while(conversation.hasBufferedMessages()) {\n            Message message = conversation.pollBufferedMessage();\n\n            if (adapter != null && message != null) {\n                adapter.addMessage(message);\n                int status;\n\n                switch (message.getType())\n                {\n                    case Message.TYPE_MISC:\n                        status = Conversation.STATUS_MISC;\n                        break;\n\n                    default:\n                        status = Conversation.STATUS_MESSAGE;\n                        break;\n                }\n                conversation.setStatus(status);\n            }\n        }\n\n        if (dots != null) {\n            dots.invalidate();\n        }\n    }\n\n    /**\n     * On new conversation\n     */\n    @Override\n    public void onNewConversation(String target)\n    {\n        createNewConversation(target);\n\n        if (!deckAdapter.isSwitched()) {\n            // Scroll to new conversation\n            deck.setSelection(deckAdapter.getCount() - 1);\n        }\n    }\n    public void createNewConversation(String target)\n    {\n        deckAdapter.addItem(server.getConversation(target));\n    }\n\n    /**\n     * On conversation remove\n     */\n    @Override\n    public void onRemoveConversation(String target)\n    {\n        deckAdapter.removeItem(target);\n\n        if (deckAdapter.isSwitched()) {\n            switcher.showNext();\n            switcher.removeView(deckAdapter.getSwitchedView());\n            deckAdapter.setSwitched(null, null);\n        }\n    }\n\n    /**\n     * On topic change\n     */\n    public void onTopicChanged(String target)\n    {\n        String selected = server.getSelectedConversation();\n        if (selected.equals(target)) {\n            // onTopicChanged is only called for channels\n            Channel channel = (Channel) server.getConversation(selected);\n            StringBuilder sb = new StringBuilder();\n            sb.append(server.getTitle() + \" - \" + channel.getName());\n            if (!(channel.getTopic()).equals(\"\"))\n                sb.append(\" - \" + channel.getTopic());\n            ((TextView) findViewById(R.id.title)).setText(sb.toString());\n        }\n    }\n\n    /**\n     * On server status update\n     */\n    @Override\n    public void onStatusUpdate()\n    {\n        ((ImageView) findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\n        EditText input = (EditText) findViewById(R.id.input);\n\n        if (server.isConnected()) {\n            input.setEnabled(true);\n        } else {\n            input.setEnabled(false);\n\n            if (server.getStatus() == Status.CONNECTING) {\n                deckAdapter.clearConversations();\n                Conversation serverInfo = server.getConversation(ServerInfo.DEFAULT_NAME);\n                serverInfo.setHistorySize(historySize);\n                deckAdapter.addItem(serverInfo);\n                return;\n            }\n\n            // Service is not connected or initialized yet - See #54\n            if (binder == null || binder.getService() == null || binder.getService().getSettings() == null) {\n                return;\n            }\n\n            if (!binder.getService().getSettings().isReconnectEnabled()) {\n                AlertDialog.Builder builder = new AlertDialog.Builder(this);\n                builder.setMessage(getResources().getString(R.string.reconnect_after_disconnect, server.getTitle()))\n                .setCancelable(false)\n                .setPositiveButton(\"Yes\", new DialogInterface.OnClickListener() {\n                    @Override\n                    public void onClick(DialogInterface dialog, int id) {\n                        binder.getService().getConnection(server.getId()).setAutojoinChannels(\n                            server.getCurrentChannelNames()\n                        );\n                        server.clearConversations();\n                        deckAdapter.clearConversations();\n                        Conversation serverInfo = server.getConversation(ServerInfo.DEFAULT_NAME);\n                        serverInfo.setHistorySize(historySize);\n                        deckAdapter.addItem(serverInfo);\n                        binder.connect(server);\n                    }\n                })\n                .setNegativeButton(getString(R.string.negative_button), new DialogInterface.OnClickListener() {\n                    @Override\n                    public void onClick(DialogInterface dialog, int id) {\n                        dialog.cancel();\n                    }\n                });\n                AlertDialog alert = builder.create();\n                alert.show();\n            }\n        }\n    }\n\n    /**\n     * On key down\n     *\n     * XXX: As we only track the back key: Android >= 2.0 will call a method called onBackPressed()\n     */\n    @Override\n    public boolean onKeyDown(int keyCode, KeyEvent event)\n    {\n        if (keyCode == KeyEvent.KEYCODE_BACK && event.getRepeatCount() == 0) {\n            if (deckAdapter.isSwitched()) {\n                MessageListView canvas = (MessageListView) deckAdapter.getView(deckAdapter.getPositionByName(deckAdapter.getSwitchedName()), null, switcher);\n                canvas.setSwitched(false);\n                deckAdapter.setSwitched(null, null);\n                return true;\n            }\n        }\n        return super.onKeyDown(keyCode, event);\n    }\n\n    /**\n     * On key pressed (input line)\n     */\n    @Override\n    public boolean onKey(View view, int keyCode, KeyEvent event)\n    {\n        EditText input = (EditText) view;\n\n        if (keyCode == KeyEvent.KEYCODE_DPAD_UP && event.getAction() == KeyEvent.ACTION_DOWN) {\n            String message = scrollback.goBack();\n            if (message != null) {\n                input.setText(message);\n            }\n            return true;\n        }\n\n        if (keyCode == KeyEvent.KEYCODE_DPAD_DOWN && event.getAction() == KeyEvent.ACTION_DOWN) {\n            String message = scrollback.goForward();\n            if (message != null) {\n                input.setText(message);\n            }\n            return true;\n        }\n\n        // Nick completion\n        if (keyCode == KeyEvent.KEYCODE_SEARCH && event.getAction() == KeyEvent.ACTION_DOWN) {\n            String text = input.getText().toString();\n\n            if (text.length() <= 0) {\n                return true;\n            }\n\n            String[] tokens = text.split(\"[\\\\s,.-]+\");\n\n            if (tokens.length <= 0) {\n                return true;\n            }\n\n            String word = tokens[tokens.length - 1].toLowerCase();\n            tokens[tokens.length - 1] = null;\n\n            int begin   = input.getSelectionStart();\n            int end     = input.getSelectionEnd();\n            int cursor  = Math.min(begin, end);\n            int sel_end = Math.max(begin, end);\n\n            boolean in_selection = cursor != sel_end;\n\n            if (in_selection) {\n                word = text.substring(cursor, sel_end);\n            } else {\n                // use the word at the curent cursor position\n                while(true) {\n                    cursor -= 1;\n                    if (cursor <= 0 || text.charAt(cursor) == ' ') {\n                        break;\n                    }\n                }\n\n                if (cursor < 0) {\n                    cursor = 0;\n                }\n\n                if (text.charAt(cursor) == ' ') {\n                    cursor += 1;\n                }\n\n                sel_end = text.indexOf(' ', cursor);\n\n                if (sel_end == -1) {\n                    sel_end = text.length();\n                }\n\n                word = text.substring(cursor, sel_end);\n            }\n            // Log.d(\"Yaaic\", \"Trying to complete nick: \" + word);\n\n            Conversation conversationForUserList = deckAdapter.getItem(deck.getSelectedItemPosition());\n\n            String[] users = null;\n\n            if (conversationForUserList.getType() == Conversation.TYPE_CHANNEL) {\n                users = binder.getService().getConnection(server.getId()).getUsersAsStringArray(\n                    conversationForUserList.getName()\n                );\n            }\n\n            // go through users and add matches\n            if (users != null) {\n                List<Integer> result = new ArrayList<Integer>();\n\n                for (int i = 0; i < users.length; i++) {\n                    if (users[i].toLowerCase().startsWith(word)) {\n                        result.add(Integer.valueOf(i));\n                    }\n                }\n\n                if (result.size() == 1) {\n                    String text1 = users[result.get(0).intValue()];\n\n                    if (cursor == 0) {\n                        text1 += \":\";\n                    }\n\n                    text1 += \" \";\n                    input.getText().replace(cursor, sel_end, text1, 0, text1.length());\n                    int old = input.getInputType();\n                    input.setInputType(old | setInputTypeFlag);\n                } else if (result.size() > 0) {\n                    Intent intent  = new Intent(this, UsersActivity.class);\n                    String[] extra = new String[result.size()];\n                    int i = 0;\n\n                    for (Integer n : result) {\n                        extra[i++] = users[n.intValue()];\n                    }\n\n                    input.setSelection(cursor, sel_end);\n                    intent.putExtra(Extra.USERS, extra);\n                    startActivityForResult(intent, REQUEST_CODE_NICK_COMPLETION);\n                }\n            }\n            return true;\n        }\n\n        if (keyCode == KeyEvent.KEYCODE_ENTER && event.getAction() == KeyEvent.ACTION_DOWN) {\n            if (!server.isConnected()) {\n                Message message = new Message(getString(R.string.message_not_connected));\n                message.setColor(Message.COLOR_RED);\n                message.setIcon(R.drawable.error);\n                server.getConversation(server.getSelectedConversation()).addMessage(message);\n                onConversationMessage(server.getSelectedConversation());\n            }\n\n            String text = input.getText().toString();\n            input.setText(\"\");\n\n            if (text.equals(\"\")) {\n                // ignore empty messages\n                return true;\n            }\n\n            scrollback.addMessage(text);\n\n            Conversation conversation = deckAdapter.getItem(deck.getSelectedItemPosition());\n\n            if (conversation != null) {\n                if (!text.trim().startsWith(\"/\")) {\n                    if (conversation.getType() != Conversation.TYPE_SERVER) {\n                        String nickname = binder.getService().getConnection(serverId).getNick();\n                        //conversation.addMessage(new Message(\"<\" + nickname + \"> \" + text));\n                        conversation.addMessage(new Message(text, nickname));\n                        binder.getService().getConnection(serverId).sendMessage(conversation.getName(), text);\n                    } else {\n                        Message message = new Message(getString(R.string.chat_only_form_channel));\n                        message.setColor(Message.COLOR_YELLOW);\n                        message.setIcon(R.drawable.warning);\n                        conversation.addMessage(message);\n                    }\n                    onConversationMessage(conversation.getName());\n                } else {\n                    CommandParser.getInstance().parse(text, server, conversation, binder.getService());\n                }\n            }\n\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * On activity result\n     */\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent data)\n    {\n        if (resultCode != RESULT_OK) {\n            // ignore other result codes\n            return;\n        }\n\n        switch (requestCode) {\n            case REQUEST_CODE_SPEECH:\n                ArrayList<String> matches = data.getStringArrayListExtra(RecognizerIntent.EXTRA_RESULTS);\n                if (matches.size() > 0) {\n                    ((EditText) findViewById(R.id.input)).setText(matches.get(0));\n                }\n                break;\n            case REQUEST_CODE_JOIN:\n                joinChannelBuffer = data.getExtras().getString(\"channel\");\n                break;\n            case REQUEST_CODE_USERS:\n                Intent intent = new Intent(this, UserActivity.class);\n                intent.putExtra(Extra.USER, data.getStringExtra(Extra.USER));\n                startActivityForResult(intent, REQUEST_CODE_USER);\n                break;\n            case REQUEST_CODE_NICK_COMPLETION:\n                EditText input = (EditText) findViewById(R.id.input);\n                String src        = data.getExtras().getString(Extra.USER);\n                int start        = input.getSelectionStart();\n                int end        = input.getSelectionEnd();\n\n                if (start == 0) {\n                    src += \":\";\n                }\n\n                src += \" \";\n                input.getText().replace(start, end, src, 0, src.length());\n                // put cursor after inserted text\n                input.setSelection(start + src.length());\n                input.post(new Runnable() {\n                    @Override\n                    public void run() {\n                        // make the softkeyboard come up again (only if no hw keyboard is attached)\n                        EditText input = (EditText) findViewById(R.id.input);\n                        InputMethodManager mgr = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);\n                        mgr.showSoftInput(input, InputMethodManager.SHOW_IMPLICIT);\n                    }\n                });\n                input.requestFocus();\n                break;\n            case REQUEST_CODE_USER:\n                final int actionId = data.getExtras().getInt(Extra.ACTION);\n                final String nickname = data.getExtras().getString(Extra.USER);\n                final IRCConnection connection = binder.getService().getConnection(server.getId());\n                final String conversation = server.getSelectedConversation();\n                final Handler handler = new Handler();\n\n                // XXX: Implement me - The action should be handled after onResume()\n                //                     to catch the broadcasts... now we just wait a second\n                // Yes .. that's very ugly - we need some kind of queue that is handled after onResume()\n\n                new Thread() {\n                    @Override\n                    public void run() {\n                        try {\n                            Thread.sleep(1000);\n                        } catch (InterruptedException e) {\n                            // Do nothing\n                        }\n\n                        String nicknameWithoutPrefix = nickname;\n\n                        while (\n                            nicknameWithoutPrefix.startsWith(\"@\") ||\n                            nicknameWithoutPrefix.startsWith(\"+\") ||\n                            nicknameWithoutPrefix.startsWith(\".\") ||\n                            nicknameWithoutPrefix.startsWith(\"%\")\n                        ) {\n                            // Strip prefix(es) now\n                            nicknameWithoutPrefix = nicknameWithoutPrefix.substring(1);\n                        }\n\n                        switch (actionId) {\n                            case User.ACTION_REPLY:\n                                final String replyText = nicknameWithoutPrefix + \": \";\n                                handler.post(new Runnable() {\n                                    @Override\n                                    public void run() {\n                                        EditText input = (EditText) findViewById(R.id.input);\n                                        input.setText(replyText);\n                                        input.setSelection(replyText.length());\n                                    }\n                                });\n                                break;\n                            case User.ACTION_QUERY:\n                                Conversation query = server.getConversation(nicknameWithoutPrefix);\n                                if (query == null) {\n                                    // Open a query if there's none yet\n                                    query = new Query(nicknameWithoutPrefix);\n                                    query.setHistorySize(binder.getService().getSettings().getHistorySize());\n                                    server.addConversation(query);\n\n                                    Intent intent = Broadcast.createConversationIntent(\n                                        Broadcast.CONVERSATION_NEW,\n                                        server.getId(),\n                                        nicknameWithoutPrefix\n                                    );\n                                    binder.getService().sendBroadcast(intent);\n                                }\n                                break;\n                            case User.ACTION_OP:\n                                connection.op(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_DEOP:\n                                connection.deOp(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_VOICE:\n                                connection.voice(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_DEVOICE:\n                                connection.deVoice(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_KICK:\n                                connection.kick(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_BAN:\n                                connection.ban(conversation, nicknameWithoutPrefix + \"!*@*\");\n                                break;\n                        }\n                    }\n                }.start();\n\n                break;\n        }\n    }\n}\n","lineNo":570}
{"Smelly Sample":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2011 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage org.yaaic.activity;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.adapter.DeckAdapter;\nimport org.yaaic.adapter.MessageListAdapter;\nimport org.yaaic.command.CommandParser;\nimport org.yaaic.irc.IRCBinder;\nimport org.yaaic.irc.IRCConnection;\nimport org.yaaic.irc.IRCService;\nimport org.yaaic.layout.NonScalingBackgroundDrawable;\nimport org.yaaic.listener.ConversationClickListener;\nimport org.yaaic.listener.ConversationListener;\nimport org.yaaic.listener.ConversationSelectedListener;\nimport org.yaaic.listener.ServerListener;\nimport org.yaaic.listener.SpeechClickListener;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.model.Extra;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Query;\nimport org.yaaic.model.Scrollback;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.ServerInfo;\nimport org.yaaic.model.Settings;\nimport org.yaaic.model.Status;\nimport org.yaaic.model.User;\nimport org.yaaic.receiver.ConversationReceiver;\nimport org.yaaic.receiver.ServerReceiver;\nimport org.yaaic.view.ConversationSwitcher;\nimport org.yaaic.view.MessageListView;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.content.pm.PackageManager;\nimport android.content.pm.ResolveInfo;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.speech.RecognizerIntent;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.View.OnKeyListener;\nimport android.view.Window;\nimport android.view.inputmethod.InputMethodManager;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.Gallery;\nimport android.widget.ImageView;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport android.widget.ViewSwitcher;\n\n/**\n * The server view with a scrollable list of all channels\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class ConversationActivity extends Activity implements ServiceConnection, ServerListener, ConversationListener, OnKeyListener\n{\n    public static final int REQUEST_CODE_SPEECH = 99;\n\n    private static final int REQUEST_CODE_JOIN = 1;\n    private static final int REQUEST_CODE_USERS = 2;\n    private static final int REQUEST_CODE_USER = 3;\n    private static final int REQUEST_CODE_NICK_COMPLETION= 4;\n\n    private int serverId;\n    private Server server;\n    private IRCBinder binder;\n    private ConversationReceiver channelReceiver;\n    private ServerReceiver serverReceiver;\n\n    private ViewSwitcher switcher;\n    private Gallery deck;\n    private DeckAdapter deckAdapter;\n    private Scrollback scrollback;\n    private ConversationSwitcher dots;\n\n    // XXX: This is ugly. This is a buffer for a channel that should be joined after showing the\n    //      JoinActivity. As onActivityResult() is called before onResume() a \"channel joined\"\n    //      broadcast may get lost as the broadcast receivers are registered in onResume() but the\n    //      join command would be called in onActivityResult(). joinChannelBuffer will save the\n    //      channel name in onActivityResult() and run the join command in onResume().\n    private String joinChannelBuffer;\n\n    // flag passed to setInputType later\n    // shall be TYPE_TEXT_FLAG_NO_SUGGESTIONS but it's not supported in all API levels (only in 5+)\n    // We'll set it to 0 if it's not supported\n    private int setInputTypeFlag;\n\n    /**\n     * On create\n     */\n    @Override\n    protected void onCreate(Bundle savedInstanceState)\n    {\n        super.onCreate(savedInstanceState);\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n\n        serverId = getIntent().getExtras().getInt(\"serverId\");\n        server = Yaaic.getInstance().getServerById(serverId);\n\n        // Finish activity if server does not exist anymore - See #55\n        if (server == null) {\n            this.finish();\n        }\n\n        setTitle(\"Yaaic - \" + server.getTitle());\n\n        setContentView(R.layout.conversations);\n\n        ((TextView) findViewById(R.id.title)).setText(server.getTitle());\n        ((EditText) findViewById(R.id.input)).setOnKeyListener(this);\n\n        switcher = (ViewSwitcher) findViewById(R.id.switcher);\n\n        dots = (ConversationSwitcher) findViewById(R.id.dots);\n        dots.setServer(server);\n\n        deckAdapter = new DeckAdapter();\n        deck = (Gallery) findViewById(R.id.deck);\n        deck.setOnItemSelectedListener(new ConversationSelectedListener(this, server, (TextView) findViewById(R.id.title), dots));\n        deck.setAdapter(deckAdapter);\n        deck.setOnItemClickListener(new ConversationClickListener(deckAdapter, switcher));\n        deck.setBackgroundDrawable(new NonScalingBackgroundDrawable(this, deck, R.drawable.background));\n\n        if (server.getStatus() == Status.PRE_CONNECTING) {\n            server.clearConversations();\n            deckAdapter.clearConversations();\n        }\n\n        // Optimization : cache field lookups\n        Collection<Conversation> mConversations = server.getConversations();\n\n        for (Conversation conversation : mConversations) {\n            // Only scroll to new conversation if it was selected before\n            if (conversation.getStatus() == Conversation.STATUS_SELECTED) {\n                onNewConversation(conversation.getName());\n            } else {\n                createNewConversation(conversation.getName());\n            }\n        }\n\n        // keep compatibility with api level 3\n        if ((android.os.Build.VERSION.SDK.charAt(0) - '0') >= 5) {\n            setInputTypeFlag = 0x80000; // InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS\n        }\n        else {\n            setInputTypeFlag = 0;\n        }\n\n        // Create a new scrollback history\n        scrollback = new Scrollback();\n    }\n\n    /**\n     * On resume\n     */\n    @Override\n    public void onResume()\n    {\n        // register the receivers as early as possible, otherwise we may loose a broadcast message\n        channelReceiver = new ConversationReceiver(server.getId(), this);\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_MESSAGE));\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_NEW));\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_REMOVE));\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_TOPIC));\n\n        serverReceiver = new ServerReceiver(this);\n        registerReceiver(serverReceiver, new IntentFilter(Broadcast.SERVER_UPDATE));\n\n        super.onResume();\n\n        // Check if speech recognition is enabled and available\n        if (new Settings(this).isVoiceRecognitionEnabled()) {\n            PackageManager pm = getPackageManager();\n            Button speechButton = (Button) findViewById(R.id.speech);\n            List<ResolveInfo> activities = pm.queryIntentActivities(new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH), 0);\n\n            if (activities.size() != 0) {\n                ((Button) findViewById(R.id.speech)).setOnClickListener(new SpeechClickListener(this));\n                speechButton.setVisibility(View.VISIBLE);\n            }\n        }\n\n        ((ImageView) findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\n        // Start service\n        Intent intent = new Intent(this, IRCService.class);\n        intent.setAction(IRCService.ACTION_FOREGROUND);\n        startService(intent);\n        bindService(intent, this, 0);\n\n        if (!server.isConnected()) {\n            ((EditText) findViewById(R.id.input)).setEnabled(false);\n        } else {\n            ((EditText) findViewById(R.id.input)).setEnabled(true);\n        }\n\n        // Optimization - cache field lookup\n        Collection<Conversation> mConversations = server.getConversations();\n        MessageListAdapter mAdapter;\n\n        // Fill view with messages that have been buffered while paused\n        for (Conversation conversation : mConversations) {\n            mAdapter = deckAdapter.getItemAdapter(conversation.getName());\n\n            if (mAdapter != null) {\n                mAdapter.addBulkMessages(conversation.getBuffer());\n                conversation.clearBuffer();\n            }\n\n            // Clear new message notifications for the selected conversation\n            if (conversation.getStatus() == Conversation.STATUS_SELECTED && conversation.getNewMentions() > 0) {\n                Intent ackIntent = new Intent(this, IRCService.class);\n                ackIntent.setAction(IRCService.ACTION_ACK_NEW_MENTIONS);\n                ackIntent.putExtra(IRCService.EXTRA_ACK_CONVTITLE, conversation.getName());\n                startService(ackIntent);\n            }\n        }\n\n        // Join channel that has been selected in JoinActivity (onActivityResult())\n        if (joinChannelBuffer != null) {\n            new Thread() {\n                @Override\n                public void run() {\n                    binder.getService().getConnection(serverId).joinChannel(joinChannelBuffer);\n                    joinChannelBuffer = null;\n                }\n            }.start();\n        }\n\n        server.setIsForeground(true);\n    }\n\n    /**\n     * On Pause\n     */\n    @Override\n    public void onPause()\n    {\n        super.onPause();\n\n        server.setIsForeground(false);\n\n        if (binder != null && binder.getService() != null) {\n            binder.getService().checkServiceStatus();\n        }\n\n        unbindService(this);\n        unregisterReceiver(channelReceiver);\n        unregisterReceiver(serverReceiver);\n    }\n\n    /**\n     * On save instance state (e.g. before a configuration change)\n     */\n    @Override\n    protected void onSaveInstanceState(Bundle outState)\n    {\n        super.onSaveInstanceState(outState);\n\n        if (deckAdapter.isSwitched()) {\n            outState.putBoolean(\"isSwitched\", deckAdapter.isSwitched());\n            outState.putString(\"switchedName\", deckAdapter.getSwitchedName());\n        }\n    }\n\n    /**\n     * On restore instance state (e.g. after a configuration change)\n     */\n    @Override\n    protected void onRestoreInstanceState(Bundle inState)\n    {\n        super.onRestoreInstanceState(inState);\n\n        if (inState.getBoolean(\"isSwitched\")) {\n            deckAdapter.setSwitched(inState.getString(\"switchedName\"), null);\n        }\n    }\n\n    /**\n     * On service connected\n     */\n    @Override\n    public void onServiceConnected(ComponentName name, IBinder service)\n    {\n        this.binder = (IRCBinder) service;\n\n        // connect to irc server if connect has been requested\n        if (server.getStatus() == Status.PRE_CONNECTING && getIntent().hasExtra(\"connect\")) {\n            server.setStatus(Status.CONNECTING);\n            binder.connect(server);\n        }\n    }\n\n    /**\n     * On service disconnected\n     */\n    @Override\n    public void onServiceDisconnected(ComponentName name)\n    {\n        this.binder = null;\n    }\n\n    /**\n     * On options menu requested\n     */\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu)\n    {\n        super.onCreateOptionsMenu(menu);\n\n        // inflate from xml\n        MenuInflater inflater = getMenuInflater();\n        inflater.inflate(R.menu.conversations, menu);\n\n        return true;\n    }\n\n    /**\n     * On prepare options menu\n     */\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu)\n    {\n        menu.getItem(0).setEnabled(server.isConnected()); // join\n        menu.getItem(1).setEnabled(server.isConnected()); // users\n        menu.getItem(2).setEnabled(server.isConnected()); // close\n\n        return true;\n    }\n\n    /**\n     * On menu item selected\n     */\n    @Override\n    public boolean onMenuItemSelected(int featureId, MenuItem item)\n    {\n        switch (item.getItemId()) {\n            case R.id.disconnect:\n                server.setStatus(Status.DISCONNECTED);\n                binder.getService().getConnection(serverId).quitServer();\n                server.clearConversations();\n                setResult(RESULT_OK);\n                finish();\n                break;\n\n            case R.id.close:\n                Conversation conversationToClose = deckAdapter.getItem(deck.getSelectedItemPosition());\n                // Make sure we part a channel when closing the channel conversation\n                if (conversationToClose.getType() == Conversation.TYPE_CHANNEL) {\n                    binder.getService().getConnection(serverId).partChannel(conversationToClose.getName());\n                }\n                else if (conversationToClose.getType() == Conversation.TYPE_QUERY) {\n                    server.removeConversation(conversationToClose.getName());\n                    onRemoveConversation(conversationToClose.getName());\n                } else {\n                    Toast.makeText(this, getResources().getString(R.string.close_server_window), Toast.LENGTH_SHORT).show();\n                }\n                break;\n\n            case R.id.join:\n                startActivityForResult(new Intent(this, JoinActivity.class), REQUEST_CODE_JOIN);\n                break;\n\n            case R.id.users:\n                Conversation conversationForUserList = deckAdapter.getItem(deck.getSelectedItemPosition());\n                if (conversationForUserList.getType() == Conversation.TYPE_CHANNEL) {\n                    Intent intent = new Intent(this, UsersActivity.class);\n                    intent.putExtra(\n                        Extra.USERS,\n                        binder.getService().getConnection(server.getId()).getUsersAsStringArray(\n                            conversationForUserList.getName()\n                        )\n                    );\n                    startActivityForResult(intent, REQUEST_CODE_USERS);\n                } else {\n                    Toast.makeText(this, getResources().getString(R.string.only_usable_from_channel), Toast.LENGTH_SHORT).show();\n                }\n                break;\n        }\n\n        return true;\n    }\n\n    /**\n     * Get server object assigned to this activity\n     * \n     * @return the server object\n     */\n    public Server getServer()\n    {\n        return server;\n    }\n\n    /**\n     * On conversation message\n     */\n    @Override\n    public void onConversationMessage(String target)\n    {\n        Conversation conversation = server.getConversation(target);\n\n        if (conversation == null) {\n            // In an early state it can happen that the conversation object\n            // is not created yet.\n            return;\n        }\n\n        MessageListAdapter adapter = deckAdapter.getItemAdapter(target);\n\n        while(conversation.hasBufferedMessages()) {\n            Message message = conversation.pollBufferedMessage();\n\n            if (adapter != null && message != null) {\n                adapter.addMessage(message);\n                int status;\n\n                switch (message.getType())\n                {\n                    case Message.TYPE_MISC:\n                        status = Conversation.STATUS_MISC;\n                        break;\n\n                    default:\n                        status = Conversation.STATUS_MESSAGE;\n                        break;\n                }\n                conversation.setStatus(status);\n            }\n        }\n\n        if (dots != null) {\n            dots.invalidate();\n        }\n    }\n\n    /**\n     * On new conversation\n     */\n    @Override\n    public void onNewConversation(String target)\n    {\n        createNewConversation(target);\n\n        if (!deckAdapter.isSwitched()) {\n            // Scroll to new conversation\n            deck.setSelection(deckAdapter.getCount() - 1);\n        }\n    }\n    public void createNewConversation(String target)\n    {\n        deckAdapter.addItem(server.getConversation(target));\n    }\n\n    /**\n     * On conversation remove\n     */\n    @Override\n    public void onRemoveConversation(String target)\n    {\n        deckAdapter.removeItem(target);\n\n        if (deckAdapter.isSwitched()) {\n            switcher.showNext();\n            switcher.removeView(deckAdapter.getSwitchedView());\n            deckAdapter.setSwitched(null, null);\n        }\n    }\n\n    /**\n     * On topic change\n     */\n    public void onTopicChanged(String target)\n    {\n        String selected = server.getSelectedConversation();\n        if (selected.equals(target)) {\n            // onTopicChanged is only called for channels\n            Channel channel = (Channel) server.getConversation(selected);\n            StringBuilder sb = new StringBuilder();\n            sb.append(server.getTitle() + \" - \" + channel.getName());\n            if (!(channel.getTopic()).equals(\"\"))\n                sb.append(\" - \" + channel.getTopic());\n            ((TextView) findViewById(R.id.title)).setText(sb.toString());\n        }\n    }\n\n    /**\n     * On server status update\n     */\n    @Override\n    public void onStatusUpdate()\n    {\n        ((ImageView) findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\n        EditText input = (EditText) findViewById(R.id.input);\n\n        if (server.isConnected()) {\n            input.setEnabled(true);\n        } else {\n            input.setEnabled(false);\n\n            if (server.getStatus() == Status.CONNECTING) {\n                deckAdapter.clearConversations();\n                deckAdapter.addItem(server.getConversation(ServerInfo.DEFAULT_NAME));\n                return;\n            }\n\n            // Service is not connected or initialized yet - See #54\n            if (binder == null || binder.getService() == null || binder.getService().getSettings() == null) {\n                return;\n            }\n\n            if (!binder.getService().getSettings().isReconnectEnabled()) {\n                AlertDialog.Builder builder = new AlertDialog.Builder(this);\n                builder.setMessage(getResources().getString(R.string.reconnect_after_disconnect, server.getTitle()))\n                .setCancelable(false)\n                .setPositiveButton(\"Yes\", new DialogInterface.OnClickListener() {\n                    @Override\n                    public void onClick(DialogInterface dialog, int id) {\n                        binder.getService().getConnection(server.getId()).setAutojoinChannels(\n                            server.getCurrentChannelNames()\n                        );\n                        server.clearConversations();\n                        deckAdapter.clearConversations();\n                        deckAdapter.addItem(server.getConversation(ServerInfo.DEFAULT_NAME));\n                        binder.connect(server);\n                    }\n                })\n                .setNegativeButton(getString(R.string.negative_button), new DialogInterface.OnClickListener() {\n                    @Override\n                    public void onClick(DialogInterface dialog, int id) {\n                        dialog.cancel();\n                    }\n                });\n                AlertDialog alert = builder.create();\n                alert.show();\n            }\n        }\n    }\n\n    /**\n     * On key down\n     *\n     * XXX: As we only track the back key: Android >= 2.0 will call a method called onBackPressed()\n     */\n    @Override\n    public boolean onKeyDown(int keyCode, KeyEvent event)\n    {\n        if (keyCode == KeyEvent.KEYCODE_BACK && event.getRepeatCount() == 0) {\n            if (deckAdapter.isSwitched()) {\n                MessageListView canvas = (MessageListView) deckAdapter.getView(deckAdapter.getPositionByName(deckAdapter.getSwitchedName()), null, switcher);\n                canvas.setSwitched(false);\n                deckAdapter.setSwitched(null, null);\n                return true;\n            }\n        }\n        return super.onKeyDown(keyCode, event);\n    }\n\n    /**\n     * On key pressed (input line)\n     */\n    @Override\n    public boolean onKey(View view, int keyCode, KeyEvent event)\n    {\n        EditText input = (EditText) view;\n\n        if (keyCode == KeyEvent.KEYCODE_DPAD_UP && event.getAction() == KeyEvent.ACTION_DOWN) {\n            String message = scrollback.goBack();\n            if (message != null) {\n                input.setText(message);\n            }\n            return true;\n        }\n\n        if (keyCode == KeyEvent.KEYCODE_DPAD_DOWN && event.getAction() == KeyEvent.ACTION_DOWN) {\n            String message = scrollback.goForward();\n            if (message != null) {\n                input.setText(message);\n            }\n            return true;\n        }\n\n        // Nick completion\n        if (keyCode == KeyEvent.KEYCODE_SEARCH && event.getAction() == KeyEvent.ACTION_DOWN) {\n            String text = input.getText().toString();\n\n            if (text.length() <= 0) {\n                return true;\n            }\n\n            String[] tokens = text.split(\"[\\\\s,.-]+\");\n\n            if (tokens.length <= 0) {\n                return true;\n            }\n\n            String word = tokens[tokens.length - 1].toLowerCase();\n            tokens[tokens.length - 1] = null;\n\n            int begin   = input.getSelectionStart();\n            int end     = input.getSelectionEnd();\n            int cursor  = Math.min(begin, end);\n            int sel_end = Math.max(begin, end);\n\n            boolean in_selection = cursor != sel_end;\n\n            if (in_selection) {\n                word = text.substring(cursor, sel_end);\n            } else {\n                // use the word at the curent cursor position\n                while(true) {\n                    cursor -= 1;\n                    if (cursor <= 0 || text.charAt(cursor) == ' ') {\n                        break;\n                    }\n                }\n\n                if (cursor < 0) {\n                    cursor = 0;\n                }\n\n                if (text.charAt(cursor) == ' ') {\n                    cursor += 1;\n                }\n\n                sel_end = text.indexOf(' ', cursor);\n\n                if (sel_end == -1) {\n                    sel_end = text.length();\n                }\n\n                word = text.substring(cursor, sel_end);\n            }\n            // Log.d(\"Yaaic\", \"Trying to complete nick: \" + word);\n\n            Conversation conversationForUserList = deckAdapter.getItem(deck.getSelectedItemPosition());\n\n            String[] users = null;\n\n            if (conversationForUserList.getType() == Conversation.TYPE_CHANNEL) {\n                users = binder.getService().getConnection(server.getId()).getUsersAsStringArray(\n                    conversationForUserList.getName()\n                );\n            }\n\n            // go through users and add matches\n            if (users != null) {\n                List<Integer> result = new ArrayList<Integer>();\n\n                for (int i = 0; i < users.length; i++) {\n                    if (users[i].toLowerCase().startsWith(word)) {\n                        result.add(Integer.valueOf(i));\n                    }\n                }\n\n                if (result.size() == 1) {\n                    String text1 = users[result.get(0).intValue()];\n\n                    if (cursor == 0) {\n                        text1 += \":\";\n                    }\n\n                    text1 += \" \";\n                    input.getText().replace(cursor, sel_end, text1, 0, text1.length());\n                    int old = input.getInputType();\n                    input.setInputType(old | setInputTypeFlag);\n                } else if (result.size() > 0) {\n                    Intent intent  = new Intent(this, UsersActivity.class);\n                    String[] extra = new String[result.size()];\n                    int i = 0;\n\n                    for (Integer n : result) {\n                        extra[i++] = users[n.intValue()];\n                    }\n\n                    input.setSelection(cursor, sel_end);\n                    intent.putExtra(Extra.USERS, extra);\n                    startActivityForResult(intent, REQUEST_CODE_NICK_COMPLETION);\n                }\n            }\n            return true;\n        }\n\n        if (keyCode == KeyEvent.KEYCODE_ENTER && event.getAction() == KeyEvent.ACTION_DOWN) {\n            if (!server.isConnected()) {\n                Message message = new Message(getString(R.string.message_not_connected));\n                message.setColor(Message.COLOR_RED);\n                message.setIcon(R.drawable.error);\n                server.getConversation(server.getSelectedConversation()).addMessage(message);\n                onConversationMessage(server.getSelectedConversation());\n            }\n\n            String text = input.getText().toString();\n            input.setText(\"\");\n\n            if (text.equals(\"\")) {\n                // ignore empty messages\n                return true;\n            }\n\n            scrollback.addMessage(text);\n\n            Conversation conversation = deckAdapter.getItem(deck.getSelectedItemPosition());\n\n            if (conversation != null) {\n                if (!text.trim().startsWith(\"/\")) {\n                    if (conversation.getType() != Conversation.TYPE_SERVER) {\n                        String nickname = binder.getService().getConnection(serverId).getNick();\n                        //conversation.addMessage(new Message(\"<\" + nickname + \"> \" + text));\n                        conversation.addMessage(new Message(text, nickname));\n                        binder.getService().getConnection(serverId).sendMessage(conversation.getName(), text);\n                    } else {\n                        Message message = new Message(getString(R.string.chat_only_form_channel));\n                        message.setColor(Message.COLOR_YELLOW);\n                        message.setIcon(R.drawable.warning);\n                        conversation.addMessage(message);\n                    }\n                    onConversationMessage(conversation.getName());\n                } else {\n                    CommandParser.getInstance().parse(text, server, conversation, binder.getService());\n                }\n            }\n\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * On activity result\n     */\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent data)\n    {\n        if (resultCode != RESULT_OK) {\n            // ignore other result codes\n            return;\n        }\n\n        switch (requestCode) {\n            case REQUEST_CODE_SPEECH:\n                ArrayList<String> matches = data.getStringArrayListExtra(RecognizerIntent.EXTRA_RESULTS);\n                if (matches.size() > 0) {\n                    ((EditText) findViewById(R.id.input)).setText(matches.get(0));\n                }\n                break;\n            case REQUEST_CODE_JOIN:\n                joinChannelBuffer = data.getExtras().getString(\"channel\");\n                break;\n            case REQUEST_CODE_USERS:\n                Intent intent = new Intent(this, UserActivity.class);\n                intent.putExtra(Extra.USER, data.getStringExtra(Extra.USER));\n                startActivityForResult(intent, REQUEST_CODE_USER);\n                break;\n            case REQUEST_CODE_NICK_COMPLETION:\n                EditText input = (EditText) findViewById(R.id.input);\n                String src        = data.getExtras().getString(Extra.USER);\n                int start        = input.getSelectionStart();\n                int end        = input.getSelectionEnd();\n\n                if (start == 0) {\n                    src += \":\";\n                }\n\n                src += \" \";\n                input.getText().replace(start, end, src, 0, src.length());\n                // put cursor after inserted text\n                input.setSelection(start + src.length());\n                input.post(new Runnable() {\n                    @Override\n                    public void run() {\n                        // make the softkeyboard come up again (only if no hw keyboard is attached)\n                        EditText input = (EditText) findViewById(R.id.input);\n                        InputMethodManager mgr = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);\n                        mgr.showSoftInput(input, InputMethodManager.SHOW_IMPLICIT);\n                    }\n                });\n                input.requestFocus();\n                break;\n            case REQUEST_CODE_USER:\n                final int actionId = data.getExtras().getInt(Extra.ACTION);\n                final String nickname = data.getExtras().getString(Extra.USER);\n                final IRCConnection connection = binder.getService().getConnection(server.getId());\n                final String conversation = server.getSelectedConversation();\n                final Handler handler = new Handler();\n\n                // XXX: Implement me - The action should be handled after onResume()\n                //                     to catch the broadcasts... now we just wait a second\n                // Yes .. that's very ugly - we need some kind of queue that is handled after onResume()\n\n                new Thread() {\n                    @Override\n                    public void run() {\n                        try {\n                            Thread.sleep(1000);\n                        } catch (InterruptedException e) {\n                            // Do nothing\n                        }\n\n                        String nicknameWithoutPrefix = nickname;\n\n                        while (\n                            nicknameWithoutPrefix.startsWith(\"@\") ||\n                            nicknameWithoutPrefix.startsWith(\"+\") ||\n                            nicknameWithoutPrefix.startsWith(\".\") ||\n                            nicknameWithoutPrefix.startsWith(\"%\")\n                        ) {\n                            // Strip prefix(es) now\n                            nicknameWithoutPrefix = nicknameWithoutPrefix.substring(1);\n                        }\n\n                        switch (actionId) {\n                            case User.ACTION_REPLY:\n                                final String replyText = nicknameWithoutPrefix + \": \";\n                                handler.post(new Runnable() {\n                                    @Override\n                                    public void run() {\n                                        EditText input = (EditText) findViewById(R.id.input);\n                                        input.setText(replyText);\n                                        input.setSelection(replyText.length());\n                                    }\n                                });\n                                break;\n                            case User.ACTION_QUERY:\n                                Conversation query = server.getConversation(nicknameWithoutPrefix);\n                                if (query == null) {\n                                    // Open a query if there's none yet\n                                    query = new Query(nicknameWithoutPrefix);\n                                    server.addConversation(query);\n\n                                    Intent intent = Broadcast.createConversationIntent(\n                                        Broadcast.CONVERSATION_NEW,\n                                        server.getId(),\n                                        nicknameWithoutPrefix\n                                    );\n                                    binder.getService().sendBroadcast(intent);\n                                }\n                                break;\n                            case User.ACTION_OP:\n                                connection.op(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_DEOP:\n                                connection.deOp(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_VOICE:\n                                connection.voice(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_DEVOICE:\n                                connection.deVoice(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_KICK:\n                                connection.kick(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_BAN:\n                                connection.ban(conversation, nicknameWithoutPrefix + \"!*@*\");\n                                break;\n                        }\n                    }\n                }.start();\n\n                break;\n        }\n    }\n}\n","Method after Refactoring":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2011 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage org.yaaic.activity;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.adapter.DeckAdapter;\nimport org.yaaic.adapter.MessageListAdapter;\nimport org.yaaic.command.CommandParser;\nimport org.yaaic.irc.IRCBinder;\nimport org.yaaic.irc.IRCConnection;\nimport org.yaaic.irc.IRCService;\nimport org.yaaic.layout.NonScalingBackgroundDrawable;\nimport org.yaaic.listener.ConversationClickListener;\nimport org.yaaic.listener.ConversationListener;\nimport org.yaaic.listener.ConversationSelectedListener;\nimport org.yaaic.listener.ServerListener;\nimport org.yaaic.listener.SpeechClickListener;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.model.Extra;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Query;\nimport org.yaaic.model.Scrollback;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.ServerInfo;\nimport org.yaaic.model.Settings;\nimport org.yaaic.model.Status;\nimport org.yaaic.model.User;\nimport org.yaaic.receiver.ConversationReceiver;\nimport org.yaaic.receiver.ServerReceiver;\nimport org.yaaic.view.ConversationSwitcher;\nimport org.yaaic.view.MessageListView;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.content.pm.PackageManager;\nimport android.content.pm.ResolveInfo;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.speech.RecognizerIntent;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.View.OnKeyListener;\nimport android.view.Window;\nimport android.view.inputmethod.InputMethodManager;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.Gallery;\nimport android.widget.ImageView;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport android.widget.ViewSwitcher;\n\n/**\n * The server view with a scrollable list of all channels\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class ConversationActivity extends Activity implements ServiceConnection, ServerListener, ConversationListener, OnKeyListener\n{\n    public static final int REQUEST_CODE_SPEECH = 99;\n\n    private static final int REQUEST_CODE_JOIN = 1;\n    private static final int REQUEST_CODE_USERS = 2;\n    private static final int REQUEST_CODE_USER = 3;\n    private static final int REQUEST_CODE_NICK_COMPLETION= 4;\n\n    private int serverId;\n    private Server server;\n    private IRCBinder binder;\n    private ConversationReceiver channelReceiver;\n    private ServerReceiver serverReceiver;\n\n    private ViewSwitcher switcher;\n    private Gallery deck;\n    private DeckAdapter deckAdapter;\n    private Scrollback scrollback;\n    private ConversationSwitcher dots;\n\n    // XXX: This is ugly. This is a buffer for a channel that should be joined after showing the\n    //      JoinActivity. As onActivityResult() is called before onResume() a \"channel joined\"\n    //      broadcast may get lost as the broadcast receivers are registered in onResume() but the\n    //      join command would be called in onActivityResult(). joinChannelBuffer will save the\n    //      channel name in onActivityResult() and run the join command in onResume().\n    private String joinChannelBuffer;\n\n    // flag passed to setInputType later\n    // shall be TYPE_TEXT_FLAG_NO_SUGGESTIONS but it's not supported in all API levels (only in 5+)\n    // We'll set it to 0 if it's not supported\n    private int setInputTypeFlag;\n\n    private int historySize;\n\n    /**\n     * On create\n     */\n    @Override\n    protected void onCreate(Bundle savedInstanceState)\n    {\n        super.onCreate(savedInstanceState);\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n\n        serverId = getIntent().getExtras().getInt(\"serverId\");\n        server = Yaaic.getInstance().getServerById(serverId);\n\n        // Finish activity if server does not exist anymore - See #55\n        if (server == null) {\n            this.finish();\n        }\n\n        setTitle(\"Yaaic - \" + server.getTitle());\n\n        setContentView(R.layout.conversations);\n\n        ((TextView) findViewById(R.id.title)).setText(server.getTitle());\n        ((EditText) findViewById(R.id.input)).setOnKeyListener(this);\n\n        switcher = (ViewSwitcher) findViewById(R.id.switcher);\n\n        dots = (ConversationSwitcher) findViewById(R.id.dots);\n        dots.setServer(server);\n\n        deckAdapter = new DeckAdapter();\n        deck = (Gallery) findViewById(R.id.deck);\n        deck.setOnItemSelectedListener(new ConversationSelectedListener(this, server, (TextView) findViewById(R.id.title), dots));\n        deck.setAdapter(deckAdapter);\n        deck.setOnItemClickListener(new ConversationClickListener(deckAdapter, switcher));\n        deck.setBackgroundDrawable(new NonScalingBackgroundDrawable(this, deck, R.drawable.background));\n\n        Settings settings = new Settings(this);\n        historySize = settings.getHistorySize();\n\n        if (server.getStatus() == Status.PRE_CONNECTING) {\n            server.clearConversations();\n            deckAdapter.clearConversations();\n            server.getConversation(ServerInfo.DEFAULT_NAME).setHistorySize(historySize);\n        }\n\n        // Optimization : cache field lookups\n        Collection<Conversation> mConversations = server.getConversations();\n\n        for (Conversation conversation : mConversations) {\n            // Only scroll to new conversation if it was selected before\n            if (conversation.getStatus() == Conversation.STATUS_SELECTED) {\n                onNewConversation(conversation.getName());\n            } else {\n                createNewConversation(conversation.getName());\n            }\n        }\n\n        // keep compatibility with api level 3\n        if ((android.os.Build.VERSION.SDK.charAt(0) - '0') >= 5) {\n            setInputTypeFlag = 0x80000; // InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS\n        }\n        else {\n            setInputTypeFlag = 0;\n        }\n\n        // Create a new scrollback history\n        scrollback = new Scrollback();\n    }\n\n    /**\n     * On resume\n     */\n    @Override\n    public void onResume()\n    {\n        // register the receivers as early as possible, otherwise we may loose a broadcast message\n        channelReceiver = new ConversationReceiver(server.getId(), this);\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_MESSAGE));\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_NEW));\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_REMOVE));\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_TOPIC));\n\n        serverReceiver = new ServerReceiver(this);\n        registerReceiver(serverReceiver, new IntentFilter(Broadcast.SERVER_UPDATE));\n\n        super.onResume();\n\n        // Check if speech recognition is enabled and available\n        if (new Settings(this).isVoiceRecognitionEnabled()) {\n            PackageManager pm = getPackageManager();\n            Button speechButton = (Button) findViewById(R.id.speech);\n            List<ResolveInfo> activities = pm.queryIntentActivities(new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH), 0);\n\n            if (activities.size() != 0) {\n                ((Button) findViewById(R.id.speech)).setOnClickListener(new SpeechClickListener(this));\n                speechButton.setVisibility(View.VISIBLE);\n            }\n        }\n\n        ((ImageView) findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\n        // Start service\n        Intent intent = new Intent(this, IRCService.class);\n        intent.setAction(IRCService.ACTION_FOREGROUND);\n        startService(intent);\n        bindService(intent, this, 0);\n\n        if (!server.isConnected()) {\n            ((EditText) findViewById(R.id.input)).setEnabled(false);\n        } else {\n            ((EditText) findViewById(R.id.input)).setEnabled(true);\n        }\n\n        // Optimization - cache field lookup\n        Collection<Conversation> mConversations = server.getConversations();\n        MessageListAdapter mAdapter;\n\n        // Fill view with messages that have been buffered while paused\n        for (Conversation conversation : mConversations) {\n            mAdapter = deckAdapter.getItemAdapter(conversation.getName());\n\n            if (mAdapter != null) {\n                mAdapter.addBulkMessages(conversation.getBuffer());\n                conversation.clearBuffer();\n            }\n\n            // Clear new message notifications for the selected conversation\n            if (conversation.getStatus() == Conversation.STATUS_SELECTED && conversation.getNewMentions() > 0) {\n                Intent ackIntent = new Intent(this, IRCService.class);\n                ackIntent.setAction(IRCService.ACTION_ACK_NEW_MENTIONS);\n                ackIntent.putExtra(IRCService.EXTRA_ACK_CONVTITLE, conversation.getName());\n                startService(ackIntent);\n            }\n        }\n\n        // Join channel that has been selected in JoinActivity (onActivityResult())\n        if (joinChannelBuffer != null) {\n            new Thread() {\n                @Override\n                public void run() {\n                    binder.getService().getConnection(serverId).joinChannel(joinChannelBuffer);\n                    joinChannelBuffer = null;\n                }\n            }.start();\n        }\n\n        server.setIsForeground(true);\n    }\n\n    /**\n     * On Pause\n     */\n    @Override\n    public void onPause()\n    {\n        super.onPause();\n\n        server.setIsForeground(false);\n\n        if (binder != null && binder.getService() != null) {\n            binder.getService().checkServiceStatus();\n        }\n\n        unbindService(this);\n        unregisterReceiver(channelReceiver);\n        unregisterReceiver(serverReceiver);\n    }\n\n    /**\n     * On save instance state (e.g. before a configuration change)\n     */\n    @Override\n    protected void onSaveInstanceState(Bundle outState)\n    {\n        super.onSaveInstanceState(outState);\n\n        if (deckAdapter.isSwitched()) {\n            outState.putBoolean(\"isSwitched\", deckAdapter.isSwitched());\n            outState.putString(\"switchedName\", deckAdapter.getSwitchedName());\n        }\n    }\n\n    /**\n     * On restore instance state (e.g. after a configuration change)\n     */\n    @Override\n    protected void onRestoreInstanceState(Bundle inState)\n    {\n        super.onRestoreInstanceState(inState);\n\n        if (inState.getBoolean(\"isSwitched\")) {\n            deckAdapter.setSwitched(inState.getString(\"switchedName\"), null);\n        }\n    }\n\n    /**\n     * On service connected\n     */\n    @Override\n    public void onServiceConnected(ComponentName name, IBinder service)\n    {\n        this.binder = (IRCBinder) service;\n\n        // connect to irc server if connect has been requested\n        if (server.getStatus() == Status.PRE_CONNECTING && getIntent().hasExtra(\"connect\")) {\n            server.setStatus(Status.CONNECTING);\n            binder.connect(server);\n        }\n    }\n\n    /**\n     * On service disconnected\n     */\n    @Override\n    public void onServiceDisconnected(ComponentName name)\n    {\n        this.binder = null;\n    }\n\n    /**\n     * On options menu requested\n     */\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu)\n    {\n        super.onCreateOptionsMenu(menu);\n\n        // inflate from xml\n        MenuInflater inflater = getMenuInflater();\n        inflater.inflate(R.menu.conversations, menu);\n\n        return true;\n    }\n\n    /**\n     * On prepare options menu\n     */\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu)\n    {\n        menu.getItem(0).setEnabled(server.isConnected()); // join\n        menu.getItem(1).setEnabled(server.isConnected()); // users\n        menu.getItem(2).setEnabled(server.isConnected()); // close\n\n        return true;\n    }\n\n    /**\n     * On menu item selected\n     */\n    @Override\n    public boolean onMenuItemSelected(int featureId, MenuItem item)\n    {\n        switch (item.getItemId()) {\n            case R.id.disconnect:\n                server.setStatus(Status.DISCONNECTED);\n                binder.getService().getConnection(serverId).quitServer();\n                server.clearConversations();\n                setResult(RESULT_OK);\n                finish();\n                break;\n\n            case R.id.close:\n                Conversation conversationToClose = deckAdapter.getItem(deck.getSelectedItemPosition());\n                // Make sure we part a channel when closing the channel conversation\n                if (conversationToClose.getType() == Conversation.TYPE_CHANNEL) {\n                    binder.getService().getConnection(serverId).partChannel(conversationToClose.getName());\n                }\n                else if (conversationToClose.getType() == Conversation.TYPE_QUERY) {\n                    server.removeConversation(conversationToClose.getName());\n                    onRemoveConversation(conversationToClose.getName());\n                } else {\n                    Toast.makeText(this, getResources().getString(R.string.close_server_window), Toast.LENGTH_SHORT).show();\n                }\n                break;\n\n            case R.id.join:\n                startActivityForResult(new Intent(this, JoinActivity.class), REQUEST_CODE_JOIN);\n                break;\n\n            case R.id.users:\n                Conversation conversationForUserList = deckAdapter.getItem(deck.getSelectedItemPosition());\n                if (conversationForUserList.getType() == Conversation.TYPE_CHANNEL) {\n                    Intent intent = new Intent(this, UsersActivity.class);\n                    intent.putExtra(\n                        Extra.USERS,\n                        binder.getService().getConnection(server.getId()).getUsersAsStringArray(\n                            conversationForUserList.getName()\n                        )\n                    );\n                    startActivityForResult(intent, REQUEST_CODE_USERS);\n                } else {\n                    Toast.makeText(this, getResources().getString(R.string.only_usable_from_channel), Toast.LENGTH_SHORT).show();\n                }\n                break;\n        }\n\n        return true;\n    }\n\n    /**\n     * Get server object assigned to this activity\n     * \n     * @return the server object\n     */\n    public Server getServer()\n    {\n        return server;\n    }\n\n    /**\n     * On conversation message\n     */\n    @Override\n    public void onConversationMessage(String target)\n    {\n        Conversation conversation = server.getConversation(target);\n\n        if (conversation == null) {\n            // In an early state it can happen that the conversation object\n            // is not created yet.\n            return;\n        }\n\n        MessageListAdapter adapter = deckAdapter.getItemAdapter(target);\n\n        while(conversation.hasBufferedMessages()) {\n            Message message = conversation.pollBufferedMessage();\n\n            if (adapter != null && message != null) {\n                adapter.addMessage(message);\n                int status;\n\n                switch (message.getType())\n                {\n                    case Message.TYPE_MISC:\n                        status = Conversation.STATUS_MISC;\n                        break;\n\n                    default:\n                        status = Conversation.STATUS_MESSAGE;\n                        break;\n                }\n                conversation.setStatus(status);\n            }\n        }\n\n        if (dots != null) {\n            dots.invalidate();\n        }\n    }\n\n    /**\n     * On new conversation\n     */\n    @Override\n    public void onNewConversation(String target)\n    {\n        createNewConversation(target);\n\n        if (!deckAdapter.isSwitched()) {\n            // Scroll to new conversation\n            deck.setSelection(deckAdapter.getCount() - 1);\n        }\n    }\n    public void createNewConversation(String target)\n    {\n        deckAdapter.addItem(server.getConversation(target));\n    }\n\n    /**\n     * On conversation remove\n     */\n    @Override\n    public void onRemoveConversation(String target)\n    {\n        deckAdapter.removeItem(target);\n\n        if (deckAdapter.isSwitched()) {\n            switcher.showNext();\n            switcher.removeView(deckAdapter.getSwitchedView());\n            deckAdapter.setSwitched(null, null);\n        }\n    }\n\n    /**\n     * On topic change\n     */\n    public void onTopicChanged(String target)\n    {\n        String selected = server.getSelectedConversation();\n        if (selected.equals(target)) {\n            // onTopicChanged is only called for channels\n            Channel channel = (Channel) server.getConversation(selected);\n            StringBuilder sb = new StringBuilder();\n            sb.append(server.getTitle() + \" - \" + channel.getName());\n            if (!(channel.getTopic()).equals(\"\"))\n                sb.append(\" - \" + channel.getTopic());\n            ((TextView) findViewById(R.id.title)).setText(sb.toString());\n        }\n    }\n\n    /**\n     * On server status update\n     */\n    @Override\n    public void onStatusUpdate()\n    {\n        ((ImageView) findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\n        EditText input = (EditText) findViewById(R.id.input);\n\n        if (server.isConnected()) {\n            input.setEnabled(true);\n        } else {\n            input.setEnabled(false);\n\n            if (server.getStatus() == Status.CONNECTING) {\n                deckAdapter.clearConversations();\n                Conversation serverInfo = server.getConversation(ServerInfo.DEFAULT_NAME);\n                serverInfo.setHistorySize(historySize);\n                deckAdapter.addItem(serverInfo);\n                return;\n            }\n\n            // Service is not connected or initialized yet - See #54\n            if (binder == null || binder.getService() == null || binder.getService().getSettings() == null) {\n                return;\n            }\n\n            if (!binder.getService().getSettings().isReconnectEnabled()) {\n                AlertDialog.Builder builder = new AlertDialog.Builder(this);\n                builder.setMessage(getResources().getString(R.string.reconnect_after_disconnect, server.getTitle()))\n                .setCancelable(false)\n                .setPositiveButton(\"Yes\", new DialogInterface.OnClickListener() {\n                    @Override\n                    public void onClick(DialogInterface dialog, int id) {\n                        binder.getService().getConnection(server.getId()).setAutojoinChannels(\n                            server.getCurrentChannelNames()\n                        );\n                        server.clearConversations();\n                        deckAdapter.clearConversations();\n                        Conversation serverInfo = server.getConversation(ServerInfo.DEFAULT_NAME);\n                        serverInfo.setHistorySize(historySize);\n                        deckAdapter.addItem(serverInfo);\n                        binder.connect(server);\n                    }\n                })\n                .setNegativeButton(getString(R.string.negative_button), new DialogInterface.OnClickListener() {\n                    @Override\n                    public void onClick(DialogInterface dialog, int id) {\n                        dialog.cancel();\n                    }\n                });\n                AlertDialog alert = builder.create();\n                alert.show();\n            }\n        }\n    }\n\n    /**\n     * On key down\n     *\n     * XXX: As we only track the back key: Android >= 2.0 will call a method called onBackPressed()\n     */\n    @Override\n    public boolean onKeyDown(int keyCode, KeyEvent event)\n    {\n        if (keyCode == KeyEvent.KEYCODE_BACK && event.getRepeatCount() == 0) {\n            if (deckAdapter.isSwitched()) {\n                MessageListView canvas = (MessageListView) deckAdapter.getView(deckAdapter.getPositionByName(deckAdapter.getSwitchedName()), null, switcher);\n                canvas.setSwitched(false);\n                deckAdapter.setSwitched(null, null);\n                return true;\n            }\n        }\n        return super.onKeyDown(keyCode, event);\n    }\n\n    /**\n     * On key pressed (input line)\n     */\n    @Override\n    public boolean onKey(View view, int keyCode, KeyEvent event)\n    {\n        EditText input = (EditText) view;\n\n        if (keyCode == KeyEvent.KEYCODE_DPAD_UP && event.getAction() == KeyEvent.ACTION_DOWN) {\n            String message = scrollback.goBack();\n            if (message != null) {\n                input.setText(message);\n            }\n            return true;\n        }\n\n        if (keyCode == KeyEvent.KEYCODE_DPAD_DOWN && event.getAction() == KeyEvent.ACTION_DOWN) {\n            String message = scrollback.goForward();\n            if (message != null) {\n                input.setText(message);\n            }\n            return true;\n        }\n\n        // Nick completion\n        if (keyCode == KeyEvent.KEYCODE_SEARCH && event.getAction() == KeyEvent.ACTION_DOWN) {\n            String text = input.getText().toString();\n\n            if (text.length() <= 0) {\n                return true;\n            }\n\n            String[] tokens = text.split(\"[\\\\s,.-]+\");\n\n            if (tokens.length <= 0) {\n                return true;\n            }\n\n            String word = tokens[tokens.length - 1].toLowerCase();\n            tokens[tokens.length - 1] = null;\n\n            int begin   = input.getSelectionStart();\n            int end     = input.getSelectionEnd();\n            int cursor  = Math.min(begin, end);\n            int sel_end = Math.max(begin, end);\n\n            boolean in_selection = cursor != sel_end;\n\n            if (in_selection) {\n                word = text.substring(cursor, sel_end);\n            } else {\n                // use the word at the curent cursor position\n                while(true) {\n                    cursor -= 1;\n                    if (cursor <= 0 || text.charAt(cursor) == ' ') {\n                        break;\n                    }\n                }\n\n                if (cursor < 0) {\n                    cursor = 0;\n                }\n\n                if (text.charAt(cursor) == ' ') {\n                    cursor += 1;\n                }\n\n                sel_end = text.indexOf(' ', cursor);\n\n                if (sel_end == -1) {\n                    sel_end = text.length();\n                }\n\n                word = text.substring(cursor, sel_end);\n            }\n            // Log.d(\"Yaaic\", \"Trying to complete nick: \" + word);\n\n            Conversation conversationForUserList = deckAdapter.getItem(deck.getSelectedItemPosition());\n\n            String[] users = null;\n\n            if (conversationForUserList.getType() == Conversation.TYPE_CHANNEL) {\n                users = binder.getService().getConnection(server.getId()).getUsersAsStringArray(\n                    conversationForUserList.getName()\n                );\n            }\n\n            // go through users and add matches\n            if (users != null) {\n                List<Integer> result = new ArrayList<Integer>();\n\n                for (int i = 0; i < users.length; i++) {\n                    if (users[i].toLowerCase().startsWith(word)) {\n                        result.add(Integer.valueOf(i));\n                    }\n                }\n\n                if (result.size() == 1) {\n                    String text1 = users[result.get(0).intValue()];\n\n                    if (cursor == 0) {\n                        text1 += \":\";\n                    }\n\n                    text1 += \" \";\n                    input.getText().replace(cursor, sel_end, text1, 0, text1.length());\n                    int old = input.getInputType();\n                    input.setInputType(old | setInputTypeFlag);\n                } else if (result.size() > 0) {\n                    Intent intent  = new Intent(this, UsersActivity.class);\n                    String[] extra = new String[result.size()];\n                    int i = 0;\n\n                    for (Integer n : result) {\n                        extra[i++] = users[n.intValue()];\n                    }\n\n                    input.setSelection(cursor, sel_end);\n                    intent.putExtra(Extra.USERS, extra);\n                    startActivityForResult(intent, REQUEST_CODE_NICK_COMPLETION);\n                }\n            }\n            return true;\n        }\n\n        if (keyCode == KeyEvent.KEYCODE_ENTER && event.getAction() == KeyEvent.ACTION_DOWN) {\n            if (!server.isConnected()) {\n                Message message = new Message(getString(R.string.message_not_connected));\n                message.setColor(Message.COLOR_RED);\n                message.setIcon(R.drawable.error);\n                server.getConversation(server.getSelectedConversation()).addMessage(message);\n                onConversationMessage(server.getSelectedConversation());\n            }\n\n            String text = input.getText().toString();\n            input.setText(\"\");\n\n            if (text.equals(\"\")) {\n                // ignore empty messages\n                return true;\n            }\n\n            scrollback.addMessage(text);\n\n            Conversation conversation = deckAdapter.getItem(deck.getSelectedItemPosition());\n\n            if (conversation != null) {\n                if (!text.trim().startsWith(\"/\")) {\n                    if (conversation.getType() != Conversation.TYPE_SERVER) {\n                        String nickname = binder.getService().getConnection(serverId).getNick();\n                        //conversation.addMessage(new Message(\"<\" + nickname + \"> \" + text));\n                        conversation.addMessage(new Message(text, nickname));\n                        binder.getService().getConnection(serverId).sendMessage(conversation.getName(), text);\n                    } else {\n                        Message message = new Message(getString(R.string.chat_only_form_channel));\n                        message.setColor(Message.COLOR_YELLOW);\n                        message.setIcon(R.drawable.warning);\n                        conversation.addMessage(message);\n                    }\n                    onConversationMessage(conversation.getName());\n                } else {\n                    CommandParser.getInstance().parse(text, server, conversation, binder.getService());\n                }\n            }\n\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * On activity result\n     */\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent data)\n    {\n        if (resultCode != RESULT_OK) {\n            // ignore other result codes\n            return;\n        }\n\n        switch (requestCode) {\n            case REQUEST_CODE_SPEECH:\n                ArrayList<String> matches = data.getStringArrayListExtra(RecognizerIntent.EXTRA_RESULTS);\n                if (matches.size() > 0) {\n                    ((EditText) findViewById(R.id.input)).setText(matches.get(0));\n                }\n                break;\n            case REQUEST_CODE_JOIN:\n                joinChannelBuffer = data.getExtras().getString(\"channel\");\n                break;\n            case REQUEST_CODE_USERS:\n                Intent intent = new Intent(this, UserActivity.class);\n                intent.putExtra(Extra.USER, data.getStringExtra(Extra.USER));\n                startActivityForResult(intent, REQUEST_CODE_USER);\n                break;\n            case REQUEST_CODE_NICK_COMPLETION:\n                EditText input = (EditText) findViewById(R.id.input);\n                String src        = data.getExtras().getString(Extra.USER);\n                int start        = input.getSelectionStart();\n                int end        = input.getSelectionEnd();\n\n                if (start == 0) {\n                    src += \":\";\n                }\n\n                src += \" \";\n                input.getText().replace(start, end, src, 0, src.length());\n                // put cursor after inserted text\n                input.setSelection(start + src.length());\n                input.post(new Runnable() {\n                    @Override\n                    public void run() {\n                        // make the softkeyboard come up again (only if no hw keyboard is attached)\n                        EditText input = (EditText) findViewById(R.id.input);\n                        InputMethodManager mgr = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);\n                        mgr.showSoftInput(input, InputMethodManager.SHOW_IMPLICIT);\n                    }\n                });\n                input.requestFocus();\n                break;\n            case REQUEST_CODE_USER:\n                final int actionId = data.getExtras().getInt(Extra.ACTION);\n                final String nickname = data.getExtras().getString(Extra.USER);\n                final IRCConnection connection = binder.getService().getConnection(server.getId());\n                final String conversation = server.getSelectedConversation();\n                final Handler handler = new Handler();\n\n                // XXX: Implement me - The action should be handled after onResume()\n                //                     to catch the broadcasts... now we just wait a second\n                // Yes .. that's very ugly - we need some kind of queue that is handled after onResume()\n\n                new Thread() {\n                    @Override\n                    public void run() {\n                        try {\n                            Thread.sleep(1000);\n                        } catch (InterruptedException e) {\n                            // Do nothing\n                        }\n\n                        String nicknameWithoutPrefix = nickname;\n\n                        while (\n                            nicknameWithoutPrefix.startsWith(\"@\") ||\n                            nicknameWithoutPrefix.startsWith(\"+\") ||\n                            nicknameWithoutPrefix.startsWith(\".\") ||\n                            nicknameWithoutPrefix.startsWith(\"%\")\n                        ) {\n                            // Strip prefix(es) now\n                            nicknameWithoutPrefix = nicknameWithoutPrefix.substring(1);\n                        }\n\n                        switch (actionId) {\n                            case User.ACTION_REPLY:\n                                final String replyText = nicknameWithoutPrefix + \": \";\n                                handler.post(new Runnable() {\n                                    @Override\n                                    public void run() {\n                                        EditText input = (EditText) findViewById(R.id.input);\n                                        input.setText(replyText);\n                                        input.setSelection(replyText.length());\n                                    }\n                                });\n                                break;\n                            case User.ACTION_QUERY:\n                                Conversation query = server.getConversation(nicknameWithoutPrefix);\n                                if (query == null) {\n                                    // Open a query if there's none yet\n                                    query = new Query(nicknameWithoutPrefix);\n                                    query.setHistorySize(binder.getService().getSettings().getHistorySize());\n                                    server.addConversation(query);\n\n                                    Intent intent = Broadcast.createConversationIntent(\n                                        Broadcast.CONVERSATION_NEW,\n                                        server.getId(),\n                                        nicknameWithoutPrefix\n                                    );\n                                    binder.getService().sendBroadcast(intent);\n                                }\n                                break;\n                            case User.ACTION_OP:\n                                connection.op(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_DEOP:\n                                connection.deOp(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_VOICE:\n                                connection.voice(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_DEVOICE:\n                                connection.deVoice(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_KICK:\n                                connection.kick(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_BAN:\n                                connection.ban(conversation, nicknameWithoutPrefix + \"!*@*\");\n                                break;\n                        }\n                    }\n                }.start();\n\n                break;\n        }\n    }\n}\n","lineNo":570}
{"Smelly Sample":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2011 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage org.yaaic.activity;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.adapter.DeckAdapter;\nimport org.yaaic.adapter.MessageListAdapter;\nimport org.yaaic.command.CommandParser;\nimport org.yaaic.irc.IRCBinder;\nimport org.yaaic.irc.IRCConnection;\nimport org.yaaic.irc.IRCService;\nimport org.yaaic.layout.NonScalingBackgroundDrawable;\nimport org.yaaic.listener.ConversationClickListener;\nimport org.yaaic.listener.ConversationListener;\nimport org.yaaic.listener.ConversationSelectedListener;\nimport org.yaaic.listener.ServerListener;\nimport org.yaaic.listener.SpeechClickListener;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.model.Extra;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Query;\nimport org.yaaic.model.Scrollback;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.ServerInfo;\nimport org.yaaic.model.Settings;\nimport org.yaaic.model.Status;\nimport org.yaaic.model.User;\nimport org.yaaic.receiver.ConversationReceiver;\nimport org.yaaic.receiver.ServerReceiver;\nimport org.yaaic.view.ConversationSwitcher;\nimport org.yaaic.view.MessageListView;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.content.pm.PackageManager;\nimport android.content.pm.ResolveInfo;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.speech.RecognizerIntent;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.View.OnKeyListener;\nimport android.view.Window;\nimport android.view.inputmethod.InputMethodManager;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.Gallery;\nimport android.widget.ImageView;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport android.widget.ViewSwitcher;\n\n/**\n * The server view with a scrollable list of all channels\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class ConversationActivity extends Activity implements ServiceConnection, ServerListener, ConversationListener, OnKeyListener\n{\n    public static final int REQUEST_CODE_SPEECH = 99;\n\n    private static final int REQUEST_CODE_JOIN = 1;\n    private static final int REQUEST_CODE_USERS = 2;\n    private static final int REQUEST_CODE_USER = 3;\n    private static final int REQUEST_CODE_NICK_COMPLETION= 4;\n\n    private int serverId;\n    private Server server;\n    private IRCBinder binder;\n    private ConversationReceiver channelReceiver;\n    private ServerReceiver serverReceiver;\n\n    private ViewSwitcher switcher;\n    private Gallery deck;\n    private DeckAdapter deckAdapter;\n    private Scrollback scrollback;\n    private ConversationSwitcher dots;\n\n    // XXX: This is ugly. This is a buffer for a channel that should be joined after showing the\n    //      JoinActivity. As onActivityResult() is called before onResume() a \"channel joined\"\n    //      broadcast may get lost as the broadcast receivers are registered in onResume() but the\n    //      join command would be called in onActivityResult(). joinChannelBuffer will save the\n    //      channel name in onActivityResult() and run the join command in onResume().\n    private String joinChannelBuffer;\n\n    // flag passed to setInputType later\n    // shall be TYPE_TEXT_FLAG_NO_SUGGESTIONS but it's not supported in all API levels (only in 5+)\n    // We'll set it to 0 if it's not supported\n    private int setInputTypeFlag;\n\n    /**\n     * On create\n     */\n    @Override\n    protected void onCreate(Bundle savedInstanceState)\n    {\n        super.onCreate(savedInstanceState);\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n\n        serverId = getIntent().getExtras().getInt(\"serverId\");\n        server = Yaaic.getInstance().getServerById(serverId);\n\n        // Finish activity if server does not exist anymore - See #55\n        if (server == null) {\n            this.finish();\n        }\n\n        setTitle(\"Yaaic - \" + server.getTitle());\n\n        setContentView(R.layout.conversations);\n\n        ((TextView) findViewById(R.id.title)).setText(server.getTitle());\n        ((EditText) findViewById(R.id.input)).setOnKeyListener(this);\n\n        switcher = (ViewSwitcher) findViewById(R.id.switcher);\n\n        dots = (ConversationSwitcher) findViewById(R.id.dots);\n        dots.setServer(server);\n\n        deckAdapter = new DeckAdapter();\n        deck = (Gallery) findViewById(R.id.deck);\n        deck.setOnItemSelectedListener(new ConversationSelectedListener(this, server, (TextView) findViewById(R.id.title), dots));\n        deck.setAdapter(deckAdapter);\n        deck.setOnItemClickListener(new ConversationClickListener(deckAdapter, switcher));\n        deck.setBackgroundDrawable(new NonScalingBackgroundDrawable(this, deck, R.drawable.background));\n\n        if (server.getStatus() == Status.PRE_CONNECTING) {\n            server.clearConversations();\n            deckAdapter.clearConversations();\n        }\n\n        // Optimization : cache field lookups\n        Collection<Conversation> mConversations = server.getConversations();\n\n        for (Conversation conversation : mConversations) {\n            // Only scroll to new conversation if it was selected before\n            if (conversation.getStatus() == Conversation.STATUS_SELECTED) {\n                onNewConversation(conversation.getName());\n            } else {\n                createNewConversation(conversation.getName());\n            }\n        }\n\n        // keep compatibility with api level 3\n        if ((android.os.Build.VERSION.SDK.charAt(0) - '0') >= 5) {\n            setInputTypeFlag = 0x80000; // InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS\n        }\n        else {\n            setInputTypeFlag = 0;\n        }\n\n        // Create a new scrollback history\n        scrollback = new Scrollback();\n    }\n\n    /**\n     * On resume\n     */\n    @Override\n    public void onResume()\n    {\n        // register the receivers as early as possible, otherwise we may loose a broadcast message\n        channelReceiver = new ConversationReceiver(server.getId(), this);\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_MESSAGE));\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_NEW));\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_REMOVE));\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_TOPIC));\n\n        serverReceiver = new ServerReceiver(this);\n        registerReceiver(serverReceiver, new IntentFilter(Broadcast.SERVER_UPDATE));\n\n        super.onResume();\n\n        // Check if speech recognition is enabled and available\n        if (new Settings(this).isVoiceRecognitionEnabled()) {\n            PackageManager pm = getPackageManager();\n            Button speechButton = (Button) findViewById(R.id.speech);\n            List<ResolveInfo> activities = pm.queryIntentActivities(new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH), 0);\n\n            if (activities.size() != 0) {\n                ((Button) findViewById(R.id.speech)).setOnClickListener(new SpeechClickListener(this));\n                speechButton.setVisibility(View.VISIBLE);\n            }\n        }\n\n        ((ImageView) findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\n        // Start service\n        Intent intent = new Intent(this, IRCService.class);\n        intent.setAction(IRCService.ACTION_FOREGROUND);\n        startService(intent);\n        bindService(intent, this, 0);\n\n        if (!server.isConnected()) {\n            ((EditText) findViewById(R.id.input)).setEnabled(false);\n        } else {\n            ((EditText) findViewById(R.id.input)).setEnabled(true);\n        }\n\n        // Optimization - cache field lookup\n        Collection<Conversation> mConversations = server.getConversations();\n        MessageListAdapter mAdapter;\n\n        // Fill view with messages that have been buffered while paused\n        for (Conversation conversation : mConversations) {\n            mAdapter = deckAdapter.getItemAdapter(conversation.getName());\n\n            if (mAdapter != null) {\n                mAdapter.addBulkMessages(conversation.getBuffer());\n                conversation.clearBuffer();\n            }\n\n            // Clear new message notifications for the selected conversation\n            if (conversation.getStatus() == Conversation.STATUS_SELECTED && conversation.getNewMentions() > 0) {\n                Intent ackIntent = new Intent(this, IRCService.class);\n                ackIntent.setAction(IRCService.ACTION_ACK_NEW_MENTIONS);\n                ackIntent.putExtra(IRCService.EXTRA_ACK_CONVTITLE, conversation.getName());\n                startService(ackIntent);\n            }\n        }\n\n        // Join channel that has been selected in JoinActivity (onActivityResult())\n        if (joinChannelBuffer != null) {\n            new Thread() {\n                @Override\n                public void run() {\n                    binder.getService().getConnection(serverId).joinChannel(joinChannelBuffer);\n                    joinChannelBuffer = null;\n                }\n            }.start();\n        }\n\n        server.setIsForeground(true);\n    }\n\n    /**\n     * On Pause\n     */\n    @Override\n    public void onPause()\n    {\n        super.onPause();\n\n        server.setIsForeground(false);\n\n        if (binder != null && binder.getService() != null) {\n            binder.getService().checkServiceStatus();\n        }\n\n        unbindService(this);\n        unregisterReceiver(channelReceiver);\n        unregisterReceiver(serverReceiver);\n    }\n\n    /**\n     * On save instance state (e.g. before a configuration change)\n     */\n    @Override\n    protected void onSaveInstanceState(Bundle outState)\n    {\n        super.onSaveInstanceState(outState);\n\n        if (deckAdapter.isSwitched()) {\n            outState.putBoolean(\"isSwitched\", deckAdapter.isSwitched());\n            outState.putString(\"switchedName\", deckAdapter.getSwitchedName());\n        }\n    }\n\n    /**\n     * On restore instance state (e.g. after a configuration change)\n     */\n    @Override\n    protected void onRestoreInstanceState(Bundle inState)\n    {\n        super.onRestoreInstanceState(inState);\n\n        if (inState.getBoolean(\"isSwitched\")) {\n            deckAdapter.setSwitched(inState.getString(\"switchedName\"), null);\n        }\n    }\n\n    /**\n     * On service connected\n     */\n    @Override\n    public void onServiceConnected(ComponentName name, IBinder service)\n    {\n        this.binder = (IRCBinder) service;\n\n        // connect to irc server if connect has been requested\n        if (server.getStatus() == Status.PRE_CONNECTING && getIntent().hasExtra(\"connect\")) {\n            server.setStatus(Status.CONNECTING);\n            binder.connect(server);\n        }\n    }\n\n    /**\n     * On service disconnected\n     */\n    @Override\n    public void onServiceDisconnected(ComponentName name)\n    {\n        this.binder = null;\n    }\n\n    /**\n     * On options menu requested\n     */\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu)\n    {\n        super.onCreateOptionsMenu(menu);\n\n        // inflate from xml\n        MenuInflater inflater = getMenuInflater();\n        inflater.inflate(R.menu.conversations, menu);\n\n        return true;\n    }\n\n    /**\n     * On prepare options menu\n     */\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu)\n    {\n        menu.getItem(0).setEnabled(server.isConnected()); // join\n        menu.getItem(1).setEnabled(server.isConnected()); // users\n        menu.getItem(2).setEnabled(server.isConnected()); // close\n\n        return true;\n    }\n\n    /**\n     * On menu item selected\n     */\n    @Override\n    public boolean onMenuItemSelected(int featureId, MenuItem item)\n    {\n        switch (item.getItemId()) {\n            case R.id.disconnect:\n                server.setStatus(Status.DISCONNECTED);\n                binder.getService().getConnection(serverId).quitServer();\n                server.clearConversations();\n                setResult(RESULT_OK);\n                finish();\n                break;\n\n            case R.id.close:\n                Conversation conversationToClose = deckAdapter.getItem(deck.getSelectedItemPosition());\n                // Make sure we part a channel when closing the channel conversation\n                if (conversationToClose.getType() == Conversation.TYPE_CHANNEL) {\n                    binder.getService().getConnection(serverId).partChannel(conversationToClose.getName());\n                }\n                else if (conversationToClose.getType() == Conversation.TYPE_QUERY) {\n                    server.removeConversation(conversationToClose.getName());\n                    onRemoveConversation(conversationToClose.getName());\n                } else {\n                    Toast.makeText(this, getResources().getString(R.string.close_server_window), Toast.LENGTH_SHORT).show();\n                }\n                break;\n\n            case R.id.join:\n                startActivityForResult(new Intent(this, JoinActivity.class), REQUEST_CODE_JOIN);\n                break;\n\n            case R.id.users:\n                Conversation conversationForUserList = deckAdapter.getItem(deck.getSelectedItemPosition());\n                if (conversationForUserList.getType() == Conversation.TYPE_CHANNEL) {\n                    Intent intent = new Intent(this, UsersActivity.class);\n                    intent.putExtra(\n                        Extra.USERS,\n                        binder.getService().getConnection(server.getId()).getUsersAsStringArray(\n                            conversationForUserList.getName()\n                        )\n                    );\n                    startActivityForResult(intent, REQUEST_CODE_USERS);\n                } else {\n                    Toast.makeText(this, getResources().getString(R.string.only_usable_from_channel), Toast.LENGTH_SHORT).show();\n                }\n                break;\n        }\n\n        return true;\n    }\n\n    /**\n     * Get server object assigned to this activity\n     * \n     * @return the server object\n     */\n    public Server getServer()\n    {\n        return server;\n    }\n\n    /**\n     * On conversation message\n     */\n    @Override\n    public void onConversationMessage(String target)\n    {\n        Conversation conversation = server.getConversation(target);\n\n        if (conversation == null) {\n            // In an early state it can happen that the conversation object\n            // is not created yet.\n            return;\n        }\n\n        MessageListAdapter adapter = deckAdapter.getItemAdapter(target);\n\n        while(conversation.hasBufferedMessages()) {\n            Message message = conversation.pollBufferedMessage();\n\n            if (adapter != null && message != null) {\n                adapter.addMessage(message);\n                int status;\n\n                switch (message.getType())\n                {\n                    case Message.TYPE_MISC:\n                        status = Conversation.STATUS_MISC;\n                        break;\n\n                    default:\n                        status = Conversation.STATUS_MESSAGE;\n                        break;\n                }\n                conversation.setStatus(status);\n            }\n        }\n\n        if (dots != null) {\n            dots.invalidate();\n        }\n    }\n\n    /**\n     * On new conversation\n     */\n    @Override\n    public void onNewConversation(String target)\n    {\n        createNewConversation(target);\n\n        if (!deckAdapter.isSwitched()) {\n            // Scroll to new conversation\n            deck.setSelection(deckAdapter.getCount() - 1);\n        }\n    }\n    public void createNewConversation(String target)\n    {\n        deckAdapter.addItem(server.getConversation(target));\n    }\n\n    /**\n     * On conversation remove\n     */\n    @Override\n    public void onRemoveConversation(String target)\n    {\n        deckAdapter.removeItem(target);\n\n        if (deckAdapter.isSwitched()) {\n            switcher.showNext();\n            switcher.removeView(deckAdapter.getSwitchedView());\n            deckAdapter.setSwitched(null, null);\n        }\n    }\n\n    /**\n     * On topic change\n     */\n    public void onTopicChanged(String target)\n    {\n        String selected = server.getSelectedConversation();\n        if (selected.equals(target)) {\n            // onTopicChanged is only called for channels\n            Channel channel = (Channel) server.getConversation(selected);\n            StringBuilder sb = new StringBuilder();\n            sb.append(server.getTitle() + \" - \" + channel.getName());\n            if (!(channel.getTopic()).equals(\"\"))\n                sb.append(\" - \" + channel.getTopic());\n            ((TextView) findViewById(R.id.title)).setText(sb.toString());\n        }\n    }\n\n    /**\n     * On server status update\n     */\n    @Override\n    public void onStatusUpdate()\n    {\n        ((ImageView) findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\n        EditText input = (EditText) findViewById(R.id.input);\n\n        if (server.isConnected()) {\n            input.setEnabled(true);\n        } else {\n            input.setEnabled(false);\n\n            if (server.getStatus() == Status.CONNECTING) {\n                deckAdapter.clearConversations();\n                deckAdapter.addItem(server.getConversation(ServerInfo.DEFAULT_NAME));\n                return;\n            }\n\n            // Service is not connected or initialized yet - See #54\n            if (binder == null || binder.getService() == null || binder.getService().getSettings() == null) {\n                return;\n            }\n\n            if (!binder.getService().getSettings().isReconnectEnabled()) {\n                AlertDialog.Builder builder = new AlertDialog.Builder(this);\n                builder.setMessage(getResources().getString(R.string.reconnect_after_disconnect, server.getTitle()))\n                .setCancelable(false)\n                .setPositiveButton(\"Yes\", new DialogInterface.OnClickListener() {\n                    @Override\n                    public void onClick(DialogInterface dialog, int id) {\n                        binder.getService().getConnection(server.getId()).setAutojoinChannels(\n                            server.getCurrentChannelNames()\n                        );\n                        server.clearConversations();\n                        deckAdapter.clearConversations();\n                        deckAdapter.addItem(server.getConversation(ServerInfo.DEFAULT_NAME));\n                        binder.connect(server);\n                    }\n                })\n                .setNegativeButton(getString(R.string.negative_button), new DialogInterface.OnClickListener() {\n                    @Override\n                    public void onClick(DialogInterface dialog, int id) {\n                        dialog.cancel();\n                    }\n                });\n                AlertDialog alert = builder.create();\n                alert.show();\n            }\n        }\n    }\n\n    /**\n     * On key down\n     *\n     * XXX: As we only track the back key: Android >= 2.0 will call a method called onBackPressed()\n     */\n    @Override\n    public boolean onKeyDown(int keyCode, KeyEvent event)\n    {\n        if (keyCode == KeyEvent.KEYCODE_BACK && event.getRepeatCount() == 0) {\n            if (deckAdapter.isSwitched()) {\n                MessageListView canvas = (MessageListView) deckAdapter.getView(deckAdapter.getPositionByName(deckAdapter.getSwitchedName()), null, switcher);\n                canvas.setSwitched(false);\n                deckAdapter.setSwitched(null, null);\n                return true;\n            }\n        }\n        return super.onKeyDown(keyCode, event);\n    }\n\n    /**\n     * On key pressed (input line)\n     */\n    @Override\n    public boolean onKey(View view, int keyCode, KeyEvent event)\n    {\n        EditText input = (EditText) view;\n\n        if (keyCode == KeyEvent.KEYCODE_DPAD_UP && event.getAction() == KeyEvent.ACTION_DOWN) {\n            String message = scrollback.goBack();\n            if (message != null) {\n                input.setText(message);\n            }\n            return true;\n        }\n\n        if (keyCode == KeyEvent.KEYCODE_DPAD_DOWN && event.getAction() == KeyEvent.ACTION_DOWN) {\n            String message = scrollback.goForward();\n            if (message != null) {\n                input.setText(message);\n            }\n            return true;\n        }\n\n        // Nick completion\n        if (keyCode == KeyEvent.KEYCODE_SEARCH && event.getAction() == KeyEvent.ACTION_DOWN) {\n            String text = input.getText().toString();\n\n            if (text.length() <= 0) {\n                return true;\n            }\n\n            String[] tokens = text.split(\"[\\\\s,.-]+\");\n\n            if (tokens.length <= 0) {\n                return true;\n            }\n\n            String word = tokens[tokens.length - 1].toLowerCase();\n            tokens[tokens.length - 1] = null;\n\n            int begin   = input.getSelectionStart();\n            int end     = input.getSelectionEnd();\n            int cursor  = Math.min(begin, end);\n            int sel_end = Math.max(begin, end);\n\n            boolean in_selection = cursor != sel_end;\n\n            if (in_selection) {\n                word = text.substring(cursor, sel_end);\n            } else {\n                // use the word at the curent cursor position\n                while(true) {\n                    cursor -= 1;\n                    if (cursor <= 0 || text.charAt(cursor) == ' ') {\n                        break;\n                    }\n                }\n\n                if (cursor < 0) {\n                    cursor = 0;\n                }\n\n                if (text.charAt(cursor) == ' ') {\n                    cursor += 1;\n                }\n\n                sel_end = text.indexOf(' ', cursor);\n\n                if (sel_end == -1) {\n                    sel_end = text.length();\n                }\n\n                word = text.substring(cursor, sel_end);\n            }\n            // Log.d(\"Yaaic\", \"Trying to complete nick: \" + word);\n\n            Conversation conversationForUserList = deckAdapter.getItem(deck.getSelectedItemPosition());\n\n            String[] users = null;\n\n            if (conversationForUserList.getType() == Conversation.TYPE_CHANNEL) {\n                users = binder.getService().getConnection(server.getId()).getUsersAsStringArray(\n                    conversationForUserList.getName()\n                );\n            }\n\n            // go through users and add matches\n            if (users != null) {\n                List<Integer> result = new ArrayList<Integer>();\n\n                for (int i = 0; i < users.length; i++) {\n                    if (users[i].toLowerCase().startsWith(word)) {\n                        result.add(Integer.valueOf(i));\n                    }\n                }\n\n                if (result.size() == 1) {\n                    String text1 = users[result.get(0).intValue()];\n\n                    if (cursor == 0) {\n                        text1 += \":\";\n                    }\n\n                    text1 += \" \";\n                    input.getText().replace(cursor, sel_end, text1, 0, text1.length());\n                    int old = input.getInputType();\n                    input.setInputType(old | setInputTypeFlag);\n                } else if (result.size() > 0) {\n                    Intent intent  = new Intent(this, UsersActivity.class);\n                    String[] extra = new String[result.size()];\n                    int i = 0;\n\n                    for (Integer n : result) {\n                        extra[i++] = users[n.intValue()];\n                    }\n\n                    input.setSelection(cursor, sel_end);\n                    intent.putExtra(Extra.USERS, extra);\n                    startActivityForResult(intent, REQUEST_CODE_NICK_COMPLETION);\n                }\n            }\n            return true;\n        }\n\n        if (keyCode == KeyEvent.KEYCODE_ENTER && event.getAction() == KeyEvent.ACTION_DOWN) {\n            if (!server.isConnected()) {\n                Message message = new Message(getString(R.string.message_not_connected));\n                message.setColor(Message.COLOR_RED);\n                message.setIcon(R.drawable.error);\n                server.getConversation(server.getSelectedConversation()).addMessage(message);\n                onConversationMessage(server.getSelectedConversation());\n            }\n\n            String text = input.getText().toString();\n            input.setText(\"\");\n\n            if (text.equals(\"\")) {\n                // ignore empty messages\n                return true;\n            }\n\n            scrollback.addMessage(text);\n\n            Conversation conversation = deckAdapter.getItem(deck.getSelectedItemPosition());\n\n            if (conversation != null) {\n                if (!text.trim().startsWith(\"/\")) {\n                    if (conversation.getType() != Conversation.TYPE_SERVER) {\n                        String nickname = binder.getService().getConnection(serverId).getNick();\n                        //conversation.addMessage(new Message(\"<\" + nickname + \"> \" + text));\n                        conversation.addMessage(new Message(text, nickname));\n                        binder.getService().getConnection(serverId).sendMessage(conversation.getName(), text);\n                    } else {\n                        Message message = new Message(getString(R.string.chat_only_form_channel));\n                        message.setColor(Message.COLOR_YELLOW);\n                        message.setIcon(R.drawable.warning);\n                        conversation.addMessage(message);\n                    }\n                    onConversationMessage(conversation.getName());\n                } else {\n                    CommandParser.getInstance().parse(text, server, conversation, binder.getService());\n                }\n            }\n\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * On activity result\n     */\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent data)\n    {\n        if (resultCode != RESULT_OK) {\n            // ignore other result codes\n            return;\n        }\n\n        switch (requestCode) {\n            case REQUEST_CODE_SPEECH:\n                ArrayList<String> matches = data.getStringArrayListExtra(RecognizerIntent.EXTRA_RESULTS);\n                if (matches.size() > 0) {\n                    ((EditText) findViewById(R.id.input)).setText(matches.get(0));\n                }\n                break;\n            case REQUEST_CODE_JOIN:\n                joinChannelBuffer = data.getExtras().getString(\"channel\");\n                break;\n            case REQUEST_CODE_USERS:\n                Intent intent = new Intent(this, UserActivity.class);\n                intent.putExtra(Extra.USER, data.getStringExtra(Extra.USER));\n                startActivityForResult(intent, REQUEST_CODE_USER);\n                break;\n            case REQUEST_CODE_NICK_COMPLETION:\n                EditText input = (EditText) findViewById(R.id.input);\n                String src        = data.getExtras().getString(Extra.USER);\n                int start        = input.getSelectionStart();\n                int end        = input.getSelectionEnd();\n\n                if (start == 0) {\n                    src += \":\";\n                }\n\n                src += \" \";\n                input.getText().replace(start, end, src, 0, src.length());\n                // put cursor after inserted text\n                input.setSelection(start + src.length());\n                input.post(new Runnable() {\n                    @Override\n                    public void run() {\n                        // make the softkeyboard come up again (only if no hw keyboard is attached)\n                        EditText input = (EditText) findViewById(R.id.input);\n                        InputMethodManager mgr = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);\n                        mgr.showSoftInput(input, InputMethodManager.SHOW_IMPLICIT);\n                    }\n                });\n                input.requestFocus();\n                break;\n            case REQUEST_CODE_USER:\n                final int actionId = data.getExtras().getInt(Extra.ACTION);\n                final String nickname = data.getExtras().getString(Extra.USER);\n                final IRCConnection connection = binder.getService().getConnection(server.getId());\n                final String conversation = server.getSelectedConversation();\n                final Handler handler = new Handler();\n\n                // XXX: Implement me - The action should be handled after onResume()\n                //                     to catch the broadcasts... now we just wait a second\n                // Yes .. that's very ugly - we need some kind of queue that is handled after onResume()\n\n                new Thread() {\n                    @Override\n                    public void run() {\n                        try {\n                            Thread.sleep(1000);\n                        } catch (InterruptedException e) {\n                            // Do nothing\n                        }\n\n                        String nicknameWithoutPrefix = nickname;\n\n                        while (\n                            nicknameWithoutPrefix.startsWith(\"@\") ||\n                            nicknameWithoutPrefix.startsWith(\"+\") ||\n                            nicknameWithoutPrefix.startsWith(\".\") ||\n                            nicknameWithoutPrefix.startsWith(\"%\")\n                        ) {\n                            // Strip prefix(es) now\n                            nicknameWithoutPrefix = nicknameWithoutPrefix.substring(1);\n                        }\n\n                        switch (actionId) {\n                            case User.ACTION_REPLY:\n                                final String replyText = nicknameWithoutPrefix + \": \";\n                                handler.post(new Runnable() {\n                                    @Override\n                                    public void run() {\n                                        EditText input = (EditText) findViewById(R.id.input);\n                                        input.setText(replyText);\n                                        input.setSelection(replyText.length());\n                                    }\n                                });\n                                break;\n                            case User.ACTION_QUERY:\n                                Conversation query = server.getConversation(nicknameWithoutPrefix);\n                                if (query == null) {\n                                    // Open a query if there's none yet\n                                    query = new Query(nicknameWithoutPrefix);\n                                    server.addConversation(query);\n\n                                    Intent intent = Broadcast.createConversationIntent(\n                                        Broadcast.CONVERSATION_NEW,\n                                        server.getId(),\n                                        nicknameWithoutPrefix\n                                    );\n                                    binder.getService().sendBroadcast(intent);\n                                }\n                                break;\n                            case User.ACTION_OP:\n                                connection.op(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_DEOP:\n                                connection.deOp(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_VOICE:\n                                connection.voice(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_DEVOICE:\n                                connection.deVoice(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_KICK:\n                                connection.kick(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_BAN:\n                                connection.ban(conversation, nicknameWithoutPrefix + \"!*@*\");\n                                break;\n                        }\n                    }\n                }.start();\n\n                break;\n        }\n    }\n}\n","Method after Refactoring":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2011 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage org.yaaic.activity;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.adapter.DeckAdapter;\nimport org.yaaic.adapter.MessageListAdapter;\nimport org.yaaic.command.CommandParser;\nimport org.yaaic.irc.IRCBinder;\nimport org.yaaic.irc.IRCConnection;\nimport org.yaaic.irc.IRCService;\nimport org.yaaic.layout.NonScalingBackgroundDrawable;\nimport org.yaaic.listener.ConversationClickListener;\nimport org.yaaic.listener.ConversationListener;\nimport org.yaaic.listener.ConversationSelectedListener;\nimport org.yaaic.listener.ServerListener;\nimport org.yaaic.listener.SpeechClickListener;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.model.Extra;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Query;\nimport org.yaaic.model.Scrollback;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.ServerInfo;\nimport org.yaaic.model.Settings;\nimport org.yaaic.model.Status;\nimport org.yaaic.model.User;\nimport org.yaaic.receiver.ConversationReceiver;\nimport org.yaaic.receiver.ServerReceiver;\nimport org.yaaic.view.ConversationSwitcher;\nimport org.yaaic.view.MessageListView;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.content.pm.PackageManager;\nimport android.content.pm.ResolveInfo;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.speech.RecognizerIntent;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.View.OnKeyListener;\nimport android.view.Window;\nimport android.view.inputmethod.InputMethodManager;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.Gallery;\nimport android.widget.ImageView;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport android.widget.ViewSwitcher;\n\n/**\n * The server view with a scrollable list of all channels\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class ConversationActivity extends Activity implements ServiceConnection, ServerListener, ConversationListener, OnKeyListener\n{\n    public static final int REQUEST_CODE_SPEECH = 99;\n\n    private static final int REQUEST_CODE_JOIN = 1;\n    private static final int REQUEST_CODE_USERS = 2;\n    private static final int REQUEST_CODE_USER = 3;\n    private static final int REQUEST_CODE_NICK_COMPLETION= 4;\n\n    private int serverId;\n    private Server server;\n    private IRCBinder binder;\n    private ConversationReceiver channelReceiver;\n    private ServerReceiver serverReceiver;\n\n    private ViewSwitcher switcher;\n    private Gallery deck;\n    private DeckAdapter deckAdapter;\n    private Scrollback scrollback;\n    private ConversationSwitcher dots;\n\n    // XXX: This is ugly. This is a buffer for a channel that should be joined after showing the\n    //      JoinActivity. As onActivityResult() is called before onResume() a \"channel joined\"\n    //      broadcast may get lost as the broadcast receivers are registered in onResume() but the\n    //      join command would be called in onActivityResult(). joinChannelBuffer will save the\n    //      channel name in onActivityResult() and run the join command in onResume().\n    private String joinChannelBuffer;\n\n    // flag passed to setInputType later\n    // shall be TYPE_TEXT_FLAG_NO_SUGGESTIONS but it's not supported in all API levels (only in 5+)\n    // We'll set it to 0 if it's not supported\n    private int setInputTypeFlag;\n\n    private int historySize;\n\n    /**\n     * On create\n     */\n    @Override\n    protected void onCreate(Bundle savedInstanceState)\n    {\n        super.onCreate(savedInstanceState);\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n\n        serverId = getIntent().getExtras().getInt(\"serverId\");\n        server = Yaaic.getInstance().getServerById(serverId);\n\n        // Finish activity if server does not exist anymore - See #55\n        if (server == null) {\n            this.finish();\n        }\n\n        setTitle(\"Yaaic - \" + server.getTitle());\n\n        setContentView(R.layout.conversations);\n\n        ((TextView) findViewById(R.id.title)).setText(server.getTitle());\n        ((EditText) findViewById(R.id.input)).setOnKeyListener(this);\n\n        switcher = (ViewSwitcher) findViewById(R.id.switcher);\n\n        dots = (ConversationSwitcher) findViewById(R.id.dots);\n        dots.setServer(server);\n\n        deckAdapter = new DeckAdapter();\n        deck = (Gallery) findViewById(R.id.deck);\n        deck.setOnItemSelectedListener(new ConversationSelectedListener(this, server, (TextView) findViewById(R.id.title), dots));\n        deck.setAdapter(deckAdapter);\n        deck.setOnItemClickListener(new ConversationClickListener(deckAdapter, switcher));\n        deck.setBackgroundDrawable(new NonScalingBackgroundDrawable(this, deck, R.drawable.background));\n\n        Settings settings = new Settings(this);\n        historySize = settings.getHistorySize();\n\n        if (server.getStatus() == Status.PRE_CONNECTING) {\n            server.clearConversations();\n            deckAdapter.clearConversations();\n            server.getConversation(ServerInfo.DEFAULT_NAME).setHistorySize(historySize);\n        }\n\n        // Optimization : cache field lookups\n        Collection<Conversation> mConversations = server.getConversations();\n\n        for (Conversation conversation : mConversations) {\n            // Only scroll to new conversation if it was selected before\n            if (conversation.getStatus() == Conversation.STATUS_SELECTED) {\n                onNewConversation(conversation.getName());\n            } else {\n                createNewConversation(conversation.getName());\n            }\n        }\n\n        // keep compatibility with api level 3\n        if ((android.os.Build.VERSION.SDK.charAt(0) - '0') >= 5) {\n            setInputTypeFlag = 0x80000; // InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS\n        }\n        else {\n            setInputTypeFlag = 0;\n        }\n\n        // Create a new scrollback history\n        scrollback = new Scrollback();\n    }\n\n    /**\n     * On resume\n     */\n    @Override\n    public void onResume()\n    {\n        // register the receivers as early as possible, otherwise we may loose a broadcast message\n        channelReceiver = new ConversationReceiver(server.getId(), this);\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_MESSAGE));\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_NEW));\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_REMOVE));\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_TOPIC));\n\n        serverReceiver = new ServerReceiver(this);\n        registerReceiver(serverReceiver, new IntentFilter(Broadcast.SERVER_UPDATE));\n\n        super.onResume();\n\n        // Check if speech recognition is enabled and available\n        if (new Settings(this).isVoiceRecognitionEnabled()) {\n            PackageManager pm = getPackageManager();\n            Button speechButton = (Button) findViewById(R.id.speech);\n            List<ResolveInfo> activities = pm.queryIntentActivities(new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH), 0);\n\n            if (activities.size() != 0) {\n                ((Button) findViewById(R.id.speech)).setOnClickListener(new SpeechClickListener(this));\n                speechButton.setVisibility(View.VISIBLE);\n            }\n        }\n\n        ((ImageView) findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\n        // Start service\n        Intent intent = new Intent(this, IRCService.class);\n        intent.setAction(IRCService.ACTION_FOREGROUND);\n        startService(intent);\n        bindService(intent, this, 0);\n\n        if (!server.isConnected()) {\n            ((EditText) findViewById(R.id.input)).setEnabled(false);\n        } else {\n            ((EditText) findViewById(R.id.input)).setEnabled(true);\n        }\n\n        // Optimization - cache field lookup\n        Collection<Conversation> mConversations = server.getConversations();\n        MessageListAdapter mAdapter;\n\n        // Fill view with messages that have been buffered while paused\n        for (Conversation conversation : mConversations) {\n            mAdapter = deckAdapter.getItemAdapter(conversation.getName());\n\n            if (mAdapter != null) {\n                mAdapter.addBulkMessages(conversation.getBuffer());\n                conversation.clearBuffer();\n            }\n\n            // Clear new message notifications for the selected conversation\n            if (conversation.getStatus() == Conversation.STATUS_SELECTED && conversation.getNewMentions() > 0) {\n                Intent ackIntent = new Intent(this, IRCService.class);\n                ackIntent.setAction(IRCService.ACTION_ACK_NEW_MENTIONS);\n                ackIntent.putExtra(IRCService.EXTRA_ACK_CONVTITLE, conversation.getName());\n                startService(ackIntent);\n            }\n        }\n\n        // Join channel that has been selected in JoinActivity (onActivityResult())\n        if (joinChannelBuffer != null) {\n            new Thread() {\n                @Override\n                public void run() {\n                    binder.getService().getConnection(serverId).joinChannel(joinChannelBuffer);\n                    joinChannelBuffer = null;\n                }\n            }.start();\n        }\n\n        server.setIsForeground(true);\n    }\n\n    /**\n     * On Pause\n     */\n    @Override\n    public void onPause()\n    {\n        super.onPause();\n\n        server.setIsForeground(false);\n\n        if (binder != null && binder.getService() != null) {\n            binder.getService().checkServiceStatus();\n        }\n\n        unbindService(this);\n        unregisterReceiver(channelReceiver);\n        unregisterReceiver(serverReceiver);\n    }\n\n    /**\n     * On save instance state (e.g. before a configuration change)\n     */\n    @Override\n    protected void onSaveInstanceState(Bundle outState)\n    {\n        super.onSaveInstanceState(outState);\n\n        if (deckAdapter.isSwitched()) {\n            outState.putBoolean(\"isSwitched\", deckAdapter.isSwitched());\n            outState.putString(\"switchedName\", deckAdapter.getSwitchedName());\n        }\n    }\n\n    /**\n     * On restore instance state (e.g. after a configuration change)\n     */\n    @Override\n    protected void onRestoreInstanceState(Bundle inState)\n    {\n        super.onRestoreInstanceState(inState);\n\n        if (inState.getBoolean(\"isSwitched\")) {\n            deckAdapter.setSwitched(inState.getString(\"switchedName\"), null);\n        }\n    }\n\n    /**\n     * On service connected\n     */\n    @Override\n    public void onServiceConnected(ComponentName name, IBinder service)\n    {\n        this.binder = (IRCBinder) service;\n\n        // connect to irc server if connect has been requested\n        if (server.getStatus() == Status.PRE_CONNECTING && getIntent().hasExtra(\"connect\")) {\n            server.setStatus(Status.CONNECTING);\n            binder.connect(server);\n        }\n    }\n\n    /**\n     * On service disconnected\n     */\n    @Override\n    public void onServiceDisconnected(ComponentName name)\n    {\n        this.binder = null;\n    }\n\n    /**\n     * On options menu requested\n     */\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu)\n    {\n        super.onCreateOptionsMenu(menu);\n\n        // inflate from xml\n        MenuInflater inflater = getMenuInflater();\n        inflater.inflate(R.menu.conversations, menu);\n\n        return true;\n    }\n\n    /**\n     * On prepare options menu\n     */\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu)\n    {\n        menu.getItem(0).setEnabled(server.isConnected()); // join\n        menu.getItem(1).setEnabled(server.isConnected()); // users\n        menu.getItem(2).setEnabled(server.isConnected()); // close\n\n        return true;\n    }\n\n    /**\n     * On menu item selected\n     */\n    @Override\n    public boolean onMenuItemSelected(int featureId, MenuItem item)\n    {\n        switch (item.getItemId()) {\n            case R.id.disconnect:\n                server.setStatus(Status.DISCONNECTED);\n                binder.getService().getConnection(serverId).quitServer();\n                server.clearConversations();\n                setResult(RESULT_OK);\n                finish();\n                break;\n\n            case R.id.close:\n                Conversation conversationToClose = deckAdapter.getItem(deck.getSelectedItemPosition());\n                // Make sure we part a channel when closing the channel conversation\n                if (conversationToClose.getType() == Conversation.TYPE_CHANNEL) {\n                    binder.getService().getConnection(serverId).partChannel(conversationToClose.getName());\n                }\n                else if (conversationToClose.getType() == Conversation.TYPE_QUERY) {\n                    server.removeConversation(conversationToClose.getName());\n                    onRemoveConversation(conversationToClose.getName());\n                } else {\n                    Toast.makeText(this, getResources().getString(R.string.close_server_window), Toast.LENGTH_SHORT).show();\n                }\n                break;\n\n            case R.id.join:\n                startActivityForResult(new Intent(this, JoinActivity.class), REQUEST_CODE_JOIN);\n                break;\n\n            case R.id.users:\n                Conversation conversationForUserList = deckAdapter.getItem(deck.getSelectedItemPosition());\n                if (conversationForUserList.getType() == Conversation.TYPE_CHANNEL) {\n                    Intent intent = new Intent(this, UsersActivity.class);\n                    intent.putExtra(\n                        Extra.USERS,\n                        binder.getService().getConnection(server.getId()).getUsersAsStringArray(\n                            conversationForUserList.getName()\n                        )\n                    );\n                    startActivityForResult(intent, REQUEST_CODE_USERS);\n                } else {\n                    Toast.makeText(this, getResources().getString(R.string.only_usable_from_channel), Toast.LENGTH_SHORT).show();\n                }\n                break;\n        }\n\n        return true;\n    }\n\n    /**\n     * Get server object assigned to this activity\n     * \n     * @return the server object\n     */\n    public Server getServer()\n    {\n        return server;\n    }\n\n    /**\n     * On conversation message\n     */\n    @Override\n    public void onConversationMessage(String target)\n    {\n        Conversation conversation = server.getConversation(target);\n\n        if (conversation == null) {\n            // In an early state it can happen that the conversation object\n            // is not created yet.\n            return;\n        }\n\n        MessageListAdapter adapter = deckAdapter.getItemAdapter(target);\n\n        while(conversation.hasBufferedMessages()) {\n            Message message = conversation.pollBufferedMessage();\n\n            if (adapter != null && message != null) {\n                adapter.addMessage(message);\n                int status;\n\n                switch (message.getType())\n                {\n                    case Message.TYPE_MISC:\n                        status = Conversation.STATUS_MISC;\n                        break;\n\n                    default:\n                        status = Conversation.STATUS_MESSAGE;\n                        break;\n                }\n                conversation.setStatus(status);\n            }\n        }\n\n        if (dots != null) {\n            dots.invalidate();\n        }\n    }\n\n    /**\n     * On new conversation\n     */\n    @Override\n    public void onNewConversation(String target)\n    {\n        createNewConversation(target);\n\n        if (!deckAdapter.isSwitched()) {\n            // Scroll to new conversation\n            deck.setSelection(deckAdapter.getCount() - 1);\n        }\n    }\n    public void createNewConversation(String target)\n    {\n        deckAdapter.addItem(server.getConversation(target));\n    }\n\n    /**\n     * On conversation remove\n     */\n    @Override\n    public void onRemoveConversation(String target)\n    {\n        deckAdapter.removeItem(target);\n\n        if (deckAdapter.isSwitched()) {\n            switcher.showNext();\n            switcher.removeView(deckAdapter.getSwitchedView());\n            deckAdapter.setSwitched(null, null);\n        }\n    }\n\n    /**\n     * On topic change\n     */\n    public void onTopicChanged(String target)\n    {\n        String selected = server.getSelectedConversation();\n        if (selected.equals(target)) {\n            // onTopicChanged is only called for channels\n            Channel channel = (Channel) server.getConversation(selected);\n            StringBuilder sb = new StringBuilder();\n            sb.append(server.getTitle() + \" - \" + channel.getName());\n            if (!(channel.getTopic()).equals(\"\"))\n                sb.append(\" - \" + channel.getTopic());\n            ((TextView) findViewById(R.id.title)).setText(sb.toString());\n        }\n    }\n\n    /**\n     * On server status update\n     */\n    @Override\n    public void onStatusUpdate()\n    {\n        ((ImageView) findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\n        EditText input = (EditText) findViewById(R.id.input);\n\n        if (server.isConnected()) {\n            input.setEnabled(true);\n        } else {\n            input.setEnabled(false);\n\n            if (server.getStatus() == Status.CONNECTING) {\n                deckAdapter.clearConversations();\n                Conversation serverInfo = server.getConversation(ServerInfo.DEFAULT_NAME);\n                serverInfo.setHistorySize(historySize);\n                deckAdapter.addItem(serverInfo);\n                return;\n            }\n\n            // Service is not connected or initialized yet - See #54\n            if (binder == null || binder.getService() == null || binder.getService().getSettings() == null) {\n                return;\n            }\n\n            if (!binder.getService().getSettings().isReconnectEnabled()) {\n                AlertDialog.Builder builder = new AlertDialog.Builder(this);\n                builder.setMessage(getResources().getString(R.string.reconnect_after_disconnect, server.getTitle()))\n                .setCancelable(false)\n                .setPositiveButton(\"Yes\", new DialogInterface.OnClickListener() {\n                    @Override\n                    public void onClick(DialogInterface dialog, int id) {\n                        binder.getService().getConnection(server.getId()).setAutojoinChannels(\n                            server.getCurrentChannelNames()\n                        );\n                        server.clearConversations();\n                        deckAdapter.clearConversations();\n                        Conversation serverInfo = server.getConversation(ServerInfo.DEFAULT_NAME);\n                        serverInfo.setHistorySize(historySize);\n                        deckAdapter.addItem(serverInfo);\n                        binder.connect(server);\n                    }\n                })\n                .setNegativeButton(getString(R.string.negative_button), new DialogInterface.OnClickListener() {\n                    @Override\n                    public void onClick(DialogInterface dialog, int id) {\n                        dialog.cancel();\n                    }\n                });\n                AlertDialog alert = builder.create();\n                alert.show();\n            }\n        }\n    }\n\n    /**\n     * On key down\n     *\n     * XXX: As we only track the back key: Android >= 2.0 will call a method called onBackPressed()\n     */\n    @Override\n    public boolean onKeyDown(int keyCode, KeyEvent event)\n    {\n        if (keyCode == KeyEvent.KEYCODE_BACK && event.getRepeatCount() == 0) {\n            if (deckAdapter.isSwitched()) {\n                MessageListView canvas = (MessageListView) deckAdapter.getView(deckAdapter.getPositionByName(deckAdapter.getSwitchedName()), null, switcher);\n                canvas.setSwitched(false);\n                deckAdapter.setSwitched(null, null);\n                return true;\n            }\n        }\n        return super.onKeyDown(keyCode, event);\n    }\n\n    /**\n     * On key pressed (input line)\n     */\n    @Override\n    public boolean onKey(View view, int keyCode, KeyEvent event)\n    {\n        EditText input = (EditText) view;\n\n        if (keyCode == KeyEvent.KEYCODE_DPAD_UP && event.getAction() == KeyEvent.ACTION_DOWN) {\n            String message = scrollback.goBack();\n            if (message != null) {\n                input.setText(message);\n            }\n            return true;\n        }\n\n        if (keyCode == KeyEvent.KEYCODE_DPAD_DOWN && event.getAction() == KeyEvent.ACTION_DOWN) {\n            String message = scrollback.goForward();\n            if (message != null) {\n                input.setText(message);\n            }\n            return true;\n        }\n\n        // Nick completion\n        if (keyCode == KeyEvent.KEYCODE_SEARCH && event.getAction() == KeyEvent.ACTION_DOWN) {\n            String text = input.getText().toString();\n\n            if (text.length() <= 0) {\n                return true;\n            }\n\n            String[] tokens = text.split(\"[\\\\s,.-]+\");\n\n            if (tokens.length <= 0) {\n                return true;\n            }\n\n            String word = tokens[tokens.length - 1].toLowerCase();\n            tokens[tokens.length - 1] = null;\n\n            int begin   = input.getSelectionStart();\n            int end     = input.getSelectionEnd();\n            int cursor  = Math.min(begin, end);\n            int sel_end = Math.max(begin, end);\n\n            boolean in_selection = cursor != sel_end;\n\n            if (in_selection) {\n                word = text.substring(cursor, sel_end);\n            } else {\n                // use the word at the curent cursor position\n                while(true) {\n                    cursor -= 1;\n                    if (cursor <= 0 || text.charAt(cursor) == ' ') {\n                        break;\n                    }\n                }\n\n                if (cursor < 0) {\n                    cursor = 0;\n                }\n\n                if (text.charAt(cursor) == ' ') {\n                    cursor += 1;\n                }\n\n                sel_end = text.indexOf(' ', cursor);\n\n                if (sel_end == -1) {\n                    sel_end = text.length();\n                }\n\n                word = text.substring(cursor, sel_end);\n            }\n            // Log.d(\"Yaaic\", \"Trying to complete nick: \" + word);\n\n            Conversation conversationForUserList = deckAdapter.getItem(deck.getSelectedItemPosition());\n\n            String[] users = null;\n\n            if (conversationForUserList.getType() == Conversation.TYPE_CHANNEL) {\n                users = binder.getService().getConnection(server.getId()).getUsersAsStringArray(\n                    conversationForUserList.getName()\n                );\n            }\n\n            // go through users and add matches\n            if (users != null) {\n                List<Integer> result = new ArrayList<Integer>();\n\n                for (int i = 0; i < users.length; i++) {\n                    if (users[i].toLowerCase().startsWith(word)) {\n                        result.add(Integer.valueOf(i));\n                    }\n                }\n\n                if (result.size() == 1) {\n                    String text1 = users[result.get(0).intValue()];\n\n                    if (cursor == 0) {\n                        text1 += \":\";\n                    }\n\n                    text1 += \" \";\n                    input.getText().replace(cursor, sel_end, text1, 0, text1.length());\n                    int old = input.getInputType();\n                    input.setInputType(old | setInputTypeFlag);\n                } else if (result.size() > 0) {\n                    Intent intent  = new Intent(this, UsersActivity.class);\n                    String[] extra = new String[result.size()];\n                    int i = 0;\n\n                    for (Integer n : result) {\n                        extra[i++] = users[n.intValue()];\n                    }\n\n                    input.setSelection(cursor, sel_end);\n                    intent.putExtra(Extra.USERS, extra);\n                    startActivityForResult(intent, REQUEST_CODE_NICK_COMPLETION);\n                }\n            }\n            return true;\n        }\n\n        if (keyCode == KeyEvent.KEYCODE_ENTER && event.getAction() == KeyEvent.ACTION_DOWN) {\n            if (!server.isConnected()) {\n                Message message = new Message(getString(R.string.message_not_connected));\n                message.setColor(Message.COLOR_RED);\n                message.setIcon(R.drawable.error);\n                server.getConversation(server.getSelectedConversation()).addMessage(message);\n                onConversationMessage(server.getSelectedConversation());\n            }\n\n            String text = input.getText().toString();\n            input.setText(\"\");\n\n            if (text.equals(\"\")) {\n                // ignore empty messages\n                return true;\n            }\n\n            scrollback.addMessage(text);\n\n            Conversation conversation = deckAdapter.getItem(deck.getSelectedItemPosition());\n\n            if (conversation != null) {\n                if (!text.trim().startsWith(\"/\")) {\n                    if (conversation.getType() != Conversation.TYPE_SERVER) {\n                        String nickname = binder.getService().getConnection(serverId).getNick();\n                        //conversation.addMessage(new Message(\"<\" + nickname + \"> \" + text));\n                        conversation.addMessage(new Message(text, nickname));\n                        binder.getService().getConnection(serverId).sendMessage(conversation.getName(), text);\n                    } else {\n                        Message message = new Message(getString(R.string.chat_only_form_channel));\n                        message.setColor(Message.COLOR_YELLOW);\n                        message.setIcon(R.drawable.warning);\n                        conversation.addMessage(message);\n                    }\n                    onConversationMessage(conversation.getName());\n                } else {\n                    CommandParser.getInstance().parse(text, server, conversation, binder.getService());\n                }\n            }\n\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * On activity result\n     */\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent data)\n    {\n        if (resultCode != RESULT_OK) {\n            // ignore other result codes\n            return;\n        }\n\n        switch (requestCode) {\n            case REQUEST_CODE_SPEECH:\n                ArrayList<String> matches = data.getStringArrayListExtra(RecognizerIntent.EXTRA_RESULTS);\n                if (matches.size() > 0) {\n                    ((EditText) findViewById(R.id.input)).setText(matches.get(0));\n                }\n                break;\n            case REQUEST_CODE_JOIN:\n                joinChannelBuffer = data.getExtras().getString(\"channel\");\n                break;\n            case REQUEST_CODE_USERS:\n                Intent intent = new Intent(this, UserActivity.class);\n                intent.putExtra(Extra.USER, data.getStringExtra(Extra.USER));\n                startActivityForResult(intent, REQUEST_CODE_USER);\n                break;\n            case REQUEST_CODE_NICK_COMPLETION:\n                EditText input = (EditText) findViewById(R.id.input);\n                String src        = data.getExtras().getString(Extra.USER);\n                int start        = input.getSelectionStart();\n                int end        = input.getSelectionEnd();\n\n                if (start == 0) {\n                    src += \":\";\n                }\n\n                src += \" \";\n                input.getText().replace(start, end, src, 0, src.length());\n                // put cursor after inserted text\n                input.setSelection(start + src.length());\n                input.post(new Runnable() {\n                    @Override\n                    public void run() {\n                        // make the softkeyboard come up again (only if no hw keyboard is attached)\n                        EditText input = (EditText) findViewById(R.id.input);\n                        InputMethodManager mgr = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);\n                        mgr.showSoftInput(input, InputMethodManager.SHOW_IMPLICIT);\n                    }\n                });\n                input.requestFocus();\n                break;\n            case REQUEST_CODE_USER:\n                final int actionId = data.getExtras().getInt(Extra.ACTION);\n                final String nickname = data.getExtras().getString(Extra.USER);\n                final IRCConnection connection = binder.getService().getConnection(server.getId());\n                final String conversation = server.getSelectedConversation();\n                final Handler handler = new Handler();\n\n                // XXX: Implement me - The action should be handled after onResume()\n                //                     to catch the broadcasts... now we just wait a second\n                // Yes .. that's very ugly - we need some kind of queue that is handled after onResume()\n\n                new Thread() {\n                    @Override\n                    public void run() {\n                        try {\n                            Thread.sleep(1000);\n                        } catch (InterruptedException e) {\n                            // Do nothing\n                        }\n\n                        String nicknameWithoutPrefix = nickname;\n\n                        while (\n                            nicknameWithoutPrefix.startsWith(\"@\") ||\n                            nicknameWithoutPrefix.startsWith(\"+\") ||\n                            nicknameWithoutPrefix.startsWith(\".\") ||\n                            nicknameWithoutPrefix.startsWith(\"%\")\n                        ) {\n                            // Strip prefix(es) now\n                            nicknameWithoutPrefix = nicknameWithoutPrefix.substring(1);\n                        }\n\n                        switch (actionId) {\n                            case User.ACTION_REPLY:\n                                final String replyText = nicknameWithoutPrefix + \": \";\n                                handler.post(new Runnable() {\n                                    @Override\n                                    public void run() {\n                                        EditText input = (EditText) findViewById(R.id.input);\n                                        input.setText(replyText);\n                                        input.setSelection(replyText.length());\n                                    }\n                                });\n                                break;\n                            case User.ACTION_QUERY:\n                                Conversation query = server.getConversation(nicknameWithoutPrefix);\n                                if (query == null) {\n                                    // Open a query if there's none yet\n                                    query = new Query(nicknameWithoutPrefix);\n                                    query.setHistorySize(binder.getService().getSettings().getHistorySize());\n                                    server.addConversation(query);\n\n                                    Intent intent = Broadcast.createConversationIntent(\n                                        Broadcast.CONVERSATION_NEW,\n                                        server.getId(),\n                                        nicknameWithoutPrefix\n                                    );\n                                    binder.getService().sendBroadcast(intent);\n                                }\n                                break;\n                            case User.ACTION_OP:\n                                connection.op(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_DEOP:\n                                connection.deOp(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_VOICE:\n                                connection.voice(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_DEVOICE:\n                                connection.deVoice(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_KICK:\n                                connection.kick(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_BAN:\n                                connection.ban(conversation, nicknameWithoutPrefix + \"!*@*\");\n                                break;\n                        }\n                    }\n                }.start();\n\n                break;\n        }\n    }\n}\n","lineNo":547}
{"Smelly Sample":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2011 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage org.yaaic.irc;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Vector;\nimport java.util.regex.Pattern;\n\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.command.CommandParser;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Query;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.ServerInfo;\nimport org.yaaic.model.Status;\n\nimport android.content.Intent;\n\n/**\n * The class that actually handles the connection to an IRC server\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class IRCConnection extends PircBot\n{\n    private final IRCService service;\n    private final Server server;\n    private ArrayList<String> autojoinChannels;\n    private Pattern mNickMatch;\n\n    /**\n     * Create a new connection\n     * \n     * @param service\n     * @param serverId\n     */\n    public IRCConnection(IRCService service, int serverId)\n    {\n        this.server = Yaaic.getInstance().getServerById(serverId);\n        this.service = service;\n\n        // XXX: Should be configurable via settings\n        this.setAutoNickChange(true);\n\n        this.setFinger(\"http://www.youtube.com/watch?v=oHg5SJYRHA0\");\n        this.updateNickMatchPattern();\n    }\n\n    /**\n     * Set the nickname of the user\n     * \n     * @param nickname The nickname to use\n     */\n    public void setNickname(String nickname)\n    {\n        this.setName(nickname);\n        this.updateNickMatchPattern();\n    }\n\n    /**\n     * Set the real name of the user\n     * \n     * @param realname The realname to use\n     */\n    public void setRealName(String realname)\n    {\n        // XXX: Pircbot uses the version for \"real name\" and \"version\".\n        //      The real \"version\" value is provided by onVersion()\n        this.setVersion(realname);\n    }\n\n    /**\n     * Set channels to autojoin after connect\n     * \n     * @param channels\n     */\n    public void setAutojoinChannels(ArrayList<String> channels)\n    {\n        autojoinChannels = channels;\n    }\n\n    /**\n     * On version (CTCP version)\n     * \n     * This is a fix for pircbot as pircbot uses the version as \"real name\" and as \"version\"\n     */\n    @Override\n    protected void onVersion(String sourceNick, String sourceLogin,    String sourceHostname, String target)\n    {\n        this.sendRawLine(\n            \"NOTICE \" + sourceNick + \" :\\u0001VERSION \" +\n            \"Yaaic - Yet another Android IRC client - http://www.yaaic.org\" +\n            \"\\u0001\"\n        );\n    }\n\n    /**\n     * Set the ident of the user\n     * \n     * @param ident The ident to use\n     */\n    public void setIdent(String ident)\n    {\n        this.setLogin(ident);\n    }\n\n    /**\n     * On connect\n     */\n    @Override\n    public void onConnect()\n    {\n        server.setStatus(Status.CONNECTED);\n\n        service.sendBroadcast(\n            Broadcast.createServerIntent(Broadcast.SERVER_UPDATE, server.getId())\n        );\n\n        service.notifyConnected(server.getTitle());\n\n        Message message = new Message(service.getString(R.string.message_connected, server.getTitle()));\n        message.setColor(Message.COLOR_GREEN);\n        server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            ServerInfo.DEFAULT_NAME\n        );\n\n        service.sendBroadcast(intent);\n    }\n\n\n    /**\n     * On register\n     */\n    @Override\n    public void onRegister()\n    {\n        // Call parent method to ensure \"register\" status is tracked\n        super.onRegister();\n\n        // execute commands\n        CommandParser parser = CommandParser.getInstance();\n\n        this.updateNickMatchPattern();\n        for (String command : server.getConnectCommands()) {\n            parser.parse(command, server, server.getConversation(ServerInfo.DEFAULT_NAME), service);\n        }\n\n        // TODO: Detect \"You are now identified for <nick>\" notices from NickServ and handle\n        //       auto joins in onNotice instead if the user has chosen to wait for NickServ\n        //       identification before auto joining channels.\n\n        // delay 1 sec before auto joining channels\n        try {\n            Thread.sleep(1000);\n        } catch(InterruptedException e) {\n            // do nothing\n        }\n\n        // join channels\n        if (autojoinChannels != null) {\n            for (String channel : autojoinChannels) {\n                // Add support for channel keys\n                joinChannel(channel);\n            }\n        } else {\n            for (String channel : server.getAutoJoinChannels()) {\n                joinChannel(channel);\n            }\n        }\n    }\n    /**\n     * On channel action\n     */\n    @Override\n    protected void onAction(String sender, String login, String hostname, String target, String action)\n    {\n        Conversation conversation;\n\n        Message message = new Message(sender + \" \" + action);\n        message.setIcon(R.drawable.action);\n\n        String queryNick = target;\n        if (queryNick.equals(this.getNick())) {\n            // We are the target - this is an action in a query\n            queryNick = sender;\n        }\n        conversation = server.getConversation(queryNick);\n\n        if (conversation == null) {\n            // Open a query if there's none yet\n            conversation = new Query(queryNick);\n            server.addConversation(conversation);\n            conversation.addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_NEW,\n                server.getId(),\n                queryNick\n            );\n            service.sendBroadcast(intent);\n        } else {\n            conversation.addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                queryNick\n            );\n            service.sendBroadcast(intent);\n        }\n\n        if (sender.equals(this.getNick())) {\n           // Don't notify for something sent in our name\n           return;\n        }\n\n        boolean mentioned = isMentioned(action);\n        if (mentioned || target.equals(this.getNick())) {\n            if (conversation.getStatus() != Conversation.STATUS_SELECTED || !server.getIsForeground()) {\n                service.addNewMention(\n                    conversation,\n                    conversation.getName() + \": \" + sender + \" \" + action,\n                    service.getSettings().isVibrateHighlightEnabled(),\n                    service.getSettings().isSoundHighlightEnabled()\n                );\n            }\n        }\n\n        if (mentioned) {\n            // highlight\n            message.setColor(Message.COLOR_RED);\n            conversation.setStatus(Conversation.STATUS_HIGHLIGHT);\n        }\n    }\n\n    /**\n     * On Channel Info\n     */\n    @Override\n    protected void onChannelInfo(String channel, int userCount, String topic)\n    {\n    }\n\n    /**\n     * On Deop\n     */\n    @Override\n    protected void onDeop(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n    {\n        Message message = new Message(service.getString(R.string.message_deop, sourceNick, recipient));\n        message.setIcon(R.drawable.op);\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On DeVoice\n     */\n    @Override\n    protected void onDeVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n    {\n        Message message = new Message(service.getString(R.string.message_devoice, sourceNick, recipient));\n        message.setColor(Message.COLOR_BLUE);\n        message.setIcon(R.drawable.voice);\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On Invite\n     */\n    @Override\n    protected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String target)\n    {\n        if (targetNick.equals(this.getNick())) {\n            // We are invited\n            Message message = new Message(service.getString(R.string.message_invite_you, sourceNick, target));\n            server.getConversation(server.getSelectedConversation()).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                server.getSelectedConversation()\n            );\n            service.sendBroadcast(intent);\n        } else {\n            // Someone is invited\n            Message message = new Message(service.getString(R.string.message_invite_someone, sourceNick, targetNick, target));\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Join\n     */\n    @Override\n    protected void onJoin(String target, String sender, String login, String hostname)\n    {\n        if (sender.equalsIgnoreCase(getNick())) {\n            // We joined a new channel\n            server.addConversation(new Channel(target));\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_NEW,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        } else if (service.getSettings().showJoinPartAndQuit()) {\n            Message message = new Message(\n                service.getString(R.string.message_join, sender),\n                Message.TYPE_MISC\n            );\n\n            message.setIcon(R.drawable.join);\n            message.setColor(Message.COLOR_GREEN);\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Kick\n     */\n    @Override\n    protected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n    {\n        if (recipientNick.equals(getNick())) {\n            // We are kicked\n            server.removeConversation(target);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_REMOVE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        } else {\n            Message message = new Message(service.getString(R.string.message_kick, kickerNick, recipientNick));\n            message.setColor(Message.COLOR_GREEN);\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Message\n     */\n    @Override\n    protected void onMessage(String target, String sender, String login, String hostname, String text)\n    {\n        Message message = new Message(text, sender);\n        Conversation conversation = server.getConversation(target);\n\n        if (isMentioned(text)) {\n            // highlight\n            message.setColor(Message.COLOR_RED);\n            if (conversation.getStatus() != Conversation.STATUS_SELECTED || !server.getIsForeground()) {\n                service.addNewMention(\n                    conversation,\n                    target + \": <\" + sender + \"> \" + text,\n                    service.getSettings().isVibrateHighlightEnabled(),\n                    service.getSettings().isSoundHighlightEnabled()\n                );\n            }\n\n            conversation.setStatus(Conversation.STATUS_HIGHLIGHT);\n        }\n\n        conversation.addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On Mode\n     */\n    @Override\n    protected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n    {\n        // Disabled as it doubles events (e.g. onOp and onMode will be called)\n\n        /*\n        Message message = new Message(sourceNick + \" sets mode \" + mode);\n        server.getChannel(target).addMessage(message);\n\n        Intent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n        intent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n        intent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n        service.sendBroadcast(intent);\n         */\n    }\n\n    /**\n     * On Nick Change\n     */\n    @Override\n    protected void onNickChange(String oldNick, String login, String hostname, String newNick)\n    {\n        if (getNick().equalsIgnoreCase(newNick)) {\n            this.updateNickMatchPattern();\n\n            // Send message about own change to server info window\n            Message message = new Message(service.getString(R.string.message_self_rename, newNick));\n            message.setColor(Message.COLOR_GREEN);\n            server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                ServerInfo.DEFAULT_NAME\n            );\n\n            service.sendBroadcast(intent);\n        }\n\n        Vector<String> channels = getChannelsByNickname(newNick);\n\n        for (String target : channels) {\n            Message message = new Message(service.getString(R.string.message_rename, oldNick, newNick));\n            message.setColor(Message.COLOR_GREEN);\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Notice\n     */\n    @Override\n    protected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n    {\n        // Post notice to currently selected conversation\n        Conversation conversation;\n\n        if (service.getSettings().showNoticeInServerWindow()) {\n            conversation = server.getConversation(ServerInfo.DEFAULT_NAME);\n        } else {\n            conversation = server.getConversation(server.getSelectedConversation());\n\n            if (conversation == null) {\n                // Fallback: Use ServerInfo view\n                conversation = server.getConversation(ServerInfo.DEFAULT_NAME);\n            }\n        }\n\n        Message message = new Message(\"-\" + sourceNick + \"- \" + notice);\n        message.setIcon(R.drawable.info);\n        conversation.addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            conversation.getName()\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On Op\n     */\n    @Override\n    protected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n    {\n        Message message = new Message(service.getString(R.string.message_op, sourceNick, recipient));\n        message.setColor(Message.COLOR_BLUE);\n        message.setIcon(R.drawable.op);\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On Part\n     */\n    @Override\n    protected void onPart(String target, String sender, String login, String hostname)\n    {\n        if (sender.equals(getNick())) {\n            // We parted a channel\n            server.removeConversation(target);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_REMOVE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        } else if (service.getSettings().showJoinPartAndQuit()) {\n            Message message = new Message(\n                service.getString(R.string.message_part, sender),\n                Message.TYPE_MISC\n            );\n\n            message.setColor(Message.COLOR_GREEN);\n            message.setIcon(R.drawable.part);\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Private Message\n     */\n    @Override\n    protected void onPrivateMessage(String sender, String login, String hostname, String target, String text)\n    {\n        Message message = new Message(\"<\" + sender + \"> \" + text);\n        String queryNick = sender;\n\n        if (queryNick.equals(this.getNick())) {\n            queryNick = target;\n        }\n        Conversation conversation = server.getConversation(queryNick);\n\n        if (conversation == null) {\n            // Open a query if there's none yet\n            conversation = new Query(queryNick);\n            conversation.addMessage(message);\n            server.addConversation(conversation);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_NEW,\n                server.getId(),\n                queryNick\n            );\n            service.sendBroadcast(intent);\n        } else {\n            conversation.addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                queryNick\n            );\n            service.sendBroadcast(intent);\n        }\n\n        if (sender.equals(this.getNick())) {\n            // Don't notify for something sent in our name\n            return;\n        }\n\n        if (conversation.getStatus() != Conversation.STATUS_SELECTED || !server.getIsForeground()) {\n            service.addNewMention(\n                conversation,\n                \"<\" + sender + \"> \" + text,\n                service.getSettings().isVibrateHighlightEnabled(),\n                service.getSettings().isSoundHighlightEnabled()\n            );\n        }\n\n        if (isMentioned(text)) {\n            message.setColor(Message.COLOR_RED);\n            conversation.setStatus(Conversation.STATUS_HIGHLIGHT);\n        }\n    }\n\n    /**\n     * On Quit\n     */\n    @Override\n    protected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n    {\n        if (sourceNick.equals(this.getNick())) {\n            return;\n        }\n\n        if (service.getSettings().showJoinPartAndQuit()) {\n            Vector<String> channels = getChannelsByNickname(sourceNick);\n\n            for (String target : channels) {\n                Message message = new Message(\n                    service.getString(R.string.message_quit, sourceNick, reason),\n                    Message.TYPE_MISC\n                );\n\n                message.setColor(Message.COLOR_GREEN);\n                message.setIcon(R.drawable.quit);\n                server.getConversation(target).addMessage(message);\n\n                Intent intent = Broadcast.createConversationIntent(\n                    Broadcast.CONVERSATION_MESSAGE,\n                    server.getId(),\n                    target\n                );\n                service.sendBroadcast(intent);\n            }\n\n            // Look if there's a query to update\n            Conversation conversation = server.getConversation(sourceNick);\n\n            if (conversation != null) {\n                Message message = new Message(\n                    service.getString(R.string.message_quit, sourceNick, reason),\n                    Message.TYPE_MISC\n                );\n\n                message.setColor(Message.COLOR_GREEN);\n                message.setIcon(R.drawable.quit);\n                conversation.addMessage(message);\n\n                Intent intent = Broadcast.createConversationIntent(\n                    Broadcast.CONVERSATION_MESSAGE,\n                    server.getId(),\n                    conversation.getName()\n                );\n                service.sendBroadcast(intent);\n            }\n        }\n    }\n\n    /**\n     * On Topic\n     */\n    @Override\n    public void onTopic(String target, String topic, String setBy, long date, boolean changed)\n    {\n        if (changed) {\n            Message message = new Message(service.getString(R.string.message_topic_set, setBy, topic));\n            message.setColor(Message.COLOR_YELLOW);\n            server.getConversation(target).addMessage(message);\n        } else {\n            Message message = new Message(service.getString(R.string.message_topic, topic));\n            message.setColor(Message.COLOR_YELLOW);\n            server.getConversation(target).addMessage(message);\n        }\n\n        // remember channel's topic\n        ((Channel) server.getConversation(target)).setTopic(topic);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On User List\n     */\n    @Override\n    protected void onUserList(String channel, User[] users)\n    {\n        // XXX: Store user list somewhere and keep it updated or just broadcast some event?\n    }\n\n    /**\n     * On Voice\n     */\n    @Override\n    protected void onVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n    {\n        Message message = new Message(service.getString(R.string.message_voice, sourceNick, recipient));\n        message.setIcon(R.drawable.voice);\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n\n        // update the displayed conversation title if necessary\n        intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_TOPIC,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On remove channel key\n     */\n    @Override\n    protected void onRemoveChannelKey(String target, String sourceNick, String sourceLogin, String sourceHostname, String key)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_channel_key, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set channel key\n     */\n    @Override\n    protected void onSetChannelKey(String target, String sourceNick, String sourceLogin, String sourceHostname, String key)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_key, sourceNick, key));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set secret\n     */\n    @Override\n    protected void onSetSecret(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_secret, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove secret\n     */\n    @Override\n    protected void onRemoveSecret(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_public, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set channel limit\n     */\n    @Override\n    protected void onSetChannelLimit(String target, String sourceNick, String sourceLogin, String sourceHostname, int limit)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_limit, sourceNick, limit));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove channel limit\n     */\n    @Override\n    protected void onRemoveChannelLimit(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_channel_limit, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set channel ban\n     */\n    @Override\n    protected void onSetChannelBan(String target, String sourceNick, String sourceLogin, String sourceHostname, String hostmask)\n    {\n        Message message = new Message(service.getString(R.string.message_set_ban, sourceNick, hostmask));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove channel ban\n     */\n    @Override\n    protected void onRemoveChannelBan(String target, String sourceNick, String sourceLogin, String sourceHostname, String hostmask)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_ban, sourceNick, hostmask));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set topic protection\n     */\n    @Override\n    protected void onSetTopicProtection(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_topic_protection, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove topic protection\n     */\n    @Override\n    protected void onRemoveTopicProtection(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_topic_protection, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set no external messages\n     */\n    @Override\n    protected void onSetNoExternalMessages(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_disable_external, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove no external messages\n     */\n    @Override\n    protected void onRemoveNoExternalMessages(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_enable_external, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set invite only\n     */\n    @Override\n    protected void onSetInviteOnly(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_invite_only, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove invite only\n     */\n    @Override\n    protected void onRemoveInviteOnly(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_invite_only, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set moderated\n     */\n    @Override\n    protected void onSetModerated(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_moderated, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove moderated\n     */\n    @Override\n    protected void onRemoveModerated(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_moderated, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set private\n     */\n    @Override\n    protected void onSetPrivate(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_private, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove private\n     */\n    @Override\n    protected void onRemovePrivate(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_public, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On unknown\n     */\n    @Override\n    protected void onUnknown(String line)\n    {\n        Message message = new Message(line);\n        message.setIcon(R.drawable.action);\n        message.setColor(Message.COLOR_GREY);\n        server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            ServerInfo.DEFAULT_NAME\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On server response\n     */\n    @Override\n    protected void onServerResponse(int code, String response)\n    {\n        if (code == 4) {\n            // User has registered with the server\n            onRegister();\n            return;\n        }\n        if (code == 372 || code == 375 || code == 376) {\n            // Skip MOTD\n            return;\n        }\n\n        if (code >= 200 && code < 300) {\n            // Skip 2XX responses\n            return;\n        }\n\n        if (code == 353 || code == 366 || code == 332 || code == 333) {\n            return;\n        }\n\n        if (code < 10) {\n            // Skip server info\n            return;\n        }\n\n        // Currently disabled... to much text\n        Message message = new Message(response);\n        message.setColor(Message.COLOR_GREY);\n        server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            ServerInfo.DEFAULT_NAME\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On disconnect\n     */\n    @Override\n    public void onDisconnect()\n    {\n        // Call parent method to ensure \"register\" status is tracked\n        super.onDisconnect();\n\n        if (service.getSettings().isReconnectEnabled() && server.getStatus() != Status.DISCONNECTED) {\n            setAutojoinChannels(server.getCurrentChannelNames());\n\n            server.clearConversations();\n            server.setStatus(Status.CONNECTING);\n            service.connect(server);\n        } else {\n            server.setStatus(Status.DISCONNECTED);\n        }\n\n        service.notifyDisconnected(server.getTitle());\n\n        Intent sIntent = Broadcast.createServerIntent(Broadcast.SERVER_UPDATE, server.getId());\n        service.sendBroadcast(sIntent);\n\n        Collection<Conversation> conversations = server.getConversations();\n\n        for (Conversation conversation : conversations) {\n            Message message = new Message(service.getString(R.string.message_disconnected));\n            message.setIcon(R.drawable.error);\n            message.setColor(Message.COLOR_RED);\n            server.getConversation(conversation.getName()).addMessage(message);\n\n            Intent cIntent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                conversation.getName()\n            );\n            service.sendBroadcast(cIntent);\n        }\n    }\n\n    /**\n     * Get all channels where the user with the given nickname is online\n     * \n     * @param nickname\n     * @return Array of channel names\n     */\n    private Vector<String> getChannelsByNickname(String nickname)\n    {\n        Vector<String> channels = new Vector<String>();\n        String[] channelArray = getChannels();\n\n        for (String channel : channelArray) {\n            User[] userArray = getUsers(channel);\n            for (User user : userArray) {\n                if (user.getNick().equals(nickname)) {\n                    channels.add(channel);\n                    break;\n                }\n            }\n        }\n\n        return channels;\n    }\n\n    /**\n     * Get list of users in a channel as array of strings\n     * \n     * @param channel Name of the channel\n     */\n    public String[] getUsersAsStringArray(String channel)\n    {\n        User[] userArray = getUsers(channel);\n        int mLength = userArray.length;\n        String[] users = new String[mLength];\n\n        for (int i = 0; i < mLength; i++) {\n            users[i] = userArray[i].getPrefix() + userArray[i].getNick();\n        }\n\n        return users;\n    }\n\n    /**\n     * Get a user by channel and nickname\n     * \n     * @param channel The channel the user is in\n     * @param nickname The nickname of the user (with or without prefix)\n     * @return the User object or null if user was not found\n     */\n    public User getUser(String channel, String nickname)\n    {\n        User[] users = getUsers(channel);\n        int mLength = users.length;\n\n        for (int i = 0; i < mLength; i++) {\n            if (nickname.equals(users[i].getNick())) {\n                return users[i];\n            }\n            if (nickname.equals(users[i].getPrefix() + users[i].getNick())) {\n                return users[i];\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Quits from the IRC server with default reason.\n     */\n    @Override\n    public void quitServer()\n    {\n        new Thread() {\n            @Override\n            public void run() {\n                quitServer(service.getSettings().getQuitMessage());\n            }\n        }.start();\n    }\n\n    /**\n     * Check whether the nickname has been mentioned.\n     * \n     * @param text The text to check for the nickname\n     * @return true if nickname was found, otherwise false\n     */\n    public boolean isMentioned(String text)\n    {\n        return mNickMatch.matcher(text).find();\n    }\n\n    /**\n     * Update the nick matching pattern, should be called when the nickname changes.\n     */\n    private void updateNickMatchPattern()\n    {\n        mNickMatch = Pattern.compile(\"(?:^|[\\\\s?!'�:;,.])\"+Pattern.quote(getNick())+\"(?:[\\\\s?!'�:;,.]|$)\", Pattern.CASE_INSENSITIVE);\n    }\n}\n","Method after Refactoring":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2011 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage org.yaaic.irc;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Vector;\nimport java.util.regex.Pattern;\n\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.command.CommandParser;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Query;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.ServerInfo;\nimport org.yaaic.model.Status;\n\nimport android.content.Intent;\n\n/**\n * The class that actually handles the connection to an IRC server\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class IRCConnection extends PircBot\n{\n    private final IRCService service;\n    private final Server server;\n    private ArrayList<String> autojoinChannels;\n    private Pattern mNickMatch;\n\n    /**\n     * Create a new connection\n     * \n     * @param service\n     * @param serverId\n     */\n    public IRCConnection(IRCService service, int serverId)\n    {\n        this.server = Yaaic.getInstance().getServerById(serverId);\n        this.service = service;\n\n        // XXX: Should be configurable via settings\n        this.setAutoNickChange(true);\n\n        this.setFinger(\"http://www.youtube.com/watch?v=oHg5SJYRHA0\");\n        this.updateNickMatchPattern();\n    }\n\n    /**\n     * Set the nickname of the user\n     * \n     * @param nickname The nickname to use\n     */\n    public void setNickname(String nickname)\n    {\n        this.setName(nickname);\n        this.updateNickMatchPattern();\n    }\n\n    /**\n     * Set the real name of the user\n     * \n     * @param realname The realname to use\n     */\n    public void setRealName(String realname)\n    {\n        // XXX: Pircbot uses the version for \"real name\" and \"version\".\n        //      The real \"version\" value is provided by onVersion()\n        this.setVersion(realname);\n    }\n\n    /**\n     * Set channels to autojoin after connect\n     * \n     * @param channels\n     */\n    public void setAutojoinChannels(ArrayList<String> channels)\n    {\n        autojoinChannels = channels;\n    }\n\n    /**\n     * On version (CTCP version)\n     * \n     * This is a fix for pircbot as pircbot uses the version as \"real name\" and as \"version\"\n     */\n    @Override\n    protected void onVersion(String sourceNick, String sourceLogin,    String sourceHostname, String target)\n    {\n        this.sendRawLine(\n            \"NOTICE \" + sourceNick + \" :\\u0001VERSION \" +\n            \"Yaaic - Yet another Android IRC client - http://www.yaaic.org\" +\n            \"\\u0001\"\n        );\n    }\n\n    /**\n     * Set the ident of the user\n     * \n     * @param ident The ident to use\n     */\n    public void setIdent(String ident)\n    {\n        this.setLogin(ident);\n    }\n\n    /**\n     * On connect\n     */\n    @Override\n    public void onConnect()\n    {\n        server.setStatus(Status.CONNECTED);\n\n        service.sendBroadcast(\n            Broadcast.createServerIntent(Broadcast.SERVER_UPDATE, server.getId())\n        );\n\n        service.notifyConnected(server.getTitle());\n\n        Message message = new Message(service.getString(R.string.message_connected, server.getTitle()));\n        message.setColor(Message.COLOR_GREEN);\n        server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            ServerInfo.DEFAULT_NAME\n        );\n\n        service.sendBroadcast(intent);\n    }\n\n\n    /**\n     * On register\n     */\n    @Override\n    public void onRegister()\n    {\n        // Call parent method to ensure \"register\" status is tracked\n        super.onRegister();\n\n        // execute commands\n        CommandParser parser = CommandParser.getInstance();\n\n        this.updateNickMatchPattern();\n        for (String command : server.getConnectCommands()) {\n            parser.parse(command, server, server.getConversation(ServerInfo.DEFAULT_NAME), service);\n        }\n\n        // TODO: Detect \"You are now identified for <nick>\" notices from NickServ and handle\n        //       auto joins in onNotice instead if the user has chosen to wait for NickServ\n        //       identification before auto joining channels.\n\n        // delay 1 sec before auto joining channels\n        try {\n            Thread.sleep(1000);\n        } catch(InterruptedException e) {\n            // do nothing\n        }\n\n        // join channels\n        if (autojoinChannels != null) {\n            for (String channel : autojoinChannels) {\n                // Add support for channel keys\n                joinChannel(channel);\n            }\n        } else {\n            for (String channel : server.getAutoJoinChannels()) {\n                joinChannel(channel);\n            }\n        }\n    }\n    /**\n     * On channel action\n     */\n    @Override\n    protected void onAction(String sender, String login, String hostname, String target, String action)\n    {\n        Conversation conversation;\n\n        Message message = new Message(sender + \" \" + action);\n        message.setIcon(R.drawable.action);\n\n        String queryNick = target;\n        if (queryNick.equals(this.getNick())) {\n            // We are the target - this is an action in a query\n            queryNick = sender;\n        }\n        conversation = server.getConversation(queryNick);\n\n        if (conversation == null) {\n            // Open a query if there's none yet\n            conversation = new Query(queryNick);\n            conversation.setHistorySize(service.getSettings().getHistorySize());\n            server.addConversation(conversation);\n            conversation.addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_NEW,\n                server.getId(),\n                queryNick\n            );\n            service.sendBroadcast(intent);\n        } else {\n            conversation.addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                queryNick\n            );\n            service.sendBroadcast(intent);\n        }\n\n        if (sender.equals(this.getNick())) {\n           // Don't notify for something sent in our name\n           return;\n        }\n\n        boolean mentioned = isMentioned(action);\n        if (mentioned || target.equals(this.getNick())) {\n            if (conversation.getStatus() != Conversation.STATUS_SELECTED || !server.getIsForeground()) {\n                service.addNewMention(\n                    conversation,\n                    conversation.getName() + \": \" + sender + \" \" + action,\n                    service.getSettings().isVibrateHighlightEnabled(),\n                    service.getSettings().isSoundHighlightEnabled()\n                );\n            }\n        }\n\n        if (mentioned) {\n            // highlight\n            message.setColor(Message.COLOR_RED);\n            conversation.setStatus(Conversation.STATUS_HIGHLIGHT);\n        }\n    }\n\n    /**\n     * On Channel Info\n     */\n    @Override\n    protected void onChannelInfo(String channel, int userCount, String topic)\n    {\n    }\n\n    /**\n     * On Deop\n     */\n    @Override\n    protected void onDeop(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n    {\n        Message message = new Message(service.getString(R.string.message_deop, sourceNick, recipient));\n        message.setIcon(R.drawable.op);\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On DeVoice\n     */\n    @Override\n    protected void onDeVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n    {\n        Message message = new Message(service.getString(R.string.message_devoice, sourceNick, recipient));\n        message.setColor(Message.COLOR_BLUE);\n        message.setIcon(R.drawable.voice);\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On Invite\n     */\n    @Override\n    protected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String target)\n    {\n        if (targetNick.equals(this.getNick())) {\n            // We are invited\n            Message message = new Message(service.getString(R.string.message_invite_you, sourceNick, target));\n            server.getConversation(server.getSelectedConversation()).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                server.getSelectedConversation()\n            );\n            service.sendBroadcast(intent);\n        } else {\n            // Someone is invited\n            Message message = new Message(service.getString(R.string.message_invite_someone, sourceNick, targetNick, target));\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Join\n     */\n    @Override\n    protected void onJoin(String target, String sender, String login, String hostname)\n    {\n        if (sender.equalsIgnoreCase(getNick())) {\n            // We joined a new channel\n            Conversation conversation = new Channel(target);\n            conversation.setHistorySize(service.getSettings().getHistorySize());\n            server.addConversation(conversation);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_NEW,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        } else if (service.getSettings().showJoinPartAndQuit()) {\n            Message message = new Message(\n                service.getString(R.string.message_join, sender),\n                Message.TYPE_MISC\n            );\n\n            message.setIcon(R.drawable.join);\n            message.setColor(Message.COLOR_GREEN);\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Kick\n     */\n    @Override\n    protected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n    {\n        if (recipientNick.equals(getNick())) {\n            // We are kicked\n            server.removeConversation(target);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_REMOVE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        } else {\n            Message message = new Message(service.getString(R.string.message_kick, kickerNick, recipientNick));\n            message.setColor(Message.COLOR_GREEN);\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Message\n     */\n    @Override\n    protected void onMessage(String target, String sender, String login, String hostname, String text)\n    {\n        Message message = new Message(text, sender);\n        Conversation conversation = server.getConversation(target);\n\n        if (isMentioned(text)) {\n            // highlight\n            message.setColor(Message.COLOR_RED);\n            if (conversation.getStatus() != Conversation.STATUS_SELECTED || !server.getIsForeground()) {\n                service.addNewMention(\n                    conversation,\n                    target + \": <\" + sender + \"> \" + text,\n                    service.getSettings().isVibrateHighlightEnabled(),\n                    service.getSettings().isSoundHighlightEnabled()\n                );\n            }\n\n            conversation.setStatus(Conversation.STATUS_HIGHLIGHT);\n        }\n\n        conversation.addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On Mode\n     */\n    @Override\n    protected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n    {\n        // Disabled as it doubles events (e.g. onOp and onMode will be called)\n\n        /*\n        Message message = new Message(sourceNick + \" sets mode \" + mode);\n        server.getChannel(target).addMessage(message);\n\n        Intent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n        intent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n        intent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n        service.sendBroadcast(intent);\n         */\n    }\n\n    /**\n     * On Nick Change\n     */\n    @Override\n    protected void onNickChange(String oldNick, String login, String hostname, String newNick)\n    {\n        if (getNick().equalsIgnoreCase(newNick)) {\n            this.updateNickMatchPattern();\n\n            // Send message about own change to server info window\n            Message message = new Message(service.getString(R.string.message_self_rename, newNick));\n            message.setColor(Message.COLOR_GREEN);\n            server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                ServerInfo.DEFAULT_NAME\n            );\n\n            service.sendBroadcast(intent);\n        }\n\n        Vector<String> channels = getChannelsByNickname(newNick);\n\n        for (String target : channels) {\n            Message message = new Message(service.getString(R.string.message_rename, oldNick, newNick));\n            message.setColor(Message.COLOR_GREEN);\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Notice\n     */\n    @Override\n    protected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n    {\n        // Post notice to currently selected conversation\n        Conversation conversation;\n\n        if (service.getSettings().showNoticeInServerWindow()) {\n            conversation = server.getConversation(ServerInfo.DEFAULT_NAME);\n        } else {\n            conversation = server.getConversation(server.getSelectedConversation());\n\n            if (conversation == null) {\n                // Fallback: Use ServerInfo view\n                conversation = server.getConversation(ServerInfo.DEFAULT_NAME);\n            }\n        }\n\n        Message message = new Message(\"-\" + sourceNick + \"- \" + notice);\n        message.setIcon(R.drawable.info);\n        conversation.addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            conversation.getName()\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On Op\n     */\n    @Override\n    protected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n    {\n        Message message = new Message(service.getString(R.string.message_op, sourceNick, recipient));\n        message.setColor(Message.COLOR_BLUE);\n        message.setIcon(R.drawable.op);\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On Part\n     */\n    @Override\n    protected void onPart(String target, String sender, String login, String hostname)\n    {\n        if (sender.equals(getNick())) {\n            // We parted a channel\n            server.removeConversation(target);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_REMOVE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        } else if (service.getSettings().showJoinPartAndQuit()) {\n            Message message = new Message(\n                service.getString(R.string.message_part, sender),\n                Message.TYPE_MISC\n            );\n\n            message.setColor(Message.COLOR_GREEN);\n            message.setIcon(R.drawable.part);\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Private Message\n     */\n    @Override\n    protected void onPrivateMessage(String sender, String login, String hostname, String target, String text)\n    {\n        Message message = new Message(\"<\" + sender + \"> \" + text);\n        String queryNick = sender;\n\n        if (queryNick.equals(this.getNick())) {\n            queryNick = target;\n        }\n        Conversation conversation = server.getConversation(queryNick);\n\n        if (conversation == null) {\n            // Open a query if there's none yet\n            conversation = new Query(queryNick);\n            conversation.setHistorySize(service.getSettings().getHistorySize());\n            conversation.addMessage(message);\n            server.addConversation(conversation);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_NEW,\n                server.getId(),\n                queryNick\n            );\n            service.sendBroadcast(intent);\n        } else {\n            conversation.addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                queryNick\n            );\n            service.sendBroadcast(intent);\n        }\n\n        if (sender.equals(this.getNick())) {\n            // Don't notify for something sent in our name\n            return;\n        }\n\n        if (conversation.getStatus() != Conversation.STATUS_SELECTED || !server.getIsForeground()) {\n            service.addNewMention(\n                conversation,\n                \"<\" + sender + \"> \" + text,\n                service.getSettings().isVibrateHighlightEnabled(),\n                service.getSettings().isSoundHighlightEnabled()\n            );\n        }\n\n        if (isMentioned(text)) {\n            message.setColor(Message.COLOR_RED);\n            conversation.setStatus(Conversation.STATUS_HIGHLIGHT);\n        }\n    }\n\n    /**\n     * On Quit\n     */\n    @Override\n    protected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n    {\n        if (sourceNick.equals(this.getNick())) {\n            return;\n        }\n\n        if (service.getSettings().showJoinPartAndQuit()) {\n            Vector<String> channels = getChannelsByNickname(sourceNick);\n\n            for (String target : channels) {\n                Message message = new Message(\n                    service.getString(R.string.message_quit, sourceNick, reason),\n                    Message.TYPE_MISC\n                );\n\n                message.setColor(Message.COLOR_GREEN);\n                message.setIcon(R.drawable.quit);\n                server.getConversation(target).addMessage(message);\n\n                Intent intent = Broadcast.createConversationIntent(\n                    Broadcast.CONVERSATION_MESSAGE,\n                    server.getId(),\n                    target\n                );\n                service.sendBroadcast(intent);\n            }\n\n            // Look if there's a query to update\n            Conversation conversation = server.getConversation(sourceNick);\n\n            if (conversation != null) {\n                Message message = new Message(\n                    service.getString(R.string.message_quit, sourceNick, reason),\n                    Message.TYPE_MISC\n                );\n\n                message.setColor(Message.COLOR_GREEN);\n                message.setIcon(R.drawable.quit);\n                conversation.addMessage(message);\n\n                Intent intent = Broadcast.createConversationIntent(\n                    Broadcast.CONVERSATION_MESSAGE,\n                    server.getId(),\n                    conversation.getName()\n                );\n                service.sendBroadcast(intent);\n            }\n        }\n    }\n\n    /**\n     * On Topic\n     */\n    @Override\n    public void onTopic(String target, String topic, String setBy, long date, boolean changed)\n    {\n        if (changed) {\n            Message message = new Message(service.getString(R.string.message_topic_set, setBy, topic));\n            message.setColor(Message.COLOR_YELLOW);\n            server.getConversation(target).addMessage(message);\n        } else {\n            Message message = new Message(service.getString(R.string.message_topic, topic));\n            message.setColor(Message.COLOR_YELLOW);\n            server.getConversation(target).addMessage(message);\n        }\n\n        // remember channel's topic\n        ((Channel) server.getConversation(target)).setTopic(topic);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On User List\n     */\n    @Override\n    protected void onUserList(String channel, User[] users)\n    {\n        // XXX: Store user list somewhere and keep it updated or just broadcast some event?\n    }\n\n    /**\n     * On Voice\n     */\n    @Override\n    protected void onVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n    {\n        Message message = new Message(service.getString(R.string.message_voice, sourceNick, recipient));\n        message.setIcon(R.drawable.voice);\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n\n        // update the displayed conversation title if necessary\n        intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_TOPIC,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On remove channel key\n     */\n    @Override\n    protected void onRemoveChannelKey(String target, String sourceNick, String sourceLogin, String sourceHostname, String key)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_channel_key, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set channel key\n     */\n    @Override\n    protected void onSetChannelKey(String target, String sourceNick, String sourceLogin, String sourceHostname, String key)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_key, sourceNick, key));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set secret\n     */\n    @Override\n    protected void onSetSecret(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_secret, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove secret\n     */\n    @Override\n    protected void onRemoveSecret(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_public, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set channel limit\n     */\n    @Override\n    protected void onSetChannelLimit(String target, String sourceNick, String sourceLogin, String sourceHostname, int limit)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_limit, sourceNick, limit));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove channel limit\n     */\n    @Override\n    protected void onRemoveChannelLimit(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_channel_limit, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set channel ban\n     */\n    @Override\n    protected void onSetChannelBan(String target, String sourceNick, String sourceLogin, String sourceHostname, String hostmask)\n    {\n        Message message = new Message(service.getString(R.string.message_set_ban, sourceNick, hostmask));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove channel ban\n     */\n    @Override\n    protected void onRemoveChannelBan(String target, String sourceNick, String sourceLogin, String sourceHostname, String hostmask)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_ban, sourceNick, hostmask));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set topic protection\n     */\n    @Override\n    protected void onSetTopicProtection(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_topic_protection, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove topic protection\n     */\n    @Override\n    protected void onRemoveTopicProtection(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_topic_protection, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set no external messages\n     */\n    @Override\n    protected void onSetNoExternalMessages(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_disable_external, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove no external messages\n     */\n    @Override\n    protected void onRemoveNoExternalMessages(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_enable_external, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set invite only\n     */\n    @Override\n    protected void onSetInviteOnly(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_invite_only, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove invite only\n     */\n    @Override\n    protected void onRemoveInviteOnly(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_invite_only, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set moderated\n     */\n    @Override\n    protected void onSetModerated(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_moderated, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove moderated\n     */\n    @Override\n    protected void onRemoveModerated(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_moderated, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set private\n     */\n    @Override\n    protected void onSetPrivate(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_private, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove private\n     */\n    @Override\n    protected void onRemovePrivate(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_public, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On unknown\n     */\n    @Override\n    protected void onUnknown(String line)\n    {\n        Message message = new Message(line);\n        message.setIcon(R.drawable.action);\n        message.setColor(Message.COLOR_GREY);\n        server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            ServerInfo.DEFAULT_NAME\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On server response\n     */\n    @Override\n    protected void onServerResponse(int code, String response)\n    {\n        if (code == 4) {\n            // User has registered with the server\n            onRegister();\n            return;\n        }\n        if (code == 372 || code == 375 || code == 376) {\n            // Skip MOTD\n            return;\n        }\n\n        if (code >= 200 && code < 300) {\n            // Skip 2XX responses\n            return;\n        }\n\n        if (code == 353 || code == 366 || code == 332 || code == 333) {\n            return;\n        }\n\n        if (code < 10) {\n            // Skip server info\n            return;\n        }\n\n        // Currently disabled... to much text\n        Message message = new Message(response);\n        message.setColor(Message.COLOR_GREY);\n        server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            ServerInfo.DEFAULT_NAME\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On disconnect\n     */\n    @Override\n    public void onDisconnect()\n    {\n        // Call parent method to ensure \"register\" status is tracked\n        super.onDisconnect();\n\n        if (service.getSettings().isReconnectEnabled() && server.getStatus() != Status.DISCONNECTED) {\n            setAutojoinChannels(server.getCurrentChannelNames());\n\n            server.clearConversations();\n            server.setStatus(Status.CONNECTING);\n            service.connect(server);\n        } else {\n            server.setStatus(Status.DISCONNECTED);\n        }\n\n        service.notifyDisconnected(server.getTitle());\n\n        Intent sIntent = Broadcast.createServerIntent(Broadcast.SERVER_UPDATE, server.getId());\n        service.sendBroadcast(sIntent);\n\n        Collection<Conversation> conversations = server.getConversations();\n\n        for (Conversation conversation : conversations) {\n            Message message = new Message(service.getString(R.string.message_disconnected));\n            message.setIcon(R.drawable.error);\n            message.setColor(Message.COLOR_RED);\n            server.getConversation(conversation.getName()).addMessage(message);\n\n            Intent cIntent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                conversation.getName()\n            );\n            service.sendBroadcast(cIntent);\n        }\n    }\n\n    /**\n     * Get all channels where the user with the given nickname is online\n     * \n     * @param nickname\n     * @return Array of channel names\n     */\n    private Vector<String> getChannelsByNickname(String nickname)\n    {\n        Vector<String> channels = new Vector<String>();\n        String[] channelArray = getChannels();\n\n        for (String channel : channelArray) {\n            User[] userArray = getUsers(channel);\n            for (User user : userArray) {\n                if (user.getNick().equals(nickname)) {\n                    channels.add(channel);\n                    break;\n                }\n            }\n        }\n\n        return channels;\n    }\n\n    /**\n     * Get list of users in a channel as array of strings\n     * \n     * @param channel Name of the channel\n     */\n    public String[] getUsersAsStringArray(String channel)\n    {\n        User[] userArray = getUsers(channel);\n        int mLength = userArray.length;\n        String[] users = new String[mLength];\n\n        for (int i = 0; i < mLength; i++) {\n            users[i] = userArray[i].getPrefix() + userArray[i].getNick();\n        }\n\n        return users;\n    }\n\n    /**\n     * Get a user by channel and nickname\n     * \n     * @param channel The channel the user is in\n     * @param nickname The nickname of the user (with or without prefix)\n     * @return the User object or null if user was not found\n     */\n    public User getUser(String channel, String nickname)\n    {\n        User[] users = getUsers(channel);\n        int mLength = users.length;\n\n        for (int i = 0; i < mLength; i++) {\n            if (nickname.equals(users[i].getNick())) {\n                return users[i];\n            }\n            if (nickname.equals(users[i].getPrefix() + users[i].getNick())) {\n                return users[i];\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Quits from the IRC server with default reason.\n     */\n    @Override\n    public void quitServer()\n    {\n        new Thread() {\n            @Override\n            public void run() {\n                quitServer(service.getSettings().getQuitMessage());\n            }\n        }.start();\n    }\n\n    /**\n     * Check whether the nickname has been mentioned.\n     * \n     * @param text The text to check for the nickname\n     * @return true if nickname was found, otherwise false\n     */\n    public boolean isMentioned(String text)\n    {\n        return mNickMatch.matcher(text).find();\n    }\n\n    /**\n     * Update the nick matching pattern, should be called when the nickname changes.\n     */\n    private void updateNickMatchPattern()\n    {\n        mNickMatch = Pattern.compile(\"(?:^|[\\\\s?!'�:;,.])\"+Pattern.quote(getNick())+\"(?:[\\\\s?!'�:;,.]|$)\", Pattern.CASE_INSENSITIVE);\n    }\n}\n","lineNo":353}
{"Smelly Sample":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2011 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage org.yaaic.irc;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Vector;\nimport java.util.regex.Pattern;\n\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.command.CommandParser;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Query;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.ServerInfo;\nimport org.yaaic.model.Status;\n\nimport android.content.Intent;\n\n/**\n * The class that actually handles the connection to an IRC server\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class IRCConnection extends PircBot\n{\n    private final IRCService service;\n    private final Server server;\n    private ArrayList<String> autojoinChannels;\n    private Pattern mNickMatch;\n\n    /**\n     * Create a new connection\n     * \n     * @param service\n     * @param serverId\n     */\n    public IRCConnection(IRCService service, int serverId)\n    {\n        this.server = Yaaic.getInstance().getServerById(serverId);\n        this.service = service;\n\n        // XXX: Should be configurable via settings\n        this.setAutoNickChange(true);\n\n        this.setFinger(\"http://www.youtube.com/watch?v=oHg5SJYRHA0\");\n        this.updateNickMatchPattern();\n    }\n\n    /**\n     * Set the nickname of the user\n     * \n     * @param nickname The nickname to use\n     */\n    public void setNickname(String nickname)\n    {\n        this.setName(nickname);\n        this.updateNickMatchPattern();\n    }\n\n    /**\n     * Set the real name of the user\n     * \n     * @param realname The realname to use\n     */\n    public void setRealName(String realname)\n    {\n        // XXX: Pircbot uses the version for \"real name\" and \"version\".\n        //      The real \"version\" value is provided by onVersion()\n        this.setVersion(realname);\n    }\n\n    /**\n     * Set channels to autojoin after connect\n     * \n     * @param channels\n     */\n    public void setAutojoinChannels(ArrayList<String> channels)\n    {\n        autojoinChannels = channels;\n    }\n\n    /**\n     * On version (CTCP version)\n     * \n     * This is a fix for pircbot as pircbot uses the version as \"real name\" and as \"version\"\n     */\n    @Override\n    protected void onVersion(String sourceNick, String sourceLogin,    String sourceHostname, String target)\n    {\n        this.sendRawLine(\n            \"NOTICE \" + sourceNick + \" :\\u0001VERSION \" +\n            \"Yaaic - Yet another Android IRC client - http://www.yaaic.org\" +\n            \"\\u0001\"\n        );\n    }\n\n    /**\n     * Set the ident of the user\n     * \n     * @param ident The ident to use\n     */\n    public void setIdent(String ident)\n    {\n        this.setLogin(ident);\n    }\n\n    /**\n     * On connect\n     */\n    @Override\n    public void onConnect()\n    {\n        server.setStatus(Status.CONNECTED);\n\n        service.sendBroadcast(\n            Broadcast.createServerIntent(Broadcast.SERVER_UPDATE, server.getId())\n        );\n\n        service.updateNotification(service.getString(R.string.notification_connected, server.getTitle()));\n\n        Message message = new Message(service.getString(R.string.message_connected, server.getTitle()));\n        message.setColor(Message.COLOR_GREEN);\n        server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            ServerInfo.DEFAULT_NAME\n        );\n\n        service.sendBroadcast(intent);\n    }\n\n\n    /**\n     * On register\n     */\n    @Override\n    public void onRegister()\n    {\n        // Call parent method to ensure \"register\" status is tracked\n        super.onRegister();\n\n        // execute commands\n        CommandParser parser = CommandParser.getInstance();\n\n        this.updateNickMatchPattern();\n        for (String command : server.getConnectCommands()) {\n            parser.parse(command, server, server.getConversation(ServerInfo.DEFAULT_NAME), service);\n        }\n\n        // TODO: Detect \"You are now identified for <nick>\" notices from NickServ and handle\n        //       auto joins in onNotice instead if the user has chosen to wait for NickServ\n        //       identification before auto joining channels.\n\n        // delay 1 sec before auto joining channels\n        try {\n            Thread.sleep(1000);\n        } catch(InterruptedException e) {\n            // do nothing\n        }\n\n        // join channels\n        if (autojoinChannels != null) {\n            for (String channel : autojoinChannels) {\n                // Add support for channel keys\n                joinChannel(channel);\n            }\n        } else {\n            for (String channel : server.getAutoJoinChannels()) {\n                joinChannel(channel);\n            }\n        }\n    }\n    /**\n     * On channel action\n     */\n    @Override\n    protected void onAction(String sender, String login, String hostname, String target, String action)\n    {\n        Conversation conversation;\n\n        Message message = new Message(sender + \" \" + action);\n        message.setIcon(R.drawable.action);\n\n        String queryNick = target;\n        if (queryNick.equals(this.getNick())) {\n            // We are the target - this is an action in a query\n            queryNick = sender;\n        }\n        conversation = server.getConversation(queryNick);\n\n        if (conversation == null) {\n            // Open a query if there's none yet\n            conversation = new Query(queryNick);\n            server.addConversation(conversation);\n            conversation.addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_NEW,\n                server.getId(),\n                queryNick\n            );\n            service.sendBroadcast(intent);\n        } else {\n            conversation.addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                queryNick\n            );\n            service.sendBroadcast(intent);\n        }\n\n        if (sender.equals(this.getNick())) {\n           // Don't notify for something sent in our name\n           return;\n        }\n\n        boolean mentioned = isMentioned(action);\n        if (mentioned || target.equals(this.getNick())) {\n            service.updateNotification(\n                target + \": \" + sender + \" \" + action,\n                service.getSettings().isVibrateHighlightEnabled(),\n                service.getSettings().isSoundHighlightEnabled()\n            );\n        }\n\n        if (mentioned) {\n            // highlight\n            message.setColor(Message.COLOR_RED);\n            conversation.setStatus(Conversation.STATUS_HIGHLIGHT);\n        }\n    }\n\n    /**\n     * On Channel Info\n     */\n    @Override\n    protected void onChannelInfo(String channel, int userCount, String topic)\n    {\n    }\n\n    /**\n     * On Deop\n     */\n    @Override\n    protected void onDeop(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n    {\n        Message message = new Message(service.getString(R.string.message_deop, sourceNick, recipient));\n        message.setIcon(R.drawable.op);\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On DeVoice\n     */\n    @Override\n    protected void onDeVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n    {\n        Message message = new Message(service.getString(R.string.message_devoice, sourceNick, recipient));\n        message.setColor(Message.COLOR_BLUE);\n        message.setIcon(R.drawable.voice);\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On Invite\n     */\n    @Override\n    protected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String target)\n    {\n        if (targetNick.equals(this.getNick())) {\n            // We are invited\n            Message message = new Message(service.getString(R.string.message_invite_you, sourceNick, target));\n            server.getConversation(server.getSelectedConversation()).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                server.getSelectedConversation()\n            );\n            service.sendBroadcast(intent);\n        } else {\n            // Someone is invited\n            Message message = new Message(service.getString(R.string.message_invite_someone, sourceNick, targetNick, target));\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Join\n     */\n    @Override\n    protected void onJoin(String target, String sender, String login, String hostname)\n    {\n        if (sender.equalsIgnoreCase(getNick())) {\n            // We joined a new channel\n            server.addConversation(new Channel(target));\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_NEW,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        } else if (service.getSettings().showJoinPartAndQuit()) {\n            Message message = new Message(\n                service.getString(R.string.message_join, sender),\n                Message.TYPE_MISC\n            );\n\n            message.setIcon(R.drawable.join);\n            message.setColor(Message.COLOR_GREEN);\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Kick\n     */\n    @Override\n    protected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n    {\n        if (recipientNick.equals(getNick())) {\n            // We are kicked\n            server.removeConversation(target);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_REMOVE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        } else {\n            Message message = new Message(service.getString(R.string.message_kick, kickerNick, recipientNick));\n            message.setColor(Message.COLOR_GREEN);\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Message\n     */\n    @Override\n    protected void onMessage(String target, String sender, String login, String hostname, String text)\n    {\n        Message message = new Message(text, sender);\n\n        if (isMentioned(text)) {\n            // highlight\n            message.setColor(Message.COLOR_RED);\n            service.updateNotification(\n                target + \": <\" + sender + \"> \" + text,\n                service.getSettings().isVibrateHighlightEnabled(),\n                service.getSettings().isSoundHighlightEnabled()\n            );\n\n            server.getConversation(target).setStatus(Conversation.STATUS_HIGHLIGHT);\n        }\n\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On Mode\n     */\n    @Override\n    protected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n    {\n        // Disabled as it doubles events (e.g. onOp and onMode will be called)\n\n        /*\n        Message message = new Message(sourceNick + \" sets mode \" + mode);\n        server.getChannel(target).addMessage(message);\n\n        Intent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n        intent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n        intent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n        service.sendBroadcast(intent);\n         */\n    }\n\n    /**\n     * On Nick Change\n     */\n    @Override\n    protected void onNickChange(String oldNick, String login, String hostname, String newNick)\n    {\n        if (getNick().equalsIgnoreCase(newNick)) {\n            this.updateNickMatchPattern();\n\n            // Send message about own change to server info window\n            Message message = new Message(service.getString(R.string.message_self_rename, newNick));\n            message.setColor(Message.COLOR_GREEN);\n            server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                ServerInfo.DEFAULT_NAME\n            );\n\n            service.sendBroadcast(intent);\n        }\n\n        Vector<String> channels = getChannelsByNickname(newNick);\n\n        for (String target : channels) {\n            Message message = new Message(service.getString(R.string.message_rename, oldNick, newNick));\n            message.setColor(Message.COLOR_GREEN);\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Notice\n     */\n    @Override\n    protected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n    {\n        // Post notice to currently selected conversation\n        Conversation conversation;\n\n        if (service.getSettings().showNoticeInServerWindow()) {\n            conversation = server.getConversation(ServerInfo.DEFAULT_NAME);\n        } else {\n            conversation = server.getConversation(server.getSelectedConversation());\n\n            if (conversation == null) {\n                // Fallback: Use ServerInfo view\n                conversation = server.getConversation(ServerInfo.DEFAULT_NAME);\n            }\n        }\n\n        Message message = new Message(\"-\" + sourceNick + \"- \" + notice);\n        message.setIcon(R.drawable.info);\n        conversation.addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            conversation.getName()\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On Op\n     */\n    @Override\n    protected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n    {\n        Message message = new Message(service.getString(R.string.message_op, sourceNick, recipient));\n        message.setColor(Message.COLOR_BLUE);\n        message.setIcon(R.drawable.op);\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On Part\n     */\n    @Override\n    protected void onPart(String target, String sender, String login, String hostname)\n    {\n        if (sender.equals(getNick())) {\n            // We parted a channel\n            server.removeConversation(target);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_REMOVE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        } else if (service.getSettings().showJoinPartAndQuit()) {\n            Message message = new Message(\n                service.getString(R.string.message_part, sender),\n                Message.TYPE_MISC\n            );\n\n            message.setColor(Message.COLOR_GREEN);\n            message.setIcon(R.drawable.part);\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Private Message\n     */\n    @Override\n    protected void onPrivateMessage(String sender, String login, String hostname, String target, String text)\n    {\n        Message message = new Message(\"<\" + sender + \"> \" + text);\n        String queryNick = sender;\n\n        if (queryNick.equals(this.getNick())) {\n            queryNick = target;\n        }\n        Conversation conversation = server.getConversation(queryNick);\n\n        if (conversation == null) {\n            // Open a query if there's none yet\n            conversation = new Query(queryNick);\n            conversation.addMessage(message);\n            server.addConversation(conversation);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_NEW,\n                server.getId(),\n                queryNick\n            );\n            service.sendBroadcast(intent);\n        } else {\n            conversation.addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                queryNick\n            );\n            service.sendBroadcast(intent);\n        }\n\n        if (sender.equals(this.getNick())) {\n            // Don't notify for something sent in our name\n            return;\n        }\n\n        service.updateNotification(\n            \"<\" + sender + \"> \" + text,\n            service.getSettings().isVibrateHighlightEnabled(),\n            service.getSettings().isSoundHighlightEnabled()\n        );\n\n        if (isMentioned(text)) {\n            message.setColor(Message.COLOR_RED);\n            conversation.setStatus(Conversation.STATUS_HIGHLIGHT);\n        }\n    }\n\n    /**\n     * On Quit\n     */\n    @Override\n    protected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n    {\n        if (sourceNick.equals(this.getNick())) {\n            return;\n        }\n\n        if (service.getSettings().showJoinPartAndQuit()) {\n            Vector<String> channels = getChannelsByNickname(sourceNick);\n\n            for (String target : channels) {\n                Message message = new Message(\n                    service.getString(R.string.message_quit, sourceNick, reason),\n                    Message.TYPE_MISC\n                );\n\n                message.setColor(Message.COLOR_GREEN);\n                message.setIcon(R.drawable.quit);\n                server.getConversation(target).addMessage(message);\n\n                Intent intent = Broadcast.createConversationIntent(\n                    Broadcast.CONVERSATION_MESSAGE,\n                    server.getId(),\n                    target\n                );\n                service.sendBroadcast(intent);\n            }\n\n            // Look if there's a query to update\n            Conversation conversation = server.getConversation(sourceNick);\n\n            if (conversation != null) {\n                Message message = new Message(\n                    service.getString(R.string.message_quit, sourceNick, reason),\n                    Message.TYPE_MISC\n                );\n\n                message.setColor(Message.COLOR_GREEN);\n                message.setIcon(R.drawable.quit);\n                conversation.addMessage(message);\n\n                Intent intent = Broadcast.createConversationIntent(\n                    Broadcast.CONVERSATION_MESSAGE,\n                    server.getId(),\n                    conversation.getName()\n                );\n                service.sendBroadcast(intent);\n            }\n        }\n    }\n\n    /**\n     * On Topic\n     */\n    @Override\n    public void onTopic(String target, String topic, String setBy, long date, boolean changed)\n    {\n        if (changed) {\n            Message message = new Message(service.getString(R.string.message_topic_set, setBy, topic));\n            message.setColor(Message.COLOR_YELLOW);\n            server.getConversation(target).addMessage(message);\n        } else {\n            Message message = new Message(service.getString(R.string.message_topic, topic));\n            message.setColor(Message.COLOR_YELLOW);\n            server.getConversation(target).addMessage(message);\n        }\n\n        // remember channel's topic\n        ((Channel) server.getConversation(target)).setTopic(topic);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On User List\n     */\n    @Override\n    protected void onUserList(String channel, User[] users)\n    {\n        // XXX: Store user list somewhere and keep it updated or just broadcast some event?\n    }\n\n    /**\n     * On Voice\n     */\n    @Override\n    protected void onVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n    {\n        Message message = new Message(service.getString(R.string.message_voice, sourceNick, recipient));\n        message.setIcon(R.drawable.voice);\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n\n        // update the displayed conversation title if necessary\n        intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_TOPIC,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On remove channel key\n     */\n    @Override\n    protected void onRemoveChannelKey(String target, String sourceNick, String sourceLogin, String sourceHostname, String key)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_channel_key, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set channel key\n     */\n    @Override\n    protected void onSetChannelKey(String target, String sourceNick, String sourceLogin, String sourceHostname, String key)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_key, sourceNick, key));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set secret\n     */\n    @Override\n    protected void onSetSecret(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_secret, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove secret\n     */\n    @Override\n    protected void onRemoveSecret(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_public, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set channel limit\n     */\n    @Override\n    protected void onSetChannelLimit(String target, String sourceNick, String sourceLogin, String sourceHostname, int limit)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_limit, sourceNick, limit));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove channel limit\n     */\n    @Override\n    protected void onRemoveChannelLimit(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_channel_limit, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set channel ban\n     */\n    @Override\n    protected void onSetChannelBan(String target, String sourceNick, String sourceLogin, String sourceHostname, String hostmask)\n    {\n        Message message = new Message(service.getString(R.string.message_set_ban, sourceNick, hostmask));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove channel ban\n     */\n    @Override\n    protected void onRemoveChannelBan(String target, String sourceNick, String sourceLogin, String sourceHostname, String hostmask)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_ban, sourceNick, hostmask));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set topic protection\n     */\n    @Override\n    protected void onSetTopicProtection(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_topic_protection, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove topic protection\n     */\n    @Override\n    protected void onRemoveTopicProtection(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_topic_protection, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set no external messages\n     */\n    @Override\n    protected void onSetNoExternalMessages(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_disable_external, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove no external messages\n     */\n    @Override\n    protected void onRemoveNoExternalMessages(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_enable_external, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set invite only\n     */\n    @Override\n    protected void onSetInviteOnly(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_invite_only, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove invite only\n     */\n    @Override\n    protected void onRemoveInviteOnly(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_invite_only, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set moderated\n     */\n    @Override\n    protected void onSetModerated(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_moderated, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove moderated\n     */\n    @Override\n    protected void onRemoveModerated(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_moderated, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set private\n     */\n    @Override\n    protected void onSetPrivate(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_private, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove private\n     */\n    @Override\n    protected void onRemovePrivate(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_public, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On unknown\n     */\n    @Override\n    protected void onUnknown(String line)\n    {\n        Message message = new Message(line);\n        message.setIcon(R.drawable.action);\n        message.setColor(Message.COLOR_GREY);\n        server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            ServerInfo.DEFAULT_NAME\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On server response\n     */\n    @Override\n    protected void onServerResponse(int code, String response)\n    {\n        if (code == 4) {\n            // User has registered with the server\n            onRegister();\n            return;\n        }\n        if (code == 372 || code == 375 || code == 376) {\n            // Skip MOTD\n            return;\n        }\n\n        if (code >= 200 && code < 300) {\n            // Skip 2XX responses\n            return;\n        }\n\n        if (code == 353 || code == 366 || code == 332 || code == 333) {\n            return;\n        }\n\n        if (code < 10) {\n            // Skip server info\n            return;\n        }\n\n        // Currently disabled... to much text\n        Message message = new Message(response);\n        message.setColor(Message.COLOR_GREY);\n        server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            ServerInfo.DEFAULT_NAME\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On disconnect\n     */\n    @Override\n    public void onDisconnect()\n    {\n        // Call parent method to ensure \"register\" status is tracked\n        super.onDisconnect();\n\n        if (service.getSettings().isReconnectEnabled() && server.getStatus() != Status.DISCONNECTED) {\n            setAutojoinChannels(server.getCurrentChannelNames());\n\n            server.clearConversations();\n            server.setStatus(Status.CONNECTING);\n            service.connect(server);\n        } else {\n            server.setStatus(Status.DISCONNECTED);\n        }\n\n        service.updateNotification(service.getString(R.string.notification_disconnected, server.getTitle()));\n\n        Intent sIntent = Broadcast.createServerIntent(Broadcast.SERVER_UPDATE, server.getId());\n        service.sendBroadcast(sIntent);\n\n        Collection<Conversation> conversations = server.getConversations();\n\n        for (Conversation conversation : conversations) {\n            Message message = new Message(service.getString(R.string.message_disconnected));\n            message.setIcon(R.drawable.error);\n            message.setColor(Message.COLOR_RED);\n            server.getConversation(conversation.getName()).addMessage(message);\n\n            Intent cIntent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                conversation.getName()\n            );\n            service.sendBroadcast(cIntent);\n        }\n    }\n\n    /**\n     * Get all channels where the user with the given nickname is online\n     * \n     * @param nickname\n     * @return Array of channel names\n     */\n    private Vector<String> getChannelsByNickname(String nickname)\n    {\n        Vector<String> channels = new Vector<String>();\n        String[] channelArray = getChannels();\n\n        for (String channel : channelArray) {\n            User[] userArray = getUsers(channel);\n            for (User user : userArray) {\n                if (user.getNick().equals(nickname)) {\n                    channels.add(channel);\n                    break;\n                }\n            }\n        }\n\n        return channels;\n    }\n\n    /**\n     * Get list of users in a channel as array of strings\n     * \n     * @param channel Name of the channel\n     */\n    public String[] getUsersAsStringArray(String channel)\n    {\n        User[] userArray = getUsers(channel);\n        int mLength = userArray.length;\n        String[] users = new String[mLength];\n\n        for (int i = 0; i < mLength; i++) {\n            users[i] = userArray[i].getPrefix() + userArray[i].getNick();\n        }\n\n        return users;\n    }\n\n    /**\n     * Get a user by channel and nickname\n     * \n     * @param channel The channel the user is in\n     * @param nickname The nickname of the user (with or without prefix)\n     * @return the User object or null if user was not found\n     */\n    public User getUser(String channel, String nickname)\n    {\n        User[] users = getUsers(channel);\n        int mLength = users.length;\n\n        for (int i = 0; i < mLength; i++) {\n            if (nickname.equals(users[i].getNick())) {\n                return users[i];\n            }\n            if (nickname.equals(users[i].getPrefix() + users[i].getNick())) {\n                return users[i];\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Quits from the IRC server with default reason.\n     */\n    @Override\n    public void quitServer()\n    {\n        new Thread() {\n            @Override\n            public void run() {\n                quitServer(service.getSettings().getQuitMessage());\n            }\n        }.start();\n    }\n\n    /**\n     * Check whether the nickname has been mentioned.\n     * \n     * @param text The text to check for the nickname\n     * @return true if nickname was found, otherwise false\n     */\n    public boolean isMentioned(String text)\n    {\n        return mNickMatch.matcher(text).find();\n    }\n\n    /**\n     * Update the nick matching pattern, should be called when the nickname changes.\n     */\n    private void updateNickMatchPattern()\n    {\n        mNickMatch = Pattern.compile(\"(?:^|[\\\\s?!'�:;,.])\"+Pattern.quote(getNick())+\"(?:[\\\\s?!'�:;,.]|$)\", Pattern.CASE_INSENSITIVE);\n    }\n}\n","Method after Refactoring":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2011 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage org.yaaic.irc;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Vector;\nimport java.util.regex.Pattern;\n\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.command.CommandParser;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Query;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.ServerInfo;\nimport org.yaaic.model.Status;\n\nimport android.content.Intent;\n\n/**\n * The class that actually handles the connection to an IRC server\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class IRCConnection extends PircBot\n{\n    private final IRCService service;\n    private final Server server;\n    private ArrayList<String> autojoinChannels;\n    private Pattern mNickMatch;\n\n    /**\n     * Create a new connection\n     * \n     * @param service\n     * @param serverId\n     */\n    public IRCConnection(IRCService service, int serverId)\n    {\n        this.server = Yaaic.getInstance().getServerById(serverId);\n        this.service = service;\n\n        // XXX: Should be configurable via settings\n        this.setAutoNickChange(true);\n\n        this.setFinger(\"http://www.youtube.com/watch?v=oHg5SJYRHA0\");\n        this.updateNickMatchPattern();\n    }\n\n    /**\n     * Set the nickname of the user\n     * \n     * @param nickname The nickname to use\n     */\n    public void setNickname(String nickname)\n    {\n        this.setName(nickname);\n        this.updateNickMatchPattern();\n    }\n\n    /**\n     * Set the real name of the user\n     * \n     * @param realname The realname to use\n     */\n    public void setRealName(String realname)\n    {\n        // XXX: Pircbot uses the version for \"real name\" and \"version\".\n        //      The real \"version\" value is provided by onVersion()\n        this.setVersion(realname);\n    }\n\n    /**\n     * Set channels to autojoin after connect\n     * \n     * @param channels\n     */\n    public void setAutojoinChannels(ArrayList<String> channels)\n    {\n        autojoinChannels = channels;\n    }\n\n    /**\n     * On version (CTCP version)\n     * \n     * This is a fix for pircbot as pircbot uses the version as \"real name\" and as \"version\"\n     */\n    @Override\n    protected void onVersion(String sourceNick, String sourceLogin,    String sourceHostname, String target)\n    {\n        this.sendRawLine(\n            \"NOTICE \" + sourceNick + \" :\\u0001VERSION \" +\n            \"Yaaic - Yet another Android IRC client - http://www.yaaic.org\" +\n            \"\\u0001\"\n        );\n    }\n\n    /**\n     * Set the ident of the user\n     * \n     * @param ident The ident to use\n     */\n    public void setIdent(String ident)\n    {\n        this.setLogin(ident);\n    }\n\n    /**\n     * On connect\n     */\n    @Override\n    public void onConnect()\n    {\n        server.setStatus(Status.CONNECTED);\n\n        service.sendBroadcast(\n            Broadcast.createServerIntent(Broadcast.SERVER_UPDATE, server.getId())\n        );\n\n        service.notifyConnected(server.getTitle());\n\n        Message message = new Message(service.getString(R.string.message_connected, server.getTitle()));\n        message.setColor(Message.COLOR_GREEN);\n        server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            ServerInfo.DEFAULT_NAME\n        );\n\n        service.sendBroadcast(intent);\n    }\n\n\n    /**\n     * On register\n     */\n    @Override\n    public void onRegister()\n    {\n        // Call parent method to ensure \"register\" status is tracked\n        super.onRegister();\n\n        // execute commands\n        CommandParser parser = CommandParser.getInstance();\n\n        this.updateNickMatchPattern();\n        for (String command : server.getConnectCommands()) {\n            parser.parse(command, server, server.getConversation(ServerInfo.DEFAULT_NAME), service);\n        }\n\n        // TODO: Detect \"You are now identified for <nick>\" notices from NickServ and handle\n        //       auto joins in onNotice instead if the user has chosen to wait for NickServ\n        //       identification before auto joining channels.\n\n        // delay 1 sec before auto joining channels\n        try {\n            Thread.sleep(1000);\n        } catch(InterruptedException e) {\n            // do nothing\n        }\n\n        // join channels\n        if (autojoinChannels != null) {\n            for (String channel : autojoinChannels) {\n                // Add support for channel keys\n                joinChannel(channel);\n            }\n        } else {\n            for (String channel : server.getAutoJoinChannels()) {\n                joinChannel(channel);\n            }\n        }\n    }\n    /**\n     * On channel action\n     */\n    @Override\n    protected void onAction(String sender, String login, String hostname, String target, String action)\n    {\n        Conversation conversation;\n\n        Message message = new Message(sender + \" \" + action);\n        message.setIcon(R.drawable.action);\n\n        String queryNick = target;\n        if (queryNick.equals(this.getNick())) {\n            // We are the target - this is an action in a query\n            queryNick = sender;\n        }\n        conversation = server.getConversation(queryNick);\n\n        if (conversation == null) {\n            // Open a query if there's none yet\n            conversation = new Query(queryNick);\n            server.addConversation(conversation);\n            conversation.addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_NEW,\n                server.getId(),\n                queryNick\n            );\n            service.sendBroadcast(intent);\n        } else {\n            conversation.addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                queryNick\n            );\n            service.sendBroadcast(intent);\n        }\n\n        if (sender.equals(this.getNick())) {\n           // Don't notify for something sent in our name\n           return;\n        }\n\n        boolean mentioned = isMentioned(action);\n        if (mentioned || target.equals(this.getNick())) {\n            if (conversation.getStatus() != Conversation.STATUS_SELECTED || !server.getIsForeground()) {\n                service.addNewMention(\n                    conversation,\n                    conversation.getName() + \": \" + sender + \" \" + action,\n                    service.getSettings().isVibrateHighlightEnabled(),\n                    service.getSettings().isSoundHighlightEnabled()\n                );\n            }\n        }\n\n        if (mentioned) {\n            // highlight\n            message.setColor(Message.COLOR_RED);\n            conversation.setStatus(Conversation.STATUS_HIGHLIGHT);\n        }\n    }\n\n    /**\n     * On Channel Info\n     */\n    @Override\n    protected void onChannelInfo(String channel, int userCount, String topic)\n    {\n    }\n\n    /**\n     * On Deop\n     */\n    @Override\n    protected void onDeop(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n    {\n        Message message = new Message(service.getString(R.string.message_deop, sourceNick, recipient));\n        message.setIcon(R.drawable.op);\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On DeVoice\n     */\n    @Override\n    protected void onDeVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n    {\n        Message message = new Message(service.getString(R.string.message_devoice, sourceNick, recipient));\n        message.setColor(Message.COLOR_BLUE);\n        message.setIcon(R.drawable.voice);\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On Invite\n     */\n    @Override\n    protected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String target)\n    {\n        if (targetNick.equals(this.getNick())) {\n            // We are invited\n            Message message = new Message(service.getString(R.string.message_invite_you, sourceNick, target));\n            server.getConversation(server.getSelectedConversation()).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                server.getSelectedConversation()\n            );\n            service.sendBroadcast(intent);\n        } else {\n            // Someone is invited\n            Message message = new Message(service.getString(R.string.message_invite_someone, sourceNick, targetNick, target));\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Join\n     */\n    @Override\n    protected void onJoin(String target, String sender, String login, String hostname)\n    {\n        if (sender.equalsIgnoreCase(getNick())) {\n            // We joined a new channel\n            server.addConversation(new Channel(target));\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_NEW,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        } else if (service.getSettings().showJoinPartAndQuit()) {\n            Message message = new Message(\n                service.getString(R.string.message_join, sender),\n                Message.TYPE_MISC\n            );\n\n            message.setIcon(R.drawable.join);\n            message.setColor(Message.COLOR_GREEN);\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Kick\n     */\n    @Override\n    protected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n    {\n        if (recipientNick.equals(getNick())) {\n            // We are kicked\n            server.removeConversation(target);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_REMOVE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        } else {\n            Message message = new Message(service.getString(R.string.message_kick, kickerNick, recipientNick));\n            message.setColor(Message.COLOR_GREEN);\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Message\n     */\n    @Override\n    protected void onMessage(String target, String sender, String login, String hostname, String text)\n    {\n        Message message = new Message(text, sender);\n        Conversation conversation = server.getConversation(target);\n\n        if (isMentioned(text)) {\n            // highlight\n            message.setColor(Message.COLOR_RED);\n            if (conversation.getStatus() != Conversation.STATUS_SELECTED || !server.getIsForeground()) {\n                service.addNewMention(\n                    conversation,\n                    target + \": <\" + sender + \"> \" + text,\n                    service.getSettings().isVibrateHighlightEnabled(),\n                    service.getSettings().isSoundHighlightEnabled()\n                );\n            }\n\n            conversation.setStatus(Conversation.STATUS_HIGHLIGHT);\n        }\n\n        conversation.addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On Mode\n     */\n    @Override\n    protected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n    {\n        // Disabled as it doubles events (e.g. onOp and onMode will be called)\n\n        /*\n        Message message = new Message(sourceNick + \" sets mode \" + mode);\n        server.getChannel(target).addMessage(message);\n\n        Intent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n        intent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n        intent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n        service.sendBroadcast(intent);\n         */\n    }\n\n    /**\n     * On Nick Change\n     */\n    @Override\n    protected void onNickChange(String oldNick, String login, String hostname, String newNick)\n    {\n        if (getNick().equalsIgnoreCase(newNick)) {\n            this.updateNickMatchPattern();\n\n            // Send message about own change to server info window\n            Message message = new Message(service.getString(R.string.message_self_rename, newNick));\n            message.setColor(Message.COLOR_GREEN);\n            server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                ServerInfo.DEFAULT_NAME\n            );\n\n            service.sendBroadcast(intent);\n        }\n\n        Vector<String> channels = getChannelsByNickname(newNick);\n\n        for (String target : channels) {\n            Message message = new Message(service.getString(R.string.message_rename, oldNick, newNick));\n            message.setColor(Message.COLOR_GREEN);\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Notice\n     */\n    @Override\n    protected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n    {\n        // Post notice to currently selected conversation\n        Conversation conversation;\n\n        if (service.getSettings().showNoticeInServerWindow()) {\n            conversation = server.getConversation(ServerInfo.DEFAULT_NAME);\n        } else {\n            conversation = server.getConversation(server.getSelectedConversation());\n\n            if (conversation == null) {\n                // Fallback: Use ServerInfo view\n                conversation = server.getConversation(ServerInfo.DEFAULT_NAME);\n            }\n        }\n\n        Message message = new Message(\"-\" + sourceNick + \"- \" + notice);\n        message.setIcon(R.drawable.info);\n        conversation.addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            conversation.getName()\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On Op\n     */\n    @Override\n    protected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n    {\n        Message message = new Message(service.getString(R.string.message_op, sourceNick, recipient));\n        message.setColor(Message.COLOR_BLUE);\n        message.setIcon(R.drawable.op);\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On Part\n     */\n    @Override\n    protected void onPart(String target, String sender, String login, String hostname)\n    {\n        if (sender.equals(getNick())) {\n            // We parted a channel\n            server.removeConversation(target);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_REMOVE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        } else if (service.getSettings().showJoinPartAndQuit()) {\n            Message message = new Message(\n                service.getString(R.string.message_part, sender),\n                Message.TYPE_MISC\n            );\n\n            message.setColor(Message.COLOR_GREEN);\n            message.setIcon(R.drawable.part);\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Private Message\n     */\n    @Override\n    protected void onPrivateMessage(String sender, String login, String hostname, String target, String text)\n    {\n        Message message = new Message(\"<\" + sender + \"> \" + text);\n        String queryNick = sender;\n\n        if (queryNick.equals(this.getNick())) {\n            queryNick = target;\n        }\n        Conversation conversation = server.getConversation(queryNick);\n\n        if (conversation == null) {\n            // Open a query if there's none yet\n            conversation = new Query(queryNick);\n            conversation.addMessage(message);\n            server.addConversation(conversation);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_NEW,\n                server.getId(),\n                queryNick\n            );\n            service.sendBroadcast(intent);\n        } else {\n            conversation.addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                queryNick\n            );\n            service.sendBroadcast(intent);\n        }\n\n        if (sender.equals(this.getNick())) {\n            // Don't notify for something sent in our name\n            return;\n        }\n\n        if (conversation.getStatus() != Conversation.STATUS_SELECTED || !server.getIsForeground()) {\n            service.addNewMention(\n                conversation,\n                \"<\" + sender + \"> \" + text,\n                service.getSettings().isVibrateHighlightEnabled(),\n                service.getSettings().isSoundHighlightEnabled()\n            );\n        }\n\n        if (isMentioned(text)) {\n            message.setColor(Message.COLOR_RED);\n            conversation.setStatus(Conversation.STATUS_HIGHLIGHT);\n        }\n    }\n\n    /**\n     * On Quit\n     */\n    @Override\n    protected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n    {\n        if (sourceNick.equals(this.getNick())) {\n            return;\n        }\n\n        if (service.getSettings().showJoinPartAndQuit()) {\n            Vector<String> channels = getChannelsByNickname(sourceNick);\n\n            for (String target : channels) {\n                Message message = new Message(\n                    service.getString(R.string.message_quit, sourceNick, reason),\n                    Message.TYPE_MISC\n                );\n\n                message.setColor(Message.COLOR_GREEN);\n                message.setIcon(R.drawable.quit);\n                server.getConversation(target).addMessage(message);\n\n                Intent intent = Broadcast.createConversationIntent(\n                    Broadcast.CONVERSATION_MESSAGE,\n                    server.getId(),\n                    target\n                );\n                service.sendBroadcast(intent);\n            }\n\n            // Look if there's a query to update\n            Conversation conversation = server.getConversation(sourceNick);\n\n            if (conversation != null) {\n                Message message = new Message(\n                    service.getString(R.string.message_quit, sourceNick, reason),\n                    Message.TYPE_MISC\n                );\n\n                message.setColor(Message.COLOR_GREEN);\n                message.setIcon(R.drawable.quit);\n                conversation.addMessage(message);\n\n                Intent intent = Broadcast.createConversationIntent(\n                    Broadcast.CONVERSATION_MESSAGE,\n                    server.getId(),\n                    conversation.getName()\n                );\n                service.sendBroadcast(intent);\n            }\n        }\n    }\n\n    /**\n     * On Topic\n     */\n    @Override\n    public void onTopic(String target, String topic, String setBy, long date, boolean changed)\n    {\n        if (changed) {\n            Message message = new Message(service.getString(R.string.message_topic_set, setBy, topic));\n            message.setColor(Message.COLOR_YELLOW);\n            server.getConversation(target).addMessage(message);\n        } else {\n            Message message = new Message(service.getString(R.string.message_topic, topic));\n            message.setColor(Message.COLOR_YELLOW);\n            server.getConversation(target).addMessage(message);\n        }\n\n        // remember channel's topic\n        ((Channel) server.getConversation(target)).setTopic(topic);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On User List\n     */\n    @Override\n    protected void onUserList(String channel, User[] users)\n    {\n        // XXX: Store user list somewhere and keep it updated or just broadcast some event?\n    }\n\n    /**\n     * On Voice\n     */\n    @Override\n    protected void onVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n    {\n        Message message = new Message(service.getString(R.string.message_voice, sourceNick, recipient));\n        message.setIcon(R.drawable.voice);\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n\n        // update the displayed conversation title if necessary\n        intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_TOPIC,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On remove channel key\n     */\n    @Override\n    protected void onRemoveChannelKey(String target, String sourceNick, String sourceLogin, String sourceHostname, String key)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_channel_key, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set channel key\n     */\n    @Override\n    protected void onSetChannelKey(String target, String sourceNick, String sourceLogin, String sourceHostname, String key)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_key, sourceNick, key));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set secret\n     */\n    @Override\n    protected void onSetSecret(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_secret, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove secret\n     */\n    @Override\n    protected void onRemoveSecret(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_public, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set channel limit\n     */\n    @Override\n    protected void onSetChannelLimit(String target, String sourceNick, String sourceLogin, String sourceHostname, int limit)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_limit, sourceNick, limit));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove channel limit\n     */\n    @Override\n    protected void onRemoveChannelLimit(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_channel_limit, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set channel ban\n     */\n    @Override\n    protected void onSetChannelBan(String target, String sourceNick, String sourceLogin, String sourceHostname, String hostmask)\n    {\n        Message message = new Message(service.getString(R.string.message_set_ban, sourceNick, hostmask));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove channel ban\n     */\n    @Override\n    protected void onRemoveChannelBan(String target, String sourceNick, String sourceLogin, String sourceHostname, String hostmask)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_ban, sourceNick, hostmask));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set topic protection\n     */\n    @Override\n    protected void onSetTopicProtection(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_topic_protection, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove topic protection\n     */\n    @Override\n    protected void onRemoveTopicProtection(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_topic_protection, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set no external messages\n     */\n    @Override\n    protected void onSetNoExternalMessages(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_disable_external, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove no external messages\n     */\n    @Override\n    protected void onRemoveNoExternalMessages(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_enable_external, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set invite only\n     */\n    @Override\n    protected void onSetInviteOnly(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_invite_only, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove invite only\n     */\n    @Override\n    protected void onRemoveInviteOnly(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_invite_only, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set moderated\n     */\n    @Override\n    protected void onSetModerated(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_moderated, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove moderated\n     */\n    @Override\n    protected void onRemoveModerated(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_moderated, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set private\n     */\n    @Override\n    protected void onSetPrivate(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_private, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove private\n     */\n    @Override\n    protected void onRemovePrivate(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_public, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On unknown\n     */\n    @Override\n    protected void onUnknown(String line)\n    {\n        Message message = new Message(line);\n        message.setIcon(R.drawable.action);\n        message.setColor(Message.COLOR_GREY);\n        server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            ServerInfo.DEFAULT_NAME\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On server response\n     */\n    @Override\n    protected void onServerResponse(int code, String response)\n    {\n        if (code == 4) {\n            // User has registered with the server\n            onRegister();\n            return;\n        }\n        if (code == 372 || code == 375 || code == 376) {\n            // Skip MOTD\n            return;\n        }\n\n        if (code >= 200 && code < 300) {\n            // Skip 2XX responses\n            return;\n        }\n\n        if (code == 353 || code == 366 || code == 332 || code == 333) {\n            return;\n        }\n\n        if (code < 10) {\n            // Skip server info\n            return;\n        }\n\n        // Currently disabled... to much text\n        Message message = new Message(response);\n        message.setColor(Message.COLOR_GREY);\n        server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            ServerInfo.DEFAULT_NAME\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On disconnect\n     */\n    @Override\n    public void onDisconnect()\n    {\n        // Call parent method to ensure \"register\" status is tracked\n        super.onDisconnect();\n\n        if (service.getSettings().isReconnectEnabled() && server.getStatus() != Status.DISCONNECTED) {\n            setAutojoinChannels(server.getCurrentChannelNames());\n\n            server.clearConversations();\n            server.setStatus(Status.CONNECTING);\n            service.connect(server);\n        } else {\n            server.setStatus(Status.DISCONNECTED);\n        }\n\n        service.notifyDisconnected(server.getTitle());\n\n        Intent sIntent = Broadcast.createServerIntent(Broadcast.SERVER_UPDATE, server.getId());\n        service.sendBroadcast(sIntent);\n\n        Collection<Conversation> conversations = server.getConversations();\n\n        for (Conversation conversation : conversations) {\n            Message message = new Message(service.getString(R.string.message_disconnected));\n            message.setIcon(R.drawable.error);\n            message.setColor(Message.COLOR_RED);\n            server.getConversation(conversation.getName()).addMessage(message);\n\n            Intent cIntent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                conversation.getName()\n            );\n            service.sendBroadcast(cIntent);\n        }\n    }\n\n    /**\n     * Get all channels where the user with the given nickname is online\n     * \n     * @param nickname\n     * @return Array of channel names\n     */\n    private Vector<String> getChannelsByNickname(String nickname)\n    {\n        Vector<String> channels = new Vector<String>();\n        String[] channelArray = getChannels();\n\n        for (String channel : channelArray) {\n            User[] userArray = getUsers(channel);\n            for (User user : userArray) {\n                if (user.getNick().equals(nickname)) {\n                    channels.add(channel);\n                    break;\n                }\n            }\n        }\n\n        return channels;\n    }\n\n    /**\n     * Get list of users in a channel as array of strings\n     * \n     * @param channel Name of the channel\n     */\n    public String[] getUsersAsStringArray(String channel)\n    {\n        User[] userArray = getUsers(channel);\n        int mLength = userArray.length;\n        String[] users = new String[mLength];\n\n        for (int i = 0; i < mLength; i++) {\n            users[i] = userArray[i].getPrefix() + userArray[i].getNick();\n        }\n\n        return users;\n    }\n\n    /**\n     * Get a user by channel and nickname\n     * \n     * @param channel The channel the user is in\n     * @param nickname The nickname of the user (with or without prefix)\n     * @return the User object or null if user was not found\n     */\n    public User getUser(String channel, String nickname)\n    {\n        User[] users = getUsers(channel);\n        int mLength = users.length;\n\n        for (int i = 0; i < mLength; i++) {\n            if (nickname.equals(users[i].getNick())) {\n                return users[i];\n            }\n            if (nickname.equals(users[i].getPrefix() + users[i].getNick())) {\n                return users[i];\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Quits from the IRC server with default reason.\n     */\n    @Override\n    public void quitServer()\n    {\n        new Thread() {\n            @Override\n            public void run() {\n                quitServer(service.getSettings().getQuitMessage());\n            }\n        }.start();\n    }\n\n    /**\n     * Check whether the nickname has been mentioned.\n     * \n     * @param text The text to check for the nickname\n     * @return true if nickname was found, otherwise false\n     */\n    public boolean isMentioned(String text)\n    {\n        return mNickMatch.matcher(text).find();\n    }\n\n    /**\n     * Update the nick matching pattern, should be called when the nickname changes.\n     */\n    private void updateNickMatchPattern()\n    {\n        mNickMatch = Pattern.compile(\"(?:^|[\\\\s?!'�:;,.])\"+Pattern.quote(getNick())+\"(?:[\\\\s?!'�:;,.]|$)\", Pattern.CASE_INSENSITIVE);\n    }\n}\n","lineNo":416}
{"Smelly Sample":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2011 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage org.yaaic.irc;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Vector;\nimport java.util.regex.Pattern;\n\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.command.CommandParser;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Query;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.ServerInfo;\nimport org.yaaic.model.Status;\n\nimport android.content.Intent;\n\n/**\n * The class that actually handles the connection to an IRC server\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class IRCConnection extends PircBot\n{\n    private final IRCService service;\n    private final Server server;\n    private ArrayList<String> autojoinChannels;\n    private Pattern mNickMatch;\n\n    /**\n     * Create a new connection\n     * \n     * @param service\n     * @param serverId\n     */\n    public IRCConnection(IRCService service, int serverId)\n    {\n        this.server = Yaaic.getInstance().getServerById(serverId);\n        this.service = service;\n\n        // XXX: Should be configurable via settings\n        this.setAutoNickChange(true);\n\n        this.setFinger(\"http://www.youtube.com/watch?v=oHg5SJYRHA0\");\n        this.updateNickMatchPattern();\n    }\n\n    /**\n     * Set the nickname of the user\n     * \n     * @param nickname The nickname to use\n     */\n    public void setNickname(String nickname)\n    {\n        this.setName(nickname);\n        this.updateNickMatchPattern();\n    }\n\n    /**\n     * Set the real name of the user\n     * \n     * @param realname The realname to use\n     */\n    public void setRealName(String realname)\n    {\n        // XXX: Pircbot uses the version for \"real name\" and \"version\".\n        //      The real \"version\" value is provided by onVersion()\n        this.setVersion(realname);\n    }\n\n    /**\n     * Set channels to autojoin after connect\n     * \n     * @param channels\n     */\n    public void setAutojoinChannels(ArrayList<String> channels)\n    {\n        autojoinChannels = channels;\n    }\n\n    /**\n     * On version (CTCP version)\n     * \n     * This is a fix for pircbot as pircbot uses the version as \"real name\" and as \"version\"\n     */\n    @Override\n    protected void onVersion(String sourceNick, String sourceLogin,    String sourceHostname, String target)\n    {\n        this.sendRawLine(\n            \"NOTICE \" + sourceNick + \" :\\u0001VERSION \" +\n            \"Yaaic - Yet another Android IRC client - http://www.yaaic.org\" +\n            \"\\u0001\"\n        );\n    }\n\n    /**\n     * Set the ident of the user\n     * \n     * @param ident The ident to use\n     */\n    public void setIdent(String ident)\n    {\n        this.setLogin(ident);\n    }\n\n    /**\n     * On connect\n     */\n    @Override\n    public void onConnect()\n    {\n        server.setStatus(Status.CONNECTED);\n\n        service.sendBroadcast(\n            Broadcast.createServerIntent(Broadcast.SERVER_UPDATE, server.getId())\n        );\n\n        service.updateNotification(service.getString(R.string.notification_connected, server.getTitle()));\n\n        Message message = new Message(service.getString(R.string.message_connected, server.getTitle()));\n        message.setColor(Message.COLOR_GREEN);\n        server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            ServerInfo.DEFAULT_NAME\n        );\n\n        service.sendBroadcast(intent);\n    }\n\n\n    /**\n     * On register\n     */\n    @Override\n    public void onRegister()\n    {\n        // Call parent method to ensure \"register\" status is tracked\n        super.onRegister();\n\n        // execute commands\n        CommandParser parser = CommandParser.getInstance();\n\n        this.updateNickMatchPattern();\n        for (String command : server.getConnectCommands()) {\n            parser.parse(command, server, server.getConversation(ServerInfo.DEFAULT_NAME), service);\n        }\n\n        // TODO: Detect \"You are now identified for <nick>\" notices from NickServ and handle\n        //       auto joins in onNotice instead if the user has chosen to wait for NickServ\n        //       identification before auto joining channels.\n\n        // delay 1 sec before auto joining channels\n        try {\n            Thread.sleep(1000);\n        } catch(InterruptedException e) {\n            // do nothing\n        }\n\n        // join channels\n        if (autojoinChannels != null) {\n            for (String channel : autojoinChannels) {\n                // Add support for channel keys\n                joinChannel(channel);\n            }\n        } else {\n            for (String channel : server.getAutoJoinChannels()) {\n                joinChannel(channel);\n            }\n        }\n    }\n    /**\n     * On channel action\n     */\n    @Override\n    protected void onAction(String sender, String login, String hostname, String target, String action)\n    {\n        Conversation conversation;\n\n        Message message = new Message(sender + \" \" + action);\n        message.setIcon(R.drawable.action);\n\n        if (target.equals(this.getNick())) {\n            // We are the target - this is an action in a query\n            conversation = server.getConversation(sender);\n            if (conversation == null) {\n                // Open a query if there's none yet\n                conversation = new Query(sender);\n                server.addConversation(conversation);\n                conversation.addMessage(message);\n\n                Intent intent = Broadcast.createConversationIntent(\n                    Broadcast.CONVERSATION_NEW,\n                    server.getId(),\n                    sender\n                );\n                service.sendBroadcast(intent);\n            } else {\n                conversation.addMessage(message);\n\n                Intent intent = Broadcast.createConversationIntent(\n                    Broadcast.CONVERSATION_MESSAGE,\n                    server.getId(),\n                    sender\n                );\n                service.sendBroadcast(intent);\n            }\n        } else {\n            // A action in a channel\n            conversation = server.getConversation(target);\n            conversation.addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n\n        boolean mentioned = isMentioned(action);\n        if (mentioned || target.equals(this.getNick())) {\n            service.updateNotification(\n                target + \": \" + sender + \" \" + action,\n                service.getSettings().isVibrateHighlightEnabled(),\n                service.getSettings().isSoundHighlightEnabled()\n            );\n        }\n\n        if (mentioned) {\n            // highlight\n            message.setColor(Message.COLOR_RED);\n            conversation.setStatus(Conversation.STATUS_HIGHLIGHT);\n        }\n    }\n\n    /**\n     * On Channel Info\n     */\n    @Override\n    protected void onChannelInfo(String channel, int userCount, String topic)\n    {\n    }\n\n    /**\n     * On Deop\n     */\n    @Override\n    protected void onDeop(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n    {\n        Message message = new Message(service.getString(R.string.message_deop, sourceNick, recipient));\n        message.setIcon(R.drawable.op);\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On DeVoice\n     */\n    @Override\n    protected void onDeVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n    {\n        Message message = new Message(service.getString(R.string.message_devoice, sourceNick, recipient));\n        message.setColor(Message.COLOR_BLUE);\n        message.setIcon(R.drawable.voice);\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On Invite\n     */\n    @Override\n    protected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String target)\n    {\n        if (targetNick.equals(this.getNick())) {\n            // We are invited\n            Message message = new Message(service.getString(R.string.message_invite_you, sourceNick, target));\n            server.getConversation(server.getSelectedConversation()).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                server.getSelectedConversation()\n            );\n            service.sendBroadcast(intent);\n        } else {\n            // Someone is invited\n            Message message = new Message(service.getString(R.string.message_invite_someone, sourceNick, targetNick, target));\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Join\n     */\n    @Override\n    protected void onJoin(String target, String sender, String login, String hostname)\n    {\n        if (sender.equalsIgnoreCase(getNick())) {\n            // We joined a new channel\n            server.addConversation(new Channel(target));\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_NEW,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        } else if (service.getSettings().showJoinPartAndQuit()) {\n            Message message = new Message(\n                service.getString(R.string.message_join, sender),\n                Message.TYPE_MISC\n            );\n\n            message.setIcon(R.drawable.join);\n            message.setColor(Message.COLOR_GREEN);\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Kick\n     */\n    @Override\n    protected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n    {\n        if (recipientNick.equals(getNick())) {\n            // We are kicked\n            server.removeConversation(target);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_REMOVE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        } else {\n            Message message = new Message(service.getString(R.string.message_kick, kickerNick, recipientNick));\n            message.setColor(Message.COLOR_GREEN);\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Message\n     */\n    @Override\n    protected void onMessage(String target, String sender, String login, String hostname, String text)\n    {\n        Message message = new Message(text, sender);\n\n        if (isMentioned(text)) {\n            // highlight\n            message.setColor(Message.COLOR_RED);\n            service.updateNotification(\n                target + \": <\" + sender + \"> \" + text,\n                service.getSettings().isVibrateHighlightEnabled(),\n                service.getSettings().isSoundHighlightEnabled()\n            );\n\n            server.getConversation(target).setStatus(Conversation.STATUS_HIGHLIGHT);\n        }\n\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On Mode\n     */\n    @Override\n    protected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n    {\n        // Disabled as it doubles events (e.g. onOp and onMode will be called)\n\n        /*\n        Message message = new Message(sourceNick + \" sets mode \" + mode);\n        server.getChannel(target).addMessage(message);\n\n        Intent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n        intent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n        intent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n        service.sendBroadcast(intent);\n         */\n    }\n\n    /**\n     * On Nick Change\n     */\n    @Override\n    protected void onNickChange(String oldNick, String login, String hostname, String newNick)\n    {\n        if (getNick().equalsIgnoreCase(newNick)) {\n            this.updateNickMatchPattern();\n\n            // Send message about own change to server info window\n            Message message = new Message(service.getString(R.string.message_self_rename, newNick));\n            message.setColor(Message.COLOR_GREEN);\n            server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                ServerInfo.DEFAULT_NAME\n            );\n\n            service.sendBroadcast(intent);\n        }\n\n        Vector<String> channels = getChannelsByNickname(newNick);\n\n        for (String target : channels) {\n            Message message = new Message(service.getString(R.string.message_rename, oldNick, newNick));\n            message.setColor(Message.COLOR_GREEN);\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Notice\n     */\n    @Override\n    protected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n    {\n        // Post notice to currently selected conversation\n        Conversation conversation;\n\n        if (service.getSettings().showNoticeInServerWindow()) {\n            conversation = server.getConversation(ServerInfo.DEFAULT_NAME);\n        } else {\n            conversation = server.getConversation(server.getSelectedConversation());\n\n            if (conversation == null) {\n                // Fallback: Use ServerInfo view\n                conversation = server.getConversation(ServerInfo.DEFAULT_NAME);\n            }\n        }\n\n        Message message = new Message(\"-\" + sourceNick + \"- \" + notice);\n        message.setIcon(R.drawable.info);\n        conversation.addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            conversation.getName()\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On Op\n     */\n    @Override\n    protected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n    {\n        Message message = new Message(service.getString(R.string.message_op, sourceNick, recipient));\n        message.setColor(Message.COLOR_BLUE);\n        message.setIcon(R.drawable.op);\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On Part\n     */\n    @Override\n    protected void onPart(String target, String sender, String login, String hostname)\n    {\n        if (sender.equals(getNick())) {\n            // We parted a channel\n            server.removeConversation(target);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_REMOVE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        } else if (service.getSettings().showJoinPartAndQuit()) {\n            Message message = new Message(\n                service.getString(R.string.message_part, sender),\n                Message.TYPE_MISC\n            );\n\n            message.setColor(Message.COLOR_GREEN);\n            message.setIcon(R.drawable.part);\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Private Message\n     */\n    @Override\n    protected void onPrivateMessage(String sender, String login, String hostname, String text)\n    {\n        Message message = new Message(\"<\" + sender + \"> \" + text);\n\n        Conversation conversation = server.getConversation(sender);\n\n        if (conversation == null) {\n            // Open a query if there's none yet\n            conversation = new Query(sender);\n            conversation.addMessage(message);\n            server.addConversation(conversation);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_NEW,\n                server.getId(),\n                sender\n            );\n            service.sendBroadcast(intent);\n        } else {\n            conversation.addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                sender\n            );\n            service.sendBroadcast(intent);\n        }\n\n        service.updateNotification(\n            \"<\" + sender + \"> \" + text,\n            service.getSettings().isVibrateHighlightEnabled(),\n            service.getSettings().isSoundHighlightEnabled()\n        );\n\n        if (isMentioned(text)) {\n            message.setColor(Message.COLOR_RED);\n            conversation.setStatus(Conversation.STATUS_HIGHLIGHT);\n        }\n    }\n\n    /**\n     * On Quit\n     */\n    @Override\n    protected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n    {\n        if (sourceNick.equals(this.getNick())) {\n            return;\n        }\n\n        if (service.getSettings().showJoinPartAndQuit()) {\n            Vector<String> channels = getChannelsByNickname(sourceNick);\n\n            for (String target : channels) {\n                Message message = new Message(\n                    service.getString(R.string.message_quit, sourceNick, reason),\n                    Message.TYPE_MISC\n                );\n\n                message.setColor(Message.COLOR_GREEN);\n                message.setIcon(R.drawable.quit);\n                server.getConversation(target).addMessage(message);\n\n                Intent intent = Broadcast.createConversationIntent(\n                    Broadcast.CONVERSATION_MESSAGE,\n                    server.getId(),\n                    target\n                );\n                service.sendBroadcast(intent);\n            }\n\n            // Look if there's a query to update\n            Conversation conversation = server.getConversation(sourceNick);\n\n            if (conversation != null) {\n                Message message = new Message(\n                    service.getString(R.string.message_quit, sourceNick, reason),\n                    Message.TYPE_MISC\n                );\n\n                message.setColor(Message.COLOR_GREEN);\n                message.setIcon(R.drawable.quit);\n                conversation.addMessage(message);\n\n                Intent intent = Broadcast.createConversationIntent(\n                    Broadcast.CONVERSATION_MESSAGE,\n                    server.getId(),\n                    conversation.getName()\n                );\n                service.sendBroadcast(intent);\n            }\n        }\n    }\n\n    /**\n     * On Topic\n     */\n    @Override\n    public void onTopic(String target, String topic, String setBy, long date, boolean changed)\n    {\n        if (changed) {\n            Message message = new Message(service.getString(R.string.message_topic_set, setBy, topic));\n            message.setColor(Message.COLOR_YELLOW);\n            server.getConversation(target).addMessage(message);\n        } else {\n            Message message = new Message(service.getString(R.string.message_topic, topic));\n            message.setColor(Message.COLOR_YELLOW);\n            server.getConversation(target).addMessage(message);\n        }\n\n        // remember channel's topic\n        ((Channel) server.getConversation(target)).setTopic(topic);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On User List\n     */\n    @Override\n    protected void onUserList(String channel, User[] users)\n    {\n        // XXX: Store user list somewhere and keep it updated or just broadcast some event?\n    }\n\n    /**\n     * On Voice\n     */\n    @Override\n    protected void onVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n    {\n        Message message = new Message(service.getString(R.string.message_voice, sourceNick, recipient));\n        message.setIcon(R.drawable.voice);\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On remove channel key\n     */\n    @Override\n    protected void onRemoveChannelKey(String target, String sourceNick, String sourceLogin, String sourceHostname, String key)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_channel_key, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set channel key\n     */\n    @Override\n    protected void onSetChannelKey(String target, String sourceNick, String sourceLogin, String sourceHostname, String key)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_key, sourceNick, key));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set secret\n     */\n    @Override\n    protected void onSetSecret(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_secret, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove secret\n     */\n    @Override\n    protected void onRemoveSecret(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_public, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set channel limit\n     */\n    @Override\n    protected void onSetChannelLimit(String target, String sourceNick, String sourceLogin, String sourceHostname, int limit)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_limit, sourceNick, limit));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove channel limit\n     */\n    @Override\n    protected void onRemoveChannelLimit(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_channel_limit, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set channel ban\n     */\n    @Override\n    protected void onSetChannelBan(String target, String sourceNick, String sourceLogin, String sourceHostname, String hostmask)\n    {\n        Message message = new Message(service.getString(R.string.message_set_ban, sourceNick, hostmask));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove channel ban\n     */\n    @Override\n    protected void onRemoveChannelBan(String target, String sourceNick, String sourceLogin, String sourceHostname, String hostmask)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_ban, sourceNick, hostmask));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set topic protection\n     */\n    @Override\n    protected void onSetTopicProtection(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_topic_protection, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove topic protection\n     */\n    @Override\n    protected void onRemoveTopicProtection(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_topic_protection, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set no external messages\n     */\n    @Override\n    protected void onSetNoExternalMessages(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_disable_external, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove no external messages\n     */\n    @Override\n    protected void onRemoveNoExternalMessages(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_enable_external, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set invite only\n     */\n    @Override\n    protected void onSetInviteOnly(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_invite_only, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove invite only\n     */\n    @Override\n    protected void onRemoveInviteOnly(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_invite_only, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set moderated\n     */\n    @Override\n    protected void onSetModerated(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_moderated, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove moderated\n     */\n    @Override\n    protected void onRemoveModerated(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_moderated, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set private\n     */\n    @Override\n    protected void onSetPrivate(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_private, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove private\n     */\n    @Override\n    protected void onRemovePrivate(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_public, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On unknown\n     */\n    @Override\n    protected void onUnknown(String line)\n    {\n        Message message = new Message(line);\n        message.setIcon(R.drawable.action);\n        message.setColor(Message.COLOR_GREY);\n        server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            ServerInfo.DEFAULT_NAME\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On server response\n     */\n    @Override\n    protected void onServerResponse(int code, String response)\n    {\n        if (code == 4) {\n            // User has registered with the server\n            onRegister();\n            return;\n        }\n        if (code == 372 || code == 375 || code == 376) {\n            // Skip MOTD\n            return;\n        }\n\n        if (code >= 200 && code < 300) {\n            // Skip 2XX responses\n            return;\n        }\n\n        if (code == 353 || code == 366 || code == 332 || code == 333) {\n            return;\n        }\n\n        if (code < 10) {\n            // Skip server info\n            return;\n        }\n\n        // Currently disabled... to much text\n        Message message = new Message(response);\n        message.setColor(Message.COLOR_GREY);\n        server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            ServerInfo.DEFAULT_NAME\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On disconnect\n     */\n    @Override\n    public void onDisconnect()\n    {\n        // Call parent method to ensure \"register\" status is tracked\n        super.onDisconnect();\n\n        if (service.getSettings().isReconnectEnabled() && server.getStatus() != Status.DISCONNECTED) {\n            setAutojoinChannels(server.getCurrentChannelNames());\n\n            server.clearConversations();\n            server.setStatus(Status.CONNECTING);\n            service.connect(server);\n        } else {\n            server.setStatus(Status.DISCONNECTED);\n        }\n\n        service.updateNotification(service.getString(R.string.notification_disconnected, server.getTitle()));\n\n        Intent sIntent = Broadcast.createServerIntent(Broadcast.SERVER_UPDATE, server.getId());\n        service.sendBroadcast(sIntent);\n\n        Collection<Conversation> conversations = server.getConversations();\n\n        for (Conversation conversation : conversations) {\n            Message message = new Message(service.getString(R.string.message_disconnected));\n            message.setIcon(R.drawable.error);\n            message.setColor(Message.COLOR_RED);\n            server.getConversation(conversation.getName()).addMessage(message);\n\n            Intent cIntent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                conversation.getName()\n            );\n            service.sendBroadcast(cIntent);\n        }\n    }\n\n    /**\n     * Get all channels where the user with the given nickname is online\n     * \n     * @param nickname\n     * @return Array of channel names\n     */\n    private Vector<String> getChannelsByNickname(String nickname)\n    {\n        Vector<String> channels = new Vector<String>();\n        String[] channelArray = getChannels();\n\n        for (String channel : channelArray) {\n            User[] userArray = getUsers(channel);\n            for (User user : userArray) {\n                if (user.getNick().equals(nickname)) {\n                    channels.add(channel);\n                    break;\n                }\n            }\n        }\n\n        return channels;\n    }\n\n    /**\n     * Get list of users in a channel as array of strings\n     * \n     * @param channel Name of the channel\n     */\n    public String[] getUsersAsStringArray(String channel)\n    {\n        User[] userArray = getUsers(channel);\n        int mLength = userArray.length;\n        String[] users = new String[mLength];\n\n        for (int i = 0; i < mLength; i++) {\n            users[i] = userArray[i].getPrefix() + userArray[i].getNick();\n        }\n\n        return users;\n    }\n\n    /**\n     * Get a user by channel and nickname\n     * \n     * @param channel The channel the user is in\n     * @param nickname The nickname of the user (with or without prefix)\n     * @return the User object or null if user was not found\n     */\n    public User getUser(String channel, String nickname)\n    {\n        User[] users = getUsers(channel);\n        int mLength = users.length;\n\n        for (int i = 0; i < mLength; i++) {\n            if (nickname.equals(users[i].getNick())) {\n                return users[i];\n            }\n            if (nickname.equals(users[i].getPrefix() + users[i].getNick())) {\n                return users[i];\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Quits from the IRC server with default reason.\n     */\n    @Override\n    public void quitServer()\n    {\n        new Thread() {\n            @Override\n            public void run() {\n                quitServer(service.getSettings().getQuitMessage());\n            }\n        }.start();\n    }\n\n    /**\n     * Check whether the nickname has been mentioned.\n     * \n     * @param text The text to check for the nickname\n     * @return true if nickname was found, otherwise false\n     */\n    public boolean isMentioned(String text)\n    {\n        return mNickMatch.matcher(text).find();\n    }\n\n    /**\n     * Update the nick matching pattern, should be called when the nickname changes.\n     */\n    private void updateNickMatchPattern()\n    {\n        mNickMatch = Pattern.compile(\"(?:^|[\\\\s?!'�:;,.])\"+Pattern.quote(getNick())+\"(?:[\\\\s?!'�:;,.]|$)\", Pattern.CASE_INSENSITIVE);\n    }\n}\n","Method after Refactoring":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2011 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage org.yaaic.irc;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Vector;\nimport java.util.regex.Pattern;\n\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.command.CommandParser;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Query;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.ServerInfo;\nimport org.yaaic.model.Status;\n\nimport android.content.Intent;\n\n/**\n * The class that actually handles the connection to an IRC server\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class IRCConnection extends PircBot\n{\n    private final IRCService service;\n    private final Server server;\n    private ArrayList<String> autojoinChannels;\n    private Pattern mNickMatch;\n\n    /**\n     * Create a new connection\n     * \n     * @param service\n     * @param serverId\n     */\n    public IRCConnection(IRCService service, int serverId)\n    {\n        this.server = Yaaic.getInstance().getServerById(serverId);\n        this.service = service;\n\n        // XXX: Should be configurable via settings\n        this.setAutoNickChange(true);\n\n        this.setFinger(\"http://www.youtube.com/watch?v=oHg5SJYRHA0\");\n        this.updateNickMatchPattern();\n    }\n\n    /**\n     * Set the nickname of the user\n     * \n     * @param nickname The nickname to use\n     */\n    public void setNickname(String nickname)\n    {\n        this.setName(nickname);\n        this.updateNickMatchPattern();\n    }\n\n    /**\n     * Set the real name of the user\n     * \n     * @param realname The realname to use\n     */\n    public void setRealName(String realname)\n    {\n        // XXX: Pircbot uses the version for \"real name\" and \"version\".\n        //      The real \"version\" value is provided by onVersion()\n        this.setVersion(realname);\n    }\n\n    /**\n     * Set channels to autojoin after connect\n     * \n     * @param channels\n     */\n    public void setAutojoinChannels(ArrayList<String> channels)\n    {\n        autojoinChannels = channels;\n    }\n\n    /**\n     * On version (CTCP version)\n     * \n     * This is a fix for pircbot as pircbot uses the version as \"real name\" and as \"version\"\n     */\n    @Override\n    protected void onVersion(String sourceNick, String sourceLogin,    String sourceHostname, String target)\n    {\n        this.sendRawLine(\n            \"NOTICE \" + sourceNick + \" :\\u0001VERSION \" +\n            \"Yaaic - Yet another Android IRC client - http://www.yaaic.org\" +\n            \"\\u0001\"\n        );\n    }\n\n    /**\n     * Set the ident of the user\n     * \n     * @param ident The ident to use\n     */\n    public void setIdent(String ident)\n    {\n        this.setLogin(ident);\n    }\n\n    /**\n     * On connect\n     */\n    @Override\n    public void onConnect()\n    {\n        server.setStatus(Status.CONNECTED);\n\n        service.sendBroadcast(\n            Broadcast.createServerIntent(Broadcast.SERVER_UPDATE, server.getId())\n        );\n\n        service.updateNotification(service.getString(R.string.notification_connected, server.getTitle()));\n\n        Message message = new Message(service.getString(R.string.message_connected, server.getTitle()));\n        message.setColor(Message.COLOR_GREEN);\n        server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            ServerInfo.DEFAULT_NAME\n        );\n\n        service.sendBroadcast(intent);\n    }\n\n\n    /**\n     * On register\n     */\n    @Override\n    public void onRegister()\n    {\n        // Call parent method to ensure \"register\" status is tracked\n        super.onRegister();\n\n        // execute commands\n        CommandParser parser = CommandParser.getInstance();\n\n        this.updateNickMatchPattern();\n        for (String command : server.getConnectCommands()) {\n            parser.parse(command, server, server.getConversation(ServerInfo.DEFAULT_NAME), service);\n        }\n\n        // TODO: Detect \"You are now identified for <nick>\" notices from NickServ and handle\n        //       auto joins in onNotice instead if the user has chosen to wait for NickServ\n        //       identification before auto joining channels.\n\n        // delay 1 sec before auto joining channels\n        try {\n            Thread.sleep(1000);\n        } catch(InterruptedException e) {\n            // do nothing\n        }\n\n        // join channels\n        if (autojoinChannels != null) {\n            for (String channel : autojoinChannels) {\n                // Add support for channel keys\n                joinChannel(channel);\n            }\n        } else {\n            for (String channel : server.getAutoJoinChannels()) {\n                joinChannel(channel);\n            }\n        }\n    }\n    /**\n     * On channel action\n     */\n    @Override\n    protected void onAction(String sender, String login, String hostname, String target, String action)\n    {\n        Conversation conversation;\n\n        Message message = new Message(sender + \" \" + action);\n        message.setIcon(R.drawable.action);\n\n        String queryNick = target;\n        if (queryNick.equals(this.getNick())) {\n            // We are the target - this is an action in a query\n            queryNick = sender;\n        }\n        conversation = server.getConversation(queryNick);\n\n        if (conversation == null) {\n            // Open a query if there's none yet\n            conversation = new Query(queryNick);\n            server.addConversation(conversation);\n            conversation.addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_NEW,\n                server.getId(),\n                queryNick\n            );\n            service.sendBroadcast(intent);\n        } else {\n            conversation.addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                queryNick\n            );\n            service.sendBroadcast(intent);\n        }\n\n        if (sender.equals(this.getNick())) {\n           // Don't notify for something sent in our name\n           return;\n        }\n\n        boolean mentioned = isMentioned(action);\n        if (mentioned || target.equals(this.getNick())) {\n            service.updateNotification(\n                target + \": \" + sender + \" \" + action,\n                service.getSettings().isVibrateHighlightEnabled(),\n                service.getSettings().isSoundHighlightEnabled()\n            );\n        }\n\n        if (mentioned) {\n            // highlight\n            message.setColor(Message.COLOR_RED);\n            conversation.setStatus(Conversation.STATUS_HIGHLIGHT);\n        }\n    }\n\n    /**\n     * On Channel Info\n     */\n    @Override\n    protected void onChannelInfo(String channel, int userCount, String topic)\n    {\n    }\n\n    /**\n     * On Deop\n     */\n    @Override\n    protected void onDeop(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n    {\n        Message message = new Message(service.getString(R.string.message_deop, sourceNick, recipient));\n        message.setIcon(R.drawable.op);\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On DeVoice\n     */\n    @Override\n    protected void onDeVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n    {\n        Message message = new Message(service.getString(R.string.message_devoice, sourceNick, recipient));\n        message.setColor(Message.COLOR_BLUE);\n        message.setIcon(R.drawable.voice);\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On Invite\n     */\n    @Override\n    protected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String target)\n    {\n        if (targetNick.equals(this.getNick())) {\n            // We are invited\n            Message message = new Message(service.getString(R.string.message_invite_you, sourceNick, target));\n            server.getConversation(server.getSelectedConversation()).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                server.getSelectedConversation()\n            );\n            service.sendBroadcast(intent);\n        } else {\n            // Someone is invited\n            Message message = new Message(service.getString(R.string.message_invite_someone, sourceNick, targetNick, target));\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Join\n     */\n    @Override\n    protected void onJoin(String target, String sender, String login, String hostname)\n    {\n        if (sender.equalsIgnoreCase(getNick())) {\n            // We joined a new channel\n            server.addConversation(new Channel(target));\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_NEW,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        } else if (service.getSettings().showJoinPartAndQuit()) {\n            Message message = new Message(\n                service.getString(R.string.message_join, sender),\n                Message.TYPE_MISC\n            );\n\n            message.setIcon(R.drawable.join);\n            message.setColor(Message.COLOR_GREEN);\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Kick\n     */\n    @Override\n    protected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n    {\n        if (recipientNick.equals(getNick())) {\n            // We are kicked\n            server.removeConversation(target);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_REMOVE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        } else {\n            Message message = new Message(service.getString(R.string.message_kick, kickerNick, recipientNick));\n            message.setColor(Message.COLOR_GREEN);\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Message\n     */\n    @Override\n    protected void onMessage(String target, String sender, String login, String hostname, String text)\n    {\n        Message message = new Message(text, sender);\n\n        if (isMentioned(text)) {\n            // highlight\n            message.setColor(Message.COLOR_RED);\n            service.updateNotification(\n                target + \": <\" + sender + \"> \" + text,\n                service.getSettings().isVibrateHighlightEnabled(),\n                service.getSettings().isSoundHighlightEnabled()\n            );\n\n            server.getConversation(target).setStatus(Conversation.STATUS_HIGHLIGHT);\n        }\n\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On Mode\n     */\n    @Override\n    protected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n    {\n        // Disabled as it doubles events (e.g. onOp and onMode will be called)\n\n        /*\n        Message message = new Message(sourceNick + \" sets mode \" + mode);\n        server.getChannel(target).addMessage(message);\n\n        Intent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n        intent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n        intent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n        service.sendBroadcast(intent);\n         */\n    }\n\n    /**\n     * On Nick Change\n     */\n    @Override\n    protected void onNickChange(String oldNick, String login, String hostname, String newNick)\n    {\n        if (getNick().equalsIgnoreCase(newNick)) {\n            this.updateNickMatchPattern();\n\n            // Send message about own change to server info window\n            Message message = new Message(service.getString(R.string.message_self_rename, newNick));\n            message.setColor(Message.COLOR_GREEN);\n            server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                ServerInfo.DEFAULT_NAME\n            );\n\n            service.sendBroadcast(intent);\n        }\n\n        Vector<String> channels = getChannelsByNickname(newNick);\n\n        for (String target : channels) {\n            Message message = new Message(service.getString(R.string.message_rename, oldNick, newNick));\n            message.setColor(Message.COLOR_GREEN);\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Notice\n     */\n    @Override\n    protected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n    {\n        // Post notice to currently selected conversation\n        Conversation conversation;\n\n        if (service.getSettings().showNoticeInServerWindow()) {\n            conversation = server.getConversation(ServerInfo.DEFAULT_NAME);\n        } else {\n            conversation = server.getConversation(server.getSelectedConversation());\n\n            if (conversation == null) {\n                // Fallback: Use ServerInfo view\n                conversation = server.getConversation(ServerInfo.DEFAULT_NAME);\n            }\n        }\n\n        Message message = new Message(\"-\" + sourceNick + \"- \" + notice);\n        message.setIcon(R.drawable.info);\n        conversation.addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            conversation.getName()\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On Op\n     */\n    @Override\n    protected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n    {\n        Message message = new Message(service.getString(R.string.message_op, sourceNick, recipient));\n        message.setColor(Message.COLOR_BLUE);\n        message.setIcon(R.drawable.op);\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On Part\n     */\n    @Override\n    protected void onPart(String target, String sender, String login, String hostname)\n    {\n        if (sender.equals(getNick())) {\n            // We parted a channel\n            server.removeConversation(target);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_REMOVE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        } else if (service.getSettings().showJoinPartAndQuit()) {\n            Message message = new Message(\n                service.getString(R.string.message_part, sender),\n                Message.TYPE_MISC\n            );\n\n            message.setColor(Message.COLOR_GREEN);\n            message.setIcon(R.drawable.part);\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Private Message\n     */\n    @Override\n    protected void onPrivateMessage(String sender, String login, String hostname, String target, String text)\n    {\n        Message message = new Message(\"<\" + sender + \"> \" + text);\n        String queryNick = sender;\n\n        if (queryNick.equals(this.getNick())) {\n            queryNick = target;\n        }\n        Conversation conversation = server.getConversation(queryNick);\n\n        if (conversation == null) {\n            // Open a query if there's none yet\n            conversation = new Query(queryNick);\n            conversation.addMessage(message);\n            server.addConversation(conversation);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_NEW,\n                server.getId(),\n                queryNick\n            );\n            service.sendBroadcast(intent);\n        } else {\n            conversation.addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                queryNick\n            );\n            service.sendBroadcast(intent);\n        }\n\n        if (sender.equals(this.getNick())) {\n            // Don't notify for something sent in our name\n            return;\n        }\n\n        service.updateNotification(\n            \"<\" + sender + \"> \" + text,\n            service.getSettings().isVibrateHighlightEnabled(),\n            service.getSettings().isSoundHighlightEnabled()\n        );\n\n        if (isMentioned(text)) {\n            message.setColor(Message.COLOR_RED);\n            conversation.setStatus(Conversation.STATUS_HIGHLIGHT);\n        }\n    }\n\n    /**\n     * On Quit\n     */\n    @Override\n    protected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n    {\n        if (sourceNick.equals(this.getNick())) {\n            return;\n        }\n\n        if (service.getSettings().showJoinPartAndQuit()) {\n            Vector<String> channels = getChannelsByNickname(sourceNick);\n\n            for (String target : channels) {\n                Message message = new Message(\n                    service.getString(R.string.message_quit, sourceNick, reason),\n                    Message.TYPE_MISC\n                );\n\n                message.setColor(Message.COLOR_GREEN);\n                message.setIcon(R.drawable.quit);\n                server.getConversation(target).addMessage(message);\n\n                Intent intent = Broadcast.createConversationIntent(\n                    Broadcast.CONVERSATION_MESSAGE,\n                    server.getId(),\n                    target\n                );\n                service.sendBroadcast(intent);\n            }\n\n            // Look if there's a query to update\n            Conversation conversation = server.getConversation(sourceNick);\n\n            if (conversation != null) {\n                Message message = new Message(\n                    service.getString(R.string.message_quit, sourceNick, reason),\n                    Message.TYPE_MISC\n                );\n\n                message.setColor(Message.COLOR_GREEN);\n                message.setIcon(R.drawable.quit);\n                conversation.addMessage(message);\n\n                Intent intent = Broadcast.createConversationIntent(\n                    Broadcast.CONVERSATION_MESSAGE,\n                    server.getId(),\n                    conversation.getName()\n                );\n                service.sendBroadcast(intent);\n            }\n        }\n    }\n\n    /**\n     * On Topic\n     */\n    @Override\n    public void onTopic(String target, String topic, String setBy, long date, boolean changed)\n    {\n        if (changed) {\n            Message message = new Message(service.getString(R.string.message_topic_set, setBy, topic));\n            message.setColor(Message.COLOR_YELLOW);\n            server.getConversation(target).addMessage(message);\n        } else {\n            Message message = new Message(service.getString(R.string.message_topic, topic));\n            message.setColor(Message.COLOR_YELLOW);\n            server.getConversation(target).addMessage(message);\n        }\n\n        // remember channel's topic\n        ((Channel) server.getConversation(target)).setTopic(topic);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On User List\n     */\n    @Override\n    protected void onUserList(String channel, User[] users)\n    {\n        // XXX: Store user list somewhere and keep it updated or just broadcast some event?\n    }\n\n    /**\n     * On Voice\n     */\n    @Override\n    protected void onVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n    {\n        Message message = new Message(service.getString(R.string.message_voice, sourceNick, recipient));\n        message.setIcon(R.drawable.voice);\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On remove channel key\n     */\n    @Override\n    protected void onRemoveChannelKey(String target, String sourceNick, String sourceLogin, String sourceHostname, String key)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_channel_key, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set channel key\n     */\n    @Override\n    protected void onSetChannelKey(String target, String sourceNick, String sourceLogin, String sourceHostname, String key)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_key, sourceNick, key));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set secret\n     */\n    @Override\n    protected void onSetSecret(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_secret, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove secret\n     */\n    @Override\n    protected void onRemoveSecret(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_public, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set channel limit\n     */\n    @Override\n    protected void onSetChannelLimit(String target, String sourceNick, String sourceLogin, String sourceHostname, int limit)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_limit, sourceNick, limit));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove channel limit\n     */\n    @Override\n    protected void onRemoveChannelLimit(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_channel_limit, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set channel ban\n     */\n    @Override\n    protected void onSetChannelBan(String target, String sourceNick, String sourceLogin, String sourceHostname, String hostmask)\n    {\n        Message message = new Message(service.getString(R.string.message_set_ban, sourceNick, hostmask));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove channel ban\n     */\n    @Override\n    protected void onRemoveChannelBan(String target, String sourceNick, String sourceLogin, String sourceHostname, String hostmask)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_ban, sourceNick, hostmask));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set topic protection\n     */\n    @Override\n    protected void onSetTopicProtection(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_topic_protection, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove topic protection\n     */\n    @Override\n    protected void onRemoveTopicProtection(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_topic_protection, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set no external messages\n     */\n    @Override\n    protected void onSetNoExternalMessages(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_disable_external, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove no external messages\n     */\n    @Override\n    protected void onRemoveNoExternalMessages(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_enable_external, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set invite only\n     */\n    @Override\n    protected void onSetInviteOnly(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_invite_only, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove invite only\n     */\n    @Override\n    protected void onRemoveInviteOnly(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_invite_only, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set moderated\n     */\n    @Override\n    protected void onSetModerated(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_moderated, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove moderated\n     */\n    @Override\n    protected void onRemoveModerated(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_moderated, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set private\n     */\n    @Override\n    protected void onSetPrivate(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_private, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove private\n     */\n    @Override\n    protected void onRemovePrivate(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_public, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On unknown\n     */\n    @Override\n    protected void onUnknown(String line)\n    {\n        Message message = new Message(line);\n        message.setIcon(R.drawable.action);\n        message.setColor(Message.COLOR_GREY);\n        server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            ServerInfo.DEFAULT_NAME\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On server response\n     */\n    @Override\n    protected void onServerResponse(int code, String response)\n    {\n        if (code == 4) {\n            // User has registered with the server\n            onRegister();\n            return;\n        }\n        if (code == 372 || code == 375 || code == 376) {\n            // Skip MOTD\n            return;\n        }\n\n        if (code >= 200 && code < 300) {\n            // Skip 2XX responses\n            return;\n        }\n\n        if (code == 353 || code == 366 || code == 332 || code == 333) {\n            return;\n        }\n\n        if (code < 10) {\n            // Skip server info\n            return;\n        }\n\n        // Currently disabled... to much text\n        Message message = new Message(response);\n        message.setColor(Message.COLOR_GREY);\n        server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            ServerInfo.DEFAULT_NAME\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On disconnect\n     */\n    @Override\n    public void onDisconnect()\n    {\n        // Call parent method to ensure \"register\" status is tracked\n        super.onDisconnect();\n\n        if (service.getSettings().isReconnectEnabled() && server.getStatus() != Status.DISCONNECTED) {\n            setAutojoinChannels(server.getCurrentChannelNames());\n\n            server.clearConversations();\n            server.setStatus(Status.CONNECTING);\n            service.connect(server);\n        } else {\n            server.setStatus(Status.DISCONNECTED);\n        }\n\n        service.updateNotification(service.getString(R.string.notification_disconnected, server.getTitle()));\n\n        Intent sIntent = Broadcast.createServerIntent(Broadcast.SERVER_UPDATE, server.getId());\n        service.sendBroadcast(sIntent);\n\n        Collection<Conversation> conversations = server.getConversations();\n\n        for (Conversation conversation : conversations) {\n            Message message = new Message(service.getString(R.string.message_disconnected));\n            message.setIcon(R.drawable.error);\n            message.setColor(Message.COLOR_RED);\n            server.getConversation(conversation.getName()).addMessage(message);\n\n            Intent cIntent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                conversation.getName()\n            );\n            service.sendBroadcast(cIntent);\n        }\n    }\n\n    /**\n     * Get all channels where the user with the given nickname is online\n     * \n     * @param nickname\n     * @return Array of channel names\n     */\n    private Vector<String> getChannelsByNickname(String nickname)\n    {\n        Vector<String> channels = new Vector<String>();\n        String[] channelArray = getChannels();\n\n        for (String channel : channelArray) {\n            User[] userArray = getUsers(channel);\n            for (User user : userArray) {\n                if (user.getNick().equals(nickname)) {\n                    channels.add(channel);\n                    break;\n                }\n            }\n        }\n\n        return channels;\n    }\n\n    /**\n     * Get list of users in a channel as array of strings\n     * \n     * @param channel Name of the channel\n     */\n    public String[] getUsersAsStringArray(String channel)\n    {\n        User[] userArray = getUsers(channel);\n        int mLength = userArray.length;\n        String[] users = new String[mLength];\n\n        for (int i = 0; i < mLength; i++) {\n            users[i] = userArray[i].getPrefix() + userArray[i].getNick();\n        }\n\n        return users;\n    }\n\n    /**\n     * Get a user by channel and nickname\n     * \n     * @param channel The channel the user is in\n     * @param nickname The nickname of the user (with or without prefix)\n     * @return the User object or null if user was not found\n     */\n    public User getUser(String channel, String nickname)\n    {\n        User[] users = getUsers(channel);\n        int mLength = users.length;\n\n        for (int i = 0; i < mLength; i++) {\n            if (nickname.equals(users[i].getNick())) {\n                return users[i];\n            }\n            if (nickname.equals(users[i].getPrefix() + users[i].getNick())) {\n                return users[i];\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Quits from the IRC server with default reason.\n     */\n    @Override\n    public void quitServer()\n    {\n        new Thread() {\n            @Override\n            public void run() {\n                quitServer(service.getSettings().getQuitMessage());\n            }\n        }.start();\n    }\n\n    /**\n     * Check whether the nickname has been mentioned.\n     * \n     * @param text The text to check for the nickname\n     * @return true if nickname was found, otherwise false\n     */\n    public boolean isMentioned(String text)\n    {\n        return mNickMatch.matcher(text).find();\n    }\n\n    /**\n     * Update the nick matching pattern, should be called when the nickname changes.\n     */\n    private void updateNickMatchPattern()\n    {\n        mNickMatch = Pattern.compile(\"(?:^|[\\\\s?!'�:;,.])\"+Pattern.quote(getNick())+\"(?:[\\\\s?!'�:;,.]|$)\", Pattern.CASE_INSENSITIVE);\n    }\n}\n","lineNo":211}
{"Smelly Sample":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2011 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage org.yaaic.irc;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Vector;\nimport java.util.regex.Pattern;\n\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.command.CommandParser;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Query;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.ServerInfo;\nimport org.yaaic.model.Status;\n\nimport android.content.Intent;\n\n/**\n * The class that actually handles the connection to an IRC server\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class IRCConnection extends PircBot\n{\n    private final IRCService service;\n    private final Server server;\n    private ArrayList<String> autojoinChannels;\n    private Pattern mNickMatch;\n\n    /**\n     * Create a new connection\n     * \n     * @param service\n     * @param serverId\n     */\n    public IRCConnection(IRCService service, int serverId)\n    {\n        this.server = Yaaic.getInstance().getServerById(serverId);\n        this.service = service;\n\n        // XXX: Should be configurable via settings\n        this.setAutoNickChange(true);\n\n        this.setFinger(\"http://www.youtube.com/watch?v=oHg5SJYRHA0\");\n        this.updateNickMatchPattern();\n    }\n\n    /**\n     * Set the nickname of the user\n     * \n     * @param nickname The nickname to use\n     */\n    public void setNickname(String nickname)\n    {\n        this.setName(nickname);\n        this.updateNickMatchPattern();\n    }\n\n    /**\n     * Set the real name of the user\n     * \n     * @param realname The realname to use\n     */\n    public void setRealName(String realname)\n    {\n        // XXX: Pircbot uses the version for \"real name\" and \"version\".\n        //      The real \"version\" value is provided by onVersion()\n        this.setVersion(realname);\n    }\n\n    /**\n     * Set channels to autojoin after connect\n     * \n     * @param channels\n     */\n    public void setAutojoinChannels(ArrayList<String> channels)\n    {\n        autojoinChannels = channels;\n    }\n\n    /**\n     * On version (CTCP version)\n     * \n     * This is a fix for pircbot as pircbot uses the version as \"real name\" and as \"version\"\n     */\n    @Override\n    protected void onVersion(String sourceNick, String sourceLogin,    String sourceHostname, String target)\n    {\n        this.sendRawLine(\n            \"NOTICE \" + sourceNick + \" :\\u0001VERSION \" +\n            \"Yaaic - Yet another Android IRC client - http://www.yaaic.org\" +\n            \"\\u0001\"\n        );\n    }\n\n    /**\n     * Set the ident of the user\n     * \n     * @param ident The ident to use\n     */\n    public void setIdent(String ident)\n    {\n        this.setLogin(ident);\n    }\n\n    /**\n     * On connect\n     */\n    @Override\n    public void onConnect()\n    {\n        server.setStatus(Status.CONNECTED);\n\n        service.sendBroadcast(\n            Broadcast.createServerIntent(Broadcast.SERVER_UPDATE, server.getId())\n        );\n\n        service.updateNotification(service.getString(R.string.notification_connected, server.getTitle()));\n\n        Message message = new Message(service.getString(R.string.message_connected, server.getTitle()));\n        message.setColor(Message.COLOR_GREEN);\n        server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            ServerInfo.DEFAULT_NAME\n        );\n\n        service.sendBroadcast(intent);\n    }\n\n\n    /**\n     * On register\n     */\n    @Override\n    public void onRegister()\n    {\n        // Call parent method to ensure \"register\" status is tracked\n        super.onRegister();\n\n        // execute commands\n        CommandParser parser = CommandParser.getInstance();\n\n        this.updateNickMatchPattern();\n        for (String command : server.getConnectCommands()) {\n            parser.parse(command, server, server.getConversation(ServerInfo.DEFAULT_NAME), service);\n        }\n\n        // TODO: Detect \"You are now identified for <nick>\" notices from NickServ and handle\n        //       auto joins in onNotice instead if the user has chosen to wait for NickServ\n        //       identification before auto joining channels.\n\n        // delay 1 sec before auto joining channels\n        try {\n            Thread.sleep(1000);\n        } catch(InterruptedException e) {\n            // do nothing\n        }\n\n        // join channels\n        if (autojoinChannels != null) {\n            for (String channel : autojoinChannels) {\n                // Add support for channel keys\n                joinChannel(channel);\n            }\n        } else {\n            for (String channel : server.getAutoJoinChannels()) {\n                joinChannel(channel);\n            }\n        }\n    }\n    /**\n     * On channel action\n     */\n    @Override\n    protected void onAction(String sender, String login, String hostname, String target, String action)\n    {\n        Conversation conversation;\n\n        Message message = new Message(sender + \" \" + action);\n        message.setIcon(R.drawable.action);\n\n        if (target.equals(this.getNick())) {\n            // We are the target - this is an action in a query\n            conversation = server.getConversation(sender);\n            if (conversation == null) {\n                // Open a query if there's none yet\n                conversation = new Query(sender);\n                server.addConversation(conversation);\n                conversation.addMessage(message);\n\n                Intent intent = Broadcast.createConversationIntent(\n                    Broadcast.CONVERSATION_NEW,\n                    server.getId(),\n                    sender\n                );\n                service.sendBroadcast(intent);\n            } else {\n                conversation.addMessage(message);\n\n                Intent intent = Broadcast.createConversationIntent(\n                    Broadcast.CONVERSATION_MESSAGE,\n                    server.getId(),\n                    sender\n                );\n                service.sendBroadcast(intent);\n            }\n        } else {\n            // A action in a channel\n            conversation = server.getConversation(target);\n            conversation.addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n\n        boolean mentioned = isMentioned(action);\n        if (mentioned || target.equals(this.getNick())) {\n            service.updateNotification(\n                target + \": \" + sender + \" \" + action,\n                service.getSettings().isVibrateHighlightEnabled(),\n                service.getSettings().isSoundHighlightEnabled()\n            );\n        }\n\n        if (mentioned) {\n            // highlight\n            message.setColor(Message.COLOR_RED);\n            conversation.setStatus(Conversation.STATUS_HIGHLIGHT);\n        }\n    }\n\n    /**\n     * On Channel Info\n     */\n    @Override\n    protected void onChannelInfo(String channel, int userCount, String topic)\n    {\n    }\n\n    /**\n     * On Deop\n     */\n    @Override\n    protected void onDeop(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n    {\n        Message message = new Message(service.getString(R.string.message_deop, sourceNick, recipient));\n        message.setIcon(R.drawable.op);\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On DeVoice\n     */\n    @Override\n    protected void onDeVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n    {\n        Message message = new Message(service.getString(R.string.message_devoice, sourceNick, recipient));\n        message.setColor(Message.COLOR_BLUE);\n        message.setIcon(R.drawable.voice);\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On Invite\n     */\n    @Override\n    protected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String target)\n    {\n        if (targetNick.equals(this.getNick())) {\n            // We are invited\n            Message message = new Message(service.getString(R.string.message_invite_you, sourceNick, target));\n            server.getConversation(server.getSelectedConversation()).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                server.getSelectedConversation()\n            );\n            service.sendBroadcast(intent);\n        } else {\n            // Someone is invited\n            Message message = new Message(service.getString(R.string.message_invite_someone, sourceNick, targetNick, target));\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Join\n     */\n    @Override\n    protected void onJoin(String target, String sender, String login, String hostname)\n    {\n        if (sender.equalsIgnoreCase(getNick())) {\n            // We joined a new channel\n            server.addConversation(new Channel(target));\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_NEW,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        } else if (service.getSettings().showJoinPartAndQuit()) {\n            Message message = new Message(\n                service.getString(R.string.message_join, sender),\n                Message.TYPE_MISC\n            );\n\n            message.setIcon(R.drawable.join);\n            message.setColor(Message.COLOR_GREEN);\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Kick\n     */\n    @Override\n    protected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n    {\n        if (recipientNick.equals(getNick())) {\n            // We are kicked\n            server.removeConversation(target);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_REMOVE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        } else {\n            Message message = new Message(service.getString(R.string.message_kick, kickerNick, recipientNick));\n            message.setColor(Message.COLOR_GREEN);\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Message\n     */\n    @Override\n    protected void onMessage(String target, String sender, String login, String hostname, String text)\n    {\n        Message message = new Message(text, sender);\n\n        if (isMentioned(text)) {\n            // highlight\n            message.setColor(Message.COLOR_RED);\n            service.updateNotification(\n                target + \": <\" + sender + \"> \" + text,\n                service.getSettings().isVibrateHighlightEnabled(),\n                service.getSettings().isSoundHighlightEnabled()\n            );\n\n            server.getConversation(target).setStatus(Conversation.STATUS_HIGHLIGHT);\n        }\n\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On Mode\n     */\n    @Override\n    protected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n    {\n        // Disabled as it doubles events (e.g. onOp and onMode will be called)\n\n        /*\n        Message message = new Message(sourceNick + \" sets mode \" + mode);\n        server.getChannel(target).addMessage(message);\n\n        Intent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n        intent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n        intent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n        service.sendBroadcast(intent);\n         */\n    }\n\n    /**\n     * On Nick Change\n     */\n    @Override\n    protected void onNickChange(String oldNick, String login, String hostname, String newNick)\n    {\n        if (getNick().equalsIgnoreCase(newNick)) {\n            this.updateNickMatchPattern();\n\n            // Send message about own change to server info window\n            Message message = new Message(service.getString(R.string.message_self_rename, newNick));\n            message.setColor(Message.COLOR_GREEN);\n            server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                ServerInfo.DEFAULT_NAME\n            );\n\n            service.sendBroadcast(intent);\n        }\n\n        Vector<String> channels = getChannelsByNickname(newNick);\n\n        for (String target : channels) {\n            Message message = new Message(service.getString(R.string.message_rename, oldNick, newNick));\n            message.setColor(Message.COLOR_GREEN);\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Notice\n     */\n    @Override\n    protected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n    {\n        // Post notice to currently selected conversation\n        Conversation conversation;\n\n        if (service.getSettings().showNoticeInServerWindow()) {\n            conversation = server.getConversation(ServerInfo.DEFAULT_NAME);\n        } else {\n            conversation = server.getConversation(server.getSelectedConversation());\n\n            if (conversation == null) {\n                // Fallback: Use ServerInfo view\n                conversation = server.getConversation(ServerInfo.DEFAULT_NAME);\n            }\n        }\n\n        Message message = new Message(\"-\" + sourceNick + \"- \" + notice);\n        message.setIcon(R.drawable.info);\n        conversation.addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            conversation.getName()\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On Op\n     */\n    @Override\n    protected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n    {\n        Message message = new Message(service.getString(R.string.message_op, sourceNick, recipient));\n        message.setColor(Message.COLOR_BLUE);\n        message.setIcon(R.drawable.op);\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On Part\n     */\n    @Override\n    protected void onPart(String target, String sender, String login, String hostname)\n    {\n        if (sender.equals(getNick())) {\n            // We parted a channel\n            server.removeConversation(target);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_REMOVE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        } else if (service.getSettings().showJoinPartAndQuit()) {\n            Message message = new Message(\n                service.getString(R.string.message_part, sender),\n                Message.TYPE_MISC\n            );\n\n            message.setColor(Message.COLOR_GREEN);\n            message.setIcon(R.drawable.part);\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Private Message\n     */\n    @Override\n    protected void onPrivateMessage(String sender, String login, String hostname, String text)\n    {\n        Message message = new Message(\"<\" + sender + \"> \" + text);\n\n        Conversation conversation = server.getConversation(sender);\n\n        if (conversation == null) {\n            // Open a query if there's none yet\n            conversation = new Query(sender);\n            conversation.addMessage(message);\n            server.addConversation(conversation);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_NEW,\n                server.getId(),\n                sender\n            );\n            service.sendBroadcast(intent);\n        } else {\n            conversation.addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                sender\n            );\n            service.sendBroadcast(intent);\n        }\n\n        service.updateNotification(\n            \"<\" + sender + \"> \" + text,\n            service.getSettings().isVibrateHighlightEnabled(),\n            service.getSettings().isSoundHighlightEnabled()\n        );\n\n        if (isMentioned(text)) {\n            message.setColor(Message.COLOR_RED);\n            conversation.setStatus(Conversation.STATUS_HIGHLIGHT);\n        }\n    }\n\n    /**\n     * On Quit\n     */\n    @Override\n    protected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n    {\n        if (sourceNick.equals(this.getNick())) {\n            return;\n        }\n\n        if (service.getSettings().showJoinPartAndQuit()) {\n            Vector<String> channels = getChannelsByNickname(sourceNick);\n\n            for (String target : channels) {\n                Message message = new Message(\n                    service.getString(R.string.message_quit, sourceNick, reason),\n                    Message.TYPE_MISC\n                );\n\n                message.setColor(Message.COLOR_GREEN);\n                message.setIcon(R.drawable.quit);\n                server.getConversation(target).addMessage(message);\n\n                Intent intent = Broadcast.createConversationIntent(\n                    Broadcast.CONVERSATION_MESSAGE,\n                    server.getId(),\n                    target\n                );\n                service.sendBroadcast(intent);\n            }\n\n            // Look if there's a query to update\n            Conversation conversation = server.getConversation(sourceNick);\n\n            if (conversation != null) {\n                Message message = new Message(\n                    service.getString(R.string.message_quit, sourceNick, reason),\n                    Message.TYPE_MISC\n                );\n\n                message.setColor(Message.COLOR_GREEN);\n                message.setIcon(R.drawable.quit);\n                conversation.addMessage(message);\n\n                Intent intent = Broadcast.createConversationIntent(\n                    Broadcast.CONVERSATION_MESSAGE,\n                    server.getId(),\n                    conversation.getName()\n                );\n                service.sendBroadcast(intent);\n            }\n        }\n    }\n\n    /**\n     * On Topic\n     */\n    @Override\n    public void onTopic(String target, String topic, String setBy, long date, boolean changed)\n    {\n        if (changed) {\n            Message message = new Message(service.getString(R.string.message_topic_set, setBy, topic));\n            message.setColor(Message.COLOR_YELLOW);\n            server.getConversation(target).addMessage(message);\n        } else {\n            Message message = new Message(service.getString(R.string.message_topic, topic));\n            message.setColor(Message.COLOR_YELLOW);\n            server.getConversation(target).addMessage(message);\n        }\n\n        // remember channel's topic\n        ((Channel) server.getConversation(target)).setTopic(topic);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On User List\n     */\n    @Override\n    protected void onUserList(String channel, User[] users)\n    {\n        // XXX: Store user list somewhere and keep it updated or just broadcast some event?\n    }\n\n    /**\n     * On Voice\n     */\n    @Override\n    protected void onVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n    {\n        Message message = new Message(service.getString(R.string.message_voice, sourceNick, recipient));\n        message.setIcon(R.drawable.voice);\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On remove channel key\n     */\n    @Override\n    protected void onRemoveChannelKey(String target, String sourceNick, String sourceLogin, String sourceHostname, String key)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_channel_key, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set channel key\n     */\n    @Override\n    protected void onSetChannelKey(String target, String sourceNick, String sourceLogin, String sourceHostname, String key)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_key, sourceNick, key));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set secret\n     */\n    @Override\n    protected void onSetSecret(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_secret, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove secret\n     */\n    @Override\n    protected void onRemoveSecret(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_public, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set channel limit\n     */\n    @Override\n    protected void onSetChannelLimit(String target, String sourceNick, String sourceLogin, String sourceHostname, int limit)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_limit, sourceNick, limit));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove channel limit\n     */\n    @Override\n    protected void onRemoveChannelLimit(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_channel_limit, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set channel ban\n     */\n    @Override\n    protected void onSetChannelBan(String target, String sourceNick, String sourceLogin, String sourceHostname, String hostmask)\n    {\n        Message message = new Message(service.getString(R.string.message_set_ban, sourceNick, hostmask));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove channel ban\n     */\n    @Override\n    protected void onRemoveChannelBan(String target, String sourceNick, String sourceLogin, String sourceHostname, String hostmask)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_ban, sourceNick, hostmask));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set topic protection\n     */\n    @Override\n    protected void onSetTopicProtection(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_topic_protection, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove topic protection\n     */\n    @Override\n    protected void onRemoveTopicProtection(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_topic_protection, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set no external messages\n     */\n    @Override\n    protected void onSetNoExternalMessages(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_disable_external, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove no external messages\n     */\n    @Override\n    protected void onRemoveNoExternalMessages(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_enable_external, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set invite only\n     */\n    @Override\n    protected void onSetInviteOnly(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_invite_only, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove invite only\n     */\n    @Override\n    protected void onRemoveInviteOnly(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_invite_only, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set moderated\n     */\n    @Override\n    protected void onSetModerated(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_moderated, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove moderated\n     */\n    @Override\n    protected void onRemoveModerated(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_moderated, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set private\n     */\n    @Override\n    protected void onSetPrivate(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_private, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove private\n     */\n    @Override\n    protected void onRemovePrivate(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_public, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On unknown\n     */\n    @Override\n    protected void onUnknown(String line)\n    {\n        Message message = new Message(line);\n        message.setIcon(R.drawable.action);\n        message.setColor(Message.COLOR_GREY);\n        server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            ServerInfo.DEFAULT_NAME\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On server response\n     */\n    @Override\n    protected void onServerResponse(int code, String response)\n    {\n        if (code == 4) {\n            // User has registered with the server\n            onRegister();\n            return;\n        }\n        if (code == 372 || code == 375 || code == 376) {\n            // Skip MOTD\n            return;\n        }\n\n        if (code >= 200 && code < 300) {\n            // Skip 2XX responses\n            return;\n        }\n\n        if (code == 353 || code == 366 || code == 332 || code == 333) {\n            return;\n        }\n\n        if (code < 10) {\n            // Skip server info\n            return;\n        }\n\n        // Currently disabled... to much text\n        Message message = new Message(response);\n        message.setColor(Message.COLOR_GREY);\n        server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            ServerInfo.DEFAULT_NAME\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On disconnect\n     */\n    @Override\n    public void onDisconnect()\n    {\n        // Call parent method to ensure \"register\" status is tracked\n        super.onDisconnect();\n\n        if (service.getSettings().isReconnectEnabled() && server.getStatus() != Status.DISCONNECTED) {\n            setAutojoinChannels(server.getCurrentChannelNames());\n\n            server.clearConversations();\n            server.setStatus(Status.CONNECTING);\n            service.connect(server);\n        } else {\n            server.setStatus(Status.DISCONNECTED);\n        }\n\n        service.updateNotification(service.getString(R.string.notification_disconnected, server.getTitle()));\n\n        Intent sIntent = Broadcast.createServerIntent(Broadcast.SERVER_UPDATE, server.getId());\n        service.sendBroadcast(sIntent);\n\n        Collection<Conversation> conversations = server.getConversations();\n\n        for (Conversation conversation : conversations) {\n            Message message = new Message(service.getString(R.string.message_disconnected));\n            message.setIcon(R.drawable.error);\n            message.setColor(Message.COLOR_RED);\n            server.getConversation(conversation.getName()).addMessage(message);\n\n            Intent cIntent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                conversation.getName()\n            );\n            service.sendBroadcast(cIntent);\n        }\n    }\n\n    /**\n     * Get all channels where the user with the given nickname is online\n     * \n     * @param nickname\n     * @return Array of channel names\n     */\n    private Vector<String> getChannelsByNickname(String nickname)\n    {\n        Vector<String> channels = new Vector<String>();\n        String[] channelArray = getChannels();\n\n        for (String channel : channelArray) {\n            User[] userArray = getUsers(channel);\n            for (User user : userArray) {\n                if (user.getNick().equals(nickname)) {\n                    channels.add(channel);\n                    break;\n                }\n            }\n        }\n\n        return channels;\n    }\n\n    /**\n     * Get list of users in a channel as array of strings\n     * \n     * @param channel Name of the channel\n     */\n    public String[] getUsersAsStringArray(String channel)\n    {\n        User[] userArray = getUsers(channel);\n        int mLength = userArray.length;\n        String[] users = new String[mLength];\n\n        for (int i = 0; i < mLength; i++) {\n            users[i] = userArray[i].getPrefix() + userArray[i].getNick();\n        }\n\n        return users;\n    }\n\n    /**\n     * Get a user by channel and nickname\n     * \n     * @param channel The channel the user is in\n     * @param nickname The nickname of the user (with or without prefix)\n     * @return the User object or null if user was not found\n     */\n    public User getUser(String channel, String nickname)\n    {\n        User[] users = getUsers(channel);\n        int mLength = users.length;\n\n        for (int i = 0; i < mLength; i++) {\n            if (nickname.equals(users[i].getNick())) {\n                return users[i];\n            }\n            if (nickname.equals(users[i].getPrefix() + users[i].getNick())) {\n                return users[i];\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Quits from the IRC server with default reason.\n     */\n    @Override\n    public void quitServer()\n    {\n        new Thread() {\n            @Override\n            public void run() {\n                quitServer(service.getSettings().getQuitMessage());\n            }\n        }.start();\n    }\n\n    /**\n     * Check whether the nickname has been mentioned.\n     * \n     * @param text The text to check for the nickname\n     * @return true if nickname was found, otherwise false\n     */\n    public boolean isMentioned(String text)\n    {\n        return mNickMatch.matcher(text).find();\n    }\n\n    /**\n     * Update the nick matching pattern, should be called when the nickname changes.\n     */\n    private void updateNickMatchPattern()\n    {\n        mNickMatch = Pattern.compile(\"(?:^|[\\\\s?!'�:;,.])\"+Pattern.quote(getNick())+\"(?:[\\\\s?!'�:;,.]|$)\", Pattern.CASE_INSENSITIVE);\n    }\n}\n","Method after Refactoring":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2011 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage org.yaaic.irc;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Vector;\nimport java.util.regex.Pattern;\n\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.command.CommandParser;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Query;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.ServerInfo;\nimport org.yaaic.model.Status;\n\nimport android.content.Intent;\n\n/**\n * The class that actually handles the connection to an IRC server\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class IRCConnection extends PircBot\n{\n    private final IRCService service;\n    private final Server server;\n    private ArrayList<String> autojoinChannels;\n    private Pattern mNickMatch;\n\n    /**\n     * Create a new connection\n     * \n     * @param service\n     * @param serverId\n     */\n    public IRCConnection(IRCService service, int serverId)\n    {\n        this.server = Yaaic.getInstance().getServerById(serverId);\n        this.service = service;\n\n        // XXX: Should be configurable via settings\n        this.setAutoNickChange(true);\n\n        this.setFinger(\"http://www.youtube.com/watch?v=oHg5SJYRHA0\");\n        this.updateNickMatchPattern();\n    }\n\n    /**\n     * Set the nickname of the user\n     * \n     * @param nickname The nickname to use\n     */\n    public void setNickname(String nickname)\n    {\n        this.setName(nickname);\n        this.updateNickMatchPattern();\n    }\n\n    /**\n     * Set the real name of the user\n     * \n     * @param realname The realname to use\n     */\n    public void setRealName(String realname)\n    {\n        // XXX: Pircbot uses the version for \"real name\" and \"version\".\n        //      The real \"version\" value is provided by onVersion()\n        this.setVersion(realname);\n    }\n\n    /**\n     * Set channels to autojoin after connect\n     * \n     * @param channels\n     */\n    public void setAutojoinChannels(ArrayList<String> channels)\n    {\n        autojoinChannels = channels;\n    }\n\n    /**\n     * On version (CTCP version)\n     * \n     * This is a fix for pircbot as pircbot uses the version as \"real name\" and as \"version\"\n     */\n    @Override\n    protected void onVersion(String sourceNick, String sourceLogin,    String sourceHostname, String target)\n    {\n        this.sendRawLine(\n            \"NOTICE \" + sourceNick + \" :\\u0001VERSION \" +\n            \"Yaaic - Yet another Android IRC client - http://www.yaaic.org\" +\n            \"\\u0001\"\n        );\n    }\n\n    /**\n     * Set the ident of the user\n     * \n     * @param ident The ident to use\n     */\n    public void setIdent(String ident)\n    {\n        this.setLogin(ident);\n    }\n\n    /**\n     * On connect\n     */\n    @Override\n    public void onConnect()\n    {\n        server.setStatus(Status.CONNECTED);\n\n        service.sendBroadcast(\n            Broadcast.createServerIntent(Broadcast.SERVER_UPDATE, server.getId())\n        );\n\n        service.updateNotification(service.getString(R.string.notification_connected, server.getTitle()));\n\n        Message message = new Message(service.getString(R.string.message_connected, server.getTitle()));\n        message.setColor(Message.COLOR_GREEN);\n        server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            ServerInfo.DEFAULT_NAME\n        );\n\n        service.sendBroadcast(intent);\n    }\n\n\n    /**\n     * On register\n     */\n    @Override\n    public void onRegister()\n    {\n        // Call parent method to ensure \"register\" status is tracked\n        super.onRegister();\n\n        // execute commands\n        CommandParser parser = CommandParser.getInstance();\n\n        this.updateNickMatchPattern();\n        for (String command : server.getConnectCommands()) {\n            parser.parse(command, server, server.getConversation(ServerInfo.DEFAULT_NAME), service);\n        }\n\n        // TODO: Detect \"You are now identified for <nick>\" notices from NickServ and handle\n        //       auto joins in onNotice instead if the user has chosen to wait for NickServ\n        //       identification before auto joining channels.\n\n        // delay 1 sec before auto joining channels\n        try {\n            Thread.sleep(1000);\n        } catch(InterruptedException e) {\n            // do nothing\n        }\n\n        // join channels\n        if (autojoinChannels != null) {\n            for (String channel : autojoinChannels) {\n                // Add support for channel keys\n                joinChannel(channel);\n            }\n        } else {\n            for (String channel : server.getAutoJoinChannels()) {\n                joinChannel(channel);\n            }\n        }\n    }\n    /**\n     * On channel action\n     */\n    @Override\n    protected void onAction(String sender, String login, String hostname, String target, String action)\n    {\n        Conversation conversation;\n\n        Message message = new Message(sender + \" \" + action);\n        message.setIcon(R.drawable.action);\n\n        String queryNick = target;\n        if (queryNick.equals(this.getNick())) {\n            // We are the target - this is an action in a query\n            queryNick = sender;\n        }\n        conversation = server.getConversation(queryNick);\n\n        if (conversation == null) {\n            // Open a query if there's none yet\n            conversation = new Query(queryNick);\n            server.addConversation(conversation);\n            conversation.addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_NEW,\n                server.getId(),\n                queryNick\n            );\n            service.sendBroadcast(intent);\n        } else {\n            conversation.addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                queryNick\n            );\n            service.sendBroadcast(intent);\n        }\n\n        if (sender.equals(this.getNick())) {\n           // Don't notify for something sent in our name\n           return;\n        }\n\n        boolean mentioned = isMentioned(action);\n        if (mentioned || target.equals(this.getNick())) {\n            service.updateNotification(\n                target + \": \" + sender + \" \" + action,\n                service.getSettings().isVibrateHighlightEnabled(),\n                service.getSettings().isSoundHighlightEnabled()\n            );\n        }\n\n        if (mentioned) {\n            // highlight\n            message.setColor(Message.COLOR_RED);\n            conversation.setStatus(Conversation.STATUS_HIGHLIGHT);\n        }\n    }\n\n    /**\n     * On Channel Info\n     */\n    @Override\n    protected void onChannelInfo(String channel, int userCount, String topic)\n    {\n    }\n\n    /**\n     * On Deop\n     */\n    @Override\n    protected void onDeop(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n    {\n        Message message = new Message(service.getString(R.string.message_deop, sourceNick, recipient));\n        message.setIcon(R.drawable.op);\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On DeVoice\n     */\n    @Override\n    protected void onDeVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n    {\n        Message message = new Message(service.getString(R.string.message_devoice, sourceNick, recipient));\n        message.setColor(Message.COLOR_BLUE);\n        message.setIcon(R.drawable.voice);\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On Invite\n     */\n    @Override\n    protected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String target)\n    {\n        if (targetNick.equals(this.getNick())) {\n            // We are invited\n            Message message = new Message(service.getString(R.string.message_invite_you, sourceNick, target));\n            server.getConversation(server.getSelectedConversation()).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                server.getSelectedConversation()\n            );\n            service.sendBroadcast(intent);\n        } else {\n            // Someone is invited\n            Message message = new Message(service.getString(R.string.message_invite_someone, sourceNick, targetNick, target));\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Join\n     */\n    @Override\n    protected void onJoin(String target, String sender, String login, String hostname)\n    {\n        if (sender.equalsIgnoreCase(getNick())) {\n            // We joined a new channel\n            server.addConversation(new Channel(target));\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_NEW,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        } else if (service.getSettings().showJoinPartAndQuit()) {\n            Message message = new Message(\n                service.getString(R.string.message_join, sender),\n                Message.TYPE_MISC\n            );\n\n            message.setIcon(R.drawable.join);\n            message.setColor(Message.COLOR_GREEN);\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Kick\n     */\n    @Override\n    protected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n    {\n        if (recipientNick.equals(getNick())) {\n            // We are kicked\n            server.removeConversation(target);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_REMOVE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        } else {\n            Message message = new Message(service.getString(R.string.message_kick, kickerNick, recipientNick));\n            message.setColor(Message.COLOR_GREEN);\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Message\n     */\n    @Override\n    protected void onMessage(String target, String sender, String login, String hostname, String text)\n    {\n        Message message = new Message(text, sender);\n\n        if (isMentioned(text)) {\n            // highlight\n            message.setColor(Message.COLOR_RED);\n            service.updateNotification(\n                target + \": <\" + sender + \"> \" + text,\n                service.getSettings().isVibrateHighlightEnabled(),\n                service.getSettings().isSoundHighlightEnabled()\n            );\n\n            server.getConversation(target).setStatus(Conversation.STATUS_HIGHLIGHT);\n        }\n\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On Mode\n     */\n    @Override\n    protected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n    {\n        // Disabled as it doubles events (e.g. onOp and onMode will be called)\n\n        /*\n        Message message = new Message(sourceNick + \" sets mode \" + mode);\n        server.getChannel(target).addMessage(message);\n\n        Intent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n        intent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n        intent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n        service.sendBroadcast(intent);\n         */\n    }\n\n    /**\n     * On Nick Change\n     */\n    @Override\n    protected void onNickChange(String oldNick, String login, String hostname, String newNick)\n    {\n        if (getNick().equalsIgnoreCase(newNick)) {\n            this.updateNickMatchPattern();\n\n            // Send message about own change to server info window\n            Message message = new Message(service.getString(R.string.message_self_rename, newNick));\n            message.setColor(Message.COLOR_GREEN);\n            server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                ServerInfo.DEFAULT_NAME\n            );\n\n            service.sendBroadcast(intent);\n        }\n\n        Vector<String> channels = getChannelsByNickname(newNick);\n\n        for (String target : channels) {\n            Message message = new Message(service.getString(R.string.message_rename, oldNick, newNick));\n            message.setColor(Message.COLOR_GREEN);\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Notice\n     */\n    @Override\n    protected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n    {\n        // Post notice to currently selected conversation\n        Conversation conversation;\n\n        if (service.getSettings().showNoticeInServerWindow()) {\n            conversation = server.getConversation(ServerInfo.DEFAULT_NAME);\n        } else {\n            conversation = server.getConversation(server.getSelectedConversation());\n\n            if (conversation == null) {\n                // Fallback: Use ServerInfo view\n                conversation = server.getConversation(ServerInfo.DEFAULT_NAME);\n            }\n        }\n\n        Message message = new Message(\"-\" + sourceNick + \"- \" + notice);\n        message.setIcon(R.drawable.info);\n        conversation.addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            conversation.getName()\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On Op\n     */\n    @Override\n    protected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n    {\n        Message message = new Message(service.getString(R.string.message_op, sourceNick, recipient));\n        message.setColor(Message.COLOR_BLUE);\n        message.setIcon(R.drawable.op);\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On Part\n     */\n    @Override\n    protected void onPart(String target, String sender, String login, String hostname)\n    {\n        if (sender.equals(getNick())) {\n            // We parted a channel\n            server.removeConversation(target);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_REMOVE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        } else if (service.getSettings().showJoinPartAndQuit()) {\n            Message message = new Message(\n                service.getString(R.string.message_part, sender),\n                Message.TYPE_MISC\n            );\n\n            message.setColor(Message.COLOR_GREEN);\n            message.setIcon(R.drawable.part);\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Private Message\n     */\n    @Override\n    protected void onPrivateMessage(String sender, String login, String hostname, String target, String text)\n    {\n        Message message = new Message(\"<\" + sender + \"> \" + text);\n        String queryNick = sender;\n\n        if (queryNick.equals(this.getNick())) {\n            queryNick = target;\n        }\n        Conversation conversation = server.getConversation(queryNick);\n\n        if (conversation == null) {\n            // Open a query if there's none yet\n            conversation = new Query(queryNick);\n            conversation.addMessage(message);\n            server.addConversation(conversation);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_NEW,\n                server.getId(),\n                queryNick\n            );\n            service.sendBroadcast(intent);\n        } else {\n            conversation.addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                queryNick\n            );\n            service.sendBroadcast(intent);\n        }\n\n        if (sender.equals(this.getNick())) {\n            // Don't notify for something sent in our name\n            return;\n        }\n\n        service.updateNotification(\n            \"<\" + sender + \"> \" + text,\n            service.getSettings().isVibrateHighlightEnabled(),\n            service.getSettings().isSoundHighlightEnabled()\n        );\n\n        if (isMentioned(text)) {\n            message.setColor(Message.COLOR_RED);\n            conversation.setStatus(Conversation.STATUS_HIGHLIGHT);\n        }\n    }\n\n    /**\n     * On Quit\n     */\n    @Override\n    protected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n    {\n        if (sourceNick.equals(this.getNick())) {\n            return;\n        }\n\n        if (service.getSettings().showJoinPartAndQuit()) {\n            Vector<String> channels = getChannelsByNickname(sourceNick);\n\n            for (String target : channels) {\n                Message message = new Message(\n                    service.getString(R.string.message_quit, sourceNick, reason),\n                    Message.TYPE_MISC\n                );\n\n                message.setColor(Message.COLOR_GREEN);\n                message.setIcon(R.drawable.quit);\n                server.getConversation(target).addMessage(message);\n\n                Intent intent = Broadcast.createConversationIntent(\n                    Broadcast.CONVERSATION_MESSAGE,\n                    server.getId(),\n                    target\n                );\n                service.sendBroadcast(intent);\n            }\n\n            // Look if there's a query to update\n            Conversation conversation = server.getConversation(sourceNick);\n\n            if (conversation != null) {\n                Message message = new Message(\n                    service.getString(R.string.message_quit, sourceNick, reason),\n                    Message.TYPE_MISC\n                );\n\n                message.setColor(Message.COLOR_GREEN);\n                message.setIcon(R.drawable.quit);\n                conversation.addMessage(message);\n\n                Intent intent = Broadcast.createConversationIntent(\n                    Broadcast.CONVERSATION_MESSAGE,\n                    server.getId(),\n                    conversation.getName()\n                );\n                service.sendBroadcast(intent);\n            }\n        }\n    }\n\n    /**\n     * On Topic\n     */\n    @Override\n    public void onTopic(String target, String topic, String setBy, long date, boolean changed)\n    {\n        if (changed) {\n            Message message = new Message(service.getString(R.string.message_topic_set, setBy, topic));\n            message.setColor(Message.COLOR_YELLOW);\n            server.getConversation(target).addMessage(message);\n        } else {\n            Message message = new Message(service.getString(R.string.message_topic, topic));\n            message.setColor(Message.COLOR_YELLOW);\n            server.getConversation(target).addMessage(message);\n        }\n\n        // remember channel's topic\n        ((Channel) server.getConversation(target)).setTopic(topic);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On User List\n     */\n    @Override\n    protected void onUserList(String channel, User[] users)\n    {\n        // XXX: Store user list somewhere and keep it updated or just broadcast some event?\n    }\n\n    /**\n     * On Voice\n     */\n    @Override\n    protected void onVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n    {\n        Message message = new Message(service.getString(R.string.message_voice, sourceNick, recipient));\n        message.setIcon(R.drawable.voice);\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On remove channel key\n     */\n    @Override\n    protected void onRemoveChannelKey(String target, String sourceNick, String sourceLogin, String sourceHostname, String key)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_channel_key, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set channel key\n     */\n    @Override\n    protected void onSetChannelKey(String target, String sourceNick, String sourceLogin, String sourceHostname, String key)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_key, sourceNick, key));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set secret\n     */\n    @Override\n    protected void onSetSecret(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_secret, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove secret\n     */\n    @Override\n    protected void onRemoveSecret(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_public, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set channel limit\n     */\n    @Override\n    protected void onSetChannelLimit(String target, String sourceNick, String sourceLogin, String sourceHostname, int limit)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_limit, sourceNick, limit));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove channel limit\n     */\n    @Override\n    protected void onRemoveChannelLimit(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_channel_limit, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set channel ban\n     */\n    @Override\n    protected void onSetChannelBan(String target, String sourceNick, String sourceLogin, String sourceHostname, String hostmask)\n    {\n        Message message = new Message(service.getString(R.string.message_set_ban, sourceNick, hostmask));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove channel ban\n     */\n    @Override\n    protected void onRemoveChannelBan(String target, String sourceNick, String sourceLogin, String sourceHostname, String hostmask)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_ban, sourceNick, hostmask));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set topic protection\n     */\n    @Override\n    protected void onSetTopicProtection(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_topic_protection, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove topic protection\n     */\n    @Override\n    protected void onRemoveTopicProtection(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_topic_protection, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set no external messages\n     */\n    @Override\n    protected void onSetNoExternalMessages(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_disable_external, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove no external messages\n     */\n    @Override\n    protected void onRemoveNoExternalMessages(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_enable_external, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set invite only\n     */\n    @Override\n    protected void onSetInviteOnly(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_invite_only, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove invite only\n     */\n    @Override\n    protected void onRemoveInviteOnly(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_invite_only, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set moderated\n     */\n    @Override\n    protected void onSetModerated(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_moderated, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove moderated\n     */\n    @Override\n    protected void onRemoveModerated(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_moderated, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set private\n     */\n    @Override\n    protected void onSetPrivate(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_private, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove private\n     */\n    @Override\n    protected void onRemovePrivate(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_public, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On unknown\n     */\n    @Override\n    protected void onUnknown(String line)\n    {\n        Message message = new Message(line);\n        message.setIcon(R.drawable.action);\n        message.setColor(Message.COLOR_GREY);\n        server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            ServerInfo.DEFAULT_NAME\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On server response\n     */\n    @Override\n    protected void onServerResponse(int code, String response)\n    {\n        if (code == 4) {\n            // User has registered with the server\n            onRegister();\n            return;\n        }\n        if (code == 372 || code == 375 || code == 376) {\n            // Skip MOTD\n            return;\n        }\n\n        if (code >= 200 && code < 300) {\n            // Skip 2XX responses\n            return;\n        }\n\n        if (code == 353 || code == 366 || code == 332 || code == 333) {\n            return;\n        }\n\n        if (code < 10) {\n            // Skip server info\n            return;\n        }\n\n        // Currently disabled... to much text\n        Message message = new Message(response);\n        message.setColor(Message.COLOR_GREY);\n        server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            ServerInfo.DEFAULT_NAME\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On disconnect\n     */\n    @Override\n    public void onDisconnect()\n    {\n        // Call parent method to ensure \"register\" status is tracked\n        super.onDisconnect();\n\n        if (service.getSettings().isReconnectEnabled() && server.getStatus() != Status.DISCONNECTED) {\n            setAutojoinChannels(server.getCurrentChannelNames());\n\n            server.clearConversations();\n            server.setStatus(Status.CONNECTING);\n            service.connect(server);\n        } else {\n            server.setStatus(Status.DISCONNECTED);\n        }\n\n        service.updateNotification(service.getString(R.string.notification_disconnected, server.getTitle()));\n\n        Intent sIntent = Broadcast.createServerIntent(Broadcast.SERVER_UPDATE, server.getId());\n        service.sendBroadcast(sIntent);\n\n        Collection<Conversation> conversations = server.getConversations();\n\n        for (Conversation conversation : conversations) {\n            Message message = new Message(service.getString(R.string.message_disconnected));\n            message.setIcon(R.drawable.error);\n            message.setColor(Message.COLOR_RED);\n            server.getConversation(conversation.getName()).addMessage(message);\n\n            Intent cIntent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                conversation.getName()\n            );\n            service.sendBroadcast(cIntent);\n        }\n    }\n\n    /**\n     * Get all channels where the user with the given nickname is online\n     * \n     * @param nickname\n     * @return Array of channel names\n     */\n    private Vector<String> getChannelsByNickname(String nickname)\n    {\n        Vector<String> channels = new Vector<String>();\n        String[] channelArray = getChannels();\n\n        for (String channel : channelArray) {\n            User[] userArray = getUsers(channel);\n            for (User user : userArray) {\n                if (user.getNick().equals(nickname)) {\n                    channels.add(channel);\n                    break;\n                }\n            }\n        }\n\n        return channels;\n    }\n\n    /**\n     * Get list of users in a channel as array of strings\n     * \n     * @param channel Name of the channel\n     */\n    public String[] getUsersAsStringArray(String channel)\n    {\n        User[] userArray = getUsers(channel);\n        int mLength = userArray.length;\n        String[] users = new String[mLength];\n\n        for (int i = 0; i < mLength; i++) {\n            users[i] = userArray[i].getPrefix() + userArray[i].getNick();\n        }\n\n        return users;\n    }\n\n    /**\n     * Get a user by channel and nickname\n     * \n     * @param channel The channel the user is in\n     * @param nickname The nickname of the user (with or without prefix)\n     * @return the User object or null if user was not found\n     */\n    public User getUser(String channel, String nickname)\n    {\n        User[] users = getUsers(channel);\n        int mLength = users.length;\n\n        for (int i = 0; i < mLength; i++) {\n            if (nickname.equals(users[i].getNick())) {\n                return users[i];\n            }\n            if (nickname.equals(users[i].getPrefix() + users[i].getNick())) {\n                return users[i];\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Quits from the IRC server with default reason.\n     */\n    @Override\n    public void quitServer()\n    {\n        new Thread() {\n            @Override\n            public void run() {\n                quitServer(service.getSettings().getQuitMessage());\n            }\n        }.start();\n    }\n\n    /**\n     * Check whether the nickname has been mentioned.\n     * \n     * @param text The text to check for the nickname\n     * @return true if nickname was found, otherwise false\n     */\n    public boolean isMentioned(String text)\n    {\n        return mNickMatch.matcher(text).find();\n    }\n\n    /**\n     * Update the nick matching pattern, should be called when the nickname changes.\n     */\n    private void updateNickMatchPattern()\n    {\n        mNickMatch = Pattern.compile(\"(?:^|[\\\\s?!'�:;,.])\"+Pattern.quote(getNick())+\"(?:[\\\\s?!'�:;,.]|$)\", Pattern.CASE_INSENSITIVE);\n    }\n}\n","lineNo":587}
{"Smelly Sample":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2011 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage org.yaaic.irc;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.HashMap;\n\nimport org.jibble.pircbot.IrcException;\nimport org.jibble.pircbot.NickAlreadyInUseException;\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.activity.ServersActivity;\nimport org.yaaic.db.Database;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.ServerInfo;\nimport org.yaaic.model.Settings;\nimport org.yaaic.model.Status;\n\nimport android.app.Notification;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.app.Service;\nimport android.content.Intent;\n\n/**\n * The background service for managing the irc connections\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class IRCService extends Service\n{\n    private final IRCBinder binder;\n    private final HashMap<Integer, IRCConnection> connections;\n    private boolean foreground = false;\n\n    @SuppressWarnings(\"rawtypes\")\n    private static final Class[] mStartForegroundSignature = new Class[] { int.class, Notification.class };\n    @SuppressWarnings(\"rawtypes\")\n    private static final Class[] mStopForegroundSignature = new Class[] { boolean.class };\n\n    public static final String ACTION_FOREGROUND = \"org.yaaic.service.foreground\";\n    public static final String ACTION_BACKGROUND = \"org.yaaic.service.background\";\n\n    private NotificationManager notificationManager;\n    private Method mStartForeground;\n    private Method mStopForeground;\n    private final Object[] mStartForegroundArgs = new Object[2];\n    private final Object[] mStopForegroundArgs = new Object[1];\n    private Notification notification;\n    private Settings settings;\n\n    /**\n     * Create new service\n     */\n    public IRCService()\n    {\n        super();\n\n        this.connections = new HashMap<Integer, IRCConnection>();\n        this.binder = new IRCBinder(this);\n    }\n\n    /**\n     * On create\n     */\n    @Override\n    public void onCreate()\n    {\n        super.onCreate();\n\n        settings = new Settings(getBaseContext());\n        notificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);\n\n        try {\n            mStartForeground = getClass().getMethod(\"startForeground\", mStartForegroundSignature);\n            mStopForeground = getClass().getMethod(\"stopForeground\", mStopForegroundSignature);\n        } catch (NoSuchMethodException e) {\n            // Running on an older platform.\n            mStartForeground = mStopForeground = null;\n        }\n\n        // Load servers from Database\n        Database db = new Database(this);\n        Yaaic.getInstance().setServers(db.getServers());\n        db.close();\n\n        // Broadcast changed server list\n        sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n    }\n\n    /**\n     * Get Settings object\n     * \n     * @return the settings helper object\n     */\n    public Settings getSettings()\n    {\n        return settings;\n    }\n\n    /**\n     * On start (will be called on pre-2.0 platform. On 2.0 or later onStartCommand()\n     * will be called)\n     */\n    @Override\n    public void onStart(Intent intent, int startId)\n    {\n        super.onStart(intent, startId);\n        handleCommand(intent);\n    }\n\n    /**\n     * On start command (Android >= 2.0)\n     * \n     * @param intent\n     * @param flags\n     * @param startId\n     * @return\n     */\n    public int onStartCommand(Intent intent, int flags, int startId)\n    {\n        if (intent != null) {\n            handleCommand(intent);\n        }\n\n        // We want this service to continue running until it is explicitly\n        // stopped, so return sticky.\n        //return START_STICKY;\n        return 1;\n    }\n\n\n    /**\n     * Handle command\n     * \n     * @param intent\n     */\n    private void handleCommand(Intent intent)\n    {\n        if (ACTION_FOREGROUND.equals(intent.getAction())) {\n            if (foreground) {\n                return; // XXX: We are already in foreground...\n            }\n            foreground = true;\n\n            // Set the icon, scrolling text and timestamp\n            notification = new Notification(R.drawable.icon, \"\", System.currentTimeMillis());\n\n            // The PendingIntent to launch our activity if the user selects this notification\n            Intent notifyIntent = new Intent(this, ServersActivity.class);\n            notifyIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n            PendingIntent contentIntent = PendingIntent.getActivity(this, 0, notifyIntent, 0);\n\n            // Set the info for the views that show in the notification panel.\n            notification.setLatestEventInfo(this, getText(R.string.app_name), \"\", contentIntent);\n\n            startForegroundCompat(R.string.app_name, notification);\n        } else if (ACTION_BACKGROUND.equals(intent.getAction()) && !foreground) {\n            stopForegroundCompat(R.string.app_name);\n        }\n    }\n\n    /**\n     * Update notification\n     * \n     * @param text The text to display\n     */\n    public void updateNotification(String text)\n    {\n        updateNotification(text, false, false);\n    }\n\n    /**\n     * Update notification and vibrate if needed\n     *\n     * @param text       The text to display\n     * @param vibrate True if the device should vibrate, false otherwise\n     */\n    public void updateNotification(String text, boolean vibrate, boolean sound)\n    {\n        if (foreground) {\n            notificationManager.cancel(R.string.app_name);\n            notification = new Notification(R.drawable.icon, text, System.currentTimeMillis());\n            Intent notifyIntent = new Intent(this, ServersActivity.class);\n            notifyIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n            PendingIntent contentIntent = PendingIntent.getActivity(this, 0, notifyIntent, 0);\n            notification.setLatestEventInfo(this, getText(R.string.app_name), text, contentIntent);\n\n            if (vibrate) {\n                long[] pattern = {0,100,200,300};\n                notification.vibrate = pattern;\n            }\n\n            if (sound) {\n                notification.defaults |= Notification.DEFAULT_SOUND;\n            }\n\n            notificationManager.notify(R.string.app_name, notification);\n        }\n    }\n\n    /**\n     * This is a wrapper around the new startForeground method, using the older\n     * APIs if it is not available.\n     */\n    private void startForegroundCompat(int id, Notification notification)\n    {\n        // If we have the new startForeground API, then use it.\n        if (mStartForeground != null) {\n            mStartForegroundArgs[0] = Integer.valueOf(id);\n            mStartForegroundArgs[1] = notification;\n            try {\n                mStartForeground.invoke(this, mStartForegroundArgs);\n            } catch (InvocationTargetException e) {\n                // Should not happen.\n            } catch (IllegalAccessException e) {\n                // Should not happen.\n            }\n        } else {\n            // Fall back on the old API.\n            setForeground(true);\n            notificationManager.notify(id, notification);\n        }\n    }\n\n    /**\n     * This is a wrapper around the new stopForeground method, using the older\n     * APIs if it is not available.\n     */\n    public void stopForegroundCompat(int id)\n    {\n        foreground = false;\n\n        // If we have the new stopForeground API, then use it.\n        if (mStopForeground != null) {\n            mStopForegroundArgs[0] = Boolean.TRUE;\n            try {\n                mStopForeground.invoke(this, mStopForegroundArgs);\n            } catch (InvocationTargetException e) {\n                // Should not happen.\n            } catch (IllegalAccessException e) {\n                // Should not happen.\n            }\n        } else {\n            // Fall back on the old API.  Note to cancel BEFORE changing the\n            // foreground state, since we could be killed at that point.\n            notificationManager.cancel(id);\n            setForeground(false);\n        }\n    }\n\n    /**\n     * Connect to the given server\n     */\n    public void connect(final Server server)\n    {\n        new Thread() {\n            @Override\n            public void run() {\n                try {\n                    IRCConnection connection = getConnection(server.getId());\n\n                    connection.setNickname(server.getIdentity().getNickname());\n                    connection.setAliases(server.getIdentity().getAliases());\n                    connection.setIdent(server.getIdentity().getIdent());\n                    connection.setRealName(server.getIdentity().getRealName());\n                    connection.setUseSSL(server.useSSL());\n\n                    if (server.getCharset() != null) {\n                        connection.setEncoding(server.getCharset());\n                    }\n\n                    if (server.getPassword() != \"\") {\n                        connection.connect(server.getHost(), server.getPort(), server.getPassword());\n                    } else {\n                        connection.connect(server.getHost(), server.getPort());\n                    }\n                }\n                catch (Exception e) {\n                    server.setStatus(Status.DISCONNECTED);\n\n                    Intent sIntent = Broadcast.createServerIntent(Broadcast.SERVER_UPDATE, server.getId());\n                    sendBroadcast(sIntent);\n\n                    IRCConnection connection = getConnection(server.getId());\n\n                    Message message;\n\n                    if (e instanceof NickAlreadyInUseException) {\n                        message = new Message(getString(R.string.nickname_in_use, connection.getNick()));\n                    } else if (e instanceof IrcException) {\n                        message = new Message(getString(R.string.irc_login_error, server.getHost(), server.getPort()));\n                    } else {\n                        message = new Message(getString(R.string.could_not_connect, server.getHost(), server.getPort()));\n                    }\n\n                    message.setColor(Message.COLOR_RED);\n                    message.setIcon(R.drawable.error);\n                    server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n                    Intent cIntent = Broadcast.createConversationIntent(\n                        Broadcast.CONVERSATION_MESSAGE,\n                        server.getId(),\n                        ServerInfo.DEFAULT_NAME\n                    );\n                    sendBroadcast(cIntent);\n                }\n            }\n        }.start();\n    }\n\n    /**\n     * Get connection for given server\n     * \n     * @param serverId\n     * @return\n     */\n    public synchronized IRCConnection getConnection(int serverId)\n    {\n        IRCConnection connection = connections.get(serverId);\n\n        if (connection == null) {\n            connection = new IRCConnection(this, serverId);\n            connections.put(serverId, connection);\n        }\n\n        return connection;\n    }\n\n    /**\n     * Does the service keep a connection object for this server?\n     * \n     * @return true if there's a connection object, false otherwise\n     */\n    public boolean hasConnection(int serverId)\n    {\n        return connections.containsKey(serverId);\n    }\n\n    /**\n     * Check status of service\n     */\n    public void checkServiceStatus()\n    {\n        boolean shutDown = true;\n        ArrayList<Server> mServers = Yaaic.getInstance().getServersAsArrayList();\n        int mSize = mServers.size();\n        Server server;\n\n        for (int i = 0; i < mSize; i++) {\n            server = mServers.get(i);\n            if (server.isDisconnected()) {\n                connections.remove(server.getId());\n            } else {\n                shutDown = false;\n            }\n        }\n\n        if (shutDown) {\n            foreground = false;\n            stopForegroundCompat(R.string.app_name);\n            stopSelf();\n        }\n    }\n\n    /**\n     * On Destroy\n     */\n    @Override\n    public void onDestroy()\n    {\n        // Make sure our notification is gone.\n        if (foreground) {\n            stopForegroundCompat(R.string.app_name);\n        }\n    }\n\n    /**\n     * On Activity binding to this service\n     * \n     * @param intent\n     * @return\n     */\n    @Override\n    public IRCBinder onBind(Intent intent)\n    {\n        return binder;\n    }\n}\n","Method after Refactoring":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2011 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage org.yaaic.irc;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.HashMap;\n\nimport org.jibble.pircbot.IrcException;\nimport org.jibble.pircbot.NickAlreadyInUseException;\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.activity.ServersActivity;\nimport org.yaaic.db.Database;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.ServerInfo;\nimport org.yaaic.model.Settings;\nimport org.yaaic.model.Status;\n\nimport android.app.Notification;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.app.Service;\nimport android.content.Intent;\n\n/**\n * The background service for managing the irc connections\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class IRCService extends Service\n{\n    private final IRCBinder binder;\n    private final HashMap<Integer, IRCConnection> connections;\n    private boolean foreground = false;\n\n    @SuppressWarnings(\"rawtypes\")\n    private static final Class[] mStartForegroundSignature = new Class[] { int.class, Notification.class };\n    @SuppressWarnings(\"rawtypes\")\n    private static final Class[] mStopForegroundSignature = new Class[] { boolean.class };\n\n    public static final String ACTION_FOREGROUND = \"org.yaaic.service.foreground\";\n    public static final String ACTION_BACKGROUND = \"org.yaaic.service.background\";\n\n    private NotificationManager notificationManager;\n    private Method mStartForeground;\n    private Method mStopForeground;\n    private final Object[] mStartForegroundArgs = new Object[2];\n    private final Object[] mStopForegroundArgs = new Object[1];\n    private Notification notification;\n    private Settings settings;\n\n    /**\n     * Create new service\n     */\n    public IRCService()\n    {\n        super();\n\n        this.connections = new HashMap<Integer, IRCConnection>();\n        this.binder = new IRCBinder(this);\n    }\n\n    /**\n     * On create\n     */\n    @Override\n    public void onCreate()\n    {\n        super.onCreate();\n\n        settings = new Settings(getBaseContext());\n        notificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);\n\n        try {\n            mStartForeground = getClass().getMethod(\"startForeground\", mStartForegroundSignature);\n            mStopForeground = getClass().getMethod(\"stopForeground\", mStopForegroundSignature);\n        } catch (NoSuchMethodException e) {\n            // Running on an older platform.\n            mStartForeground = mStopForeground = null;\n        }\n\n        // Load servers from Database\n        Database db = new Database(this);\n        Yaaic.getInstance().setServers(db.getServers());\n        db.close();\n\n        // Broadcast changed server list\n        sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n    }\n\n    /**\n     * Get Settings object\n     * \n     * @return the settings helper object\n     */\n    public Settings getSettings()\n    {\n        return settings;\n    }\n\n    /**\n     * On start (will be called on pre-2.0 platform. On 2.0 or later onStartCommand()\n     * will be called)\n     */\n    @Override\n    public void onStart(Intent intent, int startId)\n    {\n        super.onStart(intent, startId);\n        handleCommand(intent);\n    }\n\n    /**\n     * On start command (Android >= 2.0)\n     * \n     * @param intent\n     * @param flags\n     * @param startId\n     * @return\n     */\n    public int onStartCommand(Intent intent, int flags, int startId)\n    {\n        if (intent != null) {\n            handleCommand(intent);\n        }\n\n        // We want this service to continue running until it is explicitly\n        // stopped, so return sticky.\n        //return START_STICKY;\n        return 1;\n    }\n\n\n    /**\n     * Handle command\n     * \n     * @param intent\n     */\n    private void handleCommand(Intent intent)\n    {\n        if (ACTION_FOREGROUND.equals(intent.getAction())) {\n            if (foreground) {\n                return; // XXX: We are already in foreground...\n            }\n            foreground = true;\n\n            // Set the icon, scrolling text and timestamp\n            notification = new Notification(R.drawable.icon, \"\", System.currentTimeMillis());\n\n            // The PendingIntent to launch our activity if the user selects this notification\n            Intent notifyIntent = new Intent(this, ServersActivity.class);\n            notifyIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n            PendingIntent contentIntent = PendingIntent.getActivity(this, 0, notifyIntent, 0);\n\n            // Set the info for the views that show in the notification panel.\n            notification.setLatestEventInfo(this, getText(R.string.app_name), \"\", contentIntent);\n\n            startForegroundCompat(R.string.app_name, notification);\n        } else if (ACTION_BACKGROUND.equals(intent.getAction()) && !foreground) {\n            stopForegroundCompat(R.string.app_name);\n        }\n    }\n\n    /**\n     * Update notification\n     * \n     * @param text The text to display\n     */\n    public void updateNotification(String text)\n    {\n        updateNotification(text, false, false);\n    }\n\n    /**\n     * Update notification and vibrate if needed\n     *\n     * @param text       The text to display\n     * @param vibrate True if the device should vibrate, false otherwise\n     */\n    public void updateNotification(String text, boolean vibrate, boolean sound)\n    {\n        if (foreground) {\n            notificationManager.cancel(R.string.app_name);\n            notification = new Notification(R.drawable.icon, text, System.currentTimeMillis());\n            Intent notifyIntent = new Intent(this, ServersActivity.class);\n            notifyIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n            PendingIntent contentIntent = PendingIntent.getActivity(this, 0, notifyIntent, 0);\n            notification.setLatestEventInfo(this, getText(R.string.app_name), text, contentIntent);\n\n            if (vibrate) {\n                long[] pattern = {0,100,200,300};\n                notification.vibrate = pattern;\n            }\n\n            if (sound) {\n                notification.defaults |= Notification.DEFAULT_SOUND;\n            }\n\n            notificationManager.notify(R.string.app_name, notification);\n        }\n    }\n\n    /**\n     * This is a wrapper around the new startForeground method, using the older\n     * APIs if it is not available.\n     */\n    private void startForegroundCompat(int id, Notification notification)\n    {\n        // If we have the new startForeground API, then use it.\n        if (mStartForeground != null) {\n            mStartForegroundArgs[0] = Integer.valueOf(id);\n            mStartForegroundArgs[1] = notification;\n            try {\n                mStartForeground.invoke(this, mStartForegroundArgs);\n            } catch (InvocationTargetException e) {\n                // Should not happen.\n            } catch (IllegalAccessException e) {\n                // Should not happen.\n            }\n        } else {\n            // Fall back on the old API.\n            setForeground(true);\n            notificationManager.notify(id, notification);\n        }\n    }\n\n    /**\n     * This is a wrapper around the new stopForeground method, using the older\n     * APIs if it is not available.\n     */\n    public void stopForegroundCompat(int id)\n    {\n        foreground = false;\n\n        // If we have the new stopForeground API, then use it.\n        if (mStopForeground != null) {\n            mStopForegroundArgs[0] = Boolean.TRUE;\n            try {\n                mStopForeground.invoke(this, mStopForegroundArgs);\n            } catch (InvocationTargetException e) {\n                // Should not happen.\n            } catch (IllegalAccessException e) {\n                // Should not happen.\n            }\n        } else {\n            // Fall back on the old API.  Note to cancel BEFORE changing the\n            // foreground state, since we could be killed at that point.\n            notificationManager.cancel(id);\n            setForeground(false);\n        }\n    }\n\n    /**\n     * Connect to the given server\n     */\n    public void connect(final Server server)\n    {\n        new Thread() {\n            @Override\n            public void run() {\n                try {\n                    IRCConnection connection = getConnection(server.getId());\n\n                    connection.setNickname(server.getIdentity().getNickname());\n                    connection.setAliases(server.getIdentity().getAliases());\n                    connection.setIdent(server.getIdentity().getIdent());\n                    connection.setRealName(server.getIdentity().getRealName());\n                    connection.setUseSSL(server.useSSL());\n\n                    if (server.getCharset() != null) {\n                        connection.setEncoding(server.getCharset());\n                    }\n\n                    if (server.getPassword() != \"\") {\n                        connection.connect(server.getHost(), server.getPort(), server.getPassword());\n                    } else {\n                        connection.connect(server.getHost(), server.getPort());\n                    }\n                }\n                catch (Exception e) {\n                    server.setStatus(Status.DISCONNECTED);\n\n                    Intent sIntent = Broadcast.createServerIntent(Broadcast.SERVER_UPDATE, server.getId());\n                    sendBroadcast(sIntent);\n\n                    IRCConnection connection = getConnection(server.getId());\n\n                    Message message;\n\n                    if (e instanceof NickAlreadyInUseException) {\n                        message = new Message(getString(R.string.nickname_in_use, connection.getNick()));\n                    } else if (e instanceof IrcException) {\n                        message = new Message(getString(R.string.irc_login_error, server.getHost(), server.getPort()));\n                    } else {\n                        message = new Message(getString(R.string.could_not_connect, server.getHost(), server.getPort()));\n                    }\n\n                    message.setColor(Message.COLOR_RED);\n                    message.setIcon(R.drawable.error);\n                    server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n                    Intent cIntent = Broadcast.createConversationIntent(\n                        Broadcast.CONVERSATION_MESSAGE,\n                        server.getId(),\n                        ServerInfo.DEFAULT_NAME\n                    );\n                    sendBroadcast(cIntent);\n                }\n            }\n        }.start();\n    }\n\n    /**\n     * Get connection for given server\n     * \n     * @param serverId\n     * @return\n     */\n    public synchronized IRCConnection getConnection(int serverId)\n    {\n        IRCConnection connection = connections.get(serverId);\n\n        if (connection == null) {\n            connection = new IRCConnection(this, serverId);\n            connections.put(serverId, connection);\n        }\n\n        return connection;\n    }\n\n    /**\n     * Does the service keep a connection object for this server?\n     * \n     * @return true if there's a connection object, false otherwise\n     */\n    public boolean hasConnection(int serverId)\n    {\n        return connections.containsKey(serverId);\n    }\n\n    /**\n     * Check status of service\n     */\n    public void checkServiceStatus()\n    {\n        boolean shutDown = true;\n        ArrayList<Server> mServers = Yaaic.getInstance().getServersAsArrayList();\n        int mSize = mServers.size();\n        Server server;\n\n        for (int i = 0; i < mSize; i++) {\n            server = mServers.get(i);\n            if (server.isDisconnected()) {\n                int serverId = server.getId();\n                synchronized(this) {\n                    IRCConnection connection = connections.get(serverId);\n                    if (connection != null) {\n                        connection.dispose();\n                    }\n                    connections.remove(serverId);\n                }\n            } else {\n                shutDown = false;\n            }\n        }\n\n        if (shutDown) {\n            foreground = false;\n            stopForegroundCompat(R.string.app_name);\n            stopSelf();\n        }\n    }\n\n    /**\n     * On Destroy\n     */\n    @Override\n    public void onDestroy()\n    {\n        // Make sure our notification is gone.\n        if (foreground) {\n            stopForegroundCompat(R.string.app_name);\n        }\n    }\n\n    /**\n     * On Activity binding to this service\n     * \n     * @param intent\n     * @return\n     */\n    @Override\n    public IRCBinder onBind(Intent intent)\n    {\n        return binder;\n    }\n}\n","lineNo":375}
{"Smelly Sample":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2011 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage org.yaaic.irc;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Vector;\nimport java.util.regex.Pattern;\n\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.command.CommandParser;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Query;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.ServerInfo;\nimport org.yaaic.model.Status;\n\nimport android.content.Intent;\n\n/**\n * The class that actually handles the connection to an IRC server\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class IRCConnection extends PircBot\n{\n    private final IRCService service;\n    private final Server server;\n    private ArrayList<String> autojoinChannels;\n    private Pattern mNickMatch;\n\n    /**\n     * Create a new connection\n     * \n     * @param service\n     * @param serverId\n     */\n    public IRCConnection(IRCService service, int serverId)\n    {\n        this.server = Yaaic.getInstance().getServerById(serverId);\n        this.service = service;\n\n        // XXX: Should be configurable via settings\n        this.setAutoNickChange(true);\n\n        this.setFinger(\"http://www.youtube.com/watch?v=oHg5SJYRHA0\");\n        this.updateNickMatchPattern();\n    }\n\n    /**\n     * Set the nickname of the user\n     * \n     * @param nickname The nickname to use\n     */\n    public void setNickname(String nickname)\n    {\n        this.setName(nickname);\n        this.updateNickMatchPattern();\n    }\n\n    /**\n     * Set the real name of the user\n     * \n     * @param realname The realname to use\n     */\n    public void setRealName(String realname)\n    {\n        // XXX: Pircbot uses the version for \"real name\" and \"version\".\n        //      The real \"version\" value is provided by onVersion()\n        this.setVersion(realname);\n    }\n\n    /**\n     * Set channels to autojoin after connect\n     * \n     * @param channels\n     */\n    public void setAutojoinChannels(ArrayList<String> channels)\n    {\n        autojoinChannels = channels;\n    }\n\n    /**\n     * On version (CTCP version)\n     * \n     * This is a fix for pircbot as pircbot uses the version as \"real name\" and as \"version\"\n     */\n    @Override\n    protected void onVersion(String sourceNick, String sourceLogin,    String sourceHostname, String target)\n    {\n        this.sendRawLine(\n            \"NOTICE \" + sourceNick + \" :\\u0001VERSION \" +\n            \"Yaaic - Yet another Android IRC client - http://www.yaaic.org\" +\n            \"\\u0001\"\n        );\n    }\n\n    /**\n     * Set the ident of the user\n     * \n     * @param ident The ident to use\n     */\n    public void setIdent(String ident)\n    {\n        this.setLogin(ident);\n    }\n\n    /**\n     * On connect\n     */\n    @Override\n    public void onConnect()\n    {\n        server.setStatus(Status.CONNECTED);\n\n        service.sendBroadcast(\n            Broadcast.createServerIntent(Broadcast.SERVER_UPDATE, server.getId())\n        );\n\n        service.updateNotification(service.getString(R.string.notification_connected, server.getTitle()));\n\n        Message message = new Message(service.getString(R.string.message_connected, server.getTitle()));\n        message.setColor(Message.COLOR_GREEN);\n        server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            ServerInfo.DEFAULT_NAME\n        );\n\n        service.sendBroadcast(intent);\n    }\n\n\n    /**\n     * On register\n     */\n    @Override\n    public void onRegister()\n    {\n        // Call parent method to ensure \"register\" status is tracked\n        super.onRegister();\n\n        // execute commands\n        CommandParser parser = CommandParser.getInstance();\n\n        this.updateNickMatchPattern();\n        for (String command : server.getConnectCommands()) {\n            parser.parse(command, server, server.getConversation(ServerInfo.DEFAULT_NAME), service);\n        }\n\n        // TODO: Detect \"You are now identified for <nick>\" notices from NickServ and handle\n        //       auto joins in onNotice instead if the user has chosen to wait for NickServ\n        //       identification before auto joining channels.\n\n        // delay 1 sec before auto joining channels\n        try {\n            Thread.sleep(1000);\n        } catch(InterruptedException e) {\n            // do nothing\n        }\n\n        // join channels\n        if (autojoinChannels != null) {\n            for (String channel : autojoinChannels) {\n                // Add support for channel keys\n                joinChannel(channel);\n            }\n        } else {\n            for (String channel : server.getAutoJoinChannels()) {\n                joinChannel(channel);\n            }\n        }\n    }\n    /**\n     * On channel action\n     */\n    @Override\n    protected void onAction(String sender, String login, String hostname, String target, String action)\n    {\n        Conversation conversation;\n\n        Message message = new Message(sender + \" \" + action);\n        message.setIcon(R.drawable.action);\n\n        if (target.equals(this.getNick())) {\n            // We are the target - this is an action in a query\n            conversation = server.getConversation(sender);\n            if (conversation == null) {\n                // Open a query if there's none yet\n                conversation = new Query(sender);\n                server.addConversation(conversation);\n                conversation.addMessage(message);\n\n                Intent intent = Broadcast.createConversationIntent(\n                    Broadcast.CONVERSATION_NEW,\n                    server.getId(),\n                    sender\n                );\n                service.sendBroadcast(intent);\n            } else {\n                Intent intent = Broadcast.createConversationIntent(\n                    Broadcast.CONVERSATION_MESSAGE,\n                    server.getId(),\n                    sender\n                );\n                service.sendBroadcast(intent);\n            }\n        } else {\n            // A action in a channel\n            conversation = server.getConversation(target);\n            conversation.addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n\n        if (isMentioned(action)) {\n            // highlight\n            message.setColor(Message.COLOR_RED);\n            service.updateNotification(\n                target + \": \" + sender + \" \" + action,\n                service.getSettings().isVibrateHighlightEnabled(),\n                service.getSettings().isSoundHighlightEnabled()\n            );\n\n            conversation.setStatus(Conversation.STATUS_HIGHLIGHT);\n        }\n    }\n\n    /**\n     * On Channel Info\n     */\n    @Override\n    protected void onChannelInfo(String channel, int userCount, String topic)\n    {\n    }\n\n    /**\n     * On Deop\n     */\n    @Override\n    protected void onDeop(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n    {\n        Message message = new Message(service.getString(R.string.message_deop, sourceNick, recipient));\n        message.setIcon(R.drawable.op);\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On DeVoice\n     */\n    @Override\n    protected void onDeVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n    {\n        Message message = new Message(service.getString(R.string.message_devoice, sourceNick, recipient));\n        message.setColor(Message.COLOR_BLUE);\n        message.setIcon(R.drawable.voice);\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On Invite\n     */\n    @Override\n    protected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String target)\n    {\n        if (targetNick.equals(this.getNick())) {\n            // We are invited\n            Message message = new Message(service.getString(R.string.message_invite_you, sourceNick, target));\n            server.getConversation(server.getSelectedConversation()).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                server.getSelectedConversation()\n            );\n            service.sendBroadcast(intent);\n        } else {\n            // Someone is invited\n            Message message = new Message(service.getString(R.string.message_invite_someone, sourceNick, targetNick, target));\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Join\n     */\n    @Override\n    protected void onJoin(String target, String sender, String login, String hostname)\n    {\n        if (sender.equalsIgnoreCase(getNick())) {\n            // We joined a new channel\n            server.addConversation(new Channel(target));\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_NEW,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        } else if (service.getSettings().showJoinPartAndQuit()) {\n            Message message = new Message(\n                service.getString(R.string.message_join, sender),\n                Message.TYPE_MISC\n            );\n\n            message.setIcon(R.drawable.join);\n            message.setColor(Message.COLOR_GREEN);\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Kick\n     */\n    @Override\n    protected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n    {\n        if (recipientNick.equals(getNick())) {\n            // We are kicked\n            server.removeConversation(target);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_REMOVE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        } else {\n            Message message = new Message(service.getString(R.string.message_kick, kickerNick, recipientNick));\n            message.setColor(Message.COLOR_GREEN);\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Message\n     */\n    @Override\n    protected void onMessage(String target, String sender, String login, String hostname, String text)\n    {\n        Message message = new Message(text, sender);\n\n        if (isMentioned(text)) {\n            // highlight\n            message.setColor(Message.COLOR_RED);\n            service.updateNotification(\n                target + \": <\" + sender + \"> \" + text,\n                service.getSettings().isVibrateHighlightEnabled(),\n                service.getSettings().isSoundHighlightEnabled()\n            );\n\n            server.getConversation(target).setStatus(Conversation.STATUS_HIGHLIGHT);\n        }\n\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On Mode\n     */\n    @Override\n    protected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n    {\n        // Disabled as it doubles events (e.g. onOp and onMode will be called)\n\n        /*\n        Message message = new Message(sourceNick + \" sets mode \" + mode);\n        server.getChannel(target).addMessage(message);\n\n        Intent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n        intent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n        intent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n        service.sendBroadcast(intent);\n         */\n    }\n\n    /**\n     * On Nick Change\n     */\n    @Override\n    protected void onNickChange(String oldNick, String login, String hostname, String newNick)\n    {\n        if (getNick().equalsIgnoreCase(newNick)) {\n            this.updateNickMatchPattern();\n\n            // Send message about own change to server info window\n            Message message = new Message(service.getString(R.string.message_self_rename, newNick));\n            message.setColor(Message.COLOR_GREEN);\n            server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                ServerInfo.DEFAULT_NAME\n            );\n\n            service.sendBroadcast(intent);\n        }\n\n        Vector<String> channels = getChannelsByNickname(newNick);\n\n        for (String target : channels) {\n            Message message = new Message(service.getString(R.string.message_rename, oldNick, newNick));\n            message.setColor(Message.COLOR_GREEN);\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Notice\n     */\n    @Override\n    protected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n    {\n        // Post notice to currently selected conversation\n        Conversation conversation;\n\n        if (service.getSettings().showNoticeInServerWindow()) {\n            conversation = server.getConversation(ServerInfo.DEFAULT_NAME);\n        } else {\n            conversation = server.getConversation(server.getSelectedConversation());\n\n            if (conversation == null) {\n                // Fallback: Use ServerInfo view\n                conversation = server.getConversation(ServerInfo.DEFAULT_NAME);\n            }\n        }\n\n        Message message = new Message(\"-\" + sourceNick + \"- \" + notice);\n        message.setIcon(R.drawable.info);\n        conversation.addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            conversation.getName()\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On Op\n     */\n    @Override\n    protected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n    {\n        Message message = new Message(service.getString(R.string.message_op, sourceNick, recipient));\n        message.setColor(Message.COLOR_BLUE);\n        message.setIcon(R.drawable.op);\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On Part\n     */\n    @Override\n    protected void onPart(String target, String sender, String login, String hostname)\n    {\n        if (sender.equals(getNick())) {\n            // We parted a channel\n            server.removeConversation(target);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_REMOVE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        } else if (service.getSettings().showJoinPartAndQuit()) {\n            Message message = new Message(\n                service.getString(R.string.message_part, sender),\n                Message.TYPE_MISC\n            );\n\n            message.setColor(Message.COLOR_GREEN);\n            message.setIcon(R.drawable.part);\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Private Message\n     */\n    @Override\n    protected void onPrivateMessage(String sender, String login, String hostname, String text)\n    {\n        Message message = new Message(\"<\" + sender + \"> \" + text);\n\n        Conversation conversation = server.getConversation(sender);\n\n        if (conversation == null) {\n            // Open a query if there's none yet\n            conversation = new Query(sender);\n            conversation.addMessage(message);\n            server.addConversation(conversation);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_NEW,\n                server.getId(),\n                sender\n            );\n            service.sendBroadcast(intent);\n        } else {\n            conversation.addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                sender\n            );\n            service.sendBroadcast(intent);\n        }\n\n        if (isMentioned(text)) {\n            message.setColor(Message.COLOR_RED);\n            service.updateNotification(\n                \"<\" + sender + \"> \" + text,\n                service.getSettings().isVibrateHighlightEnabled(),\n                service.getSettings().isSoundHighlightEnabled()\n            );\n\n            conversation.setStatus(Conversation.STATUS_HIGHLIGHT);\n        }\n    }\n\n    /**\n     * On Quit\n     */\n    @Override\n    protected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n    {\n        if (sourceNick.equals(this.getNick())) {\n            return;\n        }\n\n        if (service.getSettings().showJoinPartAndQuit()) {\n            Vector<String> channels = getChannelsByNickname(sourceNick);\n\n            for (String target : channels) {\n                Message message = new Message(\n                    service.getString(R.string.message_quit, sourceNick, reason),\n                    Message.TYPE_MISC\n                );\n\n                message.setColor(Message.COLOR_GREEN);\n                message.setIcon(R.drawable.quit);\n                server.getConversation(target).addMessage(message);\n\n                Intent intent = Broadcast.createConversationIntent(\n                    Broadcast.CONVERSATION_MESSAGE,\n                    server.getId(),\n                    target\n                );\n                service.sendBroadcast(intent);\n            }\n\n            // Look if there's a query to update\n            Conversation conversation = server.getConversation(sourceNick);\n\n            if (conversation != null) {\n                Message message = new Message(\n                    service.getString(R.string.message_quit, sourceNick, reason),\n                    Message.TYPE_MISC\n                );\n\n                message.setColor(Message.COLOR_GREEN);\n                message.setIcon(R.drawable.quit);\n                conversation.addMessage(message);\n\n                Intent intent = Broadcast.createConversationIntent(\n                    Broadcast.CONVERSATION_MESSAGE,\n                    server.getId(),\n                    conversation.getName()\n                );\n                service.sendBroadcast(intent);\n            }\n        }\n    }\n\n    /**\n     * On Topic\n     */\n    @Override\n    public void onTopic(String target, String topic, String setBy, long date, boolean changed)\n    {\n        if (changed) {\n            Message message = new Message(service.getString(R.string.message_topic_set, setBy, topic));\n            message.setColor(Message.COLOR_YELLOW);\n            server.getConversation(target).addMessage(message);\n        } else {\n            Message message = new Message(service.getString(R.string.message_topic, topic));\n            message.setColor(Message.COLOR_YELLOW);\n            server.getConversation(target).addMessage(message);\n        }\n\n        // remember channel's topic\n        ((Channel) server.getConversation(target)).setTopic(topic);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On User List\n     */\n    @Override\n    protected void onUserList(String channel, User[] users)\n    {\n        // XXX: Store user list somewhere and keep it updated or just broadcast some event?\n    }\n\n    /**\n     * On Voice\n     */\n    @Override\n    protected void onVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n    {\n        Message message = new Message(service.getString(R.string.message_voice, sourceNick, recipient));\n        message.setIcon(R.drawable.voice);\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On remove channel key\n     */\n    @Override\n    protected void onRemoveChannelKey(String target, String sourceNick, String sourceLogin, String sourceHostname, String key)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_channel_key, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set channel key\n     */\n    @Override\n    protected void onSetChannelKey(String target, String sourceNick, String sourceLogin, String sourceHostname, String key)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_key, sourceNick, key));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set secret\n     */\n    @Override\n    protected void onSetSecret(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_secret, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove secret\n     */\n    @Override\n    protected void onRemoveSecret(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_public, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set channel limit\n     */\n    @Override\n    protected void onSetChannelLimit(String target, String sourceNick, String sourceLogin, String sourceHostname, int limit)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_limit, sourceNick, limit));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove channel limit\n     */\n    @Override\n    protected void onRemoveChannelLimit(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_channel_limit, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set channel ban\n     */\n    @Override\n    protected void onSetChannelBan(String target, String sourceNick, String sourceLogin, String sourceHostname, String hostmask)\n    {\n        Message message = new Message(service.getString(R.string.message_set_ban, sourceNick, hostmask));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove channel ban\n     */\n    @Override\n    protected void onRemoveChannelBan(String target, String sourceNick, String sourceLogin, String sourceHostname, String hostmask)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_ban, sourceNick, hostmask));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set topic protection\n     */\n    @Override\n    protected void onSetTopicProtection(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_topic_protection, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove topic protection\n     */\n    @Override\n    protected void onRemoveTopicProtection(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_topic_protection, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set no external messages\n     */\n    @Override\n    protected void onSetNoExternalMessages(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_disable_external, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove no external messages\n     */\n    @Override\n    protected void onRemoveNoExternalMessages(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_enable_external, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set invite only\n     */\n    @Override\n    protected void onSetInviteOnly(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_invite_only, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove invite only\n     */\n    @Override\n    protected void onRemoveInviteOnly(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_invite_only, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set moderated\n     */\n    @Override\n    protected void onSetModerated(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_moderated, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove moderated\n     */\n    @Override\n    protected void onRemoveModerated(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_moderated, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set private\n     */\n    @Override\n    protected void onSetPrivate(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_private, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove private\n     */\n    @Override\n    protected void onRemovePrivate(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_public, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On unknown\n     */\n    @Override\n    protected void onUnknown(String line)\n    {\n        Message message = new Message(line);\n        message.setIcon(R.drawable.action);\n        message.setColor(Message.COLOR_GREY);\n        server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            ServerInfo.DEFAULT_NAME\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On server response\n     */\n    @Override\n    protected void onServerResponse(int code, String response)\n    {\n        if (code == 4) {\n            // User has registered with the server\n            onRegister();\n            return;\n        }\n        if (code == 372 || code == 375 || code == 376) {\n            // Skip MOTD\n            return;\n        }\n\n        if (code >= 200 && code < 300) {\n            // Skip 2XX responses\n            return;\n        }\n\n        if (code == 353 || code == 366 || code == 332 || code == 333) {\n            return;\n        }\n\n        if (code < 10) {\n            // Skip server info\n            return;\n        }\n\n        // Currently disabled... to much text\n        Message message = new Message(response);\n        message.setColor(Message.COLOR_GREY);\n        server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            ServerInfo.DEFAULT_NAME\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On disconnect\n     */\n    @Override\n    public void onDisconnect()\n    {\n        // Call parent method to ensure \"register\" status is tracked\n        super.onDisconnect();\n\n        if (service.getSettings().isReconnectEnabled() && server.getStatus() != Status.DISCONNECTED) {\n            setAutojoinChannels(server.getCurrentChannelNames());\n\n            server.clearConversations();\n            server.setStatus(Status.CONNECTING);\n            service.connect(server);\n        } else {\n            server.setStatus(Status.DISCONNECTED);\n        }\n\n        service.updateNotification(service.getString(R.string.notification_disconnected, server.getTitle()));\n\n        Intent sIntent = Broadcast.createServerIntent(Broadcast.SERVER_UPDATE, server.getId());\n        service.sendBroadcast(sIntent);\n\n        Collection<Conversation> conversations = server.getConversations();\n\n        for (Conversation conversation : conversations) {\n            Message message = new Message(service.getString(R.string.message_disconnected));\n            message.setIcon(R.drawable.error);\n            message.setColor(Message.COLOR_RED);\n            server.getConversation(conversation.getName()).addMessage(message);\n\n            Intent cIntent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                conversation.getName()\n            );\n            service.sendBroadcast(cIntent);\n        }\n    }\n\n    /**\n     * Get all channels where the user with the given nickname is online\n     * \n     * @param nickname\n     * @return Array of channel names\n     */\n    private Vector<String> getChannelsByNickname(String nickname)\n    {\n        Vector<String> channels = new Vector<String>();\n        String[] channelArray = getChannels();\n\n        for (String channel : channelArray) {\n            User[] userArray = getUsers(channel);\n            for (User user : userArray) {\n                if (user.getNick().equals(nickname)) {\n                    channels.add(channel);\n                    break;\n                }\n            }\n        }\n\n        return channels;\n    }\n\n    /**\n     * Get list of users in a channel as array of strings\n     * \n     * @param channel Name of the channel\n     */\n    public String[] getUsersAsStringArray(String channel)\n    {\n        User[] userArray = getUsers(channel);\n        int mLength = userArray.length;\n        String[] users = new String[mLength];\n\n        for (int i = 0; i < mLength; i++) {\n            users[i] = userArray[i].getPrefix() + userArray[i].getNick();\n        }\n\n        return users;\n    }\n\n    /**\n     * Get a user by channel and nickname\n     * \n     * @param channel The channel the user is in\n     * @param nickname The nickname of the user (with or without prefix)\n     * @return the User object or null if user was not found\n     */\n    public User getUser(String channel, String nickname)\n    {\n        User[] users = getUsers(channel);\n        int mLength = users.length;\n\n        for (int i = 0; i < mLength; i++) {\n            if (nickname.equals(users[i].getNick())) {\n                return users[i];\n            }\n            if (nickname.equals(users[i].getPrefix() + users[i].getNick())) {\n                return users[i];\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Quits from the IRC server with default reason.\n     */\n    @Override\n    public void quitServer()\n    {\n        new Thread() {\n            @Override\n            public void run() {\n                quitServer(service.getSettings().getQuitMessage());\n            }\n        }.start();\n    }\n\n    /**\n     * Check whether the nickname has been mentioned.\n     * \n     * @param text The text to check for the nickname\n     * @return true if nickname was found, otherwise false\n     */\n    public boolean isMentioned(String text)\n    {\n        return mNickMatch.matcher(text).find();\n    }\n\n    /**\n     * Update the nick matching pattern, should be called when the nickname changes.\n     */\n    private void updateNickMatchPattern()\n    {\n        mNickMatch = Pattern.compile(\"(?:^|[\\\\s?!'�:;,.])\"+Pattern.quote(getNick())+\"(?:[\\\\s?!'�:;,.]|$)\", Pattern.CASE_INSENSITIVE);\n    }\n}\n","Method after Refactoring":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2011 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage org.yaaic.irc;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Vector;\nimport java.util.regex.Pattern;\n\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.command.CommandParser;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Query;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.ServerInfo;\nimport org.yaaic.model.Status;\n\nimport android.content.Intent;\n\n/**\n * The class that actually handles the connection to an IRC server\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class IRCConnection extends PircBot\n{\n    private final IRCService service;\n    private final Server server;\n    private ArrayList<String> autojoinChannels;\n    private Pattern mNickMatch;\n\n    /**\n     * Create a new connection\n     * \n     * @param service\n     * @param serverId\n     */\n    public IRCConnection(IRCService service, int serverId)\n    {\n        this.server = Yaaic.getInstance().getServerById(serverId);\n        this.service = service;\n\n        // XXX: Should be configurable via settings\n        this.setAutoNickChange(true);\n\n        this.setFinger(\"http://www.youtube.com/watch?v=oHg5SJYRHA0\");\n        this.updateNickMatchPattern();\n    }\n\n    /**\n     * Set the nickname of the user\n     * \n     * @param nickname The nickname to use\n     */\n    public void setNickname(String nickname)\n    {\n        this.setName(nickname);\n        this.updateNickMatchPattern();\n    }\n\n    /**\n     * Set the real name of the user\n     * \n     * @param realname The realname to use\n     */\n    public void setRealName(String realname)\n    {\n        // XXX: Pircbot uses the version for \"real name\" and \"version\".\n        //      The real \"version\" value is provided by onVersion()\n        this.setVersion(realname);\n    }\n\n    /**\n     * Set channels to autojoin after connect\n     * \n     * @param channels\n     */\n    public void setAutojoinChannels(ArrayList<String> channels)\n    {\n        autojoinChannels = channels;\n    }\n\n    /**\n     * On version (CTCP version)\n     * \n     * This is a fix for pircbot as pircbot uses the version as \"real name\" and as \"version\"\n     */\n    @Override\n    protected void onVersion(String sourceNick, String sourceLogin,    String sourceHostname, String target)\n    {\n        this.sendRawLine(\n            \"NOTICE \" + sourceNick + \" :\\u0001VERSION \" +\n            \"Yaaic - Yet another Android IRC client - http://www.yaaic.org\" +\n            \"\\u0001\"\n        );\n    }\n\n    /**\n     * Set the ident of the user\n     * \n     * @param ident The ident to use\n     */\n    public void setIdent(String ident)\n    {\n        this.setLogin(ident);\n    }\n\n    /**\n     * On connect\n     */\n    @Override\n    public void onConnect()\n    {\n        server.setStatus(Status.CONNECTED);\n\n        service.sendBroadcast(\n            Broadcast.createServerIntent(Broadcast.SERVER_UPDATE, server.getId())\n        );\n\n        service.updateNotification(service.getString(R.string.notification_connected, server.getTitle()));\n\n        Message message = new Message(service.getString(R.string.message_connected, server.getTitle()));\n        message.setColor(Message.COLOR_GREEN);\n        server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            ServerInfo.DEFAULT_NAME\n        );\n\n        service.sendBroadcast(intent);\n    }\n\n\n    /**\n     * On register\n     */\n    @Override\n    public void onRegister()\n    {\n        // Call parent method to ensure \"register\" status is tracked\n        super.onRegister();\n\n        // execute commands\n        CommandParser parser = CommandParser.getInstance();\n\n        this.updateNickMatchPattern();\n        for (String command : server.getConnectCommands()) {\n            parser.parse(command, server, server.getConversation(ServerInfo.DEFAULT_NAME), service);\n        }\n\n        // TODO: Detect \"You are now identified for <nick>\" notices from NickServ and handle\n        //       auto joins in onNotice instead if the user has chosen to wait for NickServ\n        //       identification before auto joining channels.\n\n        // delay 1 sec before auto joining channels\n        try {\n            Thread.sleep(1000);\n        } catch(InterruptedException e) {\n            // do nothing\n        }\n\n        // join channels\n        if (autojoinChannels != null) {\n            for (String channel : autojoinChannels) {\n                // Add support for channel keys\n                joinChannel(channel);\n            }\n        } else {\n            for (String channel : server.getAutoJoinChannels()) {\n                joinChannel(channel);\n            }\n        }\n    }\n    /**\n     * On channel action\n     */\n    @Override\n    protected void onAction(String sender, String login, String hostname, String target, String action)\n    {\n        Conversation conversation;\n\n        Message message = new Message(sender + \" \" + action);\n        message.setIcon(R.drawable.action);\n\n        if (target.equals(this.getNick())) {\n            // We are the target - this is an action in a query\n            conversation = server.getConversation(sender);\n            if (conversation == null) {\n                // Open a query if there's none yet\n                conversation = new Query(sender);\n                server.addConversation(conversation);\n                conversation.addMessage(message);\n\n                Intent intent = Broadcast.createConversationIntent(\n                    Broadcast.CONVERSATION_NEW,\n                    server.getId(),\n                    sender\n                );\n                service.sendBroadcast(intent);\n            } else {\n                Intent intent = Broadcast.createConversationIntent(\n                    Broadcast.CONVERSATION_MESSAGE,\n                    server.getId(),\n                    sender\n                );\n                service.sendBroadcast(intent);\n            }\n        } else {\n            // A action in a channel\n            conversation = server.getConversation(target);\n            conversation.addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n\n        boolean mentioned = isMentioned(action);\n        if (mentioned || target.equals(this.getNick())) {\n            service.updateNotification(\n                target + \": \" + sender + \" \" + action,\n                service.getSettings().isVibrateHighlightEnabled(),\n                service.getSettings().isSoundHighlightEnabled()\n            );\n        }\n\n        if (mentioned) {\n            // highlight\n            message.setColor(Message.COLOR_RED);\n            conversation.setStatus(Conversation.STATUS_HIGHLIGHT);\n        }\n    }\n\n    /**\n     * On Channel Info\n     */\n    @Override\n    protected void onChannelInfo(String channel, int userCount, String topic)\n    {\n    }\n\n    /**\n     * On Deop\n     */\n    @Override\n    protected void onDeop(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n    {\n        Message message = new Message(service.getString(R.string.message_deop, sourceNick, recipient));\n        message.setIcon(R.drawable.op);\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On DeVoice\n     */\n    @Override\n    protected void onDeVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n    {\n        Message message = new Message(service.getString(R.string.message_devoice, sourceNick, recipient));\n        message.setColor(Message.COLOR_BLUE);\n        message.setIcon(R.drawable.voice);\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On Invite\n     */\n    @Override\n    protected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String target)\n    {\n        if (targetNick.equals(this.getNick())) {\n            // We are invited\n            Message message = new Message(service.getString(R.string.message_invite_you, sourceNick, target));\n            server.getConversation(server.getSelectedConversation()).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                server.getSelectedConversation()\n            );\n            service.sendBroadcast(intent);\n        } else {\n            // Someone is invited\n            Message message = new Message(service.getString(R.string.message_invite_someone, sourceNick, targetNick, target));\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Join\n     */\n    @Override\n    protected void onJoin(String target, String sender, String login, String hostname)\n    {\n        if (sender.equalsIgnoreCase(getNick())) {\n            // We joined a new channel\n            server.addConversation(new Channel(target));\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_NEW,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        } else if (service.getSettings().showJoinPartAndQuit()) {\n            Message message = new Message(\n                service.getString(R.string.message_join, sender),\n                Message.TYPE_MISC\n            );\n\n            message.setIcon(R.drawable.join);\n            message.setColor(Message.COLOR_GREEN);\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Kick\n     */\n    @Override\n    protected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n    {\n        if (recipientNick.equals(getNick())) {\n            // We are kicked\n            server.removeConversation(target);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_REMOVE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        } else {\n            Message message = new Message(service.getString(R.string.message_kick, kickerNick, recipientNick));\n            message.setColor(Message.COLOR_GREEN);\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Message\n     */\n    @Override\n    protected void onMessage(String target, String sender, String login, String hostname, String text)\n    {\n        Message message = new Message(text, sender);\n\n        if (isMentioned(text)) {\n            // highlight\n            message.setColor(Message.COLOR_RED);\n            service.updateNotification(\n                target + \": <\" + sender + \"> \" + text,\n                service.getSettings().isVibrateHighlightEnabled(),\n                service.getSettings().isSoundHighlightEnabled()\n            );\n\n            server.getConversation(target).setStatus(Conversation.STATUS_HIGHLIGHT);\n        }\n\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On Mode\n     */\n    @Override\n    protected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n    {\n        // Disabled as it doubles events (e.g. onOp and onMode will be called)\n\n        /*\n        Message message = new Message(sourceNick + \" sets mode \" + mode);\n        server.getChannel(target).addMessage(message);\n\n        Intent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n        intent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n        intent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n        service.sendBroadcast(intent);\n         */\n    }\n\n    /**\n     * On Nick Change\n     */\n    @Override\n    protected void onNickChange(String oldNick, String login, String hostname, String newNick)\n    {\n        if (getNick().equalsIgnoreCase(newNick)) {\n            this.updateNickMatchPattern();\n\n            // Send message about own change to server info window\n            Message message = new Message(service.getString(R.string.message_self_rename, newNick));\n            message.setColor(Message.COLOR_GREEN);\n            server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                ServerInfo.DEFAULT_NAME\n            );\n\n            service.sendBroadcast(intent);\n        }\n\n        Vector<String> channels = getChannelsByNickname(newNick);\n\n        for (String target : channels) {\n            Message message = new Message(service.getString(R.string.message_rename, oldNick, newNick));\n            message.setColor(Message.COLOR_GREEN);\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Notice\n     */\n    @Override\n    protected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n    {\n        // Post notice to currently selected conversation\n        Conversation conversation;\n\n        if (service.getSettings().showNoticeInServerWindow()) {\n            conversation = server.getConversation(ServerInfo.DEFAULT_NAME);\n        } else {\n            conversation = server.getConversation(server.getSelectedConversation());\n\n            if (conversation == null) {\n                // Fallback: Use ServerInfo view\n                conversation = server.getConversation(ServerInfo.DEFAULT_NAME);\n            }\n        }\n\n        Message message = new Message(\"-\" + sourceNick + \"- \" + notice);\n        message.setIcon(R.drawable.info);\n        conversation.addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            conversation.getName()\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On Op\n     */\n    @Override\n    protected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n    {\n        Message message = new Message(service.getString(R.string.message_op, sourceNick, recipient));\n        message.setColor(Message.COLOR_BLUE);\n        message.setIcon(R.drawable.op);\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On Part\n     */\n    @Override\n    protected void onPart(String target, String sender, String login, String hostname)\n    {\n        if (sender.equals(getNick())) {\n            // We parted a channel\n            server.removeConversation(target);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_REMOVE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        } else if (service.getSettings().showJoinPartAndQuit()) {\n            Message message = new Message(\n                service.getString(R.string.message_part, sender),\n                Message.TYPE_MISC\n            );\n\n            message.setColor(Message.COLOR_GREEN);\n            message.setIcon(R.drawable.part);\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Private Message\n     */\n    @Override\n    protected void onPrivateMessage(String sender, String login, String hostname, String text)\n    {\n        Message message = new Message(\"<\" + sender + \"> \" + text);\n\n        Conversation conversation = server.getConversation(sender);\n\n        if (conversation == null) {\n            // Open a query if there's none yet\n            conversation = new Query(sender);\n            conversation.addMessage(message);\n            server.addConversation(conversation);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_NEW,\n                server.getId(),\n                sender\n            );\n            service.sendBroadcast(intent);\n        } else {\n            conversation.addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                sender\n            );\n            service.sendBroadcast(intent);\n        }\n\n        service.updateNotification(\n            \"<\" + sender + \"> \" + text,\n            service.getSettings().isVibrateHighlightEnabled(),\n            service.getSettings().isSoundHighlightEnabled()\n        );\n\n        if (isMentioned(text)) {\n            message.setColor(Message.COLOR_RED);\n            conversation.setStatus(Conversation.STATUS_HIGHLIGHT);\n        }\n    }\n\n    /**\n     * On Quit\n     */\n    @Override\n    protected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n    {\n        if (sourceNick.equals(this.getNick())) {\n            return;\n        }\n\n        if (service.getSettings().showJoinPartAndQuit()) {\n            Vector<String> channels = getChannelsByNickname(sourceNick);\n\n            for (String target : channels) {\n                Message message = new Message(\n                    service.getString(R.string.message_quit, sourceNick, reason),\n                    Message.TYPE_MISC\n                );\n\n                message.setColor(Message.COLOR_GREEN);\n                message.setIcon(R.drawable.quit);\n                server.getConversation(target).addMessage(message);\n\n                Intent intent = Broadcast.createConversationIntent(\n                    Broadcast.CONVERSATION_MESSAGE,\n                    server.getId(),\n                    target\n                );\n                service.sendBroadcast(intent);\n            }\n\n            // Look if there's a query to update\n            Conversation conversation = server.getConversation(sourceNick);\n\n            if (conversation != null) {\n                Message message = new Message(\n                    service.getString(R.string.message_quit, sourceNick, reason),\n                    Message.TYPE_MISC\n                );\n\n                message.setColor(Message.COLOR_GREEN);\n                message.setIcon(R.drawable.quit);\n                conversation.addMessage(message);\n\n                Intent intent = Broadcast.createConversationIntent(\n                    Broadcast.CONVERSATION_MESSAGE,\n                    server.getId(),\n                    conversation.getName()\n                );\n                service.sendBroadcast(intent);\n            }\n        }\n    }\n\n    /**\n     * On Topic\n     */\n    @Override\n    public void onTopic(String target, String topic, String setBy, long date, boolean changed)\n    {\n        if (changed) {\n            Message message = new Message(service.getString(R.string.message_topic_set, setBy, topic));\n            message.setColor(Message.COLOR_YELLOW);\n            server.getConversation(target).addMessage(message);\n        } else {\n            Message message = new Message(service.getString(R.string.message_topic, topic));\n            message.setColor(Message.COLOR_YELLOW);\n            server.getConversation(target).addMessage(message);\n        }\n\n        // remember channel's topic\n        ((Channel) server.getConversation(target)).setTopic(topic);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On User List\n     */\n    @Override\n    protected void onUserList(String channel, User[] users)\n    {\n        // XXX: Store user list somewhere and keep it updated or just broadcast some event?\n    }\n\n    /**\n     * On Voice\n     */\n    @Override\n    protected void onVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n    {\n        Message message = new Message(service.getString(R.string.message_voice, sourceNick, recipient));\n        message.setIcon(R.drawable.voice);\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On remove channel key\n     */\n    @Override\n    protected void onRemoveChannelKey(String target, String sourceNick, String sourceLogin, String sourceHostname, String key)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_channel_key, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set channel key\n     */\n    @Override\n    protected void onSetChannelKey(String target, String sourceNick, String sourceLogin, String sourceHostname, String key)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_key, sourceNick, key));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set secret\n     */\n    @Override\n    protected void onSetSecret(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_secret, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove secret\n     */\n    @Override\n    protected void onRemoveSecret(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_public, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set channel limit\n     */\n    @Override\n    protected void onSetChannelLimit(String target, String sourceNick, String sourceLogin, String sourceHostname, int limit)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_limit, sourceNick, limit));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove channel limit\n     */\n    @Override\n    protected void onRemoveChannelLimit(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_channel_limit, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set channel ban\n     */\n    @Override\n    protected void onSetChannelBan(String target, String sourceNick, String sourceLogin, String sourceHostname, String hostmask)\n    {\n        Message message = new Message(service.getString(R.string.message_set_ban, sourceNick, hostmask));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove channel ban\n     */\n    @Override\n    protected void onRemoveChannelBan(String target, String sourceNick, String sourceLogin, String sourceHostname, String hostmask)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_ban, sourceNick, hostmask));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set topic protection\n     */\n    @Override\n    protected void onSetTopicProtection(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_topic_protection, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove topic protection\n     */\n    @Override\n    protected void onRemoveTopicProtection(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_topic_protection, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set no external messages\n     */\n    @Override\n    protected void onSetNoExternalMessages(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_disable_external, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove no external messages\n     */\n    @Override\n    protected void onRemoveNoExternalMessages(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_enable_external, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set invite only\n     */\n    @Override\n    protected void onSetInviteOnly(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_invite_only, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove invite only\n     */\n    @Override\n    protected void onRemoveInviteOnly(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_invite_only, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set moderated\n     */\n    @Override\n    protected void onSetModerated(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_moderated, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove moderated\n     */\n    @Override\n    protected void onRemoveModerated(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_moderated, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set private\n     */\n    @Override\n    protected void onSetPrivate(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_private, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove private\n     */\n    @Override\n    protected void onRemovePrivate(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_public, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On unknown\n     */\n    @Override\n    protected void onUnknown(String line)\n    {\n        Message message = new Message(line);\n        message.setIcon(R.drawable.action);\n        message.setColor(Message.COLOR_GREY);\n        server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            ServerInfo.DEFAULT_NAME\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On server response\n     */\n    @Override\n    protected void onServerResponse(int code, String response)\n    {\n        if (code == 4) {\n            // User has registered with the server\n            onRegister();\n            return;\n        }\n        if (code == 372 || code == 375 || code == 376) {\n            // Skip MOTD\n            return;\n        }\n\n        if (code >= 200 && code < 300) {\n            // Skip 2XX responses\n            return;\n        }\n\n        if (code == 353 || code == 366 || code == 332 || code == 333) {\n            return;\n        }\n\n        if (code < 10) {\n            // Skip server info\n            return;\n        }\n\n        // Currently disabled... to much text\n        Message message = new Message(response);\n        message.setColor(Message.COLOR_GREY);\n        server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            ServerInfo.DEFAULT_NAME\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On disconnect\n     */\n    @Override\n    public void onDisconnect()\n    {\n        // Call parent method to ensure \"register\" status is tracked\n        super.onDisconnect();\n\n        if (service.getSettings().isReconnectEnabled() && server.getStatus() != Status.DISCONNECTED) {\n            setAutojoinChannels(server.getCurrentChannelNames());\n\n            server.clearConversations();\n            server.setStatus(Status.CONNECTING);\n            service.connect(server);\n        } else {\n            server.setStatus(Status.DISCONNECTED);\n        }\n\n        service.updateNotification(service.getString(R.string.notification_disconnected, server.getTitle()));\n\n        Intent sIntent = Broadcast.createServerIntent(Broadcast.SERVER_UPDATE, server.getId());\n        service.sendBroadcast(sIntent);\n\n        Collection<Conversation> conversations = server.getConversations();\n\n        for (Conversation conversation : conversations) {\n            Message message = new Message(service.getString(R.string.message_disconnected));\n            message.setIcon(R.drawable.error);\n            message.setColor(Message.COLOR_RED);\n            server.getConversation(conversation.getName()).addMessage(message);\n\n            Intent cIntent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                conversation.getName()\n            );\n            service.sendBroadcast(cIntent);\n        }\n    }\n\n    /**\n     * Get all channels where the user with the given nickname is online\n     * \n     * @param nickname\n     * @return Array of channel names\n     */\n    private Vector<String> getChannelsByNickname(String nickname)\n    {\n        Vector<String> channels = new Vector<String>();\n        String[] channelArray = getChannels();\n\n        for (String channel : channelArray) {\n            User[] userArray = getUsers(channel);\n            for (User user : userArray) {\n                if (user.getNick().equals(nickname)) {\n                    channels.add(channel);\n                    break;\n                }\n            }\n        }\n\n        return channels;\n    }\n\n    /**\n     * Get list of users in a channel as array of strings\n     * \n     * @param channel Name of the channel\n     */\n    public String[] getUsersAsStringArray(String channel)\n    {\n        User[] userArray = getUsers(channel);\n        int mLength = userArray.length;\n        String[] users = new String[mLength];\n\n        for (int i = 0; i < mLength; i++) {\n            users[i] = userArray[i].getPrefix() + userArray[i].getNick();\n        }\n\n        return users;\n    }\n\n    /**\n     * Get a user by channel and nickname\n     * \n     * @param channel The channel the user is in\n     * @param nickname The nickname of the user (with or without prefix)\n     * @return the User object or null if user was not found\n     */\n    public User getUser(String channel, String nickname)\n    {\n        User[] users = getUsers(channel);\n        int mLength = users.length;\n\n        for (int i = 0; i < mLength; i++) {\n            if (nickname.equals(users[i].getNick())) {\n                return users[i];\n            }\n            if (nickname.equals(users[i].getPrefix() + users[i].getNick())) {\n                return users[i];\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Quits from the IRC server with default reason.\n     */\n    @Override\n    public void quitServer()\n    {\n        new Thread() {\n            @Override\n            public void run() {\n                quitServer(service.getSettings().getQuitMessage());\n            }\n        }.start();\n    }\n\n    /**\n     * Check whether the nickname has been mentioned.\n     * \n     * @param text The text to check for the nickname\n     * @return true if nickname was found, otherwise false\n     */\n    public boolean isMentioned(String text)\n    {\n        return mNickMatch.matcher(text).find();\n    }\n\n    /**\n     * Update the nick matching pattern, should be called when the nickname changes.\n     */\n    private void updateNickMatchPattern()\n    {\n        mNickMatch = Pattern.compile(\"(?:^|[\\\\s?!'�:;,.])\"+Pattern.quote(getNick())+\"(?:[\\\\s?!'�:;,.]|$)\", Pattern.CASE_INSENSITIVE);\n    }\n}\n","lineNo":247}
{"Smelly Sample":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2011 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage org.yaaic.irc;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.HashMap;\n\nimport org.jibble.pircbot.IrcException;\nimport org.jibble.pircbot.NickAlreadyInUseException;\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.activity.ServersActivity;\nimport org.yaaic.db.Database;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.ServerInfo;\nimport org.yaaic.model.Settings;\nimport org.yaaic.model.Status;\n\nimport android.app.Notification;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.app.Service;\nimport android.content.Intent;\n\n/**\n * The background service for managing the irc connections\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class IRCService extends Service\n{\n    private final IRCBinder binder;\n    private final HashMap<Integer, IRCConnection> connections;\n    private boolean foreground = false;\n\n    @SuppressWarnings(\"rawtypes\")\n    private static final Class[] mStartForegroundSignature = new Class[] { int.class, Notification.class };\n    @SuppressWarnings(\"rawtypes\")\n    private static final Class[] mStopForegroundSignature = new Class[] { boolean.class };\n\n    public static final String ACTION_FOREGROUND = \"org.yaaic.service.foreground\";\n    public static final String ACTION_BACKGROUND = \"org.yaaic.service.background\";\n\n    private NotificationManager notificationManager;\n    private Method mStartForeground;\n    private Method mStopForeground;\n    private final Object[] mStartForegroundArgs = new Object[2];\n    private final Object[] mStopForegroundArgs = new Object[1];\n    private Notification notification;\n    private Settings settings;\n\n    /**\n     * Create new service\n     */\n    public IRCService()\n    {\n        super();\n\n        this.connections = new HashMap<Integer, IRCConnection>();\n        this.binder = new IRCBinder(this);\n    }\n\n    /**\n     * On create\n     */\n    @Override\n    public void onCreate()\n    {\n        super.onCreate();\n\n        settings = new Settings(getBaseContext());\n        notificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);\n\n        try {\n            mStartForeground = getClass().getMethod(\"startForeground\", mStartForegroundSignature);\n            mStopForeground = getClass().getMethod(\"stopForeground\", mStopForegroundSignature);\n        } catch (NoSuchMethodException e) {\n            // Running on an older platform.\n            mStartForeground = mStopForeground = null;\n        }\n\n        // Load servers from Database\n        Database db = new Database(this);\n        Yaaic.getInstance().setServers(db.getServers());\n        db.close();\n\n        // Broadcast changed server list\n        sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n    }\n\n    /**\n     * Get Settings object\n     * \n     * @return the settings helper object\n     */\n    public Settings getSettings()\n    {\n        return settings;\n    }\n\n    /**\n     * On start (will be called on pre-2.0 platform. On 2.0 or later onStartCommand()\n     * will be called)\n     */\n    @Override\n    public void onStart(Intent intent, int startId)\n    {\n        super.onStart(intent, startId);\n        handleCommand(intent);\n    }\n\n    /**\n     * On start command (Android >= 2.0)\n     * \n     * @param intent\n     * @param flags\n     * @param startId\n     * @return\n     */\n    public int onStartCommand(Intent intent, int flags, int startId)\n    {\n        if (intent != null) {\n            handleCommand(intent);\n        }\n\n        // We want this service to continue running until it is explicitly\n        // stopped, so return sticky.\n        //return START_STICKY;\n        return 1;\n    }\n\n\n    /**\n     * Handle command\n     * \n     * @param intent\n     */\n    private void handleCommand(Intent intent)\n    {\n        if (ACTION_FOREGROUND.equals(intent.getAction())) {\n            if (foreground) {\n                return; // XXX: We are already in foreground...\n            }\n            foreground = true;\n\n            // Set the icon, scrolling text and timestamp\n            notification = new Notification(R.drawable.icon, \"\", System.currentTimeMillis());\n\n            // The PendingIntent to launch our activity if the user selects this notification\n            PendingIntent contentIntent = PendingIntent.getActivity(this, 0, new Intent(this, ServersActivity.class), 0);\n\n            // Set the info for the views that show in the notification panel.\n            notification.setLatestEventInfo(this, getText(R.string.app_name), \"\", contentIntent);\n\n            startForegroundCompat(R.string.app_name, notification);\n        } else if (ACTION_BACKGROUND.equals(intent.getAction()) && !foreground) {\n            stopForegroundCompat(R.string.app_name);\n        }\n    }\n\n    /**\n     * Update notification\n     * \n     * @param text The text to display\n     */\n    public void updateNotification(String text)\n    {\n        updateNotification(text, false, false);\n    }\n\n    /**\n     * Update notification and vibrate if needed\n     *\n     * @param text       The text to display\n     * @param vibrate True if the device should vibrate, false otherwise\n     */\n    public void updateNotification(String text, boolean vibrate, boolean sound)\n    {\n        if (foreground) {\n            notificationManager.cancel(R.string.app_name);\n            notification = new Notification(R.drawable.icon, text, System.currentTimeMillis());\n            PendingIntent contentIntent = PendingIntent.getActivity(this, 0, new Intent(this, ServersActivity.class), 0);\n            notification.setLatestEventInfo(this, getText(R.string.app_name), text, contentIntent);\n\n            if (vibrate) {\n                long[] pattern = {0,100,200,300};\n                notification.vibrate = pattern;\n            }\n\n            if (sound) {\n                notification.defaults |= Notification.DEFAULT_SOUND;\n            }\n\n            notificationManager.notify(R.string.app_name, notification);\n        }\n    }\n\n    /**\n     * This is a wrapper around the new startForeground method, using the older\n     * APIs if it is not available.\n     */\n    private void startForegroundCompat(int id, Notification notification)\n    {\n        // If we have the new startForeground API, then use it.\n        if (mStartForeground != null) {\n            mStartForegroundArgs[0] = Integer.valueOf(id);\n            mStartForegroundArgs[1] = notification;\n            try {\n                mStartForeground.invoke(this, mStartForegroundArgs);\n            } catch (InvocationTargetException e) {\n                // Should not happen.\n            } catch (IllegalAccessException e) {\n                // Should not happen.\n            }\n        } else {\n            // Fall back on the old API.\n            setForeground(true);\n            notificationManager.notify(id, notification);\n        }\n    }\n\n    /**\n     * This is a wrapper around the new stopForeground method, using the older\n     * APIs if it is not available.\n     */\n    public void stopForegroundCompat(int id)\n    {\n        foreground = false;\n\n        // If we have the new stopForeground API, then use it.\n        if (mStopForeground != null) {\n            mStopForegroundArgs[0] = Boolean.TRUE;\n            try {\n                mStopForeground.invoke(this, mStopForegroundArgs);\n            } catch (InvocationTargetException e) {\n                // Should not happen.\n            } catch (IllegalAccessException e) {\n                // Should not happen.\n            }\n        } else {\n            // Fall back on the old API.  Note to cancel BEFORE changing the\n            // foreground state, since we could be killed at that point.\n            notificationManager.cancel(id);\n            setForeground(false);\n        }\n    }\n\n    /**\n     * Connect to the given server\n     */\n    public void connect(final Server server)\n    {\n        new Thread() {\n            @Override\n            public void run() {\n                try {\n                    IRCConnection connection = getConnection(server.getId());\n\n                    connection.setNickname(server.getIdentity().getNickname());\n                    connection.setAliases(server.getIdentity().getAliases());\n                    connection.setIdent(server.getIdentity().getIdent());\n                    connection.setRealName(server.getIdentity().getRealName());\n                    connection.setUseSSL(server.useSSL());\n\n                    if (server.getCharset() != null) {\n                        connection.setEncoding(server.getCharset());\n                    }\n\n                    if (server.getPassword() != \"\") {\n                        connection.connect(server.getHost(), server.getPort(), server.getPassword());\n                    } else {\n                        connection.connect(server.getHost(), server.getPort());\n                    }\n                }\n                catch (Exception e) {\n                    server.setStatus(Status.DISCONNECTED);\n\n                    Intent sIntent = Broadcast.createServerIntent(Broadcast.SERVER_UPDATE, server.getId());\n                    sendBroadcast(sIntent);\n\n                    IRCConnection connection = getConnection(server.getId());\n\n                    Message message;\n\n                    if (e instanceof NickAlreadyInUseException) {\n                        message = new Message(getString(R.string.nickname_in_use, connection.getNick()));\n                    } else if (e instanceof IrcException) {\n                        message = new Message(getString(R.string.irc_login_error, server.getHost(), server.getPort()));\n                    } else {\n                        message = new Message(getString(R.string.could_not_connect, server.getHost(), server.getPort()));\n                    }\n\n                    message.setColor(Message.COLOR_RED);\n                    message.setIcon(R.drawable.error);\n                    server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n                    Intent cIntent = Broadcast.createConversationIntent(\n                        Broadcast.CONVERSATION_MESSAGE,\n                        server.getId(),\n                        ServerInfo.DEFAULT_NAME\n                    );\n                    sendBroadcast(cIntent);\n                }\n            }\n        }.start();\n    }\n\n    /**\n     * Get connection for given server\n     * \n     * @param serverId\n     * @return\n     */\n    public synchronized IRCConnection getConnection(int serverId)\n    {\n        IRCConnection connection = connections.get(serverId);\n\n        if (connection == null) {\n            connection = new IRCConnection(this, serverId);\n            connections.put(serverId, connection);\n        }\n\n        return connection;\n    }\n\n    /**\n     * Does the service keep a connection object for this server?\n     * \n     * @return true if there's a connection object, false otherwise\n     */\n    public boolean hasConnection(int serverId)\n    {\n        return connections.containsKey(serverId);\n    }\n\n    /**\n     * Check status of service\n     */\n    public void checkServiceStatus()\n    {\n        boolean shutDown = true;\n        ArrayList<Server> mServers = Yaaic.getInstance().getServersAsArrayList();\n        int mSize = mServers.size();\n        Server server;\n\n        for (int i = 0; i < mSize; i++) {\n            server = mServers.get(i);\n            if (server.isDisconnected()) {\n                connections.remove(server.getId());\n            } else {\n                shutDown = false;\n            }\n        }\n\n        if (shutDown) {\n            foreground = false;\n            stopForegroundCompat(R.string.app_name);\n            stopSelf();\n        }\n    }\n\n    /**\n     * On Destroy\n     */\n    @Override\n    public void onDestroy()\n    {\n        // Make sure our notification is gone.\n        if (foreground) {\n            stopForegroundCompat(R.string.app_name);\n        }\n    }\n\n    /**\n     * On Activity binding to this service\n     * \n     * @param intent\n     * @return\n     */\n    @Override\n    public IRCBinder onBind(Intent intent)\n    {\n        return binder;\n    }\n}\n","Method after Refactoring":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2011 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage org.yaaic.irc;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.HashMap;\n\nimport org.jibble.pircbot.IrcException;\nimport org.jibble.pircbot.NickAlreadyInUseException;\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.activity.ServersActivity;\nimport org.yaaic.db.Database;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.ServerInfo;\nimport org.yaaic.model.Settings;\nimport org.yaaic.model.Status;\n\nimport android.app.Notification;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.app.Service;\nimport android.content.Intent;\n\n/**\n * The background service for managing the irc connections\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class IRCService extends Service\n{\n    private final IRCBinder binder;\n    private final HashMap<Integer, IRCConnection> connections;\n    private boolean foreground = false;\n\n    @SuppressWarnings(\"rawtypes\")\n    private static final Class[] mStartForegroundSignature = new Class[] { int.class, Notification.class };\n    @SuppressWarnings(\"rawtypes\")\n    private static final Class[] mStopForegroundSignature = new Class[] { boolean.class };\n\n    public static final String ACTION_FOREGROUND = \"org.yaaic.service.foreground\";\n    public static final String ACTION_BACKGROUND = \"org.yaaic.service.background\";\n\n    private NotificationManager notificationManager;\n    private Method mStartForeground;\n    private Method mStopForeground;\n    private final Object[] mStartForegroundArgs = new Object[2];\n    private final Object[] mStopForegroundArgs = new Object[1];\n    private Notification notification;\n    private Settings settings;\n\n    /**\n     * Create new service\n     */\n    public IRCService()\n    {\n        super();\n\n        this.connections = new HashMap<Integer, IRCConnection>();\n        this.binder = new IRCBinder(this);\n    }\n\n    /**\n     * On create\n     */\n    @Override\n    public void onCreate()\n    {\n        super.onCreate();\n\n        settings = new Settings(getBaseContext());\n        notificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);\n\n        try {\n            mStartForeground = getClass().getMethod(\"startForeground\", mStartForegroundSignature);\n            mStopForeground = getClass().getMethod(\"stopForeground\", mStopForegroundSignature);\n        } catch (NoSuchMethodException e) {\n            // Running on an older platform.\n            mStartForeground = mStopForeground = null;\n        }\n\n        // Load servers from Database\n        Database db = new Database(this);\n        Yaaic.getInstance().setServers(db.getServers());\n        db.close();\n\n        // Broadcast changed server list\n        sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n    }\n\n    /**\n     * Get Settings object\n     * \n     * @return the settings helper object\n     */\n    public Settings getSettings()\n    {\n        return settings;\n    }\n\n    /**\n     * On start (will be called on pre-2.0 platform. On 2.0 or later onStartCommand()\n     * will be called)\n     */\n    @Override\n    public void onStart(Intent intent, int startId)\n    {\n        super.onStart(intent, startId);\n        handleCommand(intent);\n    }\n\n    /**\n     * On start command (Android >= 2.0)\n     * \n     * @param intent\n     * @param flags\n     * @param startId\n     * @return\n     */\n    public int onStartCommand(Intent intent, int flags, int startId)\n    {\n        if (intent != null) {\n            handleCommand(intent);\n        }\n\n        // We want this service to continue running until it is explicitly\n        // stopped, so return sticky.\n        //return START_STICKY;\n        return 1;\n    }\n\n\n    /**\n     * Handle command\n     * \n     * @param intent\n     */\n    private void handleCommand(Intent intent)\n    {\n        if (ACTION_FOREGROUND.equals(intent.getAction())) {\n            if (foreground) {\n                return; // XXX: We are already in foreground...\n            }\n            foreground = true;\n\n            // Set the icon, scrolling text and timestamp\n            notification = new Notification(R.drawable.icon, \"\", System.currentTimeMillis());\n\n            // The PendingIntent to launch our activity if the user selects this notification\n            Intent notifyIntent = new Intent(this, ServersActivity.class);\n            notifyIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n            PendingIntent contentIntent = PendingIntent.getActivity(this, 0, notifyIntent, 0);\n\n            // Set the info for the views that show in the notification panel.\n            notification.setLatestEventInfo(this, getText(R.string.app_name), \"\", contentIntent);\n\n            startForegroundCompat(R.string.app_name, notification);\n        } else if (ACTION_BACKGROUND.equals(intent.getAction()) && !foreground) {\n            stopForegroundCompat(R.string.app_name);\n        }\n    }\n\n    /**\n     * Update notification\n     * \n     * @param text The text to display\n     */\n    public void updateNotification(String text)\n    {\n        updateNotification(text, false, false);\n    }\n\n    /**\n     * Update notification and vibrate if needed\n     *\n     * @param text       The text to display\n     * @param vibrate True if the device should vibrate, false otherwise\n     */\n    public void updateNotification(String text, boolean vibrate, boolean sound)\n    {\n        if (foreground) {\n            notificationManager.cancel(R.string.app_name);\n            notification = new Notification(R.drawable.icon, text, System.currentTimeMillis());\n            Intent notifyIntent = new Intent(this, ServersActivity.class);\n            notifyIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n            PendingIntent contentIntent = PendingIntent.getActivity(this, 0, notifyIntent, 0);\n            notification.setLatestEventInfo(this, getText(R.string.app_name), text, contentIntent);\n\n            if (vibrate) {\n                long[] pattern = {0,100,200,300};\n                notification.vibrate = pattern;\n            }\n\n            if (sound) {\n                notification.defaults |= Notification.DEFAULT_SOUND;\n            }\n\n            notificationManager.notify(R.string.app_name, notification);\n        }\n    }\n\n    /**\n     * This is a wrapper around the new startForeground method, using the older\n     * APIs if it is not available.\n     */\n    private void startForegroundCompat(int id, Notification notification)\n    {\n        // If we have the new startForeground API, then use it.\n        if (mStartForeground != null) {\n            mStartForegroundArgs[0] = Integer.valueOf(id);\n            mStartForegroundArgs[1] = notification;\n            try {\n                mStartForeground.invoke(this, mStartForegroundArgs);\n            } catch (InvocationTargetException e) {\n                // Should not happen.\n            } catch (IllegalAccessException e) {\n                // Should not happen.\n            }\n        } else {\n            // Fall back on the old API.\n            setForeground(true);\n            notificationManager.notify(id, notification);\n        }\n    }\n\n    /**\n     * This is a wrapper around the new stopForeground method, using the older\n     * APIs if it is not available.\n     */\n    public void stopForegroundCompat(int id)\n    {\n        foreground = false;\n\n        // If we have the new stopForeground API, then use it.\n        if (mStopForeground != null) {\n            mStopForegroundArgs[0] = Boolean.TRUE;\n            try {\n                mStopForeground.invoke(this, mStopForegroundArgs);\n            } catch (InvocationTargetException e) {\n                // Should not happen.\n            } catch (IllegalAccessException e) {\n                // Should not happen.\n            }\n        } else {\n            // Fall back on the old API.  Note to cancel BEFORE changing the\n            // foreground state, since we could be killed at that point.\n            notificationManager.cancel(id);\n            setForeground(false);\n        }\n    }\n\n    /**\n     * Connect to the given server\n     */\n    public void connect(final Server server)\n    {\n        new Thread() {\n            @Override\n            public void run() {\n                try {\n                    IRCConnection connection = getConnection(server.getId());\n\n                    connection.setNickname(server.getIdentity().getNickname());\n                    connection.setAliases(server.getIdentity().getAliases());\n                    connection.setIdent(server.getIdentity().getIdent());\n                    connection.setRealName(server.getIdentity().getRealName());\n                    connection.setUseSSL(server.useSSL());\n\n                    if (server.getCharset() != null) {\n                        connection.setEncoding(server.getCharset());\n                    }\n\n                    if (server.getPassword() != \"\") {\n                        connection.connect(server.getHost(), server.getPort(), server.getPassword());\n                    } else {\n                        connection.connect(server.getHost(), server.getPort());\n                    }\n                }\n                catch (Exception e) {\n                    server.setStatus(Status.DISCONNECTED);\n\n                    Intent sIntent = Broadcast.createServerIntent(Broadcast.SERVER_UPDATE, server.getId());\n                    sendBroadcast(sIntent);\n\n                    IRCConnection connection = getConnection(server.getId());\n\n                    Message message;\n\n                    if (e instanceof NickAlreadyInUseException) {\n                        message = new Message(getString(R.string.nickname_in_use, connection.getNick()));\n                    } else if (e instanceof IrcException) {\n                        message = new Message(getString(R.string.irc_login_error, server.getHost(), server.getPort()));\n                    } else {\n                        message = new Message(getString(R.string.could_not_connect, server.getHost(), server.getPort()));\n                    }\n\n                    message.setColor(Message.COLOR_RED);\n                    message.setIcon(R.drawable.error);\n                    server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n                    Intent cIntent = Broadcast.createConversationIntent(\n                        Broadcast.CONVERSATION_MESSAGE,\n                        server.getId(),\n                        ServerInfo.DEFAULT_NAME\n                    );\n                    sendBroadcast(cIntent);\n                }\n            }\n        }.start();\n    }\n\n    /**\n     * Get connection for given server\n     * \n     * @param serverId\n     * @return\n     */\n    public synchronized IRCConnection getConnection(int serverId)\n    {\n        IRCConnection connection = connections.get(serverId);\n\n        if (connection == null) {\n            connection = new IRCConnection(this, serverId);\n            connections.put(serverId, connection);\n        }\n\n        return connection;\n    }\n\n    /**\n     * Does the service keep a connection object for this server?\n     * \n     * @return true if there's a connection object, false otherwise\n     */\n    public boolean hasConnection(int serverId)\n    {\n        return connections.containsKey(serverId);\n    }\n\n    /**\n     * Check status of service\n     */\n    public void checkServiceStatus()\n    {\n        boolean shutDown = true;\n        ArrayList<Server> mServers = Yaaic.getInstance().getServersAsArrayList();\n        int mSize = mServers.size();\n        Server server;\n\n        for (int i = 0; i < mSize; i++) {\n            server = mServers.get(i);\n            if (server.isDisconnected()) {\n                connections.remove(server.getId());\n            } else {\n                shutDown = false;\n            }\n        }\n\n        if (shutDown) {\n            foreground = false;\n            stopForegroundCompat(R.string.app_name);\n            stopSelf();\n        }\n    }\n\n    /**\n     * On Destroy\n     */\n    @Override\n    public void onDestroy()\n    {\n        // Make sure our notification is gone.\n        if (foreground) {\n            stopForegroundCompat(R.string.app_name);\n        }\n    }\n\n    /**\n     * On Activity binding to this service\n     * \n     * @param intent\n     * @return\n     */\n    @Override\n    public IRCBinder onBind(Intent intent)\n    {\n        return binder;\n    }\n}\n","lineNo":172}
{"Smelly Sample":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2011 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage org.yaaic.irc;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.HashMap;\n\nimport org.jibble.pircbot.IrcException;\nimport org.jibble.pircbot.NickAlreadyInUseException;\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.activity.ServersActivity;\nimport org.yaaic.db.Database;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.ServerInfo;\nimport org.yaaic.model.Settings;\nimport org.yaaic.model.Status;\n\nimport android.app.Notification;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.app.Service;\nimport android.content.Intent;\n\n/**\n * The background service for managing the irc connections\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class IRCService extends Service\n{\n    private final IRCBinder binder;\n    private final HashMap<Integer, IRCConnection> connections;\n    private boolean foreground = false;\n\n    @SuppressWarnings(\"rawtypes\")\n    private static final Class[] mStartForegroundSignature = new Class[] { int.class, Notification.class };\n    @SuppressWarnings(\"rawtypes\")\n    private static final Class[] mStopForegroundSignature = new Class[] { boolean.class };\n\n    public static final String ACTION_FOREGROUND = \"org.yaaic.service.foreground\";\n    public static final String ACTION_BACKGROUND = \"org.yaaic.service.background\";\n\n    private NotificationManager notificationManager;\n    private Method mStartForeground;\n    private Method mStopForeground;\n    private final Object[] mStartForegroundArgs = new Object[2];\n    private final Object[] mStopForegroundArgs = new Object[1];\n    private Notification notification;\n    private Settings settings;\n\n    /**\n     * Create new service\n     */\n    public IRCService()\n    {\n        super();\n\n        this.connections = new HashMap<Integer, IRCConnection>();\n        this.binder = new IRCBinder(this);\n    }\n\n    /**\n     * On create\n     */\n    @Override\n    public void onCreate()\n    {\n        super.onCreate();\n\n        settings = new Settings(getBaseContext());\n        notificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);\n\n        try {\n            mStartForeground = getClass().getMethod(\"startForeground\", mStartForegroundSignature);\n            mStopForeground = getClass().getMethod(\"stopForeground\", mStopForegroundSignature);\n        } catch (NoSuchMethodException e) {\n            // Running on an older platform.\n            mStartForeground = mStopForeground = null;\n        }\n\n        // Load servers from Database\n        Database db = new Database(this);\n        Yaaic.getInstance().setServers(db.getServers());\n        db.close();\n\n        // Broadcast changed server list\n        sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n    }\n\n    /**\n     * Get Settings object\n     * \n     * @return the settings helper object\n     */\n    public Settings getSettings()\n    {\n        return settings;\n    }\n\n    /**\n     * On start (will be called on pre-2.0 platform. On 2.0 or later onStartCommand()\n     * will be called)\n     */\n    @Override\n    public void onStart(Intent intent, int startId)\n    {\n        super.onStart(intent, startId);\n        handleCommand(intent);\n    }\n\n    /**\n     * On start command (Android >= 2.0)\n     * \n     * @param intent\n     * @param flags\n     * @param startId\n     * @return\n     */\n    public int onStartCommand(Intent intent, int flags, int startId)\n    {\n        if (intent != null) {\n            handleCommand(intent);\n        }\n\n        // We want this service to continue running until it is explicitly\n        // stopped, so return sticky.\n        //return START_STICKY;\n        return 1;\n    }\n\n\n    /**\n     * Handle command\n     * \n     * @param intent\n     */\n    private void handleCommand(Intent intent)\n    {\n        if (ACTION_FOREGROUND.equals(intent.getAction())) {\n            if (foreground) {\n                return; // XXX: We are already in foreground...\n            }\n            foreground = true;\n\n            // Set the icon, scrolling text and timestamp\n            notification = new Notification(R.drawable.icon, \"\", System.currentTimeMillis());\n\n            // The PendingIntent to launch our activity if the user selects this notification\n            PendingIntent contentIntent = PendingIntent.getActivity(this, 0, new Intent(this, ServersActivity.class), 0);\n\n            // Set the info for the views that show in the notification panel.\n            notification.setLatestEventInfo(this, getText(R.string.app_name), \"\", contentIntent);\n\n            startForegroundCompat(R.string.app_name, notification);\n        } else if (ACTION_BACKGROUND.equals(intent.getAction()) && !foreground) {\n            stopForegroundCompat(R.string.app_name);\n        }\n    }\n\n    /**\n     * Update notification\n     * \n     * @param text The text to display\n     */\n    public void updateNotification(String text)\n    {\n        updateNotification(text, false, false);\n    }\n\n    /**\n     * Update notification and vibrate if needed\n     *\n     * @param text       The text to display\n     * @param vibrate True if the device should vibrate, false otherwise\n     */\n    public void updateNotification(String text, boolean vibrate, boolean sound)\n    {\n        if (foreground) {\n            notificationManager.cancel(R.string.app_name);\n            notification = new Notification(R.drawable.icon, text, System.currentTimeMillis());\n            PendingIntent contentIntent = PendingIntent.getActivity(this, 0, new Intent(this, ServersActivity.class), 0);\n            notification.setLatestEventInfo(this, getText(R.string.app_name), text, contentIntent);\n\n            if (vibrate) {\n                long[] pattern = {0,100,200,300};\n                notification.vibrate = pattern;\n            }\n\n            if (sound) {\n                notification.defaults |= Notification.DEFAULT_SOUND;\n            }\n\n            notificationManager.notify(R.string.app_name, notification);\n        }\n    }\n\n    /**\n     * This is a wrapper around the new startForeground method, using the older\n     * APIs if it is not available.\n     */\n    private void startForegroundCompat(int id, Notification notification)\n    {\n        // If we have the new startForeground API, then use it.\n        if (mStartForeground != null) {\n            mStartForegroundArgs[0] = Integer.valueOf(id);\n            mStartForegroundArgs[1] = notification;\n            try {\n                mStartForeground.invoke(this, mStartForegroundArgs);\n            } catch (InvocationTargetException e) {\n                // Should not happen.\n            } catch (IllegalAccessException e) {\n                // Should not happen.\n            }\n        } else {\n            // Fall back on the old API.\n            setForeground(true);\n            notificationManager.notify(id, notification);\n        }\n    }\n\n    /**\n     * This is a wrapper around the new stopForeground method, using the older\n     * APIs if it is not available.\n     */\n    public void stopForegroundCompat(int id)\n    {\n        foreground = false;\n\n        // If we have the new stopForeground API, then use it.\n        if (mStopForeground != null) {\n            mStopForegroundArgs[0] = Boolean.TRUE;\n            try {\n                mStopForeground.invoke(this, mStopForegroundArgs);\n            } catch (InvocationTargetException e) {\n                // Should not happen.\n            } catch (IllegalAccessException e) {\n                // Should not happen.\n            }\n        } else {\n            // Fall back on the old API.  Note to cancel BEFORE changing the\n            // foreground state, since we could be killed at that point.\n            notificationManager.cancel(id);\n            setForeground(false);\n        }\n    }\n\n    /**\n     * Connect to the given server\n     */\n    public void connect(final Server server)\n    {\n        new Thread() {\n            @Override\n            public void run() {\n                try {\n                    IRCConnection connection = getConnection(server.getId());\n\n                    connection.setNickname(server.getIdentity().getNickname());\n                    connection.setAliases(server.getIdentity().getAliases());\n                    connection.setIdent(server.getIdentity().getIdent());\n                    connection.setRealName(server.getIdentity().getRealName());\n                    connection.setUseSSL(server.useSSL());\n\n                    if (server.getCharset() != null) {\n                        connection.setEncoding(server.getCharset());\n                    }\n\n                    if (server.getPassword() != \"\") {\n                        connection.connect(server.getHost(), server.getPort(), server.getPassword());\n                    } else {\n                        connection.connect(server.getHost(), server.getPort());\n                    }\n                }\n                catch (Exception e) {\n                    server.setStatus(Status.DISCONNECTED);\n\n                    Intent sIntent = Broadcast.createServerIntent(Broadcast.SERVER_UPDATE, server.getId());\n                    sendBroadcast(sIntent);\n\n                    IRCConnection connection = getConnection(server.getId());\n\n                    Message message;\n\n                    if (e instanceof NickAlreadyInUseException) {\n                        message = new Message(getString(R.string.nickname_in_use, connection.getNick()));\n                    } else if (e instanceof IrcException) {\n                        message = new Message(getString(R.string.irc_login_error, server.getHost(), server.getPort()));\n                    } else {\n                        message = new Message(getString(R.string.could_not_connect, server.getHost(), server.getPort()));\n                    }\n\n                    message.setColor(Message.COLOR_RED);\n                    message.setIcon(R.drawable.error);\n                    server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n                    Intent cIntent = Broadcast.createConversationIntent(\n                        Broadcast.CONVERSATION_MESSAGE,\n                        server.getId(),\n                        ServerInfo.DEFAULT_NAME\n                    );\n                    sendBroadcast(cIntent);\n                }\n            }\n        }.start();\n    }\n\n    /**\n     * Get connection for given server\n     * \n     * @param serverId\n     * @return\n     */\n    public synchronized IRCConnection getConnection(int serverId)\n    {\n        IRCConnection connection = connections.get(serverId);\n\n        if (connection == null) {\n            connection = new IRCConnection(this, serverId);\n            connections.put(serverId, connection);\n        }\n\n        return connection;\n    }\n\n    /**\n     * Does the service keep a connection object for this server?\n     * \n     * @return true if there's a connection object, false otherwise\n     */\n    public boolean hasConnection(int serverId)\n    {\n        return connections.containsKey(serverId);\n    }\n\n    /**\n     * Check status of service\n     */\n    public void checkServiceStatus()\n    {\n        boolean shutDown = true;\n        ArrayList<Server> mServers = Yaaic.getInstance().getServersAsArrayList();\n        int mSize = mServers.size();\n        Server server;\n\n        for (int i = 0; i < mSize; i++) {\n            server = mServers.get(i);\n            if (server.isDisconnected()) {\n                connections.remove(server.getId());\n            } else {\n                shutDown = false;\n            }\n        }\n\n        if (shutDown) {\n            foreground = false;\n            stopForegroundCompat(R.string.app_name);\n            stopSelf();\n        }\n    }\n\n    /**\n     * On Destroy\n     */\n    @Override\n    public void onDestroy()\n    {\n        // Make sure our notification is gone.\n        if (foreground) {\n            stopForegroundCompat(R.string.app_name);\n        }\n    }\n\n    /**\n     * On Activity binding to this service\n     * \n     * @param intent\n     * @return\n     */\n    @Override\n    public IRCBinder onBind(Intent intent)\n    {\n        return binder;\n    }\n}\n","Method after Refactoring":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2011 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage org.yaaic.irc;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.HashMap;\n\nimport org.jibble.pircbot.IrcException;\nimport org.jibble.pircbot.NickAlreadyInUseException;\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.activity.ServersActivity;\nimport org.yaaic.db.Database;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.ServerInfo;\nimport org.yaaic.model.Settings;\nimport org.yaaic.model.Status;\n\nimport android.app.Notification;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.app.Service;\nimport android.content.Intent;\n\n/**\n * The background service for managing the irc connections\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class IRCService extends Service\n{\n    private final IRCBinder binder;\n    private final HashMap<Integer, IRCConnection> connections;\n    private boolean foreground = false;\n\n    @SuppressWarnings(\"rawtypes\")\n    private static final Class[] mStartForegroundSignature = new Class[] { int.class, Notification.class };\n    @SuppressWarnings(\"rawtypes\")\n    private static final Class[] mStopForegroundSignature = new Class[] { boolean.class };\n\n    public static final String ACTION_FOREGROUND = \"org.yaaic.service.foreground\";\n    public static final String ACTION_BACKGROUND = \"org.yaaic.service.background\";\n\n    private NotificationManager notificationManager;\n    private Method mStartForeground;\n    private Method mStopForeground;\n    private final Object[] mStartForegroundArgs = new Object[2];\n    private final Object[] mStopForegroundArgs = new Object[1];\n    private Notification notification;\n    private Settings settings;\n\n    /**\n     * Create new service\n     */\n    public IRCService()\n    {\n        super();\n\n        this.connections = new HashMap<Integer, IRCConnection>();\n        this.binder = new IRCBinder(this);\n    }\n\n    /**\n     * On create\n     */\n    @Override\n    public void onCreate()\n    {\n        super.onCreate();\n\n        settings = new Settings(getBaseContext());\n        notificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);\n\n        try {\n            mStartForeground = getClass().getMethod(\"startForeground\", mStartForegroundSignature);\n            mStopForeground = getClass().getMethod(\"stopForeground\", mStopForegroundSignature);\n        } catch (NoSuchMethodException e) {\n            // Running on an older platform.\n            mStartForeground = mStopForeground = null;\n        }\n\n        // Load servers from Database\n        Database db = new Database(this);\n        Yaaic.getInstance().setServers(db.getServers());\n        db.close();\n\n        // Broadcast changed server list\n        sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n    }\n\n    /**\n     * Get Settings object\n     * \n     * @return the settings helper object\n     */\n    public Settings getSettings()\n    {\n        return settings;\n    }\n\n    /**\n     * On start (will be called on pre-2.0 platform. On 2.0 or later onStartCommand()\n     * will be called)\n     */\n    @Override\n    public void onStart(Intent intent, int startId)\n    {\n        super.onStart(intent, startId);\n        handleCommand(intent);\n    }\n\n    /**\n     * On start command (Android >= 2.0)\n     * \n     * @param intent\n     * @param flags\n     * @param startId\n     * @return\n     */\n    public int onStartCommand(Intent intent, int flags, int startId)\n    {\n        if (intent != null) {\n            handleCommand(intent);\n        }\n\n        // We want this service to continue running until it is explicitly\n        // stopped, so return sticky.\n        //return START_STICKY;\n        return 1;\n    }\n\n\n    /**\n     * Handle command\n     * \n     * @param intent\n     */\n    private void handleCommand(Intent intent)\n    {\n        if (ACTION_FOREGROUND.equals(intent.getAction())) {\n            if (foreground) {\n                return; // XXX: We are already in foreground...\n            }\n            foreground = true;\n\n            // Set the icon, scrolling text and timestamp\n            notification = new Notification(R.drawable.icon, \"\", System.currentTimeMillis());\n\n            // The PendingIntent to launch our activity if the user selects this notification\n            Intent notifyIntent = new Intent(this, ServersActivity.class);\n            notifyIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n            PendingIntent contentIntent = PendingIntent.getActivity(this, 0, notifyIntent, 0);\n\n            // Set the info for the views that show in the notification panel.\n            notification.setLatestEventInfo(this, getText(R.string.app_name), \"\", contentIntent);\n\n            startForegroundCompat(R.string.app_name, notification);\n        } else if (ACTION_BACKGROUND.equals(intent.getAction()) && !foreground) {\n            stopForegroundCompat(R.string.app_name);\n        }\n    }\n\n    /**\n     * Update notification\n     * \n     * @param text The text to display\n     */\n    public void updateNotification(String text)\n    {\n        updateNotification(text, false, false);\n    }\n\n    /**\n     * Update notification and vibrate if needed\n     *\n     * @param text       The text to display\n     * @param vibrate True if the device should vibrate, false otherwise\n     */\n    public void updateNotification(String text, boolean vibrate, boolean sound)\n    {\n        if (foreground) {\n            notificationManager.cancel(R.string.app_name);\n            notification = new Notification(R.drawable.icon, text, System.currentTimeMillis());\n            Intent notifyIntent = new Intent(this, ServersActivity.class);\n            notifyIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n            PendingIntent contentIntent = PendingIntent.getActivity(this, 0, notifyIntent, 0);\n            notification.setLatestEventInfo(this, getText(R.string.app_name), text, contentIntent);\n\n            if (vibrate) {\n                long[] pattern = {0,100,200,300};\n                notification.vibrate = pattern;\n            }\n\n            if (sound) {\n                notification.defaults |= Notification.DEFAULT_SOUND;\n            }\n\n            notificationManager.notify(R.string.app_name, notification);\n        }\n    }\n\n    /**\n     * This is a wrapper around the new startForeground method, using the older\n     * APIs if it is not available.\n     */\n    private void startForegroundCompat(int id, Notification notification)\n    {\n        // If we have the new startForeground API, then use it.\n        if (mStartForeground != null) {\n            mStartForegroundArgs[0] = Integer.valueOf(id);\n            mStartForegroundArgs[1] = notification;\n            try {\n                mStartForeground.invoke(this, mStartForegroundArgs);\n            } catch (InvocationTargetException e) {\n                // Should not happen.\n            } catch (IllegalAccessException e) {\n                // Should not happen.\n            }\n        } else {\n            // Fall back on the old API.\n            setForeground(true);\n            notificationManager.notify(id, notification);\n        }\n    }\n\n    /**\n     * This is a wrapper around the new stopForeground method, using the older\n     * APIs if it is not available.\n     */\n    public void stopForegroundCompat(int id)\n    {\n        foreground = false;\n\n        // If we have the new stopForeground API, then use it.\n        if (mStopForeground != null) {\n            mStopForegroundArgs[0] = Boolean.TRUE;\n            try {\n                mStopForeground.invoke(this, mStopForegroundArgs);\n            } catch (InvocationTargetException e) {\n                // Should not happen.\n            } catch (IllegalAccessException e) {\n                // Should not happen.\n            }\n        } else {\n            // Fall back on the old API.  Note to cancel BEFORE changing the\n            // foreground state, since we could be killed at that point.\n            notificationManager.cancel(id);\n            setForeground(false);\n        }\n    }\n\n    /**\n     * Connect to the given server\n     */\n    public void connect(final Server server)\n    {\n        new Thread() {\n            @Override\n            public void run() {\n                try {\n                    IRCConnection connection = getConnection(server.getId());\n\n                    connection.setNickname(server.getIdentity().getNickname());\n                    connection.setAliases(server.getIdentity().getAliases());\n                    connection.setIdent(server.getIdentity().getIdent());\n                    connection.setRealName(server.getIdentity().getRealName());\n                    connection.setUseSSL(server.useSSL());\n\n                    if (server.getCharset() != null) {\n                        connection.setEncoding(server.getCharset());\n                    }\n\n                    if (server.getPassword() != \"\") {\n                        connection.connect(server.getHost(), server.getPort(), server.getPassword());\n                    } else {\n                        connection.connect(server.getHost(), server.getPort());\n                    }\n                }\n                catch (Exception e) {\n                    server.setStatus(Status.DISCONNECTED);\n\n                    Intent sIntent = Broadcast.createServerIntent(Broadcast.SERVER_UPDATE, server.getId());\n                    sendBroadcast(sIntent);\n\n                    IRCConnection connection = getConnection(server.getId());\n\n                    Message message;\n\n                    if (e instanceof NickAlreadyInUseException) {\n                        message = new Message(getString(R.string.nickname_in_use, connection.getNick()));\n                    } else if (e instanceof IrcException) {\n                        message = new Message(getString(R.string.irc_login_error, server.getHost(), server.getPort()));\n                    } else {\n                        message = new Message(getString(R.string.could_not_connect, server.getHost(), server.getPort()));\n                    }\n\n                    message.setColor(Message.COLOR_RED);\n                    message.setIcon(R.drawable.error);\n                    server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n                    Intent cIntent = Broadcast.createConversationIntent(\n                        Broadcast.CONVERSATION_MESSAGE,\n                        server.getId(),\n                        ServerInfo.DEFAULT_NAME\n                    );\n                    sendBroadcast(cIntent);\n                }\n            }\n        }.start();\n    }\n\n    /**\n     * Get connection for given server\n     * \n     * @param serverId\n     * @return\n     */\n    public synchronized IRCConnection getConnection(int serverId)\n    {\n        IRCConnection connection = connections.get(serverId);\n\n        if (connection == null) {\n            connection = new IRCConnection(this, serverId);\n            connections.put(serverId, connection);\n        }\n\n        return connection;\n    }\n\n    /**\n     * Does the service keep a connection object for this server?\n     * \n     * @return true if there's a connection object, false otherwise\n     */\n    public boolean hasConnection(int serverId)\n    {\n        return connections.containsKey(serverId);\n    }\n\n    /**\n     * Check status of service\n     */\n    public void checkServiceStatus()\n    {\n        boolean shutDown = true;\n        ArrayList<Server> mServers = Yaaic.getInstance().getServersAsArrayList();\n        int mSize = mServers.size();\n        Server server;\n\n        for (int i = 0; i < mSize; i++) {\n            server = mServers.get(i);\n            if (server.isDisconnected()) {\n                connections.remove(server.getId());\n            } else {\n                shutDown = false;\n            }\n        }\n\n        if (shutDown) {\n            foreground = false;\n            stopForegroundCompat(R.string.app_name);\n            stopSelf();\n        }\n    }\n\n    /**\n     * On Destroy\n     */\n    @Override\n    public void onDestroy()\n    {\n        // Make sure our notification is gone.\n        if (foreground) {\n            stopForegroundCompat(R.string.app_name);\n        }\n    }\n\n    /**\n     * On Activity binding to this service\n     * \n     * @param intent\n     * @return\n     */\n    @Override\n    public IRCBinder onBind(Intent intent)\n    {\n        return binder;\n    }\n}\n","lineNo":206}
{"Smelly Sample":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2011 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage org.yaaic.irc;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Vector;\nimport java.util.regex.Pattern;\n\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.command.CommandParser;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Query;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.ServerInfo;\nimport org.yaaic.model.Status;\n\nimport android.content.Intent;\n\n/**\n * The class that actually handles the connection to an IRC server\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class IRCConnection extends PircBot\n{\n    private final IRCService service;\n    private final Server server;\n    private ArrayList<String> autojoinChannels;\n    private Pattern mNickMatch;\n\n    /**\n     * Create a new connection\n     * \n     * @param service\n     * @param serverId\n     */\n    public IRCConnection(IRCService service, int serverId)\n    {\n        this.server = Yaaic.getInstance().getServerById(serverId);\n        this.service = service;\n\n        // XXX: Should be configurable via settings\n        this.setAutoNickChange(true);\n\n        this.setFinger(\"http://www.youtube.com/watch?v=oHg5SJYRHA0\");\n        this.updateNickMatchPattern();\n    }\n\n    /**\n     * Set the nickname of the user\n     * \n     * @param nickname The nickname to use\n     */\n    public void setNickname(String nickname)\n    {\n        this.setName(nickname);\n        this.updateNickMatchPattern();\n    }\n\n    /**\n     * Set the real name of the user\n     * \n     * @param realname The realname to use\n     */\n    public void setRealName(String realname)\n    {\n        // XXX: Pircbot uses the version for \"real name\" and \"version\".\n        //      The real \"version\" value is provided by onVersion()\n        this.setVersion(realname);\n    }\n\n    /**\n     * Set channels to autojoin after connect\n     * \n     * @param channels\n     */\n    public void setAutojoinChannels(ArrayList<String> channels)\n    {\n        autojoinChannels = channels;\n    }\n\n    /**\n     * On version (CTCP version)\n     * \n     * This is a fix for pircbot as pircbot uses the version as \"real name\" and as \"version\"\n     */\n    @Override\n    protected void onVersion(String sourceNick, String sourceLogin,    String sourceHostname, String target)\n    {\n        this.sendRawLine(\n            \"NOTICE \" + sourceNick + \" :\\u0001VERSION \" +\n            \"Yaaic - Yet another Android IRC client - http://www.yaaic.org\" +\n            \"\\u0001\"\n        );\n    }\n\n    /**\n     * Set the ident of the user\n     * \n     * @param ident The ident to use\n     */\n    public void setIdent(String ident)\n    {\n        this.setLogin(ident);\n    }\n\n    /**\n     * On connect\n     */\n    @Override\n    public void onConnect()\n    {\n        server.setStatus(Status.CONNECTED);\n\n        service.sendBroadcast(\n            Broadcast.createServerIntent(Broadcast.SERVER_UPDATE, server.getId())\n        );\n\n        service.updateNotification(service.getString(R.string.notification_connected, server.getTitle()));\n\n        Message message = new Message(service.getString(R.string.message_connected, server.getTitle()));\n        message.setColor(Message.COLOR_GREEN);\n        server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            ServerInfo.DEFAULT_NAME\n        );\n\n        service.sendBroadcast(intent);\n    }\n\n\n    /**\n     * On register\n     */\n    @Override\n    public void onRegister()\n    {\n        // Call parent method to ensure \"register\" status is tracked\n        super.onRegister();\n\n        // execute commands\n        CommandParser parser = CommandParser.getInstance();\n\n        this.updateNickMatchPattern();\n        for (String command : server.getConnectCommands()) {\n            parser.parse(command, server, server.getConversation(ServerInfo.DEFAULT_NAME), service);\n        }\n\n        // TODO: Detect \"You are now identified for <nick>\" notices from NickServ and handle\n        //       auto joins in onNotice instead if the user has chosen to wait for NickServ\n        //       identification before auto joining channels.\n\n        // delay 1 sec before auto joining channels\n        try {\n            Thread.sleep(1000);\n        } catch(InterruptedException e) {\n            // do nothing\n        }\n\n        // join channels\n        if (autojoinChannels != null) {\n            for (String channel : autojoinChannels) {\n                // Add support for channel keys\n                joinChannel(channel);\n            }\n        } else {\n            for (String channel : server.getAutoJoinChannels()) {\n                joinChannel(channel);\n            }\n        }\n    }\n    /**\n     * On channel action\n     */\n    @Override\n    protected void onAction(String sender, String login, String hostname, String target, String action)\n    {\n        Message message = new Message(sender + \" \" + action);\n        message.setIcon(R.drawable.action);\n\n        if (isMentioned(action)) {\n            // highlight\n            message.setColor(Message.COLOR_RED);\n            service.updateNotification(\n                target + \": \" + sender + \" \" + action,\n                service.getSettings().isVibrateHighlightEnabled(),\n                service.getSettings().isSoundHighlightEnabled()\n            );\n\n            server.getConversation(target).setStatus(Conversation.STATUS_HIGHLIGHT);\n        }\n\n        if (target.equals(this.getNick())) {\n            // We are the target - this is an action in a query\n            Conversation conversation = server.getConversation(sender);\n            if (conversation == null) {\n                // Open a query if there's none yet\n                conversation = new Query(sender);\n                server.addConversation(conversation);\n                conversation.addMessage(message);\n\n                Intent intent = Broadcast.createConversationIntent(\n                    Broadcast.CONVERSATION_NEW,\n                    server.getId(),\n                    sender\n                );\n                service.sendBroadcast(intent);\n            } else {\n                Intent intent = Broadcast.createConversationIntent(\n                    Broadcast.CONVERSATION_MESSAGE,\n                    server.getId(),\n                    sender\n                );\n                service.sendBroadcast(intent);\n            }\n        } else {\n            // A action in a channel\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Channel Info\n     */\n    @Override\n    protected void onChannelInfo(String channel, int userCount, String topic)\n    {\n    }\n\n    /**\n     * On Deop\n     */\n    @Override\n    protected void onDeop(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n    {\n        Message message = new Message(service.getString(R.string.message_deop, sourceNick, recipient));\n        message.setIcon(R.drawable.op);\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On DeVoice\n     */\n    @Override\n    protected void onDeVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n    {\n        Message message = new Message(service.getString(R.string.message_devoice, sourceNick, recipient));\n        message.setColor(Message.COLOR_BLUE);\n        message.setIcon(R.drawable.voice);\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On Invite\n     */\n    @Override\n    protected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String target)\n    {\n        if (targetNick.equals(this.getNick())) {\n            // We are invited\n            Message message = new Message(service.getString(R.string.message_invite_you, sourceNick, target));\n            server.getConversation(server.getSelectedConversation()).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                server.getSelectedConversation()\n            );\n            service.sendBroadcast(intent);\n        } else {\n            // Someone is invited\n            Message message = new Message(service.getString(R.string.message_invite_someone, sourceNick, targetNick, target));\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Join\n     */\n    @Override\n    protected void onJoin(String target, String sender, String login, String hostname)\n    {\n        if (sender.equalsIgnoreCase(getNick())) {\n            // We joined a new channel\n            server.addConversation(new Channel(target));\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_NEW,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        } else if (service.getSettings().showJoinPartAndQuit()) {\n            Message message = new Message(\n                service.getString(R.string.message_join, sender),\n                Message.TYPE_MISC\n            );\n\n            message.setIcon(R.drawable.join);\n            message.setColor(Message.COLOR_GREEN);\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Kick\n     */\n    @Override\n    protected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n    {\n        if (recipientNick.equals(getNick())) {\n            // We are kicked\n            server.removeConversation(target);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_REMOVE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        } else {\n            Message message = new Message(service.getString(R.string.message_kick, kickerNick, recipientNick));\n            message.setColor(Message.COLOR_GREEN);\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Message\n     */\n    @Override\n    protected void onMessage(String target, String sender, String login, String hostname, String text)\n    {\n        Message message = new Message(text, sender);\n\n        if (isMentioned(text)) {\n            // highlight\n            message.setColor(Message.COLOR_RED);\n            service.updateNotification(\n                target + \": <\" + sender + \"> \" + text,\n                service.getSettings().isVibrateHighlightEnabled(),\n                service.getSettings().isSoundHighlightEnabled()\n            );\n\n            server.getConversation(target).setStatus(Conversation.STATUS_HIGHLIGHT);\n        }\n\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On Mode\n     */\n    @Override\n    protected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n    {\n        // Disabled as it doubles events (e.g. onOp and onMode will be called)\n\n        /*\n        Message message = new Message(sourceNick + \" sets mode \" + mode);\n        server.getChannel(target).addMessage(message);\n\n        Intent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n        intent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n        intent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n        service.sendBroadcast(intent);\n         */\n    }\n\n    /**\n     * On Nick Change\n     */\n    @Override\n    protected void onNickChange(String oldNick, String login, String hostname, String newNick)\n    {\n        if (getNick().equalsIgnoreCase(newNick)) {\n            this.updateNickMatchPattern();\n\n            // Send message about own change to server info window\n            Message message = new Message(service.getString(R.string.message_self_rename, newNick));\n            message.setColor(Message.COLOR_GREEN);\n            server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                ServerInfo.DEFAULT_NAME\n            );\n\n            service.sendBroadcast(intent);\n        }\n\n        Vector<String> channels = getChannelsByNickname(newNick);\n\n        for (String target : channels) {\n            Message message = new Message(service.getString(R.string.message_rename, oldNick, newNick));\n            message.setColor(Message.COLOR_GREEN);\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Notice\n     */\n    @Override\n    protected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n    {\n        // Post notice to currently selected conversation\n        Conversation conversation;\n\n        if (service.getSettings().showNoticeInServerWindow()) {\n            conversation = server.getConversation(ServerInfo.DEFAULT_NAME);\n        } else {\n            conversation = server.getConversation(server.getSelectedConversation());\n\n            if (conversation == null) {\n                // Fallback: Use ServerInfo view\n                conversation = server.getConversation(ServerInfo.DEFAULT_NAME);\n            }\n        }\n\n        Message message = new Message(\"-\" + sourceNick + \"- \" + notice);\n        message.setIcon(R.drawable.info);\n        conversation.addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            conversation.getName()\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On Op\n     */\n    @Override\n    protected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n    {\n        Message message = new Message(service.getString(R.string.message_op, sourceNick, recipient));\n        message.setColor(Message.COLOR_BLUE);\n        message.setIcon(R.drawable.op);\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On Part\n     */\n    @Override\n    protected void onPart(String target, String sender, String login, String hostname)\n    {\n        if (sender.equals(getNick())) {\n            // We parted a channel\n            server.removeConversation(target);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_REMOVE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        } else if (service.getSettings().showJoinPartAndQuit()) {\n            Message message = new Message(\n                service.getString(R.string.message_part, sender),\n                Message.TYPE_MISC\n            );\n\n            message.setColor(Message.COLOR_GREEN);\n            message.setIcon(R.drawable.part);\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Private Message\n     */\n    @Override\n    protected void onPrivateMessage(String sender, String login, String hostname, String text)\n    {\n        Message message = new Message(\"<\" + sender + \"> \" + text);\n\n        if (isMentioned(text)) {\n            message.setColor(Message.COLOR_RED);\n            service.updateNotification(\n                \"<\" + sender + \"> \" + text,\n                service.getSettings().isVibrateHighlightEnabled(),\n                service.getSettings().isSoundHighlightEnabled()\n            );\n\n            server.getConversation(sender).setStatus(Conversation.STATUS_HIGHLIGHT);\n        }\n\n        Conversation conversation = server.getConversation(sender);\n\n        if (conversation == null) {\n            // Open a query if there's none yet\n            conversation = new Query(sender);\n            conversation.addMessage(message);\n            server.addConversation(conversation);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_NEW,\n                server.getId(),\n                sender\n            );\n            service.sendBroadcast(intent);\n        } else {\n            conversation.addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                sender\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Quit\n     */\n    @Override\n    protected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n    {\n        if (sourceNick.equals(this.getNick())) {\n            return;\n        }\n\n        if (service.getSettings().showJoinPartAndQuit()) {\n            Vector<String> channels = getChannelsByNickname(sourceNick);\n\n            for (String target : channels) {\n                Message message = new Message(\n                    service.getString(R.string.message_quit, sourceNick, reason),\n                    Message.TYPE_MISC\n                );\n\n                message.setColor(Message.COLOR_GREEN);\n                message.setIcon(R.drawable.quit);\n                server.getConversation(target).addMessage(message);\n\n                Intent intent = Broadcast.createConversationIntent(\n                    Broadcast.CONVERSATION_MESSAGE,\n                    server.getId(),\n                    target\n                );\n                service.sendBroadcast(intent);\n            }\n\n            // Look if there's a query to update\n            Conversation conversation = server.getConversation(sourceNick);\n\n            if (conversation != null) {\n                Message message = new Message(\n                    service.getString(R.string.message_quit, sourceNick, reason),\n                    Message.TYPE_MISC\n                );\n\n                message.setColor(Message.COLOR_GREEN);\n                message.setIcon(R.drawable.quit);\n                conversation.addMessage(message);\n\n                Intent intent = Broadcast.createConversationIntent(\n                    Broadcast.CONVERSATION_MESSAGE,\n                    server.getId(),\n                    conversation.getName()\n                );\n                service.sendBroadcast(intent);\n            }\n        }\n    }\n\n    /**\n     * On Topic\n     */\n    @Override\n    public void onTopic(String target, String topic, String setBy, long date, boolean changed)\n    {\n        if (changed) {\n            Message message = new Message(service.getString(R.string.message_topic_set, setBy, topic));\n            message.setColor(Message.COLOR_YELLOW);\n            server.getConversation(target).addMessage(message);\n        } else {\n            Message message = new Message(service.getString(R.string.message_topic, topic));\n            message.setColor(Message.COLOR_YELLOW);\n            server.getConversation(target).addMessage(message);\n        }\n\n        // remember channel's topic\n        ((Channel) server.getConversation(target)).setTopic(topic);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On User List\n     */\n    @Override\n    protected void onUserList(String channel, User[] users)\n    {\n        // XXX: Store user list somewhere and keep it updated or just broadcast some event?\n    }\n\n    /**\n     * On Voice\n     */\n    @Override\n    protected void onVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n    {\n        Message message = new Message(service.getString(R.string.message_voice, sourceNick, recipient));\n        message.setIcon(R.drawable.voice);\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On remove channel key\n     */\n    @Override\n    protected void onRemoveChannelKey(String target, String sourceNick, String sourceLogin, String sourceHostname, String key)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_channel_key, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set channel key\n     */\n    @Override\n    protected void onSetChannelKey(String target, String sourceNick, String sourceLogin, String sourceHostname, String key)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_key, sourceNick, key));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set secret\n     */\n    @Override\n    protected void onSetSecret(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_secret, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove secret\n     */\n    @Override\n    protected void onRemoveSecret(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_public, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set channel limit\n     */\n    @Override\n    protected void onSetChannelLimit(String target, String sourceNick, String sourceLogin, String sourceHostname, int limit)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_limit, sourceNick, limit));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove channel limit\n     */\n    @Override\n    protected void onRemoveChannelLimit(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_channel_limit, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set channel ban\n     */\n    @Override\n    protected void onSetChannelBan(String target, String sourceNick, String sourceLogin, String sourceHostname, String hostmask)\n    {\n        Message message = new Message(service.getString(R.string.message_set_ban, sourceNick, hostmask));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove channel ban\n     */\n    @Override\n    protected void onRemoveChannelBan(String target, String sourceNick, String sourceLogin, String sourceHostname, String hostmask)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_ban, sourceNick, hostmask));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set topic protection\n     */\n    @Override\n    protected void onSetTopicProtection(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_topic_protection, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove topic protection\n     */\n    @Override\n    protected void onRemoveTopicProtection(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_topic_protection, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set no external messages\n     */\n    @Override\n    protected void onSetNoExternalMessages(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_disable_external, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove no external messages\n     */\n    @Override\n    protected void onRemoveNoExternalMessages(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_enable_external, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set invite only\n     */\n    @Override\n    protected void onSetInviteOnly(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_invite_only, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove invite only\n     */\n    @Override\n    protected void onRemoveInviteOnly(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_invite_only, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set moderated\n     */\n    @Override\n    protected void onSetModerated(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_moderated, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove moderated\n     */\n    @Override\n    protected void onRemoveModerated(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_moderated, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set private\n     */\n    @Override\n    protected void onSetPrivate(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_private, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove private\n     */\n    @Override\n    protected void onRemovePrivate(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_public, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On unknown\n     */\n    @Override\n    protected void onUnknown(String line)\n    {\n        Message message = new Message(line);\n        message.setIcon(R.drawable.action);\n        message.setColor(Message.COLOR_GREY);\n        server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            ServerInfo.DEFAULT_NAME\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On server response\n     */\n    @Override\n    protected void onServerResponse(int code, String response)\n    {\n        if (code == 4) {\n            // User has registered with the server\n            onRegister();\n            return;\n        }\n        if (code == 372 || code == 375 || code == 376) {\n            // Skip MOTD\n            return;\n        }\n\n        if (code >= 200 && code < 300) {\n            // Skip 2XX responses\n            return;\n        }\n\n        if (code == 353 || code == 366 || code == 332 || code == 333) {\n            return;\n        }\n\n        if (code < 10) {\n            // Skip server info\n            return;\n        }\n\n        // Currently disabled... to much text\n        Message message = new Message(response);\n        message.setColor(Message.COLOR_GREY);\n        server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            ServerInfo.DEFAULT_NAME\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On disconnect\n     */\n    @Override\n    public void onDisconnect()\n    {\n        // Call parent method to ensure \"register\" status is tracked\n        super.onDisconnect();\n\n        if (service.getSettings().isReconnectEnabled() && server.getStatus() != Status.DISCONNECTED) {\n            setAutojoinChannels(server.getCurrentChannelNames());\n\n            server.clearConversations();\n            server.setStatus(Status.CONNECTING);\n            service.connect(server);\n        } else {\n            server.setStatus(Status.DISCONNECTED);\n        }\n\n        service.updateNotification(service.getString(R.string.notification_disconnected, server.getTitle()));\n\n        Intent sIntent = Broadcast.createServerIntent(Broadcast.SERVER_UPDATE, server.getId());\n        service.sendBroadcast(sIntent);\n\n        Collection<Conversation> conversations = server.getConversations();\n\n        for (Conversation conversation : conversations) {\n            Message message = new Message(service.getString(R.string.message_disconnected));\n            message.setIcon(R.drawable.error);\n            message.setColor(Message.COLOR_RED);\n            server.getConversation(conversation.getName()).addMessage(message);\n\n            Intent cIntent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                conversation.getName()\n            );\n            service.sendBroadcast(cIntent);\n        }\n    }\n\n    /**\n     * Get all channels where the user with the given nickname is online\n     * \n     * @param nickname\n     * @return Array of channel names\n     */\n    private Vector<String> getChannelsByNickname(String nickname)\n    {\n        Vector<String> channels = new Vector<String>();\n        String[] channelArray = getChannels();\n\n        for (String channel : channelArray) {\n            User[] userArray = getUsers(channel);\n            for (User user : userArray) {\n                if (user.getNick().equals(nickname)) {\n                    channels.add(channel);\n                    break;\n                }\n            }\n        }\n\n        return channels;\n    }\n\n    /**\n     * Get list of users in a channel as array of strings\n     * \n     * @param channel Name of the channel\n     */\n    public String[] getUsersAsStringArray(String channel)\n    {\n        User[] userArray = getUsers(channel);\n        int mLength = userArray.length;\n        String[] users = new String[mLength];\n\n        for (int i = 0; i < mLength; i++) {\n            users[i] = userArray[i].getPrefix() + userArray[i].getNick();\n        }\n\n        return users;\n    }\n\n    /**\n     * Get a user by channel and nickname\n     * \n     * @param channel The channel the user is in\n     * @param nickname The nickname of the user (with or without prefix)\n     * @return the User object or null if user was not found\n     */\n    public User getUser(String channel, String nickname)\n    {\n        User[] users = getUsers(channel);\n        int mLength = users.length;\n\n        for (int i = 0; i < mLength; i++) {\n            if (nickname.equals(users[i].getNick())) {\n                return users[i];\n            }\n            if (nickname.equals(users[i].getPrefix() + users[i].getNick())) {\n                return users[i];\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Quits from the IRC server with default reason.\n     */\n    @Override\n    public void quitServer()\n    {\n        new Thread() {\n            @Override\n            public void run() {\n                quitServer(service.getSettings().getQuitMessage());\n            }\n        }.start();\n    }\n\n    /**\n     * Check whether the nickname has been mentioned.\n     * \n     * @param text The text to check for the nickname\n     * @return true if nickname was found, otherwise false\n     */\n    public boolean isMentioned(String text)\n    {\n        return mNickMatch.matcher(text).find();\n    }\n\n    /**\n     * Update the nick matching pattern, should be called when the nickname changes.\n     */\n    private void updateNickMatchPattern()\n    {\n        mNickMatch = Pattern.compile(\"(?:^|[\\\\s?!'�:;,.])\"+Pattern.quote(getNick())+\"(?:[\\\\s?!'�:;,.]|$)\", Pattern.CASE_INSENSITIVE);\n    }\n}\n","Method after Refactoring":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2011 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage org.yaaic.irc;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Vector;\nimport java.util.regex.Pattern;\n\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.command.CommandParser;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Query;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.ServerInfo;\nimport org.yaaic.model.Status;\n\nimport android.content.Intent;\n\n/**\n * The class that actually handles the connection to an IRC server\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class IRCConnection extends PircBot\n{\n    private final IRCService service;\n    private final Server server;\n    private ArrayList<String> autojoinChannels;\n    private Pattern mNickMatch;\n\n    /**\n     * Create a new connection\n     * \n     * @param service\n     * @param serverId\n     */\n    public IRCConnection(IRCService service, int serverId)\n    {\n        this.server = Yaaic.getInstance().getServerById(serverId);\n        this.service = service;\n\n        // XXX: Should be configurable via settings\n        this.setAutoNickChange(true);\n\n        this.setFinger(\"http://www.youtube.com/watch?v=oHg5SJYRHA0\");\n        this.updateNickMatchPattern();\n    }\n\n    /**\n     * Set the nickname of the user\n     * \n     * @param nickname The nickname to use\n     */\n    public void setNickname(String nickname)\n    {\n        this.setName(nickname);\n        this.updateNickMatchPattern();\n    }\n\n    /**\n     * Set the real name of the user\n     * \n     * @param realname The realname to use\n     */\n    public void setRealName(String realname)\n    {\n        // XXX: Pircbot uses the version for \"real name\" and \"version\".\n        //      The real \"version\" value is provided by onVersion()\n        this.setVersion(realname);\n    }\n\n    /**\n     * Set channels to autojoin after connect\n     * \n     * @param channels\n     */\n    public void setAutojoinChannels(ArrayList<String> channels)\n    {\n        autojoinChannels = channels;\n    }\n\n    /**\n     * On version (CTCP version)\n     * \n     * This is a fix for pircbot as pircbot uses the version as \"real name\" and as \"version\"\n     */\n    @Override\n    protected void onVersion(String sourceNick, String sourceLogin,    String sourceHostname, String target)\n    {\n        this.sendRawLine(\n            \"NOTICE \" + sourceNick + \" :\\u0001VERSION \" +\n            \"Yaaic - Yet another Android IRC client - http://www.yaaic.org\" +\n            \"\\u0001\"\n        );\n    }\n\n    /**\n     * Set the ident of the user\n     * \n     * @param ident The ident to use\n     */\n    public void setIdent(String ident)\n    {\n        this.setLogin(ident);\n    }\n\n    /**\n     * On connect\n     */\n    @Override\n    public void onConnect()\n    {\n        server.setStatus(Status.CONNECTED);\n\n        service.sendBroadcast(\n            Broadcast.createServerIntent(Broadcast.SERVER_UPDATE, server.getId())\n        );\n\n        service.updateNotification(service.getString(R.string.notification_connected, server.getTitle()));\n\n        Message message = new Message(service.getString(R.string.message_connected, server.getTitle()));\n        message.setColor(Message.COLOR_GREEN);\n        server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            ServerInfo.DEFAULT_NAME\n        );\n\n        service.sendBroadcast(intent);\n    }\n\n\n    /**\n     * On register\n     */\n    @Override\n    public void onRegister()\n    {\n        // Call parent method to ensure \"register\" status is tracked\n        super.onRegister();\n\n        // execute commands\n        CommandParser parser = CommandParser.getInstance();\n\n        this.updateNickMatchPattern();\n        for (String command : server.getConnectCommands()) {\n            parser.parse(command, server, server.getConversation(ServerInfo.DEFAULT_NAME), service);\n        }\n\n        // TODO: Detect \"You are now identified for <nick>\" notices from NickServ and handle\n        //       auto joins in onNotice instead if the user has chosen to wait for NickServ\n        //       identification before auto joining channels.\n\n        // delay 1 sec before auto joining channels\n        try {\n            Thread.sleep(1000);\n        } catch(InterruptedException e) {\n            // do nothing\n        }\n\n        // join channels\n        if (autojoinChannels != null) {\n            for (String channel : autojoinChannels) {\n                // Add support for channel keys\n                joinChannel(channel);\n            }\n        } else {\n            for (String channel : server.getAutoJoinChannels()) {\n                joinChannel(channel);\n            }\n        }\n    }\n    /**\n     * On channel action\n     */\n    @Override\n    protected void onAction(String sender, String login, String hostname, String target, String action)\n    {\n        Conversation conversation;\n\n        Message message = new Message(sender + \" \" + action);\n        message.setIcon(R.drawable.action);\n\n        if (target.equals(this.getNick())) {\n            // We are the target - this is an action in a query\n            conversation = server.getConversation(sender);\n            if (conversation == null) {\n                // Open a query if there's none yet\n                conversation = new Query(sender);\n                server.addConversation(conversation);\n                conversation.addMessage(message);\n\n                Intent intent = Broadcast.createConversationIntent(\n                    Broadcast.CONVERSATION_NEW,\n                    server.getId(),\n                    sender\n                );\n                service.sendBroadcast(intent);\n            } else {\n                Intent intent = Broadcast.createConversationIntent(\n                    Broadcast.CONVERSATION_MESSAGE,\n                    server.getId(),\n                    sender\n                );\n                service.sendBroadcast(intent);\n            }\n        } else {\n            // A action in a channel\n            conversation = server.getConversation(target);\n            conversation.addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n\n        if (isMentioned(action)) {\n            // highlight\n            message.setColor(Message.COLOR_RED);\n            service.updateNotification(\n                target + \": \" + sender + \" \" + action,\n                service.getSettings().isVibrateHighlightEnabled(),\n                service.getSettings().isSoundHighlightEnabled()\n            );\n\n            conversation.setStatus(Conversation.STATUS_HIGHLIGHT);\n        }\n    }\n\n    /**\n     * On Channel Info\n     */\n    @Override\n    protected void onChannelInfo(String channel, int userCount, String topic)\n    {\n    }\n\n    /**\n     * On Deop\n     */\n    @Override\n    protected void onDeop(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n    {\n        Message message = new Message(service.getString(R.string.message_deop, sourceNick, recipient));\n        message.setIcon(R.drawable.op);\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On DeVoice\n     */\n    @Override\n    protected void onDeVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n    {\n        Message message = new Message(service.getString(R.string.message_devoice, sourceNick, recipient));\n        message.setColor(Message.COLOR_BLUE);\n        message.setIcon(R.drawable.voice);\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On Invite\n     */\n    @Override\n    protected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String target)\n    {\n        if (targetNick.equals(this.getNick())) {\n            // We are invited\n            Message message = new Message(service.getString(R.string.message_invite_you, sourceNick, target));\n            server.getConversation(server.getSelectedConversation()).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                server.getSelectedConversation()\n            );\n            service.sendBroadcast(intent);\n        } else {\n            // Someone is invited\n            Message message = new Message(service.getString(R.string.message_invite_someone, sourceNick, targetNick, target));\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Join\n     */\n    @Override\n    protected void onJoin(String target, String sender, String login, String hostname)\n    {\n        if (sender.equalsIgnoreCase(getNick())) {\n            // We joined a new channel\n            server.addConversation(new Channel(target));\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_NEW,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        } else if (service.getSettings().showJoinPartAndQuit()) {\n            Message message = new Message(\n                service.getString(R.string.message_join, sender),\n                Message.TYPE_MISC\n            );\n\n            message.setIcon(R.drawable.join);\n            message.setColor(Message.COLOR_GREEN);\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Kick\n     */\n    @Override\n    protected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n    {\n        if (recipientNick.equals(getNick())) {\n            // We are kicked\n            server.removeConversation(target);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_REMOVE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        } else {\n            Message message = new Message(service.getString(R.string.message_kick, kickerNick, recipientNick));\n            message.setColor(Message.COLOR_GREEN);\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Message\n     */\n    @Override\n    protected void onMessage(String target, String sender, String login, String hostname, String text)\n    {\n        Message message = new Message(text, sender);\n\n        if (isMentioned(text)) {\n            // highlight\n            message.setColor(Message.COLOR_RED);\n            service.updateNotification(\n                target + \": <\" + sender + \"> \" + text,\n                service.getSettings().isVibrateHighlightEnabled(),\n                service.getSettings().isSoundHighlightEnabled()\n            );\n\n            server.getConversation(target).setStatus(Conversation.STATUS_HIGHLIGHT);\n        }\n\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On Mode\n     */\n    @Override\n    protected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n    {\n        // Disabled as it doubles events (e.g. onOp and onMode will be called)\n\n        /*\n        Message message = new Message(sourceNick + \" sets mode \" + mode);\n        server.getChannel(target).addMessage(message);\n\n        Intent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n        intent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n        intent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n        service.sendBroadcast(intent);\n         */\n    }\n\n    /**\n     * On Nick Change\n     */\n    @Override\n    protected void onNickChange(String oldNick, String login, String hostname, String newNick)\n    {\n        if (getNick().equalsIgnoreCase(newNick)) {\n            this.updateNickMatchPattern();\n\n            // Send message about own change to server info window\n            Message message = new Message(service.getString(R.string.message_self_rename, newNick));\n            message.setColor(Message.COLOR_GREEN);\n            server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                ServerInfo.DEFAULT_NAME\n            );\n\n            service.sendBroadcast(intent);\n        }\n\n        Vector<String> channels = getChannelsByNickname(newNick);\n\n        for (String target : channels) {\n            Message message = new Message(service.getString(R.string.message_rename, oldNick, newNick));\n            message.setColor(Message.COLOR_GREEN);\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Notice\n     */\n    @Override\n    protected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n    {\n        // Post notice to currently selected conversation\n        Conversation conversation;\n\n        if (service.getSettings().showNoticeInServerWindow()) {\n            conversation = server.getConversation(ServerInfo.DEFAULT_NAME);\n        } else {\n            conversation = server.getConversation(server.getSelectedConversation());\n\n            if (conversation == null) {\n                // Fallback: Use ServerInfo view\n                conversation = server.getConversation(ServerInfo.DEFAULT_NAME);\n            }\n        }\n\n        Message message = new Message(\"-\" + sourceNick + \"- \" + notice);\n        message.setIcon(R.drawable.info);\n        conversation.addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            conversation.getName()\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On Op\n     */\n    @Override\n    protected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n    {\n        Message message = new Message(service.getString(R.string.message_op, sourceNick, recipient));\n        message.setColor(Message.COLOR_BLUE);\n        message.setIcon(R.drawable.op);\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On Part\n     */\n    @Override\n    protected void onPart(String target, String sender, String login, String hostname)\n    {\n        if (sender.equals(getNick())) {\n            // We parted a channel\n            server.removeConversation(target);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_REMOVE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        } else if (service.getSettings().showJoinPartAndQuit()) {\n            Message message = new Message(\n                service.getString(R.string.message_part, sender),\n                Message.TYPE_MISC\n            );\n\n            message.setColor(Message.COLOR_GREEN);\n            message.setIcon(R.drawable.part);\n            server.getConversation(target).addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                target\n            );\n            service.sendBroadcast(intent);\n        }\n    }\n\n    /**\n     * On Private Message\n     */\n    @Override\n    protected void onPrivateMessage(String sender, String login, String hostname, String text)\n    {\n        Message message = new Message(\"<\" + sender + \"> \" + text);\n\n        Conversation conversation = server.getConversation(sender);\n\n        if (conversation == null) {\n            // Open a query if there's none yet\n            conversation = new Query(sender);\n            conversation.addMessage(message);\n            server.addConversation(conversation);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_NEW,\n                server.getId(),\n                sender\n            );\n            service.sendBroadcast(intent);\n        } else {\n            conversation.addMessage(message);\n\n            Intent intent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                sender\n            );\n            service.sendBroadcast(intent);\n        }\n\n        if (isMentioned(text)) {\n            message.setColor(Message.COLOR_RED);\n            service.updateNotification(\n                \"<\" + sender + \"> \" + text,\n                service.getSettings().isVibrateHighlightEnabled(),\n                service.getSettings().isSoundHighlightEnabled()\n            );\n\n            conversation.setStatus(Conversation.STATUS_HIGHLIGHT);\n        }\n    }\n\n    /**\n     * On Quit\n     */\n    @Override\n    protected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n    {\n        if (sourceNick.equals(this.getNick())) {\n            return;\n        }\n\n        if (service.getSettings().showJoinPartAndQuit()) {\n            Vector<String> channels = getChannelsByNickname(sourceNick);\n\n            for (String target : channels) {\n                Message message = new Message(\n                    service.getString(R.string.message_quit, sourceNick, reason),\n                    Message.TYPE_MISC\n                );\n\n                message.setColor(Message.COLOR_GREEN);\n                message.setIcon(R.drawable.quit);\n                server.getConversation(target).addMessage(message);\n\n                Intent intent = Broadcast.createConversationIntent(\n                    Broadcast.CONVERSATION_MESSAGE,\n                    server.getId(),\n                    target\n                );\n                service.sendBroadcast(intent);\n            }\n\n            // Look if there's a query to update\n            Conversation conversation = server.getConversation(sourceNick);\n\n            if (conversation != null) {\n                Message message = new Message(\n                    service.getString(R.string.message_quit, sourceNick, reason),\n                    Message.TYPE_MISC\n                );\n\n                message.setColor(Message.COLOR_GREEN);\n                message.setIcon(R.drawable.quit);\n                conversation.addMessage(message);\n\n                Intent intent = Broadcast.createConversationIntent(\n                    Broadcast.CONVERSATION_MESSAGE,\n                    server.getId(),\n                    conversation.getName()\n                );\n                service.sendBroadcast(intent);\n            }\n        }\n    }\n\n    /**\n     * On Topic\n     */\n    @Override\n    public void onTopic(String target, String topic, String setBy, long date, boolean changed)\n    {\n        if (changed) {\n            Message message = new Message(service.getString(R.string.message_topic_set, setBy, topic));\n            message.setColor(Message.COLOR_YELLOW);\n            server.getConversation(target).addMessage(message);\n        } else {\n            Message message = new Message(service.getString(R.string.message_topic, topic));\n            message.setColor(Message.COLOR_YELLOW);\n            server.getConversation(target).addMessage(message);\n        }\n\n        // remember channel's topic\n        ((Channel) server.getConversation(target)).setTopic(topic);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On User List\n     */\n    @Override\n    protected void onUserList(String channel, User[] users)\n    {\n        // XXX: Store user list somewhere and keep it updated or just broadcast some event?\n    }\n\n    /**\n     * On Voice\n     */\n    @Override\n    protected void onVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n    {\n        Message message = new Message(service.getString(R.string.message_voice, sourceNick, recipient));\n        message.setIcon(R.drawable.voice);\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            target\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On remove channel key\n     */\n    @Override\n    protected void onRemoveChannelKey(String target, String sourceNick, String sourceLogin, String sourceHostname, String key)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_channel_key, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set channel key\n     */\n    @Override\n    protected void onSetChannelKey(String target, String sourceNick, String sourceLogin, String sourceHostname, String key)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_key, sourceNick, key));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set secret\n     */\n    @Override\n    protected void onSetSecret(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_secret, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove secret\n     */\n    @Override\n    protected void onRemoveSecret(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_public, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set channel limit\n     */\n    @Override\n    protected void onSetChannelLimit(String target, String sourceNick, String sourceLogin, String sourceHostname, int limit)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_limit, sourceNick, limit));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove channel limit\n     */\n    @Override\n    protected void onRemoveChannelLimit(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_channel_limit, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set channel ban\n     */\n    @Override\n    protected void onSetChannelBan(String target, String sourceNick, String sourceLogin, String sourceHostname, String hostmask)\n    {\n        Message message = new Message(service.getString(R.string.message_set_ban, sourceNick, hostmask));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove channel ban\n     */\n    @Override\n    protected void onRemoveChannelBan(String target, String sourceNick, String sourceLogin, String sourceHostname, String hostmask)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_ban, sourceNick, hostmask));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set topic protection\n     */\n    @Override\n    protected void onSetTopicProtection(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_topic_protection, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove topic protection\n     */\n    @Override\n    protected void onRemoveTopicProtection(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_topic_protection, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set no external messages\n     */\n    @Override\n    protected void onSetNoExternalMessages(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_disable_external, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove no external messages\n     */\n    @Override\n    protected void onRemoveNoExternalMessages(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_enable_external, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set invite only\n     */\n    @Override\n    protected void onSetInviteOnly(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_invite_only, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove invite only\n     */\n    @Override\n    protected void onRemoveInviteOnly(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_invite_only, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set moderated\n     */\n    @Override\n    protected void onSetModerated(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_moderated, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove moderated\n     */\n    @Override\n    protected void onRemoveModerated(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_remove_moderated, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On set private\n     */\n    @Override\n    protected void onSetPrivate(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_private, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On remove private\n     */\n    @Override\n    protected void onRemovePrivate(String target, String sourceNick, String sourceLogin, String sourceHostname)\n    {\n        Message message = new Message(service.getString(R.string.message_set_channel_public, sourceNick));\n        message.setColor(Message.COLOR_BLUE);\n        server.getConversation(target).addMessage(message);\n\n        service.sendBroadcast(\n            Broadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n        );\n    }\n\n    /**\n     * On unknown\n     */\n    @Override\n    protected void onUnknown(String line)\n    {\n        Message message = new Message(line);\n        message.setIcon(R.drawable.action);\n        message.setColor(Message.COLOR_GREY);\n        server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            ServerInfo.DEFAULT_NAME\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On server response\n     */\n    @Override\n    protected void onServerResponse(int code, String response)\n    {\n        if (code == 4) {\n            // User has registered with the server\n            onRegister();\n            return;\n        }\n        if (code == 372 || code == 375 || code == 376) {\n            // Skip MOTD\n            return;\n        }\n\n        if (code >= 200 && code < 300) {\n            // Skip 2XX responses\n            return;\n        }\n\n        if (code == 353 || code == 366 || code == 332 || code == 333) {\n            return;\n        }\n\n        if (code < 10) {\n            // Skip server info\n            return;\n        }\n\n        // Currently disabled... to much text\n        Message message = new Message(response);\n        message.setColor(Message.COLOR_GREY);\n        server.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\n        Intent intent = Broadcast.createConversationIntent(\n            Broadcast.CONVERSATION_MESSAGE,\n            server.getId(),\n            ServerInfo.DEFAULT_NAME\n        );\n        service.sendBroadcast(intent);\n    }\n\n    /**\n     * On disconnect\n     */\n    @Override\n    public void onDisconnect()\n    {\n        // Call parent method to ensure \"register\" status is tracked\n        super.onDisconnect();\n\n        if (service.getSettings().isReconnectEnabled() && server.getStatus() != Status.DISCONNECTED) {\n            setAutojoinChannels(server.getCurrentChannelNames());\n\n            server.clearConversations();\n            server.setStatus(Status.CONNECTING);\n            service.connect(server);\n        } else {\n            server.setStatus(Status.DISCONNECTED);\n        }\n\n        service.updateNotification(service.getString(R.string.notification_disconnected, server.getTitle()));\n\n        Intent sIntent = Broadcast.createServerIntent(Broadcast.SERVER_UPDATE, server.getId());\n        service.sendBroadcast(sIntent);\n\n        Collection<Conversation> conversations = server.getConversations();\n\n        for (Conversation conversation : conversations) {\n            Message message = new Message(service.getString(R.string.message_disconnected));\n            message.setIcon(R.drawable.error);\n            message.setColor(Message.COLOR_RED);\n            server.getConversation(conversation.getName()).addMessage(message);\n\n            Intent cIntent = Broadcast.createConversationIntent(\n                Broadcast.CONVERSATION_MESSAGE,\n                server.getId(),\n                conversation.getName()\n            );\n            service.sendBroadcast(cIntent);\n        }\n    }\n\n    /**\n     * Get all channels where the user with the given nickname is online\n     * \n     * @param nickname\n     * @return Array of channel names\n     */\n    private Vector<String> getChannelsByNickname(String nickname)\n    {\n        Vector<String> channels = new Vector<String>();\n        String[] channelArray = getChannels();\n\n        for (String channel : channelArray) {\n            User[] userArray = getUsers(channel);\n            for (User user : userArray) {\n                if (user.getNick().equals(nickname)) {\n                    channels.add(channel);\n                    break;\n                }\n            }\n        }\n\n        return channels;\n    }\n\n    /**\n     * Get list of users in a channel as array of strings\n     * \n     * @param channel Name of the channel\n     */\n    public String[] getUsersAsStringArray(String channel)\n    {\n        User[] userArray = getUsers(channel);\n        int mLength = userArray.length;\n        String[] users = new String[mLength];\n\n        for (int i = 0; i < mLength; i++) {\n            users[i] = userArray[i].getPrefix() + userArray[i].getNick();\n        }\n\n        return users;\n    }\n\n    /**\n     * Get a user by channel and nickname\n     * \n     * @param channel The channel the user is in\n     * @param nickname The nickname of the user (with or without prefix)\n     * @return the User object or null if user was not found\n     */\n    public User getUser(String channel, String nickname)\n    {\n        User[] users = getUsers(channel);\n        int mLength = users.length;\n\n        for (int i = 0; i < mLength; i++) {\n            if (nickname.equals(users[i].getNick())) {\n                return users[i];\n            }\n            if (nickname.equals(users[i].getPrefix() + users[i].getNick())) {\n                return users[i];\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Quits from the IRC server with default reason.\n     */\n    @Override\n    public void quitServer()\n    {\n        new Thread() {\n            @Override\n            public void run() {\n                quitServer(service.getSettings().getQuitMessage());\n            }\n        }.start();\n    }\n\n    /**\n     * Check whether the nickname has been mentioned.\n     * \n     * @param text The text to check for the nickname\n     * @return true if nickname was found, otherwise false\n     */\n    public boolean isMentioned(String text)\n    {\n        return mNickMatch.matcher(text).find();\n    }\n\n    /**\n     * Update the nick matching pattern, should be called when the nickname changes.\n     */\n    private void updateNickMatchPattern()\n    {\n        mNickMatch = Pattern.compile(\"(?:^|[\\\\s?!'�:;,.])\"+Pattern.quote(getNick())+\"(?:[\\\\s?!'�:;,.]|$)\", Pattern.CASE_INSENSITIVE);\n    }\n}\n","lineNo":206}
{"Smelly Sample":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2011 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage org.yaaic.model;\n\nimport java.util.Date;\n\nimport org.yaaic.utils.MircColors;\n\nimport android.content.Context;\nimport android.graphics.Typeface;\nimport android.graphics.drawable.Drawable;\nimport android.text.Spannable;\nimport android.text.SpannableString;\nimport android.text.TextUtils;\nimport android.text.style.ForegroundColorSpan;\nimport android.text.style.ImageSpan;\nimport android.widget.TextView;\n\n/**\n * A channel or server message\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class Message\n{\n    public static final int COLOR_GREEN   = 0xFF458509;\n    public static final int COLOR_RED     = 0xFFcc0000;\n    public static final int COLOR_BLUE    = 0xFF729fcf;\n    public static final int COLOR_YELLOW  = 0xFFbe9b01;\n    public static final int COLOR_GREY    = 0xFFaaaaaa;\n    public static final int COLOR_DEFAULT = 0xFFeeeeee;\n\n    /* normal message, this is the default */\n    public static final int TYPE_MESSAGE = 0;\n    /* join, part or quit */\n    public static final int TYPE_MISC    = 1;\n\n    /* Some are light versions because dark colors hardly readable on\n     * Yaaic's dark background */\n    public static final int[] colors = {\n        0xFFffffff, // White\n        0xFFffff00, // Yellow\n        0xFFff00ff, // Fuchsia\n        0xFFff0000, // Red\n        0xFFc0c0c0, // Silver\n        0xFF808080, // Gray\n        0xFF808000, // Olive\n        0xFFC040C0, // Light Purple\n        0xFFC04040, // Light Maroon\n        0xFF00ffff, // Agua\n        0xFF80ff80, // Light Lime\n        0xFF008080, // Teal\n        0xFF008000, // Green\n        0xFF8484FF, // Light Blue\n        0xFF6060D0, // Light Navy\n        0xFF000000, // Black\n    };\n\n    public static final int NO_ICON  = -1;\n    public static final int NO_TYPE  = -1;\n    public static final int NO_COLOR = -1;\n\n    private final String text;\n    private final String sender;\n    private SpannableString canvas;\n    private long timestamp;\n\n    private int color = NO_COLOR;\n    private int type  = NO_ICON;\n    private int icon  = NO_TYPE;\n\n    /**\n     * Create a new message without an icon defaulting to TYPE_MESSAGE\n     * \n     * @param text\n     */\n    public Message(String text)\n    {\n        this(text, null, TYPE_MESSAGE);\n    }\n\n    /**\n     * Create a new message without an icon with a specific type\n     * \n     * @param text\n     * @param type Message type\n     */\n    public Message(String text, int type)\n    {\n        this(text, null, type);\n    }\n\n    /**\n     * Create a new message sent by a user, without an icon,\n     * defaulting to TYPE_MESSAGE\n     * \n     * @param text\n     * @param sender\n     */\n    public Message(String text, String sender)\n    {\n        this(text, sender, TYPE_MESSAGE);\n    }\n\n    /**\n     * Create a new message sent by a user without an icon\n     *\n     * @param text\n     * @param sender\n     * @param type Message type\n     */\n    public Message(String text, String sender, int type)\n    {\n        this.text = text;\n        this.sender = sender;\n        this.timestamp = new Date().getTime();\n        this.type = type;\n    }\n\n    /**\n     * Set the message's icon\n     */\n    public void setIcon(int icon)\n    {\n        this.icon = icon;\n    }\n\n    /**\n     * Get the message's icon\n     * \n     * @return\n     */\n    public int getIcon()\n    {\n        return icon;\n    }\n\n    /**\n     * Get the text of this message\n     * \n     * @return\n     */\n    public String getText()\n    {\n        return text;\n    }\n\n    /**\n     * Get the type of this message\n     * \n     * @return One of Message.TYPE_*\n     */\n    public int getType()\n    {\n        return type;\n    }\n\n    /**\n     * Set the color of this message\n     */\n    public void setColor(int color)\n    {\n        this.color = color;\n    }\n\n    /**\n     * Set the timestamp of the message\n     *\n     * @param timestamp\n     */\n    public void setTimestamp(long timestamp)\n    {\n        this.timestamp = timestamp;\n    }\n\n    /**\n     * Associate a color with a sender name\n     *\n     * @return a color hexa\n     */\n    private int getSenderColor()\n    {\n        /* It might be worth to use some hash table here */\n        if (sender == null) {\n            return COLOR_DEFAULT;\n        }\n\n        int color = 0;\n\n        for(int i = 0; i < sender.length(); i++){\n            color += sender.charAt(i);\n        }\n\n        /* we dont want color[colors.length-1] which is black */\n        color = color % (colors.length - 1);\n\n        return colors[color];\n    }\n\n    /**\n     * Render message as spannable string\n     * \n     * @return\n     */\n    public SpannableString render(Context context)\n    {\n        Settings settings = new Settings(context);\n\n        if (canvas == null) {\n            String prefix    = hasIcon() && settings.showIcons() ? \"  \" : \"\";\n            String nick      = hasSender() ? \"<\" + sender + \"> \" : \"\";\n            String timestamp = settings.showTimestamp() ? renderTimeStamp(settings.use24hFormat()) : \"\";\n            if (settings.showMircColors()) {\n                canvas = new SpannableString(prefix + timestamp + nick);\n                canvas = new SpannableString(TextUtils.concat(canvas, MircColors.toSpannable(text)));\n            }\n            else {\n                canvas = new SpannableString(prefix + timestamp + nick + MircColors.removeStyleAndColors(text));\n            }\n\n            if (hasSender()) {\n                int start = (prefix + timestamp).length() + 1;\n                int end = start + sender.length();\n\n                if (settings.showColorsNick()) {\n                    canvas.setSpan(new ForegroundColorSpan(getSenderColor()), start, end , Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n                }\n            }\n\n            if (hasIcon() && settings.showIcons()) {\n                Drawable drawable = context.getResources().getDrawable(icon);\n                drawable.setBounds(0, 0, drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight());\n                canvas.setSpan(new ImageSpan(drawable, ImageSpan.ALIGN_BOTTOM), 0, 1, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n            }\n            if (hasColor() && settings.showColors()) {\n                // Only apply the foreground color to areas that don't already have a foreground color.\n                ForegroundColorSpan[] spans = canvas.getSpans(0, canvas.length(), ForegroundColorSpan.class);\n                int start = 0;\n                for (int i = 0; i < spans.length; i++) {\n                    canvas.setSpan(new ForegroundColorSpan(color), start, canvas.getSpanStart(spans[i]), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n                    start = canvas.getSpanEnd(spans[i]);\n                }\n                canvas.setSpan(new ForegroundColorSpan(color), start, canvas.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n            }\n        }\n\n        return canvas;\n    }\n\n    /**\n     * Does this message have a sender?\n     *\n     * @return\n     */\n    private boolean hasSender()\n    {\n        return sender != null;\n    }\n\n    /**\n     * Does this message have a color assigned?\n     *\n     * @return\n     */\n    private boolean hasColor()\n    {\n        return color != NO_COLOR;\n    }\n\n    /**\n     * Does this message have an icon assigned?\n     *\n     * @return\n     */\n    private boolean hasIcon()\n    {\n        return icon != NO_ICON;\n    }\n\n    /**\n     * Render message as text view\n     *\n     * @param context\n     * @return\n     */\n    public TextView renderTextView(Context context)\n    {\n        // XXX: We should not read settings here ALWAYS for EVERY textview\n        Settings settings = new Settings(context);\n\n        TextView canvas = new TextView(context);\n\n        canvas.setText(this.render(context));\n        canvas.setTextSize(settings.getFontSize());\n        canvas.setTypeface(Typeface.MONOSPACE);\n        canvas.setTextColor(COLOR_DEFAULT);\n\n        return canvas;\n    }\n\n    /**\n     * Generate a timestamp\n     * \n     * @param use24hFormat\n     * @return\n     */\n    public String renderTimeStamp(boolean use24hFormat)\n    {\n        Date date = new Date(timestamp);\n\n        int hours = date.getHours();\n        int minutes = date.getMinutes();\n\n        if (!use24hFormat) {\n            hours = Math.abs(12 - hours);\n            if (hours == 12) {\n                hours = 0;\n            }\n        }\n\n        return \"[\" + (hours < 10 ? \"0\" + hours : hours) + \":\" + (minutes < 10 ? \"0\" + minutes : minutes) + \"] \";\n    }\n}\n","Method after Refactoring":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2011 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage org.yaaic.model;\n\nimport java.util.Date;\n\nimport org.yaaic.utils.MircColors;\nimport org.yaaic.utils.Smilies;\n\nimport android.content.Context;\nimport android.graphics.Typeface;\nimport android.graphics.drawable.Drawable;\nimport android.text.Spannable;\nimport android.text.SpannableString;\nimport android.text.TextUtils;\nimport android.text.style.ForegroundColorSpan;\nimport android.text.style.ImageSpan;\nimport android.widget.TextView;\n\n/**\n * A channel or server message\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class Message\n{\n    public static final int COLOR_GREEN   = 0xFF458509;\n    public static final int COLOR_RED     = 0xFFcc0000;\n    public static final int COLOR_BLUE    = 0xFF729fcf;\n    public static final int COLOR_YELLOW  = 0xFFbe9b01;\n    public static final int COLOR_GREY    = 0xFFaaaaaa;\n    public static final int COLOR_DEFAULT = 0xFFeeeeee;\n\n    /* normal message, this is the default */\n    public static final int TYPE_MESSAGE = 0;\n    /* join, part or quit */\n    public static final int TYPE_MISC    = 1;\n\n    /* Some are light versions because dark colors hardly readable on\n     * Yaaic's dark background */\n    public static final int[] colors = {\n        0xFFffffff, // White\n        0xFFffff00, // Yellow\n        0xFFff00ff, // Fuchsia\n        0xFFff0000, // Red\n        0xFFc0c0c0, // Silver\n        0xFF808080, // Gray\n        0xFF808000, // Olive\n        0xFFC040C0, // Light Purple\n        0xFFC04040, // Light Maroon\n        0xFF00ffff, // Agua\n        0xFF80ff80, // Light Lime\n        0xFF008080, // Teal\n        0xFF008000, // Green\n        0xFF8484FF, // Light Blue\n        0xFF6060D0, // Light Navy\n        0xFF000000, // Black\n    };\n\n    public static final int NO_ICON  = -1;\n    public static final int NO_TYPE  = -1;\n    public static final int NO_COLOR = -1;\n\n    private final String text;\n    private final String sender;\n    private SpannableString canvas;\n    private long timestamp;\n\n    private int color = NO_COLOR;\n    private int type  = NO_ICON;\n    private int icon  = NO_TYPE;\n\n    /**\n     * Create a new message without an icon defaulting to TYPE_MESSAGE\n     * \n     * @param text\n     */\n    public Message(String text)\n    {\n        this(text, null, TYPE_MESSAGE);\n    }\n\n    /**\n     * Create a new message without an icon with a specific type\n     * \n     * @param text\n     * @param type Message type\n     */\n    public Message(String text, int type)\n    {\n        this(text, null, type);\n    }\n\n    /**\n     * Create a new message sent by a user, without an icon,\n     * defaulting to TYPE_MESSAGE\n     * \n     * @param text\n     * @param sender\n     */\n    public Message(String text, String sender)\n    {\n        this(text, sender, TYPE_MESSAGE);\n    }\n\n    /**\n     * Create a new message sent by a user without an icon\n     *\n     * @param text\n     * @param sender\n     * @param type Message type\n     */\n    public Message(String text, String sender, int type)\n    {\n        this.text = text;\n        this.sender = sender;\n        this.timestamp = new Date().getTime();\n        this.type = type;\n    }\n\n    /**\n     * Set the message's icon\n     */\n    public void setIcon(int icon)\n    {\n        this.icon = icon;\n    }\n\n    /**\n     * Get the message's icon\n     * \n     * @return\n     */\n    public int getIcon()\n    {\n        return icon;\n    }\n\n    /**\n     * Get the text of this message\n     * \n     * @return\n     */\n    public String getText()\n    {\n        return text;\n    }\n\n    /**\n     * Get the type of this message\n     * \n     * @return One of Message.TYPE_*\n     */\n    public int getType()\n    {\n        return type;\n    }\n\n    /**\n     * Set the color of this message\n     */\n    public void setColor(int color)\n    {\n        this.color = color;\n    }\n\n    /**\n     * Set the timestamp of the message\n     *\n     * @param timestamp\n     */\n    public void setTimestamp(long timestamp)\n    {\n        this.timestamp = timestamp;\n    }\n\n    /**\n     * Associate a color with a sender name\n     *\n     * @return a color hexa\n     */\n    private int getSenderColor()\n    {\n        /* It might be worth to use some hash table here */\n        if (sender == null) {\n            return COLOR_DEFAULT;\n        }\n\n        int color = 0;\n\n        for(int i = 0; i < sender.length(); i++){\n            color += sender.charAt(i);\n        }\n\n        /* we dont want color[colors.length-1] which is black */\n        color = color % (colors.length - 1);\n\n        return colors[color];\n    }\n\n    /**\n     * Render message as spannable string\n     * \n     * @return\n     */\n    public SpannableString render(Context context)\n    {\n        Settings settings = new Settings(context);\n\n        if (canvas == null) {\n            String prefix    = hasIcon() && settings.showIcons() ? \"  \" : \"\";\n            String nick      = hasSender() ? \"<\" + sender + \"> \" : \"\";\n            String timestamp = settings.showTimestamp() ? renderTimeStamp(settings.use24hFormat()) : \"\";\n            canvas = new SpannableString(prefix + timestamp + nick);\n            SpannableString renderedText = new SpannableString(text);\n            if (settings.showMircColors()) {\n                renderedText = MircColors.toSpannable(text);\n            }\n            if (settings.showGraphicalSmilies()) {\n                renderedText = Smilies.toSpannable(renderedText, context);\n            }\n            canvas = new SpannableString(TextUtils.concat(canvas, renderedText));\n            if (hasSender()) {\n                int start = (prefix + timestamp).length() + 1;\n                int end = start + sender.length();\n\n                if (settings.showColorsNick()) {\n                    canvas.setSpan(new ForegroundColorSpan(getSenderColor()), start, end , Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n                }\n            }\n\n            if (hasIcon() && settings.showIcons()) {\n                Drawable drawable = context.getResources().getDrawable(icon);\n                drawable.setBounds(0, 0, drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight());\n                canvas.setSpan(new ImageSpan(drawable, ImageSpan.ALIGN_BOTTOM), 0, 1, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n            }\n            if (hasColor() && settings.showColors()) {\n                // Only apply the foreground color to areas that don't already have a foreground color.\n                ForegroundColorSpan[] spans = canvas.getSpans(0, canvas.length(), ForegroundColorSpan.class);\n                int start = 0;\n                for (int i = 0; i < spans.length; i++) {\n                    canvas.setSpan(new ForegroundColorSpan(color), start, canvas.getSpanStart(spans[i]), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n                    start = canvas.getSpanEnd(spans[i]);\n                }\n                canvas.setSpan(new ForegroundColorSpan(color), start, canvas.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n            }\n        }\n\n        return canvas;\n    }\n\n    /**\n     * Does this message have a sender?\n     *\n     * @return\n     */\n    private boolean hasSender()\n    {\n        return sender != null;\n    }\n\n    /**\n     * Does this message have a color assigned?\n     *\n     * @return\n     */\n    private boolean hasColor()\n    {\n        return color != NO_COLOR;\n    }\n\n    /**\n     * Does this message have an icon assigned?\n     *\n     * @return\n     */\n    private boolean hasIcon()\n    {\n        return icon != NO_ICON;\n    }\n\n    /**\n     * Render message as text view\n     *\n     * @param context\n     * @return\n     */\n    public TextView renderTextView(Context context)\n    {\n        // XXX: We should not read settings here ALWAYS for EVERY textview\n        Settings settings = new Settings(context);\n\n        TextView canvas = new TextView(context);\n\n        canvas.setText(this.render(context));\n        canvas.setTextSize(settings.getFontSize());\n        canvas.setTypeface(Typeface.MONOSPACE);\n        canvas.setTextColor(COLOR_DEFAULT);\n\n        return canvas;\n    }\n\n    /**\n     * Generate a timestamp\n     * \n     * @param use24hFormat\n     * @return\n     */\n    public String renderTimeStamp(boolean use24hFormat)\n    {\n        Date date = new Date(timestamp);\n\n        int hours = date.getHours();\n        int minutes = date.getMinutes();\n\n        if (!use24hFormat) {\n            hours = Math.abs(12 - hours);\n            if (hours == 12) {\n                hours = 0;\n            }\n        }\n\n        return \"[\" + (hours < 10 ? \"0\" + hours : hours) + \":\" + (minutes < 10 ? \"0\" + minutes : minutes) + \"] \";\n    }\n}\n","lineNo":233}
{"Smelly Sample":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2011 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage org.yaaic.model;\n\nimport java.util.Date;\n\nimport org.yaaic.utils.Colors;\nimport org.yaaic.utils.Html2;\n\nimport android.content.Context;\nimport android.graphics.Typeface;\nimport android.graphics.drawable.Drawable;\nimport android.text.Spannable;\nimport android.text.SpannableString;\nimport android.text.Spanned;\nimport android.text.TextUtils;\nimport android.text.style.ForegroundColorSpan;\nimport android.text.style.ImageSpan;\nimport android.widget.TextView;\n\n/**\n * A channel or server message\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class Message\n{\n    public static final int COLOR_GREEN   = 0xFF458509;\n    public static final int COLOR_RED     = 0xFFcc0000;\n    public static final int COLOR_BLUE    = 0xFF729fcf;\n    public static final int COLOR_YELLOW  = 0xFFbe9b01;\n    public static final int COLOR_GREY    = 0xFFaaaaaa;\n    public static final int COLOR_DEFAULT = 0xFFeeeeee;\n\n    /* normal message, this is the default */\n    public static final int TYPE_MESSAGE = 0;\n    /* join, part or quit */\n    public static final int TYPE_MISC    = 1;\n\n    /* Some are light versions because dark colors hardly readable on\n     * Yaaic's dark background */\n    public static final int[] colors = {\n        0xFFffffff, // White\n        0xFFffff00, // Yellow\n        0xFFff00ff, // Fuchsia\n        0xFFff0000, // Red\n        0xFFc0c0c0, // Silver\n        0xFF808080, // Gray\n        0xFF808000, // Olive\n        0xFFC040C0, // Light Purple\n        0xFFC04040, // Light Maroon\n        0xFF00ffff, // Agua\n        0xFF80ff80, // Light Lime\n        0xFF008080, // Teal\n        0xFF008000, // Green\n        0xFF8484FF, // Light Blue\n        0xFF6060D0, // Light Navy\n        0xFF000000, // Black\n    };\n\n    public static final int NO_ICON  = -1;\n    public static final int NO_TYPE  = -1;\n    public static final int NO_COLOR = -1;\n\n    private final String text;\n    private final String sender;\n    private SpannableString canvas;\n    private long timestamp;\n\n    private int color = NO_COLOR;\n    private int type  = NO_ICON;\n    private int icon  = NO_TYPE;\n\n    /**\n     * Create a new message without an icon defaulting to TYPE_MESSAGE\n     * \n     * @param text\n     */\n    public Message(String text)\n    {\n        this(text, null, TYPE_MESSAGE);\n    }\n\n    /**\n     * Create a new message without an icon with a specific type\n     * \n     * @param text\n     * @param type Message type\n     */\n    public Message(String text, int type)\n    {\n        this(text, null, type);\n    }\n\n    /**\n     * Create a new message sent by a user, without an icon,\n     * defaulting to TYPE_MESSAGE\n     * \n     * @param text\n     * @param sender\n     */\n    public Message(String text, String sender)\n    {\n        this(text, sender, TYPE_MESSAGE);\n    }\n\n    /**\n     * Create a new message sent by a user without an icon\n     *\n     * @param text\n     * @param sender\n     * @param type Message type\n     */\n    public Message(String text, String sender, int type)\n    {\n        this.text = text;\n        this.sender = sender;\n        this.timestamp = new Date().getTime();\n        this.type = type;\n    }\n\n    /**\n     * Set the message's icon\n     */\n    public void setIcon(int icon)\n    {\n        this.icon = icon;\n    }\n\n    /**\n     * Get the message's icon\n     * \n     * @return\n     */\n    public int getIcon()\n    {\n        return icon;\n    }\n\n    /**\n     * Get the text of this message\n     * \n     * @return\n     */\n    public String getText()\n    {\n        return text;\n    }\n\n    /**\n     * Get the type of this message\n     * \n     * @return One of Message.TYPE_*\n     */\n    public int getType()\n    {\n        return type;\n    }\n\n    /**\n     * Set the color of this message\n     */\n    public void setColor(int color)\n    {\n        this.color = color;\n    }\n\n    /**\n     * Set the timestamp of the message\n     *\n     * @param timestamp\n     */\n    public void setTimestamp(long timestamp)\n    {\n        this.timestamp = timestamp;\n    }\n\n    /**\n     * Associate a color with a sender name\n     *\n     * @return a color hexa\n     */\n    private int getSenderColor()\n    {\n        /* It might be worth to use some hash table here */\n        if (sender == null) {\n            return COLOR_DEFAULT;\n        }\n\n        int color = 0;\n\n        for(int i = 0; i < sender.length(); i++){\n            color += sender.charAt(i);\n        }\n\n        /* we dont want color[colors.length-1] which is black */\n        color = color % (colors.length - 1);\n\n        return colors[color];\n    }\n\n    /**\n     * Render message as spannable string\n     * \n     * @return\n     */\n    public SpannableString render(Context context)\n    {\n        Settings settings = new Settings(context);\n\n        if (canvas == null) {\n            String prefix    = hasIcon() && settings.showIcons() ? \"  \" : \"\";\n            String nick      = hasSender() ? \"<\" + sender + \"> \" : \"\";\n            String timestamp = settings.showTimestamp() ? renderTimeStamp(settings.use24hFormat()) : \"\";\n            if (settings.showMircColors()) {\n                String htmltext = Colors.mircColorParser(TextUtils.htmlEncode(text));\n                Spanned colortext = Html2.fromHtml(htmltext);\n\n                canvas = new SpannableString(prefix + timestamp + nick);\n                canvas = new SpannableString(TextUtils.concat(canvas, colortext));\n            }\n            else {\n                canvas = new SpannableString(prefix + timestamp + nick + Colors.removeStyleAndColors(text));\n            }\n\n\n            if (hasSender()) {\n                int start = (prefix + timestamp).length() + 1;\n                int end = start + sender.length();\n\n                if (settings.showColorsNick()) {\n                    canvas.setSpan(new ForegroundColorSpan(getSenderColor()), start, end , Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n                }\n            }\n\n            if (hasIcon() && settings.showIcons()) {\n                Drawable drawable = context.getResources().getDrawable(icon);\n                drawable.setBounds(0, 0, drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight());\n                canvas.setSpan(new ImageSpan(drawable, ImageSpan.ALIGN_BOTTOM), 0, 1, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n            }\n            if (hasColor() && settings.showColors()) {\n                canvas.setSpan(new ForegroundColorSpan(color), 0, canvas.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n            }\n        }\n\n        return canvas;\n    }\n\n    /**\n     * Does this message have a sender?\n     *\n     * @return\n     */\n    private boolean hasSender()\n    {\n        return sender != null;\n    }\n\n    /**\n     * Does this message have a color assigned?\n     *\n     * @return\n     */\n    private boolean hasColor()\n    {\n        return color != NO_COLOR;\n    }\n\n    /**\n     * Does this message have an icon assigned?\n     *\n     * @return\n     */\n    private boolean hasIcon()\n    {\n        return icon != NO_ICON;\n    }\n\n    /**\n     * Render message as text view\n     *\n     * @param context\n     * @return\n     */\n    public TextView renderTextView(Context context)\n    {\n        // XXX: We should not read settings here ALWAYS for EVERY textview\n        Settings settings = new Settings(context);\n\n        TextView canvas = new TextView(context);\n\n        canvas.setText(this.render(context));\n        canvas.setTextSize(settings.getFontSize());\n        canvas.setTypeface(Typeface.MONOSPACE);\n        canvas.setTextColor(COLOR_DEFAULT);\n\n        return canvas;\n    }\n\n    /**\n     * Generate a timestamp\n     * \n     * @param use24hFormat\n     * @return\n     */\n    public String renderTimeStamp(boolean use24hFormat)\n    {\n        Date date = new Date(timestamp);\n\n        int hours = date.getHours();\n        int minutes = date.getMinutes();\n\n        if (!use24hFormat) {\n            hours = Math.abs(12 - hours);\n            if (hours == 12) {\n                hours = 0;\n            }\n        }\n\n        return \"[\" + (hours < 10 ? \"0\" + hours : hours) + \":\" + (minutes < 10 ? \"0\" + minutes : minutes) + \"] \";\n    }\n}\n","Method after Refactoring":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2011 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage org.yaaic.model;\n\nimport java.util.Date;\n\nimport org.yaaic.utils.Colors;\nimport org.yaaic.utils.Html2;\n\nimport android.content.Context;\nimport android.graphics.Typeface;\nimport android.graphics.drawable.Drawable;\nimport android.text.Spannable;\nimport android.text.SpannableString;\nimport android.text.Spanned;\nimport android.text.TextUtils;\nimport android.text.style.ForegroundColorSpan;\nimport android.text.style.ImageSpan;\nimport android.widget.TextView;\n\n/**\n * A channel or server message\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class Message\n{\n    public static final int COLOR_GREEN   = 0xFF458509;\n    public static final int COLOR_RED     = 0xFFcc0000;\n    public static final int COLOR_BLUE    = 0xFF729fcf;\n    public static final int COLOR_YELLOW  = 0xFFbe9b01;\n    public static final int COLOR_GREY    = 0xFFaaaaaa;\n    public static final int COLOR_DEFAULT = 0xFFeeeeee;\n\n    /* normal message, this is the default */\n    public static final int TYPE_MESSAGE = 0;\n    /* join, part or quit */\n    public static final int TYPE_MISC    = 1;\n\n    /* Some are light versions because dark colors hardly readable on\n     * Yaaic's dark background */\n    public static final int[] colors = {\n        0xFFffffff, // White\n        0xFFffff00, // Yellow\n        0xFFff00ff, // Fuchsia\n        0xFFff0000, // Red\n        0xFFc0c0c0, // Silver\n        0xFF808080, // Gray\n        0xFF808000, // Olive\n        0xFFC040C0, // Light Purple\n        0xFFC04040, // Light Maroon\n        0xFF00ffff, // Agua\n        0xFF80ff80, // Light Lime\n        0xFF008080, // Teal\n        0xFF008000, // Green\n        0xFF8484FF, // Light Blue\n        0xFF6060D0, // Light Navy\n        0xFF000000, // Black\n    };\n\n    public static final int NO_ICON  = -1;\n    public static final int NO_TYPE  = -1;\n    public static final int NO_COLOR = -1;\n\n    private final String text;\n    private final String sender;\n    private SpannableString canvas;\n    private long timestamp;\n\n    private int color = NO_COLOR;\n    private int type  = NO_ICON;\n    private int icon  = NO_TYPE;\n\n    /**\n     * Create a new message without an icon defaulting to TYPE_MESSAGE\n     * \n     * @param text\n     */\n    public Message(String text)\n    {\n        this(text, null, TYPE_MESSAGE);\n    }\n\n    /**\n     * Create a new message without an icon with a specific type\n     * \n     * @param text\n     * @param type Message type\n     */\n    public Message(String text, int type)\n    {\n        this(text, null, type);\n    }\n\n    /**\n     * Create a new message sent by a user, without an icon,\n     * defaulting to TYPE_MESSAGE\n     * \n     * @param text\n     * @param sender\n     */\n    public Message(String text, String sender)\n    {\n        this(text, sender, TYPE_MESSAGE);\n    }\n\n    /**\n     * Create a new message sent by a user without an icon\n     *\n     * @param text\n     * @param sender\n     * @param type Message type\n     */\n    public Message(String text, String sender, int type)\n    {\n        this.text = text;\n        this.sender = sender;\n        this.timestamp = new Date().getTime();\n        this.type = type;\n    }\n\n    /**\n     * Set the message's icon\n     */\n    public void setIcon(int icon)\n    {\n        this.icon = icon;\n    }\n\n    /**\n     * Get the message's icon\n     * \n     * @return\n     */\n    public int getIcon()\n    {\n        return icon;\n    }\n\n    /**\n     * Get the text of this message\n     * \n     * @return\n     */\n    public String getText()\n    {\n        return text;\n    }\n\n    /**\n     * Get the type of this message\n     * \n     * @return One of Message.TYPE_*\n     */\n    public int getType()\n    {\n        return type;\n    }\n\n    /**\n     * Set the color of this message\n     */\n    public void setColor(int color)\n    {\n        this.color = color;\n    }\n\n    /**\n     * Set the timestamp of the message\n     *\n     * @param timestamp\n     */\n    public void setTimestamp(long timestamp)\n    {\n        this.timestamp = timestamp;\n    }\n\n    /**\n     * Associate a color with a sender name\n     *\n     * @return a color hexa\n     */\n    private int getSenderColor()\n    {\n        /* It might be worth to use some hash table here */\n        if (sender == null) {\n            return COLOR_DEFAULT;\n        }\n\n        int color = 0;\n\n        for(int i = 0; i < sender.length(); i++){\n            color += sender.charAt(i);\n        }\n\n        /* we dont want color[colors.length-1] which is black */\n        color = color % (colors.length - 1);\n\n        return colors[color];\n    }\n\n    /**\n     * Render message as spannable string\n     * \n     * @return\n     */\n    public SpannableString render(Context context)\n    {\n        Settings settings = new Settings(context);\n\n        if (canvas == null) {\n            String prefix    = hasIcon() && settings.showIcons() ? \"  \" : \"\";\n            String nick      = hasSender() ? \"<\" + sender + \"> \" : \"\";\n            String timestamp = settings.showTimestamp() ? renderTimeStamp(settings.use24hFormat()) : \"\";\n            if (settings.showMircColors()) {\n                // Tagsoup doesn't like when a html string begins with a <font> tag so we'll surround the html with <pre> tags.\n                String entext = \"<pre>\"+TextUtils.htmlEncode(text).replaceAll(\" \", \"&nbsp;\")+\"<\/pre>\";\n                String htmltext = Colors.mircColorParser(entext);\n                Spanned colortext = Html2.fromHtml(htmltext);\n\n                canvas = new SpannableString(prefix + timestamp + nick);\n                canvas = new SpannableString(TextUtils.concat(canvas, colortext));\n            }\n            else {\n                canvas = new SpannableString(prefix + timestamp + nick + Colors.removeStyleAndColors(text));\n            }\n\n\n            if (hasSender()) {\n                int start = (prefix + timestamp).length() + 1;\n                int end = start + sender.length();\n\n                if (settings.showColorsNick()) {\n                    canvas.setSpan(new ForegroundColorSpan(getSenderColor()), start, end , Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n                }\n            }\n\n            if (hasIcon() && settings.showIcons()) {\n                Drawable drawable = context.getResources().getDrawable(icon);\n                drawable.setBounds(0, 0, drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight());\n                canvas.setSpan(new ImageSpan(drawable, ImageSpan.ALIGN_BOTTOM), 0, 1, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n            }\n            if (hasColor() && settings.showColors()) {\n                // Only apply the foreground color on areas that don't already have a foreground color.\n                ForegroundColorSpan[] spans = canvas.getSpans(0, canvas.length(), ForegroundColorSpan.class);\n                int start = 0;\n                for (int i = 0; i < spans.length; i++) {\n                    canvas.getSpanStart(spans[i]);\n                    canvas.setSpan(new ForegroundColorSpan(color), start, canvas.getSpanStart(spans[i]), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n                    start = canvas.getSpanEnd(spans[i]);\n                }\n                canvas.setSpan(new ForegroundColorSpan(color), start, canvas.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n            }\n        }\n\n        return canvas;\n    }\n\n    /**\n     * Does this message have a sender?\n     *\n     * @return\n     */\n    private boolean hasSender()\n    {\n        return sender != null;\n    }\n\n    /**\n     * Does this message have a color assigned?\n     *\n     * @return\n     */\n    private boolean hasColor()\n    {\n        return color != NO_COLOR;\n    }\n\n    /**\n     * Does this message have an icon assigned?\n     *\n     * @return\n     */\n    private boolean hasIcon()\n    {\n        return icon != NO_ICON;\n    }\n\n    /**\n     * Render message as text view\n     *\n     * @param context\n     * @return\n     */\n    public TextView renderTextView(Context context)\n    {\n        // XXX: We should not read settings here ALWAYS for EVERY textview\n        Settings settings = new Settings(context);\n\n        TextView canvas = new TextView(context);\n\n        canvas.setText(this.render(context));\n        canvas.setTextSize(settings.getFontSize());\n        canvas.setTypeface(Typeface.MONOSPACE);\n        canvas.setTextColor(COLOR_DEFAULT);\n\n        return canvas;\n    }\n\n    /**\n     * Generate a timestamp\n     * \n     * @param use24hFormat\n     * @return\n     */\n    public String renderTimeStamp(boolean use24hFormat)\n    {\n        Date date = new Date(timestamp);\n\n        int hours = date.getHours();\n        int minutes = date.getMinutes();\n\n        if (!use24hFormat) {\n            hours = Math.abs(12 - hours);\n            if (hours == 12) {\n                hours = 0;\n            }\n        }\n\n        return \"[\" + (hours < 10 ? \"0\" + hours : hours) + \":\" + (minutes < 10 ? \"0\" + minutes : minutes) + \"] \";\n    }\n}\n","lineNo":264}
{"Smelly Sample":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2011 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage org.yaaic.activity;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.adapter.DeckAdapter;\nimport org.yaaic.adapter.MessageListAdapter;\nimport org.yaaic.command.CommandParser;\nimport org.yaaic.irc.IRCBinder;\nimport org.yaaic.irc.IRCConnection;\nimport org.yaaic.irc.IRCService;\nimport org.yaaic.layout.NonScalingBackgroundDrawable;\nimport org.yaaic.listener.ConversationClickListener;\nimport org.yaaic.listener.ConversationListener;\nimport org.yaaic.listener.ConversationSelectedListener;\nimport org.yaaic.listener.ServerListener;\nimport org.yaaic.listener.SpeechClickListener;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.model.Extra;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Query;\nimport org.yaaic.model.Scrollback;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.ServerInfo;\nimport org.yaaic.model.Settings;\nimport org.yaaic.model.Status;\nimport org.yaaic.model.User;\nimport org.yaaic.receiver.ConversationReceiver;\nimport org.yaaic.receiver.ServerReceiver;\nimport org.yaaic.view.ConversationSwitcher;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.content.pm.PackageManager;\nimport android.content.pm.ResolveInfo;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.speech.RecognizerIntent;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.View.OnKeyListener;\nimport android.view.Window;\nimport android.view.inputmethod.InputMethodManager;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.Gallery;\nimport android.widget.ImageView;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport android.widget.ViewSwitcher;\n\n/**\n * The server view with a scrollable list of all channels\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class ConversationActivity extends Activity implements ServiceConnection, ServerListener, ConversationListener, OnKeyListener\n{\n    public static final int REQUEST_CODE_SPEECH = 99;\n\n    private static final int REQUEST_CODE_JOIN = 1;\n    private static final int REQUEST_CODE_USERS = 2;\n    private static final int REQUEST_CODE_USER = 3;\n    private static final int REQUEST_CODE_NICK_COMPLETION= 4;\n\n    private int serverId;\n    private Server server;\n    private IRCBinder binder;\n    private ConversationReceiver channelReceiver;\n    private ServerReceiver serverReceiver;\n\n    private ViewSwitcher switcher;\n    private Gallery deck;\n    private DeckAdapter deckAdapter;\n    private Scrollback scrollback;\n    private ConversationSwitcher dots;\n\n    // XXX: This is ugly. This is a buffer for a channel that should be joined after showing the\n    //      JoinActivity. As onActivityResult() is called before onResume() a \"channel joined\"\n    //      broadcast may get lost as the broadcast receivers are registered in onResume() but the\n    //      join command would be called in onActivityResult(). joinChannelBuffer will save the\n    //      channel name in onActivityResult() and run the join command in onResume().\n    private String joinChannelBuffer;\n\n    // flag passed to setInputType later\n    // shall be TYPE_TEXT_FLAG_NO_SUGGESTIONS but it's not supported in all API levels (only in 5+)\n    // We'll set it to 0 if it's not supported\n    private int setInputTypeFlag;\n\n    /**\n     * On create\n     */\n    @Override\n    protected void onCreate(Bundle savedInstanceState)\n    {\n        super.onCreate(savedInstanceState);\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n\n        serverId = getIntent().getExtras().getInt(\"serverId\");\n        server = Yaaic.getInstance().getServerById(serverId);\n        setTitle(\"Yaaic - \" + server.getTitle());\n\n        setContentView(R.layout.conversations);\n\n        ((TextView) findViewById(R.id.title)).setText(server.getTitle());\n        ((EditText) findViewById(R.id.input)).setOnKeyListener(this);\n\n        switcher = (ViewSwitcher) findViewById(R.id.switcher);\n\n        dots = (ConversationSwitcher) findViewById(R.id.dots);\n        dots.setServer(server);\n\n        deckAdapter = new DeckAdapter();\n        deck = (Gallery) findViewById(R.id.deck);\n        deck.setOnItemSelectedListener(new ConversationSelectedListener(server, (TextView) findViewById(R.id.title), dots));\n        deck.setAdapter(deckAdapter);\n        deck.setOnItemClickListener(new ConversationClickListener(deckAdapter, switcher));\n        deck.setBackgroundDrawable(new NonScalingBackgroundDrawable(this, deck, R.drawable.background));\n\n        if (server.getStatus() == Status.PRE_CONNECTING) {\n            server.clearConversations();\n            deckAdapter.clearConversations();\n        }\n\n        // Optimization : cache field lookups\n        Collection<Conversation> mConversations = server.getConversations();\n\n        for (Conversation conversation : mConversations) {\n            onNewConversation(conversation.getName());\n        }\n\n        // keep compatibility with api level 3\n        if ((android.os.Build.VERSION.SDK.charAt(0) - '0') >= 5) {\n            setInputTypeFlag = 0x80000; // InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS\n        }\n        else {\n            setInputTypeFlag = 0;\n        }\n\n        // Create a new scrollback history\n        scrollback = new Scrollback();\n    }\n\n    /**\n     * On resume\n     */\n    @Override\n    public void onResume()\n    {\n        // register the receivers as early as possible, otherwise we may loose a broadcast message\n        channelReceiver = new ConversationReceiver(server.getId(), this);\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_MESSAGE));\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_NEW));\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_REMOVE));\n\n        serverReceiver = new ServerReceiver(this);\n        registerReceiver(serverReceiver, new IntentFilter(Broadcast.SERVER_UPDATE));\n\n        super.onResume();\n\n        // Check if speech recognition is enabled and available\n        if (new Settings(this).isVoiceRecognitionEnabled()) {\n            PackageManager pm = getPackageManager();\n            Button speechButton = (Button) findViewById(R.id.speech);\n            List<ResolveInfo> activities = pm.queryIntentActivities(new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH), 0);\n            if (activities.size() != 0) {\n                ((Button) findViewById(R.id.speech)).setOnClickListener(new SpeechClickListener(this));\n                speechButton.setVisibility(View.VISIBLE);\n            }\n        }\n\n        ((ImageView) findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\n        // Start service\n        Intent intent = new Intent(this, IRCService.class);\n        intent.setAction(IRCService.ACTION_FOREGROUND);\n        startService(intent);\n        bindService(intent, this, 0);\n\n        if (!server.isConnected()) {\n            ((EditText) findViewById(R.id.input)).setEnabled(false);\n        } else {\n            ((EditText) findViewById(R.id.input)).setEnabled(true);\n        }\n\n        // Optimization - cache field lookup\n        Collection<Conversation> mConversations = server.getConversations();\n        MessageListAdapter mAdapter;\n\n        // Fill view with messages that have been buffered while paused\n        for (Conversation conversation : mConversations) {\n            mAdapter = conversation.getMessageListAdapter();\n\n            if (mAdapter != null) {\n                mAdapter.addBulkMessages(conversation.getBuffer());\n                conversation.clearBuffer();\n            }\n        }\n\n        // Join channel that has been selected in JoinActivity (onActivityResult())\n        if (joinChannelBuffer != null) {\n            new Thread() {\n                @Override\n                public void run() {\n                    binder.getService().getConnection(serverId).joinChannel(joinChannelBuffer);\n                    joinChannelBuffer = null;\n                }\n            }.start();\n        }\n    }\n\n    /**\n     * On Pause\n     */\n    @Override\n    public void onPause()\n    {\n        super.onPause();\n\n        if (binder != null && binder.getService() != null) {\n            binder.getService().checkServiceStatus();\n        }\n\n        unbindService(this);\n        unregisterReceiver(channelReceiver);\n        unregisterReceiver(serverReceiver);\n    }\n\n    /**\n     * On service connected\n     */\n    @Override\n    public void onServiceConnected(ComponentName name, IBinder service)\n    {\n        this.binder = (IRCBinder) service;\n\n        // connect to irc server if connect has been requested\n        if (server.getStatus() == Status.PRE_CONNECTING && getIntent().hasExtra(\"connect\")) {\n            server.setStatus(Status.CONNECTING);\n            binder.connect(server);\n        }\n    }\n\n    /**\n     * On service disconnected\n     */\n    @Override\n    public void onServiceDisconnected(ComponentName name)\n    {\n        this.binder = null;\n    }\n\n    /**\n     * On options menu requested\n     */\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu)\n    {\n        super.onCreateOptionsMenu(menu);\n\n        // inflate from xml\n        MenuInflater inflater = getMenuInflater();\n        inflater.inflate(R.menu.conversations, menu);\n\n        return true;\n    }\n\n    /**\n     * On prepare options menu\n     */\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu)\n    {\n        menu.getItem(0).setEnabled(server.isConnected()); // join\n        menu.getItem(1).setEnabled(server.isConnected()); // users\n        menu.getItem(2).setEnabled(server.isConnected()); // close\n\n        return true;\n    }\n\n    /**\n     * On menu item selected\n     */\n    @Override\n    public boolean onMenuItemSelected(int featureId, MenuItem item)\n    {\n        switch (item.getItemId()) {\n            case R.id.disconnect:\n                server.setStatus(Status.DISCONNECTED);\n                binder.getService().getConnection(serverId).quitServer();\n                server.clearConversations();\n                setResult(RESULT_OK);\n                finish();\n                break;\n            case R.id.close:\n                Conversation conversationToClose = deckAdapter.getItem(deck.getSelectedItemPosition());\n                // Make sure we part a channel when closing the channel conversation\n                if (conversationToClose.getType() == Conversation.TYPE_CHANNEL) {\n                    binder.getService().getConnection(serverId).partChannel(conversationToClose.getName());\n                }\n                else if (conversationToClose.getType() == Conversation.TYPE_QUERY) {\n                    server.removeConversation(conversationToClose.getName());\n                    onRemoveConversation(conversationToClose.getName());\n                } else {\n                    Toast.makeText(this, getResources().getString(R.string.close_server_window), Toast.LENGTH_SHORT).show();\n                }\n                break;\n            case R.id.join:\n                startActivityForResult(new Intent(this, JoinActivity.class), REQUEST_CODE_JOIN);\n                break;\n            case R.id.users:\n                Conversation conversationForUserList = deckAdapter.getItem(deck.getSelectedItemPosition());\n                if (conversationForUserList.getType() == Conversation.TYPE_CHANNEL) {\n                    Intent intent = new Intent(this, UsersActivity.class);\n                    intent.putExtra(\n                        Extra.USERS,\n                        binder.getService().getConnection(server.getId()).getUsersAsStringArray(\n                            conversationForUserList.getName()\n                        )\n                    );\n                    startActivityForResult(intent, REQUEST_CODE_USERS);\n                } else {\n                    Toast.makeText(this, getResources().getString(R.string.only_usable_from_channel), Toast.LENGTH_SHORT).show();\n                }\n                break;\n        }\n\n        return true;\n    }\n\n    /**\n     * Get server object assigned to this activity\n     * \n     * @return the server object\n     */\n    public Server getServer()\n    {\n        return server;\n    }\n\n    /**\n     * On conversation message\n     */\n    @Override\n    public void onConversationMessage(String target)\n    {\n        Conversation conversation = server.getConversation(target);\n\n        if (conversation == null) {\n            // In an early state it can happen that the conversation object\n            // is not created yet.\n            return;\n        }\n\n        MessageListAdapter adapter = conversation.getMessageListAdapter();\n\n        conversation.setStatus(Conversation.STATUS_MESSAGE);\n\n        if (dots != null) {\n            dots.invalidate();\n        }\n\n        while(conversation.hasBufferedMessages()) {\n            Message message = conversation.pollBufferedMessage();\n\n            if (adapter != null) {\n                adapter.addMessage(message);\n            }\n        }\n    }\n\n    /**\n     * On new conversation\n     */\n    @Override\n    public void onNewConversation(String target)\n    {\n        deckAdapter.addItem(server.getConversation(target));\n\n        if (!deckAdapter.isSwitched()) {\n            // Scroll to new conversation\n            deck.setSelection(deckAdapter.getCount() - 1);\n        }\n    }\n\n    /**\n     * On conversation remove\n     */\n    @Override\n    public void onRemoveConversation(String target)\n    {\n        deckAdapter.removeItem(target);\n\n        if (deckAdapter.isSwitched()) {\n            switcher.showNext();\n            switcher.removeView(deckAdapter.getSwitchedView());\n            deckAdapter.setSwitched(null, null);\n        }\n    }\n\n    /**\n     * On server status update\n     */\n    @Override\n    public void onStatusUpdate()\n    {\n        ((ImageView) findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\n        EditText input = (EditText) findViewById(R.id.input);\n\n        if (server.isConnected()) {\n            input.setEnabled(true);\n        } else {\n            input.setEnabled(false);\n\n            if (server.getStatus() == Status.CONNECTING) {\n                deckAdapter.clearConversations();\n                deckAdapter.addItem(server.getConversation(ServerInfo.DEFAULT_NAME));\n                return;\n            }\n\n            if (!binder.getService().getSettings().isReconnectEnabled()) {\n                AlertDialog.Builder builder = new AlertDialog.Builder(this);\n                builder.setMessage(getResources().getString(R.string.reconnect_after_disconnect, server.getTitle()))\n                .setCancelable(false)\n                .setPositiveButton(\"Yes\", new DialogInterface.OnClickListener() {\n                    @Override\n                    public void onClick(DialogInterface dialog, int id) {\n                        binder.getService().getConnection(server.getId()).setAutojoinChannels(\n                            server.getCurrentChannelNames()\n                        );\n                        server.clearConversations();\n                        deckAdapter.clearConversations();\n                        deckAdapter.addItem(server.getConversation(ServerInfo.DEFAULT_NAME));\n                        binder.connect(server);\n                    }\n                })\n                .setNegativeButton(getString(R.string.negative_button), new DialogInterface.OnClickListener() {\n                    @Override\n                    public void onClick(DialogInterface dialog, int id) {\n                        dialog.cancel();\n                    }\n                });\n                AlertDialog alert = builder.create();\n                alert.show();\n            }\n        }\n    }\n\n    /**\n     * On key down\n     *\n     * XXX: As we only track the back key: Android >= 2.0 will call a method called onBackPressed()\n     */\n    @Override\n    public boolean onKeyDown(int keyCode, KeyEvent event)\n    {\n        if (keyCode == KeyEvent.KEYCODE_BACK && event.getRepeatCount() == 0) {\n            if (deckAdapter.isSwitched()) {\n                switcher.showNext();\n                switcher.removeView(deckAdapter.getSwitchedView());\n                deckAdapter.setSwitched(null, null);\n                return true;\n            }\n        }\n        return super.onKeyDown(keyCode, event);\n    }\n\n    /**\n     * On key pressed (input line)\n     */\n    @Override\n    public boolean onKey(View view, int keyCode, KeyEvent event)\n    {\n        EditText input = (EditText) view;\n\n        if (keyCode == KeyEvent.KEYCODE_DPAD_UP && event.getAction() == KeyEvent.ACTION_DOWN) {\n            String message = scrollback.goBack();\n            if (message != null) {\n                input.setText(message);\n            }\n            return true;\n        }\n\n        if (keyCode == KeyEvent.KEYCODE_DPAD_DOWN && event.getAction() == KeyEvent.ACTION_DOWN) {\n            String message = scrollback.goForward();\n            if (message != null) {\n                input.setText(message);\n            }\n            return true;\n        }\n\n        // Nick completion\n        if (keyCode == KeyEvent.KEYCODE_SEARCH && event.getAction() == KeyEvent.ACTION_DOWN) {\n            String text = input.getText().toString();\n\n            if (text.length() <= 0) {\n                return true;\n            }\n\n            String[] tokens = text.split(\"[\\\\s,.-]+\");\n\n            if (tokens.length <= 0) {\n                return true;\n            }\n\n            String word = tokens[tokens.length - 1].toLowerCase();\n            tokens[tokens.length - 1] = null;\n\n            int begin   = input.getSelectionStart();\n            int end     = input.getSelectionEnd();\n            int cursor  = Math.min(begin, end);\n            int sel_end = Math.max(begin, end);\n\n            boolean in_selection = cursor != sel_end;\n\n            if (in_selection) {\n                word = text.substring(cursor, sel_end);\n            } else {\n                // use the word at the curent cursor position\n                while(true) {\n                    cursor -= 1;\n                    if (cursor <= 0 || text.charAt(cursor) == ' ') {\n                        break;\n                    }\n                }\n\n                if (cursor < 0) {\n                    cursor = 0;\n                }\n\n                if (text.charAt(cursor) == ' ') {\n                    cursor += 1;\n                }\n\n                sel_end = text.indexOf(' ', cursor);\n\n                if (sel_end == -1) {\n                    sel_end = text.length();\n                }\n\n                word = text.substring(cursor, sel_end);\n            }\n            // Log.d(\"Yaaic\", \"Trying to complete nick: \" + word);\n\n            Conversation conversationForUserList = deckAdapter.getItem(deck.getSelectedItemPosition());\n\n            String[] users = null;\n\n            if (conversationForUserList.getType() == Conversation.TYPE_CHANNEL) {\n                users = binder.getService().getConnection(server.getId()).getUsersAsStringArray(\n                    conversationForUserList.getName()\n                );\n            }\n\n            // go through users and add matches\n            if (users != null) {\n                List<Integer> result = new ArrayList<Integer>();\n\n                for (int i = 0; i < users.length; i++) {\n                    if (users[i].toLowerCase().startsWith(word)) {\n                        result.add(Integer.valueOf(i));\n                    }\n                }\n\n                if (result.size() == 1) {\n                    String text1 = users[result.get(0).intValue()];\n\n                    if (cursor == 0) {\n                        text1 += \":\";\n                    }\n\n                    text1 += \" \";\n                    input.getText().replace(cursor, sel_end, text1, 0, text1.length());\n                    int old = input.getInputType();\n                    input.setInputType(old | setInputTypeFlag);\n                } else if (result.size() > 0) {\n                    Intent intent  = new Intent(this, UsersActivity.class);\n                    String[] extra = new String[result.size()];\n                    int i = 0;\n\n                    for (Integer n : result) {\n                        extra[i++] = users[n.intValue()];\n                    }\n\n                    input.setSelection(cursor, sel_end);\n                    intent.putExtra(Extra.USERS, extra);\n                    startActivityForResult(intent, REQUEST_CODE_NICK_COMPLETION);\n                }\n            }\n            return true;\n        }\n\n        if (keyCode == KeyEvent.KEYCODE_ENTER && event.getAction() == KeyEvent.ACTION_DOWN) {\n            if (!server.isConnected()) {\n                Message message = new Message(getString(R.string.message_not_connected));\n                message.setColor(Message.COLOR_RED);\n                message.setIcon(R.drawable.error);\n                server.getConversation(server.getSelectedConversation()).addMessage(message);\n                onConversationMessage(server.getSelectedConversation());\n            }\n\n            String text = input.getText().toString();\n            input.setText(\"\");\n\n            if (text.equals(\"\")) {\n                // ignore empty messages\n                return true;\n            }\n\n            scrollback.addMessage(text);\n\n            Conversation conversation = deckAdapter.getItem(deck.getSelectedItemPosition());\n\n            if (conversation != null) {\n                if (!text.trim().startsWith(\"/\")) {\n                    if (conversation.getType() != Conversation.TYPE_SERVER) {\n                        String nickname = binder.getService().getConnection(serverId).getNick();\n                        conversation.addMessage(new Message(\"<\" + nickname + \"> \" + text));\n                        binder.getService().getConnection(serverId).sendMessage(conversation.getName(), text);\n                    } else {\n                        Message message = new Message(getString(R.string.chat_only_form_channel));\n                        message.setColor(Message.COLOR_YELLOW);\n                        message.setIcon(R.drawable.warning);\n                        conversation.addMessage(message);\n                    }\n                    onConversationMessage(conversation.getName());\n                } else {\n                    CommandParser.getInstance().parse(text, server, conversation, binder.getService());\n                }\n            }\n\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * On activity result\n     */\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent data)\n    {\n        if (resultCode != RESULT_OK) {\n            // ignore other result codes\n            return;\n        }\n\n        switch (requestCode) {\n            case REQUEST_CODE_SPEECH:\n                ArrayList<String> matches = data.getStringArrayListExtra(RecognizerIntent.EXTRA_RESULTS);\n                if (matches.size() > 0) {\n                    ((EditText) findViewById(R.id.input)).setText(matches.get(0));\n                }\n                break;\n            case REQUEST_CODE_JOIN:\n                joinChannelBuffer = data.getExtras().getString(\"channel\");\n                break;\n            case REQUEST_CODE_USERS:\n                Intent intent = new Intent(this, UserActivity.class);\n                intent.putExtra(Extra.USER, data.getStringExtra(Extra.USER));\n                startActivityForResult(intent, REQUEST_CODE_USER);\n                break;\n            case REQUEST_CODE_NICK_COMPLETION:\n                EditText input = (EditText) findViewById(R.id.input);\n                String src        = data.getExtras().getString(Extra.USER);\n                int start        = input.getSelectionStart();\n                int end        = input.getSelectionEnd();\n\n                if (start == 0) {\n                    src += \":\";\n                }\n\n                src += \" \";\n                input.getText().replace(start, end, src, 0, src.length());\n                // put cursor after inserted text\n                input.setSelection(start + src.length());\n                input.post(new Runnable() {\n                    @Override\n                    public void run() {\n                        // make the softkeyboard come up again (only if no hw keyboard is attached)\n                        EditText input = (EditText) findViewById(R.id.input);\n                        InputMethodManager mgr = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);\n                        mgr.showSoftInput(input, InputMethodManager.SHOW_IMPLICIT);\n                    }\n                });\n                input.requestFocus();\n                break;\n            case REQUEST_CODE_USER:\n                final int actionId = data.getExtras().getInt(Extra.ACTION);\n                final String nickname = data.getExtras().getString(Extra.USER);\n                final IRCConnection connection = binder.getService().getConnection(server.getId());\n                final String conversation = server.getSelectedConversation();\n                final Handler handler = new Handler();\n\n                // XXX: Implement me - The action should be handled after onResume()\n                //                     to catch the broadcasts... now we just wait a second\n                // Yes .. that's very ugly - we need some kind of queue that is handled after onResume()\n\n                new Thread() {\n                    @Override\n                    public void run() {\n                        try {\n                            Thread.sleep(1000);\n                        } catch (InterruptedException e) {\n                            // Do nothing\n                        }\n\n                        String nicknameWithoutPrefix = nickname;\n\n                        while (\n                            nicknameWithoutPrefix.startsWith(\"@\") ||\n                            nicknameWithoutPrefix.startsWith(\"+\") ||\n                            nicknameWithoutPrefix.startsWith(\".\") ||\n                            nicknameWithoutPrefix.startsWith(\"%\")\n                        ) {\n                            // Strip prefix(es) now\n                            nicknameWithoutPrefix = nicknameWithoutPrefix.substring(1);\n                        }\n\n                        switch (actionId) {\n                            case User.ACTION_REPLY:\n                                final String replyText = nicknameWithoutPrefix + \": \";\n                                handler.post(new Runnable() {\n                                    @Override\n                                    public void run() {\n                                        EditText input = (EditText) findViewById(R.id.input);\n                                        input.setText(replyText);\n                                        input.setSelection(replyText.length());\n                                    }\n                                });\n                                break;\n                            case User.ACTION_QUERY:\n                                Conversation query = server.getConversation(nicknameWithoutPrefix);\n                                if (query == null) {\n                                    // Open a query if there's none yet\n                                    query = new Query(nicknameWithoutPrefix);\n                                    server.addConversationl(query);\n\n                                    Intent intent = Broadcast.createConversationIntent(\n                                        Broadcast.CONVERSATION_NEW,\n                                        server.getId(),\n                                        nicknameWithoutPrefix\n                                    );\n                                    binder.getService().sendBroadcast(intent);\n                                }\n                                break;\n                            case User.ACTION_OP:\n                                connection.op(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_DEOP:\n                                connection.deOp(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_VOICE:\n                                connection.voice(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_DEVOICE:\n                                connection.deVoice(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_KICK:\n                                connection.kick(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_BAN:\n                                connection.ban(conversation, nicknameWithoutPrefix + \"!*@*\");\n                                break;\n                        }\n                    }\n                }.start();\n\n                break;\n        }\n    }\n}\n","Method after Refactoring":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2011 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage org.yaaic.activity;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.adapter.DeckAdapter;\nimport org.yaaic.adapter.MessageListAdapter;\nimport org.yaaic.command.CommandParser;\nimport org.yaaic.irc.IRCBinder;\nimport org.yaaic.irc.IRCConnection;\nimport org.yaaic.irc.IRCService;\nimport org.yaaic.layout.NonScalingBackgroundDrawable;\nimport org.yaaic.listener.ConversationClickListener;\nimport org.yaaic.listener.ConversationListener;\nimport org.yaaic.listener.ConversationSelectedListener;\nimport org.yaaic.listener.ServerListener;\nimport org.yaaic.listener.SpeechClickListener;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.model.Extra;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Query;\nimport org.yaaic.model.Scrollback;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.ServerInfo;\nimport org.yaaic.model.Settings;\nimport org.yaaic.model.Status;\nimport org.yaaic.model.User;\nimport org.yaaic.receiver.ConversationReceiver;\nimport org.yaaic.receiver.ServerReceiver;\nimport org.yaaic.view.ConversationSwitcher;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.content.pm.PackageManager;\nimport android.content.pm.ResolveInfo;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.speech.RecognizerIntent;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.Window;\nimport android.view.View.OnKeyListener;\nimport android.view.inputmethod.InputMethodManager;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.Gallery;\nimport android.widget.ImageView;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport android.widget.ViewSwitcher;\n\n/**\n * The server view with a scrollable list of all channels\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class ConversationActivity extends Activity implements ServiceConnection, ServerListener, ConversationListener, OnKeyListener\n{\n    public static final int REQUEST_CODE_SPEECH = 99;\n\n    private static final int REQUEST_CODE_JOIN = 1;\n    private static final int REQUEST_CODE_USERS = 2;\n    private static final int REQUEST_CODE_USER = 3;\n    private static final int REQUEST_CODE_NICK_COMPLETION= 4;\n\n    private int serverId;\n    private Server server;\n    private IRCBinder binder;\n    private ConversationReceiver channelReceiver;\n    private ServerReceiver serverReceiver;\n\n    private ViewSwitcher switcher;\n    private Gallery deck;\n    private DeckAdapter deckAdapter;\n    private Scrollback scrollback;\n    private ConversationSwitcher dots;\n\n    // XXX: This is ugly. This is a buffer for a channel that should be joined after showing the\n    //      JoinActivity. As onActivityResult() is called before onResume() a \"channel joined\"\n    //      broadcast may get lost as the broadcast receivers are registered in onResume() but the\n    //      join command would be called in onActivityResult(). joinChannelBuffer will save the\n    //      channel name in onActivityResult() and run the join command in onResume().\n    private String joinChannelBuffer;\n\n    // flag passed to setInputType later\n    // shall be TYPE_TEXT_FLAG_NO_SUGGESTIONS but it's not supported in all API levels (only in 5+)\n    // We'll set it to 0 if it's not supported\n    private int setInputTypeFlag;\n\n    /**\n     * On create\n     */\n    @Override\n    protected void onCreate(Bundle savedInstanceState)\n    {\n        super.onCreate(savedInstanceState);\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n\n        serverId = getIntent().getExtras().getInt(\"serverId\");\n        server = Yaaic.getInstance().getServerById(serverId);\n        setTitle(\"Yaaic - \" + server.getTitle());\n\n        setContentView(R.layout.conversations);\n\n        ((TextView) findViewById(R.id.title)).setText(server.getTitle());\n        ((EditText) findViewById(R.id.input)).setOnKeyListener(this);\n\n        switcher = (ViewSwitcher) findViewById(R.id.switcher);\n\n        dots = (ConversationSwitcher) findViewById(R.id.dots);\n        dots.setServer(server);\n\n        deckAdapter = new DeckAdapter();\n        deck = (Gallery) findViewById(R.id.deck);\n        deck.setOnItemSelectedListener(new ConversationSelectedListener(server, (TextView) findViewById(R.id.title), dots));\n        deck.setAdapter(deckAdapter);\n        deck.setOnItemClickListener(new ConversationClickListener(deckAdapter, switcher));\n        deck.setBackgroundDrawable(new NonScalingBackgroundDrawable(this, deck, R.drawable.background));\n\n        if (server.getStatus() == Status.PRE_CONNECTING) {\n            server.clearConversations();\n            deckAdapter.clearConversations();\n        }\n\n        // Optimization : cache field lookups\n        Collection<Conversation> mConversations = server.getConversations();\n\n        for (Conversation conversation : mConversations) {\n            onNewConversation(conversation.getName());\n        }\n\n        // keep compatibility with api level 3\n        if ((android.os.Build.VERSION.SDK.charAt(0) - '0') >= 5) {\n            setInputTypeFlag = 0x80000; // InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS\n        }\n        else {\n            setInputTypeFlag = 0;\n        }\n\n        // Create a new scrollback history\n        scrollback = new Scrollback();\n    }\n\n    /**\n     * On resume\n     */\n    @Override\n    public void onResume()\n    {\n        // register the receivers as early as possible, otherwise we may loose a broadcast message\n        channelReceiver = new ConversationReceiver(server.getId(), this);\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_MESSAGE));\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_NEW));\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_REMOVE));\n\n        serverReceiver = new ServerReceiver(this);\n        registerReceiver(serverReceiver, new IntentFilter(Broadcast.SERVER_UPDATE));\n\n        super.onResume();\n\n        // Check if speech recognition is enabled and available\n        if (new Settings(this).isVoiceRecognitionEnabled()) {\n            PackageManager pm = getPackageManager();\n            Button speechButton = (Button) findViewById(R.id.speech);\n            List<ResolveInfo> activities = pm.queryIntentActivities(new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH), 0);\n            if (activities.size() != 0) {\n                ((Button) findViewById(R.id.speech)).setOnClickListener(new SpeechClickListener(this));\n                speechButton.setVisibility(View.VISIBLE);\n            }\n        }\n\n        ((ImageView) findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\n        // Start service\n        Intent intent = new Intent(this, IRCService.class);\n        intent.setAction(IRCService.ACTION_FOREGROUND);\n        startService(intent);\n        bindService(intent, this, 0);\n\n        if (!server.isConnected()) {\n            ((EditText) findViewById(R.id.input)).setEnabled(false);\n        } else {\n            ((EditText) findViewById(R.id.input)).setEnabled(true);\n        }\n\n        // Optimization - cache field lookup\n        Collection<Conversation> mConversations = server.getConversations();\n        MessageListAdapter mAdapter;\n\n        // Fill view with messages that have been buffered while paused\n        for (Conversation conversation : mConversations) {\n            mAdapter = conversation.getMessageListAdapter();\n\n            if (mAdapter != null) {\n                mAdapter.addBulkMessages(conversation.getBuffer());\n                conversation.clearBuffer();\n            }\n        }\n\n        // Join channel that has been selected in JoinActivity (onActivityResult())\n        if (joinChannelBuffer != null) {\n            new Thread() {\n                @Override\n                public void run() {\n                    binder.getService().getConnection(serverId).joinChannel(joinChannelBuffer);\n                    joinChannelBuffer = null;\n                }\n            }.start();\n        }\n    }\n\n    /**\n     * On Pause\n     */\n    @Override\n    public void onPause()\n    {\n        super.onPause();\n\n        if (binder != null && binder.getService() != null) {\n            binder.getService().checkServiceStatus();\n        }\n\n        unbindService(this);\n        unregisterReceiver(channelReceiver);\n        unregisterReceiver(serverReceiver);\n    }\n\n    /**\n     * On service connected\n     */\n    @Override\n    public void onServiceConnected(ComponentName name, IBinder service)\n    {\n        this.binder = (IRCBinder) service;\n\n        // connect to irc server if connect has been requested\n        if (server.getStatus() == Status.PRE_CONNECTING && getIntent().hasExtra(\"connect\")) {\n            server.setStatus(Status.CONNECTING);\n            binder.connect(server);\n        }\n    }\n\n    /**\n     * On service disconnected\n     */\n    @Override\n    public void onServiceDisconnected(ComponentName name)\n    {\n        this.binder = null;\n    }\n\n    /**\n     * On options menu requested\n     */\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu)\n    {\n        super.onCreateOptionsMenu(menu);\n\n        // inflate from xml\n        MenuInflater inflater = getMenuInflater();\n        inflater.inflate(R.menu.conversations, menu);\n\n        return true;\n    }\n\n    /**\n     * On prepare options menu\n     */\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu)\n    {\n        menu.getItem(0).setEnabled(server.isConnected()); // join\n        menu.getItem(1).setEnabled(server.isConnected()); // users\n        menu.getItem(2).setEnabled(server.isConnected()); // close\n\n        return true;\n    }\n\n    /**\n     * On menu item selected\n     */\n    @Override\n    public boolean onMenuItemSelected(int featureId, MenuItem item)\n    {\n        switch (item.getItemId()) {\n            case R.id.disconnect:\n                server.setStatus(Status.DISCONNECTED);\n                binder.getService().getConnection(serverId).quitServer();\n                server.clearConversations();\n                setResult(RESULT_OK);\n                finish();\n                break;\n            case R.id.close:\n                Conversation conversationToClose = deckAdapter.getItem(deck.getSelectedItemPosition());\n                // Make sure we part a channel when closing the channel conversation\n                if (conversationToClose.getType() == Conversation.TYPE_CHANNEL) {\n                    binder.getService().getConnection(serverId).partChannel(conversationToClose.getName());\n                }\n                else if (conversationToClose.getType() == Conversation.TYPE_QUERY) {\n                    server.removeConversation(conversationToClose.getName());\n                    onRemoveConversation(conversationToClose.getName());\n                } else {\n                    Toast.makeText(this, getResources().getString(R.string.close_server_window), Toast.LENGTH_SHORT).show();\n                }\n                break;\n            case R.id.join:\n                startActivityForResult(new Intent(this, JoinActivity.class), REQUEST_CODE_JOIN);\n                break;\n            case R.id.users:\n                Conversation conversationForUserList = deckAdapter.getItem(deck.getSelectedItemPosition());\n                if (conversationForUserList.getType() == Conversation.TYPE_CHANNEL) {\n                    Intent intent = new Intent(this, UsersActivity.class);\n                    intent.putExtra(\n                        Extra.USERS,\n                        binder.getService().getConnection(server.getId()).getUsersAsStringArray(\n                            conversationForUserList.getName()\n                        )\n                    );\n                    startActivityForResult(intent, REQUEST_CODE_USERS);\n                } else {\n                    Toast.makeText(this, getResources().getString(R.string.only_usable_from_channel), Toast.LENGTH_SHORT).show();\n                }\n                break;\n        }\n\n        return true;\n    }\n\n    /**\n     * Get server object assigned to this activity\n     * \n     * @return the server object\n     */\n    public Server getServer()\n    {\n        return server;\n    }\n\n    /**\n     * On conversation message\n     */\n    @Override\n    public void onConversationMessage(String target)\n    {\n        Conversation conversation = server.getConversation(target);\n\n        if (conversation == null) {\n            // In an early state it can happen that the conversation object\n            // is not created yet.\n            return;\n        }\n\n        MessageListAdapter adapter = conversation.getMessageListAdapter();\n\n        while(conversation.hasBufferedMessages()) {\n            Message message = conversation.pollBufferedMessage();\n\n            if (adapter != null) {\n                adapter.addMessage(message);\n                int status;\n                switch (message.getType())\n                {\n                    case Message.TYPE_MISC:\n                        status = Conversation.STATUS_MISC;\n                        break;\n                    default:\n                        status = Conversation.STATUS_MESSAGE;\n                        break;\n                }\n                conversation.setStatus(status);\n            }\n        }\n\n        if (dots != null) {\n            dots.invalidate();\n        }\n    }\n\n    /**\n     * On new conversation\n     */\n    @Override\n    public void onNewConversation(String target)\n    {\n        deckAdapter.addItem(server.getConversation(target));\n\n        if (!deckAdapter.isSwitched()) {\n            // Scroll to new conversation\n            deck.setSelection(deckAdapter.getCount() - 1);\n        }\n    }\n\n    /**\n     * On conversation remove\n     */\n    @Override\n    public void onRemoveConversation(String target)\n    {\n        deckAdapter.removeItem(target);\n\n        if (deckAdapter.isSwitched()) {\n            switcher.showNext();\n            switcher.removeView(deckAdapter.getSwitchedView());\n            deckAdapter.setSwitched(null, null);\n        }\n    }\n\n    /**\n     * On server status update\n     */\n    @Override\n    public void onStatusUpdate()\n    {\n        ((ImageView) findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\n        EditText input = (EditText) findViewById(R.id.input);\n\n        if (server.isConnected()) {\n            input.setEnabled(true);\n        } else {\n            input.setEnabled(false);\n\n            if (server.getStatus() == Status.CONNECTING) {\n                deckAdapter.clearConversations();\n                deckAdapter.addItem(server.getConversation(ServerInfo.DEFAULT_NAME));\n                return;\n            }\n\n            if (!binder.getService().getSettings().isReconnectEnabled()) {\n                AlertDialog.Builder builder = new AlertDialog.Builder(this);\n                builder.setMessage(getResources().getString(R.string.reconnect_after_disconnect, server.getTitle()))\n                .setCancelable(false)\n                .setPositiveButton(\"Yes\", new DialogInterface.OnClickListener() {\n                    @Override\n                    public void onClick(DialogInterface dialog, int id) {\n                        binder.getService().getConnection(server.getId()).setAutojoinChannels(\n                            server.getCurrentChannelNames()\n                        );\n                        server.clearConversations();\n                        deckAdapter.clearConversations();\n                        deckAdapter.addItem(server.getConversation(ServerInfo.DEFAULT_NAME));\n                        binder.connect(server);\n                    }\n                })\n                .setNegativeButton(getString(R.string.negative_button), new DialogInterface.OnClickListener() {\n                    @Override\n                    public void onClick(DialogInterface dialog, int id) {\n                        dialog.cancel();\n                    }\n                });\n                AlertDialog alert = builder.create();\n                alert.show();\n            }\n        }\n    }\n\n    /**\n     * On key down\n     *\n     * XXX: As we only track the back key: Android >= 2.0 will call a method called onBackPressed()\n     */\n    @Override\n    public boolean onKeyDown(int keyCode, KeyEvent event)\n    {\n        if (keyCode == KeyEvent.KEYCODE_BACK && event.getRepeatCount() == 0) {\n            if (deckAdapter.isSwitched()) {\n                switcher.showNext();\n                switcher.removeView(deckAdapter.getSwitchedView());\n                deckAdapter.setSwitched(null, null);\n                return true;\n            }\n        }\n        return super.onKeyDown(keyCode, event);\n    }\n\n    /**\n     * On key pressed (input line)\n     */\n    @Override\n    public boolean onKey(View view, int keyCode, KeyEvent event)\n    {\n        EditText input = (EditText) view;\n\n        if (keyCode == KeyEvent.KEYCODE_DPAD_UP && event.getAction() == KeyEvent.ACTION_DOWN) {\n            String message = scrollback.goBack();\n            if (message != null) {\n                input.setText(message);\n            }\n            return true;\n        }\n\n        if (keyCode == KeyEvent.KEYCODE_DPAD_DOWN && event.getAction() == KeyEvent.ACTION_DOWN) {\n            String message = scrollback.goForward();\n            if (message != null) {\n                input.setText(message);\n            }\n            return true;\n        }\n\n        // Nick completion\n        if (keyCode == KeyEvent.KEYCODE_SEARCH && event.getAction() == KeyEvent.ACTION_DOWN) {\n            String text = input.getText().toString();\n\n            if (text.length() <= 0) {\n                return true;\n            }\n\n            String[] tokens = text.split(\"[\\\\s,.-]+\");\n\n            if (tokens.length <= 0) {\n                return true;\n            }\n\n            String word = tokens[tokens.length - 1].toLowerCase();\n            tokens[tokens.length - 1] = null;\n\n            int begin   = input.getSelectionStart();\n            int end     = input.getSelectionEnd();\n            int cursor  = Math.min(begin, end);\n            int sel_end = Math.max(begin, end);\n\n            boolean in_selection = cursor != sel_end;\n\n            if (in_selection) {\n                word = text.substring(cursor, sel_end);\n            } else {\n                // use the word at the curent cursor position\n                while(true) {\n                    cursor -= 1;\n                    if (cursor <= 0 || text.charAt(cursor) == ' ') {\n                        break;\n                    }\n                }\n\n                if (cursor < 0) {\n                    cursor = 0;\n                }\n\n                if (text.charAt(cursor) == ' ') {\n                    cursor += 1;\n                }\n\n                sel_end = text.indexOf(' ', cursor);\n\n                if (sel_end == -1) {\n                    sel_end = text.length();\n                }\n\n                word = text.substring(cursor, sel_end);\n            }\n            // Log.d(\"Yaaic\", \"Trying to complete nick: \" + word);\n\n            Conversation conversationForUserList = deckAdapter.getItem(deck.getSelectedItemPosition());\n\n            String[] users = null;\n\n            if (conversationForUserList.getType() == Conversation.TYPE_CHANNEL) {\n                users = binder.getService().getConnection(server.getId()).getUsersAsStringArray(\n                    conversationForUserList.getName()\n                );\n            }\n\n            // go through users and add matches\n            if (users != null) {\n                List<Integer> result = new ArrayList<Integer>();\n\n                for (int i = 0; i < users.length; i++) {\n                    if (users[i].toLowerCase().startsWith(word)) {\n                        result.add(Integer.valueOf(i));\n                    }\n                }\n\n                if (result.size() == 1) {\n                    String text1 = users[result.get(0).intValue()];\n\n                    if (cursor == 0) {\n                        text1 += \":\";\n                    }\n\n                    text1 += \" \";\n                    input.getText().replace(cursor, sel_end, text1, 0, text1.length());\n                    int old = input.getInputType();\n                    input.setInputType(old | setInputTypeFlag);\n                } else if (result.size() > 0) {\n                    Intent intent  = new Intent(this, UsersActivity.class);\n                    String[] extra = new String[result.size()];\n                    int i = 0;\n\n                    for (Integer n : result) {\n                        extra[i++] = users[n.intValue()];\n                    }\n\n                    input.setSelection(cursor, sel_end);\n                    intent.putExtra(Extra.USERS, extra);\n                    startActivityForResult(intent, REQUEST_CODE_NICK_COMPLETION);\n                }\n            }\n            return true;\n        }\n\n        if (keyCode == KeyEvent.KEYCODE_ENTER && event.getAction() == KeyEvent.ACTION_DOWN) {\n            if (!server.isConnected()) {\n                Message message = new Message(getString(R.string.message_not_connected));\n                message.setColor(Message.COLOR_RED);\n                message.setIcon(R.drawable.error);\n                server.getConversation(server.getSelectedConversation()).addMessage(message);\n                onConversationMessage(server.getSelectedConversation());\n            }\n\n            String text = input.getText().toString();\n            input.setText(\"\");\n\n            if (text.equals(\"\")) {\n                // ignore empty messages\n                return true;\n            }\n\n            scrollback.addMessage(text);\n\n            Conversation conversation = deckAdapter.getItem(deck.getSelectedItemPosition());\n\n            if (conversation != null) {\n                if (!text.trim().startsWith(\"/\")) {\n                    if (conversation.getType() != Conversation.TYPE_SERVER) {\n                        String nickname = binder.getService().getConnection(serverId).getNick();\n                        conversation.addMessage(new Message(\"<\" + nickname + \"> \" + text));\n                        binder.getService().getConnection(serverId).sendMessage(conversation.getName(), text);\n                    } else {\n                        Message message = new Message(getString(R.string.chat_only_form_channel));\n                        message.setColor(Message.COLOR_YELLOW);\n                        message.setIcon(R.drawable.warning);\n                        conversation.addMessage(message);\n                    }\n                    onConversationMessage(conversation.getName());\n                } else {\n                    CommandParser.getInstance().parse(text, server, conversation, binder.getService());\n                }\n            }\n\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * On activity result\n     */\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent data)\n    {\n        if (resultCode != RESULT_OK) {\n            // ignore other result codes\n            return;\n        }\n\n        switch (requestCode) {\n            case REQUEST_CODE_SPEECH:\n                ArrayList<String> matches = data.getStringArrayListExtra(RecognizerIntent.EXTRA_RESULTS);\n                if (matches.size() > 0) {\n                    ((EditText) findViewById(R.id.input)).setText(matches.get(0));\n                }\n                break;\n            case REQUEST_CODE_JOIN:\n                joinChannelBuffer = data.getExtras().getString(\"channel\");\n                break;\n            case REQUEST_CODE_USERS:\n                Intent intent = new Intent(this, UserActivity.class);\n                intent.putExtra(Extra.USER, data.getStringExtra(Extra.USER));\n                startActivityForResult(intent, REQUEST_CODE_USER);\n                break;\n            case REQUEST_CODE_NICK_COMPLETION:\n                EditText input = (EditText) findViewById(R.id.input);\n                String src        = data.getExtras().getString(Extra.USER);\n                int start        = input.getSelectionStart();\n                int end        = input.getSelectionEnd();\n\n                if (start == 0) {\n                    src += \":\";\n                }\n\n                src += \" \";\n                input.getText().replace(start, end, src, 0, src.length());\n                // put cursor after inserted text\n                input.setSelection(start + src.length());\n                input.post(new Runnable() {\n                    @Override\n                    public void run() {\n                        // make the softkeyboard come up again (only if no hw keyboard is attached)\n                        EditText input = (EditText) findViewById(R.id.input);\n                        InputMethodManager mgr = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);\n                        mgr.showSoftInput(input, InputMethodManager.SHOW_IMPLICIT);\n                    }\n                });\n                input.requestFocus();\n                break;\n            case REQUEST_CODE_USER:\n                final int actionId = data.getExtras().getInt(Extra.ACTION);\n                final String nickname = data.getExtras().getString(Extra.USER);\n                final IRCConnection connection = binder.getService().getConnection(server.getId());\n                final String conversation = server.getSelectedConversation();\n                final Handler handler = new Handler();\n\n                // XXX: Implement me - The action should be handled after onResume()\n                //                     to catch the broadcasts... now we just wait a second\n                // Yes .. that's very ugly - we need some kind of queue that is handled after onResume()\n\n                new Thread() {\n                    @Override\n                    public void run() {\n                        try {\n                            Thread.sleep(1000);\n                        } catch (InterruptedException e) {\n                            // Do nothing\n                        }\n\n                        String nicknameWithoutPrefix = nickname;\n\n                        while (\n                            nicknameWithoutPrefix.startsWith(\"@\") ||\n                            nicknameWithoutPrefix.startsWith(\"+\") ||\n                            nicknameWithoutPrefix.startsWith(\".\") ||\n                            nicknameWithoutPrefix.startsWith(\"%\")\n                        ) {\n                            // Strip prefix(es) now\n                            nicknameWithoutPrefix = nicknameWithoutPrefix.substring(1);\n                        }\n\n                        switch (actionId) {\n                            case User.ACTION_REPLY:\n                                final String replyText = nicknameWithoutPrefix + \": \";\n                                handler.post(new Runnable() {\n                                    @Override\n                                    public void run() {\n                                        EditText input = (EditText) findViewById(R.id.input);\n                                        input.setText(replyText);\n                                        input.setSelection(replyText.length());\n                                    }\n                                });\n                                break;\n                            case User.ACTION_QUERY:\n                                Conversation query = server.getConversation(nicknameWithoutPrefix);\n                                if (query == null) {\n                                    // Open a query if there's none yet\n                                    query = new Query(nicknameWithoutPrefix);\n                                    server.addConversationl(query);\n\n                                    Intent intent = Broadcast.createConversationIntent(\n                                        Broadcast.CONVERSATION_NEW,\n                                        server.getId(),\n                                        nicknameWithoutPrefix\n                                    );\n                                    binder.getService().sendBroadcast(intent);\n                                }\n                                break;\n                            case User.ACTION_OP:\n                                connection.op(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_DEOP:\n                                connection.deOp(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_VOICE:\n                                connection.voice(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_DEVOICE:\n                                connection.deVoice(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_KICK:\n                                connection.kick(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_BAN:\n                                connection.ban(conversation, nicknameWithoutPrefix + \"!*@*\");\n                                break;\n                        }\n                    }\n                }.start();\n\n                break;\n        }\n    }\n}\n","lineNo":396}
{"Smelly Sample":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2011 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage org.yaaic.adapter;\n\nimport java.util.ArrayList;\n\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.model.Server;\n\nimport android.content.Context;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.BaseAdapter;\nimport android.widget.ImageView;\nimport android.widget.TextView;\n\n/**\n * Adapter for server lists\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class ServerListAdapter extends BaseAdapter\n{\n    private ArrayList<Server> servers;\n\n    /**\n     * Create a new adapter for server lists\n     */\n    public ServerListAdapter()\n    {\n        loadServers();\n    }\n\n    /**\n     * Load servers from database\n     *\n     * Delegate call to yaaic instance\n     */\n    public void loadServers()\n    {\n        servers = Yaaic.getInstance().getServersAsArrayList();\n        notifyDataSetChanged();\n    }\n\n    /**\n     * Get number of items\n     */\n    @Override\n    public int getCount()\n    {\n        int size = servers.size();\n\n        // Display \"Add server\" item\n        if (size == 0) {\n            return 1;\n        }\n\n        return size;\n    }\n\n    /**\n     * Get item at position\n     * \n     * @param position\n     */\n    @Override\n    public Server getItem(int position)\n    {\n        if (servers.size() == 0) {\n            return null; // No server object for the \"add server\" view\n        }\n\n        return servers.get(position);\n    }\n\n    /**\n     * Get id of item at position\n     * \n     * @param position\n     */\n    @Override\n    public long getItemId(int position)\n    {\n        if (servers.size() == 0) {\n            return 0;\n        }\n\n        return getItem(position).getId();\n    }\n\n    /**\n     * Get view for item at given position\n     * \n     * @param position\n     * @param convertView\n     * @param parent\n     */\n    @Override\n    public View getView(int position, View convertView, ViewGroup parent)\n    {\n        Server server = getItem(position);\n\n        LayoutInflater inflater = (LayoutInflater) parent.getContext().getSystemService(Context.LAYOUT_INFLATER_SERVICE);\n\n        if (server == null) {\n            // Return \"Add server\" view\n            return inflater.inflate(R.layout.addserveritem, null);\n        }\n\n        View v = inflater.inflate(R.layout.serveritem, null);\n\n        ((TextView) v.findViewById(R.id.title)).setText(server.getTitle());\n        ((TextView) v.findViewById(R.id.host)).setText(server.getIdentity().getNickname() + \" @ \" + server.getHost() + \" : \" + server.getPort());\n\n        ((ImageView) v.findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\n        return v;\n    }\n}\n","Method after Refactoring":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2011 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage org.yaaic.adapter;\n\nimport java.util.ArrayList;\n\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.model.Server;\n\nimport android.content.Context;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.BaseAdapter;\nimport android.widget.ImageView;\nimport android.widget.TextView;\n\n/**\n * Adapter for server lists\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class ServerListAdapter extends BaseAdapter\n{\n    private ArrayList<Server> servers;\n\n    /**\n     * Create a new adapter for server lists\n     */\n    public ServerListAdapter()\n    {\n        loadServers();\n    }\n\n    /**\n     * Load servers from database\n     *\n     * Delegate call to yaaic instance\n     */\n    public void loadServers()\n    {\n        servers = Yaaic.getInstance().getServersAsArrayList();\n        notifyDataSetChanged();\n    }\n\n    /**\n     * Get number of items\n     */\n    @Override\n    public int getCount()\n    {\n        int size = servers.size();\n\n        // Display \"Add server\" item\n        if (size == 0) {\n            return 1;\n        }\n\n        return size;\n    }\n\n    /**\n     * Get item at position\n     * \n     * @param position\n     */\n    @Override\n    public Server getItem(int position)\n    {\n        if (servers.size() == 0) {\n            return null; // No server object for the \"add server\" view\n        }\n\n        return servers.get(position);\n    }\n\n    /**\n     * Get id of item at position\n     * \n     * @param position\n     */\n    @Override\n    public long getItemId(int position)\n    {\n        if (servers.size() == 0) {\n            return 0;\n        }\n\n        return getItem(position).getId();\n    }\n\n    /**\n     * Get view for item at given position\n     * \n     * @param position\n     * @param convertView\n     * @param parent\n     */\n    @Override\n    public View getView(int position, View convertView, ViewGroup parent)\n    {\n        Server server = getItem(position);\n\n        LayoutInflater inflater = (LayoutInflater) parent.getContext().getSystemService(Context.LAYOUT_INFLATER_SERVICE);\n\n        if (server == null) {\n            // Return \"Add server\" view\n            return inflater.inflate(R.layout.addserveritem, null);\n        }\n\n        View v = inflater.inflate(R.layout.serveritem, null);\n\n        TextView titleView = (TextView) v.findViewById(R.id.title);\n        titleView.setText(server.getTitle());\n\n        TextView hostView = (TextView) v.findViewById(R.id.host);\n        hostView.setText(server.getIdentity().getNickname() + \" @ \" + server.getHost() + \" : \" + server.getPort());\n\n        if (server.isConnected()) {\n            titleView.setTextColor(0xFFcecfce);\n            hostView.setTextColor(0xFFcecfce);\n        } else {\n            titleView.setTextColor(0xFF767776);\n            hostView.setTextColor(0xFF767776);\n        }\n\n        ((ImageView) v.findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\n        return v;\n    }\n}\n","lineNo":132}
{"Smelly Sample":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2011 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage org.yaaic.adapter;\n\nimport java.util.ArrayList;\n\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.model.Server;\n\nimport android.content.Context;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.BaseAdapter;\nimport android.widget.ImageView;\nimport android.widget.TextView;\n\n/**\n * Adapter for server lists\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class ServerListAdapter extends BaseAdapter\n{\n    private ArrayList<Server> servers;\n\n    /**\n     * Create a new adapter for server lists\n     */\n    public ServerListAdapter()\n    {\n        loadServers();\n    }\n\n    /**\n     * Load servers from database\n     *\n     * Delegate call to yaaic instance\n     */\n    public void loadServers()\n    {\n        servers = Yaaic.getInstance().getServersAsArrayList();\n        notifyDataSetChanged();\n    }\n\n    /**\n     * Get number of items\n     */\n    @Override\n    public int getCount()\n    {\n        int size = servers.size();\n\n        // Display \"Add server\" item\n        if (size == 0) {\n            return 1;\n        }\n\n        return size;\n    }\n\n    /**\n     * Get item at position\n     * \n     * @param position\n     */\n    @Override\n    public Server getItem(int position)\n    {\n        if (servers.size() == 0) {\n            return null; // No server object for the \"add server\" view\n        }\n\n        return servers.get(position);\n    }\n\n    /**\n     * Get id of item at position\n     * \n     * @param position\n     */\n    @Override\n    public long getItemId(int position)\n    {\n        if (servers.size() == 0) {\n            return 0;\n        }\n\n        return getItem(position).getId();\n    }\n\n    /**\n     * Get view for item at given position\n     * \n     * @param position\n     * @param convertView\n     * @param parent\n     */\n    @Override\n    public View getView(int position, View convertView, ViewGroup parent)\n    {\n        Server server = getItem(position);\n\n        LayoutInflater inflater = (LayoutInflater) parent.getContext().getSystemService(Context.LAYOUT_INFLATER_SERVICE);\n\n        if (server == null) {\n            // Return \"Add server\" view\n            return inflater.inflate(R.layout.addserveritem, null);\n        }\n\n        View v = inflater.inflate(R.layout.serveritem, null);\n\n        ((TextView) v.findViewById(R.id.title)).setText(server.getTitle());\n        ((TextView) v.findViewById(R.id.host)).setText(server.getIdentity().getNickname() + \" @ \" + server.getHost() + \" : \" + server.getPort());\n\n        ((ImageView) v.findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\n        return v;\n    }\n}\n","Method after Refactoring":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2011 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage org.yaaic.adapter;\n\nimport java.util.ArrayList;\n\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.model.Server;\n\nimport android.content.Context;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.BaseAdapter;\nimport android.widget.ImageView;\nimport android.widget.TextView;\n\n/**\n * Adapter for server lists\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class ServerListAdapter extends BaseAdapter\n{\n    private ArrayList<Server> servers;\n\n    /**\n     * Create a new adapter for server lists\n     */\n    public ServerListAdapter()\n    {\n        loadServers();\n    }\n\n    /**\n     * Load servers from database\n     *\n     * Delegate call to yaaic instance\n     */\n    public void loadServers()\n    {\n        servers = Yaaic.getInstance().getServersAsArrayList();\n        notifyDataSetChanged();\n    }\n\n    /**\n     * Get number of items\n     */\n    @Override\n    public int getCount()\n    {\n        int size = servers.size();\n\n        // Display \"Add server\" item\n        if (size == 0) {\n            return 1;\n        }\n\n        return size;\n    }\n\n    /**\n     * Get item at position\n     * \n     * @param position\n     */\n    @Override\n    public Server getItem(int position)\n    {\n        if (servers.size() == 0) {\n            return null; // No server object for the \"add server\" view\n        }\n\n        return servers.get(position);\n    }\n\n    /**\n     * Get id of item at position\n     * \n     * @param position\n     */\n    @Override\n    public long getItemId(int position)\n    {\n        if (servers.size() == 0) {\n            return 0;\n        }\n\n        return getItem(position).getId();\n    }\n\n    /**\n     * Get view for item at given position\n     * \n     * @param position\n     * @param convertView\n     * @param parent\n     */\n    @Override\n    public View getView(int position, View convertView, ViewGroup parent)\n    {\n        Server server = getItem(position);\n\n        LayoutInflater inflater = (LayoutInflater) parent.getContext().getSystemService(Context.LAYOUT_INFLATER_SERVICE);\n\n        if (server == null) {\n            // Return \"Add server\" view\n            return inflater.inflate(R.layout.addserveritem, null);\n        }\n\n        View v = inflater.inflate(R.layout.serveritem, null);\n\n        TextView titleView = (TextView) v.findViewById(R.id.title);\n        titleView.setText(server.getTitle());\n\n        TextView hostView = (TextView) v.findViewById(R.id.host);\n        hostView.setText(server.getIdentity().getNickname() + \" @ \" + server.getHost() + \" : \" + server.getPort());\n\n        if (server.isConnected()) {\n            titleView.setTextColor(0xFFcecfce);\n            hostView.setTextColor(0xFFcecfce);\n        } else {\n            titleView.setTextColor(0xFF767776);\n            hostView.setTextColor(0xFF767776);\n        }\n\n        ((ImageView) v.findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\n        return v;\n    }\n}\n","lineNo":135}
{"Smelly Sample":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2011 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage org.yaaic.activity;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.adapter.DeckAdapter;\nimport org.yaaic.adapter.MessageListAdapter;\nimport org.yaaic.command.CommandParser;\nimport org.yaaic.irc.IRCBinder;\nimport org.yaaic.irc.IRCConnection;\nimport org.yaaic.irc.IRCService;\nimport org.yaaic.layout.NonScalingBackgroundDrawable;\nimport org.yaaic.listener.ConversationClickListener;\nimport org.yaaic.listener.ConversationListener;\nimport org.yaaic.listener.ConversationSelectedListener;\nimport org.yaaic.listener.ServerListener;\nimport org.yaaic.listener.SpeechClickListener;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.model.Extra;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Scrollback;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.ServerInfo;\nimport org.yaaic.model.Settings;\nimport org.yaaic.model.Status;\nimport org.yaaic.receiver.ConversationReceiver;\nimport org.yaaic.receiver.ServerReceiver;\nimport org.yaaic.view.ConversationSwitcher;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.content.pm.PackageManager;\nimport android.content.pm.ResolveInfo;\nimport android.os.Bundle;\nimport android.os.IBinder;\nimport android.speech.RecognizerIntent;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.View.OnKeyListener;\nimport android.view.Window;\nimport android.view.inputmethod.InputMethodManager;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.Gallery;\nimport android.widget.ImageView;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport android.widget.ViewSwitcher;\n\n/**\n * The server view with a scrollable list of all channels\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class ConversationActivity extends Activity implements ServiceConnection, ServerListener, ConversationListener, OnKeyListener\n{\n    public static final int REQUEST_CODE_SPEECH = 99;\n\n    private static final int REQUEST_CODE_JOIN = 1;\n    private static final int REQUEST_CODE_USERS = 2;\n    private static final int REQUEST_CODE_USER = 3;\n    private static final int REQUEST_CODE_NICK_COMPLETION= 4;\n\n    private int serverId;\n    private Server server;\n    private IRCBinder binder;\n    private ConversationReceiver channelReceiver;\n    private ServerReceiver serverReceiver;\n\n    private ViewSwitcher switcher;\n    private Gallery deck;\n    private DeckAdapter deckAdapter;\n    private Scrollback scrollback;\n    private ConversationSwitcher dots;\n\n    // XXX: This is ugly. This is a buffer for a channel that should be joined after showing the\n    //      JoinActivity. As onActivityResult() is called before onResume() a \"channel joined\"\n    //      broadcast may get lost as the broadcast receivers are registered in onResume() but the\n    //      join command would be called in onActivityResult(). joinChannelBuffer will save the\n    //      channel name in onActivityResult() and run the join command in onResume().\n    private String joinChannelBuffer;\n\n    // flag passed to setInputType later\n    // shall be TYPE_TEXT_FLAG_NO_SUGGESTIONS but it's not supported in all API levels (only in 5+)\n    // We'll set it to 0 if it's not supported\n    private int setInputTypeFlag;\n\n    /**\n     * On create\n     */\n    @Override\n    protected void onCreate(Bundle savedInstanceState)\n    {\n        super.onCreate(savedInstanceState);\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n\n        serverId = getIntent().getExtras().getInt(\"serverId\");\n        server = Yaaic.getInstance().getServerById(serverId);\n        setTitle(\"Yaaic - \" + server.getTitle());\n\n        setContentView(R.layout.conversations);\n\n        ((TextView) findViewById(R.id.title)).setText(server.getTitle());\n        ((EditText) findViewById(R.id.input)).setOnKeyListener(this);\n\n        switcher = (ViewSwitcher) findViewById(R.id.switcher);\n\n        dots = (ConversationSwitcher) findViewById(R.id.dots);\n        dots.setServer(server);\n\n        deckAdapter = new DeckAdapter();\n        deck = (Gallery) findViewById(R.id.deck);\n        deck.setOnItemSelectedListener(new ConversationSelectedListener(server, (TextView) findViewById(R.id.title), dots));\n        deck.setAdapter(deckAdapter);\n        deck.setOnItemClickListener(new ConversationClickListener(deckAdapter, switcher));\n        deck.setBackgroundDrawable(new NonScalingBackgroundDrawable(this, deck, R.drawable.background));\n\n        if (server.getStatus() == Status.PRE_CONNECTING) {\n            server.clearConversations();\n            deckAdapter.clearConversations();\n        }\n\n        // Optimization : cache field lookups\n        Collection<Conversation> mConversations = server.getConversations();\n\n        for (Conversation conversation : mConversations) {\n            onNewConversation(conversation.getName());\n        }\n\n        // keep compatibility with api level 3\n        if ((android.os.Build.VERSION.SDK.charAt(0) - '0') >= 5) {\n            setInputTypeFlag = 0x80000; // InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS\n        }\n        else {\n            setInputTypeFlag = 0;\n        }\n\n        // Create a new scrollback history\n        scrollback = new Scrollback();\n    }\n\n    /**\n     * On resume\n     */\n    @Override\n    public void onResume()\n    {\n        // register the receivers as early as possible, otherwise we may loose a broadcast message\n        channelReceiver = new ConversationReceiver(server.getId(), this);\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_MESSAGE));\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_NEW));\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_REMOVE));\n\n        serverReceiver = new ServerReceiver(this);\n        registerReceiver(serverReceiver, new IntentFilter(Broadcast.SERVER_UPDATE));\n\n        super.onResume();\n\n        // Check if speech recognition is enabled and available\n        if (new Settings(this).isVoiceRecognitionEnabled()) {\n            PackageManager pm = getPackageManager();\n            Button speechButton = (Button) findViewById(R.id.speech);\n            List<ResolveInfo> activities = pm.queryIntentActivities(new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH), 0);\n            if (activities.size() != 0) {\n                ((Button) findViewById(R.id.speech)).setOnClickListener(new SpeechClickListener(this));\n                speechButton.setVisibility(View.VISIBLE);\n            }\n        }\n\n        ((ImageView) findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\n        // Start service\n        Intent intent = new Intent(this, IRCService.class);\n        intent.setAction(IRCService.ACTION_FOREGROUND);\n        startService(intent);\n        bindService(intent, this, 0);\n\n        if (!server.isConnected()) {\n            ((EditText) findViewById(R.id.input)).setEnabled(false);\n        } else {\n            ((EditText) findViewById(R.id.input)).setEnabled(true);\n        }\n\n        // Optimization - cache field lookup\n        Collection<Conversation> mConversations = server.getConversations();\n        MessageListAdapter mAdapter;\n\n        // Fill view with messages that have been buffered while paused\n        for (Conversation conversation : mConversations) {\n            mAdapter = conversation.getMessageListAdapter();\n\n            if (mAdapter != null) {\n                mAdapter.addBulkMessages(conversation.getBuffer());\n                conversation.clearBuffer();\n            }\n        }\n\n        // Join channel that has been selected in JoinActivity (onActivityResult())\n        if (joinChannelBuffer != null) {\n            new Thread() {\n                @Override\n                public void run() {\n                    binder.getService().getConnection(serverId).joinChannel(joinChannelBuffer);\n                    joinChannelBuffer = null;\n                }\n            }.start();\n        }\n    }\n\n    /**\n     * On Pause\n     */\n    @Override\n    public void onPause()\n    {\n        super.onPause();\n\n        if (binder != null && binder.getService() != null) {\n            binder.getService().checkServiceStatus();\n        }\n\n        unbindService(this);\n        unregisterReceiver(channelReceiver);\n        unregisterReceiver(serverReceiver);\n    }\n\n    /**\n     * On service connected\n     */\n    @Override\n    public void onServiceConnected(ComponentName name, IBinder service)\n    {\n        this.binder = (IRCBinder) service;\n\n        // connect to irc server if connect has been requested\n        if (server.getStatus() == Status.PRE_CONNECTING && getIntent().hasExtra(\"connect\")) {\n            server.setStatus(Status.CONNECTING);\n            binder.connect(server);\n        }\n    }\n\n    /**\n     * On service disconnected\n     */\n    @Override\n    public void onServiceDisconnected(ComponentName name)\n    {\n        this.binder = null;\n    }\n\n    /**\n     * On options menu requested\n     */\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu)\n    {\n        super.onCreateOptionsMenu(menu);\n\n        // inflate from xml\n        MenuInflater inflater = getMenuInflater();\n        inflater.inflate(R.menu.conversations, menu);\n\n        return true;\n    }\n\n    /**\n     * On prepare options menu\n     */\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu)\n    {\n        menu.getItem(0).setEnabled(server.isConnected()); // join\n        menu.getItem(1).setEnabled(server.isConnected()); // users\n        menu.getItem(2).setEnabled(server.isConnected()); // close\n\n        return true;\n    }\n\n    /**\n     * On menu item selected\n     */\n    @Override\n    public boolean onMenuItemSelected(int featureId, MenuItem item)\n    {\n        switch (item.getItemId()) {\n            case R.id.disconnect:\n                server.setStatus(Status.DISCONNECTED);\n                binder.getService().getConnection(serverId).quitServer();\n                server.clearConversations();\n                setResult(RESULT_OK);\n                finish();\n                break;\n            case R.id.close:\n                Conversation conversationToClose = deckAdapter.getItem(deck.getSelectedItemPosition());\n                // Make sure we part a channel when closing the channel conversation\n                if (conversationToClose.getType() == Conversation.TYPE_CHANNEL) {\n                    binder.getService().getConnection(serverId).partChannel(conversationToClose.getName());\n                }\n                else if (conversationToClose.getType() == Conversation.TYPE_QUERY) {\n                    server.removeConversation(conversationToClose.getName());\n                    onRemoveConversation(conversationToClose.getName());\n                } else {\n                    Toast.makeText(this, getResources().getString(R.string.close_server_window), Toast.LENGTH_SHORT).show();\n                }\n                break;\n            case R.id.join:\n                startActivityForResult(new Intent(this, JoinActivity.class), REQUEST_CODE_JOIN);\n                break;\n            case R.id.users:\n                Conversation conversationForUserList = deckAdapter.getItem(deck.getSelectedItemPosition());\n                if (conversationForUserList.getType() == Conversation.TYPE_CHANNEL) {\n                    Intent intent = new Intent(this, UsersActivity.class);\n                    intent.putExtra(\n                        Extra.USERS,\n                        binder.getService().getConnection(server.getId()).getUsersAsStringArray(\n                            conversationForUserList.getName()\n                        )\n                    );\n                    startActivityForResult(intent, REQUEST_CODE_USERS);\n                } else {\n                    Toast.makeText(this, getResources().getString(R.string.only_usable_from_channel), Toast.LENGTH_SHORT).show();\n                }\n                break;\n        }\n\n        return true;\n    }\n\n    /**\n     * Get server object assigned to this activity\n     * \n     * @return the server object\n     */\n    public Server getServer()\n    {\n        return server;\n    }\n\n    /**\n     * On conversation message\n     */\n    @Override\n    public void onConversationMessage(String target)\n    {\n        Conversation conversation = server.getConversation(target);\n\n        if (conversation == null) {\n            // In an early state it can happen that the conversation object\n            // is not created yet.\n            return;\n        }\n\n        MessageListAdapter adapter = conversation.getMessageListAdapter();\n\n        conversation.setStatus(Conversation.STATUS_MESSAGE);\n\n        if (dots != null) {\n            dots.invalidate();\n        }\n\n        while(conversation.hasBufferedMessages()) {\n            Message message = conversation.pollBufferedMessage();\n\n            if (adapter != null) {\n                adapter.addMessage(message);\n            }\n        }\n    }\n\n    /**\n     * On new conversation\n     */\n    @Override\n    public void onNewConversation(String target)\n    {\n        deckAdapter.addItem(server.getConversation(target));\n\n        if (!deckAdapter.isSwitched()) {\n            // Scroll to new conversation\n            deck.setSelection(deckAdapter.getCount() - 1);\n        }\n    }\n\n    /**\n     * On conversation remove\n     */\n    @Override\n    public void onRemoveConversation(String target)\n    {\n        deckAdapter.removeItem(target);\n\n        if (deckAdapter.isSwitched()) {\n            switcher.showNext();\n            switcher.removeView(deckAdapter.getSwitchedView());\n            deckAdapter.setSwitched(null, null);\n        }\n    }\n\n    /**\n     * On server status update\n     */\n    @Override\n    public void onStatusUpdate()\n    {\n        ((ImageView) findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\n        EditText input = (EditText) findViewById(R.id.input);\n\n        if (server.isConnected()) {\n            input.setEnabled(true);\n        } else {\n            input.setEnabled(false);\n\n            if (server.getStatus() == Status.CONNECTING) {\n                deckAdapter.clearConversations();\n                deckAdapter.addItem(server.getConversation(ServerInfo.DEFAULT_NAME));\n                return;\n            }\n\n            if (!binder.getService().getSettings().isReconnectEnabled()) {\n                AlertDialog.Builder builder = new AlertDialog.Builder(this);\n                builder.setMessage(getResources().getString(R.string.reconnect_after_disconnect, server.getTitle()))\n                .setCancelable(false)\n                .setPositiveButton(\"Yes\", new DialogInterface.OnClickListener() {\n                    @Override\n                    public void onClick(DialogInterface dialog, int id) {\n                        binder.getService().getConnection(server.getId()).setAutojoinChannels(\n                            server.getCurrentChannelNames()\n                        );\n                        server.clearConversations();\n                        deckAdapter.clearConversations();\n                        deckAdapter.addItem(server.getConversation(ServerInfo.DEFAULT_NAME));\n                        binder.connect(server);\n                    }\n                })\n                .setNegativeButton(getString(R.string.negative_button), new DialogInterface.OnClickListener() {\n                    @Override\n                    public void onClick(DialogInterface dialog, int id) {\n                        dialog.cancel();\n                    }\n                });\n                AlertDialog alert = builder.create();\n                alert.show();\n            }\n        }\n    }\n\n    /**\n     * On key down\n     *\n     * XXX: As we only track the back key: Android >= 2.0 will call a method called onBackPressed()\n     */\n    @Override\n    public boolean onKeyDown(int keyCode, KeyEvent event)\n    {\n        if (keyCode == KeyEvent.KEYCODE_BACK && event.getRepeatCount() == 0) {\n            if (deckAdapter.isSwitched()) {\n                switcher.showNext();\n                switcher.removeView(deckAdapter.getSwitchedView());\n                deckAdapter.setSwitched(null, null);\n                return true;\n            }\n        }\n        return super.onKeyDown(keyCode, event);\n    }\n\n    /**\n     * On key pressed (input line)\n     */\n    @Override\n    public boolean onKey(View view, int keyCode, KeyEvent event)\n    {\n        EditText input = (EditText) view;\n\n        if (keyCode == KeyEvent.KEYCODE_DPAD_UP && event.getAction() == KeyEvent.ACTION_DOWN) {\n            String message = scrollback.goBack();\n            if (message != null) {\n                input.setText(message);\n            }\n            return true;\n        }\n\n        if (keyCode == KeyEvent.KEYCODE_DPAD_DOWN && event.getAction() == KeyEvent.ACTION_DOWN) {\n            String message = scrollback.goForward();\n            if (message != null) {\n                input.setText(message);\n            }\n            return true;\n        }\n\n        // Nick completion\n        if (keyCode == KeyEvent.KEYCODE_SEARCH && event.getAction() == KeyEvent.ACTION_DOWN) {\n            String text = input.getText().toString();\n\n            if (text.length() <= 0) {\n                return true;\n            }\n\n            String[] tokens = text.split(\"[\\\\s,.-]+\");\n\n            if (tokens.length <= 0) {\n                return true;\n            }\n\n            String word = tokens[tokens.length - 1].toLowerCase();\n            tokens[tokens.length - 1] = null;\n\n            int begin   = input.getSelectionStart();\n            int end     = input.getSelectionEnd();\n            int cursor  = Math.min(begin, end);\n            int sel_end = Math.max(begin, end);\n\n            boolean in_selection = cursor != sel_end;\n\n            if (in_selection) {\n                word = text.substring(cursor, sel_end);\n            } else {\n                // use the word at the curent cursor position\n                while(true) {\n                    cursor -= 1;\n                    if (cursor <= 0 || text.charAt(cursor) == ' ') {\n                        break;\n                    }\n                }\n\n                if (cursor < 0) {\n                    cursor = 0;\n                }\n\n                if (text.charAt(cursor) == ' ') {\n                    cursor += 1;\n                }\n\n                sel_end = text.indexOf(' ', cursor);\n\n                if (sel_end == -1) {\n                    sel_end = text.length();\n                }\n\n                word = text.substring(cursor, sel_end);\n            }\n            // Log.d(\"Yaaic\", \"Trying to complete nick: \" + word);\n\n            Conversation conversationForUserList = deckAdapter.getItem(deck.getSelectedItemPosition());\n\n            String[] users = null;\n\n            if (conversationForUserList.getType() == Conversation.TYPE_CHANNEL) {\n                users = binder.getService().getConnection(server.getId()).getUsersAsStringArray(\n                    conversationForUserList.getName()\n                );\n            }\n\n            // go through users and add matches\n            if (users != null) {\n                List<Integer> result = new ArrayList<Integer>();\n\n                for (int i = 0; i < users.length; i++) {\n                    if (users[i].toLowerCase().startsWith(word)) {\n                        result.add(Integer.valueOf(i));\n                    }\n                }\n\n                if (result.size() == 1) {\n                    String text1 = users[result.get(0).intValue()];\n\n                    if (cursor == 0) {\n                        text1 += \":\";\n                    }\n\n                    text1 += \" \";\n                    input.getText().replace(cursor, sel_end, text1, 0, text1.length());\n                    int old = input.getInputType();\n                    input.setInputType(old | setInputTypeFlag);\n                } else if (result.size() > 0) {\n                    Intent intent  = new Intent(this, UsersActivity.class);\n                    String[] extra = new String[result.size()];\n                    int i = 0;\n\n                    for (Integer n : result) {\n                        extra[i++] = users[n.intValue()];\n                    }\n\n                    input.setSelection(cursor, sel_end);\n                    intent.putExtra(Extra.USERS, extra);\n                    startActivityForResult(intent, REQUEST_CODE_NICK_COMPLETION);\n                }\n            }\n            return true;\n        }\n\n        if (keyCode == KeyEvent.KEYCODE_ENTER && event.getAction() == KeyEvent.ACTION_DOWN) {\n            if (!server.isConnected()) {\n                Message message = new Message(getString(R.string.message_not_connected));\n                message.setColor(Message.COLOR_RED);\n                message.setIcon(R.drawable.error);\n                server.getConversation(server.getSelectedConversation()).addMessage(message);\n                onConversationMessage(server.getSelectedConversation());\n            }\n\n            String text = input.getText().toString();\n            input.setText(\"\");\n\n            if (text.equals(\"\")) {\n                // ignore empty messages\n                return true;\n            }\n\n            scrollback.addMessage(text);\n\n            Conversation conversation = deckAdapter.getItem(deck.getSelectedItemPosition());\n\n            if (conversation != null) {\n                if (!text.trim().startsWith(\"/\")) {\n                    if (conversation.getType() != Conversation.TYPE_SERVER) {\n                        String nickname = binder.getService().getConnection(serverId).getNick();\n                        conversation.addMessage(new Message(\"<\" + nickname + \"> \" + text));\n                        binder.getService().getConnection(serverId).sendMessage(conversation.getName(), text);\n                    } else {\n                        Message message = new Message(getString(R.string.chat_only_form_channel));\n                        message.setColor(Message.COLOR_YELLOW);\n                        message.setIcon(R.drawable.warning);\n                        conversation.addMessage(message);\n                    }\n                    onConversationMessage(conversation.getName());\n                } else {\n                    CommandParser.getInstance().parse(text, server, conversation, binder.getService());\n                }\n            }\n\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * On activity result\n     */\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent data)\n    {\n        if (resultCode != RESULT_OK) {\n            // ignore other result codes\n            return;\n        }\n\n        switch (requestCode) {\n            case REQUEST_CODE_SPEECH:\n                ArrayList<String> matches = data.getStringArrayListExtra(RecognizerIntent.EXTRA_RESULTS);\n                if (matches.size() > 0) {\n                    ((EditText) findViewById(R.id.input)).setText(matches.get(0));\n                }\n                break;\n            case REQUEST_CODE_JOIN:\n                joinChannelBuffer = data.getExtras().getString(\"channel\");\n                break;\n            case REQUEST_CODE_USERS:\n                Intent intent = new Intent(this, UserActivity.class);\n                intent.putExtra(Extra.USER, data.getStringExtra(Extra.USER));\n                startActivityForResult(intent, REQUEST_CODE_USER);\n                break;\n            case REQUEST_CODE_NICK_COMPLETION:\n                EditText input = (EditText) findViewById(R.id.input);\n                String src        = data.getExtras().getString(Extra.USER);\n                int start        = input.getSelectionStart();\n                int end        = input.getSelectionEnd();\n\n                if (start == 0) {\n                    src += \":\";\n                }\n\n                src += \" \";\n                input.getText().replace(start, end, src, 0, src.length());\n                // put cursor after inserted text\n                input.setSelection(start + src.length());\n                input.post(new Runnable() {\n                    @Override\n                    public void run() {\n                        // make the softkeyboard come up again (only if no hw keyboard is attached)\n                        EditText input = (EditText) findViewById(R.id.input);\n                        InputMethodManager mgr = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);\n                        mgr.showSoftInput(input, InputMethodManager.SHOW_IMPLICIT);\n                    }\n                });\n                input.requestFocus();\n                break;\n            case REQUEST_CODE_USER:\n                final int actionId = data.getExtras().getInt(Extra.ACTION);\n                final String nickname = data.getExtras().getString(Extra.USER);\n                final IRCConnection connection = binder.getService().getConnection(server.getId());\n                final String conversation = server.getSelectedConversation();\n\n                // XXX: Implement me - The action should be handled after onResume()\n                //                     to catch the broadcasts... now we just wait a second\n                // Yes .. that's very ugly - we need some kind of queue that is handled after onResume()\n\n                new Thread() {\n                    @Override\n                    public void run() {\n                        try {\n                            Thread.sleep(1000);\n                        } catch (InterruptedException e) {\n                            // Do nothing\n                        }\n\n                        switch (actionId) {\n                            case R.id.op:\n                                connection.op(conversation, nickname);\n                                break;\n                            case R.id.deop:\n                                connection.deOp(conversation, nickname);\n                                break;\n                            case R.id.voice:\n                                connection.voice(conversation, nickname);\n                                break;\n                            case R.id.devoice:\n                                connection.deVoice(conversation, nickname);\n                                break;\n                            case R.id.kick:\n                                connection.kick(conversation, nickname);\n                                break;\n                            case R.id.ban:\n                                connection.ban(conversation, nickname + \"!*@*\");\n                                break;\n                        }\n                    }\n                }.start();\n\n                break;\n        }\n    }\n}\n","Method after Refactoring":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2011 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage org.yaaic.activity;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.adapter.DeckAdapter;\nimport org.yaaic.adapter.MessageListAdapter;\nimport org.yaaic.command.CommandParser;\nimport org.yaaic.irc.IRCBinder;\nimport org.yaaic.irc.IRCConnection;\nimport org.yaaic.irc.IRCService;\nimport org.yaaic.layout.NonScalingBackgroundDrawable;\nimport org.yaaic.listener.ConversationClickListener;\nimport org.yaaic.listener.ConversationListener;\nimport org.yaaic.listener.ConversationSelectedListener;\nimport org.yaaic.listener.ServerListener;\nimport org.yaaic.listener.SpeechClickListener;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.model.Extra;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Query;\nimport org.yaaic.model.Scrollback;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.ServerInfo;\nimport org.yaaic.model.Settings;\nimport org.yaaic.model.Status;\nimport org.yaaic.model.User;\nimport org.yaaic.receiver.ConversationReceiver;\nimport org.yaaic.receiver.ServerReceiver;\nimport org.yaaic.view.ConversationSwitcher;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.content.pm.PackageManager;\nimport android.content.pm.ResolveInfo;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.speech.RecognizerIntent;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.View.OnKeyListener;\nimport android.view.Window;\nimport android.view.inputmethod.InputMethodManager;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.Gallery;\nimport android.widget.ImageView;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport android.widget.ViewSwitcher;\n\n/**\n * The server view with a scrollable list of all channels\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class ConversationActivity extends Activity implements ServiceConnection, ServerListener, ConversationListener, OnKeyListener\n{\n    public static final int REQUEST_CODE_SPEECH = 99;\n\n    private static final int REQUEST_CODE_JOIN = 1;\n    private static final int REQUEST_CODE_USERS = 2;\n    private static final int REQUEST_CODE_USER = 3;\n    private static final int REQUEST_CODE_NICK_COMPLETION= 4;\n\n    private int serverId;\n    private Server server;\n    private IRCBinder binder;\n    private ConversationReceiver channelReceiver;\n    private ServerReceiver serverReceiver;\n\n    private ViewSwitcher switcher;\n    private Gallery deck;\n    private DeckAdapter deckAdapter;\n    private Scrollback scrollback;\n    private ConversationSwitcher dots;\n\n    // XXX: This is ugly. This is a buffer for a channel that should be joined after showing the\n    //      JoinActivity. As onActivityResult() is called before onResume() a \"channel joined\"\n    //      broadcast may get lost as the broadcast receivers are registered in onResume() but the\n    //      join command would be called in onActivityResult(). joinChannelBuffer will save the\n    //      channel name in onActivityResult() and run the join command in onResume().\n    private String joinChannelBuffer;\n\n    // flag passed to setInputType later\n    // shall be TYPE_TEXT_FLAG_NO_SUGGESTIONS but it's not supported in all API levels (only in 5+)\n    // We'll set it to 0 if it's not supported\n    private int setInputTypeFlag;\n\n    /**\n     * On create\n     */\n    @Override\n    protected void onCreate(Bundle savedInstanceState)\n    {\n        super.onCreate(savedInstanceState);\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n\n        serverId = getIntent().getExtras().getInt(\"serverId\");\n        server = Yaaic.getInstance().getServerById(serverId);\n        setTitle(\"Yaaic - \" + server.getTitle());\n\n        setContentView(R.layout.conversations);\n\n        ((TextView) findViewById(R.id.title)).setText(server.getTitle());\n        ((EditText) findViewById(R.id.input)).setOnKeyListener(this);\n\n        switcher = (ViewSwitcher) findViewById(R.id.switcher);\n\n        dots = (ConversationSwitcher) findViewById(R.id.dots);\n        dots.setServer(server);\n\n        deckAdapter = new DeckAdapter();\n        deck = (Gallery) findViewById(R.id.deck);\n        deck.setOnItemSelectedListener(new ConversationSelectedListener(server, (TextView) findViewById(R.id.title), dots));\n        deck.setAdapter(deckAdapter);\n        deck.setOnItemClickListener(new ConversationClickListener(deckAdapter, switcher));\n        deck.setBackgroundDrawable(new NonScalingBackgroundDrawable(this, deck, R.drawable.background));\n\n        if (server.getStatus() == Status.PRE_CONNECTING) {\n            server.clearConversations();\n            deckAdapter.clearConversations();\n        }\n\n        // Optimization : cache field lookups\n        Collection<Conversation> mConversations = server.getConversations();\n\n        for (Conversation conversation : mConversations) {\n            onNewConversation(conversation.getName());\n        }\n\n        // keep compatibility with api level 3\n        if ((android.os.Build.VERSION.SDK.charAt(0) - '0') >= 5) {\n            setInputTypeFlag = 0x80000; // InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS\n        }\n        else {\n            setInputTypeFlag = 0;\n        }\n\n        // Create a new scrollback history\n        scrollback = new Scrollback();\n    }\n\n    /**\n     * On resume\n     */\n    @Override\n    public void onResume()\n    {\n        // register the receivers as early as possible, otherwise we may loose a broadcast message\n        channelReceiver = new ConversationReceiver(server.getId(), this);\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_MESSAGE));\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_NEW));\n        registerReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_REMOVE));\n\n        serverReceiver = new ServerReceiver(this);\n        registerReceiver(serverReceiver, new IntentFilter(Broadcast.SERVER_UPDATE));\n\n        super.onResume();\n\n        // Check if speech recognition is enabled and available\n        if (new Settings(this).isVoiceRecognitionEnabled()) {\n            PackageManager pm = getPackageManager();\n            Button speechButton = (Button) findViewById(R.id.speech);\n            List<ResolveInfo> activities = pm.queryIntentActivities(new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH), 0);\n            if (activities.size() != 0) {\n                ((Button) findViewById(R.id.speech)).setOnClickListener(new SpeechClickListener(this));\n                speechButton.setVisibility(View.VISIBLE);\n            }\n        }\n\n        ((ImageView) findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\n        // Start service\n        Intent intent = new Intent(this, IRCService.class);\n        intent.setAction(IRCService.ACTION_FOREGROUND);\n        startService(intent);\n        bindService(intent, this, 0);\n\n        if (!server.isConnected()) {\n            ((EditText) findViewById(R.id.input)).setEnabled(false);\n        } else {\n            ((EditText) findViewById(R.id.input)).setEnabled(true);\n        }\n\n        // Optimization - cache field lookup\n        Collection<Conversation> mConversations = server.getConversations();\n        MessageListAdapter mAdapter;\n\n        // Fill view with messages that have been buffered while paused\n        for (Conversation conversation : mConversations) {\n            mAdapter = conversation.getMessageListAdapter();\n\n            if (mAdapter != null) {\n                mAdapter.addBulkMessages(conversation.getBuffer());\n                conversation.clearBuffer();\n            }\n        }\n\n        // Join channel that has been selected in JoinActivity (onActivityResult())\n        if (joinChannelBuffer != null) {\n            new Thread() {\n                @Override\n                public void run() {\n                    binder.getService().getConnection(serverId).joinChannel(joinChannelBuffer);\n                    joinChannelBuffer = null;\n                }\n            }.start();\n        }\n    }\n\n    /**\n     * On Pause\n     */\n    @Override\n    public void onPause()\n    {\n        super.onPause();\n\n        if (binder != null && binder.getService() != null) {\n            binder.getService().checkServiceStatus();\n        }\n\n        unbindService(this);\n        unregisterReceiver(channelReceiver);\n        unregisterReceiver(serverReceiver);\n    }\n\n    /**\n     * On service connected\n     */\n    @Override\n    public void onServiceConnected(ComponentName name, IBinder service)\n    {\n        this.binder = (IRCBinder) service;\n\n        // connect to irc server if connect has been requested\n        if (server.getStatus() == Status.PRE_CONNECTING && getIntent().hasExtra(\"connect\")) {\n            server.setStatus(Status.CONNECTING);\n            binder.connect(server);\n        }\n    }\n\n    /**\n     * On service disconnected\n     */\n    @Override\n    public void onServiceDisconnected(ComponentName name)\n    {\n        this.binder = null;\n    }\n\n    /**\n     * On options menu requested\n     */\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu)\n    {\n        super.onCreateOptionsMenu(menu);\n\n        // inflate from xml\n        MenuInflater inflater = getMenuInflater();\n        inflater.inflate(R.menu.conversations, menu);\n\n        return true;\n    }\n\n    /**\n     * On prepare options menu\n     */\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu)\n    {\n        menu.getItem(0).setEnabled(server.isConnected()); // join\n        menu.getItem(1).setEnabled(server.isConnected()); // users\n        menu.getItem(2).setEnabled(server.isConnected()); // close\n\n        return true;\n    }\n\n    /**\n     * On menu item selected\n     */\n    @Override\n    public boolean onMenuItemSelected(int featureId, MenuItem item)\n    {\n        switch (item.getItemId()) {\n            case R.id.disconnect:\n                server.setStatus(Status.DISCONNECTED);\n                binder.getService().getConnection(serverId).quitServer();\n                server.clearConversations();\n                setResult(RESULT_OK);\n                finish();\n                break;\n            case R.id.close:\n                Conversation conversationToClose = deckAdapter.getItem(deck.getSelectedItemPosition());\n                // Make sure we part a channel when closing the channel conversation\n                if (conversationToClose.getType() == Conversation.TYPE_CHANNEL) {\n                    binder.getService().getConnection(serverId).partChannel(conversationToClose.getName());\n                }\n                else if (conversationToClose.getType() == Conversation.TYPE_QUERY) {\n                    server.removeConversation(conversationToClose.getName());\n                    onRemoveConversation(conversationToClose.getName());\n                } else {\n                    Toast.makeText(this, getResources().getString(R.string.close_server_window), Toast.LENGTH_SHORT).show();\n                }\n                break;\n            case R.id.join:\n                startActivityForResult(new Intent(this, JoinActivity.class), REQUEST_CODE_JOIN);\n                break;\n            case R.id.users:\n                Conversation conversationForUserList = deckAdapter.getItem(deck.getSelectedItemPosition());\n                if (conversationForUserList.getType() == Conversation.TYPE_CHANNEL) {\n                    Intent intent = new Intent(this, UsersActivity.class);\n                    intent.putExtra(\n                        Extra.USERS,\n                        binder.getService().getConnection(server.getId()).getUsersAsStringArray(\n                            conversationForUserList.getName()\n                        )\n                    );\n                    startActivityForResult(intent, REQUEST_CODE_USERS);\n                } else {\n                    Toast.makeText(this, getResources().getString(R.string.only_usable_from_channel), Toast.LENGTH_SHORT).show();\n                }\n                break;\n        }\n\n        return true;\n    }\n\n    /**\n     * Get server object assigned to this activity\n     * \n     * @return the server object\n     */\n    public Server getServer()\n    {\n        return server;\n    }\n\n    /**\n     * On conversation message\n     */\n    @Override\n    public void onConversationMessage(String target)\n    {\n        Conversation conversation = server.getConversation(target);\n\n        if (conversation == null) {\n            // In an early state it can happen that the conversation object\n            // is not created yet.\n            return;\n        }\n\n        MessageListAdapter adapter = conversation.getMessageListAdapter();\n\n        conversation.setStatus(Conversation.STATUS_MESSAGE);\n\n        if (dots != null) {\n            dots.invalidate();\n        }\n\n        while(conversation.hasBufferedMessages()) {\n            Message message = conversation.pollBufferedMessage();\n\n            if (adapter != null) {\n                adapter.addMessage(message);\n            }\n        }\n    }\n\n    /**\n     * On new conversation\n     */\n    @Override\n    public void onNewConversation(String target)\n    {\n        deckAdapter.addItem(server.getConversation(target));\n\n        if (!deckAdapter.isSwitched()) {\n            // Scroll to new conversation\n            deck.setSelection(deckAdapter.getCount() - 1);\n        }\n    }\n\n    /**\n     * On conversation remove\n     */\n    @Override\n    public void onRemoveConversation(String target)\n    {\n        deckAdapter.removeItem(target);\n\n        if (deckAdapter.isSwitched()) {\n            switcher.showNext();\n            switcher.removeView(deckAdapter.getSwitchedView());\n            deckAdapter.setSwitched(null, null);\n        }\n    }\n\n    /**\n     * On server status update\n     */\n    @Override\n    public void onStatusUpdate()\n    {\n        ((ImageView) findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\n        EditText input = (EditText) findViewById(R.id.input);\n\n        if (server.isConnected()) {\n            input.setEnabled(true);\n        } else {\n            input.setEnabled(false);\n\n            if (server.getStatus() == Status.CONNECTING) {\n                deckAdapter.clearConversations();\n                deckAdapter.addItem(server.getConversation(ServerInfo.DEFAULT_NAME));\n                return;\n            }\n\n            if (!binder.getService().getSettings().isReconnectEnabled()) {\n                AlertDialog.Builder builder = new AlertDialog.Builder(this);\n                builder.setMessage(getResources().getString(R.string.reconnect_after_disconnect, server.getTitle()))\n                .setCancelable(false)\n                .setPositiveButton(\"Yes\", new DialogInterface.OnClickListener() {\n                    @Override\n                    public void onClick(DialogInterface dialog, int id) {\n                        binder.getService().getConnection(server.getId()).setAutojoinChannels(\n                            server.getCurrentChannelNames()\n                        );\n                        server.clearConversations();\n                        deckAdapter.clearConversations();\n                        deckAdapter.addItem(server.getConversation(ServerInfo.DEFAULT_NAME));\n                        binder.connect(server);\n                    }\n                })\n                .setNegativeButton(getString(R.string.negative_button), new DialogInterface.OnClickListener() {\n                    @Override\n                    public void onClick(DialogInterface dialog, int id) {\n                        dialog.cancel();\n                    }\n                });\n                AlertDialog alert = builder.create();\n                alert.show();\n            }\n        }\n    }\n\n    /**\n     * On key down\n     *\n     * XXX: As we only track the back key: Android >= 2.0 will call a method called onBackPressed()\n     */\n    @Override\n    public boolean onKeyDown(int keyCode, KeyEvent event)\n    {\n        if (keyCode == KeyEvent.KEYCODE_BACK && event.getRepeatCount() == 0) {\n            if (deckAdapter.isSwitched()) {\n                switcher.showNext();\n                switcher.removeView(deckAdapter.getSwitchedView());\n                deckAdapter.setSwitched(null, null);\n                return true;\n            }\n        }\n        return super.onKeyDown(keyCode, event);\n    }\n\n    /**\n     * On key pressed (input line)\n     */\n    @Override\n    public boolean onKey(View view, int keyCode, KeyEvent event)\n    {\n        EditText input = (EditText) view;\n\n        if (keyCode == KeyEvent.KEYCODE_DPAD_UP && event.getAction() == KeyEvent.ACTION_DOWN) {\n            String message = scrollback.goBack();\n            if (message != null) {\n                input.setText(message);\n            }\n            return true;\n        }\n\n        if (keyCode == KeyEvent.KEYCODE_DPAD_DOWN && event.getAction() == KeyEvent.ACTION_DOWN) {\n            String message = scrollback.goForward();\n            if (message != null) {\n                input.setText(message);\n            }\n            return true;\n        }\n\n        // Nick completion\n        if (keyCode == KeyEvent.KEYCODE_SEARCH && event.getAction() == KeyEvent.ACTION_DOWN) {\n            String text = input.getText().toString();\n\n            if (text.length() <= 0) {\n                return true;\n            }\n\n            String[] tokens = text.split(\"[\\\\s,.-]+\");\n\n            if (tokens.length <= 0) {\n                return true;\n            }\n\n            String word = tokens[tokens.length - 1].toLowerCase();\n            tokens[tokens.length - 1] = null;\n\n            int begin   = input.getSelectionStart();\n            int end     = input.getSelectionEnd();\n            int cursor  = Math.min(begin, end);\n            int sel_end = Math.max(begin, end);\n\n            boolean in_selection = cursor != sel_end;\n\n            if (in_selection) {\n                word = text.substring(cursor, sel_end);\n            } else {\n                // use the word at the curent cursor position\n                while(true) {\n                    cursor -= 1;\n                    if (cursor <= 0 || text.charAt(cursor) == ' ') {\n                        break;\n                    }\n                }\n\n                if (cursor < 0) {\n                    cursor = 0;\n                }\n\n                if (text.charAt(cursor) == ' ') {\n                    cursor += 1;\n                }\n\n                sel_end = text.indexOf(' ', cursor);\n\n                if (sel_end == -1) {\n                    sel_end = text.length();\n                }\n\n                word = text.substring(cursor, sel_end);\n            }\n            // Log.d(\"Yaaic\", \"Trying to complete nick: \" + word);\n\n            Conversation conversationForUserList = deckAdapter.getItem(deck.getSelectedItemPosition());\n\n            String[] users = null;\n\n            if (conversationForUserList.getType() == Conversation.TYPE_CHANNEL) {\n                users = binder.getService().getConnection(server.getId()).getUsersAsStringArray(\n                    conversationForUserList.getName()\n                );\n            }\n\n            // go through users and add matches\n            if (users != null) {\n                List<Integer> result = new ArrayList<Integer>();\n\n                for (int i = 0; i < users.length; i++) {\n                    if (users[i].toLowerCase().startsWith(word)) {\n                        result.add(Integer.valueOf(i));\n                    }\n                }\n\n                if (result.size() == 1) {\n                    String text1 = users[result.get(0).intValue()];\n\n                    if (cursor == 0) {\n                        text1 += \":\";\n                    }\n\n                    text1 += \" \";\n                    input.getText().replace(cursor, sel_end, text1, 0, text1.length());\n                    int old = input.getInputType();\n                    input.setInputType(old | setInputTypeFlag);\n                } else if (result.size() > 0) {\n                    Intent intent  = new Intent(this, UsersActivity.class);\n                    String[] extra = new String[result.size()];\n                    int i = 0;\n\n                    for (Integer n : result) {\n                        extra[i++] = users[n.intValue()];\n                    }\n\n                    input.setSelection(cursor, sel_end);\n                    intent.putExtra(Extra.USERS, extra);\n                    startActivityForResult(intent, REQUEST_CODE_NICK_COMPLETION);\n                }\n            }\n            return true;\n        }\n\n        if (keyCode == KeyEvent.KEYCODE_ENTER && event.getAction() == KeyEvent.ACTION_DOWN) {\n            if (!server.isConnected()) {\n                Message message = new Message(getString(R.string.message_not_connected));\n                message.setColor(Message.COLOR_RED);\n                message.setIcon(R.drawable.error);\n                server.getConversation(server.getSelectedConversation()).addMessage(message);\n                onConversationMessage(server.getSelectedConversation());\n            }\n\n            String text = input.getText().toString();\n            input.setText(\"\");\n\n            if (text.equals(\"\")) {\n                // ignore empty messages\n                return true;\n            }\n\n            scrollback.addMessage(text);\n\n            Conversation conversation = deckAdapter.getItem(deck.getSelectedItemPosition());\n\n            if (conversation != null) {\n                if (!text.trim().startsWith(\"/\")) {\n                    if (conversation.getType() != Conversation.TYPE_SERVER) {\n                        String nickname = binder.getService().getConnection(serverId).getNick();\n                        conversation.addMessage(new Message(\"<\" + nickname + \"> \" + text));\n                        binder.getService().getConnection(serverId).sendMessage(conversation.getName(), text);\n                    } else {\n                        Message message = new Message(getString(R.string.chat_only_form_channel));\n                        message.setColor(Message.COLOR_YELLOW);\n                        message.setIcon(R.drawable.warning);\n                        conversation.addMessage(message);\n                    }\n                    onConversationMessage(conversation.getName());\n                } else {\n                    CommandParser.getInstance().parse(text, server, conversation, binder.getService());\n                }\n            }\n\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * On activity result\n     */\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent data)\n    {\n        if (resultCode != RESULT_OK) {\n            // ignore other result codes\n            return;\n        }\n\n        switch (requestCode) {\n            case REQUEST_CODE_SPEECH:\n                ArrayList<String> matches = data.getStringArrayListExtra(RecognizerIntent.EXTRA_RESULTS);\n                if (matches.size() > 0) {\n                    ((EditText) findViewById(R.id.input)).setText(matches.get(0));\n                }\n                break;\n            case REQUEST_CODE_JOIN:\n                joinChannelBuffer = data.getExtras().getString(\"channel\");\n                break;\n            case REQUEST_CODE_USERS:\n                Intent intent = new Intent(this, UserActivity.class);\n                intent.putExtra(Extra.USER, data.getStringExtra(Extra.USER));\n                startActivityForResult(intent, REQUEST_CODE_USER);\n                break;\n            case REQUEST_CODE_NICK_COMPLETION:\n                EditText input = (EditText) findViewById(R.id.input);\n                String src        = data.getExtras().getString(Extra.USER);\n                int start        = input.getSelectionStart();\n                int end        = input.getSelectionEnd();\n\n                if (start == 0) {\n                    src += \":\";\n                }\n\n                src += \" \";\n                input.getText().replace(start, end, src, 0, src.length());\n                // put cursor after inserted text\n                input.setSelection(start + src.length());\n                input.post(new Runnable() {\n                    @Override\n                    public void run() {\n                        // make the softkeyboard come up again (only if no hw keyboard is attached)\n                        EditText input = (EditText) findViewById(R.id.input);\n                        InputMethodManager mgr = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);\n                        mgr.showSoftInput(input, InputMethodManager.SHOW_IMPLICIT);\n                    }\n                });\n                input.requestFocus();\n                break;\n            case REQUEST_CODE_USER:\n                final int actionId = data.getExtras().getInt(Extra.ACTION);\n                final String nickname = data.getExtras().getString(Extra.USER);\n                final IRCConnection connection = binder.getService().getConnection(server.getId());\n                final String conversation = server.getSelectedConversation();\n                final Handler handler = new Handler();\n\n                // XXX: Implement me - The action should be handled after onResume()\n                //                     to catch the broadcasts... now we just wait a second\n                // Yes .. that's very ugly - we need some kind of queue that is handled after onResume()\n\n                new Thread() {\n                    @Override\n                    public void run() {\n                        try {\n                            Thread.sleep(1000);\n                        } catch (InterruptedException e) {\n                            // Do nothing\n                        }\n\n                        String nicknameWithoutPrefix = nickname;\n\n                        while (\n                            nicknameWithoutPrefix.startsWith(\"@\") ||\n                            nicknameWithoutPrefix.startsWith(\"+\") ||\n                            nicknameWithoutPrefix.startsWith(\".\") ||\n                            nicknameWithoutPrefix.startsWith(\"%\")\n                        ) {\n                            // Strip prefix(es) now\n                            nicknameWithoutPrefix = nicknameWithoutPrefix.substring(1);\n                        }\n\n                        switch (actionId) {\n                            case User.ACTION_REPLY:\n                                final String replyText = nicknameWithoutPrefix + \": \";\n                                handler.post(new Runnable() {\n                                    @Override\n                                    public void run() {\n                                        EditText input = (EditText) findViewById(R.id.input);\n                                        input.setText(replyText);\n                                        input.setSelection(replyText.length());\n                                    }\n                                });\n                                break;\n                            case User.ACTION_QUERY:\n                                Conversation query = server.getConversation(nicknameWithoutPrefix);\n                                if (query == null) {\n                                    // Open a query if there's none yet\n                                    query = new Query(nicknameWithoutPrefix);\n                                    server.addConversationl(query);\n\n                                    Intent intent = Broadcast.createConversationIntent(\n                                        Broadcast.CONVERSATION_NEW,\n                                        server.getId(),\n                                        nicknameWithoutPrefix\n                                    );\n                                    binder.getService().sendBroadcast(intent);\n                                }\n                                break;\n                            case User.ACTION_OP:\n                                connection.op(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_DEOP:\n                                connection.deOp(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_VOICE:\n                                connection.voice(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_DEVOICE:\n                                connection.deVoice(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_KICK:\n                                connection.kick(conversation, nicknameWithoutPrefix);\n                                break;\n                            case User.ACTION_BAN:\n                                connection.ban(conversation, nicknameWithoutPrefix + \"!*@*\");\n                                break;\n                        }\n                    }\n                }.start();\n\n                break;\n        }\n    }\n}\n","lineNo":743}
{"Smelly Sample":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2010 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.activity;\n\nimport java.util.Collection;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.content.ComponentName;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.os.Bundle;\nimport android.os.IBinder;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.Window;\nimport android.view.View.OnKeyListener;\nimport android.widget.AdapterView;\nimport android.widget.EditText;\nimport android.widget.Gallery;\nimport android.widget.ImageView;\nimport android.widget.ListView;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport android.widget.ViewSwitcher;\nimport android.widget.AdapterView.OnItemClickListener;\nimport android.widget.AdapterView.OnItemSelectedListener;\nimport android.widget.TableLayout.LayoutParams;\n\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.adapter.DeckAdapter;\nimport org.yaaic.adapter.MessageListAdapter;\nimport org.yaaic.command.CommandParser;\nimport org.yaaic.irc.IRCBinder;\nimport org.yaaic.irc.IRCService;\nimport org.yaaic.layout.NonScalingBackgroundDrawable;\nimport org.yaaic.listener.ConversationListener;\nimport org.yaaic.listener.ServerListener;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.model.Extra;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Scrollback;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.ServerInfo;\nimport org.yaaic.model.Status;\nimport org.yaaic.receiver.ConversationReceiver;\nimport org.yaaic.receiver.ServerReceiver;\nimport org.yaaic.view.MessageListView;\nimport org.yaaic.view.ConversationSwitcher;\n\n/**\n * The server view with a scrollable list of all channels\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class ConversationActivity extends Activity implements ServiceConnection, ServerListener, ConversationListener, OnItemClickListener, OnKeyListener, OnItemSelectedListener\n{\n\tprivate static final int REQUEST_CODE_JOIN = 1;\n\tprivate static final int REQUEST_CODE_USERS = 2;\n\tprivate static final int REQUEST_CODE_USER = 3;\n\t\n\tprivate int serverId;\n\tprivate Server server;\n\tprivate IRCBinder binder;\n\tprivate ConversationReceiver channelReceiver;\n\tprivate ServerReceiver serverReceiver;\n\t\n\tprivate ViewSwitcher switcher;\n\tprivate Gallery deck;\n\tprivate DeckAdapter deckAdapter;\n\tprivate Scrollback scrollback;\n\tprivate ConversationSwitcher dots;\n\t\n\t// XXX: This is ugly. This is a buffer for a channel that should be joined after showing the\n\t//      JoinActivity. As onActivityResult() is called before onResume() a \"channel joined\"\n\t//      broadcast may get lost as the broadcast receivers are registered in onResume() but the\n\t//      join command would be called in onActivityResult(). joinChannelBuffer will save the\n\t//      channel name in onActivityResult() and run the join command in onResume().\n\tprivate String joinChannelBuffer;\n\t\n\t/**\n\t * On create\n\t */\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState)\n\t{\n\t\tsuper.onCreate(savedInstanceState);\n\t\trequestWindowFeature(Window.FEATURE_NO_TITLE);\n\t\t\n\t\tserverId = getIntent().getExtras().getInt(\"serverId\");\n\t\tserver = (Server) Yaaic.getInstance().getServerById(serverId);\n\t\tsetTitle(\"Yaaic - \" + server.getTitle());\n\t\t\n\t\tsetContentView(R.layout.conversations);\n\t\t\n\t\t((TextView) findViewById(R.id.title)).setText(server.getTitle());\n\t\t((EditText) findViewById(R.id.input)).setOnKeyListener(this);\n\t\t\n        deckAdapter = new DeckAdapter();\n\t\tdeck = (Gallery) findViewById(R.id.deck);\n\t\tdeck.setOnItemSelectedListener(this);\n\t\tdeck.setAdapter(deckAdapter);\n\t\tdeck.setOnItemClickListener(this);\n\t\tdeck.setBackgroundDrawable(new NonScalingBackgroundDrawable(this, deck, R.drawable.background));\n\t\t\n\t\tif (server.getStatus() == Status.PRE_CONNECTING) {\n\t\t\tserver.clearConversations();\n\t\t\tdeckAdapter.clearConversations();\n\t\t}\n\n\t\tswitcher = (ViewSwitcher) findViewById(R.id.switcher);\n\t\t\n\t\t// Optimization : cache field lookups \n\t\tCollection<Conversation> mConversations = server.getConversations();\n\t\t\n\t\tfor (Conversation conversation : mConversations) {\n\t\t\tonNewConversation(conversation.getName());\n\t\t}\n\t\t\n\t\t// Create a new scrollback history\n\t\tscrollback = new Scrollback();\n\t}\n\t\n\t/**\n\t * On resume\n\t */\n\t@Override\n\tpublic void onResume()\n\t{\n\t\t// register the receivers as early as possible, otherwise we may loose a broadcast message\n\t\tchannelReceiver = new ConversationReceiver(server.getId(), this);\n\t\tregisterReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_MESSAGE));\n\t\tregisterReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_NEW));\n\t\tregisterReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_REMOVE));\n\t\t\n\t\tserverReceiver = new ServerReceiver(this);\n\t\tregisterReceiver(serverReceiver, new IntentFilter(Broadcast.SERVER_UPDATE));\n\t\t\n\t\tsuper.onResume();\n\t\t\n\t\t((ImageView) findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\t\t\n\t\t// Start service\n        Intent intent = new Intent(this, IRCService.class);\n        intent.setAction(IRCService.ACTION_FOREGROUND);\n        startService(intent);\n        bindService(intent, this, 0);\n        \n\t\tif (!server.isConnected()) {\n\t\t\t ((EditText) findViewById(R.id.input)).setEnabled(false);\n\t\t} else {\n\t\t\t ((EditText) findViewById(R.id.input)).setEnabled(true);\n\t\t}\n\t\t\n\t\tdots = (ConversationSwitcher) findViewById(R.id.dots);\n\t\tdots.setServer(server);\n\n\t\t// Optimization - cache field lookup\n\t\tCollection<Conversation> mConversations = server.getConversations();\n\t\tMessageListAdapter mAdapter;\n\t\t\n\t\t// Fill view with messages that have been buffered while paused\n\t\tfor (Conversation conversation : mConversations) {\n\t\t\tmAdapter = conversation.getMessageListAdapter();\n\t\t\t\n\t\t\tif (mAdapter != null) {\n\t\t\t\tmAdapter.addBulkMessages(conversation.getBuffer());\n\t\t\t\tconversation.clearBuffer();\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Join channel that has been selected in JoinActivity (onActivityResult())\n\t\tif (joinChannelBuffer != null) {\n\t\t\tnew Thread() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tbinder.getService().getConnection(serverId).joinChannel(joinChannelBuffer);\n\t\t\t\t\tjoinChannelBuffer = null;\n\t\t\t\t}\n\t\t\t}.start();\n\t\t}\n\t}\n\t\n\t/**\n\t * On Pause\n\t */\n\t@Override\n\tpublic void onPause()\n\t{\n\t\tsuper.onPause();\n\t\t\n\t\tif (binder != null && binder.getService() != null) {\n\t\t\tbinder.getService().checkServiceStatus();\n\t\t}\n\t\t\n\t\t/*if (!binder.getService().hasConnections()) {\n\t\t\tLog.d(\"Yaaic\", \"Stopping service\");\n\t\t\t//binder.getService().stopSelf();\n\t\t} else {\n\t\t\tLog.d(\"Yaaic\", \"Unbinding service\");\n\t\t}*/\n\n\t\tunbindService(this);\n\t\tunregisterReceiver(channelReceiver);\n\t\tunregisterReceiver(serverReceiver);\n\t}\n\n\t/**\n\t * On service connected\n\t */\n\tpublic void onServiceConnected(ComponentName name, IBinder service)\n\t{\n\t\tthis.binder = (IRCBinder) service;\n\t\t\n\t\t// connect to irc server if connect has been requested\n\t\tif (server.getStatus() == Status.PRE_CONNECTING && getIntent().hasExtra(\"connect\")) {\n\t\t\tserver.setStatus(Status.CONNECTING);\n\t\t\tbinder.connect(server);\n\t\t}\n\t}\n\n\t/**\n\t * On service disconnected\n\t */\n\tpublic void onServiceDisconnected(ComponentName name)\n\t{\n\t\tthis.binder = null;\n\t}\n\n\t/**\n\t * On options menu requested\n\t */\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu)\n\t{\n    \tsuper.onCreateOptionsMenu(menu);\n    \t\n    \t// inflate from xml\n    \tMenuInflater inflater = getMenuInflater();\n    \tinflater.inflate(R.menu.conversations, menu);\n    \t\n    \treturn true;\n\t}\n\t\n\t/**\n\t * On prepare options menu\n\t */\n\t@Override\n\tpublic boolean onPrepareOptionsMenu(Menu menu)\n\t{\n\t\tmenu.getItem(0).setEnabled(server.isConnected()); // join\n\t\tmenu.getItem(1).setEnabled(server.isConnected()); // users\n\t\tmenu.getItem(2).setEnabled(server.isConnected()); // close\n\t\t\n\t\treturn true;\n\t}\n\n\t/**\n\t * On menu item selected\n\t */\n\t@Override\n\tpublic boolean onMenuItemSelected(int featureId, MenuItem item)\n\t{\n\t\tswitch (item.getItemId()) {\n\t\t\tcase R.id.disconnect:\n\t\t\t\tserver.setStatus(Status.DISCONNECTED);\n\t\t\t\tbinder.getService().getConnection(serverId).quitServer();\n\t\t\t\tserver.clearConversations();\n\t\t\t\tsetResult(RESULT_OK);\n\t\t\t\tfinish();\n\t\t\t\tbreak;\n\t\t\tcase R.id.close:\n\t\t\t\tConversation conversationToClose = deckAdapter.getItem(deck.getSelectedItemPosition());\n\t\t\t\t// Make sure we part a channel when closing the channel conversation\n\t\t\t\tif (conversationToClose.getType() == Conversation.TYPE_CHANNEL) {\n\t\t\t\t\tbinder.getService().getConnection(serverId).partChannel(conversationToClose.getName());\n\t\t\t\t}\n\t\t\t\telse if (conversationToClose.getType() == Conversation.TYPE_QUERY) {\n\t\t\t\t\tserver.removeConversation(conversationToClose.getName());\n\t\t\t\t\tonRemoveConversation(conversationToClose.getName());\n\t\t\t\t} else {\n\t\t\t\t\tToast.makeText(this, \"You can not close the server info window\", Toast.LENGTH_SHORT).show();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase R.id.join:\n\t\t\t\tstartActivityForResult(new Intent(this, JoinActivity.class), REQUEST_CODE_JOIN);\n\t\t\t\tbreak;\n\t\t\tcase R.id.users:\n\t\t\t\tConversation conversationForUserList = deckAdapter.getItem(deck.getSelectedItemPosition());\n\t\t\t\tif (conversationForUserList.getType() == Conversation.TYPE_CHANNEL) {\n\t\t\t\t\tIntent intent = new Intent(this, UsersActivity.class);\n\t\t\t\t\tintent.putExtra(\n\t\t\t\t\t\tExtra.USERS,\n\t\t\t\t\t\tbinder.getService().getConnection(server.getId()).getUsersAsStringArray(\n\t\t\t\t\t\t\tconversationForUserList.getName()\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t\tstartActivityForResult(intent, REQUEST_CODE_USERS);\n\t\t\t\t} else {\n\t\t\t\t\tToast.makeText(this, \"Only usable from within a channel\", Toast.LENGTH_SHORT).show();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\t/**\n\t * Get server object assigned to this activity\n\t * \n\t * @return the server object\n\t */\n\tpublic Server getServer()\n\t{\n\t\treturn server;\n\t}\n\n\t/**\n\t * On conversation message\n\t */\n\tpublic void onConversationMessage(String target)\n\t{\n\t\tConversation conversation = server.getConversation(target);\n\t\tMessageListAdapter adapter = conversation.getMessageListAdapter();\n\t\t\n\t\tconversation.setStatus(Conversation.STATUS_MESSAGE);\n\t\tif (dots != null) {\n\t\t\tdots.invalidate();\n\t\t}\n\t\t\n\t\twhile(conversation.hasBufferedMessages()) {\n\t\t\tMessage message = conversation.pollBufferedMessage();\n\t\t\t\n\t\t\tif (adapter != null) {\n\t\t\t\tadapter.addMessage(message);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * On new conversation\n\t */\n\tpublic void onNewConversation(String target)\n\t{\n\t\tdeckAdapter.addItem(server.getConversation(target));\n\t\t\n\t\tif (!deckAdapter.isSwitched()) {\n\t\t\t// Scroll to new conversation\n\t\t\tdeck.setSelection(deckAdapter.getCount() - 1);\n\t\t}\n\t}\n\t\n\t/**\n\t * On conversation remove\n\t */\n\tpublic void onRemoveConversation(String target)\n\t{\n\t\tdeckAdapter.removeItem(target);\n\t\t\n\t\tif (deckAdapter.isSwitched()) {\n\t\t\tswitcher.showNext();\n\t\t\tswitcher.removeView(deckAdapter.getSwitchedView());\n\t\t\tdeckAdapter.setSwitched(null, null);\n\t\t}\n\t}\n\n\t/**\n\t * On server status update\n\t */\n\tpublic void onStatusUpdate()\n\t{\n\t\t((ImageView) findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\t\t\n\t\tEditText input = (EditText) findViewById(R.id.input);\n\n\t\tif (server.isConnected()) {\n\t\t\tinput.setEnabled(true); \n\t\t} else {\n\t\t\tinput.setEnabled(false);\n\n\t\t\tif (server.getStatus() == Status.CONNECTING) {\n\t\t\t\tdeckAdapter.clearConversations();\n\t\t\t\tdeckAdapter.addItem(server.getConversation(ServerInfo.DEFAULT_NAME));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!binder.getService().getSettings().isReconnectEnabled()) {\n\t\t\t\tAlertDialog.Builder builder = new AlertDialog.Builder(this);\n\t\t\t\tbuilder.setMessage(\"You disconnected from \" + server.getTitle() + \". Do you want to reconnect?\")\n\t\t\t\t.setCancelable(false)\n\t\t\t\t.setPositiveButton(\"Yes\", new DialogInterface.OnClickListener() {\n\t\t\t\t\tpublic void onClick(DialogInterface dialog, int id) {\n\t\t\t\t\t\tbinder.getService().getConnection(server.getId()).setAutojoinChannels(\n\t\t\t\t\t\t\tserver.getCurrentChannelNames()\n\t\t\t\t\t\t);\n\t\t\t\t\t\tserver.clearConversations();\n\t\t\t\t\t\tdeckAdapter.clearConversations();\n\t\t\t\t\t\tdeckAdapter.addItem(server.getConversation(ServerInfo.DEFAULT_NAME));\n\t\t\t\t\t\tbinder.connect(server);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.setNegativeButton(\"No\", new DialogInterface.OnClickListener() {\n\t\t\t\t\tpublic void onClick(DialogInterface dialog, int id) {\n\t\t\t\t\t\tdialog.cancel();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tAlertDialog alert = builder.create();\n\t\t\t\talert.show();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * On conversation item clicked\n\t */\n\tpublic void onItemClick(AdapterView<?> adapterView, View view, int position, long id)\n\t{\n\t\tConversation conversation = deckAdapter.getItem(position);\n\t\t\n\t\tMessageListView canvas = deckAdapter.renderConversation(conversation, switcher);\n\t\tcanvas.setTranscriptMode(ListView.TRANSCRIPT_MODE_NORMAL);\n\t\tcanvas.setLayoutParams(new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT));\n\t\tcanvas.setDelegateTouchEvents(false); // Do not delegate\n\t\t\n\t\tdeckAdapter.setSwitched(conversation.getName(), canvas);\n\t\tswitcher.addView(canvas);\n\t\tswitcher.showNext();\n\t}\n\t\n\t/**\n\t * On key down\n\t *\n\t * XXX: As we only track the back key: Android >= 2.0 will call a method called onBackPressed()\n\t */\n\t@Override\n\tpublic boolean onKeyDown(int keyCode, KeyEvent event)\n\t{\n\t\tif (keyCode == KeyEvent.KEYCODE_BACK && event.getRepeatCount() == 0) {\n\t\t\tif (deckAdapter.isSwitched()) {\n\t\t\t\tswitcher.showNext();\n\t\t\t\tswitcher.removeView(deckAdapter.getSwitchedView());\n\t\t\t\tdeckAdapter.setSwitched(null, null);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn super.onKeyDown(keyCode, event);\n\t}\n\n\t/**\n\t * On key pressed (input line)\n\t */\n\tpublic boolean onKey(View view, int keyCode, KeyEvent event)\n\t{\n\t\tEditText input = (EditText) view;\n\t\t\n\t\tif (keyCode == KeyEvent.KEYCODE_DPAD_UP && event.getAction() == KeyEvent.ACTION_DOWN) {\n\t\t\tString message = scrollback.goBack();\n\t\t\tif (message != null) {\n\t\t\t\tinput.setText(message);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tif (keyCode == KeyEvent.KEYCODE_DPAD_DOWN && event.getAction() == KeyEvent.ACTION_DOWN) {\n\t\t\tString message = scrollback.goForward();\n\t\t\tif (message != null) {\n\t\t\t\tinput.setText(message);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tif (keyCode == KeyEvent.KEYCODE_ENTER && event.getAction() == KeyEvent.ACTION_UP) {\n\t\t\tif (!server.isConnected()) {\n\t\t\t\tMessage message = new Message(\"Not connected\");\n\t\t\t\tmessage.setColor(Message.COLOR_RED);\n\t\t\t\tmessage.setIcon(R.drawable.error);\n\t\t\t\tserver.getConversation(server.getSelectedConversation()).addMessage(message);\n\t\t\t\tonConversationMessage(server.getSelectedConversation());\n\t\t\t}\n\t\t\t\n\t\t\tString text = input.getText().toString();\n\t\t\tinput.setText(\"\");\n\t\t\t\n\t\t\tif (text.equals(\"\")) {\n\t\t\t\t// ignore empty messages\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\tscrollback.addMessage(text);\n\t\t\t\n\t\t\tConversation conversation = deckAdapter.getItem(deck.getSelectedItemPosition());\n\t\t\t\n\t\t\tif (conversation != null) {\n\t\t\t\tif (!text.trim().startsWith(\"/\")) {\n\t\t\t\t\tif (conversation.getType() != Conversation.TYPE_SERVER) {\n\t\t\t\t\t\tString nickname = binder.getService().getConnection(serverId).getNick();\n\t\t\t\t\t\tconversation.addMessage(new Message(\"<\" + nickname + \"> \" + text));\n\t\t\t\t\t\tbinder.getService().getConnection(serverId).sendMessage(conversation.getName(), text);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tMessage message = new Message(\"You can only chat from within a channel or a query\");\n\t\t\t\t\t\tmessage.setColor(Message.COLOR_YELLOW);\n\t\t\t\t\t\tmessage.setIcon(R.drawable.warning);\n\t\t\t\t\t\tconversation.addMessage(message);\n\t\t\t\t\t}\n\t\t\t\t\tonConversationMessage(conversation.getName());\n\t\t\t\t} else {\n\t\t\t\t\tCommandParser.getInstance().parse(text, server, conversation, binder.getService());\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * On activity result\n\t */\n\t@Override\n\tprotected void onActivityResult(int requestCode, int resultCode, Intent data)\n\t{\n\t\tif (resultCode != RESULT_OK) {\n\t\t\t// ignore other result codes\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// currently there's only the \"join channel\" activity\n\t\tswitch (requestCode) {\n\t\t\tcase REQUEST_CODE_JOIN:\n\t\t\t\tjoinChannelBuffer = data.getExtras().getString(\"channel\");\n\t\t\t\tbreak;\n\t\t\tcase REQUEST_CODE_USERS:\n\t\t\t\tIntent intent = new Intent(this, UserActivity.class);\n\t\t\t\tintent.putExtra(Extra.USER, data.getStringExtra(Extra.USER));\n\t\t\t\tstartActivityForResult(intent, REQUEST_CODE_USER);\n\t\t\t\tbreak;\n\t\t\tcase REQUEST_CODE_USER:\n\t\t\t\tint actionId = data.getExtras().getInt(Extra.ACTION);\n\t\t\t\tString nickname = data.getExtras().getString(Extra.USER);\n\n\t\t\t\t// XXX: Implement me - The action should be handled after onResume()\n\t\t\t\t//                     to catch the broadcasts\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * On channel selected/focused\n\t */\n\tpublic void onItemSelected(AdapterView<?> deck, View view, int position, long id)\n\t{\n\t\tConversation conversation = (Conversation) deck.getItemAtPosition(position);\n\t\t\n\t\tif (conversation != null && conversation.getType() != Conversation.TYPE_SERVER) {\n\t\t\t((TextView) findViewById(R.id.title)).setText(server.getTitle() + \" - \" + conversation.getName());\n\t\t} else {\n\t\t\tonNothingSelected(deck);\n\t\t}\n\t\t\n\t\t// Remember selection\n\t\tif (conversation != null) {\n\t\t\tserver.getConversation(server.getSelectedConversation()).setStatus(Conversation.STATUS_DEFAULT);\n\t\t\tconversation.setStatus(Conversation.STATUS_SELECTED);\n\t\t\tserver.setSelectedConversation(conversation.getName());\n\t\t}\n\t}\n\n\t/**\n\t * On no channel selected/focused\n\t */\n\tpublic void onNothingSelected(AdapterView<?> deck)\n\t{\n\t\t((TextView) findViewById(R.id.title)).setText(server.getTitle());\n\t}\n}\n","Method after Refactoring":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2010 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.activity;\n\nimport java.util.Collection;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.content.ComponentName;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.os.Bundle;\nimport android.os.IBinder;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.Window;\nimport android.view.View.OnKeyListener;\nimport android.widget.AdapterView;\nimport android.widget.EditText;\nimport android.widget.Gallery;\nimport android.widget.ImageView;\nimport android.widget.ListView;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport android.widget.ViewSwitcher;\nimport android.widget.AdapterView.OnItemClickListener;\nimport android.widget.AdapterView.OnItemSelectedListener;\nimport android.widget.TableLayout.LayoutParams;\n\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.adapter.DeckAdapter;\nimport org.yaaic.adapter.MessageListAdapter;\nimport org.yaaic.command.CommandParser;\nimport org.yaaic.irc.IRCBinder;\nimport org.yaaic.irc.IRCService;\nimport org.yaaic.layout.NonScalingBackgroundDrawable;\nimport org.yaaic.listener.ConversationListener;\nimport org.yaaic.listener.ServerListener;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.model.Extra;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Scrollback;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.ServerInfo;\nimport org.yaaic.model.Status;\nimport org.yaaic.receiver.ConversationReceiver;\nimport org.yaaic.receiver.ServerReceiver;\nimport org.yaaic.view.MessageListView;\nimport org.yaaic.view.ConversationSwitcher;\n\n/**\n * The server view with a scrollable list of all channels\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class ConversationActivity extends Activity implements ServiceConnection, ServerListener, ConversationListener, OnItemClickListener, OnKeyListener, OnItemSelectedListener\n{\n\tprivate static final int REQUEST_CODE_JOIN = 1;\n\tprivate static final int REQUEST_CODE_USERS = 2;\n\tprivate static final int REQUEST_CODE_USER = 3;\n\t\n\tprivate int serverId;\n\tprivate Server server;\n\tprivate IRCBinder binder;\n\tprivate ConversationReceiver channelReceiver;\n\tprivate ServerReceiver serverReceiver;\n\t\n\tprivate ViewSwitcher switcher;\n\tprivate Gallery deck;\n\tprivate DeckAdapter deckAdapter;\n\tprivate Scrollback scrollback;\n\tprivate ConversationSwitcher dots;\n\t\n\t// XXX: This is ugly. This is a buffer for a channel that should be joined after showing the\n\t//      JoinActivity. As onActivityResult() is called before onResume() a \"channel joined\"\n\t//      broadcast may get lost as the broadcast receivers are registered in onResume() but the\n\t//      join command would be called in onActivityResult(). joinChannelBuffer will save the\n\t//      channel name in onActivityResult() and run the join command in onResume().\n\tprivate String joinChannelBuffer;\n\t\n\t/**\n\t * On create\n\t */\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState)\n\t{\n\t\tsuper.onCreate(savedInstanceState);\n\t\trequestWindowFeature(Window.FEATURE_NO_TITLE);\n\t\t\n\t\tserverId = getIntent().getExtras().getInt(\"serverId\");\n\t\tserver = (Server) Yaaic.getInstance().getServerById(serverId);\n\t\tsetTitle(\"Yaaic - \" + server.getTitle());\n\t\t\n\t\tsetContentView(R.layout.conversations);\n\t\t\n\t\t((TextView) findViewById(R.id.title)).setText(server.getTitle());\n\t\t((EditText) findViewById(R.id.input)).setOnKeyListener(this);\n\t\t\n        deckAdapter = new DeckAdapter();\n\t\tdeck = (Gallery) findViewById(R.id.deck);\n\t\tdeck.setOnItemSelectedListener(this);\n\t\tdeck.setAdapter(deckAdapter);\n\t\tdeck.setOnItemClickListener(this);\n\t\tdeck.setBackgroundDrawable(new NonScalingBackgroundDrawable(this, deck, R.drawable.background));\n\t\t\n\t\tif (server.getStatus() == Status.PRE_CONNECTING) {\n\t\t\tserver.clearConversations();\n\t\t\tdeckAdapter.clearConversations();\n\t\t}\n\n\t\tswitcher = (ViewSwitcher) findViewById(R.id.switcher);\n\t\t\n\t\t// Optimization : cache field lookups \n\t\tCollection<Conversation> mConversations = server.getConversations();\n\t\t\n\t\tfor (Conversation conversation : mConversations) {\n\t\t\tonNewConversation(conversation.getName());\n\t\t}\n\t\t\n\t\t// Create a new scrollback history\n\t\tscrollback = new Scrollback();\n\t}\n\t\n\t/**\n\t * On resume\n\t */\n\t@Override\n\tpublic void onResume()\n\t{\n\t\t// register the receivers as early as possible, otherwise we may loose a broadcast message\n\t\tchannelReceiver = new ConversationReceiver(server.getId(), this);\n\t\tregisterReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_MESSAGE));\n\t\tregisterReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_NEW));\n\t\tregisterReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_REMOVE));\n\t\t\n\t\tserverReceiver = new ServerReceiver(this);\n\t\tregisterReceiver(serverReceiver, new IntentFilter(Broadcast.SERVER_UPDATE));\n\t\t\n\t\tsuper.onResume();\n\t\t\n\t\t((ImageView) findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\t\t\n\t\t// Start service\n        Intent intent = new Intent(this, IRCService.class);\n        intent.setAction(IRCService.ACTION_FOREGROUND);\n        startService(intent);\n        bindService(intent, this, 0);\n        \n\t\tif (!server.isConnected()) {\n\t\t\t ((EditText) findViewById(R.id.input)).setEnabled(false);\n\t\t} else {\n\t\t\t ((EditText) findViewById(R.id.input)).setEnabled(true);\n\t\t}\n\t\t\n\t\tdots = (ConversationSwitcher) findViewById(R.id.dots);\n\t\tdots.setServer(server);\n\n\t\t// Optimization - cache field lookup\n\t\tCollection<Conversation> mConversations = server.getConversations();\n\t\tMessageListAdapter mAdapter;\n\t\t\n\t\t// Fill view with messages that have been buffered while paused\n\t\tfor (Conversation conversation : mConversations) {\n\t\t\tmAdapter = conversation.getMessageListAdapter();\n\t\t\t\n\t\t\tif (mAdapter != null) {\n\t\t\t\tmAdapter.addBulkMessages(conversation.getBuffer());\n\t\t\t\tconversation.clearBuffer();\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Join channel that has been selected in JoinActivity (onActivityResult())\n\t\tif (joinChannelBuffer != null) {\n\t\t\tnew Thread() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tbinder.getService().getConnection(serverId).joinChannel(joinChannelBuffer);\n\t\t\t\t\tjoinChannelBuffer = null;\n\t\t\t\t}\n\t\t\t}.start();\n\t\t}\n\t}\n\t\n\t/**\n\t * On Pause\n\t */\n\t@Override\n\tpublic void onPause()\n\t{\n\t\tsuper.onPause();\n\t\t\n\t\tif (binder != null && binder.getService() != null) {\n\t\t\tbinder.getService().checkServiceStatus();\n\t\t}\n\t\t\n\t\t/*if (!binder.getService().hasConnections()) {\n\t\t\tLog.d(\"Yaaic\", \"Stopping service\");\n\t\t\t//binder.getService().stopSelf();\n\t\t} else {\n\t\t\tLog.d(\"Yaaic\", \"Unbinding service\");\n\t\t}*/\n\n\t\tunbindService(this);\n\t\tunregisterReceiver(channelReceiver);\n\t\tunregisterReceiver(serverReceiver);\n\t}\n\n\t/**\n\t * On service connected\n\t */\n\tpublic void onServiceConnected(ComponentName name, IBinder service)\n\t{\n\t\tthis.binder = (IRCBinder) service;\n\t\t\n\t\t// connect to irc server if connect has been requested\n\t\tif (server.getStatus() == Status.PRE_CONNECTING && getIntent().hasExtra(\"connect\")) {\n\t\t\tserver.setStatus(Status.CONNECTING);\n\t\t\tbinder.connect(server);\n\t\t}\n\t}\n\n\t/**\n\t * On service disconnected\n\t */\n\tpublic void onServiceDisconnected(ComponentName name)\n\t{\n\t\tthis.binder = null;\n\t}\n\n\t/**\n\t * On options menu requested\n\t */\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu)\n\t{\n    \tsuper.onCreateOptionsMenu(menu);\n    \t\n    \t// inflate from xml\n    \tMenuInflater inflater = getMenuInflater();\n    \tinflater.inflate(R.menu.conversations, menu);\n    \t\n    \treturn true;\n\t}\n\t\n\t/**\n\t * On prepare options menu\n\t */\n\t@Override\n\tpublic boolean onPrepareOptionsMenu(Menu menu)\n\t{\n\t\tmenu.getItem(0).setEnabled(server.isConnected()); // join\n\t\tmenu.getItem(1).setEnabled(server.isConnected()); // users\n\t\tmenu.getItem(2).setEnabled(server.isConnected()); // close\n\t\t\n\t\treturn true;\n\t}\n\n\t/**\n\t * On menu item selected\n\t */\n\t@Override\n\tpublic boolean onMenuItemSelected(int featureId, MenuItem item)\n\t{\n\t\tswitch (item.getItemId()) {\n\t\t\tcase R.id.disconnect:\n\t\t\t\tserver.setStatus(Status.DISCONNECTED);\n\t\t\t\tbinder.getService().getConnection(serverId).quitServer();\n\t\t\t\tserver.clearConversations();\n\t\t\t\tsetResult(RESULT_OK);\n\t\t\t\tfinish();\n\t\t\t\tbreak;\n\t\t\tcase R.id.close:\n\t\t\t\tConversation conversationToClose = deckAdapter.getItem(deck.getSelectedItemPosition());\n\t\t\t\t// Make sure we part a channel when closing the channel conversation\n\t\t\t\tif (conversationToClose.getType() == Conversation.TYPE_CHANNEL) {\n\t\t\t\t\tbinder.getService().getConnection(serverId).partChannel(conversationToClose.getName());\n\t\t\t\t}\n\t\t\t\telse if (conversationToClose.getType() == Conversation.TYPE_QUERY) {\n\t\t\t\t\tserver.removeConversation(conversationToClose.getName());\n\t\t\t\t\tonRemoveConversation(conversationToClose.getName());\n\t\t\t\t} else {\n\t\t\t\t\tToast.makeText(this, \"You can not close the server info window\", Toast.LENGTH_SHORT).show();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase R.id.join:\n\t\t\t\tstartActivityForResult(new Intent(this, JoinActivity.class), REQUEST_CODE_JOIN);\n\t\t\t\tbreak;\n\t\t\tcase R.id.users:\n\t\t\t\tConversation conversationForUserList = deckAdapter.getItem(deck.getSelectedItemPosition());\n\t\t\t\tif (conversationForUserList.getType() == Conversation.TYPE_CHANNEL) {\n\t\t\t\t\tIntent intent = new Intent(this, UsersActivity.class);\n\t\t\t\t\tintent.putExtra(\n\t\t\t\t\t\tExtra.USERS,\n\t\t\t\t\t\tbinder.getService().getConnection(server.getId()).getUsersAsStringArray(\n\t\t\t\t\t\t\tconversationForUserList.getName()\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t\tstartActivityForResult(intent, REQUEST_CODE_USERS);\n\t\t\t\t} else {\n\t\t\t\t\tToast.makeText(this, \"Only usable from within a channel\", Toast.LENGTH_SHORT).show();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\t/**\n\t * Get server object assigned to this activity\n\t * \n\t * @return the server object\n\t */\n\tpublic Server getServer()\n\t{\n\t\treturn server;\n\t}\n\n\t/**\n\t * On conversation message\n\t */\n\tpublic void onConversationMessage(String target)\n\t{\n\t\tConversation conversation = server.getConversation(target);\n\t\tMessageListAdapter adapter = conversation.getMessageListAdapter();\n\t\t\n\t\tconversation.setStatus(Conversation.STATUS_MESSAGE);\n\t\tif (dots != null) {\n\t\t\tdots.invalidate();\n\t\t}\n\t\t\n\t\twhile(conversation.hasBufferedMessages()) {\n\t\t\tMessage message = conversation.pollBufferedMessage();\n\t\t\t\n\t\t\tif (adapter != null) {\n\t\t\t\tadapter.addMessage(message);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * On new conversation\n\t */\n\tpublic void onNewConversation(String target)\n\t{\n\t\tdeckAdapter.addItem(server.getConversation(target));\n\t\t\n\t\tif (!deckAdapter.isSwitched()) {\n\t\t\t// Scroll to new conversation\n\t\t\tdeck.setSelection(deckAdapter.getCount() - 1);\n\t\t}\n\t}\n\t\n\t/**\n\t * On conversation remove\n\t */\n\tpublic void onRemoveConversation(String target)\n\t{\n\t\tdeckAdapter.removeItem(target);\n\t\t\n\t\tif (deckAdapter.isSwitched()) {\n\t\t\tswitcher.showNext();\n\t\t\tswitcher.removeView(deckAdapter.getSwitchedView());\n\t\t\tdeckAdapter.setSwitched(null, null);\n\t\t}\n\t}\n\n\t/**\n\t * On server status update\n\t */\n\tpublic void onStatusUpdate()\n\t{\n\t\t((ImageView) findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\t\t\n\t\tEditText input = (EditText) findViewById(R.id.input);\n\n\t\tif (server.isConnected()) {\n\t\t\tinput.setEnabled(true); \n\t\t} else {\n\t\t\tinput.setEnabled(false);\n\n\t\t\tif (server.getStatus() == Status.CONNECTING) {\n\t\t\t\tdeckAdapter.clearConversations();\n\t\t\t\tdeckAdapter.addItem(server.getConversation(ServerInfo.DEFAULT_NAME));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!binder.getService().getSettings().isReconnectEnabled()) {\n\t\t\t\tAlertDialog.Builder builder = new AlertDialog.Builder(this);\n\t\t\t\tbuilder.setMessage(\"You disconnected from \" + server.getTitle() + \". Do you want to reconnect?\")\n\t\t\t\t.setCancelable(false)\n\t\t\t\t.setPositiveButton(\"Yes\", new DialogInterface.OnClickListener() {\n\t\t\t\t\tpublic void onClick(DialogInterface dialog, int id) {\n\t\t\t\t\t\tbinder.getService().getConnection(server.getId()).setAutojoinChannels(\n\t\t\t\t\t\t\tserver.getCurrentChannelNames()\n\t\t\t\t\t\t);\n\t\t\t\t\t\tserver.clearConversations();\n\t\t\t\t\t\tdeckAdapter.clearConversations();\n\t\t\t\t\t\tdeckAdapter.addItem(server.getConversation(ServerInfo.DEFAULT_NAME));\n\t\t\t\t\t\tbinder.connect(server);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.setNegativeButton(\"No\", new DialogInterface.OnClickListener() {\n\t\t\t\t\tpublic void onClick(DialogInterface dialog, int id) {\n\t\t\t\t\t\tdialog.cancel();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tAlertDialog alert = builder.create();\n\t\t\t\talert.show();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * On conversation item clicked\n\t */\n\tpublic void onItemClick(AdapterView<?> adapterView, View view, int position, long id)\n\t{\n\t\tConversation conversation = deckAdapter.getItem(position);\n\t\t\n\t\tMessageListView canvas = deckAdapter.renderConversation(conversation, switcher);\n\t\tcanvas.setTranscriptMode(ListView.TRANSCRIPT_MODE_NORMAL);\n\t\tcanvas.setLayoutParams(new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT));\n\t\tcanvas.setDelegateTouchEvents(false); // Do not delegate\n\t\t\n\t\tdeckAdapter.setSwitched(conversation.getName(), canvas);\n\t\tswitcher.addView(canvas);\n\t\tswitcher.showNext();\n\t}\n\t\n\t/**\n\t * On key down\n\t *\n\t * XXX: As we only track the back key: Android >= 2.0 will call a method called onBackPressed()\n\t */\n\t@Override\n\tpublic boolean onKeyDown(int keyCode, KeyEvent event)\n\t{\n\t\tif (keyCode == KeyEvent.KEYCODE_BACK && event.getRepeatCount() == 0) {\n\t\t\tif (deckAdapter.isSwitched()) {\n\t\t\t\tswitcher.showNext();\n\t\t\t\tswitcher.removeView(deckAdapter.getSwitchedView());\n\t\t\t\tdeckAdapter.setSwitched(null, null);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn super.onKeyDown(keyCode, event);\n\t}\n\n\t/**\n\t * On key pressed (input line)\n\t */\n\tpublic boolean onKey(View view, int keyCode, KeyEvent event)\n\t{\n\t\tEditText input = (EditText) view;\n\t\t\n\t\tif (keyCode == KeyEvent.KEYCODE_DPAD_UP && event.getAction() == KeyEvent.ACTION_DOWN) {\n\t\t\tString message = scrollback.goBack();\n\t\t\tif (message != null) {\n\t\t\t\tinput.setText(message);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tif (keyCode == KeyEvent.KEYCODE_DPAD_DOWN && event.getAction() == KeyEvent.ACTION_DOWN) {\n\t\t\tString message = scrollback.goForward();\n\t\t\tif (message != null) {\n\t\t\t\tinput.setText(message);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tif (keyCode == KeyEvent.KEYCODE_ENTER && event.getAction() == KeyEvent.ACTION_UP) {\n\t\t\tif (!server.isConnected()) {\n\t\t\t\tMessage message = new Message(\"Not connected\");\n\t\t\t\tmessage.setColor(Message.COLOR_RED);\n\t\t\t\tmessage.setIcon(R.drawable.error);\n\t\t\t\tserver.getConversation(server.getSelectedConversation()).addMessage(message);\n\t\t\t\tonConversationMessage(server.getSelectedConversation());\n\t\t\t}\n\t\t\t\n\t\t\tString text = input.getText().toString();\n\t\t\tinput.setText(\"\");\n\t\t\t\n\t\t\tif (text.equals(\"\")) {\n\t\t\t\t// ignore empty messages\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\tscrollback.addMessage(text);\n\t\t\t\n\t\t\tConversation conversation = deckAdapter.getItem(deck.getSelectedItemPosition());\n\t\t\t\n\t\t\tif (conversation != null) {\n\t\t\t\tif (!text.trim().startsWith(\"/\")) {\n\t\t\t\t\tif (conversation.getType() != Conversation.TYPE_SERVER) {\n\t\t\t\t\t\tString nickname = binder.getService().getConnection(serverId).getNick();\n\t\t\t\t\t\tconversation.addMessage(new Message(\"<\" + nickname + \"> \" + text));\n\t\t\t\t\t\tbinder.getService().getConnection(serverId).sendMessage(conversation.getName(), text);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tMessage message = new Message(\"You can only chat from within a channel or a query\");\n\t\t\t\t\t\tmessage.setColor(Message.COLOR_YELLOW);\n\t\t\t\t\t\tmessage.setIcon(R.drawable.warning);\n\t\t\t\t\t\tconversation.addMessage(message);\n\t\t\t\t\t}\n\t\t\t\t\tonConversationMessage(conversation.getName());\n\t\t\t\t} else {\n\t\t\t\t\tCommandParser.getInstance().parse(text, server, conversation, binder.getService());\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * On activity result\n\t */\n\t@Override\n\tprotected void onActivityResult(int requestCode, int resultCode, Intent data)\n\t{\n\t\tif (resultCode != RESULT_OK) {\n\t\t\t// ignore other result codes\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// currently there's only the \"join channel\" activity\n\t\tswitch (requestCode) {\n\t\t\tcase REQUEST_CODE_JOIN:\n\t\t\t\tjoinChannelBuffer = data.getExtras().getString(\"channel\");\n\t\t\t\tbreak;\n\t\t\tcase REQUEST_CODE_USERS:\n\t\t\t\tIntent intent = new Intent(this, UserActivity.class);\n\t\t\t\tintent.putExtra(Extra.USER, data.getStringExtra(Extra.USER));\n\t\t\t\tstartActivityForResult(intent, REQUEST_CODE_USER);\n\t\t\t\tbreak;\n\t\t\tcase REQUEST_CODE_USER:\n\t\t\t\tint actionId = data.getExtras().getInt(Extra.ACTION);\n\t\t\t\tString nickname = data.getExtras().getString(Extra.USER);\n\n\t\t\t\t// XXX: Implement me - The action should be handled after onResume()\n\t\t\t\t//                     to catch the broadcasts\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * On channel selected/focused\n\t */\n\tpublic void onItemSelected(AdapterView<?> deck, View view, int position, long id)\n\t{\n\t\tConversation conversation = (Conversation) deck.getItemAtPosition(position);\n\t\t\n\t\tif (conversation != null && conversation.getType() != Conversation.TYPE_SERVER) {\n\t\t\t((TextView) findViewById(R.id.title)).setText(server.getTitle() + \" - \" + conversation.getName());\n\t\t} else {\n\t\t\tonNothingSelected(deck);\n\t\t}\n\t\t\n\t\t// Remember selection\n\t\tif (conversation != null) {\n\t\t\tConversation previousConversation = server.getConversation(server.getSelectedConversation());\n\t\t\t\n\t\t\tif (previousConversation != null) {\n\t\t\t\tpreviousConversation.setStatus(Conversation.STATUS_DEFAULT);\n\t\t\t}\n\t\t\t\n\t\t\tconversation.setStatus(Conversation.STATUS_SELECTED);\n\t\t\tserver.setSelectedConversation(conversation.getName());\n\t\t}\n\t}\n\n\t/**\n\t * On no channel selected/focused\n\t */\n\tpublic void onNothingSelected(AdapterView<?> deck)\n\t{\n\t\t((TextView) findViewById(R.id.title)).setText(server.getTitle());\n\t}\n}\n","lineNo":587}
{"Smelly Sample":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2010 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.view;\n\nimport android.content.Context;\nimport android.graphics.Canvas;\nimport android.graphics.Paint;\nimport android.graphics.Rect;\nimport android.util.AttributeSet;\nimport android.util.Log;\nimport android.view.View;\n\n/**\n * The ConversationSwitcher - The small funny dots at the top ;)\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class ConversationSwitcher extends View\n{\n\tprivate Paint paint;\n\t\n\t/**\n\t * Create a new ConversationSwitcher\n\t * \n\t * @param context The Context the view is running in, through which it can access the current theme, resources, etc.\n\t */\n\tpublic ConversationSwitcher(Context context, AttributeSet attributes)\n\t{\n\t\tsuper(context, attributes);\n\t\t\n\t\tpaint = new Paint();\n\t}\n\t\n\tprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)\n\t{\n\t\tint width = MeasureSpec.getSize(widthMeasureSpec);\n\t\tLog.d(\"Yaaic\", width + \" x \" + 20);\n\t\tsetMeasuredDimension(width, 20);\n\t}\n\t\n\t/**\n\t * On draw\n\t */\n\tprotected void onDraw(Canvas canvas)\n\t{\n\t\tsuper.onDraw(canvas);\n\t\t\n\t\t// Draw debug lines\n\t\tpaint.setColor(0xFFFF0000);\n\t\tpaint.setStyle(Paint.Style.STROKE);\n\t\tcanvas.drawRect(new Rect(0, 0, getWidth() - 1, getHeight() - 1), paint);\n\t\t\n\t\tLog.d(\"Yaaic\", \"Circle at \" + (getWidth() / 2) + \" x \" + (getHeight() / 2));\n\n\t\t// Draw dots\n\t\tpaint.setColor(0xFFFFFFFF);\n\t\tpaint.setStyle(Paint.Style.FILL);\n\t\tcanvas.drawCircle(getWidth() / 2, getHeight() / 2, 5, paint);\n\t}\n}\n","Method after Refactoring":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2010 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.view;\n\nimport java.util.Collection;\n\nimport org.yaaic.model.Conversation;\nimport org.yaaic.model.Server;\n\nimport android.content.Context;\nimport android.graphics.Canvas;\nimport android.graphics.Paint;\nimport android.graphics.Rect;\nimport android.util.AttributeSet;\nimport android.util.Log;\nimport android.view.View;\n\n/**\n * The ConversationSwitcher - The small funny dots at the top ;)\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class ConversationSwitcher extends View\n{\n\tprivate static final boolean DEBUG_MODE = false;\n\t\n\tprivate Server server;\n\tprivate Paint paint;\n\t\n\t/**\n\t * Create a new ConversationSwitcher\n\t * \n\t * @param context The Context the view is running in, through which it can access the current theme, resources, etc.\n\t */\n\tpublic ConversationSwitcher(Context context, AttributeSet attributes)\n\t{\n\t\tsuper(context, attributes);\n\t\t\n\t\tpaint = new Paint();\n\t}\n\t\n\t/**\n\t * Set the server whos conversations should be displayed\n\t * \n\t * @param server\n\t */\n\tpublic void setServer(Server server)\n\t{\n\t\tthis.server = server;\n\t}\n\t\n\t/**\n\t * Measure the size of the view\n\t * \n\t * @param widthMeasureSpec\n\t * @param heightMeasureSpec\n\t */\n\tprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)\n\t{\n\t\tint width = MeasureSpec.getSize(widthMeasureSpec);\n\t\tLog.d(\"Yaaic\", width + \" x \" + 20);\n\t\tsetMeasuredDimension(width, 20);\n\t}\n\t\n\t/**\n\t * On draw\n\t */\n\tprotected void onDraw(Canvas canvas)\n\t{\n\t\tsuper.onDraw(canvas);\n\t\n\t\tif (DEBUG_MODE) {\n\t\t\t// Draw debug lines\n\t\t\tpaint.setColor(0xFFFF0000);\n\t\t\tpaint.setStyle(Paint.Style.STROKE);\n\t\t\tcanvas.drawRect(new Rect(0, 0, getWidth() - 1, getHeight() - 1), paint);\n\t\t}\n\t\t\n\t\t//Log.d(\"Yaaic\", \"Drawing...\");\n\t\t\n\t\tif (server == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tint width = getWidth();\n\t\tint height = getHeight();\n\t\t\n\t\tCollection<Conversation> conversations = server.getConversations();\n\t\tint circles = conversations.size();\n\t\t\n\t\tint startX = width / 2 - circles * 14;\n\t\t\n\t\tpaint.setColor(0xFFDDDDDD);\n\t\tpaint.setStyle(Paint.Style.FILL);\n\t\t\n\t\tint i = 0;\n\t\t\n\t\tfor (Conversation conversation : conversations) {\n\t\t\tswitch (conversation.getStatus()) {\n\t\t\t\tcase Conversation.STATUS_DEFAULT:\n\t\t\t\t\tpaint.setColor(0xFF888888);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Conversation.STATUS_HIGHLIGHT:\n\t\t\t\t\tpaint.setColor(0xFFDD0000);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Conversation.STATUS_MESSAGE:\n\t\t\t\t\tpaint.setColor(0xFF00DD00);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Conversation.STATUS_SELECTED:\n\t\t\t\t\tpaint.setColor(0xFFFFFFFF);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tcanvas.drawCircle(startX + 14 * i, height / 2, 5, paint);\n\t\t\ti++;\n\t\t}\n\t\t\n\t}\n}\n","lineNo":103}
{"Smelly Sample":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2010 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.activity;\n\nimport java.util.ArrayList;\n\nimport org.yaaic.R;\nimport org.yaaic.model.Extra;\n\nimport android.app.Activity;\nimport android.content.Intent;\nimport android.os.Bundle;\nimport android.view.View;\nimport android.view.View.OnClickListener;\nimport android.widget.ArrayAdapter;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.ListView;\n\n/**\n * Adding channels to a server\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class AddChannelActivity extends Activity implements OnClickListener\n{\n\tprivate EditText channelInput;\n\tprivate ArrayAdapter<String> adapter;\n\tprivate ArrayList<String> channels;\n\t\n\t/**\n\t * On create\n\t */\n\t@Override\n\tpublic void onCreate(Bundle savedInstanceState)\n\t{\n\t\tsuper.onCreate(savedInstanceState);\n\t\t\n\t\tsetContentView(R.layout.channeladd);\n\t\t\n\t\tchannelInput = (EditText) findViewById(R.id.channel);\n\t\t\n\t\tadapter = new ArrayAdapter<String>(this, R.layout.channelitem);\n\t\t((ListView) findViewById(R.id.channels)).setAdapter(adapter);\n\t\t\n\t\t((Button) findViewById(R.id.add)).setOnClickListener(this);\n\t\t((Button) findViewById(R.id.ok)).setOnClickListener(this);\n\t\t((Button) findViewById(R.id.cancel)).setOnClickListener(this);\n\t\t\n\t\tchannels = getIntent().getExtras().getStringArrayList(Extra.CHANNELS);\n\t\t\n\t\tfor (String channel : channels) {\n\t\t\tadapter.add(channel);\n\t\t}\n\t}\n\n\t/**\n\t * On Click\n\t */\n\tpublic void onClick(View v)\n\t{\n\t\tswitch (v.getId()) {\n\t\t\tcase R.id.add:\n\t\t\t\tString channel = channelInput.getText().toString();\n\t\t\t\tchannels.add(channel);\n\t\t\t\tadapter.add(channel);\n\t\t\t\tchannelInput.setText(\"#\");\n\t\t\t\tbreak;\n\t\t\tcase R.id.cancel:\n\t\t\t\tsetResult(RESULT_CANCELED);\n\t\t\t\tfinish();\n\t\t\t\tbreak;\n\t\t\tcase R.id.ok:\n\t\t\t\t// Get list and return as result\n\t\t\t\tIntent intent = new Intent();\n\t\t\t\tintent.putExtra(Extra.CHANNELS, channels);\n\t\t\t\tsetResult(RESULT_OK, intent);\n\t\t\t\tfinish();\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n","Method after Refactoring":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2010 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.activity;\n\nimport java.util.ArrayList;\n\nimport org.yaaic.R;\nimport org.yaaic.model.Extra;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.os.Bundle;\nimport android.view.View;\nimport android.view.Window;\nimport android.view.View.OnClickListener;\nimport android.widget.AdapterView;\nimport android.widget.ArrayAdapter;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.ListView;\nimport android.widget.AdapterView.OnItemClickListener;\n\n/**\n * Adding auto join channels to a server\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class AddChannelActivity extends Activity implements OnClickListener, OnItemClickListener\n{\n\tprivate EditText channelInput;\n\tprivate ArrayAdapter<String> adapter;\n\tprivate ArrayList<String> channels;\n\t\n\t/**\n\t * On create\n\t */\n\t@Override\n\tpublic void onCreate(Bundle savedInstanceState)\n\t{\n\t\tsuper.onCreate(savedInstanceState);\n\t\trequestWindowFeature(Window.FEATURE_NO_TITLE);\n\t\t\n\t\tsetContentView(R.layout.channeladd);\n\t\t\n\t\tchannelInput = (EditText) findViewById(R.id.channel);\n\t\t\n\t\tadapter = new ArrayAdapter<String>(this, R.layout.channelitem);\n\t\t\n\t\tListView list = (ListView) findViewById(R.id.channels);\n\t\tlist.setAdapter(adapter);\n\t\tlist.setOnItemClickListener(this);\n\t\t\n\t\t((Button) findViewById(R.id.add)).setOnClickListener(this);\n\t\t((Button) findViewById(R.id.ok)).setOnClickListener(this);\n\t\t((Button) findViewById(R.id.cancel)).setOnClickListener(this);\n\t\t\n\t\tchannels = getIntent().getExtras().getStringArrayList(Extra.CHANNELS);\n\t\t\n\t\tfor (String channel : channels) {\n\t\t\tadapter.add(channel);\n\t\t}\n\t}\n\n\t/**\n\t * On Click\n\t */\n\tpublic void onClick(View v)\n\t{\n\t\tswitch (v.getId()) {\n\t\t\tcase R.id.add:\n\t\t\t\tString channel = channelInput.getText().toString();\n\t\t\t\tchannels.add(channel);\n\t\t\t\tadapter.add(channel);\n\t\t\t\tchannelInput.setText(\"#\");\n\t\t\t\tbreak;\n\t\t\tcase R.id.cancel:\n\t\t\t\tsetResult(RESULT_CANCELED);\n\t\t\t\tfinish();\n\t\t\t\tbreak;\n\t\t\tcase R.id.ok:\n\t\t\t\t// Get list and return as result\n\t\t\t\tIntent intent = new Intent();\n\t\t\t\tintent.putExtra(Extra.CHANNELS, channels);\n\t\t\t\tsetResult(RESULT_OK, intent);\n\t\t\t\tfinish();\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * On item clicked\n\t */\n\tpublic void onItemClick(AdapterView<?> list, View item, int position, long id)\n\t{\n\t\tfinal String channel = adapter.getItem(position);\n\t\t\n\t\tString[] items = { \"Remove\" };\n\t\t\n\t\tAlertDialog.Builder builder = new AlertDialog.Builder(this);\n\t\tbuilder.setTitle(channel);\n\t\tbuilder.setItems(items, new DialogInterface.OnClickListener() {\n\t\t    public void onClick(DialogInterface dialog, int item) {\n\t\t        switch (item) {\n\t\t\t        case 0: // Remove\n\t\t        \t\tadapter.remove(channel);\n\t\t        \t\tchannels.remove(channel);\n\t\t        \t\tbreak;\n\t\t        }\n\t\t    }\n\t\t});\n\t\tAlertDialog alert = builder.create();\n\t\talert.show();\n\t}\n}\n","lineNo":69}
{"Smelly Sample":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2010 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.activity;\n\nimport org.yaaic.R;\n\nimport android.app.Activity;\nimport android.os.Bundle;\nimport android.view.View;\nimport android.view.View.OnClickListener;\nimport android.widget.ArrayAdapter;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.ListView;\nimport android.widget.Toast;\n\n/**\n * Adding channels to a server\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class AddChannelActivity extends Activity implements OnClickListener\n{\n\tprivate ListView channelList;\n\tprivate EditText channelInput;\n\tprivate ArrayAdapter<String> adapter;\n\t\n\t/**\n\t * On create\n\t */\n\t@Override\n\tpublic void onCreate(Bundle savedInstanceState)\n\t{\n\t\tsuper.onCreate(savedInstanceState);\n\t\t\n\t\tsetContentView(R.layout.channeladd);\n\t\t\n\t\tchannelList = (ListView) findViewById(R.id.channels);\n\t\tchannelInput = (EditText) findViewById(R.id.channel);\n\t\t\n\t\tadapter = new ArrayAdapter<String>(this, R.layout.channelitem);\n\t\tchannelList.setAdapter(adapter);\n\t\t\n\t\t((Button) findViewById(R.id.add)).setOnClickListener(this);\n\t\t((Button) findViewById(R.id.save)).setOnClickListener(this);\n\t\t((Button) findViewById(R.id.cancel)).setOnClickListener(this);\n\t}\n\n\t/**\n\t * On Click\n\t */\n\tpublic void onClick(View v)\n\t{\n\t\tswitch (v.getId()) {\n\t\t\tcase R.id.add:\n\t\t\t\tadapter.add(channelInput.getText().toString());\n\t\t\t\tbreak;\n\t\t\tcase R.id.cancel:\n\t\t\t\tsetResult(RESULT_CANCELED);\n\t\t\t\tfinish();\n\t\t\t\tbreak;\n\t\t\tcase R.id.save:\n\t\t\t\t// Get list and return as result\n\t\t\t\t\n\t\t\t\tsetResult(RESULT_OK);\n\t\t\t\tfinish();\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n","Method after Refactoring":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2010 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.activity;\n\nimport java.util.ArrayList;\n\nimport org.yaaic.R;\nimport org.yaaic.model.Extra;\n\nimport android.app.Activity;\nimport android.content.Intent;\nimport android.os.Bundle;\nimport android.view.View;\nimport android.view.View.OnClickListener;\nimport android.widget.ArrayAdapter;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.ListView;\n\n/**\n * Adding channels to a server\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class AddChannelActivity extends Activity implements OnClickListener\n{\n\tprivate EditText channelInput;\n\tprivate ArrayAdapter<String> adapter;\n\tprivate ArrayList<String> channels;\n\t\n\t/**\n\t * On create\n\t */\n\t@Override\n\tpublic void onCreate(Bundle savedInstanceState)\n\t{\n\t\tsuper.onCreate(savedInstanceState);\n\t\t\n\t\tsetContentView(R.layout.channeladd);\n\t\t\n\t\tchannelInput = (EditText) findViewById(R.id.channel);\n\t\t\n\t\tadapter = new ArrayAdapter<String>(this, R.layout.channelitem);\n\t\t((ListView) findViewById(R.id.channels)).setAdapter(adapter);\n\t\t\n\t\t((Button) findViewById(R.id.add)).setOnClickListener(this);\n\t\t((Button) findViewById(R.id.save)).setOnClickListener(this);\n\t\t((Button) findViewById(R.id.cancel)).setOnClickListener(this);\n\t\t\n\t\tchannels = getIntent().getExtras().getStringArrayList(Extra.CHANNELS);\n\t\t\n\t\tfor (String channel : channels) {\n\t\t\tadapter.add(channel);\n\t\t}\n\t}\n\n\t/**\n\t * On Click\n\t */\n\tpublic void onClick(View v)\n\t{\n\t\tswitch (v.getId()) {\n\t\t\tcase R.id.add:\n\t\t\t\tString channel = channelInput.getText().toString();\n\t\t\t\tchannels.add(channel);\n\t\t\t\tadapter.add(channel);\n\t\t\t\tbreak;\n\t\t\tcase R.id.cancel:\n\t\t\t\tsetResult(RESULT_CANCELED);\n\t\t\t\tfinish();\n\t\t\t\tbreak;\n\t\t\tcase R.id.save:\n\t\t\t\t// Get list and return as result\n\t\t\t\tIntent intent = new Intent();\n\t\t\t\tintent.putExtra(Extra.CHANNELS, channels);\n\t\t\t\tsetResult(RESULT_OK, intent);\n\t\t\t\tfinish();\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n","lineNo":82}
{"Smelly Sample":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2010 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.activity;\n\nimport java.io.UnsupportedEncodingException;\nimport java.util.regex.Pattern;\n\nimport android.app.Activity;\nimport android.content.Intent;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.view.View;\nimport android.view.View.OnClickListener;\nimport android.widget.ArrayAdapter;\nimport android.widget.Button;\nimport android.widget.CheckBox;\nimport android.widget.EditText;\nimport android.widget.Spinner;\nimport android.widget.Toast;\n\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.db.Database;\nimport org.yaaic.exception.ValidationException;\nimport org.yaaic.model.Extra;\nimport org.yaaic.model.Identity;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.Status;\n\n/**\n * Add a new server to the list\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class AddServerActivity extends Activity implements OnClickListener\n{\n\tprivate Server server;\n\t\n\t/**\n\t * On create\n\t */\n\t@Override\n    public void onCreate(Bundle savedInstanceState)\n    {\n        super.onCreate(savedInstanceState);\n        \n        setContentView(R.layout.serveradd);\n        \n        ((Button) findViewById(R.id.add)).setOnClickListener(this);\n        ((Button) findViewById(R.id.cancel)).setOnClickListener(this);\n\n        Spinner spinner = (Spinner) findViewById(R.id.charset);\n        String[] charsets = getResources().getStringArray(R.array.charsets);\n        ArrayAdapter<CharSequence> adapter = new ArrayAdapter<CharSequence>(this, android.R.layout.simple_spinner_item, charsets);\n        adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);\n        spinner.setAdapter(adapter);\n        \n        ((Button) findViewById(R.id.channels)).setOnClickListener(this);\n        \n        Bundle extras = getIntent().getExtras();\n        if (extras != null && extras.containsKey(Extra.SERVER)) {\n        \t// Request to edit an existing server\n        \tDatabase db = new Database(this);\n        \tthis.server = db.getServerById(extras.getInt(Extra.SERVER));\n        \tdb.close();\n        \t\n        \t// Set server values\n        \t((EditText) findViewById(R.id.title)).setText(server.getTitle());\n        \t((EditText) findViewById(R.id.host)).setText(server.getHost());\n        \t((EditText) findViewById(R.id.port)).setText(String.valueOf(server.getPort()));\n        \t((EditText) findViewById(R.id.password)).setText(server.getPassword());\n        \t\n        \t((EditText) findViewById(R.id.nickname)).setText(server.getIdentity().getNickname());\n        \t((EditText) findViewById(R.id.ident)).setText(server.getIdentity().getIdent());\n        \t((EditText) findViewById(R.id.realname)).setText(server.getIdentity().getRealName());\n        \t((CheckBox) findViewById(R.id.useSSL)).setChecked(server.useSSL());\n        \t\n        \t((Button) findViewById(R.id.add)).setText(\"Save\");\n        \t\n        \t// Select charset\n        \tif (server.getCharset() != null) {\n        \t\tfor (int i = 0; i < charsets.length; i++) {\n        \t\t\tif (server.getCharset().equals(charsets[i])) {\n        \t\t\t\tspinner.setSelection(i);\n        \t\t\t\tbreak;\n        \t\t\t}\n        \t\t}\n        \t}\n        }\n        \n        Uri uri = getIntent().getData();\n        if (uri != null && uri.getScheme().equals(\"irc\")) {\n        \t// handling an irc:// uri\n        \t\n        \t((EditText) findViewById(R.id.host)).setText(uri.getHost());\n        \tif (uri.getPort() != -1) {\n        \t\t((EditText) findViewById(R.id.port)).setText(String.valueOf(uri.getPort()));\n        \t}\n        }\n    }\n\n\t/**\n\t * On click add server or cancel activity\n\t */\n\tpublic void onClick(View v)\n\t{\n\t\tswitch (v.getId()) {\n\t\t\tcase R.id.channels:\n\t\t\t\tstartActivityForResult(new Intent(this, AddChannelActivity.class), 0);\n\t\t\t\tbreak;\n\t\t\tcase R.id.add:\n\t\t\t\ttry {\n\t\t\t\t\tvalidateServer();\n\t\t\t\t\tvalidateIdentity();\n\t\t\t\t\tif (server == null) {\n\t\t\t\t\t\taddServer();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tupdateServer();\n\t\t\t\t\t}\n\t\t\t\t\tsetResult(RESULT_OK);\n\t\t\t\t\tfinish();\n\t\t\t\t} catch(ValidationException e) {\n\t\t\t\t\tToast.makeText(this, e.getMessage(), Toast.LENGTH_SHORT).show();\n\t\t\t\t}\n\t\t\tbreak;\n\t\t\tcase R.id.cancel:\n\t\t\t\tsetResult(RESULT_CANCELED);\n\t\t\t\tfinish();\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t/**\n\t * Add server to database\n\t */\n\tprivate void addServer()\n\t{\n\t\tDatabase db = new Database(this);\n\t\t\n\t\tIdentity identity = getIdentityFromView();\n\t\tlong identityId = db.addIdentity(\n\t\t\tidentity.getNickname(),\n\t\t\tidentity.getIdent(),\n\t\t\tidentity.getRealName()\n\t\t);\n\t\t\n\t\tServer server = getServerFromView();\n\t\tlong serverId = db.addServer(\n\t\t\tserver.getTitle(),\n\t\t\tserver.getHost(),\n\t\t\tserver.getPort(),\n\t\t\tserver.getPassword(),\n\t\t\tfalse, // auto connect\n\t\t\tserver.useSSL(),\n\t\t\tidentityId,\n\t\t\tserver.getCharset()\n\t\t);\n\t\t\n\t\tdb.close();\n\t\t\n\t\tserver.setId((int) serverId);\n\t\tserver.setIdentity(identity);\n\t\t\n\t\tYaaic.getInstance().addServer(server);\n\t}\n\t\n\t/**\n\t * Update server\n\t */\n\tprivate void updateServer()\n\t{\n\t\tDatabase db = new Database(this);\n\t\t\n\t\tint serverId = this.server.getId();\n\t\tint identityId = db.getIdentityIdByServerId(serverId);\n\t\t\n\t\tServer server = getServerFromView();\n\t\tdb.updateServer(\n\t\t\tserverId,\n\t\t\tserver.getTitle(),\n\t\t\tserver.getHost(),\n\t\t\tserver.getPort(),\n\t\t\tserver.getPassword(),\n\t\t\tfalse, // auto connect\n\t\t\tserver.useSSL(),\n\t\t\tidentityId,\n\t\t\tserver.getCharset()\n\t\t);\n\t\t\n\t\tIdentity identity = getIdentityFromView();\n\t\tdb.updateIdentity(\n\t\t\tidentityId,\n\t\t\tidentity.getNickname(),\n\t\t\tidentity.getIdent(),\n\t\t\tidentity.getNickname()\n\t\t);\n\t\t\n\t\tdb.close();\n\t\t\n\t\tserver.setId(this.server.getId());\n\t\tserver.setIdentity(identity);\n\t\t\n\t\tYaaic.getInstance().updateServer(server);\n\t}\n\t\n\t/**\n\t * Populate a server object from the data in the view\n\t * \n\t * @return The server object\n\t */\n\tprivate Server getServerFromView()\n\t{\n\t\tString title = ((EditText) findViewById(R.id.title)).getText().toString();\n\t\tString host = ((EditText) findViewById(R.id.host)).getText().toString();\n\t\tint port = Integer.parseInt(((EditText) findViewById(R.id.port)).getText().toString());\n\t\tString password = ((EditText) findViewById(R.id.password)).getText().toString();\n\t\tString charset = ((Spinner) findViewById(R.id.charset)).getSelectedItem().toString();\n\t\tBoolean useSSL = ((CheckBox) findViewById(R.id.useSSL)).isChecked();\n\t\t\n\t\t// not in use yet\n\t\t//boolean autoConnect = ((CheckBox) findViewById(R.id.autoconnect)).isChecked();\n\t\t\n\t\tServer server = new Server();\n\t\tserver.setHost(host);\n\t\tserver.setPort(port);\n\t\tserver.setPassword(password);\n\t\tserver.setTitle(title);\n\t\tserver.setCharset(charset);\n\t\tserver.setUseSSL(useSSL);\n\t\tserver.setStatus(Status.DISCONNECTED);\n\n\t\treturn server;\n\t}\n\t\n\t/**\n\t * Populate an identity object from the data in the view\n\t * \n\t * @return The identity object\n\t */\n\tprivate Identity getIdentityFromView()\n\t{\n\t\tString nickname = ((EditText) findViewById(R.id.nickname)).getText().toString();\n\t\tString ident = ((EditText) findViewById(R.id.ident)).getText().toString();\n\t\tString realname = ((EditText) findViewById(R.id.realname)).getText().toString();\n\t\t\n\t\tIdentity identity = new Identity();\n\t\tidentity.setNickname(nickname);\n\t\tidentity.setIdent(ident);\n\t\tidentity.setRealName(realname);\n\t\t\n\t\treturn identity;\n\t}\n\t\n\t/**\n\t * Validate the input for a server\n\t * \n\t * @throws ValidationException\n\t */\n\tprivate void validateServer() throws ValidationException\n\t{\n\t\tString title = ((EditText) findViewById(R.id.title)).getText().toString();\n\t\tString host = ((EditText) findViewById(R.id.host)).getText().toString();\n\t\tString port = ((EditText) findViewById(R.id.port)).getText().toString();\n\t\tString charset = ((Spinner) findViewById(R.id.charset)).getSelectedItem().toString();\n\t\t\n\t\tif (title.trim().equals(\"\")) {\n\t\t\tthrow new ValidationException(\"Title cannot be blank\");\n\t\t}\n\t\t\n\t\tif (host.trim().equals(\"\")) {\n\t\t\t// XXX: We should use some better host validation\n\t\t\tthrow new ValidationException(\"Host cannot be blank\");\n\t\t}\n\t\t\n\t\ttry {\n\t\t\tInteger.parseInt(port);\n\t\t} catch (NumberFormatException e) {\n\t\t\tthrow new ValidationException(\"Enter a numeric port\");\n\t\t}\n\t\t\n\t\ttry {\n\t\t\t\"\".getBytes(charset);\n\t\t}\n\t\tcatch (UnsupportedEncodingException e) {\n\t\t\tthrow new ValidationException(\"Charset is not supported by your device\");\n\t\t}\n\t\t\n\t\tDatabase db = new Database(this);\n\t\tif (db.isTitleUsed(title) && (server == null || !server.getTitle().equals(title))) {\n\t\t\tdb.close();\n\t\t\tthrow new ValidationException(\"There is already a server with this title\");\n\t\t}\n\t\tdb.close();\n\t}\n\t\n\t/**\n\t * Validate the input for a identity\n\t * \n\t * @throws ValidationException\n\t */\n\tprivate void validateIdentity() throws ValidationException\n\t{\n\t\tString nickname = ((EditText) findViewById(R.id.nickname)).getText().toString();\n\t\tString ident = ((EditText) findViewById(R.id.ident)).getText().toString();\n\t\tString realname = ((EditText) findViewById(R.id.realname)).getText().toString();\n\t\t\n\t\tif (nickname.trim().equals(\"\")) {\n\t\t\tthrow new ValidationException(\"Nickname cannot be blank\");\n\t\t}\n\t\t\n\t\tif (ident.trim().equals(\"\")) {\n\t\t\tthrow new ValidationException(\"Ident cannot be blank\");\n\t\t}\n\t\t\n\t\tif (realname.trim().equals(\"\")) {\n\t\t\tthrow new ValidationException(\"Realname cannot be blank\");\n\t\t}\n\t\t\n\t\t// RFC 1459:  <nick> ::= <letter> { <letter> | <number> | <special> }\n\t\t// <special>    ::= '-' | '[' | ']' | '\\' | '`' | '^' | '{' | '}'\n\t\t// Chars that are not in RFC 1459 but are supported too:\n\t\t// | and _ \n\t\tPattern nickPattern = Pattern.compile(\"^[a-zA-Z][a-zA-Z0-9^\\\\-`\\\\[\\\\]{}|_\\\\\\\\]*$\");\n\t\tif (!nickPattern.matcher(nickname).matches()) {\n\t\t\tthrow new ValidationException(\"Invalid nickname\");\n\t\t}\n\t\t\n\t\t// We currently only allow chars as ident\n\t\tPattern identPattern = Pattern.compile(\"^[a-zA-Z]+$\");\n\t\tif (!identPattern.matcher(ident).matches()) {\n\t\t\tthrow new ValidationException(\"Invalid ident\");\n\t\t}\n\t}\n}\n","Method after Refactoring":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2010 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.activity;\n\nimport java.io.UnsupportedEncodingException;\nimport java.util.ArrayList;\nimport java.util.regex.Pattern;\n\nimport android.app.Activity;\nimport android.content.Intent;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.view.View;\nimport android.view.View.OnClickListener;\nimport android.widget.ArrayAdapter;\nimport android.widget.Button;\nimport android.widget.CheckBox;\nimport android.widget.EditText;\nimport android.widget.Spinner;\nimport android.widget.Toast;\n\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.db.Database;\nimport org.yaaic.exception.ValidationException;\nimport org.yaaic.model.Extra;\nimport org.yaaic.model.Identity;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.Status;\n\n/**\n * Add a new server to the list\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class AddServerActivity extends Activity implements OnClickListener\n{\n\tprivate Server server;\n\tprivate ArrayList<String> channels;\n\t\n\t/**\n\t * On create\n\t */\n\t@Override\n    public void onCreate(Bundle savedInstanceState)\n    {\n        super.onCreate(savedInstanceState);\n        \n        setContentView(R.layout.serveradd);\n        channels = new ArrayList<String>();\n        \n        ((Button) findViewById(R.id.add)).setOnClickListener(this);\n        ((Button) findViewById(R.id.cancel)).setOnClickListener(this);\n\n        Spinner spinner = (Spinner) findViewById(R.id.charset);\n        String[] charsets = getResources().getStringArray(R.array.charsets);\n        ArrayAdapter<CharSequence> adapter = new ArrayAdapter<CharSequence>(this, android.R.layout.simple_spinner_item, charsets);\n        adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);\n        spinner.setAdapter(adapter);\n        \n        ((Button) findViewById(R.id.channels)).setOnClickListener(this);\n        \n        Bundle extras = getIntent().getExtras();\n        if (extras != null && extras.containsKey(Extra.SERVER)) {\n        \t// Request to edit an existing server\n        \tDatabase db = new Database(this);\n        \tthis.server = db.getServerById(extras.getInt(Extra.SERVER));\n        \tdb.close();\n        \t\n        \t// Set server values\n        \t((EditText) findViewById(R.id.title)).setText(server.getTitle());\n        \t((EditText) findViewById(R.id.host)).setText(server.getHost());\n        \t((EditText) findViewById(R.id.port)).setText(String.valueOf(server.getPort()));\n        \t((EditText) findViewById(R.id.password)).setText(server.getPassword());\n        \t\n        \t((EditText) findViewById(R.id.nickname)).setText(server.getIdentity().getNickname());\n        \t((EditText) findViewById(R.id.ident)).setText(server.getIdentity().getIdent());\n        \t((EditText) findViewById(R.id.realname)).setText(server.getIdentity().getRealName());\n        \t((CheckBox) findViewById(R.id.useSSL)).setChecked(server.useSSL());\n        \t\n        \t((Button) findViewById(R.id.add)).setText(\"Save\");\n        \t\n        \t// Select charset\n        \tif (server.getCharset() != null) {\n        \t\tfor (int i = 0; i < charsets.length; i++) {\n        \t\t\tif (server.getCharset().equals(charsets[i])) {\n        \t\t\t\tspinner.setSelection(i);\n        \t\t\t\tbreak;\n        \t\t\t}\n        \t\t}\n        \t}\n        }\n        \n        Uri uri = getIntent().getData();\n        if (uri != null && uri.getScheme().equals(\"irc\")) {\n        \t// handling an irc:// uri\n        \t\n        \t((EditText) findViewById(R.id.host)).setText(uri.getHost());\n        \tif (uri.getPort() != -1) {\n        \t\t((EditText) findViewById(R.id.port)).setText(String.valueOf(uri.getPort()));\n        \t}\n        }\n    }\n\t\n\t/**\n\t * On activity result\n\t */\n\t@Override\n\tprotected void onActivityResult(int requestCode, int resultCode, Intent data)\n\t{\n\t\tif (resultCode == RESULT_OK) {\n\t\t\tchannels = data.getExtras().getStringArrayList(Extra.CHANNELS);\n\t\t}\n\t}\n\n\t/**\n\t * On click add server or cancel activity\n\t */\n\tpublic void onClick(View v)\n\t{\n\t\tswitch (v.getId()) {\n\t\t\tcase R.id.channels:\n\t\t\t\tIntent intent = new Intent(this, AddChannelActivity.class);\n\t\t\t\tintent.putExtra(Extra.CHANNELS, channels);\n\t\t\t\tstartActivityForResult(intent, 0);\n\t\t\t\tbreak;\n\t\t\tcase R.id.add:\n\t\t\t\ttry {\n\t\t\t\t\tvalidateServer();\n\t\t\t\t\tvalidateIdentity();\n\t\t\t\t\tif (server == null) {\n\t\t\t\t\t\taddServer();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tupdateServer();\n\t\t\t\t\t}\n\t\t\t\t\tsetResult(RESULT_OK);\n\t\t\t\t\tfinish();\n\t\t\t\t} catch(ValidationException e) {\n\t\t\t\t\tToast.makeText(this, e.getMessage(), Toast.LENGTH_SHORT).show();\n\t\t\t\t}\n\t\t\tbreak;\n\t\t\tcase R.id.cancel:\n\t\t\t\tsetResult(RESULT_CANCELED);\n\t\t\t\tfinish();\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t/**\n\t * Add server to database\n\t */\n\tprivate void addServer()\n\t{\n\t\tDatabase db = new Database(this);\n\t\t\n\t\tIdentity identity = getIdentityFromView();\n\t\tlong identityId = db.addIdentity(\n\t\t\tidentity.getNickname(),\n\t\t\tidentity.getIdent(),\n\t\t\tidentity.getRealName()\n\t\t);\n\t\t\n\t\tServer server = getServerFromView();\n\t\tlong serverId = db.addServer(\n\t\t\tserver.getTitle(),\n\t\t\tserver.getHost(),\n\t\t\tserver.getPort(),\n\t\t\tserver.getPassword(),\n\t\t\tfalse, // auto connect\n\t\t\tserver.useSSL(),\n\t\t\tidentityId,\n\t\t\tserver.getCharset()\n\t\t);\n\t\t\n\t\tdb.close();\n\t\t\n\t\tserver.setId((int) serverId);\n\t\tserver.setIdentity(identity);\n\t\t\n\t\tYaaic.getInstance().addServer(server);\n\t}\n\t\n\t/**\n\t * Update server\n\t */\n\tprivate void updateServer()\n\t{\n\t\tDatabase db = new Database(this);\n\t\t\n\t\tint serverId = this.server.getId();\n\t\tint identityId = db.getIdentityIdByServerId(serverId);\n\t\t\n\t\tServer server = getServerFromView();\n\t\tdb.updateServer(\n\t\t\tserverId,\n\t\t\tserver.getTitle(),\n\t\t\tserver.getHost(),\n\t\t\tserver.getPort(),\n\t\t\tserver.getPassword(),\n\t\t\tfalse, // auto connect\n\t\t\tserver.useSSL(),\n\t\t\tidentityId,\n\t\t\tserver.getCharset()\n\t\t);\n\t\t\n\t\tIdentity identity = getIdentityFromView();\n\t\tdb.updateIdentity(\n\t\t\tidentityId,\n\t\t\tidentity.getNickname(),\n\t\t\tidentity.getIdent(),\n\t\t\tidentity.getNickname()\n\t\t);\n\t\t\n\t\tdb.close();\n\t\t\n\t\tserver.setId(this.server.getId());\n\t\tserver.setIdentity(identity);\n\t\t\n\t\tYaaic.getInstance().updateServer(server);\n\t}\n\t\n\t/**\n\t * Populate a server object from the data in the view\n\t * \n\t * @return The server object\n\t */\n\tprivate Server getServerFromView()\n\t{\n\t\tString title = ((EditText) findViewById(R.id.title)).getText().toString();\n\t\tString host = ((EditText) findViewById(R.id.host)).getText().toString();\n\t\tint port = Integer.parseInt(((EditText) findViewById(R.id.port)).getText().toString());\n\t\tString password = ((EditText) findViewById(R.id.password)).getText().toString();\n\t\tString charset = ((Spinner) findViewById(R.id.charset)).getSelectedItem().toString();\n\t\tBoolean useSSL = ((CheckBox) findViewById(R.id.useSSL)).isChecked();\n\t\t\n\t\t// not in use yet\n\t\t//boolean autoConnect = ((CheckBox) findViewById(R.id.autoconnect)).isChecked();\n\t\t\n\t\tServer server = new Server();\n\t\tserver.setHost(host);\n\t\tserver.setPort(port);\n\t\tserver.setPassword(password);\n\t\tserver.setTitle(title);\n\t\tserver.setCharset(charset);\n\t\tserver.setUseSSL(useSSL);\n\t\tserver.setStatus(Status.DISCONNECTED);\n\n\t\treturn server;\n\t}\n\t\n\t/**\n\t * Populate an identity object from the data in the view\n\t * \n\t * @return The identity object\n\t */\n\tprivate Identity getIdentityFromView()\n\t{\n\t\tString nickname = ((EditText) findViewById(R.id.nickname)).getText().toString();\n\t\tString ident = ((EditText) findViewById(R.id.ident)).getText().toString();\n\t\tString realname = ((EditText) findViewById(R.id.realname)).getText().toString();\n\t\t\n\t\tIdentity identity = new Identity();\n\t\tidentity.setNickname(nickname);\n\t\tidentity.setIdent(ident);\n\t\tidentity.setRealName(realname);\n\t\t\n\t\treturn identity;\n\t}\n\t\n\t/**\n\t * Validate the input for a server\n\t * \n\t * @throws ValidationException\n\t */\n\tprivate void validateServer() throws ValidationException\n\t{\n\t\tString title = ((EditText) findViewById(R.id.title)).getText().toString();\n\t\tString host = ((EditText) findViewById(R.id.host)).getText().toString();\n\t\tString port = ((EditText) findViewById(R.id.port)).getText().toString();\n\t\tString charset = ((Spinner) findViewById(R.id.charset)).getSelectedItem().toString();\n\t\t\n\t\tif (title.trim().equals(\"\")) {\n\t\t\tthrow new ValidationException(\"Title cannot be blank\");\n\t\t}\n\t\t\n\t\tif (host.trim().equals(\"\")) {\n\t\t\t// XXX: We should use some better host validation\n\t\t\tthrow new ValidationException(\"Host cannot be blank\");\n\t\t}\n\t\t\n\t\ttry {\n\t\t\tInteger.parseInt(port);\n\t\t} catch (NumberFormatException e) {\n\t\t\tthrow new ValidationException(\"Enter a numeric port\");\n\t\t}\n\t\t\n\t\ttry {\n\t\t\t\"\".getBytes(charset);\n\t\t}\n\t\tcatch (UnsupportedEncodingException e) {\n\t\t\tthrow new ValidationException(\"Charset is not supported by your device\");\n\t\t}\n\t\t\n\t\tDatabase db = new Database(this);\n\t\tif (db.isTitleUsed(title) && (server == null || !server.getTitle().equals(title))) {\n\t\t\tdb.close();\n\t\t\tthrow new ValidationException(\"There is already a server with this title\");\n\t\t}\n\t\tdb.close();\n\t}\n\t\n\t/**\n\t * Validate the input for a identity\n\t * \n\t * @throws ValidationException\n\t */\n\tprivate void validateIdentity() throws ValidationException\n\t{\n\t\tString nickname = ((EditText) findViewById(R.id.nickname)).getText().toString();\n\t\tString ident = ((EditText) findViewById(R.id.ident)).getText().toString();\n\t\tString realname = ((EditText) findViewById(R.id.realname)).getText().toString();\n\t\t\n\t\tif (nickname.trim().equals(\"\")) {\n\t\t\tthrow new ValidationException(\"Nickname cannot be blank\");\n\t\t}\n\t\t\n\t\tif (ident.trim().equals(\"\")) {\n\t\t\tthrow new ValidationException(\"Ident cannot be blank\");\n\t\t}\n\t\t\n\t\tif (realname.trim().equals(\"\")) {\n\t\t\tthrow new ValidationException(\"Realname cannot be blank\");\n\t\t}\n\t\t\n\t\t// RFC 1459:  <nick> ::= <letter> { <letter> | <number> | <special> }\n\t\t// <special>    ::= '-' | '[' | ']' | '\\' | '`' | '^' | '{' | '}'\n\t\t// Chars that are not in RFC 1459 but are supported too:\n\t\t// | and _ \n\t\tPattern nickPattern = Pattern.compile(\"^[a-zA-Z][a-zA-Z0-9^\\\\-`\\\\[\\\\]{}|_\\\\\\\\]*$\");\n\t\tif (!nickPattern.matcher(nickname).matches()) {\n\t\t\tthrow new ValidationException(\"Invalid nickname\");\n\t\t}\n\t\t\n\t\t// We currently only allow chars as ident\n\t\tPattern identPattern = Pattern.compile(\"^[a-zA-Z]+$\");\n\t\tif (!identPattern.matcher(ident).matches()) {\n\t\t\tthrow new ValidationException(\"Invalid ident\");\n\t\t}\n\t}\n}\n","lineNo":141}
{"Smelly Sample":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2010 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.command.handler;\n\nimport org.yaaic.command.BaseHandler;\nimport org.yaaic.exception.CommandException;\nimport org.yaaic.irc.IRCService;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.model.Query;\nimport org.yaaic.model.Server;\n\nimport android.content.Intent;\n\n/**\n * Command: /query <nickname>\n * \n * Opens a private chat with the given user\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class QueryHandler extends BaseHandler\n{\n\t/**\n\t * Execute /query\n\t */\n\t@Override\n\tpublic void execute(String[] params, Server server, Conversation conversation, IRCService service) throws CommandException \n\t{\n\t\tif (params.length == 2) {\n\t\t\t// Simple validation\n\t\t\tif (params[1].startsWith(\"#\")) {\n\t\t\t\tthrow new CommandException(\"You cannot open queries to channels\");\n\t\t\t}\n\t\t\t\n\t\t\tConversation query = server.getConversation(params[1]);\n\t\t\t\n\t\t\tif (query != null) {\n\t\t\t\tthrow new CommandException(\"Query already exists\");\n\t\t\t}\n\t\t\t\n\t\t\tserver.addConversationl(new Query(params[1]));\n\t\t\t\n\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\t\tserver.getId(),\n\t\t\t\tconversation.getName()\n\t\t\t);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tthrow new CommandException(\"Invalid number of params\");\n\t\t}\n\t}\n\t\n\t/**\n\t * Usage of /query\n\t */\n\t@Override\n\tpublic String getUsage()\n\t{\n\t\treturn \"/query <nickname>\";\n\t}\n\n\t/**\n\t * Description of /query\n\t */\n\t@Override\n\tpublic String getDescription()\n\t{\n\t\treturn \"opens a private chat with a user\";\n\t}\n}\n","Method after Refactoring":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2010 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.command.handler;\n\nimport org.yaaic.command.BaseHandler;\nimport org.yaaic.exception.CommandException;\nimport org.yaaic.irc.IRCService;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.model.Query;\nimport org.yaaic.model.Server;\n\nimport android.content.Intent;\n\n/**\n * Command: /query <nickname>\n * \n * Opens a private chat with the given user\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class QueryHandler extends BaseHandler\n{\n\t/**\n\t * Execute /query\n\t */\n\t@Override\n\tpublic void execute(String[] params, Server server, Conversation conversation, IRCService service) throws CommandException \n\t{\n\t\tif (params.length == 2) {\n\t\t\t// Simple validation\n\t\t\tif (params[1].startsWith(\"#\")) {\n\t\t\t\tthrow new CommandException(\"You cannot open queries to channels\");\n\t\t\t}\n\t\t\t\n\t\t\tConversation query = server.getConversation(params[1]);\n\t\t\t\n\t\t\tif (query != null) {\n\t\t\t\tthrow new CommandException(\"Query already exists\");\n\t\t\t}\n\t\t\t\n\t\t\tquery = new Query(params[1]);\n\t\t\tserver.addConversationl(query);\n\t\t\t\n\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\tBroadcast.CONVERSATION_NEW,\n\t\t\t\tserver.getId(),\n\t\t\t\tquery.getName()\n\t\t\t);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tthrow new CommandException(\"Invalid number of params\");\n\t\t}\n\t}\n\t\n\t/**\n\t * Usage of /query\n\t */\n\t@Override\n\tpublic String getUsage()\n\t{\n\t\treturn \"/query <nickname>\";\n\t}\n\n\t/**\n\t * Description of /query\n\t */\n\t@Override\n\tpublic String getDescription()\n\t{\n\t\treturn \"opens a private chat with a user\";\n\t}\n}\n","lineNo":54}
{"Smelly Sample":"/* \nCopyright Paul James Mutton, 2001-2007, http://www.jibble.org/\n\nThis file is part of PircBot.\n\nThis software is dual-licensed, allowing you to choose between the GNU\nGeneral Public License (GPL) and the www.jibble.org Commercial License.\nSince the GPL may be too restrictive for use in a proprietary application,\na commercial license is also provided. Full license information can be\nfound at http://www.jibble.org/licenses/\n\nModified by: Sebastian Kaspari <sebastian@yaaic.org>\n\n*/\npackage org.jibble.pircbot;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.UnsupportedEncodingException;\nimport java.net.InetAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Date;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.StringTokenizer;\n\nimport javax.net.ssl.SSLSocketFactory;\n\n/**\n * PircBot is a Java framework for writing IRC bots quickly and easily.\n *  <p>\n * It provides an event-driven architecture to handle common IRC\n * events, flood protection, DCC support, ident support, and more.\n * The comprehensive logfile format is suitable for use with pisg to generate\n * channel statistics.\n *  <p>\n * Methods of the PircBot class can be called to send events to the IRC server\n * that it connects to.  For example, calling the sendMessage method will\n * send a message to a channel or user on the IRC server.  Multiple servers\n * can be supported using multiple instances of PircBot.\n *  <p>\n * To perform an action when the PircBot receives a normal message from the IRC\n * server, you would override the onMessage method defined in the PircBot\n * class.  All on<i>XYZ<\/i> methods in the PircBot class are automatically called\n * when the event <i>XYZ<\/i> happens, so you would override these if you wish\n * to do something when it does happen.\n *  <p>\n * Some event methods, such as onPing, should only really perform a specific\n * function (i.e. respond to a PING from the server).  For your convenience, such\n * methods are already correctly implemented in the PircBot and should not\n * normally need to be overridden.  Please read the full documentation for each\n * method to see which ones are already implemented by the PircBot class.\n *  <p>\n * Please visit the PircBot homepage at\n * <a href=\"http://www.jibble.org/pircbot.php\">http://www.jibble.org/pircbot.php<\/a>\n * for full revision history, a beginners guide to creating your first PircBot\n * and a list of some existing Java IRC bots and clients that use the PircBot\n * framework.\n * \n * @author  Paul James Mutton,\n *          <a href=\"http://www.jibble.org/\">http://www.jibble.org/<\/a>\n * @version    1.4.6 (Build time: Wed Apr 11 19:20:59 2007)\n */\npublic abstract class PircBot implements ReplyConstants {\n    /**\n     * The definitive version number of this release of PircBot.\n     * (Note: Change this before automatically building releases)\n     */\n    public static final String VERSION = \"1.4.6\";\n    \n    private static final int OP_ADD = 1;\n    private static final int OP_REMOVE = 2;\n    private static final int VOICE_ADD = 3;\n    private static final int VOICE_REMOVE = 4;\n    \n    /**\n     * Constructs a PircBot with the default settings.  Your own constructors\n     * in classes which extend the PircBot abstract class should be responsible\n     * for changing the default settings if required.\n     */\n    public PircBot() {}\n    \n    /**\n     * Attempt to connect to the specified IRC server.\n     * The onConnect method is called upon success.\n     *\n     * @param hostname The hostname of the server to connect to.\n     * \n     * @throws IOException if it was not possible to connect to the server.\n     * @throws IrcException if the server would not let us join it.\n     * @throws NickAlreadyInUseException if our nick is already in use on the server.\n     */\n    public final synchronized void connect(String hostname) throws IOException, IrcException, NickAlreadyInUseException {\n        this.connect(hostname, 6667, null);\n    }\n\n\n    /**\n     * Attempt to connect to the specified IRC server and port number.\n     * The onConnect method is called upon success.\n     *\n     * @param hostname The hostname of the server to connect to.\n     * @param port The port number to connect to on the server.\n     * \n     * @throws IOException if it was not possible to connect to the server.\n     * @throws IrcException if the server would not let us join it.\n     * @throws NickAlreadyInUseException if our nick is already in use on the server.\n     */\n    public final synchronized void connect(String hostname, int port) throws IOException, IrcException, NickAlreadyInUseException {\n        this.connect(hostname, port, null);\n    }\n    \n    \n    /**\n     * Attempt to connect to the specified IRC server using the supplied\n     * password.\n     * The onConnect method is called upon success.\n     *\n     * @param hostname The hostname of the server to connect to.\n     * @param port The port number to connect to on the server.\n     * @param password The password to use to join the server.\n     *\n     * @throws IOException if it was not possible to connect to the server.\n     * @throws IrcException if the server would not let us join it.\n     * @throws NickAlreadyInUseException if our nick is already in use on the server.\n     */\n    public final synchronized void connect(String hostname, int port, String password) throws IOException, IrcException, NickAlreadyInUseException {\n\n        _server = hostname;\n        _port = port;\n        _password = password;\n        \n        if (isConnected()) {\n            throw new IOException(\"The PircBot is already connected to an IRC server.  Disconnect first.\");\n        }\n        \n        // Don't clear the outqueue - there might be something important in it!\n        \n        // Clear everything we may have know about channels.\n        this.removeAllChannels();\n        \n        // Connect to the server.\n        \n        // XXX: PircBot Patch for SSL\n        Socket socket;\n        if (_useSSL) {\n        \tsocket = SSLSocketFactory.getDefault().createSocket(hostname, port);\n        } else {\n        \tsocket =  new Socket(hostname, port);\n        }\n        \n        _inetAddress = socket.getLocalAddress();\n        \n        InputStreamReader inputStreamReader = null;\n        OutputStreamWriter outputStreamWriter = null;\n        if (getEncoding() != null) {\n            // Assume the specified encoding is valid for this JVM.\n            inputStreamReader = new InputStreamReader(socket.getInputStream(), getEncoding());\n            outputStreamWriter = new OutputStreamWriter(socket.getOutputStream(), getEncoding());\n        }\n        else {\n            // Otherwise, just use the JVM's default encoding.\n            inputStreamReader = new InputStreamReader(socket.getInputStream());\n            outputStreamWriter = new OutputStreamWriter(socket.getOutputStream());\n        }\n\n        BufferedReader breader = new BufferedReader(inputStreamReader);\n        BufferedWriter bwriter = new BufferedWriter(outputStreamWriter);\n        \n        // Attempt to join the server.\n        if (password != null && !password.equals(\"\")) {\n            OutputThread.sendRawLine(this, bwriter, \"PASS \" + password);\n        }\n        String nick = this.getName();\n        OutputThread.sendRawLine(this, bwriter, \"NICK \" + nick);\n        OutputThread.sendRawLine(this, bwriter, \"USER \" + this.getLogin() + \" 8 * :\" + this.getVersion());\n\n        _inputThread = new InputThread(this, socket, breader, bwriter);\n        \n        // Read stuff back from the server to see if we connected.\n        String line = null;\n        int tries = 1;\n        while ((line = breader.readLine()) != null) {\n            \n            this.handleLine(line);\n            \n            int firstSpace = line.indexOf(\" \");\n            int secondSpace = line.indexOf(\" \", firstSpace + 1);\n            if (secondSpace >= 0) {\n                String code = line.substring(firstSpace + 1, secondSpace);\n           \n                if (code.equals(\"004\")) {\n                    // We're connected to the server.\n                    break;\n                }\n                else if (code.equals(\"433\")) {\n                    if (_autoNickChange) {\n                        tries++;\n                        nick = getName() + tries;\n                        OutputThread.sendRawLine(this, bwriter, \"NICK \" + nick);\n                    }\n                    else {\n                        socket.close();\n                        _inputThread = null;\n                        throw new NickAlreadyInUseException(line);\n                    }\n                }\n                else if ((code.startsWith(\"5\") || code.startsWith(\"4\")) && !code.equals(\"439\")) {\n                    socket.close();\n                    _inputThread = null;\n                    throw new IrcException(\"Could not log into the IRC server: \" + line);\n                }\n            }\n            this.setNick(nick);\n            \n        }\n        \n        // This makes the socket timeout on read operations after 5 minutes.\n        // Maybe in some future version I will let the user change this at runtime.\n        socket.setSoTimeout(5 * 60 * 1000);\n        \n        // Now start the InputThread to read all other lines from the server.\n        _inputThread.start();\n        \n        // Now start the outputThread that will be used to send all messages.\n        if (_outputThread == null) {\n            _outputThread = new OutputThread(this, _outQueue);\n            _outputThread.start();\n        }\n        \n        this.onConnect();\n        \n    }\n    \n    \n    /**\n     * Reconnects to the IRC server that we were previously connected to.\n     * If necessary, the appropriate port number and password will be used.\n     * This method will throw an IrcException if we have never connected\n     * to an IRC server previously.\n     * \n     * @since PircBot 0.9.9\n     * \n     * @throws IOException if it was not possible to connect to the server.\n     * @throws IrcException if the server would not let us join it.\n     * @throws NickAlreadyInUseException if our nick is already in use on the server.\n     */\n    public final synchronized void reconnect() throws IOException, IrcException, NickAlreadyInUseException{\n        if (getServer() == null) {\n            throw new IrcException(\"Cannot reconnect to an IRC server because we were never connected to one previously!\");\n        }\n        connect(getServer(), getPort(), getPassword());\n    }\n    \n    \n    /**\n     * Set wether SSL should be used to connect to the server\n     * \n     * @author Sebastian Kaspari <sebastian@yaaic.org>\n     */\n    public void setUseSSL(boolean useSSL)\n    {\n    \t_useSSL = useSSL;\n    }\n\n\n    /**\n     * This method disconnects from the server cleanly by calling the\n     * quitServer() method.  Providing the PircBot was connected to an\n     * IRC server, the onDisconnect() will be called as soon as the\n     * disconnection is made by the server.\n     *\n     * @see #quitServer() quitServer\n     * @see #quitServer(String) quitServer\n     */\n    public final synchronized void disconnect() {\n        this.quitServer();\n    }\n    \n    \n    /**\n     * When you connect to a server and your nick is already in use and\n     * this is set to true, a new nick will be automatically chosen.\n     * This is done by adding numbers to the end of the nick until an\n     * available nick is found.\n     *\n     * @param autoNickChange Set to true if you want automatic nick changes\n     *                       during connection.\n     */\n    public void setAutoNickChange(boolean autoNickChange) {\n        _autoNickChange = autoNickChange;\n    }\n    \n    /**\n     * Joins a channel.\n     * \n     * @param channel The name of the channel to join (eg \"#cs\").\n     */\n    public final void joinChannel(String channel) {\n        this.sendRawLine(\"JOIN \" + channel);\n    }\n    \n    \n    /**\n     * Joins a channel with a key.\n     * \n     * @param channel The name of the channel to join (eg \"#cs\").\n     * @param key The key that will be used to join the channel.\n     */\n    public final void joinChannel(String channel, String key) {\n        this.joinChannel(channel + \" \" + key);\n    }\n    \n\n    /**\n     * Parts a channel.\n     *\n     * @param channel The name of the channel to leave.\n     */\n    public final void partChannel(String channel) {\n        this.sendRawLine(\"PART \" + channel);\n    }\n    \n    \n    /**\n     * Parts a channel, giving a reason.\n     *\n     * @param channel The name of the channel to leave.\n     * @param reason  The reason for parting the channel.\n     */\n    public final void partChannel(String channel, String reason) {\n        this.sendRawLine(\"PART \" + channel + \" :\" + reason);\n    }\n\n\n    /**\n     * Quits from the IRC server.\n     * Providing we are actually connected to an IRC server, the\n     * onDisconnect() method will be called as soon as the IRC server\n     * disconnects us.\n     */\n    public void quitServer() {\n        this.quitServer(\"\");\n    }\n    \n    \n    /**\n     * Quits from the IRC server with a reason.\n     * Providing we are actually connected to an IRC server, the\n     * onDisconnect() method will be called as soon as the IRC server\n     * disconnects us.\n     *\n     * @param reason The reason for quitting the server.\n     */\n    public final void quitServer(String reason) {\n        this.sendRawLine(\"QUIT :\" + reason);\n    }\n    \n    \n    /**\n     * Sends a raw line to the IRC server as soon as possible, bypassing the\n     * outgoing message queue.\n     *\n     * @param line The raw line to send to the IRC server.\n     */\n    public final synchronized void sendRawLine(String line) {\n        if (isConnected()) {\n            _inputThread.sendRawLine(line);\n        }\n    }\n    \n    /**\n     * Sends a raw line through the outgoing message queue.\n     * \n     * @param line The raw line to send to the IRC server.\n     */\n    public final synchronized void sendRawLineViaQueue(String line) {\n        if (line == null) {\n            throw new NullPointerException(\"Cannot send null messages to server\");\n        }\n        if (isConnected()) {\n            _outQueue.add(line);\n        }\n    }\n    \n    \n    /**\n     * Sends a message to a channel or a private message to a user.  These\n     * messages are added to the outgoing message queue and sent at the\n     * earliest possible opportunity.\n     *  <p>\n     * Some examples: -\n     *  <pre>    // Send the message \"Hello!\" to the channel #cs.\n     *    sendMessage(\"#cs\", \"Hello!\");\n     *    \n     *    // Send a private message to Paul that says \"Hi\".\n     *    sendMessage(\"Paul\", \"Hi\");<\/pre>\n     *  \n     * You may optionally apply colours, boldness, underlining, etc to\n     * the message by using the <code>Colors<\/code> class.\n     *\n     * @param target The name of the channel or user nick to send to.\n     * @param message The message to send.\n     * \n     * @see Colors\n     */\n    public final void sendMessage(String target, String message) {\n        _outQueue.add(\"PRIVMSG \" + target + \" :\" + message);\n    }\n    \n    \n    /**\n     * Sends an action to the channel or to a user.\n     *\n     * @param target The name of the channel or user nick to send to.\n     * @param action The action to send.\n     * \n     * @see Colors\n     */\n    public final void sendAction(String target, String action) {\n        sendCTCPCommand(target, \"ACTION \" + action);\n    }\n    \n    \n    /**\n     * Sends a notice to the channel or to a user.\n     *\n     * @param target The name of the channel or user nick to send to.\n     * @param notice The notice to send.\n     */\n    public final void sendNotice(String target, String notice) {\n        _outQueue.add(\"NOTICE \" + target + \" :\" + notice);\n    }\n    \n    \n    /**\n     * Sends a CTCP command to a channel or user.  (Client to client protocol).\n     * Examples of such commands are \"PING <number>\", \"FINGER\", \"VERSION\", etc.\n     * For example, if you wish to request the version of a user called \"Dave\",\n     * then you would call <code>sendCTCPCommand(\"Dave\", \"VERSION\");<\/code>.\n     * The type of response to such commands is largely dependant on the target\n     * client software.\n     * \n     * @since PircBot 0.9.5\n     *\n     * @param target The name of the channel or user to send the CTCP message to.\n     * @param command The CTCP command to send.\n     */\n    public final void sendCTCPCommand(String target, String command) {\n        _outQueue.add(\"PRIVMSG \" + target + \" :\\u0001\" + command + \"\\u0001\");\n    }\n    \n    \n    /**\n     * Attempt to change the current nick (nickname) of the bot when it\n     * is connected to an IRC server.\n     * After confirmation of a successful nick change, the getNick method\n     * will return the new nick.\n     *\n     * @param newNick The new nick to use.\n     */\n    public final void changeNick(String newNick) {\n        this.sendRawLine(\"NICK \" + newNick);\n    }\n    \n    \n    /**\n     * Identify the bot with NickServ, supplying the appropriate password.\n     * Some IRC Networks (such as freenode) require users to <i>register<\/i> and\n     * <i>identify<\/i> with NickServ before they are able to send private messages\n     * to other users, thus reducing the amount of spam.  If you are using\n     * an IRC network where this kind of policy is enforced, you will need\n     * to make your bot <i>identify<\/i> itself to NickServ before you can send\n     * private messages. Assuming you have already registered your bot's\n     * nick with NickServ, this method can be used to <i>identify<\/i> with\n     * the supplied password. It usually makes sense to identify with NickServ\n     * immediately after connecting to a server.\n     *  <p>\n     * This method issues a raw NICKSERV command to the server, and is therefore\n     * safer than the alternative approach of sending a private message to\n     * NickServ. The latter approach is considered dangerous, as it may cause\n     * you to inadvertently transmit your password to an untrusted party if you\n     * connect to a network which does not run a NickServ service and where the\n     * untrusted party has assumed the nick \"NickServ\".  However, if your IRC\n     * network is only compatible with the private message approach, you may\n     * typically identify like so:\n     * <pre>sendMessage(\"NickServ\", \"identify PASSWORD\");<\/pre>\n     * \n     * @param password The password which will be used to identify with NickServ.\n     */\n    public final void identify(String password) {\n        this.sendRawLine(\"NICKSERV IDENTIFY \" + password);\n    }                                        \n\n\n    /**\n     * Set the mode of a channel.\n     * This method attempts to set the mode of a channel.  This\n     * may require the bot to have operator status on the channel.\n     * For example, if the bot has operator status, we can grant\n     * operator status to \"Dave\" on the #cs channel\n     * by calling setMode(\"#cs\", \"+o Dave\");\n     * An alternative way of doing this would be to use the op method.\n     * \n     * @param channel The channel on which to perform the mode change.\n     * @param mode    The new mode to apply to the channel.  This may include\n     *                zero or more arguments if necessary.\n     * \n     * @see #op(String,String) op\n     */\n    public final void setMode(String channel, String mode) {\n        this.sendRawLine(\"MODE \" + channel + \" \" + mode);\n    }\n    \n    \n    /**\n     * Sends an invitation to join a channel.  Some channels can be marked\n     * as \"invite-only\", so it may be useful to allow a bot to invite people\n     * into it.\n     * \n     * @param nick    The nick of the user to invite\n     * @param channel The channel you are inviting the user to join.\n     * \n     */\n    public final void sendInvite(String nick, String channel) {\n        this.sendRawLine(\"INVITE \" + nick + \" :\" + channel);\n    }    \n\n\n    /**\n     * Bans a user from a channel.  An example of a valid hostmask is\n     * \"*!*compu@*.18hp.net\".  This may be used in conjunction with the\n     * kick method to permanently remove a user from a channel.\n     * Successful use of this method may require the bot to have operator\n     * status itself.\n     * \n     * @param channel The channel to ban the user from.\n     * @param hostmask A hostmask representing the user we're banning.\n     */\n    public final void ban(String channel, String hostmask) {\n        this.sendRawLine(\"MODE \" + channel + \" +b \" + hostmask);\n    }\n\n\n    /**\n     * Unbans a user from a channel.  An example of a valid hostmask is\n     * \"*!*compu@*.18hp.net\".\n     * Successful use of this method may require the bot to have operator\n     * status itself.\n     * \n     * @param channel The channel to unban the user from.\n     * @param hostmask A hostmask representing the user we're unbanning.\n     */\n    public final void unBan(String channel, String hostmask) {\n        this.sendRawLine(\"MODE \" + channel + \" -b \" + hostmask);\n    }\n\n\n    /**\n     * Grants operator privilidges to a user on a channel.\n     * Successful use of this method may require the bot to have operator\n     * status itself.\n     * \n     * @param channel The channel we're opping the user on.\n     * @param nick The nick of the user we are opping.\n     */\n    public final void op(String channel, String nick) {\n        this.setMode(channel, \"+o \" + nick);\n    }\n\n\n    /**\n     * Removes operator privilidges from a user on a channel.\n     * Successful use of this method may require the bot to have operator\n     * status itself.\n     * \n     * @param channel The channel we're deopping the user on.\n     * @param nick The nick of the user we are deopping.\n     */\n    public final void deOp(String channel, String nick) {\n        this.setMode(channel, \"-o \" + nick);\n    }\n    \n    \n    /**\n     * Grants voice privilidges to a user on a channel.\n     * Successful use of this method may require the bot to have operator\n     * status itself.\n     * \n     * @param channel The channel we're voicing the user on.\n     * @param nick The nick of the user we are voicing.\n     */\n    public final void voice(String channel, String nick) {\n        this.setMode(channel, \"+v \" + nick);\n    }\n\n\n    /**\n     * Removes voice privilidges from a user on a channel.\n     * Successful use of this method may require the bot to have operator\n     * status itself.\n     * \n     * @param channel The channel we're devoicing the user on.\n     * @param nick The nick of the user we are devoicing.\n     */\n    public final void deVoice(String channel, String nick) {\n        this.setMode(channel, \"-v \" + nick);\n    }\n\n\n    /**\n     * Set the topic for a channel.\n     * This method attempts to set the topic of a channel.  This\n     * may require the bot to have operator status if the topic\n     * is protected.\n     * \n     * @param channel The channel on which to perform the mode change.\n     * @param topic   The new topic for the channel.\n     * \n     */\n    public final void setTopic(String channel, String topic) {\n        this.sendRawLine(\"TOPIC \" + channel + \" :\" + topic);\n    }\n\n\n    /**\n     * Kicks a user from a channel.\n     * This method attempts to kick a user from a channel and\n     * may require the bot to have operator status in the channel.\n     * \n     * @param channel The channel to kick the user from.\n     * @param nick    The nick of the user to kick.\n     */\n    public final void kick(String channel, String nick) {\n        this.kick(channel, nick, \"\");\n    }\n\n\n    /**\n     * Kicks a user from a channel, giving a reason.\n     * This method attempts to kick a user from a channel and\n     * may require the bot to have operator status in the channel.\n     * \n     * @param channel The channel to kick the user from.\n     * @param nick    The nick of the user to kick.\n     * @param reason  A description of the reason for kicking a user.\n     */\n    public final void kick(String channel, String nick, String reason) {\n        this.sendRawLine(\"KICK \" + channel + \" \" + nick + \" :\" + reason);\n    }\n    \n    \n    /**\n     * Issues a request for a list of all channels on the IRC server.\n     * When the PircBot receives information for each channel, it will\n     * call the onChannelInfo method, which you will need to override\n     * if you want it to do anything useful.\n     * \n     * @see #onChannelInfo(String,int,String) onChannelInfo\n     */\n    public final void listChannels() {\n        this.listChannels(null);\n    }\n    \n    \n    /**\n     * Issues a request for a list of all channels on the IRC server.\n     * When the PircBot receives information for each channel, it will\n     * call the onChannelInfo method, which you will need to override\n     * if you want it to do anything useful.\n     *  <p>\n     * Some IRC servers support certain parameters for LIST requests.\n     * One example is a parameter of \">10\" to list only those channels\n     * that have more than 10 users in them.  Whether these parameters\n     * are supported or not will depend on the IRC server software.\n     * \n     * @param parameters The parameters to supply when requesting the\n     *                   list.\n     * \n     * @see #onChannelInfo(String,int,String) onChannelInfo\n     */\n    public final void listChannels(String parameters) {\n        if (parameters == null) {\n            this.sendRawLine(\"LIST\");\n        }\n        else {\n            this.sendRawLine(\"LIST \" + parameters);\n        }\n    }\n    \n    \n    /**\n     * Sends a file to another user.  Resuming is supported.\n     * The other user must be able to connect directly to your bot to be\n     * able to receive the file.\n     *  <p>\n     * You may throttle the speed of this file transfer by calling the\n     * setPacketDelay method on the DccFileTransfer that is returned.\n     *  <p>\n     * This method may not be overridden.\n     * \n     * @since 0.9c\n     * \n     * @param file The file to send.\n     * @param nick The user to whom the file is to be sent.\n     * @param timeout The number of milliseconds to wait for the recipient to\n     *                acccept the file (we recommend about 120000).\n     * \n     * @return The DccFileTransfer that can be used to monitor this transfer.\n     * \n     * @see DccFileTransfer\n     * \n     */\n    public final DccFileTransfer dccSendFile(File file, String nick, int timeout) {\n        DccFileTransfer transfer = new DccFileTransfer(this, _dccManager, file, nick, timeout);\n        transfer.doSend(true);\n        return transfer;\n    }\n    \n    \n    /**\n     * Receives a file that is being sent to us by a DCC SEND request.\n     * Please use the onIncomingFileTransfer method to receive files.\n     * \n     * @deprecated As of PircBot 1.2.0, use {@link #onIncomingFileTransfer(DccFileTransfer)}\n     */\n    protected final void dccReceiveFile(File file, long address, int port, int size) {\n        throw new RuntimeException(\"dccReceiveFile is deprecated, please use sendFile\");\n    }\n    \n    \n    /**\n     * Attempts to establish a DCC CHAT session with a client.  This method\n     * issues the connection request to the client and then waits for the\n     * client to respond.  If the connection is successfully made, then a\n     * DccChat object is returned by this method.  If the connection is not\n     * made within the time limit specified by the timeout value, then null\n     * is returned.\n     *  <p>\n     * It is <b>strongly recommended<\/b> that you call this method within a new\n     * Thread, as it may take a long time to return.\n     *  <p>\n     * This method may not be overridden.\n     * \n     * @since PircBot 0.9.8\n     *\n     * @param nick The nick of the user we are trying to establish a chat with.\n     * @param timeout The number of milliseconds to wait for the recipient to\n     *                accept the chat connection (we recommend about 120000).\n     * \n     * @return a DccChat object that can be used to send and recieve lines of\n     *         text.  Returns <b>null<\/b> if the connection could not be made.\n     * \n     * @see DccChat\n     */\n    public final DccChat dccSendChatRequest(String nick, int timeout) {\n        DccChat chat = null;\n        try {\n            ServerSocket ss = null;\n            \n            int[] ports = getDccPorts();\n            if (ports == null) {\n                // Use any free port.\n                ss = new ServerSocket(0);\n            }\n            else {\n                for (int i = 0; i < ports.length; i++) {\n                    try {\n                        ss = new ServerSocket(ports[i]);\n                        // Found a port number we could use.\n                        break;\n                    }\n                    catch (Exception e) {\n                        // Do nothing; go round and try another port.\n                    }\n                }\n                if (ss == null) {\n                    // No ports could be used.\n                    throw new IOException(\"All ports returned by getDccPorts() are in use.\");\n                }\n            }\n            \n            ss.setSoTimeout(timeout);\n            int port = ss.getLocalPort();\n            \n            InetAddress inetAddress = getDccInetAddress();\n            if (inetAddress == null) {\n                inetAddress = getInetAddress();\n            }\n            byte[] ip = inetAddress.getAddress();\n            long ipNum = ipToLong(ip);\n            \n            sendCTCPCommand(nick, \"DCC CHAT chat \" + ipNum + \" \" + port);\n            \n            // The client may now connect to us to chat.\n            Socket socket = ss.accept();\n            \n            // Close the server socket now that we've finished with it.\n            ss.close();\n            \n            chat = new DccChat(this, nick, socket);\n        }\n        catch (Exception e) {\n            // Do nothing.\n        }\n        return chat;\n    }\n\n    \n    /**\n     * Attempts to accept a DCC CHAT request by a client.\n     * Please use the onIncomingChatRequest method to receive files.\n     * \n     * @deprecated As of PircBot 1.2.0, use {@link #onIncomingChatRequest(DccChat)}\n     */\n    protected final DccChat dccAcceptChatRequest(String sourceNick, long address, int port) {\n        throw new RuntimeException(\"dccAcceptChatRequest is deprecated, please use onIncomingChatRequest\");\n    }\n\n    /**\n     * This method handles events when any line of text arrives from the server,\n     * then calling the appropriate method in the PircBot.  This method is\n     * protected and only called by the InputThread for this instance.\n     *  <p>\n     * This method may not be overridden!\n     * \n     * @param line The raw line of text from the server.\n     */\n    protected void handleLine(String line) {\n        // Check for server pings.\n        if (line.startsWith(\"PING \")) {\n            // Respond to the ping and return immediately.\n            this.onServerPing(line.substring(5));\n            return;\n        }\n\n        String sourceNick = \"\";\n        String sourceLogin = \"\";\n        String sourceHostname = \"\";\n\n        StringTokenizer tokenizer = new StringTokenizer(line);\n        String senderInfo = tokenizer.nextToken();\n        String command = tokenizer.nextToken();\n        String target = null;\n\n        int exclamation = senderInfo.indexOf(\"!\");\n        int at = senderInfo.indexOf(\"@\");\n        if (senderInfo.startsWith(\":\")) {\n            if (exclamation > 0 && at > 0 && exclamation < at) {\n                sourceNick = senderInfo.substring(1, exclamation);\n                sourceLogin = senderInfo.substring(exclamation + 1, at);\n                sourceHostname = senderInfo.substring(at + 1);\n            }\n            else {\n                \n                if (tokenizer.hasMoreTokens()) {\n                    String token = command;\n\n                    int code = -1;\n                    try {\n                        code = Integer.parseInt(token);\n                    }\n                    catch (NumberFormatException e) {\n                        // Keep the existing value.\n                    }\n                    \n                    if (code != -1) {\n                        String errorStr = token;\n                        String response = line.substring(line.indexOf(errorStr, senderInfo.length()) + 4, line.length());\n                        this.processServerResponse(code, response);\n                        // Return from the method.\n                        return;\n                    }\n                    else {\n                        // This is not a server response.\n                        // It must be a nick without login and hostname.\n                        // (or maybe a NOTICE or suchlike from the server)\n                        sourceNick = senderInfo;\n                        target = token;\n                    }\n                }\n                else {\n                    // We don't know what this line means.\n                    this.onUnknown(line);\n                    // Return from the method;\n                    return;\n                }\n                \n            }\n        }\n        \n        command = command.toUpperCase();\n        if (sourceNick.startsWith(\":\")) {\n            sourceNick = sourceNick.substring(1);\n        }\n        if (target == null) {\n            target = tokenizer.nextToken();\n        }\n        if (target.startsWith(\":\")) {\n            target = target.substring(1);\n        }\n\n        // Check for CTCP requests.\n        if (command.equals(\"PRIVMSG\") && line.indexOf(\":\\u0001\") > 0 && line.endsWith(\"\\u0001\")) {\n            String request = line.substring(line.indexOf(\":\\u0001\") + 2, line.length() - 1);\n            if (request.equals(\"VERSION\")) {\n                // VERSION request\n                this.onVersion(sourceNick, sourceLogin, sourceHostname, target);\n            }\n            else if (request.startsWith(\"ACTION \")) {\n                // ACTION request\n                this.onAction(sourceNick, sourceLogin, sourceHostname, target, request.substring(7));\n            }\n            else if (request.startsWith(\"PING \")) {\n                // PING request\n                this.onPing(sourceNick, sourceLogin, sourceHostname, target, request.substring(5));\n            }\n            else if (request.equals(\"TIME\")) {\n                // TIME request\n                this.onTime(sourceNick, sourceLogin, sourceHostname, target);\n            }\n            else if (request.equals(\"FINGER\")) {\n                // FINGER request\n                this.onFinger(sourceNick, sourceLogin, sourceHostname, target);\n            }\n            else if ((tokenizer = new StringTokenizer(request)).countTokens() >= 5 && tokenizer.nextToken().equals(\"DCC\")) {\n                // This is a DCC request.\n                boolean success = _dccManager.processRequest(sourceNick, sourceLogin, sourceHostname, request);\n                if (!success) {\n                    // The DccManager didn't know what to do with the line.\n                    this.onUnknown(line);\n                }\n            }\n            else {            \n                // An unknown CTCP message - ignore it.\n                this.onUnknown(line);\n            }\n        }\n        else if (command.equals(\"PRIVMSG\") && _channelPrefixes.indexOf(target.charAt(0)) >= 0) {\n            // This is a normal message to a channel.\n            this.onMessage(target, sourceNick, sourceLogin, sourceHostname, line.substring(line.indexOf(\" :\") + 2));\n        }\n        else if (command.equals(\"PRIVMSG\")) {\n            // This is a private message to us.\n            this.onPrivateMessage(sourceNick, sourceLogin, sourceHostname, line.substring(line.indexOf(\" :\") + 2));\n        }\n        else if (command.equals(\"JOIN\")) {\n            // Someone is joining a channel.\n            String channel = target;\n            this.addUser(channel, new User(\"\", sourceNick));\n            this.onJoin(channel, sourceNick, sourceLogin, sourceHostname);\n        }\n        else if (command.equals(\"PART\")) {\n            // Someone is parting from a channel.\n            this.removeUser(target, sourceNick);\n            if (sourceNick.equals(this.getNick())) {\n                this.removeChannel(target);\n            }\n            this.onPart(target, sourceNick, sourceLogin, sourceHostname);\n        }\n        else if (command.equals(\"NICK\")) {\n            // Somebody is changing their nick.\n            String newNick = target;\n            this.renameUser(sourceNick, newNick);\n            if (sourceNick.equals(this.getNick())) {\n                // Update our nick if it was us that changed nick.\n                this.setNick(newNick);\n            }\n            this.onNickChange(sourceNick, sourceLogin, sourceHostname, newNick);\n        }\n        else if (command.equals(\"NOTICE\")) {\n            // Someone is sending a notice.\n            this.onNotice(sourceNick, sourceLogin, sourceHostname, target, line.substring(line.indexOf(\" :\") + 2));\n        }\n        else if (command.equals(\"QUIT\")) {\n            // Someone has quit from the IRC server.\n        \t\n        \t// XXX: Pircbot Patch - Call onQuit before removing the user. This way we\n        \t//\t\t\t\t\t\tare able to know which channels the user was on.\n        \tthis.onQuit(sourceNick, sourceLogin, sourceHostname, line.substring(line.indexOf(\" :\") + 2));\n        \t\n            if (sourceNick.equals(this.getNick())) {\n                this.removeAllChannels();\n            }\n            else {\n                this.removeUser(sourceNick);\n            }\n        }\n        else if (command.equals(\"KICK\")) {\n            // Somebody has been kicked from a channel.\n            String recipient = tokenizer.nextToken();\n            if (recipient.equals(this.getNick())) {\n                this.removeChannel(target);\n            }\n            this.removeUser(target, recipient);\n            this.onKick(target, sourceNick, sourceLogin, sourceHostname, recipient, line.substring(line.indexOf(\" :\") + 2));\n        }\n        else if (command.equals(\"MODE\")) {\n            // Somebody is changing the mode on a channel or user.\n            String mode = line.substring(line.indexOf(target, 2) + target.length() + 1);\n            if (mode.startsWith(\":\")) {\n                mode = mode.substring(1);\n            }\n            this.processMode(target, sourceNick, sourceLogin, sourceHostname, mode);\n        }\n        else if (command.equals(\"TOPIC\")) {\n            // Someone is changing the topic.\n            this.onTopic(target, line.substring(line.indexOf(\" :\") + 2), sourceNick, System.currentTimeMillis(), true);\n        }\n        else if (command.equals(\"INVITE\")) {\n            // Somebody is inviting somebody else into a channel.\n            this.onInvite(target, sourceNick, sourceLogin, sourceHostname, line.substring(line.indexOf(\" :\") + 2));\n        }\n        else {\n            // If we reach this point, then we've found something that the PircBot\n            // Doesn't currently deal with.\n            this.onUnknown(line);\n        }\n        \n    }\n    \n    \n    /**\n     * This method is called once the PircBot has successfully connected to\n     * the IRC server.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @since PircBot 0.9.6\n     */\n    protected void onConnect() {}\n    \n    \n    /**\n     * This method carries out the actions to be performed when the PircBot\n     * gets disconnected.  This may happen if the PircBot quits from the\n     * server, or if the connection is unexpectedly lost.\n     *  <p>\n     * Disconnection from the IRC server is detected immediately if either\n     * we or the server close the connection normally. If the connection to\n     * the server is lost, but neither we nor the server have explicitly closed\n     * the connection, then it may take a few minutes to detect (this is\n     * commonly referred to as a \"ping timeout\").\n     *  <p>\n     * If you wish to get your IRC bot to automatically rejoin a server after\n     * the connection has been lost, then this is probably the ideal method to\n     * override to implement such functionality.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     */\n    protected void onDisconnect() {}\n    \n    \n    /**\n     * This method is called by the PircBot when a numeric response\n     * is received from the IRC server.  We use this method to\n     * allow PircBot to process various responses from the server\n     * before then passing them on to the onServerResponse method.\n     *  <p>\n     * Note that this method is private and should not appear in any\n     * of the javadoc generated documenation.\n     * \n     * @param code The three-digit numerical code for the response.\n     * @param response The full response from the IRC server.\n     */\n    private final void processServerResponse(int code, String response) {\n        \n        if (code == RPL_LIST) {\n            // This is a bit of information about a channel.\n            int firstSpace = response.indexOf(' ');\n            int secondSpace = response.indexOf(' ', firstSpace + 1);\n            int thirdSpace = response.indexOf(' ', secondSpace + 1);\n            int colon = response.indexOf(':');\n            String channel = response.substring(firstSpace + 1, secondSpace);\n            int userCount = 0;\n            try {\n                userCount = Integer.parseInt(response.substring(secondSpace + 1, thirdSpace));\n            }\n            catch (NumberFormatException e) {\n                // Stick with the value of zero.\n            }\n            String topic = response.substring(colon + 1);\n            this.onChannelInfo(channel, userCount, topic);\n        }\n        else if (code == RPL_TOPIC) {\n            // This is topic information about a channel we've just joined.\n            int firstSpace = response.indexOf(' ');\n            int secondSpace = response.indexOf(' ', firstSpace + 1);\n            int colon = response.indexOf(':');\n            String channel = response.substring(firstSpace + 1, secondSpace);\n            String topic = response.substring(colon + 1);\n            \n            _topics.put(channel, topic);\n            \n            // For backwards compatibility only - this onTopic method is deprecated.\n            this.onTopic(channel, topic);\n        }\n        else if (code == RPL_TOPICINFO) {\n            StringTokenizer tokenizer = new StringTokenizer(response);\n            tokenizer.nextToken();\n            String channel = tokenizer.nextToken();\n            String setBy = tokenizer.nextToken();\n            long date = 0;\n            try {\n                date = Long.parseLong(tokenizer.nextToken()) * 1000;\n            }\n            catch (NumberFormatException e) {\n                // Stick with the default value of zero.\n            }\n            \n            String topic = (String) _topics.get(channel);\n            _topics.remove(channel);\n            \n            this.onTopic(channel, topic, setBy, date, false);\n        }\n        else if (code == RPL_NAMREPLY) {\n            // This is a list of nicks in a channel that we've just joined.\n            int channelEndIndex = response.indexOf(\" :\");\n            String channel = response.substring(response.lastIndexOf(' ', channelEndIndex - 1) + 1, channelEndIndex);\n            \n            StringTokenizer tokenizer = new StringTokenizer(response.substring(response.indexOf(\" :\") + 2));\n            while (tokenizer.hasMoreTokens()) {\n                String nick = tokenizer.nextToken();\n                String prefix = \"\";\n                if (nick.startsWith(\"@\")) {\n                    // User is an operator in this channel.\n                    prefix = \"@\";\n                }\n                else if (nick.startsWith(\"+\")) {\n                    // User is voiced in this channel.\n                    prefix = \"+\";\n                }\n                else if (nick.startsWith(\".\")) {\n                    // Some wibbly status I've never seen before...\n                    prefix = \".\";\n                }\n                nick = nick.substring(prefix.length());\n                this.addUser(channel, new User(prefix, nick));\n            }\n        }\n        else if (code == RPL_ENDOFNAMES) {\n            // This is the end of a NAMES list, so we know that we've got\n            // the full list of users in the channel that we just joined. \n            String channel = response.substring(response.indexOf(' ') + 1, response.indexOf(\" :\"));\n            User[] users = this.getUsers(channel);\n            this.onUserList(channel, users);\n        }\n        \n        this.onServerResponse(code, response);\n    }\n\n\n    /**\n     * This method is called when we receive a numeric response from the\n     * IRC server.\n     *  <p> \n     * Numerics in the range from 001 to 099 are used for client-server\n     * connections only and should never travel between servers.  Replies\n     * generated in response to commands are found in the range from 200\n     * to 399.  Error replies are found in the range from 400 to 599.\n     *  <p>\n     * For example, we can use this method to discover the topic of a\n     * channel when we join it.  If we join the channel #test which\n     * has a topic of &quot;I am King of Test&quot; then the response\n     * will be &quot;<code>PircBot #test :I Am King of Test<\/code>&quot;\n     * with a code of 332 to signify that this is a topic.\n     * (This is just an example - note that overriding the\n     * <code>onTopic<\/code> method is an easier way of finding the\n     * topic for a channel). Check the IRC RFC for the full list of other\n     * command response codes.\n     *  <p>\n     * PircBot implements the interface ReplyConstants, which contains\n     * contstants that you may find useful here.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @param code The three-digit numerical code for the response.\n     * @param response The full response from the IRC server.\n     * \n     * @see ReplyConstants\n     */\n    protected void onServerResponse(int code, String response) {}\n    \n    \n    /**\n     * This method is called when we receive a user list from the server\n     * after joining a channel.\n     *  <p>\n     * Shortly after joining a channel, the IRC server sends a list of all\n     * users in that channel. The PircBot collects this information and\n     * calls this method as soon as it has the full list.\n     *  <p>\n     * To obtain the nick of each user in the channel, call the getNick()\n     * method on each User object in the array.\n     *  <p>\n     * At a later time, you may call the getUsers method to obtain an\n     * up to date list of the users in the channel.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @since PircBot 1.0.0\n     * \n     * @param channel The name of the channel.\n     * @param users An array of User objects belonging to this channel.\n     * \n     * @see User\n     */\n    protected void onUserList(String channel, User[] users) {}\n    \n    \n    /**\n     * This method is called whenever a message is sent to a channel.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     *\n     * @param channel The channel to which the message was sent.\n     * @param sender The nick of the person who sent the message.\n     * @param login The login of the person who sent the message.\n     * @param hostname The hostname of the person who sent the message.\n     * @param message The actual message sent to the channel.\n     */\n    protected void onMessage(String channel, String sender, String login, String hostname, String message) {}\n\n\n    /**\n     * This method is called whenever a private message is sent to the PircBot.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     *\n     * @param sender The nick of the person who sent the private message.\n     * @param login The login of the person who sent the private message.\n     * @param hostname The hostname of the person who sent the private message.\n     * @param message The actual message.\n     */\n    protected void onPrivateMessage(String sender, String login, String hostname, String message) {}\n    \n    \n    /**\n     * This method is called whenever an ACTION is sent from a user.  E.g.\n     * such events generated by typing \"/me goes shopping\" in most IRC clients.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @param sender The nick of the user that sent the action.\n     * @param login The login of the user that sent the action.\n     * @param hostname The hostname of the user that sent the action.\n     * @param target The target of the action, be it a channel or our nick.\n     * @param action The action carried out by the user.\n     */\n    protected void onAction(String sender, String login, String hostname, String target, String action) {}\n    \n    \n    /**\n     * This method is called whenever we receive a notice.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @param sourceNick The nick of the user that sent the notice.\n     * @param sourceLogin The login of the user that sent the notice.\n     * @param sourceHostname The hostname of the user that sent the notice.\n     * @param target The target of the notice, be it our nick or a channel name.\n     * @param notice The notice message.\n     */\n    protected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice) {}\n    \n    \n    /**\n     * This method is called whenever someone (possibly us) joins a channel\n     * which we are on.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     *\n     * @param channel The channel which somebody joined.\n     * @param sender The nick of the user who joined the channel.\n     * @param login The login of the user who joined the channel.\n     * @param hostname The hostname of the user who joined the channel.\n     */\n    protected void onJoin(String channel, String sender, String login, String hostname) {}\n    \n    \n    /**\n     * This method is called whenever someone (possibly us) parts a channel\n     * which we are on.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     *\n     * @param channel The channel which somebody parted from.\n     * @param sender The nick of the user who parted from the channel.\n     * @param login The login of the user who parted from the channel.\n     * @param hostname The hostname of the user who parted from the channel.\n     */\n    protected void onPart(String channel, String sender, String login, String hostname) {}\n\n\n    /**\n     * This method is called whenever someone (possibly us) changes nick on any\n     * of the channels that we are on.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     *\n     * @param oldNick The old nick.\n     * @param login The login of the user.\n     * @param hostname The hostname of the user.\n     * @param newNick The new nick.\n     */\n    protected void onNickChange(String oldNick, String login, String hostname, String newNick) {}\n    \n    \n    /**\n     * This method is called whenever someone (possibly us) is kicked from\n     * any of the channels that we are in.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @param channel The channel from which the recipient was kicked.\n     * @param kickerNick The nick of the user who performed the kick.\n     * @param kickerLogin The login of the user who performed the kick.\n     * @param kickerHostname The hostname of the user who performed the kick.\n     * @param recipientNick The unfortunate recipient of the kick.\n     * @param reason The reason given by the user who performed the kick.\n     */\n    protected void onKick(String channel, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason) {}\n    \n    \n    /**\n     * This method is called whenever someone (possibly us) quits from the\n     * server.  We will only observe this if the user was in one of the\n     * channels to which we are connected.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @param sourceNick The nick of the user that quit from the server.\n     * @param sourceLogin The login of the user that quit from the server.\n     * @param sourceHostname The hostname of the user that quit from the server.\n     * @param reason The reason given for quitting the server.\n     */\n    protected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason) {}\n    \n    \n    /**\n     * This method is called whenever a user sets the topic, or when\n     * PircBot joins a new channel and discovers its topic.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     *\n     * @param channel The channel that the topic belongs to.\n     * @param topic The topic for the channel.\n     * \n     * @deprecated As of 1.2.0, replaced by {@link #onTopic(String,String,String,long,boolean)}\n     */\n    protected void onTopic(String channel, String topic) {}\n    \n\n    /**\n     * This method is called whenever a user sets the topic, or when\n     * PircBot joins a new channel and discovers its topic.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     *\n     * @param channel The channel that the topic belongs to.\n     * @param topic The topic for the channel.\n     * @param setBy The nick of the user that set the topic.\n     * @param date When the topic was set (milliseconds since the epoch).\n     * @param changed True if the topic has just been changed, false if\n     *                the topic was already there.\n     * \n     */\n    protected void onTopic(String channel, String topic, String setBy, long date, boolean changed) {}\n    \n    \n    /**\n     * After calling the listChannels() method in PircBot, the server\n     * will start to send us information about each channel on the\n     * server.  You may override this method in order to receive the\n     * information about each channel as soon as it is received.\n     *  <p>\n     * Note that certain channels, such as those marked as hidden,\n     * may not appear in channel listings.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @param channel The name of the channel.\n     * @param userCount The number of users visible in this channel.\n     * @param topic The topic for this channel.\n     * \n     * @see #listChannels() listChannels\n     */\n    protected void onChannelInfo(String channel, int userCount, String topic) {}\n      \n    \n    /**\n     * Called when the mode of a channel is set.  We process this in\n     * order to call the appropriate onOp, onDeop, etc method before\n     * finally calling the override-able onMode method.\n     *  <p>\n     * Note that this method is private and is not intended to appear\n     * in the javadoc generated documentation.\n     *\n     * @param target The channel or nick that the mode operation applies to.\n     * @param sourceNick The nick of the user that set the mode.\n     * @param sourceLogin The login of the user that set the mode.\n     * @param sourceHostname The hostname of the user that set the mode.\n     * @param mode  The mode that has been set.\n     */\n    private final void processMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode) {\n        \n        if (_channelPrefixes.indexOf(target.charAt(0)) >= 0) {\n            // The mode of a channel is being changed.\n            String channel = target;\n            StringTokenizer tok = new StringTokenizer(mode);\n            String[] params = new String[tok.countTokens()];\n     \n            int t = 0;\n            while (tok.hasMoreTokens()) {\n                params[t] = tok.nextToken();\n                t++;\n            }\n            \n            char pn = ' ';\n            int p = 1;\n     \n            // All of this is very large and ugly, but it's the only way of providing\n            // what the users want :-/\n            for (int i = 0; i < params[0].length(); i++) {\n                char atPos = params[0].charAt(i);\n     \n                if (atPos == '+' || atPos == '-') {\n                    pn = atPos;\n                }\n                else if (atPos == 'o') {\n                   if (pn == '+') {\n                       this.updateUser(channel, OP_ADD, params[p]);\n                       onOp(channel, sourceNick, sourceLogin, sourceHostname, params[p]);\n                   }\n                   else {\n                       this.updateUser(channel, OP_REMOVE, params[p]);\n                       onDeop(channel, sourceNick, sourceLogin, sourceHostname, params[p]);\n                   }\n                   p++;\n               }\n               else if (atPos == 'v') {\n                   if (pn == '+') {\n                       this.updateUser(channel, VOICE_ADD, params[p]);\n                       onVoice(channel, sourceNick, sourceLogin, sourceHostname, params[p]);\n                   }\n                   else {\n                       this.updateUser(channel, VOICE_REMOVE, params[p]);\n                       onDeVoice(channel, sourceNick, sourceLogin, sourceHostname, params[p]);\n                   }\n                   p++; \n                }\n                else if (atPos == 'k') {\n                    if (pn == '+') {\n                        onSetChannelKey(channel, sourceNick, sourceLogin, sourceHostname, params[p]);\n                    }\n                    else {\n                        onRemoveChannelKey(channel, sourceNick, sourceLogin, sourceHostname, params[p]);\n                    }\n                    p++;\n                }\n                else if (atPos == 'l') {\n                    if (pn == '+') {\n                        onSetChannelLimit(channel, sourceNick, sourceLogin, sourceHostname, Integer.parseInt(params[p]));\n                        p++;\n                    }\n                    else {\n                        onRemoveChannelLimit(channel, sourceNick, sourceLogin, sourceHostname);\n                    }\n                }\n                else if (atPos == 'b') {\n                    if (pn == '+') {\n                        onSetChannelBan(channel, sourceNick, sourceLogin, sourceHostname,params[p]);\n                    }\n                    else {\n                        onRemoveChannelBan(channel, sourceNick, sourceLogin, sourceHostname, params[p]);\n                    }\n                    p++;\n                }\n                else if (atPos == 't') {\n                    if (pn == '+') {\n                        onSetTopicProtection(channel, sourceNick, sourceLogin, sourceHostname);\n                    }\n                    else {\n                        onRemoveTopicProtection(channel, sourceNick, sourceLogin, sourceHostname);\n                    }\n                }\n                else if (atPos == 'n') {\n                    if (pn == '+') {\n                        onSetNoExternalMessages(channel, sourceNick, sourceLogin, sourceHostname);\n                    }\n                    else {\n                        onRemoveNoExternalMessages(channel, sourceNick, sourceLogin, sourceHostname);\n                    }\n                }\n                else if (atPos == 'i') {\n                    if (pn == '+') {\n                        onSetInviteOnly(channel, sourceNick, sourceLogin, sourceHostname);\n                    }\n                    else {\n                        onRemoveInviteOnly(channel, sourceNick, sourceLogin, sourceHostname);\n                    }\n                }\n                else if (atPos == 'm') {\n                    if (pn == '+') {\n                        onSetModerated(channel, sourceNick, sourceLogin, sourceHostname);\n                    }\n                    else {\n                        onRemoveModerated(channel, sourceNick, sourceLogin, sourceHostname);\n                    }\n                }\n                else if (atPos == 'p') {\n                    if (pn == '+') {\n                        onSetPrivate(channel, sourceNick, sourceLogin, sourceHostname);\n                    }\n                    else {\n                        onRemovePrivate(channel, sourceNick, sourceLogin, sourceHostname);\n                    }\n                }\n                else if (atPos == 's') {\n                    if (pn == '+') {\n                        onSetSecret(channel, sourceNick, sourceLogin, sourceHostname);\n                    }\n                    else {\n                        onRemoveSecret(channel, sourceNick, sourceLogin, sourceHostname);\n                    }\n                }\n            }\n        \n            this.onMode(channel, sourceNick, sourceLogin, sourceHostname, mode);\n        }\n        else {\n            // The mode of a user is being changed.\n            String nick = target;\n            this.onUserMode(nick, sourceNick, sourceLogin, sourceHostname, mode);\n        }\n    }\n    \n    \n    /**\n     * Called when the mode of a channel is set.\n     *  <p>\n     * You may find it more convenient to decode the meaning of the mode\n     * string by overriding the onOp, onDeOp, onVoice, onDeVoice,\n     * onChannelKey, onDeChannelKey, onChannelLimit, onDeChannelLimit,\n     * onChannelBan or onDeChannelBan methods as appropriate.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     *\n     * @param channel The channel that the mode operation applies to.\n     * @param sourceNick The nick of the user that set the mode.\n     * @param sourceLogin The login of the user that set the mode.\n     * @param sourceHostname The hostname of the user that set the mode.\n     * @param mode The mode that has been set.\n     * \n     */\n    protected void onMode(String channel, String sourceNick, String sourceLogin, String sourceHostname, String mode) {}\n\n    \n    /**\n     * Called when the mode of a user is set.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @since PircBot 1.2.0\n     * \n     * @param targetNick The nick that the mode operation applies to.\n     * @param sourceNick The nick of the user that set the mode.\n     * @param sourceLogin The login of the user that set the mode.\n     * @param sourceHostname The hostname of the user that set the mode.\n     * @param mode The mode that has been set.\n     * \n     */\n    protected void onUserMode(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String mode) {}\n    \n    \n    \n    /**\n     * Called when a user (possibly us) gets granted operator status for a channel.\n     *  <p>\n     * This is a type of mode change and is also passed to the onMode\n     * method in the PircBot class.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @since PircBot 0.9.5\n     *\n     * @param channel The channel in which the mode change took place.\n     * @param sourceNick The nick of the user that performed the mode change.\n     * @param sourceLogin The login of the user that performed the mode change.\n     * @param sourceHostname The hostname of the user that performed the mode change.\n     * @param recipient The nick of the user that got 'opped'.\n     */\n    protected void onOp(String channel, String sourceNick, String sourceLogin, String sourceHostname, String recipient) {}\n\n\n    /**\n     * Called when a user (possibly us) gets operator status taken away.\n     *  <p>\n     * This is a type of mode change and is also passed to the onMode\n     * method in the PircBot class.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @since PircBot 0.9.5\n     *\n     * @param channel The channel in which the mode change took place.\n     * @param sourceNick The nick of the user that performed the mode change.\n     * @param sourceLogin The login of the user that performed the mode change.\n     * @param sourceHostname The hostname of the user that performed the mode change.\n     * @param recipient The nick of the user that got 'deopped'.\n     */\n    protected void onDeop(String channel, String sourceNick, String sourceLogin, String sourceHostname, String recipient) {}\n\n\n    /**\n     * Called when a user (possibly us) gets voice status granted in a channel.\n     *  <p>\n     * This is a type of mode change and is also passed to the onMode\n     * method in the PircBot class.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @since PircBot 0.9.5\n     *\n     * @param channel The channel in which the mode change took place.\n     * @param sourceNick The nick of the user that performed the mode change.\n     * @param sourceLogin The login of the user that performed the mode change.\n     * @param sourceHostname The hostname of the user that performed the mode change.\n     * @param recipient The nick of the user that got 'voiced'.\n     */\n    protected void onVoice(String channel, String sourceNick, String sourceLogin, String sourceHostname, String recipient) {}\n\n\n    /**\n     * Called when a user (possibly us) gets voice status removed.\n     *  <p>\n     * This is a type of mode change and is also passed to the onMode\n     * method in the PircBot class.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @since PircBot 0.9.5\n     *\n     * @param channel The channel in which the mode change took place.\n     * @param sourceNick The nick of the user that performed the mode change.\n     * @param sourceLogin The login of the user that performed the mode change.\n     * @param sourceHostname The hostname of the user that performed the mode change.\n     * @param recipient The nick of the user that got 'devoiced'.\n     */\n    protected void onDeVoice(String channel, String sourceNick, String sourceLogin, String sourceHostname, String recipient) {}\n\n\n    /**\n     * Called when a channel key is set.  When the channel key has been set,\n     * other users may only join that channel if they know the key.  Channel keys\n     * are sometimes referred to as passwords.\n     *  <p>\n     * This is a type of mode change and is also passed to the onMode\n     * method in the PircBot class.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @since PircBot 0.9.5\n     *\n     * @param channel The channel in which the mode change took place.\n     * @param sourceNick The nick of the user that performed the mode change.\n     * @param sourceLogin The login of the user that performed the mode change.\n     * @param sourceHostname The hostname of the user that performed the mode change.\n     * @param key The new key for the channel.\n     */\n    protected void onSetChannelKey(String channel, String sourceNick, String sourceLogin, String sourceHostname, String key) {}\n\n\n    /**\n     * Called when a channel key is removed.\n     *  <p>\n     * This is a type of mode change and is also passed to the onMode\n     * method in the PircBot class.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @since PircBot 0.9.5\n     *\n     * @param channel The channel in which the mode change took place.\n     * @param sourceNick The nick of the user that performed the mode change.\n     * @param sourceLogin The login of the user that performed the mode change.\n     * @param sourceHostname The hostname of the user that performed the mode change.\n     * @param key The key that was in use before the channel key was removed.\n     */\n    protected void onRemoveChannelKey(String channel, String sourceNick, String sourceLogin, String sourceHostname, String key) {}\n\n\n    /**\n     * Called when a user limit is set for a channel.  The number of users in\n     * the channel cannot exceed this limit.\n     *  <p>\n     * This is a type of mode change and is also passed to the onMode\n     * method in the PircBot class.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @since PircBot 0.9.5\n     *\n     * @param channel The channel in which the mode change took place.\n     * @param sourceNick The nick of the user that performed the mode change.\n     * @param sourceLogin The login of the user that performed the mode change.\n     * @param sourceHostname The hostname of the user that performed the mode change.\n     * @param limit The maximum number of users that may be in this channel at the same time.\n     */\n    protected void onSetChannelLimit(String channel, String sourceNick, String sourceLogin, String sourceHostname, int limit) {}\n\n\n    /**\n     * Called when the user limit is removed for a channel.\n     *  <p>\n     * This is a type of mode change and is also passed to the onMode\n     * method in the PircBot class.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @since PircBot 0.9.5\n     *\n     * @param channel The channel in which the mode change took place.\n     * @param sourceNick The nick of the user that performed the mode change.\n     * @param sourceLogin The login of the user that performed the mode change.\n     * @param sourceHostname The hostname of the user that performed the mode change.\n     */\n    protected void onRemoveChannelLimit(String channel, String sourceNick, String sourceLogin, String sourceHostname) {}\n\n\n    /**\n     * Called when a user (possibly us) gets banned from a channel.  Being\n     * banned from a channel prevents any user with a matching hostmask from\n     * joining the channel.  For this reason, most bans are usually directly\n     * followed by the user being kicked :-)\n     *  <p>\n     * This is a type of mode change and is also passed to the onMode\n     * method in the PircBot class.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @since PircBot 0.9.5\n     *\n     * @param channel The channel in which the mode change took place.\n     * @param sourceNick The nick of the user that performed the mode change.\n     * @param sourceLogin The login of the user that performed the mode change.\n     * @param sourceHostname The hostname of the user that performed the mode change.\n     * @param hostmask The hostmask of the user that has been banned.\n     */\n    protected void onSetChannelBan(String channel, String sourceNick, String sourceLogin, String sourceHostname, String hostmask) {}\n\n\n    /**\n     * Called when a hostmask ban is removed from a channel.\n     *  <p>\n     * This is a type of mode change and is also passed to the onMode\n     * method in the PircBot class.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @since PircBot 0.9.5\n     *\n     * @param channel The channel in which the mode change took place.\n     * @param sourceNick The nick of the user that performed the mode change.\n     * @param sourceLogin The login of the user that performed the mode change.\n     * @param sourceHostname The hostname of the user that performed the mode change.\n     * @param hostmask\n     */\n    protected void onRemoveChannelBan(String channel, String sourceNick, String sourceLogin, String sourceHostname, String hostmask) {}\n\n    \n    /**\n     * Called when topic protection is enabled for a channel.  Topic protection\n     * means that only operators in a channel may change the topic.\n     *  <p>\n     * This is a type of mode change and is also passed to the onMode\n     * method in the PircBot class.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @since PircBot 0.9.5\n     *\n     * @param channel The channel in which the mode change took place.\n     * @param sourceNick The nick of the user that performed the mode change.\n     * @param sourceLogin The login of the user that performed the mode change.\n     * @param sourceHostname The hostname of the user that performed the mode change.\n     */\n    protected void onSetTopicProtection(String channel, String sourceNick, String sourceLogin, String sourceHostname) {}\n    \n    \n    /**\n     * Called when topic protection is removed for a channel.\n     *  <p>\n     * This is a type of mode change and is also passed to the onMode\n     * method in the PircBot class.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @since PircBot 0.9.5\n     *\n     * @param channel The channel in which the mode change took place.\n     * @param sourceNick The nick of the user that performed the mode change.\n     * @param sourceLogin The login of the user that performed the mode change.\n     * @param sourceHostname The hostname of the user that performed the mode change.\n     */\n    protected void onRemoveTopicProtection(String channel, String sourceNick, String sourceLogin, String sourceHostname) {}\n    \n    \n    /**\n     * Called when a channel is set to only allow messages from users that\n     * are in the channel.\n     *  <p>\n     * This is a type of mode change and is also passed to the onMode\n     * method in the PircBot class.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @since PircBot 0.9.5\n     *\n     * @param channel The channel in which the mode change took place.\n     * @param sourceNick The nick of the user that performed the mode change.\n     * @param sourceLogin The login of the user that performed the mode change.\n     * @param sourceHostname The hostname of the user that performed the mode change.\n     */\n    protected void onSetNoExternalMessages(String channel, String sourceNick, String sourceLogin, String sourceHostname) {}\n    \n    \n    /**\n     * Called when a channel is set to allow messages from any user, even\n     * if they are not actually in the channel.\n     *  <p>\n     * This is a type of mode change and is also passed to the onMode\n     * method in the PircBot class.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @since PircBot 0.9.5\n     *\n     * @param channel The channel in which the mode change took place.\n     * @param sourceNick The nick of the user that performed the mode change.\n     * @param sourceLogin The login of the user that performed the mode change.\n     * @param sourceHostname The hostname of the user that performed the mode change.\n     */\n    protected void onRemoveNoExternalMessages(String channel, String sourceNick, String sourceLogin, String sourceHostname) {}\n    \n    \n    /**\n     * Called when a channel is set to 'invite only' mode.  A user may only\n     * join the channel if they are invited by someone who is already in the\n     * channel.\n     *  <p>\n     * This is a type of mode change and is also passed to the onMode\n     * method in the PircBot class.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @since PircBot 0.9.5\n     *\n     * @param channel The channel in which the mode change took place.\n     * @param sourceNick The nick of the user that performed the mode change.\n     * @param sourceLogin The login of the user that performed the mode change.\n     * @param sourceHostname The hostname of the user that performed the mode change.\n     */\n    protected void onSetInviteOnly(String channel, String sourceNick, String sourceLogin, String sourceHostname) {}\n    \n    \n    /**\n     * Called when a channel has 'invite only' removed.\n     *  <p>\n     * This is a type of mode change and is also passed to the onMode\n     * method in the PircBot class.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @since PircBot 0.9.5\n     *\n     * @param channel The channel in which the mode change took place.\n     * @param sourceNick The nick of the user that performed the mode change.\n     * @param sourceLogin The login of the user that performed the mode change.\n     * @param sourceHostname The hostname of the user that performed the mode change.\n     */\n    protected void onRemoveInviteOnly(String channel, String sourceNick, String sourceLogin, String sourceHostname) {}\n    \n    \n    /**\n     * Called when a channel is set to 'moderated' mode.  If a channel is\n     * moderated, then only users who have been 'voiced' or 'opped' may speak\n     * or change their nicks.\n     *  <p>\n     * This is a type of mode change and is also passed to the onMode\n     * method in the PircBot class.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @since PircBot 0.9.5\n     *\n     * @param channel The channel in which the mode change took place.\n     * @param sourceNick The nick of the user that performed the mode change.\n     * @param sourceLogin The login of the user that performed the mode change.\n     * @param sourceHostname The hostname of the user that performed the mode change.\n     */\n    protected void onSetModerated(String channel, String sourceNick, String sourceLogin, String sourceHostname) {}\n    \n    \n    /**\n     * Called when a channel has moderated mode removed.\n     *  <p>\n     * This is a type of mode change and is also passed to the onMode\n     * method in the PircBot class.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @since PircBot 0.9.5\n     *\n     * @param channel The channel in which the mode change took place.\n     * @param sourceNick The nick of the user that performed the mode change.\n     * @param sourceLogin The login of the user that performed the mode change.\n     * @param sourceHostname The hostname of the user that performed the mode change.\n     */\n    protected void onRemoveModerated(String channel, String sourceNick, String sourceLogin, String sourceHostname) {}\n    \n    \n    /**\n     * Called when a channel is marked as being in private mode.\n     *  <p>\n     * This is a type of mode change and is also passed to the onMode\n     * method in the PircBot class.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @since PircBot 0.9.5\n     *\n     * @param channel The channel in which the mode change took place.\n     * @param sourceNick The nick of the user that performed the mode change.\n     * @param sourceLogin The login of the user that performed the mode change.\n     * @param sourceHostname The hostname of the user that performed the mode change.\n     */\n    protected void onSetPrivate(String channel, String sourceNick, String sourceLogin, String sourceHostname) {}\n    \n    \n    /**\n     * Called when a channel is marked as not being in private mode.\n     *  <p>\n     * This is a type of mode change and is also passed to the onMode\n     * method in the PircBot class.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @since PircBot 0.9.5\n     *\n     * @param channel The channel in which the mode change took place.\n     * @param sourceNick The nick of the user that performed the mode change.\n     * @param sourceLogin The login of the user that performed the mode change.\n     * @param sourceHostname The hostname of the user that performed the mode change.\n     */\n    protected void onRemovePrivate(String channel, String sourceNick, String sourceLogin, String sourceHostname) {}\n    \n    \n    /**\n     * Called when a channel is set to be in 'secret' mode.  Such channels\n     * typically do not appear on a server's channel listing.\n     *  <p>\n     * This is a type of mode change and is also passed to the onMode\n     * method in the PircBot class.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @since PircBot 0.9.5\n     *\n     * @param channel The channel in which the mode change took place.\n     * @param sourceNick The nick of the user that performed the mode change.\n     * @param sourceLogin The login of the user that performed the mode change.\n     * @param sourceHostname The hostname of the user that performed the mode change.\n     */\n    protected void onSetSecret(String channel, String sourceNick, String sourceLogin, String sourceHostname) {}\n    \n    \n    /**\n     * Called when a channel has 'secret' mode removed.\n     *  <p>\n     * This is a type of mode change and is also passed to the onMode\n     * method in the PircBot class.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @since PircBot 0.9.5\n     *\n     * @param channel The channel in which the mode change took place.\n     * @param sourceNick The nick of the user that performed the mode change.\n     * @param sourceLogin The login of the user that performed the mode change.\n     * @param sourceHostname The hostname of the user that performed the mode change.\n     */\n    protected void onRemoveSecret(String channel, String sourceNick, String sourceLogin, String sourceHostname) {}\n    \n    \n    /**\n     * Called when we are invited to a channel by a user.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @since PircBot 0.9.5\n     * \n     * @param targetNick The nick of the user being invited - should be us!\n     * @param sourceNick The nick of the user that sent the invitation.\n     * @param sourceLogin The login of the user that sent the invitation.\n     * @param sourceHostname The hostname of the user that sent the invitation.\n     * @param channel The channel that we're being invited to.\n     */\n    protected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String channel)  {}    \n\n\n    /**\n     * This method used to be called when a DCC SEND request was sent to the PircBot.\n     * Please use the onIncomingFileTransfer method to receive files, as it\n     * has better functionality and supports resuming.\n     * \n     * @deprecated As of PircBot 1.2.0, use {@link #onIncomingFileTransfer(DccFileTransfer)}\n     */\n    protected void onDccSendRequest(String sourceNick, String sourceLogin, String sourceHostname, String filename, long address, int port, int size) {}\n    \n    \n    /**\n     * This method used to be called when a DCC CHAT request was sent to the PircBot.\n     * Please use the onIncomingChatRequest method to accept chats, as it\n     * has better functionality.\n     * \n     * @deprecated As of PircBot 1.2.0, use {@link #onIncomingChatRequest(DccChat)}\n     */\n    protected void onDccChatRequest(String sourceNick, String sourceLogin, String sourceHostname, long address, int port) {}\n    \n    \n    /**\n     * This method is called whenever a DCC SEND request is sent to the PircBot.\n     * This means that a client has requested to send a file to us.\n     * This abstract implementation performs no action, which means that all\n     * DCC SEND requests will be ignored by default. If you wish to receive\n     * the file, then you may override this method and call the receive method\n     * on the DccFileTransfer object, which connects to the sender and downloads\n     * the file.\n     *  <p>\n     * Example:\n     * <pre> public void onIncomingFileTransfer(DccFileTransfer transfer) {\n     *     // Use the suggested file name.\n     *     File file = transfer.getFile();\n     *     // Receive the transfer and save it to the file, allowing resuming.\n     *     transfer.receive(file, true);\n     * }<\/pre>\n     *  <p>\n     * <b>Warning:<\/b> Receiving an incoming file transfer will cause a file\n     * to be written to disk. Please ensure that you make adequate security\n     * checks so that this file does not overwrite anything important!\n     *  <p>\n     * Each time a file is received, it happens within a new Thread\n     * in order to allow multiple files to be downloaded by the PircBot\n     * at the same time. \n     *  <p>\n     * If you allow resuming and the file already partly exists, it will\n     * be appended to instead of overwritten.  If resuming is not enabled,\n     * the file will be overwritten if it already exists.\n     *  <p>\n     * You can throttle the speed of the transfer by calling the setPacketDelay\n     * method on the DccFileTransfer object, either before you receive the\n     * file or at any moment during the transfer.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     *\n     * @since PircBot 1.2.0\n     * \n     * @param transfer The DcccFileTransfer that you may accept.\n     * \n     * @see DccFileTransfer\n     * \n     */\n    protected void onIncomingFileTransfer(DccFileTransfer transfer) {}\n    \n    \n    /**\n     * This method gets called when a DccFileTransfer has finished.\n     * If there was a problem, the Exception will say what went wrong.\n     * If the file was sent successfully, the Exception will be null.\n     *  <p>\n     * Both incoming and outgoing file transfers are passed to this method.\n     * You can determine the type by calling the isIncoming or isOutgoing\n     * methods on the DccFileTransfer object.\n     *\n     * @since PircBot 1.2.0\n     * \n     * @param transfer The DccFileTransfer that has finished.\n     * @param e null if the file was transfered successfully, otherwise this\n     *          will report what went wrong.\n     * \n     * @see DccFileTransfer\n     * \n     */\n    protected void onFileTransferFinished(DccFileTransfer transfer, Exception e) {}\n    \n    \n    /**\n     * This method will be called whenever a DCC Chat request is received.\n     * This means that a client has requested to chat to us directly rather\n     * than via the IRC server. This is useful for sending many lines of text\n     * to and from the bot without having to worry about flooding the server\n     * or any operators of the server being able to \"spy\" on what is being\n     * said. This abstract implementation performs no action, which means\n     * that all DCC CHAT requests will be ignored by default.\n     *  <p>\n     * If you wish to accept the connection, then you may override this\n     * method and call the accept() method on the DccChat object, which\n     * connects to the sender of the chat request and allows lines to be\n     * sent to and from the bot.\n     *  <p>\n     * Your bot must be able to connect directly to the user that sent the\n     * request.\n     *  <p>\n     * Example: \n     * <pre> public void onIncomingChatRequest(DccChat chat) {\n     *     try {\n     *         // Accept all chat, whoever it's from.\n     *         chat.accept();\n     *         chat.sendLine(\"Hello\");\n     *         String response = chat.readLine();\n     *         chat.close();\n     *     }\n     *     catch (IOException e) {}\n     * }<\/pre>\n     * \n     * Each time this method is called, it is called from within a new Thread\n     * so that multiple DCC CHAT sessions can run concurrently.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     *\n     * @since PircBot 1.2.0\n     * \n     * @param chat A DccChat object that represents the incoming chat request.\n     * \n     * @see DccChat\n     * \n     */\n    protected void onIncomingChatRequest(DccChat chat) {}\n    \n    \n    /**\n     * This method is called whenever we receive a VERSION request.\n     * This abstract implementation responds with the PircBot's _version string,\n     * so if you override this method, be sure to either mimic its functionality\n     * or to call super.onVersion(...);\n     * \n     * @param sourceNick The nick of the user that sent the VERSION request.\n     * @param sourceLogin The login of the user that sent the VERSION request.\n     * @param sourceHostname The hostname of the user that sent the VERSION request.\n     * @param target The target of the VERSION request, be it our nick or a channel name.\n     */\n    protected void onVersion(String sourceNick, String sourceLogin, String sourceHostname, String target) {\n        this.sendRawLine(\"NOTICE \" + sourceNick + \" :\\u0001VERSION \" + _version + \"\\u0001\");\n    }\n    \n    \n    /**\n     * This method is called whenever we receive a PING request from another\n     * user.\n     *  <p>\n     * This abstract implementation responds correctly, so if you override this\n     * method, be sure to either mimic its functionality or to call\n     * super.onPing(...);\n     * \n     * @param sourceNick The nick of the user that sent the PING request.\n     * @param sourceLogin The login of the user that sent the PING request.\n     * @param sourceHostname The hostname of the user that sent the PING request.\n     * @param target The target of the PING request, be it our nick or a channel name.\n     * @param pingValue The value that was supplied as an argument to the PING command.\n     */\n    protected void onPing(String sourceNick, String sourceLogin, String sourceHostname, String target, String pingValue) {\n        this.sendRawLine(\"NOTICE \" + sourceNick + \" :\\u0001PING \" + pingValue + \"\\u0001\");\n    }\n    \n    \n    /**\n     * The actions to perform when a PING request comes from the server.\n     *  <p>\n     * This sends back a correct response, so if you override this method,\n     * be sure to either mimic its functionality or to call\n     * super.onServerPing(response);\n     *\n     * @param response The response that should be given back in your PONG.\n     */\n    protected void onServerPing(String response) {\n        this.sendRawLine(\"PONG \" + response);\n    }\n    \n    \n    /**\n     * This method is called whenever we receive a TIME request.\n     *  <p>\n     * This abstract implementation responds correctly, so if you override this\n     * method, be sure to either mimic its functionality or to call\n     * super.onTime(...);\n     * \n     * @param sourceNick The nick of the user that sent the TIME request.\n     * @param sourceLogin The login of the user that sent the TIME request.\n     * @param sourceHostname The hostname of the user that sent the TIME request.\n     * @param target The target of the TIME request, be it our nick or a channel name.\n     */\n    protected void onTime(String sourceNick, String sourceLogin, String sourceHostname, String target) {\n        this.sendRawLine(\"NOTICE \" + sourceNick + \" :\\u0001TIME \" + new Date().toString() + \"\\u0001\");\n    }\n    \n    \n    /**\n     * This method is called whenever we receive a FINGER request.\n     *  <p>\n     * This abstract implementation responds correctly, so if you override this\n     * method, be sure to either mimic its functionality or to call\n     * super.onFinger(...);\n     * \n     * @param sourceNick The nick of the user that sent the FINGER request.\n     * @param sourceLogin The login of the user that sent the FINGER request.\n     * @param sourceHostname The hostname of the user that sent the FINGER request.\n     * @param target The target of the FINGER request, be it our nick or a channel name.\n     */\n    protected void onFinger(String sourceNick, String sourceLogin, String sourceHostname, String target) {\n        this.sendRawLine(\"NOTICE \" + sourceNick + \" :\\u0001FINGER \" + _finger + \"\\u0001\");\n    }\n    \n    \n    /**\n     * This method is called whenever we receive a line from the server that\n     * the PircBot has not been programmed to recognise.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @param line The raw line that was received from the server.\n     */\n    protected void onUnknown(String line) {\n        // And then there were none :)\n    }\n    \n    /**\n     * Sets the name of the bot, which will be used as its nick when it\n     * tries to join an IRC server.  This should be set before joining\n     * any servers, otherwise the default nick will be used.  You would\n     * typically call this method from the constructor of the class that\n     * extends PircBot.\n     *  <p>\n     * The changeNick method should be used if you wish to change your nick\n     * when you are connected to a server.\n     *\n     * @param name The new name of the Bot.\n     */\n    protected final void setName(String name) {\n        _name = name;\n    }\n    \n    \n    /**\n     * Sets the internal nick of the bot.  This is only to be called by the\n     * PircBot class in response to notification of nick changes that apply\n     * to us.\n     * \n     * @param nick The new nick.\n     */\n    private final void setNick(String nick) {\n        _nick = nick;\n    }\n    \n    \n    /**\n     * Sets the internal login of the Bot.  This should be set before joining\n     * any servers.\n     *\n     * @param login The new login of the Bot.\n     */\n    protected final void setLogin(String login) {\n        _login = login;\n    }\n    \n\n    /**\n     * Sets the internal version of the Bot.  This should be set before joining\n     * any servers.\n     *\n     * @param version The new version of the Bot.\n     */\n    protected final void setVersion(String version) {\n        _version = version;\n    }\n\n\n    /**\n     * Sets the interal finger message.  This should be set before joining\n     * any servers.\n     *\n     * @param finger The new finger message for the Bot.\n     */\n    protected final void setFinger(String finger) {\n        _finger = finger;\n    }\n    \n    \n    /**\n     * Gets the name of the PircBot. This is the name that will be used as\n     * as a nick when we try to join servers.\n     *\n     * @return The name of the PircBot.\n     */\n    public final String getName() {\n        return _name;\n    }\n    \n    \n    /**\n     * Returns the current nick of the bot. Note that if you have just changed\n     * your nick, this method will still return the old nick until confirmation\n     * of the nick change is received from the server.\n     *  <p>\n     * The nick returned by this method is maintained only by the PircBot\n     * class and is guaranteed to be correct in the context of the IRC server.\n     *\n     * @since PircBot 1.0.0\n     * \n     * @return The current nick of the bot.\n     */\n    public String getNick() {\n        return _nick;\n    }\n    \n    \n    /**\n     * Gets the internal login of the PircBot.\n     *\n     * @return The login of the PircBot.\n     */\n    public final String getLogin() {\n        return _login;\n    }\n    \n\n    /**\n     * Gets the internal version of the PircBot.\n     *\n     * @return The version of the PircBot.\n     */\n    public final String getVersion() {\n        return _version;\n    }\n    \n    \n    /**\n     * Gets the internal finger message of the PircBot.\n     *\n     * @return The finger message of the PircBot.\n     */\n    public final String getFinger() {\n        return _finger;\n    }\n    \n    \n    /**\n     * Returns whether or not the PircBot is currently connected to a server.\n     * The result of this method should only act as a rough guide,\n     * as the result may not be valid by the time you act upon it.\n     *\n     * @return True if and only if the PircBot is currently connected to a server.\n     */\n    public final synchronized boolean isConnected() {\n        return _inputThread != null && _inputThread.isConnected();\n    }\n    \n    \n    /**\n     * Sets the number of milliseconds to delay between consecutive\n     * messages when there are multiple messages waiting in the\n     * outgoing message queue.  This has a default value of 1000ms.\n     * It is a good idea to stick to this default value, as it will\n     * prevent your bot from spamming servers and facing the subsequent\n     * wrath!  However, if you do need to change this delay value (<b>not\n     * recommended<\/b>), then this is the method to use.\n     *\n     * @param delay The number of milliseconds between each outgoing message.\n     * \n     */\n    public final void setMessageDelay(long delay) {\n        if (delay < 0) {\n            throw new IllegalArgumentException(\"Cannot have a negative time.\");\n        }\n        _messageDelay = delay;\n    }\n    \n    \n    /**\n     * Returns the number of milliseconds that will be used to separate\n     * consecutive messages to the server from the outgoing message queue.\n     *\n     * @return Number of milliseconds.\n     */\n    public final long getMessageDelay() {\n        return _messageDelay;\n    }\n    \n    \n    /**\n     * Gets the maximum length of any line that is sent via the IRC protocol.\n     * The IRC RFC specifies that line lengths, including the trailing \\r\\n\n     * must not exceed 512 bytes.  Hence, there is currently no option to\n     * change this value in PircBot.  All lines greater than this length\n     * will be truncated before being sent to the IRC server.\n     * \n     * @return The maximum line length (currently fixed at 512)\n     */\n    public final int getMaxLineLength() {\n        return InputThread.MAX_LINE_LENGTH;\n    }\n    \n    \n    /**\n     * Gets the number of lines currently waiting in the outgoing message Queue.\n     * If this returns 0, then the Queue is empty and any new message is likely\n     * to be sent to the IRC server immediately.\n     *\n     * @since PircBot 0.9.9\n     * \n     * @return The number of lines in the outgoing message Queue.\n     */\n    public final int getOutgoingQueueSize() {\n        return _outQueue.size();\n    }\n    \n    \n    /**\n     * Returns the name of the last IRC server the PircBot tried to connect to.\n     * This does not imply that the connection attempt to the server was\n     * successful (we suggest you look at the onConnect method).\n     * A value of null is returned if the PircBot has never tried to connect\n     * to a server.\n     * \n     * @return The name of the last machine we tried to connect to. Returns\n     *         null if no connection attempts have ever been made.\n     */\n    public final String getServer() {\n        return _server;\n    }\n    \n    \n    /**\n     * Returns the port number of the last IRC server that the PircBot tried\n     * to connect to.\n     * This does not imply that the connection attempt to the server was\n     * successful (we suggest you look at the onConnect method).\n     * A value of -1 is returned if the PircBot has never tried to connect\n     * to a server.\n     * \n     * @since PircBot 0.9.9\n     * \n     * @return The port number of the last IRC server we connected to.\n     *         Returns -1 if no connection attempts have ever been made.\n     */\n    public final int getPort() {\n        return _port;\n    }\n    \n    \n    /**\n     * Returns the last password that we used when connecting to an IRC server.\n     * This does not imply that the connection attempt to the server was\n     * successful (we suggest you look at the onConnect method).\n     * A value of null is returned if the PircBot has never tried to connect\n     * to a server using a password.\n     * \n     * @since PircBot 0.9.9\n     * \n     * @return The last password that we used when connecting to an IRC server.\n     *         Returns null if we have not previously connected using a password.\n     */\n    public final String getPassword() {\n        return _password;\n    }\n    \n    \n    /**\n     * A convenient method that accepts an IP address represented as a\n     * long and returns an integer array of size 4 representing the same\n     * IP address.\n     * \n     * @since PircBot 0.9.4\n     *\n     * @param address the long value representing the IP address.\n     * \n     * @return An int[] of size 4.\n     */\n    public int[] longToIp(long address) {\n        int[] ip = new int[4];\n        for (int i = 3; i >= 0; i--) {\n            ip[i] = (int) (address % 256);\n            address = address / 256;\n        }\n        return ip;\n    }\n\n    \n    /**\n     * A convenient method that accepts an IP address represented by a byte[]\n     * of size 4 and returns this as a long representation of the same IP\n     * address.\n     * \n     * @since PircBot 0.9.4\n     *\n     * @param address the byte[] of size 4 representing the IP address.\n     * \n     * @return a long representation of the IP address.\n     */\n    public long ipToLong(byte[] address) {\n        if (address.length != 4) {\n            throw new IllegalArgumentException(\"byte array must be of length 4\");\n        }\n        long ipNum = 0;\n        long multiplier = 1;\n        for (int i = 3; i >= 0; i--) {\n            int byteVal = (address[i] + 256) % 256;\n            ipNum += byteVal*multiplier;\n            multiplier *= 256;\n        }\n        return ipNum;\n    }\n    \n    \n    /**\n     * Sets the encoding charset to be used when sending or receiving lines\n     * from the IRC server.  If set to null, then the platform's default\n     * charset is used.  You should only use this method if you are\n     * trying to send text to an IRC server in a different charset, e.g.\n     * \"GB2312\" for Chinese encoding.  If a PircBot is currently connected\n     * to a server, then it must reconnect before this change takes effect.\n     * \n     * @since PircBot 1.0.4\n     * \n     * @param charset The new encoding charset to be used by PircBot.\n     * \n     * @throws UnsupportedEncodingException If the named charset is not\n     *                                      supported.\n     */\n    public void setEncoding(String charset) throws UnsupportedEncodingException {\n        // Just try to see if the charset is supported first...\n        \"\".getBytes(charset);\n        \n        _charset = charset;\n    }\n\n    \n    /**\n     * Returns the encoding used to send and receive lines from\n     * the IRC server, or null if not set.  Use the setEncoding\n     * method to change the encoding charset.\n     * \n     * @since PircBot 1.0.4\n     * \n     * @return The encoding used to send outgoing messages, or\n     *         null if not set.\n     */\n    public String getEncoding() {\n        return _charset;\n    }\n    \n    /**\n     * Returns the InetAddress used by the PircBot.\n     * This can be used to find the I.P. address from which the PircBot is\n     * connected to a server.\n     * \n     * @since PircBot 1.4.4\n     * \n     * @return The current local InetAddress, or null if never connected.\n     */\n    public InetAddress getInetAddress() {\n        return _inetAddress;\n    }\n    \n\n    /**\n     * Sets the InetAddress to be used when sending DCC chat or file transfers.\n     * This can be very useful when you are running a bot on a machine which\n     * is behind a firewall and you need to tell receiving clients to connect\n     * to a NAT/router, which then forwards the connection.\n     * \n     * @since PircBot 1.4.4\n     * \n     * @param dccInetAddress The new InetAddress, or null to use the default.\n     */\n    public void setDccInetAddress(InetAddress dccInetAddress) {\n        _dccInetAddress = dccInetAddress;\n    }\n    \n\n    /**\n     * Returns the InetAddress used when sending DCC chat or file transfers.\n     * If this is null, the default InetAddress will be used.\n     * \n     * @since PircBot 1.4.4\n     * \n     * @return The current DCC InetAddress, or null if left as default.\n     */\n    public InetAddress getDccInetAddress() {\n        return _dccInetAddress;\n    }\n    \n    \n    /**\n     * Returns the set of port numbers to be used when sending a DCC chat\n     * or file transfer. This is useful when you are behind a firewall and\n     * need to set up port forwarding. The array of port numbers is traversed\n     * in sequence until a free port is found to listen on. A DCC tranfer will\n     * fail if all ports are already in use.\n     * If set to null, <i>any<\/i> free port number will be used. \n     * \n     * @since PircBot 1.4.4\n     * \n     * @return An array of port numbers that PircBot can use to send DCC\n     *         transfers, or null if any port is allowed.\n     */\n    public int[] getDccPorts() {\n        if (_dccPorts == null || _dccPorts.length == 0) {\n            return null;\n        }\n        // Clone the array to prevent external modification.\n        return (int[]) _dccPorts.clone();\n    }\n    \n    \n    /**\n     * Sets the choice of port numbers that can be used when sending a DCC chat\n     * or file transfer. This is useful when you are behind a firewall and\n     * need to set up port forwarding. The array of port numbers is traversed\n     * in sequence until a free port is found to listen on. A DCC tranfer will\n     * fail if all ports are already in use.\n     * If set to null, <i>any<\/i> free port number will be used. \n     * \n     * @since PircBot 1.4.4\n     * \n     * @param ports The set of port numbers that PircBot may use for DCC\n     *              transfers, or null to let it use any free port (default).\n     *\n     */\n    public void setDccPorts(int[] ports) {\n        if (ports == null || ports.length == 0) {\n            _dccPorts = null;\n        }\n        else {\n            // Clone the array to prevent external modification.\n            _dccPorts = (int[]) ports.clone();\n        }\n    }    \n    \n    \n    /**\n     * Returns true if and only if the object being compared is the exact\n     * same instance as this PircBot. This may be useful if you are writing\n     * a multiple server IRC bot that uses more than one instance of PircBot.\n     * \n     * @since PircBot 0.9.9\n     *\n     * @return true if and only if Object o is a PircBot and equal to this.\n     */\n    public boolean equals(Object o) {\n        // This probably has the same effect as Object.equals, but that may change...\n        if (o instanceof PircBot) {\n            PircBot other = (PircBot) o;\n            return other == this;\n        }\n        return false;\n    }\n    \n    \n    /**\n     * Returns the hashCode of this PircBot. This method can be called by hashed\n     * collection classes and is useful for managing multiple instances of\n     * PircBots in such collections.\n     * \n     * @since PircBot 0.9.9\n     * \n     * @return the hash code for this instance of PircBot.\n     */\n    public int hashCode() {\n        return super.hashCode();\n    }\n    \n    \n    /**\n     * Returns a String representation of this object.\n     * You may find this useful for debugging purposes, particularly\n     * if you are using more than one PircBot instance to achieve\n     * multiple server connectivity. The format of\n     * this String may change between different versions of PircBot\n     * but is currently something of the form\n     * <code>\n     *   Version{PircBot x.y.z Java IRC Bot - www.jibble.org}\n     *   Connected{true}\n     *   Server{irc.dal.net}\n     *   Port{6667}\n     *   Password{}\n     * <\/code>\n     * \n     * @since PircBot 0.9.10\n     * \n     * @return a String representation of this object.\n     */\n    public String toString() {\n        return \"Version{\" + _version + \"}\" +\n                \" Connected{\" + isConnected() + \"}\" +\n                \" Server{\" + _server + \"}\" +\n                \" Port{\" + _port + \"}\" +\n                \" Password{\" + _password + \"}\";\n    }\n    \n    \n    /**\n     * Returns an array of all users in the specified channel.\n     *  <p>\n     * There are some important things to note about this method:-\n     * <ul>\n     *  <li>This method may not return a full list of users if you call it\n     *      before the complete nick list has arrived from the IRC server.\n     *  <\/li>\n     *  <li>If you wish to find out which users are in a channel as soon\n     *      as you join it, then you should override the onUserList method\n     *      instead of calling this method, as the onUserList method is only\n     *      called as soon as the full user list has been received.\n     *  <\/li>\n     *  <li>This method will return immediately, as it does not require any\n     *      interaction with the IRC server.\n     *  <\/li>\n     *  <li>The bot must be in a channel to be able to know which users are\n     *      in it.\n     *  <\/li>\n     * <\/ul>\n     * \n     * @since PircBot 1.0.0\n     *\n     * @param channel The name of the channel to list.\n     * \n     * @return An array of User objects. This array is empty if we are not\n     *         in the channel.\n     * \n     * @see #onUserList(String,User[]) onUserList\n     */\n    public final User[] getUsers(String channel) {\n        channel = channel.toLowerCase();\n        User[] userArray = new User[0];\n        synchronized (_channels) {\n            Hashtable<User, User> users = _channels.get(channel);\n            if (users != null) {\n                userArray = new User[users.size()];\n                Enumeration<User> enumeration = users.elements();\n                for (int i = 0; i < userArray.length; i++) {\n                    User user = (User) enumeration.nextElement();\n                    userArray[i] = user;\n                }\n            }\n        }\n        return userArray;\n    }\n    \n    \n    /**\n     * Returns an array of all channels that we are in.  Note that if you\n     * call this method immediately after joining a new channel, the new\n     * channel may not appear in this array as it is not possible to tell\n     * if the join was successful until a response is received from the\n     * IRC server.\n     * \n     * @since PircBot 1.0.0\n     * \n     * @return A String array containing the names of all channels that we\n     *         are in.\n     */\n    public final String[] getChannels() {\n        String[] channels = new String[0];\n        synchronized (_channels) {\n            channels = new String[_channels.size()];\n            Enumeration<String> enumeration = _channels.keys();\n            for (int i = 0; i < channels.length; i++) {\n                channels[i] = (String) enumeration.nextElement();\n            }\n        }\n        return channels;\n    }\n    \n    \n    /**\n     * Disposes of all thread resources used by this PircBot. This may be\n     * useful when writing bots or clients that use multiple servers (and\n     * therefore multiple PircBot instances) or when integrating a PircBot\n     * with an existing program.\n     *  <p>\n     * Each PircBot runs its own threads for dispatching messages from its\n     * outgoing message queue and receiving messages from the server.\n     * Calling dispose() ensures that these threads are\n     * stopped, thus freeing up system resources and allowing the PircBot\n     * object to be garbage collected if there are no other references to\n     * it.\n     *  <p>\n     * Once a PircBot object has been disposed, it should not be used again.\n     * Attempting to use a PircBot that has been disposed may result in\n     * unpredictable behaviour.\n     * \n     * @since 1.2.2\n     */\n    public synchronized void dispose() {\n        //System.out.println(\"disposing...\");\n        _outputThread.interrupt();\n        _inputThread.dispose();\n    }\n    \n    \n    /**\n     * Add a user to the specified channel in our memory.\n     * Overwrite the existing entry if it exists.\n     */\n    private final void addUser(String channel, User user) {\n        channel = channel.toLowerCase();\n        synchronized (_channels) {\n            Hashtable<User, User> users = _channels.get(channel);\n            if (users == null) {\n                users = new Hashtable<User, User>();\n                _channels.put(channel, users);\n            }\n            users.put(user, user);\n        }\n    }\n    \n    \n    /**\n     * Remove a user from the specified channel in our memory.\n     */\n    private final User removeUser(String channel, String nick) {\n        channel = channel.toLowerCase();\n        User user = new User(\"\", nick);\n        synchronized (_channels) {\n            Hashtable<User, User> users = _channels.get(channel);\n            if (users != null) {\n                return (User) users.remove(user);\n            }\n        }\n        return null;\n    }\n    \n    \n    /**\n     * Remove a user from all channels in our memory.\n     */\n    private final void removeUser(String nick) {\n        synchronized (_channels) {\n            Enumeration<String> enumeration = _channels.keys();\n            while (enumeration.hasMoreElements()) {\n                String channel = (String) enumeration.nextElement();\n                this.removeUser(channel, nick);\n            }\n        }\n    }\n    \n    \n    /**\n     * Rename a user if they appear in any of the channels we know about.\n     */\n    private final void renameUser(String oldNick, String newNick) {\n        synchronized (_channels) {\n            Enumeration<String> enumeration = _channels.keys();\n            while (enumeration.hasMoreElements()) {\n                String channel = (String) enumeration.nextElement();\n                User user = this.removeUser(channel, oldNick);\n                if (user != null) {\n                    user = new User(user.getPrefix(), newNick);\n                    this.addUser(channel, user);\n                }\n            }\n        }\n    }\n    \n    \n    /**\n     * Removes an entire channel from our memory of users.\n     */\n    private final void removeChannel(String channel) {\n        channel = channel.toLowerCase();\n        synchronized (_channels) {\n            _channels.remove(channel);\n        }\n    }\n    \n    \n    /**\n     * Removes all channels from our memory of users.\n     */\n    private final void removeAllChannels() {\n        synchronized(_channels) {\n            _channels = new Hashtable<String, Hashtable<User, User>>();\n        }\n    }\n\n\n    private final void updateUser(String channel, int userMode, String nick) {\n        channel = channel.toLowerCase();\n        synchronized (_channels) {\n            Hashtable<User, User> users = _channels.get(channel);\n            User newUser = null;\n            if (users != null) {\n                Enumeration<User> enumeration = users.elements();\n                while(enumeration.hasMoreElements()) {\n                    User userObj = (User) enumeration.nextElement();\n                    if (userObj.getNick().equalsIgnoreCase(nick)) {\n                        if (userMode == OP_ADD) {\n                            if (userObj.hasVoice()) {\n                                newUser = new User(\"@+\", nick);\n                            }\n                            else {\n                                newUser = new User(\"@\", nick);\n                            }\n                        }\n                        else if (userMode == OP_REMOVE) {\n                            if(userObj.hasVoice()) {\n                                newUser = new User(\"+\", nick);\n                            }\n                            else {\n                                newUser = new User(\"\", nick);\n                            }\n                        }\n                        else if (userMode == VOICE_ADD) {\n                            if(userObj.isOp()) {\n                                newUser = new User(\"@+\", nick);\n                            }\n                            else {\n                                newUser = new User(\"+\", nick);\n                            }\n                        }\n                        else if (userMode == VOICE_REMOVE) {\n                            if(userObj.isOp()) {\n                                newUser = new User(\"@\", nick);\n                            }\n                            else {\n                                newUser = new User(\"\", nick);\n                            }\n                        }\n                    }\n                }\n            }\n            if (newUser != null) {\n                users.put(newUser, newUser);\n            }\n            else {\n                // just in case ...\n                newUser = new User(\"\", nick);\n                users.put(newUser, newUser);\n            }\n        }\n    }\n\n\n    // Connection stuff.\n    private InputThread _inputThread = null;\n    private OutputThread _outputThread = null;\n    private String _charset = null;\n    private InetAddress _inetAddress = null;\n\n    // Details about the last server that we connected to.\n    private String _server = null;\n    private int _port = -1;\n    private String _password = null;\n    \n    // Outgoing message stuff.\n    private Queue _outQueue = new Queue();\n    private long _messageDelay = 1000;\n    \n    // A Hashtable of channels that points to a selfreferential Hashtable of\n    // User objects (used to remember which users are in which channels).\n    private Hashtable<String, Hashtable<User, User>> _channels = new Hashtable<String, Hashtable<User, User>>();\n    \n    // A Hashtable to temporarily store channel topics when we join them\n    // until we find out who set that topic.\n    private Hashtable<String, String> _topics = new Hashtable<String, String>();\n    \n    // DccManager to process and handle all DCC events.\n    private DccManager _dccManager = new DccManager(this);\n    private int[] _dccPorts = null;\n    private InetAddress _dccInetAddress = null;\n    \n    // Default settings for the PircBot.\n    private boolean _autoNickChange = false;\n    private boolean _useSSL = false;\n\n    private String _name = \"PircBot\";\n    private String _nick = _name;\n    private String _login = \"PircBot\";\n    private String _version = \"PircBot \" + VERSION + \" Java IRC Bot - www.jibble.org\";\n    private String _finger = \"You ought to be arrested for fingering a bot!\";\n    \n    private String _channelPrefixes = \"#&+!\";\n}\n","Method after Refactoring":"/* \nCopyright Paul James Mutton, 2001-2007, http://www.jibble.org/\n\nThis file is part of PircBot.\n\nThis software is dual-licensed, allowing you to choose between the GNU\nGeneral Public License (GPL) and the www.jibble.org Commercial License.\nSince the GPL may be too restrictive for use in a proprietary application,\na commercial license is also provided. Full license information can be\nfound at http://www.jibble.org/licenses/\n\nModified by: Sebastian Kaspari <sebastian@yaaic.org>\n\n*/\npackage org.jibble.pircbot;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.UnsupportedEncodingException;\nimport java.net.InetAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Date;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.StringTokenizer;\n\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocket;\nimport javax.net.ssl.SSLSocketFactory;\nimport javax.net.ssl.X509TrustManager;\n\nimport org.yaaic.ssl.NaiveTrustManager;\n\n/**\n * PircBot is a Java framework for writing IRC bots quickly and easily.\n *  <p>\n * It provides an event-driven architecture to handle common IRC\n * events, flood protection, DCC support, ident support, and more.\n * The comprehensive logfile format is suitable for use with pisg to generate\n * channel statistics.\n *  <p>\n * Methods of the PircBot class can be called to send events to the IRC server\n * that it connects to.  For example, calling the sendMessage method will\n * send a message to a channel or user on the IRC server.  Multiple servers\n * can be supported using multiple instances of PircBot.\n *  <p>\n * To perform an action when the PircBot receives a normal message from the IRC\n * server, you would override the onMessage method defined in the PircBot\n * class.  All on<i>XYZ<\/i> methods in the PircBot class are automatically called\n * when the event <i>XYZ<\/i> happens, so you would override these if you wish\n * to do something when it does happen.\n *  <p>\n * Some event methods, such as onPing, should only really perform a specific\n * function (i.e. respond to a PING from the server).  For your convenience, such\n * methods are already correctly implemented in the PircBot and should not\n * normally need to be overridden.  Please read the full documentation for each\n * method to see which ones are already implemented by the PircBot class.\n *  <p>\n * Please visit the PircBot homepage at\n * <a href=\"http://www.jibble.org/pircbot.php\">http://www.jibble.org/pircbot.php<\/a>\n * for full revision history, a beginners guide to creating your first PircBot\n * and a list of some existing Java IRC bots and clients that use the PircBot\n * framework.\n * \n * @author  Paul James Mutton,\n *          <a href=\"http://www.jibble.org/\">http://www.jibble.org/<\/a>\n * @version    1.4.6 (Build time: Wed Apr 11 19:20:59 2007)\n */\npublic abstract class PircBot implements ReplyConstants {\n    /**\n     * The definitive version number of this release of PircBot.\n     * (Note: Change this before automatically building releases)\n     */\n    public static final String VERSION = \"1.4.6\";\n    \n    private static final int OP_ADD = 1;\n    private static final int OP_REMOVE = 2;\n    private static final int VOICE_ADD = 3;\n    private static final int VOICE_REMOVE = 4;\n    \n    /**\n     * Constructs a PircBot with the default settings.  Your own constructors\n     * in classes which extend the PircBot abstract class should be responsible\n     * for changing the default settings if required.\n     */\n    public PircBot() {}\n    \n    /**\n     * Attempt to connect to the specified IRC server.\n     * The onConnect method is called upon success.\n     *\n     * @param hostname The hostname of the server to connect to.\n     * \n     * @throws IOException if it was not possible to connect to the server.\n     * @throws IrcException if the server would not let us join it.\n     * @throws NickAlreadyInUseException if our nick is already in use on the server.\n     */\n    public final synchronized void connect(String hostname) throws IOException, IrcException, NickAlreadyInUseException {\n        this.connect(hostname, 6667, null);\n    }\n\n\n    /**\n     * Attempt to connect to the specified IRC server and port number.\n     * The onConnect method is called upon success.\n     *\n     * @param hostname The hostname of the server to connect to.\n     * @param port The port number to connect to on the server.\n     * \n     * @throws IOException if it was not possible to connect to the server.\n     * @throws IrcException if the server would not let us join it.\n     * @throws NickAlreadyInUseException if our nick is already in use on the server.\n     */\n    public final synchronized void connect(String hostname, int port) throws IOException, IrcException, NickAlreadyInUseException {\n        this.connect(hostname, port, null);\n    }\n    \n    \n    /**\n     * Attempt to connect to the specified IRC server using the supplied\n     * password.\n     * The onConnect method is called upon success.\n     *\n     * @param hostname The hostname of the server to connect to.\n     * @param port The port number to connect to on the server.\n     * @param password The password to use to join the server.\n     *\n     * @throws IOException if it was not possible to connect to the server.\n     * @throws IrcException if the server would not let us join it.\n     * @throws NickAlreadyInUseException if our nick is already in use on the server.\n     */\n    public final synchronized void connect(String hostname, int port, String password) throws IOException, IrcException, NickAlreadyInUseException {\n\n        _server = hostname;\n        _port = port;\n        _password = password;\n        \n        if (isConnected()) {\n            throw new IOException(\"The PircBot is already connected to an IRC server.  Disconnect first.\");\n        }\n        \n        // Don't clear the outqueue - there might be something important in it!\n        \n        // Clear everything we may have know about channels.\n        this.removeAllChannels();\n        \n        // Connect to the server.\n        \n        // XXX: PircBot Patch for SSL\n        Socket socket;\n        if (_useSSL) {\n        \ttry {\n        \t\tSSLContext context = SSLContext.getInstance(\"TLS\");\n        \t\tcontext.init(null, new X509TrustManager[] { new NaiveTrustManager() }, null);\n        \t\tSSLSocketFactory factory = context.getSocketFactory();\n        \t\tSSLSocket ssocket = (SSLSocket) factory.createSocket(hostname, port);\n        \t\tssocket.startHandshake();\n        \t\tsocket = ssocket;\n        \t}\n        \tcatch(Exception e)\n        \t{\n        \t\t// XXX: It's not really an IOException :)\n        \t\tthrow new IOException(\"Cannot open SSL socket\");\n        \t}\n        } else {\n        \tsocket =  new Socket(hostname, port);\n        }\n        \n        _inetAddress = socket.getLocalAddress();\n        \n        InputStreamReader inputStreamReader = null;\n        OutputStreamWriter outputStreamWriter = null;\n        if (getEncoding() != null) {\n            // Assume the specified encoding is valid for this JVM.\n            inputStreamReader = new InputStreamReader(socket.getInputStream(), getEncoding());\n            outputStreamWriter = new OutputStreamWriter(socket.getOutputStream(), getEncoding());\n        }\n        else {\n            // Otherwise, just use the JVM's default encoding.\n            inputStreamReader = new InputStreamReader(socket.getInputStream());\n            outputStreamWriter = new OutputStreamWriter(socket.getOutputStream());\n        }\n\n        BufferedReader breader = new BufferedReader(inputStreamReader);\n        BufferedWriter bwriter = new BufferedWriter(outputStreamWriter);\n        \n        // Attempt to join the server.\n        if (password != null && !password.equals(\"\")) {\n            OutputThread.sendRawLine(this, bwriter, \"PASS \" + password);\n        }\n        String nick = this.getName();\n        OutputThread.sendRawLine(this, bwriter, \"NICK \" + nick);\n        OutputThread.sendRawLine(this, bwriter, \"USER \" + this.getLogin() + \" 8 * :\" + this.getVersion());\n\n        _inputThread = new InputThread(this, socket, breader, bwriter);\n        \n        // Read stuff back from the server to see if we connected.\n        String line = null;\n        int tries = 1;\n        while ((line = breader.readLine()) != null) {\n            \n            this.handleLine(line);\n            \n            int firstSpace = line.indexOf(\" \");\n            int secondSpace = line.indexOf(\" \", firstSpace + 1);\n            if (secondSpace >= 0) {\n                String code = line.substring(firstSpace + 1, secondSpace);\n           \n                if (code.equals(\"004\")) {\n                    // We're connected to the server.\n                    break;\n                }\n                else if (code.equals(\"433\")) {\n                    if (_autoNickChange) {\n                        tries++;\n                        nick = getName() + tries;\n                        OutputThread.sendRawLine(this, bwriter, \"NICK \" + nick);\n                    }\n                    else {\n                        socket.close();\n                        _inputThread = null;\n                        throw new NickAlreadyInUseException(line);\n                    }\n                }\n                else if ((code.startsWith(\"5\") || code.startsWith(\"4\")) && !code.equals(\"439\")) {\n                    socket.close();\n                    _inputThread = null;\n                    throw new IrcException(\"Could not log into the IRC server: \" + line);\n                }\n            }\n            this.setNick(nick);\n            \n        }\n        \n        // This makes the socket timeout on read operations after 5 minutes.\n        // Maybe in some future version I will let the user change this at runtime.\n        socket.setSoTimeout(5 * 60 * 1000);\n        \n        // Now start the InputThread to read all other lines from the server.\n        _inputThread.start();\n        \n        // Now start the outputThread that will be used to send all messages.\n        if (_outputThread == null) {\n            _outputThread = new OutputThread(this, _outQueue);\n            _outputThread.start();\n        }\n        \n        this.onConnect();\n        \n    }\n    \n    \n    /**\n     * Reconnects to the IRC server that we were previously connected to.\n     * If necessary, the appropriate port number and password will be used.\n     * This method will throw an IrcException if we have never connected\n     * to an IRC server previously.\n     * \n     * @since PircBot 0.9.9\n     * \n     * @throws IOException if it was not possible to connect to the server.\n     * @throws IrcException if the server would not let us join it.\n     * @throws NickAlreadyInUseException if our nick is already in use on the server.\n     */\n    public final synchronized void reconnect() throws IOException, IrcException, NickAlreadyInUseException{\n        if (getServer() == null) {\n            throw new IrcException(\"Cannot reconnect to an IRC server because we were never connected to one previously!\");\n        }\n        connect(getServer(), getPort(), getPassword());\n    }\n    \n    \n    /**\n     * Set wether SSL should be used to connect to the server\n     * \n     * @author Sebastian Kaspari <sebastian@yaaic.org>\n     */\n    public void setUseSSL(boolean useSSL)\n    {\n    \t_useSSL = useSSL;\n    }\n\n\n    /**\n     * This method disconnects from the server cleanly by calling the\n     * quitServer() method.  Providing the PircBot was connected to an\n     * IRC server, the onDisconnect() will be called as soon as the\n     * disconnection is made by the server.\n     *\n     * @see #quitServer() quitServer\n     * @see #quitServer(String) quitServer\n     */\n    public final synchronized void disconnect() {\n        this.quitServer();\n    }\n    \n    \n    /**\n     * When you connect to a server and your nick is already in use and\n     * this is set to true, a new nick will be automatically chosen.\n     * This is done by adding numbers to the end of the nick until an\n     * available nick is found.\n     *\n     * @param autoNickChange Set to true if you want automatic nick changes\n     *                       during connection.\n     */\n    public void setAutoNickChange(boolean autoNickChange) {\n        _autoNickChange = autoNickChange;\n    }\n    \n    /**\n     * Joins a channel.\n     * \n     * @param channel The name of the channel to join (eg \"#cs\").\n     */\n    public final void joinChannel(String channel) {\n        this.sendRawLine(\"JOIN \" + channel);\n    }\n    \n    \n    /**\n     * Joins a channel with a key.\n     * \n     * @param channel The name of the channel to join (eg \"#cs\").\n     * @param key The key that will be used to join the channel.\n     */\n    public final void joinChannel(String channel, String key) {\n        this.joinChannel(channel + \" \" + key);\n    }\n    \n\n    /**\n     * Parts a channel.\n     *\n     * @param channel The name of the channel to leave.\n     */\n    public final void partChannel(String channel) {\n        this.sendRawLine(\"PART \" + channel);\n    }\n    \n    \n    /**\n     * Parts a channel, giving a reason.\n     *\n     * @param channel The name of the channel to leave.\n     * @param reason  The reason for parting the channel.\n     */\n    public final void partChannel(String channel, String reason) {\n        this.sendRawLine(\"PART \" + channel + \" :\" + reason);\n    }\n\n\n    /**\n     * Quits from the IRC server.\n     * Providing we are actually connected to an IRC server, the\n     * onDisconnect() method will be called as soon as the IRC server\n     * disconnects us.\n     */\n    public void quitServer() {\n        this.quitServer(\"\");\n    }\n    \n    \n    /**\n     * Quits from the IRC server with a reason.\n     * Providing we are actually connected to an IRC server, the\n     * onDisconnect() method will be called as soon as the IRC server\n     * disconnects us.\n     *\n     * @param reason The reason for quitting the server.\n     */\n    public final void quitServer(String reason) {\n        this.sendRawLine(\"QUIT :\" + reason);\n    }\n    \n    \n    /**\n     * Sends a raw line to the IRC server as soon as possible, bypassing the\n     * outgoing message queue.\n     *\n     * @param line The raw line to send to the IRC server.\n     */\n    public final synchronized void sendRawLine(String line) {\n        if (isConnected()) {\n            _inputThread.sendRawLine(line);\n        }\n    }\n    \n    /**\n     * Sends a raw line through the outgoing message queue.\n     * \n     * @param line The raw line to send to the IRC server.\n     */\n    public final synchronized void sendRawLineViaQueue(String line) {\n        if (line == null) {\n            throw new NullPointerException(\"Cannot send null messages to server\");\n        }\n        if (isConnected()) {\n            _outQueue.add(line);\n        }\n    }\n    \n    \n    /**\n     * Sends a message to a channel or a private message to a user.  These\n     * messages are added to the outgoing message queue and sent at the\n     * earliest possible opportunity.\n     *  <p>\n     * Some examples: -\n     *  <pre>    // Send the message \"Hello!\" to the channel #cs.\n     *    sendMessage(\"#cs\", \"Hello!\");\n     *    \n     *    // Send a private message to Paul that says \"Hi\".\n     *    sendMessage(\"Paul\", \"Hi\");<\/pre>\n     *  \n     * You may optionally apply colours, boldness, underlining, etc to\n     * the message by using the <code>Colors<\/code> class.\n     *\n     * @param target The name of the channel or user nick to send to.\n     * @param message The message to send.\n     * \n     * @see Colors\n     */\n    public final void sendMessage(String target, String message) {\n        _outQueue.add(\"PRIVMSG \" + target + \" :\" + message);\n    }\n    \n    \n    /**\n     * Sends an action to the channel or to a user.\n     *\n     * @param target The name of the channel or user nick to send to.\n     * @param action The action to send.\n     * \n     * @see Colors\n     */\n    public final void sendAction(String target, String action) {\n        sendCTCPCommand(target, \"ACTION \" + action);\n    }\n    \n    \n    /**\n     * Sends a notice to the channel or to a user.\n     *\n     * @param target The name of the channel or user nick to send to.\n     * @param notice The notice to send.\n     */\n    public final void sendNotice(String target, String notice) {\n        _outQueue.add(\"NOTICE \" + target + \" :\" + notice);\n    }\n    \n    \n    /**\n     * Sends a CTCP command to a channel or user.  (Client to client protocol).\n     * Examples of such commands are \"PING <number>\", \"FINGER\", \"VERSION\", etc.\n     * For example, if you wish to request the version of a user called \"Dave\",\n     * then you would call <code>sendCTCPCommand(\"Dave\", \"VERSION\");<\/code>.\n     * The type of response to such commands is largely dependant on the target\n     * client software.\n     * \n     * @since PircBot 0.9.5\n     *\n     * @param target The name of the channel or user to send the CTCP message to.\n     * @param command The CTCP command to send.\n     */\n    public final void sendCTCPCommand(String target, String command) {\n        _outQueue.add(\"PRIVMSG \" + target + \" :\\u0001\" + command + \"\\u0001\");\n    }\n    \n    \n    /**\n     * Attempt to change the current nick (nickname) of the bot when it\n     * is connected to an IRC server.\n     * After confirmation of a successful nick change, the getNick method\n     * will return the new nick.\n     *\n     * @param newNick The new nick to use.\n     */\n    public final void changeNick(String newNick) {\n        this.sendRawLine(\"NICK \" + newNick);\n    }\n    \n    \n    /**\n     * Identify the bot with NickServ, supplying the appropriate password.\n     * Some IRC Networks (such as freenode) require users to <i>register<\/i> and\n     * <i>identify<\/i> with NickServ before they are able to send private messages\n     * to other users, thus reducing the amount of spam.  If you are using\n     * an IRC network where this kind of policy is enforced, you will need\n     * to make your bot <i>identify<\/i> itself to NickServ before you can send\n     * private messages. Assuming you have already registered your bot's\n     * nick with NickServ, this method can be used to <i>identify<\/i> with\n     * the supplied password. It usually makes sense to identify with NickServ\n     * immediately after connecting to a server.\n     *  <p>\n     * This method issues a raw NICKSERV command to the server, and is therefore\n     * safer than the alternative approach of sending a private message to\n     * NickServ. The latter approach is considered dangerous, as it may cause\n     * you to inadvertently transmit your password to an untrusted party if you\n     * connect to a network which does not run a NickServ service and where the\n     * untrusted party has assumed the nick \"NickServ\".  However, if your IRC\n     * network is only compatible with the private message approach, you may\n     * typically identify like so:\n     * <pre>sendMessage(\"NickServ\", \"identify PASSWORD\");<\/pre>\n     * \n     * @param password The password which will be used to identify with NickServ.\n     */\n    public final void identify(String password) {\n        this.sendRawLine(\"NICKSERV IDENTIFY \" + password);\n    }                                        \n\n\n    /**\n     * Set the mode of a channel.\n     * This method attempts to set the mode of a channel.  This\n     * may require the bot to have operator status on the channel.\n     * For example, if the bot has operator status, we can grant\n     * operator status to \"Dave\" on the #cs channel\n     * by calling setMode(\"#cs\", \"+o Dave\");\n     * An alternative way of doing this would be to use the op method.\n     * \n     * @param channel The channel on which to perform the mode change.\n     * @param mode    The new mode to apply to the channel.  This may include\n     *                zero or more arguments if necessary.\n     * \n     * @see #op(String,String) op\n     */\n    public final void setMode(String channel, String mode) {\n        this.sendRawLine(\"MODE \" + channel + \" \" + mode);\n    }\n    \n    \n    /**\n     * Sends an invitation to join a channel.  Some channels can be marked\n     * as \"invite-only\", so it may be useful to allow a bot to invite people\n     * into it.\n     * \n     * @param nick    The nick of the user to invite\n     * @param channel The channel you are inviting the user to join.\n     * \n     */\n    public final void sendInvite(String nick, String channel) {\n        this.sendRawLine(\"INVITE \" + nick + \" :\" + channel);\n    }    \n\n\n    /**\n     * Bans a user from a channel.  An example of a valid hostmask is\n     * \"*!*compu@*.18hp.net\".  This may be used in conjunction with the\n     * kick method to permanently remove a user from a channel.\n     * Successful use of this method may require the bot to have operator\n     * status itself.\n     * \n     * @param channel The channel to ban the user from.\n     * @param hostmask A hostmask representing the user we're banning.\n     */\n    public final void ban(String channel, String hostmask) {\n        this.sendRawLine(\"MODE \" + channel + \" +b \" + hostmask);\n    }\n\n\n    /**\n     * Unbans a user from a channel.  An example of a valid hostmask is\n     * \"*!*compu@*.18hp.net\".\n     * Successful use of this method may require the bot to have operator\n     * status itself.\n     * \n     * @param channel The channel to unban the user from.\n     * @param hostmask A hostmask representing the user we're unbanning.\n     */\n    public final void unBan(String channel, String hostmask) {\n        this.sendRawLine(\"MODE \" + channel + \" -b \" + hostmask);\n    }\n\n\n    /**\n     * Grants operator privilidges to a user on a channel.\n     * Successful use of this method may require the bot to have operator\n     * status itself.\n     * \n     * @param channel The channel we're opping the user on.\n     * @param nick The nick of the user we are opping.\n     */\n    public final void op(String channel, String nick) {\n        this.setMode(channel, \"+o \" + nick);\n    }\n\n\n    /**\n     * Removes operator privilidges from a user on a channel.\n     * Successful use of this method may require the bot to have operator\n     * status itself.\n     * \n     * @param channel The channel we're deopping the user on.\n     * @param nick The nick of the user we are deopping.\n     */\n    public final void deOp(String channel, String nick) {\n        this.setMode(channel, \"-o \" + nick);\n    }\n    \n    \n    /**\n     * Grants voice privilidges to a user on a channel.\n     * Successful use of this method may require the bot to have operator\n     * status itself.\n     * \n     * @param channel The channel we're voicing the user on.\n     * @param nick The nick of the user we are voicing.\n     */\n    public final void voice(String channel, String nick) {\n        this.setMode(channel, \"+v \" + nick);\n    }\n\n\n    /**\n     * Removes voice privilidges from a user on a channel.\n     * Successful use of this method may require the bot to have operator\n     * status itself.\n     * \n     * @param channel The channel we're devoicing the user on.\n     * @param nick The nick of the user we are devoicing.\n     */\n    public final void deVoice(String channel, String nick) {\n        this.setMode(channel, \"-v \" + nick);\n    }\n\n\n    /**\n     * Set the topic for a channel.\n     * This method attempts to set the topic of a channel.  This\n     * may require the bot to have operator status if the topic\n     * is protected.\n     * \n     * @param channel The channel on which to perform the mode change.\n     * @param topic   The new topic for the channel.\n     * \n     */\n    public final void setTopic(String channel, String topic) {\n        this.sendRawLine(\"TOPIC \" + channel + \" :\" + topic);\n    }\n\n\n    /**\n     * Kicks a user from a channel.\n     * This method attempts to kick a user from a channel and\n     * may require the bot to have operator status in the channel.\n     * \n     * @param channel The channel to kick the user from.\n     * @param nick    The nick of the user to kick.\n     */\n    public final void kick(String channel, String nick) {\n        this.kick(channel, nick, \"\");\n    }\n\n\n    /**\n     * Kicks a user from a channel, giving a reason.\n     * This method attempts to kick a user from a channel and\n     * may require the bot to have operator status in the channel.\n     * \n     * @param channel The channel to kick the user from.\n     * @param nick    The nick of the user to kick.\n     * @param reason  A description of the reason for kicking a user.\n     */\n    public final void kick(String channel, String nick, String reason) {\n        this.sendRawLine(\"KICK \" + channel + \" \" + nick + \" :\" + reason);\n    }\n    \n    \n    /**\n     * Issues a request for a list of all channels on the IRC server.\n     * When the PircBot receives information for each channel, it will\n     * call the onChannelInfo method, which you will need to override\n     * if you want it to do anything useful.\n     * \n     * @see #onChannelInfo(String,int,String) onChannelInfo\n     */\n    public final void listChannels() {\n        this.listChannels(null);\n    }\n    \n    \n    /**\n     * Issues a request for a list of all channels on the IRC server.\n     * When the PircBot receives information for each channel, it will\n     * call the onChannelInfo method, which you will need to override\n     * if you want it to do anything useful.\n     *  <p>\n     * Some IRC servers support certain parameters for LIST requests.\n     * One example is a parameter of \">10\" to list only those channels\n     * that have more than 10 users in them.  Whether these parameters\n     * are supported or not will depend on the IRC server software.\n     * \n     * @param parameters The parameters to supply when requesting the\n     *                   list.\n     * \n     * @see #onChannelInfo(String,int,String) onChannelInfo\n     */\n    public final void listChannels(String parameters) {\n        if (parameters == null) {\n            this.sendRawLine(\"LIST\");\n        }\n        else {\n            this.sendRawLine(\"LIST \" + parameters);\n        }\n    }\n    \n    \n    /**\n     * Sends a file to another user.  Resuming is supported.\n     * The other user must be able to connect directly to your bot to be\n     * able to receive the file.\n     *  <p>\n     * You may throttle the speed of this file transfer by calling the\n     * setPacketDelay method on the DccFileTransfer that is returned.\n     *  <p>\n     * This method may not be overridden.\n     * \n     * @since 0.9c\n     * \n     * @param file The file to send.\n     * @param nick The user to whom the file is to be sent.\n     * @param timeout The number of milliseconds to wait for the recipient to\n     *                acccept the file (we recommend about 120000).\n     * \n     * @return The DccFileTransfer that can be used to monitor this transfer.\n     * \n     * @see DccFileTransfer\n     * \n     */\n    public final DccFileTransfer dccSendFile(File file, String nick, int timeout) {\n        DccFileTransfer transfer = new DccFileTransfer(this, _dccManager, file, nick, timeout);\n        transfer.doSend(true);\n        return transfer;\n    }\n    \n    \n    /**\n     * Receives a file that is being sent to us by a DCC SEND request.\n     * Please use the onIncomingFileTransfer method to receive files.\n     * \n     * @deprecated As of PircBot 1.2.0, use {@link #onIncomingFileTransfer(DccFileTransfer)}\n     */\n    protected final void dccReceiveFile(File file, long address, int port, int size) {\n        throw new RuntimeException(\"dccReceiveFile is deprecated, please use sendFile\");\n    }\n    \n    \n    /**\n     * Attempts to establish a DCC CHAT session with a client.  This method\n     * issues the connection request to the client and then waits for the\n     * client to respond.  If the connection is successfully made, then a\n     * DccChat object is returned by this method.  If the connection is not\n     * made within the time limit specified by the timeout value, then null\n     * is returned.\n     *  <p>\n     * It is <b>strongly recommended<\/b> that you call this method within a new\n     * Thread, as it may take a long time to return.\n     *  <p>\n     * This method may not be overridden.\n     * \n     * @since PircBot 0.9.8\n     *\n     * @param nick The nick of the user we are trying to establish a chat with.\n     * @param timeout The number of milliseconds to wait for the recipient to\n     *                accept the chat connection (we recommend about 120000).\n     * \n     * @return a DccChat object that can be used to send and recieve lines of\n     *         text.  Returns <b>null<\/b> if the connection could not be made.\n     * \n     * @see DccChat\n     */\n    public final DccChat dccSendChatRequest(String nick, int timeout) {\n        DccChat chat = null;\n        try {\n            ServerSocket ss = null;\n            \n            int[] ports = getDccPorts();\n            if (ports == null) {\n                // Use any free port.\n                ss = new ServerSocket(0);\n            }\n            else {\n                for (int i = 0; i < ports.length; i++) {\n                    try {\n                        ss = new ServerSocket(ports[i]);\n                        // Found a port number we could use.\n                        break;\n                    }\n                    catch (Exception e) {\n                        // Do nothing; go round and try another port.\n                    }\n                }\n                if (ss == null) {\n                    // No ports could be used.\n                    throw new IOException(\"All ports returned by getDccPorts() are in use.\");\n                }\n            }\n            \n            ss.setSoTimeout(timeout);\n            int port = ss.getLocalPort();\n            \n            InetAddress inetAddress = getDccInetAddress();\n            if (inetAddress == null) {\n                inetAddress = getInetAddress();\n            }\n            byte[] ip = inetAddress.getAddress();\n            long ipNum = ipToLong(ip);\n            \n            sendCTCPCommand(nick, \"DCC CHAT chat \" + ipNum + \" \" + port);\n            \n            // The client may now connect to us to chat.\n            Socket socket = ss.accept();\n            \n            // Close the server socket now that we've finished with it.\n            ss.close();\n            \n            chat = new DccChat(this, nick, socket);\n        }\n        catch (Exception e) {\n            // Do nothing.\n        }\n        return chat;\n    }\n\n    \n    /**\n     * Attempts to accept a DCC CHAT request by a client.\n     * Please use the onIncomingChatRequest method to receive files.\n     * \n     * @deprecated As of PircBot 1.2.0, use {@link #onIncomingChatRequest(DccChat)}\n     */\n    protected final DccChat dccAcceptChatRequest(String sourceNick, long address, int port) {\n        throw new RuntimeException(\"dccAcceptChatRequest is deprecated, please use onIncomingChatRequest\");\n    }\n\n    /**\n     * This method handles events when any line of text arrives from the server,\n     * then calling the appropriate method in the PircBot.  This method is\n     * protected and only called by the InputThread for this instance.\n     *  <p>\n     * This method may not be overridden!\n     * \n     * @param line The raw line of text from the server.\n     */\n    protected void handleLine(String line) {\n        // Check for server pings.\n        if (line.startsWith(\"PING \")) {\n            // Respond to the ping and return immediately.\n            this.onServerPing(line.substring(5));\n            return;\n        }\n\n        String sourceNick = \"\";\n        String sourceLogin = \"\";\n        String sourceHostname = \"\";\n\n        StringTokenizer tokenizer = new StringTokenizer(line);\n        String senderInfo = tokenizer.nextToken();\n        String command = tokenizer.nextToken();\n        String target = null;\n\n        int exclamation = senderInfo.indexOf(\"!\");\n        int at = senderInfo.indexOf(\"@\");\n        if (senderInfo.startsWith(\":\")) {\n            if (exclamation > 0 && at > 0 && exclamation < at) {\n                sourceNick = senderInfo.substring(1, exclamation);\n                sourceLogin = senderInfo.substring(exclamation + 1, at);\n                sourceHostname = senderInfo.substring(at + 1);\n            }\n            else {\n                \n                if (tokenizer.hasMoreTokens()) {\n                    String token = command;\n\n                    int code = -1;\n                    try {\n                        code = Integer.parseInt(token);\n                    }\n                    catch (NumberFormatException e) {\n                        // Keep the existing value.\n                    }\n                    \n                    if (code != -1) {\n                        String errorStr = token;\n                        String response = line.substring(line.indexOf(errorStr, senderInfo.length()) + 4, line.length());\n                        this.processServerResponse(code, response);\n                        // Return from the method.\n                        return;\n                    }\n                    else {\n                        // This is not a server response.\n                        // It must be a nick without login and hostname.\n                        // (or maybe a NOTICE or suchlike from the server)\n                        sourceNick = senderInfo;\n                        target = token;\n                    }\n                }\n                else {\n                    // We don't know what this line means.\n                    this.onUnknown(line);\n                    // Return from the method;\n                    return;\n                }\n                \n            }\n        }\n        \n        command = command.toUpperCase();\n        if (sourceNick.startsWith(\":\")) {\n            sourceNick = sourceNick.substring(1);\n        }\n        if (target == null) {\n            target = tokenizer.nextToken();\n        }\n        if (target.startsWith(\":\")) {\n            target = target.substring(1);\n        }\n\n        // Check for CTCP requests.\n        if (command.equals(\"PRIVMSG\") && line.indexOf(\":\\u0001\") > 0 && line.endsWith(\"\\u0001\")) {\n            String request = line.substring(line.indexOf(\":\\u0001\") + 2, line.length() - 1);\n            if (request.equals(\"VERSION\")) {\n                // VERSION request\n                this.onVersion(sourceNick, sourceLogin, sourceHostname, target);\n            }\n            else if (request.startsWith(\"ACTION \")) {\n                // ACTION request\n                this.onAction(sourceNick, sourceLogin, sourceHostname, target, request.substring(7));\n            }\n            else if (request.startsWith(\"PING \")) {\n                // PING request\n                this.onPing(sourceNick, sourceLogin, sourceHostname, target, request.substring(5));\n            }\n            else if (request.equals(\"TIME\")) {\n                // TIME request\n                this.onTime(sourceNick, sourceLogin, sourceHostname, target);\n            }\n            else if (request.equals(\"FINGER\")) {\n                // FINGER request\n                this.onFinger(sourceNick, sourceLogin, sourceHostname, target);\n            }\n            else if ((tokenizer = new StringTokenizer(request)).countTokens() >= 5 && tokenizer.nextToken().equals(\"DCC\")) {\n                // This is a DCC request.\n                boolean success = _dccManager.processRequest(sourceNick, sourceLogin, sourceHostname, request);\n                if (!success) {\n                    // The DccManager didn't know what to do with the line.\n                    this.onUnknown(line);\n                }\n            }\n            else {            \n                // An unknown CTCP message - ignore it.\n                this.onUnknown(line);\n            }\n        }\n        else if (command.equals(\"PRIVMSG\") && _channelPrefixes.indexOf(target.charAt(0)) >= 0) {\n            // This is a normal message to a channel.\n            this.onMessage(target, sourceNick, sourceLogin, sourceHostname, line.substring(line.indexOf(\" :\") + 2));\n        }\n        else if (command.equals(\"PRIVMSG\")) {\n            // This is a private message to us.\n            this.onPrivateMessage(sourceNick, sourceLogin, sourceHostname, line.substring(line.indexOf(\" :\") + 2));\n        }\n        else if (command.equals(\"JOIN\")) {\n            // Someone is joining a channel.\n            String channel = target;\n            this.addUser(channel, new User(\"\", sourceNick));\n            this.onJoin(channel, sourceNick, sourceLogin, sourceHostname);\n        }\n        else if (command.equals(\"PART\")) {\n            // Someone is parting from a channel.\n            this.removeUser(target, sourceNick);\n            if (sourceNick.equals(this.getNick())) {\n                this.removeChannel(target);\n            }\n            this.onPart(target, sourceNick, sourceLogin, sourceHostname);\n        }\n        else if (command.equals(\"NICK\")) {\n            // Somebody is changing their nick.\n            String newNick = target;\n            this.renameUser(sourceNick, newNick);\n            if (sourceNick.equals(this.getNick())) {\n                // Update our nick if it was us that changed nick.\n                this.setNick(newNick);\n            }\n            this.onNickChange(sourceNick, sourceLogin, sourceHostname, newNick);\n        }\n        else if (command.equals(\"NOTICE\")) {\n            // Someone is sending a notice.\n            this.onNotice(sourceNick, sourceLogin, sourceHostname, target, line.substring(line.indexOf(\" :\") + 2));\n        }\n        else if (command.equals(\"QUIT\")) {\n            // Someone has quit from the IRC server.\n        \t\n        \t// XXX: Pircbot Patch - Call onQuit before removing the user. This way we\n        \t//\t\t\t\t\t\tare able to know which channels the user was on.\n        \tthis.onQuit(sourceNick, sourceLogin, sourceHostname, line.substring(line.indexOf(\" :\") + 2));\n        \t\n            if (sourceNick.equals(this.getNick())) {\n                this.removeAllChannels();\n            }\n            else {\n                this.removeUser(sourceNick);\n            }\n        }\n        else if (command.equals(\"KICK\")) {\n            // Somebody has been kicked from a channel.\n            String recipient = tokenizer.nextToken();\n            if (recipient.equals(this.getNick())) {\n                this.removeChannel(target);\n            }\n            this.removeUser(target, recipient);\n            this.onKick(target, sourceNick, sourceLogin, sourceHostname, recipient, line.substring(line.indexOf(\" :\") + 2));\n        }\n        else if (command.equals(\"MODE\")) {\n            // Somebody is changing the mode on a channel or user.\n            String mode = line.substring(line.indexOf(target, 2) + target.length() + 1);\n            if (mode.startsWith(\":\")) {\n                mode = mode.substring(1);\n            }\n            this.processMode(target, sourceNick, sourceLogin, sourceHostname, mode);\n        }\n        else if (command.equals(\"TOPIC\")) {\n            // Someone is changing the topic.\n            this.onTopic(target, line.substring(line.indexOf(\" :\") + 2), sourceNick, System.currentTimeMillis(), true);\n        }\n        else if (command.equals(\"INVITE\")) {\n            // Somebody is inviting somebody else into a channel.\n            this.onInvite(target, sourceNick, sourceLogin, sourceHostname, line.substring(line.indexOf(\" :\") + 2));\n        }\n        else {\n            // If we reach this point, then we've found something that the PircBot\n            // Doesn't currently deal with.\n            this.onUnknown(line);\n        }\n        \n    }\n    \n    \n    /**\n     * This method is called once the PircBot has successfully connected to\n     * the IRC server.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @since PircBot 0.9.6\n     */\n    protected void onConnect() {}\n    \n    \n    /**\n     * This method carries out the actions to be performed when the PircBot\n     * gets disconnected.  This may happen if the PircBot quits from the\n     * server, or if the connection is unexpectedly lost.\n     *  <p>\n     * Disconnection from the IRC server is detected immediately if either\n     * we or the server close the connection normally. If the connection to\n     * the server is lost, but neither we nor the server have explicitly closed\n     * the connection, then it may take a few minutes to detect (this is\n     * commonly referred to as a \"ping timeout\").\n     *  <p>\n     * If you wish to get your IRC bot to automatically rejoin a server after\n     * the connection has been lost, then this is probably the ideal method to\n     * override to implement such functionality.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     */\n    protected void onDisconnect() {}\n    \n    \n    /**\n     * This method is called by the PircBot when a numeric response\n     * is received from the IRC server.  We use this method to\n     * allow PircBot to process various responses from the server\n     * before then passing them on to the onServerResponse method.\n     *  <p>\n     * Note that this method is private and should not appear in any\n     * of the javadoc generated documenation.\n     * \n     * @param code The three-digit numerical code for the response.\n     * @param response The full response from the IRC server.\n     */\n    private final void processServerResponse(int code, String response) {\n        \n        if (code == RPL_LIST) {\n            // This is a bit of information about a channel.\n            int firstSpace = response.indexOf(' ');\n            int secondSpace = response.indexOf(' ', firstSpace + 1);\n            int thirdSpace = response.indexOf(' ', secondSpace + 1);\n            int colon = response.indexOf(':');\n            String channel = response.substring(firstSpace + 1, secondSpace);\n            int userCount = 0;\n            try {\n                userCount = Integer.parseInt(response.substring(secondSpace + 1, thirdSpace));\n            }\n            catch (NumberFormatException e) {\n                // Stick with the value of zero.\n            }\n            String topic = response.substring(colon + 1);\n            this.onChannelInfo(channel, userCount, topic);\n        }\n        else if (code == RPL_TOPIC) {\n            // This is topic information about a channel we've just joined.\n            int firstSpace = response.indexOf(' ');\n            int secondSpace = response.indexOf(' ', firstSpace + 1);\n            int colon = response.indexOf(':');\n            String channel = response.substring(firstSpace + 1, secondSpace);\n            String topic = response.substring(colon + 1);\n            \n            _topics.put(channel, topic);\n            \n            // For backwards compatibility only - this onTopic method is deprecated.\n            this.onTopic(channel, topic);\n        }\n        else if (code == RPL_TOPICINFO) {\n            StringTokenizer tokenizer = new StringTokenizer(response);\n            tokenizer.nextToken();\n            String channel = tokenizer.nextToken();\n            String setBy = tokenizer.nextToken();\n            long date = 0;\n            try {\n                date = Long.parseLong(tokenizer.nextToken()) * 1000;\n            }\n            catch (NumberFormatException e) {\n                // Stick with the default value of zero.\n            }\n            \n            String topic = (String) _topics.get(channel);\n            _topics.remove(channel);\n            \n            this.onTopic(channel, topic, setBy, date, false);\n        }\n        else if (code == RPL_NAMREPLY) {\n            // This is a list of nicks in a channel that we've just joined.\n            int channelEndIndex = response.indexOf(\" :\");\n            String channel = response.substring(response.lastIndexOf(' ', channelEndIndex - 1) + 1, channelEndIndex);\n            \n            StringTokenizer tokenizer = new StringTokenizer(response.substring(response.indexOf(\" :\") + 2));\n            while (tokenizer.hasMoreTokens()) {\n                String nick = tokenizer.nextToken();\n                String prefix = \"\";\n                if (nick.startsWith(\"@\")) {\n                    // User is an operator in this channel.\n                    prefix = \"@\";\n                }\n                else if (nick.startsWith(\"+\")) {\n                    // User is voiced in this channel.\n                    prefix = \"+\";\n                }\n                else if (nick.startsWith(\".\")) {\n                    // Some wibbly status I've never seen before...\n                    prefix = \".\";\n                }\n                nick = nick.substring(prefix.length());\n                this.addUser(channel, new User(prefix, nick));\n            }\n        }\n        else if (code == RPL_ENDOFNAMES) {\n            // This is the end of a NAMES list, so we know that we've got\n            // the full list of users in the channel that we just joined. \n            String channel = response.substring(response.indexOf(' ') + 1, response.indexOf(\" :\"));\n            User[] users = this.getUsers(channel);\n            this.onUserList(channel, users);\n        }\n        \n        this.onServerResponse(code, response);\n    }\n\n\n    /**\n     * This method is called when we receive a numeric response from the\n     * IRC server.\n     *  <p> \n     * Numerics in the range from 001 to 099 are used for client-server\n     * connections only and should never travel between servers.  Replies\n     * generated in response to commands are found in the range from 200\n     * to 399.  Error replies are found in the range from 400 to 599.\n     *  <p>\n     * For example, we can use this method to discover the topic of a\n     * channel when we join it.  If we join the channel #test which\n     * has a topic of &quot;I am King of Test&quot; then the response\n     * will be &quot;<code>PircBot #test :I Am King of Test<\/code>&quot;\n     * with a code of 332 to signify that this is a topic.\n     * (This is just an example - note that overriding the\n     * <code>onTopic<\/code> method is an easier way of finding the\n     * topic for a channel). Check the IRC RFC for the full list of other\n     * command response codes.\n     *  <p>\n     * PircBot implements the interface ReplyConstants, which contains\n     * contstants that you may find useful here.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @param code The three-digit numerical code for the response.\n     * @param response The full response from the IRC server.\n     * \n     * @see ReplyConstants\n     */\n    protected void onServerResponse(int code, String response) {}\n    \n    \n    /**\n     * This method is called when we receive a user list from the server\n     * after joining a channel.\n     *  <p>\n     * Shortly after joining a channel, the IRC server sends a list of all\n     * users in that channel. The PircBot collects this information and\n     * calls this method as soon as it has the full list.\n     *  <p>\n     * To obtain the nick of each user in the channel, call the getNick()\n     * method on each User object in the array.\n     *  <p>\n     * At a later time, you may call the getUsers method to obtain an\n     * up to date list of the users in the channel.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @since PircBot 1.0.0\n     * \n     * @param channel The name of the channel.\n     * @param users An array of User objects belonging to this channel.\n     * \n     * @see User\n     */\n    protected void onUserList(String channel, User[] users) {}\n    \n    \n    /**\n     * This method is called whenever a message is sent to a channel.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     *\n     * @param channel The channel to which the message was sent.\n     * @param sender The nick of the person who sent the message.\n     * @param login The login of the person who sent the message.\n     * @param hostname The hostname of the person who sent the message.\n     * @param message The actual message sent to the channel.\n     */\n    protected void onMessage(String channel, String sender, String login, String hostname, String message) {}\n\n\n    /**\n     * This method is called whenever a private message is sent to the PircBot.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     *\n     * @param sender The nick of the person who sent the private message.\n     * @param login The login of the person who sent the private message.\n     * @param hostname The hostname of the person who sent the private message.\n     * @param message The actual message.\n     */\n    protected void onPrivateMessage(String sender, String login, String hostname, String message) {}\n    \n    \n    /**\n     * This method is called whenever an ACTION is sent from a user.  E.g.\n     * such events generated by typing \"/me goes shopping\" in most IRC clients.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @param sender The nick of the user that sent the action.\n     * @param login The login of the user that sent the action.\n     * @param hostname The hostname of the user that sent the action.\n     * @param target The target of the action, be it a channel or our nick.\n     * @param action The action carried out by the user.\n     */\n    protected void onAction(String sender, String login, String hostname, String target, String action) {}\n    \n    \n    /**\n     * This method is called whenever we receive a notice.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @param sourceNick The nick of the user that sent the notice.\n     * @param sourceLogin The login of the user that sent the notice.\n     * @param sourceHostname The hostname of the user that sent the notice.\n     * @param target The target of the notice, be it our nick or a channel name.\n     * @param notice The notice message.\n     */\n    protected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice) {}\n    \n    \n    /**\n     * This method is called whenever someone (possibly us) joins a channel\n     * which we are on.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     *\n     * @param channel The channel which somebody joined.\n     * @param sender The nick of the user who joined the channel.\n     * @param login The login of the user who joined the channel.\n     * @param hostname The hostname of the user who joined the channel.\n     */\n    protected void onJoin(String channel, String sender, String login, String hostname) {}\n    \n    \n    /**\n     * This method is called whenever someone (possibly us) parts a channel\n     * which we are on.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     *\n     * @param channel The channel which somebody parted from.\n     * @param sender The nick of the user who parted from the channel.\n     * @param login The login of the user who parted from the channel.\n     * @param hostname The hostname of the user who parted from the channel.\n     */\n    protected void onPart(String channel, String sender, String login, String hostname) {}\n\n\n    /**\n     * This method is called whenever someone (possibly us) changes nick on any\n     * of the channels that we are on.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     *\n     * @param oldNick The old nick.\n     * @param login The login of the user.\n     * @param hostname The hostname of the user.\n     * @param newNick The new nick.\n     */\n    protected void onNickChange(String oldNick, String login, String hostname, String newNick) {}\n    \n    \n    /**\n     * This method is called whenever someone (possibly us) is kicked from\n     * any of the channels that we are in.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @param channel The channel from which the recipient was kicked.\n     * @param kickerNick The nick of the user who performed the kick.\n     * @param kickerLogin The login of the user who performed the kick.\n     * @param kickerHostname The hostname of the user who performed the kick.\n     * @param recipientNick The unfortunate recipient of the kick.\n     * @param reason The reason given by the user who performed the kick.\n     */\n    protected void onKick(String channel, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason) {}\n    \n    \n    /**\n     * This method is called whenever someone (possibly us) quits from the\n     * server.  We will only observe this if the user was in one of the\n     * channels to which we are connected.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @param sourceNick The nick of the user that quit from the server.\n     * @param sourceLogin The login of the user that quit from the server.\n     * @param sourceHostname The hostname of the user that quit from the server.\n     * @param reason The reason given for quitting the server.\n     */\n    protected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason) {}\n    \n    \n    /**\n     * This method is called whenever a user sets the topic, or when\n     * PircBot joins a new channel and discovers its topic.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     *\n     * @param channel The channel that the topic belongs to.\n     * @param topic The topic for the channel.\n     * \n     * @deprecated As of 1.2.0, replaced by {@link #onTopic(String,String,String,long,boolean)}\n     */\n    protected void onTopic(String channel, String topic) {}\n    \n\n    /**\n     * This method is called whenever a user sets the topic, or when\n     * PircBot joins a new channel and discovers its topic.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     *\n     * @param channel The channel that the topic belongs to.\n     * @param topic The topic for the channel.\n     * @param setBy The nick of the user that set the topic.\n     * @param date When the topic was set (milliseconds since the epoch).\n     * @param changed True if the topic has just been changed, false if\n     *                the topic was already there.\n     * \n     */\n    protected void onTopic(String channel, String topic, String setBy, long date, boolean changed) {}\n    \n    \n    /**\n     * After calling the listChannels() method in PircBot, the server\n     * will start to send us information about each channel on the\n     * server.  You may override this method in order to receive the\n     * information about each channel as soon as it is received.\n     *  <p>\n     * Note that certain channels, such as those marked as hidden,\n     * may not appear in channel listings.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @param channel The name of the channel.\n     * @param userCount The number of users visible in this channel.\n     * @param topic The topic for this channel.\n     * \n     * @see #listChannels() listChannels\n     */\n    protected void onChannelInfo(String channel, int userCount, String topic) {}\n      \n    \n    /**\n     * Called when the mode of a channel is set.  We process this in\n     * order to call the appropriate onOp, onDeop, etc method before\n     * finally calling the override-able onMode method.\n     *  <p>\n     * Note that this method is private and is not intended to appear\n     * in the javadoc generated documentation.\n     *\n     * @param target The channel or nick that the mode operation applies to.\n     * @param sourceNick The nick of the user that set the mode.\n     * @param sourceLogin The login of the user that set the mode.\n     * @param sourceHostname The hostname of the user that set the mode.\n     * @param mode  The mode that has been set.\n     */\n    private final void processMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode) {\n        \n        if (_channelPrefixes.indexOf(target.charAt(0)) >= 0) {\n            // The mode of a channel is being changed.\n            String channel = target;\n            StringTokenizer tok = new StringTokenizer(mode);\n            String[] params = new String[tok.countTokens()];\n     \n            int t = 0;\n            while (tok.hasMoreTokens()) {\n                params[t] = tok.nextToken();\n                t++;\n            }\n            \n            char pn = ' ';\n            int p = 1;\n     \n            // All of this is very large and ugly, but it's the only way of providing\n            // what the users want :-/\n            for (int i = 0; i < params[0].length(); i++) {\n                char atPos = params[0].charAt(i);\n     \n                if (atPos == '+' || atPos == '-') {\n                    pn = atPos;\n                }\n                else if (atPos == 'o') {\n                   if (pn == '+') {\n                       this.updateUser(channel, OP_ADD, params[p]);\n                       onOp(channel, sourceNick, sourceLogin, sourceHostname, params[p]);\n                   }\n                   else {\n                       this.updateUser(channel, OP_REMOVE, params[p]);\n                       onDeop(channel, sourceNick, sourceLogin, sourceHostname, params[p]);\n                   }\n                   p++;\n               }\n               else if (atPos == 'v') {\n                   if (pn == '+') {\n                       this.updateUser(channel, VOICE_ADD, params[p]);\n                       onVoice(channel, sourceNick, sourceLogin, sourceHostname, params[p]);\n                   }\n                   else {\n                       this.updateUser(channel, VOICE_REMOVE, params[p]);\n                       onDeVoice(channel, sourceNick, sourceLogin, sourceHostname, params[p]);\n                   }\n                   p++; \n                }\n                else if (atPos == 'k') {\n                    if (pn == '+') {\n                        onSetChannelKey(channel, sourceNick, sourceLogin, sourceHostname, params[p]);\n                    }\n                    else {\n                        onRemoveChannelKey(channel, sourceNick, sourceLogin, sourceHostname, params[p]);\n                    }\n                    p++;\n                }\n                else if (atPos == 'l') {\n                    if (pn == '+') {\n                        onSetChannelLimit(channel, sourceNick, sourceLogin, sourceHostname, Integer.parseInt(params[p]));\n                        p++;\n                    }\n                    else {\n                        onRemoveChannelLimit(channel, sourceNick, sourceLogin, sourceHostname);\n                    }\n                }\n                else if (atPos == 'b') {\n                    if (pn == '+') {\n                        onSetChannelBan(channel, sourceNick, sourceLogin, sourceHostname,params[p]);\n                    }\n                    else {\n                        onRemoveChannelBan(channel, sourceNick, sourceLogin, sourceHostname, params[p]);\n                    }\n                    p++;\n                }\n                else if (atPos == 't') {\n                    if (pn == '+') {\n                        onSetTopicProtection(channel, sourceNick, sourceLogin, sourceHostname);\n                    }\n                    else {\n                        onRemoveTopicProtection(channel, sourceNick, sourceLogin, sourceHostname);\n                    }\n                }\n                else if (atPos == 'n') {\n                    if (pn == '+') {\n                        onSetNoExternalMessages(channel, sourceNick, sourceLogin, sourceHostname);\n                    }\n                    else {\n                        onRemoveNoExternalMessages(channel, sourceNick, sourceLogin, sourceHostname);\n                    }\n                }\n                else if (atPos == 'i') {\n                    if (pn == '+') {\n                        onSetInviteOnly(channel, sourceNick, sourceLogin, sourceHostname);\n                    }\n                    else {\n                        onRemoveInviteOnly(channel, sourceNick, sourceLogin, sourceHostname);\n                    }\n                }\n                else if (atPos == 'm') {\n                    if (pn == '+') {\n                        onSetModerated(channel, sourceNick, sourceLogin, sourceHostname);\n                    }\n                    else {\n                        onRemoveModerated(channel, sourceNick, sourceLogin, sourceHostname);\n                    }\n                }\n                else if (atPos == 'p') {\n                    if (pn == '+') {\n                        onSetPrivate(channel, sourceNick, sourceLogin, sourceHostname);\n                    }\n                    else {\n                        onRemovePrivate(channel, sourceNick, sourceLogin, sourceHostname);\n                    }\n                }\n                else if (atPos == 's') {\n                    if (pn == '+') {\n                        onSetSecret(channel, sourceNick, sourceLogin, sourceHostname);\n                    }\n                    else {\n                        onRemoveSecret(channel, sourceNick, sourceLogin, sourceHostname);\n                    }\n                }\n            }\n        \n            this.onMode(channel, sourceNick, sourceLogin, sourceHostname, mode);\n        }\n        else {\n            // The mode of a user is being changed.\n            String nick = target;\n            this.onUserMode(nick, sourceNick, sourceLogin, sourceHostname, mode);\n        }\n    }\n    \n    \n    /**\n     * Called when the mode of a channel is set.\n     *  <p>\n     * You may find it more convenient to decode the meaning of the mode\n     * string by overriding the onOp, onDeOp, onVoice, onDeVoice,\n     * onChannelKey, onDeChannelKey, onChannelLimit, onDeChannelLimit,\n     * onChannelBan or onDeChannelBan methods as appropriate.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     *\n     * @param channel The channel that the mode operation applies to.\n     * @param sourceNick The nick of the user that set the mode.\n     * @param sourceLogin The login of the user that set the mode.\n     * @param sourceHostname The hostname of the user that set the mode.\n     * @param mode The mode that has been set.\n     * \n     */\n    protected void onMode(String channel, String sourceNick, String sourceLogin, String sourceHostname, String mode) {}\n\n    \n    /**\n     * Called when the mode of a user is set.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @since PircBot 1.2.0\n     * \n     * @param targetNick The nick that the mode operation applies to.\n     * @param sourceNick The nick of the user that set the mode.\n     * @param sourceLogin The login of the user that set the mode.\n     * @param sourceHostname The hostname of the user that set the mode.\n     * @param mode The mode that has been set.\n     * \n     */\n    protected void onUserMode(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String mode) {}\n    \n    \n    \n    /**\n     * Called when a user (possibly us) gets granted operator status for a channel.\n     *  <p>\n     * This is a type of mode change and is also passed to the onMode\n     * method in the PircBot class.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @since PircBot 0.9.5\n     *\n     * @param channel The channel in which the mode change took place.\n     * @param sourceNick The nick of the user that performed the mode change.\n     * @param sourceLogin The login of the user that performed the mode change.\n     * @param sourceHostname The hostname of the user that performed the mode change.\n     * @param recipient The nick of the user that got 'opped'.\n     */\n    protected void onOp(String channel, String sourceNick, String sourceLogin, String sourceHostname, String recipient) {}\n\n\n    /**\n     * Called when a user (possibly us) gets operator status taken away.\n     *  <p>\n     * This is a type of mode change and is also passed to the onMode\n     * method in the PircBot class.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @since PircBot 0.9.5\n     *\n     * @param channel The channel in which the mode change took place.\n     * @param sourceNick The nick of the user that performed the mode change.\n     * @param sourceLogin The login of the user that performed the mode change.\n     * @param sourceHostname The hostname of the user that performed the mode change.\n     * @param recipient The nick of the user that got 'deopped'.\n     */\n    protected void onDeop(String channel, String sourceNick, String sourceLogin, String sourceHostname, String recipient) {}\n\n\n    /**\n     * Called when a user (possibly us) gets voice status granted in a channel.\n     *  <p>\n     * This is a type of mode change and is also passed to the onMode\n     * method in the PircBot class.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @since PircBot 0.9.5\n     *\n     * @param channel The channel in which the mode change took place.\n     * @param sourceNick The nick of the user that performed the mode change.\n     * @param sourceLogin The login of the user that performed the mode change.\n     * @param sourceHostname The hostname of the user that performed the mode change.\n     * @param recipient The nick of the user that got 'voiced'.\n     */\n    protected void onVoice(String channel, String sourceNick, String sourceLogin, String sourceHostname, String recipient) {}\n\n\n    /**\n     * Called when a user (possibly us) gets voice status removed.\n     *  <p>\n     * This is a type of mode change and is also passed to the onMode\n     * method in the PircBot class.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @since PircBot 0.9.5\n     *\n     * @param channel The channel in which the mode change took place.\n     * @param sourceNick The nick of the user that performed the mode change.\n     * @param sourceLogin The login of the user that performed the mode change.\n     * @param sourceHostname The hostname of the user that performed the mode change.\n     * @param recipient The nick of the user that got 'devoiced'.\n     */\n    protected void onDeVoice(String channel, String sourceNick, String sourceLogin, String sourceHostname, String recipient) {}\n\n\n    /**\n     * Called when a channel key is set.  When the channel key has been set,\n     * other users may only join that channel if they know the key.  Channel keys\n     * are sometimes referred to as passwords.\n     *  <p>\n     * This is a type of mode change and is also passed to the onMode\n     * method in the PircBot class.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @since PircBot 0.9.5\n     *\n     * @param channel The channel in which the mode change took place.\n     * @param sourceNick The nick of the user that performed the mode change.\n     * @param sourceLogin The login of the user that performed the mode change.\n     * @param sourceHostname The hostname of the user that performed the mode change.\n     * @param key The new key for the channel.\n     */\n    protected void onSetChannelKey(String channel, String sourceNick, String sourceLogin, String sourceHostname, String key) {}\n\n\n    /**\n     * Called when a channel key is removed.\n     *  <p>\n     * This is a type of mode change and is also passed to the onMode\n     * method in the PircBot class.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @since PircBot 0.9.5\n     *\n     * @param channel The channel in which the mode change took place.\n     * @param sourceNick The nick of the user that performed the mode change.\n     * @param sourceLogin The login of the user that performed the mode change.\n     * @param sourceHostname The hostname of the user that performed the mode change.\n     * @param key The key that was in use before the channel key was removed.\n     */\n    protected void onRemoveChannelKey(String channel, String sourceNick, String sourceLogin, String sourceHostname, String key) {}\n\n\n    /**\n     * Called when a user limit is set for a channel.  The number of users in\n     * the channel cannot exceed this limit.\n     *  <p>\n     * This is a type of mode change and is also passed to the onMode\n     * method in the PircBot class.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @since PircBot 0.9.5\n     *\n     * @param channel The channel in which the mode change took place.\n     * @param sourceNick The nick of the user that performed the mode change.\n     * @param sourceLogin The login of the user that performed the mode change.\n     * @param sourceHostname The hostname of the user that performed the mode change.\n     * @param limit The maximum number of users that may be in this channel at the same time.\n     */\n    protected void onSetChannelLimit(String channel, String sourceNick, String sourceLogin, String sourceHostname, int limit) {}\n\n\n    /**\n     * Called when the user limit is removed for a channel.\n     *  <p>\n     * This is a type of mode change and is also passed to the onMode\n     * method in the PircBot class.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @since PircBot 0.9.5\n     *\n     * @param channel The channel in which the mode change took place.\n     * @param sourceNick The nick of the user that performed the mode change.\n     * @param sourceLogin The login of the user that performed the mode change.\n     * @param sourceHostname The hostname of the user that performed the mode change.\n     */\n    protected void onRemoveChannelLimit(String channel, String sourceNick, String sourceLogin, String sourceHostname) {}\n\n\n    /**\n     * Called when a user (possibly us) gets banned from a channel.  Being\n     * banned from a channel prevents any user with a matching hostmask from\n     * joining the channel.  For this reason, most bans are usually directly\n     * followed by the user being kicked :-)\n     *  <p>\n     * This is a type of mode change and is also passed to the onMode\n     * method in the PircBot class.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @since PircBot 0.9.5\n     *\n     * @param channel The channel in which the mode change took place.\n     * @param sourceNick The nick of the user that performed the mode change.\n     * @param sourceLogin The login of the user that performed the mode change.\n     * @param sourceHostname The hostname of the user that performed the mode change.\n     * @param hostmask The hostmask of the user that has been banned.\n     */\n    protected void onSetChannelBan(String channel, String sourceNick, String sourceLogin, String sourceHostname, String hostmask) {}\n\n\n    /**\n     * Called when a hostmask ban is removed from a channel.\n     *  <p>\n     * This is a type of mode change and is also passed to the onMode\n     * method in the PircBot class.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @since PircBot 0.9.5\n     *\n     * @param channel The channel in which the mode change took place.\n     * @param sourceNick The nick of the user that performed the mode change.\n     * @param sourceLogin The login of the user that performed the mode change.\n     * @param sourceHostname The hostname of the user that performed the mode change.\n     * @param hostmask\n     */\n    protected void onRemoveChannelBan(String channel, String sourceNick, String sourceLogin, String sourceHostname, String hostmask) {}\n\n    \n    /**\n     * Called when topic protection is enabled for a channel.  Topic protection\n     * means that only operators in a channel may change the topic.\n     *  <p>\n     * This is a type of mode change and is also passed to the onMode\n     * method in the PircBot class.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @since PircBot 0.9.5\n     *\n     * @param channel The channel in which the mode change took place.\n     * @param sourceNick The nick of the user that performed the mode change.\n     * @param sourceLogin The login of the user that performed the mode change.\n     * @param sourceHostname The hostname of the user that performed the mode change.\n     */\n    protected void onSetTopicProtection(String channel, String sourceNick, String sourceLogin, String sourceHostname) {}\n    \n    \n    /**\n     * Called when topic protection is removed for a channel.\n     *  <p>\n     * This is a type of mode change and is also passed to the onMode\n     * method in the PircBot class.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @since PircBot 0.9.5\n     *\n     * @param channel The channel in which the mode change took place.\n     * @param sourceNick The nick of the user that performed the mode change.\n     * @param sourceLogin The login of the user that performed the mode change.\n     * @param sourceHostname The hostname of the user that performed the mode change.\n     */\n    protected void onRemoveTopicProtection(String channel, String sourceNick, String sourceLogin, String sourceHostname) {}\n    \n    \n    /**\n     * Called when a channel is set to only allow messages from users that\n     * are in the channel.\n     *  <p>\n     * This is a type of mode change and is also passed to the onMode\n     * method in the PircBot class.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @since PircBot 0.9.5\n     *\n     * @param channel The channel in which the mode change took place.\n     * @param sourceNick The nick of the user that performed the mode change.\n     * @param sourceLogin The login of the user that performed the mode change.\n     * @param sourceHostname The hostname of the user that performed the mode change.\n     */\n    protected void onSetNoExternalMessages(String channel, String sourceNick, String sourceLogin, String sourceHostname) {}\n    \n    \n    /**\n     * Called when a channel is set to allow messages from any user, even\n     * if they are not actually in the channel.\n     *  <p>\n     * This is a type of mode change and is also passed to the onMode\n     * method in the PircBot class.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @since PircBot 0.9.5\n     *\n     * @param channel The channel in which the mode change took place.\n     * @param sourceNick The nick of the user that performed the mode change.\n     * @param sourceLogin The login of the user that performed the mode change.\n     * @param sourceHostname The hostname of the user that performed the mode change.\n     */\n    protected void onRemoveNoExternalMessages(String channel, String sourceNick, String sourceLogin, String sourceHostname) {}\n    \n    \n    /**\n     * Called when a channel is set to 'invite only' mode.  A user may only\n     * join the channel if they are invited by someone who is already in the\n     * channel.\n     *  <p>\n     * This is a type of mode change and is also passed to the onMode\n     * method in the PircBot class.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @since PircBot 0.9.5\n     *\n     * @param channel The channel in which the mode change took place.\n     * @param sourceNick The nick of the user that performed the mode change.\n     * @param sourceLogin The login of the user that performed the mode change.\n     * @param sourceHostname The hostname of the user that performed the mode change.\n     */\n    protected void onSetInviteOnly(String channel, String sourceNick, String sourceLogin, String sourceHostname) {}\n    \n    \n    /**\n     * Called when a channel has 'invite only' removed.\n     *  <p>\n     * This is a type of mode change and is also passed to the onMode\n     * method in the PircBot class.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @since PircBot 0.9.5\n     *\n     * @param channel The channel in which the mode change took place.\n     * @param sourceNick The nick of the user that performed the mode change.\n     * @param sourceLogin The login of the user that performed the mode change.\n     * @param sourceHostname The hostname of the user that performed the mode change.\n     */\n    protected void onRemoveInviteOnly(String channel, String sourceNick, String sourceLogin, String sourceHostname) {}\n    \n    \n    /**\n     * Called when a channel is set to 'moderated' mode.  If a channel is\n     * moderated, then only users who have been 'voiced' or 'opped' may speak\n     * or change their nicks.\n     *  <p>\n     * This is a type of mode change and is also passed to the onMode\n     * method in the PircBot class.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @since PircBot 0.9.5\n     *\n     * @param channel The channel in which the mode change took place.\n     * @param sourceNick The nick of the user that performed the mode change.\n     * @param sourceLogin The login of the user that performed the mode change.\n     * @param sourceHostname The hostname of the user that performed the mode change.\n     */\n    protected void onSetModerated(String channel, String sourceNick, String sourceLogin, String sourceHostname) {}\n    \n    \n    /**\n     * Called when a channel has moderated mode removed.\n     *  <p>\n     * This is a type of mode change and is also passed to the onMode\n     * method in the PircBot class.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @since PircBot 0.9.5\n     *\n     * @param channel The channel in which the mode change took place.\n     * @param sourceNick The nick of the user that performed the mode change.\n     * @param sourceLogin The login of the user that performed the mode change.\n     * @param sourceHostname The hostname of the user that performed the mode change.\n     */\n    protected void onRemoveModerated(String channel, String sourceNick, String sourceLogin, String sourceHostname) {}\n    \n    \n    /**\n     * Called when a channel is marked as being in private mode.\n     *  <p>\n     * This is a type of mode change and is also passed to the onMode\n     * method in the PircBot class.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @since PircBot 0.9.5\n     *\n     * @param channel The channel in which the mode change took place.\n     * @param sourceNick The nick of the user that performed the mode change.\n     * @param sourceLogin The login of the user that performed the mode change.\n     * @param sourceHostname The hostname of the user that performed the mode change.\n     */\n    protected void onSetPrivate(String channel, String sourceNick, String sourceLogin, String sourceHostname) {}\n    \n    \n    /**\n     * Called when a channel is marked as not being in private mode.\n     *  <p>\n     * This is a type of mode change and is also passed to the onMode\n     * method in the PircBot class.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @since PircBot 0.9.5\n     *\n     * @param channel The channel in which the mode change took place.\n     * @param sourceNick The nick of the user that performed the mode change.\n     * @param sourceLogin The login of the user that performed the mode change.\n     * @param sourceHostname The hostname of the user that performed the mode change.\n     */\n    protected void onRemovePrivate(String channel, String sourceNick, String sourceLogin, String sourceHostname) {}\n    \n    \n    /**\n     * Called when a channel is set to be in 'secret' mode.  Such channels\n     * typically do not appear on a server's channel listing.\n     *  <p>\n     * This is a type of mode change and is also passed to the onMode\n     * method in the PircBot class.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @since PircBot 0.9.5\n     *\n     * @param channel The channel in which the mode change took place.\n     * @param sourceNick The nick of the user that performed the mode change.\n     * @param sourceLogin The login of the user that performed the mode change.\n     * @param sourceHostname The hostname of the user that performed the mode change.\n     */\n    protected void onSetSecret(String channel, String sourceNick, String sourceLogin, String sourceHostname) {}\n    \n    \n    /**\n     * Called when a channel has 'secret' mode removed.\n     *  <p>\n     * This is a type of mode change and is also passed to the onMode\n     * method in the PircBot class.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @since PircBot 0.9.5\n     *\n     * @param channel The channel in which the mode change took place.\n     * @param sourceNick The nick of the user that performed the mode change.\n     * @param sourceLogin The login of the user that performed the mode change.\n     * @param sourceHostname The hostname of the user that performed the mode change.\n     */\n    protected void onRemoveSecret(String channel, String sourceNick, String sourceLogin, String sourceHostname) {}\n    \n    \n    /**\n     * Called when we are invited to a channel by a user.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @since PircBot 0.9.5\n     * \n     * @param targetNick The nick of the user being invited - should be us!\n     * @param sourceNick The nick of the user that sent the invitation.\n     * @param sourceLogin The login of the user that sent the invitation.\n     * @param sourceHostname The hostname of the user that sent the invitation.\n     * @param channel The channel that we're being invited to.\n     */\n    protected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String channel)  {}    \n\n\n    /**\n     * This method used to be called when a DCC SEND request was sent to the PircBot.\n     * Please use the onIncomingFileTransfer method to receive files, as it\n     * has better functionality and supports resuming.\n     * \n     * @deprecated As of PircBot 1.2.0, use {@link #onIncomingFileTransfer(DccFileTransfer)}\n     */\n    protected void onDccSendRequest(String sourceNick, String sourceLogin, String sourceHostname, String filename, long address, int port, int size) {}\n    \n    \n    /**\n     * This method used to be called when a DCC CHAT request was sent to the PircBot.\n     * Please use the onIncomingChatRequest method to accept chats, as it\n     * has better functionality.\n     * \n     * @deprecated As of PircBot 1.2.0, use {@link #onIncomingChatRequest(DccChat)}\n     */\n    protected void onDccChatRequest(String sourceNick, String sourceLogin, String sourceHostname, long address, int port) {}\n    \n    \n    /**\n     * This method is called whenever a DCC SEND request is sent to the PircBot.\n     * This means that a client has requested to send a file to us.\n     * This abstract implementation performs no action, which means that all\n     * DCC SEND requests will be ignored by default. If you wish to receive\n     * the file, then you may override this method and call the receive method\n     * on the DccFileTransfer object, which connects to the sender and downloads\n     * the file.\n     *  <p>\n     * Example:\n     * <pre> public void onIncomingFileTransfer(DccFileTransfer transfer) {\n     *     // Use the suggested file name.\n     *     File file = transfer.getFile();\n     *     // Receive the transfer and save it to the file, allowing resuming.\n     *     transfer.receive(file, true);\n     * }<\/pre>\n     *  <p>\n     * <b>Warning:<\/b> Receiving an incoming file transfer will cause a file\n     * to be written to disk. Please ensure that you make adequate security\n     * checks so that this file does not overwrite anything important!\n     *  <p>\n     * Each time a file is received, it happens within a new Thread\n     * in order to allow multiple files to be downloaded by the PircBot\n     * at the same time. \n     *  <p>\n     * If you allow resuming and the file already partly exists, it will\n     * be appended to instead of overwritten.  If resuming is not enabled,\n     * the file will be overwritten if it already exists.\n     *  <p>\n     * You can throttle the speed of the transfer by calling the setPacketDelay\n     * method on the DccFileTransfer object, either before you receive the\n     * file or at any moment during the transfer.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     *\n     * @since PircBot 1.2.0\n     * \n     * @param transfer The DcccFileTransfer that you may accept.\n     * \n     * @see DccFileTransfer\n     * \n     */\n    protected void onIncomingFileTransfer(DccFileTransfer transfer) {}\n    \n    \n    /**\n     * This method gets called when a DccFileTransfer has finished.\n     * If there was a problem, the Exception will say what went wrong.\n     * If the file was sent successfully, the Exception will be null.\n     *  <p>\n     * Both incoming and outgoing file transfers are passed to this method.\n     * You can determine the type by calling the isIncoming or isOutgoing\n     * methods on the DccFileTransfer object.\n     *\n     * @since PircBot 1.2.0\n     * \n     * @param transfer The DccFileTransfer that has finished.\n     * @param e null if the file was transfered successfully, otherwise this\n     *          will report what went wrong.\n     * \n     * @see DccFileTransfer\n     * \n     */\n    protected void onFileTransferFinished(DccFileTransfer transfer, Exception e) {}\n    \n    \n    /**\n     * This method will be called whenever a DCC Chat request is received.\n     * This means that a client has requested to chat to us directly rather\n     * than via the IRC server. This is useful for sending many lines of text\n     * to and from the bot without having to worry about flooding the server\n     * or any operators of the server being able to \"spy\" on what is being\n     * said. This abstract implementation performs no action, which means\n     * that all DCC CHAT requests will be ignored by default.\n     *  <p>\n     * If you wish to accept the connection, then you may override this\n     * method and call the accept() method on the DccChat object, which\n     * connects to the sender of the chat request and allows lines to be\n     * sent to and from the bot.\n     *  <p>\n     * Your bot must be able to connect directly to the user that sent the\n     * request.\n     *  <p>\n     * Example: \n     * <pre> public void onIncomingChatRequest(DccChat chat) {\n     *     try {\n     *         // Accept all chat, whoever it's from.\n     *         chat.accept();\n     *         chat.sendLine(\"Hello\");\n     *         String response = chat.readLine();\n     *         chat.close();\n     *     }\n     *     catch (IOException e) {}\n     * }<\/pre>\n     * \n     * Each time this method is called, it is called from within a new Thread\n     * so that multiple DCC CHAT sessions can run concurrently.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     *\n     * @since PircBot 1.2.0\n     * \n     * @param chat A DccChat object that represents the incoming chat request.\n     * \n     * @see DccChat\n     * \n     */\n    protected void onIncomingChatRequest(DccChat chat) {}\n    \n    \n    /**\n     * This method is called whenever we receive a VERSION request.\n     * This abstract implementation responds with the PircBot's _version string,\n     * so if you override this method, be sure to either mimic its functionality\n     * or to call super.onVersion(...);\n     * \n     * @param sourceNick The nick of the user that sent the VERSION request.\n     * @param sourceLogin The login of the user that sent the VERSION request.\n     * @param sourceHostname The hostname of the user that sent the VERSION request.\n     * @param target The target of the VERSION request, be it our nick or a channel name.\n     */\n    protected void onVersion(String sourceNick, String sourceLogin, String sourceHostname, String target) {\n        this.sendRawLine(\"NOTICE \" + sourceNick + \" :\\u0001VERSION \" + _version + \"\\u0001\");\n    }\n    \n    \n    /**\n     * This method is called whenever we receive a PING request from another\n     * user.\n     *  <p>\n     * This abstract implementation responds correctly, so if you override this\n     * method, be sure to either mimic its functionality or to call\n     * super.onPing(...);\n     * \n     * @param sourceNick The nick of the user that sent the PING request.\n     * @param sourceLogin The login of the user that sent the PING request.\n     * @param sourceHostname The hostname of the user that sent the PING request.\n     * @param target The target of the PING request, be it our nick or a channel name.\n     * @param pingValue The value that was supplied as an argument to the PING command.\n     */\n    protected void onPing(String sourceNick, String sourceLogin, String sourceHostname, String target, String pingValue) {\n        this.sendRawLine(\"NOTICE \" + sourceNick + \" :\\u0001PING \" + pingValue + \"\\u0001\");\n    }\n    \n    \n    /**\n     * The actions to perform when a PING request comes from the server.\n     *  <p>\n     * This sends back a correct response, so if you override this method,\n     * be sure to either mimic its functionality or to call\n     * super.onServerPing(response);\n     *\n     * @param response The response that should be given back in your PONG.\n     */\n    protected void onServerPing(String response) {\n        this.sendRawLine(\"PONG \" + response);\n    }\n    \n    \n    /**\n     * This method is called whenever we receive a TIME request.\n     *  <p>\n     * This abstract implementation responds correctly, so if you override this\n     * method, be sure to either mimic its functionality or to call\n     * super.onTime(...);\n     * \n     * @param sourceNick The nick of the user that sent the TIME request.\n     * @param sourceLogin The login of the user that sent the TIME request.\n     * @param sourceHostname The hostname of the user that sent the TIME request.\n     * @param target The target of the TIME request, be it our nick or a channel name.\n     */\n    protected void onTime(String sourceNick, String sourceLogin, String sourceHostname, String target) {\n        this.sendRawLine(\"NOTICE \" + sourceNick + \" :\\u0001TIME \" + new Date().toString() + \"\\u0001\");\n    }\n    \n    \n    /**\n     * This method is called whenever we receive a FINGER request.\n     *  <p>\n     * This abstract implementation responds correctly, so if you override this\n     * method, be sure to either mimic its functionality or to call\n     * super.onFinger(...);\n     * \n     * @param sourceNick The nick of the user that sent the FINGER request.\n     * @param sourceLogin The login of the user that sent the FINGER request.\n     * @param sourceHostname The hostname of the user that sent the FINGER request.\n     * @param target The target of the FINGER request, be it our nick or a channel name.\n     */\n    protected void onFinger(String sourceNick, String sourceLogin, String sourceHostname, String target) {\n        this.sendRawLine(\"NOTICE \" + sourceNick + \" :\\u0001FINGER \" + _finger + \"\\u0001\");\n    }\n    \n    \n    /**\n     * This method is called whenever we receive a line from the server that\n     * the PircBot has not been programmed to recognise.\n     *  <p>\n     * The implementation of this method in the PircBot abstract class\n     * performs no actions and may be overridden as required.\n     * \n     * @param line The raw line that was received from the server.\n     */\n    protected void onUnknown(String line) {\n        // And then there were none :)\n    }\n    \n    /**\n     * Sets the name of the bot, which will be used as its nick when it\n     * tries to join an IRC server.  This should be set before joining\n     * any servers, otherwise the default nick will be used.  You would\n     * typically call this method from the constructor of the class that\n     * extends PircBot.\n     *  <p>\n     * The changeNick method should be used if you wish to change your nick\n     * when you are connected to a server.\n     *\n     * @param name The new name of the Bot.\n     */\n    protected final void setName(String name) {\n        _name = name;\n    }\n    \n    \n    /**\n     * Sets the internal nick of the bot.  This is only to be called by the\n     * PircBot class in response to notification of nick changes that apply\n     * to us.\n     * \n     * @param nick The new nick.\n     */\n    private final void setNick(String nick) {\n        _nick = nick;\n    }\n    \n    \n    /**\n     * Sets the internal login of the Bot.  This should be set before joining\n     * any servers.\n     *\n     * @param login The new login of the Bot.\n     */\n    protected final void setLogin(String login) {\n        _login = login;\n    }\n    \n\n    /**\n     * Sets the internal version of the Bot.  This should be set before joining\n     * any servers.\n     *\n     * @param version The new version of the Bot.\n     */\n    protected final void setVersion(String version) {\n        _version = version;\n    }\n\n\n    /**\n     * Sets the interal finger message.  This should be set before joining\n     * any servers.\n     *\n     * @param finger The new finger message for the Bot.\n     */\n    protected final void setFinger(String finger) {\n        _finger = finger;\n    }\n    \n    \n    /**\n     * Gets the name of the PircBot. This is the name that will be used as\n     * as a nick when we try to join servers.\n     *\n     * @return The name of the PircBot.\n     */\n    public final String getName() {\n        return _name;\n    }\n    \n    \n    /**\n     * Returns the current nick of the bot. Note that if you have just changed\n     * your nick, this method will still return the old nick until confirmation\n     * of the nick change is received from the server.\n     *  <p>\n     * The nick returned by this method is maintained only by the PircBot\n     * class and is guaranteed to be correct in the context of the IRC server.\n     *\n     * @since PircBot 1.0.0\n     * \n     * @return The current nick of the bot.\n     */\n    public String getNick() {\n        return _nick;\n    }\n    \n    \n    /**\n     * Gets the internal login of the PircBot.\n     *\n     * @return The login of the PircBot.\n     */\n    public final String getLogin() {\n        return _login;\n    }\n    \n\n    /**\n     * Gets the internal version of the PircBot.\n     *\n     * @return The version of the PircBot.\n     */\n    public final String getVersion() {\n        return _version;\n    }\n    \n    \n    /**\n     * Gets the internal finger message of the PircBot.\n     *\n     * @return The finger message of the PircBot.\n     */\n    public final String getFinger() {\n        return _finger;\n    }\n    \n    \n    /**\n     * Returns whether or not the PircBot is currently connected to a server.\n     * The result of this method should only act as a rough guide,\n     * as the result may not be valid by the time you act upon it.\n     *\n     * @return True if and only if the PircBot is currently connected to a server.\n     */\n    public final synchronized boolean isConnected() {\n        return _inputThread != null && _inputThread.isConnected();\n    }\n    \n    \n    /**\n     * Sets the number of milliseconds to delay between consecutive\n     * messages when there are multiple messages waiting in the\n     * outgoing message queue.  This has a default value of 1000ms.\n     * It is a good idea to stick to this default value, as it will\n     * prevent your bot from spamming servers and facing the subsequent\n     * wrath!  However, if you do need to change this delay value (<b>not\n     * recommended<\/b>), then this is the method to use.\n     *\n     * @param delay The number of milliseconds between each outgoing message.\n     * \n     */\n    public final void setMessageDelay(long delay) {\n        if (delay < 0) {\n            throw new IllegalArgumentException(\"Cannot have a negative time.\");\n        }\n        _messageDelay = delay;\n    }\n    \n    \n    /**\n     * Returns the number of milliseconds that will be used to separate\n     * consecutive messages to the server from the outgoing message queue.\n     *\n     * @return Number of milliseconds.\n     */\n    public final long getMessageDelay() {\n        return _messageDelay;\n    }\n    \n    \n    /**\n     * Gets the maximum length of any line that is sent via the IRC protocol.\n     * The IRC RFC specifies that line lengths, including the trailing \\r\\n\n     * must not exceed 512 bytes.  Hence, there is currently no option to\n     * change this value in PircBot.  All lines greater than this length\n     * will be truncated before being sent to the IRC server.\n     * \n     * @return The maximum line length (currently fixed at 512)\n     */\n    public final int getMaxLineLength() {\n        return InputThread.MAX_LINE_LENGTH;\n    }\n    \n    \n    /**\n     * Gets the number of lines currently waiting in the outgoing message Queue.\n     * If this returns 0, then the Queue is empty and any new message is likely\n     * to be sent to the IRC server immediately.\n     *\n     * @since PircBot 0.9.9\n     * \n     * @return The number of lines in the outgoing message Queue.\n     */\n    public final int getOutgoingQueueSize() {\n        return _outQueue.size();\n    }\n    \n    \n    /**\n     * Returns the name of the last IRC server the PircBot tried to connect to.\n     * This does not imply that the connection attempt to the server was\n     * successful (we suggest you look at the onConnect method).\n     * A value of null is returned if the PircBot has never tried to connect\n     * to a server.\n     * \n     * @return The name of the last machine we tried to connect to. Returns\n     *         null if no connection attempts have ever been made.\n     */\n    public final String getServer() {\n        return _server;\n    }\n    \n    \n    /**\n     * Returns the port number of the last IRC server that the PircBot tried\n     * to connect to.\n     * This does not imply that the connection attempt to the server was\n     * successful (we suggest you look at the onConnect method).\n     * A value of -1 is returned if the PircBot has never tried to connect\n     * to a server.\n     * \n     * @since PircBot 0.9.9\n     * \n     * @return The port number of the last IRC server we connected to.\n     *         Returns -1 if no connection attempts have ever been made.\n     */\n    public final int getPort() {\n        return _port;\n    }\n    \n    \n    /**\n     * Returns the last password that we used when connecting to an IRC server.\n     * This does not imply that the connection attempt to the server was\n     * successful (we suggest you look at the onConnect method).\n     * A value of null is returned if the PircBot has never tried to connect\n     * to a server using a password.\n     * \n     * @since PircBot 0.9.9\n     * \n     * @return The last password that we used when connecting to an IRC server.\n     *         Returns null if we have not previously connected using a password.\n     */\n    public final String getPassword() {\n        return _password;\n    }\n    \n    \n    /**\n     * A convenient method that accepts an IP address represented as a\n     * long and returns an integer array of size 4 representing the same\n     * IP address.\n     * \n     * @since PircBot 0.9.4\n     *\n     * @param address the long value representing the IP address.\n     * \n     * @return An int[] of size 4.\n     */\n    public int[] longToIp(long address) {\n        int[] ip = new int[4];\n        for (int i = 3; i >= 0; i--) {\n            ip[i] = (int) (address % 256);\n            address = address / 256;\n        }\n        return ip;\n    }\n\n    \n    /**\n     * A convenient method that accepts an IP address represented by a byte[]\n     * of size 4 and returns this as a long representation of the same IP\n     * address.\n     * \n     * @since PircBot 0.9.4\n     *\n     * @param address the byte[] of size 4 representing the IP address.\n     * \n     * @return a long representation of the IP address.\n     */\n    public long ipToLong(byte[] address) {\n        if (address.length != 4) {\n            throw new IllegalArgumentException(\"byte array must be of length 4\");\n        }\n        long ipNum = 0;\n        long multiplier = 1;\n        for (int i = 3; i >= 0; i--) {\n            int byteVal = (address[i] + 256) % 256;\n            ipNum += byteVal*multiplier;\n            multiplier *= 256;\n        }\n        return ipNum;\n    }\n    \n    \n    /**\n     * Sets the encoding charset to be used when sending or receiving lines\n     * from the IRC server.  If set to null, then the platform's default\n     * charset is used.  You should only use this method if you are\n     * trying to send text to an IRC server in a different charset, e.g.\n     * \"GB2312\" for Chinese encoding.  If a PircBot is currently connected\n     * to a server, then it must reconnect before this change takes effect.\n     * \n     * @since PircBot 1.0.4\n     * \n     * @param charset The new encoding charset to be used by PircBot.\n     * \n     * @throws UnsupportedEncodingException If the named charset is not\n     *                                      supported.\n     */\n    public void setEncoding(String charset) throws UnsupportedEncodingException {\n        // Just try to see if the charset is supported first...\n        \"\".getBytes(charset);\n        \n        _charset = charset;\n    }\n\n    \n    /**\n     * Returns the encoding used to send and receive lines from\n     * the IRC server, or null if not set.  Use the setEncoding\n     * method to change the encoding charset.\n     * \n     * @since PircBot 1.0.4\n     * \n     * @return The encoding used to send outgoing messages, or\n     *         null if not set.\n     */\n    public String getEncoding() {\n        return _charset;\n    }\n    \n    /**\n     * Returns the InetAddress used by the PircBot.\n     * This can be used to find the I.P. address from which the PircBot is\n     * connected to a server.\n     * \n     * @since PircBot 1.4.4\n     * \n     * @return The current local InetAddress, or null if never connected.\n     */\n    public InetAddress getInetAddress() {\n        return _inetAddress;\n    }\n    \n\n    /**\n     * Sets the InetAddress to be used when sending DCC chat or file transfers.\n     * This can be very useful when you are running a bot on a machine which\n     * is behind a firewall and you need to tell receiving clients to connect\n     * to a NAT/router, which then forwards the connection.\n     * \n     * @since PircBot 1.4.4\n     * \n     * @param dccInetAddress The new InetAddress, or null to use the default.\n     */\n    public void setDccInetAddress(InetAddress dccInetAddress) {\n        _dccInetAddress = dccInetAddress;\n    }\n    \n\n    /**\n     * Returns the InetAddress used when sending DCC chat or file transfers.\n     * If this is null, the default InetAddress will be used.\n     * \n     * @since PircBot 1.4.4\n     * \n     * @return The current DCC InetAddress, or null if left as default.\n     */\n    public InetAddress getDccInetAddress() {\n        return _dccInetAddress;\n    }\n    \n    \n    /**\n     * Returns the set of port numbers to be used when sending a DCC chat\n     * or file transfer. This is useful when you are behind a firewall and\n     * need to set up port forwarding. The array of port numbers is traversed\n     * in sequence until a free port is found to listen on. A DCC tranfer will\n     * fail if all ports are already in use.\n     * If set to null, <i>any<\/i> free port number will be used. \n     * \n     * @since PircBot 1.4.4\n     * \n     * @return An array of port numbers that PircBot can use to send DCC\n     *         transfers, or null if any port is allowed.\n     */\n    public int[] getDccPorts() {\n        if (_dccPorts == null || _dccPorts.length == 0) {\n            return null;\n        }\n        // Clone the array to prevent external modification.\n        return (int[]) _dccPorts.clone();\n    }\n    \n    \n    /**\n     * Sets the choice of port numbers that can be used when sending a DCC chat\n     * or file transfer. This is useful when you are behind a firewall and\n     * need to set up port forwarding. The array of port numbers is traversed\n     * in sequence until a free port is found to listen on. A DCC tranfer will\n     * fail if all ports are already in use.\n     * If set to null, <i>any<\/i> free port number will be used. \n     * \n     * @since PircBot 1.4.4\n     * \n     * @param ports The set of port numbers that PircBot may use for DCC\n     *              transfers, or null to let it use any free port (default).\n     *\n     */\n    public void setDccPorts(int[] ports) {\n        if (ports == null || ports.length == 0) {\n            _dccPorts = null;\n        }\n        else {\n            // Clone the array to prevent external modification.\n            _dccPorts = (int[]) ports.clone();\n        }\n    }    \n    \n    \n    /**\n     * Returns true if and only if the object being compared is the exact\n     * same instance as this PircBot. This may be useful if you are writing\n     * a multiple server IRC bot that uses more than one instance of PircBot.\n     * \n     * @since PircBot 0.9.9\n     *\n     * @return true if and only if Object o is a PircBot and equal to this.\n     */\n    public boolean equals(Object o) {\n        // This probably has the same effect as Object.equals, but that may change...\n        if (o instanceof PircBot) {\n            PircBot other = (PircBot) o;\n            return other == this;\n        }\n        return false;\n    }\n    \n    \n    /**\n     * Returns the hashCode of this PircBot. This method can be called by hashed\n     * collection classes and is useful for managing multiple instances of\n     * PircBots in such collections.\n     * \n     * @since PircBot 0.9.9\n     * \n     * @return the hash code for this instance of PircBot.\n     */\n    public int hashCode() {\n        return super.hashCode();\n    }\n    \n    \n    /**\n     * Returns a String representation of this object.\n     * You may find this useful for debugging purposes, particularly\n     * if you are using more than one PircBot instance to achieve\n     * multiple server connectivity. The format of\n     * this String may change between different versions of PircBot\n     * but is currently something of the form\n     * <code>\n     *   Version{PircBot x.y.z Java IRC Bot - www.jibble.org}\n     *   Connected{true}\n     *   Server{irc.dal.net}\n     *   Port{6667}\n     *   Password{}\n     * <\/code>\n     * \n     * @since PircBot 0.9.10\n     * \n     * @return a String representation of this object.\n     */\n    public String toString() {\n        return \"Version{\" + _version + \"}\" +\n                \" Connected{\" + isConnected() + \"}\" +\n                \" Server{\" + _server + \"}\" +\n                \" Port{\" + _port + \"}\" +\n                \" Password{\" + _password + \"}\";\n    }\n    \n    \n    /**\n     * Returns an array of all users in the specified channel.\n     *  <p>\n     * There are some important things to note about this method:-\n     * <ul>\n     *  <li>This method may not return a full list of users if you call it\n     *      before the complete nick list has arrived from the IRC server.\n     *  <\/li>\n     *  <li>If you wish to find out which users are in a channel as soon\n     *      as you join it, then you should override the onUserList method\n     *      instead of calling this method, as the onUserList method is only\n     *      called as soon as the full user list has been received.\n     *  <\/li>\n     *  <li>This method will return immediately, as it does not require any\n     *      interaction with the IRC server.\n     *  <\/li>\n     *  <li>The bot must be in a channel to be able to know which users are\n     *      in it.\n     *  <\/li>\n     * <\/ul>\n     * \n     * @since PircBot 1.0.0\n     *\n     * @param channel The name of the channel to list.\n     * \n     * @return An array of User objects. This array is empty if we are not\n     *         in the channel.\n     * \n     * @see #onUserList(String,User[]) onUserList\n     */\n    public final User[] getUsers(String channel) {\n        channel = channel.toLowerCase();\n        User[] userArray = new User[0];\n        synchronized (_channels) {\n            Hashtable<User, User> users = _channels.get(channel);\n            if (users != null) {\n                userArray = new User[users.size()];\n                Enumeration<User> enumeration = users.elements();\n                for (int i = 0; i < userArray.length; i++) {\n                    User user = (User) enumeration.nextElement();\n                    userArray[i] = user;\n                }\n            }\n        }\n        return userArray;\n    }\n    \n    \n    /**\n     * Returns an array of all channels that we are in.  Note that if you\n     * call this method immediately after joining a new channel, the new\n     * channel may not appear in this array as it is not possible to tell\n     * if the join was successful until a response is received from the\n     * IRC server.\n     * \n     * @since PircBot 1.0.0\n     * \n     * @return A String array containing the names of all channels that we\n     *         are in.\n     */\n    public final String[] getChannels() {\n        String[] channels = new String[0];\n        synchronized (_channels) {\n            channels = new String[_channels.size()];\n            Enumeration<String> enumeration = _channels.keys();\n            for (int i = 0; i < channels.length; i++) {\n                channels[i] = (String) enumeration.nextElement();\n            }\n        }\n        return channels;\n    }\n    \n    \n    /**\n     * Disposes of all thread resources used by this PircBot. This may be\n     * useful when writing bots or clients that use multiple servers (and\n     * therefore multiple PircBot instances) or when integrating a PircBot\n     * with an existing program.\n     *  <p>\n     * Each PircBot runs its own threads for dispatching messages from its\n     * outgoing message queue and receiving messages from the server.\n     * Calling dispose() ensures that these threads are\n     * stopped, thus freeing up system resources and allowing the PircBot\n     * object to be garbage collected if there are no other references to\n     * it.\n     *  <p>\n     * Once a PircBot object has been disposed, it should not be used again.\n     * Attempting to use a PircBot that has been disposed may result in\n     * unpredictable behaviour.\n     * \n     * @since 1.2.2\n     */\n    public synchronized void dispose() {\n        //System.out.println(\"disposing...\");\n        _outputThread.interrupt();\n        _inputThread.dispose();\n    }\n    \n    \n    /**\n     * Add a user to the specified channel in our memory.\n     * Overwrite the existing entry if it exists.\n     */\n    private final void addUser(String channel, User user) {\n        channel = channel.toLowerCase();\n        synchronized (_channels) {\n            Hashtable<User, User> users = _channels.get(channel);\n            if (users == null) {\n                users = new Hashtable<User, User>();\n                _channels.put(channel, users);\n            }\n            users.put(user, user);\n        }\n    }\n    \n    \n    /**\n     * Remove a user from the specified channel in our memory.\n     */\n    private final User removeUser(String channel, String nick) {\n        channel = channel.toLowerCase();\n        User user = new User(\"\", nick);\n        synchronized (_channels) {\n            Hashtable<User, User> users = _channels.get(channel);\n            if (users != null) {\n                return (User) users.remove(user);\n            }\n        }\n        return null;\n    }\n    \n    \n    /**\n     * Remove a user from all channels in our memory.\n     */\n    private final void removeUser(String nick) {\n        synchronized (_channels) {\n            Enumeration<String> enumeration = _channels.keys();\n            while (enumeration.hasMoreElements()) {\n                String channel = (String) enumeration.nextElement();\n                this.removeUser(channel, nick);\n            }\n        }\n    }\n    \n    \n    /**\n     * Rename a user if they appear in any of the channels we know about.\n     */\n    private final void renameUser(String oldNick, String newNick) {\n        synchronized (_channels) {\n            Enumeration<String> enumeration = _channels.keys();\n            while (enumeration.hasMoreElements()) {\n                String channel = (String) enumeration.nextElement();\n                User user = this.removeUser(channel, oldNick);\n                if (user != null) {\n                    user = new User(user.getPrefix(), newNick);\n                    this.addUser(channel, user);\n                }\n            }\n        }\n    }\n    \n    \n    /**\n     * Removes an entire channel from our memory of users.\n     */\n    private final void removeChannel(String channel) {\n        channel = channel.toLowerCase();\n        synchronized (_channels) {\n            _channels.remove(channel);\n        }\n    }\n    \n    \n    /**\n     * Removes all channels from our memory of users.\n     */\n    private final void removeAllChannels() {\n        synchronized(_channels) {\n            _channels = new Hashtable<String, Hashtable<User, User>>();\n        }\n    }\n\n\n    private final void updateUser(String channel, int userMode, String nick) {\n        channel = channel.toLowerCase();\n        synchronized (_channels) {\n            Hashtable<User, User> users = _channels.get(channel);\n            User newUser = null;\n            if (users != null) {\n                Enumeration<User> enumeration = users.elements();\n                while(enumeration.hasMoreElements()) {\n                    User userObj = (User) enumeration.nextElement();\n                    if (userObj.getNick().equalsIgnoreCase(nick)) {\n                        if (userMode == OP_ADD) {\n                            if (userObj.hasVoice()) {\n                                newUser = new User(\"@+\", nick);\n                            }\n                            else {\n                                newUser = new User(\"@\", nick);\n                            }\n                        }\n                        else if (userMode == OP_REMOVE) {\n                            if(userObj.hasVoice()) {\n                                newUser = new User(\"+\", nick);\n                            }\n                            else {\n                                newUser = new User(\"\", nick);\n                            }\n                        }\n                        else if (userMode == VOICE_ADD) {\n                            if(userObj.isOp()) {\n                                newUser = new User(\"@+\", nick);\n                            }\n                            else {\n                                newUser = new User(\"+\", nick);\n                            }\n                        }\n                        else if (userMode == VOICE_REMOVE) {\n                            if(userObj.isOp()) {\n                                newUser = new User(\"@\", nick);\n                            }\n                            else {\n                                newUser = new User(\"\", nick);\n                            }\n                        }\n                    }\n                }\n            }\n            if (newUser != null) {\n                users.put(newUser, newUser);\n            }\n            else {\n                // just in case ...\n                newUser = new User(\"\", nick);\n                users.put(newUser, newUser);\n            }\n        }\n    }\n\n\n    // Connection stuff.\n    private InputThread _inputThread = null;\n    private OutputThread _outputThread = null;\n    private String _charset = null;\n    private InetAddress _inetAddress = null;\n\n    // Details about the last server that we connected to.\n    private String _server = null;\n    private int _port = -1;\n    private String _password = null;\n    \n    // Outgoing message stuff.\n    private Queue _outQueue = new Queue();\n    private long _messageDelay = 1000;\n    \n    // A Hashtable of channels that points to a selfreferential Hashtable of\n    // User objects (used to remember which users are in which channels).\n    private Hashtable<String, Hashtable<User, User>> _channels = new Hashtable<String, Hashtable<User, User>>();\n    \n    // A Hashtable to temporarily store channel topics when we join them\n    // until we find out who set that topic.\n    private Hashtable<String, String> _topics = new Hashtable<String, String>();\n    \n    // DccManager to process and handle all DCC events.\n    private DccManager _dccManager = new DccManager(this);\n    private int[] _dccPorts = null;\n    private InetAddress _dccInetAddress = null;\n    \n    // Default settings for the PircBot.\n    private boolean _autoNickChange = false;\n    private boolean _useSSL = false;\n\n    private String _name = \"PircBot\";\n    private String _nick = _name;\n    private String _login = \"PircBot\";\n    private String _version = \"PircBot \" + VERSION + \" Java IRC Bot - www.jibble.org\";\n    private String _finger = \"You ought to be arrested for fingering a bot!\";\n    \n    private String _channelPrefixes = \"#&+!\";\n}\n","lineNo":161}
{"Smelly Sample":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2010 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.activity;\n\nimport java.util.Collection;\n\nimport android.app.Activity;\nimport android.content.ComponentName;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.os.Bundle;\nimport android.os.IBinder;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.View.OnKeyListener;\nimport android.widget.AdapterView;\nimport android.widget.EditText;\nimport android.widget.Gallery;\nimport android.widget.ImageView;\nimport android.widget.ListView;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport android.widget.ViewSwitcher;\nimport android.widget.AdapterView.OnItemClickListener;\nimport android.widget.AdapterView.OnItemSelectedListener;\nimport android.widget.TableLayout.LayoutParams;\n\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.adapter.DeckAdapter;\nimport org.yaaic.adapter.MessageListAdapter;\nimport org.yaaic.command.CommandParser;\nimport org.yaaic.irc.IRCBinder;\nimport org.yaaic.irc.IRCService;\nimport org.yaaic.layout.NonScalingBackgroundDrawable;\nimport org.yaaic.listener.ConversationListener;\nimport org.yaaic.listener.ServerListener;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.Status;\nimport org.yaaic.receiver.ConversationReceiver;\nimport org.yaaic.receiver.ServerReceiver;\nimport org.yaaic.view.MessageListView;\n\n/**\n * The server view with a scrollable list of all channels\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class ConversationActivity extends Activity implements ServiceConnection, ServerListener, ConversationListener, OnItemClickListener, OnKeyListener, OnItemSelectedListener\n{\n\tprivate int serverId;\n\tprivate Server server;\n\tprivate IRCBinder binder;\n\tprivate ConversationReceiver channelReceiver;\n\tprivate ServerReceiver serverReceiver;\n\t\n\tprivate ViewSwitcher switcher;\n\tprivate Gallery deck;\n\tprivate DeckAdapter deckAdapter;\n\t\n\t/**\n\t * On create\n\t */\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState)\n\t{\n\t\tsuper.onCreate(savedInstanceState);\n\t\t\n\t\tserverId = getIntent().getExtras().getInt(\"serverId\");\n\t\tserver = (Server) Yaaic.getInstance().getServerById(serverId);\n\t\tsetTitle(\"Yaaic - \" + server.getTitle());\n\t\t\n\t\tsetContentView(R.layout.conversations);\n\t\t\n\t\t((TextView) findViewById(R.id.title)).setText(server.getTitle());\n\t\t((EditText) findViewById(R.id.input)).setOnKeyListener(this);\n\t\t\n        deckAdapter = new DeckAdapter();\n\t\tdeck = (Gallery) findViewById(R.id.deck);\n\t\tdeck.setOnItemSelectedListener(this);\n\t\tdeck.setAdapter(deckAdapter);\n\t\tdeck.setOnItemClickListener(this);\n\t\tdeck.setBackgroundDrawable(new NonScalingBackgroundDrawable(this, deck, R.drawable.background));\n\n\t\tswitcher = (ViewSwitcher) findViewById(R.id.switcher);\n\t\t\n\t\t// Optimization : cache field lookups \n\t\tCollection<Conversation> mConversations = server.getConversations();\n\t\t\n\t\tfor (Conversation conversation : mConversations) {\n\t\t\tonNewConversation(conversation.getName());\n\t\t}\n\t}\n\t\n\t/**\n\t * On resume\n\t */\n\t@Override\n\tpublic void onResume()\n\t{\n\t\tsuper.onResume();\n\t\t\n\t\t((ImageView) findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\t\t\n\t\t// Start service\n        Intent intent = new Intent(this, IRCService.class);\n        intent.setAction(IRCService.ACTION_FOREGROUND);\n        startService(intent);\n        bindService(intent, this, 0);\n        \n    \tchannelReceiver = new ConversationReceiver(server.getId(), this);\n    \tregisterReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_MESSAGE));\n    \tregisterReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_NEW));\n    \tregisterReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_REMOVE));\n\n    \tserverReceiver = new ServerReceiver(this);\n    \tregisterReceiver(serverReceiver, new IntentFilter(Broadcast.SERVER_UPDATE));\n\n\t\tif (!server.isConnected()) {\n\t\t\t ((EditText) findViewById(R.id.input)).setEnabled(false);\n\t\t} else {\n\t\t\t ((EditText) findViewById(R.id.input)).setEnabled(true);\n\t\t}\n\n\t\t// Optimization - cache field lookup\n\t\tCollection<Conversation> mConversations = server.getConversations();\n\t\tMessageListAdapter mAdapter;\n\t\t\n\t\t// Fill view with messages that have been buffered while paused\n\t\tfor (Conversation conversation : mConversations) {\n\t\t\tmAdapter = conversation.getMessageListAdapter();\n\t\t\t\n\t\t\tif (mAdapter != null) {\n\t\t\t\tmAdapter.addBulkMessages(conversation.getBuffer());\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * On Pause\n\t */\n\t@Override\n\tpublic void onPause()\n\t{\n\t\tsuper.onPause();\n\t\t\n\t\tif (binder != null && binder.getService() != null) {\n\t\t\tbinder.getService().checkServiceStatus();\n\t\t}\n\t\t\n\t\t/*if (!binder.getService().hasConnections()) {\n\t\t\tLog.d(\"Yaaic\", \"Stopping service\");\n\t\t\t//binder.getService().stopSelf();\n\t\t} else {\n\t\t\tLog.d(\"Yaaic\", \"Unbinding service\");\n\t\t}*/\n\n\t\tunbindService(this);\n\t\tunregisterReceiver(channelReceiver);\n\t\tunregisterReceiver(serverReceiver);\n\t}\n\n\t/**\n\t * On service connected\n\t */\n\tpublic void onServiceConnected(ComponentName name, IBinder service)\n\t{\n\t\tthis.binder = (IRCBinder) service;\n\t\t\n\t\t// connect to irc server if connect has been requested\n\t\tif (server.getStatus() == Status.PRE_CONNECTING && getIntent().hasExtra(\"connect\")) {\n\t\t\tserver.setStatus(Status.CONNECTING);\n\t\t\tbinder.connect(server);\n\t\t}\n\t}\n\n\t/**\n\t * On service disconnected\n\t */\n\tpublic void onServiceDisconnected(ComponentName name)\n\t{\n\t\tthis.binder = null;\n\t}\n\n\t/**\n\t * On options menu requested\n\t */\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu)\n\t{\n    \tsuper.onCreateOptionsMenu(menu);\n    \t\n    \t// inflate from xml\n    \tMenuInflater inflater = getMenuInflater();\n    \tinflater.inflate(R.menu.conversations, menu);\n    \t\n    \treturn true;\n\t}\n\n\t/**\n\t * On menu item selected\n\t */\n\t@Override\n\tpublic boolean onMenuItemSelected(int featureId, MenuItem item)\n\t{\n\t\tswitch (item.getItemId()) {\n\t\t\tcase R.id.disconnect:\n\t\t\t\tbinder.getService().getConnection(serverId).quitServer();\n\t\t\t\tserver.setStatus(Status.DISCONNECTED);\n\t\t\t\tserver.clearConversations();\n\t\t\t\tsetResult(RESULT_OK);\n\t\t\t\tfinish();\n\t\t\t\tbreak;\n\t\t\tcase R.id.close:\n\t\t\t\tConversation conversationToClose = deckAdapter.getItem(deck.getSelectedItemPosition());\n\t\t\t\tif (conversationToClose.getType() != Conversation.TYPE_SERVER) {\n\t\t\t\t\tonRemoveConversation(conversationToClose.getName());\n\t\t\t\t} else {\n\t\t\t\t\tToast.makeText(this, \"You can not close the server info window\", Toast.LENGTH_SHORT).show();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase R.id.join:\n\t\t\t\tstartActivityForResult(new Intent(this, JoinActivity.class), 0);\n\t\t\t\tbreak;\n\t\t\tcase R.id.users:\n\t\t\t\tConversation conversationForUserList = deckAdapter.getItem(deck.getSelectedItemPosition());\n\t\t\t\tif (conversationForUserList.getType() == Conversation.TYPE_CHANNEL) {\n\t\t\t\t\tstartActivity(new Intent(this, UsersActivity.class));\n\t\t\t\t} else {\n\t\t\t\t\tToast.makeText(this, \"Only usable from within a channel\", Toast.LENGTH_SHORT).show();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\t/**\n\t * Get server object assigned to this activity\n\t * \n\t * @return the server object\n\t */\n\tpublic Server getServer()\n\t{\n\t\treturn server;\n\t}\n\n\t/**\n\t * On conversation message\n\t */\n\tpublic void onConversationMessage(String target)\n\t{\n\t\tConversation conversation = server.getConversation(target);\n\t\tMessageListAdapter adapter = conversation.getMessageListAdapter();\n\t\t\n\t\twhile(conversation.hasBufferedMessages()) {\n\t\t\tMessage message = conversation.pollBufferedMessage();\n\t\t\t\n\t\t\tif (adapter != null) {\n\t\t\t\tadapter.addMessage(message);\n\t\t\t} else {\n\t\t\t\t//\"MessageListAdapter is null (conversation \" + conversation.getName() + \" has no adapter assigned)\"\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * On new conversation\n\t */\n\tpublic void onNewConversation(String target)\n\t{\n\t\tdeckAdapter.addItem(server.getConversation(target));\n\t\t\n\t\tif (!deckAdapter.isSwitched()) {\n\t\t\t// Scroll to new conversation\n\t\t\tdeck.setSelection(deckAdapter.getCount() - 1);\n\t\t}\n\t}\n\t\n\t/**\n\t * On conversation remove\n\t */\n\tpublic void onRemoveConversation(String target)\n\t{\n\t\tdeckAdapter.removeItem(target);\n\t\t\n\t\tif (deckAdapter.isSwitched()) {\n\t\t\tswitcher.showNext();\n\t\t\tswitcher.removeView(deckAdapter.getSwitchedView());\n\t\t\tdeckAdapter.setSwitched(null, null);\n\t\t}\n\t}\n\n\t/**\n\t * On server status update\n\t */\n\tpublic void onStatusUpdate()\n\t{\n\t\t((ImageView) findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\t\t\n\t\tEditText input = (EditText) findViewById(R.id.input);\n\t\tif (server.isConnected()) {\n\t\t\tinput.setEnabled(true); \n\t\t} else {\n\t\t\tinput.setEnabled(false);\n\t\t}\n\t}\n\n\t/**\n\t * On conversation item clicked\n\t */\n\tpublic void onItemClick(AdapterView<?> adapterView, View view, int position, long id)\n\t{\n\t\tConversation conversation = deckAdapter.getItem(position);\n\t\t\n\t\tMessageListView canvas = deckAdapter.renderConversation(conversation, switcher);\n\t\tcanvas.setTranscriptMode(ListView.TRANSCRIPT_MODE_NORMAL);\n\t\tcanvas.setLayoutParams(new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT));\n\t\tcanvas.setDelegateTouchEvents(false); // Do not delegate\n\t\t\n\t\tdeckAdapter.setSwitched(conversation.getName(), canvas);\n\t\tswitcher.addView(canvas);\n\t\tswitcher.showNext();\n\t}\n\t\n\t/**\n\t * On key down\n\t *\n\t * XXX: As we only track the back key: Android >= 2.0 will call a method called onBackPressed()\n\t */\n\t@Override\n\tpublic boolean onKeyDown(int keyCode, KeyEvent event)\n\t{\n\t\tif (keyCode == KeyEvent.KEYCODE_BACK && event.getRepeatCount() == 0) {\n\t\t\tif (deckAdapter.isSwitched()) {\n\t\t\t\tswitcher.showNext();\n\t\t\t\tswitcher.removeView(deckAdapter.getSwitchedView());\n\t\t\t\tdeckAdapter.setSwitched(null, null);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn super.onKeyDown(keyCode, event);\n\t}\n\n\t/**\n\t * On key pressed (input line)\n\t */\n\tpublic boolean onKey(View view, int keyCode, KeyEvent event)\n\t{\n\t\tif (keyCode == KeyEvent.KEYCODE_DPAD_UP && event.getAction() == KeyEvent.ACTION_UP) {\n\t\t\t// XXX: History up (Implement me..)\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tif (keyCode == KeyEvent.KEYCODE_DPAD_DOWN && event.getAction() == KeyEvent.ACTION_UP) {\n\t\t\t// XXX: History down (Implement me..)\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tif (keyCode == KeyEvent.KEYCODE_ENTER && event.getAction() == KeyEvent.ACTION_UP) {\n\t\t\tif (!server.isConnected()) {\n\t\t\t\tMessage message = new Message(\"Not connected\");\n\t\t\t\tmessage.setColor(Message.COLOR_RED);\n\t\t\t\tmessage.setIcon(R.drawable.error);\n\t\t\t\tserver.getConversation(server.getSelectedConversation()).addMessage(message);\n\t\t\t\tonConversationMessage(server.getSelectedConversation());\n\t\t\t}\n\t\t\t\n\t\t\tEditText input = (EditText) view;\n\t\t\tString text = input.getText().toString();\n\t\t\tinput.setText(\"\");\n\t\t\t\n\t\t\tif (text == \"\") {\n\t\t\t\t// ignore empty messages\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\tConversation conversation = deckAdapter.getItem(deck.getSelectedItemPosition());\n\t\t\t\n\t\t\tif (conversation != null) {\n\t\t\t\tif (!text.trim().startsWith(\"/\")) {\n\t\t\t\t\tif (conversation.getType() != Conversation.TYPE_SERVER) {\n\t\t\t\t\t\tString nickname = binder.getService().getConnection(serverId).getNick();\n\t\t\t\t\t\tconversation.addMessage(new Message(\"<\" + nickname + \"> \" + text));\n\t\t\t\t\t\tbinder.getService().getConnection(serverId).sendMessage(conversation.getName(), text);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tMessage message = new Message(\"You can only chat from within a channel or a query\");\n\t\t\t\t\t\tmessage.setColor(Message.COLOR_YELLOW);\n\t\t\t\t\t\tmessage.setIcon(R.drawable.warning);\n\t\t\t\t\t\tconversation.addMessage(message);\n\t\t\t\t\t}\n\t\t\t\t\tonConversationMessage(conversation.getName());\n\t\t\t\t} else {\n\t\t\t\t\tCommandParser.getInstance().parse(text, server, conversation, binder.getService());\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * On activity result\n\t */\n\t@Override\n\tprotected void onActivityResult(int requestCode, int resultCode, Intent data)\n\t{\n\t\t// currently there's only the \"join channel\" activity\n\t\tif (resultCode == RESULT_OK) {\n\t\t\tfinal String channel = data.getExtras().getString(\"channel\");\n\t\t\t\n\t\t\t// run on own thread\n\t\t\tnew Thread() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tbinder.getService().getConnection(serverId).joinChannel(channel);\n\t\t\t\t}\n\t\t\t}.start();\n\t\t}\n\t}\n\n\t/**\n\t * On channel selected/focused\n\t */\n\tpublic void onItemSelected(AdapterView<?> deck, View view, int position, long id)\n\t{\n\t\tConversation conversation = (Conversation) deck.getItemAtPosition(position);\n\t\t\n\t\tif (conversation != null && conversation.getType() != Conversation.TYPE_SERVER) {\n\t\t\t((TextView) findViewById(R.id.title)).setText(server.getTitle() + \" - \" + conversation.getName());\n\t\t} else {\n\t\t\tonNothingSelected(deck);\n\t\t}\n\t\t\n\t\t// Remember selection\n\t\tif (conversation != null) {\n\t\t\tserver.setSelectedConversation(conversation.getName());\n\t\t}\n\t}\n\n\t/**\n\t * On no channel selected/focused\n\t */\n\tpublic void onNothingSelected(AdapterView<?> deck)\n\t{\n\t\t((TextView) findViewById(R.id.title)).setText(server.getTitle());\n\t}\n}\n","Method after Refactoring":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2010 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.activity;\n\nimport java.util.Collection;\n\nimport android.app.Activity;\nimport android.content.ComponentName;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.os.Bundle;\nimport android.os.IBinder;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.View.OnKeyListener;\nimport android.widget.AdapterView;\nimport android.widget.EditText;\nimport android.widget.Gallery;\nimport android.widget.ImageView;\nimport android.widget.ListView;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport android.widget.ViewSwitcher;\nimport android.widget.AdapterView.OnItemClickListener;\nimport android.widget.AdapterView.OnItemSelectedListener;\nimport android.widget.TableLayout.LayoutParams;\n\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.adapter.DeckAdapter;\nimport org.yaaic.adapter.MessageListAdapter;\nimport org.yaaic.command.CommandParser;\nimport org.yaaic.irc.IRCBinder;\nimport org.yaaic.irc.IRCService;\nimport org.yaaic.layout.NonScalingBackgroundDrawable;\nimport org.yaaic.listener.ConversationListener;\nimport org.yaaic.listener.ServerListener;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.model.Extra;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.Status;\nimport org.yaaic.receiver.ConversationReceiver;\nimport org.yaaic.receiver.ServerReceiver;\nimport org.yaaic.view.MessageListView;\n\n/**\n * The server view with a scrollable list of all channels\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class ConversationActivity extends Activity implements ServiceConnection, ServerListener, ConversationListener, OnItemClickListener, OnKeyListener, OnItemSelectedListener\n{\n\tprivate int serverId;\n\tprivate Server server;\n\tprivate IRCBinder binder;\n\tprivate ConversationReceiver channelReceiver;\n\tprivate ServerReceiver serverReceiver;\n\t\n\tprivate ViewSwitcher switcher;\n\tprivate Gallery deck;\n\tprivate DeckAdapter deckAdapter;\n\t\n\t/**\n\t * On create\n\t */\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState)\n\t{\n\t\tsuper.onCreate(savedInstanceState);\n\t\t\n\t\tserverId = getIntent().getExtras().getInt(\"serverId\");\n\t\tserver = (Server) Yaaic.getInstance().getServerById(serverId);\n\t\tsetTitle(\"Yaaic - \" + server.getTitle());\n\t\t\n\t\tsetContentView(R.layout.conversations);\n\t\t\n\t\t((TextView) findViewById(R.id.title)).setText(server.getTitle());\n\t\t((EditText) findViewById(R.id.input)).setOnKeyListener(this);\n\t\t\n        deckAdapter = new DeckAdapter();\n\t\tdeck = (Gallery) findViewById(R.id.deck);\n\t\tdeck.setOnItemSelectedListener(this);\n\t\tdeck.setAdapter(deckAdapter);\n\t\tdeck.setOnItemClickListener(this);\n\t\tdeck.setBackgroundDrawable(new NonScalingBackgroundDrawable(this, deck, R.drawable.background));\n\n\t\tswitcher = (ViewSwitcher) findViewById(R.id.switcher);\n\t\t\n\t\t// Optimization : cache field lookups \n\t\tCollection<Conversation> mConversations = server.getConversations();\n\t\t\n\t\tfor (Conversation conversation : mConversations) {\n\t\t\tonNewConversation(conversation.getName());\n\t\t}\n\t}\n\t\n\t/**\n\t * On resume\n\t */\n\t@Override\n\tpublic void onResume()\n\t{\n\t\tsuper.onResume();\n\t\t\n\t\t((ImageView) findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\t\t\n\t\t// Start service\n        Intent intent = new Intent(this, IRCService.class);\n        intent.setAction(IRCService.ACTION_FOREGROUND);\n        startService(intent);\n        bindService(intent, this, 0);\n        \n    \tchannelReceiver = new ConversationReceiver(server.getId(), this);\n    \tregisterReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_MESSAGE));\n    \tregisterReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_NEW));\n    \tregisterReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_REMOVE));\n\n    \tserverReceiver = new ServerReceiver(this);\n    \tregisterReceiver(serverReceiver, new IntentFilter(Broadcast.SERVER_UPDATE));\n\n\t\tif (!server.isConnected()) {\n\t\t\t ((EditText) findViewById(R.id.input)).setEnabled(false);\n\t\t} else {\n\t\t\t ((EditText) findViewById(R.id.input)).setEnabled(true);\n\t\t}\n\n\t\t// Optimization - cache field lookup\n\t\tCollection<Conversation> mConversations = server.getConversations();\n\t\tMessageListAdapter mAdapter;\n\t\t\n\t\t// Fill view with messages that have been buffered while paused\n\t\tfor (Conversation conversation : mConversations) {\n\t\t\tmAdapter = conversation.getMessageListAdapter();\n\t\t\t\n\t\t\tif (mAdapter != null) {\n\t\t\t\tmAdapter.addBulkMessages(conversation.getBuffer());\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * On Pause\n\t */\n\t@Override\n\tpublic void onPause()\n\t{\n\t\tsuper.onPause();\n\t\t\n\t\tif (binder != null && binder.getService() != null) {\n\t\t\tbinder.getService().checkServiceStatus();\n\t\t}\n\t\t\n\t\t/*if (!binder.getService().hasConnections()) {\n\t\t\tLog.d(\"Yaaic\", \"Stopping service\");\n\t\t\t//binder.getService().stopSelf();\n\t\t} else {\n\t\t\tLog.d(\"Yaaic\", \"Unbinding service\");\n\t\t}*/\n\n\t\tunbindService(this);\n\t\tunregisterReceiver(channelReceiver);\n\t\tunregisterReceiver(serverReceiver);\n\t}\n\n\t/**\n\t * On service connected\n\t */\n\tpublic void onServiceConnected(ComponentName name, IBinder service)\n\t{\n\t\tthis.binder = (IRCBinder) service;\n\t\t\n\t\t// connect to irc server if connect has been requested\n\t\tif (server.getStatus() == Status.PRE_CONNECTING && getIntent().hasExtra(\"connect\")) {\n\t\t\tserver.setStatus(Status.CONNECTING);\n\t\t\tbinder.connect(server);\n\t\t}\n\t}\n\n\t/**\n\t * On service disconnected\n\t */\n\tpublic void onServiceDisconnected(ComponentName name)\n\t{\n\t\tthis.binder = null;\n\t}\n\n\t/**\n\t * On options menu requested\n\t */\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu)\n\t{\n    \tsuper.onCreateOptionsMenu(menu);\n    \t\n    \t// inflate from xml\n    \tMenuInflater inflater = getMenuInflater();\n    \tinflater.inflate(R.menu.conversations, menu);\n    \t\n    \treturn true;\n\t}\n\n\t/**\n\t * On menu item selected\n\t */\n\t@Override\n\tpublic boolean onMenuItemSelected(int featureId, MenuItem item)\n\t{\n\t\tswitch (item.getItemId()) {\n\t\t\tcase R.id.disconnect:\n\t\t\t\tbinder.getService().getConnection(serverId).quitServer();\n\t\t\t\tserver.setStatus(Status.DISCONNECTED);\n\t\t\t\tserver.clearConversations();\n\t\t\t\tsetResult(RESULT_OK);\n\t\t\t\tfinish();\n\t\t\t\tbreak;\n\t\t\tcase R.id.close:\n\t\t\t\tConversation conversationToClose = deckAdapter.getItem(deck.getSelectedItemPosition());\n\t\t\t\tif (conversationToClose.getType() != Conversation.TYPE_SERVER) {\n\t\t\t\t\tonRemoveConversation(conversationToClose.getName());\n\t\t\t\t} else {\n\t\t\t\t\tToast.makeText(this, \"You can not close the server info window\", Toast.LENGTH_SHORT).show();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase R.id.join:\n\t\t\t\tstartActivityForResult(new Intent(this, JoinActivity.class), 0);\n\t\t\t\tbreak;\n\t\t\tcase R.id.users:\n\t\t\t\tConversation conversationForUserList = deckAdapter.getItem(deck.getSelectedItemPosition());\n\t\t\t\tif (conversationForUserList.getType() == Conversation.TYPE_CHANNEL) {\n\t\t\t\t\tIntent intent = new Intent(this, UsersActivity.class);\n\t\t\t\t\tintent.putExtra(\n\t\t\t\t\t\tExtra.USERS,\n\t\t\t\t\t\tbinder.getService().getConnection(server.getId()).getUsersAsStringArray(\n\t\t\t\t\t\t\tconversationForUserList.getName()\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t\tstartActivity(intent);\n\t\t\t\t} else {\n\t\t\t\t\tToast.makeText(this, \"Only usable from within a channel\", Toast.LENGTH_SHORT).show();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\t/**\n\t * Get server object assigned to this activity\n\t * \n\t * @return the server object\n\t */\n\tpublic Server getServer()\n\t{\n\t\treturn server;\n\t}\n\n\t/**\n\t * On conversation message\n\t */\n\tpublic void onConversationMessage(String target)\n\t{\n\t\tConversation conversation = server.getConversation(target);\n\t\tMessageListAdapter adapter = conversation.getMessageListAdapter();\n\t\t\n\t\twhile(conversation.hasBufferedMessages()) {\n\t\t\tMessage message = conversation.pollBufferedMessage();\n\t\t\t\n\t\t\tif (adapter != null) {\n\t\t\t\tadapter.addMessage(message);\n\t\t\t} else {\n\t\t\t\t//\"MessageListAdapter is null (conversation \" + conversation.getName() + \" has no adapter assigned)\"\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * On new conversation\n\t */\n\tpublic void onNewConversation(String target)\n\t{\n\t\tdeckAdapter.addItem(server.getConversation(target));\n\t\t\n\t\tif (!deckAdapter.isSwitched()) {\n\t\t\t// Scroll to new conversation\n\t\t\tdeck.setSelection(deckAdapter.getCount() - 1);\n\t\t}\n\t}\n\t\n\t/**\n\t * On conversation remove\n\t */\n\tpublic void onRemoveConversation(String target)\n\t{\n\t\tdeckAdapter.removeItem(target);\n\t\t\n\t\tif (deckAdapter.isSwitched()) {\n\t\t\tswitcher.showNext();\n\t\t\tswitcher.removeView(deckAdapter.getSwitchedView());\n\t\t\tdeckAdapter.setSwitched(null, null);\n\t\t}\n\t}\n\n\t/**\n\t * On server status update\n\t */\n\tpublic void onStatusUpdate()\n\t{\n\t\t((ImageView) findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\t\t\n\t\tEditText input = (EditText) findViewById(R.id.input);\n\t\tif (server.isConnected()) {\n\t\t\tinput.setEnabled(true); \n\t\t} else {\n\t\t\tinput.setEnabled(false);\n\t\t}\n\t}\n\n\t/**\n\t * On conversation item clicked\n\t */\n\tpublic void onItemClick(AdapterView<?> adapterView, View view, int position, long id)\n\t{\n\t\tConversation conversation = deckAdapter.getItem(position);\n\t\t\n\t\tMessageListView canvas = deckAdapter.renderConversation(conversation, switcher);\n\t\tcanvas.setTranscriptMode(ListView.TRANSCRIPT_MODE_NORMAL);\n\t\tcanvas.setLayoutParams(new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT));\n\t\tcanvas.setDelegateTouchEvents(false); // Do not delegate\n\t\t\n\t\tdeckAdapter.setSwitched(conversation.getName(), canvas);\n\t\tswitcher.addView(canvas);\n\t\tswitcher.showNext();\n\t}\n\t\n\t/**\n\t * On key down\n\t *\n\t * XXX: As we only track the back key: Android >= 2.0 will call a method called onBackPressed()\n\t */\n\t@Override\n\tpublic boolean onKeyDown(int keyCode, KeyEvent event)\n\t{\n\t\tif (keyCode == KeyEvent.KEYCODE_BACK && event.getRepeatCount() == 0) {\n\t\t\tif (deckAdapter.isSwitched()) {\n\t\t\t\tswitcher.showNext();\n\t\t\t\tswitcher.removeView(deckAdapter.getSwitchedView());\n\t\t\t\tdeckAdapter.setSwitched(null, null);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn super.onKeyDown(keyCode, event);\n\t}\n\n\t/**\n\t * On key pressed (input line)\n\t */\n\tpublic boolean onKey(View view, int keyCode, KeyEvent event)\n\t{\n\t\tif (keyCode == KeyEvent.KEYCODE_DPAD_UP && event.getAction() == KeyEvent.ACTION_UP) {\n\t\t\t// XXX: History up (Implement me..)\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tif (keyCode == KeyEvent.KEYCODE_DPAD_DOWN && event.getAction() == KeyEvent.ACTION_UP) {\n\t\t\t// XXX: History down (Implement me..)\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tif (keyCode == KeyEvent.KEYCODE_ENTER && event.getAction() == KeyEvent.ACTION_UP) {\n\t\t\tif (!server.isConnected()) {\n\t\t\t\tMessage message = new Message(\"Not connected\");\n\t\t\t\tmessage.setColor(Message.COLOR_RED);\n\t\t\t\tmessage.setIcon(R.drawable.error);\n\t\t\t\tserver.getConversation(server.getSelectedConversation()).addMessage(message);\n\t\t\t\tonConversationMessage(server.getSelectedConversation());\n\t\t\t}\n\t\t\t\n\t\t\tEditText input = (EditText) view;\n\t\t\tString text = input.getText().toString();\n\t\t\tinput.setText(\"\");\n\t\t\t\n\t\t\tif (text == \"\") {\n\t\t\t\t// ignore empty messages\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\tConversation conversation = deckAdapter.getItem(deck.getSelectedItemPosition());\n\t\t\t\n\t\t\tif (conversation != null) {\n\t\t\t\tif (!text.trim().startsWith(\"/\")) {\n\t\t\t\t\tif (conversation.getType() != Conversation.TYPE_SERVER) {\n\t\t\t\t\t\tString nickname = binder.getService().getConnection(serverId).getNick();\n\t\t\t\t\t\tconversation.addMessage(new Message(\"<\" + nickname + \"> \" + text));\n\t\t\t\t\t\tbinder.getService().getConnection(serverId).sendMessage(conversation.getName(), text);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tMessage message = new Message(\"You can only chat from within a channel or a query\");\n\t\t\t\t\t\tmessage.setColor(Message.COLOR_YELLOW);\n\t\t\t\t\t\tmessage.setIcon(R.drawable.warning);\n\t\t\t\t\t\tconversation.addMessage(message);\n\t\t\t\t\t}\n\t\t\t\t\tonConversationMessage(conversation.getName());\n\t\t\t\t} else {\n\t\t\t\t\tCommandParser.getInstance().parse(text, server, conversation, binder.getService());\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * On activity result\n\t */\n\t@Override\n\tprotected void onActivityResult(int requestCode, int resultCode, Intent data)\n\t{\n\t\t// currently there's only the \"join channel\" activity\n\t\tif (resultCode == RESULT_OK) {\n\t\t\tfinal String channel = data.getExtras().getString(\"channel\");\n\t\t\t\n\t\t\t// run on own thread\n\t\t\tnew Thread() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tbinder.getService().getConnection(serverId).joinChannel(channel);\n\t\t\t\t}\n\t\t\t}.start();\n\t\t}\n\t}\n\n\t/**\n\t * On channel selected/focused\n\t */\n\tpublic void onItemSelected(AdapterView<?> deck, View view, int position, long id)\n\t{\n\t\tConversation conversation = (Conversation) deck.getItemAtPosition(position);\n\t\t\n\t\tif (conversation != null && conversation.getType() != Conversation.TYPE_SERVER) {\n\t\t\t((TextView) findViewById(R.id.title)).setText(server.getTitle() + \" - \" + conversation.getName());\n\t\t} else {\n\t\t\tonNothingSelected(deck);\n\t\t}\n\t\t\n\t\t// Remember selection\n\t\tif (conversation != null) {\n\t\t\tserver.setSelectedConversation(conversation.getName());\n\t\t}\n\t}\n\n\t/**\n\t * On no channel selected/focused\n\t */\n\tpublic void onNothingSelected(AdapterView<?> deck)\n\t{\n\t\t((TextView) findViewById(R.id.title)).setText(server.getTitle());\n\t}\n}\n","lineNo":254}
{"Smelly Sample":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2010 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.irc;\n\nimport java.io.UnsupportedEncodingException;\nimport java.util.Vector;\n\nimport android.content.Intent;\n\nimport org.jibble.pircbot.Colors;\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\n\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Query;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.ServerInfo;\nimport org.yaaic.model.Status;\n\n/**\n * The class that actually handles the connection to an IRC server\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class IRCConnection extends PircBot\n{\n\tprivate IRCService service;\n\tprivate Server server;\n\t\n\t/**\n\t * Create a new connection\n\t * \n\t * @param service\n\t * @param serverId\n\t */\n\tpublic IRCConnection(IRCService service, int serverId)\n\t{\n\t\tthis.server = Yaaic.getInstance().getServerById(serverId);\n\t\tthis.service = service;\n\t\t\n\t\t// XXX: Should be configurable via settings\n\t\tthis.setAutoNickChange(true);\n\t\t\n\t\ttry {\n\t\t\tthis.setEncoding(\"UTF-8\");\n\t\t} catch(UnsupportedEncodingException e) {\n\t\t\t// Use default charset\n\t\t}\n\t\t\n\t\tthis.setFinger(\"http://www.youtube.com/watch?v=oHg5SJYRHA0\");\n\t}\n\t\n\t/**\n\t * Set the nickname of the user\n\t * \n\t * @param nickname The nickname to use\n\t */\n\tpublic void setNickname(String nickname)\n\t{\n\t\tthis.setName(nickname);\n\t}\n\t\n\t/**\n\t * Set the real name of the user\n\t * \n\t * @param realname The realname to use\n\t */\n\tpublic void setRealName(String realname)\n\t{\n\t\t// XXX: Pircbot uses the version for \"real name\" and \"version\".\n\t\t//      The real \"version\" value is provided by onVersion() \n\t\tthis.setVersion(realname);\n\t}\n\n\t/**\n\t * On version (CTCP version)\n\t * \n\t * This is a fix for pircbot as pircbot uses the version as \"real name\" and as \"version\"\n\t */\n\t@Override\n\tprotected void onVersion(String sourceNick, String sourceLogin,\tString sourceHostname, String target)\n\t{\n\t\tthis.sendRawLine(\n\t\t\t\t\"NOTICE \" + sourceNick + \" :\\u0001VERSION \" +\n\t\t\t\t\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\" +\n\t\t\t\t\"\\u0001\"\n\t\t);\n\t}\n\n\t/**\n\t * Set the ident of the user\n\t * \n\t * @param ident The ident to use\n\t */\n\tpublic void setIdent(String ident)\n\t{\n\t\tthis.setLogin(ident);\n\t}\n\n\t/**\n\t * On connect\n\t */\n\t@Override\n\tpublic void onConnect()\n\t{\n\t\tserver.setStatus(Status.CONNECTED);\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t\t\n\t\tMessage message = new Message(\"Connected to \" + server.getTitle());\n\t\tmessage.setColor(Message.COLOR_GREEN);\n\t\tserver.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\t\t\n\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\tserver.getId(),\n\t\t\tServerInfo.DEFAULT_NAME\n\t\t);\n\t\t\n\t\tservice.sendBroadcast(intent);\n\t}\n\t\n\t/**\n\t * On channel action\n\t */\n\t@Override\n\tprotected void onAction(String sender, String login, String hostname, String target, String action)\n\t{\n\t\t// Strip mIRC colors and formatting\n\t\taction = Colors.removeFormattingAndColors(action);\n\n\t\tMessage message = new Message(sender + \" \" + action);\n\t\tmessage.setIcon(R.drawable.action);\n\t\t\n\t\tif (action.contains(getNick())) {\n\t\t\t// highlight\n\t\t\tmessage.setColor(Message.COLOR_RED);\n\t\t}\n\t\t\n\t\tif (target.equals(this.getNick())) {\n\t\t\t// We are the target - this is an action in a query\n\t\t\tConversation conversation = server.getConversation(sender); \n\t\t\tif (conversation == null) { \n\t\t\t\t// Open a query if there's none yet\n\t\t\t\tconversation = new Query(sender);\n\t\t\t\tserver.addConversationl(conversation);\n\t\t\t\tconversation.addMessage(message);\n\n\t\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\t\tBroadcast.CONVERSATION_NEW,\n\t\t\t\t\tserver.getId(),\n\t\t\t\t\tsender\n\t\t\t\t);\n\t\t\t\tservice.sendBroadcast(intent);\n\t\t\t} else {\n\t\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\t\t\tserver.getId(),\n\t\t\t\t\tsender\n\t\t\t\t);\n\t\t\t\tservice.sendBroadcast(intent);\n\t\t\t}\n\t\t} else {\n\t\t\t// A action in a channel\n\t\t\tserver.getConversation(target).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\t\tserver.getId(),\n\t\t\t\ttarget\n\t\t\t);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Channel Info\n\t */\n\t@Override\n\tprotected void onChannelInfo(String channel, int userCount, String topic)\n\t{\n\t}\n\n\t/**\n\t * On Deop\n\t */\n\t@Override\n\tprotected void onDeop(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tMessage message = new Message(sourceNick + \" deops \" + recipient);\n\t\tmessage.setIcon(R.drawable.op);\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\tserver.getId(),\n\t\t\ttarget\n\t\t);\n\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On DeVoice\n\t */\n\t@Override\n\tprotected void onDeVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tMessage message = new Message(sourceNick + \" devoices \" + recipient);\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tmessage.setIcon(R.drawable.voice);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\tserver.getId(),\n\t\t\ttarget\n\t\t);\n\t\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Invite\n\t */\n\t@Override\n\tprotected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String target)\n\t{\n\t\tif (targetNick.equals(this.getNick())) {\n\t\t\t// We are invited\n\t\t\tMessage message = new Message(sourceNick + \" invites you into \" + target);\n\t\t\tserver.getConversation(server.getSelectedConversation()).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\t\tserver.getId(),\n\t\t\t\tserver.getSelectedConversation()\n\t\t\t);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\t// Someone is invited\n\t\t\tMessage message = new Message(sourceNick + \" invites \" + targetNick + \" into \" + target);\n\t\t\tserver.getConversation(target).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\t\tserver.getId(),\n\t\t\t\ttarget\n\t\t\t);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Join\n\t */\n\t@Override\n\tprotected void onJoin(String target, String sender, String login, String hostname)\n\t{\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We joined a new channel\n\t\t\tserver.addConversationl(new Channel(target));\n\t\t\t\n\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\tBroadcast.CONVERSATION_NEW,\n\t\t\t\tserver.getId(),\n\t\t\t\ttarget\n\t\t\t);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tMessage message = new Message(sender + \" joins\");\n\t\t\tmessage.setIcon(R.drawable.join);\n\t\t\tmessage.setColor(Message.COLOR_GREEN);\n\t\t\tserver.getConversation(target).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\t\tserver.getId(),\n\t\t\t\ttarget\n\t\t\t);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Kick\n\t */\n\t@Override\n\tprotected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n\t{\n\t\tif (recipientNick.equals(getNick())) {\n\t\t\t// We are kicked\n\t\t\tserver.removeConversation(target);\n\t\t\t\n\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\tBroadcast.CONVERSATION_REMOVE,\n\t\t\t\tserver.getId(),\n\t\t\t\ttarget\n\t\t\t);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tMessage message = new Message(kickerNick + \" kicks \" + recipientNick);\n\t\t\tmessage.setColor(Message.COLOR_GREEN);\n\t\t\tserver.getConversation(target).addMessage(message);\n\n\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\t\tserver.getId(),\n\t\t\t\ttarget\n\t\t\t);\n\t\t\tservice.sendBroadcast(intent);\t\t\t\n\t\t}\n\t}\n\n\t/**\n\t * On Message\n\t */\n\t@Override\n\tprotected void onMessage(String target, String sender, String login, String hostname, String text)\n\t{\n\t\t// Strip mIRC colors and formatting\n\t\ttext = Colors.removeFormattingAndColors(text);\n\n\t\tMessage message = new Message(\"<\" + sender + \"> \" + text);\n\t\t\n\t\tif (text.contains(getNick())) {\n\t\t\t// highlight\n\t\t\tmessage.setColor(Message.COLOR_RED);\n\t\t}\n\t\t\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\tserver.getId(),\n\t\t\ttarget\n\t\t);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Mode\n\t */\n\t@Override\n\tprotected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n\t{\n\t\t/*//Disabled as it doubles events (e.g. onOp and onMode will be called)\n\t\tMessage message = new Message(sourceNick + \" sets mode \" + mode);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t\t*/\n\t}\n\n\t/**\n\t * On Nick Change\n\t */\n\t@Override\n\tprotected void onNickChange(String oldNick, String login, String hostname, String newNick)\n\t{\n\t\t// XXX: Optimization : No getter in for loop\n\t\tfor (String target : getChannelsByNickname(newNick)) {\n\t\t\tMessage message = new Message(oldNick + \" is now known as \" + newNick);\n\t\t\tmessage.setColor(Message.COLOR_GREEN);\n\t\t\tserver.getConversation(target).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\t\tserver.getId(),\n\t\t\t\ttarget\n\t\t\t);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Notice\n\t */\n\t@Override\n\tprotected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n\t{\n\t\t// Strip mIRC colors and formatting\n\t\tnotice = Colors.removeFormattingAndColors(notice);\n\t\t\n\t\t// Post notice to currently selected conversation\n\t\tConversation conversation = server.getConversation(server.getSelectedConversation());\n\t\t\n\t\tif (conversation == null) {\n\t\t\t// Fallback: Use ServerInfo view\n\t\t\tconversation = server.getConversation(ServerInfo.DEFAULT_NAME);\n\t\t}\n\n\t\tMessage message = new Message(\"-\" + sourceNick + \"- \" + notice);\n\t\tmessage.setIcon(R.drawable.info);\n\t\tconversation.addMessage(message);\n\t\t\n\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\tserver.getId(),\n\t\t\tconversation.getName()\n\t\t);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Op\n\t */\n\t@Override\n\tprotected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tMessage message = new Message(sourceNick + \" ops \" + recipient);\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tmessage.setIcon(R.drawable.op);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\tserver.getId(),\n\t\t\ttarget\n\t\t);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Part\n\t */\n\t@Override\n\tprotected void onPart(String target, String sender, String login, String hostname)\n\t{\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We parted a channel\n\t\t\tserver.removeConversation(target);\n\t\t\t\n\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\tBroadcast.CONVERSATION_REMOVE,\n\t\t\t\tserver.getId(),\n\t\t\t\ttarget\n\t\t\t);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tMessage message = new Message(sender + \" parts\");\n\t\t\tmessage.setColor(Message.COLOR_GREEN);\n\t\t\tmessage.setIcon(R.drawable.part);\n\t\t\tserver.getConversation(target).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\t\tserver.getId(),\n\t\t\t\ttarget\n\t\t\t);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Private Message\n\t */\n\t@Override\n\tprotected void onPrivateMessage(String sender, String login, String hostname, String text)\n\t{\n\t\t// Strip mIRC colors and formatting\n\t\ttext = Colors.removeFormattingAndColors(text);\n\n\t\tMessage message = new Message(\"<\" + sender + \"> \" + text);\n\t\t\n\t\tif (text.contains(getNick())) {\n\t\t\tmessage.setColor(Message.COLOR_RED);\n\t\t}\n\n\t\tConversation conversation = server.getConversation(sender);\n\n\t\tif (conversation == null) { \n\t\t\t// Open a query if there's none yet\n\t\t\tconversation = new Query(sender);\n\t\t\tconversation.addMessage(message);\n\t\t\tserver.addConversationl(conversation);\n\t\t\t\n\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\tBroadcast.CONVERSATION_NEW,\n\t\t\t\tserver.getId(),\n\t\t\t\tsender\n\t\t\t);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tconversation.addMessage(message);\n\t\t\t\n\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\t\tserver.getId(),\n\t\t\t\tsender\n\t\t\t);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Quit\n\t */\n\t@Override\n\tprotected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n\t{\n\t\tif (!sourceNick.equals(this.getNick())) {\n\t\t\t// XXX: Optimization : No getter in for loop\n\t\t\tfor (String target : getChannelsByNickname(sourceNick)) {\n\t\t\t\tMessage message = new Message(sourceNick + \" quits (\" + reason + \")\");\n\t\t\t\tmessage.setColor(Message.COLOR_GREEN);\n\t\t\t\tmessage.setIcon(R.drawable.quit);\n\t\t\t\tserver.getConversation(target).addMessage(message);\n\t\t\t\t\n\t\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\t\t\tserver.getId(),\n\t\t\t\t\ttarget\n\t\t\t\t);\n\t\t\t\tservice.sendBroadcast(intent);\n\t\t\t}\n\t\t\t\n\t\t\t// Look if there's a query to update\n\t\t\tConversation conversation = server.getConversation(sourceNick);\n\t\t\t\n\t\t\tif (conversation != null) {\n\t\t\t\tMessage message = new Message(sourceNick + \" quits (\" + reason + \")\");\n\t\t\t\tmessage.setColor(Message.COLOR_GREEN);\n\t\t\t\tmessage.setIcon(R.drawable.quit);\n\t\t\t\tconversation.addMessage(message);\n\t\t\t\t\n\t\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\t\t\tserver.getId(),\n\t\t\t\t\tconversation.getName()\n\t\t\t\t);\n\t\t\t\tservice.sendBroadcast(intent);\n\t\t\t}\n\t\t\t\n\t\t} else {\n\t\t\t// XXX: We quitted\n\t\t}\n\t}\n\n\t/**\n\t * On Topic\n\t */\n\t@Override\n\tpublic void onTopic(String target, String topic, String setBy, long date, boolean changed)\n\t{\n\t\t// strip mIRC colors\n\t\ttopic = Colors.removeFormattingAndColors(topic);\n\t\t\n\t\tif (changed) {\n\t\t\tMessage message = new Message(setBy + \" sets topic: \" + topic);\n\t\t\tmessage.setColor(Message.COLOR_YELLOW);\n\t\t\tserver.getConversation(target).addMessage(message);\n\t\t} else {\n\t\t\tMessage message = new Message(\"Topic: \" + topic);\n\t\t\tmessage.setColor(Message.COLOR_YELLOW);\n\t\t\tserver.getConversation(target).addMessage(message);\n\t\t}\n\t\t\n\t\t// remember channel's topic\n\t\t((Channel) server.getConversation(target)).setTopic(topic);\n\t\t\n\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\tserver.getId(),\n\t\t\ttarget\n\t\t);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On User List\n\t */\n\t@Override\n\tprotected void onUserList(String channel, User[] users)\n\t{\n\t\t// XXX: Store user list somewhere and keep it updated or just broadcast some event?\n\t}\n\n\t/**\n\t * On Voice\n\t */\n\t@Override\n\tprotected void onVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tMessage message = new Message(sourceNick + \" voices \" + recipient);\n\t\tmessage.setIcon(R.drawable.voice);\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\tserver.getId(),\n\t\t\ttarget\n\t\t);\n\t\tservice.sendBroadcast(intent);\n\t}\n\t\n\t/**\n\t * On remove channel key\t\n\t */\n\t@Override\n\tprotected void onRemoveChannelKey(String target, String sourceNick, String sourceLogin, String sourceHostname, String key)\n\t{\n\t\tMessage message = new Message(sourceNick + \" removes channel key\");\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\n\t/**\n\t * On set channel key\n\t */\n\t@Override\n\tprotected void onSetChannelKey(String target, String sourceNick, String sourceLogin, String sourceHostname, String key)\n\t{\n\t\tMessage message = new Message(sourceNick + \" sets channel key: \" + key);\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\t\n\t/**\n\t * On set secret\n\t */\n\t@Override\n\tprotected void onSetSecret(String target, String sourceNick, String sourceLogin, String sourceHostname)\n\t{\n\t\tMessage message = new Message(sourceNick + \" sets channel secret\");\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\t\n\t/**\n\t * On remove secret\n\t */\n\t@Override\n\tprotected void onRemoveSecret(String target, String sourceNick, String sourceLogin, String sourceHostname)\n\t{\n\t\tMessage message = new Message(sourceNick + \" sets channel public\");\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\t\n\t/**\n\t * On set channel limit\n\t */\n\t@Override\n\tprotected void onSetChannelLimit(String target, String sourceNick, String sourceLogin, String sourceHostname, int limit)\n\t{\n\t\tMessage message = new Message(sourceNick + \" sets limit: \" + limit);\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\t\n\t/**\n\t * On remove channel limit\n\t */\n\t@Override\n\tprotected void onRemoveChannelLimit(String target, String sourceNick, String sourceLogin, String sourceHostname)\n\t{\n\t\tMessage message = new Message(sourceNick + \" removes limit\");\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\n\t/**\n\t * On set channel ban\n\t */\n\t@Override\n\tprotected void onSetChannelBan(String target, String sourceNick, String sourceLogin, String sourceHostname, String hostmask)\n\t{\n\t\tMessage message = new Message(sourceNick + \" sets ban: \" + hostmask);\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\t\n\t/**\n\t * On remove channel ban\n\t */\n\t@Override\n\tprotected void onRemoveChannelBan(String target, String sourceNick, String sourceLogin, String sourceHostname, String hostmask)\n\t{\n\t\tMessage message = new Message(sourceNick + \" removes ban: \" + hostmask);\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\t\n\t/**\n\t * On set topic protection\n\t */\n\t@Override\n\tprotected void onSetTopicProtection(String target, String sourceNick, String sourceLogin, String sourceHostname)\n\t{\n\t\tMessage message = new Message(sourceNick + \" sets topic protection\");\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\t\n\t/**\n\t * On remove topic protection\n\t */\n\t@Override\n\tprotected void onRemoveTopicProtection(String target, String sourceNick, String sourceLogin, String sourceHostname)\n\t{\n\t\tMessage message = new Message(sourceNick + \" removes topic protection\");\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\n\t/**\n\t * On set no external messages\n\t */\n\t@Override\n\tprotected void onSetNoExternalMessages(String target, String sourceNick, String sourceLogin, String sourceHostname)\n\t{\n\t\tMessage message = new Message(sourceNick + \" disables external messages\");\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\n\t/**\n\t * On remove no external messages\n\t */\n\t@Override\n\tprotected void onRemoveNoExternalMessages(String target, String sourceNick, String sourceLogin, String sourceHostname)\n\t{\n\t\tMessage message = new Message(sourceNick + \" enables external messages\");\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\t\n\t/**\n\t * On set invite only\n\t */\n\t@Override\n\tprotected void onSetInviteOnly(String target, String sourceNick, String sourceLogin, String sourceHostname)\n\t{\n\t\tMessage message = new Message(sourceNick + \" sets invite only\");\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\t\n\t/**\n\t * On remove invite only\n\t */\n\t@Override\n\tprotected void onRemoveInviteOnly(String target, String sourceNick, String sourceLogin, String sourceHostname)\n\t{\n\t\tMessage message = new Message(sourceNick + \" removes invite only\");\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\n\t/**\n\t * On set moderated\n\t */\n\t@Override\n\tprotected void onSetModerated(String target, String sourceNick, String sourceLogin, String sourceHostname)\n\t{\n\t\tMessage message = new Message(sourceNick + \" sets moderated\");\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\t\n\t/**\n\t * On remove moderated\n\t */\n\t@Override\n\tprotected void onRemoveModerated(String target, String sourceNick, String sourceLogin, String sourceHostname)\n\t{\n\t\tMessage message = new Message(sourceNick + \" removes moderated\");\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\t\n\t/**\n\t * On set private\n\t */\n\t@Override\n\tprotected void onSetPrivate(String target, String sourceNick, String sourceLogin, String sourceHostname)\n\t{\n\t\tMessage message = new Message(sourceNick + \" sets channel private\");\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\t\n\t/**\n\t * On remove private\n\t */\n\t@Override\n\tprotected void onRemovePrivate(String target, String sourceNick, String sourceLogin, String sourceHostname)\n\t{\n\t\tMessage message = new Message(sourceNick + \" sets channel public\");\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\n\t/**\n\t * On unknown\n\t */\n\t@Override\n\tprotected void onUnknown(String line)\n\t{\n\t\tMessage message = new Message(line);\n\t\tmessage.setIcon(R.drawable.action);\n\t\tmessage.setColor(Message.COLOR_GREY);\n\t\tserver.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\t\t\n\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\tserver.getId(),\n\t\t\tServerInfo.DEFAULT_NAME\n\t\t);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On server response\n\t */\n\t@Override\n\tprotected void onServerResponse(int code, String response)\n\t{\n\t\tif (code == 372 || code == 375 || code == 376) {\n\t\t\t// Skip MOTD\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (code >= 200 && code < 300) {\n\t\t\t// Skip 2XX responses\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (code == 353 || code == 366 || code == 332 || code == 333) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (code < 10) {\n\t\t\t// Skip server info\n\t\t\treturn;\n\t\t}\n\n\t\t// Currently disabled... to much text\n\t\tMessage message = new Message(response);\n\t\tmessage.setColor(Message.COLOR_GREY);\n\t\tserver.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\t\t\n\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\tserver.getId(),\n\t\t\tServerInfo.DEFAULT_NAME\n\t\t);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On disconnect\n\t */\n\t@Override\n\tpublic void onDisconnect()\n\t{\n\t\tserver.setStatus(Status.DISCONNECTED);\n\t\t\n\t\tIntent sIntent = Broadcast.createServerIntent(Broadcast.SERVER_UPDATE, server.getId());\n\t\tservice.sendBroadcast(sIntent);\t\t\n\t\t\n\t\tMessage message = new Message(\"Disconnected\");\n\t\tmessage.setIcon(R.drawable.error);\n\t\tmessage.setColor(Message.COLOR_RED);\n\t\tserver.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\t\t\n\t\tIntent cIntent = Broadcast.createConversationIntent(\n\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\tserver.getId(),\n\t\t\tServerInfo.DEFAULT_NAME\n\t\t);\n\t\tservice.sendBroadcast(cIntent);\n\t}\n\t\n\t/**\n\t * Get all channels where the user with the given nickname is online\n\t * \n\t * @param nickname\n\t * @return Array of channel names\n\t */\n\tprivate Vector<String> getChannelsByNickname(String nickname)\n\t{\n\t\tVector<String> channels = new Vector<String>();\n\t\t\n\t\t// XXX: Optimization : No getter in for loop\n\t\tfor (String channel : this.getChannels()) {\n\t\t\t// XXX: Optimization : No getter in for loop\n\t\t\tfor (User user : this.getUsers(channel)) {\n\t\t\t\tif (user.getNick().equals(nickname)) {\n\t\t\t\t\tchannels.add(channel);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn channels;\n\t}\n\t\n\t/**\n\t * Quits from the IRC server with default reason.\n\t */\n\t@Override\n\tpublic void quitServer()\n\t{\n\t\tnew Thread() {\n\t\t\tpublic void run() {\n\t\t\t\tquitServer(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t\t\t}\n\t\t}.start();\n\t}\n}\n","Method after Refactoring":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2010 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.irc;\n\nimport java.io.UnsupportedEncodingException;\nimport java.util.Vector;\n\nimport android.content.Intent;\n\nimport org.jibble.pircbot.Colors;\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\n\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Query;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.ServerInfo;\nimport org.yaaic.model.Status;\n\n/**\n * The class that actually handles the connection to an IRC server\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class IRCConnection extends PircBot\n{\n\tprivate IRCService service;\n\tprivate Server server;\n\t\n\t/**\n\t * Create a new connection\n\t * \n\t * @param service\n\t * @param serverId\n\t */\n\tpublic IRCConnection(IRCService service, int serverId)\n\t{\n\t\tthis.server = Yaaic.getInstance().getServerById(serverId);\n\t\tthis.service = service;\n\t\t\n\t\t// XXX: Should be configurable via settings\n\t\tthis.setAutoNickChange(true);\n\t\t\n\t\ttry {\n\t\t\tthis.setEncoding(\"UTF-8\");\n\t\t} catch(UnsupportedEncodingException e) {\n\t\t\t// Use default charset\n\t\t}\n\t\t\n\t\tthis.setFinger(\"http://www.youtube.com/watch?v=oHg5SJYRHA0\");\n\t}\n\t\n\t/**\n\t * Set the nickname of the user\n\t * \n\t * @param nickname The nickname to use\n\t */\n\tpublic void setNickname(String nickname)\n\t{\n\t\tthis.setName(nickname);\n\t}\n\t\n\t/**\n\t * Set the real name of the user\n\t * \n\t * @param realname The realname to use\n\t */\n\tpublic void setRealName(String realname)\n\t{\n\t\t// XXX: Pircbot uses the version for \"real name\" and \"version\".\n\t\t//      The real \"version\" value is provided by onVersion() \n\t\tthis.setVersion(realname);\n\t}\n\n\t/**\n\t * On version (CTCP version)\n\t * \n\t * This is a fix for pircbot as pircbot uses the version as \"real name\" and as \"version\"\n\t */\n\t@Override\n\tprotected void onVersion(String sourceNick, String sourceLogin,\tString sourceHostname, String target)\n\t{\n\t\tthis.sendRawLine(\n\t\t\t\t\"NOTICE \" + sourceNick + \" :\\u0001VERSION \" +\n\t\t\t\t\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\" +\n\t\t\t\t\"\\u0001\"\n\t\t);\n\t}\n\n\t/**\n\t * Set the ident of the user\n\t * \n\t * @param ident The ident to use\n\t */\n\tpublic void setIdent(String ident)\n\t{\n\t\tthis.setLogin(ident);\n\t}\n\n\t/**\n\t * On connect\n\t */\n\t@Override\n\tpublic void onConnect()\n\t{\n\t\tserver.setStatus(Status.CONNECTED);\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t\t\n\t\tMessage message = new Message(\"Connected to \" + server.getTitle());\n\t\tmessage.setColor(Message.COLOR_GREEN);\n\t\tserver.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\t\t\n\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\tserver.getId(),\n\t\t\tServerInfo.DEFAULT_NAME\n\t\t);\n\t\t\n\t\tservice.sendBroadcast(intent);\n\t}\n\t\n\t/**\n\t * On channel action\n\t */\n\t@Override\n\tprotected void onAction(String sender, String login, String hostname, String target, String action)\n\t{\n\t\t// Strip mIRC colors and formatting\n\t\taction = Colors.removeFormattingAndColors(action);\n\n\t\tMessage message = new Message(sender + \" \" + action);\n\t\tmessage.setIcon(R.drawable.action);\n\t\t\n\t\tif (action.contains(getNick())) {\n\t\t\t// highlight\n\t\t\tmessage.setColor(Message.COLOR_RED);\n\t\t}\n\t\t\n\t\tif (target.equals(this.getNick())) {\n\t\t\t// We are the target - this is an action in a query\n\t\t\tConversation conversation = server.getConversation(sender); \n\t\t\tif (conversation == null) { \n\t\t\t\t// Open a query if there's none yet\n\t\t\t\tconversation = new Query(sender);\n\t\t\t\tserver.addConversationl(conversation);\n\t\t\t\tconversation.addMessage(message);\n\n\t\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\t\tBroadcast.CONVERSATION_NEW,\n\t\t\t\t\tserver.getId(),\n\t\t\t\t\tsender\n\t\t\t\t);\n\t\t\t\tservice.sendBroadcast(intent);\n\t\t\t} else {\n\t\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\t\t\tserver.getId(),\n\t\t\t\t\tsender\n\t\t\t\t);\n\t\t\t\tservice.sendBroadcast(intent);\n\t\t\t}\n\t\t} else {\n\t\t\t// A action in a channel\n\t\t\tserver.getConversation(target).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\t\tserver.getId(),\n\t\t\t\ttarget\n\t\t\t);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Channel Info\n\t */\n\t@Override\n\tprotected void onChannelInfo(String channel, int userCount, String topic)\n\t{\n\t}\n\n\t/**\n\t * On Deop\n\t */\n\t@Override\n\tprotected void onDeop(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tMessage message = new Message(sourceNick + \" deops \" + recipient);\n\t\tmessage.setIcon(R.drawable.op);\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\tserver.getId(),\n\t\t\ttarget\n\t\t);\n\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On DeVoice\n\t */\n\t@Override\n\tprotected void onDeVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tMessage message = new Message(sourceNick + \" devoices \" + recipient);\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tmessage.setIcon(R.drawable.voice);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\tserver.getId(),\n\t\t\ttarget\n\t\t);\n\t\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Invite\n\t */\n\t@Override\n\tprotected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String target)\n\t{\n\t\tif (targetNick.equals(this.getNick())) {\n\t\t\t// We are invited\n\t\t\tMessage message = new Message(sourceNick + \" invites you into \" + target);\n\t\t\tserver.getConversation(server.getSelectedConversation()).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\t\tserver.getId(),\n\t\t\t\tserver.getSelectedConversation()\n\t\t\t);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\t// Someone is invited\n\t\t\tMessage message = new Message(sourceNick + \" invites \" + targetNick + \" into \" + target);\n\t\t\tserver.getConversation(target).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\t\tserver.getId(),\n\t\t\t\ttarget\n\t\t\t);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Join\n\t */\n\t@Override\n\tprotected void onJoin(String target, String sender, String login, String hostname)\n\t{\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We joined a new channel\n\t\t\tserver.addConversationl(new Channel(target));\n\t\t\t\n\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\tBroadcast.CONVERSATION_NEW,\n\t\t\t\tserver.getId(),\n\t\t\t\ttarget\n\t\t\t);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tMessage message = new Message(sender + \" joins\");\n\t\t\tmessage.setIcon(R.drawable.join);\n\t\t\tmessage.setColor(Message.COLOR_GREEN);\n\t\t\tserver.getConversation(target).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\t\tserver.getId(),\n\t\t\t\ttarget\n\t\t\t);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Kick\n\t */\n\t@Override\n\tprotected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n\t{\n\t\tif (recipientNick.equals(getNick())) {\n\t\t\t// We are kicked\n\t\t\tserver.removeConversation(target);\n\t\t\t\n\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\tBroadcast.CONVERSATION_REMOVE,\n\t\t\t\tserver.getId(),\n\t\t\t\ttarget\n\t\t\t);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tMessage message = new Message(kickerNick + \" kicks \" + recipientNick);\n\t\t\tmessage.setColor(Message.COLOR_GREEN);\n\t\t\tserver.getConversation(target).addMessage(message);\n\n\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\t\tserver.getId(),\n\t\t\t\ttarget\n\t\t\t);\n\t\t\tservice.sendBroadcast(intent);\t\t\t\n\t\t}\n\t}\n\n\t/**\n\t * On Message\n\t */\n\t@Override\n\tprotected void onMessage(String target, String sender, String login, String hostname, String text)\n\t{\n\t\t// Strip mIRC colors and formatting\n\t\ttext = Colors.removeFormattingAndColors(text);\n\n\t\tMessage message = new Message(\"<\" + sender + \"> \" + text);\n\t\t\n\t\tif (text.contains(getNick())) {\n\t\t\t// highlight\n\t\t\tmessage.setColor(Message.COLOR_RED);\n\t\t}\n\t\t\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\tserver.getId(),\n\t\t\ttarget\n\t\t);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Mode\n\t */\n\t@Override\n\tprotected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n\t{\n\t\t/*//Disabled as it doubles events (e.g. onOp and onMode will be called)\n\t\tMessage message = new Message(sourceNick + \" sets mode \" + mode);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t\t*/\n\t}\n\n\t/**\n\t * On Nick Change\n\t */\n\t@Override\n\tprotected void onNickChange(String oldNick, String login, String hostname, String newNick)\n\t{\n\t\tVector<String> channels = getChannelsByNickname(newNick);\n\t\t\n\t\tfor (String target : channels) {\n\t\t\tMessage message = new Message(oldNick + \" is now known as \" + newNick);\n\t\t\tmessage.setColor(Message.COLOR_GREEN);\n\t\t\tserver.getConversation(target).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\t\tserver.getId(),\n\t\t\t\ttarget\n\t\t\t);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Notice\n\t */\n\t@Override\n\tprotected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n\t{\n\t\t// Strip mIRC colors and formatting\n\t\tnotice = Colors.removeFormattingAndColors(notice);\n\t\t\n\t\t// Post notice to currently selected conversation\n\t\tConversation conversation = server.getConversation(server.getSelectedConversation());\n\t\t\n\t\tif (conversation == null) {\n\t\t\t// Fallback: Use ServerInfo view\n\t\t\tconversation = server.getConversation(ServerInfo.DEFAULT_NAME);\n\t\t}\n\n\t\tMessage message = new Message(\"-\" + sourceNick + \"- \" + notice);\n\t\tmessage.setIcon(R.drawable.info);\n\t\tconversation.addMessage(message);\n\t\t\n\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\tserver.getId(),\n\t\t\tconversation.getName()\n\t\t);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Op\n\t */\n\t@Override\n\tprotected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tMessage message = new Message(sourceNick + \" ops \" + recipient);\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tmessage.setIcon(R.drawable.op);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\tserver.getId(),\n\t\t\ttarget\n\t\t);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Part\n\t */\n\t@Override\n\tprotected void onPart(String target, String sender, String login, String hostname)\n\t{\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We parted a channel\n\t\t\tserver.removeConversation(target);\n\t\t\t\n\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\tBroadcast.CONVERSATION_REMOVE,\n\t\t\t\tserver.getId(),\n\t\t\t\ttarget\n\t\t\t);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tMessage message = new Message(sender + \" parts\");\n\t\t\tmessage.setColor(Message.COLOR_GREEN);\n\t\t\tmessage.setIcon(R.drawable.part);\n\t\t\tserver.getConversation(target).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\t\tserver.getId(),\n\t\t\t\ttarget\n\t\t\t);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Private Message\n\t */\n\t@Override\n\tprotected void onPrivateMessage(String sender, String login, String hostname, String text)\n\t{\n\t\t// Strip mIRC colors and formatting\n\t\ttext = Colors.removeFormattingAndColors(text);\n\n\t\tMessage message = new Message(\"<\" + sender + \"> \" + text);\n\t\t\n\t\tif (text.contains(getNick())) {\n\t\t\tmessage.setColor(Message.COLOR_RED);\n\t\t}\n\n\t\tConversation conversation = server.getConversation(sender);\n\n\t\tif (conversation == null) { \n\t\t\t// Open a query if there's none yet\n\t\t\tconversation = new Query(sender);\n\t\t\tconversation.addMessage(message);\n\t\t\tserver.addConversationl(conversation);\n\t\t\t\n\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\tBroadcast.CONVERSATION_NEW,\n\t\t\t\tserver.getId(),\n\t\t\t\tsender\n\t\t\t);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tconversation.addMessage(message);\n\t\t\t\n\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\t\tserver.getId(),\n\t\t\t\tsender\n\t\t\t);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Quit\n\t */\n\t@Override\n\tprotected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n\t{\n\t\tif (!sourceNick.equals(this.getNick())) {\n\t\t\tVector<String> channels = getChannelsByNickname(sourceNick);\n\t\t\t\n\t\t\tfor (String target : channels) {\n\t\t\t\tMessage message = new Message(sourceNick + \" quits (\" + reason + \")\");\n\t\t\t\tmessage.setColor(Message.COLOR_GREEN);\n\t\t\t\tmessage.setIcon(R.drawable.quit);\n\t\t\t\tserver.getConversation(target).addMessage(message);\n\t\t\t\t\n\t\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\t\t\tserver.getId(),\n\t\t\t\t\ttarget\n\t\t\t\t);\n\t\t\t\tservice.sendBroadcast(intent);\n\t\t\t}\n\t\t\t\n\t\t\t// Look if there's a query to update\n\t\t\tConversation conversation = server.getConversation(sourceNick);\n\t\t\t\n\t\t\tif (conversation != null) {\n\t\t\t\tMessage message = new Message(sourceNick + \" quits (\" + reason + \")\");\n\t\t\t\tmessage.setColor(Message.COLOR_GREEN);\n\t\t\t\tmessage.setIcon(R.drawable.quit);\n\t\t\t\tconversation.addMessage(message);\n\t\t\t\t\n\t\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\t\t\tserver.getId(),\n\t\t\t\t\tconversation.getName()\n\t\t\t\t);\n\t\t\t\tservice.sendBroadcast(intent);\n\t\t\t}\n\t\t\t\n\t\t} else {\n\t\t\t// XXX: We quitted\n\t\t}\n\t}\n\n\t/**\n\t * On Topic\n\t */\n\t@Override\n\tpublic void onTopic(String target, String topic, String setBy, long date, boolean changed)\n\t{\n\t\t// strip mIRC colors\n\t\ttopic = Colors.removeFormattingAndColors(topic);\n\t\t\n\t\tif (changed) {\n\t\t\tMessage message = new Message(setBy + \" sets topic: \" + topic);\n\t\t\tmessage.setColor(Message.COLOR_YELLOW);\n\t\t\tserver.getConversation(target).addMessage(message);\n\t\t} else {\n\t\t\tMessage message = new Message(\"Topic: \" + topic);\n\t\t\tmessage.setColor(Message.COLOR_YELLOW);\n\t\t\tserver.getConversation(target).addMessage(message);\n\t\t}\n\t\t\n\t\t// remember channel's topic\n\t\t((Channel) server.getConversation(target)).setTopic(topic);\n\t\t\n\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\tserver.getId(),\n\t\t\ttarget\n\t\t);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On User List\n\t */\n\t@Override\n\tprotected void onUserList(String channel, User[] users)\n\t{\n\t\t// XXX: Store user list somewhere and keep it updated or just broadcast some event?\n\t}\n\n\t/**\n\t * On Voice\n\t */\n\t@Override\n\tprotected void onVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tMessage message = new Message(sourceNick + \" voices \" + recipient);\n\t\tmessage.setIcon(R.drawable.voice);\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\tserver.getId(),\n\t\t\ttarget\n\t\t);\n\t\tservice.sendBroadcast(intent);\n\t}\n\t\n\t/**\n\t * On remove channel key\t\n\t */\n\t@Override\n\tprotected void onRemoveChannelKey(String target, String sourceNick, String sourceLogin, String sourceHostname, String key)\n\t{\n\t\tMessage message = new Message(sourceNick + \" removes channel key\");\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\n\t/**\n\t * On set channel key\n\t */\n\t@Override\n\tprotected void onSetChannelKey(String target, String sourceNick, String sourceLogin, String sourceHostname, String key)\n\t{\n\t\tMessage message = new Message(sourceNick + \" sets channel key: \" + key);\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\t\n\t/**\n\t * On set secret\n\t */\n\t@Override\n\tprotected void onSetSecret(String target, String sourceNick, String sourceLogin, String sourceHostname)\n\t{\n\t\tMessage message = new Message(sourceNick + \" sets channel secret\");\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\t\n\t/**\n\t * On remove secret\n\t */\n\t@Override\n\tprotected void onRemoveSecret(String target, String sourceNick, String sourceLogin, String sourceHostname)\n\t{\n\t\tMessage message = new Message(sourceNick + \" sets channel public\");\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\t\n\t/**\n\t * On set channel limit\n\t */\n\t@Override\n\tprotected void onSetChannelLimit(String target, String sourceNick, String sourceLogin, String sourceHostname, int limit)\n\t{\n\t\tMessage message = new Message(sourceNick + \" sets limit: \" + limit);\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\t\n\t/**\n\t * On remove channel limit\n\t */\n\t@Override\n\tprotected void onRemoveChannelLimit(String target, String sourceNick, String sourceLogin, String sourceHostname)\n\t{\n\t\tMessage message = new Message(sourceNick + \" removes limit\");\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\n\t/**\n\t * On set channel ban\n\t */\n\t@Override\n\tprotected void onSetChannelBan(String target, String sourceNick, String sourceLogin, String sourceHostname, String hostmask)\n\t{\n\t\tMessage message = new Message(sourceNick + \" sets ban: \" + hostmask);\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\t\n\t/**\n\t * On remove channel ban\n\t */\n\t@Override\n\tprotected void onRemoveChannelBan(String target, String sourceNick, String sourceLogin, String sourceHostname, String hostmask)\n\t{\n\t\tMessage message = new Message(sourceNick + \" removes ban: \" + hostmask);\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\t\n\t/**\n\t * On set topic protection\n\t */\n\t@Override\n\tprotected void onSetTopicProtection(String target, String sourceNick, String sourceLogin, String sourceHostname)\n\t{\n\t\tMessage message = new Message(sourceNick + \" sets topic protection\");\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\t\n\t/**\n\t * On remove topic protection\n\t */\n\t@Override\n\tprotected void onRemoveTopicProtection(String target, String sourceNick, String sourceLogin, String sourceHostname)\n\t{\n\t\tMessage message = new Message(sourceNick + \" removes topic protection\");\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\n\t/**\n\t * On set no external messages\n\t */\n\t@Override\n\tprotected void onSetNoExternalMessages(String target, String sourceNick, String sourceLogin, String sourceHostname)\n\t{\n\t\tMessage message = new Message(sourceNick + \" disables external messages\");\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\n\t/**\n\t * On remove no external messages\n\t */\n\t@Override\n\tprotected void onRemoveNoExternalMessages(String target, String sourceNick, String sourceLogin, String sourceHostname)\n\t{\n\t\tMessage message = new Message(sourceNick + \" enables external messages\");\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\t\n\t/**\n\t * On set invite only\n\t */\n\t@Override\n\tprotected void onSetInviteOnly(String target, String sourceNick, String sourceLogin, String sourceHostname)\n\t{\n\t\tMessage message = new Message(sourceNick + \" sets invite only\");\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\t\n\t/**\n\t * On remove invite only\n\t */\n\t@Override\n\tprotected void onRemoveInviteOnly(String target, String sourceNick, String sourceLogin, String sourceHostname)\n\t{\n\t\tMessage message = new Message(sourceNick + \" removes invite only\");\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\n\t/**\n\t * On set moderated\n\t */\n\t@Override\n\tprotected void onSetModerated(String target, String sourceNick, String sourceLogin, String sourceHostname)\n\t{\n\t\tMessage message = new Message(sourceNick + \" sets moderated\");\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\t\n\t/**\n\t * On remove moderated\n\t */\n\t@Override\n\tprotected void onRemoveModerated(String target, String sourceNick, String sourceLogin, String sourceHostname)\n\t{\n\t\tMessage message = new Message(sourceNick + \" removes moderated\");\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\t\n\t/**\n\t * On set private\n\t */\n\t@Override\n\tprotected void onSetPrivate(String target, String sourceNick, String sourceLogin, String sourceHostname)\n\t{\n\t\tMessage message = new Message(sourceNick + \" sets channel private\");\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\t\n\t/**\n\t * On remove private\n\t */\n\t@Override\n\tprotected void onRemovePrivate(String target, String sourceNick, String sourceLogin, String sourceHostname)\n\t{\n\t\tMessage message = new Message(sourceNick + \" sets channel public\");\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\n\t/**\n\t * On unknown\n\t */\n\t@Override\n\tprotected void onUnknown(String line)\n\t{\n\t\tMessage message = new Message(line);\n\t\tmessage.setIcon(R.drawable.action);\n\t\tmessage.setColor(Message.COLOR_GREY);\n\t\tserver.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\t\t\n\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\tserver.getId(),\n\t\t\tServerInfo.DEFAULT_NAME\n\t\t);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On server response\n\t */\n\t@Override\n\tprotected void onServerResponse(int code, String response)\n\t{\n\t\tif (code == 372 || code == 375 || code == 376) {\n\t\t\t// Skip MOTD\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (code >= 200 && code < 300) {\n\t\t\t// Skip 2XX responses\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (code == 353 || code == 366 || code == 332 || code == 333) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (code < 10) {\n\t\t\t// Skip server info\n\t\t\treturn;\n\t\t}\n\n\t\t// Currently disabled... to much text\n\t\tMessage message = new Message(response);\n\t\tmessage.setColor(Message.COLOR_GREY);\n\t\tserver.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\t\t\n\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\tserver.getId(),\n\t\t\tServerInfo.DEFAULT_NAME\n\t\t);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On disconnect\n\t */\n\t@Override\n\tpublic void onDisconnect()\n\t{\n\t\tserver.setStatus(Status.DISCONNECTED);\n\t\t\n\t\tIntent sIntent = Broadcast.createServerIntent(Broadcast.SERVER_UPDATE, server.getId());\n\t\tservice.sendBroadcast(sIntent);\t\t\n\t\t\n\t\tMessage message = new Message(\"Disconnected\");\n\t\tmessage.setIcon(R.drawable.error);\n\t\tmessage.setColor(Message.COLOR_RED);\n\t\tserver.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\t\t\n\t\tIntent cIntent = Broadcast.createConversationIntent(\n\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\tserver.getId(),\n\t\t\tServerInfo.DEFAULT_NAME\n\t\t);\n\t\tservice.sendBroadcast(cIntent);\n\t}\n\t\n\t/**\n\t * Get all channels where the user with the given nickname is online\n\t * \n\t * @param nickname\n\t * @return Array of channel names\n\t */\n\tprivate Vector<String> getChannelsByNickname(String nickname)\n\t{\n\t\tVector<String> channels = new Vector<String>();\n\t\tString[] channelArray = getChannels();\n\t\t\n\t\tfor (String channel : channelArray) {\n\t\t\tUser[] userArray = getUsers(channel);\n\t\t\tfor (User user : userArray) {\n\t\t\t\tif (user.getNick().equals(nickname)) {\n\t\t\t\t\tchannels.add(channel);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn channels;\n\t}\n\t\n\t/**\n\t * Quits from the IRC server with default reason.\n\t */\n\t@Override\n\tpublic void quitServer()\n\t{\n\t\tnew Thread() {\n\t\t\tpublic void run() {\n\t\t\t\tquitServer(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t\t\t}\n\t\t}.start();\n\t}\n}\n","lineNo":387}
{"Smelly Sample":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2010 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.irc;\n\nimport java.io.UnsupportedEncodingException;\nimport java.util.Vector;\n\nimport android.content.Intent;\n\nimport org.jibble.pircbot.Colors;\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\n\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Query;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.ServerInfo;\nimport org.yaaic.model.Status;\n\n/**\n * The class that actually handles the connection to an IRC server\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class IRCConnection extends PircBot\n{\n\tprivate IRCService service;\n\tprivate Server server;\n\t\n\t/**\n\t * Create a new connection\n\t * \n\t * @param service\n\t * @param serverId\n\t */\n\tpublic IRCConnection(IRCService service, int serverId)\n\t{\n\t\tthis.server = Yaaic.getInstance().getServerById(serverId);\n\t\tthis.service = service;\n\t\t\n\t\t// XXX: Should be configurable via settings\n\t\tthis.setAutoNickChange(true);\n\t\t\n\t\ttry {\n\t\t\tthis.setEncoding(\"UTF-8\");\n\t\t} catch(UnsupportedEncodingException e) {\n\t\t\t// Use default charset\n\t\t}\n\t\t\n\t\tthis.setFinger(\"http://www.youtube.com/watch?v=oHg5SJYRHA0\");\n\t}\n\t\n\t/**\n\t * Set the nickname of the user\n\t * \n\t * @param nickname The nickname to use\n\t */\n\tpublic void setNickname(String nickname)\n\t{\n\t\tthis.setName(nickname);\n\t}\n\t\n\t/**\n\t * Set the real name of the user\n\t * \n\t * @param realname The realname to use\n\t */\n\tpublic void setRealName(String realname)\n\t{\n\t\t// XXX: Pircbot uses the version for \"real name\" and \"version\".\n\t\t//      The real \"version\" value is provided by onVersion() \n\t\tthis.setVersion(realname);\n\t}\n\n\t/**\n\t * On version (CTCP version)\n\t * \n\t * This is a fix for pircbot as pircbot uses the version as \"real name\" and as \"version\"\n\t */\n\t@Override\n\tprotected void onVersion(String sourceNick, String sourceLogin,\tString sourceHostname, String target)\n\t{\n\t\tthis.sendRawLine(\n\t\t\t\t\"NOTICE \" + sourceNick + \" :\\u0001VERSION \" +\n\t\t\t\t\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\" +\n\t\t\t\t\"\\u0001\"\n\t\t);\n\t}\n\n\t/**\n\t * Set the ident of the user\n\t * \n\t * @param ident The ident to use\n\t */\n\tpublic void setIdent(String ident)\n\t{\n\t\tthis.setLogin(ident);\n\t}\n\n\t/**\n\t * On connect\n\t */\n\t@Override\n\tpublic void onConnect()\n\t{\n\t\tserver.setStatus(Status.CONNECTED);\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t\t\n\t\tMessage message = new Message(\"Connected to \" + server.getTitle());\n\t\tmessage.setColor(Message.COLOR_GREEN);\n\t\tserver.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\t\t\n\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\tserver.getId(),\n\t\t\tServerInfo.DEFAULT_NAME\n\t\t);\n\t\t\n\t\tservice.sendBroadcast(intent);\n\t}\n\t\n\t/**\n\t * On channel action\n\t */\n\t@Override\n\tprotected void onAction(String sender, String login, String hostname, String target, String action)\n\t{\n\t\t// Strip mIRC colors and formatting\n\t\taction = Colors.removeFormattingAndColors(action);\n\n\t\tMessage message = new Message(sender + \" \" + action);\n\t\tmessage.setIcon(R.drawable.action);\n\t\t\n\t\tif (action.contains(getNick())) {\n\t\t\t// highlight\n\t\t\tmessage.setColor(Message.COLOR_RED);\n\t\t}\n\t\t\n\t\tif (target.equals(this.getNick())) {\n\t\t\t// We are the target - this is an action in a query\n\t\t\tConversation conversation = server.getConversation(sender); \n\t\t\tif (conversation == null) { \n\t\t\t\t// Open a query if there's none yet\n\t\t\t\tconversation = new Query(sender);\n\t\t\t\tserver.addConversationl(conversation);\n\t\t\t\tconversation.addMessage(message);\n\n\t\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\t\tBroadcast.CONVERSATION_NEW,\n\t\t\t\t\tserver.getId(),\n\t\t\t\t\tsender\n\t\t\t\t);\n\t\t\t\tservice.sendBroadcast(intent);\n\t\t\t} else {\n\t\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\t\t\tserver.getId(),\n\t\t\t\t\tsender\n\t\t\t\t);\n\t\t\t\tservice.sendBroadcast(intent);\n\t\t\t}\n\t\t} else {\n\t\t\t// A action in a channel\n\t\t\tserver.getConversation(target).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\t\tserver.getId(),\n\t\t\t\ttarget\n\t\t\t);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Channel Info\n\t */\n\t@Override\n\tprotected void onChannelInfo(String channel, int userCount, String topic)\n\t{\n\t}\n\n\t/**\n\t * On Deop\n\t */\n\t@Override\n\tprotected void onDeop(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tMessage message = new Message(sourceNick + \" deops \" + recipient);\n\t\tmessage.setIcon(R.drawable.op);\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\tserver.getId(),\n\t\t\ttarget\n\t\t);\n\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On DeVoice\n\t */\n\t@Override\n\tprotected void onDeVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tMessage message = new Message(sourceNick + \" devoices \" + recipient);\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tmessage.setIcon(R.drawable.voice);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\tserver.getId(),\n\t\t\ttarget\n\t\t);\n\t\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Invite\n\t */\n\t@Override\n\tprotected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String target)\n\t{\n\t\tif (targetNick.equals(this.getNick())) {\n\t\t\t// We are invited\n\t\t\tMessage message = new Message(sourceNick + \" invites you into \" + target);\n\t\t\tserver.getConversation(server.getSelectedConversation()).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\t\tserver.getId(),\n\t\t\t\tserver.getSelectedConversation()\n\t\t\t);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\t// Someone is invited\n\t\t\tMessage message = new Message(sourceNick + \" invites \" + targetNick + \" into \" + target);\n\t\t\tserver.getConversation(target).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\t\tserver.getId(),\n\t\t\t\ttarget\n\t\t\t);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Join\n\t */\n\t@Override\n\tprotected void onJoin(String target, String sender, String login, String hostname)\n\t{\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We joined a new channel\n\t\t\tserver.addConversationl(new Channel(target));\n\t\t\t\n\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\tBroadcast.CONVERSATION_NEW,\n\t\t\t\tserver.getId(),\n\t\t\t\ttarget\n\t\t\t);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tMessage message = new Message(sender + \" joins\");\n\t\t\tmessage.setIcon(R.drawable.join);\n\t\t\tmessage.setColor(Message.COLOR_GREEN);\n\t\t\tserver.getConversation(target).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\t\tserver.getId(),\n\t\t\t\ttarget\n\t\t\t);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Kick\n\t */\n\t@Override\n\tprotected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n\t{\n\t\tif (recipientNick.equals(getNick())) {\n\t\t\t// We are kicked\n\t\t\tserver.removeConversation(target);\n\t\t\t\n\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\tBroadcast.CONVERSATION_REMOVE,\n\t\t\t\tserver.getId(),\n\t\t\t\ttarget\n\t\t\t);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tMessage message = new Message(kickerNick + \" kicks \" + recipientNick);\n\t\t\tmessage.setColor(Message.COLOR_GREEN);\n\t\t\tserver.getConversation(target).addMessage(message);\n\n\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\t\tserver.getId(),\n\t\t\t\ttarget\n\t\t\t);\n\t\t\tservice.sendBroadcast(intent);\t\t\t\n\t\t}\n\t}\n\n\t/**\n\t * On Message\n\t */\n\t@Override\n\tprotected void onMessage(String target, String sender, String login, String hostname, String text)\n\t{\n\t\t// Strip mIRC colors and formatting\n\t\ttext = Colors.removeFormattingAndColors(text);\n\n\t\tMessage message = new Message(\"<\" + sender + \"> \" + text);\n\t\t\n\t\tif (text.contains(getNick())) {\n\t\t\t// highlight\n\t\t\tmessage.setColor(Message.COLOR_RED);\n\t\t}\n\t\t\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\tserver.getId(),\n\t\t\ttarget\n\t\t);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Mode\n\t */\n\t@Override\n\tprotected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n\t{\n\t\t/*//Disabled as it doubles events (e.g. onOp and onMode will be called)\n\t\tMessage message = new Message(sourceNick + \" sets mode \" + mode);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t\t*/\n\t}\n\n\t/**\n\t * On Nick Change\n\t */\n\t@Override\n\tprotected void onNickChange(String oldNick, String login, String hostname, String newNick)\n\t{\n\t\t// XXX: Optimization : No getter in for loop\n\t\tfor (String target : getChannelsByNickname(newNick)) {\n\t\t\tMessage message = new Message(oldNick + \" is now known as \" + newNick);\n\t\t\tmessage.setColor(Message.COLOR_GREEN);\n\t\t\tserver.getConversation(target).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\t\tserver.getId(),\n\t\t\t\ttarget\n\t\t\t);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Notice\n\t */\n\t@Override\n\tprotected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n\t{\n\t\t// Strip mIRC colors and formatting\n\t\tnotice = Colors.removeFormattingAndColors(notice);\n\t\t\n\t\t// Post notice to currently selected conversation\n\t\tConversation conversation = server.getConversation(server.getSelectedConversation());\n\t\t\n\t\tif (conversation == null) {\n\t\t\t// Fallback: Use ServerInfo view\n\t\t\tconversation = server.getConversation(ServerInfo.DEFAULT_NAME);\n\t\t}\n\n\t\tMessage message = new Message(\"-\" + sourceNick + \"- \" + notice);\n\t\tmessage.setIcon(R.drawable.info);\n\t\tconversation.addMessage(message);\n\t\t\n\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\tserver.getId(),\n\t\t\tconversation.getName()\n\t\t);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Op\n\t */\n\t@Override\n\tprotected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tMessage message = new Message(sourceNick + \" ops \" + recipient);\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tmessage.setIcon(R.drawable.op);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\tserver.getId(),\n\t\t\ttarget\n\t\t);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Part\n\t */\n\t@Override\n\tprotected void onPart(String target, String sender, String login, String hostname)\n\t{\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We parted a channel\n\t\t\tserver.removeConversation(target);\n\t\t\t\n\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\tBroadcast.CONVERSATION_REMOVE,\n\t\t\t\tserver.getId(),\n\t\t\t\ttarget\n\t\t\t);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tMessage message = new Message(sender + \" parts\");\n\t\t\tmessage.setColor(Message.COLOR_GREEN);\n\t\t\tmessage.setIcon(R.drawable.part);\n\t\t\tserver.getConversation(target).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\t\tserver.getId(),\n\t\t\t\ttarget\n\t\t\t);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Private Message\n\t */\n\t@Override\n\tprotected void onPrivateMessage(String sender, String login, String hostname, String text)\n\t{\n\t\t// Strip mIRC colors and formatting\n\t\ttext = Colors.removeFormattingAndColors(text);\n\n\t\tMessage message = new Message(\"<\" + sender + \"> \" + text);\n\t\t\n\t\tif (text.contains(getNick())) {\n\t\t\tmessage.setColor(Message.COLOR_RED);\n\t\t}\n\n\t\tConversation conversation = server.getConversation(sender);\n\n\t\tif (conversation == null) { \n\t\t\t// Open a query if there's none yet\n\t\t\tconversation = new Query(sender);\n\t\t\tconversation.addMessage(message);\n\t\t\tserver.addConversationl(conversation);\n\t\t\t\n\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\tBroadcast.CONVERSATION_NEW,\n\t\t\t\tserver.getId(),\n\t\t\t\tsender\n\t\t\t);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tconversation.addMessage(message);\n\t\t\t\n\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\t\tserver.getId(),\n\t\t\t\tsender\n\t\t\t);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Quit\n\t */\n\t@Override\n\tprotected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n\t{\n\t\tif (!sourceNick.equals(this.getNick())) {\n\t\t\t// XXX: Optimization : No getter in for loop\n\t\t\tfor (String target : getChannelsByNickname(sourceNick)) {\n\t\t\t\tMessage message = new Message(sourceNick + \" quits (\" + reason + \")\");\n\t\t\t\tmessage.setColor(Message.COLOR_GREEN);\n\t\t\t\tmessage.setIcon(R.drawable.quit);\n\t\t\t\tserver.getConversation(target).addMessage(message);\n\t\t\t\t\n\t\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\t\t\tserver.getId(),\n\t\t\t\t\ttarget\n\t\t\t\t);\n\t\t\t\tservice.sendBroadcast(intent);\n\t\t\t}\n\t\t\t\n\t\t\t// Look if there's a query to update\n\t\t\tConversation conversation = server.getConversation(sourceNick);\n\t\t\t\n\t\t\tif (conversation != null) {\n\t\t\t\tMessage message = new Message(sourceNick + \" quits (\" + reason + \")\");\n\t\t\t\tmessage.setColor(Message.COLOR_GREEN);\n\t\t\t\tmessage.setIcon(R.drawable.quit);\n\t\t\t\tconversation.addMessage(message);\n\t\t\t\t\n\t\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\t\t\tserver.getId(),\n\t\t\t\t\tconversation.getName()\n\t\t\t\t);\n\t\t\t\tservice.sendBroadcast(intent);\n\t\t\t}\n\t\t\t\n\t\t} else {\n\t\t\t// XXX: We quitted\n\t\t}\n\t}\n\n\t/**\n\t * On Topic\n\t */\n\t@Override\n\tpublic void onTopic(String target, String topic, String setBy, long date, boolean changed)\n\t{\n\t\t// strip mIRC colors\n\t\ttopic = Colors.removeFormattingAndColors(topic);\n\t\t\n\t\tif (changed) {\n\t\t\tMessage message = new Message(setBy + \" sets topic: \" + topic);\n\t\t\tmessage.setColor(Message.COLOR_YELLOW);\n\t\t\tserver.getConversation(target).addMessage(message);\n\t\t} else {\n\t\t\tMessage message = new Message(\"Topic: \" + topic);\n\t\t\tmessage.setColor(Message.COLOR_YELLOW);\n\t\t\tserver.getConversation(target).addMessage(message);\n\t\t}\n\t\t\n\t\t// remember channel's topic\n\t\t((Channel) server.getConversation(target)).setTopic(topic);\n\t\t\n\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\tserver.getId(),\n\t\t\ttarget\n\t\t);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On User List\n\t */\n\t@Override\n\tprotected void onUserList(String channel, User[] users)\n\t{\n\t\t// XXX: Store user list somewhere and keep it updated or just broadcast some event?\n\t}\n\n\t/**\n\t * On Voice\n\t */\n\t@Override\n\tprotected void onVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tMessage message = new Message(sourceNick + \" voices \" + recipient);\n\t\tmessage.setIcon(R.drawable.voice);\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\tserver.getId(),\n\t\t\ttarget\n\t\t);\n\t\tservice.sendBroadcast(intent);\n\t}\n\t\n\t/**\n\t * On remove channel key\t\n\t */\n\t@Override\n\tprotected void onRemoveChannelKey(String target, String sourceNick, String sourceLogin, String sourceHostname, String key)\n\t{\n\t\tMessage message = new Message(sourceNick + \" removes channel key\");\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\n\t/**\n\t * On set channel key\n\t */\n\t@Override\n\tprotected void onSetChannelKey(String target, String sourceNick, String sourceLogin, String sourceHostname, String key)\n\t{\n\t\tMessage message = new Message(sourceNick + \" sets channel key: \" + key);\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\t\n\t/**\n\t * On set secret\n\t */\n\t@Override\n\tprotected void onSetSecret(String target, String sourceNick, String sourceLogin, String sourceHostname)\n\t{\n\t\tMessage message = new Message(sourceNick + \" sets channel secret\");\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\t\n\t/**\n\t * On remove secret\n\t */\n\t@Override\n\tprotected void onRemoveSecret(String target, String sourceNick, String sourceLogin, String sourceHostname)\n\t{\n\t\tMessage message = new Message(sourceNick + \" sets channel public\");\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\t\n\t/**\n\t * On set channel limit\n\t */\n\t@Override\n\tprotected void onSetChannelLimit(String target, String sourceNick, String sourceLogin, String sourceHostname, int limit)\n\t{\n\t\tMessage message = new Message(sourceNick + \" sets limit: \" + limit);\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\t\n\t/**\n\t * On remove channel limit\n\t */\n\t@Override\n\tprotected void onRemoveChannelLimit(String target, String sourceNick, String sourceLogin, String sourceHostname)\n\t{\n\t\tMessage message = new Message(sourceNick + \" removes limit\");\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\n\t/**\n\t * On set channel ban\n\t */\n\t@Override\n\tprotected void onSetChannelBan(String target, String sourceNick, String sourceLogin, String sourceHostname, String hostmask)\n\t{\n\t\tMessage message = new Message(sourceNick + \" sets ban: \" + hostmask);\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\t\n\t/**\n\t * On remove channel ban\n\t */\n\t@Override\n\tprotected void onRemoveChannelBan(String target, String sourceNick, String sourceLogin, String sourceHostname, String hostmask)\n\t{\n\t\tMessage message = new Message(sourceNick + \" removes ban: \" + hostmask);\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\t\n\t/**\n\t * On set topic protection\n\t */\n\t@Override\n\tprotected void onSetTopicProtection(String target, String sourceNick, String sourceLogin, String sourceHostname)\n\t{\n\t\tMessage message = new Message(sourceNick + \" sets topic protection\");\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\t\n\t/**\n\t * On remove topic protection\n\t */\n\t@Override\n\tprotected void onRemoveTopicProtection(String target, String sourceNick, String sourceLogin, String sourceHostname)\n\t{\n\t\tMessage message = new Message(sourceNick + \" removes topic protection\");\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\n\t/**\n\t * On set no external messages\n\t */\n\t@Override\n\tprotected void onSetNoExternalMessages(String target, String sourceNick, String sourceLogin, String sourceHostname)\n\t{\n\t\tMessage message = new Message(sourceNick + \" disables external messages\");\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\n\t/**\n\t * On remove no external messages\n\t */\n\t@Override\n\tprotected void onRemoveNoExternalMessages(String target, String sourceNick, String sourceLogin, String sourceHostname)\n\t{\n\t\tMessage message = new Message(sourceNick + \" enables external messages\");\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\t\n\t/**\n\t * On set invite only\n\t */\n\t@Override\n\tprotected void onSetInviteOnly(String target, String sourceNick, String sourceLogin, String sourceHostname)\n\t{\n\t\tMessage message = new Message(sourceNick + \" sets invite only\");\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\t\n\t/**\n\t * On remove invite only\n\t */\n\t@Override\n\tprotected void onRemoveInviteOnly(String target, String sourceNick, String sourceLogin, String sourceHostname)\n\t{\n\t\tMessage message = new Message(sourceNick + \" removes invite only\");\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\n\t/**\n\t * On set moderated\n\t */\n\t@Override\n\tprotected void onSetModerated(String target, String sourceNick, String sourceLogin, String sourceHostname)\n\t{\n\t\tMessage message = new Message(sourceNick + \" sets moderated\");\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\t\n\t/**\n\t * On remove moderated\n\t */\n\t@Override\n\tprotected void onRemoveModerated(String target, String sourceNick, String sourceLogin, String sourceHostname)\n\t{\n\t\tMessage message = new Message(sourceNick + \" removes moderated\");\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\t\n\t/**\n\t * On set private\n\t */\n\t@Override\n\tprotected void onSetPrivate(String target, String sourceNick, String sourceLogin, String sourceHostname)\n\t{\n\t\tMessage message = new Message(sourceNick + \" sets channel private\");\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\t\n\t/**\n\t * On remove private\n\t */\n\t@Override\n\tprotected void onRemovePrivate(String target, String sourceNick, String sourceLogin, String sourceHostname)\n\t{\n\t\tMessage message = new Message(sourceNick + \" sets channel public\");\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\n\t/**\n\t * On unknown\n\t */\n\t@Override\n\tprotected void onUnknown(String line)\n\t{\n\t\tMessage message = new Message(line);\n\t\tmessage.setIcon(R.drawable.action);\n\t\tmessage.setColor(Message.COLOR_GREY);\n\t\tserver.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\t\t\n\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\tserver.getId(),\n\t\t\tServerInfo.DEFAULT_NAME\n\t\t);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On server response\n\t */\n\t@Override\n\tprotected void onServerResponse(int code, String response)\n\t{\n\t\tif (code == 372 || code == 375 || code == 376) {\n\t\t\t// Skip MOTD\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (code >= 200 && code < 300) {\n\t\t\t// Skip 2XX responses\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (code == 353 || code == 366 || code == 332 || code == 333) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (code < 10) {\n\t\t\t// Skip server info\n\t\t\treturn;\n\t\t}\n\n\t\t// Currently disabled... to much text\n\t\tMessage message = new Message(response);\n\t\tmessage.setColor(Message.COLOR_GREY);\n\t\tserver.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\t\t\n\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\tserver.getId(),\n\t\t\tServerInfo.DEFAULT_NAME\n\t\t);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On disconnect\n\t */\n\t@Override\n\tpublic void onDisconnect()\n\t{\n\t\tserver.setStatus(Status.DISCONNECTED);\n\t\t\n\t\tIntent sIntent = Broadcast.createServerIntent(Broadcast.SERVER_UPDATE, server.getId());\n\t\tservice.sendBroadcast(sIntent);\t\t\n\t\t\n\t\tMessage message = new Message(\"Disconnected\");\n\t\tmessage.setIcon(R.drawable.error);\n\t\tmessage.setColor(Message.COLOR_RED);\n\t\tserver.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\t\t\n\t\tIntent cIntent = Broadcast.createConversationIntent(\n\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\tserver.getId(),\n\t\t\tServerInfo.DEFAULT_NAME\n\t\t);\n\t\tservice.sendBroadcast(cIntent);\n\t}\n\t\n\t/**\n\t * Get all channels where the user with the given nickname is online\n\t * \n\t * @param nickname\n\t * @return Array of channel names\n\t */\n\tprivate Vector<String> getChannelsByNickname(String nickname)\n\t{\n\t\tVector<String> channels = new Vector<String>();\n\t\t\n\t\t// XXX: Optimization : No getter in for loop\n\t\tfor (String channel : this.getChannels()) {\n\t\t\t// XXX: Optimization : No getter in for loop\n\t\t\tfor (User user : this.getUsers(channel)) {\n\t\t\t\tif (user.getNick().equals(nickname)) {\n\t\t\t\t\tchannels.add(channel);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn channels;\n\t}\n\t\n\t/**\n\t * Quits from the IRC server with default reason.\n\t */\n\t@Override\n\tpublic void quitServer()\n\t{\n\t\tnew Thread() {\n\t\t\tpublic void run() {\n\t\t\t\tquitServer(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t\t\t}\n\t\t}.start();\n\t}\n}\n","Method after Refactoring":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2010 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.irc;\n\nimport java.io.UnsupportedEncodingException;\nimport java.util.Vector;\n\nimport android.content.Intent;\n\nimport org.jibble.pircbot.Colors;\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\n\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Query;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.ServerInfo;\nimport org.yaaic.model.Status;\n\n/**\n * The class that actually handles the connection to an IRC server\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class IRCConnection extends PircBot\n{\n\tprivate IRCService service;\n\tprivate Server server;\n\t\n\t/**\n\t * Create a new connection\n\t * \n\t * @param service\n\t * @param serverId\n\t */\n\tpublic IRCConnection(IRCService service, int serverId)\n\t{\n\t\tthis.server = Yaaic.getInstance().getServerById(serverId);\n\t\tthis.service = service;\n\t\t\n\t\t// XXX: Should be configurable via settings\n\t\tthis.setAutoNickChange(true);\n\t\t\n\t\ttry {\n\t\t\tthis.setEncoding(\"UTF-8\");\n\t\t} catch(UnsupportedEncodingException e) {\n\t\t\t// Use default charset\n\t\t}\n\t\t\n\t\tthis.setFinger(\"http://www.youtube.com/watch?v=oHg5SJYRHA0\");\n\t}\n\t\n\t/**\n\t * Set the nickname of the user\n\t * \n\t * @param nickname The nickname to use\n\t */\n\tpublic void setNickname(String nickname)\n\t{\n\t\tthis.setName(nickname);\n\t}\n\t\n\t/**\n\t * Set the real name of the user\n\t * \n\t * @param realname The realname to use\n\t */\n\tpublic void setRealName(String realname)\n\t{\n\t\t// XXX: Pircbot uses the version for \"real name\" and \"version\".\n\t\t//      The real \"version\" value is provided by onVersion() \n\t\tthis.setVersion(realname);\n\t}\n\n\t/**\n\t * On version (CTCP version)\n\t * \n\t * This is a fix for pircbot as pircbot uses the version as \"real name\" and as \"version\"\n\t */\n\t@Override\n\tprotected void onVersion(String sourceNick, String sourceLogin,\tString sourceHostname, String target)\n\t{\n\t\tthis.sendRawLine(\n\t\t\t\t\"NOTICE \" + sourceNick + \" :\\u0001VERSION \" +\n\t\t\t\t\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\" +\n\t\t\t\t\"\\u0001\"\n\t\t);\n\t}\n\n\t/**\n\t * Set the ident of the user\n\t * \n\t * @param ident The ident to use\n\t */\n\tpublic void setIdent(String ident)\n\t{\n\t\tthis.setLogin(ident);\n\t}\n\n\t/**\n\t * On connect\n\t */\n\t@Override\n\tpublic void onConnect()\n\t{\n\t\tserver.setStatus(Status.CONNECTED);\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t\t\n\t\tMessage message = new Message(\"Connected to \" + server.getTitle());\n\t\tmessage.setColor(Message.COLOR_GREEN);\n\t\tserver.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\t\t\n\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\tserver.getId(),\n\t\t\tServerInfo.DEFAULT_NAME\n\t\t);\n\t\t\n\t\tservice.sendBroadcast(intent);\n\t}\n\t\n\t/**\n\t * On channel action\n\t */\n\t@Override\n\tprotected void onAction(String sender, String login, String hostname, String target, String action)\n\t{\n\t\t// Strip mIRC colors and formatting\n\t\taction = Colors.removeFormattingAndColors(action);\n\n\t\tMessage message = new Message(sender + \" \" + action);\n\t\tmessage.setIcon(R.drawable.action);\n\t\t\n\t\tif (action.contains(getNick())) {\n\t\t\t// highlight\n\t\t\tmessage.setColor(Message.COLOR_RED);\n\t\t}\n\t\t\n\t\tif (target.equals(this.getNick())) {\n\t\t\t// We are the target - this is an action in a query\n\t\t\tConversation conversation = server.getConversation(sender); \n\t\t\tif (conversation == null) { \n\t\t\t\t// Open a query if there's none yet\n\t\t\t\tconversation = new Query(sender);\n\t\t\t\tserver.addConversationl(conversation);\n\t\t\t\tconversation.addMessage(message);\n\n\t\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\t\tBroadcast.CONVERSATION_NEW,\n\t\t\t\t\tserver.getId(),\n\t\t\t\t\tsender\n\t\t\t\t);\n\t\t\t\tservice.sendBroadcast(intent);\n\t\t\t} else {\n\t\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\t\t\tserver.getId(),\n\t\t\t\t\tsender\n\t\t\t\t);\n\t\t\t\tservice.sendBroadcast(intent);\n\t\t\t}\n\t\t} else {\n\t\t\t// A action in a channel\n\t\t\tserver.getConversation(target).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\t\tserver.getId(),\n\t\t\t\ttarget\n\t\t\t);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Channel Info\n\t */\n\t@Override\n\tprotected void onChannelInfo(String channel, int userCount, String topic)\n\t{\n\t}\n\n\t/**\n\t * On Deop\n\t */\n\t@Override\n\tprotected void onDeop(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tMessage message = new Message(sourceNick + \" deops \" + recipient);\n\t\tmessage.setIcon(R.drawable.op);\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\tserver.getId(),\n\t\t\ttarget\n\t\t);\n\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On DeVoice\n\t */\n\t@Override\n\tprotected void onDeVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tMessage message = new Message(sourceNick + \" devoices \" + recipient);\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tmessage.setIcon(R.drawable.voice);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\tserver.getId(),\n\t\t\ttarget\n\t\t);\n\t\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Invite\n\t */\n\t@Override\n\tprotected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String target)\n\t{\n\t\tif (targetNick.equals(this.getNick())) {\n\t\t\t// We are invited\n\t\t\tMessage message = new Message(sourceNick + \" invites you into \" + target);\n\t\t\tserver.getConversation(server.getSelectedConversation()).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\t\tserver.getId(),\n\t\t\t\tserver.getSelectedConversation()\n\t\t\t);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\t// Someone is invited\n\t\t\tMessage message = new Message(sourceNick + \" invites \" + targetNick + \" into \" + target);\n\t\t\tserver.getConversation(target).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\t\tserver.getId(),\n\t\t\t\ttarget\n\t\t\t);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Join\n\t */\n\t@Override\n\tprotected void onJoin(String target, String sender, String login, String hostname)\n\t{\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We joined a new channel\n\t\t\tserver.addConversationl(new Channel(target));\n\t\t\t\n\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\tBroadcast.CONVERSATION_NEW,\n\t\t\t\tserver.getId(),\n\t\t\t\ttarget\n\t\t\t);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tMessage message = new Message(sender + \" joins\");\n\t\t\tmessage.setIcon(R.drawable.join);\n\t\t\tmessage.setColor(Message.COLOR_GREEN);\n\t\t\tserver.getConversation(target).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\t\tserver.getId(),\n\t\t\t\ttarget\n\t\t\t);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Kick\n\t */\n\t@Override\n\tprotected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n\t{\n\t\tif (recipientNick.equals(getNick())) {\n\t\t\t// We are kicked\n\t\t\tserver.removeConversation(target);\n\t\t\t\n\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\tBroadcast.CONVERSATION_REMOVE,\n\t\t\t\tserver.getId(),\n\t\t\t\ttarget\n\t\t\t);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tMessage message = new Message(kickerNick + \" kicks \" + recipientNick);\n\t\t\tmessage.setColor(Message.COLOR_GREEN);\n\t\t\tserver.getConversation(target).addMessage(message);\n\n\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\t\tserver.getId(),\n\t\t\t\ttarget\n\t\t\t);\n\t\t\tservice.sendBroadcast(intent);\t\t\t\n\t\t}\n\t}\n\n\t/**\n\t * On Message\n\t */\n\t@Override\n\tprotected void onMessage(String target, String sender, String login, String hostname, String text)\n\t{\n\t\t// Strip mIRC colors and formatting\n\t\ttext = Colors.removeFormattingAndColors(text);\n\n\t\tMessage message = new Message(\"<\" + sender + \"> \" + text);\n\t\t\n\t\tif (text.contains(getNick())) {\n\t\t\t// highlight\n\t\t\tmessage.setColor(Message.COLOR_RED);\n\t\t}\n\t\t\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\tserver.getId(),\n\t\t\ttarget\n\t\t);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Mode\n\t */\n\t@Override\n\tprotected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n\t{\n\t\t/*//Disabled as it doubles events (e.g. onOp and onMode will be called)\n\t\tMessage message = new Message(sourceNick + \" sets mode \" + mode);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t\t*/\n\t}\n\n\t/**\n\t * On Nick Change\n\t */\n\t@Override\n\tprotected void onNickChange(String oldNick, String login, String hostname, String newNick)\n\t{\n\t\tVector<String> channels = getChannelsByNickname(newNick);\n\t\t\n\t\tfor (String target : channels) {\n\t\t\tMessage message = new Message(oldNick + \" is now known as \" + newNick);\n\t\t\tmessage.setColor(Message.COLOR_GREEN);\n\t\t\tserver.getConversation(target).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\t\tserver.getId(),\n\t\t\t\ttarget\n\t\t\t);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Notice\n\t */\n\t@Override\n\tprotected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n\t{\n\t\t// Strip mIRC colors and formatting\n\t\tnotice = Colors.removeFormattingAndColors(notice);\n\t\t\n\t\t// Post notice to currently selected conversation\n\t\tConversation conversation = server.getConversation(server.getSelectedConversation());\n\t\t\n\t\tif (conversation == null) {\n\t\t\t// Fallback: Use ServerInfo view\n\t\t\tconversation = server.getConversation(ServerInfo.DEFAULT_NAME);\n\t\t}\n\n\t\tMessage message = new Message(\"-\" + sourceNick + \"- \" + notice);\n\t\tmessage.setIcon(R.drawable.info);\n\t\tconversation.addMessage(message);\n\t\t\n\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\tserver.getId(),\n\t\t\tconversation.getName()\n\t\t);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Op\n\t */\n\t@Override\n\tprotected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tMessage message = new Message(sourceNick + \" ops \" + recipient);\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tmessage.setIcon(R.drawable.op);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\tserver.getId(),\n\t\t\ttarget\n\t\t);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Part\n\t */\n\t@Override\n\tprotected void onPart(String target, String sender, String login, String hostname)\n\t{\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We parted a channel\n\t\t\tserver.removeConversation(target);\n\t\t\t\n\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\tBroadcast.CONVERSATION_REMOVE,\n\t\t\t\tserver.getId(),\n\t\t\t\ttarget\n\t\t\t);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tMessage message = new Message(sender + \" parts\");\n\t\t\tmessage.setColor(Message.COLOR_GREEN);\n\t\t\tmessage.setIcon(R.drawable.part);\n\t\t\tserver.getConversation(target).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\t\tserver.getId(),\n\t\t\t\ttarget\n\t\t\t);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Private Message\n\t */\n\t@Override\n\tprotected void onPrivateMessage(String sender, String login, String hostname, String text)\n\t{\n\t\t// Strip mIRC colors and formatting\n\t\ttext = Colors.removeFormattingAndColors(text);\n\n\t\tMessage message = new Message(\"<\" + sender + \"> \" + text);\n\t\t\n\t\tif (text.contains(getNick())) {\n\t\t\tmessage.setColor(Message.COLOR_RED);\n\t\t}\n\n\t\tConversation conversation = server.getConversation(sender);\n\n\t\tif (conversation == null) { \n\t\t\t// Open a query if there's none yet\n\t\t\tconversation = new Query(sender);\n\t\t\tconversation.addMessage(message);\n\t\t\tserver.addConversationl(conversation);\n\t\t\t\n\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\tBroadcast.CONVERSATION_NEW,\n\t\t\t\tserver.getId(),\n\t\t\t\tsender\n\t\t\t);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tconversation.addMessage(message);\n\t\t\t\n\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\t\tserver.getId(),\n\t\t\t\tsender\n\t\t\t);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Quit\n\t */\n\t@Override\n\tprotected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n\t{\n\t\tif (!sourceNick.equals(this.getNick())) {\n\t\t\tVector<String> channels = getChannelsByNickname(sourceNick);\n\t\t\t\n\t\t\tfor (String target : channels) {\n\t\t\t\tMessage message = new Message(sourceNick + \" quits (\" + reason + \")\");\n\t\t\t\tmessage.setColor(Message.COLOR_GREEN);\n\t\t\t\tmessage.setIcon(R.drawable.quit);\n\t\t\t\tserver.getConversation(target).addMessage(message);\n\t\t\t\t\n\t\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\t\t\tserver.getId(),\n\t\t\t\t\ttarget\n\t\t\t\t);\n\t\t\t\tservice.sendBroadcast(intent);\n\t\t\t}\n\t\t\t\n\t\t\t// Look if there's a query to update\n\t\t\tConversation conversation = server.getConversation(sourceNick);\n\t\t\t\n\t\t\tif (conversation != null) {\n\t\t\t\tMessage message = new Message(sourceNick + \" quits (\" + reason + \")\");\n\t\t\t\tmessage.setColor(Message.COLOR_GREEN);\n\t\t\t\tmessage.setIcon(R.drawable.quit);\n\t\t\t\tconversation.addMessage(message);\n\t\t\t\t\n\t\t\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\t\t\tserver.getId(),\n\t\t\t\t\tconversation.getName()\n\t\t\t\t);\n\t\t\t\tservice.sendBroadcast(intent);\n\t\t\t}\n\t\t\t\n\t\t} else {\n\t\t\t// XXX: We quitted\n\t\t}\n\t}\n\n\t/**\n\t * On Topic\n\t */\n\t@Override\n\tpublic void onTopic(String target, String topic, String setBy, long date, boolean changed)\n\t{\n\t\t// strip mIRC colors\n\t\ttopic = Colors.removeFormattingAndColors(topic);\n\t\t\n\t\tif (changed) {\n\t\t\tMessage message = new Message(setBy + \" sets topic: \" + topic);\n\t\t\tmessage.setColor(Message.COLOR_YELLOW);\n\t\t\tserver.getConversation(target).addMessage(message);\n\t\t} else {\n\t\t\tMessage message = new Message(\"Topic: \" + topic);\n\t\t\tmessage.setColor(Message.COLOR_YELLOW);\n\t\t\tserver.getConversation(target).addMessage(message);\n\t\t}\n\t\t\n\t\t// remember channel's topic\n\t\t((Channel) server.getConversation(target)).setTopic(topic);\n\t\t\n\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\tserver.getId(),\n\t\t\ttarget\n\t\t);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On User List\n\t */\n\t@Override\n\tprotected void onUserList(String channel, User[] users)\n\t{\n\t\t// XXX: Store user list somewhere and keep it updated or just broadcast some event?\n\t}\n\n\t/**\n\t * On Voice\n\t */\n\t@Override\n\tprotected void onVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tMessage message = new Message(sourceNick + \" voices \" + recipient);\n\t\tmessage.setIcon(R.drawable.voice);\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\tserver.getId(),\n\t\t\ttarget\n\t\t);\n\t\tservice.sendBroadcast(intent);\n\t}\n\t\n\t/**\n\t * On remove channel key\t\n\t */\n\t@Override\n\tprotected void onRemoveChannelKey(String target, String sourceNick, String sourceLogin, String sourceHostname, String key)\n\t{\n\t\tMessage message = new Message(sourceNick + \" removes channel key\");\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\n\t/**\n\t * On set channel key\n\t */\n\t@Override\n\tprotected void onSetChannelKey(String target, String sourceNick, String sourceLogin, String sourceHostname, String key)\n\t{\n\t\tMessage message = new Message(sourceNick + \" sets channel key: \" + key);\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\t\n\t/**\n\t * On set secret\n\t */\n\t@Override\n\tprotected void onSetSecret(String target, String sourceNick, String sourceLogin, String sourceHostname)\n\t{\n\t\tMessage message = new Message(sourceNick + \" sets channel secret\");\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\t\n\t/**\n\t * On remove secret\n\t */\n\t@Override\n\tprotected void onRemoveSecret(String target, String sourceNick, String sourceLogin, String sourceHostname)\n\t{\n\t\tMessage message = new Message(sourceNick + \" sets channel public\");\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\t\n\t/**\n\t * On set channel limit\n\t */\n\t@Override\n\tprotected void onSetChannelLimit(String target, String sourceNick, String sourceLogin, String sourceHostname, int limit)\n\t{\n\t\tMessage message = new Message(sourceNick + \" sets limit: \" + limit);\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\t\n\t/**\n\t * On remove channel limit\n\t */\n\t@Override\n\tprotected void onRemoveChannelLimit(String target, String sourceNick, String sourceLogin, String sourceHostname)\n\t{\n\t\tMessage message = new Message(sourceNick + \" removes limit\");\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\n\t/**\n\t * On set channel ban\n\t */\n\t@Override\n\tprotected void onSetChannelBan(String target, String sourceNick, String sourceLogin, String sourceHostname, String hostmask)\n\t{\n\t\tMessage message = new Message(sourceNick + \" sets ban: \" + hostmask);\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\t\n\t/**\n\t * On remove channel ban\n\t */\n\t@Override\n\tprotected void onRemoveChannelBan(String target, String sourceNick, String sourceLogin, String sourceHostname, String hostmask)\n\t{\n\t\tMessage message = new Message(sourceNick + \" removes ban: \" + hostmask);\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\t\n\t/**\n\t * On set topic protection\n\t */\n\t@Override\n\tprotected void onSetTopicProtection(String target, String sourceNick, String sourceLogin, String sourceHostname)\n\t{\n\t\tMessage message = new Message(sourceNick + \" sets topic protection\");\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\t\n\t/**\n\t * On remove topic protection\n\t */\n\t@Override\n\tprotected void onRemoveTopicProtection(String target, String sourceNick, String sourceLogin, String sourceHostname)\n\t{\n\t\tMessage message = new Message(sourceNick + \" removes topic protection\");\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\n\t/**\n\t * On set no external messages\n\t */\n\t@Override\n\tprotected void onSetNoExternalMessages(String target, String sourceNick, String sourceLogin, String sourceHostname)\n\t{\n\t\tMessage message = new Message(sourceNick + \" disables external messages\");\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\n\t/**\n\t * On remove no external messages\n\t */\n\t@Override\n\tprotected void onRemoveNoExternalMessages(String target, String sourceNick, String sourceLogin, String sourceHostname)\n\t{\n\t\tMessage message = new Message(sourceNick + \" enables external messages\");\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\t\n\t/**\n\t * On set invite only\n\t */\n\t@Override\n\tprotected void onSetInviteOnly(String target, String sourceNick, String sourceLogin, String sourceHostname)\n\t{\n\t\tMessage message = new Message(sourceNick + \" sets invite only\");\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\t\n\t/**\n\t * On remove invite only\n\t */\n\t@Override\n\tprotected void onRemoveInviteOnly(String target, String sourceNick, String sourceLogin, String sourceHostname)\n\t{\n\t\tMessage message = new Message(sourceNick + \" removes invite only\");\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\n\t/**\n\t * On set moderated\n\t */\n\t@Override\n\tprotected void onSetModerated(String target, String sourceNick, String sourceLogin, String sourceHostname)\n\t{\n\t\tMessage message = new Message(sourceNick + \" sets moderated\");\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\t\n\t/**\n\t * On remove moderated\n\t */\n\t@Override\n\tprotected void onRemoveModerated(String target, String sourceNick, String sourceLogin, String sourceHostname)\n\t{\n\t\tMessage message = new Message(sourceNick + \" removes moderated\");\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\t\n\t/**\n\t * On set private\n\t */\n\t@Override\n\tprotected void onSetPrivate(String target, String sourceNick, String sourceLogin, String sourceHostname)\n\t{\n\t\tMessage message = new Message(sourceNick + \" sets channel private\");\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\t\n\t/**\n\t * On remove private\n\t */\n\t@Override\n\tprotected void onRemovePrivate(String target, String sourceNick, String sourceLogin, String sourceHostname)\n\t{\n\t\tMessage message = new Message(sourceNick + \" sets channel public\");\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tservice.sendBroadcast(\n\t\t\tBroadcast.createConversationIntent(Broadcast.CONVERSATION_MESSAGE, server.getId(), target)\n\t\t);\n\t}\n\n\t/**\n\t * On unknown\n\t */\n\t@Override\n\tprotected void onUnknown(String line)\n\t{\n\t\tMessage message = new Message(line);\n\t\tmessage.setIcon(R.drawable.action);\n\t\tmessage.setColor(Message.COLOR_GREY);\n\t\tserver.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\t\t\n\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\tserver.getId(),\n\t\t\tServerInfo.DEFAULT_NAME\n\t\t);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On server response\n\t */\n\t@Override\n\tprotected void onServerResponse(int code, String response)\n\t{\n\t\tif (code == 372 || code == 375 || code == 376) {\n\t\t\t// Skip MOTD\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (code >= 200 && code < 300) {\n\t\t\t// Skip 2XX responses\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (code == 353 || code == 366 || code == 332 || code == 333) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (code < 10) {\n\t\t\t// Skip server info\n\t\t\treturn;\n\t\t}\n\n\t\t// Currently disabled... to much text\n\t\tMessage message = new Message(response);\n\t\tmessage.setColor(Message.COLOR_GREY);\n\t\tserver.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\t\t\n\t\tIntent intent = Broadcast.createConversationIntent(\n\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\tserver.getId(),\n\t\t\tServerInfo.DEFAULT_NAME\n\t\t);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On disconnect\n\t */\n\t@Override\n\tpublic void onDisconnect()\n\t{\n\t\tserver.setStatus(Status.DISCONNECTED);\n\t\t\n\t\tIntent sIntent = Broadcast.createServerIntent(Broadcast.SERVER_UPDATE, server.getId());\n\t\tservice.sendBroadcast(sIntent);\t\t\n\t\t\n\t\tMessage message = new Message(\"Disconnected\");\n\t\tmessage.setIcon(R.drawable.error);\n\t\tmessage.setColor(Message.COLOR_RED);\n\t\tserver.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\t\t\n\t\tIntent cIntent = Broadcast.createConversationIntent(\n\t\t\tBroadcast.CONVERSATION_MESSAGE,\n\t\t\tserver.getId(),\n\t\t\tServerInfo.DEFAULT_NAME\n\t\t);\n\t\tservice.sendBroadcast(cIntent);\n\t}\n\t\n\t/**\n\t * Get all channels where the user with the given nickname is online\n\t * \n\t * @param nickname\n\t * @return Array of channel names\n\t */\n\tprivate Vector<String> getChannelsByNickname(String nickname)\n\t{\n\t\tVector<String> channels = new Vector<String>();\n\t\tString[] channelArray = getChannels();\n\t\t\n\t\tfor (String channel : channelArray) {\n\t\t\tUser[] userArray = getUsers(channel);\n\t\t\tfor (User user : userArray) {\n\t\t\t\tif (user.getNick().equals(nickname)) {\n\t\t\t\t\tchannels.add(channel);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn channels;\n\t}\n\t\n\t/**\n\t * Quits from the IRC server with default reason.\n\t */\n\t@Override\n\tpublic void quitServer()\n\t{\n\t\tnew Thread() {\n\t\t\tpublic void run() {\n\t\t\t\tquitServer(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t\t\t}\n\t\t}.start();\n\t}\n}\n","lineNo":530}
{"Smelly Sample":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2010 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.view;\n\nimport android.app.Activity;\nimport android.content.ComponentName;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.os.Bundle;\nimport android.os.IBinder;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.View.OnKeyListener;\nimport android.widget.AdapterView;\nimport android.widget.EditText;\nimport android.widget.Gallery;\nimport android.widget.ImageView;\nimport android.widget.ListView;\nimport android.widget.TextView;\nimport android.widget.ViewSwitcher;\nimport android.widget.AdapterView.OnItemClickListener;\nimport android.widget.AdapterView.OnItemSelectedListener;\nimport android.widget.TableLayout.LayoutParams;\n\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.adapter.DeckAdapter;\nimport org.yaaic.adapter.MessageListAdapter;\nimport org.yaaic.command.CommandParser;\nimport org.yaaic.irc.IRCBinder;\nimport org.yaaic.irc.IRCService;\nimport org.yaaic.layout.NonScalingBackgroundDrawable;\nimport org.yaaic.listener.ConversationListener;\nimport org.yaaic.listener.ServerListener;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.Status;\nimport org.yaaic.receiver.ConversationReceiver;\nimport org.yaaic.receiver.ServerReceiver;\n\n/**\n * The server view with a scrollable list of all channels\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class ConversationActivity extends Activity implements ServiceConnection, ServerListener, ConversationListener, OnItemClickListener, OnKeyListener, OnItemSelectedListener\n{\n\tprivate int serverId;\n\tprivate Server server;\n\tprivate IRCBinder binder;\n\tprivate ConversationReceiver channelReceiver;\n\tprivate ServerReceiver serverReceiver;\n\t\n\tprivate ViewSwitcher switcher;\n\tprivate Gallery deck;\n\tprivate DeckAdapter deckAdapter;\n\t\n\t/**\n\t * On create\n\t */\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState)\n\t{\n\t\tsuper.onCreate(savedInstanceState);\n\t\t\n\t\tserverId = getIntent().getExtras().getInt(\"serverId\");\n\t\tserver = (Server) Yaaic.getInstance().getServerById(serverId);\n\t\tsetTitle(\"Yaaic - \" + server.getTitle());\n\t\t\n\t\tsetContentView(R.layout.conversations);\n\t\t\n\t\t((TextView) findViewById(R.id.title)).setText(server.getTitle());\n\t\t((EditText) findViewById(R.id.input)).setOnKeyListener(this);\n\n        deckAdapter = new DeckAdapter();\n\t\tdeck = (Gallery) findViewById(R.id.deck);\n\t\tdeck.setOnItemSelectedListener(this);\n\t\tdeck.setAdapter(deckAdapter);\n\t\tdeck.setOnItemClickListener(this);\n\t\tdeck.setBackgroundDrawable(new NonScalingBackgroundDrawable(this, deck, R.drawable.icon));\n\n\t\tswitcher = (ViewSwitcher) findViewById(R.id.switcher);\n\t\t\n\t\tfor (Conversation conversation : server.getConversations()) {\n\t\t\tonNewConversation(conversation.getName());\n\t\t}\n\t}\n\t\n\t/**\n\t * On resume\n\t */\n\t@Override\n\tpublic void onResume()\n\t{\n\t\tsuper.onResume();\n\t\t\n\t\t((ImageView) findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\t\t\n        Intent intent = new Intent(this, IRCService.class);\n        bindService(intent, this, 0);\n        \n    \tchannelReceiver = new ConversationReceiver(server.getId(), this);\n    \tregisterReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_MESSAGE));\n    \tregisterReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_NEW));\n    \tregisterReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_REMOVE));\n\n    \tserverReceiver = new ServerReceiver(this);\n    \tregisterReceiver(serverReceiver, new IntentFilter(Broadcast.SERVER_UPDATE));\n\n\t\tif (!server.isConnected()) {\n\t\t\t ((EditText) findViewById(R.id.input)).setEnabled(false);\n\t\t} else {\n\t\t\t ((EditText) findViewById(R.id.input)).setEnabled(true);\n\t\t}\n\t\t\n\t\t// Fill view with messages that have been buffered while paused\n\t\tfor (Conversation conversation : server.getConversations()) {\n\t\t\twhile (conversation.hasBufferedMessages()) {\n\t\t\t\tif (conversation.getMessageListAdapter() != null) {\n\t\t\t\t\tconversation.getMessageListAdapter().addMessage(conversation.pollBufferedMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * On Pause\n\t */\n\t@Override\n\tpublic void onPause()\n\t{\n\t\tsuper.onPause();\n\t\t\n\t\tunbindService(this);\n\t\tunregisterReceiver(channelReceiver);\n\t\tunregisterReceiver(serverReceiver);\n\t}\n\n\t/**\n\t * On service connected\n\t */\n\tpublic void onServiceConnected(ComponentName name, IBinder service)\n\t{\n\t\tthis.binder = (IRCBinder) service;\n\t\t\n\t\t// connect to irc server if connect has been requested\n\t\tif (server.getStatus() == Status.PRE_CONNECTING && getIntent().hasExtra(\"connect\")) {\n\t\t\tserver.setStatus(Status.CONNECTING);\n\t\t\tbinder.connect(server);\n\t\t}\n\t}\n\n\t/**\n\t * On service disconnected\n\t */\n\tpublic void onServiceDisconnected(ComponentName name)\n\t{\n\t\tthis.binder = null;\n\t}\n\n\t/**\n\t * On options menu requested\n\t */\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu)\n\t{\n    \tsuper.onCreateOptionsMenu(menu);\n    \t\n    \t// inflate from xml\n    \tMenuInflater inflater = getMenuInflater();\n    \tinflater.inflate(R.menu.conversations, menu);\n    \t\n    \treturn true;\n\t}\n\n\t/**\n\t * On menu item selected\n\t */\n\t@Override\n\tpublic boolean onMenuItemSelected(int featureId, MenuItem item)\n\t{\n\t\tswitch (item.getItemId()) {\n\t\t\tcase R.id.disconnect:\n\t\t\t\tbinder.getService().getConnection(serverId).quitServer();\n\t\t\t\tserver.clearConversations();\n\t\t\t\tsetResult(RESULT_OK);\n\t\t\t\tfinish();\n\t\t\t\tbreak;\n\t\t\tcase R.id.join:\n\t\t\t\tstartActivityForResult(new Intent(this, JoinActivity.class), 0);\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\t/**\n\t * Get server object assigned to this activity\n\t * \n\t * @return the server object\n\t */\n\tpublic Server getServer()\n\t{\n\t\treturn server;\n\t}\n\n\t/**\n\t * On conversation message\n\t */\n\tpublic void onConversationMessage(String target)\n\t{\n\t\tConversation conversation = server.getConversation(target);\n\t\tMessageListAdapter adapter = conversation.getMessageListAdapter();\n\t\t\n\t\twhile(conversation.hasBufferedMessages()) {\n\t\t\tMessage message = conversation.pollBufferedMessage();\n\t\t\t\n\t\t\tif (adapter != null) {\n\t\t\t\tadapter.addMessage(message);\n\t\t\t} else {\n\t\t\t\t//\"MessageListAdapter is null (conversation \" + conversation.getName() + \" has no adapter assigned)\"\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * On new conversation\n\t */\n\tpublic void onNewConversation(String target)\n\t{\n\t\tdeckAdapter.addItem(server.getConversation(target));\n\t\t\n\t\tif (!deckAdapter.isSwitched()) {\n\t\t\t// Scroll to new conversation\n\t\t\tdeck.setSelection(deckAdapter.getCount() - 1);\n\t\t}\n\t}\n\t\n\t/**\n\t * On conversation remove\n\t */\n\tpublic void onRemoveConversation(String target)\n\t{\n\t\tdeckAdapter.removeItem(target);\n\t\t\n\t\tif (deckAdapter.isSwitched()) {\n\t\t\tonBackPressed();\n\t\t}\n\t}\n\n\t/**\n\t * On server status update\n\t */\n\tpublic void onStatusUpdate()\n\t{\n\t\t((ImageView) findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\t\t\n\t\tEditText input = (EditText) findViewById(R.id.input);\n\t\tif (server.isConnected()) {\n\t\t\tinput.setEnabled(true); \n\t\t} else {\n\t\t\tinput.setEnabled(false);\n\t\t}\n\t}\n\n\t/**\n\t * On conversation item clicked\n\t */\n\tpublic void onItemClick(AdapterView<?> adapterView, View view, int position, long id)\n\t{\n\t\tConversation conversation = deckAdapter.getItem(position);\n\t\t\n\t\tMessageListView canvas = deckAdapter.renderConversation(conversation, switcher);\n\t\tcanvas.setTranscriptMode(ListView.TRANSCRIPT_MODE_NORMAL);\n\t\tcanvas.setLayoutParams(new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT));\n\t\tcanvas.setDelegateTouchEvents(false); // Do not delegate\n\t\t\n\t\tdeckAdapter.setSwitched(conversation.getName(), canvas);\n\t\tswitcher.addView(canvas);\n\t\tswitcher.showNext();\n\t}\n\t\n\t/**\n\t * On key down\n\t * \n\t * This is glue code to call onBackPressed() which\n\t * will be automatically called by later android releases\n\t */\n\t@Override\n\tpublic boolean onKeyDown(int keyCode, KeyEvent event)\n\t{\n\t\tif (keyCode == KeyEvent.KEYCODE_BACK) {\n\t\t\tonBackPressed();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * On back key pressed\n\t */\n\tpublic void onBackPressed()\n\t{\n\t\tif (deckAdapter.isSwitched()) {\n\t\t\tswitcher.showNext();\n\t\t\tswitcher.removeView(deckAdapter.getSwitchedView());\n\t\t\tdeckAdapter.setSwitched(null, null);\n\t\t} else {\n\t\t\tfinish();\n\t\t}\n\t}\n\n\t/**\n\t * On key pressed (input line)\n\t */\n\tpublic boolean onKey(View view, int keyCode, KeyEvent event)\n\t{\n\t\tif (keyCode == KeyEvent.KEYCODE_ENTER && event.getAction() == KeyEvent.ACTION_UP) {\n\t\t\tif (!server.isConnected()) {\n\t\t\t\tMessage message = new Message(\"Not connected\");\n\t\t\t\tmessage.setColor(Message.COLOR_RED);\n\t\t\t\tmessage.setIcon(R.drawable.error);\n\t\t\t\tserver.getConversation(server.getSelectedConversation()).addMessage(message);\n\t\t\t\tonConversationMessage(server.getSelectedConversation());\n\t\t\t}\n\t\t\t\n\t\t\tEditText input = (EditText) view;\n\t\t\tString text = input.getText().toString();\n\t\t\tinput.setText(\"\");\n\t\t\t\n\t\t\tif (text == \"\") {\n\t\t\t\t// ignore empty messages\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\tConversation conversation = deckAdapter.getItem(deck.getSelectedItemPosition());\n\t\t\t\n\t\t\tif (conversation != null) {\n\t\t\t\tif (!text.trim().startsWith(\"/\")) {\n\t\t\t\t\tif (conversation.getType() != Conversation.TYPE_SERVER) {\n\t\t\t\t\t\tString nickname = binder.getService().getConnection(serverId).getNick();\n\t\t\t\t\t\tconversation.addMessage(new Message(\"<\" + nickname + \"> \" + text));\n\t\t\t\t\t\tbinder.getService().getConnection(serverId).sendMessage(conversation.getName(), text);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tMessage message = new Message(\"You can only chat from within a channel or a query\");\n\t\t\t\t\t\tmessage.setColor(Message.COLOR_YELLOW);\n\t\t\t\t\t\tmessage.setIcon(R.drawable.warning);\n\t\t\t\t\t\tconversation.addMessage(message);\n\t\t\t\t\t}\n\t\t\t\t\tonConversationMessage(conversation.getName());\n\t\t\t\t} else {\n\t\t\t\t\tCommandParser.getInstance().parse(text, server, conversation, binder.getService());\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * On activity result\n\t */\n\t@Override\n\tprotected void onActivityResult(int requestCode, int resultCode, Intent data)\n\t{\n\t\t// currently there's only the \"join channel\" activity\n\t\tif (resultCode == RESULT_OK) {\n\t\t\tfinal String channel = data.getExtras().getString(\"channel\");\n\t\t\t\n\t\t\t// run on own thread\n\t\t\tnew Thread() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tbinder.getService().getConnection(serverId).joinChannel(channel);\n\t\t\t\t}\n\t\t\t}.start();\n\t\t}\n\t}\n\n\t/**\n\t * On channel selected/focused\n\t */\n\tpublic void onItemSelected(AdapterView<?> deck, View view, int position, long id)\n\t{\n\t\tConversation conversation = (Conversation) deck.getItemAtPosition(position);\n\t\t\n\t\tif (conversation != null && conversation.getType() != Conversation.TYPE_SERVER) {\n\t\t\t((TextView) findViewById(R.id.title)).setText(server.getTitle() + \" - \" + conversation.getName());\n\t\t} else {\n\t\t\tonNothingSelected(deck);\n\t\t}\n\t\t\n\t\t// Remember selection\n\t\tif (conversation != null) {\n\t\t\tserver.setSelectedConversation(conversation.getName());\n\t\t}\n\t}\n\n\t/**\n\t * On no channel selected/focused\n\t */\n\tpublic void onNothingSelected(AdapterView<?> deck)\n\t{\n\t\t((TextView) findViewById(R.id.title)).setText(server.getTitle());\n\t}\n}\n","Method after Refactoring":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2010 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.view;\n\nimport java.util.Collection;\n\nimport android.app.Activity;\nimport android.content.ComponentName;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.os.Bundle;\nimport android.os.IBinder;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.View.OnKeyListener;\nimport android.widget.AdapterView;\nimport android.widget.EditText;\nimport android.widget.Gallery;\nimport android.widget.ImageView;\nimport android.widget.ListView;\nimport android.widget.TextView;\nimport android.widget.ViewSwitcher;\nimport android.widget.AdapterView.OnItemClickListener;\nimport android.widget.AdapterView.OnItemSelectedListener;\nimport android.widget.TableLayout.LayoutParams;\n\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.adapter.DeckAdapter;\nimport org.yaaic.adapter.MessageListAdapter;\nimport org.yaaic.command.CommandParser;\nimport org.yaaic.irc.IRCBinder;\nimport org.yaaic.irc.IRCService;\nimport org.yaaic.layout.NonScalingBackgroundDrawable;\nimport org.yaaic.listener.ConversationListener;\nimport org.yaaic.listener.ServerListener;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.Status;\nimport org.yaaic.receiver.ConversationReceiver;\nimport org.yaaic.receiver.ServerReceiver;\n\n/**\n * The server view with a scrollable list of all channels\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class ConversationActivity extends Activity implements ServiceConnection, ServerListener, ConversationListener, OnItemClickListener, OnKeyListener, OnItemSelectedListener\n{\n\tprivate int serverId;\n\tprivate Server server;\n\tprivate IRCBinder binder;\n\tprivate ConversationReceiver channelReceiver;\n\tprivate ServerReceiver serverReceiver;\n\t\n\tprivate ViewSwitcher switcher;\n\tprivate Gallery deck;\n\tprivate DeckAdapter deckAdapter;\n\t\n\t/**\n\t * On create\n\t */\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState)\n\t{\n\t\tsuper.onCreate(savedInstanceState);\n\t\t\n\t\tserverId = getIntent().getExtras().getInt(\"serverId\");\n\t\tserver = (Server) Yaaic.getInstance().getServerById(serverId);\n\t\tsetTitle(\"Yaaic - \" + server.getTitle());\n\t\t\n\t\tsetContentView(R.layout.conversations);\n\t\t\n\t\t((TextView) findViewById(R.id.title)).setText(server.getTitle());\n\t\t((EditText) findViewById(R.id.input)).setOnKeyListener(this);\n\n        deckAdapter = new DeckAdapter();\n\t\tdeck = (Gallery) findViewById(R.id.deck);\n\t\tdeck.setOnItemSelectedListener(this);\n\t\tdeck.setAdapter(deckAdapter);\n\t\tdeck.setOnItemClickListener(this);\n\t\tdeck.setBackgroundDrawable(new NonScalingBackgroundDrawable(this, deck, R.drawable.icon));\n\n\t\tswitcher = (ViewSwitcher) findViewById(R.id.switcher);\n\t\t\n\t\t// Optimization : cache field lookups \n\t\tCollection<Conversation> mConversations = server.getConversations();\n\t\t\n\t\tfor (Conversation conversation : mConversations) {\n\t\t\tonNewConversation(conversation.getName());\n\t\t}\n\t}\n\t\n\t/**\n\t * On resume\n\t */\n\t@Override\n\tpublic void onResume()\n\t{\n\t\tsuper.onResume();\n\t\t\n\t\t((ImageView) findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\t\t\n        bindService(new Intent(this, IRCService.class), this, 0);\n        \n    \tchannelReceiver = new ConversationReceiver(server.getId(), this);\n    \tregisterReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_MESSAGE));\n    \tregisterReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_NEW));\n    \tregisterReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_REMOVE));\n\n    \tserverReceiver = new ServerReceiver(this);\n    \tregisterReceiver(serverReceiver, new IntentFilter(Broadcast.SERVER_UPDATE));\n\n\t\tif (!server.isConnected()) {\n\t\t\t ((EditText) findViewById(R.id.input)).setEnabled(false);\n\t\t} else {\n\t\t\t ((EditText) findViewById(R.id.input)).setEnabled(true);\n\t\t}\n\n\t\t// Optimization - cache field lookup\n\t\tCollection<Conversation> mConversations = server.getConversations();\n\t\tMessageListAdapter mAdapter;\n\t\t\n\t\t// Fill view with messages that have been buffered while paused\n\t\tfor (Conversation conversation : mConversations) {\n\t\t\tmAdapter = conversation.getMessageListAdapter();\n\t\t\t\n\t\t\tif (mAdapter != null) {\n\t\t\t\tmAdapter.addBulkMessages(conversation.getBuffer());\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * On Pause\n\t */\n\t@Override\n\tpublic void onPause()\n\t{\n\t\tsuper.onPause();\n\t\t\n\t\tunbindService(this);\n\t\tunregisterReceiver(channelReceiver);\n\t\tunregisterReceiver(serverReceiver);\n\t}\n\n\t/**\n\t * On service connected\n\t */\n\tpublic void onServiceConnected(ComponentName name, IBinder service)\n\t{\n\t\tthis.binder = (IRCBinder) service;\n\t\t\n\t\t// connect to irc server if connect has been requested\n\t\tif (server.getStatus() == Status.PRE_CONNECTING && getIntent().hasExtra(\"connect\")) {\n\t\t\tserver.setStatus(Status.CONNECTING);\n\t\t\tbinder.connect(server);\n\t\t}\n\t}\n\n\t/**\n\t * On service disconnected\n\t */\n\tpublic void onServiceDisconnected(ComponentName name)\n\t{\n\t\tthis.binder = null;\n\t}\n\n\t/**\n\t * On options menu requested\n\t */\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu)\n\t{\n    \tsuper.onCreateOptionsMenu(menu);\n    \t\n    \t// inflate from xml\n    \tMenuInflater inflater = getMenuInflater();\n    \tinflater.inflate(R.menu.conversations, menu);\n    \t\n    \treturn true;\n\t}\n\n\t/**\n\t * On menu item selected\n\t */\n\t@Override\n\tpublic boolean onMenuItemSelected(int featureId, MenuItem item)\n\t{\n\t\tswitch (item.getItemId()) {\n\t\t\tcase R.id.disconnect:\n\t\t\t\tbinder.getService().getConnection(serverId).quitServer();\n\t\t\t\tserver.clearConversations();\n\t\t\t\tsetResult(RESULT_OK);\n\t\t\t\tfinish();\n\t\t\t\tbreak;\n\t\t\tcase R.id.join:\n\t\t\t\tstartActivityForResult(new Intent(this, JoinActivity.class), 0);\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\t/**\n\t * Get server object assigned to this activity\n\t * \n\t * @return the server object\n\t */\n\tpublic Server getServer()\n\t{\n\t\treturn server;\n\t}\n\n\t/**\n\t * On conversation message\n\t */\n\tpublic void onConversationMessage(String target)\n\t{\n\t\tConversation conversation = server.getConversation(target);\n\t\tMessageListAdapter adapter = conversation.getMessageListAdapter();\n\t\t\n\t\twhile(conversation.hasBufferedMessages()) {\n\t\t\tMessage message = conversation.pollBufferedMessage();\n\t\t\t\n\t\t\tif (adapter != null) {\n\t\t\t\tadapter.addMessage(message);\n\t\t\t} else {\n\t\t\t\t//\"MessageListAdapter is null (conversation \" + conversation.getName() + \" has no adapter assigned)\"\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * On new conversation\n\t */\n\tpublic void onNewConversation(String target)\n\t{\n\t\tdeckAdapter.addItem(server.getConversation(target));\n\t\t\n\t\tif (!deckAdapter.isSwitched()) {\n\t\t\t// Scroll to new conversation\n\t\t\tdeck.setSelection(deckAdapter.getCount() - 1);\n\t\t}\n\t}\n\t\n\t/**\n\t * On conversation remove\n\t */\n\tpublic void onRemoveConversation(String target)\n\t{\n\t\tdeckAdapter.removeItem(target);\n\t\t\n\t\tif (deckAdapter.isSwitched()) {\n\t\t\tonBackPressed();\n\t\t}\n\t}\n\n\t/**\n\t * On server status update\n\t */\n\tpublic void onStatusUpdate()\n\t{\n\t\t((ImageView) findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\t\t\n\t\tEditText input = (EditText) findViewById(R.id.input);\n\t\tif (server.isConnected()) {\n\t\t\tinput.setEnabled(true); \n\t\t} else {\n\t\t\tinput.setEnabled(false);\n\t\t}\n\t}\n\n\t/**\n\t * On conversation item clicked\n\t */\n\tpublic void onItemClick(AdapterView<?> adapterView, View view, int position, long id)\n\t{\n\t\tConversation conversation = deckAdapter.getItem(position);\n\t\t\n\t\tMessageListView canvas = deckAdapter.renderConversation(conversation, switcher);\n\t\tcanvas.setTranscriptMode(ListView.TRANSCRIPT_MODE_NORMAL);\n\t\tcanvas.setLayoutParams(new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT));\n\t\tcanvas.setDelegateTouchEvents(false); // Do not delegate\n\t\t\n\t\tdeckAdapter.setSwitched(conversation.getName(), canvas);\n\t\tswitcher.addView(canvas);\n\t\tswitcher.showNext();\n\t}\n\t\n\t/**\n\t * On key down\n\t * \n\t * This is glue code to call onBackPressed() which\n\t * will be automatically called by later android releases\n\t */\n\t@Override\n\tpublic boolean onKeyDown(int keyCode, KeyEvent event)\n\t{\n\t\tif (keyCode == KeyEvent.KEYCODE_BACK) {\n\t\t\tonBackPressed();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * On back key pressed\n\t */\n\tpublic void onBackPressed()\n\t{\n\t\tif (deckAdapter.isSwitched()) {\n\t\t\tswitcher.showNext();\n\t\t\tswitcher.removeView(deckAdapter.getSwitchedView());\n\t\t\tdeckAdapter.setSwitched(null, null);\n\t\t} else {\n\t\t\tfinish();\n\t\t}\n\t}\n\n\t/**\n\t * On key pressed (input line)\n\t */\n\tpublic boolean onKey(View view, int keyCode, KeyEvent event)\n\t{\n\t\tif (keyCode == KeyEvent.KEYCODE_ENTER && event.getAction() == KeyEvent.ACTION_UP) {\n\t\t\tif (!server.isConnected()) {\n\t\t\t\tMessage message = new Message(\"Not connected\");\n\t\t\t\tmessage.setColor(Message.COLOR_RED);\n\t\t\t\tmessage.setIcon(R.drawable.error);\n\t\t\t\tserver.getConversation(server.getSelectedConversation()).addMessage(message);\n\t\t\t\tonConversationMessage(server.getSelectedConversation());\n\t\t\t}\n\t\t\t\n\t\t\tEditText input = (EditText) view;\n\t\t\tString text = input.getText().toString();\n\t\t\tinput.setText(\"\");\n\t\t\t\n\t\t\tif (text == \"\") {\n\t\t\t\t// ignore empty messages\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\tConversation conversation = deckAdapter.getItem(deck.getSelectedItemPosition());\n\t\t\t\n\t\t\tif (conversation != null) {\n\t\t\t\tif (!text.trim().startsWith(\"/\")) {\n\t\t\t\t\tif (conversation.getType() != Conversation.TYPE_SERVER) {\n\t\t\t\t\t\tString nickname = binder.getService().getConnection(serverId).getNick();\n\t\t\t\t\t\tconversation.addMessage(new Message(\"<\" + nickname + \"> \" + text));\n\t\t\t\t\t\tbinder.getService().getConnection(serverId).sendMessage(conversation.getName(), text);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tMessage message = new Message(\"You can only chat from within a channel or a query\");\n\t\t\t\t\t\tmessage.setColor(Message.COLOR_YELLOW);\n\t\t\t\t\t\tmessage.setIcon(R.drawable.warning);\n\t\t\t\t\t\tconversation.addMessage(message);\n\t\t\t\t\t}\n\t\t\t\t\tonConversationMessage(conversation.getName());\n\t\t\t\t} else {\n\t\t\t\t\tCommandParser.getInstance().parse(text, server, conversation, binder.getService());\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * On activity result\n\t */\n\t@Override\n\tprotected void onActivityResult(int requestCode, int resultCode, Intent data)\n\t{\n\t\t// currently there's only the \"join channel\" activity\n\t\tif (resultCode == RESULT_OK) {\n\t\t\tfinal String channel = data.getExtras().getString(\"channel\");\n\t\t\t\n\t\t\t// run on own thread\n\t\t\tnew Thread() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tbinder.getService().getConnection(serverId).joinChannel(channel);\n\t\t\t\t}\n\t\t\t}.start();\n\t\t}\n\t}\n\n\t/**\n\t * On channel selected/focused\n\t */\n\tpublic void onItemSelected(AdapterView<?> deck, View view, int position, long id)\n\t{\n\t\tConversation conversation = (Conversation) deck.getItemAtPosition(position);\n\t\t\n\t\tif (conversation != null && conversation.getType() != Conversation.TYPE_SERVER) {\n\t\t\t((TextView) findViewById(R.id.title)).setText(server.getTitle() + \" - \" + conversation.getName());\n\t\t} else {\n\t\t\tonNothingSelected(deck);\n\t\t}\n\t\t\n\t\t// Remember selection\n\t\tif (conversation != null) {\n\t\t\tserver.setSelectedConversation(conversation.getName());\n\t\t}\n\t}\n\n\t/**\n\t * On no channel selected/focused\n\t */\n\tpublic void onNothingSelected(AdapterView<?> deck)\n\t{\n\t\t((TextView) findViewById(R.id.title)).setText(server.getTitle());\n\t}\n}\n","lineNo":111}
{"Smelly Sample":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2010 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.view;\n\nimport android.app.Activity;\nimport android.content.ComponentName;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.os.Bundle;\nimport android.os.IBinder;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.View.OnKeyListener;\nimport android.widget.AdapterView;\nimport android.widget.EditText;\nimport android.widget.Gallery;\nimport android.widget.ImageView;\nimport android.widget.ListView;\nimport android.widget.TextView;\nimport android.widget.ViewSwitcher;\nimport android.widget.AdapterView.OnItemClickListener;\nimport android.widget.AdapterView.OnItemSelectedListener;\nimport android.widget.TableLayout.LayoutParams;\n\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.adapter.DeckAdapter;\nimport org.yaaic.adapter.MessageListAdapter;\nimport org.yaaic.command.CommandParser;\nimport org.yaaic.irc.IRCBinder;\nimport org.yaaic.irc.IRCService;\nimport org.yaaic.layout.NonScalingBackgroundDrawable;\nimport org.yaaic.listener.ConversationListener;\nimport org.yaaic.listener.ServerListener;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.Status;\nimport org.yaaic.receiver.ConversationReceiver;\nimport org.yaaic.receiver.ServerReceiver;\n\n/**\n * The server view with a scrollable list of all channels\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class ConversationActivity extends Activity implements ServiceConnection, ServerListener, ConversationListener, OnItemClickListener, OnKeyListener, OnItemSelectedListener\n{\n\tprivate int serverId;\n\tprivate Server server;\n\tprivate IRCBinder binder;\n\tprivate ConversationReceiver channelReceiver;\n\tprivate ServerReceiver serverReceiver;\n\t\n\tprivate ViewSwitcher switcher;\n\tprivate Gallery deck;\n\tprivate DeckAdapter deckAdapter;\n\t\n\t/**\n\t * On create\n\t */\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState)\n\t{\n\t\tsuper.onCreate(savedInstanceState);\n\t\t\n\t\tserverId = getIntent().getExtras().getInt(\"serverId\");\n\t\tserver = (Server) Yaaic.getInstance().getServerById(serverId);\n\t\tsetTitle(\"Yaaic - \" + server.getTitle());\n\t\t\n\t\tsetContentView(R.layout.conversations);\n\t\t\n\t\t((TextView) findViewById(R.id.title)).setText(server.getTitle());\n\t\t((EditText) findViewById(R.id.input)).setOnKeyListener(this);\n\n        deckAdapter = new DeckAdapter();\n\t\tdeck = (Gallery) findViewById(R.id.deck);\n\t\tdeck.setOnItemSelectedListener(this);\n\t\tdeck.setAdapter(deckAdapter);\n\t\tdeck.setOnItemClickListener(this);\n\t\tdeck.setBackgroundDrawable(new NonScalingBackgroundDrawable(this, deck, R.drawable.icon));\n\n\t\tswitcher = (ViewSwitcher) findViewById(R.id.switcher);\n\t\t\n\t\tfor (Conversation conversation : server.getConversations()) {\n\t\t\tonNewConversation(conversation.getName());\n\t\t}\n\t}\n\t\n\t/**\n\t * On resume\n\t */\n\t@Override\n\tpublic void onResume()\n\t{\n\t\tsuper.onResume();\n\t\t\n\t\t((ImageView) findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\t\t\n        Intent intent = new Intent(this, IRCService.class);\n        bindService(intent, this, 0);\n        \n    \tchannelReceiver = new ConversationReceiver(server.getId(), this);\n    \tregisterReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_MESSAGE));\n    \tregisterReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_NEW));\n    \tregisterReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_REMOVE));\n\n    \tserverReceiver = new ServerReceiver(this);\n    \tregisterReceiver(serverReceiver, new IntentFilter(Broadcast.SERVER_UPDATE));\n\n\t\tif (!server.isConnected()) {\n\t\t\t ((EditText) findViewById(R.id.input)).setEnabled(false);\n\t\t} else {\n\t\t\t ((EditText) findViewById(R.id.input)).setEnabled(true);\n\t\t}\n\t\t\n\t\t// Fill view with messages that have been buffered while paused\n\t\tfor (Conversation conversation : server.getConversations()) {\n\t\t\twhile (conversation.hasBufferedMessages()) {\n\t\t\t\tif (conversation.getMessageListAdapter() != null) {\n\t\t\t\t\tconversation.getMessageListAdapter().addMessage(conversation.pollBufferedMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * On Pause\n\t */\n\t@Override\n\tpublic void onPause()\n\t{\n\t\tsuper.onPause();\n\t\t\n\t\tunbindService(this);\n\t\tunregisterReceiver(channelReceiver);\n\t\tunregisterReceiver(serverReceiver);\n\t}\n\n\t/**\n\t * On service connected\n\t */\n\tpublic void onServiceConnected(ComponentName name, IBinder service)\n\t{\n\t\tthis.binder = (IRCBinder) service;\n\t\t\n\t\t// connect to irc server if connect has been requested\n\t\tif (server.getStatus() == Status.PRE_CONNECTING && getIntent().hasExtra(\"connect\")) {\n\t\t\tserver.setStatus(Status.CONNECTING);\n\t\t\tbinder.connect(server);\n\t\t}\n\t}\n\n\t/**\n\t * On service disconnected\n\t */\n\tpublic void onServiceDisconnected(ComponentName name)\n\t{\n\t\tthis.binder = null;\n\t}\n\n\t/**\n\t * On options menu requested\n\t */\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu)\n\t{\n    \tsuper.onCreateOptionsMenu(menu);\n    \t\n    \t// inflate from xml\n    \tMenuInflater inflater = getMenuInflater();\n    \tinflater.inflate(R.menu.conversations, menu);\n    \t\n    \treturn true;\n\t}\n\n\t/**\n\t * On menu item selected\n\t */\n\t@Override\n\tpublic boolean onMenuItemSelected(int featureId, MenuItem item)\n\t{\n\t\tswitch (item.getItemId()) {\n\t\t\tcase R.id.disconnect:\n\t\t\t\tbinder.getService().getConnection(serverId).quitServer();\n\t\t\t\tserver.clearConversations();\n\t\t\t\tsetResult(RESULT_OK);\n\t\t\t\tfinish();\n\t\t\t\tbreak;\n\t\t\tcase R.id.join:\n\t\t\t\tstartActivityForResult(new Intent(this, JoinActivity.class), 0);\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\t/**\n\t * Get server object assigned to this activity\n\t * \n\t * @return the server object\n\t */\n\tpublic Server getServer()\n\t{\n\t\treturn server;\n\t}\n\n\t/**\n\t * On conversation message\n\t */\n\tpublic void onConversationMessage(String target)\n\t{\n\t\tConversation conversation = server.getConversation(target);\n\t\tMessageListAdapter adapter = conversation.getMessageListAdapter();\n\t\t\n\t\twhile(conversation.hasBufferedMessages()) {\n\t\t\tMessage message = conversation.pollBufferedMessage();\n\t\t\t\n\t\t\tif (adapter != null) {\n\t\t\t\tadapter.addMessage(message);\n\t\t\t} else {\n\t\t\t\t//\"MessageListAdapter is null (conversation \" + conversation.getName() + \" has no adapter assigned)\"\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * On new conversation\n\t */\n\tpublic void onNewConversation(String target)\n\t{\n\t\tdeckAdapter.addItem(server.getConversation(target));\n\t\t\n\t\tif (!deckAdapter.isSwitched()) {\n\t\t\t// Scroll to new conversation\n\t\t\tdeck.setSelection(deckAdapter.getCount() - 1);\n\t\t}\n\t}\n\t\n\t/**\n\t * On conversation remove\n\t */\n\tpublic void onRemoveConversation(String target)\n\t{\n\t\tdeckAdapter.removeItem(target);\n\t\t\n\t\tif (deckAdapter.isSwitched()) {\n\t\t\tonBackPressed();\n\t\t}\n\t}\n\n\t/**\n\t * On server status update\n\t */\n\tpublic void onStatusUpdate()\n\t{\n\t\t((ImageView) findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\t\t\n\t\tEditText input = (EditText) findViewById(R.id.input);\n\t\tif (server.isConnected()) {\n\t\t\tinput.setEnabled(true); \n\t\t} else {\n\t\t\tinput.setEnabled(false);\n\t\t}\n\t}\n\n\t/**\n\t * On conversation item clicked\n\t */\n\tpublic void onItemClick(AdapterView<?> adapterView, View view, int position, long id)\n\t{\n\t\tConversation conversation = deckAdapter.getItem(position);\n\t\t\n\t\tMessageListView canvas = deckAdapter.renderConversation(conversation, switcher);\n\t\tcanvas.setTranscriptMode(ListView.TRANSCRIPT_MODE_NORMAL);\n\t\tcanvas.setLayoutParams(new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT));\n\t\tcanvas.setDelegateTouchEvents(false); // Do not delegate\n\t\t\n\t\tdeckAdapter.setSwitched(conversation.getName(), canvas);\n\t\tswitcher.addView(canvas);\n\t\tswitcher.showNext();\n\t}\n\t\n\t/**\n\t * On key down\n\t * \n\t * This is glue code to call onBackPressed() which\n\t * will be automatically called by later android releases\n\t */\n\t@Override\n\tpublic boolean onKeyDown(int keyCode, KeyEvent event)\n\t{\n\t\tif (keyCode == KeyEvent.KEYCODE_BACK) {\n\t\t\tonBackPressed();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * On back key pressed\n\t */\n\tpublic void onBackPressed()\n\t{\n\t\tif (deckAdapter.isSwitched()) {\n\t\t\tswitcher.showNext();\n\t\t\tswitcher.removeView(deckAdapter.getSwitchedView());\n\t\t\tdeckAdapter.setSwitched(null, null);\n\t\t} else {\n\t\t\tfinish();\n\t\t}\n\t}\n\n\t/**\n\t * On key pressed (input line)\n\t */\n\tpublic boolean onKey(View view, int keyCode, KeyEvent event)\n\t{\n\t\tif (keyCode == KeyEvent.KEYCODE_ENTER && event.getAction() == KeyEvent.ACTION_UP) {\n\t\t\tif (!server.isConnected()) {\n\t\t\t\tMessage message = new Message(\"Not connected\");\n\t\t\t\tmessage.setColor(Message.COLOR_RED);\n\t\t\t\tmessage.setIcon(R.drawable.error);\n\t\t\t\tserver.getConversation(server.getSelectedConversation()).addMessage(message);\n\t\t\t\tonConversationMessage(server.getSelectedConversation());\n\t\t\t}\n\t\t\t\n\t\t\tEditText input = (EditText) view;\n\t\t\tString text = input.getText().toString();\n\t\t\tinput.setText(\"\");\n\t\t\t\n\t\t\tif (text == \"\") {\n\t\t\t\t// ignore empty messages\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\tConversation conversation = deckAdapter.getItem(deck.getSelectedItemPosition());\n\t\t\t\n\t\t\tif (conversation != null) {\n\t\t\t\tif (!text.trim().startsWith(\"/\")) {\n\t\t\t\t\tif (conversation.getType() != Conversation.TYPE_SERVER) {\n\t\t\t\t\t\tString nickname = binder.getService().getConnection(serverId).getNick();\n\t\t\t\t\t\tconversation.addMessage(new Message(\"<\" + nickname + \"> \" + text));\n\t\t\t\t\t\tbinder.getService().getConnection(serverId).sendMessage(conversation.getName(), text);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tMessage message = new Message(\"You can only chat from within a channel or a query\");\n\t\t\t\t\t\tmessage.setColor(Message.COLOR_YELLOW);\n\t\t\t\t\t\tmessage.setIcon(R.drawable.warning);\n\t\t\t\t\t\tconversation.addMessage(message);\n\t\t\t\t\t}\n\t\t\t\t\tonConversationMessage(conversation.getName());\n\t\t\t\t} else {\n\t\t\t\t\tCommandParser.getInstance().parse(text, server, conversation, binder.getService());\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * On activity result\n\t */\n\t@Override\n\tprotected void onActivityResult(int requestCode, int resultCode, Intent data)\n\t{\n\t\t// currently there's only the \"join channel\" activity\n\t\tif (resultCode == RESULT_OK) {\n\t\t\tfinal String channel = data.getExtras().getString(\"channel\");\n\t\t\t\n\t\t\t// run on own thread\n\t\t\tnew Thread() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tbinder.getService().getConnection(serverId).joinChannel(channel);\n\t\t\t\t}\n\t\t\t}.start();\n\t\t}\n\t}\n\n\t/**\n\t * On channel selected/focused\n\t */\n\tpublic void onItemSelected(AdapterView<?> deck, View view, int position, long id)\n\t{\n\t\tConversation conversation = (Conversation) deck.getItemAtPosition(position);\n\t\t\n\t\tif (conversation != null && conversation.getType() != Conversation.TYPE_SERVER) {\n\t\t\t((TextView) findViewById(R.id.title)).setText(server.getTitle() + \" - \" + conversation.getName());\n\t\t} else {\n\t\t\tonNothingSelected(deck);\n\t\t}\n\t\t\n\t\t// Remember selection\n\t\tif (conversation != null) {\n\t\t\tserver.setSelectedConversation(conversation.getName());\n\t\t}\n\t}\n\n\t/**\n\t * On no channel selected/focused\n\t */\n\tpublic void onNothingSelected(AdapterView<?> deck)\n\t{\n\t\t((TextView) findViewById(R.id.title)).setText(server.getTitle());\n\t}\n}\n","Method after Refactoring":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2010 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.view;\n\nimport java.util.Collection;\n\nimport android.app.Activity;\nimport android.content.ComponentName;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.os.Bundle;\nimport android.os.IBinder;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.View.OnKeyListener;\nimport android.widget.AdapterView;\nimport android.widget.EditText;\nimport android.widget.Gallery;\nimport android.widget.ImageView;\nimport android.widget.ListView;\nimport android.widget.TextView;\nimport android.widget.ViewSwitcher;\nimport android.widget.AdapterView.OnItemClickListener;\nimport android.widget.AdapterView.OnItemSelectedListener;\nimport android.widget.TableLayout.LayoutParams;\n\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.adapter.DeckAdapter;\nimport org.yaaic.adapter.MessageListAdapter;\nimport org.yaaic.command.CommandParser;\nimport org.yaaic.irc.IRCBinder;\nimport org.yaaic.irc.IRCService;\nimport org.yaaic.layout.NonScalingBackgroundDrawable;\nimport org.yaaic.listener.ConversationListener;\nimport org.yaaic.listener.ServerListener;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.Status;\nimport org.yaaic.receiver.ConversationReceiver;\nimport org.yaaic.receiver.ServerReceiver;\n\n/**\n * The server view with a scrollable list of all channels\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class ConversationActivity extends Activity implements ServiceConnection, ServerListener, ConversationListener, OnItemClickListener, OnKeyListener, OnItemSelectedListener\n{\n\tprivate int serverId;\n\tprivate Server server;\n\tprivate IRCBinder binder;\n\tprivate ConversationReceiver channelReceiver;\n\tprivate ServerReceiver serverReceiver;\n\t\n\tprivate ViewSwitcher switcher;\n\tprivate Gallery deck;\n\tprivate DeckAdapter deckAdapter;\n\t\n\t/**\n\t * On create\n\t */\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState)\n\t{\n\t\tsuper.onCreate(savedInstanceState);\n\t\t\n\t\tserverId = getIntent().getExtras().getInt(\"serverId\");\n\t\tserver = (Server) Yaaic.getInstance().getServerById(serverId);\n\t\tsetTitle(\"Yaaic - \" + server.getTitle());\n\t\t\n\t\tsetContentView(R.layout.conversations);\n\t\t\n\t\t((TextView) findViewById(R.id.title)).setText(server.getTitle());\n\t\t((EditText) findViewById(R.id.input)).setOnKeyListener(this);\n\n        deckAdapter = new DeckAdapter();\n\t\tdeck = (Gallery) findViewById(R.id.deck);\n\t\tdeck.setOnItemSelectedListener(this);\n\t\tdeck.setAdapter(deckAdapter);\n\t\tdeck.setOnItemClickListener(this);\n\t\tdeck.setBackgroundDrawable(new NonScalingBackgroundDrawable(this, deck, R.drawable.icon));\n\n\t\tswitcher = (ViewSwitcher) findViewById(R.id.switcher);\n\t\t\n\t\t// Optimization : cache field lookups \n\t\tCollection<Conversation> mConversations = server.getConversations();\n\t\t\n\t\tfor (Conversation conversation : mConversations) {\n\t\t\tonNewConversation(conversation.getName());\n\t\t}\n\t}\n\t\n\t/**\n\t * On resume\n\t */\n\t@Override\n\tpublic void onResume()\n\t{\n\t\tsuper.onResume();\n\t\t\n\t\t((ImageView) findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\t\t\n        bindService(new Intent(this, IRCService.class), this, 0);\n        \n    \tchannelReceiver = new ConversationReceiver(server.getId(), this);\n    \tregisterReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_MESSAGE));\n    \tregisterReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_NEW));\n    \tregisterReceiver(channelReceiver, new IntentFilter(Broadcast.CONVERSATION_REMOVE));\n\n    \tserverReceiver = new ServerReceiver(this);\n    \tregisterReceiver(serverReceiver, new IntentFilter(Broadcast.SERVER_UPDATE));\n\n\t\tif (!server.isConnected()) {\n\t\t\t ((EditText) findViewById(R.id.input)).setEnabled(false);\n\t\t} else {\n\t\t\t ((EditText) findViewById(R.id.input)).setEnabled(true);\n\t\t}\n\n\t\t// Optimization - cache field lookup\n\t\tCollection<Conversation> mConversations = server.getConversations();\n\t\tMessageListAdapter mAdapter;\n\t\t\n\t\t// Fill view with messages that have been buffered while paused\n\t\tfor (Conversation conversation : mConversations) {\n\t\t\tmAdapter = conversation.getMessageListAdapter();\n\t\t\t\n\t\t\tif (mAdapter != null) {\n\t\t\t\tmAdapter.addBulkMessages(conversation.getBuffer());\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * On Pause\n\t */\n\t@Override\n\tpublic void onPause()\n\t{\n\t\tsuper.onPause();\n\t\t\n\t\tunbindService(this);\n\t\tunregisterReceiver(channelReceiver);\n\t\tunregisterReceiver(serverReceiver);\n\t}\n\n\t/**\n\t * On service connected\n\t */\n\tpublic void onServiceConnected(ComponentName name, IBinder service)\n\t{\n\t\tthis.binder = (IRCBinder) service;\n\t\t\n\t\t// connect to irc server if connect has been requested\n\t\tif (server.getStatus() == Status.PRE_CONNECTING && getIntent().hasExtra(\"connect\")) {\n\t\t\tserver.setStatus(Status.CONNECTING);\n\t\t\tbinder.connect(server);\n\t\t}\n\t}\n\n\t/**\n\t * On service disconnected\n\t */\n\tpublic void onServiceDisconnected(ComponentName name)\n\t{\n\t\tthis.binder = null;\n\t}\n\n\t/**\n\t * On options menu requested\n\t */\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu)\n\t{\n    \tsuper.onCreateOptionsMenu(menu);\n    \t\n    \t// inflate from xml\n    \tMenuInflater inflater = getMenuInflater();\n    \tinflater.inflate(R.menu.conversations, menu);\n    \t\n    \treturn true;\n\t}\n\n\t/**\n\t * On menu item selected\n\t */\n\t@Override\n\tpublic boolean onMenuItemSelected(int featureId, MenuItem item)\n\t{\n\t\tswitch (item.getItemId()) {\n\t\t\tcase R.id.disconnect:\n\t\t\t\tbinder.getService().getConnection(serverId).quitServer();\n\t\t\t\tserver.clearConversations();\n\t\t\t\tsetResult(RESULT_OK);\n\t\t\t\tfinish();\n\t\t\t\tbreak;\n\t\t\tcase R.id.join:\n\t\t\t\tstartActivityForResult(new Intent(this, JoinActivity.class), 0);\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\t/**\n\t * Get server object assigned to this activity\n\t * \n\t * @return the server object\n\t */\n\tpublic Server getServer()\n\t{\n\t\treturn server;\n\t}\n\n\t/**\n\t * On conversation message\n\t */\n\tpublic void onConversationMessage(String target)\n\t{\n\t\tConversation conversation = server.getConversation(target);\n\t\tMessageListAdapter adapter = conversation.getMessageListAdapter();\n\t\t\n\t\twhile(conversation.hasBufferedMessages()) {\n\t\t\tMessage message = conversation.pollBufferedMessage();\n\t\t\t\n\t\t\tif (adapter != null) {\n\t\t\t\tadapter.addMessage(message);\n\t\t\t} else {\n\t\t\t\t//\"MessageListAdapter is null (conversation \" + conversation.getName() + \" has no adapter assigned)\"\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * On new conversation\n\t */\n\tpublic void onNewConversation(String target)\n\t{\n\t\tdeckAdapter.addItem(server.getConversation(target));\n\t\t\n\t\tif (!deckAdapter.isSwitched()) {\n\t\t\t// Scroll to new conversation\n\t\t\tdeck.setSelection(deckAdapter.getCount() - 1);\n\t\t}\n\t}\n\t\n\t/**\n\t * On conversation remove\n\t */\n\tpublic void onRemoveConversation(String target)\n\t{\n\t\tdeckAdapter.removeItem(target);\n\t\t\n\t\tif (deckAdapter.isSwitched()) {\n\t\t\tonBackPressed();\n\t\t}\n\t}\n\n\t/**\n\t * On server status update\n\t */\n\tpublic void onStatusUpdate()\n\t{\n\t\t((ImageView) findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\t\t\n\t\tEditText input = (EditText) findViewById(R.id.input);\n\t\tif (server.isConnected()) {\n\t\t\tinput.setEnabled(true); \n\t\t} else {\n\t\t\tinput.setEnabled(false);\n\t\t}\n\t}\n\n\t/**\n\t * On conversation item clicked\n\t */\n\tpublic void onItemClick(AdapterView<?> adapterView, View view, int position, long id)\n\t{\n\t\tConversation conversation = deckAdapter.getItem(position);\n\t\t\n\t\tMessageListView canvas = deckAdapter.renderConversation(conversation, switcher);\n\t\tcanvas.setTranscriptMode(ListView.TRANSCRIPT_MODE_NORMAL);\n\t\tcanvas.setLayoutParams(new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT));\n\t\tcanvas.setDelegateTouchEvents(false); // Do not delegate\n\t\t\n\t\tdeckAdapter.setSwitched(conversation.getName(), canvas);\n\t\tswitcher.addView(canvas);\n\t\tswitcher.showNext();\n\t}\n\t\n\t/**\n\t * On key down\n\t * \n\t * This is glue code to call onBackPressed() which\n\t * will be automatically called by later android releases\n\t */\n\t@Override\n\tpublic boolean onKeyDown(int keyCode, KeyEvent event)\n\t{\n\t\tif (keyCode == KeyEvent.KEYCODE_BACK) {\n\t\t\tonBackPressed();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * On back key pressed\n\t */\n\tpublic void onBackPressed()\n\t{\n\t\tif (deckAdapter.isSwitched()) {\n\t\t\tswitcher.showNext();\n\t\t\tswitcher.removeView(deckAdapter.getSwitchedView());\n\t\t\tdeckAdapter.setSwitched(null, null);\n\t\t} else {\n\t\t\tfinish();\n\t\t}\n\t}\n\n\t/**\n\t * On key pressed (input line)\n\t */\n\tpublic boolean onKey(View view, int keyCode, KeyEvent event)\n\t{\n\t\tif (keyCode == KeyEvent.KEYCODE_ENTER && event.getAction() == KeyEvent.ACTION_UP) {\n\t\t\tif (!server.isConnected()) {\n\t\t\t\tMessage message = new Message(\"Not connected\");\n\t\t\t\tmessage.setColor(Message.COLOR_RED);\n\t\t\t\tmessage.setIcon(R.drawable.error);\n\t\t\t\tserver.getConversation(server.getSelectedConversation()).addMessage(message);\n\t\t\t\tonConversationMessage(server.getSelectedConversation());\n\t\t\t}\n\t\t\t\n\t\t\tEditText input = (EditText) view;\n\t\t\tString text = input.getText().toString();\n\t\t\tinput.setText(\"\");\n\t\t\t\n\t\t\tif (text == \"\") {\n\t\t\t\t// ignore empty messages\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\tConversation conversation = deckAdapter.getItem(deck.getSelectedItemPosition());\n\t\t\t\n\t\t\tif (conversation != null) {\n\t\t\t\tif (!text.trim().startsWith(\"/\")) {\n\t\t\t\t\tif (conversation.getType() != Conversation.TYPE_SERVER) {\n\t\t\t\t\t\tString nickname = binder.getService().getConnection(serverId).getNick();\n\t\t\t\t\t\tconversation.addMessage(new Message(\"<\" + nickname + \"> \" + text));\n\t\t\t\t\t\tbinder.getService().getConnection(serverId).sendMessage(conversation.getName(), text);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tMessage message = new Message(\"You can only chat from within a channel or a query\");\n\t\t\t\t\t\tmessage.setColor(Message.COLOR_YELLOW);\n\t\t\t\t\t\tmessage.setIcon(R.drawable.warning);\n\t\t\t\t\t\tconversation.addMessage(message);\n\t\t\t\t\t}\n\t\t\t\t\tonConversationMessage(conversation.getName());\n\t\t\t\t} else {\n\t\t\t\t\tCommandParser.getInstance().parse(text, server, conversation, binder.getService());\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * On activity result\n\t */\n\t@Override\n\tprotected void onActivityResult(int requestCode, int resultCode, Intent data)\n\t{\n\t\t// currently there's only the \"join channel\" activity\n\t\tif (resultCode == RESULT_OK) {\n\t\t\tfinal String channel = data.getExtras().getString(\"channel\");\n\t\t\t\n\t\t\t// run on own thread\n\t\t\tnew Thread() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tbinder.getService().getConnection(serverId).joinChannel(channel);\n\t\t\t\t}\n\t\t\t}.start();\n\t\t}\n\t}\n\n\t/**\n\t * On channel selected/focused\n\t */\n\tpublic void onItemSelected(AdapterView<?> deck, View view, int position, long id)\n\t{\n\t\tConversation conversation = (Conversation) deck.getItemAtPosition(position);\n\t\t\n\t\tif (conversation != null && conversation.getType() != Conversation.TYPE_SERVER) {\n\t\t\t((TextView) findViewById(R.id.title)).setText(server.getTitle() + \" - \" + conversation.getName());\n\t\t} else {\n\t\t\tonNothingSelected(deck);\n\t\t}\n\t\t\n\t\t// Remember selection\n\t\tif (conversation != null) {\n\t\t\tserver.setSelectedConversation(conversation.getName());\n\t\t}\n\t}\n\n\t/**\n\t * On no channel selected/focused\n\t */\n\tpublic void onNothingSelected(AdapterView<?> deck)\n\t{\n\t\t((TextView) findViewById(R.id.title)).setText(server.getTitle());\n\t}\n}\n","lineNo":145}
{"Smelly Sample":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2010 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.command.handler;\n\nimport org.jibble.pircbot.User;\nimport org.yaaic.command.BaseHandler;\nimport org.yaaic.exception.CommandException;\nimport org.yaaic.irc.IRCService;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Server;\n\nimport android.content.Intent;\n\n/**\n * Command: /names\n * Lists all users currently in the selected channel \n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class NamesHandler extends BaseHandler\n{\n\t/**\n\t * Execute /names\n\t */\n\t@Override\n\tpublic void execute(String[] params, Server server, Conversation conversation, IRCService service) throws CommandException \n\t{\n\t\tif (conversation.getType() != Conversation.TYPE_CHANNEL) {\n\t\t\tthrow new CommandException(\"Only usable from within a channel\");\n\t\t}\n\t\t\n\t\tStringBuffer userList = new StringBuffer(\"Users \" + conversation.getName() + \":\");\n\t\tfor (User user : service.getConnection(server.getId()).getUsers(conversation.getName())) {\n\t\t\tuserList.append(\" \");\n\t\t\tuserList.append(user.getPrefix());\n\t\t\tuserList.append(user.getNick());\n\t\t}\n\t\t\n\t\tMessage message = new Message(userList.toString());\n\t\tmessage.setColor(Message.COLOR_YELLOW);\n\t\tconversation.addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, conversation.getName());\n\t\tservice.sendBroadcast(intent);\n\t}\n\t\n\t/**\n\t * Usage of /names\n\t */\n\t@Override\n\tpublic String getUsage()\n\t{\n\t\treturn \"/names\";\n\t}\n}\n","Method after Refactoring":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2010 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.command.handler;\n\nimport org.jibble.pircbot.User;\nimport org.yaaic.command.BaseHandler;\nimport org.yaaic.exception.CommandException;\nimport org.yaaic.irc.IRCService;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Server;\n\nimport android.content.Intent;\n\n/**\n * Command: /names\n * Lists all users currently in the selected channel \n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class NamesHandler extends BaseHandler\n{\n\t/**\n\t * Execute /names\n\t */\n\t@Override\n\tpublic void execute(String[] params, Server server, Conversation conversation, IRCService service) throws CommandException \n\t{\n\t\tif (conversation.getType() != Conversation.TYPE_CHANNEL) {\n\t\t\tthrow new CommandException(\"Only usable from within a channel\");\n\t\t}\n\t\t\n\t\tStringBuffer userList = new StringBuffer(\"Users \" + conversation.getName() + \":\");\n\t\t\n\t\tUser[] mUsers = service.getConnection(server.getId()).getUsers(conversation.getName());\n\t\tint mSize = mUsers.length;\n\t\tfor (int i = 0; i < mSize; i++) {\n\t\t\tuserList.append(\" \");\n\t\t\tuserList.append(mUsers[i].getPrefix());\n\t\t\tuserList.append(mUsers[i].getNick());\n\t\t}\n\t\t\n\t\tMessage message = new Message(userList.toString());\n\t\tmessage.setColor(Message.COLOR_YELLOW);\n\t\tconversation.addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, conversation.getName());\n\t\tservice.sendBroadcast(intent);\n\t}\n\t\n\t/**\n\t * Usage of /names\n\t */\n\t@Override\n\tpublic String getUsage()\n\t{\n\t\treturn \"/names\";\n\t}\n}\n","lineNo":54}
{"Smelly Sample":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2010 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\n\nimport org.yaaic.model.Server;\n\n/**\n * Global Master Class :)\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class Yaaic\n{\n\tpublic static Yaaic instance;\n\t\n\tprivate HashMap<Integer, Server> servers;\n\t\n\t/**\n\t * Private constructor, you may want to use static getInstance()\n\t */\n\tprivate Yaaic()\n\t{\n\t\tservers = new HashMap<Integer, Server>();\n\t}\n\t\n\t/**\n\t * Get global Yaaic instance\n\t * \n\t * @return the global Yaaic instance\n\t */\n\tpublic static Yaaic getInstance()\n\t{\n\t\tif (instance == null) {\n\t\t\tinstance = new Yaaic(); \n\t\t}\n\t\t\n\t\treturn instance;\n\t}\n\t\n\t/**\n\t * Get server by id\n\t * \n\t * @return Server object with given unique id\n\t */\n\tpublic Server getServerById(int serverId)\n\t{\n\t\treturn servers.get(serverId);\n\t}\n\t\n\t/**\n\t * Remove server with given unique id from list\n\t * \n\t * @param serverId\n\t */\n\tpublic void removeServerById(int serverId)\n\t{\n\t\tservers.remove(serverId);\n\t}\n\t\n\t/**\n\t * Set servers\n\t * \n\t * @param servers\n\t */\n\tpublic void setServers(HashMap<Integer, Server> servers)\n\t{\n\t\tthis.servers = servers;\n\t}\n\t\n\t/**\n\t * Add server to list\n\t */\n\tpublic void addServer(Server server)\n\t{\n\t\tif (!servers.containsKey(server.getId())) {\n\t\t\tservers.put(server.getId(), server);\n\t\t}\n\t}\n\t\n\t/**\n\t * Update a server in list\n\t */\n\tpublic void updateServer(Server server)\n\t{\n\t\tservers.put(server.getId(), server);\n\t}\n\t\n\t/**\n\t * Get list of servers\n\t * \n\t * @return list of servers\n\t */\n\tpublic ArrayList<Server> getServersAsArrayList()\n\t{\n\t\tArrayList<Server> serverList = new ArrayList<Server>();\n\t\t\n\t\tfor (int key : servers.keySet()) {\n\t\t\tserverList.add(servers.get(key));\n\t\t}\n\t\t\n\t\treturn serverList;\n\t}\n}\n","Method after Refactoring":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2010 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Set;\n\nimport org.yaaic.model.Server;\n\n/**\n * Global Master Class :)\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class Yaaic\n{\n\tpublic static Yaaic instance;\n\t\n\tprivate HashMap<Integer, Server> servers;\n\t\n\t/**\n\t * Private constructor, you may want to use static getInstance()\n\t */\n\tprivate Yaaic()\n\t{\n\t\tservers = new HashMap<Integer, Server>();\n\t}\n\t\n\t/**\n\t * Get global Yaaic instance\n\t * \n\t * @return the global Yaaic instance\n\t */\n\tpublic static Yaaic getInstance()\n\t{\n\t\tif (instance == null) {\n\t\t\tinstance = new Yaaic(); \n\t\t}\n\t\t\n\t\treturn instance;\n\t}\n\t\n\t/**\n\t * Get server by id\n\t * \n\t * @return Server object with given unique id\n\t */\n\tpublic Server getServerById(int serverId)\n\t{\n\t\treturn servers.get(serverId);\n\t}\n\t\n\t/**\n\t * Remove server with given unique id from list\n\t * \n\t * @param serverId\n\t */\n\tpublic void removeServerById(int serverId)\n\t{\n\t\tservers.remove(serverId);\n\t}\n\t\n\t/**\n\t * Set servers\n\t * \n\t * @param servers\n\t */\n\tpublic void setServers(HashMap<Integer, Server> servers)\n\t{\n\t\tthis.servers = servers;\n\t}\n\t\n\t/**\n\t * Add server to list\n\t */\n\tpublic void addServer(Server server)\n\t{\n\t\tif (!servers.containsKey(server.getId())) {\n\t\t\tservers.put(server.getId(), server);\n\t\t}\n\t}\n\t\n\t/**\n\t * Update a server in list\n\t */\n\tpublic void updateServer(Server server)\n\t{\n\t\tservers.put(server.getId(), server);\n\t}\n\t\n\t/**\n\t * Get list of servers\n\t * \n\t * @return list of servers\n\t */\n\tpublic ArrayList<Server> getServersAsArrayList()\n\t{\n\t\tArrayList<Server> serverList = new ArrayList<Server>();\n\t\t\n\t\tSet<Integer> mKeys = servers.keySet();\n\t\tfor (int key : mKeys) {\n\t\t\tserverList.add(servers.get(key));\n\t\t}\n\t\t\n\t\treturn serverList;\n\t}\n}\n","lineNo":119}
{"Smelly Sample":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2010 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.adapter;\n\nimport java.util.LinkedList;\n\nimport org.yaaic.R;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.view.MessageListView;\n\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.BaseAdapter;\nimport android.widget.Gallery;\nimport android.widget.ListView;\n\n/**\n * The adapter for the \"DeckView\"\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class DeckAdapter extends BaseAdapter\n{\n\tprivate LinkedList<Conversation> conversations;\n\tprivate MessageListView currentView;\n\tprivate String currentChannel;\n\t\n\t/**\n\t * Create a new DeckAdapter instance\n\t */\n\tpublic DeckAdapter()\n\t{\n\t\tconversations = new LinkedList<Conversation>();\n\t}\n\t\n\t/**\n\t * Get number of item\n\t */\n\tpublic int getCount()\n\t{\n\t\treturn conversations.size();\n\t}\n\n\t/**\n\t * Get item at position\n\t */\n\tpublic Conversation getItem(int position)\n\t{\n\t\tif (position >= 0 && position < conversations.size()) {\n\t\t\treturn conversations.get(position);\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Get id of item at position\n\t */\n\tpublic long getItemId(int position)\n\t{\n\t\treturn position;\n\t}\n\t\n\t/**\n\t * Add an item \n\t * \n\t * @param channel Name of the channel\n\t * @param view The view object\n\t */\n\tpublic void addItem(Conversation conversation)\n\t{\n\t\tconversations.add(conversation);\n\t\t\n\t\tnotifyDataSetChanged();\n\t}\n\t\n\t/**\n\t * Get an item by the channel's name\n\t * \n\t * @param channel\n\t * @return The item\n\t */\n\tpublic int getPositionByName(String name)\n\t{\n\t\tfor (int i = 0; i <  conversations.size(); i++) {\n\t\t\tif (conversations.get(i).getName().equalsIgnoreCase(name)) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn -1;\n\t}\n\t\n\t/**\n\t * Remove an item\n\t * \n\t * @param channel\n\t */\n\tpublic void removeItem(String target)\n\t{\n\t\tint position = getPositionByName(target);\n\t\t\n\t\tif (position != -1) {\n\t\t\tconversations.remove(position);\n\t\t\tnotifyDataSetChanged();\n\t\t}\n\t}\n\t\n\t/**\n\t * Set single channel view\n\t * \n\t * @param switched\n\t */\n\tpublic void setSwitched(String channel, MessageListView current)\n\t{\n\t\tcurrentChannel = channel;\n\t\tcurrentView = current;\n\t}\n\t\n\t/**\n\t * Get single channel view\n\t * \n\t * @return\n\t */\n\tpublic MessageListView getSwitchedView()\n\t{\n\t\treturn currentView;\n\t}\n\t\n\t/**\n\t * Get name of channel (single channel view)\n\t * \n\t * @return\n\t */\n\tpublic String getSwitchedName()\n\t{\n\t\treturn currentChannel;\n\t}\n\t\n\t/**\n\t * Has the view been switched to single channel view? \n\t * \n\t * @return view true if view is in single channel view, false otherwise\n\t */\n\tpublic boolean isSwitched()\n\t{\n\t\treturn currentView != null;\n\t}\n\t\n\t/**\n\t * Get view at given position\n\t */\n\tpublic View getView(int position, View convertView, ViewGroup parent)\n\t{\n\t\tConversation conversation = getItem(position);\n\t\treturn renderConversation(conversation, parent);\n\t}\n\t\n\t/**\n\t * Render a conversation view (MessageListView)\n\t * \n\t * @param channel The conversation of the view\n\t * @param parent The parent view (context)\n\t * @return The rendered MessageListView\n\t */\n\tpublic MessageListView renderConversation(Conversation conversation, ViewGroup parent)\n\t{\n\t\tMessageListView list = new MessageListView(parent.getContext(), parent);\n\t\t\n\t\tMessageListAdapter adapter = conversation.getMessageListAdapter();\n\t\tif (adapter == null) {\n\t\t\tadapter = new MessageListAdapter(conversation, parent.getContext());\n\t\t\tconversation.setMessageListAdapter(adapter);\n\t\t}\n\t\t\n\t\tlist.setAdapter(adapter);\n\t\t\n\t\tlist.setDivider(null);\n\t\tlist.setLayoutParams(new Gallery.LayoutParams(\n\t\t\tparent.getWidth() / 100 * 85,\n\t\t\tparent.getHeight()\n\t\t));\n\t\t\n\t\tlist.setBackgroundResource(R.layout.rounded);\n\t\tlist.setCacheColorHint(0xee000000);\n\t\tlist.setPadding(5, 5, 5, 5);\n\t\tlist.setVerticalFadingEdgeEnabled(false);\n\t\tlist.setScrollBarStyle(ListView.SCROLLBARS_OUTSIDE_INSET);\n\t\tlist.setTranscriptMode(ListView.TRANSCRIPT_MODE_ALWAYS_SCROLL);\n\t\tlist.setSelection(list.getAdapter().getCount() - 1); // scroll to bottom\n\t\t\n\t\treturn list;\n\t}\n}\n","Method after Refactoring":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2010 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.adapter;\n\nimport java.util.LinkedList;\n\nimport org.yaaic.R;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.view.MessageListView;\n\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.BaseAdapter;\nimport android.widget.Gallery;\nimport android.widget.ListView;\n\n/**\n * The adapter for the \"DeckView\"\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class DeckAdapter extends BaseAdapter\n{\n\tprivate LinkedList<Conversation> conversations;\n\tprivate MessageListView currentView;\n\tprivate String currentChannel;\n\t\n\t/**\n\t * Create a new DeckAdapter instance\n\t */\n\tpublic DeckAdapter()\n\t{\n\t\tconversations = new LinkedList<Conversation>();\n\t}\n\t\n\t/**\n\t * Get number of item\n\t */\n\tpublic int getCount()\n\t{\n\t\treturn conversations.size();\n\t}\n\n\t/**\n\t * Get item at position\n\t */\n\tpublic Conversation getItem(int position)\n\t{\n\t\tif (position >= 0 && position < conversations.size()) {\n\t\t\treturn conversations.get(position);\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Get id of item at position\n\t */\n\tpublic long getItemId(int position)\n\t{\n\t\treturn position;\n\t}\n\t\n\t/**\n\t * Add an item \n\t * \n\t * @param channel Name of the channel\n\t * @param view The view object\n\t */\n\tpublic void addItem(Conversation conversation)\n\t{\n\t\tconversations.add(conversation);\n\t\t\n\t\tnotifyDataSetChanged();\n\t}\n\t\n\t/**\n\t * Get an item by the channel's name\n\t * \n\t * @param channel\n\t * @return The item\n\t */\n\tpublic int getPositionByName(String name)\n\t{\n\t\t// Optimization - cache field lookups\n\t\tint mSize = conversations.size();\n\t\tLinkedList<Conversation> mItems = this.conversations;\n\t\t\n\t\tfor (int i = 0; i <  mSize; i++) {\n\t\t\tif (mItems.get(i).getName().equalsIgnoreCase(name)) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn -1;\n\t}\n\t\n\t/**\n\t * Remove an item\n\t * \n\t * @param channel\n\t */\n\tpublic void removeItem(String target)\n\t{\n\t\tint position = getPositionByName(target);\n\t\t\n\t\tif (position != -1) {\n\t\t\tconversations.remove(position);\n\t\t\tnotifyDataSetChanged();\n\t\t}\n\t}\n\t\n\t/**\n\t * Set single channel view\n\t * \n\t * @param switched\n\t */\n\tpublic void setSwitched(String channel, MessageListView current)\n\t{\n\t\tcurrentChannel = channel;\n\t\tcurrentView = current;\n\t}\n\t\n\t/**\n\t * Get single channel view\n\t * \n\t * @return\n\t */\n\tpublic MessageListView getSwitchedView()\n\t{\n\t\treturn currentView;\n\t}\n\t\n\t/**\n\t * Get name of channel (single channel view)\n\t * \n\t * @return\n\t */\n\tpublic String getSwitchedName()\n\t{\n\t\treturn currentChannel;\n\t}\n\t\n\t/**\n\t * Has the view been switched to single channel view? \n\t * \n\t * @return view true if view is in single channel view, false otherwise\n\t */\n\tpublic boolean isSwitched()\n\t{\n\t\treturn currentView != null;\n\t}\n\t\n\t/**\n\t * Get view at given position\n\t */\n\tpublic View getView(int position, View convertView, ViewGroup parent)\n\t{\n\t\tConversation conversation = getItem(position);\n\t\treturn renderConversation(conversation, parent);\n\t}\n\t\n\t/**\n\t * Render a conversation view (MessageListView)\n\t * \n\t * @param channel The conversation of the view\n\t * @param parent The parent view (context)\n\t * @return The rendered MessageListView\n\t */\n\tpublic MessageListView renderConversation(Conversation conversation, ViewGroup parent)\n\t{\n\t\tMessageListView list = new MessageListView(parent.getContext(), parent);\n\t\t\n\t\tMessageListAdapter adapter = conversation.getMessageListAdapter();\n\t\tif (adapter == null) {\n\t\t\tadapter = new MessageListAdapter(conversation, parent.getContext());\n\t\t\tconversation.setMessageListAdapter(adapter);\n\t\t}\n\t\t\n\t\tlist.setAdapter(adapter);\n\t\t\n\t\tlist.setDivider(null);\n\t\tlist.setLayoutParams(new Gallery.LayoutParams(\n\t\t\tparent.getWidth() / 100 * 85,\n\t\t\tparent.getHeight()\n\t\t));\n\t\t\n\t\tlist.setBackgroundResource(R.layout.rounded);\n\t\tlist.setCacheColorHint(0xee000000);\n\t\tlist.setPadding(5, 5, 5, 5);\n\t\tlist.setVerticalFadingEdgeEnabled(false);\n\t\tlist.setScrollBarStyle(ListView.SCROLLBARS_OUTSIDE_INSET);\n\t\tlist.setTranscriptMode(ListView.TRANSCRIPT_MODE_ALWAYS_SCROLL);\n\t\tlist.setSelection(list.getAdapter().getCount() - 1); // scroll to bottom\n\t\t\n\t\treturn list;\n\t}\n}\n","lineNo":104}
{"Smelly Sample":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2010 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.adapter;\n\nimport java.util.LinkedList;\n\nimport org.yaaic.R;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.view.MessageListView;\n\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.BaseAdapter;\nimport android.widget.Gallery;\nimport android.widget.ListView;\n\n/**\n * The adapter for the \"DeckView\"\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class DeckAdapter extends BaseAdapter\n{\n\tprivate LinkedList<Conversation> conversations;\n\tprivate MessageListView currentView;\n\tprivate String currentChannel;\n\t\n\t/**\n\t * Create a new DeckAdapter instance\n\t */\n\tpublic DeckAdapter()\n\t{\n\t\tconversations = new LinkedList<Conversation>();\n\t}\n\t\n\t/**\n\t * Get number of item\n\t */\n\tpublic int getCount()\n\t{\n\t\treturn conversations.size();\n\t}\n\n\t/**\n\t * Get item at position\n\t */\n\tpublic Conversation getItem(int position)\n\t{\n\t\tif (position >= 0 && position < conversations.size()) {\n\t\t\treturn conversations.get(position);\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Get id of item at position\n\t */\n\tpublic long getItemId(int position)\n\t{\n\t\treturn position;\n\t}\n\t\n\t/**\n\t * Add an item \n\t * \n\t * @param channel Name of the channel\n\t * @param view The view object\n\t */\n\tpublic void addItem(Conversation conversation)\n\t{\n\t\tconversations.add(conversation);\n\t\t\n\t\tnotifyDataSetChanged();\n\t}\n\t\n\t/**\n\t * Get an item by the channel's name\n\t * \n\t * @param channel\n\t * @return The item\n\t */\n\tpublic int getPositionByName(String name)\n\t{\n\t\tfor (int i = 0; i <  conversations.size(); i++) {\n\t\t\tif (conversations.get(i).getName().equalsIgnoreCase(name)) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn -1;\n\t}\n\t\n\t/**\n\t * Remove an item\n\t * \n\t * @param channel\n\t */\n\tpublic void removeItem(String target)\n\t{\n\t\tint position = getPositionByName(target);\n\t\t\n\t\tif (position != -1) {\n\t\t\tconversations.remove(position);\n\t\t\tnotifyDataSetChanged();\n\t\t}\n\t}\n\t\n\t/**\n\t * Set single channel view\n\t * \n\t * @param switched\n\t */\n\tpublic void setSwitched(String channel, MessageListView current)\n\t{\n\t\tcurrentChannel = channel;\n\t\tcurrentView = current;\n\t}\n\t\n\t/**\n\t * Get single channel view\n\t * \n\t * @return\n\t */\n\tpublic MessageListView getSwitchedView()\n\t{\n\t\treturn currentView;\n\t}\n\t\n\t/**\n\t * Get name of channel (single channel view)\n\t * \n\t * @return\n\t */\n\tpublic String getSwitchedName()\n\t{\n\t\treturn currentChannel;\n\t}\n\t\n\t/**\n\t * Has the view been switched to single channel view? \n\t * \n\t * @return view true if view is in single channel view, false otherwise\n\t */\n\tpublic boolean isSwitched()\n\t{\n\t\treturn currentView != null;\n\t}\n\t\n\t/**\n\t * Get view at given position\n\t */\n\tpublic View getView(int position, View convertView, ViewGroup parent)\n\t{\n\t\tConversation conversation = getItem(position);\n\t\treturn renderConversation(conversation, parent);\n\t}\n\t\n\t/**\n\t * Render a conversation view (MessageListView)\n\t * \n\t * @param channel The conversation of the view\n\t * @param parent The parent view (context)\n\t * @return The rendered MessageListView\n\t */\n\tpublic MessageListView renderConversation(Conversation conversation, ViewGroup parent)\n\t{\n\t\tMessageListView list = new MessageListView(parent.getContext(), parent);\n\t\t\n\t\tMessageListAdapter adapter = conversation.getMessageListAdapter();\n\t\tif (adapter == null) {\n\t\t\tadapter = new MessageListAdapter(conversation, parent.getContext());\n\t\t\tconversation.setMessageListAdapter(adapter);\n\t\t}\n\t\t\n\t\tlist.setAdapter(adapter);\n\t\t\n\t\tlist.setDivider(null);\n\t\tlist.setLayoutParams(new Gallery.LayoutParams(\n\t\t\tparent.getWidth() / 100 * 85,\n\t\t\tparent.getHeight()\n\t\t));\n\t\t\n\t\tlist.setBackgroundResource(R.layout.rounded);\n\t\tlist.setCacheColorHint(0xee000000);\n\t\tlist.setPadding(5, 5, 5, 5);\n\t\tlist.setVerticalFadingEdgeEnabled(false);\n\t\tlist.setScrollBarStyle(ListView.SCROLLBARS_OUTSIDE_INSET);\n\t\tlist.setTranscriptMode(ListView.TRANSCRIPT_MODE_ALWAYS_SCROLL);\n\t\tlist.setSelection(list.getAdapter().getCount() - 1); // scroll to bottom\n\t\t\n\t\treturn list;\n\t}\n}\n","Method after Refactoring":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2010 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.adapter;\n\nimport java.util.LinkedList;\n\nimport org.yaaic.R;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.view.MessageListView;\n\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.BaseAdapter;\nimport android.widget.Gallery;\nimport android.widget.ListView;\n\n/**\n * The adapter for the \"DeckView\"\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class DeckAdapter extends BaseAdapter\n{\n\tprivate LinkedList<Conversation> conversations;\n\tprivate MessageListView currentView;\n\tprivate String currentChannel;\n\t\n\t/**\n\t * Create a new DeckAdapter instance\n\t */\n\tpublic DeckAdapter()\n\t{\n\t\tconversations = new LinkedList<Conversation>();\n\t}\n\t\n\t/**\n\t * Get number of item\n\t */\n\tpublic int getCount()\n\t{\n\t\treturn conversations.size();\n\t}\n\n\t/**\n\t * Get item at position\n\t */\n\tpublic Conversation getItem(int position)\n\t{\n\t\tif (position >= 0 && position < conversations.size()) {\n\t\t\treturn conversations.get(position);\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Get id of item at position\n\t */\n\tpublic long getItemId(int position)\n\t{\n\t\treturn position;\n\t}\n\t\n\t/**\n\t * Add an item \n\t * \n\t * @param channel Name of the channel\n\t * @param view The view object\n\t */\n\tpublic void addItem(Conversation conversation)\n\t{\n\t\tconversations.add(conversation);\n\t\t\n\t\tnotifyDataSetChanged();\n\t}\n\t\n\t/**\n\t * Get an item by the channel's name\n\t * \n\t * @param channel\n\t * @return The item\n\t */\n\tpublic int getPositionByName(String name)\n\t{\n\t\t// Optimization - cache field lookups\n\t\tint mSize = conversations.size();\n\t\tLinkedList<Conversation> mItems = this.conversations;\n\t\t\n\t\tfor (int i = 0; i <  mSize; i++) {\n\t\t\tif (mItems.get(i).getName().equalsIgnoreCase(name)) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn -1;\n\t}\n\t\n\t/**\n\t * Remove an item\n\t * \n\t * @param channel\n\t */\n\tpublic void removeItem(String target)\n\t{\n\t\tint position = getPositionByName(target);\n\t\t\n\t\tif (position != -1) {\n\t\t\tconversations.remove(position);\n\t\t\tnotifyDataSetChanged();\n\t\t}\n\t}\n\t\n\t/**\n\t * Set single channel view\n\t * \n\t * @param switched\n\t */\n\tpublic void setSwitched(String channel, MessageListView current)\n\t{\n\t\tcurrentChannel = channel;\n\t\tcurrentView = current;\n\t}\n\t\n\t/**\n\t * Get single channel view\n\t * \n\t * @return\n\t */\n\tpublic MessageListView getSwitchedView()\n\t{\n\t\treturn currentView;\n\t}\n\t\n\t/**\n\t * Get name of channel (single channel view)\n\t * \n\t * @return\n\t */\n\tpublic String getSwitchedName()\n\t{\n\t\treturn currentChannel;\n\t}\n\t\n\t/**\n\t * Has the view been switched to single channel view? \n\t * \n\t * @return view true if view is in single channel view, false otherwise\n\t */\n\tpublic boolean isSwitched()\n\t{\n\t\treturn currentView != null;\n\t}\n\t\n\t/**\n\t * Get view at given position\n\t */\n\tpublic View getView(int position, View convertView, ViewGroup parent)\n\t{\n\t\tConversation conversation = getItem(position);\n\t\treturn renderConversation(conversation, parent);\n\t}\n\t\n\t/**\n\t * Render a conversation view (MessageListView)\n\t * \n\t * @param channel The conversation of the view\n\t * @param parent The parent view (context)\n\t * @return The rendered MessageListView\n\t */\n\tpublic MessageListView renderConversation(Conversation conversation, ViewGroup parent)\n\t{\n\t\tMessageListView list = new MessageListView(parent.getContext(), parent);\n\t\t\n\t\tMessageListAdapter adapter = conversation.getMessageListAdapter();\n\t\tif (adapter == null) {\n\t\t\tadapter = new MessageListAdapter(conversation, parent.getContext());\n\t\t\tconversation.setMessageListAdapter(adapter);\n\t\t}\n\t\t\n\t\tlist.setAdapter(adapter);\n\t\t\n\t\tlist.setDivider(null);\n\t\tlist.setLayoutParams(new Gallery.LayoutParams(\n\t\t\tparent.getWidth() / 100 * 85,\n\t\t\tparent.getHeight()\n\t\t));\n\t\t\n\t\tlist.setBackgroundResource(R.layout.rounded);\n\t\tlist.setCacheColorHint(0xee000000);\n\t\tlist.setPadding(5, 5, 5, 5);\n\t\tlist.setVerticalFadingEdgeEnabled(false);\n\t\tlist.setScrollBarStyle(ListView.SCROLLBARS_OUTSIDE_INSET);\n\t\tlist.setTranscriptMode(ListView.TRANSCRIPT_MODE_ALWAYS_SCROLL);\n\t\tlist.setSelection(list.getAdapter().getCount() - 1); // scroll to bottom\n\t\t\n\t\treturn list;\n\t}\n}\n","lineNo":103}
{"Smelly Sample":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2010 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.db;\n\nimport java.util.HashMap;\n\nimport org.yaaic.model.Identity;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.Status;\n\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteOpenHelper;\n\n/**\n * Database Helper for the servers and channels tables  \n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class Database extends SQLiteOpenHelper\n{\n\tpublic static final String TAG = \"Yaaic/Database\";\n\t\n\tprivate static final String DATABASE_NAME = \"servers.db\";\n\tprivate static final int DATABASE_VERSION = 1;\n\t\n\t/**\n\t * Create a new helper for database access\n\t * \n\t * @param context\n\t */\n\tpublic Database(Context context)\n\t{\n\t\tsuper(context, DATABASE_NAME, null, DATABASE_VERSION);\n\t}\n\t\n\t/**\n\t * Create all needed tables on first start\n\t */\n\t@Override\n\tpublic void onCreate(SQLiteDatabase db)\n\t{\n\t\tdb.execSQL(\"CREATE TABLE \" + ServerConstants.TABLE_NAME + \" ( \"\n\t\t\t\t+ ServerConstants._ID + \" INTEGER PRIMARY KEY AUTOINCREMENT, \"\n\t\t\t\t+ ServerConstants.TITLE + \" TEXT NOT NULL, \"\n\t\t\t\t+ ServerConstants.HOST + \" TEXT NOT NULL, \"\n\t\t\t\t+ ServerConstants.PORT + \" INTEGER, \"\n\t\t\t\t+ ServerConstants.PASSWORD + \" TEXT, \"\n\t\t\t\t+ ServerConstants.AUTOCONNECT + \" BOOLEAN, \" // XXX: Does SQLLite support boolean?\n\t\t\t\t+ ServerConstants.USE_SSL + \" BOOLEAN, \"\n\t\t\t\t+ ServerConstants.IDENTITY + \" INTEGER\"\n\t\t\t\t+ \");\"\n\t\t);\n\t\t\n\t\tdb.execSQL(\"CREATE TABLE \" + ChannelConstants.TABLE_NAME + \" (\"\n\t\t\t\t+ ChannelConstants._ID + \" INTEGER PRIMARY KEY AUTOINCREMENT, \"\n\t\t\t\t+ ChannelConstants.NAME + \" TEXT NOT NULL, \"\n\t\t\t\t+ ChannelConstants.PASSWORD + \" TEXT, \"\n\t\t\t\t+ ChannelConstants.SERVER + \" INTEGER\"\n\t\t\t\t+ \");\"\n\t\t);\n\t\t\n\t\tdb.execSQL(\"CREATE TABLE \" + IdentityConstants.TABLE_NAME +\" (\"\n\t\t\t\t+ IdentityConstants._ID + \" INTEGER PRIMARY KEY AUTOINCREMENT, \"\n\t\t\t\t+ IdentityConstants.NICKNAME + \" TEXT NOT NULL,\"\n\t\t\t\t+ IdentityConstants.IDENT + \" TEXT NOT NULL,\"\n\t\t\t\t+ IdentityConstants.REALNAME + \" TEXT NOT NULL\"\n\t\t\t\t+ \");\"\n\t\t);\n\t}\n\t\n\t/**\n\t * Migrate existing databases to\n\t */\n\t@Override\n\tpublic void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion)\n\t{\n\t\t// XXX: We delete the database currently, in future versions we want to\n\t\t// migrate the database to the new version (add or remove rows..)\n\t\tdb.execSQL(\"DROP TABLE IF EXISTS \" + ServerConstants.TABLE_NAME + \";\");\n\t\tdb.execSQL(\"DROP TABLE IF EXISTS \" + ChannelConstants.TABLE_NAME + \";\");\n\t\tdb.execSQL(\"DROP TABLE IF EXISTS \" + IdentityConstants.TABLE_NAME + \";\");\n\t\t\n\t\tonCreate(db);\n\t}\n\t\n\t/**\n\t * Add a new server to the database \n\t * \n\t * @param title Unique title of the server\n\t * @param host Hostname of the server\n\t * @param port Port (default: 3337)\n\t * @param password Password if needed\n\t * @param autoConnect Autoconnect to this server on startup?\n\t * @param useSSL Does the server use SSL?\n\t * @param identityId The id of the identity record\n\t */\n\tpublic long addServer(String title, String host, int port, String password, boolean autoConnect, boolean useSSL, long identityId)\n\t{\n\t\tContentValues values = new ContentValues();\n\t\t\n\t\tvalues.put(ServerConstants.TITLE, title);\n\t\tvalues.put(ServerConstants.HOST, host);\n\t\tvalues.put(ServerConstants.PORT, port);\n\t\tvalues.put(ServerConstants.PASSWORD, password);\n\t\tvalues.put(ServerConstants.AUTOCONNECT, autoConnect);\n\t\tvalues.put(ServerConstants.USE_SSL, useSSL);\n\t\tvalues.put(ServerConstants.IDENTITY, identityId);\n\t\t\n\t\treturn this.getWritableDatabase().insert(ServerConstants.TABLE_NAME, null, values);\n\t}\n\t\n\t/**\n\t * Update the server record in the database\n\t * \n\t * @param serverId\n\t * @param title Unique title of the server\n\t * @param host Hostname of the server\n\t * @param port Port (default: 3337)\n\t * @param password Password if needed\n\t * @param autoConnect Autoconnect to this server on startup?\n\t * @param useSSL Does the server use SSL?\n\t * @param identityId The identity of the server record\n\t */\n\tpublic void updateServer(int serverId, String title, String host, int port, String password, boolean autoConnect, boolean useSSL, long identityId)\n\t{\n\t\tContentValues values = new ContentValues();\n\t\t\n\t\tvalues.put(ServerConstants.TITLE, title);\n\t\tvalues.put(ServerConstants.HOST, host);\n\t\tvalues.put(ServerConstants.PORT, port);\n\t\tvalues.put(ServerConstants.PASSWORD, password);\n\t\tvalues.put(ServerConstants.AUTOCONNECT, autoConnect);\n\t\tvalues.put(ServerConstants.USE_SSL, useSSL);\n\t\tvalues.put(ServerConstants.IDENTITY, identityId);\n\t\t\n\t\tthis.getWritableDatabase().update(\n\t\t\tServerConstants.TABLE_NAME,\n\t\t\tvalues, ServerConstants._ID + \" = \" + serverId,\n\t\t\tnull\n\t\t);\n\t}\n\t\n\t/**\n\t * Add a channel to the database\n\t * \n\t * @param server Unique id of server\n\t * @param name Name of channel\n\t * @param password Password to join (if needed)\n\t */\n\tpublic void addChannel(int server, String name, String password)\n\t{\n\t\tContentValues values = new ContentValues();\n\t\t\n\t\tvalues.put(ChannelConstants.NAME, name);\n\t\tvalues.put(ChannelConstants.PASSWORD, password);\n\t\tvalues.put(ChannelConstants.SERVER, server);\n\t\t\n\t\tthis.getWritableDatabase().insert(ServerConstants.TABLE_NAME, null, values);\n\t}\n\t\n\t/**\n\t * Get all servers from database\n\t * \n\t * @return\n\t */\n\tpublic HashMap<Integer, Server> getServers()\n\t{\n\t\tHashMap<Integer, Server> servers = new HashMap<Integer, Server>();\n\t\t\n\t\tCursor cursor = this.getReadableDatabase().query(\n\t\t\tServerConstants.TABLE_NAME,\n\t\t\tServerConstants.ALL,\n\t\t\tnull,\n\t\t\tnull,\n\t\t\tnull,\n\t\t\tnull,\n\t\t\tServerConstants.TITLE + \" ASC\"\n\t\t);\n\t\t\n\t\twhile (cursor.moveToNext()) {\n\t\t\tServer server = new Server();\n\t\t\t\n\t\t\tserver.setTitle(cursor.getString(cursor.getColumnIndex((ServerConstants.TITLE))));\n\t\t\tserver.setHost(cursor.getString(cursor.getColumnIndex((ServerConstants.HOST))));\n\t\t\tserver.setPort(cursor.getInt(cursor.getColumnIndex((ServerConstants.PORT))));\n\t\t\tserver.setPassword(cursor.getString(cursor.getColumnIndex(ServerConstants.PASSWORD)));\n\t\t\tserver.setId(cursor.getInt(cursor.getColumnIndex((ServerConstants._ID))));\n\t\t\tserver.setStatus(Status.DISCONNECTED);\n\t\t\t\n\t\t\t// Load identity for server\n\t\t\tIdentity identity = this.getIdentityById(cursor.getInt(cursor.getColumnIndex(ServerConstants.IDENTITY)));\n\t\t\tserver.setIdentity(identity);\n\t\t\t\n\t\t\tservers.put(server.getId(), server);\n\t\t}\n\t\tcursor.close();\n\t\t\n\t\treturn servers;\n\t}\n\t\n\t/**\n\t * Get all servers with autoconnect enabled\n\t * \n\t * @return\n\t */\n\tpublic Cursor getAutoConnectServers()\n\t{\n\t\treturn this.getReadableDatabase().query(\n\t\t\tServerConstants.TABLE_NAME,\n\t\t\tServerConstants.ALL,\n\t\t\tServerConstants.AUTOCONNECT + \" = 1\",\n\t\t\tnull,\n\t\t\tnull,\n\t\t\tnull,\n\t\t\tServerConstants.TITLE + \" ASC\"\n\t\t);\n\t}\n\t\n\t/**\n\t * Get all channels\n\t * \n\t * @return\n\t */\n\tpublic Cursor getChannels()\n\t{\n\t\treturn this.getReadableDatabase().query(\n\t\t\tChannelConstants.TABLE_NAME,\n\t\t\tChannelConstants.ALL,\n\t\t\tnull,\n\t\t\tnull,\n\t\t\tnull,\n\t\t\tnull,\n\t\t\tChannelConstants.NAME + \" ASC\"\n\t\t);\n\t}\n\t\n\t/**\n\t * Get all channels of server\n\t * \n\t * @param server Unique id of server\n\t * @return\n\t */\n\tpublic Cursor getChannelsById(int serverId)\n\t{\n\t\treturn this.getReadableDatabase().query(\n\t\t\tChannelConstants.TABLE_NAME,\n\t\t\tChannelConstants.ALL,\n\t\t\tChannelConstants.SERVER + \"=\" + serverId,\n\t\t\tnull,\n\t\t\tnull,\n\t\t\tnull,\n\t\t\tChannelConstants.NAME + \" ASC\"\n\t\t);\t\n\t}\n\t\n\t/**\n\t * Remove server from database by unique id\n\t * \n\t * @param title\n\t */\n\tpublic void removeServerById(int serverId)\n\t{\n\t\t// XXX: Workaround: Remove identity assigned to this server\n\t\t//      until we have some kind of identity manager\n\t\tint identityId = this.getIdentityIdByServerId(serverId);\n\t\tif (identityId != -1) {\n\t\t\tthis.getWritableDatabase().execSQL(\n\t\t\t\t\"DELETE FROM \" + IdentityConstants.TABLE_NAME + \" WHERE \" + IdentityConstants._ID + \" = \" + identityId + \";\"\n\t\t\t);\t\t\n\t\t}\n\t\t\n\t\t// Now delete the server entry\n\t\tthis.getWritableDatabase().execSQL(\n\t\t\t\"DELETE FROM \" + ServerConstants.TABLE_NAME + \" WHERE \" + ServerConstants._ID + \" = \" + serverId + \";\"\n\t\t);\n\t}\n\t\n\t/**\n\t * Add a new identity\n\t * \n\t * @param identityId\n\t * @param nickname\n\t * @param ident\n\t * @param realname\n\t */\n\tpublic long addIdentity(String nickname, String ident, String realname)\n\t{\n\t\tContentValues values = new ContentValues();\n\t\t\n\t\tvalues.put(IdentityConstants.NICKNAME, nickname);\n\t\tvalues.put(IdentityConstants.IDENT, ident);\n\t\tvalues.put(IdentityConstants.REALNAME, realname);\n\t\t\n\t\treturn this.getWritableDatabase().insert(IdentityConstants.TABLE_NAME, null, values);\n\t}\n\t\n\t/**\n\t * Update the identity with the given id\n\t * \n\t * @param identityId\n\t * @param nickname\n\t * @param ident\n\t * @param realname\n\t */\n\tpublic void updateIdentity(int identityId, String nickname, String ident, String realname)\n\t{\n\t\tContentValues values = new ContentValues();\n\t\t\n\t\tvalues.put(IdentityConstants.NICKNAME, nickname);\n\t\tvalues.put(IdentityConstants.IDENT, ident);\n\t\tvalues.put(IdentityConstants.REALNAME, realname);\n\t\t\n\t\tthis.getWritableDatabase().update(\n\t\t\tIdentityConstants.TABLE_NAME,\n\t\t\tvalues,\n\t\t\tIdentityConstants._ID + \" = \" + identityId,\n\t\t\tnull\n\t\t);\n\t}\n\t\n\t/**\n\t * Get an identity by its id\n\t * \n\t * @param identityId\n\t * @return\n\t */\n\tpublic Identity getIdentityById(int identityId)\n\t{\n\t\tCursor cursor = this.getReadableDatabase().query(\n\t\t\tIdentityConstants.TABLE_NAME,\n\t\t\tIdentityConstants.ALL,\n\t\t\tIdentityConstants._ID + \"=\" + identityId,\n\t\t\tnull,\n\t\t\tnull,\n\t\t\tnull,\n\t\t\tnull\n\t\t);\n\t\t\n\t\tif (cursor.moveToNext()) {\n\t\t\tIdentity identity = new Identity();\n\t\t\t\n\t\t\tidentity.setNickname(cursor.getString(cursor.getColumnIndex(IdentityConstants.NICKNAME)));\n\t\t\tidentity.setIdent(cursor.getString(cursor.getColumnIndex(IdentityConstants.IDENT)));\n\t\t\tidentity.setRealName(cursor.getString(cursor.getColumnIndex(IdentityConstants.REALNAME)));\n\t\t\t\n\t\t\tcursor.close();\n\t\t\t\n\t\t\treturn identity;\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\t\n\t/**\n\t * Get a server by its id\n\t * \n\t * @param serverId\n\t * @return\n\t */\n\tprivate int getIdentityIdByServerId(int serverId)\n\t{\n\t\tCursor cursor = this.getReadableDatabase().query(\n\t\t\tServerConstants.TABLE_NAME,\n\t\t\tServerConstants.ALL,\n\t\t\tServerConstants._ID + \"=\" + serverId,\n\t\t\tnull,\n\t\t\tnull,\n\t\t\tnull,\n\t\t\tnull\n\t\t);\n\t\t\n\t\tif (cursor.moveToNext()) {\n\t\t\treturn cursor.getInt(cursor.getColumnIndex(ServerConstants.IDENTITY));\n\t\t}\n\t\t\n\t\treturn -1;\n\t}\n}\n","Method after Refactoring":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2010 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.db;\n\nimport java.util.HashMap;\n\nimport org.yaaic.model.Identity;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.Status;\n\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteOpenHelper;\n\n/**\n * Database Helper for the servers and channels tables  \n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class Database extends SQLiteOpenHelper\n{\n\tpublic static final String TAG = \"Yaaic/Database\";\n\t\n\tprivate static final String DATABASE_NAME = \"servers.db\";\n\tprivate static final int DATABASE_VERSION = 1;\n\t\n\t/**\n\t * Create a new helper for database access\n\t * \n\t * @param context\n\t */\n\tpublic Database(Context context)\n\t{\n\t\tsuper(context, DATABASE_NAME, null, DATABASE_VERSION);\n\t}\n\t\n\t/**\n\t * Create all needed tables on first start\n\t */\n\t@Override\n\tpublic void onCreate(SQLiteDatabase db)\n\t{\n\t\tdb.execSQL(\"CREATE TABLE \" + ServerConstants.TABLE_NAME + \" ( \"\n\t\t\t\t+ ServerConstants._ID + \" INTEGER PRIMARY KEY AUTOINCREMENT, \"\n\t\t\t\t+ ServerConstants.TITLE + \" TEXT NOT NULL, \"\n\t\t\t\t+ ServerConstants.HOST + \" TEXT NOT NULL, \"\n\t\t\t\t+ ServerConstants.PORT + \" INTEGER, \"\n\t\t\t\t+ ServerConstants.PASSWORD + \" TEXT, \"\n\t\t\t\t+ ServerConstants.AUTOCONNECT + \" BOOLEAN, \" // XXX: Does SQLLite support boolean?\n\t\t\t\t+ ServerConstants.USE_SSL + \" BOOLEAN, \"\n\t\t\t\t+ ServerConstants.IDENTITY + \" INTEGER\"\n\t\t\t\t+ \");\"\n\t\t);\n\t\t\n\t\tdb.execSQL(\"CREATE TABLE \" + ChannelConstants.TABLE_NAME + \" (\"\n\t\t\t\t+ ChannelConstants._ID + \" INTEGER PRIMARY KEY AUTOINCREMENT, \"\n\t\t\t\t+ ChannelConstants.NAME + \" TEXT NOT NULL, \"\n\t\t\t\t+ ChannelConstants.PASSWORD + \" TEXT, \"\n\t\t\t\t+ ChannelConstants.SERVER + \" INTEGER\"\n\t\t\t\t+ \");\"\n\t\t);\n\t\t\n\t\tdb.execSQL(\"CREATE TABLE \" + IdentityConstants.TABLE_NAME +\" (\"\n\t\t\t\t+ IdentityConstants._ID + \" INTEGER PRIMARY KEY AUTOINCREMENT, \"\n\t\t\t\t+ IdentityConstants.NICKNAME + \" TEXT NOT NULL,\"\n\t\t\t\t+ IdentityConstants.IDENT + \" TEXT NOT NULL,\"\n\t\t\t\t+ IdentityConstants.REALNAME + \" TEXT NOT NULL\"\n\t\t\t\t+ \");\"\n\t\t);\n\t}\n\t\n\t/**\n\t * Migrate existing databases to\n\t */\n\t@Override\n\tpublic void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion)\n\t{\n\t\t// XXX: We delete the database currently, in future versions we want to\n\t\t// migrate the database to the new version (add or remove rows..)\n\t\tdb.execSQL(\"DROP TABLE IF EXISTS \" + ServerConstants.TABLE_NAME + \";\");\n\t\tdb.execSQL(\"DROP TABLE IF EXISTS \" + ChannelConstants.TABLE_NAME + \";\");\n\t\tdb.execSQL(\"DROP TABLE IF EXISTS \" + IdentityConstants.TABLE_NAME + \";\");\n\t\t\n\t\tonCreate(db);\n\t}\n\t\n\t/**\n\t * Add a new server to the database \n\t * \n\t * @param title Unique title of the server\n\t * @param host Hostname of the server\n\t * @param port Port (default: 3337)\n\t * @param password Password if needed\n\t * @param autoConnect Autoconnect to this server on startup?\n\t * @param useSSL Does the server use SSL?\n\t * @param identityId The id of the identity record\n\t */\n\tpublic long addServer(String title, String host, int port, String password, boolean autoConnect, boolean useSSL, long identityId)\n\t{\n\t\tContentValues values = new ContentValues();\n\t\t\n\t\tvalues.put(ServerConstants.TITLE, title);\n\t\tvalues.put(ServerConstants.HOST, host);\n\t\tvalues.put(ServerConstants.PORT, port);\n\t\tvalues.put(ServerConstants.PASSWORD, password);\n\t\tvalues.put(ServerConstants.AUTOCONNECT, autoConnect);\n\t\tvalues.put(ServerConstants.USE_SSL, useSSL);\n\t\tvalues.put(ServerConstants.IDENTITY, identityId);\n\t\t\n\t\treturn this.getWritableDatabase().insert(ServerConstants.TABLE_NAME, null, values);\n\t}\n\t\n\t/**\n\t * Update the server record in the database\n\t * \n\t * @param serverId\n\t * @param title Unique title of the server\n\t * @param host Hostname of the server\n\t * @param port Port (default: 3337)\n\t * @param password Password if needed\n\t * @param autoConnect Autoconnect to this server on startup?\n\t * @param useSSL Does the server use SSL?\n\t * @param identityId The identity of the server record\n\t */\n\tpublic void updateServer(int serverId, String title, String host, int port, String password, boolean autoConnect, boolean useSSL, long identityId)\n\t{\n\t\tContentValues values = new ContentValues();\n\t\t\n\t\tvalues.put(ServerConstants.TITLE, title);\n\t\tvalues.put(ServerConstants.HOST, host);\n\t\tvalues.put(ServerConstants.PORT, port);\n\t\tvalues.put(ServerConstants.PASSWORD, password);\n\t\tvalues.put(ServerConstants.AUTOCONNECT, autoConnect);\n\t\tvalues.put(ServerConstants.USE_SSL, useSSL);\n\t\tvalues.put(ServerConstants.IDENTITY, identityId);\n\t\t\n\t\tthis.getWritableDatabase().update(\n\t\t\tServerConstants.TABLE_NAME,\n\t\t\tvalues, ServerConstants._ID + \" = \" + serverId,\n\t\t\tnull\n\t\t);\n\t}\n\t\n\t/**\n\t * Add a channel to the database\n\t * \n\t * @param server Unique id of server\n\t * @param name Name of channel\n\t * @param password Password to join (if needed)\n\t */\n\tpublic void addChannel(int server, String name, String password)\n\t{\n\t\tContentValues values = new ContentValues();\n\t\t\n\t\tvalues.put(ChannelConstants.NAME, name);\n\t\tvalues.put(ChannelConstants.PASSWORD, password);\n\t\tvalues.put(ChannelConstants.SERVER, server);\n\t\t\n\t\tthis.getWritableDatabase().insert(ServerConstants.TABLE_NAME, null, values);\n\t}\n\t\n\t/**\n\t * Get all servers from database\n\t * \n\t * @return\n\t */\n\tpublic HashMap<Integer, Server> getServers()\n\t{\n\t\tHashMap<Integer, Server> servers = new HashMap<Integer, Server>();\n\t\t\n\t\tCursor cursor = this.getReadableDatabase().query(\n\t\t\tServerConstants.TABLE_NAME,\n\t\t\tServerConstants.ALL,\n\t\t\tnull,\n\t\t\tnull,\n\t\t\tnull,\n\t\t\tnull,\n\t\t\tServerConstants.TITLE + \" ASC\"\n\t\t);\n\t\t\n\t\twhile (cursor.moveToNext()) {\n\t\t\tServer server = populateServer(cursor);\n\t\t\tservers.put(server.getId(), server);\n\t\t}\n\t\tcursor.close();\n\t\t\n\t\treturn servers;\n\t}\n\t\n\tpublic Server getServerById(int serverId)\n\t{\n\t\tServer server = null;\n\t\t\n\t\tCursor cursor = this.getReadableDatabase().query(\n\t\t\tServerConstants.TABLE_NAME,\n\t\t\tServerConstants.ALL,\n\t\t\tServerConstants._ID + \"=\" + serverId,\n\t\t\tnull,\n\t\t\tnull,\n\t\t\tnull,\n\t\t\tServerConstants.TITLE + \" ASC\"\n\t\t);\n\t\t\n\t\tif (cursor.moveToNext()) {\n\t\t\tserver = populateServer(cursor);\n\t\t}\n\t\t\n\t\tcursor.close();\n\t\t\n\t\treturn server;\n\t}\n\t\n\t/**\n\t * Populate a server object from the given database cursor\n\t * @param cursor\n\t * @return\n\t */\n\tprivate Server populateServer(Cursor cursor)\n\t{\n\t\tServer server = new Server();\n\t\t\n\t\tserver.setTitle(cursor.getString(cursor.getColumnIndex((ServerConstants.TITLE))));\n\t\tserver.setHost(cursor.getString(cursor.getColumnIndex((ServerConstants.HOST))));\n\t\tserver.setPort(cursor.getInt(cursor.getColumnIndex((ServerConstants.PORT))));\n\t\tserver.setPassword(cursor.getString(cursor.getColumnIndex(ServerConstants.PASSWORD)));\n\t\tserver.setId(cursor.getInt(cursor.getColumnIndex((ServerConstants._ID))));\n\t\tserver.setStatus(Status.DISCONNECTED);\n\t\t\n\t\t// Load identity for server\n\t\tIdentity identity = this.getIdentityById(cursor.getInt(cursor.getColumnIndex(ServerConstants.IDENTITY)));\n\t\tserver.setIdentity(identity);\n\t\t\n\t\treturn server;\n\t}\n\t\n\t/**\n\t * Get all servers with autoconnect enabled\n\t * \n\t * @return\n\t */\n\tpublic Cursor getAutoConnectServers()\n\t{\n\t\treturn this.getReadableDatabase().query(\n\t\t\tServerConstants.TABLE_NAME,\n\t\t\tServerConstants.ALL,\n\t\t\tServerConstants.AUTOCONNECT + \" = 1\",\n\t\t\tnull,\n\t\t\tnull,\n\t\t\tnull,\n\t\t\tServerConstants.TITLE + \" ASC\"\n\t\t);\n\t}\n\t\n\t/**\n\t * Get all channels\n\t * \n\t * @return\n\t */\n\tpublic Cursor getChannels()\n\t{\n\t\treturn this.getReadableDatabase().query(\n\t\t\tChannelConstants.TABLE_NAME,\n\t\t\tChannelConstants.ALL,\n\t\t\tnull,\n\t\t\tnull,\n\t\t\tnull,\n\t\t\tnull,\n\t\t\tChannelConstants.NAME + \" ASC\"\n\t\t);\n\t}\n\t\n\t/**\n\t * Get all channels of server\n\t * \n\t * @param server Unique id of server\n\t * @return\n\t */\n\tpublic Cursor getChannelsById(int serverId)\n\t{\n\t\treturn this.getReadableDatabase().query(\n\t\t\tChannelConstants.TABLE_NAME,\n\t\t\tChannelConstants.ALL,\n\t\t\tChannelConstants.SERVER + \"=\" + serverId,\n\t\t\tnull,\n\t\t\tnull,\n\t\t\tnull,\n\t\t\tChannelConstants.NAME + \" ASC\"\n\t\t);\t\n\t}\n\t\n\t/**\n\t * Remove server from database by unique id\n\t * \n\t * @param title\n\t */\n\tpublic void removeServerById(int serverId)\n\t{\n\t\t// XXX: Workaround: Remove identity assigned to this server\n\t\t//      until we have some kind of identity manager\n\t\tint identityId = this.getIdentityIdByServerId(serverId);\n\t\tif (identityId != -1) {\n\t\t\tthis.getWritableDatabase().execSQL(\n\t\t\t\t\"DELETE FROM \" + IdentityConstants.TABLE_NAME + \" WHERE \" + IdentityConstants._ID + \" = \" + identityId + \";\"\n\t\t\t);\t\t\n\t\t}\n\t\t\n\t\t// Now delete the server entry\n\t\tthis.getWritableDatabase().execSQL(\n\t\t\t\"DELETE FROM \" + ServerConstants.TABLE_NAME + \" WHERE \" + ServerConstants._ID + \" = \" + serverId + \";\"\n\t\t);\n\t}\n\t\n\t/**\n\t * Add a new identity\n\t * \n\t * @param identityId\n\t * @param nickname\n\t * @param ident\n\t * @param realname\n\t */\n\tpublic long addIdentity(String nickname, String ident, String realname)\n\t{\n\t\tContentValues values = new ContentValues();\n\t\t\n\t\tvalues.put(IdentityConstants.NICKNAME, nickname);\n\t\tvalues.put(IdentityConstants.IDENT, ident);\n\t\tvalues.put(IdentityConstants.REALNAME, realname);\n\t\t\n\t\treturn this.getWritableDatabase().insert(IdentityConstants.TABLE_NAME, null, values);\n\t}\n\t\n\t/**\n\t * Update the identity with the given id\n\t * \n\t * @param identityId\n\t * @param nickname\n\t * @param ident\n\t * @param realname\n\t */\n\tpublic void updateIdentity(int identityId, String nickname, String ident, String realname)\n\t{\n\t\tContentValues values = new ContentValues();\n\t\t\n\t\tvalues.put(IdentityConstants.NICKNAME, nickname);\n\t\tvalues.put(IdentityConstants.IDENT, ident);\n\t\tvalues.put(IdentityConstants.REALNAME, realname);\n\t\t\n\t\tthis.getWritableDatabase().update(\n\t\t\tIdentityConstants.TABLE_NAME,\n\t\t\tvalues,\n\t\t\tIdentityConstants._ID + \" = \" + identityId,\n\t\t\tnull\n\t\t);\n\t}\n\t\n\t/**\n\t * Get an identity by its id\n\t * \n\t * @param identityId\n\t * @return\n\t */\n\tpublic Identity getIdentityById(int identityId)\n\t{\n\t\tIdentity identity = null;\n\t\t\n\t\tCursor cursor = this.getReadableDatabase().query(\n\t\t\tIdentityConstants.TABLE_NAME,\n\t\t\tIdentityConstants.ALL,\n\t\t\tIdentityConstants._ID + \"=\" + identityId,\n\t\t\tnull,\n\t\t\tnull,\n\t\t\tnull,\n\t\t\tnull\n\t\t);\n\t\t\n\t\tif (cursor.moveToNext()) {\n\t\t\tidentity = new Identity();\n\t\t\t\n\t\t\tidentity.setNickname(cursor.getString(cursor.getColumnIndex(IdentityConstants.NICKNAME)));\n\t\t\tidentity.setIdent(cursor.getString(cursor.getColumnIndex(IdentityConstants.IDENT)));\n\t\t\tidentity.setRealName(cursor.getString(cursor.getColumnIndex(IdentityConstants.REALNAME)));\n\t\t}\n\t\t\n\t\tcursor.close();\n\t\t\n\t\treturn identity;\n\t}\n\t\n\t/**\n\t * Get a server by its id\n\t * \n\t * @param serverId\n\t * @return\n\t */\n\tpublic int getIdentityIdByServerId(int serverId)\n\t{\n\t\tint identityId = -1;\n\t\t\n\t\tCursor cursor = this.getReadableDatabase().query(\n\t\t\tServerConstants.TABLE_NAME,\n\t\t\tServerConstants.ALL,\n\t\t\tServerConstants._ID + \"=\" + serverId,\n\t\t\tnull,\n\t\t\tnull,\n\t\t\tnull,\n\t\t\tnull\n\t\t);\n\t\t\n\t\tif (cursor.moveToNext()) {\n\t\t\tidentityId = cursor.getInt(cursor.getColumnIndex(ServerConstants.IDENTITY));\n\t\t}\n\t\t\n\t\tcursor.close();\n\t\t\n\t\treturn identityId;\n\t}\n}\n","lineNo":417}
{"Smelly Sample":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2010 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.adapter;\n\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\n\nimport org.yaaic.model.Conversation;\nimport org.yaaic.view.MessageListView;\n\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.BaseAdapter;\nimport android.widget.Gallery;\nimport android.widget.ListView;\n\n/**\n * The adapter for the \"DeckView\"\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class DeckAdapter extends BaseAdapter\n{\n\tpublic static final String TAG = \"Yaaic/DeckAdapter\";\n\t\n\tprivate List<Conversation> conversations;\n\tprivate MessageListView currentView;\n\tprivate String currentChannel;\n\t\n\t/**\n\t * Create a new DeckAdapter instance\n\t */\n\tpublic DeckAdapter()\n\t{\n\t\tconversations = Collections.synchronizedList(new LinkedList<Conversation>());\n\t}\n\t\n\t/**\n\t * Get number of item\n\t */\n\tpublic int getCount()\n\t{\n\t\treturn conversations.size();\n\t}\n\n\t/**\n\t * Get item at position\n\t */\n\tpublic Conversation getItem(int position)\n\t{\n\t\tif (position >= 0 && position < conversations.size()) {\n\t\t\treturn conversations.get(position);\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Get id of item at position\n\t */\n\tpublic long getItemId(int position)\n\t{\n\t\treturn position;\n\t}\n\t\n\t/**\n\t * Add an item \n\t * \n\t * @param channel Name of the channel\n\t * @param view The view object\n\t */\n\tpublic void addItem(Conversation conversation)\n\t{\n\t\tconversations.add(conversation);\n\t\t\n\t\tnotifyDataSetChanged();\n\t}\n\t\n\t/**\n\t * Get an item by the channel's name\n\t * \n\t * @param channel\n\t * @return The item\n\t */\n\tpublic int getPositionByName(String name)\n\t{\n\t\tfor (int i = 0; i <  conversations.size(); i++) {\n\t\t\tif (conversations.get(i).getName().equalsIgnoreCase(name)) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn -1;\n\t}\n\t\n\t/**\n\t * Remove an item\n\t * \n\t * @param channel\n\t */\n\tpublic void removeItem(String target)\n\t{\n\t\tint position = getPositionByName(target);\n\t\t\n\t\tif (position != -1) {\n\t\t\tconversations.remove(position);\n\t\t\tnotifyDataSetChanged();\n\t\t}\n\t}\n\t\n\t/**\n\t * Set single channel view\n\t * \n\t * @param switched\n\t */\n\tpublic void setSwitched(String channel, MessageListView current)\n\t{\n\t\tcurrentChannel = channel;\n\t\tcurrentView = current;\n\t}\n\t\n\t/**\n\t * Get single channel view\n\t * \n\t * @return\n\t */\n\tpublic MessageListView getSwitchedView()\n\t{\n\t\treturn currentView;\n\t}\n\t\n\t/**\n\t * Get name of channel (single channel view)\n\t * \n\t * @return\n\t */\n\tpublic String getSwitchedName()\n\t{\n\t\treturn currentChannel;\n\t}\n\t\n\t/**\n\t * Has the view been switched to single channel view? \n\t * \n\t * @return view true if view is in single channel view, false otherwise\n\t */\n\tpublic boolean isSwitched()\n\t{\n\t\treturn currentView != null;\n\t}\n\t\n\t/**\n\t * Get view at given position\n\t */\n\tpublic View getView(int position, View convertView, ViewGroup parent)\n\t{\n\t\tConversation conversation = getItem(position);\n\t\treturn renderConversation(conversation, parent);\n\t}\n\t\n\t/**\n\t * Render a conversation view (MessageListView)\n\t * \n\t * @param channel The conversation of the view\n\t * @param parent The parent view (context)\n\t * @return The rendered MessageListView\n\t */\n\tpublic MessageListView renderConversation(Conversation conversation, ViewGroup parent)\n\t{\n\t\tMessageListView list = new MessageListView(parent.getContext());\n\t\tlist.setAdapter(new MessageListAdapter(conversation, parent.getContext()));\n\t\t\n\t\tlist.setDivider(null);\n\t\tlist.setLayoutParams(new Gallery.LayoutParams(\n\t\t\tparent.getWidth() / 100 * 85,\n\t\t\tparent.getHeight() / 100 * 95\n\t\t));\n\t\tlist.setBackgroundColor(0xff222222);\n\t\tlist.setPadding(5, 5, 5, 5);\n\t\tlist.setVerticalFadingEdgeEnabled(false);\n\t\tlist.setScrollBarStyle(ListView.SCROLLBARS_OUTSIDE_INSET);\n\t\tlist.setTranscriptMode(ListView.TRANSCRIPT_MODE_NORMAL);\n\t\tlist.setSelection(list.getAdapter().getCount() - 1); // scroll to bottom\n\t\t\n\t\treturn list;\n\t}\n}\n","Method after Refactoring":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2010 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.adapter;\n\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\n\nimport org.yaaic.model.Conversation;\nimport org.yaaic.view.MessageListView;\n\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.BaseAdapter;\nimport android.widget.Gallery;\nimport android.widget.ListView;\n\n/**\n * The adapter for the \"DeckView\"\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class DeckAdapter extends BaseAdapter\n{\n\tpublic static final String TAG = \"Yaaic/DeckAdapter\";\n\t\n\tprivate List<Conversation> conversations;\n\tprivate MessageListView currentView;\n\tprivate String currentChannel;\n\t\n\t/**\n\t * Create a new DeckAdapter instance\n\t */\n\tpublic DeckAdapter()\n\t{\n\t\tconversations = Collections.synchronizedList(new LinkedList<Conversation>());\n\t}\n\t\n\t/**\n\t * Get number of item\n\t */\n\tpublic int getCount()\n\t{\n\t\treturn conversations.size();\n\t}\n\n\t/**\n\t * Get item at position\n\t */\n\tpublic Conversation getItem(int position)\n\t{\n\t\tif (position >= 0 && position < conversations.size()) {\n\t\t\treturn conversations.get(position);\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Get id of item at position\n\t */\n\tpublic long getItemId(int position)\n\t{\n\t\treturn position;\n\t}\n\t\n\t/**\n\t * Add an item \n\t * \n\t * @param channel Name of the channel\n\t * @param view The view object\n\t */\n\tpublic void addItem(Conversation conversation)\n\t{\n\t\tconversations.add(conversation);\n\t\t\n\t\tnotifyDataSetChanged();\n\t}\n\t\n\t/**\n\t * Get an item by the channel's name\n\t * \n\t * @param channel\n\t * @return The item\n\t */\n\tpublic int getPositionByName(String name)\n\t{\n\t\tfor (int i = 0; i <  conversations.size(); i++) {\n\t\t\tif (conversations.get(i).getName().equalsIgnoreCase(name)) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn -1;\n\t}\n\t\n\t/**\n\t * Remove an item\n\t * \n\t * @param channel\n\t */\n\tpublic void removeItem(String target)\n\t{\n\t\tint position = getPositionByName(target);\n\t\t\n\t\tif (position != -1) {\n\t\t\tconversations.remove(position);\n\t\t\tnotifyDataSetChanged();\n\t\t}\n\t}\n\t\n\t/**\n\t * Set single channel view\n\t * \n\t * @param switched\n\t */\n\tpublic void setSwitched(String channel, MessageListView current)\n\t{\n\t\tcurrentChannel = channel;\n\t\tcurrentView = current;\n\t}\n\t\n\t/**\n\t * Get single channel view\n\t * \n\t * @return\n\t */\n\tpublic MessageListView getSwitchedView()\n\t{\n\t\treturn currentView;\n\t}\n\t\n\t/**\n\t * Get name of channel (single channel view)\n\t * \n\t * @return\n\t */\n\tpublic String getSwitchedName()\n\t{\n\t\treturn currentChannel;\n\t}\n\t\n\t/**\n\t * Has the view been switched to single channel view? \n\t * \n\t * @return view true if view is in single channel view, false otherwise\n\t */\n\tpublic boolean isSwitched()\n\t{\n\t\treturn currentView != null;\n\t}\n\t\n\t/**\n\t * Get view at given position\n\t */\n\tpublic View getView(int position, View convertView, ViewGroup parent)\n\t{\n\t\tConversation conversation = getItem(position);\n\t\treturn renderConversation(conversation, parent);\n\t}\n\t\n\t/**\n\t * Render a conversation view (MessageListView)\n\t * \n\t * @param channel The conversation of the view\n\t * @param parent The parent view (context)\n\t * @return The rendered MessageListView\n\t */\n\tpublic MessageListView renderConversation(Conversation conversation, ViewGroup parent)\n\t{\n\t\tMessageListView list = new MessageListView(parent.getContext());\n\t\t\n\t\tMessageListAdapter adapter = conversation.getMessageListAdapter();\n\t\tif (adapter == null) {\n\t\t\tadapter = new MessageListAdapter(conversation, parent.getContext());\n\t\t\tconversation.setMessageListAdapter(adapter);\n\t\t}\n\t\t\n\t\tlist.setAdapter(adapter);\n\t\t\n\t\tlist.setDivider(null);\n\t\tlist.setLayoutParams(new Gallery.LayoutParams(\n\t\t\tparent.getWidth() / 100 * 85,\n\t\t\tparent.getHeight() / 100 * 95\n\t\t));\n\t\tlist.setBackgroundColor(0xff222222);\n\t\tlist.setPadding(5, 5, 5, 5);\n\t\tlist.setVerticalFadingEdgeEnabled(false);\n\t\tlist.setScrollBarStyle(ListView.SCROLLBARS_OUTSIDE_INSET);\n\t\tlist.setTranscriptMode(ListView.TRANSCRIPT_MODE_NORMAL);\n\t\tlist.setSelection(list.getAdapter().getCount() - 1); // scroll to bottom\n\t\t\n\t\treturn list;\n\t}\n}\n","lineNo":190}
{"Smelly Sample":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2010 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.irc;\n\nimport java.util.Vector;\n\nimport android.content.Intent;\nimport android.util.Log;\n\nimport org.jibble.pircbot.Colors;\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\n\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Query;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.ServerInfo;\nimport org.yaaic.model.Status;\n\npublic class IRCConnection extends PircBot\n{\n\tprivate IRCService service;\n\tprivate Server server;\n\t\n\t// XXX: Print all IRC events to the debug console\n\tprivate static final boolean DEBUG_EVENTS = true;\n\tpublic static final String TAG = \"Yaaic/IRCConnection\";\n\t\n\t/**\n\t * Create a new connection\n\t * \n\t * @param service\n\t * @param serverId\n\t */\n\tpublic IRCConnection(IRCService service, int serverId)\n\t{\n\t\tthis.server = Yaaic.getInstance().getServerById(serverId);\n\t\tthis.service = service;\n\t\t\n\t\tthis.setAutoNickChange(true);\n\t}\n\t\n\t/**\n\t * Set the nickname of the user\n\t * \n\t * @param nickname The nickname to use\n\t */\n\tpublic void setNickname(String nickname)\n\t{\n\t\tthis.setName(nickname);\n\t}\n\t\n\t/**\n\t * Set the real name of the user\n\t * \n\t * @param realname The realname to use\n\t */\n\tpublic void setRealName(String realname)\n\t{\n\t\t// XXX: Pircbot uses the version for \"real name\" and \"version\".\n\t\t//      The real \"version\" value is provided by onVersion() \n\t\tthis.setVersion(realname);\n\t}\n\n\t/**\n\t * On version (CTCP version)\n\t * \n\t * This is a fix for pircbot as pircbot uses the version as \"real name\" and as \"version\"\n\t */\n\t@Override\n\tprotected void onVersion(String sourceNick, String sourceLogin,\tString sourceHostname, String target)\n\t{\n\t\tthis.sendRawLine(\n\t\t\t\t\"NOTICE \" + sourceNick + \" :\\u0001VERSION \" +\n\t\t\t\t\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\" +\n\t\t\t\t\"\\u0001\"\n\t\t);\n\t}\n\n\t/**\n\t * Set the ident of the user\n\t * \n\t * @param ident The ident to use\n\t */\n\tpublic void setIdent(String ident)\n\t{\n\t\tthis.setLogin(ident);\n\t}\n\n\t/**\n\t * On connect\n\t */\n\t@Override\n\tpublic void onConnect()\n\t{\n\t\tdebug(\"Connect\", \"\");\n\t\t\n\t\tserver.setStatus(Status.CONNECTED);\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t\t\n\t\tMessage message = new Message(\"Connected to \" + server.getTitle());\n\t\tmessage.setColor(Message.COLOR_GREEN);\n\t\tserver.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, ServerInfo.DEFAULT_NAME);\n\t\tservice.sendBroadcast(intent);\n\t}\n\t\n\t/**\n\t * On channel action\n\t */\n\t@Override\n\tprotected void onAction(String sender, String login, String hostname, String target, String action)\n\t{\n\t\tdebug(\"Action\", target + \" \" + sender + \" \" + action);\n\n\t\t// Strip mIRC colors and formatting\n\t\taction = Colors.removeFormattingAndColors(action);\n\n\t\tMessage message = new Message(sender + \" \" + action);\n\t\tmessage.setIcon(R.drawable.action);\n\t\t\n\t\tif (target.equals(this.getNick())) {\n\t\t\t// We are the target - this is an action in a query\n\t\t\tConversation conversation = server.getConversation(sender); \n\t\t\tif (conversation == null) { \n\t\t\t\t// Open a query if there's none yet\n\t\t\t\tconversation = new Query(sender);\n\t\t\t\tserver.addConversationl(conversation);\n\t\t\t\tconversation.addMessage(message);\n\t\t\t\t\n\t\t\t\tIntent intent = new Intent(Broadcast.CONVERSATION_NEW);\n\t\t\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, sender);\n\t\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\t\tservice.sendBroadcast(intent);\n\t\t\t} else {\n\t\t\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, sender);\n\t\t\t\tservice.sendBroadcast(intent);\n\t\t\t}\n\t\t} else {\n\t\t\t// A action in a channel\n\t\t\tserver.getConversation(target).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Channel Info\n\t */\n\t@Override\n\tprotected void onChannelInfo(String channel, int userCount, String topic)\n\t{\n\t\tdebug(\"ChannelInfo\", channel + \" \" + userCount);\n\t}\n\n\t/**\n\t * On Deop\n\t */\n\t@Override\n\tprotected void onDeop(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Deop\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" deoped \" + recipient);\n\t\tmessage.setIcon(R.drawable.op);\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On DeVoice\n\t */\n\t@Override\n\tprotected void onDeVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"DeVoice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" devoiced \" + recipient);\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tmessage.setIcon(R.drawable.voice);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Invite\n\t */\n\t@Override\n\tprotected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String target)\n\t{\n\t\tdebug(\"Invite\", target + \" \" + targetNick + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" invited \" + targetNick);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Join\n\t */\n\t@Override\n\tprotected void onJoin(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Join\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We joined a new channel\n\t\t\tserver.addConversationl(new Channel(target));\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CONVERSATION_NEW);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tMessage message = new Message(sender + \" joined\");\n\t\t\tmessage.setIcon(R.drawable.join);\n\t\t\tmessage.setColor(Message.COLOR_GREEN);\n\t\t\tserver.getConversation(target).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Kick\n\t */\n\t@Override\n\tprotected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n\t{\n\t\tdebug(\"Kick\", target + \" \" + recipientNick + \"(\" + kickerNick + \")\");\n\t\t\n\t\tif (recipientNick.equals(getNick())) {\n\t\t\t// We are kicked\n\t\t\tserver.removeConversation(target);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CONVERSATION_REMOVE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tMessage message = new Message(kickerNick + \" kicked \" + recipientNick);\n\t\t\tmessage.setColor(Message.COLOR_GREEN);\n\t\t\tserver.getConversation(target).addMessage(message);\n\n\t\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\t\tservice.sendBroadcast(intent);\t\t\t\n\t\t}\n\t}\n\n\t/**\n\t * On Message\n\t */\n\t@Override\n\tprotected void onMessage(String target, String sender, String login, String hostname, String text)\n\t{\n\t\tdebug(\"Message\", target + \" \" + sender + \" \" + text);\n\t\t\n\t\t// Strip mIRC colors and formatting\n\t\ttext = Colors.removeFormattingAndColors(text);\n\n\t\tMessage message = new Message(\"<\" + sender + \"> \" + text);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Mode\n\t */\n\t@Override\n\tprotected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n\t{\n\t\tdebug(\"Mode\", target + \" \" + sourceNick + \" \" + mode);\n\t\t\n\t\t/*//Disabled as it doubles events (e.g. onOp and onMode will be called)\n\t\tMessage message = new Message(sourceNick + \" sets mode \" + mode);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t\t*/\n\t}\n\n\t/**\n\t * On Nick Change\n\t */\n\t@Override\n\tprotected void onNickChange(String oldNick, String login, String hostname, String newNick)\n\t{\n\t\tdebug(\"Nick\", oldNick + \" \" + newNick);\n\t\t\n\t\tfor (String target : getChannelsByNickname(newNick)) {\n\t\t\tMessage message = new Message(oldNick + \" is now known as \" + newNick);\n\t\t\tmessage.setColor(Message.COLOR_GREEN);\n\t\t\tserver.getConversation(target).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Notice\n\t */\n\t@Override\n\tprotected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n\t{\n\t\tdebug(\"Notice\", sourceNick + \" \" + notice);\n\n\t\t// Strip mIRC colors and formatting\n\t\tnotice = Colors.removeFormattingAndColors(notice);\n\t\t\n\t\t// Post notice to currently selected conversation\n\t\tConversation conversation = server.getConversation(server.getSelectedConversation());\n\t\t\n\t\tif (conversation == null) {\n\t\t\t// Fallback: Use ServerInfo view\n\t\t\tconversation = server.getConversation(ServerInfo.DEFAULT_NAME);\n\t\t}\n\n\t\tMessage message = new Message(\"-\" + sourceNick + \"- \" + notice);\n\t\tmessage.setIcon(R.drawable.info);\n\t\tconversation.addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, conversation.getName());\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Op\n\t */\n\t@Override\n\tprotected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Op\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" oped \" + recipient);\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tmessage.setIcon(R.drawable.op);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Part\n\t */\n\t@Override\n\tprotected void onPart(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Part\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We parted a channel\n\t\t\tserver.removeConversation(target);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CONVERSATION_REMOVE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tMessage message = new Message(sender + \" parted\");\n\t\t\tmessage.setColor(Message.COLOR_GREEN);\n\t\t\tmessage.setIcon(R.drawable.part);\n\t\t\tserver.getConversation(target).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Private Message\n\t */\n\t@Override\n\tprotected void onPrivateMessage(String sender, String login, String hostname, String text)\n\t{\n\t\tdebug(\"PrivateMessage\", sender + \" \" + text);\n\t\t\n\t\t// Strip mIRC colors and formatting\n\t\ttext = Colors.removeFormattingAndColors(text);\n\n\t\tMessage message = new Message(\"<\" + sender + \"> \" + text);\n\n\t\tConversation conversation = server.getConversation(sender);\n\n\t\tif (conversation == null) { \n\t\t\t// Open a query if there's none yet\n\t\t\tconversation = new Query(sender);\n\t\t\tconversation.addMessage(message);\n\t\t\tserver.addConversationl(conversation);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CONVERSATION_NEW);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, sender);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tconversation.addMessage(message);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, sender);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Quit\n\t */\n\t@Override\n\tprotected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n\t{\n\t\tdebug(\"Quit\", sourceNick);\n\t\t\n\t\tif (!sourceNick.equals(this.getNick())) {\n\t\t\tfor (String target : getChannelsByNickname(sourceNick)) {\n\t\t\t\tMessage message = new Message(sourceNick + \" quitted (\" + reason + \")\");\n\t\t\t\tmessage.setColor(Message.COLOR_GREEN);\n\t\t\t\tmessage.setIcon(R.drawable.quit);\n\t\t\t\tserver.getConversation(target).addMessage(message);\n\t\t\t\t\n\t\t\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\t\t\tservice.sendBroadcast(intent);\n\t\t\t}\n\t\t\t\n\t\t\t// Look if there's a query to update\n\t\t\tConversation conversation = server.getConversation(sourceNick);\n\t\t\t\n\t\t\tif (conversation != null) {\n\t\t\t\tMessage message = new Message(sourceNick + \" quitted (\" + reason + \")\");\n\t\t\t\tmessage.setColor(Message.COLOR_GREEN);\n\t\t\t\tmessage.setIcon(R.drawable.quit);\n\t\t\t\tconversation.addMessage(message);\n\t\t\t\t\n\t\t\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, conversation.getName());\n\t\t\t\tservice.sendBroadcast(intent);\n\t\t\t}\n\t\t\t\n\t\t} else {\n\t\t\t// XXX: We quitted\n\t\t}\n\t}\n\n\t/**\n\t * On Topic\n\t */\n\t@Override\n\tpublic void onTopic(String target, String topic, String setBy, long date, boolean changed)\n\t{\n\t\tdebug(\"Topic\", target + \" \" + setBy + \" \" + topic);\n\t\t\n\t\tif (changed) {\n\t\t\tMessage message = new Message(setBy + \" sets topic: \" + topic);\n\t\t\tmessage.setColor(Message.COLOR_YELLOW);\n\t\t\tserver.getConversation(target).addMessage(message);\n\t\t} else {\n\t\t\tMessage message = new Message(\"Topic: \" + topic);\n\t\t\tmessage.setColor(Message.COLOR_YELLOW);\n\t\t\tserver.getConversation(target).addMessage(message);\n\t\t}\n\t\t\n\t\t// remember channel's topic\n\t\t((Channel) server.getConversation(target)).setTopic(topic);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On User List\n\t */\n\t@Override\n\tprotected void onUserList(String channel, User[] users)\n\t{\n\t\tdebug(\"UserList\", channel + \" (\" + users.length + \")\");\n\t\t\n\t\t// XXX: Store user list somewhere and keep it updated or just broadcast some event?\n\t}\n\n\t/**\n\t * On Voice\n\t */\n\t@Override\n\tprotected void onVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Voice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" voiced \" + recipient);\n\t\tmessage.setIcon(R.drawable.voice);\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\t\n\t/**\n\t * On unknown\n\t */\n\t@Override\n\tprotected void onUnknown(String line)\n\t{\n\t\tdebug(\"Unknown\", line);\n\t\treturn;\n\t\t\n\t\t/*\n\t\t// Currently disabled... to much text\n\t\t\n\t\tMessage message = new Message(line);\n\t\tmessage.setIcon(R.drawable.action);\n\t\tmessage.setColor(Message.COLOR_GREY);\n\t\tserver.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, ServerInfo.DEFAULT_NAME);\n\t\tservice.sendBroadcast(intent);\n\t\t*/\n\t}\n\n\t/**\n\t * On server response\n\t */\n\t@Override\n\tprotected void onServerResponse(int code, String response)\n\t{\n\t\tdebug(\"ServerResponse\", code + \" \" + response);\n\t\treturn;\n\t\t\n\t\t/*\n\t\t// Currently disabled... to much text\n\t\tMessage message = new Message(response);\n\t\tserver.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, ServerInfo.DEFAULT_NAME);\n\t\tservice.sendBroadcast(intent);\n\t\t*/\n\t}\n\n\t/**\n\t * On disconnect\n\t */\n\t@Override\n\tpublic void onDisconnect()\n\t{\n\t\tserver.setStatus(Status.DISCONNECTED);\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\n\t/**\n\t * Print an event to the debug console \n\t */\n\tprivate void debug(String event, String params)\n\t{\n\t\tif (DEBUG_EVENTS) {\n\t\t\tLog.d(TAG, \"(\" + server.getTitle() + \") [\" + event + \"]: \" + params);\n\t\t}\n\t}\n\t\n\t/**\n\t * Get all channels where the user with the given nickname is online\n\t * \n\t * @param nickname\n\t * @return Array of channel names\n\t */\n\tprivate Vector<String> getChannelsByNickname(String nickname)\n\t{\n\t\tVector<String> channels = new Vector<String>();\n\t\t\n\t\tfor (String channel : this.getChannels()) {\n\t\t\tfor (User user : this.getUsers(channel)) {\n\t\t\t\tif (user.getNick().equals(nickname)) {\n\t\t\t\t\tchannels.add(channel);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tLog.d(TAG, \"Found \" + channels.size() + \" channels for nickname \" + nickname);\n\t\t\n\t\treturn channels;\n\t}\n\t\n\t/**\n\t * Quits from the IRC server with default reason.\n\t */\n\t@Override\n\tpublic void quitServer()\n\t{\n\t\tquitServer(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n}\n","Method after Refactoring":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2010 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.irc;\n\nimport java.util.Vector;\n\nimport android.content.Intent;\nimport android.util.Log;\n\nimport org.jibble.pircbot.Colors;\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\n\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Query;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.ServerInfo;\nimport org.yaaic.model.Status;\n\npublic class IRCConnection extends PircBot\n{\n\tprivate IRCService service;\n\tprivate Server server;\n\t\n\t// XXX: Print all IRC events to the debug console\n\tprivate static final boolean DEBUG_EVENTS = true;\n\tpublic static final String TAG = \"Yaaic/IRCConnection\";\n\t\n\t/**\n\t * Create a new connection\n\t * \n\t * @param service\n\t * @param serverId\n\t */\n\tpublic IRCConnection(IRCService service, int serverId)\n\t{\n\t\tthis.server = Yaaic.getInstance().getServerById(serverId);\n\t\tthis.service = service;\n\t\t\n\t\tthis.setAutoNickChange(true);\n\t}\n\t\n\t/**\n\t * Set the nickname of the user\n\t * \n\t * @param nickname The nickname to use\n\t */\n\tpublic void setNickname(String nickname)\n\t{\n\t\tthis.setName(nickname);\n\t}\n\t\n\t/**\n\t * Set the real name of the user\n\t * \n\t * @param realname The realname to use\n\t */\n\tpublic void setRealName(String realname)\n\t{\n\t\t// XXX: Pircbot uses the version for \"real name\" and \"version\".\n\t\t//      The real \"version\" value is provided by onVersion() \n\t\tthis.setVersion(realname);\n\t}\n\n\t/**\n\t * On version (CTCP version)\n\t * \n\t * This is a fix for pircbot as pircbot uses the version as \"real name\" and as \"version\"\n\t */\n\t@Override\n\tprotected void onVersion(String sourceNick, String sourceLogin,\tString sourceHostname, String target)\n\t{\n\t\tthis.sendRawLine(\n\t\t\t\t\"NOTICE \" + sourceNick + \" :\\u0001VERSION \" +\n\t\t\t\t\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\" +\n\t\t\t\t\"\\u0001\"\n\t\t);\n\t}\n\n\t/**\n\t * Set the ident of the user\n\t * \n\t * @param ident The ident to use\n\t */\n\tpublic void setIdent(String ident)\n\t{\n\t\tthis.setLogin(ident);\n\t}\n\n\t/**\n\t * On connect\n\t */\n\t@Override\n\tpublic void onConnect()\n\t{\n\t\tdebug(\"Connect\", \"\");\n\t\t\n\t\tserver.setStatus(Status.CONNECTED);\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t\t\n\t\tMessage message = new Message(\"Connected to \" + server.getTitle());\n\t\tmessage.setColor(Message.COLOR_GREEN);\n\t\tserver.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, ServerInfo.DEFAULT_NAME);\n\t\tservice.sendBroadcast(intent);\n\t}\n\t\n\t/**\n\t * On channel action\n\t */\n\t@Override\n\tprotected void onAction(String sender, String login, String hostname, String target, String action)\n\t{\n\t\tdebug(\"Action\", target + \" \" + sender + \" \" + action);\n\n\t\t// Strip mIRC colors and formatting\n\t\taction = Colors.removeFormattingAndColors(action);\n\n\t\tMessage message = new Message(sender + \" \" + action);\n\t\tmessage.setIcon(R.drawable.action);\n\t\t\n\t\tif (target.equals(this.getNick())) {\n\t\t\t// We are the target - this is an action in a query\n\t\t\tConversation conversation = server.getConversation(sender); \n\t\t\tif (conversation == null) { \n\t\t\t\t// Open a query if there's none yet\n\t\t\t\tconversation = new Query(sender);\n\t\t\t\tserver.addConversationl(conversation);\n\t\t\t\tconversation.addMessage(message);\n\t\t\t\t\n\t\t\t\tIntent intent = new Intent(Broadcast.CONVERSATION_NEW);\n\t\t\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, sender);\n\t\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\t\tservice.sendBroadcast(intent);\n\t\t\t} else {\n\t\t\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, sender);\n\t\t\t\tservice.sendBroadcast(intent);\n\t\t\t}\n\t\t} else {\n\t\t\t// A action in a channel\n\t\t\tserver.getConversation(target).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Channel Info\n\t */\n\t@Override\n\tprotected void onChannelInfo(String channel, int userCount, String topic)\n\t{\n\t\tdebug(\"ChannelInfo\", channel + \" \" + userCount);\n\t}\n\n\t/**\n\t * On Deop\n\t */\n\t@Override\n\tprotected void onDeop(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Deop\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" deoped \" + recipient);\n\t\tmessage.setIcon(R.drawable.op);\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On DeVoice\n\t */\n\t@Override\n\tprotected void onDeVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"DeVoice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" devoiced \" + recipient);\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tmessage.setIcon(R.drawable.voice);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Invite\n\t */\n\t@Override\n\tprotected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String target)\n\t{\n\t\tdebug(\"Invite\", target + \" \" + targetNick + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" invited \" + targetNick);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Join\n\t */\n\t@Override\n\tprotected void onJoin(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Join\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We joined a new channel\n\t\t\tserver.addConversationl(new Channel(target));\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CONVERSATION_NEW);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tMessage message = new Message(sender + \" joined\");\n\t\t\tmessage.setIcon(R.drawable.join);\n\t\t\tmessage.setColor(Message.COLOR_GREEN);\n\t\t\tserver.getConversation(target).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Kick\n\t */\n\t@Override\n\tprotected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n\t{\n\t\tdebug(\"Kick\", target + \" \" + recipientNick + \"(\" + kickerNick + \")\");\n\t\t\n\t\tif (recipientNick.equals(getNick())) {\n\t\t\t// We are kicked\n\t\t\tserver.removeConversation(target);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CONVERSATION_REMOVE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tMessage message = new Message(kickerNick + \" kicked \" + recipientNick);\n\t\t\tmessage.setColor(Message.COLOR_GREEN);\n\t\t\tserver.getConversation(target).addMessage(message);\n\n\t\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\t\tservice.sendBroadcast(intent);\t\t\t\n\t\t}\n\t}\n\n\t/**\n\t * On Message\n\t */\n\t@Override\n\tprotected void onMessage(String target, String sender, String login, String hostname, String text)\n\t{\n\t\tdebug(\"Message\", target + \" \" + sender + \" \" + text);\n\t\t\n\t\t// Strip mIRC colors and formatting\n\t\ttext = Colors.removeFormattingAndColors(text);\n\n\t\tMessage message = new Message(\"<\" + sender + \"> \" + text);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Mode\n\t */\n\t@Override\n\tprotected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n\t{\n\t\tdebug(\"Mode\", target + \" \" + sourceNick + \" \" + mode);\n\t\t\n\t\t/*//Disabled as it doubles events (e.g. onOp and onMode will be called)\n\t\tMessage message = new Message(sourceNick + \" sets mode \" + mode);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t\t*/\n\t}\n\n\t/**\n\t * On Nick Change\n\t */\n\t@Override\n\tprotected void onNickChange(String oldNick, String login, String hostname, String newNick)\n\t{\n\t\tdebug(\"Nick\", oldNick + \" \" + newNick);\n\t\t\n\t\tfor (String target : getChannelsByNickname(newNick)) {\n\t\t\tMessage message = new Message(oldNick + \" is now known as \" + newNick);\n\t\t\tmessage.setColor(Message.COLOR_GREEN);\n\t\t\tserver.getConversation(target).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Notice\n\t */\n\t@Override\n\tprotected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n\t{\n\t\tdebug(\"Notice\", sourceNick + \" \" + notice);\n\n\t\t// Strip mIRC colors and formatting\n\t\tnotice = Colors.removeFormattingAndColors(notice);\n\t\t\n\t\t// Post notice to currently selected conversation\n\t\tConversation conversation = server.getConversation(server.getSelectedConversation());\n\t\t\n\t\tif (conversation == null) {\n\t\t\t// Fallback: Use ServerInfo view\n\t\t\tconversation = server.getConversation(ServerInfo.DEFAULT_NAME);\n\t\t}\n\n\t\tMessage message = new Message(\"-\" + sourceNick + \"- \" + notice);\n\t\tmessage.setIcon(R.drawable.info);\n\t\tconversation.addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, conversation.getName());\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Op\n\t */\n\t@Override\n\tprotected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Op\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" oped \" + recipient);\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tmessage.setIcon(R.drawable.op);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Part\n\t */\n\t@Override\n\tprotected void onPart(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Part\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We parted a channel\n\t\t\tserver.removeConversation(target);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CONVERSATION_REMOVE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tMessage message = new Message(sender + \" parted\");\n\t\t\tmessage.setColor(Message.COLOR_GREEN);\n\t\t\tmessage.setIcon(R.drawable.part);\n\t\t\tserver.getConversation(target).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Private Message\n\t */\n\t@Override\n\tprotected void onPrivateMessage(String sender, String login, String hostname, String text)\n\t{\n\t\tdebug(\"PrivateMessage\", sender + \" \" + text);\n\t\t\n\t\t// Strip mIRC colors and formatting\n\t\ttext = Colors.removeFormattingAndColors(text);\n\n\t\tMessage message = new Message(\"<\" + sender + \"> \" + text);\n\n\t\tConversation conversation = server.getConversation(sender);\n\n\t\tif (conversation == null) { \n\t\t\t// Open a query if there's none yet\n\t\t\tconversation = new Query(sender);\n\t\t\tconversation.addMessage(message);\n\t\t\tserver.addConversationl(conversation);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CONVERSATION_NEW);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, sender);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tconversation.addMessage(message);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, sender);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Quit\n\t */\n\t@Override\n\tprotected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n\t{\n\t\tdebug(\"Quit\", sourceNick);\n\t\t\n\t\tif (!sourceNick.equals(this.getNick())) {\n\t\t\tfor (String target : getChannelsByNickname(sourceNick)) {\n\t\t\t\tMessage message = new Message(sourceNick + \" quitted (\" + reason + \")\");\n\t\t\t\tmessage.setColor(Message.COLOR_GREEN);\n\t\t\t\tmessage.setIcon(R.drawable.quit);\n\t\t\t\tserver.getConversation(target).addMessage(message);\n\t\t\t\t\n\t\t\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\t\t\tservice.sendBroadcast(intent);\n\t\t\t}\n\t\t\t\n\t\t\t// Look if there's a query to update\n\t\t\tConversation conversation = server.getConversation(sourceNick);\n\t\t\t\n\t\t\tif (conversation != null) {\n\t\t\t\tMessage message = new Message(sourceNick + \" quitted (\" + reason + \")\");\n\t\t\t\tmessage.setColor(Message.COLOR_GREEN);\n\t\t\t\tmessage.setIcon(R.drawable.quit);\n\t\t\t\tconversation.addMessage(message);\n\t\t\t\t\n\t\t\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, conversation.getName());\n\t\t\t\tservice.sendBroadcast(intent);\n\t\t\t}\n\t\t\t\n\t\t} else {\n\t\t\t// XXX: We quitted\n\t\t}\n\t}\n\n\t/**\n\t * On Topic\n\t */\n\t@Override\n\tpublic void onTopic(String target, String topic, String setBy, long date, boolean changed)\n\t{\n\t\tdebug(\"Topic\", target + \" \" + setBy + \" \" + topic);\n\t\t\n\t\tif (changed) {\n\t\t\tMessage message = new Message(setBy + \" sets topic: \" + topic);\n\t\t\tmessage.setColor(Message.COLOR_YELLOW);\n\t\t\tserver.getConversation(target).addMessage(message);\n\t\t} else {\n\t\t\tMessage message = new Message(\"Topic: \" + topic);\n\t\t\tmessage.setColor(Message.COLOR_YELLOW);\n\t\t\tserver.getConversation(target).addMessage(message);\n\t\t}\n\t\t\n\t\t// remember channel's topic\n\t\t((Channel) server.getConversation(target)).setTopic(topic);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On User List\n\t */\n\t@Override\n\tprotected void onUserList(String channel, User[] users)\n\t{\n\t\tdebug(\"UserList\", channel + \" (\" + users.length + \")\");\n\t\t\n\t\t// XXX: Store user list somewhere and keep it updated or just broadcast some event?\n\t}\n\n\t/**\n\t * On Voice\n\t */\n\t@Override\n\tprotected void onVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Voice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" voiced \" + recipient);\n\t\tmessage.setIcon(R.drawable.voice);\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\t\n\t/**\n\t * On unknown\n\t */\n\t@Override\n\tprotected void onUnknown(String line)\n\t{\n\t\tdebug(\"Unknown\", line);\n\t\treturn;\n\t\t\n\t\t/*\n\t\t// Currently disabled... to much text\n\t\t\n\t\tMessage message = new Message(line);\n\t\tmessage.setIcon(R.drawable.action);\n\t\tmessage.setColor(Message.COLOR_GREY);\n\t\tserver.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, ServerInfo.DEFAULT_NAME);\n\t\tservice.sendBroadcast(intent);\n\t\t*/\n\t}\n\n\t/**\n\t * On server response\n\t */\n\t@Override\n\tprotected void onServerResponse(int code, String response)\n\t{\n\t\tdebug(\"ServerResponse\", code + \" \" + response);\n\t\treturn;\n\t\t\n\t\t/*\n\t\t// Currently disabled... to much text\n\t\tMessage message = new Message(response);\n\t\tserver.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, ServerInfo.DEFAULT_NAME);\n\t\tservice.sendBroadcast(intent);\n\t\t*/\n\t}\n\n\t/**\n\t * On disconnect\n\t */\n\t@Override\n\tpublic void onDisconnect()\n\t{\n\t\tserver.setStatus(Status.DISCONNECTED);\n\t\tIntent sIntent = new Intent(Broadcast.SERVER_UPDATE);\n\t\tsIntent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tservice.sendBroadcast(sIntent);\t\t\n\t\t\n\t\tMessage message = new Message(\"Disconnected\");\n\t\tmessage.setIcon(R.drawable.error);\n\t\tmessage.setColor(Message.COLOR_RED);\n\t\tserver.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\t\t\n\t\tIntent cIntent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\tcIntent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tcIntent.putExtra(Broadcast.EXTRA_CONVERSATION, ServerInfo.DEFAULT_NAME);\n\t\tservice.sendBroadcast(cIntent);\n\t}\n\n\t/**\n\t * Print an event to the debug console \n\t */\n\tprivate void debug(String event, String params)\n\t{\n\t\tif (DEBUG_EVENTS) {\n\t\t\tLog.d(TAG, \"(\" + server.getTitle() + \") [\" + event + \"]: \" + params);\n\t\t}\n\t}\n\t\n\t/**\n\t * Get all channels where the user with the given nickname is online\n\t * \n\t * @param nickname\n\t * @return Array of channel names\n\t */\n\tprivate Vector<String> getChannelsByNickname(String nickname)\n\t{\n\t\tVector<String> channels = new Vector<String>();\n\t\t\n\t\tfor (String channel : this.getChannels()) {\n\t\t\tfor (User user : this.getUsers(channel)) {\n\t\t\t\tif (user.getNick().equals(nickname)) {\n\t\t\t\t\tchannels.add(channel);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tLog.d(TAG, \"Found \" + channels.size() + \" channels for nickname \" + nickname);\n\t\t\n\t\treturn channels;\n\t}\n\t\n\t/**\n\t * Quits from the IRC server with default reason.\n\t */\n\t@Override\n\tpublic void quitServer()\n\t{\n\t\tquitServer(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n}\n","lineNo":620}
{"Smelly Sample":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2010 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.irc;\n\nimport java.util.Vector;\n\nimport android.content.Intent;\nimport android.util.Log;\n\nimport org.jibble.pircbot.Colors;\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\n\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Query;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.ServerInfo;\nimport org.yaaic.model.Status;\n\npublic class IRCConnection extends PircBot\n{\n\tprivate IRCService service;\n\tprivate Server server;\n\t\n\t// XXX: Print all IRC events to the debug console\n\tprivate static final boolean DEBUG_EVENTS = true;\n\tpublic static final String TAG = \"Yaaic/IRCConnection\";\n\t\n\t/**\n\t * Create a new connection\n\t * \n\t * @param service\n\t * @param serverId\n\t */\n\tpublic IRCConnection(IRCService service, int serverId)\n\t{\n\t\tthis.server = Yaaic.getInstance().getServerById(serverId);\n\t\tthis.service = service;\n\t\t\n\t\tthis.setAutoNickChange(true);\n\t}\n\t\n\t/**\n\t * Set the nickname of the user\n\t * \n\t * @param nickname The nickname to use\n\t */\n\tpublic void setNickname(String nickname)\n\t{\n\t\tthis.setName(nickname);\n\t}\n\t\n\t/**\n\t * Set the real name of the user\n\t * \n\t * @param realname The realname to use\n\t */\n\tpublic void setRealName(String realname)\n\t{\n\t\t// XXX: Pircbot uses the version for \"real name\" and \"version\".\n\t\t//      The real \"version\" value is provided by onVersion() \n\t\tthis.setVersion(realname);\n\t}\n\n\t/**\n\t * On version (CTCP version)\n\t * \n\t * This is a fix for pircbot as pircbot uses the version as \"real name\" and as \"version\"\n\t */\n\t@Override\n\tprotected void onVersion(String sourceNick, String sourceLogin,\tString sourceHostname, String target)\n\t{\n\t\tthis.sendRawLine(\n\t\t\t\t\"NOTICE \" + sourceNick + \" :\\u0001VERSION \" +\n\t\t\t\t\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\" +\n\t\t\t\t\"\\u0001\"\n\t\t);\n\t}\n\n\t/**\n\t * Set the ident of the user\n\t * \n\t * @param ident The ident to use\n\t */\n\tpublic void setIdent(String ident)\n\t{\n\t\tthis.setLogin(ident);\n\t}\n\n\t/**\n\t * On connect\n\t */\n\t@Override\n\tpublic void onConnect()\n\t{\n\t\tdebug(\"Connect\", \"\");\n\t\t\n\t\tserver.setStatus(Status.CONNECTED);\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t\t\n\t\tMessage message = new Message(\"Connected to \" + server.getTitle());\n\t\tmessage.setColor(Message.COLOR_GREEN);\n\t\tserver.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, ServerInfo.DEFAULT_NAME);\n\t\tservice.sendBroadcast(intent);\n\t}\n\t\n\t/**\n\t * On channel action\n\t */\n\t@Override\n\tprotected void onAction(String sender, String login, String hostname, String target, String action)\n\t{\n\t\tdebug(\"Action\", target + \" \" + sender + \" \" + action);\n\n\t\t// Strip mIRC colors and formatting\n\t\taction = Colors.removeFormattingAndColors(action);\n\n\t\tMessage message = new Message(sender + \" \" + action);\n\t\tmessage.setIcon(R.drawable.action);\n\t\t\n\t\tif (target.equals(this.getNick())) {\n\t\t\t// We are the target - this is an action in a query\n\t\t\tConversation conversation = server.getConversation(sender); \n\t\t\tif (conversation == null) { \n\t\t\t\t// Open a query if there's none yet\n\t\t\t\tconversation = new Query(sender);\n\t\t\t\tserver.addConversationl(conversation);\n\t\t\t\tconversation.addMessage(message);\n\t\t\t\t\n\t\t\t\tIntent intent = new Intent(Broadcast.CONVERSATION_NEW);\n\t\t\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, sender);\n\t\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\t\tservice.sendBroadcast(intent);\n\t\t\t} else {\n\t\t\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, sender);\n\t\t\t\tservice.sendBroadcast(intent);\n\t\t\t}\n\t\t} else {\n\t\t\t// A action in a channel\n\t\t\tserver.getConversation(target).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Channel Info\n\t */\n\t@Override\n\tprotected void onChannelInfo(String channel, int userCount, String topic)\n\t{\n\t\tdebug(\"ChannelInfo\", channel + \" \" + userCount);\n\t}\n\n\t/**\n\t * On Deop\n\t */\n\t@Override\n\tprotected void onDeop(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Deop\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" deoped \" + recipient);\n\t\tmessage.setIcon(R.drawable.op);\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On DeVoice\n\t */\n\t@Override\n\tprotected void onDeVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"DeVoice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" devoiced \" + recipient);\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tmessage.setIcon(R.drawable.voice);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Invite\n\t */\n\t@Override\n\tprotected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String target)\n\t{\n\t\tdebug(\"Invite\", target + \" \" + targetNick + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" invited \" + targetNick);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Join\n\t */\n\t@Override\n\tprotected void onJoin(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Join\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We joined a new channel\n\t\t\tserver.addConversationl(new Channel(target));\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CONVERSATION_NEW);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tMessage message = new Message(sender + \" joined\");\n\t\t\tmessage.setIcon(R.drawable.join);\n\t\t\tmessage.setColor(Message.COLOR_GREEN);\n\t\t\tserver.getConversation(target).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Kick\n\t */\n\t@Override\n\tprotected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n\t{\n\t\tdebug(\"Kick\", target + \" \" + recipientNick + \"(\" + kickerNick + \")\");\n\t\t\n\t\tif (recipientNick.equals(getNick())) {\n\t\t\t// We are kicked\n\t\t\tserver.removeConversation(target);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CONVERSATION_REMOVE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tMessage message = new Message(kickerNick + \" kicked \" + recipientNick);\n\t\t\tmessage.setColor(Message.COLOR_GREEN);\n\t\t\tserver.getConversation(target).addMessage(message);\n\n\t\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\t\tservice.sendBroadcast(intent);\t\t\t\n\t\t}\n\t}\n\n\t/**\n\t * On Message\n\t */\n\t@Override\n\tprotected void onMessage(String target, String sender, String login, String hostname, String text)\n\t{\n\t\tdebug(\"Message\", target + \" \" + sender + \" \" + text);\n\t\t\n\t\t// Strip mIRC colors and formatting\n\t\ttext = Colors.removeFormattingAndColors(text);\n\n\t\tMessage message = new Message(\"<\" + sender + \"> \" + text);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Mode\n\t */\n\t@Override\n\tprotected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n\t{\n\t\tdebug(\"Mode\", target + \" \" + sourceNick + \" \" + mode);\n\t\t\n\t\t/*//Disabled as it doubles events (e.g. onOp and onMode will be called)\n\t\tMessage message = new Message(sourceNick + \" sets mode \" + mode);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t\t*/\n\t}\n\n\t/**\n\t * On Nick Change\n\t */\n\t@Override\n\tprotected void onNickChange(String oldNick, String login, String hostname, String newNick)\n\t{\n\t\tdebug(\"Nick\", oldNick + \" \" + newNick);\n\t\t\n\t\tfor (String target : getChannelsByNickname(newNick)) {\n\t\t\tMessage message = new Message(oldNick + \" is now known as \" + newNick);\n\t\t\tmessage.setColor(Message.COLOR_GREEN);\n\t\t\tserver.getConversation(target).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Notice\n\t */\n\t@Override\n\tprotected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n\t{\n\t\tdebug(\"Notice\", sourceNick + \" \" + notice);\n\n\t\t// Strip mIRC colors and formatting\n\t\tnotice = Colors.removeFormattingAndColors(notice);\n\t\t\n\t\t// Post notice to currently selected conversation\n\t\tConversation conversation = server.getConversation(server.getSelectedConversation());\n\t\t\n\t\tif (conversation == null) {\n\t\t\t// Fallback: Use ServerInfo view\n\t\t\tconversation = server.getConversation(ServerInfo.DEFAULT_NAME);\n\t\t}\n\n\t\tMessage message = new Message(\"-\" + sourceNick + \"- \" + notice);\n\t\tmessage.setIcon(R.drawable.info);\n\t\tconversation.addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, conversation.getName());\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Op\n\t */\n\t@Override\n\tprotected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Op\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" oped \" + recipient);\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tmessage.setIcon(R.drawable.op);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Part\n\t */\n\t@Override\n\tprotected void onPart(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Part\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We parted a channel\n\t\t\tserver.removeConversation(target);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CONVERSATION_REMOVE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tMessage message = new Message(sender + \" parted\");\n\t\t\tmessage.setColor(Message.COLOR_GREEN);\n\t\t\tmessage.setIcon(R.drawable.part);\n\t\t\tserver.getConversation(target).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Private Message\n\t */\n\t@Override\n\tprotected void onPrivateMessage(String sender, String login, String hostname, String text)\n\t{\n\t\tdebug(\"PrivateMessage\", sender + \" \" + text);\n\t\t\n\t\t// Strip mIRC colors and formatting\n\t\ttext = Colors.removeFormattingAndColors(text);\n\n\t\tMessage message = new Message(\"<\" + sender + \"> \" + text);\n\n\t\tConversation conversation = server.getConversation(sender);\n\n\t\tif (conversation == null) { \n\t\t\t// Open a query if there's none yet\n\t\t\tconversation = new Query(sender);\n\t\t\tconversation.addMessage(message);\n\t\t\tserver.addConversationl(conversation);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CONVERSATION_NEW);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, sender);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tconversation.addMessage(message);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, sender);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Quit\n\t */\n\t@Override\n\tprotected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n\t{\n\t\tdebug(\"Quit\", sourceNick);\n\t\t\n\t\tif (!sourceNick.equals(this.getNick())) {\n\t\t\tfor (String target : getChannelsByNickname(sourceNick)) {\n\t\t\t\tMessage message = new Message(sourceNick + \" quitted (\" + reason + \")\");\n\t\t\t\tmessage.setColor(Message.COLOR_GREEN);\n\t\t\t\tmessage.setIcon(R.drawable.quit);\n\t\t\t\tserver.getConversation(target).addMessage(message);\n\t\t\t\t\n\t\t\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\t\t\tservice.sendBroadcast(intent);\n\t\t\t}\n\t\t\t\n\t\t\t// Look if there's a query to update\n\t\t\tConversation conversation = server.getConversation(sourceNick);\n\t\t\t\n\t\t\tif (conversation != null) {\n\t\t\t\tMessage message = new Message(sourceNick + \" quitted (\" + reason + \")\");\n\t\t\t\tmessage.setColor(Message.COLOR_GREEN);\n\t\t\t\tmessage.setIcon(R.drawable.quit);\n\t\t\t\tconversation.addMessage(message);\n\t\t\t\t\n\t\t\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, conversation.getName());\n\t\t\t\tservice.sendBroadcast(intent);\n\t\t\t}\n\t\t\t\n\t\t} else {\n\t\t\t// XXX: We quitted\n\t\t}\n\t}\n\n\t/**\n\t * On Topic\n\t */\n\t@Override\n\tpublic void onTopic(String target, String topic, String setBy, long date, boolean changed)\n\t{\n\t\tdebug(\"Topic\", target + \" \" + setBy + \" \" + topic);\n\t\t\n\t\tif (changed) {\n\t\t\tMessage message = new Message(setBy + \" sets topic: \" + topic);\n\t\t\tmessage.setColor(Message.COLOR_YELLOW);\n\t\t\tserver.getConversation(target).addMessage(message);\n\t\t} else {\n\t\t\tMessage message = new Message(\"Topic: \" + topic);\n\t\t\tmessage.setColor(Message.COLOR_YELLOW);\n\t\t\tserver.getConversation(target).addMessage(message);\n\t\t}\n\t\t\n\t\t// remember channel's topic\n\t\t((Channel) server.getConversation(target)).setTopic(topic);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On User List\n\t */\n\t@Override\n\tprotected void onUserList(String channel, User[] users)\n\t{\n\t\tdebug(\"UserList\", channel + \" (\" + users.length + \")\");\n\t\t\n\t\t// XXX: Store user list somewhere and keep it updated or just broadcast some event?\n\t}\n\n\t/**\n\t * On Voice\n\t */\n\t@Override\n\tprotected void onVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Voice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" voiced \" + recipient);\n\t\tmessage.setIcon(R.drawable.voice);\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\t\n\t/**\n\t * On unknown\n\t */\n\t@Override\n\tprotected void onUnknown(String line)\n\t{\n\t\tdebug(\"Unknown\", line);\n\t\treturn;\n\t\t\n\t\t/*\n\t\t// Currently disabled... to much text\n\t\t\n\t\tMessage message = new Message(line);\n\t\tmessage.setIcon(R.drawable.action);\n\t\tmessage.setColor(Message.COLOR_GREY);\n\t\tserver.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, ServerInfo.DEFAULT_NAME);\n\t\tservice.sendBroadcast(intent);\n\t\t*/\n\t}\n\n\t/**\n\t * On server response\n\t */\n\t@Override\n\tprotected void onServerResponse(int code, String response)\n\t{\n\t\tdebug(\"ServerResponse\", code + \" \" + response);\n\t\treturn;\n\t\t\n\t\t/*\n\t\t// Currently disabled... to much text\n\t\tMessage message = new Message(response);\n\t\tserver.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, ServerInfo.DEFAULT_NAME);\n\t\tservice.sendBroadcast(intent);\n\t\t*/\n\t}\n\n\t/**\n\t * On disconnect\n\t */\n\t@Override\n\tpublic void onDisconnect()\n\t{\n\t\tserver.setStatus(Status.DISCONNECTED);\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\n\t/**\n\t * Print an event to the debug console \n\t */\n\tprivate void debug(String event, String params)\n\t{\n\t\tif (DEBUG_EVENTS) {\n\t\t\tLog.d(TAG, \"(\" + server.getTitle() + \") [\" + event + \"]: \" + params);\n\t\t}\n\t}\n\t\n\t/**\n\t * Get all channels where the user with the given nickname is online\n\t * \n\t * @param nickname\n\t * @return Array of channel names\n\t */\n\tprivate Vector<String> getChannelsByNickname(String nickname)\n\t{\n\t\tVector<String> channels = new Vector<String>();\n\t\t\n\t\tfor (String channel : this.getChannels()) {\n\t\t\tfor (User user : this.getUsers(channel)) {\n\t\t\t\tif (user.getNick().equals(nickname)) {\n\t\t\t\t\tchannels.add(channel);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tLog.d(TAG, \"Found \" + channels.size() + \" channels for nickname \" + nickname);\n\t\t\n\t\treturn channels;\n\t}\n\t\n\t/**\n\t * Quits from the IRC server with default reason.\n\t */\n\t@Override\n\tpublic void quitServer()\n\t{\n\t\tquitServer(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n}\n","Method after Refactoring":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2010 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.irc;\n\nimport java.util.Vector;\n\nimport android.content.Intent;\nimport android.util.Log;\n\nimport org.jibble.pircbot.Colors;\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\n\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Query;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.ServerInfo;\nimport org.yaaic.model.Status;\n\npublic class IRCConnection extends PircBot\n{\n\tprivate IRCService service;\n\tprivate Server server;\n\t\n\t// XXX: Print all IRC events to the debug console\n\tprivate static final boolean DEBUG_EVENTS = true;\n\tpublic static final String TAG = \"Yaaic/IRCConnection\";\n\t\n\t/**\n\t * Create a new connection\n\t * \n\t * @param service\n\t * @param serverId\n\t */\n\tpublic IRCConnection(IRCService service, int serverId)\n\t{\n\t\tthis.server = Yaaic.getInstance().getServerById(serverId);\n\t\tthis.service = service;\n\t\t\n\t\tthis.setAutoNickChange(true);\n\t}\n\t\n\t/**\n\t * Set the nickname of the user\n\t * \n\t * @param nickname The nickname to use\n\t */\n\tpublic void setNickname(String nickname)\n\t{\n\t\tthis.setName(nickname);\n\t}\n\t\n\t/**\n\t * Set the real name of the user\n\t * \n\t * @param realname The realname to use\n\t */\n\tpublic void setRealName(String realname)\n\t{\n\t\t// XXX: Pircbot uses the version for \"real name\" and \"version\".\n\t\t//      The real \"version\" value is provided by onVersion() \n\t\tthis.setVersion(realname);\n\t}\n\n\t/**\n\t * On version (CTCP version)\n\t * \n\t * This is a fix for pircbot as pircbot uses the version as \"real name\" and as \"version\"\n\t */\n\t@Override\n\tprotected void onVersion(String sourceNick, String sourceLogin,\tString sourceHostname, String target)\n\t{\n\t\tthis.sendRawLine(\n\t\t\t\t\"NOTICE \" + sourceNick + \" :\\u0001VERSION \" +\n\t\t\t\t\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\" +\n\t\t\t\t\"\\u0001\"\n\t\t);\n\t}\n\n\t/**\n\t * Set the ident of the user\n\t * \n\t * @param ident The ident to use\n\t */\n\tpublic void setIdent(String ident)\n\t{\n\t\tthis.setLogin(ident);\n\t}\n\n\t/**\n\t * On connect\n\t */\n\t@Override\n\tpublic void onConnect()\n\t{\n\t\tdebug(\"Connect\", \"\");\n\t\t\n\t\tserver.setStatus(Status.CONNECTED);\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t\t\n\t\tMessage message = new Message(\"Connected to \" + server.getTitle());\n\t\tmessage.setColor(Message.COLOR_GREEN);\n\t\tserver.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, ServerInfo.DEFAULT_NAME);\n\t\tservice.sendBroadcast(intent);\n\t}\n\t\n\t/**\n\t * On channel action\n\t */\n\t@Override\n\tprotected void onAction(String sender, String login, String hostname, String target, String action)\n\t{\n\t\tdebug(\"Action\", target + \" \" + sender + \" \" + action);\n\n\t\t// Strip mIRC colors and formatting\n\t\taction = Colors.removeFormattingAndColors(action);\n\n\t\tMessage message = new Message(sender + \" \" + action);\n\t\tmessage.setIcon(R.drawable.action);\n\t\t\n\t\tif (target.equals(this.getNick())) {\n\t\t\t// We are the target - this is an action in a query\n\t\t\tConversation conversation = server.getConversation(sender); \n\t\t\tif (conversation == null) { \n\t\t\t\t// Open a query if there's none yet\n\t\t\t\tconversation = new Query(sender);\n\t\t\t\tserver.addConversationl(conversation);\n\t\t\t\tconversation.addMessage(message);\n\t\t\t\t\n\t\t\t\tIntent intent = new Intent(Broadcast.CONVERSATION_NEW);\n\t\t\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, sender);\n\t\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\t\tservice.sendBroadcast(intent);\n\t\t\t} else {\n\t\t\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, sender);\n\t\t\t\tservice.sendBroadcast(intent);\n\t\t\t}\n\t\t} else {\n\t\t\t// A action in a channel\n\t\t\tserver.getConversation(target).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Channel Info\n\t */\n\t@Override\n\tprotected void onChannelInfo(String channel, int userCount, String topic)\n\t{\n\t\tdebug(\"ChannelInfo\", channel + \" \" + userCount);\n\t}\n\n\t/**\n\t * On Deop\n\t */\n\t@Override\n\tprotected void onDeop(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Deop\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" deoped \" + recipient);\n\t\tmessage.setIcon(R.drawable.op);\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On DeVoice\n\t */\n\t@Override\n\tprotected void onDeVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"DeVoice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" devoiced \" + recipient);\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tmessage.setIcon(R.drawable.voice);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Invite\n\t */\n\t@Override\n\tprotected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String target)\n\t{\n\t\tdebug(\"Invite\", target + \" \" + targetNick + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" invited \" + targetNick);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Join\n\t */\n\t@Override\n\tprotected void onJoin(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Join\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We joined a new channel\n\t\t\tserver.addConversationl(new Channel(target));\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CONVERSATION_NEW);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tMessage message = new Message(sender + \" joined\");\n\t\t\tmessage.setIcon(R.drawable.join);\n\t\t\tmessage.setColor(Message.COLOR_GREEN);\n\t\t\tserver.getConversation(target).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Kick\n\t */\n\t@Override\n\tprotected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n\t{\n\t\tdebug(\"Kick\", target + \" \" + recipientNick + \"(\" + kickerNick + \")\");\n\t\t\n\t\tif (recipientNick.equals(getNick())) {\n\t\t\t// We are kicked\n\t\t\tserver.removeConversation(target);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CONVERSATION_REMOVE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tMessage message = new Message(kickerNick + \" kicked \" + recipientNick);\n\t\t\tmessage.setColor(Message.COLOR_GREEN);\n\t\t\tserver.getConversation(target).addMessage(message);\n\n\t\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\t\tservice.sendBroadcast(intent);\t\t\t\n\t\t}\n\t}\n\n\t/**\n\t * On Message\n\t */\n\t@Override\n\tprotected void onMessage(String target, String sender, String login, String hostname, String text)\n\t{\n\t\tdebug(\"Message\", target + \" \" + sender + \" \" + text);\n\t\t\n\t\t// Strip mIRC colors and formatting\n\t\ttext = Colors.removeFormattingAndColors(text);\n\n\t\tMessage message = new Message(\"<\" + sender + \"> \" + text);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Mode\n\t */\n\t@Override\n\tprotected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n\t{\n\t\tdebug(\"Mode\", target + \" \" + sourceNick + \" \" + mode);\n\t\t\n\t\t/*//Disabled as it doubles events (e.g. onOp and onMode will be called)\n\t\tMessage message = new Message(sourceNick + \" sets mode \" + mode);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t\t*/\n\t}\n\n\t/**\n\t * On Nick Change\n\t */\n\t@Override\n\tprotected void onNickChange(String oldNick, String login, String hostname, String newNick)\n\t{\n\t\tdebug(\"Nick\", oldNick + \" \" + newNick);\n\t\t\n\t\tfor (String target : getChannelsByNickname(newNick)) {\n\t\t\tMessage message = new Message(oldNick + \" is now known as \" + newNick);\n\t\t\tmessage.setColor(Message.COLOR_GREEN);\n\t\t\tserver.getConversation(target).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Notice\n\t */\n\t@Override\n\tprotected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n\t{\n\t\tdebug(\"Notice\", sourceNick + \" \" + notice);\n\n\t\t// Strip mIRC colors and formatting\n\t\tnotice = Colors.removeFormattingAndColors(notice);\n\t\t\n\t\t// Post notice to currently selected conversation\n\t\tConversation conversation = server.getConversation(server.getSelectedConversation());\n\t\t\n\t\tif (conversation == null) {\n\t\t\t// Fallback: Use ServerInfo view\n\t\t\tconversation = server.getConversation(ServerInfo.DEFAULT_NAME);\n\t\t}\n\n\t\tMessage message = new Message(\"-\" + sourceNick + \"- \" + notice);\n\t\tmessage.setIcon(R.drawable.info);\n\t\tconversation.addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, conversation.getName());\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Op\n\t */\n\t@Override\n\tprotected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Op\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" oped \" + recipient);\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tmessage.setIcon(R.drawable.op);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Part\n\t */\n\t@Override\n\tprotected void onPart(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Part\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We parted a channel\n\t\t\tserver.removeConversation(target);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CONVERSATION_REMOVE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tMessage message = new Message(sender + \" parted\");\n\t\t\tmessage.setColor(Message.COLOR_GREEN);\n\t\t\tmessage.setIcon(R.drawable.part);\n\t\t\tserver.getConversation(target).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Private Message\n\t */\n\t@Override\n\tprotected void onPrivateMessage(String sender, String login, String hostname, String text)\n\t{\n\t\tdebug(\"PrivateMessage\", sender + \" \" + text);\n\t\t\n\t\t// Strip mIRC colors and formatting\n\t\ttext = Colors.removeFormattingAndColors(text);\n\n\t\tMessage message = new Message(\"<\" + sender + \"> \" + text);\n\n\t\tConversation conversation = server.getConversation(sender);\n\n\t\tif (conversation == null) { \n\t\t\t// Open a query if there's none yet\n\t\t\tconversation = new Query(sender);\n\t\t\tconversation.addMessage(message);\n\t\t\tserver.addConversationl(conversation);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CONVERSATION_NEW);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, sender);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tconversation.addMessage(message);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, sender);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Quit\n\t */\n\t@Override\n\tprotected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n\t{\n\t\tdebug(\"Quit\", sourceNick);\n\t\t\n\t\tif (!sourceNick.equals(this.getNick())) {\n\t\t\tfor (String target : getChannelsByNickname(sourceNick)) {\n\t\t\t\tMessage message = new Message(sourceNick + \" quitted (\" + reason + \")\");\n\t\t\t\tmessage.setColor(Message.COLOR_GREEN);\n\t\t\t\tmessage.setIcon(R.drawable.quit);\n\t\t\t\tserver.getConversation(target).addMessage(message);\n\t\t\t\t\n\t\t\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\t\t\tservice.sendBroadcast(intent);\n\t\t\t}\n\t\t\t\n\t\t\t// Look if there's a query to update\n\t\t\tConversation conversation = server.getConversation(sourceNick);\n\t\t\t\n\t\t\tif (conversation != null) {\n\t\t\t\tMessage message = new Message(sourceNick + \" quitted (\" + reason + \")\");\n\t\t\t\tmessage.setColor(Message.COLOR_GREEN);\n\t\t\t\tmessage.setIcon(R.drawable.quit);\n\t\t\t\tconversation.addMessage(message);\n\t\t\t\t\n\t\t\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, conversation.getName());\n\t\t\t\tservice.sendBroadcast(intent);\n\t\t\t}\n\t\t\t\n\t\t} else {\n\t\t\t// XXX: We quitted\n\t\t}\n\t}\n\n\t/**\n\t * On Topic\n\t */\n\t@Override\n\tpublic void onTopic(String target, String topic, String setBy, long date, boolean changed)\n\t{\n\t\tdebug(\"Topic\", target + \" \" + setBy + \" \" + topic);\n\t\t\n\t\tif (changed) {\n\t\t\tMessage message = new Message(setBy + \" sets topic: \" + topic);\n\t\t\tmessage.setColor(Message.COLOR_YELLOW);\n\t\t\tserver.getConversation(target).addMessage(message);\n\t\t} else {\n\t\t\tMessage message = new Message(\"Topic: \" + topic);\n\t\t\tmessage.setColor(Message.COLOR_YELLOW);\n\t\t\tserver.getConversation(target).addMessage(message);\n\t\t}\n\t\t\n\t\t// remember channel's topic\n\t\t((Channel) server.getConversation(target)).setTopic(topic);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On User List\n\t */\n\t@Override\n\tprotected void onUserList(String channel, User[] users)\n\t{\n\t\tdebug(\"UserList\", channel + \" (\" + users.length + \")\");\n\t\t\n\t\t// XXX: Store user list somewhere and keep it updated or just broadcast some event?\n\t}\n\n\t/**\n\t * On Voice\n\t */\n\t@Override\n\tprotected void onVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Voice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" voiced \" + recipient);\n\t\tmessage.setIcon(R.drawable.voice);\n\t\tmessage.setColor(Message.COLOR_BLUE);\n\t\tserver.getConversation(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\t\n\t/**\n\t * On unknown\n\t */\n\t@Override\n\tprotected void onUnknown(String line)\n\t{\n\t\tdebug(\"Unknown\", line);\n\t\treturn;\n\t\t\n\t\t/*\n\t\t// Currently disabled... to much text\n\t\t\n\t\tMessage message = new Message(line);\n\t\tmessage.setIcon(R.drawable.action);\n\t\tmessage.setColor(Message.COLOR_GREY);\n\t\tserver.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, ServerInfo.DEFAULT_NAME);\n\t\tservice.sendBroadcast(intent);\n\t\t*/\n\t}\n\n\t/**\n\t * On server response\n\t */\n\t@Override\n\tprotected void onServerResponse(int code, String response)\n\t{\n\t\tdebug(\"ServerResponse\", code + \" \" + response);\n\t\treturn;\n\t\t\n\t\t/*\n\t\t// Currently disabled... to much text\n\t\tMessage message = new Message(response);\n\t\tserver.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CONVERSATION, ServerInfo.DEFAULT_NAME);\n\t\tservice.sendBroadcast(intent);\n\t\t*/\n\t}\n\n\t/**\n\t * On disconnect\n\t */\n\t@Override\n\tpublic void onDisconnect()\n\t{\n\t\tserver.setStatus(Status.DISCONNECTED);\n\t\tIntent sIntent = new Intent(Broadcast.SERVER_UPDATE);\n\t\tsIntent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tservice.sendBroadcast(sIntent);\t\t\n\t\t\n\t\tMessage message = new Message(\"Disconnected\");\n\t\tmessage.setIcon(R.drawable.error);\n\t\tmessage.setColor(Message.COLOR_RED);\n\t\tserver.getConversation(ServerInfo.DEFAULT_NAME).addMessage(message);\n\t\t\n\t\tIntent cIntent = new Intent(Broadcast.CONVERSATION_MESSAGE);\n\t\tcIntent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tcIntent.putExtra(Broadcast.EXTRA_CONVERSATION, ServerInfo.DEFAULT_NAME);\n\t\tservice.sendBroadcast(cIntent);\n\t}\n\n\t/**\n\t * Print an event to the debug console \n\t */\n\tprivate void debug(String event, String params)\n\t{\n\t\tif (DEBUG_EVENTS) {\n\t\t\tLog.d(TAG, \"(\" + server.getTitle() + \") [\" + event + \"]: \" + params);\n\t\t}\n\t}\n\t\n\t/**\n\t * Get all channels where the user with the given nickname is online\n\t * \n\t * @param nickname\n\t * @return Array of channel names\n\t */\n\tprivate Vector<String> getChannelsByNickname(String nickname)\n\t{\n\t\tVector<String> channels = new Vector<String>();\n\t\t\n\t\tfor (String channel : this.getChannels()) {\n\t\t\tfor (User user : this.getUsers(channel)) {\n\t\t\t\tif (user.getNick().equals(nickname)) {\n\t\t\t\t\tchannels.add(channel);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tLog.d(TAG, \"Found \" + channels.size() + \" channels for nickname \" + nickname);\n\t\t\n\t\treturn channels;\n\t}\n\t\n\t/**\n\t * Quits from the IRC server with default reason.\n\t */\n\t@Override\n\tpublic void quitServer()\n\t{\n\t\tquitServer(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n}\n","lineNo":629}
{"Smelly Sample":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2010 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.model;\n\nimport android.content.Context;\nimport android.graphics.Typeface;\nimport android.graphics.drawable.Drawable;\nimport android.text.Spannable;\nimport android.text.SpannableString;\nimport android.text.style.ForegroundColorSpan;\nimport android.text.style.ImageSpan;\nimport android.widget.TextView;\n\n/**\n * A channel or server message\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class Message {\n\tpublic static final int COLOR_GREEN  = 0xFF458509;\n\tpublic static final int COLOR_RED    = 0xFFcc0000;\n\tpublic static final int COLOR_BLUE   = 0xFF729fcf;\n\tpublic static final int COLOR_YELLOW = 0xFFbe9b01;\n\t\n\tprivate int icon = -1;\n\tprivate String text;\n\tprivate SpannableString canvas;\n\tprivate int color = -1;\n\t\n\t/**\n\t * Create a new message without an icon\n\t * \n\t * @param text\n\t */\n\tpublic Message(String text)\n\t{\n\t\tthis.text = text;\n\t}\n\t\n\t/**\n\t * Set the message's icon\n\t */\n\tpublic void setIcon(int icon)\n\t{\n\t\tthis.icon = icon;\n\t}\n\t\n\t/**\n\t * Get the message's icon\n\t * \n\t * @return\n\t */\n\tpublic int getIcon()\n\t{\n\t\treturn icon;\n\t}\n\t\n\t/**\n\t * Does this message have an icon?\n\t * \n\t * @return\n\t */\n\tpublic boolean hasIcon()\n\t{\n\t\treturn icon != -1;\n\t}\n\t\n\t/**\n\t * Get the text of this message\n\t * \n\t * @return\n\t */\n\tpublic String getText()\n\t{\n\t\treturn text;\n\t}\n\t\n\t/**\n\t * Set the color of this message\n\t */\n\tpublic void setColor(int color)\n\t{\n\t\tthis.color = color;\n\t}\n\t\n\t/**\n\t * Render message as spannable string\n\t * \n\t * @return\n\t */\n\tpublic SpannableString render(Context context)\n\t{\n\t\tSettings settings = new Settings(context);\n\t\t\n\t\tif (canvas == null) {\n\t\t\tString prefix = hasIcon() && settings.showIcons() ? \"  \" : \"\";\n\t\t\tcanvas = new SpannableString(prefix + text);\n\t\t\t\n\t\t\tif (hasIcon() && settings.showIcons()) {\n\t\t\t\tDrawable drawable = context.getResources().getDrawable(icon);\n\t\t\t\tdrawable.setBounds(0, 0, drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight());\n\t\t\t\tcanvas.setSpan(new ImageSpan(drawable, ImageSpan.ALIGN_BOTTOM), 0, 1, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n\t\t\t}\n\t\t\tif (color != -1 && settings.showTimestamp()) {\n\t\t\t\tcanvas.setSpan(new ForegroundColorSpan(color), 0, canvas.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn canvas;\n\t}\n\t\n\tpublic TextView renderTextView(Context context)\n\t{\n\t\tTextView canvas = new TextView(context);\n\t\t\n\t\tcanvas.setText(this.render(context));\n\t\tcanvas.setTextSize(11);\n\t\tcanvas.setTypeface(Typeface.MONOSPACE);\n\t\tcanvas.setTextColor(0xffeeeeee);\n\t\t\n\t\treturn canvas;\n\t}\n}\n","Method after Refactoring":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009-2010 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.model;\n\nimport java.util.Date;\n\nimport android.content.Context;\nimport android.graphics.Typeface;\nimport android.graphics.drawable.Drawable;\nimport android.text.Spannable;\nimport android.text.SpannableString;\nimport android.text.style.ForegroundColorSpan;\nimport android.text.style.ImageSpan;\nimport android.widget.TextView;\n\n/**\n * A channel or server message\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class Message {\n\tpublic static final int COLOR_GREEN  = 0xFF458509;\n\tpublic static final int COLOR_RED    = 0xFFcc0000;\n\tpublic static final int COLOR_BLUE   = 0xFF729fcf;\n\tpublic static final int COLOR_YELLOW = 0xFFbe9b01;\n\t\n\tprivate int icon = -1;\n\tprivate String text;\n\tprivate SpannableString canvas;\n\tprivate int color = -1;\n\t\n\t/**\n\t * Create a new message without an icon\n\t * \n\t * @param text\n\t */\n\tpublic Message(String text)\n\t{\n\t\tthis.text = text;\n\t}\n\t\n\t/**\n\t * Set the message's icon\n\t */\n\tpublic void setIcon(int icon)\n\t{\n\t\tthis.icon = icon;\n\t}\n\t\n\t/**\n\t * Get the message's icon\n\t * \n\t * @return\n\t */\n\tpublic int getIcon()\n\t{\n\t\treturn icon;\n\t}\n\t\n\t/**\n\t * Does this message have an icon?\n\t * \n\t * @return\n\t */\n\tpublic boolean hasIcon()\n\t{\n\t\treturn icon != -1;\n\t}\n\t\n\t/**\n\t * Get the text of this message\n\t * \n\t * @return\n\t */\n\tpublic String getText()\n\t{\n\t\treturn text;\n\t}\n\t\n\t/**\n\t * Set the color of this message\n\t */\n\tpublic void setColor(int color)\n\t{\n\t\tthis.color = color;\n\t}\n\t\n\t/**\n\t * Render message as spannable string\n\t * \n\t * @return\n\t */\n\tpublic SpannableString render(Context context)\n\t{\n\t\tSettings settings = new Settings(context);\n\t\t\n\t\tif (canvas == null) {\n\t\t\tString prefix = hasIcon() && settings.showIcons() ? \"  \" : \"\";\n\t\t\tString timestamp = settings.showTimestamp() ? Message.generateTimestamp(settings.use24hFormat()) : \"\";\n\t\t\t\n\t\t\tcanvas = new SpannableString(prefix + timestamp + text);\n\t\t\t\n\t\t\tif (hasIcon() && settings.showIcons()) {\n\t\t\t\tDrawable drawable = context.getResources().getDrawable(icon);\n\t\t\t\tdrawable.setBounds(0, 0, drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight());\n\t\t\t\tcanvas.setSpan(new ImageSpan(drawable, ImageSpan.ALIGN_BOTTOM), 0, 1, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n\t\t\t}\n\t\t\tif (color != -1 && settings.showColors()) {\n\t\t\t\tcanvas.setSpan(new ForegroundColorSpan(color), 0, canvas.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn canvas;\n\t}\n\t\n\t/**\n\t * Render message as text view\n\t * \n\t * @param context\n\t * @return\n\t */\n\tpublic TextView renderTextView(Context context)\n\t{\n\t\tTextView canvas = new TextView(context);\n\t\t\n\t\tcanvas.setText(this.render(context));\n\t\tcanvas.setTextSize(11);\n\t\tcanvas.setTypeface(Typeface.MONOSPACE);\n\t\tcanvas.setTextColor(0xffeeeeee);\n\t\t\n\t\treturn canvas;\n\t}\n\t\n\t/**\n\t * Generate a timestamp\n\t * \n\t * @param use24hFormat\n\t * @return\n\t */\n\tpublic static String generateTimestamp(boolean use24hFormat)\n\t{\n\t\tDate date = new Date();\n\t\t\n\t\tint hours = date.getHours();\n\t\t\n\t\tif (!use24hFormat) {\n\t\t\thours = Math.abs(24 - hours);\n\t\t}\n\t\t\n\t\treturn \"[\" + hours + \":\" + date.getMinutes() + \"] \";\n\t}\n}\n","lineNo":117}
{"Smelly Sample":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.irc;\n\nimport org.yaaic.model.Server;\n\nimport android.os.Binder;\nimport android.util.Log;\n\n/**\n * Binder for service communication\n *  \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class IRCBinder extends Binder\n{\n\tpublic static final String TAG = \"Yaaic/IRCBinder\";\n\t\n\tprivate IRCService service;\n\t\n\t/**\n\t * Create a new binder for given service \n\t * \n\t * @param service\n\t */\n\tpublic IRCBinder(IRCService service)\n\t{\n\t\tsuper();\n\t\t\n\t\tthis.service = service;\n\t}\n\t\n\t/**\n\t * Connect to given server\n\t * \n\t * @param server\n\t */\n\tpublic void connect(final Server server)\n\t{\n\t\tnew Thread() {\n\t\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\tgetService().getConnection(server.getId()).connect(server.getHost());\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tLog.d(TAG, \"Exception: \" + e.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t}.start();\n\t}\n\t\n\t/**\n\t * Get service associated with this service\n\t * @return\n\t */\n\tpublic IRCService getService()\n\t{\n\t\treturn service;\n\t}\n}\n","Method after Refactoring":"/*\nYaaic - Yet Another Android IRC Client\n\nCopyright 2009 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.irc;\n\nimport org.yaaic.model.Server;\n\nimport android.os.Binder;\nimport android.util.Log;\n\n/**\n * Binder for service communication\n *  \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class IRCBinder extends Binder\n{\n\tpublic static final String TAG = \"Yaaic/IRCBinder\";\n\t\n\tprivate IRCService service;\n\t\n\t/**\n\t * Create a new binder for given service \n\t * \n\t * @param service\n\t */\n\tpublic IRCBinder(IRCService service)\n\t{\n\t\tsuper();\n\t\t\n\t\tthis.service = service;\n\t}\n\t\n\t/**\n\t * Connect to given server\n\t * \n\t * @param server\n\t */\n\tpublic void connect(final Server server)\n\t{\n\t\tnew Thread() {\n\t\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\tIRCConnection connection = getService().getConnection(server.getId());\n\n\t\t\t\t\tconnection.setNickname(server.getIdentity().getNickname());\n\t\t\t\t\tconnection.setIdent(server.getIdentity().getIdent());\n\t\t\t\t\t\n\t\t\t\t\tconnection.connect(server.getHost());\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tLog.d(TAG, \"Exception: \" + e.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t}.start();\n\t}\n\t\n\t/**\n\t * Get service associated with this service\n\t * @return\n\t */\n\tpublic IRCService getService()\n\t{\n\t\treturn service;\n\t}\n}\n","lineNo":61}
{"Smelly Sample":"/*\n Yaaic - Yet Another Android IRC Client\n\nCopyright 2009 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.view;\n\nimport android.app.Activity;\nimport android.app.Dialog;\nimport android.content.ComponentName;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.os.Bundle;\nimport android.os.IBinder;\nimport android.util.Log;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.View.OnClickListener;\nimport android.view.View.OnKeyListener;\nimport android.widget.AdapterView;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.Gallery;\nimport android.widget.ImageView;\nimport android.widget.TextView;\nimport android.widget.ViewSwitcher;\nimport android.widget.AdapterView.OnItemClickListener;\nimport android.widget.AdapterView.OnItemSelectedListener;\nimport android.widget.TableLayout.LayoutParams;\n\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.adapter.DeckAdapter;\nimport org.yaaic.adapter.MessageListAdapter;\nimport org.yaaic.command.CommandParser;\nimport org.yaaic.irc.IRCBinder;\nimport org.yaaic.irc.IRCService;\nimport org.yaaic.listener.ChannelListener;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Server;\nimport org.yaaic.receiver.ChannelReceiver;\n\n/**\n * The server view with a scrollable list of all channels\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class ServerActivity extends Activity implements ServiceConnection, ChannelListener, OnItemClickListener, OnKeyListener, OnItemSelectedListener\n{\n\tpublic static final String TAG = \"Yaaic/ServerActivity\";\n\t\n\tprivate int serverId;\n\tprivate Server server;\n\tprivate IRCBinder binder;\n\tprivate ChannelReceiver receiver;\n\t\n\tprivate ViewSwitcher switcher;\n\tprivate Gallery deck;\n\tprivate DeckAdapter deckAdapter;\n\t\n\t/**\n\t * On create\n\t */\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState)\n\t{\n\t\tsuper.onCreate(savedInstanceState);\n\t\t\n\t\tserverId = getIntent().getExtras().getInt(\"serverId\");\n\t\tserver = (Server) Yaaic.getInstance().getServerById(serverId);\n\t\tsetTitle(\"Yaaic - \" + server.getTitle());\n\t\t\n\t\tsetContentView(R.layout.server);\n\t\t\n\t\t((TextView) findViewById(R.id.title)).setText(server.getTitle());\n\t\t((ImageView) findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\t\t((EditText) findViewById(R.id.input)).setOnKeyListener(this);\n\t\t\n\t\tdeck = (Gallery) findViewById(R.id.deck);\n\t\tdeck.setOnItemSelectedListener(this);\n        deckAdapter = new DeckAdapter();\n\t\tdeck.setAdapter(deckAdapter);\n\t\tdeck.setOnItemClickListener(this);\n\n\t\tswitcher = (ViewSwitcher) findViewById(R.id.switcher);\n\t\t\n\t\tfor (Conversation conversation : server.getConversations()) {\n\t\t\tonNewConversation(conversation.getName());\n\t\t}\n\t}\n\t\n\t/**\n\t * On resume\n\t */\n\t@Override\n\tpublic void onResume()\n\t{\n\t\tsuper.onResume();\n\t\t\n        Intent intent = new Intent(this, IRCService.class);\n        bindService(intent, this, 0);\n        \n    \treceiver = new ChannelReceiver(server.getId(), this);\n    \tregisterReceiver(receiver, new IntentFilter(Broadcast.CHANNEL_MESSAGE));\n    \tregisterReceiver(receiver, new IntentFilter(Broadcast.CHANNEL_NEW));\n    \tregisterReceiver(receiver, new IntentFilter(Broadcast.CHANNEL_REMOVE));\n\t}\n\t\n\t/**\n\t * On Pause\n\t */\n\t@Override\n\tpublic void onPause()\n\t{\n\t\tsuper.onPause();\n\t\t\n\t\tunbindService(this);\n\t\tunregisterReceiver(receiver);\n\t}\n\n\t/**\n\t * On service connected\n\t */\n\tpublic void onServiceConnected(ComponentName name, IBinder service)\n\t{\n\t\tthis.binder = (IRCBinder) service;\n\t}\n\n\t/**\n\t * On service disconnected\n\t */\n\tpublic void onServiceDisconnected(ComponentName name)\n\t{\n\t\tthis.binder = null;\n\t}\n\n\t/**\n\t * On options menu requested\n\t */\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu)\n\t{\n    \tsuper.onCreateOptionsMenu(menu);\n    \t\n    \t// inflate from xml\n    \tMenuInflater inflater = getMenuInflater();\n    \tinflater.inflate(R.menu.server, menu);\n    \t\n    \treturn true;\n\t}\n\n\t/**\n\t * On menu item selected\n\t */\n\t@Override\n\tpublic boolean onMenuItemSelected(int featureId, MenuItem item)\n\t{\n\t\tswitch (item.getItemId()) {\n\t\t\tcase R.id.disconnect:\n\t\t\t\tbinder.getService().getConnection(serverId).quitServer();\n\t\t\t\tserver.clearConversations();\n\t\t\t\tsetResult(RESULT_OK);\n\t\t\t\tfinish();\n\t\t\t\tbreak;\n\t\t\tcase R.id.join:\n\t\t\t\tfinal Dialog dialog = new Dialog(this);\n\t\t\t\tdialog.setContentView(R.layout.channeldialog);\n\t\t\t\tdialog.setTitle(R.string.channel);\n\n\t\t\t\tButton button = (Button) dialog.findViewById(R.id.join);\n\t\t\t\tbutton.setOnClickListener(new OnClickListener() {\n\t\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\t\tString channel = ((EditText) v.getRootView().findViewById(R.id.channel)).getText().toString();\n\t\t\t\t\t\tbinder.getService().getConnection(serverId).joinChannel(channel);\n\t\t\t\t\t\tdialog.cancel();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tdialog.show();\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\t/**\n\t * Get server object assigned to this activity\n\t * \n\t * @return the server object\n\t */\n\tpublic Server getServer()\n\t{\n\t\treturn server;\n\t}\n\n\t/**\n\t * On channel message\n\t */\n\tpublic void onConversationMessage(String target)\n\t{\n\t\tConversation conversation = server.getConversation(target);\n\t\t\n\t\twhile(conversation.hasBufferedMessages()) {\n\t\t\tMessage message = conversation.pollBufferedMessage();\n\t\t\t\n\t\t\tint position = deckAdapter.getPositionByName(target);\n\t\t\t\n\t\t\tif (position != -1) {\n\t\t\t\tMessageListView view = (MessageListView) deck.getChildAt(position);\n\t\t\t\tif (view != null) {\n\t\t\t\t\tMessageListAdapter adapter = view.getAdapter();\n\t\t\t\t\tadapter.addMessage(message);\n\t\t\t\t} else {\n\t\t\t\t\tLog.d(TAG, \"MessageListView Adapter is null (position: \" + position + \")\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (deckAdapter.isSwitched()) {\n\t\t\t\tMessageListView switchedView = deckAdapter.getSwitchedView();\n\t\t\t\tswitchedView.getAdapter().addMessage(message);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * On new channel\n\t */\n\tpublic void onNewConversation(String target)\n\t{\n\t\tdeckAdapter.addItem(server.getConversation(target));\n\t\t\n\t\tif (!deckAdapter.isSwitched()) {\n\t\t\t// Scroll to new conversation\n\t\t\tdeck.setSelection(deckAdapter.getCount() - 1);\n\t\t}\n\t}\n\n\t/**\n\t * On Channel item clicked\n\t */\n\tpublic void onItemClick(AdapterView<?> adapterView, View view, int position, long id)\n\t{\n\t\tLog.d(TAG, \"Selected channel: \" + position);\n\t\t\n\t\tConversation conversation = deckAdapter.getItem(position);\n\t\tMessageListView canvas = deckAdapter.renderConversation(conversation, switcher);\n\t\tcanvas.setLayoutParams(new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT));\n\t\tcanvas.setDelegateTouchEvents(false); // Do not delegate\n\t\tdeckAdapter.setSwitched(conversation.getName(), canvas);\n\t\tswitcher.addView(canvas);\n\t\tswitcher.showNext();\n\t}\n\t\n\t/**\n\t * On key down\n\t * \n\t * This is glue code to call onBackPressed() which\n\t * will be automatically called by later android releases\n\t */\n\t@Override\n\tpublic boolean onKeyDown(int keyCode, KeyEvent event)\n\t{\n\t\tif (keyCode == KeyEvent.KEYCODE_BACK) {\n\t\t\tonBackPressed();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * On back key pressed\n\t */\n\tpublic void onBackPressed()\n\t{\n\t\tif (deckAdapter.isSwitched()) {\n\t\t\tswitcher.showNext();\n\t\t\tswitcher.removeView(deckAdapter.getSwitchedView());\n\t\t\tdeckAdapter.setSwitched(null, null);\n\t\t} else {\n\t\t\tfinish();\n\t\t}\n\t}\n\n\t/**\n\t * On channel remove\n\t */\n\tpublic void onRemoveConversation(String target)\n\t{\n\t\t// XXX: Implement me :)\n\t}\n\n\t/**\n\t * On key pressed (input line)\n\t */\n\tpublic boolean onKey(View view, int keyCode, KeyEvent event)\n\t{\n\t\tif (keyCode == KeyEvent.KEYCODE_ENTER && event.getAction() == KeyEvent.ACTION_UP) {\n\t\t\tEditText input = (EditText) view;\n\t\t\tString text = input.getText().toString();\n\t\t\tinput.setText(\"\");\n\t\t\t\n\t\t\tif (text == \"\") {\n\t\t\t\t// ignore empty messages\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\tConversation conversation = deckAdapter.getItem(deck.getSelectedItemPosition());\n\t\t\t\n\t\t\tif (conversation != null) {\n\t\t\t\tif (!text.trim().startsWith(\"/\")) {\n\t\t\t\t\tString nickname = this.binder.getService().getConnection(serverId).getNick();\n\t\t\t\t\tconversation.addMessage(new Message(\"<\" + nickname + \"> \" + text));\n\t\t\t\t\tonConversationMessage(conversation.getName());\n\t\t\t\t\tthis.binder.getService().getConnection(serverId).sendMessage(conversation.getName(), text);\n\t\t\t\t} else {\n\t\t\t\t\tCommandParser.getInstance().parse(text, server, conversation, binder.getService());\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * On channel selected/focused\n\t */\n\tpublic void onItemSelected(AdapterView<?> deck, View view, int position, long id)\n\t{\n\t\tConversation conversation = (Conversation) deck.getItemAtPosition(position);\n\t\t\n\t\tif (conversation != null && conversation.getType() != Conversation.TYPE_SERVER) {\n\t\t\t((TextView) findViewById(R.id.title)).setText(server.getTitle() + \" - \" + conversation.getName());\n\t\t} else {\n\t\t\tonNothingSelected(deck);\n\t\t}\n\t\t\n\t\t// Remember selection\n\t\tif (conversation != null) {\n\t\t\tserver.setSelectedConversation(conversation.getName());\n\t\t}\n\t}\n\n\t/**\n\t * On no channel selected/focused\n\t */\n\tpublic void onNothingSelected(AdapterView<?> deck)\n\t{\n\t\t((TextView) findViewById(R.id.title)).setText(server.getTitle());\n\t}\n}\n","Method after Refactoring":"/*\n Yaaic - Yet Another Android IRC Client\n\nCopyright 2009 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.view;\n\nimport android.app.Activity;\nimport android.app.Dialog;\nimport android.content.ComponentName;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.os.Bundle;\nimport android.os.IBinder;\nimport android.util.Log;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.View.OnClickListener;\nimport android.view.View.OnKeyListener;\nimport android.widget.AdapterView;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.Gallery;\nimport android.widget.ImageView;\nimport android.widget.TextView;\nimport android.widget.ViewSwitcher;\nimport android.widget.AdapterView.OnItemClickListener;\nimport android.widget.AdapterView.OnItemSelectedListener;\nimport android.widget.TableLayout.LayoutParams;\n\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.adapter.DeckAdapter;\nimport org.yaaic.adapter.MessageListAdapter;\nimport org.yaaic.command.CommandParser;\nimport org.yaaic.irc.IRCBinder;\nimport org.yaaic.irc.IRCService;\nimport org.yaaic.listener.ChannelListener;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Conversation;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Server;\nimport org.yaaic.receiver.ChannelReceiver;\n\n/**\n * The server view with a scrollable list of all channels\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class ServerActivity extends Activity implements ServiceConnection, ChannelListener, OnItemClickListener, OnKeyListener, OnItemSelectedListener\n{\n\tpublic static final String TAG = \"Yaaic/ServerActivity\";\n\t\n\tprivate int serverId;\n\tprivate Server server;\n\tprivate IRCBinder binder;\n\tprivate ChannelReceiver receiver;\n\t\n\tprivate ViewSwitcher switcher;\n\tprivate Gallery deck;\n\tprivate DeckAdapter deckAdapter;\n\t\n\t/**\n\t * On create\n\t */\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState)\n\t{\n\t\tsuper.onCreate(savedInstanceState);\n\t\t\n\t\tserverId = getIntent().getExtras().getInt(\"serverId\");\n\t\tserver = (Server) Yaaic.getInstance().getServerById(serverId);\n\t\tsetTitle(\"Yaaic - \" + server.getTitle());\n\t\t\n\t\tsetContentView(R.layout.server);\n\t\t\n\t\t((TextView) findViewById(R.id.title)).setText(server.getTitle());\n\t\t((ImageView) findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\t\t\n\t\tEditText input = (EditText) findViewById(R.id.input);\n\t\tinput.setOnKeyListener(this);\n\n\t\tif (!server.isConnected()) {\n\t\t\tinput.setEnabled(false);\n\t\t}\n\t\t\n\t\tdeck = (Gallery) findViewById(R.id.deck);\n\t\tdeck.setOnItemSelectedListener(this);\n        deckAdapter = new DeckAdapter();\n\t\tdeck.setAdapter(deckAdapter);\n\t\tdeck.setOnItemClickListener(this);\n\n\t\tswitcher = (ViewSwitcher) findViewById(R.id.switcher);\n\t\t\n\t\tfor (Conversation conversation : server.getConversations()) {\n\t\t\tonNewConversation(conversation.getName());\n\t\t}\n\t}\n\t\n\t/**\n\t * On resume\n\t */\n\t@Override\n\tpublic void onResume()\n\t{\n\t\tsuper.onResume();\n\t\t\n        Intent intent = new Intent(this, IRCService.class);\n        bindService(intent, this, 0);\n        \n    \treceiver = new ChannelReceiver(server.getId(), this);\n    \tregisterReceiver(receiver, new IntentFilter(Broadcast.CHANNEL_MESSAGE));\n    \tregisterReceiver(receiver, new IntentFilter(Broadcast.CHANNEL_NEW));\n    \tregisterReceiver(receiver, new IntentFilter(Broadcast.CHANNEL_REMOVE));\n\t}\n\t\n\t/**\n\t * On Pause\n\t */\n\t@Override\n\tpublic void onPause()\n\t{\n\t\tsuper.onPause();\n\t\t\n\t\tunbindService(this);\n\t\tunregisterReceiver(receiver);\n\t}\n\n\t/**\n\t * On service connected\n\t */\n\tpublic void onServiceConnected(ComponentName name, IBinder service)\n\t{\n\t\tthis.binder = (IRCBinder) service;\n\t}\n\n\t/**\n\t * On service disconnected\n\t */\n\tpublic void onServiceDisconnected(ComponentName name)\n\t{\n\t\tthis.binder = null;\n\t}\n\n\t/**\n\t * On options menu requested\n\t */\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu)\n\t{\n    \tsuper.onCreateOptionsMenu(menu);\n    \t\n    \t// inflate from xml\n    \tMenuInflater inflater = getMenuInflater();\n    \tinflater.inflate(R.menu.server, menu);\n    \t\n    \treturn true;\n\t}\n\n\t/**\n\t * On menu item selected\n\t */\n\t@Override\n\tpublic boolean onMenuItemSelected(int featureId, MenuItem item)\n\t{\n\t\tswitch (item.getItemId()) {\n\t\t\tcase R.id.disconnect:\n\t\t\t\tbinder.getService().getConnection(serverId).quitServer();\n\t\t\t\tserver.clearConversations();\n\t\t\t\tsetResult(RESULT_OK);\n\t\t\t\tfinish();\n\t\t\t\tbreak;\n\t\t\tcase R.id.join:\n\t\t\t\tfinal Dialog dialog = new Dialog(this);\n\t\t\t\tdialog.setContentView(R.layout.channeldialog);\n\t\t\t\tdialog.setTitle(R.string.channel);\n\n\t\t\t\tButton button = (Button) dialog.findViewById(R.id.join);\n\t\t\t\tbutton.setOnClickListener(new OnClickListener() {\n\t\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\t\tString channel = ((EditText) v.getRootView().findViewById(R.id.channel)).getText().toString();\n\t\t\t\t\t\tbinder.getService().getConnection(serverId).joinChannel(channel);\n\t\t\t\t\t\tdialog.cancel();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tdialog.show();\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\t/**\n\t * Get server object assigned to this activity\n\t * \n\t * @return the server object\n\t */\n\tpublic Server getServer()\n\t{\n\t\treturn server;\n\t}\n\n\t/**\n\t * On channel message\n\t */\n\tpublic void onConversationMessage(String target)\n\t{\n\t\tConversation conversation = server.getConversation(target);\n\t\t\n\t\twhile(conversation.hasBufferedMessages()) {\n\t\t\tMessage message = conversation.pollBufferedMessage();\n\t\t\t\n\t\t\tint position = deckAdapter.getPositionByName(target);\n\t\t\t\n\t\t\tif (position != -1) {\n\t\t\t\tMessageListView view = (MessageListView) deck.getChildAt(position);\n\t\t\t\tif (view != null) {\n\t\t\t\t\tMessageListAdapter adapter = view.getAdapter();\n\t\t\t\t\tadapter.addMessage(message);\n\t\t\t\t} else {\n\t\t\t\t\tLog.d(TAG, \"MessageListView Adapter is null (position: \" + position + \")\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (deckAdapter.isSwitched()) {\n\t\t\t\tMessageListView switchedView = deckAdapter.getSwitchedView();\n\t\t\t\tswitchedView.getAdapter().addMessage(message);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * On new channel\n\t */\n\tpublic void onNewConversation(String target)\n\t{\n\t\tdeckAdapter.addItem(server.getConversation(target));\n\t\t\n\t\tif (!deckAdapter.isSwitched()) {\n\t\t\t// Scroll to new conversation\n\t\t\tdeck.setSelection(deckAdapter.getCount() - 1);\n\t\t}\n\t}\n\n\t/**\n\t * On Channel item clicked\n\t */\n\tpublic void onItemClick(AdapterView<?> adapterView, View view, int position, long id)\n\t{\n\t\tLog.d(TAG, \"Selected channel: \" + position);\n\t\t\n\t\tConversation conversation = deckAdapter.getItem(position);\n\t\tMessageListView canvas = deckAdapter.renderConversation(conversation, switcher);\n\t\tcanvas.setLayoutParams(new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT));\n\t\tcanvas.setDelegateTouchEvents(false); // Do not delegate\n\t\tdeckAdapter.setSwitched(conversation.getName(), canvas);\n\t\tswitcher.addView(canvas);\n\t\tswitcher.showNext();\n\t}\n\t\n\t/**\n\t * On key down\n\t * \n\t * This is glue code to call onBackPressed() which\n\t * will be automatically called by later android releases\n\t */\n\t@Override\n\tpublic boolean onKeyDown(int keyCode, KeyEvent event)\n\t{\n\t\tif (keyCode == KeyEvent.KEYCODE_BACK) {\n\t\t\tonBackPressed();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * On back key pressed\n\t */\n\tpublic void onBackPressed()\n\t{\n\t\tif (deckAdapter.isSwitched()) {\n\t\t\tswitcher.showNext();\n\t\t\tswitcher.removeView(deckAdapter.getSwitchedView());\n\t\t\tdeckAdapter.setSwitched(null, null);\n\t\t} else {\n\t\t\tfinish();\n\t\t}\n\t}\n\n\t/**\n\t * On channel remove\n\t */\n\tpublic void onRemoveConversation(String target)\n\t{\n\t\t// XXX: Implement me :)\n\t}\n\n\t/**\n\t * On key pressed (input line)\n\t */\n\tpublic boolean onKey(View view, int keyCode, KeyEvent event)\n\t{\n\t\tif (keyCode == KeyEvent.KEYCODE_ENTER && event.getAction() == KeyEvent.ACTION_UP) {\n\t\t\tEditText input = (EditText) view;\n\t\t\tString text = input.getText().toString();\n\t\t\tinput.setText(\"\");\n\t\t\t\n\t\t\tif (text == \"\") {\n\t\t\t\t// ignore empty messages\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\tConversation conversation = deckAdapter.getItem(deck.getSelectedItemPosition());\n\t\t\t\n\t\t\tif (conversation != null) {\n\t\t\t\tif (!text.trim().startsWith(\"/\")) {\n\t\t\t\t\tString nickname = this.binder.getService().getConnection(serverId).getNick();\n\t\t\t\t\tconversation.addMessage(new Message(\"<\" + nickname + \"> \" + text));\n\t\t\t\t\tonConversationMessage(conversation.getName());\n\t\t\t\t\tthis.binder.getService().getConnection(serverId).sendMessage(conversation.getName(), text);\n\t\t\t\t} else {\n\t\t\t\t\tCommandParser.getInstance().parse(text, server, conversation, binder.getService());\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * On channel selected/focused\n\t */\n\tpublic void onItemSelected(AdapterView<?> deck, View view, int position, long id)\n\t{\n\t\tConversation conversation = (Conversation) deck.getItemAtPosition(position);\n\t\t\n\t\tif (conversation != null && conversation.getType() != Conversation.TYPE_SERVER) {\n\t\t\t((TextView) findViewById(R.id.title)).setText(server.getTitle() + \" - \" + conversation.getName());\n\t\t} else {\n\t\t\tonNothingSelected(deck);\n\t\t}\n\t\t\n\t\t// Remember selection\n\t\tif (conversation != null) {\n\t\t\tserver.setSelectedConversation(conversation.getName());\n\t\t}\n\t}\n\n\t/**\n\t * On no channel selected/focused\n\t */\n\tpublic void onNothingSelected(AdapterView<?> deck)\n\t{\n\t\t((TextView) findViewById(R.id.title)).setText(server.getTitle());\n\t}\n}\n","lineNo":99}
{"Smelly Sample":"/*\n Yaaic - Yet Another Android IRC Client\n\nCopyright 2009 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.view;\n\nimport android.app.Activity;\nimport android.app.Dialog;\nimport android.content.ComponentName;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.os.Bundle;\nimport android.os.IBinder;\nimport android.util.Log;\nimport android.view.Display;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.View.OnClickListener;\nimport android.widget.AdapterView;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.Gallery;\nimport android.widget.ImageView;\nimport android.widget.TextView;\nimport android.widget.ViewSwitcher;\nimport android.widget.AdapterView.OnItemClickListener;\nimport android.widget.TableLayout.LayoutParams;\n\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.adapter.DeckAdapter;\nimport org.yaaic.adapter.MessageListAdapter;\nimport org.yaaic.irc.IRCBinder;\nimport org.yaaic.irc.IRCService;\nimport org.yaaic.listener.ChannelListener;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Server;\nimport org.yaaic.receiver.ChannelReceiver;\n\n/**\n * The server view with a scrollable list of all channels\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class ServerActivity extends Activity implements ServiceConnection, ChannelListener, OnItemClickListener\n{\n\tpublic static final String TAG = \"Yaaic/ServerActivity\";\n\t\n\tprivate int serverId;\n\tprivate Server server;\n\tprivate IRCBinder binder;\n\tprivate ChannelReceiver receiver;\n\t\n\tprivate ViewSwitcher switcher;\n\tprivate Gallery deck;\n\tprivate DeckAdapter deckAdapter;\n\t\n\t/**\n\t * On create\n\t */\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState)\n\t{\n\t\tsuper.onCreate(savedInstanceState);\n\t\t\n\t\tserverId = getIntent().getExtras().getInt(\"serverId\");\n\t\tserver = (Server) Yaaic.getInstance().getServerById(serverId);\n\t\tsetTitle(\"Yaaic - \" + server.getTitle());\n\t\t\n\t\tsetContentView(R.layout.server);\n\t\t\n\t\t((TextView) findViewById(R.id.title)).setText(server.getTitle());\n\t\t((ImageView) findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\t\t\n        Display d = getWindowManager().getDefaultDisplay();\n\n\t\tdeck = (Gallery) findViewById(R.id.deck);\n        deckAdapter = new DeckAdapter(d.getWidth(), d.getHeight());\n\t\tdeck.setAdapter(deckAdapter);\n\t\tdeck.setOnItemClickListener(this);\n\n\t\tswitcher = (ViewSwitcher) findViewById(R.id.switcher);\n\t\t\n\t\tfor (Channel channel : server.getChannels()) {\n\t\t\tonNewChannel(channel.getName());\n\t\t}\n\t}\n\t\n\t/**\n\t * On resume\n\t */\n\t@Override\n\tpublic void onResume()\n\t{\n\t\tsuper.onResume();\n\t\t\n        Intent intent = new Intent(this, IRCService.class);\n        bindService(intent, this, 0);\n        \n    \treceiver = new ChannelReceiver(server.getId(), this);\n    \tregisterReceiver(receiver, new IntentFilter(Broadcast.CHANNEL_MESSAGE));\n    \tregisterReceiver(receiver, new IntentFilter(Broadcast.CHANNEL_NEW));\n    \tregisterReceiver(receiver, new IntentFilter(Broadcast.CHANNEL_REMOVE));\n\t}\n\t\n\t/**\n\t * On Pause\n\t */\n\t@Override\n\tpublic void onPause()\n\t{\n\t\tsuper.onPause();\n\t\t\n\t\tunbindService(this);\n\t\tunregisterReceiver(receiver);\n\t}\n\n\t/**\n\t * On service connected\n\t */\n\tpublic void onServiceConnected(ComponentName name, IBinder service)\n\t{\n\t\tthis.binder = (IRCBinder) service;\n\t}\n\n\t/**\n\t * On service disconnected\n\t */\n\tpublic void onServiceDisconnected(ComponentName name)\n\t{\n\t\tthis.binder = null;\n\t}\n\n\t/**\n\t * On options menu requested\n\t */\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu)\n\t{\n    \tsuper.onCreateOptionsMenu(menu);\n    \t\n    \t// inflate from xml\n    \tMenuInflater inflater = getMenuInflater();\n    \tinflater.inflate(R.menu.server, menu);\n    \t\n    \treturn true;\n\t}\n\n\t/**\n\t * On menu item selected\n\t */\n\t@Override\n\tpublic boolean onMenuItemSelected(int featureId, MenuItem item)\n\t{\n\t\tswitch (item.getItemId()) {\n\t\t\tcase R.id.disconnect:\n\t\t\t\tbinder.getService().getConnection(serverId).quitServer();\n\t\t\t\tserver.clearChannels();\n\t\t\t\tsetResult(RESULT_OK);\n\t\t\t\tfinish();\n\t\t\t\tbreak;\n\t\t\tcase R.id.join:\n\t\t\t\tfinal Dialog dialog = new Dialog(this);\n\t\t\t\tdialog.setContentView(R.layout.channeldialog);\n\t\t\t\tdialog.setTitle(R.string.channel);\n\n\t\t\t\tButton button = (Button) dialog.findViewById(R.id.join);\n\t\t\t\tbutton.setOnClickListener(new OnClickListener() {\n\t\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\t\tString channel = ((EditText) v.getRootView().findViewById(R.id.channel)).getText().toString();\n\t\t\t\t\t\tbinder.getService().getConnection(serverId).joinChannel(channel);\n\t\t\t\t\t\tdialog.cancel();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tdialog.show();\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\t/**\n\t * Get server object assigned to this activity\n\t * \n\t * @return the server object\n\t */\n\tpublic Server getServer()\n\t{\n\t\treturn server;\n\t}\n\n\t/**\n\t * On channel message\n\t */\n\tpublic void onChannelMessage(String target)\n\t{\n\t\tLog.d(TAG, \"Message for target \" + target);\n\t\t\n\t\tMessage message = server.getChannel(target).pollMessage();\n\t\tMessageListView view = (MessageListView) deckAdapter.getItemByName(target);\n\t\t\n\t\tif (view != null) {\n\t\t\tMessageListAdapter adapter = view.getAdapter();\n\t\t\tadapter.addMessage(message);\n\t\t}\n\t\t\n\t\tif (deckAdapter.isSwitched()) {\n\t\t\tMessageListView switchedView = deckAdapter.getSwitchedView();\n\t\t\tswitchedView.getAdapter().addMessage(message);\n\t\t}\n\t}\n\n\t/**\n\t * On new channel\n\t */\n\tpublic void onNewChannel(String target)\n\t{\n\t\tLog.d(TAG, \"onNewChannel() \" + target);\n\t\t\n\t\tdeckAdapter.addItem(server.getChannel(target));\n\t}\n\n\t/**\n\t * On Channel item clicked\n\t */\n\tpublic void onItemClick(AdapterView<?> adapterView, View view, int position, long id)\n\t{\n\t\tLog.d(TAG, \"Selected channel: \" + position);\n\t\t\n\t\tChannel channel = deckAdapter.getItem(position);\n\t\tMessageListView canvas = deckAdapter.renderChannel(channel, switcher);\n\t\tcanvas.setLayoutParams(new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT));\n\t\tcanvas.setDelegateTouchEvents(false); // Do not delegate\n\t\tdeckAdapter.setSwitched(channel.getName(), canvas);\n\t\tswitcher.addView(canvas);\n\t\tswitcher.showNext();\n\t}\n\t\n\t/**\n\t * On key down\n\t * \n\t * This is glue code to call onBackPressed() which\n\t * will be automatically called by later android releases\n\t */\n\t@Override\n\tpublic boolean onKeyDown(int keyCode, KeyEvent event)\n\t{\n\t\tif (keyCode == KeyEvent.KEYCODE_BACK) {\n\t\t\tonBackPressed();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * On back key pressed\n\t */\n\tpublic void onBackPressed()\n\t{\n\t\tif (deckAdapter.isSwitched()) {\n\t\t\tswitcher.showNext();\n\t\t\tswitcher.removeView(deckAdapter.getSwitchedView());\n\t\t\t//switcher.showNext();\n\t\t\tdeckAdapter.setSwitched(null, null);\n\t\t\tLog.d(TAG, \"Back pressed\");\n\t\t} else {\n\t\t\tLog.d(TAG, \"Back pressed -> FINISH\");\n\t\t\tfinish();\n\t\t}\n\t}\n\n\t/**\n\t * On channel remove\n\t */\n\tpublic void onRemoveChannel(String target)\n\t{\n\t\t// XXX: Implement me :)\n\t}\n}\n","Method after Refactoring":"/*\n Yaaic - Yet Another Android IRC Client\n\nCopyright 2009 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.view;\n\nimport android.app.Activity;\nimport android.app.Dialog;\nimport android.content.ComponentName;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.ServiceConnection;\nimport android.os.Bundle;\nimport android.os.IBinder;\nimport android.util.Log;\nimport android.view.Display;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.View.OnClickListener;\nimport android.widget.AdapterView;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.Gallery;\nimport android.widget.ImageView;\nimport android.widget.TextView;\nimport android.widget.ViewSwitcher;\nimport android.widget.AdapterView.OnItemClickListener;\nimport android.widget.TableLayout.LayoutParams;\n\nimport org.yaaic.R;\nimport org.yaaic.Yaaic;\nimport org.yaaic.adapter.DeckAdapter;\nimport org.yaaic.adapter.MessageListAdapter;\nimport org.yaaic.irc.IRCBinder;\nimport org.yaaic.irc.IRCService;\nimport org.yaaic.listener.ChannelListener;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Server;\nimport org.yaaic.receiver.ChannelReceiver;\n\n/**\n * The server view with a scrollable list of all channels\n * \n * @author Sebastian Kaspari <sebastian@yaaic.org>\n */\npublic class ServerActivity extends Activity implements ServiceConnection, ChannelListener, OnItemClickListener\n{\n\tpublic static final String TAG = \"Yaaic/ServerActivity\";\n\t\n\tprivate int serverId;\n\tprivate Server server;\n\tprivate IRCBinder binder;\n\tprivate ChannelReceiver receiver;\n\t\n\tprivate ViewSwitcher switcher;\n\tprivate Gallery deck;\n\tprivate DeckAdapter deckAdapter;\n\t\n\t/**\n\t * On create\n\t */\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState)\n\t{\n\t\tsuper.onCreate(savedInstanceState);\n\t\t\n\t\tserverId = getIntent().getExtras().getInt(\"serverId\");\n\t\tserver = (Server) Yaaic.getInstance().getServerById(serverId);\n\t\tsetTitle(\"Yaaic - \" + server.getTitle());\n\t\t\n\t\tsetContentView(R.layout.server);\n\t\t\n\t\t((TextView) findViewById(R.id.title)).setText(server.getTitle());\n\t\t((ImageView) findViewById(R.id.status)).setImageResource(server.getStatusIcon());\n\t\t\n        Display d = getWindowManager().getDefaultDisplay();\n\n\t\tdeck = (Gallery) findViewById(R.id.deck);\n        deckAdapter = new DeckAdapter(d.getWidth(), d.getHeight());\n\t\tdeck.setAdapter(deckAdapter);\n\t\tdeck.setOnItemClickListener(this);\n\n\t\tswitcher = (ViewSwitcher) findViewById(R.id.switcher);\n\t\t\n\t\tfor (Channel channel : server.getChannels()) {\n\t\t\tonNewChannel(channel.getName());\n\t\t}\n\t}\n\t\n\t/**\n\t * On resume\n\t */\n\t@Override\n\tpublic void onResume()\n\t{\n\t\tsuper.onResume();\n\t\t\n        Intent intent = new Intent(this, IRCService.class);\n        bindService(intent, this, 0);\n        \n    \treceiver = new ChannelReceiver(server.getId(), this);\n    \tregisterReceiver(receiver, new IntentFilter(Broadcast.CHANNEL_MESSAGE));\n    \tregisterReceiver(receiver, new IntentFilter(Broadcast.CHANNEL_NEW));\n    \tregisterReceiver(receiver, new IntentFilter(Broadcast.CHANNEL_REMOVE));\n\t}\n\t\n\t/**\n\t * On Pause\n\t */\n\t@Override\n\tpublic void onPause()\n\t{\n\t\tsuper.onPause();\n\t\t\n\t\tunbindService(this);\n\t\tunregisterReceiver(receiver);\n\t}\n\n\t/**\n\t * On service connected\n\t */\n\tpublic void onServiceConnected(ComponentName name, IBinder service)\n\t{\n\t\tthis.binder = (IRCBinder) service;\n\t}\n\n\t/**\n\t * On service disconnected\n\t */\n\tpublic void onServiceDisconnected(ComponentName name)\n\t{\n\t\tthis.binder = null;\n\t}\n\n\t/**\n\t * On options menu requested\n\t */\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu)\n\t{\n    \tsuper.onCreateOptionsMenu(menu);\n    \t\n    \t// inflate from xml\n    \tMenuInflater inflater = getMenuInflater();\n    \tinflater.inflate(R.menu.server, menu);\n    \t\n    \treturn true;\n\t}\n\n\t/**\n\t * On menu item selected\n\t */\n\t@Override\n\tpublic boolean onMenuItemSelected(int featureId, MenuItem item)\n\t{\n\t\tswitch (item.getItemId()) {\n\t\t\tcase R.id.disconnect:\n\t\t\t\tbinder.getService().getConnection(serverId).quitServer();\n\t\t\t\tserver.clearChannels();\n\t\t\t\tsetResult(RESULT_OK);\n\t\t\t\tfinish();\n\t\t\t\tbreak;\n\t\t\tcase R.id.join:\n\t\t\t\tfinal Dialog dialog = new Dialog(this);\n\t\t\t\tdialog.setContentView(R.layout.channeldialog);\n\t\t\t\tdialog.setTitle(R.string.channel);\n\n\t\t\t\tButton button = (Button) dialog.findViewById(R.id.join);\n\t\t\t\tbutton.setOnClickListener(new OnClickListener() {\n\t\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\t\tString channel = ((EditText) v.getRootView().findViewById(R.id.channel)).getText().toString();\n\t\t\t\t\t\tbinder.getService().getConnection(serverId).joinChannel(channel);\n\t\t\t\t\t\tdialog.cancel();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tdialog.show();\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\t/**\n\t * Get server object assigned to this activity\n\t * \n\t * @return the server object\n\t */\n\tpublic Server getServer()\n\t{\n\t\treturn server;\n\t}\n\n\t/**\n\t * On channel message\n\t */\n\tpublic void onChannelMessage(String target)\n\t{\n\t\tLog.d(TAG, \"Message for target \" + target);\n\t\tChannel channel = server.getChannel(target);\n\t\t\n\t\twhile(channel.hasBufferedMessages()) {\n\t\t\tMessage message = channel.pollBufferedMessage();\n\t\t\tMessageListView view = (MessageListView) deckAdapter.getItemByName(target);\n\t\t\t\n\t\t\tif (view != null) {\n\t\t\t\tMessageListAdapter adapter = view.getAdapter();\n\t\t\t\tadapter.addMessage(message);\n\t\t\t}\n\t\t\t\n\t\t\tif (deckAdapter.isSwitched()) {\n\t\t\t\tMessageListView switchedView = deckAdapter.getSwitchedView();\n\t\t\t\tswitchedView.getAdapter().addMessage(message);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * On new channel\n\t */\n\tpublic void onNewChannel(String target)\n\t{\n\t\tLog.d(TAG, \"onNewChannel() \" + target);\n\t\t\n\t\tdeckAdapter.addItem(server.getChannel(target));\n\t}\n\n\t/**\n\t * On Channel item clicked\n\t */\n\tpublic void onItemClick(AdapterView<?> adapterView, View view, int position, long id)\n\t{\n\t\tLog.d(TAG, \"Selected channel: \" + position);\n\t\t\n\t\tChannel channel = deckAdapter.getItem(position);\n\t\tMessageListView canvas = deckAdapter.renderChannel(channel, switcher);\n\t\tcanvas.setLayoutParams(new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT));\n\t\tcanvas.setDelegateTouchEvents(false); // Do not delegate\n\t\tdeckAdapter.setSwitched(channel.getName(), canvas);\n\t\tswitcher.addView(canvas);\n\t\tswitcher.showNext();\n\t}\n\t\n\t/**\n\t * On key down\n\t * \n\t * This is glue code to call onBackPressed() which\n\t * will be automatically called by later android releases\n\t */\n\t@Override\n\tpublic boolean onKeyDown(int keyCode, KeyEvent event)\n\t{\n\t\tif (keyCode == KeyEvent.KEYCODE_BACK) {\n\t\t\tonBackPressed();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * On back key pressed\n\t */\n\tpublic void onBackPressed()\n\t{\n\t\tif (deckAdapter.isSwitched()) {\n\t\t\tswitcher.showNext();\n\t\t\tswitcher.removeView(deckAdapter.getSwitchedView());\n\t\t\t//switcher.showNext();\n\t\t\tdeckAdapter.setSwitched(null, null);\n\t\t\tLog.d(TAG, \"Back pressed\");\n\t\t} else {\n\t\t\tLog.d(TAG, \"Back pressed -> FINISH\");\n\t\t\tfinish();\n\t\t}\n\t}\n\n\t/**\n\t * On channel remove\n\t */\n\tpublic void onRemoveChannel(String target)\n\t{\n\t\t// XXX: Implement me :)\n\t}\n}\n","lineNo":221}
{"Smelly Sample":"/*\n Yaaic - Yet Another Android IRC Client\n\nCopyright 2009 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.irc;\n\nimport android.content.Intent;\nimport android.util.Log;\n\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\n\nimport org.yaaic.Yaaic;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.Status;\n\npublic class IRCConnection extends PircBot\n{\n\tprivate IRCService service;\n\tprivate Server server;\n\t\n\t// XXX: Print all IRC events to the debug console\n\tprivate static final boolean DEBUG_EVENTS = true;\n\tpublic static final String TAG = \"Yaaic/IRCConnection\";\n\t\n\t/**\n\t * Create a new connection\n\t * \n\t * @param service\n\t * @param serverId\n\t */\n\tpublic IRCConnection(IRCService service, int serverId)\n\t{\n\t\tthis.server = Yaaic.getInstance().getServerById(serverId);\n\t\tthis.service = service;\n\t\t\n\t\tthis.setName(\"Yaaic\");\n\t\tthis.setLogin(\"Yaaic\");\n\t\tthis.setAutoNickChange(true);\n\t\tthis.setVersion(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n\n\t/**\n\t * On connect\n\t */\n\t@Override\n\tpublic void onConnect()\n\t{\n\t\tdebug(\"Connect\", \"\");\n\t\t\n\t\tserver.setStatus(Status.CONNECTED);\n\t\t\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\t\n\t/**\n\t * On channel action\n\t */\n\t@Override\n\tprotected void onAction(String sender, String login, String hostname, String target, String action)\n\t{\n\t\tdebug(\"Action\", target + \" \" + sender + \" \" + action);\n\t\t\n\t\tserver.getChannel(target).addMessage(\"* \" + sender + \" \" + action);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Channel Info\n\t */\n\t@Override\n\tprotected void onChannelInfo(String channel, int userCount, String topic)\n\t{\n\t\tdebug(\"ChannelInfo\", channel + \" \" + userCount);\n\t}\n\n\t/**\n\t * On Deop\n\t */\n\t@Override\n\tprotected void onDeop(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Deop\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" deoped \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On DeVoice\n\t */\n\t@Override\n\tprotected void onDeVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"DeVoice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" devoiced \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Invite\n\t */\n\t@Override\n\tprotected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String target)\n\t{\n\t\tdebug(\"Invite\", target + \" \" + targetNick + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" invited \" + targetNick);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Join\n\t */\n\t@Override\n\tprotected void onJoin(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Join\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We joined a new channel\n\t\t\tserver.addChannel(new Channel(target));\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_NEW);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" joined\");\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Kick\n\t */\n\t@Override\n\tprotected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n\t{\n\t\tdebug(\"Kick\", target + \" \" + recipientNick + \"(\" + kickerNick + \")\");\n\t\t\n\t\tif (recipientNick.equals(getNick())) {\n\t\t\t// We are kicked\n\t\t\tserver.removeChannel(target);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_REMOVE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(kickerNick + \" kicked \" + recipientNick);\n\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\t\t\t\n\t\t}\n\t}\n\n\t/**\n\t * On Message\n\t */\n\t@Override\n\tprotected void onMessage(String target, String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"Message\", target + \" \" + sender + \" \" + message);\n\n\t\tserver.getChannel(target).addMessage(\"<\" + sender + \"> \" + message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Mode\n\t */\n\t@Override\n\tprotected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n\t{\n\t\tdebug(\"Mode\", target + \" \" + sourceNick + \" \" + mode);\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" sets mode \" + mode);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Nick Change\n\t */\n\t@Override\n\tprotected void onNickChange(String oldNick, String login, String hostname, String newNick)\n\t{\n\t\tdebug(\"Nick\", oldNick + \" \" + newNick);\n\t}\n\n\t/**\n\t * On Notice\n\t */\n\t@Override\n\tprotected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n\t{\n\t\tdebug(\"Notice\", sourceNick + \" \" + notice);\n\t}\n\n\t/**\n\t * On Op\n\t */\n\t@Override\n\tprotected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Op\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" oped \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Part\n\t */\n\t@Override\n\tprotected void onPart(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Part\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We pareted a channel\n\t\t\tserver.removeChannel(target);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_REMOVE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" parted\");\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Private Message\n\t */\n\t@Override\n\tprotected void onPrivateMessage(String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"PrivateMessage\", sender + \" \" + message);\n\t}\n\n\t/**\n\t * On Quit\n\t */\n\t@Override\n\tprotected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n\t{\n\t\tdebug(\"Quit\", sourceNick);\n\t}\n\n\t/**\n\t * On Topic\n\t */\n\t@Override\n\tprotected void onTopic(String target, String topic, String setBy, long date, boolean changed)\n\t{\n\t\tdebug(\"Topic\", target + \" \" + setBy + \" \" + topic);\n\t\t\n\t\tif (changed) {\n\t\t\tserver.getChannel(target).addMessage(setBy + \" sets topic: \" + topic);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(\"Topic: \" + topic);\n\t\t}\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On User List\n\t */\n\t@Override\n\tprotected void onUserList(String channel, User[] users)\n\t{\n\t\tdebug(\"UserList\", channel + \" (\" + users.length + \")\");\n\t}\n\n\t/**\n\t * On Voice\n\t */\n\t@Override\n\tprotected void onVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Voice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" voiced \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\t\n\t/**\n\t * On disconnect\n\t */\n\t@Override\n\tpublic void onDisconnect()\n\t{\n\t\tserver.setStatus(Status.DISCONNECTED);\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\n\t/**\n\t * Print an event to the debug console \n\t */\n\tprivate void debug(String event, String params)\n\t{\n\t\tif (DEBUG_EVENTS) {\n\t\t\tLog.d(TAG, \"(\" + server.getTitle() + \") [\" + event + \"]: \" + params);\n\t\t}\n\t}\n\t\n\t/**\n\t * Quits from the IRC server with default reason.\n\t */\n\t@Override\n\tpublic void quitServer()\n\t{\n\t\tquitServer(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n}\n","Method after Refactoring":"/*\n Yaaic - Yet Another Android IRC Client\n\nCopyright 2009 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.irc;\n\nimport android.content.Intent;\nimport android.util.Log;\n\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\n\nimport org.yaaic.Yaaic;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.Status;\n\npublic class IRCConnection extends PircBot\n{\n\tprivate IRCService service;\n\tprivate Server server;\n\t\n\t// XXX: Print all IRC events to the debug console\n\tprivate static final boolean DEBUG_EVENTS = true;\n\tpublic static final String TAG = \"Yaaic/IRCConnection\";\n\t\n\t/**\n\t * Create a new connection\n\t * \n\t * @param service\n\t * @param serverId\n\t */\n\tpublic IRCConnection(IRCService service, int serverId)\n\t{\n\t\tthis.server = Yaaic.getInstance().getServerById(serverId);\n\t\tthis.service = service;\n\t\t\n\t\tthis.setName(\"Yaaic\");\n\t\tthis.setLogin(\"Yaaic\");\n\t\tthis.setAutoNickChange(true);\n\t\tthis.setVersion(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n\n\t/**\n\t * On connect\n\t */\n\t@Override\n\tpublic void onConnect()\n\t{\n\t\tdebug(\"Connect\", \"\");\n\t\t\n\t\tserver.setStatus(Status.CONNECTED);\n\t\t\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\t\n\t/**\n\t * On channel action\n\t */\n\t@Override\n\tprotected void onAction(String sender, String login, String hostname, String target, String action)\n\t{\n\t\tdebug(\"Action\", target + \" \" + sender + \" \" + action);\n\t\t\n\t\tMessage message = new Message(sender + \" \" + action);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Channel Info\n\t */\n\t@Override\n\tprotected void onChannelInfo(String channel, int userCount, String topic)\n\t{\n\t\tdebug(\"ChannelInfo\", channel + \" \" + userCount);\n\t}\n\n\t/**\n\t * On Deop\n\t */\n\t@Override\n\tprotected void onDeop(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Deop\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" deoped \" + recipient);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On DeVoice\n\t */\n\t@Override\n\tprotected void onDeVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"DeVoice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" devoiced \" + recipient);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Invite\n\t */\n\t@Override\n\tprotected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String target)\n\t{\n\t\tdebug(\"Invite\", target + \" \" + targetNick + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" invited \" + targetNick);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Join\n\t */\n\t@Override\n\tprotected void onJoin(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Join\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We joined a new channel\n\t\t\tserver.addChannel(new Channel(target));\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_NEW);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tMessage message = new Message(sender + \" joined\");\n\t\t\tserver.getChannel(target).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Kick\n\t */\n\t@Override\n\tprotected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n\t{\n\t\tdebug(\"Kick\", target + \" \" + recipientNick + \"(\" + kickerNick + \")\");\n\t\t\n\t\tif (recipientNick.equals(getNick())) {\n\t\t\t// We are kicked\n\t\t\tserver.removeChannel(target);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_REMOVE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tMessage message = new Message(kickerNick + \" kicked \" + recipientNick);\n\t\t\tserver.getChannel(target).addMessage(message);\n\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\t\t\t\n\t\t}\n\t}\n\n\t/**\n\t * On Message\n\t */\n\t@Override\n\tprotected void onMessage(String target, String sender, String login, String hostname, String text)\n\t{\n\t\tdebug(\"Message\", target + \" \" + sender + \" \" + text);\n\n\t\tMessage message = new Message(\"<\" + sender + \"> \" + text);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Mode\n\t */\n\t@Override\n\tprotected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n\t{\n\t\tdebug(\"Mode\", target + \" \" + sourceNick + \" \" + mode);\n\t\t\n\t\tMessage message = new Message(sourceNick + \" sets mode \" + mode);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Nick Change\n\t */\n\t@Override\n\tprotected void onNickChange(String oldNick, String login, String hostname, String newNick)\n\t{\n\t\tdebug(\"Nick\", oldNick + \" \" + newNick);\n\t\t\n\t\t// XXX: Add message to all channels where oldNick / newNick is present\n\t}\n\n\t/**\n\t * On Notice\n\t */\n\t@Override\n\tprotected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n\t{\n\t\tdebug(\"Notice\", sourceNick + \" \" + notice);\n\n\t\t// XXX: Where should notices be shown? Current window? All windows? Server window?\n\t}\n\n\t/**\n\t * On Op\n\t */\n\t@Override\n\tprotected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Op\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" oped \" + recipient);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Part\n\t */\n\t@Override\n\tprotected void onPart(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Part\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We pareted a channel\n\t\t\tserver.removeChannel(target);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_REMOVE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tMessage message = new Message(sender + \" parted\");\n\t\t\tserver.getChannel(target).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Private Message\n\t */\n\t@Override\n\tprotected void onPrivateMessage(String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"PrivateMessage\", sender + \" \" + message);\n\t}\n\n\t/**\n\t * On Quit\n\t */\n\t@Override\n\tprotected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n\t{\n\t\tdebug(\"Quit\", sourceNick);\n\t}\n\n\t/**\n\t * On Topic\n\t */\n\t@Override\n\tprotected void onTopic(String target, String topic, String setBy, long date, boolean changed)\n\t{\n\t\tdebug(\"Topic\", target + \" \" + setBy + \" \" + topic);\n\t\t\n\t\tif (changed) {\n\t\t\tMessage message = new Message(setBy + \" sets topic: \" + topic);\n\t\t\tserver.getChannel(target).addMessage(message);\n\t\t} else {\n\t\t\tMessage message = new Message(\"Topic: \" + topic);\n\t\t\tserver.getChannel(target).addMessage(message);\n\t\t}\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On User List\n\t */\n\t@Override\n\tprotected void onUserList(String channel, User[] users)\n\t{\n\t\tdebug(\"UserList\", channel + \" (\" + users.length + \")\");\n\t\t\n\t\t// XXX: Store user list somewhere and keep it updated or just broadcast some event?\n\t}\n\n\t/**\n\t * On Voice\n\t */\n\t@Override\n\tprotected void onVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Voice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" voiced \" + recipient);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\t\n\t/**\n\t * On disconnect\n\t */\n\t@Override\n\tpublic void onDisconnect()\n\t{\n\t\tserver.setStatus(Status.DISCONNECTED);\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\n\t/**\n\t * Print an event to the debug console \n\t */\n\tprivate void debug(String event, String params)\n\t{\n\t\tif (DEBUG_EVENTS) {\n\t\t\tLog.d(TAG, \"(\" + server.getTitle() + \") [\" + event + \"]: \" + params);\n\t\t}\n\t}\n\t\n\t/**\n\t * Quits from the IRC server with default reason.\n\t */\n\t@Override\n\tpublic void quitServer()\n\t{\n\t\tquitServer(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n}\n","lineNo":109}
{"Smelly Sample":"/*\n Yaaic - Yet Another Android IRC Client\n\nCopyright 2009 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.irc;\n\nimport android.content.Intent;\nimport android.util.Log;\n\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\n\nimport org.yaaic.Yaaic;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.Status;\n\npublic class IRCConnection extends PircBot\n{\n\tprivate IRCService service;\n\tprivate Server server;\n\t\n\t// XXX: Print all IRC events to the debug console\n\tprivate static final boolean DEBUG_EVENTS = true;\n\tpublic static final String TAG = \"Yaaic/IRCConnection\";\n\t\n\t/**\n\t * Create a new connection\n\t * \n\t * @param service\n\t * @param serverId\n\t */\n\tpublic IRCConnection(IRCService service, int serverId)\n\t{\n\t\tthis.server = Yaaic.getInstance().getServerById(serverId);\n\t\tthis.service = service;\n\t\t\n\t\tthis.setName(\"Yaaic\");\n\t\tthis.setLogin(\"Yaaic\");\n\t\tthis.setAutoNickChange(true);\n\t\tthis.setVersion(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n\n\t/**\n\t * On connect\n\t */\n\t@Override\n\tpublic void onConnect()\n\t{\n\t\tdebug(\"Connect\", \"\");\n\t\t\n\t\tserver.setStatus(Status.CONNECTED);\n\t\t\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\t\n\t/**\n\t * On channel action\n\t */\n\t@Override\n\tprotected void onAction(String sender, String login, String hostname, String target, String action)\n\t{\n\t\tdebug(\"Action\", target + \" \" + sender + \" \" + action);\n\t\t\n\t\tserver.getChannel(target).addMessage(\"* \" + sender + \" \" + action);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Channel Info\n\t */\n\t@Override\n\tprotected void onChannelInfo(String channel, int userCount, String topic)\n\t{\n\t\tdebug(\"ChannelInfo\", channel + \" \" + userCount);\n\t}\n\n\t/**\n\t * On Deop\n\t */\n\t@Override\n\tprotected void onDeop(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Deop\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" deoped \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On DeVoice\n\t */\n\t@Override\n\tprotected void onDeVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"DeVoice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" devoiced \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Invite\n\t */\n\t@Override\n\tprotected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String target)\n\t{\n\t\tdebug(\"Invite\", target + \" \" + targetNick + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" invited \" + targetNick);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Join\n\t */\n\t@Override\n\tprotected void onJoin(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Join\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We joined a new channel\n\t\t\tserver.addChannel(new Channel(target));\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_NEW);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" joined\");\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Kick\n\t */\n\t@Override\n\tprotected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n\t{\n\t\tdebug(\"Kick\", target + \" \" + recipientNick + \"(\" + kickerNick + \")\");\n\t\t\n\t\tif (recipientNick.equals(getNick())) {\n\t\t\t// We are kicked\n\t\t\tserver.removeChannel(target);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_REMOVE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(kickerNick + \" kicked \" + recipientNick);\n\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\t\t\t\n\t\t}\n\t}\n\n\t/**\n\t * On Message\n\t */\n\t@Override\n\tprotected void onMessage(String target, String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"Message\", target + \" \" + sender + \" \" + message);\n\n\t\tserver.getChannel(target).addMessage(\"<\" + sender + \"> \" + message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Mode\n\t */\n\t@Override\n\tprotected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n\t{\n\t\tdebug(\"Mode\", target + \" \" + sourceNick + \" \" + mode);\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" sets mode \" + mode);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Nick Change\n\t */\n\t@Override\n\tprotected void onNickChange(String oldNick, String login, String hostname, String newNick)\n\t{\n\t\tdebug(\"Nick\", oldNick + \" \" + newNick);\n\t}\n\n\t/**\n\t * On Notice\n\t */\n\t@Override\n\tprotected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n\t{\n\t\tdebug(\"Notice\", sourceNick + \" \" + notice);\n\t}\n\n\t/**\n\t * On Op\n\t */\n\t@Override\n\tprotected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Op\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" oped \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Part\n\t */\n\t@Override\n\tprotected void onPart(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Part\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We pareted a channel\n\t\t\tserver.removeChannel(target);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_REMOVE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" parted\");\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Private Message\n\t */\n\t@Override\n\tprotected void onPrivateMessage(String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"PrivateMessage\", sender + \" \" + message);\n\t}\n\n\t/**\n\t * On Quit\n\t */\n\t@Override\n\tprotected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n\t{\n\t\tdebug(\"Quit\", sourceNick);\n\t}\n\n\t/**\n\t * On Topic\n\t */\n\t@Override\n\tprotected void onTopic(String target, String topic, String setBy, long date, boolean changed)\n\t{\n\t\tdebug(\"Topic\", target + \" \" + setBy + \" \" + topic);\n\t\t\n\t\tif (changed) {\n\t\t\tserver.getChannel(target).addMessage(setBy + \" sets topic: \" + topic);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(\"Topic: \" + topic);\n\t\t}\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On User List\n\t */\n\t@Override\n\tprotected void onUserList(String channel, User[] users)\n\t{\n\t\tdebug(\"UserList\", channel + \" (\" + users.length + \")\");\n\t}\n\n\t/**\n\t * On Voice\n\t */\n\t@Override\n\tprotected void onVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Voice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" voiced \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\t\n\t/**\n\t * On disconnect\n\t */\n\t@Override\n\tpublic void onDisconnect()\n\t{\n\t\tserver.setStatus(Status.DISCONNECTED);\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\n\t/**\n\t * Print an event to the debug console \n\t */\n\tprivate void debug(String event, String params)\n\t{\n\t\tif (DEBUG_EVENTS) {\n\t\t\tLog.d(TAG, \"(\" + server.getTitle() + \") [\" + event + \"]: \" + params);\n\t\t}\n\t}\n\t\n\t/**\n\t * Quits from the IRC server with default reason.\n\t */\n\t@Override\n\tpublic void quitServer()\n\t{\n\t\tquitServer(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n}\n","Method after Refactoring":"/*\n Yaaic - Yet Another Android IRC Client\n\nCopyright 2009 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.irc;\n\nimport android.content.Intent;\nimport android.util.Log;\n\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\n\nimport org.yaaic.Yaaic;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.Status;\n\npublic class IRCConnection extends PircBot\n{\n\tprivate IRCService service;\n\tprivate Server server;\n\t\n\t// XXX: Print all IRC events to the debug console\n\tprivate static final boolean DEBUG_EVENTS = true;\n\tpublic static final String TAG = \"Yaaic/IRCConnection\";\n\t\n\t/**\n\t * Create a new connection\n\t * \n\t * @param service\n\t * @param serverId\n\t */\n\tpublic IRCConnection(IRCService service, int serverId)\n\t{\n\t\tthis.server = Yaaic.getInstance().getServerById(serverId);\n\t\tthis.service = service;\n\t\t\n\t\tthis.setName(\"Yaaic\");\n\t\tthis.setLogin(\"Yaaic\");\n\t\tthis.setAutoNickChange(true);\n\t\tthis.setVersion(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n\n\t/**\n\t * On connect\n\t */\n\t@Override\n\tpublic void onConnect()\n\t{\n\t\tdebug(\"Connect\", \"\");\n\t\t\n\t\tserver.setStatus(Status.CONNECTED);\n\t\t\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\t\n\t/**\n\t * On channel action\n\t */\n\t@Override\n\tprotected void onAction(String sender, String login, String hostname, String target, String action)\n\t{\n\t\tdebug(\"Action\", target + \" \" + sender + \" \" + action);\n\t\t\n\t\tMessage message = new Message(sender + \" \" + action);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Channel Info\n\t */\n\t@Override\n\tprotected void onChannelInfo(String channel, int userCount, String topic)\n\t{\n\t\tdebug(\"ChannelInfo\", channel + \" \" + userCount);\n\t}\n\n\t/**\n\t * On Deop\n\t */\n\t@Override\n\tprotected void onDeop(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Deop\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" deoped \" + recipient);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On DeVoice\n\t */\n\t@Override\n\tprotected void onDeVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"DeVoice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" devoiced \" + recipient);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Invite\n\t */\n\t@Override\n\tprotected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String target)\n\t{\n\t\tdebug(\"Invite\", target + \" \" + targetNick + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" invited \" + targetNick);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Join\n\t */\n\t@Override\n\tprotected void onJoin(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Join\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We joined a new channel\n\t\t\tserver.addChannel(new Channel(target));\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_NEW);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tMessage message = new Message(sender + \" joined\");\n\t\t\tserver.getChannel(target).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Kick\n\t */\n\t@Override\n\tprotected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n\t{\n\t\tdebug(\"Kick\", target + \" \" + recipientNick + \"(\" + kickerNick + \")\");\n\t\t\n\t\tif (recipientNick.equals(getNick())) {\n\t\t\t// We are kicked\n\t\t\tserver.removeChannel(target);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_REMOVE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tMessage message = new Message(kickerNick + \" kicked \" + recipientNick);\n\t\t\tserver.getChannel(target).addMessage(message);\n\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\t\t\t\n\t\t}\n\t}\n\n\t/**\n\t * On Message\n\t */\n\t@Override\n\tprotected void onMessage(String target, String sender, String login, String hostname, String text)\n\t{\n\t\tdebug(\"Message\", target + \" \" + sender + \" \" + text);\n\n\t\tMessage message = new Message(\"<\" + sender + \"> \" + text);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Mode\n\t */\n\t@Override\n\tprotected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n\t{\n\t\tdebug(\"Mode\", target + \" \" + sourceNick + \" \" + mode);\n\t\t\n\t\tMessage message = new Message(sourceNick + \" sets mode \" + mode);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Nick Change\n\t */\n\t@Override\n\tprotected void onNickChange(String oldNick, String login, String hostname, String newNick)\n\t{\n\t\tdebug(\"Nick\", oldNick + \" \" + newNick);\n\t\t\n\t\t// XXX: Add message to all channels where oldNick / newNick is present\n\t}\n\n\t/**\n\t * On Notice\n\t */\n\t@Override\n\tprotected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n\t{\n\t\tdebug(\"Notice\", sourceNick + \" \" + notice);\n\n\t\t// XXX: Where should notices be shown? Current window? All windows? Server window?\n\t}\n\n\t/**\n\t * On Op\n\t */\n\t@Override\n\tprotected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Op\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" oped \" + recipient);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Part\n\t */\n\t@Override\n\tprotected void onPart(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Part\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We pareted a channel\n\t\t\tserver.removeChannel(target);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_REMOVE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tMessage message = new Message(sender + \" parted\");\n\t\t\tserver.getChannel(target).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Private Message\n\t */\n\t@Override\n\tprotected void onPrivateMessage(String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"PrivateMessage\", sender + \" \" + message);\n\t}\n\n\t/**\n\t * On Quit\n\t */\n\t@Override\n\tprotected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n\t{\n\t\tdebug(\"Quit\", sourceNick);\n\t}\n\n\t/**\n\t * On Topic\n\t */\n\t@Override\n\tprotected void onTopic(String target, String topic, String setBy, long date, boolean changed)\n\t{\n\t\tdebug(\"Topic\", target + \" \" + setBy + \" \" + topic);\n\t\t\n\t\tif (changed) {\n\t\t\tMessage message = new Message(setBy + \" sets topic: \" + topic);\n\t\t\tserver.getChannel(target).addMessage(message);\n\t\t} else {\n\t\t\tMessage message = new Message(\"Topic: \" + topic);\n\t\t\tserver.getChannel(target).addMessage(message);\n\t\t}\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On User List\n\t */\n\t@Override\n\tprotected void onUserList(String channel, User[] users)\n\t{\n\t\tdebug(\"UserList\", channel + \" (\" + users.length + \")\");\n\t\t\n\t\t// XXX: Store user list somewhere and keep it updated or just broadcast some event?\n\t}\n\n\t/**\n\t * On Voice\n\t */\n\t@Override\n\tprotected void onVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Voice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" voiced \" + recipient);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\t\n\t/**\n\t * On disconnect\n\t */\n\t@Override\n\tpublic void onDisconnect()\n\t{\n\t\tserver.setStatus(Status.DISCONNECTED);\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\n\t/**\n\t * Print an event to the debug console \n\t */\n\tprivate void debug(String event, String params)\n\t{\n\t\tif (DEBUG_EVENTS) {\n\t\t\tLog.d(TAG, \"(\" + server.getTitle() + \") [\" + event + \"]: \" + params);\n\t\t}\n\t}\n\t\n\t/**\n\t * Quits from the IRC server with default reason.\n\t */\n\t@Override\n\tpublic void quitServer()\n\t{\n\t\tquitServer(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n}\n","lineNo":126}
{"Smelly Sample":"/*\n Yaaic - Yet Another Android IRC Client\n\nCopyright 2009 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.irc;\n\nimport android.content.Intent;\nimport android.util.Log;\n\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\n\nimport org.yaaic.Yaaic;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.Status;\n\npublic class IRCConnection extends PircBot\n{\n\tprivate IRCService service;\n\tprivate Server server;\n\t\n\t// XXX: Print all IRC events to the debug console\n\tprivate static final boolean DEBUG_EVENTS = true;\n\tpublic static final String TAG = \"Yaaic/IRCConnection\";\n\t\n\t/**\n\t * Create a new connection\n\t * \n\t * @param service\n\t * @param serverId\n\t */\n\tpublic IRCConnection(IRCService service, int serverId)\n\t{\n\t\tthis.server = Yaaic.getInstance().getServerById(serverId);\n\t\tthis.service = service;\n\t\t\n\t\tthis.setName(\"Yaaic\");\n\t\tthis.setLogin(\"Yaaic\");\n\t\tthis.setAutoNickChange(true);\n\t\tthis.setVersion(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n\n\t/**\n\t * On connect\n\t */\n\t@Override\n\tpublic void onConnect()\n\t{\n\t\tdebug(\"Connect\", \"\");\n\t\t\n\t\tserver.setStatus(Status.CONNECTED);\n\t\t\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\t\n\t/**\n\t * On channel action\n\t */\n\t@Override\n\tprotected void onAction(String sender, String login, String hostname, String target, String action)\n\t{\n\t\tdebug(\"Action\", target + \" \" + sender + \" \" + action);\n\t\t\n\t\tserver.getChannel(target).addMessage(\"* \" + sender + \" \" + action);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Channel Info\n\t */\n\t@Override\n\tprotected void onChannelInfo(String channel, int userCount, String topic)\n\t{\n\t\tdebug(\"ChannelInfo\", channel + \" \" + userCount);\n\t}\n\n\t/**\n\t * On Deop\n\t */\n\t@Override\n\tprotected void onDeop(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Deop\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" deoped \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On DeVoice\n\t */\n\t@Override\n\tprotected void onDeVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"DeVoice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" devoiced \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Invite\n\t */\n\t@Override\n\tprotected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String target)\n\t{\n\t\tdebug(\"Invite\", target + \" \" + targetNick + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" invited \" + targetNick);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Join\n\t */\n\t@Override\n\tprotected void onJoin(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Join\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We joined a new channel\n\t\t\tserver.addChannel(new Channel(target));\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_NEW);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" joined\");\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Kick\n\t */\n\t@Override\n\tprotected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n\t{\n\t\tdebug(\"Kick\", target + \" \" + recipientNick + \"(\" + kickerNick + \")\");\n\t\t\n\t\tif (recipientNick.equals(getNick())) {\n\t\t\t// We are kicked\n\t\t\tserver.removeChannel(target);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_REMOVE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(kickerNick + \" kicked \" + recipientNick);\n\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\t\t\t\n\t\t}\n\t}\n\n\t/**\n\t * On Message\n\t */\n\t@Override\n\tprotected void onMessage(String target, String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"Message\", target + \" \" + sender + \" \" + message);\n\n\t\tserver.getChannel(target).addMessage(\"<\" + sender + \"> \" + message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Mode\n\t */\n\t@Override\n\tprotected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n\t{\n\t\tdebug(\"Mode\", target + \" \" + sourceNick + \" \" + mode);\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" sets mode \" + mode);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Nick Change\n\t */\n\t@Override\n\tprotected void onNickChange(String oldNick, String login, String hostname, String newNick)\n\t{\n\t\tdebug(\"Nick\", oldNick + \" \" + newNick);\n\t}\n\n\t/**\n\t * On Notice\n\t */\n\t@Override\n\tprotected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n\t{\n\t\tdebug(\"Notice\", sourceNick + \" \" + notice);\n\t}\n\n\t/**\n\t * On Op\n\t */\n\t@Override\n\tprotected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Op\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" oped \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Part\n\t */\n\t@Override\n\tprotected void onPart(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Part\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We pareted a channel\n\t\t\tserver.removeChannel(target);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_REMOVE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" parted\");\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Private Message\n\t */\n\t@Override\n\tprotected void onPrivateMessage(String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"PrivateMessage\", sender + \" \" + message);\n\t}\n\n\t/**\n\t * On Quit\n\t */\n\t@Override\n\tprotected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n\t{\n\t\tdebug(\"Quit\", sourceNick);\n\t}\n\n\t/**\n\t * On Topic\n\t */\n\t@Override\n\tprotected void onTopic(String target, String topic, String setBy, long date, boolean changed)\n\t{\n\t\tdebug(\"Topic\", target + \" \" + setBy + \" \" + topic);\n\t\t\n\t\tif (changed) {\n\t\t\tserver.getChannel(target).addMessage(setBy + \" sets topic: \" + topic);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(\"Topic: \" + topic);\n\t\t}\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On User List\n\t */\n\t@Override\n\tprotected void onUserList(String channel, User[] users)\n\t{\n\t\tdebug(\"UserList\", channel + \" (\" + users.length + \")\");\n\t}\n\n\t/**\n\t * On Voice\n\t */\n\t@Override\n\tprotected void onVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Voice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" voiced \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\t\n\t/**\n\t * On disconnect\n\t */\n\t@Override\n\tpublic void onDisconnect()\n\t{\n\t\tserver.setStatus(Status.DISCONNECTED);\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\n\t/**\n\t * Print an event to the debug console \n\t */\n\tprivate void debug(String event, String params)\n\t{\n\t\tif (DEBUG_EVENTS) {\n\t\t\tLog.d(TAG, \"(\" + server.getTitle() + \") [\" + event + \"]: \" + params);\n\t\t}\n\t}\n\t\n\t/**\n\t * Quits from the IRC server with default reason.\n\t */\n\t@Override\n\tpublic void quitServer()\n\t{\n\t\tquitServer(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n}\n","Method after Refactoring":"/*\n Yaaic - Yet Another Android IRC Client\n\nCopyright 2009 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.irc;\n\nimport android.content.Intent;\nimport android.util.Log;\n\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\n\nimport org.yaaic.Yaaic;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.Status;\n\npublic class IRCConnection extends PircBot\n{\n\tprivate IRCService service;\n\tprivate Server server;\n\t\n\t// XXX: Print all IRC events to the debug console\n\tprivate static final boolean DEBUG_EVENTS = true;\n\tpublic static final String TAG = \"Yaaic/IRCConnection\";\n\t\n\t/**\n\t * Create a new connection\n\t * \n\t * @param service\n\t * @param serverId\n\t */\n\tpublic IRCConnection(IRCService service, int serverId)\n\t{\n\t\tthis.server = Yaaic.getInstance().getServerById(serverId);\n\t\tthis.service = service;\n\t\t\n\t\tthis.setName(\"Yaaic\");\n\t\tthis.setLogin(\"Yaaic\");\n\t\tthis.setAutoNickChange(true);\n\t\tthis.setVersion(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n\n\t/**\n\t * On connect\n\t */\n\t@Override\n\tpublic void onConnect()\n\t{\n\t\tdebug(\"Connect\", \"\");\n\t\t\n\t\tserver.setStatus(Status.CONNECTED);\n\t\t\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\t\n\t/**\n\t * On channel action\n\t */\n\t@Override\n\tprotected void onAction(String sender, String login, String hostname, String target, String action)\n\t{\n\t\tdebug(\"Action\", target + \" \" + sender + \" \" + action);\n\t\t\n\t\tMessage message = new Message(sender + \" \" + action);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Channel Info\n\t */\n\t@Override\n\tprotected void onChannelInfo(String channel, int userCount, String topic)\n\t{\n\t\tdebug(\"ChannelInfo\", channel + \" \" + userCount);\n\t}\n\n\t/**\n\t * On Deop\n\t */\n\t@Override\n\tprotected void onDeop(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Deop\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" deoped \" + recipient);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On DeVoice\n\t */\n\t@Override\n\tprotected void onDeVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"DeVoice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" devoiced \" + recipient);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Invite\n\t */\n\t@Override\n\tprotected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String target)\n\t{\n\t\tdebug(\"Invite\", target + \" \" + targetNick + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" invited \" + targetNick);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Join\n\t */\n\t@Override\n\tprotected void onJoin(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Join\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We joined a new channel\n\t\t\tserver.addChannel(new Channel(target));\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_NEW);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tMessage message = new Message(sender + \" joined\");\n\t\t\tserver.getChannel(target).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Kick\n\t */\n\t@Override\n\tprotected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n\t{\n\t\tdebug(\"Kick\", target + \" \" + recipientNick + \"(\" + kickerNick + \")\");\n\t\t\n\t\tif (recipientNick.equals(getNick())) {\n\t\t\t// We are kicked\n\t\t\tserver.removeChannel(target);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_REMOVE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tMessage message = new Message(kickerNick + \" kicked \" + recipientNick);\n\t\t\tserver.getChannel(target).addMessage(message);\n\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\t\t\t\n\t\t}\n\t}\n\n\t/**\n\t * On Message\n\t */\n\t@Override\n\tprotected void onMessage(String target, String sender, String login, String hostname, String text)\n\t{\n\t\tdebug(\"Message\", target + \" \" + sender + \" \" + text);\n\n\t\tMessage message = new Message(\"<\" + sender + \"> \" + text);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Mode\n\t */\n\t@Override\n\tprotected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n\t{\n\t\tdebug(\"Mode\", target + \" \" + sourceNick + \" \" + mode);\n\t\t\n\t\tMessage message = new Message(sourceNick + \" sets mode \" + mode);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Nick Change\n\t */\n\t@Override\n\tprotected void onNickChange(String oldNick, String login, String hostname, String newNick)\n\t{\n\t\tdebug(\"Nick\", oldNick + \" \" + newNick);\n\t\t\n\t\t// XXX: Add message to all channels where oldNick / newNick is present\n\t}\n\n\t/**\n\t * On Notice\n\t */\n\t@Override\n\tprotected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n\t{\n\t\tdebug(\"Notice\", sourceNick + \" \" + notice);\n\n\t\t// XXX: Where should notices be shown? Current window? All windows? Server window?\n\t}\n\n\t/**\n\t * On Op\n\t */\n\t@Override\n\tprotected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Op\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" oped \" + recipient);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Part\n\t */\n\t@Override\n\tprotected void onPart(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Part\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We pareted a channel\n\t\t\tserver.removeChannel(target);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_REMOVE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tMessage message = new Message(sender + \" parted\");\n\t\t\tserver.getChannel(target).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Private Message\n\t */\n\t@Override\n\tprotected void onPrivateMessage(String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"PrivateMessage\", sender + \" \" + message);\n\t}\n\n\t/**\n\t * On Quit\n\t */\n\t@Override\n\tprotected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n\t{\n\t\tdebug(\"Quit\", sourceNick);\n\t}\n\n\t/**\n\t * On Topic\n\t */\n\t@Override\n\tprotected void onTopic(String target, String topic, String setBy, long date, boolean changed)\n\t{\n\t\tdebug(\"Topic\", target + \" \" + setBy + \" \" + topic);\n\t\t\n\t\tif (changed) {\n\t\t\tMessage message = new Message(setBy + \" sets topic: \" + topic);\n\t\t\tserver.getChannel(target).addMessage(message);\n\t\t} else {\n\t\t\tMessage message = new Message(\"Topic: \" + topic);\n\t\t\tserver.getChannel(target).addMessage(message);\n\t\t}\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On User List\n\t */\n\t@Override\n\tprotected void onUserList(String channel, User[] users)\n\t{\n\t\tdebug(\"UserList\", channel + \" (\" + users.length + \")\");\n\t\t\n\t\t// XXX: Store user list somewhere and keep it updated or just broadcast some event?\n\t}\n\n\t/**\n\t * On Voice\n\t */\n\t@Override\n\tprotected void onVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Voice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" voiced \" + recipient);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\t\n\t/**\n\t * On disconnect\n\t */\n\t@Override\n\tpublic void onDisconnect()\n\t{\n\t\tserver.setStatus(Status.DISCONNECTED);\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\n\t/**\n\t * Print an event to the debug console \n\t */\n\tprivate void debug(String event, String params)\n\t{\n\t\tif (DEBUG_EVENTS) {\n\t\t\tLog.d(TAG, \"(\" + server.getTitle() + \") [\" + event + \"]: \" + params);\n\t\t}\n\t}\n\t\n\t/**\n\t * Quits from the IRC server with default reason.\n\t */\n\t@Override\n\tpublic void quitServer()\n\t{\n\t\tquitServer(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n}\n","lineNo":143}
{"Smelly Sample":"/*\n Yaaic - Yet Another Android IRC Client\n\nCopyright 2009 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.irc;\n\nimport android.content.Intent;\nimport android.util.Log;\n\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\n\nimport org.yaaic.Yaaic;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.Status;\n\npublic class IRCConnection extends PircBot\n{\n\tprivate IRCService service;\n\tprivate Server server;\n\t\n\t// XXX: Print all IRC events to the debug console\n\tprivate static final boolean DEBUG_EVENTS = true;\n\tpublic static final String TAG = \"Yaaic/IRCConnection\";\n\t\n\t/**\n\t * Create a new connection\n\t * \n\t * @param service\n\t * @param serverId\n\t */\n\tpublic IRCConnection(IRCService service, int serverId)\n\t{\n\t\tthis.server = Yaaic.getInstance().getServerById(serverId);\n\t\tthis.service = service;\n\t\t\n\t\tthis.setName(\"Yaaic\");\n\t\tthis.setLogin(\"Yaaic\");\n\t\tthis.setAutoNickChange(true);\n\t\tthis.setVersion(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n\n\t/**\n\t * On connect\n\t */\n\t@Override\n\tpublic void onConnect()\n\t{\n\t\tdebug(\"Connect\", \"\");\n\t\t\n\t\tserver.setStatus(Status.CONNECTED);\n\t\t\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\t\n\t/**\n\t * On channel action\n\t */\n\t@Override\n\tprotected void onAction(String sender, String login, String hostname, String target, String action)\n\t{\n\t\tdebug(\"Action\", target + \" \" + sender + \" \" + action);\n\t\t\n\t\tserver.getChannel(target).addMessage(\"* \" + sender + \" \" + action);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Channel Info\n\t */\n\t@Override\n\tprotected void onChannelInfo(String channel, int userCount, String topic)\n\t{\n\t\tdebug(\"ChannelInfo\", channel + \" \" + userCount);\n\t}\n\n\t/**\n\t * On Deop\n\t */\n\t@Override\n\tprotected void onDeop(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Deop\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" deoped \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On DeVoice\n\t */\n\t@Override\n\tprotected void onDeVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"DeVoice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" devoiced \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Invite\n\t */\n\t@Override\n\tprotected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String target)\n\t{\n\t\tdebug(\"Invite\", target + \" \" + targetNick + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" invited \" + targetNick);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Join\n\t */\n\t@Override\n\tprotected void onJoin(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Join\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We joined a new channel\n\t\t\tserver.addChannel(new Channel(target));\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_NEW);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" joined\");\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Kick\n\t */\n\t@Override\n\tprotected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n\t{\n\t\tdebug(\"Kick\", target + \" \" + recipientNick + \"(\" + kickerNick + \")\");\n\t\t\n\t\tif (recipientNick.equals(getNick())) {\n\t\t\t// We are kicked\n\t\t\tserver.removeChannel(target);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_REMOVE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(kickerNick + \" kicked \" + recipientNick);\n\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\t\t\t\n\t\t}\n\t}\n\n\t/**\n\t * On Message\n\t */\n\t@Override\n\tprotected void onMessage(String target, String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"Message\", target + \" \" + sender + \" \" + message);\n\n\t\tserver.getChannel(target).addMessage(\"<\" + sender + \"> \" + message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Mode\n\t */\n\t@Override\n\tprotected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n\t{\n\t\tdebug(\"Mode\", target + \" \" + sourceNick + \" \" + mode);\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" sets mode \" + mode);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Nick Change\n\t */\n\t@Override\n\tprotected void onNickChange(String oldNick, String login, String hostname, String newNick)\n\t{\n\t\tdebug(\"Nick\", oldNick + \" \" + newNick);\n\t}\n\n\t/**\n\t * On Notice\n\t */\n\t@Override\n\tprotected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n\t{\n\t\tdebug(\"Notice\", sourceNick + \" \" + notice);\n\t}\n\n\t/**\n\t * On Op\n\t */\n\t@Override\n\tprotected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Op\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" oped \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Part\n\t */\n\t@Override\n\tprotected void onPart(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Part\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We pareted a channel\n\t\t\tserver.removeChannel(target);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_REMOVE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" parted\");\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Private Message\n\t */\n\t@Override\n\tprotected void onPrivateMessage(String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"PrivateMessage\", sender + \" \" + message);\n\t}\n\n\t/**\n\t * On Quit\n\t */\n\t@Override\n\tprotected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n\t{\n\t\tdebug(\"Quit\", sourceNick);\n\t}\n\n\t/**\n\t * On Topic\n\t */\n\t@Override\n\tprotected void onTopic(String target, String topic, String setBy, long date, boolean changed)\n\t{\n\t\tdebug(\"Topic\", target + \" \" + setBy + \" \" + topic);\n\t\t\n\t\tif (changed) {\n\t\t\tserver.getChannel(target).addMessage(setBy + \" sets topic: \" + topic);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(\"Topic: \" + topic);\n\t\t}\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On User List\n\t */\n\t@Override\n\tprotected void onUserList(String channel, User[] users)\n\t{\n\t\tdebug(\"UserList\", channel + \" (\" + users.length + \")\");\n\t}\n\n\t/**\n\t * On Voice\n\t */\n\t@Override\n\tprotected void onVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Voice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" voiced \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\t\n\t/**\n\t * On disconnect\n\t */\n\t@Override\n\tpublic void onDisconnect()\n\t{\n\t\tserver.setStatus(Status.DISCONNECTED);\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\n\t/**\n\t * Print an event to the debug console \n\t */\n\tprivate void debug(String event, String params)\n\t{\n\t\tif (DEBUG_EVENTS) {\n\t\t\tLog.d(TAG, \"(\" + server.getTitle() + \") [\" + event + \"]: \" + params);\n\t\t}\n\t}\n\t\n\t/**\n\t * Quits from the IRC server with default reason.\n\t */\n\t@Override\n\tpublic void quitServer()\n\t{\n\t\tquitServer(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n}\n","Method after Refactoring":"/*\n Yaaic - Yet Another Android IRC Client\n\nCopyright 2009 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.irc;\n\nimport android.content.Intent;\nimport android.util.Log;\n\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\n\nimport org.yaaic.Yaaic;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.Status;\n\npublic class IRCConnection extends PircBot\n{\n\tprivate IRCService service;\n\tprivate Server server;\n\t\n\t// XXX: Print all IRC events to the debug console\n\tprivate static final boolean DEBUG_EVENTS = true;\n\tpublic static final String TAG = \"Yaaic/IRCConnection\";\n\t\n\t/**\n\t * Create a new connection\n\t * \n\t * @param service\n\t * @param serverId\n\t */\n\tpublic IRCConnection(IRCService service, int serverId)\n\t{\n\t\tthis.server = Yaaic.getInstance().getServerById(serverId);\n\t\tthis.service = service;\n\t\t\n\t\tthis.setName(\"Yaaic\");\n\t\tthis.setLogin(\"Yaaic\");\n\t\tthis.setAutoNickChange(true);\n\t\tthis.setVersion(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n\n\t/**\n\t * On connect\n\t */\n\t@Override\n\tpublic void onConnect()\n\t{\n\t\tdebug(\"Connect\", \"\");\n\t\t\n\t\tserver.setStatus(Status.CONNECTED);\n\t\t\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\t\n\t/**\n\t * On channel action\n\t */\n\t@Override\n\tprotected void onAction(String sender, String login, String hostname, String target, String action)\n\t{\n\t\tdebug(\"Action\", target + \" \" + sender + \" \" + action);\n\t\t\n\t\tMessage message = new Message(sender + \" \" + action);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Channel Info\n\t */\n\t@Override\n\tprotected void onChannelInfo(String channel, int userCount, String topic)\n\t{\n\t\tdebug(\"ChannelInfo\", channel + \" \" + userCount);\n\t}\n\n\t/**\n\t * On Deop\n\t */\n\t@Override\n\tprotected void onDeop(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Deop\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" deoped \" + recipient);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On DeVoice\n\t */\n\t@Override\n\tprotected void onDeVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"DeVoice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" devoiced \" + recipient);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Invite\n\t */\n\t@Override\n\tprotected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String target)\n\t{\n\t\tdebug(\"Invite\", target + \" \" + targetNick + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" invited \" + targetNick);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Join\n\t */\n\t@Override\n\tprotected void onJoin(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Join\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We joined a new channel\n\t\t\tserver.addChannel(new Channel(target));\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_NEW);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tMessage message = new Message(sender + \" joined\");\n\t\t\tserver.getChannel(target).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Kick\n\t */\n\t@Override\n\tprotected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n\t{\n\t\tdebug(\"Kick\", target + \" \" + recipientNick + \"(\" + kickerNick + \")\");\n\t\t\n\t\tif (recipientNick.equals(getNick())) {\n\t\t\t// We are kicked\n\t\t\tserver.removeChannel(target);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_REMOVE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tMessage message = new Message(kickerNick + \" kicked \" + recipientNick);\n\t\t\tserver.getChannel(target).addMessage(message);\n\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\t\t\t\n\t\t}\n\t}\n\n\t/**\n\t * On Message\n\t */\n\t@Override\n\tprotected void onMessage(String target, String sender, String login, String hostname, String text)\n\t{\n\t\tdebug(\"Message\", target + \" \" + sender + \" \" + text);\n\n\t\tMessage message = new Message(\"<\" + sender + \"> \" + text);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Mode\n\t */\n\t@Override\n\tprotected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n\t{\n\t\tdebug(\"Mode\", target + \" \" + sourceNick + \" \" + mode);\n\t\t\n\t\tMessage message = new Message(sourceNick + \" sets mode \" + mode);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Nick Change\n\t */\n\t@Override\n\tprotected void onNickChange(String oldNick, String login, String hostname, String newNick)\n\t{\n\t\tdebug(\"Nick\", oldNick + \" \" + newNick);\n\t\t\n\t\t// XXX: Add message to all channels where oldNick / newNick is present\n\t}\n\n\t/**\n\t * On Notice\n\t */\n\t@Override\n\tprotected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n\t{\n\t\tdebug(\"Notice\", sourceNick + \" \" + notice);\n\n\t\t// XXX: Where should notices be shown? Current window? All windows? Server window?\n\t}\n\n\t/**\n\t * On Op\n\t */\n\t@Override\n\tprotected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Op\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" oped \" + recipient);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Part\n\t */\n\t@Override\n\tprotected void onPart(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Part\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We pareted a channel\n\t\t\tserver.removeChannel(target);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_REMOVE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tMessage message = new Message(sender + \" parted\");\n\t\t\tserver.getChannel(target).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Private Message\n\t */\n\t@Override\n\tprotected void onPrivateMessage(String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"PrivateMessage\", sender + \" \" + message);\n\t}\n\n\t/**\n\t * On Quit\n\t */\n\t@Override\n\tprotected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n\t{\n\t\tdebug(\"Quit\", sourceNick);\n\t}\n\n\t/**\n\t * On Topic\n\t */\n\t@Override\n\tprotected void onTopic(String target, String topic, String setBy, long date, boolean changed)\n\t{\n\t\tdebug(\"Topic\", target + \" \" + setBy + \" \" + topic);\n\t\t\n\t\tif (changed) {\n\t\t\tMessage message = new Message(setBy + \" sets topic: \" + topic);\n\t\t\tserver.getChannel(target).addMessage(message);\n\t\t} else {\n\t\t\tMessage message = new Message(\"Topic: \" + topic);\n\t\t\tserver.getChannel(target).addMessage(message);\n\t\t}\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On User List\n\t */\n\t@Override\n\tprotected void onUserList(String channel, User[] users)\n\t{\n\t\tdebug(\"UserList\", channel + \" (\" + users.length + \")\");\n\t\t\n\t\t// XXX: Store user list somewhere and keep it updated or just broadcast some event?\n\t}\n\n\t/**\n\t * On Voice\n\t */\n\t@Override\n\tprotected void onVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Voice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" voiced \" + recipient);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\t\n\t/**\n\t * On disconnect\n\t */\n\t@Override\n\tpublic void onDisconnect()\n\t{\n\t\tserver.setStatus(Status.DISCONNECTED);\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\n\t/**\n\t * Print an event to the debug console \n\t */\n\tprivate void debug(String event, String params)\n\t{\n\t\tif (DEBUG_EVENTS) {\n\t\t\tLog.d(TAG, \"(\" + server.getTitle() + \") [\" + event + \"]: \" + params);\n\t\t}\n\t}\n\t\n\t/**\n\t * Quits from the IRC server with default reason.\n\t */\n\t@Override\n\tpublic void quitServer()\n\t{\n\t\tquitServer(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n}\n","lineNo":169}
{"Smelly Sample":"/*\n Yaaic - Yet Another Android IRC Client\n\nCopyright 2009 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.irc;\n\nimport android.content.Intent;\nimport android.util.Log;\n\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\n\nimport org.yaaic.Yaaic;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.Status;\n\npublic class IRCConnection extends PircBot\n{\n\tprivate IRCService service;\n\tprivate Server server;\n\t\n\t// XXX: Print all IRC events to the debug console\n\tprivate static final boolean DEBUG_EVENTS = true;\n\tpublic static final String TAG = \"Yaaic/IRCConnection\";\n\t\n\t/**\n\t * Create a new connection\n\t * \n\t * @param service\n\t * @param serverId\n\t */\n\tpublic IRCConnection(IRCService service, int serverId)\n\t{\n\t\tthis.server = Yaaic.getInstance().getServerById(serverId);\n\t\tthis.service = service;\n\t\t\n\t\tthis.setName(\"Yaaic\");\n\t\tthis.setLogin(\"Yaaic\");\n\t\tthis.setAutoNickChange(true);\n\t\tthis.setVersion(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n\n\t/**\n\t * On connect\n\t */\n\t@Override\n\tpublic void onConnect()\n\t{\n\t\tdebug(\"Connect\", \"\");\n\t\t\n\t\tserver.setStatus(Status.CONNECTED);\n\t\t\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\t\n\t/**\n\t * On channel action\n\t */\n\t@Override\n\tprotected void onAction(String sender, String login, String hostname, String target, String action)\n\t{\n\t\tdebug(\"Action\", target + \" \" + sender + \" \" + action);\n\t\t\n\t\tserver.getChannel(target).addMessage(\"* \" + sender + \" \" + action);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Channel Info\n\t */\n\t@Override\n\tprotected void onChannelInfo(String channel, int userCount, String topic)\n\t{\n\t\tdebug(\"ChannelInfo\", channel + \" \" + userCount);\n\t}\n\n\t/**\n\t * On Deop\n\t */\n\t@Override\n\tprotected void onDeop(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Deop\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" deoped \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On DeVoice\n\t */\n\t@Override\n\tprotected void onDeVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"DeVoice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" devoiced \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Invite\n\t */\n\t@Override\n\tprotected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String target)\n\t{\n\t\tdebug(\"Invite\", target + \" \" + targetNick + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" invited \" + targetNick);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Join\n\t */\n\t@Override\n\tprotected void onJoin(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Join\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We joined a new channel\n\t\t\tserver.addChannel(new Channel(target));\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_NEW);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" joined\");\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Kick\n\t */\n\t@Override\n\tprotected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n\t{\n\t\tdebug(\"Kick\", target + \" \" + recipientNick + \"(\" + kickerNick + \")\");\n\t\t\n\t\tif (recipientNick.equals(getNick())) {\n\t\t\t// We are kicked\n\t\t\tserver.removeChannel(target);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_REMOVE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(kickerNick + \" kicked \" + recipientNick);\n\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\t\t\t\n\t\t}\n\t}\n\n\t/**\n\t * On Message\n\t */\n\t@Override\n\tprotected void onMessage(String target, String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"Message\", target + \" \" + sender + \" \" + message);\n\n\t\tserver.getChannel(target).addMessage(\"<\" + sender + \"> \" + message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Mode\n\t */\n\t@Override\n\tprotected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n\t{\n\t\tdebug(\"Mode\", target + \" \" + sourceNick + \" \" + mode);\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" sets mode \" + mode);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Nick Change\n\t */\n\t@Override\n\tprotected void onNickChange(String oldNick, String login, String hostname, String newNick)\n\t{\n\t\tdebug(\"Nick\", oldNick + \" \" + newNick);\n\t}\n\n\t/**\n\t * On Notice\n\t */\n\t@Override\n\tprotected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n\t{\n\t\tdebug(\"Notice\", sourceNick + \" \" + notice);\n\t}\n\n\t/**\n\t * On Op\n\t */\n\t@Override\n\tprotected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Op\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" oped \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Part\n\t */\n\t@Override\n\tprotected void onPart(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Part\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We pareted a channel\n\t\t\tserver.removeChannel(target);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_REMOVE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" parted\");\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Private Message\n\t */\n\t@Override\n\tprotected void onPrivateMessage(String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"PrivateMessage\", sender + \" \" + message);\n\t}\n\n\t/**\n\t * On Quit\n\t */\n\t@Override\n\tprotected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n\t{\n\t\tdebug(\"Quit\", sourceNick);\n\t}\n\n\t/**\n\t * On Topic\n\t */\n\t@Override\n\tprotected void onTopic(String target, String topic, String setBy, long date, boolean changed)\n\t{\n\t\tdebug(\"Topic\", target + \" \" + setBy + \" \" + topic);\n\t\t\n\t\tif (changed) {\n\t\t\tserver.getChannel(target).addMessage(setBy + \" sets topic: \" + topic);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(\"Topic: \" + topic);\n\t\t}\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On User List\n\t */\n\t@Override\n\tprotected void onUserList(String channel, User[] users)\n\t{\n\t\tdebug(\"UserList\", channel + \" (\" + users.length + \")\");\n\t}\n\n\t/**\n\t * On Voice\n\t */\n\t@Override\n\tprotected void onVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Voice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" voiced \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\t\n\t/**\n\t * On disconnect\n\t */\n\t@Override\n\tpublic void onDisconnect()\n\t{\n\t\tserver.setStatus(Status.DISCONNECTED);\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\n\t/**\n\t * Print an event to the debug console \n\t */\n\tprivate void debug(String event, String params)\n\t{\n\t\tif (DEBUG_EVENTS) {\n\t\t\tLog.d(TAG, \"(\" + server.getTitle() + \") [\" + event + \"]: \" + params);\n\t\t}\n\t}\n\t\n\t/**\n\t * Quits from the IRC server with default reason.\n\t */\n\t@Override\n\tpublic void quitServer()\n\t{\n\t\tquitServer(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n}\n","Method after Refactoring":"/*\n Yaaic - Yet Another Android IRC Client\n\nCopyright 2009 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.irc;\n\nimport android.content.Intent;\nimport android.util.Log;\n\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\n\nimport org.yaaic.Yaaic;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.Status;\n\npublic class IRCConnection extends PircBot\n{\n\tprivate IRCService service;\n\tprivate Server server;\n\t\n\t// XXX: Print all IRC events to the debug console\n\tprivate static final boolean DEBUG_EVENTS = true;\n\tpublic static final String TAG = \"Yaaic/IRCConnection\";\n\t\n\t/**\n\t * Create a new connection\n\t * \n\t * @param service\n\t * @param serverId\n\t */\n\tpublic IRCConnection(IRCService service, int serverId)\n\t{\n\t\tthis.server = Yaaic.getInstance().getServerById(serverId);\n\t\tthis.service = service;\n\t\t\n\t\tthis.setName(\"Yaaic\");\n\t\tthis.setLogin(\"Yaaic\");\n\t\tthis.setAutoNickChange(true);\n\t\tthis.setVersion(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n\n\t/**\n\t * On connect\n\t */\n\t@Override\n\tpublic void onConnect()\n\t{\n\t\tdebug(\"Connect\", \"\");\n\t\t\n\t\tserver.setStatus(Status.CONNECTED);\n\t\t\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\t\n\t/**\n\t * On channel action\n\t */\n\t@Override\n\tprotected void onAction(String sender, String login, String hostname, String target, String action)\n\t{\n\t\tdebug(\"Action\", target + \" \" + sender + \" \" + action);\n\t\t\n\t\tMessage message = new Message(sender + \" \" + action);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Channel Info\n\t */\n\t@Override\n\tprotected void onChannelInfo(String channel, int userCount, String topic)\n\t{\n\t\tdebug(\"ChannelInfo\", channel + \" \" + userCount);\n\t}\n\n\t/**\n\t * On Deop\n\t */\n\t@Override\n\tprotected void onDeop(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Deop\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" deoped \" + recipient);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On DeVoice\n\t */\n\t@Override\n\tprotected void onDeVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"DeVoice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" devoiced \" + recipient);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Invite\n\t */\n\t@Override\n\tprotected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String target)\n\t{\n\t\tdebug(\"Invite\", target + \" \" + targetNick + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" invited \" + targetNick);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Join\n\t */\n\t@Override\n\tprotected void onJoin(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Join\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We joined a new channel\n\t\t\tserver.addChannel(new Channel(target));\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_NEW);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tMessage message = new Message(sender + \" joined\");\n\t\t\tserver.getChannel(target).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Kick\n\t */\n\t@Override\n\tprotected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n\t{\n\t\tdebug(\"Kick\", target + \" \" + recipientNick + \"(\" + kickerNick + \")\");\n\t\t\n\t\tif (recipientNick.equals(getNick())) {\n\t\t\t// We are kicked\n\t\t\tserver.removeChannel(target);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_REMOVE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tMessage message = new Message(kickerNick + \" kicked \" + recipientNick);\n\t\t\tserver.getChannel(target).addMessage(message);\n\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\t\t\t\n\t\t}\n\t}\n\n\t/**\n\t * On Message\n\t */\n\t@Override\n\tprotected void onMessage(String target, String sender, String login, String hostname, String text)\n\t{\n\t\tdebug(\"Message\", target + \" \" + sender + \" \" + text);\n\n\t\tMessage message = new Message(\"<\" + sender + \"> \" + text);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Mode\n\t */\n\t@Override\n\tprotected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n\t{\n\t\tdebug(\"Mode\", target + \" \" + sourceNick + \" \" + mode);\n\t\t\n\t\tMessage message = new Message(sourceNick + \" sets mode \" + mode);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Nick Change\n\t */\n\t@Override\n\tprotected void onNickChange(String oldNick, String login, String hostname, String newNick)\n\t{\n\t\tdebug(\"Nick\", oldNick + \" \" + newNick);\n\t\t\n\t\t// XXX: Add message to all channels where oldNick / newNick is present\n\t}\n\n\t/**\n\t * On Notice\n\t */\n\t@Override\n\tprotected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n\t{\n\t\tdebug(\"Notice\", sourceNick + \" \" + notice);\n\n\t\t// XXX: Where should notices be shown? Current window? All windows? Server window?\n\t}\n\n\t/**\n\t * On Op\n\t */\n\t@Override\n\tprotected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Op\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" oped \" + recipient);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Part\n\t */\n\t@Override\n\tprotected void onPart(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Part\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We pareted a channel\n\t\t\tserver.removeChannel(target);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_REMOVE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tMessage message = new Message(sender + \" parted\");\n\t\t\tserver.getChannel(target).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Private Message\n\t */\n\t@Override\n\tprotected void onPrivateMessage(String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"PrivateMessage\", sender + \" \" + message);\n\t}\n\n\t/**\n\t * On Quit\n\t */\n\t@Override\n\tprotected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n\t{\n\t\tdebug(\"Quit\", sourceNick);\n\t}\n\n\t/**\n\t * On Topic\n\t */\n\t@Override\n\tprotected void onTopic(String target, String topic, String setBy, long date, boolean changed)\n\t{\n\t\tdebug(\"Topic\", target + \" \" + setBy + \" \" + topic);\n\t\t\n\t\tif (changed) {\n\t\t\tMessage message = new Message(setBy + \" sets topic: \" + topic);\n\t\t\tserver.getChannel(target).addMessage(message);\n\t\t} else {\n\t\t\tMessage message = new Message(\"Topic: \" + topic);\n\t\t\tserver.getChannel(target).addMessage(message);\n\t\t}\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On User List\n\t */\n\t@Override\n\tprotected void onUserList(String channel, User[] users)\n\t{\n\t\tdebug(\"UserList\", channel + \" (\" + users.length + \")\");\n\t\t\n\t\t// XXX: Store user list somewhere and keep it updated or just broadcast some event?\n\t}\n\n\t/**\n\t * On Voice\n\t */\n\t@Override\n\tprotected void onVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Voice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" voiced \" + recipient);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\t\n\t/**\n\t * On disconnect\n\t */\n\t@Override\n\tpublic void onDisconnect()\n\t{\n\t\tserver.setStatus(Status.DISCONNECTED);\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\n\t/**\n\t * Print an event to the debug console \n\t */\n\tprivate void debug(String event, String params)\n\t{\n\t\tif (DEBUG_EVENTS) {\n\t\t\tLog.d(TAG, \"(\" + server.getTitle() + \") [\" + event + \"]: \" + params);\n\t\t}\n\t}\n\t\n\t/**\n\t * Quits from the IRC server with default reason.\n\t */\n\t@Override\n\tpublic void quitServer()\n\t{\n\t\tquitServer(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n}\n","lineNo":196}
{"Smelly Sample":"/*\n Yaaic - Yet Another Android IRC Client\n\nCopyright 2009 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.irc;\n\nimport android.content.Intent;\nimport android.util.Log;\n\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\n\nimport org.yaaic.Yaaic;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.Status;\n\npublic class IRCConnection extends PircBot\n{\n\tprivate IRCService service;\n\tprivate Server server;\n\t\n\t// XXX: Print all IRC events to the debug console\n\tprivate static final boolean DEBUG_EVENTS = true;\n\tpublic static final String TAG = \"Yaaic/IRCConnection\";\n\t\n\t/**\n\t * Create a new connection\n\t * \n\t * @param service\n\t * @param serverId\n\t */\n\tpublic IRCConnection(IRCService service, int serverId)\n\t{\n\t\tthis.server = Yaaic.getInstance().getServerById(serverId);\n\t\tthis.service = service;\n\t\t\n\t\tthis.setName(\"Yaaic\");\n\t\tthis.setLogin(\"Yaaic\");\n\t\tthis.setAutoNickChange(true);\n\t\tthis.setVersion(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n\n\t/**\n\t * On connect\n\t */\n\t@Override\n\tpublic void onConnect()\n\t{\n\t\tdebug(\"Connect\", \"\");\n\t\t\n\t\tserver.setStatus(Status.CONNECTED);\n\t\t\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\t\n\t/**\n\t * On channel action\n\t */\n\t@Override\n\tprotected void onAction(String sender, String login, String hostname, String target, String action)\n\t{\n\t\tdebug(\"Action\", target + \" \" + sender + \" \" + action);\n\t\t\n\t\tserver.getChannel(target).addMessage(\"* \" + sender + \" \" + action);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Channel Info\n\t */\n\t@Override\n\tprotected void onChannelInfo(String channel, int userCount, String topic)\n\t{\n\t\tdebug(\"ChannelInfo\", channel + \" \" + userCount);\n\t}\n\n\t/**\n\t * On Deop\n\t */\n\t@Override\n\tprotected void onDeop(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Deop\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" deoped \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On DeVoice\n\t */\n\t@Override\n\tprotected void onDeVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"DeVoice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" devoiced \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Invite\n\t */\n\t@Override\n\tprotected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String target)\n\t{\n\t\tdebug(\"Invite\", target + \" \" + targetNick + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" invited \" + targetNick);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Join\n\t */\n\t@Override\n\tprotected void onJoin(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Join\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We joined a new channel\n\t\t\tserver.addChannel(new Channel(target));\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_NEW);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" joined\");\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Kick\n\t */\n\t@Override\n\tprotected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n\t{\n\t\tdebug(\"Kick\", target + \" \" + recipientNick + \"(\" + kickerNick + \")\");\n\t\t\n\t\tif (recipientNick.equals(getNick())) {\n\t\t\t// We are kicked\n\t\t\tserver.removeChannel(target);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_REMOVE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(kickerNick + \" kicked \" + recipientNick);\n\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\t\t\t\n\t\t}\n\t}\n\n\t/**\n\t * On Message\n\t */\n\t@Override\n\tprotected void onMessage(String target, String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"Message\", target + \" \" + sender + \" \" + message);\n\n\t\tserver.getChannel(target).addMessage(\"<\" + sender + \"> \" + message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Mode\n\t */\n\t@Override\n\tprotected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n\t{\n\t\tdebug(\"Mode\", target + \" \" + sourceNick + \" \" + mode);\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" sets mode \" + mode);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Nick Change\n\t */\n\t@Override\n\tprotected void onNickChange(String oldNick, String login, String hostname, String newNick)\n\t{\n\t\tdebug(\"Nick\", oldNick + \" \" + newNick);\n\t}\n\n\t/**\n\t * On Notice\n\t */\n\t@Override\n\tprotected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n\t{\n\t\tdebug(\"Notice\", sourceNick + \" \" + notice);\n\t}\n\n\t/**\n\t * On Op\n\t */\n\t@Override\n\tprotected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Op\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" oped \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Part\n\t */\n\t@Override\n\tprotected void onPart(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Part\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We pareted a channel\n\t\t\tserver.removeChannel(target);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_REMOVE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" parted\");\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Private Message\n\t */\n\t@Override\n\tprotected void onPrivateMessage(String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"PrivateMessage\", sender + \" \" + message);\n\t}\n\n\t/**\n\t * On Quit\n\t */\n\t@Override\n\tprotected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n\t{\n\t\tdebug(\"Quit\", sourceNick);\n\t}\n\n\t/**\n\t * On Topic\n\t */\n\t@Override\n\tprotected void onTopic(String target, String topic, String setBy, long date, boolean changed)\n\t{\n\t\tdebug(\"Topic\", target + \" \" + setBy + \" \" + topic);\n\t\t\n\t\tif (changed) {\n\t\t\tserver.getChannel(target).addMessage(setBy + \" sets topic: \" + topic);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(\"Topic: \" + topic);\n\t\t}\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On User List\n\t */\n\t@Override\n\tprotected void onUserList(String channel, User[] users)\n\t{\n\t\tdebug(\"UserList\", channel + \" (\" + users.length + \")\");\n\t}\n\n\t/**\n\t * On Voice\n\t */\n\t@Override\n\tprotected void onVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Voice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" voiced \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\t\n\t/**\n\t * On disconnect\n\t */\n\t@Override\n\tpublic void onDisconnect()\n\t{\n\t\tserver.setStatus(Status.DISCONNECTED);\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\n\t/**\n\t * Print an event to the debug console \n\t */\n\tprivate void debug(String event, String params)\n\t{\n\t\tif (DEBUG_EVENTS) {\n\t\t\tLog.d(TAG, \"(\" + server.getTitle() + \") [\" + event + \"]: \" + params);\n\t\t}\n\t}\n\t\n\t/**\n\t * Quits from the IRC server with default reason.\n\t */\n\t@Override\n\tpublic void quitServer()\n\t{\n\t\tquitServer(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n}\n","Method after Refactoring":"/*\n Yaaic - Yet Another Android IRC Client\n\nCopyright 2009 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.irc;\n\nimport android.content.Intent;\nimport android.util.Log;\n\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\n\nimport org.yaaic.Yaaic;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.Status;\n\npublic class IRCConnection extends PircBot\n{\n\tprivate IRCService service;\n\tprivate Server server;\n\t\n\t// XXX: Print all IRC events to the debug console\n\tprivate static final boolean DEBUG_EVENTS = true;\n\tpublic static final String TAG = \"Yaaic/IRCConnection\";\n\t\n\t/**\n\t * Create a new connection\n\t * \n\t * @param service\n\t * @param serverId\n\t */\n\tpublic IRCConnection(IRCService service, int serverId)\n\t{\n\t\tthis.server = Yaaic.getInstance().getServerById(serverId);\n\t\tthis.service = service;\n\t\t\n\t\tthis.setName(\"Yaaic\");\n\t\tthis.setLogin(\"Yaaic\");\n\t\tthis.setAutoNickChange(true);\n\t\tthis.setVersion(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n\n\t/**\n\t * On connect\n\t */\n\t@Override\n\tpublic void onConnect()\n\t{\n\t\tdebug(\"Connect\", \"\");\n\t\t\n\t\tserver.setStatus(Status.CONNECTED);\n\t\t\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\t\n\t/**\n\t * On channel action\n\t */\n\t@Override\n\tprotected void onAction(String sender, String login, String hostname, String target, String action)\n\t{\n\t\tdebug(\"Action\", target + \" \" + sender + \" \" + action);\n\t\t\n\t\tMessage message = new Message(sender + \" \" + action);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Channel Info\n\t */\n\t@Override\n\tprotected void onChannelInfo(String channel, int userCount, String topic)\n\t{\n\t\tdebug(\"ChannelInfo\", channel + \" \" + userCount);\n\t}\n\n\t/**\n\t * On Deop\n\t */\n\t@Override\n\tprotected void onDeop(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Deop\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" deoped \" + recipient);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On DeVoice\n\t */\n\t@Override\n\tprotected void onDeVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"DeVoice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" devoiced \" + recipient);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Invite\n\t */\n\t@Override\n\tprotected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String target)\n\t{\n\t\tdebug(\"Invite\", target + \" \" + targetNick + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" invited \" + targetNick);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Join\n\t */\n\t@Override\n\tprotected void onJoin(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Join\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We joined a new channel\n\t\t\tserver.addChannel(new Channel(target));\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_NEW);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tMessage message = new Message(sender + \" joined\");\n\t\t\tserver.getChannel(target).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Kick\n\t */\n\t@Override\n\tprotected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n\t{\n\t\tdebug(\"Kick\", target + \" \" + recipientNick + \"(\" + kickerNick + \")\");\n\t\t\n\t\tif (recipientNick.equals(getNick())) {\n\t\t\t// We are kicked\n\t\t\tserver.removeChannel(target);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_REMOVE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tMessage message = new Message(kickerNick + \" kicked \" + recipientNick);\n\t\t\tserver.getChannel(target).addMessage(message);\n\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\t\t\t\n\t\t}\n\t}\n\n\t/**\n\t * On Message\n\t */\n\t@Override\n\tprotected void onMessage(String target, String sender, String login, String hostname, String text)\n\t{\n\t\tdebug(\"Message\", target + \" \" + sender + \" \" + text);\n\n\t\tMessage message = new Message(\"<\" + sender + \"> \" + text);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Mode\n\t */\n\t@Override\n\tprotected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n\t{\n\t\tdebug(\"Mode\", target + \" \" + sourceNick + \" \" + mode);\n\t\t\n\t\tMessage message = new Message(sourceNick + \" sets mode \" + mode);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Nick Change\n\t */\n\t@Override\n\tprotected void onNickChange(String oldNick, String login, String hostname, String newNick)\n\t{\n\t\tdebug(\"Nick\", oldNick + \" \" + newNick);\n\t\t\n\t\t// XXX: Add message to all channels where oldNick / newNick is present\n\t}\n\n\t/**\n\t * On Notice\n\t */\n\t@Override\n\tprotected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n\t{\n\t\tdebug(\"Notice\", sourceNick + \" \" + notice);\n\n\t\t// XXX: Where should notices be shown? Current window? All windows? Server window?\n\t}\n\n\t/**\n\t * On Op\n\t */\n\t@Override\n\tprotected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Op\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" oped \" + recipient);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Part\n\t */\n\t@Override\n\tprotected void onPart(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Part\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We pareted a channel\n\t\t\tserver.removeChannel(target);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_REMOVE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tMessage message = new Message(sender + \" parted\");\n\t\t\tserver.getChannel(target).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Private Message\n\t */\n\t@Override\n\tprotected void onPrivateMessage(String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"PrivateMessage\", sender + \" \" + message);\n\t}\n\n\t/**\n\t * On Quit\n\t */\n\t@Override\n\tprotected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n\t{\n\t\tdebug(\"Quit\", sourceNick);\n\t}\n\n\t/**\n\t * On Topic\n\t */\n\t@Override\n\tprotected void onTopic(String target, String topic, String setBy, long date, boolean changed)\n\t{\n\t\tdebug(\"Topic\", target + \" \" + setBy + \" \" + topic);\n\t\t\n\t\tif (changed) {\n\t\t\tMessage message = new Message(setBy + \" sets topic: \" + topic);\n\t\t\tserver.getChannel(target).addMessage(message);\n\t\t} else {\n\t\t\tMessage message = new Message(\"Topic: \" + topic);\n\t\t\tserver.getChannel(target).addMessage(message);\n\t\t}\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On User List\n\t */\n\t@Override\n\tprotected void onUserList(String channel, User[] users)\n\t{\n\t\tdebug(\"UserList\", channel + \" (\" + users.length + \")\");\n\t\t\n\t\t// XXX: Store user list somewhere and keep it updated or just broadcast some event?\n\t}\n\n\t/**\n\t * On Voice\n\t */\n\t@Override\n\tprotected void onVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Voice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" voiced \" + recipient);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\t\n\t/**\n\t * On disconnect\n\t */\n\t@Override\n\tpublic void onDisconnect()\n\t{\n\t\tserver.setStatus(Status.DISCONNECTED);\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\n\t/**\n\t * Print an event to the debug console \n\t */\n\tprivate void debug(String event, String params)\n\t{\n\t\tif (DEBUG_EVENTS) {\n\t\t\tLog.d(TAG, \"(\" + server.getTitle() + \") [\" + event + \"]: \" + params);\n\t\t}\n\t}\n\t\n\t/**\n\t * Quits from the IRC server with default reason.\n\t */\n\t@Override\n\tpublic void quitServer()\n\t{\n\t\tquitServer(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n}\n","lineNo":231}
{"Smelly Sample":"/*\n Yaaic - Yet Another Android IRC Client\n\nCopyright 2009 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.irc;\n\nimport android.content.Intent;\nimport android.util.Log;\n\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\n\nimport org.yaaic.Yaaic;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.Status;\n\npublic class IRCConnection extends PircBot\n{\n\tprivate IRCService service;\n\tprivate Server server;\n\t\n\t// XXX: Print all IRC events to the debug console\n\tprivate static final boolean DEBUG_EVENTS = true;\n\tpublic static final String TAG = \"Yaaic/IRCConnection\";\n\t\n\t/**\n\t * Create a new connection\n\t * \n\t * @param service\n\t * @param serverId\n\t */\n\tpublic IRCConnection(IRCService service, int serverId)\n\t{\n\t\tthis.server = Yaaic.getInstance().getServerById(serverId);\n\t\tthis.service = service;\n\t\t\n\t\tthis.setName(\"Yaaic\");\n\t\tthis.setLogin(\"Yaaic\");\n\t\tthis.setAutoNickChange(true);\n\t\tthis.setVersion(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n\n\t/**\n\t * On connect\n\t */\n\t@Override\n\tpublic void onConnect()\n\t{\n\t\tdebug(\"Connect\", \"\");\n\t\t\n\t\tserver.setStatus(Status.CONNECTED);\n\t\t\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\t\n\t/**\n\t * On channel action\n\t */\n\t@Override\n\tprotected void onAction(String sender, String login, String hostname, String target, String action)\n\t{\n\t\tdebug(\"Action\", target + \" \" + sender + \" \" + action);\n\t\t\n\t\tserver.getChannel(target).addMessage(\"* \" + sender + \" \" + action);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Channel Info\n\t */\n\t@Override\n\tprotected void onChannelInfo(String channel, int userCount, String topic)\n\t{\n\t\tdebug(\"ChannelInfo\", channel + \" \" + userCount);\n\t}\n\n\t/**\n\t * On Deop\n\t */\n\t@Override\n\tprotected void onDeop(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Deop\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" deoped \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On DeVoice\n\t */\n\t@Override\n\tprotected void onDeVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"DeVoice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" devoiced \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Invite\n\t */\n\t@Override\n\tprotected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String target)\n\t{\n\t\tdebug(\"Invite\", target + \" \" + targetNick + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" invited \" + targetNick);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Join\n\t */\n\t@Override\n\tprotected void onJoin(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Join\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We joined a new channel\n\t\t\tserver.addChannel(new Channel(target));\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_NEW);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" joined\");\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Kick\n\t */\n\t@Override\n\tprotected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n\t{\n\t\tdebug(\"Kick\", target + \" \" + recipientNick + \"(\" + kickerNick + \")\");\n\t\t\n\t\tif (recipientNick.equals(getNick())) {\n\t\t\t// We are kicked\n\t\t\tserver.removeChannel(target);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_REMOVE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(kickerNick + \" kicked \" + recipientNick);\n\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\t\t\t\n\t\t}\n\t}\n\n\t/**\n\t * On Message\n\t */\n\t@Override\n\tprotected void onMessage(String target, String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"Message\", target + \" \" + sender + \" \" + message);\n\n\t\tserver.getChannel(target).addMessage(\"<\" + sender + \"> \" + message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Mode\n\t */\n\t@Override\n\tprotected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n\t{\n\t\tdebug(\"Mode\", target + \" \" + sourceNick + \" \" + mode);\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" sets mode \" + mode);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Nick Change\n\t */\n\t@Override\n\tprotected void onNickChange(String oldNick, String login, String hostname, String newNick)\n\t{\n\t\tdebug(\"Nick\", oldNick + \" \" + newNick);\n\t}\n\n\t/**\n\t * On Notice\n\t */\n\t@Override\n\tprotected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n\t{\n\t\tdebug(\"Notice\", sourceNick + \" \" + notice);\n\t}\n\n\t/**\n\t * On Op\n\t */\n\t@Override\n\tprotected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Op\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" oped \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Part\n\t */\n\t@Override\n\tprotected void onPart(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Part\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We pareted a channel\n\t\t\tserver.removeChannel(target);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_REMOVE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" parted\");\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Private Message\n\t */\n\t@Override\n\tprotected void onPrivateMessage(String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"PrivateMessage\", sender + \" \" + message);\n\t}\n\n\t/**\n\t * On Quit\n\t */\n\t@Override\n\tprotected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n\t{\n\t\tdebug(\"Quit\", sourceNick);\n\t}\n\n\t/**\n\t * On Topic\n\t */\n\t@Override\n\tprotected void onTopic(String target, String topic, String setBy, long date, boolean changed)\n\t{\n\t\tdebug(\"Topic\", target + \" \" + setBy + \" \" + topic);\n\t\t\n\t\tif (changed) {\n\t\t\tserver.getChannel(target).addMessage(setBy + \" sets topic: \" + topic);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(\"Topic: \" + topic);\n\t\t}\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On User List\n\t */\n\t@Override\n\tprotected void onUserList(String channel, User[] users)\n\t{\n\t\tdebug(\"UserList\", channel + \" (\" + users.length + \")\");\n\t}\n\n\t/**\n\t * On Voice\n\t */\n\t@Override\n\tprotected void onVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Voice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" voiced \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\t\n\t/**\n\t * On disconnect\n\t */\n\t@Override\n\tpublic void onDisconnect()\n\t{\n\t\tserver.setStatus(Status.DISCONNECTED);\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\n\t/**\n\t * Print an event to the debug console \n\t */\n\tprivate void debug(String event, String params)\n\t{\n\t\tif (DEBUG_EVENTS) {\n\t\t\tLog.d(TAG, \"(\" + server.getTitle() + \") [\" + event + \"]: \" + params);\n\t\t}\n\t}\n\t\n\t/**\n\t * Quits from the IRC server with default reason.\n\t */\n\t@Override\n\tpublic void quitServer()\n\t{\n\t\tquitServer(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n}\n","Method after Refactoring":"/*\n Yaaic - Yet Another Android IRC Client\n\nCopyright 2009 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.irc;\n\nimport android.content.Intent;\nimport android.util.Log;\n\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\n\nimport org.yaaic.Yaaic;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.Status;\n\npublic class IRCConnection extends PircBot\n{\n\tprivate IRCService service;\n\tprivate Server server;\n\t\n\t// XXX: Print all IRC events to the debug console\n\tprivate static final boolean DEBUG_EVENTS = true;\n\tpublic static final String TAG = \"Yaaic/IRCConnection\";\n\t\n\t/**\n\t * Create a new connection\n\t * \n\t * @param service\n\t * @param serverId\n\t */\n\tpublic IRCConnection(IRCService service, int serverId)\n\t{\n\t\tthis.server = Yaaic.getInstance().getServerById(serverId);\n\t\tthis.service = service;\n\t\t\n\t\tthis.setName(\"Yaaic\");\n\t\tthis.setLogin(\"Yaaic\");\n\t\tthis.setAutoNickChange(true);\n\t\tthis.setVersion(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n\n\t/**\n\t * On connect\n\t */\n\t@Override\n\tpublic void onConnect()\n\t{\n\t\tdebug(\"Connect\", \"\");\n\t\t\n\t\tserver.setStatus(Status.CONNECTED);\n\t\t\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\t\n\t/**\n\t * On channel action\n\t */\n\t@Override\n\tprotected void onAction(String sender, String login, String hostname, String target, String action)\n\t{\n\t\tdebug(\"Action\", target + \" \" + sender + \" \" + action);\n\t\t\n\t\tMessage message = new Message(sender + \" \" + action);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Channel Info\n\t */\n\t@Override\n\tprotected void onChannelInfo(String channel, int userCount, String topic)\n\t{\n\t\tdebug(\"ChannelInfo\", channel + \" \" + userCount);\n\t}\n\n\t/**\n\t * On Deop\n\t */\n\t@Override\n\tprotected void onDeop(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Deop\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" deoped \" + recipient);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On DeVoice\n\t */\n\t@Override\n\tprotected void onDeVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"DeVoice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" devoiced \" + recipient);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Invite\n\t */\n\t@Override\n\tprotected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String target)\n\t{\n\t\tdebug(\"Invite\", target + \" \" + targetNick + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" invited \" + targetNick);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Join\n\t */\n\t@Override\n\tprotected void onJoin(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Join\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We joined a new channel\n\t\t\tserver.addChannel(new Channel(target));\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_NEW);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tMessage message = new Message(sender + \" joined\");\n\t\t\tserver.getChannel(target).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Kick\n\t */\n\t@Override\n\tprotected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n\t{\n\t\tdebug(\"Kick\", target + \" \" + recipientNick + \"(\" + kickerNick + \")\");\n\t\t\n\t\tif (recipientNick.equals(getNick())) {\n\t\t\t// We are kicked\n\t\t\tserver.removeChannel(target);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_REMOVE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tMessage message = new Message(kickerNick + \" kicked \" + recipientNick);\n\t\t\tserver.getChannel(target).addMessage(message);\n\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\t\t\t\n\t\t}\n\t}\n\n\t/**\n\t * On Message\n\t */\n\t@Override\n\tprotected void onMessage(String target, String sender, String login, String hostname, String text)\n\t{\n\t\tdebug(\"Message\", target + \" \" + sender + \" \" + text);\n\n\t\tMessage message = new Message(\"<\" + sender + \"> \" + text);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Mode\n\t */\n\t@Override\n\tprotected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n\t{\n\t\tdebug(\"Mode\", target + \" \" + sourceNick + \" \" + mode);\n\t\t\n\t\tMessage message = new Message(sourceNick + \" sets mode \" + mode);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Nick Change\n\t */\n\t@Override\n\tprotected void onNickChange(String oldNick, String login, String hostname, String newNick)\n\t{\n\t\tdebug(\"Nick\", oldNick + \" \" + newNick);\n\t\t\n\t\t// XXX: Add message to all channels where oldNick / newNick is present\n\t}\n\n\t/**\n\t * On Notice\n\t */\n\t@Override\n\tprotected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n\t{\n\t\tdebug(\"Notice\", sourceNick + \" \" + notice);\n\n\t\t// XXX: Where should notices be shown? Current window? All windows? Server window?\n\t}\n\n\t/**\n\t * On Op\n\t */\n\t@Override\n\tprotected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Op\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" oped \" + recipient);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Part\n\t */\n\t@Override\n\tprotected void onPart(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Part\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We pareted a channel\n\t\t\tserver.removeChannel(target);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_REMOVE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tMessage message = new Message(sender + \" parted\");\n\t\t\tserver.getChannel(target).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Private Message\n\t */\n\t@Override\n\tprotected void onPrivateMessage(String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"PrivateMessage\", sender + \" \" + message);\n\t}\n\n\t/**\n\t * On Quit\n\t */\n\t@Override\n\tprotected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n\t{\n\t\tdebug(\"Quit\", sourceNick);\n\t}\n\n\t/**\n\t * On Topic\n\t */\n\t@Override\n\tprotected void onTopic(String target, String topic, String setBy, long date, boolean changed)\n\t{\n\t\tdebug(\"Topic\", target + \" \" + setBy + \" \" + topic);\n\t\t\n\t\tif (changed) {\n\t\t\tMessage message = new Message(setBy + \" sets topic: \" + topic);\n\t\t\tserver.getChannel(target).addMessage(message);\n\t\t} else {\n\t\t\tMessage message = new Message(\"Topic: \" + topic);\n\t\t\tserver.getChannel(target).addMessage(message);\n\t\t}\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On User List\n\t */\n\t@Override\n\tprotected void onUserList(String channel, User[] users)\n\t{\n\t\tdebug(\"UserList\", channel + \" (\" + users.length + \")\");\n\t\t\n\t\t// XXX: Store user list somewhere and keep it updated or just broadcast some event?\n\t}\n\n\t/**\n\t * On Voice\n\t */\n\t@Override\n\tprotected void onVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Voice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" voiced \" + recipient);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\t\n\t/**\n\t * On disconnect\n\t */\n\t@Override\n\tpublic void onDisconnect()\n\t{\n\t\tserver.setStatus(Status.DISCONNECTED);\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\n\t/**\n\t * Print an event to the debug console \n\t */\n\tprivate void debug(String event, String params)\n\t{\n\t\tif (DEBUG_EVENTS) {\n\t\t\tLog.d(TAG, \"(\" + server.getTitle() + \") [\" + event + \"]: \" + params);\n\t\t}\n\t}\n\t\n\t/**\n\t * Quits from the IRC server with default reason.\n\t */\n\t@Override\n\tpublic void quitServer()\n\t{\n\t\tquitServer(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n}\n","lineNo":270}
{"Smelly Sample":"/*\n Yaaic - Yet Another Android IRC Client\n\nCopyright 2009 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.irc;\n\nimport android.content.Intent;\nimport android.util.Log;\n\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\n\nimport org.yaaic.Yaaic;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.Status;\n\npublic class IRCConnection extends PircBot\n{\n\tprivate IRCService service;\n\tprivate Server server;\n\t\n\t// XXX: Print all IRC events to the debug console\n\tprivate static final boolean DEBUG_EVENTS = true;\n\tpublic static final String TAG = \"Yaaic/IRCConnection\";\n\t\n\t/**\n\t * Create a new connection\n\t * \n\t * @param service\n\t * @param serverId\n\t */\n\tpublic IRCConnection(IRCService service, int serverId)\n\t{\n\t\tthis.server = Yaaic.getInstance().getServerById(serverId);\n\t\tthis.service = service;\n\t\t\n\t\tthis.setName(\"Yaaic\");\n\t\tthis.setLogin(\"Yaaic\");\n\t\tthis.setAutoNickChange(true);\n\t\tthis.setVersion(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n\n\t/**\n\t * On connect\n\t */\n\t@Override\n\tpublic void onConnect()\n\t{\n\t\tdebug(\"Connect\", \"\");\n\t\t\n\t\tserver.setStatus(Status.CONNECTED);\n\t\t\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\t\n\t/**\n\t * On channel action\n\t */\n\t@Override\n\tprotected void onAction(String sender, String login, String hostname, String target, String action)\n\t{\n\t\tdebug(\"Action\", target + \" \" + sender + \" \" + action);\n\t\t\n\t\tserver.getChannel(target).addMessage(\"* \" + sender + \" \" + action);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Channel Info\n\t */\n\t@Override\n\tprotected void onChannelInfo(String channel, int userCount, String topic)\n\t{\n\t\tdebug(\"ChannelInfo\", channel + \" \" + userCount);\n\t}\n\n\t/**\n\t * On Deop\n\t */\n\t@Override\n\tprotected void onDeop(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Deop\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" deoped \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On DeVoice\n\t */\n\t@Override\n\tprotected void onDeVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"DeVoice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" devoiced \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Invite\n\t */\n\t@Override\n\tprotected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String target)\n\t{\n\t\tdebug(\"Invite\", target + \" \" + targetNick + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" invited \" + targetNick);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Join\n\t */\n\t@Override\n\tprotected void onJoin(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Join\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We joined a new channel\n\t\t\tserver.addChannel(new Channel(target));\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_NEW);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" joined\");\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Kick\n\t */\n\t@Override\n\tprotected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n\t{\n\t\tdebug(\"Kick\", target + \" \" + recipientNick + \"(\" + kickerNick + \")\");\n\t\t\n\t\tif (recipientNick.equals(getNick())) {\n\t\t\t// We are kicked\n\t\t\tserver.removeChannel(target);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_REMOVE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(kickerNick + \" kicked \" + recipientNick);\n\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\t\t\t\n\t\t}\n\t}\n\n\t/**\n\t * On Message\n\t */\n\t@Override\n\tprotected void onMessage(String target, String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"Message\", target + \" \" + sender + \" \" + message);\n\n\t\tserver.getChannel(target).addMessage(\"<\" + sender + \"> \" + message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Mode\n\t */\n\t@Override\n\tprotected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n\t{\n\t\tdebug(\"Mode\", target + \" \" + sourceNick + \" \" + mode);\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" sets mode \" + mode);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Nick Change\n\t */\n\t@Override\n\tprotected void onNickChange(String oldNick, String login, String hostname, String newNick)\n\t{\n\t\tdebug(\"Nick\", oldNick + \" \" + newNick);\n\t}\n\n\t/**\n\t * On Notice\n\t */\n\t@Override\n\tprotected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n\t{\n\t\tdebug(\"Notice\", sourceNick + \" \" + notice);\n\t}\n\n\t/**\n\t * On Op\n\t */\n\t@Override\n\tprotected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Op\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" oped \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Part\n\t */\n\t@Override\n\tprotected void onPart(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Part\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We pareted a channel\n\t\t\tserver.removeChannel(target);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_REMOVE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" parted\");\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Private Message\n\t */\n\t@Override\n\tprotected void onPrivateMessage(String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"PrivateMessage\", sender + \" \" + message);\n\t}\n\n\t/**\n\t * On Quit\n\t */\n\t@Override\n\tprotected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n\t{\n\t\tdebug(\"Quit\", sourceNick);\n\t}\n\n\t/**\n\t * On Topic\n\t */\n\t@Override\n\tprotected void onTopic(String target, String topic, String setBy, long date, boolean changed)\n\t{\n\t\tdebug(\"Topic\", target + \" \" + setBy + \" \" + topic);\n\t\t\n\t\tif (changed) {\n\t\t\tserver.getChannel(target).addMessage(setBy + \" sets topic: \" + topic);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(\"Topic: \" + topic);\n\t\t}\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On User List\n\t */\n\t@Override\n\tprotected void onUserList(String channel, User[] users)\n\t{\n\t\tdebug(\"UserList\", channel + \" (\" + users.length + \")\");\n\t}\n\n\t/**\n\t * On Voice\n\t */\n\t@Override\n\tprotected void onVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Voice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" voiced \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\t\n\t/**\n\t * On disconnect\n\t */\n\t@Override\n\tpublic void onDisconnect()\n\t{\n\t\tserver.setStatus(Status.DISCONNECTED);\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\n\t/**\n\t * Print an event to the debug console \n\t */\n\tprivate void debug(String event, String params)\n\t{\n\t\tif (DEBUG_EVENTS) {\n\t\t\tLog.d(TAG, \"(\" + server.getTitle() + \") [\" + event + \"]: \" + params);\n\t\t}\n\t}\n\t\n\t/**\n\t * Quits from the IRC server with default reason.\n\t */\n\t@Override\n\tpublic void quitServer()\n\t{\n\t\tquitServer(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n}\n","Method after Refactoring":"/*\n Yaaic - Yet Another Android IRC Client\n\nCopyright 2009 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.irc;\n\nimport android.content.Intent;\nimport android.util.Log;\n\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\n\nimport org.yaaic.Yaaic;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.Status;\n\npublic class IRCConnection extends PircBot\n{\n\tprivate IRCService service;\n\tprivate Server server;\n\t\n\t// XXX: Print all IRC events to the debug console\n\tprivate static final boolean DEBUG_EVENTS = true;\n\tpublic static final String TAG = \"Yaaic/IRCConnection\";\n\t\n\t/**\n\t * Create a new connection\n\t * \n\t * @param service\n\t * @param serverId\n\t */\n\tpublic IRCConnection(IRCService service, int serverId)\n\t{\n\t\tthis.server = Yaaic.getInstance().getServerById(serverId);\n\t\tthis.service = service;\n\t\t\n\t\tthis.setName(\"Yaaic\");\n\t\tthis.setLogin(\"Yaaic\");\n\t\tthis.setAutoNickChange(true);\n\t\tthis.setVersion(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n\n\t/**\n\t * On connect\n\t */\n\t@Override\n\tpublic void onConnect()\n\t{\n\t\tdebug(\"Connect\", \"\");\n\t\t\n\t\tserver.setStatus(Status.CONNECTED);\n\t\t\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\t\n\t/**\n\t * On channel action\n\t */\n\t@Override\n\tprotected void onAction(String sender, String login, String hostname, String target, String action)\n\t{\n\t\tdebug(\"Action\", target + \" \" + sender + \" \" + action);\n\t\t\n\t\tMessage message = new Message(sender + \" \" + action);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Channel Info\n\t */\n\t@Override\n\tprotected void onChannelInfo(String channel, int userCount, String topic)\n\t{\n\t\tdebug(\"ChannelInfo\", channel + \" \" + userCount);\n\t}\n\n\t/**\n\t * On Deop\n\t */\n\t@Override\n\tprotected void onDeop(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Deop\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" deoped \" + recipient);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On DeVoice\n\t */\n\t@Override\n\tprotected void onDeVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"DeVoice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" devoiced \" + recipient);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Invite\n\t */\n\t@Override\n\tprotected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String target)\n\t{\n\t\tdebug(\"Invite\", target + \" \" + targetNick + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" invited \" + targetNick);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Join\n\t */\n\t@Override\n\tprotected void onJoin(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Join\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We joined a new channel\n\t\t\tserver.addChannel(new Channel(target));\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_NEW);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tMessage message = new Message(sender + \" joined\");\n\t\t\tserver.getChannel(target).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Kick\n\t */\n\t@Override\n\tprotected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n\t{\n\t\tdebug(\"Kick\", target + \" \" + recipientNick + \"(\" + kickerNick + \")\");\n\t\t\n\t\tif (recipientNick.equals(getNick())) {\n\t\t\t// We are kicked\n\t\t\tserver.removeChannel(target);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_REMOVE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tMessage message = new Message(kickerNick + \" kicked \" + recipientNick);\n\t\t\tserver.getChannel(target).addMessage(message);\n\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\t\t\t\n\t\t}\n\t}\n\n\t/**\n\t * On Message\n\t */\n\t@Override\n\tprotected void onMessage(String target, String sender, String login, String hostname, String text)\n\t{\n\t\tdebug(\"Message\", target + \" \" + sender + \" \" + text);\n\n\t\tMessage message = new Message(\"<\" + sender + \"> \" + text);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Mode\n\t */\n\t@Override\n\tprotected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n\t{\n\t\tdebug(\"Mode\", target + \" \" + sourceNick + \" \" + mode);\n\t\t\n\t\tMessage message = new Message(sourceNick + \" sets mode \" + mode);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Nick Change\n\t */\n\t@Override\n\tprotected void onNickChange(String oldNick, String login, String hostname, String newNick)\n\t{\n\t\tdebug(\"Nick\", oldNick + \" \" + newNick);\n\t\t\n\t\t// XXX: Add message to all channels where oldNick / newNick is present\n\t}\n\n\t/**\n\t * On Notice\n\t */\n\t@Override\n\tprotected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n\t{\n\t\tdebug(\"Notice\", sourceNick + \" \" + notice);\n\n\t\t// XXX: Where should notices be shown? Current window? All windows? Server window?\n\t}\n\n\t/**\n\t * On Op\n\t */\n\t@Override\n\tprotected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Op\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" oped \" + recipient);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Part\n\t */\n\t@Override\n\tprotected void onPart(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Part\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We pareted a channel\n\t\t\tserver.removeChannel(target);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_REMOVE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tMessage message = new Message(sender + \" parted\");\n\t\t\tserver.getChannel(target).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Private Message\n\t */\n\t@Override\n\tprotected void onPrivateMessage(String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"PrivateMessage\", sender + \" \" + message);\n\t}\n\n\t/**\n\t * On Quit\n\t */\n\t@Override\n\tprotected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n\t{\n\t\tdebug(\"Quit\", sourceNick);\n\t}\n\n\t/**\n\t * On Topic\n\t */\n\t@Override\n\tprotected void onTopic(String target, String topic, String setBy, long date, boolean changed)\n\t{\n\t\tdebug(\"Topic\", target + \" \" + setBy + \" \" + topic);\n\t\t\n\t\tif (changed) {\n\t\t\tMessage message = new Message(setBy + \" sets topic: \" + topic);\n\t\t\tserver.getChannel(target).addMessage(message);\n\t\t} else {\n\t\t\tMessage message = new Message(\"Topic: \" + topic);\n\t\t\tserver.getChannel(target).addMessage(message);\n\t\t}\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On User List\n\t */\n\t@Override\n\tprotected void onUserList(String channel, User[] users)\n\t{\n\t\tdebug(\"UserList\", channel + \" (\" + users.length + \")\");\n\t\t\n\t\t// XXX: Store user list somewhere and keep it updated or just broadcast some event?\n\t}\n\n\t/**\n\t * On Voice\n\t */\n\t@Override\n\tprotected void onVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Voice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" voiced \" + recipient);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\t\n\t/**\n\t * On disconnect\n\t */\n\t@Override\n\tpublic void onDisconnect()\n\t{\n\t\tserver.setStatus(Status.DISCONNECTED);\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\n\t/**\n\t * Print an event to the debug console \n\t */\n\tprivate void debug(String event, String params)\n\t{\n\t\tif (DEBUG_EVENTS) {\n\t\t\tLog.d(TAG, \"(\" + server.getTitle() + \") [\" + event + \"]: \" + params);\n\t\t}\n\t}\n\t\n\t/**\n\t * Quits from the IRC server with default reason.\n\t */\n\t@Override\n\tpublic void quitServer()\n\t{\n\t\tquitServer(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n}\n","lineNo":296}
{"Smelly Sample":"/*\n Yaaic - Yet Another Android IRC Client\n\nCopyright 2009 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.irc;\n\nimport android.content.Intent;\nimport android.util.Log;\n\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\n\nimport org.yaaic.Yaaic;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.Status;\n\npublic class IRCConnection extends PircBot\n{\n\tprivate IRCService service;\n\tprivate Server server;\n\t\n\t// XXX: Print all IRC events to the debug console\n\tprivate static final boolean DEBUG_EVENTS = true;\n\tpublic static final String TAG = \"Yaaic/IRCConnection\";\n\t\n\t/**\n\t * Create a new connection\n\t * \n\t * @param service\n\t * @param serverId\n\t */\n\tpublic IRCConnection(IRCService service, int serverId)\n\t{\n\t\tthis.server = Yaaic.getInstance().getServerById(serverId);\n\t\tthis.service = service;\n\t\t\n\t\tthis.setName(\"Yaaic\");\n\t\tthis.setLogin(\"Yaaic\");\n\t\tthis.setAutoNickChange(true);\n\t\tthis.setVersion(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n\n\t/**\n\t * On connect\n\t */\n\t@Override\n\tpublic void onConnect()\n\t{\n\t\tdebug(\"Connect\", \"\");\n\t\t\n\t\tserver.setStatus(Status.CONNECTED);\n\t\t\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\t\n\t/**\n\t * On channel action\n\t */\n\t@Override\n\tprotected void onAction(String sender, String login, String hostname, String target, String action)\n\t{\n\t\tdebug(\"Action\", target + \" \" + sender + \" \" + action);\n\t\t\n\t\tserver.getChannel(target).addMessage(\"* \" + sender + \" \" + action);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Channel Info\n\t */\n\t@Override\n\tprotected void onChannelInfo(String channel, int userCount, String topic)\n\t{\n\t\tdebug(\"ChannelInfo\", channel + \" \" + userCount);\n\t}\n\n\t/**\n\t * On Deop\n\t */\n\t@Override\n\tprotected void onDeop(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Deop\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" deoped \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On DeVoice\n\t */\n\t@Override\n\tprotected void onDeVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"DeVoice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" devoiced \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Invite\n\t */\n\t@Override\n\tprotected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String target)\n\t{\n\t\tdebug(\"Invite\", target + \" \" + targetNick + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" invited \" + targetNick);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Join\n\t */\n\t@Override\n\tprotected void onJoin(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Join\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We joined a new channel\n\t\t\tserver.addChannel(new Channel(target));\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_NEW);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" joined\");\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Kick\n\t */\n\t@Override\n\tprotected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n\t{\n\t\tdebug(\"Kick\", target + \" \" + recipientNick + \"(\" + kickerNick + \")\");\n\t\t\n\t\tif (recipientNick.equals(getNick())) {\n\t\t\t// We are kicked\n\t\t\tserver.removeChannel(target);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_REMOVE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(kickerNick + \" kicked \" + recipientNick);\n\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\t\t\t\n\t\t}\n\t}\n\n\t/**\n\t * On Message\n\t */\n\t@Override\n\tprotected void onMessage(String target, String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"Message\", target + \" \" + sender + \" \" + message);\n\n\t\tserver.getChannel(target).addMessage(\"<\" + sender + \"> \" + message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Mode\n\t */\n\t@Override\n\tprotected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n\t{\n\t\tdebug(\"Mode\", target + \" \" + sourceNick + \" \" + mode);\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" sets mode \" + mode);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Nick Change\n\t */\n\t@Override\n\tprotected void onNickChange(String oldNick, String login, String hostname, String newNick)\n\t{\n\t\tdebug(\"Nick\", oldNick + \" \" + newNick);\n\t}\n\n\t/**\n\t * On Notice\n\t */\n\t@Override\n\tprotected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n\t{\n\t\tdebug(\"Notice\", sourceNick + \" \" + notice);\n\t}\n\n\t/**\n\t * On Op\n\t */\n\t@Override\n\tprotected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Op\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" oped \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Part\n\t */\n\t@Override\n\tprotected void onPart(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Part\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We pareted a channel\n\t\t\tserver.removeChannel(target);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_REMOVE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" parted\");\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Private Message\n\t */\n\t@Override\n\tprotected void onPrivateMessage(String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"PrivateMessage\", sender + \" \" + message);\n\t}\n\n\t/**\n\t * On Quit\n\t */\n\t@Override\n\tprotected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n\t{\n\t\tdebug(\"Quit\", sourceNick);\n\t}\n\n\t/**\n\t * On Topic\n\t */\n\t@Override\n\tprotected void onTopic(String target, String topic, String setBy, long date, boolean changed)\n\t{\n\t\tdebug(\"Topic\", target + \" \" + setBy + \" \" + topic);\n\t\t\n\t\tif (changed) {\n\t\t\tserver.getChannel(target).addMessage(setBy + \" sets topic: \" + topic);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(\"Topic: \" + topic);\n\t\t}\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On User List\n\t */\n\t@Override\n\tprotected void onUserList(String channel, User[] users)\n\t{\n\t\tdebug(\"UserList\", channel + \" (\" + users.length + \")\");\n\t}\n\n\t/**\n\t * On Voice\n\t */\n\t@Override\n\tprotected void onVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Voice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" voiced \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\t\n\t/**\n\t * On disconnect\n\t */\n\t@Override\n\tpublic void onDisconnect()\n\t{\n\t\tserver.setStatus(Status.DISCONNECTED);\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\n\t/**\n\t * Print an event to the debug console \n\t */\n\tprivate void debug(String event, String params)\n\t{\n\t\tif (DEBUG_EVENTS) {\n\t\t\tLog.d(TAG, \"(\" + server.getTitle() + \") [\" + event + \"]: \" + params);\n\t\t}\n\t}\n\t\n\t/**\n\t * Quits from the IRC server with default reason.\n\t */\n\t@Override\n\tpublic void quitServer()\n\t{\n\t\tquitServer(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n}\n","Method after Refactoring":"/*\n Yaaic - Yet Another Android IRC Client\n\nCopyright 2009 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.irc;\n\nimport android.content.Intent;\nimport android.util.Log;\n\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\n\nimport org.yaaic.Yaaic;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.Status;\n\npublic class IRCConnection extends PircBot\n{\n\tprivate IRCService service;\n\tprivate Server server;\n\t\n\t// XXX: Print all IRC events to the debug console\n\tprivate static final boolean DEBUG_EVENTS = true;\n\tpublic static final String TAG = \"Yaaic/IRCConnection\";\n\t\n\t/**\n\t * Create a new connection\n\t * \n\t * @param service\n\t * @param serverId\n\t */\n\tpublic IRCConnection(IRCService service, int serverId)\n\t{\n\t\tthis.server = Yaaic.getInstance().getServerById(serverId);\n\t\tthis.service = service;\n\t\t\n\t\tthis.setName(\"Yaaic\");\n\t\tthis.setLogin(\"Yaaic\");\n\t\tthis.setAutoNickChange(true);\n\t\tthis.setVersion(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n\n\t/**\n\t * On connect\n\t */\n\t@Override\n\tpublic void onConnect()\n\t{\n\t\tdebug(\"Connect\", \"\");\n\t\t\n\t\tserver.setStatus(Status.CONNECTED);\n\t\t\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\t\n\t/**\n\t * On channel action\n\t */\n\t@Override\n\tprotected void onAction(String sender, String login, String hostname, String target, String action)\n\t{\n\t\tdebug(\"Action\", target + \" \" + sender + \" \" + action);\n\t\t\n\t\tMessage message = new Message(sender + \" \" + action);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Channel Info\n\t */\n\t@Override\n\tprotected void onChannelInfo(String channel, int userCount, String topic)\n\t{\n\t\tdebug(\"ChannelInfo\", channel + \" \" + userCount);\n\t}\n\n\t/**\n\t * On Deop\n\t */\n\t@Override\n\tprotected void onDeop(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Deop\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" deoped \" + recipient);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On DeVoice\n\t */\n\t@Override\n\tprotected void onDeVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"DeVoice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" devoiced \" + recipient);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Invite\n\t */\n\t@Override\n\tprotected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String target)\n\t{\n\t\tdebug(\"Invite\", target + \" \" + targetNick + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" invited \" + targetNick);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Join\n\t */\n\t@Override\n\tprotected void onJoin(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Join\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We joined a new channel\n\t\t\tserver.addChannel(new Channel(target));\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_NEW);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tMessage message = new Message(sender + \" joined\");\n\t\t\tserver.getChannel(target).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Kick\n\t */\n\t@Override\n\tprotected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n\t{\n\t\tdebug(\"Kick\", target + \" \" + recipientNick + \"(\" + kickerNick + \")\");\n\t\t\n\t\tif (recipientNick.equals(getNick())) {\n\t\t\t// We are kicked\n\t\t\tserver.removeChannel(target);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_REMOVE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tMessage message = new Message(kickerNick + \" kicked \" + recipientNick);\n\t\t\tserver.getChannel(target).addMessage(message);\n\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\t\t\t\n\t\t}\n\t}\n\n\t/**\n\t * On Message\n\t */\n\t@Override\n\tprotected void onMessage(String target, String sender, String login, String hostname, String text)\n\t{\n\t\tdebug(\"Message\", target + \" \" + sender + \" \" + text);\n\n\t\tMessage message = new Message(\"<\" + sender + \"> \" + text);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Mode\n\t */\n\t@Override\n\tprotected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n\t{\n\t\tdebug(\"Mode\", target + \" \" + sourceNick + \" \" + mode);\n\t\t\n\t\tMessage message = new Message(sourceNick + \" sets mode \" + mode);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Nick Change\n\t */\n\t@Override\n\tprotected void onNickChange(String oldNick, String login, String hostname, String newNick)\n\t{\n\t\tdebug(\"Nick\", oldNick + \" \" + newNick);\n\t\t\n\t\t// XXX: Add message to all channels where oldNick / newNick is present\n\t}\n\n\t/**\n\t * On Notice\n\t */\n\t@Override\n\tprotected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n\t{\n\t\tdebug(\"Notice\", sourceNick + \" \" + notice);\n\n\t\t// XXX: Where should notices be shown? Current window? All windows? Server window?\n\t}\n\n\t/**\n\t * On Op\n\t */\n\t@Override\n\tprotected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Op\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" oped \" + recipient);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Part\n\t */\n\t@Override\n\tprotected void onPart(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Part\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We pareted a channel\n\t\t\tserver.removeChannel(target);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_REMOVE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tMessage message = new Message(sender + \" parted\");\n\t\t\tserver.getChannel(target).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Private Message\n\t */\n\t@Override\n\tprotected void onPrivateMessage(String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"PrivateMessage\", sender + \" \" + message);\n\t}\n\n\t/**\n\t * On Quit\n\t */\n\t@Override\n\tprotected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n\t{\n\t\tdebug(\"Quit\", sourceNick);\n\t}\n\n\t/**\n\t * On Topic\n\t */\n\t@Override\n\tprotected void onTopic(String target, String topic, String setBy, long date, boolean changed)\n\t{\n\t\tdebug(\"Topic\", target + \" \" + setBy + \" \" + topic);\n\t\t\n\t\tif (changed) {\n\t\t\tMessage message = new Message(setBy + \" sets topic: \" + topic);\n\t\t\tserver.getChannel(target).addMessage(message);\n\t\t} else {\n\t\t\tMessage message = new Message(\"Topic: \" + topic);\n\t\t\tserver.getChannel(target).addMessage(message);\n\t\t}\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On User List\n\t */\n\t@Override\n\tprotected void onUserList(String channel, User[] users)\n\t{\n\t\tdebug(\"UserList\", channel + \" (\" + users.length + \")\");\n\t\t\n\t\t// XXX: Store user list somewhere and keep it updated or just broadcast some event?\n\t}\n\n\t/**\n\t * On Voice\n\t */\n\t@Override\n\tprotected void onVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Voice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" voiced \" + recipient);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\t\n\t/**\n\t * On disconnect\n\t */\n\t@Override\n\tpublic void onDisconnect()\n\t{\n\t\tserver.setStatus(Status.DISCONNECTED);\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\n\t/**\n\t * Print an event to the debug console \n\t */\n\tprivate void debug(String event, String params)\n\t{\n\t\tif (DEBUG_EVENTS) {\n\t\t\tLog.d(TAG, \"(\" + server.getTitle() + \") [\" + event + \"]: \" + params);\n\t\t}\n\t}\n\t\n\t/**\n\t * Quits from the IRC server with default reason.\n\t */\n\t@Override\n\tpublic void quitServer()\n\t{\n\t\tquitServer(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n}\n","lineNo":333}
{"Smelly Sample":"/*\n Yaaic - Yet Another Android IRC Client\n\nCopyright 2009 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.irc;\n\nimport android.content.Intent;\nimport android.util.Log;\n\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\n\nimport org.yaaic.Yaaic;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.Status;\n\npublic class IRCConnection extends PircBot\n{\n\tprivate IRCService service;\n\tprivate Server server;\n\t\n\t// XXX: Print all IRC events to the debug console\n\tprivate static final boolean DEBUG_EVENTS = true;\n\tpublic static final String TAG = \"Yaaic/IRCConnection\";\n\t\n\t/**\n\t * Create a new connection\n\t * \n\t * @param service\n\t * @param serverId\n\t */\n\tpublic IRCConnection(IRCService service, int serverId)\n\t{\n\t\tthis.server = Yaaic.getInstance().getServerById(serverId);\n\t\tthis.service = service;\n\t\t\n\t\tthis.setName(\"Yaaic\");\n\t\tthis.setLogin(\"Yaaic\");\n\t\tthis.setAutoNickChange(true);\n\t\tthis.setVersion(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n\n\t/**\n\t * On connect\n\t */\n\t@Override\n\tpublic void onConnect()\n\t{\n\t\tdebug(\"Connect\", \"\");\n\t\t\n\t\tserver.setStatus(Status.CONNECTED);\n\t\t\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\t\n\t/**\n\t * On channel action\n\t */\n\t@Override\n\tprotected void onAction(String sender, String login, String hostname, String target, String action)\n\t{\n\t\tdebug(\"Action\", target + \" \" + sender + \" \" + action);\n\t\t\n\t\tserver.getChannel(target).addMessage(\"* \" + sender + \" \" + action);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Channel Info\n\t */\n\t@Override\n\tprotected void onChannelInfo(String channel, int userCount, String topic)\n\t{\n\t\tdebug(\"ChannelInfo\", channel + \" \" + userCount);\n\t}\n\n\t/**\n\t * On Deop\n\t */\n\t@Override\n\tprotected void onDeop(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Deop\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" deoped \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On DeVoice\n\t */\n\t@Override\n\tprotected void onDeVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"DeVoice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" devoiced \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Invite\n\t */\n\t@Override\n\tprotected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String target)\n\t{\n\t\tdebug(\"Invite\", target + \" \" + targetNick + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" invited \" + targetNick);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Join\n\t */\n\t@Override\n\tprotected void onJoin(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Join\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We joined a new channel\n\t\t\tserver.addChannel(new Channel(target));\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_NEW);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" joined\");\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Kick\n\t */\n\t@Override\n\tprotected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n\t{\n\t\tdebug(\"Kick\", target + \" \" + recipientNick + \"(\" + kickerNick + \")\");\n\t\t\n\t\tif (recipientNick.equals(getNick())) {\n\t\t\t// We are kicked\n\t\t\tserver.removeChannel(target);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_REMOVE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(kickerNick + \" kicked \" + recipientNick);\n\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\t\t\t\n\t\t}\n\t}\n\n\t/**\n\t * On Message\n\t */\n\t@Override\n\tprotected void onMessage(String target, String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"Message\", target + \" \" + sender + \" \" + message);\n\n\t\tserver.getChannel(target).addMessage(\"<\" + sender + \"> \" + message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Mode\n\t */\n\t@Override\n\tprotected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n\t{\n\t\tdebug(\"Mode\", target + \" \" + sourceNick + \" \" + mode);\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" sets mode \" + mode);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Nick Change\n\t */\n\t@Override\n\tprotected void onNickChange(String oldNick, String login, String hostname, String newNick)\n\t{\n\t\tdebug(\"Nick\", oldNick + \" \" + newNick);\n\t}\n\n\t/**\n\t * On Notice\n\t */\n\t@Override\n\tprotected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n\t{\n\t\tdebug(\"Notice\", sourceNick + \" \" + notice);\n\t}\n\n\t/**\n\t * On Op\n\t */\n\t@Override\n\tprotected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Op\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" oped \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Part\n\t */\n\t@Override\n\tprotected void onPart(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Part\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We pareted a channel\n\t\t\tserver.removeChannel(target);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_REMOVE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" parted\");\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Private Message\n\t */\n\t@Override\n\tprotected void onPrivateMessage(String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"PrivateMessage\", sender + \" \" + message);\n\t}\n\n\t/**\n\t * On Quit\n\t */\n\t@Override\n\tprotected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n\t{\n\t\tdebug(\"Quit\", sourceNick);\n\t}\n\n\t/**\n\t * On Topic\n\t */\n\t@Override\n\tprotected void onTopic(String target, String topic, String setBy, long date, boolean changed)\n\t{\n\t\tdebug(\"Topic\", target + \" \" + setBy + \" \" + topic);\n\t\t\n\t\tif (changed) {\n\t\t\tserver.getChannel(target).addMessage(setBy + \" sets topic: \" + topic);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(\"Topic: \" + topic);\n\t\t}\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On User List\n\t */\n\t@Override\n\tprotected void onUserList(String channel, User[] users)\n\t{\n\t\tdebug(\"UserList\", channel + \" (\" + users.length + \")\");\n\t}\n\n\t/**\n\t * On Voice\n\t */\n\t@Override\n\tprotected void onVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Voice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" voiced \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\t\n\t/**\n\t * On disconnect\n\t */\n\t@Override\n\tpublic void onDisconnect()\n\t{\n\t\tserver.setStatus(Status.DISCONNECTED);\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\n\t/**\n\t * Print an event to the debug console \n\t */\n\tprivate void debug(String event, String params)\n\t{\n\t\tif (DEBUG_EVENTS) {\n\t\t\tLog.d(TAG, \"(\" + server.getTitle() + \") [\" + event + \"]: \" + params);\n\t\t}\n\t}\n\t\n\t/**\n\t * Quits from the IRC server with default reason.\n\t */\n\t@Override\n\tpublic void quitServer()\n\t{\n\t\tquitServer(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n}\n","Method after Refactoring":"/*\n Yaaic - Yet Another Android IRC Client\n\nCopyright 2009 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.irc;\n\nimport android.content.Intent;\nimport android.util.Log;\n\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\n\nimport org.yaaic.Yaaic;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.Status;\n\npublic class IRCConnection extends PircBot\n{\n\tprivate IRCService service;\n\tprivate Server server;\n\t\n\t// XXX: Print all IRC events to the debug console\n\tprivate static final boolean DEBUG_EVENTS = true;\n\tpublic static final String TAG = \"Yaaic/IRCConnection\";\n\t\n\t/**\n\t * Create a new connection\n\t * \n\t * @param service\n\t * @param serverId\n\t */\n\tpublic IRCConnection(IRCService service, int serverId)\n\t{\n\t\tthis.server = Yaaic.getInstance().getServerById(serverId);\n\t\tthis.service = service;\n\t\t\n\t\tthis.setName(\"Yaaic\");\n\t\tthis.setLogin(\"Yaaic\");\n\t\tthis.setAutoNickChange(true);\n\t\tthis.setVersion(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n\n\t/**\n\t * On connect\n\t */\n\t@Override\n\tpublic void onConnect()\n\t{\n\t\tdebug(\"Connect\", \"\");\n\t\t\n\t\tserver.setStatus(Status.CONNECTED);\n\t\t\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\t\n\t/**\n\t * On channel action\n\t */\n\t@Override\n\tprotected void onAction(String sender, String login, String hostname, String target, String action)\n\t{\n\t\tdebug(\"Action\", target + \" \" + sender + \" \" + action);\n\t\t\n\t\tMessage message = new Message(sender + \" \" + action);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Channel Info\n\t */\n\t@Override\n\tprotected void onChannelInfo(String channel, int userCount, String topic)\n\t{\n\t\tdebug(\"ChannelInfo\", channel + \" \" + userCount);\n\t}\n\n\t/**\n\t * On Deop\n\t */\n\t@Override\n\tprotected void onDeop(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Deop\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" deoped \" + recipient);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On DeVoice\n\t */\n\t@Override\n\tprotected void onDeVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"DeVoice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" devoiced \" + recipient);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Invite\n\t */\n\t@Override\n\tprotected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String target)\n\t{\n\t\tdebug(\"Invite\", target + \" \" + targetNick + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" invited \" + targetNick);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Join\n\t */\n\t@Override\n\tprotected void onJoin(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Join\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We joined a new channel\n\t\t\tserver.addChannel(new Channel(target));\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_NEW);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tMessage message = new Message(sender + \" joined\");\n\t\t\tserver.getChannel(target).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Kick\n\t */\n\t@Override\n\tprotected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n\t{\n\t\tdebug(\"Kick\", target + \" \" + recipientNick + \"(\" + kickerNick + \")\");\n\t\t\n\t\tif (recipientNick.equals(getNick())) {\n\t\t\t// We are kicked\n\t\t\tserver.removeChannel(target);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_REMOVE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tMessage message = new Message(kickerNick + \" kicked \" + recipientNick);\n\t\t\tserver.getChannel(target).addMessage(message);\n\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\t\t\t\n\t\t}\n\t}\n\n\t/**\n\t * On Message\n\t */\n\t@Override\n\tprotected void onMessage(String target, String sender, String login, String hostname, String text)\n\t{\n\t\tdebug(\"Message\", target + \" \" + sender + \" \" + text);\n\n\t\tMessage message = new Message(\"<\" + sender + \"> \" + text);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Mode\n\t */\n\t@Override\n\tprotected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n\t{\n\t\tdebug(\"Mode\", target + \" \" + sourceNick + \" \" + mode);\n\t\t\n\t\tMessage message = new Message(sourceNick + \" sets mode \" + mode);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Nick Change\n\t */\n\t@Override\n\tprotected void onNickChange(String oldNick, String login, String hostname, String newNick)\n\t{\n\t\tdebug(\"Nick\", oldNick + \" \" + newNick);\n\t\t\n\t\t// XXX: Add message to all channels where oldNick / newNick is present\n\t}\n\n\t/**\n\t * On Notice\n\t */\n\t@Override\n\tprotected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n\t{\n\t\tdebug(\"Notice\", sourceNick + \" \" + notice);\n\n\t\t// XXX: Where should notices be shown? Current window? All windows? Server window?\n\t}\n\n\t/**\n\t * On Op\n\t */\n\t@Override\n\tprotected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Op\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" oped \" + recipient);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Part\n\t */\n\t@Override\n\tprotected void onPart(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Part\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We pareted a channel\n\t\t\tserver.removeChannel(target);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_REMOVE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tMessage message = new Message(sender + \" parted\");\n\t\t\tserver.getChannel(target).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Private Message\n\t */\n\t@Override\n\tprotected void onPrivateMessage(String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"PrivateMessage\", sender + \" \" + message);\n\t}\n\n\t/**\n\t * On Quit\n\t */\n\t@Override\n\tprotected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n\t{\n\t\tdebug(\"Quit\", sourceNick);\n\t}\n\n\t/**\n\t * On Topic\n\t */\n\t@Override\n\tprotected void onTopic(String target, String topic, String setBy, long date, boolean changed)\n\t{\n\t\tdebug(\"Topic\", target + \" \" + setBy + \" \" + topic);\n\t\t\n\t\tif (changed) {\n\t\t\tMessage message = new Message(setBy + \" sets topic: \" + topic);\n\t\t\tserver.getChannel(target).addMessage(message);\n\t\t} else {\n\t\t\tMessage message = new Message(\"Topic: \" + topic);\n\t\t\tserver.getChannel(target).addMessage(message);\n\t\t}\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On User List\n\t */\n\t@Override\n\tprotected void onUserList(String channel, User[] users)\n\t{\n\t\tdebug(\"UserList\", channel + \" (\" + users.length + \")\");\n\t\t\n\t\t// XXX: Store user list somewhere and keep it updated or just broadcast some event?\n\t}\n\n\t/**\n\t * On Voice\n\t */\n\t@Override\n\tprotected void onVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Voice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" voiced \" + recipient);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\t\n\t/**\n\t * On disconnect\n\t */\n\t@Override\n\tpublic void onDisconnect()\n\t{\n\t\tserver.setStatus(Status.DISCONNECTED);\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\n\t/**\n\t * Print an event to the debug console \n\t */\n\tprivate void debug(String event, String params)\n\t{\n\t\tif (DEBUG_EVENTS) {\n\t\t\tLog.d(TAG, \"(\" + server.getTitle() + \") [\" + event + \"]: \" + params);\n\t\t}\n\t}\n\t\n\t/**\n\t * Quits from the IRC server with default reason.\n\t */\n\t@Override\n\tpublic void quitServer()\n\t{\n\t\tquitServer(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n}\n","lineNo":336}
{"Smelly Sample":"/*\n Yaaic - Yet Another Android IRC Client\n\nCopyright 2009 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.irc;\n\nimport android.content.Intent;\nimport android.util.Log;\n\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\n\nimport org.yaaic.Yaaic;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.Status;\n\npublic class IRCConnection extends PircBot\n{\n\tprivate IRCService service;\n\tprivate Server server;\n\t\n\t// XXX: Print all IRC events to the debug console\n\tprivate static final boolean DEBUG_EVENTS = true;\n\tpublic static final String TAG = \"Yaaic/IRCConnection\";\n\t\n\t/**\n\t * Create a new connection\n\t * \n\t * @param service\n\t * @param serverId\n\t */\n\tpublic IRCConnection(IRCService service, int serverId)\n\t{\n\t\tthis.server = Yaaic.getInstance().getServerById(serverId);\n\t\tthis.service = service;\n\t\t\n\t\tthis.setName(\"Yaaic\");\n\t\tthis.setLogin(\"Yaaic\");\n\t\tthis.setAutoNickChange(true);\n\t\tthis.setVersion(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n\n\t/**\n\t * On connect\n\t */\n\t@Override\n\tpublic void onConnect()\n\t{\n\t\tdebug(\"Connect\", \"\");\n\t\t\n\t\tserver.setStatus(Status.CONNECTED);\n\t\t\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\t\n\t/**\n\t * On channel action\n\t */\n\t@Override\n\tprotected void onAction(String sender, String login, String hostname, String target, String action)\n\t{\n\t\tdebug(\"Action\", target + \" \" + sender + \" \" + action);\n\t\t\n\t\tserver.getChannel(target).addMessage(\"* \" + sender + \" \" + action);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Channel Info\n\t */\n\t@Override\n\tprotected void onChannelInfo(String channel, int userCount, String topic)\n\t{\n\t\tdebug(\"ChannelInfo\", channel + \" \" + userCount);\n\t}\n\n\t/**\n\t * On Deop\n\t */\n\t@Override\n\tprotected void onDeop(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Deop\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" deoped \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On DeVoice\n\t */\n\t@Override\n\tprotected void onDeVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"DeVoice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" devoiced \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Invite\n\t */\n\t@Override\n\tprotected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String target)\n\t{\n\t\tdebug(\"Invite\", target + \" \" + targetNick + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" invited \" + targetNick);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Join\n\t */\n\t@Override\n\tprotected void onJoin(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Join\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We joined a new channel\n\t\t\tserver.addChannel(new Channel(target));\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_NEW);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" joined\");\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Kick\n\t */\n\t@Override\n\tprotected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n\t{\n\t\tdebug(\"Kick\", target + \" \" + recipientNick + \"(\" + kickerNick + \")\");\n\t\t\n\t\tif (recipientNick.equals(getNick())) {\n\t\t\t// We are kicked\n\t\t\tserver.removeChannel(target);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_REMOVE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(kickerNick + \" kicked \" + recipientNick);\n\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\t\t\t\n\t\t}\n\t}\n\n\t/**\n\t * On Message\n\t */\n\t@Override\n\tprotected void onMessage(String target, String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"Message\", target + \" \" + sender + \" \" + message);\n\n\t\tserver.getChannel(target).addMessage(\"<\" + sender + \"> \" + message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Mode\n\t */\n\t@Override\n\tprotected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n\t{\n\t\tdebug(\"Mode\", target + \" \" + sourceNick + \" \" + mode);\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" sets mode \" + mode);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Nick Change\n\t */\n\t@Override\n\tprotected void onNickChange(String oldNick, String login, String hostname, String newNick)\n\t{\n\t\tdebug(\"Nick\", oldNick + \" \" + newNick);\n\t}\n\n\t/**\n\t * On Notice\n\t */\n\t@Override\n\tprotected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n\t{\n\t\tdebug(\"Notice\", sourceNick + \" \" + notice);\n\t}\n\n\t/**\n\t * On Op\n\t */\n\t@Override\n\tprotected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Op\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" oped \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Part\n\t */\n\t@Override\n\tprotected void onPart(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Part\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We pareted a channel\n\t\t\tserver.removeChannel(target);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_REMOVE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" parted\");\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Private Message\n\t */\n\t@Override\n\tprotected void onPrivateMessage(String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"PrivateMessage\", sender + \" \" + message);\n\t}\n\n\t/**\n\t * On Quit\n\t */\n\t@Override\n\tprotected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n\t{\n\t\tdebug(\"Quit\", sourceNick);\n\t}\n\n\t/**\n\t * On Topic\n\t */\n\t@Override\n\tprotected void onTopic(String target, String topic, String setBy, long date, boolean changed)\n\t{\n\t\tdebug(\"Topic\", target + \" \" + setBy + \" \" + topic);\n\t\t\n\t\tif (changed) {\n\t\t\tserver.getChannel(target).addMessage(setBy + \" sets topic: \" + topic);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(\"Topic: \" + topic);\n\t\t}\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On User List\n\t */\n\t@Override\n\tprotected void onUserList(String channel, User[] users)\n\t{\n\t\tdebug(\"UserList\", channel + \" (\" + users.length + \")\");\n\t}\n\n\t/**\n\t * On Voice\n\t */\n\t@Override\n\tprotected void onVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Voice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" voiced \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\t\n\t/**\n\t * On disconnect\n\t */\n\t@Override\n\tpublic void onDisconnect()\n\t{\n\t\tserver.setStatus(Status.DISCONNECTED);\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\n\t/**\n\t * Print an event to the debug console \n\t */\n\tprivate void debug(String event, String params)\n\t{\n\t\tif (DEBUG_EVENTS) {\n\t\t\tLog.d(TAG, \"(\" + server.getTitle() + \") [\" + event + \"]: \" + params);\n\t\t}\n\t}\n\t\n\t/**\n\t * Quits from the IRC server with default reason.\n\t */\n\t@Override\n\tpublic void quitServer()\n\t{\n\t\tquitServer(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n}\n","Method after Refactoring":"/*\n Yaaic - Yet Another Android IRC Client\n\nCopyright 2009 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.irc;\n\nimport android.content.Intent;\nimport android.util.Log;\n\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\n\nimport org.yaaic.Yaaic;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Message;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.Status;\n\npublic class IRCConnection extends PircBot\n{\n\tprivate IRCService service;\n\tprivate Server server;\n\t\n\t// XXX: Print all IRC events to the debug console\n\tprivate static final boolean DEBUG_EVENTS = true;\n\tpublic static final String TAG = \"Yaaic/IRCConnection\";\n\t\n\t/**\n\t * Create a new connection\n\t * \n\t * @param service\n\t * @param serverId\n\t */\n\tpublic IRCConnection(IRCService service, int serverId)\n\t{\n\t\tthis.server = Yaaic.getInstance().getServerById(serverId);\n\t\tthis.service = service;\n\t\t\n\t\tthis.setName(\"Yaaic\");\n\t\tthis.setLogin(\"Yaaic\");\n\t\tthis.setAutoNickChange(true);\n\t\tthis.setVersion(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n\n\t/**\n\t * On connect\n\t */\n\t@Override\n\tpublic void onConnect()\n\t{\n\t\tdebug(\"Connect\", \"\");\n\t\t\n\t\tserver.setStatus(Status.CONNECTED);\n\t\t\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\t\n\t/**\n\t * On channel action\n\t */\n\t@Override\n\tprotected void onAction(String sender, String login, String hostname, String target, String action)\n\t{\n\t\tdebug(\"Action\", target + \" \" + sender + \" \" + action);\n\t\t\n\t\tMessage message = new Message(sender + \" \" + action);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Channel Info\n\t */\n\t@Override\n\tprotected void onChannelInfo(String channel, int userCount, String topic)\n\t{\n\t\tdebug(\"ChannelInfo\", channel + \" \" + userCount);\n\t}\n\n\t/**\n\t * On Deop\n\t */\n\t@Override\n\tprotected void onDeop(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Deop\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" deoped \" + recipient);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On DeVoice\n\t */\n\t@Override\n\tprotected void onDeVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"DeVoice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" devoiced \" + recipient);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Invite\n\t */\n\t@Override\n\tprotected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String target)\n\t{\n\t\tdebug(\"Invite\", target + \" \" + targetNick + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" invited \" + targetNick);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Join\n\t */\n\t@Override\n\tprotected void onJoin(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Join\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We joined a new channel\n\t\t\tserver.addChannel(new Channel(target));\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_NEW);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tMessage message = new Message(sender + \" joined\");\n\t\t\tserver.getChannel(target).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Kick\n\t */\n\t@Override\n\tprotected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n\t{\n\t\tdebug(\"Kick\", target + \" \" + recipientNick + \"(\" + kickerNick + \")\");\n\t\t\n\t\tif (recipientNick.equals(getNick())) {\n\t\t\t// We are kicked\n\t\t\tserver.removeChannel(target);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_REMOVE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tMessage message = new Message(kickerNick + \" kicked \" + recipientNick);\n\t\t\tserver.getChannel(target).addMessage(message);\n\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\t\t\t\n\t\t}\n\t}\n\n\t/**\n\t * On Message\n\t */\n\t@Override\n\tprotected void onMessage(String target, String sender, String login, String hostname, String text)\n\t{\n\t\tdebug(\"Message\", target + \" \" + sender + \" \" + text);\n\n\t\tMessage message = new Message(\"<\" + sender + \"> \" + text);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Mode\n\t */\n\t@Override\n\tprotected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n\t{\n\t\tdebug(\"Mode\", target + \" \" + sourceNick + \" \" + mode);\n\t\t\n\t\tMessage message = new Message(sourceNick + \" sets mode \" + mode);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Nick Change\n\t */\n\t@Override\n\tprotected void onNickChange(String oldNick, String login, String hostname, String newNick)\n\t{\n\t\tdebug(\"Nick\", oldNick + \" \" + newNick);\n\t\t\n\t\t// XXX: Add message to all channels where oldNick / newNick is present\n\t}\n\n\t/**\n\t * On Notice\n\t */\n\t@Override\n\tprotected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n\t{\n\t\tdebug(\"Notice\", sourceNick + \" \" + notice);\n\n\t\t// XXX: Where should notices be shown? Current window? All windows? Server window?\n\t}\n\n\t/**\n\t * On Op\n\t */\n\t@Override\n\tprotected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Op\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" oped \" + recipient);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Part\n\t */\n\t@Override\n\tprotected void onPart(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Part\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We pareted a channel\n\t\t\tserver.removeChannel(target);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_REMOVE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tMessage message = new Message(sender + \" parted\");\n\t\t\tserver.getChannel(target).addMessage(message);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Private Message\n\t */\n\t@Override\n\tprotected void onPrivateMessage(String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"PrivateMessage\", sender + \" \" + message);\n\t}\n\n\t/**\n\t * On Quit\n\t */\n\t@Override\n\tprotected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n\t{\n\t\tdebug(\"Quit\", sourceNick);\n\t}\n\n\t/**\n\t * On Topic\n\t */\n\t@Override\n\tprotected void onTopic(String target, String topic, String setBy, long date, boolean changed)\n\t{\n\t\tdebug(\"Topic\", target + \" \" + setBy + \" \" + topic);\n\t\t\n\t\tif (changed) {\n\t\t\tMessage message = new Message(setBy + \" sets topic: \" + topic);\n\t\t\tserver.getChannel(target).addMessage(message);\n\t\t} else {\n\t\t\tMessage message = new Message(\"Topic: \" + topic);\n\t\t\tserver.getChannel(target).addMessage(message);\n\t\t}\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On User List\n\t */\n\t@Override\n\tprotected void onUserList(String channel, User[] users)\n\t{\n\t\tdebug(\"UserList\", channel + \" (\" + users.length + \")\");\n\t\t\n\t\t// XXX: Store user list somewhere and keep it updated or just broadcast some event?\n\t}\n\n\t/**\n\t * On Voice\n\t */\n\t@Override\n\tprotected void onVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Voice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tMessage message = new Message(sourceNick + \" voiced \" + recipient);\n\t\tserver.getChannel(target).addMessage(message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_SERVER, server.getId());\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\t\n\t/**\n\t * On disconnect\n\t */\n\t@Override\n\tpublic void onDisconnect()\n\t{\n\t\tserver.setStatus(Status.DISCONNECTED);\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\n\t/**\n\t * Print an event to the debug console \n\t */\n\tprivate void debug(String event, String params)\n\t{\n\t\tif (DEBUG_EVENTS) {\n\t\t\tLog.d(TAG, \"(\" + server.getTitle() + \") [\" + event + \"]: \" + params);\n\t\t}\n\t}\n\t\n\t/**\n\t * Quits from the IRC server with default reason.\n\t */\n\t@Override\n\tpublic void quitServer()\n\t{\n\t\tquitServer(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n}\n","lineNo":365}
{"Smelly Sample":"/*\n Yaaic - Yet Another Android IRC Client\n\nCopyright 2009 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.irc;\n\nimport android.content.Intent;\nimport android.util.Log;\n\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\n\nimport org.yaaic.Yaaic;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.Status;\n\npublic class IRCConnection extends PircBot\n{\n\tprivate IRCService service;\n\tprivate Server server;\n\t\n\t// XXX: Print all IRC events to the debug console\n\tprivate static final boolean DEBUG_EVENTS = true;\n\tpublic static final String TAG = \"Yaaic/IRCConnection\";\n\t\n\t/**\n\t * Create a new connection\n\t * \n\t * @param service\n\t * @param serverId\n\t */\n\tpublic IRCConnection(IRCService service, int serverId)\n\t{\n\t\tthis.server = Yaaic.getInstance().getServerById(serverId);\n\t\tthis.service = service;\n\t\t\n\t\tthis.setName(\"Yaaic\");\n\t\tthis.setLogin(\"Yaaic\");\n\t\tthis.setAutoNickChange(true);\n\t\tthis.setVersion(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n\n\t/**\n\t * On connect\n\t */\n\t@Override\n\tpublic void onConnect()\n\t{\n\t\tdebug(\"Connect\", \"\");\n\t\t\n\t\tserver.setStatus(Status.CONNECTED);\n\t\t\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\t\n\t/**\n\t * On channel action\n\t */\n\t@Override\n\tprotected void onAction(String sender, String login, String hostname, String target, String action)\n\t{\n\t\tdebug(\"Action\", target + \" \" + sender + \" \" + action);\n\t\t\n\t\tserver.getChannel(target).addMessage(\"* \" + sender + \" \" + action);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Channel Info\n\t */\n\t@Override\n\tprotected void onChannelInfo(String channel, int userCount, String topic)\n\t{\n\t\tdebug(\"ChannelInfo\", channel + \" \" + userCount);\n\t}\n\n\t/**\n\t * On Deop\n\t */\n\t@Override\n\tprotected void onDeop(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Deop\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" deoped \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On DeVoice\n\t */\n\t@Override\n\tprotected void onDeVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"DeVoice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" devoiced \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Invite\n\t */\n\t@Override\n\tprotected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String target)\n\t{\n\t\tdebug(\"Invite\", target + \" \" + targetNick + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" invited \" + targetNick);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Join\n\t */\n\t@Override\n\tprotected void onJoin(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Join\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We joined a new channel\n\t\t\tserver.addChannel(new Channel(target));\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_NEW));\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" joined\");\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Kick\n\t */\n\t@Override\n\tprotected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n\t{\n\t\tdebug(\"Kick\", target + \" \" + recipientNick + \"(\" + kickerNick + \")\");\n\t\t\n\t\tif (recipientNick.equals(getNick())) {\n\t\t\t// We are kicked\n\t\t\tserver.removeChannel(target);\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_REMOVE));\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(kickerNick + \" kicked \" + recipientNick);\n\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\t\t\t\n\t\t}\n\t}\n\n\t/**\n\t * On Message\n\t */\n\t@Override\n\tprotected void onMessage(String target, String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"Message\", target + \" \" + sender + \" \" + message);\n\n\t\tserver.getChannel(target).addMessage(\"<\" + sender + \"> \" + message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Mode\n\t */\n\t@Override\n\tprotected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n\t{\n\t\tdebug(\"Mode\", target + \" \" + sourceNick + \" \" + mode);\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" sets mode \" + mode);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Nick Change\n\t */\n\t@Override\n\tprotected void onNickChange(String oldNick, String login, String hostname, String newNick)\n\t{\n\t\tdebug(\"Nick\", oldNick + \" \" + newNick);\n\t}\n\n\t/**\n\t * On Notice\n\t */\n\t@Override\n\tprotected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n\t{\n\t\tdebug(\"Notice\", sourceNick + \" \" + notice);\n\t}\n\n\t/**\n\t * On Op\n\t */\n\t@Override\n\tprotected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Op\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" oped \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Part\n\t */\n\t@Override\n\tprotected void onPart(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Part\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We pareted a channel\n\t\t\tserver.removeChannel(target);\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_REMOVE));\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" parted\");\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Private Message\n\t */\n\t@Override\n\tprotected void onPrivateMessage(String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"PrivateMessage\", sender + \" \" + message);\n\t}\n\n\t/**\n\t * On Quit\n\t */\n\t@Override\n\tprotected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n\t{\n\t\tdebug(\"Quit\", sourceNick);\n\t}\n\n\t/**\n\t * On Topic\n\t */\n\t@Override\n\tprotected void onTopic(String target, String topic, String setBy, long date, boolean changed)\n\t{\n\t\tdebug(\"Topic\", target + \" \" + setBy + \" \" + topic);\n\t\t\n\t\tif (changed) {\n\t\t\tserver.getChannel(target).addMessage(setBy + \" sets topic: \" + topic);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(\"Topic: \" + topic);\n\t\t}\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On User List\n\t */\n\t@Override\n\tprotected void onUserList(String channel, User[] users)\n\t{\n\t\tdebug(\"UserList\", channel + \" (\" + users.length + \")\");\n\t}\n\n\t/**\n\t * On Voice\n\t */\n\t@Override\n\tprotected void onVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Voice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" voiced \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\t\n\t/**\n\t * On disconnect\n\t */\n\t@Override\n\tpublic void onDisconnect()\n\t{\n\t\tserver.setStatus(Status.DISCONNECTED);\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\n\t/**\n\t * Print an event to the debug console \n\t */\n\tprivate void debug(String event, String params)\n\t{\n\t\tif (DEBUG_EVENTS) {\n\t\t\tLog.d(TAG, \"(\" + server.getTitle() + \") [\" + event + \"]: \" + params);\n\t\t}\n\t}\n\t\n\t/**\n\t * Quits from the IRC server with default reason.\n\t */\n\t@Override\n\tpublic void quitServer()\n\t{\n\t\tquitServer(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n}\n","Method after Refactoring":"/*\n Yaaic - Yet Another Android IRC Client\n\nCopyright 2009 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.irc;\n\nimport android.content.Intent;\nimport android.util.Log;\n\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\n\nimport org.yaaic.Yaaic;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.Status;\n\npublic class IRCConnection extends PircBot\n{\n\tprivate IRCService service;\n\tprivate Server server;\n\t\n\t// XXX: Print all IRC events to the debug console\n\tprivate static final boolean DEBUG_EVENTS = true;\n\tpublic static final String TAG = \"Yaaic/IRCConnection\";\n\t\n\t/**\n\t * Create a new connection\n\t * \n\t * @param service\n\t * @param serverId\n\t */\n\tpublic IRCConnection(IRCService service, int serverId)\n\t{\n\t\tthis.server = Yaaic.getInstance().getServerById(serverId);\n\t\tthis.service = service;\n\t\t\n\t\tthis.setName(\"Yaaic\");\n\t\tthis.setLogin(\"Yaaic\");\n\t\tthis.setAutoNickChange(true);\n\t\tthis.setVersion(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n\n\t/**\n\t * On connect\n\t */\n\t@Override\n\tpublic void onConnect()\n\t{\n\t\tdebug(\"Connect\", \"\");\n\t\t\n\t\tserver.setStatus(Status.CONNECTED);\n\t\t\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\t\n\t/**\n\t * On channel action\n\t */\n\t@Override\n\tprotected void onAction(String sender, String login, String hostname, String target, String action)\n\t{\n\t\tdebug(\"Action\", target + \" \" + sender + \" \" + action);\n\t\t\n\t\tserver.getChannel(target).addMessage(\"* \" + sender + \" \" + action);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Channel Info\n\t */\n\t@Override\n\tprotected void onChannelInfo(String channel, int userCount, String topic)\n\t{\n\t\tdebug(\"ChannelInfo\", channel + \" \" + userCount);\n\t}\n\n\t/**\n\t * On Deop\n\t */\n\t@Override\n\tprotected void onDeop(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Deop\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" deoped \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On DeVoice\n\t */\n\t@Override\n\tprotected void onDeVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"DeVoice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" devoiced \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Invite\n\t */\n\t@Override\n\tprotected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String target)\n\t{\n\t\tdebug(\"Invite\", target + \" \" + targetNick + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" invited \" + targetNick);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Join\n\t */\n\t@Override\n\tprotected void onJoin(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Join\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We joined a new channel\n\t\t\tserver.addChannel(new Channel(target));\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_NEW);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" joined\");\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Kick\n\t */\n\t@Override\n\tprotected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n\t{\n\t\tdebug(\"Kick\", target + \" \" + recipientNick + \"(\" + kickerNick + \")\");\n\t\t\n\t\tif (recipientNick.equals(getNick())) {\n\t\t\t// We are kicked\n\t\t\tserver.removeChannel(target);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_REMOVE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(kickerNick + \" kicked \" + recipientNick);\n\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\t\t\t\n\t\t}\n\t}\n\n\t/**\n\t * On Message\n\t */\n\t@Override\n\tprotected void onMessage(String target, String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"Message\", target + \" \" + sender + \" \" + message);\n\n\t\tserver.getChannel(target).addMessage(\"<\" + sender + \"> \" + message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Mode\n\t */\n\t@Override\n\tprotected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n\t{\n\t\tdebug(\"Mode\", target + \" \" + sourceNick + \" \" + mode);\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" sets mode \" + mode);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Nick Change\n\t */\n\t@Override\n\tprotected void onNickChange(String oldNick, String login, String hostname, String newNick)\n\t{\n\t\tdebug(\"Nick\", oldNick + \" \" + newNick);\n\t}\n\n\t/**\n\t * On Notice\n\t */\n\t@Override\n\tprotected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n\t{\n\t\tdebug(\"Notice\", sourceNick + \" \" + notice);\n\t}\n\n\t/**\n\t * On Op\n\t */\n\t@Override\n\tprotected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Op\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" oped \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Part\n\t */\n\t@Override\n\tprotected void onPart(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Part\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We pareted a channel\n\t\t\tserver.removeChannel(target);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_REMOVE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" parted\");\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Private Message\n\t */\n\t@Override\n\tprotected void onPrivateMessage(String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"PrivateMessage\", sender + \" \" + message);\n\t}\n\n\t/**\n\t * On Quit\n\t */\n\t@Override\n\tprotected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n\t{\n\t\tdebug(\"Quit\", sourceNick);\n\t}\n\n\t/**\n\t * On Topic\n\t */\n\t@Override\n\tprotected void onTopic(String target, String topic, String setBy, long date, boolean changed)\n\t{\n\t\tdebug(\"Topic\", target + \" \" + setBy + \" \" + topic);\n\t\t\n\t\tif (changed) {\n\t\t\tserver.getChannel(target).addMessage(setBy + \" sets topic: \" + topic);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(\"Topic: \" + topic);\n\t\t}\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On User List\n\t */\n\t@Override\n\tprotected void onUserList(String channel, User[] users)\n\t{\n\t\tdebug(\"UserList\", channel + \" (\" + users.length + \")\");\n\t}\n\n\t/**\n\t * On Voice\n\t */\n\t@Override\n\tprotected void onVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Voice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" voiced \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\t\n\t/**\n\t * On disconnect\n\t */\n\t@Override\n\tpublic void onDisconnect()\n\t{\n\t\tserver.setStatus(Status.DISCONNECTED);\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\n\t/**\n\t * Print an event to the debug console \n\t */\n\tprivate void debug(String event, String params)\n\t{\n\t\tif (DEBUG_EVENTS) {\n\t\t\tLog.d(TAG, \"(\" + server.getTitle() + \") [\" + event + \"]: \" + params);\n\t\t}\n\t}\n\t\n\t/**\n\t * Quits from the IRC server with default reason.\n\t */\n\t@Override\n\tpublic void quitServer()\n\t{\n\t\tquitServer(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n}\n","lineNo":155}
{"Smelly Sample":"/*\n Yaaic - Yet Another Android IRC Client\n\nCopyright 2009 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.irc;\n\nimport android.content.Intent;\nimport android.util.Log;\n\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\n\nimport org.yaaic.Yaaic;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.Status;\n\npublic class IRCConnection extends PircBot\n{\n\tprivate IRCService service;\n\tprivate Server server;\n\t\n\t// XXX: Print all IRC events to the debug console\n\tprivate static final boolean DEBUG_EVENTS = true;\n\tpublic static final String TAG = \"Yaaic/IRCConnection\";\n\t\n\t/**\n\t * Create a new connection\n\t * \n\t * @param service\n\t * @param serverId\n\t */\n\tpublic IRCConnection(IRCService service, int serverId)\n\t{\n\t\tthis.server = Yaaic.getInstance().getServerById(serverId);\n\t\tthis.service = service;\n\t\t\n\t\tthis.setName(\"Yaaic\");\n\t\tthis.setLogin(\"Yaaic\");\n\t\tthis.setAutoNickChange(true);\n\t\tthis.setVersion(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n\n\t/**\n\t * On connect\n\t */\n\t@Override\n\tpublic void onConnect()\n\t{\n\t\tdebug(\"Connect\", \"\");\n\t\t\n\t\tserver.setStatus(Status.CONNECTED);\n\t\t\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\t\n\t/**\n\t * On channel action\n\t */\n\t@Override\n\tprotected void onAction(String sender, String login, String hostname, String target, String action)\n\t{\n\t\tdebug(\"Action\", target + \" \" + sender + \" \" + action);\n\t\t\n\t\tserver.getChannel(target).addMessage(\"* \" + sender + \" \" + action);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Channel Info\n\t */\n\t@Override\n\tprotected void onChannelInfo(String channel, int userCount, String topic)\n\t{\n\t\tdebug(\"ChannelInfo\", channel + \" \" + userCount);\n\t}\n\n\t/**\n\t * On Deop\n\t */\n\t@Override\n\tprotected void onDeop(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Deop\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" deoped \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On DeVoice\n\t */\n\t@Override\n\tprotected void onDeVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"DeVoice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" devoiced \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Invite\n\t */\n\t@Override\n\tprotected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String target)\n\t{\n\t\tdebug(\"Invite\", target + \" \" + targetNick + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" invited \" + targetNick);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Join\n\t */\n\t@Override\n\tprotected void onJoin(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Join\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We joined a new channel\n\t\t\tserver.addChannel(new Channel(target));\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_NEW));\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" joined\");\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Kick\n\t */\n\t@Override\n\tprotected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n\t{\n\t\tdebug(\"Kick\", target + \" \" + recipientNick + \"(\" + kickerNick + \")\");\n\t\t\n\t\tif (recipientNick.equals(getNick())) {\n\t\t\t// We are kicked\n\t\t\tserver.removeChannel(target);\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_REMOVE));\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(kickerNick + \" kicked \" + recipientNick);\n\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\t\t\t\n\t\t}\n\t}\n\n\t/**\n\t * On Message\n\t */\n\t@Override\n\tprotected void onMessage(String target, String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"Message\", target + \" \" + sender + \" \" + message);\n\n\t\tserver.getChannel(target).addMessage(\"<\" + sender + \"> \" + message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Mode\n\t */\n\t@Override\n\tprotected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n\t{\n\t\tdebug(\"Mode\", target + \" \" + sourceNick + \" \" + mode);\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" sets mode \" + mode);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Nick Change\n\t */\n\t@Override\n\tprotected void onNickChange(String oldNick, String login, String hostname, String newNick)\n\t{\n\t\tdebug(\"Nick\", oldNick + \" \" + newNick);\n\t}\n\n\t/**\n\t * On Notice\n\t */\n\t@Override\n\tprotected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n\t{\n\t\tdebug(\"Notice\", sourceNick + \" \" + notice);\n\t}\n\n\t/**\n\t * On Op\n\t */\n\t@Override\n\tprotected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Op\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" oped \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Part\n\t */\n\t@Override\n\tprotected void onPart(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Part\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We pareted a channel\n\t\t\tserver.removeChannel(target);\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_REMOVE));\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" parted\");\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Private Message\n\t */\n\t@Override\n\tprotected void onPrivateMessage(String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"PrivateMessage\", sender + \" \" + message);\n\t}\n\n\t/**\n\t * On Quit\n\t */\n\t@Override\n\tprotected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n\t{\n\t\tdebug(\"Quit\", sourceNick);\n\t}\n\n\t/**\n\t * On Topic\n\t */\n\t@Override\n\tprotected void onTopic(String target, String topic, String setBy, long date, boolean changed)\n\t{\n\t\tdebug(\"Topic\", target + \" \" + setBy + \" \" + topic);\n\t\t\n\t\tif (changed) {\n\t\t\tserver.getChannel(target).addMessage(setBy + \" sets topic: \" + topic);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(\"Topic: \" + topic);\n\t\t}\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On User List\n\t */\n\t@Override\n\tprotected void onUserList(String channel, User[] users)\n\t{\n\t\tdebug(\"UserList\", channel + \" (\" + users.length + \")\");\n\t}\n\n\t/**\n\t * On Voice\n\t */\n\t@Override\n\tprotected void onVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Voice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" voiced \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\t\n\t/**\n\t * On disconnect\n\t */\n\t@Override\n\tpublic void onDisconnect()\n\t{\n\t\tserver.setStatus(Status.DISCONNECTED);\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\n\t/**\n\t * Print an event to the debug console \n\t */\n\tprivate void debug(String event, String params)\n\t{\n\t\tif (DEBUG_EVENTS) {\n\t\t\tLog.d(TAG, \"(\" + server.getTitle() + \") [\" + event + \"]: \" + params);\n\t\t}\n\t}\n\t\n\t/**\n\t * Quits from the IRC server with default reason.\n\t */\n\t@Override\n\tpublic void quitServer()\n\t{\n\t\tquitServer(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n}\n","Method after Refactoring":"/*\n Yaaic - Yet Another Android IRC Client\n\nCopyright 2009 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.irc;\n\nimport android.content.Intent;\nimport android.util.Log;\n\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\n\nimport org.yaaic.Yaaic;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.Status;\n\npublic class IRCConnection extends PircBot\n{\n\tprivate IRCService service;\n\tprivate Server server;\n\t\n\t// XXX: Print all IRC events to the debug console\n\tprivate static final boolean DEBUG_EVENTS = true;\n\tpublic static final String TAG = \"Yaaic/IRCConnection\";\n\t\n\t/**\n\t * Create a new connection\n\t * \n\t * @param service\n\t * @param serverId\n\t */\n\tpublic IRCConnection(IRCService service, int serverId)\n\t{\n\t\tthis.server = Yaaic.getInstance().getServerById(serverId);\n\t\tthis.service = service;\n\t\t\n\t\tthis.setName(\"Yaaic\");\n\t\tthis.setLogin(\"Yaaic\");\n\t\tthis.setAutoNickChange(true);\n\t\tthis.setVersion(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n\n\t/**\n\t * On connect\n\t */\n\t@Override\n\tpublic void onConnect()\n\t{\n\t\tdebug(\"Connect\", \"\");\n\t\t\n\t\tserver.setStatus(Status.CONNECTED);\n\t\t\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\t\n\t/**\n\t * On channel action\n\t */\n\t@Override\n\tprotected void onAction(String sender, String login, String hostname, String target, String action)\n\t{\n\t\tdebug(\"Action\", target + \" \" + sender + \" \" + action);\n\t\t\n\t\tserver.getChannel(target).addMessage(\"* \" + sender + \" \" + action);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Channel Info\n\t */\n\t@Override\n\tprotected void onChannelInfo(String channel, int userCount, String topic)\n\t{\n\t\tdebug(\"ChannelInfo\", channel + \" \" + userCount);\n\t}\n\n\t/**\n\t * On Deop\n\t */\n\t@Override\n\tprotected void onDeop(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Deop\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" deoped \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On DeVoice\n\t */\n\t@Override\n\tprotected void onDeVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"DeVoice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" devoiced \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Invite\n\t */\n\t@Override\n\tprotected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String target)\n\t{\n\t\tdebug(\"Invite\", target + \" \" + targetNick + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" invited \" + targetNick);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Join\n\t */\n\t@Override\n\tprotected void onJoin(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Join\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We joined a new channel\n\t\t\tserver.addChannel(new Channel(target));\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_NEW);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" joined\");\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Kick\n\t */\n\t@Override\n\tprotected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n\t{\n\t\tdebug(\"Kick\", target + \" \" + recipientNick + \"(\" + kickerNick + \")\");\n\t\t\n\t\tif (recipientNick.equals(getNick())) {\n\t\t\t// We are kicked\n\t\t\tserver.removeChannel(target);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_REMOVE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(kickerNick + \" kicked \" + recipientNick);\n\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\t\t\t\n\t\t}\n\t}\n\n\t/**\n\t * On Message\n\t */\n\t@Override\n\tprotected void onMessage(String target, String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"Message\", target + \" \" + sender + \" \" + message);\n\n\t\tserver.getChannel(target).addMessage(\"<\" + sender + \"> \" + message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Mode\n\t */\n\t@Override\n\tprotected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n\t{\n\t\tdebug(\"Mode\", target + \" \" + sourceNick + \" \" + mode);\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" sets mode \" + mode);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Nick Change\n\t */\n\t@Override\n\tprotected void onNickChange(String oldNick, String login, String hostname, String newNick)\n\t{\n\t\tdebug(\"Nick\", oldNick + \" \" + newNick);\n\t}\n\n\t/**\n\t * On Notice\n\t */\n\t@Override\n\tprotected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n\t{\n\t\tdebug(\"Notice\", sourceNick + \" \" + notice);\n\t}\n\n\t/**\n\t * On Op\n\t */\n\t@Override\n\tprotected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Op\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" oped \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Part\n\t */\n\t@Override\n\tprotected void onPart(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Part\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We pareted a channel\n\t\t\tserver.removeChannel(target);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_REMOVE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" parted\");\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Private Message\n\t */\n\t@Override\n\tprotected void onPrivateMessage(String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"PrivateMessage\", sender + \" \" + message);\n\t}\n\n\t/**\n\t * On Quit\n\t */\n\t@Override\n\tprotected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n\t{\n\t\tdebug(\"Quit\", sourceNick);\n\t}\n\n\t/**\n\t * On Topic\n\t */\n\t@Override\n\tprotected void onTopic(String target, String topic, String setBy, long date, boolean changed)\n\t{\n\t\tdebug(\"Topic\", target + \" \" + setBy + \" \" + topic);\n\t\t\n\t\tif (changed) {\n\t\t\tserver.getChannel(target).addMessage(setBy + \" sets topic: \" + topic);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(\"Topic: \" + topic);\n\t\t}\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On User List\n\t */\n\t@Override\n\tprotected void onUserList(String channel, User[] users)\n\t{\n\t\tdebug(\"UserList\", channel + \" (\" + users.length + \")\");\n\t}\n\n\t/**\n\t * On Voice\n\t */\n\t@Override\n\tprotected void onVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Voice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" voiced \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\t\n\t/**\n\t * On disconnect\n\t */\n\t@Override\n\tpublic void onDisconnect()\n\t{\n\t\tserver.setStatus(Status.DISCONNECTED);\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\n\t/**\n\t * Print an event to the debug console \n\t */\n\tprivate void debug(String event, String params)\n\t{\n\t\tif (DEBUG_EVENTS) {\n\t\t\tLog.d(TAG, \"(\" + server.getTitle() + \") [\" + event + \"]: \" + params);\n\t\t}\n\t}\n\t\n\t/**\n\t * Quits from the IRC server with default reason.\n\t */\n\t@Override\n\tpublic void quitServer()\n\t{\n\t\tquitServer(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n}\n","lineNo":179}
{"Smelly Sample":"/*\n Yaaic - Yet Another Android IRC Client\n\nCopyright 2009 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.irc;\n\nimport android.content.Intent;\nimport android.util.Log;\n\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\n\nimport org.yaaic.Yaaic;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.Status;\n\npublic class IRCConnection extends PircBot\n{\n\tprivate IRCService service;\n\tprivate Server server;\n\t\n\t// XXX: Print all IRC events to the debug console\n\tprivate static final boolean DEBUG_EVENTS = true;\n\tpublic static final String TAG = \"Yaaic/IRCConnection\";\n\t\n\t/**\n\t * Create a new connection\n\t * \n\t * @param service\n\t * @param serverId\n\t */\n\tpublic IRCConnection(IRCService service, int serverId)\n\t{\n\t\tthis.server = Yaaic.getInstance().getServerById(serverId);\n\t\tthis.service = service;\n\t\t\n\t\tthis.setName(\"Yaaic\");\n\t\tthis.setLogin(\"Yaaic\");\n\t\tthis.setAutoNickChange(true);\n\t\tthis.setVersion(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n\n\t/**\n\t * On connect\n\t */\n\t@Override\n\tpublic void onConnect()\n\t{\n\t\tdebug(\"Connect\", \"\");\n\t\t\n\t\tserver.setStatus(Status.CONNECTED);\n\t\t\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\t\n\t/**\n\t * On channel action\n\t */\n\t@Override\n\tprotected void onAction(String sender, String login, String hostname, String target, String action)\n\t{\n\t\tdebug(\"Action\", target + \" \" + sender + \" \" + action);\n\t\t\n\t\tserver.getChannel(target).addMessage(\"* \" + sender + \" \" + action);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Channel Info\n\t */\n\t@Override\n\tprotected void onChannelInfo(String channel, int userCount, String topic)\n\t{\n\t\tdebug(\"ChannelInfo\", channel + \" \" + userCount);\n\t}\n\n\t/**\n\t * On Deop\n\t */\n\t@Override\n\tprotected void onDeop(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Deop\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" deoped \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On DeVoice\n\t */\n\t@Override\n\tprotected void onDeVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"DeVoice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" devoiced \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Invite\n\t */\n\t@Override\n\tprotected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String target)\n\t{\n\t\tdebug(\"Invite\", target + \" \" + targetNick + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" invited \" + targetNick);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Join\n\t */\n\t@Override\n\tprotected void onJoin(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Join\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We joined a new channel\n\t\t\tserver.addChannel(new Channel(target));\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_NEW));\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" joined\");\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Kick\n\t */\n\t@Override\n\tprotected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n\t{\n\t\tdebug(\"Kick\", target + \" \" + recipientNick + \"(\" + kickerNick + \")\");\n\t\t\n\t\tif (recipientNick.equals(getNick())) {\n\t\t\t// We are kicked\n\t\t\tserver.removeChannel(target);\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_REMOVE));\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(kickerNick + \" kicked \" + recipientNick);\n\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\t\t\t\n\t\t}\n\t}\n\n\t/**\n\t * On Message\n\t */\n\t@Override\n\tprotected void onMessage(String target, String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"Message\", target + \" \" + sender + \" \" + message);\n\n\t\tserver.getChannel(target).addMessage(\"<\" + sender + \"> \" + message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Mode\n\t */\n\t@Override\n\tprotected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n\t{\n\t\tdebug(\"Mode\", target + \" \" + sourceNick + \" \" + mode);\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" sets mode \" + mode);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Nick Change\n\t */\n\t@Override\n\tprotected void onNickChange(String oldNick, String login, String hostname, String newNick)\n\t{\n\t\tdebug(\"Nick\", oldNick + \" \" + newNick);\n\t}\n\n\t/**\n\t * On Notice\n\t */\n\t@Override\n\tprotected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n\t{\n\t\tdebug(\"Notice\", sourceNick + \" \" + notice);\n\t}\n\n\t/**\n\t * On Op\n\t */\n\t@Override\n\tprotected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Op\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" oped \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Part\n\t */\n\t@Override\n\tprotected void onPart(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Part\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We pareted a channel\n\t\t\tserver.removeChannel(target);\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_REMOVE));\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" parted\");\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Private Message\n\t */\n\t@Override\n\tprotected void onPrivateMessage(String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"PrivateMessage\", sender + \" \" + message);\n\t}\n\n\t/**\n\t * On Quit\n\t */\n\t@Override\n\tprotected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n\t{\n\t\tdebug(\"Quit\", sourceNick);\n\t}\n\n\t/**\n\t * On Topic\n\t */\n\t@Override\n\tprotected void onTopic(String target, String topic, String setBy, long date, boolean changed)\n\t{\n\t\tdebug(\"Topic\", target + \" \" + setBy + \" \" + topic);\n\t\t\n\t\tif (changed) {\n\t\t\tserver.getChannel(target).addMessage(setBy + \" sets topic: \" + topic);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(\"Topic: \" + topic);\n\t\t}\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On User List\n\t */\n\t@Override\n\tprotected void onUserList(String channel, User[] users)\n\t{\n\t\tdebug(\"UserList\", channel + \" (\" + users.length + \")\");\n\t}\n\n\t/**\n\t * On Voice\n\t */\n\t@Override\n\tprotected void onVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Voice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" voiced \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\t\n\t/**\n\t * On disconnect\n\t */\n\t@Override\n\tpublic void onDisconnect()\n\t{\n\t\tserver.setStatus(Status.DISCONNECTED);\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\n\t/**\n\t * Print an event to the debug console \n\t */\n\tprivate void debug(String event, String params)\n\t{\n\t\tif (DEBUG_EVENTS) {\n\t\t\tLog.d(TAG, \"(\" + server.getTitle() + \") [\" + event + \"]: \" + params);\n\t\t}\n\t}\n\t\n\t/**\n\t * Quits from the IRC server with default reason.\n\t */\n\t@Override\n\tpublic void quitServer()\n\t{\n\t\tquitServer(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n}\n","Method after Refactoring":"/*\n Yaaic - Yet Another Android IRC Client\n\nCopyright 2009 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.irc;\n\nimport android.content.Intent;\nimport android.util.Log;\n\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\n\nimport org.yaaic.Yaaic;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.Status;\n\npublic class IRCConnection extends PircBot\n{\n\tprivate IRCService service;\n\tprivate Server server;\n\t\n\t// XXX: Print all IRC events to the debug console\n\tprivate static final boolean DEBUG_EVENTS = true;\n\tpublic static final String TAG = \"Yaaic/IRCConnection\";\n\t\n\t/**\n\t * Create a new connection\n\t * \n\t * @param service\n\t * @param serverId\n\t */\n\tpublic IRCConnection(IRCService service, int serverId)\n\t{\n\t\tthis.server = Yaaic.getInstance().getServerById(serverId);\n\t\tthis.service = service;\n\t\t\n\t\tthis.setName(\"Yaaic\");\n\t\tthis.setLogin(\"Yaaic\");\n\t\tthis.setAutoNickChange(true);\n\t\tthis.setVersion(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n\n\t/**\n\t * On connect\n\t */\n\t@Override\n\tpublic void onConnect()\n\t{\n\t\tdebug(\"Connect\", \"\");\n\t\t\n\t\tserver.setStatus(Status.CONNECTED);\n\t\t\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\t\n\t/**\n\t * On channel action\n\t */\n\t@Override\n\tprotected void onAction(String sender, String login, String hostname, String target, String action)\n\t{\n\t\tdebug(\"Action\", target + \" \" + sender + \" \" + action);\n\t\t\n\t\tserver.getChannel(target).addMessage(\"* \" + sender + \" \" + action);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Channel Info\n\t */\n\t@Override\n\tprotected void onChannelInfo(String channel, int userCount, String topic)\n\t{\n\t\tdebug(\"ChannelInfo\", channel + \" \" + userCount);\n\t}\n\n\t/**\n\t * On Deop\n\t */\n\t@Override\n\tprotected void onDeop(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Deop\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" deoped \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On DeVoice\n\t */\n\t@Override\n\tprotected void onDeVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"DeVoice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" devoiced \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Invite\n\t */\n\t@Override\n\tprotected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String target)\n\t{\n\t\tdebug(\"Invite\", target + \" \" + targetNick + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" invited \" + targetNick);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Join\n\t */\n\t@Override\n\tprotected void onJoin(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Join\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We joined a new channel\n\t\t\tserver.addChannel(new Channel(target));\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_NEW);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" joined\");\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Kick\n\t */\n\t@Override\n\tprotected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n\t{\n\t\tdebug(\"Kick\", target + \" \" + recipientNick + \"(\" + kickerNick + \")\");\n\t\t\n\t\tif (recipientNick.equals(getNick())) {\n\t\t\t// We are kicked\n\t\t\tserver.removeChannel(target);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_REMOVE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(kickerNick + \" kicked \" + recipientNick);\n\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\t\t\t\n\t\t}\n\t}\n\n\t/**\n\t * On Message\n\t */\n\t@Override\n\tprotected void onMessage(String target, String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"Message\", target + \" \" + sender + \" \" + message);\n\n\t\tserver.getChannel(target).addMessage(\"<\" + sender + \"> \" + message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Mode\n\t */\n\t@Override\n\tprotected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n\t{\n\t\tdebug(\"Mode\", target + \" \" + sourceNick + \" \" + mode);\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" sets mode \" + mode);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Nick Change\n\t */\n\t@Override\n\tprotected void onNickChange(String oldNick, String login, String hostname, String newNick)\n\t{\n\t\tdebug(\"Nick\", oldNick + \" \" + newNick);\n\t}\n\n\t/**\n\t * On Notice\n\t */\n\t@Override\n\tprotected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n\t{\n\t\tdebug(\"Notice\", sourceNick + \" \" + notice);\n\t}\n\n\t/**\n\t * On Op\n\t */\n\t@Override\n\tprotected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Op\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" oped \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Part\n\t */\n\t@Override\n\tprotected void onPart(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Part\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We pareted a channel\n\t\t\tserver.removeChannel(target);\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_REMOVE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" parted\");\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Private Message\n\t */\n\t@Override\n\tprotected void onPrivateMessage(String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"PrivateMessage\", sender + \" \" + message);\n\t}\n\n\t/**\n\t * On Quit\n\t */\n\t@Override\n\tprotected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n\t{\n\t\tdebug(\"Quit\", sourceNick);\n\t}\n\n\t/**\n\t * On Topic\n\t */\n\t@Override\n\tprotected void onTopic(String target, String topic, String setBy, long date, boolean changed)\n\t{\n\t\tdebug(\"Topic\", target + \" \" + setBy + \" \" + topic);\n\t\t\n\t\tif (changed) {\n\t\t\tserver.getChannel(target).addMessage(setBy + \" sets topic: \" + topic);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(\"Topic: \" + topic);\n\t\t}\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On User List\n\t */\n\t@Override\n\tprotected void onUserList(String channel, User[] users)\n\t{\n\t\tdebug(\"UserList\", channel + \" (\" + users.length + \")\");\n\t}\n\n\t/**\n\t * On Voice\n\t */\n\t@Override\n\tprotected void onVoice(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Voice\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" voiced \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\t\n\t/**\n\t * On disconnect\n\t */\n\t@Override\n\tpublic void onDisconnect()\n\t{\n\t\tserver.setStatus(Status.DISCONNECTED);\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\n\t/**\n\t * Print an event to the debug console \n\t */\n\tprivate void debug(String event, String params)\n\t{\n\t\tif (DEBUG_EVENTS) {\n\t\t\tLog.d(TAG, \"(\" + server.getTitle() + \") [\" + event + \"]: \" + params);\n\t\t}\n\t}\n\t\n\t/**\n\t * Quits from the IRC server with default reason.\n\t */\n\t@Override\n\tpublic void quitServer()\n\t{\n\t\tquitServer(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n}\n","lineNo":266}
{"Smelly Sample":"/*\n Yaaic - Yet Another Android IRC Client\n\nCopyright 2009 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.irc;\n\nimport android.content.Intent;\nimport android.util.Log;\n\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\n\nimport org.yaaic.Yaaic;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.Status;\n\npublic class IRCConnection extends PircBot\n{\n\tprivate IRCService service;\n\tprivate Server server;\n\t\n\t// XXX: Print all IRC events to the debug console\n\tprivate static final boolean DEBUG_EVENTS = true;\n\tpublic static final String TAG = \"Yaaic/IRCConnection\";\n\t\n\t/**\n\t * Create a new connection\n\t * \n\t * @param service\n\t * @param serverId\n\t */\n\tpublic IRCConnection(IRCService service, int serverId)\n\t{\n\t\tthis.server = Yaaic.getInstance().getServerById(serverId);\n\t\tthis.service = service;\n\t\t\n\t\tthis.setName(\"Yaaic\");\n\t\tthis.setLogin(\"Yaaic\");\n\t\tthis.setAutoNickChange(true);\n\t\tthis.setVersion(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n\n\t/**\n\t * On connect\n\t */\n\t@Override\n\tpublic void onConnect()\n\t{\n\t\tdebug(\"Connect\", \"\");\n\t\t\n\t\tserver.setStatus(Status.CONNECTED);\n\t\t\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\t\n\t/**\n\t * On channel action\n\t */\n\t@Override\n\tprotected void onAction(String sender, String login, String hostname, String target, String action)\n\t{\n\t\tdebug(\"Action\", target + \" \" + sender + \" \" + action);\n\t\t\n\t\tserver.getChannel(target).addMessage(\"* \" + sender + \" \" + action);\n\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t}\n\n\t/**\n\t * On Channel Info\n\t */\n\t@Override\n\tprotected void onChannelInfo(String channel, int userCount, String topic)\n\t{\n\t\tdebug(\"ChannelInfo\", channel + \" \" + userCount);\n\t}\n\n\t/**\n\t * On Deop\n\t */\n\t@Override\n\tprotected void onDeop(String channel, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Deop\", channel + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t}\n\n\t/**\n\t * On DeVoice\n\t */\n\t@Override\n\tprotected void onDeVoice(String channel, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"DeVoice\", channel + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t}\n\n\t/**\n\t * On Invite\n\t */\n\t@Override\n\tprotected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String channel)\n\t{\n\t\tdebug(\"Invite\", channel + \" \" + targetNick + \"(\" + sourceNick + \")\");\n\t}\n\n\t/**\n\t * On Join\n\t */\n\t@Override\n\tprotected void onJoin(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Join\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We joined a new channel\n\t\t\tserver.addChannel(new Channel(target));\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_NEW));\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" joined\");\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t\t}\n\t}\n\n\t/**\n\t * On Kick\n\t */\n\t@Override\n\tprotected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n\t{\n\t\tdebug(\"Kick\", target + \" \" + recipientNick + \"(\" + kickerNick + \")\");\n\t\t\n\t\tif (recipientNick.equals(getNick())) {\n\t\t\t// We are kicked\n\t\t\tserver.removeChannel(target);\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_REMOVE));\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(kickerNick + \" kicked \" + recipientNick);\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t\t}\n\t}\n\n\t/**\n\t * On Message\n\t */\n\t@Override\n\tprotected void onMessage(String target, String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"Message\", target + \" \" + sender + \" \" + message);\n\n\t\tserver.getChannel(target).addMessage(\"<\" + sender + \">\" + message);\n\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t}\n\n\t/**\n\t * On Mode\n\t */\n\t@Override\n\tprotected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n\t{\n\t\tdebug(\"Mode\", target + \" \" + sourceNick + \" \" + mode);\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" sets mode \" + mode);\n\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t}\n\n\t/**\n\t * On Nick Change\n\t */\n\t@Override\n\tprotected void onNickChange(String oldNick, String login, String hostname, String newNick)\n\t{\n\t\tdebug(\"Nick\", oldNick + \" \" + newNick);\n\t}\n\n\t/**\n\t * On Notice\n\t */\n\t@Override\n\tprotected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n\t{\n\t\tdebug(\"Notice\", sourceNick + \" \" + notice);\n\t}\n\n\t/**\n\t * On Op\n\t */\n\t@Override\n\tprotected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Op\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" oped \" + recipient);\n\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t}\n\n\t/**\n\t * On Part\n\t */\n\t@Override\n\tprotected void onPart(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Part\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We pareted a channel\n\t\t\tserver.removeChannel(target);\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_REMOVE));\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" parted\");\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t\t}\n\t}\n\n\t/**\n\t * On Private Message\n\t */\n\t@Override\n\tprotected void onPrivateMessage(String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"PrivateMessage\", sender + \" \" + message);\n\t}\n\n\t/**\n\t * On Quit\n\t */\n\t@Override\n\tprotected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n\t{\n\t\tdebug(\"Quit\", sourceNick);\n\t}\n\n\t/**\n\t * On Topic\n\t */\n\t@Override\n\tprotected void onTopic(String target, String topic, String setBy, long date, boolean changed)\n\t{\n\t\tdebug(\"Topic\", target + \" \" + setBy + \" \" + topic);\n\t\t\n\t\tif (changed) {\n\t\t\tserver.getChannel(target).addMessage(setBy + \" sets topic: \" + topic);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(\"Topic: \" + topic);\n\t\t}\n\t\t\n\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t}\n\n\t/**\n\t * On User List\n\t */\n\t@Override\n\tprotected void onUserList(String channel, User[] users)\n\t{\n\t\tdebug(\"UserList\", channel + \" (\" + users.length + \")\");\n\t}\n\n\t/**\n\t * On Voice\n\t */\n\t@Override\n\tprotected void onVoice(String channel, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Voice\", channel + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t}\n\t\n\t/**\n\t * On disconnect\n\t */\n\t@Override\n\tpublic void onDisconnect()\n\t{\n\t\tserver.setStatus(Status.DISCONNECTED);\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\n\t/**\n\t * Print an event to the debug console \n\t */\n\tprivate void debug(String event, String params)\n\t{\n\t\tif (DEBUG_EVENTS) {\n\t\t\tLog.d(TAG, \"(\" + server.getTitle() + \") [\" + event + \"]: \" + params);\n\t\t}\n\t}\n\t\n\t/**\n\t * Quits from the IRC server with default reason.\n\t */\n\t@Override\n\tpublic void quitServer()\n\t{\n\t\tquitServer(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n}\n","Method after Refactoring":"/*\n Yaaic - Yet Another Android IRC Client\n\nCopyright 2009 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.irc;\n\nimport android.content.Intent;\nimport android.util.Log;\n\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\n\nimport org.yaaic.Yaaic;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.Status;\n\npublic class IRCConnection extends PircBot\n{\n\tprivate IRCService service;\n\tprivate Server server;\n\t\n\t// XXX: Print all IRC events to the debug console\n\tprivate static final boolean DEBUG_EVENTS = true;\n\tpublic static final String TAG = \"Yaaic/IRCConnection\";\n\t\n\t/**\n\t * Create a new connection\n\t * \n\t * @param service\n\t * @param serverId\n\t */\n\tpublic IRCConnection(IRCService service, int serverId)\n\t{\n\t\tthis.server = Yaaic.getInstance().getServerById(serverId);\n\t\tthis.service = service;\n\t\t\n\t\tthis.setName(\"Yaaic\");\n\t\tthis.setLogin(\"Yaaic\");\n\t\tthis.setAutoNickChange(true);\n\t\tthis.setVersion(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n\n\t/**\n\t * On connect\n\t */\n\t@Override\n\tpublic void onConnect()\n\t{\n\t\tdebug(\"Connect\", \"\");\n\t\t\n\t\tserver.setStatus(Status.CONNECTED);\n\t\t\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\t\n\t/**\n\t * On channel action\n\t */\n\t@Override\n\tprotected void onAction(String sender, String login, String hostname, String target, String action)\n\t{\n\t\tdebug(\"Action\", target + \" \" + sender + \" \" + action);\n\t\t\n\t\tserver.getChannel(target).addMessage(\"* \" + sender + \" \" + action);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Channel Info\n\t */\n\t@Override\n\tprotected void onChannelInfo(String channel, int userCount, String topic)\n\t{\n\t\tdebug(\"ChannelInfo\", channel + \" \" + userCount);\n\t}\n\n\t/**\n\t * On Deop\n\t */\n\t@Override\n\tprotected void onDeop(String channel, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Deop\", channel + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t}\n\n\t/**\n\t * On DeVoice\n\t */\n\t@Override\n\tprotected void onDeVoice(String channel, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"DeVoice\", channel + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t}\n\n\t/**\n\t * On Invite\n\t */\n\t@Override\n\tprotected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String channel)\n\t{\n\t\tdebug(\"Invite\", channel + \" \" + targetNick + \"(\" + sourceNick + \")\");\n\t}\n\n\t/**\n\t * On Join\n\t */\n\t@Override\n\tprotected void onJoin(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Join\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We joined a new channel\n\t\t\tserver.addChannel(new Channel(target));\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_NEW));\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" joined\");\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Kick\n\t */\n\t@Override\n\tprotected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n\t{\n\t\tdebug(\"Kick\", target + \" \" + recipientNick + \"(\" + kickerNick + \")\");\n\t\t\n\t\tif (recipientNick.equals(getNick())) {\n\t\t\t// We are kicked\n\t\t\tserver.removeChannel(target);\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_REMOVE));\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(kickerNick + \" kicked \" + recipientNick);\n\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\t\t\t\n\t\t}\n\t}\n\n\t/**\n\t * On Message\n\t */\n\t@Override\n\tprotected void onMessage(String target, String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"Message\", target + \" \" + sender + \" \" + message);\n\n\t\tserver.getChannel(target).addMessage(\"<\" + sender + \">\" + message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Mode\n\t */\n\t@Override\n\tprotected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n\t{\n\t\tdebug(\"Mode\", target + \" \" + sourceNick + \" \" + mode);\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" sets mode \" + mode);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Nick Change\n\t */\n\t@Override\n\tprotected void onNickChange(String oldNick, String login, String hostname, String newNick)\n\t{\n\t\tdebug(\"Nick\", oldNick + \" \" + newNick);\n\t}\n\n\t/**\n\t * On Notice\n\t */\n\t@Override\n\tprotected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n\t{\n\t\tdebug(\"Notice\", sourceNick + \" \" + notice);\n\t}\n\n\t/**\n\t * On Op\n\t */\n\t@Override\n\tprotected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Op\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" oped \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Part\n\t */\n\t@Override\n\tprotected void onPart(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Part\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We pareted a channel\n\t\t\tserver.removeChannel(target);\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_REMOVE));\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" parted\");\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Private Message\n\t */\n\t@Override\n\tprotected void onPrivateMessage(String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"PrivateMessage\", sender + \" \" + message);\n\t}\n\n\t/**\n\t * On Quit\n\t */\n\t@Override\n\tprotected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n\t{\n\t\tdebug(\"Quit\", sourceNick);\n\t}\n\n\t/**\n\t * On Topic\n\t */\n\t@Override\n\tprotected void onTopic(String target, String topic, String setBy, long date, boolean changed)\n\t{\n\t\tdebug(\"Topic\", target + \" \" + setBy + \" \" + topic);\n\t\t\n\t\tif (changed) {\n\t\t\tserver.getChannel(target).addMessage(setBy + \" sets topic: \" + topic);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(\"Topic: \" + topic);\n\t\t}\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On User List\n\t */\n\t@Override\n\tprotected void onUserList(String channel, User[] users)\n\t{\n\t\tdebug(\"UserList\", channel + \" (\" + users.length + \")\");\n\t}\n\n\t/**\n\t * On Voice\n\t */\n\t@Override\n\tprotected void onVoice(String channel, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Voice\", channel + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t}\n\t\n\t/**\n\t * On disconnect\n\t */\n\t@Override\n\tpublic void onDisconnect()\n\t{\n\t\tserver.setStatus(Status.DISCONNECTED);\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\n\t/**\n\t * Print an event to the debug console \n\t */\n\tprivate void debug(String event, String params)\n\t{\n\t\tif (DEBUG_EVENTS) {\n\t\t\tLog.d(TAG, \"(\" + server.getTitle() + \") [\" + event + \"]: \" + params);\n\t\t}\n\t}\n\t\n\t/**\n\t * Quits from the IRC server with default reason.\n\t */\n\t@Override\n\tpublic void quitServer()\n\t{\n\t\tquitServer(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n}\n","lineNo":84}
{"Smelly Sample":"/*\n Yaaic - Yet Another Android IRC Client\n\nCopyright 2009 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.irc;\n\nimport android.content.Intent;\nimport android.util.Log;\n\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\n\nimport org.yaaic.Yaaic;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.Status;\n\npublic class IRCConnection extends PircBot\n{\n\tprivate IRCService service;\n\tprivate Server server;\n\t\n\t// XXX: Print all IRC events to the debug console\n\tprivate static final boolean DEBUG_EVENTS = true;\n\tpublic static final String TAG = \"Yaaic/IRCConnection\";\n\t\n\t/**\n\t * Create a new connection\n\t * \n\t * @param service\n\t * @param serverId\n\t */\n\tpublic IRCConnection(IRCService service, int serverId)\n\t{\n\t\tthis.server = Yaaic.getInstance().getServerById(serverId);\n\t\tthis.service = service;\n\t\t\n\t\tthis.setName(\"Yaaic\");\n\t\tthis.setLogin(\"Yaaic\");\n\t\tthis.setAutoNickChange(true);\n\t\tthis.setVersion(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n\n\t/**\n\t * On connect\n\t */\n\t@Override\n\tpublic void onConnect()\n\t{\n\t\tdebug(\"Connect\", \"\");\n\t\t\n\t\tserver.setStatus(Status.CONNECTED);\n\t\t\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\t\n\t/**\n\t * On channel action\n\t */\n\t@Override\n\tprotected void onAction(String sender, String login, String hostname, String target, String action)\n\t{\n\t\tdebug(\"Action\", target + \" \" + sender + \" \" + action);\n\t\t\n\t\tserver.getChannel(target).addMessage(\"* \" + sender + \" \" + action);\n\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t}\n\n\t/**\n\t * On Channel Info\n\t */\n\t@Override\n\tprotected void onChannelInfo(String channel, int userCount, String topic)\n\t{\n\t\tdebug(\"ChannelInfo\", channel + \" \" + userCount);\n\t}\n\n\t/**\n\t * On Deop\n\t */\n\t@Override\n\tprotected void onDeop(String channel, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Deop\", channel + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t}\n\n\t/**\n\t * On DeVoice\n\t */\n\t@Override\n\tprotected void onDeVoice(String channel, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"DeVoice\", channel + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t}\n\n\t/**\n\t * On Invite\n\t */\n\t@Override\n\tprotected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String channel)\n\t{\n\t\tdebug(\"Invite\", channel + \" \" + targetNick + \"(\" + sourceNick + \")\");\n\t}\n\n\t/**\n\t * On Join\n\t */\n\t@Override\n\tprotected void onJoin(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Join\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We joined a new channel\n\t\t\tserver.addChannel(new Channel(target));\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_NEW));\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" joined\");\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t\t}\n\t}\n\n\t/**\n\t * On Kick\n\t */\n\t@Override\n\tprotected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n\t{\n\t\tdebug(\"Kick\", target + \" \" + recipientNick + \"(\" + kickerNick + \")\");\n\t\t\n\t\tif (recipientNick.equals(getNick())) {\n\t\t\t// We are kicked\n\t\t\tserver.removeChannel(target);\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_REMOVE));\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(kickerNick + \" kicked \" + recipientNick);\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t\t}\n\t}\n\n\t/**\n\t * On Message\n\t */\n\t@Override\n\tprotected void onMessage(String target, String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"Message\", target + \" \" + sender + \" \" + message);\n\n\t\tserver.getChannel(target).addMessage(\"<\" + sender + \">\" + message);\n\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t}\n\n\t/**\n\t * On Mode\n\t */\n\t@Override\n\tprotected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n\t{\n\t\tdebug(\"Mode\", target + \" \" + sourceNick + \" \" + mode);\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" sets mode \" + mode);\n\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t}\n\n\t/**\n\t * On Nick Change\n\t */\n\t@Override\n\tprotected void onNickChange(String oldNick, String login, String hostname, String newNick)\n\t{\n\t\tdebug(\"Nick\", oldNick + \" \" + newNick);\n\t}\n\n\t/**\n\t * On Notice\n\t */\n\t@Override\n\tprotected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n\t{\n\t\tdebug(\"Notice\", sourceNick + \" \" + notice);\n\t}\n\n\t/**\n\t * On Op\n\t */\n\t@Override\n\tprotected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Op\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" oped \" + recipient);\n\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t}\n\n\t/**\n\t * On Part\n\t */\n\t@Override\n\tprotected void onPart(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Part\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We pareted a channel\n\t\t\tserver.removeChannel(target);\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_REMOVE));\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" parted\");\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t\t}\n\t}\n\n\t/**\n\t * On Private Message\n\t */\n\t@Override\n\tprotected void onPrivateMessage(String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"PrivateMessage\", sender + \" \" + message);\n\t}\n\n\t/**\n\t * On Quit\n\t */\n\t@Override\n\tprotected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n\t{\n\t\tdebug(\"Quit\", sourceNick);\n\t}\n\n\t/**\n\t * On Topic\n\t */\n\t@Override\n\tprotected void onTopic(String target, String topic, String setBy, long date, boolean changed)\n\t{\n\t\tdebug(\"Topic\", target + \" \" + setBy + \" \" + topic);\n\t\t\n\t\tif (changed) {\n\t\t\tserver.getChannel(target).addMessage(setBy + \" sets topic: \" + topic);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(\"Topic: \" + topic);\n\t\t}\n\t\t\n\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t}\n\n\t/**\n\t * On User List\n\t */\n\t@Override\n\tprotected void onUserList(String channel, User[] users)\n\t{\n\t\tdebug(\"UserList\", channel + \" (\" + users.length + \")\");\n\t}\n\n\t/**\n\t * On Voice\n\t */\n\t@Override\n\tprotected void onVoice(String channel, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Voice\", channel + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t}\n\t\n\t/**\n\t * On disconnect\n\t */\n\t@Override\n\tpublic void onDisconnect()\n\t{\n\t\tserver.setStatus(Status.DISCONNECTED);\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\n\t/**\n\t * Print an event to the debug console \n\t */\n\tprivate void debug(String event, String params)\n\t{\n\t\tif (DEBUG_EVENTS) {\n\t\t\tLog.d(TAG, \"(\" + server.getTitle() + \") [\" + event + \"]: \" + params);\n\t\t}\n\t}\n\t\n\t/**\n\t * Quits from the IRC server with default reason.\n\t */\n\t@Override\n\tpublic void quitServer()\n\t{\n\t\tquitServer(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n}\n","Method after Refactoring":"/*\n Yaaic - Yet Another Android IRC Client\n\nCopyright 2009 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.irc;\n\nimport android.content.Intent;\nimport android.util.Log;\n\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\n\nimport org.yaaic.Yaaic;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.Status;\n\npublic class IRCConnection extends PircBot\n{\n\tprivate IRCService service;\n\tprivate Server server;\n\t\n\t// XXX: Print all IRC events to the debug console\n\tprivate static final boolean DEBUG_EVENTS = true;\n\tpublic static final String TAG = \"Yaaic/IRCConnection\";\n\t\n\t/**\n\t * Create a new connection\n\t * \n\t * @param service\n\t * @param serverId\n\t */\n\tpublic IRCConnection(IRCService service, int serverId)\n\t{\n\t\tthis.server = Yaaic.getInstance().getServerById(serverId);\n\t\tthis.service = service;\n\t\t\n\t\tthis.setName(\"Yaaic\");\n\t\tthis.setLogin(\"Yaaic\");\n\t\tthis.setAutoNickChange(true);\n\t\tthis.setVersion(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n\n\t/**\n\t * On connect\n\t */\n\t@Override\n\tpublic void onConnect()\n\t{\n\t\tdebug(\"Connect\", \"\");\n\t\t\n\t\tserver.setStatus(Status.CONNECTED);\n\t\t\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\t\n\t/**\n\t * On channel action\n\t */\n\t@Override\n\tprotected void onAction(String sender, String login, String hostname, String target, String action)\n\t{\n\t\tdebug(\"Action\", target + \" \" + sender + \" \" + action);\n\t\t\n\t\tserver.getChannel(target).addMessage(\"* \" + sender + \" \" + action);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Channel Info\n\t */\n\t@Override\n\tprotected void onChannelInfo(String channel, int userCount, String topic)\n\t{\n\t\tdebug(\"ChannelInfo\", channel + \" \" + userCount);\n\t}\n\n\t/**\n\t * On Deop\n\t */\n\t@Override\n\tprotected void onDeop(String channel, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Deop\", channel + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t}\n\n\t/**\n\t * On DeVoice\n\t */\n\t@Override\n\tprotected void onDeVoice(String channel, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"DeVoice\", channel + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t}\n\n\t/**\n\t * On Invite\n\t */\n\t@Override\n\tprotected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String channel)\n\t{\n\t\tdebug(\"Invite\", channel + \" \" + targetNick + \"(\" + sourceNick + \")\");\n\t}\n\n\t/**\n\t * On Join\n\t */\n\t@Override\n\tprotected void onJoin(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Join\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We joined a new channel\n\t\t\tserver.addChannel(new Channel(target));\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_NEW));\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" joined\");\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Kick\n\t */\n\t@Override\n\tprotected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n\t{\n\t\tdebug(\"Kick\", target + \" \" + recipientNick + \"(\" + kickerNick + \")\");\n\t\t\n\t\tif (recipientNick.equals(getNick())) {\n\t\t\t// We are kicked\n\t\t\tserver.removeChannel(target);\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_REMOVE));\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(kickerNick + \" kicked \" + recipientNick);\n\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\t\t\t\n\t\t}\n\t}\n\n\t/**\n\t * On Message\n\t */\n\t@Override\n\tprotected void onMessage(String target, String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"Message\", target + \" \" + sender + \" \" + message);\n\n\t\tserver.getChannel(target).addMessage(\"<\" + sender + \">\" + message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Mode\n\t */\n\t@Override\n\tprotected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n\t{\n\t\tdebug(\"Mode\", target + \" \" + sourceNick + \" \" + mode);\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" sets mode \" + mode);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Nick Change\n\t */\n\t@Override\n\tprotected void onNickChange(String oldNick, String login, String hostname, String newNick)\n\t{\n\t\tdebug(\"Nick\", oldNick + \" \" + newNick);\n\t}\n\n\t/**\n\t * On Notice\n\t */\n\t@Override\n\tprotected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n\t{\n\t\tdebug(\"Notice\", sourceNick + \" \" + notice);\n\t}\n\n\t/**\n\t * On Op\n\t */\n\t@Override\n\tprotected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Op\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" oped \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Part\n\t */\n\t@Override\n\tprotected void onPart(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Part\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We pareted a channel\n\t\t\tserver.removeChannel(target);\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_REMOVE));\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" parted\");\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Private Message\n\t */\n\t@Override\n\tprotected void onPrivateMessage(String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"PrivateMessage\", sender + \" \" + message);\n\t}\n\n\t/**\n\t * On Quit\n\t */\n\t@Override\n\tprotected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n\t{\n\t\tdebug(\"Quit\", sourceNick);\n\t}\n\n\t/**\n\t * On Topic\n\t */\n\t@Override\n\tprotected void onTopic(String target, String topic, String setBy, long date, boolean changed)\n\t{\n\t\tdebug(\"Topic\", target + \" \" + setBy + \" \" + topic);\n\t\t\n\t\tif (changed) {\n\t\t\tserver.getChannel(target).addMessage(setBy + \" sets topic: \" + topic);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(\"Topic: \" + topic);\n\t\t}\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On User List\n\t */\n\t@Override\n\tprotected void onUserList(String channel, User[] users)\n\t{\n\t\tdebug(\"UserList\", channel + \" (\" + users.length + \")\");\n\t}\n\n\t/**\n\t * On Voice\n\t */\n\t@Override\n\tprotected void onVoice(String channel, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Voice\", channel + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t}\n\t\n\t/**\n\t * On disconnect\n\t */\n\t@Override\n\tpublic void onDisconnect()\n\t{\n\t\tserver.setStatus(Status.DISCONNECTED);\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\n\t/**\n\t * Print an event to the debug console \n\t */\n\tprivate void debug(String event, String params)\n\t{\n\t\tif (DEBUG_EVENTS) {\n\t\t\tLog.d(TAG, \"(\" + server.getTitle() + \") [\" + event + \"]: \" + params);\n\t\t}\n\t}\n\t\n\t/**\n\t * Quits from the IRC server with default reason.\n\t */\n\t@Override\n\tpublic void quitServer()\n\t{\n\t\tquitServer(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n}\n","lineNo":140}
{"Smelly Sample":"/*\n Yaaic - Yet Another Android IRC Client\n\nCopyright 2009 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.irc;\n\nimport android.content.Intent;\nimport android.util.Log;\n\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\n\nimport org.yaaic.Yaaic;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.Status;\n\npublic class IRCConnection extends PircBot\n{\n\tprivate IRCService service;\n\tprivate Server server;\n\t\n\t// XXX: Print all IRC events to the debug console\n\tprivate static final boolean DEBUG_EVENTS = true;\n\tpublic static final String TAG = \"Yaaic/IRCConnection\";\n\t\n\t/**\n\t * Create a new connection\n\t * \n\t * @param service\n\t * @param serverId\n\t */\n\tpublic IRCConnection(IRCService service, int serverId)\n\t{\n\t\tthis.server = Yaaic.getInstance().getServerById(serverId);\n\t\tthis.service = service;\n\t\t\n\t\tthis.setName(\"Yaaic\");\n\t\tthis.setLogin(\"Yaaic\");\n\t\tthis.setAutoNickChange(true);\n\t\tthis.setVersion(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n\n\t/**\n\t * On connect\n\t */\n\t@Override\n\tpublic void onConnect()\n\t{\n\t\tdebug(\"Connect\", \"\");\n\t\t\n\t\tserver.setStatus(Status.CONNECTED);\n\t\t\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\t\n\t/**\n\t * On channel action\n\t */\n\t@Override\n\tprotected void onAction(String sender, String login, String hostname, String target, String action)\n\t{\n\t\tdebug(\"Action\", target + \" \" + sender + \" \" + action);\n\t\t\n\t\tserver.getChannel(target).addMessage(\"* \" + sender + \" \" + action);\n\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t}\n\n\t/**\n\t * On Channel Info\n\t */\n\t@Override\n\tprotected void onChannelInfo(String channel, int userCount, String topic)\n\t{\n\t\tdebug(\"ChannelInfo\", channel + \" \" + userCount);\n\t}\n\n\t/**\n\t * On Deop\n\t */\n\t@Override\n\tprotected void onDeop(String channel, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Deop\", channel + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t}\n\n\t/**\n\t * On DeVoice\n\t */\n\t@Override\n\tprotected void onDeVoice(String channel, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"DeVoice\", channel + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t}\n\n\t/**\n\t * On Invite\n\t */\n\t@Override\n\tprotected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String channel)\n\t{\n\t\tdebug(\"Invite\", channel + \" \" + targetNick + \"(\" + sourceNick + \")\");\n\t}\n\n\t/**\n\t * On Join\n\t */\n\t@Override\n\tprotected void onJoin(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Join\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We joined a new channel\n\t\t\tserver.addChannel(new Channel(target));\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_NEW));\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" joined\");\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t\t}\n\t}\n\n\t/**\n\t * On Kick\n\t */\n\t@Override\n\tprotected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n\t{\n\t\tdebug(\"Kick\", target + \" \" + recipientNick + \"(\" + kickerNick + \")\");\n\t\t\n\t\tif (recipientNick.equals(getNick())) {\n\t\t\t// We are kicked\n\t\t\tserver.removeChannel(target);\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_REMOVE));\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(kickerNick + \" kicked \" + recipientNick);\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t\t}\n\t}\n\n\t/**\n\t * On Message\n\t */\n\t@Override\n\tprotected void onMessage(String target, String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"Message\", target + \" \" + sender + \" \" + message);\n\n\t\tserver.getChannel(target).addMessage(\"<\" + sender + \">\" + message);\n\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t}\n\n\t/**\n\t * On Mode\n\t */\n\t@Override\n\tprotected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n\t{\n\t\tdebug(\"Mode\", target + \" \" + sourceNick + \" \" + mode);\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" sets mode \" + mode);\n\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t}\n\n\t/**\n\t * On Nick Change\n\t */\n\t@Override\n\tprotected void onNickChange(String oldNick, String login, String hostname, String newNick)\n\t{\n\t\tdebug(\"Nick\", oldNick + \" \" + newNick);\n\t}\n\n\t/**\n\t * On Notice\n\t */\n\t@Override\n\tprotected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n\t{\n\t\tdebug(\"Notice\", sourceNick + \" \" + notice);\n\t}\n\n\t/**\n\t * On Op\n\t */\n\t@Override\n\tprotected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Op\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" oped \" + recipient);\n\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t}\n\n\t/**\n\t * On Part\n\t */\n\t@Override\n\tprotected void onPart(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Part\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We pareted a channel\n\t\t\tserver.removeChannel(target);\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_REMOVE));\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" parted\");\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t\t}\n\t}\n\n\t/**\n\t * On Private Message\n\t */\n\t@Override\n\tprotected void onPrivateMessage(String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"PrivateMessage\", sender + \" \" + message);\n\t}\n\n\t/**\n\t * On Quit\n\t */\n\t@Override\n\tprotected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n\t{\n\t\tdebug(\"Quit\", sourceNick);\n\t}\n\n\t/**\n\t * On Topic\n\t */\n\t@Override\n\tprotected void onTopic(String target, String topic, String setBy, long date, boolean changed)\n\t{\n\t\tdebug(\"Topic\", target + \" \" + setBy + \" \" + topic);\n\t\t\n\t\tif (changed) {\n\t\t\tserver.getChannel(target).addMessage(setBy + \" sets topic: \" + topic);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(\"Topic: \" + topic);\n\t\t}\n\t\t\n\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t}\n\n\t/**\n\t * On User List\n\t */\n\t@Override\n\tprotected void onUserList(String channel, User[] users)\n\t{\n\t\tdebug(\"UserList\", channel + \" (\" + users.length + \")\");\n\t}\n\n\t/**\n\t * On Voice\n\t */\n\t@Override\n\tprotected void onVoice(String channel, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Voice\", channel + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t}\n\t\n\t/**\n\t * On disconnect\n\t */\n\t@Override\n\tpublic void onDisconnect()\n\t{\n\t\tserver.setStatus(Status.DISCONNECTED);\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\n\t/**\n\t * Print an event to the debug console \n\t */\n\tprivate void debug(String event, String params)\n\t{\n\t\tif (DEBUG_EVENTS) {\n\t\t\tLog.d(TAG, \"(\" + server.getTitle() + \") [\" + event + \"]: \" + params);\n\t\t}\n\t}\n\t\n\t/**\n\t * Quits from the IRC server with default reason.\n\t */\n\t@Override\n\tpublic void quitServer()\n\t{\n\t\tquitServer(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n}\n","Method after Refactoring":"/*\n Yaaic - Yet Another Android IRC Client\n\nCopyright 2009 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.irc;\n\nimport android.content.Intent;\nimport android.util.Log;\n\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\n\nimport org.yaaic.Yaaic;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.Status;\n\npublic class IRCConnection extends PircBot\n{\n\tprivate IRCService service;\n\tprivate Server server;\n\t\n\t// XXX: Print all IRC events to the debug console\n\tprivate static final boolean DEBUG_EVENTS = true;\n\tpublic static final String TAG = \"Yaaic/IRCConnection\";\n\t\n\t/**\n\t * Create a new connection\n\t * \n\t * @param service\n\t * @param serverId\n\t */\n\tpublic IRCConnection(IRCService service, int serverId)\n\t{\n\t\tthis.server = Yaaic.getInstance().getServerById(serverId);\n\t\tthis.service = service;\n\t\t\n\t\tthis.setName(\"Yaaic\");\n\t\tthis.setLogin(\"Yaaic\");\n\t\tthis.setAutoNickChange(true);\n\t\tthis.setVersion(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n\n\t/**\n\t * On connect\n\t */\n\t@Override\n\tpublic void onConnect()\n\t{\n\t\tdebug(\"Connect\", \"\");\n\t\t\n\t\tserver.setStatus(Status.CONNECTED);\n\t\t\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\t\n\t/**\n\t * On channel action\n\t */\n\t@Override\n\tprotected void onAction(String sender, String login, String hostname, String target, String action)\n\t{\n\t\tdebug(\"Action\", target + \" \" + sender + \" \" + action);\n\t\t\n\t\tserver.getChannel(target).addMessage(\"* \" + sender + \" \" + action);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Channel Info\n\t */\n\t@Override\n\tprotected void onChannelInfo(String channel, int userCount, String topic)\n\t{\n\t\tdebug(\"ChannelInfo\", channel + \" \" + userCount);\n\t}\n\n\t/**\n\t * On Deop\n\t */\n\t@Override\n\tprotected void onDeop(String channel, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Deop\", channel + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t}\n\n\t/**\n\t * On DeVoice\n\t */\n\t@Override\n\tprotected void onDeVoice(String channel, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"DeVoice\", channel + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t}\n\n\t/**\n\t * On Invite\n\t */\n\t@Override\n\tprotected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String channel)\n\t{\n\t\tdebug(\"Invite\", channel + \" \" + targetNick + \"(\" + sourceNick + \")\");\n\t}\n\n\t/**\n\t * On Join\n\t */\n\t@Override\n\tprotected void onJoin(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Join\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We joined a new channel\n\t\t\tserver.addChannel(new Channel(target));\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_NEW));\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" joined\");\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Kick\n\t */\n\t@Override\n\tprotected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n\t{\n\t\tdebug(\"Kick\", target + \" \" + recipientNick + \"(\" + kickerNick + \")\");\n\t\t\n\t\tif (recipientNick.equals(getNick())) {\n\t\t\t// We are kicked\n\t\t\tserver.removeChannel(target);\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_REMOVE));\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(kickerNick + \" kicked \" + recipientNick);\n\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\t\t\t\n\t\t}\n\t}\n\n\t/**\n\t * On Message\n\t */\n\t@Override\n\tprotected void onMessage(String target, String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"Message\", target + \" \" + sender + \" \" + message);\n\n\t\tserver.getChannel(target).addMessage(\"<\" + sender + \">\" + message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Mode\n\t */\n\t@Override\n\tprotected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n\t{\n\t\tdebug(\"Mode\", target + \" \" + sourceNick + \" \" + mode);\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" sets mode \" + mode);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Nick Change\n\t */\n\t@Override\n\tprotected void onNickChange(String oldNick, String login, String hostname, String newNick)\n\t{\n\t\tdebug(\"Nick\", oldNick + \" \" + newNick);\n\t}\n\n\t/**\n\t * On Notice\n\t */\n\t@Override\n\tprotected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n\t{\n\t\tdebug(\"Notice\", sourceNick + \" \" + notice);\n\t}\n\n\t/**\n\t * On Op\n\t */\n\t@Override\n\tprotected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Op\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" oped \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Part\n\t */\n\t@Override\n\tprotected void onPart(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Part\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We pareted a channel\n\t\t\tserver.removeChannel(target);\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_REMOVE));\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" parted\");\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Private Message\n\t */\n\t@Override\n\tprotected void onPrivateMessage(String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"PrivateMessage\", sender + \" \" + message);\n\t}\n\n\t/**\n\t * On Quit\n\t */\n\t@Override\n\tprotected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n\t{\n\t\tdebug(\"Quit\", sourceNick);\n\t}\n\n\t/**\n\t * On Topic\n\t */\n\t@Override\n\tprotected void onTopic(String target, String topic, String setBy, long date, boolean changed)\n\t{\n\t\tdebug(\"Topic\", target + \" \" + setBy + \" \" + topic);\n\t\t\n\t\tif (changed) {\n\t\t\tserver.getChannel(target).addMessage(setBy + \" sets topic: \" + topic);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(\"Topic: \" + topic);\n\t\t}\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On User List\n\t */\n\t@Override\n\tprotected void onUserList(String channel, User[] users)\n\t{\n\t\tdebug(\"UserList\", channel + \" (\" + users.length + \")\");\n\t}\n\n\t/**\n\t * On Voice\n\t */\n\t@Override\n\tprotected void onVoice(String channel, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Voice\", channel + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t}\n\t\n\t/**\n\t * On disconnect\n\t */\n\t@Override\n\tpublic void onDisconnect()\n\t{\n\t\tserver.setStatus(Status.DISCONNECTED);\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\n\t/**\n\t * Print an event to the debug console \n\t */\n\tprivate void debug(String event, String params)\n\t{\n\t\tif (DEBUG_EVENTS) {\n\t\t\tLog.d(TAG, \"(\" + server.getTitle() + \") [\" + event + \"]: \" + params);\n\t\t}\n\t}\n\t\n\t/**\n\t * Quits from the IRC server with default reason.\n\t */\n\t@Override\n\tpublic void quitServer()\n\t{\n\t\tquitServer(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n}\n","lineNo":161}
{"Smelly Sample":"/*\n Yaaic - Yet Another Android IRC Client\n\nCopyright 2009 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.irc;\n\nimport android.content.Intent;\nimport android.util.Log;\n\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\n\nimport org.yaaic.Yaaic;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.Status;\n\npublic class IRCConnection extends PircBot\n{\n\tprivate IRCService service;\n\tprivate Server server;\n\t\n\t// XXX: Print all IRC events to the debug console\n\tprivate static final boolean DEBUG_EVENTS = true;\n\tpublic static final String TAG = \"Yaaic/IRCConnection\";\n\t\n\t/**\n\t * Create a new connection\n\t * \n\t * @param service\n\t * @param serverId\n\t */\n\tpublic IRCConnection(IRCService service, int serverId)\n\t{\n\t\tthis.server = Yaaic.getInstance().getServerById(serverId);\n\t\tthis.service = service;\n\t\t\n\t\tthis.setName(\"Yaaic\");\n\t\tthis.setLogin(\"Yaaic\");\n\t\tthis.setAutoNickChange(true);\n\t\tthis.setVersion(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n\n\t/**\n\t * On connect\n\t */\n\t@Override\n\tpublic void onConnect()\n\t{\n\t\tdebug(\"Connect\", \"\");\n\t\t\n\t\tserver.setStatus(Status.CONNECTED);\n\t\t\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\t\n\t/**\n\t * On channel action\n\t */\n\t@Override\n\tprotected void onAction(String sender, String login, String hostname, String target, String action)\n\t{\n\t\tdebug(\"Action\", target + \" \" + sender + \" \" + action);\n\t\t\n\t\tserver.getChannel(target).addMessage(\"* \" + sender + \" \" + action);\n\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t}\n\n\t/**\n\t * On Channel Info\n\t */\n\t@Override\n\tprotected void onChannelInfo(String channel, int userCount, String topic)\n\t{\n\t\tdebug(\"ChannelInfo\", channel + \" \" + userCount);\n\t}\n\n\t/**\n\t * On Deop\n\t */\n\t@Override\n\tprotected void onDeop(String channel, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Deop\", channel + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t}\n\n\t/**\n\t * On DeVoice\n\t */\n\t@Override\n\tprotected void onDeVoice(String channel, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"DeVoice\", channel + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t}\n\n\t/**\n\t * On Invite\n\t */\n\t@Override\n\tprotected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String channel)\n\t{\n\t\tdebug(\"Invite\", channel + \" \" + targetNick + \"(\" + sourceNick + \")\");\n\t}\n\n\t/**\n\t * On Join\n\t */\n\t@Override\n\tprotected void onJoin(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Join\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We joined a new channel\n\t\t\tserver.addChannel(new Channel(target));\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_NEW));\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" joined\");\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t\t}\n\t}\n\n\t/**\n\t * On Kick\n\t */\n\t@Override\n\tprotected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n\t{\n\t\tdebug(\"Kick\", target + \" \" + recipientNick + \"(\" + kickerNick + \")\");\n\t\t\n\t\tif (recipientNick.equals(getNick())) {\n\t\t\t// We are kicked\n\t\t\tserver.removeChannel(target);\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_REMOVE));\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(kickerNick + \" kicked \" + recipientNick);\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t\t}\n\t}\n\n\t/**\n\t * On Message\n\t */\n\t@Override\n\tprotected void onMessage(String target, String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"Message\", target + \" \" + sender + \" \" + message);\n\n\t\tserver.getChannel(target).addMessage(\"<\" + sender + \">\" + message);\n\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t}\n\n\t/**\n\t * On Mode\n\t */\n\t@Override\n\tprotected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n\t{\n\t\tdebug(\"Mode\", target + \" \" + sourceNick + \" \" + mode);\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" sets mode \" + mode);\n\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t}\n\n\t/**\n\t * On Nick Change\n\t */\n\t@Override\n\tprotected void onNickChange(String oldNick, String login, String hostname, String newNick)\n\t{\n\t\tdebug(\"Nick\", oldNick + \" \" + newNick);\n\t}\n\n\t/**\n\t * On Notice\n\t */\n\t@Override\n\tprotected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n\t{\n\t\tdebug(\"Notice\", sourceNick + \" \" + notice);\n\t}\n\n\t/**\n\t * On Op\n\t */\n\t@Override\n\tprotected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Op\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" oped \" + recipient);\n\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t}\n\n\t/**\n\t * On Part\n\t */\n\t@Override\n\tprotected void onPart(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Part\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We pareted a channel\n\t\t\tserver.removeChannel(target);\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_REMOVE));\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" parted\");\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t\t}\n\t}\n\n\t/**\n\t * On Private Message\n\t */\n\t@Override\n\tprotected void onPrivateMessage(String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"PrivateMessage\", sender + \" \" + message);\n\t}\n\n\t/**\n\t * On Quit\n\t */\n\t@Override\n\tprotected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n\t{\n\t\tdebug(\"Quit\", sourceNick);\n\t}\n\n\t/**\n\t * On Topic\n\t */\n\t@Override\n\tprotected void onTopic(String target, String topic, String setBy, long date, boolean changed)\n\t{\n\t\tdebug(\"Topic\", target + \" \" + setBy + \" \" + topic);\n\t\t\n\t\tif (changed) {\n\t\t\tserver.getChannel(target).addMessage(setBy + \" sets topic: \" + topic);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(\"Topic: \" + topic);\n\t\t}\n\t\t\n\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t}\n\n\t/**\n\t * On User List\n\t */\n\t@Override\n\tprotected void onUserList(String channel, User[] users)\n\t{\n\t\tdebug(\"UserList\", channel + \" (\" + users.length + \")\");\n\t}\n\n\t/**\n\t * On Voice\n\t */\n\t@Override\n\tprotected void onVoice(String channel, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Voice\", channel + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t}\n\t\n\t/**\n\t * On disconnect\n\t */\n\t@Override\n\tpublic void onDisconnect()\n\t{\n\t\tserver.setStatus(Status.DISCONNECTED);\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\n\t/**\n\t * Print an event to the debug console \n\t */\n\tprivate void debug(String event, String params)\n\t{\n\t\tif (DEBUG_EVENTS) {\n\t\t\tLog.d(TAG, \"(\" + server.getTitle() + \") [\" + event + \"]: \" + params);\n\t\t}\n\t}\n\t\n\t/**\n\t * Quits from the IRC server with default reason.\n\t */\n\t@Override\n\tpublic void quitServer()\n\t{\n\t\tquitServer(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n}\n","Method after Refactoring":"/*\n Yaaic - Yet Another Android IRC Client\n\nCopyright 2009 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.irc;\n\nimport android.content.Intent;\nimport android.util.Log;\n\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\n\nimport org.yaaic.Yaaic;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.Status;\n\npublic class IRCConnection extends PircBot\n{\n\tprivate IRCService service;\n\tprivate Server server;\n\t\n\t// XXX: Print all IRC events to the debug console\n\tprivate static final boolean DEBUG_EVENTS = true;\n\tpublic static final String TAG = \"Yaaic/IRCConnection\";\n\t\n\t/**\n\t * Create a new connection\n\t * \n\t * @param service\n\t * @param serverId\n\t */\n\tpublic IRCConnection(IRCService service, int serverId)\n\t{\n\t\tthis.server = Yaaic.getInstance().getServerById(serverId);\n\t\tthis.service = service;\n\t\t\n\t\tthis.setName(\"Yaaic\");\n\t\tthis.setLogin(\"Yaaic\");\n\t\tthis.setAutoNickChange(true);\n\t\tthis.setVersion(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n\n\t/**\n\t * On connect\n\t */\n\t@Override\n\tpublic void onConnect()\n\t{\n\t\tdebug(\"Connect\", \"\");\n\t\t\n\t\tserver.setStatus(Status.CONNECTED);\n\t\t\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\t\n\t/**\n\t * On channel action\n\t */\n\t@Override\n\tprotected void onAction(String sender, String login, String hostname, String target, String action)\n\t{\n\t\tdebug(\"Action\", target + \" \" + sender + \" \" + action);\n\t\t\n\t\tserver.getChannel(target).addMessage(\"* \" + sender + \" \" + action);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Channel Info\n\t */\n\t@Override\n\tprotected void onChannelInfo(String channel, int userCount, String topic)\n\t{\n\t\tdebug(\"ChannelInfo\", channel + \" \" + userCount);\n\t}\n\n\t/**\n\t * On Deop\n\t */\n\t@Override\n\tprotected void onDeop(String channel, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Deop\", channel + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t}\n\n\t/**\n\t * On DeVoice\n\t */\n\t@Override\n\tprotected void onDeVoice(String channel, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"DeVoice\", channel + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t}\n\n\t/**\n\t * On Invite\n\t */\n\t@Override\n\tprotected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String channel)\n\t{\n\t\tdebug(\"Invite\", channel + \" \" + targetNick + \"(\" + sourceNick + \")\");\n\t}\n\n\t/**\n\t * On Join\n\t */\n\t@Override\n\tprotected void onJoin(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Join\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We joined a new channel\n\t\t\tserver.addChannel(new Channel(target));\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_NEW));\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" joined\");\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Kick\n\t */\n\t@Override\n\tprotected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n\t{\n\t\tdebug(\"Kick\", target + \" \" + recipientNick + \"(\" + kickerNick + \")\");\n\t\t\n\t\tif (recipientNick.equals(getNick())) {\n\t\t\t// We are kicked\n\t\t\tserver.removeChannel(target);\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_REMOVE));\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(kickerNick + \" kicked \" + recipientNick);\n\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\t\t\t\n\t\t}\n\t}\n\n\t/**\n\t * On Message\n\t */\n\t@Override\n\tprotected void onMessage(String target, String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"Message\", target + \" \" + sender + \" \" + message);\n\n\t\tserver.getChannel(target).addMessage(\"<\" + sender + \">\" + message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Mode\n\t */\n\t@Override\n\tprotected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n\t{\n\t\tdebug(\"Mode\", target + \" \" + sourceNick + \" \" + mode);\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" sets mode \" + mode);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Nick Change\n\t */\n\t@Override\n\tprotected void onNickChange(String oldNick, String login, String hostname, String newNick)\n\t{\n\t\tdebug(\"Nick\", oldNick + \" \" + newNick);\n\t}\n\n\t/**\n\t * On Notice\n\t */\n\t@Override\n\tprotected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n\t{\n\t\tdebug(\"Notice\", sourceNick + \" \" + notice);\n\t}\n\n\t/**\n\t * On Op\n\t */\n\t@Override\n\tprotected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Op\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" oped \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Part\n\t */\n\t@Override\n\tprotected void onPart(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Part\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We pareted a channel\n\t\t\tserver.removeChannel(target);\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_REMOVE));\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" parted\");\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Private Message\n\t */\n\t@Override\n\tprotected void onPrivateMessage(String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"PrivateMessage\", sender + \" \" + message);\n\t}\n\n\t/**\n\t * On Quit\n\t */\n\t@Override\n\tprotected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n\t{\n\t\tdebug(\"Quit\", sourceNick);\n\t}\n\n\t/**\n\t * On Topic\n\t */\n\t@Override\n\tprotected void onTopic(String target, String topic, String setBy, long date, boolean changed)\n\t{\n\t\tdebug(\"Topic\", target + \" \" + setBy + \" \" + topic);\n\t\t\n\t\tif (changed) {\n\t\t\tserver.getChannel(target).addMessage(setBy + \" sets topic: \" + topic);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(\"Topic: \" + topic);\n\t\t}\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On User List\n\t */\n\t@Override\n\tprotected void onUserList(String channel, User[] users)\n\t{\n\t\tdebug(\"UserList\", channel + \" (\" + users.length + \")\");\n\t}\n\n\t/**\n\t * On Voice\n\t */\n\t@Override\n\tprotected void onVoice(String channel, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Voice\", channel + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t}\n\t\n\t/**\n\t * On disconnect\n\t */\n\t@Override\n\tpublic void onDisconnect()\n\t{\n\t\tserver.setStatus(Status.DISCONNECTED);\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\n\t/**\n\t * Print an event to the debug console \n\t */\n\tprivate void debug(String event, String params)\n\t{\n\t\tif (DEBUG_EVENTS) {\n\t\t\tLog.d(TAG, \"(\" + server.getTitle() + \") [\" + event + \"]: \" + params);\n\t\t}\n\t}\n\t\n\t/**\n\t * Quits from the IRC server with default reason.\n\t */\n\t@Override\n\tpublic void quitServer()\n\t{\n\t\tquitServer(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n}\n","lineNo":177}
{"Smelly Sample":"/*\n Yaaic - Yet Another Android IRC Client\n\nCopyright 2009 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.irc;\n\nimport android.content.Intent;\nimport android.util.Log;\n\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\n\nimport org.yaaic.Yaaic;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.Status;\n\npublic class IRCConnection extends PircBot\n{\n\tprivate IRCService service;\n\tprivate Server server;\n\t\n\t// XXX: Print all IRC events to the debug console\n\tprivate static final boolean DEBUG_EVENTS = true;\n\tpublic static final String TAG = \"Yaaic/IRCConnection\";\n\t\n\t/**\n\t * Create a new connection\n\t * \n\t * @param service\n\t * @param serverId\n\t */\n\tpublic IRCConnection(IRCService service, int serverId)\n\t{\n\t\tthis.server = Yaaic.getInstance().getServerById(serverId);\n\t\tthis.service = service;\n\t\t\n\t\tthis.setName(\"Yaaic\");\n\t\tthis.setLogin(\"Yaaic\");\n\t\tthis.setAutoNickChange(true);\n\t\tthis.setVersion(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n\n\t/**\n\t * On connect\n\t */\n\t@Override\n\tpublic void onConnect()\n\t{\n\t\tdebug(\"Connect\", \"\");\n\t\t\n\t\tserver.setStatus(Status.CONNECTED);\n\t\t\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\t\n\t/**\n\t * On channel action\n\t */\n\t@Override\n\tprotected void onAction(String sender, String login, String hostname, String target, String action)\n\t{\n\t\tdebug(\"Action\", target + \" \" + sender + \" \" + action);\n\t\t\n\t\tserver.getChannel(target).addMessage(\"* \" + sender + \" \" + action);\n\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t}\n\n\t/**\n\t * On Channel Info\n\t */\n\t@Override\n\tprotected void onChannelInfo(String channel, int userCount, String topic)\n\t{\n\t\tdebug(\"ChannelInfo\", channel + \" \" + userCount);\n\t}\n\n\t/**\n\t * On Deop\n\t */\n\t@Override\n\tprotected void onDeop(String channel, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Deop\", channel + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t}\n\n\t/**\n\t * On DeVoice\n\t */\n\t@Override\n\tprotected void onDeVoice(String channel, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"DeVoice\", channel + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t}\n\n\t/**\n\t * On Invite\n\t */\n\t@Override\n\tprotected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String channel)\n\t{\n\t\tdebug(\"Invite\", channel + \" \" + targetNick + \"(\" + sourceNick + \")\");\n\t}\n\n\t/**\n\t * On Join\n\t */\n\t@Override\n\tprotected void onJoin(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Join\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We joined a new channel\n\t\t\tserver.addChannel(new Channel(target));\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_NEW));\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" joined\");\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t\t}\n\t}\n\n\t/**\n\t * On Kick\n\t */\n\t@Override\n\tprotected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n\t{\n\t\tdebug(\"Kick\", target + \" \" + recipientNick + \"(\" + kickerNick + \")\");\n\t\t\n\t\tif (recipientNick.equals(getNick())) {\n\t\t\t// We are kicked\n\t\t\tserver.removeChannel(target);\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_REMOVE));\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(kickerNick + \" kicked \" + recipientNick);\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t\t}\n\t}\n\n\t/**\n\t * On Message\n\t */\n\t@Override\n\tprotected void onMessage(String target, String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"Message\", target + \" \" + sender + \" \" + message);\n\n\t\tserver.getChannel(target).addMessage(\"<\" + sender + \">\" + message);\n\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t}\n\n\t/**\n\t * On Mode\n\t */\n\t@Override\n\tprotected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n\t{\n\t\tdebug(\"Mode\", target + \" \" + sourceNick + \" \" + mode);\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" sets mode \" + mode);\n\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t}\n\n\t/**\n\t * On Nick Change\n\t */\n\t@Override\n\tprotected void onNickChange(String oldNick, String login, String hostname, String newNick)\n\t{\n\t\tdebug(\"Nick\", oldNick + \" \" + newNick);\n\t}\n\n\t/**\n\t * On Notice\n\t */\n\t@Override\n\tprotected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n\t{\n\t\tdebug(\"Notice\", sourceNick + \" \" + notice);\n\t}\n\n\t/**\n\t * On Op\n\t */\n\t@Override\n\tprotected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Op\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" oped \" + recipient);\n\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t}\n\n\t/**\n\t * On Part\n\t */\n\t@Override\n\tprotected void onPart(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Part\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We pareted a channel\n\t\t\tserver.removeChannel(target);\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_REMOVE));\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" parted\");\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t\t}\n\t}\n\n\t/**\n\t * On Private Message\n\t */\n\t@Override\n\tprotected void onPrivateMessage(String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"PrivateMessage\", sender + \" \" + message);\n\t}\n\n\t/**\n\t * On Quit\n\t */\n\t@Override\n\tprotected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n\t{\n\t\tdebug(\"Quit\", sourceNick);\n\t}\n\n\t/**\n\t * On Topic\n\t */\n\t@Override\n\tprotected void onTopic(String target, String topic, String setBy, long date, boolean changed)\n\t{\n\t\tdebug(\"Topic\", target + \" \" + setBy + \" \" + topic);\n\t\t\n\t\tif (changed) {\n\t\t\tserver.getChannel(target).addMessage(setBy + \" sets topic: \" + topic);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(\"Topic: \" + topic);\n\t\t}\n\t\t\n\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t}\n\n\t/**\n\t * On User List\n\t */\n\t@Override\n\tprotected void onUserList(String channel, User[] users)\n\t{\n\t\tdebug(\"UserList\", channel + \" (\" + users.length + \")\");\n\t}\n\n\t/**\n\t * On Voice\n\t */\n\t@Override\n\tprotected void onVoice(String channel, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Voice\", channel + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t}\n\t\n\t/**\n\t * On disconnect\n\t */\n\t@Override\n\tpublic void onDisconnect()\n\t{\n\t\tserver.setStatus(Status.DISCONNECTED);\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\n\t/**\n\t * Print an event to the debug console \n\t */\n\tprivate void debug(String event, String params)\n\t{\n\t\tif (DEBUG_EVENTS) {\n\t\t\tLog.d(TAG, \"(\" + server.getTitle() + \") [\" + event + \"]: \" + params);\n\t\t}\n\t}\n\t\n\t/**\n\t * Quits from the IRC server with default reason.\n\t */\n\t@Override\n\tpublic void quitServer()\n\t{\n\t\tquitServer(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n}\n","Method after Refactoring":"/*\n Yaaic - Yet Another Android IRC Client\n\nCopyright 2009 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.irc;\n\nimport android.content.Intent;\nimport android.util.Log;\n\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\n\nimport org.yaaic.Yaaic;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.Status;\n\npublic class IRCConnection extends PircBot\n{\n\tprivate IRCService service;\n\tprivate Server server;\n\t\n\t// XXX: Print all IRC events to the debug console\n\tprivate static final boolean DEBUG_EVENTS = true;\n\tpublic static final String TAG = \"Yaaic/IRCConnection\";\n\t\n\t/**\n\t * Create a new connection\n\t * \n\t * @param service\n\t * @param serverId\n\t */\n\tpublic IRCConnection(IRCService service, int serverId)\n\t{\n\t\tthis.server = Yaaic.getInstance().getServerById(serverId);\n\t\tthis.service = service;\n\t\t\n\t\tthis.setName(\"Yaaic\");\n\t\tthis.setLogin(\"Yaaic\");\n\t\tthis.setAutoNickChange(true);\n\t\tthis.setVersion(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n\n\t/**\n\t * On connect\n\t */\n\t@Override\n\tpublic void onConnect()\n\t{\n\t\tdebug(\"Connect\", \"\");\n\t\t\n\t\tserver.setStatus(Status.CONNECTED);\n\t\t\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\t\n\t/**\n\t * On channel action\n\t */\n\t@Override\n\tprotected void onAction(String sender, String login, String hostname, String target, String action)\n\t{\n\t\tdebug(\"Action\", target + \" \" + sender + \" \" + action);\n\t\t\n\t\tserver.getChannel(target).addMessage(\"* \" + sender + \" \" + action);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Channel Info\n\t */\n\t@Override\n\tprotected void onChannelInfo(String channel, int userCount, String topic)\n\t{\n\t\tdebug(\"ChannelInfo\", channel + \" \" + userCount);\n\t}\n\n\t/**\n\t * On Deop\n\t */\n\t@Override\n\tprotected void onDeop(String channel, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Deop\", channel + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t}\n\n\t/**\n\t * On DeVoice\n\t */\n\t@Override\n\tprotected void onDeVoice(String channel, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"DeVoice\", channel + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t}\n\n\t/**\n\t * On Invite\n\t */\n\t@Override\n\tprotected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String channel)\n\t{\n\t\tdebug(\"Invite\", channel + \" \" + targetNick + \"(\" + sourceNick + \")\");\n\t}\n\n\t/**\n\t * On Join\n\t */\n\t@Override\n\tprotected void onJoin(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Join\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We joined a new channel\n\t\t\tserver.addChannel(new Channel(target));\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_NEW));\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" joined\");\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Kick\n\t */\n\t@Override\n\tprotected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n\t{\n\t\tdebug(\"Kick\", target + \" \" + recipientNick + \"(\" + kickerNick + \")\");\n\t\t\n\t\tif (recipientNick.equals(getNick())) {\n\t\t\t// We are kicked\n\t\t\tserver.removeChannel(target);\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_REMOVE));\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(kickerNick + \" kicked \" + recipientNick);\n\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\t\t\t\n\t\t}\n\t}\n\n\t/**\n\t * On Message\n\t */\n\t@Override\n\tprotected void onMessage(String target, String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"Message\", target + \" \" + sender + \" \" + message);\n\n\t\tserver.getChannel(target).addMessage(\"<\" + sender + \">\" + message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Mode\n\t */\n\t@Override\n\tprotected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n\t{\n\t\tdebug(\"Mode\", target + \" \" + sourceNick + \" \" + mode);\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" sets mode \" + mode);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Nick Change\n\t */\n\t@Override\n\tprotected void onNickChange(String oldNick, String login, String hostname, String newNick)\n\t{\n\t\tdebug(\"Nick\", oldNick + \" \" + newNick);\n\t}\n\n\t/**\n\t * On Notice\n\t */\n\t@Override\n\tprotected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n\t{\n\t\tdebug(\"Notice\", sourceNick + \" \" + notice);\n\t}\n\n\t/**\n\t * On Op\n\t */\n\t@Override\n\tprotected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Op\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" oped \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Part\n\t */\n\t@Override\n\tprotected void onPart(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Part\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We pareted a channel\n\t\t\tserver.removeChannel(target);\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_REMOVE));\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" parted\");\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Private Message\n\t */\n\t@Override\n\tprotected void onPrivateMessage(String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"PrivateMessage\", sender + \" \" + message);\n\t}\n\n\t/**\n\t * On Quit\n\t */\n\t@Override\n\tprotected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n\t{\n\t\tdebug(\"Quit\", sourceNick);\n\t}\n\n\t/**\n\t * On Topic\n\t */\n\t@Override\n\tprotected void onTopic(String target, String topic, String setBy, long date, boolean changed)\n\t{\n\t\tdebug(\"Topic\", target + \" \" + setBy + \" \" + topic);\n\t\t\n\t\tif (changed) {\n\t\t\tserver.getChannel(target).addMessage(setBy + \" sets topic: \" + topic);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(\"Topic: \" + topic);\n\t\t}\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On User List\n\t */\n\t@Override\n\tprotected void onUserList(String channel, User[] users)\n\t{\n\t\tdebug(\"UserList\", channel + \" (\" + users.length + \")\");\n\t}\n\n\t/**\n\t * On Voice\n\t */\n\t@Override\n\tprotected void onVoice(String channel, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Voice\", channel + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t}\n\t\n\t/**\n\t * On disconnect\n\t */\n\t@Override\n\tpublic void onDisconnect()\n\t{\n\t\tserver.setStatus(Status.DISCONNECTED);\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\n\t/**\n\t * Print an event to the debug console \n\t */\n\tprivate void debug(String event, String params)\n\t{\n\t\tif (DEBUG_EVENTS) {\n\t\t\tLog.d(TAG, \"(\" + server.getTitle() + \") [\" + event + \"]: \" + params);\n\t\t}\n\t}\n\t\n\t/**\n\t * Quits from the IRC server with default reason.\n\t */\n\t@Override\n\tpublic void quitServer()\n\t{\n\t\tquitServer(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n}\n","lineNo":192}
{"Smelly Sample":"/*\n Yaaic - Yet Another Android IRC Client\n\nCopyright 2009 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.irc;\n\nimport android.content.Intent;\nimport android.util.Log;\n\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\n\nimport org.yaaic.Yaaic;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.Status;\n\npublic class IRCConnection extends PircBot\n{\n\tprivate IRCService service;\n\tprivate Server server;\n\t\n\t// XXX: Print all IRC events to the debug console\n\tprivate static final boolean DEBUG_EVENTS = true;\n\tpublic static final String TAG = \"Yaaic/IRCConnection\";\n\t\n\t/**\n\t * Create a new connection\n\t * \n\t * @param service\n\t * @param serverId\n\t */\n\tpublic IRCConnection(IRCService service, int serverId)\n\t{\n\t\tthis.server = Yaaic.getInstance().getServerById(serverId);\n\t\tthis.service = service;\n\t\t\n\t\tthis.setName(\"Yaaic\");\n\t\tthis.setLogin(\"Yaaic\");\n\t\tthis.setAutoNickChange(true);\n\t\tthis.setVersion(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n\n\t/**\n\t * On connect\n\t */\n\t@Override\n\tpublic void onConnect()\n\t{\n\t\tdebug(\"Connect\", \"\");\n\t\t\n\t\tserver.setStatus(Status.CONNECTED);\n\t\t\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\t\n\t/**\n\t * On channel action\n\t */\n\t@Override\n\tprotected void onAction(String sender, String login, String hostname, String target, String action)\n\t{\n\t\tdebug(\"Action\", target + \" \" + sender + \" \" + action);\n\t\t\n\t\tserver.getChannel(target).addMessage(\"* \" + sender + \" \" + action);\n\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t}\n\n\t/**\n\t * On Channel Info\n\t */\n\t@Override\n\tprotected void onChannelInfo(String channel, int userCount, String topic)\n\t{\n\t\tdebug(\"ChannelInfo\", channel + \" \" + userCount);\n\t}\n\n\t/**\n\t * On Deop\n\t */\n\t@Override\n\tprotected void onDeop(String channel, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Deop\", channel + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t}\n\n\t/**\n\t * On DeVoice\n\t */\n\t@Override\n\tprotected void onDeVoice(String channel, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"DeVoice\", channel + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t}\n\n\t/**\n\t * On Invite\n\t */\n\t@Override\n\tprotected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String channel)\n\t{\n\t\tdebug(\"Invite\", channel + \" \" + targetNick + \"(\" + sourceNick + \")\");\n\t}\n\n\t/**\n\t * On Join\n\t */\n\t@Override\n\tprotected void onJoin(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Join\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We joined a new channel\n\t\t\tserver.addChannel(new Channel(target));\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_NEW));\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" joined\");\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t\t}\n\t}\n\n\t/**\n\t * On Kick\n\t */\n\t@Override\n\tprotected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n\t{\n\t\tdebug(\"Kick\", target + \" \" + recipientNick + \"(\" + kickerNick + \")\");\n\t\t\n\t\tif (recipientNick.equals(getNick())) {\n\t\t\t// We are kicked\n\t\t\tserver.removeChannel(target);\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_REMOVE));\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(kickerNick + \" kicked \" + recipientNick);\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t\t}\n\t}\n\n\t/**\n\t * On Message\n\t */\n\t@Override\n\tprotected void onMessage(String target, String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"Message\", target + \" \" + sender + \" \" + message);\n\n\t\tserver.getChannel(target).addMessage(\"<\" + sender + \">\" + message);\n\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t}\n\n\t/**\n\t * On Mode\n\t */\n\t@Override\n\tprotected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n\t{\n\t\tdebug(\"Mode\", target + \" \" + sourceNick + \" \" + mode);\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" sets mode \" + mode);\n\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t}\n\n\t/**\n\t * On Nick Change\n\t */\n\t@Override\n\tprotected void onNickChange(String oldNick, String login, String hostname, String newNick)\n\t{\n\t\tdebug(\"Nick\", oldNick + \" \" + newNick);\n\t}\n\n\t/**\n\t * On Notice\n\t */\n\t@Override\n\tprotected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n\t{\n\t\tdebug(\"Notice\", sourceNick + \" \" + notice);\n\t}\n\n\t/**\n\t * On Op\n\t */\n\t@Override\n\tprotected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Op\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" oped \" + recipient);\n\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t}\n\n\t/**\n\t * On Part\n\t */\n\t@Override\n\tprotected void onPart(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Part\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We pareted a channel\n\t\t\tserver.removeChannel(target);\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_REMOVE));\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" parted\");\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t\t}\n\t}\n\n\t/**\n\t * On Private Message\n\t */\n\t@Override\n\tprotected void onPrivateMessage(String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"PrivateMessage\", sender + \" \" + message);\n\t}\n\n\t/**\n\t * On Quit\n\t */\n\t@Override\n\tprotected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n\t{\n\t\tdebug(\"Quit\", sourceNick);\n\t}\n\n\t/**\n\t * On Topic\n\t */\n\t@Override\n\tprotected void onTopic(String target, String topic, String setBy, long date, boolean changed)\n\t{\n\t\tdebug(\"Topic\", target + \" \" + setBy + \" \" + topic);\n\t\t\n\t\tif (changed) {\n\t\t\tserver.getChannel(target).addMessage(setBy + \" sets topic: \" + topic);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(\"Topic: \" + topic);\n\t\t}\n\t\t\n\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t}\n\n\t/**\n\t * On User List\n\t */\n\t@Override\n\tprotected void onUserList(String channel, User[] users)\n\t{\n\t\tdebug(\"UserList\", channel + \" (\" + users.length + \")\");\n\t}\n\n\t/**\n\t * On Voice\n\t */\n\t@Override\n\tprotected void onVoice(String channel, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Voice\", channel + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t}\n\t\n\t/**\n\t * On disconnect\n\t */\n\t@Override\n\tpublic void onDisconnect()\n\t{\n\t\tserver.setStatus(Status.DISCONNECTED);\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\n\t/**\n\t * Print an event to the debug console \n\t */\n\tprivate void debug(String event, String params)\n\t{\n\t\tif (DEBUG_EVENTS) {\n\t\t\tLog.d(TAG, \"(\" + server.getTitle() + \") [\" + event + \"]: \" + params);\n\t\t}\n\t}\n\t\n\t/**\n\t * Quits from the IRC server with default reason.\n\t */\n\t@Override\n\tpublic void quitServer()\n\t{\n\t\tquitServer(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n}\n","Method after Refactoring":"/*\n Yaaic - Yet Another Android IRC Client\n\nCopyright 2009 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.irc;\n\nimport android.content.Intent;\nimport android.util.Log;\n\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\n\nimport org.yaaic.Yaaic;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.Status;\n\npublic class IRCConnection extends PircBot\n{\n\tprivate IRCService service;\n\tprivate Server server;\n\t\n\t// XXX: Print all IRC events to the debug console\n\tprivate static final boolean DEBUG_EVENTS = true;\n\tpublic static final String TAG = \"Yaaic/IRCConnection\";\n\t\n\t/**\n\t * Create a new connection\n\t * \n\t * @param service\n\t * @param serverId\n\t */\n\tpublic IRCConnection(IRCService service, int serverId)\n\t{\n\t\tthis.server = Yaaic.getInstance().getServerById(serverId);\n\t\tthis.service = service;\n\t\t\n\t\tthis.setName(\"Yaaic\");\n\t\tthis.setLogin(\"Yaaic\");\n\t\tthis.setAutoNickChange(true);\n\t\tthis.setVersion(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n\n\t/**\n\t * On connect\n\t */\n\t@Override\n\tpublic void onConnect()\n\t{\n\t\tdebug(\"Connect\", \"\");\n\t\t\n\t\tserver.setStatus(Status.CONNECTED);\n\t\t\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\t\n\t/**\n\t * On channel action\n\t */\n\t@Override\n\tprotected void onAction(String sender, String login, String hostname, String target, String action)\n\t{\n\t\tdebug(\"Action\", target + \" \" + sender + \" \" + action);\n\t\t\n\t\tserver.getChannel(target).addMessage(\"* \" + sender + \" \" + action);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Channel Info\n\t */\n\t@Override\n\tprotected void onChannelInfo(String channel, int userCount, String topic)\n\t{\n\t\tdebug(\"ChannelInfo\", channel + \" \" + userCount);\n\t}\n\n\t/**\n\t * On Deop\n\t */\n\t@Override\n\tprotected void onDeop(String channel, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Deop\", channel + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t}\n\n\t/**\n\t * On DeVoice\n\t */\n\t@Override\n\tprotected void onDeVoice(String channel, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"DeVoice\", channel + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t}\n\n\t/**\n\t * On Invite\n\t */\n\t@Override\n\tprotected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String channel)\n\t{\n\t\tdebug(\"Invite\", channel + \" \" + targetNick + \"(\" + sourceNick + \")\");\n\t}\n\n\t/**\n\t * On Join\n\t */\n\t@Override\n\tprotected void onJoin(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Join\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We joined a new channel\n\t\t\tserver.addChannel(new Channel(target));\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_NEW));\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" joined\");\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Kick\n\t */\n\t@Override\n\tprotected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n\t{\n\t\tdebug(\"Kick\", target + \" \" + recipientNick + \"(\" + kickerNick + \")\");\n\t\t\n\t\tif (recipientNick.equals(getNick())) {\n\t\t\t// We are kicked\n\t\t\tserver.removeChannel(target);\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_REMOVE));\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(kickerNick + \" kicked \" + recipientNick);\n\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\t\t\t\n\t\t}\n\t}\n\n\t/**\n\t * On Message\n\t */\n\t@Override\n\tprotected void onMessage(String target, String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"Message\", target + \" \" + sender + \" \" + message);\n\n\t\tserver.getChannel(target).addMessage(\"<\" + sender + \">\" + message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Mode\n\t */\n\t@Override\n\tprotected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n\t{\n\t\tdebug(\"Mode\", target + \" \" + sourceNick + \" \" + mode);\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" sets mode \" + mode);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Nick Change\n\t */\n\t@Override\n\tprotected void onNickChange(String oldNick, String login, String hostname, String newNick)\n\t{\n\t\tdebug(\"Nick\", oldNick + \" \" + newNick);\n\t}\n\n\t/**\n\t * On Notice\n\t */\n\t@Override\n\tprotected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n\t{\n\t\tdebug(\"Notice\", sourceNick + \" \" + notice);\n\t}\n\n\t/**\n\t * On Op\n\t */\n\t@Override\n\tprotected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Op\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" oped \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Part\n\t */\n\t@Override\n\tprotected void onPart(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Part\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We pareted a channel\n\t\t\tserver.removeChannel(target);\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_REMOVE));\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" parted\");\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Private Message\n\t */\n\t@Override\n\tprotected void onPrivateMessage(String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"PrivateMessage\", sender + \" \" + message);\n\t}\n\n\t/**\n\t * On Quit\n\t */\n\t@Override\n\tprotected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n\t{\n\t\tdebug(\"Quit\", sourceNick);\n\t}\n\n\t/**\n\t * On Topic\n\t */\n\t@Override\n\tprotected void onTopic(String target, String topic, String setBy, long date, boolean changed)\n\t{\n\t\tdebug(\"Topic\", target + \" \" + setBy + \" \" + topic);\n\t\t\n\t\tif (changed) {\n\t\t\tserver.getChannel(target).addMessage(setBy + \" sets topic: \" + topic);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(\"Topic: \" + topic);\n\t\t}\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On User List\n\t */\n\t@Override\n\tprotected void onUserList(String channel, User[] users)\n\t{\n\t\tdebug(\"UserList\", channel + \" (\" + users.length + \")\");\n\t}\n\n\t/**\n\t * On Voice\n\t */\n\t@Override\n\tprotected void onVoice(String channel, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Voice\", channel + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t}\n\t\n\t/**\n\t * On disconnect\n\t */\n\t@Override\n\tpublic void onDisconnect()\n\t{\n\t\tserver.setStatus(Status.DISCONNECTED);\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\n\t/**\n\t * Print an event to the debug console \n\t */\n\tprivate void debug(String event, String params)\n\t{\n\t\tif (DEBUG_EVENTS) {\n\t\t\tLog.d(TAG, \"(\" + server.getTitle() + \") [\" + event + \"]: \" + params);\n\t\t}\n\t}\n\t\n\t/**\n\t * Quits from the IRC server with default reason.\n\t */\n\t@Override\n\tpublic void quitServer()\n\t{\n\t\tquitServer(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n}\n","lineNo":225}
{"Smelly Sample":"/*\n Yaaic - Yet Another Android IRC Client\n\nCopyright 2009 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.irc;\n\nimport android.content.Intent;\nimport android.util.Log;\n\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\n\nimport org.yaaic.Yaaic;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.Status;\n\npublic class IRCConnection extends PircBot\n{\n\tprivate IRCService service;\n\tprivate Server server;\n\t\n\t// XXX: Print all IRC events to the debug console\n\tprivate static final boolean DEBUG_EVENTS = true;\n\tpublic static final String TAG = \"Yaaic/IRCConnection\";\n\t\n\t/**\n\t * Create a new connection\n\t * \n\t * @param service\n\t * @param serverId\n\t */\n\tpublic IRCConnection(IRCService service, int serverId)\n\t{\n\t\tthis.server = Yaaic.getInstance().getServerById(serverId);\n\t\tthis.service = service;\n\t\t\n\t\tthis.setName(\"Yaaic\");\n\t\tthis.setLogin(\"Yaaic\");\n\t\tthis.setAutoNickChange(true);\n\t\tthis.setVersion(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n\n\t/**\n\t * On connect\n\t */\n\t@Override\n\tpublic void onConnect()\n\t{\n\t\tdebug(\"Connect\", \"\");\n\t\t\n\t\tserver.setStatus(Status.CONNECTED);\n\t\t\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\t\n\t/**\n\t * On channel action\n\t */\n\t@Override\n\tprotected void onAction(String sender, String login, String hostname, String target, String action)\n\t{\n\t\tdebug(\"Action\", target + \" \" + sender + \" \" + action);\n\t\t\n\t\tserver.getChannel(target).addMessage(\"* \" + sender + \" \" + action);\n\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t}\n\n\t/**\n\t * On Channel Info\n\t */\n\t@Override\n\tprotected void onChannelInfo(String channel, int userCount, String topic)\n\t{\n\t\tdebug(\"ChannelInfo\", channel + \" \" + userCount);\n\t}\n\n\t/**\n\t * On Deop\n\t */\n\t@Override\n\tprotected void onDeop(String channel, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Deop\", channel + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t}\n\n\t/**\n\t * On DeVoice\n\t */\n\t@Override\n\tprotected void onDeVoice(String channel, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"DeVoice\", channel + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t}\n\n\t/**\n\t * On Invite\n\t */\n\t@Override\n\tprotected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String channel)\n\t{\n\t\tdebug(\"Invite\", channel + \" \" + targetNick + \"(\" + sourceNick + \")\");\n\t}\n\n\t/**\n\t * On Join\n\t */\n\t@Override\n\tprotected void onJoin(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Join\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We joined a new channel\n\t\t\tserver.addChannel(new Channel(target));\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_NEW));\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" joined\");\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t\t}\n\t}\n\n\t/**\n\t * On Kick\n\t */\n\t@Override\n\tprotected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n\t{\n\t\tdebug(\"Kick\", target + \" \" + recipientNick + \"(\" + kickerNick + \")\");\n\t\t\n\t\tif (recipientNick.equals(getNick())) {\n\t\t\t// We are kicked\n\t\t\tserver.removeChannel(target);\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_REMOVE));\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(kickerNick + \" kicked \" + recipientNick);\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t\t}\n\t}\n\n\t/**\n\t * On Message\n\t */\n\t@Override\n\tprotected void onMessage(String target, String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"Message\", target + \" \" + sender + \" \" + message);\n\n\t\tserver.getChannel(target).addMessage(\"<\" + sender + \">\" + message);\n\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t}\n\n\t/**\n\t * On Mode\n\t */\n\t@Override\n\tprotected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n\t{\n\t\tdebug(\"Mode\", target + \" \" + sourceNick + \" \" + mode);\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" sets mode \" + mode);\n\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t}\n\n\t/**\n\t * On Nick Change\n\t */\n\t@Override\n\tprotected void onNickChange(String oldNick, String login, String hostname, String newNick)\n\t{\n\t\tdebug(\"Nick\", oldNick + \" \" + newNick);\n\t}\n\n\t/**\n\t * On Notice\n\t */\n\t@Override\n\tprotected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n\t{\n\t\tdebug(\"Notice\", sourceNick + \" \" + notice);\n\t}\n\n\t/**\n\t * On Op\n\t */\n\t@Override\n\tprotected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Op\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" oped \" + recipient);\n\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t}\n\n\t/**\n\t * On Part\n\t */\n\t@Override\n\tprotected void onPart(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Part\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We pareted a channel\n\t\t\tserver.removeChannel(target);\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_REMOVE));\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" parted\");\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t\t}\n\t}\n\n\t/**\n\t * On Private Message\n\t */\n\t@Override\n\tprotected void onPrivateMessage(String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"PrivateMessage\", sender + \" \" + message);\n\t}\n\n\t/**\n\t * On Quit\n\t */\n\t@Override\n\tprotected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n\t{\n\t\tdebug(\"Quit\", sourceNick);\n\t}\n\n\t/**\n\t * On Topic\n\t */\n\t@Override\n\tprotected void onTopic(String target, String topic, String setBy, long date, boolean changed)\n\t{\n\t\tdebug(\"Topic\", target + \" \" + setBy + \" \" + topic);\n\t\t\n\t\tif (changed) {\n\t\t\tserver.getChannel(target).addMessage(setBy + \" sets topic: \" + topic);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(\"Topic: \" + topic);\n\t\t}\n\t\t\n\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t}\n\n\t/**\n\t * On User List\n\t */\n\t@Override\n\tprotected void onUserList(String channel, User[] users)\n\t{\n\t\tdebug(\"UserList\", channel + \" (\" + users.length + \")\");\n\t}\n\n\t/**\n\t * On Voice\n\t */\n\t@Override\n\tprotected void onVoice(String channel, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Voice\", channel + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t}\n\t\n\t/**\n\t * On disconnect\n\t */\n\t@Override\n\tpublic void onDisconnect()\n\t{\n\t\tserver.setStatus(Status.DISCONNECTED);\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\n\t/**\n\t * Print an event to the debug console \n\t */\n\tprivate void debug(String event, String params)\n\t{\n\t\tif (DEBUG_EVENTS) {\n\t\t\tLog.d(TAG, \"(\" + server.getTitle() + \") [\" + event + \"]: \" + params);\n\t\t}\n\t}\n\t\n\t/**\n\t * Quits from the IRC server with default reason.\n\t */\n\t@Override\n\tpublic void quitServer()\n\t{\n\t\tquitServer(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n}\n","Method after Refactoring":"/*\n Yaaic - Yet Another Android IRC Client\n\nCopyright 2009 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.irc;\n\nimport android.content.Intent;\nimport android.util.Log;\n\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\n\nimport org.yaaic.Yaaic;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.Status;\n\npublic class IRCConnection extends PircBot\n{\n\tprivate IRCService service;\n\tprivate Server server;\n\t\n\t// XXX: Print all IRC events to the debug console\n\tprivate static final boolean DEBUG_EVENTS = true;\n\tpublic static final String TAG = \"Yaaic/IRCConnection\";\n\t\n\t/**\n\t * Create a new connection\n\t * \n\t * @param service\n\t * @param serverId\n\t */\n\tpublic IRCConnection(IRCService service, int serverId)\n\t{\n\t\tthis.server = Yaaic.getInstance().getServerById(serverId);\n\t\tthis.service = service;\n\t\t\n\t\tthis.setName(\"Yaaic\");\n\t\tthis.setLogin(\"Yaaic\");\n\t\tthis.setAutoNickChange(true);\n\t\tthis.setVersion(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n\n\t/**\n\t * On connect\n\t */\n\t@Override\n\tpublic void onConnect()\n\t{\n\t\tdebug(\"Connect\", \"\");\n\t\t\n\t\tserver.setStatus(Status.CONNECTED);\n\t\t\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\t\n\t/**\n\t * On channel action\n\t */\n\t@Override\n\tprotected void onAction(String sender, String login, String hostname, String target, String action)\n\t{\n\t\tdebug(\"Action\", target + \" \" + sender + \" \" + action);\n\t\t\n\t\tserver.getChannel(target).addMessage(\"* \" + sender + \" \" + action);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Channel Info\n\t */\n\t@Override\n\tprotected void onChannelInfo(String channel, int userCount, String topic)\n\t{\n\t\tdebug(\"ChannelInfo\", channel + \" \" + userCount);\n\t}\n\n\t/**\n\t * On Deop\n\t */\n\t@Override\n\tprotected void onDeop(String channel, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Deop\", channel + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t}\n\n\t/**\n\t * On DeVoice\n\t */\n\t@Override\n\tprotected void onDeVoice(String channel, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"DeVoice\", channel + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t}\n\n\t/**\n\t * On Invite\n\t */\n\t@Override\n\tprotected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String channel)\n\t{\n\t\tdebug(\"Invite\", channel + \" \" + targetNick + \"(\" + sourceNick + \")\");\n\t}\n\n\t/**\n\t * On Join\n\t */\n\t@Override\n\tprotected void onJoin(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Join\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We joined a new channel\n\t\t\tserver.addChannel(new Channel(target));\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_NEW));\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" joined\");\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Kick\n\t */\n\t@Override\n\tprotected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n\t{\n\t\tdebug(\"Kick\", target + \" \" + recipientNick + \"(\" + kickerNick + \")\");\n\t\t\n\t\tif (recipientNick.equals(getNick())) {\n\t\t\t// We are kicked\n\t\t\tserver.removeChannel(target);\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_REMOVE));\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(kickerNick + \" kicked \" + recipientNick);\n\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\t\t\t\n\t\t}\n\t}\n\n\t/**\n\t * On Message\n\t */\n\t@Override\n\tprotected void onMessage(String target, String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"Message\", target + \" \" + sender + \" \" + message);\n\n\t\tserver.getChannel(target).addMessage(\"<\" + sender + \">\" + message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Mode\n\t */\n\t@Override\n\tprotected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n\t{\n\t\tdebug(\"Mode\", target + \" \" + sourceNick + \" \" + mode);\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" sets mode \" + mode);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Nick Change\n\t */\n\t@Override\n\tprotected void onNickChange(String oldNick, String login, String hostname, String newNick)\n\t{\n\t\tdebug(\"Nick\", oldNick + \" \" + newNick);\n\t}\n\n\t/**\n\t * On Notice\n\t */\n\t@Override\n\tprotected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n\t{\n\t\tdebug(\"Notice\", sourceNick + \" \" + notice);\n\t}\n\n\t/**\n\t * On Op\n\t */\n\t@Override\n\tprotected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Op\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" oped \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Part\n\t */\n\t@Override\n\tprotected void onPart(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Part\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We pareted a channel\n\t\t\tserver.removeChannel(target);\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_REMOVE));\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" parted\");\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Private Message\n\t */\n\t@Override\n\tprotected void onPrivateMessage(String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"PrivateMessage\", sender + \" \" + message);\n\t}\n\n\t/**\n\t * On Quit\n\t */\n\t@Override\n\tprotected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n\t{\n\t\tdebug(\"Quit\", sourceNick);\n\t}\n\n\t/**\n\t * On Topic\n\t */\n\t@Override\n\tprotected void onTopic(String target, String topic, String setBy, long date, boolean changed)\n\t{\n\t\tdebug(\"Topic\", target + \" \" + setBy + \" \" + topic);\n\t\t\n\t\tif (changed) {\n\t\t\tserver.getChannel(target).addMessage(setBy + \" sets topic: \" + topic);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(\"Topic: \" + topic);\n\t\t}\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On User List\n\t */\n\t@Override\n\tprotected void onUserList(String channel, User[] users)\n\t{\n\t\tdebug(\"UserList\", channel + \" (\" + users.length + \")\");\n\t}\n\n\t/**\n\t * On Voice\n\t */\n\t@Override\n\tprotected void onVoice(String channel, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Voice\", channel + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t}\n\t\n\t/**\n\t * On disconnect\n\t */\n\t@Override\n\tpublic void onDisconnect()\n\t{\n\t\tserver.setStatus(Status.DISCONNECTED);\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\n\t/**\n\t * Print an event to the debug console \n\t */\n\tprivate void debug(String event, String params)\n\t{\n\t\tif (DEBUG_EVENTS) {\n\t\t\tLog.d(TAG, \"(\" + server.getTitle() + \") [\" + event + \"]: \" + params);\n\t\t}\n\t}\n\t\n\t/**\n\t * Quits from the IRC server with default reason.\n\t */\n\t@Override\n\tpublic void quitServer()\n\t{\n\t\tquitServer(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n}\n","lineNo":245}
{"Smelly Sample":"/*\n Yaaic - Yet Another Android IRC Client\n\nCopyright 2009 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.irc;\n\nimport android.content.Intent;\nimport android.util.Log;\n\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\n\nimport org.yaaic.Yaaic;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.Status;\n\npublic class IRCConnection extends PircBot\n{\n\tprivate IRCService service;\n\tprivate Server server;\n\t\n\t// XXX: Print all IRC events to the debug console\n\tprivate static final boolean DEBUG_EVENTS = true;\n\tpublic static final String TAG = \"Yaaic/IRCConnection\";\n\t\n\t/**\n\t * Create a new connection\n\t * \n\t * @param service\n\t * @param serverId\n\t */\n\tpublic IRCConnection(IRCService service, int serverId)\n\t{\n\t\tthis.server = Yaaic.getInstance().getServerById(serverId);\n\t\tthis.service = service;\n\t\t\n\t\tthis.setName(\"Yaaic\");\n\t\tthis.setLogin(\"Yaaic\");\n\t\tthis.setAutoNickChange(true);\n\t\tthis.setVersion(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n\n\t/**\n\t * On connect\n\t */\n\t@Override\n\tpublic void onConnect()\n\t{\n\t\tdebug(\"Connect\", \"\");\n\t\t\n\t\tserver.setStatus(Status.CONNECTED);\n\t\t\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\t\n\t/**\n\t * On channel action\n\t */\n\t@Override\n\tprotected void onAction(String sender, String login, String hostname, String target, String action)\n\t{\n\t\tdebug(\"Action\", target + \" \" + sender + \" \" + action);\n\t\t\n\t\tserver.getChannel(target).addMessage(\"* \" + sender + \" \" + action);\n\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t}\n\n\t/**\n\t * On Channel Info\n\t */\n\t@Override\n\tprotected void onChannelInfo(String channel, int userCount, String topic)\n\t{\n\t\tdebug(\"ChannelInfo\", channel + \" \" + userCount);\n\t}\n\n\t/**\n\t * On Deop\n\t */\n\t@Override\n\tprotected void onDeop(String channel, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Deop\", channel + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t}\n\n\t/**\n\t * On DeVoice\n\t */\n\t@Override\n\tprotected void onDeVoice(String channel, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"DeVoice\", channel + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t}\n\n\t/**\n\t * On Invite\n\t */\n\t@Override\n\tprotected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String channel)\n\t{\n\t\tdebug(\"Invite\", channel + \" \" + targetNick + \"(\" + sourceNick + \")\");\n\t}\n\n\t/**\n\t * On Join\n\t */\n\t@Override\n\tprotected void onJoin(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Join\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We joined a new channel\n\t\t\tserver.addChannel(new Channel(target));\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_NEW));\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" joined\");\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t\t}\n\t}\n\n\t/**\n\t * On Kick\n\t */\n\t@Override\n\tprotected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n\t{\n\t\tdebug(\"Kick\", target + \" \" + recipientNick + \"(\" + kickerNick + \")\");\n\t\t\n\t\tif (recipientNick.equals(getNick())) {\n\t\t\t// We are kicked\n\t\t\tserver.removeChannel(target);\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_REMOVE));\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(kickerNick + \" kicked \" + recipientNick);\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t\t}\n\t}\n\n\t/**\n\t * On Message\n\t */\n\t@Override\n\tprotected void onMessage(String target, String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"Message\", target + \" \" + sender + \" \" + message);\n\n\t\tserver.getChannel(target).addMessage(\"<\" + sender + \">\" + message);\n\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t}\n\n\t/**\n\t * On Mode\n\t */\n\t@Override\n\tprotected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n\t{\n\t\tdebug(\"Mode\", target + \" \" + sourceNick + \" \" + mode);\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" sets mode \" + mode);\n\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t}\n\n\t/**\n\t * On Nick Change\n\t */\n\t@Override\n\tprotected void onNickChange(String oldNick, String login, String hostname, String newNick)\n\t{\n\t\tdebug(\"Nick\", oldNick + \" \" + newNick);\n\t}\n\n\t/**\n\t * On Notice\n\t */\n\t@Override\n\tprotected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n\t{\n\t\tdebug(\"Notice\", sourceNick + \" \" + notice);\n\t}\n\n\t/**\n\t * On Op\n\t */\n\t@Override\n\tprotected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Op\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" oped \" + recipient);\n\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t}\n\n\t/**\n\t * On Part\n\t */\n\t@Override\n\tprotected void onPart(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Part\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We pareted a channel\n\t\t\tserver.removeChannel(target);\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_REMOVE));\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" parted\");\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t\t}\n\t}\n\n\t/**\n\t * On Private Message\n\t */\n\t@Override\n\tprotected void onPrivateMessage(String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"PrivateMessage\", sender + \" \" + message);\n\t}\n\n\t/**\n\t * On Quit\n\t */\n\t@Override\n\tprotected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n\t{\n\t\tdebug(\"Quit\", sourceNick);\n\t}\n\n\t/**\n\t * On Topic\n\t */\n\t@Override\n\tprotected void onTopic(String target, String topic, String setBy, long date, boolean changed)\n\t{\n\t\tdebug(\"Topic\", target + \" \" + setBy + \" \" + topic);\n\t\t\n\t\tif (changed) {\n\t\t\tserver.getChannel(target).addMessage(setBy + \" sets topic: \" + topic);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(\"Topic: \" + topic);\n\t\t}\n\t\t\n\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_MESSAGE));\n\t}\n\n\t/**\n\t * On User List\n\t */\n\t@Override\n\tprotected void onUserList(String channel, User[] users)\n\t{\n\t\tdebug(\"UserList\", channel + \" (\" + users.length + \")\");\n\t}\n\n\t/**\n\t * On Voice\n\t */\n\t@Override\n\tprotected void onVoice(String channel, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Voice\", channel + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t}\n\t\n\t/**\n\t * On disconnect\n\t */\n\t@Override\n\tpublic void onDisconnect()\n\t{\n\t\tserver.setStatus(Status.DISCONNECTED);\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\n\t/**\n\t * Print an event to the debug console \n\t */\n\tprivate void debug(String event, String params)\n\t{\n\t\tif (DEBUG_EVENTS) {\n\t\t\tLog.d(TAG, \"(\" + server.getTitle() + \") [\" + event + \"]: \" + params);\n\t\t}\n\t}\n\t\n\t/**\n\t * Quits from the IRC server with default reason.\n\t */\n\t@Override\n\tpublic void quitServer()\n\t{\n\t\tquitServer(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n}\n","Method after Refactoring":"/*\n Yaaic - Yet Another Android IRC Client\n\nCopyright 2009 Sebastian Kaspari\n\nThis file is part of Yaaic.\n\nYaaic is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nYaaic is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Yaaic.  If not, see <http://www.gnu.org/licenses/>.\n*/\npackage org.yaaic.irc;\n\nimport android.content.Intent;\nimport android.util.Log;\n\nimport org.jibble.pircbot.PircBot;\nimport org.jibble.pircbot.User;\n\nimport org.yaaic.Yaaic;\nimport org.yaaic.model.Broadcast;\nimport org.yaaic.model.Channel;\nimport org.yaaic.model.Server;\nimport org.yaaic.model.Status;\n\npublic class IRCConnection extends PircBot\n{\n\tprivate IRCService service;\n\tprivate Server server;\n\t\n\t// XXX: Print all IRC events to the debug console\n\tprivate static final boolean DEBUG_EVENTS = true;\n\tpublic static final String TAG = \"Yaaic/IRCConnection\";\n\t\n\t/**\n\t * Create a new connection\n\t * \n\t * @param service\n\t * @param serverId\n\t */\n\tpublic IRCConnection(IRCService service, int serverId)\n\t{\n\t\tthis.server = Yaaic.getInstance().getServerById(serverId);\n\t\tthis.service = service;\n\t\t\n\t\tthis.setName(\"Yaaic\");\n\t\tthis.setLogin(\"Yaaic\");\n\t\tthis.setAutoNickChange(true);\n\t\tthis.setVersion(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n\n\t/**\n\t * On connect\n\t */\n\t@Override\n\tpublic void onConnect()\n\t{\n\t\tdebug(\"Connect\", \"\");\n\t\t\n\t\tserver.setStatus(Status.CONNECTED);\n\t\t\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\t\n\t/**\n\t * On channel action\n\t */\n\t@Override\n\tprotected void onAction(String sender, String login, String hostname, String target, String action)\n\t{\n\t\tdebug(\"Action\", target + \" \" + sender + \" \" + action);\n\t\t\n\t\tserver.getChannel(target).addMessage(\"* \" + sender + \" \" + action);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Channel Info\n\t */\n\t@Override\n\tprotected void onChannelInfo(String channel, int userCount, String topic)\n\t{\n\t\tdebug(\"ChannelInfo\", channel + \" \" + userCount);\n\t}\n\n\t/**\n\t * On Deop\n\t */\n\t@Override\n\tprotected void onDeop(String channel, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Deop\", channel + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t}\n\n\t/**\n\t * On DeVoice\n\t */\n\t@Override\n\tprotected void onDeVoice(String channel, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"DeVoice\", channel + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t}\n\n\t/**\n\t * On Invite\n\t */\n\t@Override\n\tprotected void onInvite(String targetNick, String sourceNick, String sourceLogin, String sourceHostname, String channel)\n\t{\n\t\tdebug(\"Invite\", channel + \" \" + targetNick + \"(\" + sourceNick + \")\");\n\t}\n\n\t/**\n\t * On Join\n\t */\n\t@Override\n\tprotected void onJoin(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Join\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We joined a new channel\n\t\t\tserver.addChannel(new Channel(target));\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_NEW));\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" joined\");\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Kick\n\t */\n\t@Override\n\tprotected void onKick(String target, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)\n\t{\n\t\tdebug(\"Kick\", target + \" \" + recipientNick + \"(\" + kickerNick + \")\");\n\t\t\n\t\tif (recipientNick.equals(getNick())) {\n\t\t\t// We are kicked\n\t\t\tserver.removeChannel(target);\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_REMOVE));\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(kickerNick + \" kicked \" + recipientNick);\n\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\t\t\t\n\t\t}\n\t}\n\n\t/**\n\t * On Message\n\t */\n\t@Override\n\tprotected void onMessage(String target, String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"Message\", target + \" \" + sender + \" \" + message);\n\n\t\tserver.getChannel(target).addMessage(\"<\" + sender + \">\" + message);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Mode\n\t */\n\t@Override\n\tprotected void onMode(String target, String sourceNick, String sourceLogin, String sourceHostname, String mode)\n\t{\n\t\tdebug(\"Mode\", target + \" \" + sourceNick + \" \" + mode);\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" sets mode \" + mode);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Nick Change\n\t */\n\t@Override\n\tprotected void onNickChange(String oldNick, String login, String hostname, String newNick)\n\t{\n\t\tdebug(\"Nick\", oldNick + \" \" + newNick);\n\t}\n\n\t/**\n\t * On Notice\n\t */\n\t@Override\n\tprotected void onNotice(String sourceNick, String sourceLogin, String sourceHostname, String target, String notice)\n\t{\n\t\tdebug(\"Notice\", sourceNick + \" \" + notice);\n\t}\n\n\t/**\n\t * On Op\n\t */\n\t@Override\n\tprotected void onOp(String target, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Op\", target + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t\t\n\t\tserver.getChannel(target).addMessage(sourceNick + \" oped \" + recipient);\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On Part\n\t */\n\t@Override\n\tprotected void onPart(String target, String sender, String login, String hostname)\n\t{\n\t\tdebug(\"Part\", target + \" \" + sender);\n\t\t\n\t\tif (sender.equals(getNick())) {\n\t\t\t// We pareted a channel\n\t\t\tserver.removeChannel(target);\n\t\t\tservice.sendBroadcast(new Intent(Broadcast.CHANNEL_REMOVE));\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(sender + \" parted\");\n\t\t\t\n\t\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\t\tservice.sendBroadcast(intent);\n\t\t}\n\t}\n\n\t/**\n\t * On Private Message\n\t */\n\t@Override\n\tprotected void onPrivateMessage(String sender, String login, String hostname, String message)\n\t{\n\t\tdebug(\"PrivateMessage\", sender + \" \" + message);\n\t}\n\n\t/**\n\t * On Quit\n\t */\n\t@Override\n\tprotected void onQuit(String sourceNick, String sourceLogin, String sourceHostname, String reason)\n\t{\n\t\tdebug(\"Quit\", sourceNick);\n\t}\n\n\t/**\n\t * On Topic\n\t */\n\t@Override\n\tprotected void onTopic(String target, String topic, String setBy, long date, boolean changed)\n\t{\n\t\tdebug(\"Topic\", target + \" \" + setBy + \" \" + topic);\n\t\t\n\t\tif (changed) {\n\t\t\tserver.getChannel(target).addMessage(setBy + \" sets topic: \" + topic);\n\t\t} else {\n\t\t\tserver.getChannel(target).addMessage(\"Topic: \" + topic);\n\t\t}\n\t\t\n\t\tIntent intent = new Intent(Broadcast.CHANNEL_MESSAGE);\n\t\tintent.putExtra(Broadcast.EXTRA_CHANNEL, target);\n\t\tservice.sendBroadcast(intent);\n\t}\n\n\t/**\n\t * On User List\n\t */\n\t@Override\n\tprotected void onUserList(String channel, User[] users)\n\t{\n\t\tdebug(\"UserList\", channel + \" (\" + users.length + \")\");\n\t}\n\n\t/**\n\t * On Voice\n\t */\n\t@Override\n\tprotected void onVoice(String channel, String sourceNick, String sourceLogin, String sourceHostname, String recipient)\n\t{\n\t\tdebug(\"Voice\", channel + \" \" + recipient + \"(\" + sourceNick + \")\");\n\t}\n\t\n\t/**\n\t * On disconnect\n\t */\n\t@Override\n\tpublic void onDisconnect()\n\t{\n\t\tserver.setStatus(Status.DISCONNECTED);\n\t\tservice.sendBroadcast(new Intent(Broadcast.SERVER_UPDATE));\n\t}\n\n\t/**\n\t * Print an event to the debug console \n\t */\n\tprivate void debug(String event, String params)\n\t{\n\t\tif (DEBUG_EVENTS) {\n\t\t\tLog.d(TAG, \"(\" + server.getTitle() + \") [\" + event + \"]: \" + params);\n\t\t}\n\t}\n\t\n\t/**\n\t * Quits from the IRC server with default reason.\n\t */\n\t@Override\n\tpublic void quitServer()\n\t{\n\t\tquitServer(\"Yaaic - Yet another Android IRC client - http://www.yaaic.org\");\n\t}\n}\n","lineNo":283}
