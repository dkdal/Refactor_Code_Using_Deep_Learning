{"Smelly Sample":"/*\n * ConnectBot: simple, powerful, open-source SSH client for Android\n * Copyright 2007 Kenny Root, Jeffrey Sharkey\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.connectbot;\n\nimport java.lang.ref.WeakReference;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.connectbot.bean.HostBean;\nimport org.connectbot.service.BridgeDisconnectedListener;\nimport org.connectbot.service.PromptHelper;\nimport org.connectbot.service.TerminalBridge;\nimport org.connectbot.service.TerminalKeyListener;\nimport org.connectbot.service.TerminalManager;\nimport org.connectbot.util.PreferenceConstants;\nimport org.connectbot.util.TerminalViewPager;\n\nimport android.annotation.SuppressLint;\nimport android.app.Dialog;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.ServiceConnection;\nimport android.content.SharedPreferences;\nimport android.content.pm.ActivityInfo;\nimport android.content.res.Configuration;\nimport android.graphics.Rect;\nimport android.media.AudioManager;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Message;\nimport android.os.StrictMode;\nimport android.preference.PreferenceManager;\nimport androidx.annotation.Nullable;\nimport com.google.android.material.tabs.TabLayout;\nimport androidx.core.app.ActivityCompat;\nimport androidx.core.view.MenuItemCompat;\nimport androidx.viewpager.widget.PagerAdapter;\nimport androidx.appcompat.app.ActionBar;\nimport androidx.appcompat.app.AppCompatActivity;\nimport androidx.appcompat.widget.Toolbar;\nimport android.text.ClipboardManager;\nimport android.util.Log;\nimport android.view.KeyEvent;\nimport android.view.LayoutInflater;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.MenuItem.OnMenuItemClickListener;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.view.View.OnClickListener;\nimport android.view.View.OnKeyListener;\nimport android.view.View.OnTouchListener;\nimport android.view.ViewGroup;\nimport android.view.ViewTreeObserver;\nimport android.view.Window;\nimport android.view.WindowManager;\nimport android.view.animation.Animation;\nimport android.view.animation.AnimationUtils;\nimport android.view.inputmethod.InputMethodManager;\nimport android.widget.AdapterView;\nimport android.widget.AdapterView.OnItemClickListener;\nimport android.widget.ArrayAdapter;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.HorizontalScrollView;\nimport android.widget.ImageView;\nimport android.widget.LinearLayout;\nimport android.widget.ListView;\nimport android.widget.RelativeLayout;\nimport android.widget.TextView;\nimport de.mud.terminal.vt320;\n\npublic class ConsoleActivity extends AppCompatActivity implements BridgeDisconnectedListener {\n\tpublic final static String TAG = \"CB.ConsoleActivity\";\n\n\tprotected static final int REQUEST_EDIT = 1;\n\n\tprivate static final int KEYBOARD_DISPLAY_TIME = 3000;\n\tprivate static final int KEYBOARD_REPEAT_INITIAL = 500;\n\tprivate static final int KEYBOARD_REPEAT = 100;\n\tprivate static final String STATE_SELECTED_URI = \"selectedUri\";\n\n\tprotected TerminalViewPager pager = null;\n\tprotected TabLayout tabs = null;\n\tprotected Toolbar toolbar = null;\n\t@Nullable\n\tprotected TerminalManager bound = null;\n\tprotected TerminalPagerAdapter adapter = null;\n\tprotected LayoutInflater inflater = null;\n\n\tprivate SharedPreferences prefs = null;\n\n\t// determines whether or not menuitem accelerators are bound\n\t// otherwise they collide with an external keyboard's CTRL-char\n\tprivate boolean hardKeyboard = false;\n\n\tprotected Uri requested;\n\n\tprotected ClipboardManager clipboard;\n\tprivate RelativeLayout stringPromptGroup;\n\tprotected EditText stringPrompt;\n\tprivate TextView stringPromptInstructions;\n\n\tprivate RelativeLayout booleanPromptGroup;\n\tprivate TextView booleanPrompt;\n\tprivate Button booleanYes;\n\n\tprivate LinearLayout keyboardGroup;\n\tprivate Runnable keyboardGroupHider;\n\n\tprivate TextView empty;\n\n\tprivate Animation fade_out_delayed;\n\n\tprivate Animation keyboard_fade_in, keyboard_fade_out;\n\n\tprivate MenuItem disconnect;\n\tprivate MenuItem paste;\n\tprivate MenuItem portForward;\n\tprivate MenuItem resize;\n\tprivate MenuItem urlscan;\n\n\tprivate boolean forcedOrientation;\n\n\tprivate final Handler handler = new Handler();\n\n\tprivate View contentView;\n\n\tprivate ImageView mKeyboardButton;\n\n\t@Nullable private ActionBar actionBar;\n\tprivate boolean inActionBarMenu = false;\n\tprivate boolean titleBarHide;\n\tprivate boolean keyboardAlwaysVisible = false;\n\n\tprivate final ServiceConnection connection = new ServiceConnection() {\n\t\t@Override\n\t\tpublic void onServiceConnected(ComponentName className, IBinder service) {\n\t\t\tbound = ((TerminalManager.TerminalBinder) service).getService();\n\n\t\t\t// let manager know about our event handling services\n\t\t\tbound.disconnectListener = ConsoleActivity.this;\n\t\t\tbound.setResizeAllowed(true);\n\n\t\t\tfinal String requestedNickname = (requested != null) ? requested.getFragment() : null;\n\t\t\tTerminalBridge requestedBridge = bound.getConnectedBridge(requestedNickname);\n\n\t\t\t// If we didn't find the requested connection, try opening it\n\t\t\tif (requestedNickname != null && requestedBridge == null) {\n\t\t\t\ttry {\n\t\t\t\t\tLog.d(TAG, String.format(\"We couldn't find an existing bridge with URI=%s (nickname=%s), so creating one now\", requested.toString(), requestedNickname));\n\t\t\t\t\trequestedBridge = bound.openConnection(requested);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tLog.e(TAG, \"Problem while trying to create new requested bridge from URI\", e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// create views for all bridges on this service\n\t\t\tadapter.notifyDataSetChanged();\n\t\t\tfinal int requestedIndex = bound.getBridges().indexOf(requestedBridge);\n\n\t\t\tif (requestedBridge != null)\n\t\t\t\trequestedBridge.promptHelper.setHandler(promptHandler);\n\n\n\t\t\tif (requestedIndex != -1) {\n\t\t\t\tpager.post(new Runnable() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\tsetDisplayedTerminal(requestedIndex);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void onServiceDisconnected(ComponentName className) {\n\t\t\tbound = null;\n\t\t\tadapter.notifyDataSetChanged();\n\t\t\tupdateEmptyVisible();\n\t\t}\n\t};\n\n\tprotected Handler promptHandler = new Handler() {\n\t\t@Override\n\t\tpublic void handleMessage(Message msg) {\n\t\t\t// someone below us requested to display a prompt\n\t\t\tupdatePromptVisible();\n\t\t}\n\t};\n\n\t@Override\n\tpublic void onDisconnected(TerminalBridge bridge) {\n\t\tsynchronized (adapter) {\n\t\t\tadapter.notifyDataSetChanged();\n\t\t\tLog.d(TAG, \"Someone sending HANDLE_DISCONNECT to parentHandler\");\n\n\t\t\tif (bridge.isAwaitingClose()) {\n\t\t\t\tcloseBridge(bridge);\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected OnClickListener emulatedKeysListener = new OnClickListener() {\n\t\t@Override\n\t\tpublic void onClick(View v) {\n\t\t\tonEmulatedKeyClicked(v);\n\t\t}\n\t};\n\n\tprotected Handler keyRepeatHandler = new Handler();\n\n\n\t/**\n\t * Handle repeatable virtual keys and touch events\n\t */\n\tpublic class KeyRepeater implements Runnable, OnTouchListener, OnClickListener {\n\t\tprivate final View mView;\n\t\tprivate final Handler mHandler;\n\t\tprivate boolean mDown;\n\n\t\tpublic KeyRepeater(Handler handler, View view) {\n\t\t\tmView = view;\n\t\t\tmHandler = handler;\n\t\t\tmDown = false;\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tmDown = true;\n\t\t\tmHandler.removeCallbacks(this);\n\t\t\tmHandler.postDelayed(this, KEYBOARD_REPEAT);\n\t\t\tmView.performClick();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean onTouch(View v, MotionEvent event) {\n\t\t\tif (BuildConfig.DEBUG) {\n\t\t\t\tLog.d(TAG, \"KeyRepeater.onTouch(\" + v.getId() + \", \" +\n\t\t\t\t\t\tevent.getAction() + \", \" +\n\t\t\t\t\t\tevent.getActionIndex() + \", \" +\n\t\t\t\t\t\tevent.getActionMasked() + \");\");\n\t\t\t}\n\t\t\tswitch (event.getAction()) {\n\t\t\tcase MotionEvent.ACTION_DOWN:\n\t\t\t\tmDown = false;\n\t\t\t\tmHandler.postDelayed(this, KEYBOARD_REPEAT_INITIAL);\n\t\t\t\tmView.setPressed(true);\n\t\t\t\treturn true;\n\n\t\t\tcase MotionEvent.ACTION_CANCEL:\n\t\t\t\tmHandler.removeCallbacks(this);\n\t\t\t\tmView.setPressed(false);\n\t\t\t\treturn true;\n\n\t\t\tcase MotionEvent.ACTION_UP:\n\t\t\t\tmHandler.removeCallbacks(this);\n\t\t\t\tmView.setPressed(false);\n\n\t\t\t\tif (!mDown) {\n\t\t\t\t\tmView.performClick();\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic void onClick(View view) {\n\t\t\tonEmulatedKeyClicked(view);\n\t\t}\n\t}\n\n\tprivate void onEmulatedKeyClicked(View v) {\n\t\tTerminalView terminal = adapter.getCurrentTerminalView();\n\t\tif (terminal == null) return;\n\n\t\tif (BuildConfig.DEBUG) {\n\t\t\tLog.d(TAG, \"onEmulatedKeyClicked(\" + v.getId() + \")\");\n\t\t}\n\t\tTerminalKeyListener handler = terminal.bridge.getKeyHandler();\n\t\tboolean hideKeys = false;\n\n\t\tswitch (v.getId()) {\n\t\tcase R.id.button_ctrl:\n\t\t\thandler.metaPress(TerminalKeyListener.OUR_CTRL_ON, true);\n\t\t\thideKeys = true;\n\t\t\tbreak;\n\t\tcase R.id.button_esc:\n\t\t\thandler.sendEscape();\n\t\t\thideKeys = true;\n\t\t\tbreak;\n\t\tcase R.id.button_tab:\n\t\t\thandler.sendTab();\n\t\t\thideKeys = true;\n\t\t\tbreak;\n\n\t\tcase R.id.button_up:\n\t\t\thandler.sendPressedKey(vt320.KEY_UP);\n\t\t\tbreak;\n\t\tcase R.id.button_down:\n\t\t\thandler.sendPressedKey(vt320.KEY_DOWN);\n\t\t\tbreak;\n\t\tcase R.id.button_left:\n\t\t\thandler.sendPressedKey(vt320.KEY_LEFT);\n\t\t\tbreak;\n\t\tcase R.id.button_right:\n\t\t\thandler.sendPressedKey(vt320.KEY_RIGHT);\n\t\t\tbreak;\n\n\t\tcase R.id.button_home:\n\t\t\thandler.sendPressedKey(vt320.KEY_HOME);\n\t\t\tbreak;\n\t\tcase R.id.button_end:\n\t\t\thandler.sendPressedKey(vt320.KEY_END);\n\t\t\tbreak;\n\t\tcase R.id.button_pgup:\n\t\t\thandler.sendPressedKey(vt320.KEY_PAGE_UP);\n\t\t\tbreak;\n\t\tcase R.id.button_pgdn:\n\t\t\thandler.sendPressedKey(vt320.KEY_PAGE_DOWN);\n\t\t\tbreak;\n\n\t\tcase R.id.button_f1:\n\t\t\thandler.sendPressedKey(vt320.KEY_F1);\n\t\t\tbreak;\n\t\tcase R.id.button_f2:\n\t\t\thandler.sendPressedKey(vt320.KEY_F2);\n\t\t\tbreak;\n\t\tcase R.id.button_f3:\n\t\t\thandler.sendPressedKey(vt320.KEY_F3);\n\t\t\tbreak;\n\t\tcase R.id.button_f4:\n\t\t\thandler.sendPressedKey(vt320.KEY_F4);\n\t\t\tbreak;\n\t\tcase R.id.button_f5:\n\t\t\thandler.sendPressedKey(vt320.KEY_F5);\n\t\t\tbreak;\n\t\tcase R.id.button_f6:\n\t\t\thandler.sendPressedKey(vt320.KEY_F6);\n\t\t\tbreak;\n\t\tcase R.id.button_f7:\n\t\t\thandler.sendPressedKey(vt320.KEY_F7);\n\t\t\tbreak;\n\t\tcase R.id.button_f8:\n\t\t\thandler.sendPressedKey(vt320.KEY_F8);\n\t\t\tbreak;\n\t\tcase R.id.button_f9:\n\t\t\thandler.sendPressedKey(vt320.KEY_F9);\n\t\t\tbreak;\n\t\tcase R.id.button_f10:\n\t\t\thandler.sendPressedKey(vt320.KEY_F10);\n\t\t\tbreak;\n\t\tcase R.id.button_f11:\n\t\t\thandler.sendPressedKey(vt320.KEY_F11);\n\t\t\tbreak;\n\t\tcase R.id.button_f12:\n\t\t\thandler.sendPressedKey(vt320.KEY_F12);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLog.e(TAG, \"Unknown emulated key clicked: \" + v.getId());\n\t\t\tbreak;\n\t\t}\n\n\t\tif (hideKeys) {\n\t\t\thideEmulatedKeys();\n\t\t} else {\n\t\t\tautoHideEmulatedKeys();\n\t\t}\n\n\t\tterminal.bridge.tryKeyVibrate();\n\t\thideActionBarIfRequested();\n\t}\n\n\tprivate void hideActionBarIfRequested() {\n\t\tif (titleBarHide && actionBar != null) {\n\t\t\tactionBar.hide();\n\t\t}\n\t}\n\n\tprivate void closeBridge(final TerminalBridge bridge) {\n\t\tupdateEmptyVisible();\n\t\tupdatePromptVisible();\n\n\t\t// If we just closed the last bridge, go back to the previous activity.\n\t\tif (pager.getChildCount() == 0) {\n\t\t\tfinish();\n\t\t\tunregisterMenuListeners();\n\t\t}\n\t}\n\n\tprivate void unregisterMenuListeners() {\n\t\tportForward.setOnMenuItemClickListener(null);\n\t\tdisconnect.setOnMenuItemClickListener(null);\n\t\tpaste.setOnMenuItemClickListener(null);\n\t\tportForward.setOnMenuItemClickListener(null);\n\t\tresize.setOnMenuItemClickListener(null);\n\t\turlscan.setOnMenuItemClickListener(null);\n\t}\n\n\tprotected View findCurrentView(int id) {\n\t\tView view = pager.findViewWithTag(adapter.getBridgeAtPosition(pager.getCurrentItem()));\n\t\tif (view == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn view.findViewById(id);\n\t}\n\n\tprotected PromptHelper getCurrentPromptHelper() {\n\t\tTerminalView view = adapter.getCurrentTerminalView();\n\t\tif (view == null) return null;\n\t\treturn view.bridge.promptHelper;\n\t}\n\n\tprotected void hideAllPrompts() {\n\t\tstringPromptGroup.setVisibility(View.GONE);\n\t\tbooleanPromptGroup.setVisibility(View.GONE);\n\t}\n\n\tprivate void showEmulatedKeys(boolean showActionBar) {\n\t\tif (keyboardGroup.getVisibility() == View.GONE) {\n\t\t\tkeyboardGroup.startAnimation(keyboard_fade_in);\n\t\t\tkeyboardGroup.setVisibility(View.VISIBLE);\n\t\t}\n\t\tif (showActionBar) {\n\t\t\tactionBar.show();\n\t\t}\n\t\tautoHideEmulatedKeys();\n\t}\n\n\tprivate void autoHideEmulatedKeys() {\n\t\tif (keyboardGroupHider != null) {\n\t\t\thandler.removeCallbacks(keyboardGroupHider);\n\t\t}\n\n\t\tkeyboardGroupHider = new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tif (keyboardGroup.getVisibility() == View.GONE || inActionBarMenu) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (!keyboardAlwaysVisible) {\n\t\t\t\t\tkeyboardGroup.startAnimation(keyboard_fade_out);\n\t\t\t\t\tkeyboardGroup.setVisibility(View.GONE);\n\t\t\t\t}\n\t\t\t\thideActionBarIfRequested();\n\t\t\t\tkeyboardGroupHider = null;\n\t\t\t}\n\t\t};\n\t\thandler.postDelayed(keyboardGroupHider, KEYBOARD_DISPLAY_TIME);\n\t}\n\n\tprivate void hideEmulatedKeys() {\n\t\tif (!keyboardAlwaysVisible) {\n\t\t\tif (keyboardGroupHider != null)\n\t\t\t\thandler.removeCallbacks(keyboardGroupHider);\n\t\t\tkeyboardGroup.setVisibility(View.GONE);\n\t\t}\n\t\thideActionBarIfRequested();\n\t}\n\n\tprivate void requestActionBar() {\n\t\tsupportRequestWindowFeature(Window.FEATURE_ACTION_BAR_OVERLAY);\n\t}\n\n\t@Override\n\tpublic void onCreate(Bundle icicle) {\n\t\tsuper.onCreate(icicle);\n\n\t\tStrictMode.setThreadPolicy(StrictMode.ThreadPolicy.LAX);\n\n\t\thardKeyboard = getResources().getConfiguration().keyboard ==\n\t\t\t\tConfiguration.KEYBOARD_QWERTY;\n\n\t\tclipboard = (ClipboardManager) getSystemService(CLIPBOARD_SERVICE);\n\t\tprefs = PreferenceManager.getDefaultSharedPreferences(this);\n\n\t\ttitleBarHide = prefs.getBoolean(PreferenceConstants.TITLEBARHIDE, false);\n\t\tif (titleBarHide) {\n\t\t\t// This is a separate method because Gradle does not uniformly respect the conditional\n\t\t\t// Build check. See: https://code.google.com/p/android/issues/detail?id=137195\n\t\t\trequestActionBar();\n\t\t}\n\n\t\tthis.setContentView(R.layout.act_console);\n\n\t\t// hide status bar if requested by user\n\t\tif (prefs.getBoolean(PreferenceConstants.FULLSCREEN, false)) {\n\t\t\tgetWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,\n\t\t\t\t\tWindowManager.LayoutParams.FLAG_FULLSCREEN);\n\t\t}\n\n\t\t// TODO find proper way to disable volume key beep if it exists.\n\t\tsetVolumeControlStream(AudioManager.STREAM_MUSIC);\n\n\t\t// handle requested console from incoming intent\n\t\tif (icicle == null) {\n\t\t\trequested = getIntent().getData();\n\t\t} else {\n\t\t\tString uri = icicle.getString(STATE_SELECTED_URI);\n\t\t\tif (uri != null) {\n\t\t\t\trequested = Uri.parse(uri);\n\t\t\t}\n\t\t}\n\n\t\tinflater = LayoutInflater.from(this);\n\n\t\ttoolbar = findViewById(R.id.toolbar);\n\n\t\tpager = findViewById(R.id.console_flip);\n\t\tpager.addOnPageChangeListener(\n\t\t\t\tnew TerminalViewPager.SimpleOnPageChangeListener() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onPageSelected(int position) {\n\t\t\t\t\t\tsetTitle(adapter.getPageTitle(position));\n\t\t\t\t\t\tonTerminalChanged();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\tadapter = new TerminalPagerAdapter();\n\t\tpager.setAdapter(adapter);\n\n\t\tempty = findViewById(android.R.id.empty);\n\n\t\tstringPromptGroup = findViewById(R.id.console_password_group);\n\t\tstringPromptInstructions = findViewById(R.id.console_password_instructions);\n\t\tstringPrompt = findViewById(R.id.console_password);\n\t\tstringPrompt.setOnKeyListener(new OnKeyListener() {\n\t\t\t@Override\n\t\t\tpublic boolean onKey(View v, int keyCode, KeyEvent event) {\n\t\t\t\tif (event.getAction() == KeyEvent.ACTION_UP) return false;\n\t\t\t\tif (keyCode != KeyEvent.KEYCODE_ENTER) return false;\n\n\t\t\t\t// pass collected password down to current terminal\n\t\t\t\tString value = stringPrompt.getText().toString();\n\n\t\t\t\tPromptHelper helper = getCurrentPromptHelper();\n\t\t\t\tif (helper == null) return false;\n\t\t\t\thelper.setResponse(value);\n\n\t\t\t\t// finally clear password for next user\n\t\t\t\tstringPrompt.setText(\"\");\n\t\t\t\tupdatePromptVisible();\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\tbooleanPromptGroup = findViewById(R.id.console_boolean_group);\n\t\tbooleanPrompt = findViewById(R.id.console_prompt);\n\n\t\tbooleanYes = findViewById(R.id.console_prompt_yes);\n\t\tbooleanYes.setOnClickListener(new OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tPromptHelper helper = getCurrentPromptHelper();\n\t\t\t\tif (helper == null) return;\n\t\t\t\thelper.setResponse(Boolean.TRUE);\n\t\t\t\tupdatePromptVisible();\n\t\t\t}\n\t\t});\n\n\t\tButton booleanNo = findViewById(R.id.console_prompt_no);\n\t\tbooleanNo.setOnClickListener(new OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tPromptHelper helper = getCurrentPromptHelper();\n\t\t\t\tif (helper == null) return;\n\t\t\t\thelper.setResponse(Boolean.FALSE);\n\t\t\t\tupdatePromptVisible();\n\t\t\t}\n\t\t});\n\n\t\tfade_out_delayed = AnimationUtils.loadAnimation(this, R.anim.fade_out_delayed);\n\n\t\t// Preload animation for keyboard button\n\t\tkeyboard_fade_in = AnimationUtils.loadAnimation(this, R.anim.keyboard_fade_in);\n\t\tkeyboard_fade_out = AnimationUtils.loadAnimation(this, R.anim.keyboard_fade_out);\n\n\t\tkeyboardGroup = findViewById(R.id.keyboard_group);\n\n\t\tkeyboardAlwaysVisible = prefs.getBoolean(PreferenceConstants.KEY_ALWAYS_VISIBLE, false);\n\t\tif (keyboardAlwaysVisible) {\n\t\t\t// equivalent to android:layout_above=keyboard_group\n\t\t\tRelativeLayout.LayoutParams layoutParams = new RelativeLayout.LayoutParams(\n\t\t\t\t\tViewGroup.LayoutParams.MATCH_PARENT,\n\t\t\t\t\tViewGroup.LayoutParams.MATCH_PARENT);\n\t\t\tlayoutParams.addRule(RelativeLayout.ABOVE, R.id.keyboard_group);\n\t\t\tpager.setLayoutParams(layoutParams);\n\n\t\t\tlayoutParams = new RelativeLayout.LayoutParams(\n\t\t\t\t\tViewGroup.LayoutParams.MATCH_PARENT,\n\t\t\t\t\tViewGroup.LayoutParams.WRAP_CONTENT);\n\t\t\tlayoutParams.addRule(RelativeLayout.ABOVE, R.id.keyboard_group);\n\t\t\tfindViewById(R.id.console_password_group).setLayoutParams(layoutParams);\n\t\t\tfindViewById(R.id.console_boolean_group).setLayoutParams(layoutParams);\n\n\t\t\t// Show virtual keyboard\n\t\t\tkeyboardGroup.setVisibility(View.VISIBLE);\n\t\t}\n\n\t\tmKeyboardButton = findViewById(R.id.button_keyboard);\n\t\tmKeyboardButton.setOnClickListener(new OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View view) {\n\t\t\t\tView terminal = adapter.getCurrentTerminalView();\n\t\t\t\tif (terminal == null)\n\t\t\t\t\treturn;\n\t\t\t\tInputMethodManager inputMethodManager =\n\t\t\t\t\t(InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);\n\t\t\t\tinputMethodManager.toggleSoftInputFromWindow(terminal.getApplicationWindowToken(),\n\t\t\t\t\tInputMethodManager.SHOW_FORCED, 0);\n\t\t\t\tterminal.requestFocus();\n\t\t\t\thideEmulatedKeys();\n\t\t\t}\n\t\t});\n\n\t\tfindViewById(R.id.button_ctrl).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_esc).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_tab).setOnClickListener(emulatedKeysListener);\n\n\t\taddKeyRepeater(findViewById(R.id.button_up));\n\t\taddKeyRepeater(findViewById(R.id.button_up));\n\t\taddKeyRepeater(findViewById(R.id.button_down));\n\t\taddKeyRepeater(findViewById(R.id.button_left));\n\t\taddKeyRepeater(findViewById(R.id.button_right));\n\n\t\tfindViewById(R.id.button_home).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_end).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_pgup).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_pgdn).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f1).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f2).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f3).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f4).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f5).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f6).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f7).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f8).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f9).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f10).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f11).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f12).setOnClickListener(emulatedKeysListener);\n\n\n\t\tactionBar = getSupportActionBar();\n\t\tif (actionBar != null) {\n\t\t\tactionBar.setDisplayHomeAsUpEnabled(true);\n\t\t\tif (titleBarHide) {\n\t\t\t\tactionBar.hide();\n\t\t\t}\n\t\t\tactionBar.addOnMenuVisibilityListener(new ActionBar.OnMenuVisibilityListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void onMenuVisibilityChanged(boolean isVisible) {\n\t\t\t\t\tinActionBarMenu = isVisible;\n\t\t\t\t\tif (!isVisible) {\n\t\t\t\t\t\thideEmulatedKeys();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tfinal HorizontalScrollView keyboardScroll = findViewById(R.id.keyboard_hscroll);\n\t\tif (!hardKeyboard) {\n\t\t\t// Show virtual keyboard and scroll back and forth\n\t\t\tshowEmulatedKeys(false);\n\t\t\tkeyboardScroll.postDelayed(new Runnable() {\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\tfinal int xscroll = findViewById(R.id.button_f12).getRight();\n\t\t\t\t\tif (BuildConfig.DEBUG) {\n\t\t\t\t\t\tLog.d(TAG, \"smoothScrollBy(toEnd[\" + xscroll + \"])\");\n\t\t\t\t\t}\n\t\t\t\t\tkeyboardScroll.smoothScrollBy(xscroll, 0);\n\t\t\t\t\tkeyboardScroll.postDelayed(new Runnable() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\tif (BuildConfig.DEBUG) {\n\t\t\t\t\t\t\t\tLog.d(TAG, \"smoothScrollBy(toStart[\" + -xscroll + \"])\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tkeyboardScroll.smoothScrollBy(-xscroll, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, 500);\n\t\t\t\t}\n\t\t\t}, 500);\n\t\t}\n\n\t\t// Reset keyboard auto-hide timer when scrolling\n\t\tkeyboardScroll.setOnTouchListener(\n\t\t\t\tnew OnTouchListener() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean onTouch(View v, MotionEvent event) {\n\t\t\t\t\t\tswitch (event.getAction()) {\n\t\t\t\t\t\tcase MotionEvent.ACTION_MOVE:\n\t\t\t\t\t\t\tautoHideEmulatedKeys();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase MotionEvent.ACTION_UP:\n\t\t\t\t\t\t\tv.performClick();\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\ttabs = findViewById(R.id.tabs);\n\t\tif (tabs != null)\n\t\t\tsetupTabLayoutWithViewPager();\n\n\t\tpager.setOnClickListener(new OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tshowEmulatedKeys(true);\n\t\t\t}\n\t\t});\n\n\t\t// Change keyboard button image according to soft keyboard visibility\n\t\t// How to detect keyboard visibility: http://stackoverflow.com/q/4745988\n\t\tcontentView = findViewById(android.R.id.content);\n\t\tcontentView.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void onGlobalLayout() {\n\t\t\t\t\tRect r = new Rect();\n\t\t\t\t\tcontentView.getWindowVisibleDisplayFrame(r);\n\t\t\t\t\tint screenHeight = contentView.getRootView().getHeight();\n\t\t\t\t\tint keypadHeight = screenHeight - r.bottom;\n\n\t\t\t\t\tif (keypadHeight > screenHeight * 0.15) {\n\t\t\t\t\t\t// keyboard is opened\n\t\t\t\t\t\tmKeyboardButton.setImageResource(R.drawable.ic_keyboard_hide);\n\t\t\t\t\t\tmKeyboardButton.setContentDescription(getResources().getText(R.string.image_description_hide_keyboard));\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// keyboard is closed\n\t\t\t\t\t\tmKeyboardButton.setImageResource(R.drawable.ic_keyboard);\n\t\t\t\t\t\tmKeyboardButton.setContentDescription(getResources().getText(R.string.image_description_show_keyboard));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t}\n\n\tprivate void addKeyRepeater(View view) {\n\t\tKeyRepeater keyRepeater = new KeyRepeater(keyRepeatHandler, view);\n\t\tview.setOnClickListener(keyRepeater);\n\t\tview.setOnTouchListener(keyRepeater);\n\t}\n\n\t/**\n\t * Ties the {@link TabLayout} to the {@link TerminalViewPager}.\n\t *\n\t * <p>This method will:\n\t * <ul>\n\t *     <li>Add a {@link TerminalViewPager.OnPageChangeListener} that will forward events to\n\t *     this TabLayout.<\/li>\n\t *     <li>Populate the TabLayout's tabs from the ViewPager's {@link PagerAdapter}.<\/li>\n\t *     <li>Set our {@link TabLayout.OnTabSelectedListener} which will forward\n\t *     selected events to the ViewPager<\/li>\n\t * <\/ul>\n\t * <\/p>\n\t */\n\tpublic void setupTabLayoutWithViewPager() {\n\t\ttabs.setTabsFromPagerAdapter(adapter);\n\t\tpager.addOnPageChangeListener(new TabLayout.TabLayoutOnPageChangeListener(tabs));\n\t\ttabs.setOnTabSelectedListener(new TabLayout.ViewPagerOnTabSelectedListener(pager));\n\n\t\tif (adapter.getCount() > 0) {\n\t\t\tfinal int curItem = pager.getCurrentItem();\n\t\t\tif (tabs.getSelectedTabPosition() != curItem) {\n\t\t\t\ttabs.getTabAt(curItem).select();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t *\n\t */\n\tprivate void configureOrientation() {\n\t\tString rotateDefault;\n\t\tif (getResources().getConfiguration().keyboard == Configuration.KEYBOARD_NOKEYS)\n\t\t\trotateDefault = PreferenceConstants.ROTATION_PORTRAIT;\n\t\telse\n\t\t\trotateDefault = PreferenceConstants.ROTATION_LANDSCAPE;\n\n\t\tString rotate = prefs.getString(PreferenceConstants.ROTATION, rotateDefault);\n\t\tif (PreferenceConstants.ROTATION_DEFAULT.equals(rotate))\n\t\t\trotate = rotateDefault;\n\n\t\t// request a forced orientation if requested by user\n\t\tif (PreferenceConstants.ROTATION_LANDSCAPE.equals(rotate)) {\n\t\t\tsetRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);\n\t\t\tforcedOrientation = true;\n\t\t} else if (PreferenceConstants.ROTATION_PORTRAIT.equals(rotate)) {\n\t\t\tsetRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);\n\t\t\tforcedOrientation = true;\n\t\t} else {\n\t\t\tsetRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);\n\t\t\tforcedOrientation = false;\n\t\t}\n\t}\n\n\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu) {\n\t\tsuper.onCreateOptionsMenu(menu);\n\n\t\tTerminalView view = adapter.getCurrentTerminalView();\n\t\tfinal boolean activeTerminal = view != null;\n\t\tboolean sessionOpen = false;\n\t\tboolean disconnected = false;\n\t\tboolean canForwardPorts = false;\n\n\t\tif (activeTerminal) {\n\t\t\tTerminalBridge bridge = view.bridge;\n\t\t\tsessionOpen = bridge.isSessionOpen();\n\t\t\tdisconnected = bridge.isDisconnected();\n\t\t\tcanForwardPorts = bridge.canFowardPorts();\n\t\t}\n\n\t\tmenu.setQwertyMode(true);\n\n\t\tdisconnect = menu.add(R.string.list_host_disconnect);\n\t\tif (hardKeyboard)\n\t\t\tdisconnect.setAlphabeticShortcut('w');\n\t\tif (!sessionOpen && disconnected)\n\t\t\tdisconnect.setTitle(R.string.console_menu_close);\n\t\tdisconnect.setEnabled(activeTerminal);\n\t\tdisconnect.setIcon(android.R.drawable.ic_menu_close_clear_cancel);\n\t\tdisconnect.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t@Override\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t// disconnect or close the currently visible session\n\t\t\t\tTerminalView terminalView = adapter.getCurrentTerminalView();\n\t\t\t\tTerminalBridge bridge = terminalView.bridge;\n\n\t\t\t\tbridge.dispatchDisconnect(true);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\tpaste = menu.add(R.string.console_menu_paste);\n\t\tif (hardKeyboard)\n\t\t\tpaste.setAlphabeticShortcut('v');\n\t\tMenuItemCompat.setShowAsAction(paste, MenuItemCompat.SHOW_AS_ACTION_IF_ROOM);\n\t\tpaste.setIcon(R.drawable.ic_action_paste);\n\t\tpaste.setEnabled(activeTerminal);\n\t\tpaste.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t@Override\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tpasteIntoTerminal();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\tportForward = menu.add(R.string.console_menu_portforwards);\n\t\tif (hardKeyboard)\n\t\t\tportForward.setAlphabeticShortcut('f');\n\t\tportForward.setIcon(android.R.drawable.ic_menu_manage);\n\t\tportForward.setEnabled(sessionOpen && canForwardPorts);\n\t\tportForward.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t@Override\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tTerminalView terminalView = adapter.getCurrentTerminalView();\n\t\t\t\tTerminalBridge bridge = terminalView.bridge;\n\n\t\t\t\tIntent intent = new Intent(ConsoleActivity.this, PortForwardListActivity.class);\n\t\t\t\tintent.putExtra(Intent.EXTRA_TITLE, bridge.host.getId());\n\t\t\t\tConsoleActivity.this.startActivityForResult(intent, REQUEST_EDIT);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\turlscan = menu.add(R.string.console_menu_urlscan);\n\t\tif (hardKeyboard)\n\t\t\turlscan.setAlphabeticShortcut('u');\n\t\turlscan.setIcon(android.R.drawable.ic_menu_search);\n\t\turlscan.setEnabled(activeTerminal);\n\t\turlscan.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t@Override\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tfinal TerminalView terminalView = adapter.getCurrentTerminalView();\n\n\t\t\t\tList<String> urls = terminalView.bridge.scanForURLs();\n\n\t\t\t\tDialog urlDialog = new Dialog(ConsoleActivity.this);\n\t\t\t\turlDialog.setTitle(R.string.console_menu_urlscan);\n\n\t\t\t\tListView urlListView = new ListView(ConsoleActivity.this);\n\t\t\t\tURLItemListener urlListener = new URLItemListener(ConsoleActivity.this);\n\t\t\t\turlListView.setOnItemClickListener(urlListener);\n\n\t\t\t\turlListView.setAdapter(new ArrayAdapter<>(ConsoleActivity.this, android.R.layout.simple_list_item_1, urls));\n\t\t\t\turlDialog.setContentView(urlListView);\n\t\t\t\turlDialog.show();\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\tresize = menu.add(R.string.console_menu_resize);\n\t\tif (hardKeyboard)\n\t\t\tresize.setAlphabeticShortcut('s');\n\t\tresize.setIcon(android.R.drawable.ic_menu_crop);\n\t\tresize.setEnabled(sessionOpen);\n\t\tresize.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t@Override\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tfinal TerminalView terminalView = adapter.getCurrentTerminalView();\n\n\t\t\t\t@SuppressLint(\"InflateParams\")  // Dialogs do not have a parent view.\n\t\t\t\tfinal View resizeView = inflater.inflate(R.layout.dia_resize, null, false);\n\t\t\t\tnew androidx.appcompat.app.AlertDialog.Builder(\n\t\t\t\t\t\t\t\tConsoleActivity.this, R.style.AlertDialogTheme)\n\t\t\t\t\t\t.setView(resizeView)\n\t\t\t\t\t\t.setPositiveButton(R.string.button_resize, new DialogInterface.OnClickListener() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\t\t\t\tint width, height;\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\twidth = Integer.parseInt(((EditText) resizeView\n\t\t\t\t\t\t\t\t\t\t\t.findViewById(R.id.width))\n\t\t\t\t\t\t\t\t\t\t\t.getText().toString());\n\t\t\t\t\t\t\t\t\theight = Integer.parseInt(((EditText) resizeView\n\t\t\t\t\t\t\t\t\t\t\t.findViewById(R.id.height))\n\t\t\t\t\t\t\t\t\t\t\t.getText().toString());\n\t\t\t\t\t\t\t\t} catch (NumberFormatException nfe) {\n\t\t\t\t\t\t\t\t\t// TODO change this to a real dialog where we can\n\t\t\t\t\t\t\t\t\t// make the input boxes turn red to indicate an error.\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tterminalView.forceSize(width, height);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}).setNegativeButton(android.R.string.cancel, null).create().show();\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean onPrepareOptionsMenu(Menu menu) {\n\t\tsuper.onPrepareOptionsMenu(menu);\n\n\t\tsetVolumeControlStream(AudioManager.STREAM_NOTIFICATION);\n\n\t\tfinal TerminalView view = adapter.getCurrentTerminalView();\n\t\tboolean activeTerminal = view != null;\n\t\tboolean sessionOpen = false;\n\t\tboolean disconnected = false;\n\t\tboolean canForwardPorts = false;\n\n\t\tif (activeTerminal) {\n\t\t\tTerminalBridge bridge = view.bridge;\n\t\t\tsessionOpen = bridge.isSessionOpen();\n\t\t\tdisconnected = bridge.isDisconnected();\n\t\t\tcanForwardPorts = bridge.canFowardPorts();\n\t\t}\n\n\t\tdisconnect.setEnabled(activeTerminal);\n\t\tif (sessionOpen || !disconnected)\n\t\t\tdisconnect.setTitle(R.string.list_host_disconnect);\n\t\telse\n\t\t\tdisconnect.setTitle(R.string.console_menu_close);\n\n\t\tpaste.setEnabled(activeTerminal);\n\t\tportForward.setEnabled(sessionOpen && canForwardPorts);\n\t\turlscan.setEnabled(activeTerminal);\n\t\tresize.setEnabled(sessionOpen);\n\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tswitch (item.getItemId()) {\n\t\tcase android.R.id.home:\n\t\t\tIntent intent = new Intent(this, HostListActivity.class);\n\t\t\tintent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n\t\t\tstartActivity(intent);\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn super.onOptionsItemSelected(item);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void onOptionsMenuClosed(Menu menu) {\n\t\tsuper.onOptionsMenuClosed(menu);\n\n\t\tsetVolumeControlStream(AudioManager.STREAM_MUSIC);\n\t}\n\n\t@Override\n\tpublic void onStart() {\n\t\tsuper.onStart();\n\n\t\t// connect with manager service to find all bridges\n\t\t// when connected it will insert all views\n\t\tbindService(new Intent(this, TerminalManager.class), connection, Context.BIND_AUTO_CREATE);\n\t}\n\n\t@Override\n\tpublic void onPause() {\n\t\tsuper.onPause();\n\t\tLog.d(TAG, \"onPause called\");\n\n\t\tif (forcedOrientation && bound != null) {\n\t\t\tbound.setResizeAllowed(false);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void onResume() {\n\t\tsuper.onResume();\n\t\tLog.d(TAG, \"onResume called\");\n\n\t\t// Make sure we don't let the screen fall asleep.\n\t\t// This also keeps the Wi-Fi chipset from disconnecting us.\n\t\tif (prefs.getBoolean(PreferenceConstants.KEEP_ALIVE, true)) {\n\t\t\tgetWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);\n\t\t} else {\n\t\t\tgetWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);\n\t\t}\n\n\t\tconfigureOrientation();\n\n\t\tif (forcedOrientation && bound != null) {\n\t\t\tbound.setResizeAllowed(true);\n\t\t}\n\t}\n\n\t/* (non-Javadoc)\n\t * @see android.app.Activity#onNewIntent(android.content.Intent)\n\t */\n\t@Override\n\tprotected void onNewIntent(Intent intent) {\n\t\tsuper.onNewIntent(intent);\n\n\t\tLog.d(TAG, \"onNewIntent called\");\n\n\t\trequested = intent.getData();\n\n\t\tif (requested == null) {\n\t\t\tLog.e(TAG, \"Got null intent data in onNewIntent()\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (bound == null) {\n\t\t\tLog.e(TAG, \"We're not bound in onNewIntent()\");\n\t\t\treturn;\n\t\t}\n\n\t\tTerminalBridge requestedBridge = bound.getConnectedBridge(requested.getFragment());\n\t\tint requestedIndex = 0;\n\n\t\tsynchronized (pager) {\n\t\t\tif (requestedBridge == null) {\n\t\t\t\t// If we didn't find the requested connection, try opening it\n\n\t\t\t\ttry {\n\t\t\t\t\tLog.d(TAG, String.format(\"We couldnt find an existing bridge with URI=%s (nickname=%s),\" +\n\t\t\t\t\t\t\t\"so creating one now\", requested.toString(), requested.getFragment()));\n\t\t\t\t\tbound.openConnection(requested);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tLog.e(TAG, \"Problem while trying to create new requested bridge from URI\", e);\n\t\t\t\t\t// TODO: We should display an error dialog here.\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tadapter.notifyDataSetChanged();\n\t\t\t\trequestedIndex = adapter.getCount();\n\t\t\t} else {\n\t\t\t\tfinal int flipIndex = bound.getBridges().indexOf(requestedBridge);\n\t\t\t\tif (flipIndex > requestedIndex) {\n\t\t\t\t\trequestedIndex = flipIndex;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsetDisplayedTerminal(requestedIndex);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void onStop() {\n\t\tsuper.onStop();\n\n\t\tunbindService(connection);\n\t}\n\n\t@Override\n\tpublic void onSaveInstanceState(Bundle savedInstanceState) {\n\t\t// Maintain selected host if connected.\n\t\tTerminalView currentTerminalView = adapter.getCurrentTerminalView();\n\t\tif (currentTerminalView != null\n\t\t\t\t&& !currentTerminalView.bridge.isDisconnected()) {\n\t\t\trequested = currentTerminalView.bridge.host.getUri();\n\t\t\tsavedInstanceState.putString(STATE_SELECTED_URI, requested.toString());\n\t\t}\n\n\t\tsuper.onSaveInstanceState(savedInstanceState);\n\t}\n\n\t/**\n\t * Save the currently shown {@link TerminalView} as the default. This is\n\t * saved back down into {@link TerminalManager} where we can read it again\n\t * later.\n\t */\n\tprivate void updateDefault() {\n\t\t// update the current default terminal\n\t\tTerminalView view = adapter.getCurrentTerminalView();\n\t\tif (view == null || bound == null) {\n\t\t\treturn;\n\t\t}\n\t\tbound.defaultBridge = view.bridge;\n\t}\n\n\tprotected void updateEmptyVisible() {\n\t\t// update visibility of empty status message\n\t\tempty.setVisibility((pager.getChildCount() == 0) ? View.VISIBLE : View.GONE);\n\t}\n\n\t/**\n\t * Show any prompts requested by the currently visible {@link TerminalView}.\n\t */\n\tprotected void updatePromptVisible() {\n\t\t// check if our currently-visible terminalbridge is requesting any prompt services\n\t\tTerminalView view = adapter.getCurrentTerminalView();\n\n\t\t// Hide all the prompts in case a prompt request was canceled\n\t\thideAllPrompts();\n\n\t\tif (view == null) {\n\t\t\t// we dont have an active view, so hide any prompts\n\t\t\treturn;\n\t\t}\n\n\t\tPromptHelper prompt = view.bridge.promptHelper;\n\t\tif (String.class.equals(prompt.promptRequested)) {\n\t\t\thideEmulatedKeys();\n\t\t\tstringPromptGroup.setVisibility(View.VISIBLE);\n\n\t\t\tString instructions = prompt.promptInstructions;\n\t\t\tif (instructions != null && instructions.length() > 0) {\n\t\t\t\tstringPromptInstructions.setVisibility(View.VISIBLE);\n\t\t\t\tstringPromptInstructions.setText(instructions);\n\t\t\t} else\n\t\t\t\tstringPromptInstructions.setVisibility(View.GONE);\n\t\t\tstringPrompt.setText(\"\");\n\t\t\tstringPrompt.setHint(prompt.promptHint);\n\t\t\tstringPrompt.requestFocus();\n\n\t\t} else if (Boolean.class.equals(prompt.promptRequested)) {\n\t\t\thideEmulatedKeys();\n\t\t\tbooleanPromptGroup.setVisibility(View.VISIBLE);\n\t\t\tbooleanPrompt.setText(prompt.promptHint);\n\t\t\tbooleanYes.requestFocus();\n\n\t\t} else {\n\t\t\thideAllPrompts();\n\t\t\tview.requestFocus();\n\t\t}\n\t}\n\n\tprivate static class URLItemListener implements OnItemClickListener {\n\t\tprivate final WeakReference<Context> contextRef;\n\n\t\tURLItemListener(Context context) {\n\t\t\tthis.contextRef = new WeakReference<>(context);\n\t\t}\n\n\t\t@Override\n\t\tpublic void onItemClick(AdapterView<?> arg0, View view, int position, long id) {\n\t\t\tContext context = contextRef.get();\n\n\t\t\tif (context == null)\n\t\t\t\treturn;\n\n\t\t\ttry {\n\t\t\t\tTextView urlView = (TextView) view;\n\n\t\t\t\tString url = urlView.getText().toString();\n\t\t\t\tIntent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));\n\t\t\t\tcontext.startActivity(intent);\n\t\t\t} catch (Exception e) {\n\t\t\t\tLog.e(TAG, \"couldn't open URL\", e);\n\t\t\t\t// We should probably tell the user that we couldn't find a handler...\n\t\t\t}\n\t\t}\n\n\t}\n\n\t@Override\n\tpublic void onConfigurationChanged(Configuration newConfig) {\n\t\tsuper.onConfigurationChanged(newConfig);\n\n\t\tLog.d(TAG, String.format(\"onConfigurationChanged; requestedOrientation=%d, newConfig.orientation=%d\", getRequestedOrientation(), newConfig.orientation));\n\t\tif (bound != null) {\n\t\t\tbound.setResizeAllowed(!forcedOrientation ||\n\t\t\t\t\t((newConfig.orientation == Configuration.ORIENTATION_LANDSCAPE ||\n\t\t\t\t\t\t\tgetRequestedOrientation() != ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE) &&\n\t\t\t\t\t\t\t(newConfig.orientation == Configuration.ORIENTATION_PORTRAIT ||\n\t\t\t\t\t\t\t\t\tgetRequestedOrientation() != ActivityInfo.SCREEN_ORIENTATION_PORTRAIT)));\n\n\t\t\tbound.hardKeyboardHidden = (newConfig.hardKeyboardHidden == Configuration.HARDKEYBOARDHIDDEN_YES);\n\n\t\t\tmKeyboardButton.setVisibility(bound.hardKeyboardHidden ? View.VISIBLE : View.GONE);\n\t\t}\n\t}\n\n\t/**\n\t * Called whenever the displayed terminal is changed.\n\t */\n\tprivate void onTerminalChanged() {\n\t\tView terminalNameOverlay = findCurrentView(R.id.terminal_name_overlay);\n\t\tif (terminalNameOverlay != null)\n\t\t\tterminalNameOverlay.startAnimation(fade_out_delayed);\n\t\tupdateDefault();\n\t\tupdatePromptVisible();\n\t\tActivityCompat.invalidateOptionsMenu(ConsoleActivity.this);\n\t}\n\n\t/**\n\t * Displays the child in the ViewPager at the requestedIndex and updates the prompts.\n\t *\n\t * @param requestedIndex the index of the terminal view to display\n\t */\n\tprivate void setDisplayedTerminal(int requestedIndex) {\n\t\tpager.setCurrentItem(requestedIndex);\n\t\t// set activity title\n\t\tsetTitle(adapter.getPageTitle(requestedIndex));\n\t\tonTerminalChanged();\n\t}\n\n\tprivate void pasteIntoTerminal() {\n\t\t// force insert of clipboard text into current console\n\t\tTerminalView terminalView = adapter.getCurrentTerminalView();\n\t\tTerminalBridge bridge = terminalView.bridge;\n\n\t\t// pull string from clipboard and generate all events to force down\n\t\tString clip = \"\";\n\t\tif (clipboard.hasText()) {\n\t\t\tclip = clipboard.getText().toString();\n\t\t}\n\t\tbridge.injectString(clip);\n\t}\n\n\tpublic class TerminalPagerAdapter extends PagerAdapter {\n\t\t@Override\n\t\tpublic int getCount() {\n\t\t\tif (bound != null) {\n\t\t\t\treturn bound.getBridges().size();\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Object instantiateItem(ViewGroup container, int position) {\n\t\t\tif (bound == null || bound.getBridges().size() <= position) {\n\t\t\t\tLog.w(TAG, \"Activity not bound when creating TerminalView.\");\n\t\t\t}\n\t\t\tTerminalBridge bridge = bound.getBridges().get(position);\n\t\t\tbridge.promptHelper.setHandler(promptHandler);\n\n\t\t\t// inflate each terminal view\n\t\t\tRelativeLayout view = (RelativeLayout) inflater.inflate(\n\t\t\t\t\tR.layout.item_terminal, container, false);\n\n\t\t\t// set the terminal name overlay text\n\t\t\tTextView terminalNameOverlay = view.findViewById(R.id.terminal_name_overlay);\n\t\t\tterminalNameOverlay.setText(bridge.host.getNickname());\n\n\t\t\t// and add our terminal view control, using index to place behind overlay\n\t\t\tfinal TerminalView terminal = new TerminalView(container.getContext(), bridge, pager);\n\t\t\tterminal.setId(R.id.terminal_view);\n\t\t\tview.addView(terminal, 0);\n\n\t\t\t// Tag the view with its bridge so it can be retrieved later.\n\t\t\tview.setTag(bridge);\n\n\t\t\tcontainer.addView(view);\n\t\t\tterminalNameOverlay.startAnimation(fade_out_delayed);\n\t\t\treturn view;\n\t\t}\n\n\t\t@Override\n\t\tpublic void destroyItem(ViewGroup container, int position, Object object) {\n\t\t\tfinal View view = (View) object;\n\n\t\t\tcontainer.removeView(view);\n\t\t}\n\n\t\t@Override\n\t\tpublic int getItemPosition(Object object) {\n\t\t\tif (bound == null) {\n\t\t\t\treturn POSITION_NONE;\n\t\t\t}\n\n\t\t\tView view = (View) object;\n\t\t\tTerminalView terminal = view.findViewById(R.id.terminal_view);\n\t\t\tHostBean host = terminal.bridge.host;\n\n\t\t\tint itemIndex = POSITION_NONE;\n\t\t\tint i = 0;\n\t\t\tfor (TerminalBridge bridge : bound.getBridges()) {\n\t\t\t\tif (bridge.host.equals(host)) {\n\t\t\t\t\titemIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t\treturn itemIndex;\n\t\t}\n\n\t\tpublic TerminalBridge getBridgeAtPosition(int position) {\n\t\t\tif (bound == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tArrayList<TerminalBridge> bridges = bound.getBridges();\n\t\t\tif (position < 0 || position >= bridges.size()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn bridges.get(position);\n\t\t}\n\n\t\t@Override\n\t\tpublic void notifyDataSetChanged() {\n\t\t\tsuper.notifyDataSetChanged();\n\t\t\tif (tabs != null) {\n\t\t\t\ttoolbar.setVisibility(this.getCount() > 1 ? View.VISIBLE : View.GONE);\n\t\t\t\ttabs.setTabsFromPagerAdapter(this);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isViewFromObject(View view, Object object) {\n\t\t\treturn view == object;\n\t\t}\n\n\t\t@Override\n\t\tpublic CharSequence getPageTitle(int position) {\n\t\t\tTerminalBridge bridge = getBridgeAtPosition(position);\n\t\t\tif (bridge == null) {\n\t\t\t\treturn \"???\";\n\t\t\t}\n\t\t\treturn bridge.host.getNickname();\n\t\t}\n\n\t\tpublic TerminalView getCurrentTerminalView() {\n\t\t\tView currentView = pager.findViewWithTag(getBridgeAtPosition(pager.getCurrentItem()));\n\t\t\tif (currentView == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn (TerminalView) currentView.findViewById(R.id.terminal_view);\n\t\t}\n\t}\n}\n","Method after Refactoring":"/*\n * ConnectBot: simple, powerful, open-source SSH client for Android\n * Copyright 2007 Kenny Root, Jeffrey Sharkey\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.connectbot;\n\nimport java.lang.ref.WeakReference;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.connectbot.bean.HostBean;\nimport org.connectbot.service.BridgeDisconnectedListener;\nimport org.connectbot.service.PromptHelper;\nimport org.connectbot.service.TerminalBridge;\nimport org.connectbot.service.TerminalKeyListener;\nimport org.connectbot.service.TerminalManager;\nimport org.connectbot.util.PreferenceConstants;\nimport org.connectbot.util.TerminalViewPager;\n\nimport android.annotation.SuppressLint;\nimport android.app.Dialog;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.ServiceConnection;\nimport android.content.SharedPreferences;\nimport android.content.pm.ActivityInfo;\nimport android.content.res.Configuration;\nimport android.graphics.Rect;\nimport android.media.AudioManager;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Message;\nimport android.os.StrictMode;\nimport android.preference.PreferenceManager;\nimport androidx.annotation.Nullable;\nimport com.google.android.material.tabs.TabLayout;\nimport androidx.core.app.ActivityCompat;\nimport androidx.core.view.MenuItemCompat;\nimport androidx.viewpager.widget.PagerAdapter;\nimport androidx.appcompat.app.ActionBar;\nimport androidx.appcompat.app.AppCompatActivity;\nimport androidx.appcompat.widget.Toolbar;\nimport android.text.ClipboardManager;\nimport android.util.Log;\nimport android.view.KeyEvent;\nimport android.view.LayoutInflater;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.MenuItem.OnMenuItemClickListener;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.view.View.OnClickListener;\nimport android.view.View.OnKeyListener;\nimport android.view.View.OnTouchListener;\nimport android.view.ViewGroup;\nimport android.view.ViewTreeObserver;\nimport android.view.Window;\nimport android.view.WindowManager;\nimport android.view.animation.Animation;\nimport android.view.animation.AnimationUtils;\nimport android.view.inputmethod.InputMethodManager;\nimport android.widget.AdapterView;\nimport android.widget.AdapterView.OnItemClickListener;\nimport android.widget.ArrayAdapter;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.HorizontalScrollView;\nimport android.widget.ImageView;\nimport android.widget.LinearLayout;\nimport android.widget.ListView;\nimport android.widget.RelativeLayout;\nimport android.widget.TextView;\nimport de.mud.terminal.vt320;\n\npublic class ConsoleActivity extends AppCompatActivity implements BridgeDisconnectedListener {\n\tpublic final static String TAG = \"CB.ConsoleActivity\";\n\n\tprotected static final int REQUEST_EDIT = 1;\n\n\tprivate static final int KEYBOARD_DISPLAY_TIME = 3000;\n\tprivate static final int KEYBOARD_REPEAT_INITIAL = 500;\n\tprivate static final int KEYBOARD_REPEAT = 100;\n\tprivate static final String STATE_SELECTED_URI = \"selectedUri\";\n\n\tprotected TerminalViewPager pager = null;\n\tprotected TabLayout tabs = null;\n\tprotected Toolbar toolbar = null;\n\t@Nullable\n\tprotected TerminalManager bound = null;\n\tprotected TerminalPagerAdapter adapter = null;\n\tprotected LayoutInflater inflater = null;\n\n\tprivate SharedPreferences prefs = null;\n\n\t// determines whether or not menuitem accelerators are bound\n\t// otherwise they collide with an external keyboard's CTRL-char\n\tprivate boolean hardKeyboard = false;\n\n\tprotected Uri requested;\n\n\tprotected ClipboardManager clipboard;\n\tprivate RelativeLayout stringPromptGroup;\n\tprotected EditText stringPrompt;\n\tprivate TextView stringPromptInstructions;\n\n\tprivate RelativeLayout booleanPromptGroup;\n\tprivate TextView booleanPrompt;\n\tprivate Button booleanYes;\n\n\tprivate LinearLayout keyboardGroup;\n\tprivate Runnable keyboardGroupHider;\n\n\tprivate TextView empty;\n\n\tprivate Animation fade_out_delayed;\n\n\tprivate Animation keyboard_fade_in, keyboard_fade_out;\n\n\tprivate MenuItem disconnect;\n\tprivate MenuItem paste;\n\tprivate MenuItem portForward;\n\tprivate MenuItem resize;\n\tprivate MenuItem urlscan;\n\n\tprivate boolean forcedOrientation;\n\n\tprivate final Handler handler = new Handler();\n\n\tprivate View contentView;\n\n\tprivate ImageView mKeyboardButton;\n\n\t@Nullable private ActionBar actionBar;\n\tprivate boolean inActionBarMenu = false;\n\tprivate boolean titleBarHide;\n\tprivate boolean keyboardAlwaysVisible = false;\n\n\tprivate final ServiceConnection connection = new ServiceConnection() {\n\t\t@Override\n\t\tpublic void onServiceConnected(ComponentName className, IBinder service) {\n\t\t\tbound = ((TerminalManager.TerminalBinder) service).getService();\n\n\t\t\t// let manager know about our event handling services\n\t\t\tbound.disconnectListener = ConsoleActivity.this;\n\t\t\tbound.setResizeAllowed(true);\n\n\t\t\tfinal String requestedNickname = (requested != null) ? requested.getFragment() : null;\n\t\t\tTerminalBridge requestedBridge = bound.getConnectedBridge(requestedNickname);\n\n\t\t\t// If we didn't find the requested connection, try opening it\n\t\t\tif (requestedNickname != null && requestedBridge == null) {\n\t\t\t\ttry {\n\t\t\t\t\tLog.d(TAG, String.format(\"We couldn't find an existing bridge with URI=%s (nickname=%s), so creating one now\", requested.toString(), requestedNickname));\n\t\t\t\t\trequestedBridge = bound.openConnection(requested);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tLog.e(TAG, \"Problem while trying to create new requested bridge from URI\", e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// create views for all bridges on this service\n\t\t\tadapter.notifyDataSetChanged();\n\t\t\tfinal int requestedIndex = bound.getBridges().indexOf(requestedBridge);\n\n\t\t\tif (requestedBridge != null)\n\t\t\t\trequestedBridge.promptHelper.setHandler(promptHandler);\n\n\n\t\t\tif (requestedIndex != -1) {\n\t\t\t\tpager.post(new Runnable() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\tsetDisplayedTerminal(requestedIndex);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void onServiceDisconnected(ComponentName className) {\n\t\t\tbound = null;\n\t\t\tadapter.notifyDataSetChanged();\n\t\t\tupdateEmptyVisible();\n\t\t}\n\t};\n\n\tprotected Handler promptHandler = new Handler() {\n\t\t@Override\n\t\tpublic void handleMessage(Message msg) {\n\t\t\t// someone below us requested to display a prompt\n\t\t\tupdatePromptVisible();\n\t\t}\n\t};\n\n\t@Override\n\tpublic void onDisconnected(TerminalBridge bridge) {\n\t\tsynchronized (adapter) {\n\t\t\tadapter.notifyDataSetChanged();\n\t\t\tLog.d(TAG, \"Someone sending HANDLE_DISCONNECT to parentHandler\");\n\n\t\t\tif (bridge.isAwaitingClose()) {\n\t\t\t\tcloseBridge(bridge);\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected OnClickListener emulatedKeysListener = new OnClickListener() {\n\t\t@Override\n\t\tpublic void onClick(View v) {\n\t\t\tonEmulatedKeyClicked(v);\n\t\t}\n\t};\n\n\tprotected Handler keyRepeatHandler = new Handler();\n\n\n\t/**\n\t * Handle repeatable virtual keys and touch events\n\t */\n\tpublic class KeyRepeater implements Runnable, OnTouchListener, OnClickListener {\n\t\tprivate final View mView;\n\t\tprivate final Handler mHandler;\n\t\tprivate boolean mDown;\n\n\t\tpublic KeyRepeater(Handler handler, View view) {\n\t\t\tmView = view;\n\t\t\tmHandler = handler;\n\t\t\tmDown = false;\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tmDown = true;\n\t\t\tmHandler.removeCallbacks(this);\n\t\t\tmHandler.postDelayed(this, KEYBOARD_REPEAT);\n\t\t\tmView.performClick();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean onTouch(View v, MotionEvent event) {\n\t\t\tif (BuildConfig.DEBUG) {\n\t\t\t\tLog.d(TAG, \"KeyRepeater.onTouch(\" + v.getId() + \", \" +\n\t\t\t\t\t\tevent.getAction() + \", \" +\n\t\t\t\t\t\tevent.getActionIndex() + \", \" +\n\t\t\t\t\t\tevent.getActionMasked() + \");\");\n\t\t\t}\n\t\t\tswitch (event.getAction()) {\n\t\t\tcase MotionEvent.ACTION_DOWN:\n\t\t\t\tmDown = false;\n\t\t\t\tmHandler.postDelayed(this, KEYBOARD_REPEAT_INITIAL);\n\t\t\t\tmView.setPressed(true);\n\t\t\t\treturn true;\n\n\t\t\tcase MotionEvent.ACTION_CANCEL:\n\t\t\t\tmHandler.removeCallbacks(this);\n\t\t\t\tmView.setPressed(false);\n\t\t\t\treturn true;\n\n\t\t\tcase MotionEvent.ACTION_UP:\n\t\t\t\tmHandler.removeCallbacks(this);\n\t\t\t\tmView.setPressed(false);\n\n\t\t\t\tif (!mDown) {\n\t\t\t\t\tmView.performClick();\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic void onClick(View view) {\n\t\t\tonEmulatedKeyClicked(view);\n\t\t}\n\t}\n\n\tprivate void onEmulatedKeyClicked(View v) {\n\t\tTerminalView terminal = adapter.getCurrentTerminalView();\n\t\tif (terminal == null) return;\n\n\t\tif (BuildConfig.DEBUG) {\n\t\t\tLog.d(TAG, \"onEmulatedKeyClicked(\" + v.getId() + \")\");\n\t\t}\n\t\tTerminalKeyListener handler = terminal.bridge.getKeyHandler();\n\t\tboolean hideKeys = false;\n\n\t\tint id = v.getId();\n\t\tif (id == R.id.button_ctrl) {\n\t\t\thandler.metaPress(TerminalKeyListener.OUR_CTRL_ON, true);\n\t\t\thideKeys = true;\n\t\t} else if (id == R.id.button_esc) {\n\t\t\thandler.sendEscape();\n\t\t\thideKeys = true;\n\t\t} else if (id == R.id.button_tab) {\n\t\t\thandler.sendTab();\n\t\t\thideKeys = true;\n\t\t} else if (id == R.id.button_up) {\n\t\t\thandler.sendPressedKey(vt320.KEY_UP);\n\t\t} else if (id == R.id.button_down) {\n\t\t\thandler.sendPressedKey(vt320.KEY_DOWN);\n\t\t} else if (id == R.id.button_left) {\n\t\t\thandler.sendPressedKey(vt320.KEY_LEFT);\n\t\t} else if (id == R.id.button_right) {\n\t\t\thandler.sendPressedKey(vt320.KEY_RIGHT);\n\t\t} else if (id == R.id.button_home) {\n\t\t\thandler.sendPressedKey(vt320.KEY_HOME);\n\t\t} else if (id == R.id.button_end) {\n\t\t\thandler.sendPressedKey(vt320.KEY_END);\n\t\t} else if (id == R.id.button_pgup) {\n\t\t\thandler.sendPressedKey(vt320.KEY_PAGE_UP);\n\t\t} else if (id == R.id.button_pgdn) {\n\t\t\thandler.sendPressedKey(vt320.KEY_PAGE_DOWN);\n\t\t} else if (id == R.id.button_f1) {\n\t\t\thandler.sendPressedKey(vt320.KEY_F1);\n\t\t} else if (id == R.id.button_f2) {\n\t\t\thandler.sendPressedKey(vt320.KEY_F2);\n\t\t} else if (id == R.id.button_f3) {\n\t\t\thandler.sendPressedKey(vt320.KEY_F3);\n\t\t} else if (id == R.id.button_f4) {\n\t\t\thandler.sendPressedKey(vt320.KEY_F4);\n\t\t} else if (id == R.id.button_f5) {\n\t\t\thandler.sendPressedKey(vt320.KEY_F5);\n\t\t} else if (id == R.id.button_f6) {\n\t\t\thandler.sendPressedKey(vt320.KEY_F6);\n\t\t} else if (id == R.id.button_f7) {\n\t\t\thandler.sendPressedKey(vt320.KEY_F7);\n\t\t} else if (id == R.id.button_f8) {\n\t\t\thandler.sendPressedKey(vt320.KEY_F8);\n\t\t} else if (id == R.id.button_f9) {\n\t\t\thandler.sendPressedKey(vt320.KEY_F9);\n\t\t} else if (id == R.id.button_f10) {\n\t\t\thandler.sendPressedKey(vt320.KEY_F10);\n\t\t} else if (id == R.id.button_f11) {\n\t\t\thandler.sendPressedKey(vt320.KEY_F11);\n\t\t} else if (id == R.id.button_f12) {\n\t\t\thandler.sendPressedKey(vt320.KEY_F12);\n\t\t} else {\n\t\t\tLog.e(TAG, \"Unknown emulated key clicked: \" + v.getId());\n\t\t}\n\n\t\tif (hideKeys) {\n\t\t\thideEmulatedKeys();\n\t\t} else {\n\t\t\tautoHideEmulatedKeys();\n\t\t}\n\n\t\tterminal.bridge.tryKeyVibrate();\n\t\thideActionBarIfRequested();\n\t}\n\n\tprivate void hideActionBarIfRequested() {\n\t\tif (titleBarHide && actionBar != null) {\n\t\t\tactionBar.hide();\n\t\t}\n\t}\n\n\tprivate void closeBridge(final TerminalBridge bridge) {\n\t\tupdateEmptyVisible();\n\t\tupdatePromptVisible();\n\n\t\t// If we just closed the last bridge, go back to the previous activity.\n\t\tif (pager.getChildCount() == 0) {\n\t\t\tfinish();\n\t\t\tunregisterMenuListeners();\n\t\t}\n\t}\n\n\tprivate void unregisterMenuListeners() {\n\t\tportForward.setOnMenuItemClickListener(null);\n\t\tdisconnect.setOnMenuItemClickListener(null);\n\t\tpaste.setOnMenuItemClickListener(null);\n\t\tportForward.setOnMenuItemClickListener(null);\n\t\tresize.setOnMenuItemClickListener(null);\n\t\turlscan.setOnMenuItemClickListener(null);\n\t}\n\n\tprotected View findCurrentView(int id) {\n\t\tView view = pager.findViewWithTag(adapter.getBridgeAtPosition(pager.getCurrentItem()));\n\t\tif (view == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn view.findViewById(id);\n\t}\n\n\tprotected PromptHelper getCurrentPromptHelper() {\n\t\tTerminalView view = adapter.getCurrentTerminalView();\n\t\tif (view == null) return null;\n\t\treturn view.bridge.promptHelper;\n\t}\n\n\tprotected void hideAllPrompts() {\n\t\tstringPromptGroup.setVisibility(View.GONE);\n\t\tbooleanPromptGroup.setVisibility(View.GONE);\n\t}\n\n\tprivate void showEmulatedKeys(boolean showActionBar) {\n\t\tif (keyboardGroup.getVisibility() == View.GONE) {\n\t\t\tkeyboardGroup.startAnimation(keyboard_fade_in);\n\t\t\tkeyboardGroup.setVisibility(View.VISIBLE);\n\t\t}\n\t\tif (showActionBar) {\n\t\t\tactionBar.show();\n\t\t}\n\t\tautoHideEmulatedKeys();\n\t}\n\n\tprivate void autoHideEmulatedKeys() {\n\t\tif (keyboardGroupHider != null) {\n\t\t\thandler.removeCallbacks(keyboardGroupHider);\n\t\t}\n\n\t\tkeyboardGroupHider = new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tif (keyboardGroup.getVisibility() == View.GONE || inActionBarMenu) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (!keyboardAlwaysVisible) {\n\t\t\t\t\tkeyboardGroup.startAnimation(keyboard_fade_out);\n\t\t\t\t\tkeyboardGroup.setVisibility(View.GONE);\n\t\t\t\t}\n\t\t\t\thideActionBarIfRequested();\n\t\t\t\tkeyboardGroupHider = null;\n\t\t\t}\n\t\t};\n\t\thandler.postDelayed(keyboardGroupHider, KEYBOARD_DISPLAY_TIME);\n\t}\n\n\tprivate void hideEmulatedKeys() {\n\t\tif (!keyboardAlwaysVisible) {\n\t\t\tif (keyboardGroupHider != null)\n\t\t\t\thandler.removeCallbacks(keyboardGroupHider);\n\t\t\tkeyboardGroup.setVisibility(View.GONE);\n\t\t}\n\t\thideActionBarIfRequested();\n\t}\n\n\tprivate void requestActionBar() {\n\t\tsupportRequestWindowFeature(Window.FEATURE_ACTION_BAR_OVERLAY);\n\t}\n\n\t@Override\n\tpublic void onCreate(Bundle icicle) {\n\t\tsuper.onCreate(icicle);\n\n\t\tStrictMode.setThreadPolicy(StrictMode.ThreadPolicy.LAX);\n\n\t\thardKeyboard = getResources().getConfiguration().keyboard ==\n\t\t\t\tConfiguration.KEYBOARD_QWERTY;\n\n\t\tclipboard = (ClipboardManager) getSystemService(CLIPBOARD_SERVICE);\n\t\tprefs = PreferenceManager.getDefaultSharedPreferences(this);\n\n\t\ttitleBarHide = prefs.getBoolean(PreferenceConstants.TITLEBARHIDE, false);\n\t\tif (titleBarHide) {\n\t\t\t// This is a separate method because Gradle does not uniformly respect the conditional\n\t\t\t// Build check. See: https://code.google.com/p/android/issues/detail?id=137195\n\t\t\trequestActionBar();\n\t\t}\n\n\t\tthis.setContentView(R.layout.act_console);\n\n\t\t// hide status bar if requested by user\n\t\tif (prefs.getBoolean(PreferenceConstants.FULLSCREEN, false)) {\n\t\t\tgetWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,\n\t\t\t\t\tWindowManager.LayoutParams.FLAG_FULLSCREEN);\n\t\t}\n\n\t\t// TODO find proper way to disable volume key beep if it exists.\n\t\tsetVolumeControlStream(AudioManager.STREAM_MUSIC);\n\n\t\t// handle requested console from incoming intent\n\t\tif (icicle == null) {\n\t\t\trequested = getIntent().getData();\n\t\t} else {\n\t\t\tString uri = icicle.getString(STATE_SELECTED_URI);\n\t\t\tif (uri != null) {\n\t\t\t\trequested = Uri.parse(uri);\n\t\t\t}\n\t\t}\n\n\t\tinflater = LayoutInflater.from(this);\n\n\t\ttoolbar = findViewById(R.id.toolbar);\n\n\t\tpager = findViewById(R.id.console_flip);\n\t\tpager.addOnPageChangeListener(\n\t\t\t\tnew TerminalViewPager.SimpleOnPageChangeListener() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onPageSelected(int position) {\n\t\t\t\t\t\tsetTitle(adapter.getPageTitle(position));\n\t\t\t\t\t\tonTerminalChanged();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\tadapter = new TerminalPagerAdapter();\n\t\tpager.setAdapter(adapter);\n\n\t\tempty = findViewById(android.R.id.empty);\n\n\t\tstringPromptGroup = findViewById(R.id.console_password_group);\n\t\tstringPromptInstructions = findViewById(R.id.console_password_instructions);\n\t\tstringPrompt = findViewById(R.id.console_password);\n\t\tstringPrompt.setOnKeyListener(new OnKeyListener() {\n\t\t\t@Override\n\t\t\tpublic boolean onKey(View v, int keyCode, KeyEvent event) {\n\t\t\t\tif (event.getAction() == KeyEvent.ACTION_UP) return false;\n\t\t\t\tif (keyCode != KeyEvent.KEYCODE_ENTER) return false;\n\n\t\t\t\t// pass collected password down to current terminal\n\t\t\t\tString value = stringPrompt.getText().toString();\n\n\t\t\t\tPromptHelper helper = getCurrentPromptHelper();\n\t\t\t\tif (helper == null) return false;\n\t\t\t\thelper.setResponse(value);\n\n\t\t\t\t// finally clear password for next user\n\t\t\t\tstringPrompt.setText(\"\");\n\t\t\t\tupdatePromptVisible();\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\tbooleanPromptGroup = findViewById(R.id.console_boolean_group);\n\t\tbooleanPrompt = findViewById(R.id.console_prompt);\n\n\t\tbooleanYes = findViewById(R.id.console_prompt_yes);\n\t\tbooleanYes.setOnClickListener(new OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tPromptHelper helper = getCurrentPromptHelper();\n\t\t\t\tif (helper == null) return;\n\t\t\t\thelper.setResponse(Boolean.TRUE);\n\t\t\t\tupdatePromptVisible();\n\t\t\t}\n\t\t});\n\n\t\tButton booleanNo = findViewById(R.id.console_prompt_no);\n\t\tbooleanNo.setOnClickListener(new OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tPromptHelper helper = getCurrentPromptHelper();\n\t\t\t\tif (helper == null) return;\n\t\t\t\thelper.setResponse(Boolean.FALSE);\n\t\t\t\tupdatePromptVisible();\n\t\t\t}\n\t\t});\n\n\t\tfade_out_delayed = AnimationUtils.loadAnimation(this, R.anim.fade_out_delayed);\n\n\t\t// Preload animation for keyboard button\n\t\tkeyboard_fade_in = AnimationUtils.loadAnimation(this, R.anim.keyboard_fade_in);\n\t\tkeyboard_fade_out = AnimationUtils.loadAnimation(this, R.anim.keyboard_fade_out);\n\n\t\tkeyboardGroup = findViewById(R.id.keyboard_group);\n\n\t\tkeyboardAlwaysVisible = prefs.getBoolean(PreferenceConstants.KEY_ALWAYS_VISIBLE, false);\n\t\tif (keyboardAlwaysVisible) {\n\t\t\t// equivalent to android:layout_above=keyboard_group\n\t\t\tRelativeLayout.LayoutParams layoutParams = new RelativeLayout.LayoutParams(\n\t\t\t\t\tViewGroup.LayoutParams.MATCH_PARENT,\n\t\t\t\t\tViewGroup.LayoutParams.MATCH_PARENT);\n\t\t\tlayoutParams.addRule(RelativeLayout.ABOVE, R.id.keyboard_group);\n\t\t\tpager.setLayoutParams(layoutParams);\n\n\t\t\tlayoutParams = new RelativeLayout.LayoutParams(\n\t\t\t\t\tViewGroup.LayoutParams.MATCH_PARENT,\n\t\t\t\t\tViewGroup.LayoutParams.WRAP_CONTENT);\n\t\t\tlayoutParams.addRule(RelativeLayout.ABOVE, R.id.keyboard_group);\n\t\t\tfindViewById(R.id.console_password_group).setLayoutParams(layoutParams);\n\t\t\tfindViewById(R.id.console_boolean_group).setLayoutParams(layoutParams);\n\n\t\t\t// Show virtual keyboard\n\t\t\tkeyboardGroup.setVisibility(View.VISIBLE);\n\t\t}\n\n\t\tmKeyboardButton = findViewById(R.id.button_keyboard);\n\t\tmKeyboardButton.setOnClickListener(new OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View view) {\n\t\t\t\tView terminal = adapter.getCurrentTerminalView();\n\t\t\t\tif (terminal == null)\n\t\t\t\t\treturn;\n\t\t\t\tInputMethodManager inputMethodManager =\n\t\t\t\t\t(InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);\n\t\t\t\tinputMethodManager.toggleSoftInputFromWindow(terminal.getApplicationWindowToken(),\n\t\t\t\t\tInputMethodManager.SHOW_FORCED, 0);\n\t\t\t\tterminal.requestFocus();\n\t\t\t\thideEmulatedKeys();\n\t\t\t}\n\t\t});\n\n\t\tfindViewById(R.id.button_ctrl).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_esc).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_tab).setOnClickListener(emulatedKeysListener);\n\n\t\taddKeyRepeater(findViewById(R.id.button_up));\n\t\taddKeyRepeater(findViewById(R.id.button_up));\n\t\taddKeyRepeater(findViewById(R.id.button_down));\n\t\taddKeyRepeater(findViewById(R.id.button_left));\n\t\taddKeyRepeater(findViewById(R.id.button_right));\n\n\t\tfindViewById(R.id.button_home).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_end).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_pgup).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_pgdn).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f1).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f2).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f3).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f4).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f5).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f6).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f7).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f8).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f9).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f10).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f11).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f12).setOnClickListener(emulatedKeysListener);\n\n\n\t\tactionBar = getSupportActionBar();\n\t\tif (actionBar != null) {\n\t\t\tactionBar.setDisplayHomeAsUpEnabled(true);\n\t\t\tif (titleBarHide) {\n\t\t\t\tactionBar.hide();\n\t\t\t}\n\t\t\tactionBar.addOnMenuVisibilityListener(new ActionBar.OnMenuVisibilityListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void onMenuVisibilityChanged(boolean isVisible) {\n\t\t\t\t\tinActionBarMenu = isVisible;\n\t\t\t\t\tif (!isVisible) {\n\t\t\t\t\t\thideEmulatedKeys();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tfinal HorizontalScrollView keyboardScroll = findViewById(R.id.keyboard_hscroll);\n\t\tif (!hardKeyboard) {\n\t\t\t// Show virtual keyboard and scroll back and forth\n\t\t\tshowEmulatedKeys(false);\n\t\t\tkeyboardScroll.postDelayed(new Runnable() {\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\tfinal int xscroll = findViewById(R.id.button_f12).getRight();\n\t\t\t\t\tif (BuildConfig.DEBUG) {\n\t\t\t\t\t\tLog.d(TAG, \"smoothScrollBy(toEnd[\" + xscroll + \"])\");\n\t\t\t\t\t}\n\t\t\t\t\tkeyboardScroll.smoothScrollBy(xscroll, 0);\n\t\t\t\t\tkeyboardScroll.postDelayed(new Runnable() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\tif (BuildConfig.DEBUG) {\n\t\t\t\t\t\t\t\tLog.d(TAG, \"smoothScrollBy(toStart[\" + -xscroll + \"])\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tkeyboardScroll.smoothScrollBy(-xscroll, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, 500);\n\t\t\t\t}\n\t\t\t}, 500);\n\t\t}\n\n\t\t// Reset keyboard auto-hide timer when scrolling\n\t\tkeyboardScroll.setOnTouchListener(\n\t\t\t\tnew OnTouchListener() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean onTouch(View v, MotionEvent event) {\n\t\t\t\t\t\tswitch (event.getAction()) {\n\t\t\t\t\t\tcase MotionEvent.ACTION_MOVE:\n\t\t\t\t\t\t\tautoHideEmulatedKeys();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase MotionEvent.ACTION_UP:\n\t\t\t\t\t\t\tv.performClick();\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\ttabs = findViewById(R.id.tabs);\n\t\tif (tabs != null)\n\t\t\tsetupTabLayoutWithViewPager();\n\n\t\tpager.setOnClickListener(new OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tshowEmulatedKeys(true);\n\t\t\t}\n\t\t});\n\n\t\t// Change keyboard button image according to soft keyboard visibility\n\t\t// How to detect keyboard visibility: http://stackoverflow.com/q/4745988\n\t\tcontentView = findViewById(android.R.id.content);\n\t\tcontentView.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void onGlobalLayout() {\n\t\t\t\t\tRect r = new Rect();\n\t\t\t\t\tcontentView.getWindowVisibleDisplayFrame(r);\n\t\t\t\t\tint screenHeight = contentView.getRootView().getHeight();\n\t\t\t\t\tint keypadHeight = screenHeight - r.bottom;\n\n\t\t\t\t\tif (keypadHeight > screenHeight * 0.15) {\n\t\t\t\t\t\t// keyboard is opened\n\t\t\t\t\t\tmKeyboardButton.setImageResource(R.drawable.ic_keyboard_hide);\n\t\t\t\t\t\tmKeyboardButton.setContentDescription(getResources().getText(R.string.image_description_hide_keyboard));\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// keyboard is closed\n\t\t\t\t\t\tmKeyboardButton.setImageResource(R.drawable.ic_keyboard);\n\t\t\t\t\t\tmKeyboardButton.setContentDescription(getResources().getText(R.string.image_description_show_keyboard));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t}\n\n\tprivate void addKeyRepeater(View view) {\n\t\tKeyRepeater keyRepeater = new KeyRepeater(keyRepeatHandler, view);\n\t\tview.setOnClickListener(keyRepeater);\n\t\tview.setOnTouchListener(keyRepeater);\n\t}\n\n\t/**\n\t * Ties the {@link TabLayout} to the {@link TerminalViewPager}.\n\t *\n\t * <p>This method will:\n\t * <ul>\n\t *     <li>Add a {@link TerminalViewPager.OnPageChangeListener} that will forward events to\n\t *     this TabLayout.<\/li>\n\t *     <li>Populate the TabLayout's tabs from the ViewPager's {@link PagerAdapter}.<\/li>\n\t *     <li>Set our {@link TabLayout.OnTabSelectedListener} which will forward\n\t *     selected events to the ViewPager<\/li>\n\t * <\/ul>\n\t * <\/p>\n\t */\n\tpublic void setupTabLayoutWithViewPager() {\n\t\ttabs.setTabsFromPagerAdapter(adapter);\n\t\tpager.addOnPageChangeListener(new TabLayout.TabLayoutOnPageChangeListener(tabs));\n\t\ttabs.setOnTabSelectedListener(new TabLayout.ViewPagerOnTabSelectedListener(pager));\n\n\t\tif (adapter.getCount() > 0) {\n\t\t\tfinal int curItem = pager.getCurrentItem();\n\t\t\tif (tabs.getSelectedTabPosition() != curItem) {\n\t\t\t\ttabs.getTabAt(curItem).select();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t *\n\t */\n\tprivate void configureOrientation() {\n\t\tString rotateDefault;\n\t\tif (getResources().getConfiguration().keyboard == Configuration.KEYBOARD_NOKEYS)\n\t\t\trotateDefault = PreferenceConstants.ROTATION_PORTRAIT;\n\t\telse\n\t\t\trotateDefault = PreferenceConstants.ROTATION_LANDSCAPE;\n\n\t\tString rotate = prefs.getString(PreferenceConstants.ROTATION, rotateDefault);\n\t\tif (PreferenceConstants.ROTATION_DEFAULT.equals(rotate))\n\t\t\trotate = rotateDefault;\n\n\t\t// request a forced orientation if requested by user\n\t\tif (PreferenceConstants.ROTATION_LANDSCAPE.equals(rotate)) {\n\t\t\tsetRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);\n\t\t\tforcedOrientation = true;\n\t\t} else if (PreferenceConstants.ROTATION_PORTRAIT.equals(rotate)) {\n\t\t\tsetRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);\n\t\t\tforcedOrientation = true;\n\t\t} else {\n\t\t\tsetRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);\n\t\t\tforcedOrientation = false;\n\t\t}\n\t}\n\n\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu) {\n\t\tsuper.onCreateOptionsMenu(menu);\n\n\t\tTerminalView view = adapter.getCurrentTerminalView();\n\t\tfinal boolean activeTerminal = view != null;\n\t\tboolean sessionOpen = false;\n\t\tboolean disconnected = false;\n\t\tboolean canForwardPorts = false;\n\n\t\tif (activeTerminal) {\n\t\t\tTerminalBridge bridge = view.bridge;\n\t\t\tsessionOpen = bridge.isSessionOpen();\n\t\t\tdisconnected = bridge.isDisconnected();\n\t\t\tcanForwardPorts = bridge.canFowardPorts();\n\t\t}\n\n\t\tmenu.setQwertyMode(true);\n\n\t\tdisconnect = menu.add(R.string.list_host_disconnect);\n\t\tif (hardKeyboard)\n\t\t\tdisconnect.setAlphabeticShortcut('w');\n\t\tif (!sessionOpen && disconnected)\n\t\t\tdisconnect.setTitle(R.string.console_menu_close);\n\t\tdisconnect.setEnabled(activeTerminal);\n\t\tdisconnect.setIcon(android.R.drawable.ic_menu_close_clear_cancel);\n\t\tdisconnect.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t@Override\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t// disconnect or close the currently visible session\n\t\t\t\tTerminalView terminalView = adapter.getCurrentTerminalView();\n\t\t\t\tTerminalBridge bridge = terminalView.bridge;\n\n\t\t\t\tbridge.dispatchDisconnect(true);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\tpaste = menu.add(R.string.console_menu_paste);\n\t\tif (hardKeyboard)\n\t\t\tpaste.setAlphabeticShortcut('v');\n\t\tMenuItemCompat.setShowAsAction(paste, MenuItemCompat.SHOW_AS_ACTION_IF_ROOM);\n\t\tpaste.setIcon(R.drawable.ic_action_paste);\n\t\tpaste.setEnabled(activeTerminal);\n\t\tpaste.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t@Override\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tpasteIntoTerminal();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\tportForward = menu.add(R.string.console_menu_portforwards);\n\t\tif (hardKeyboard)\n\t\t\tportForward.setAlphabeticShortcut('f');\n\t\tportForward.setIcon(android.R.drawable.ic_menu_manage);\n\t\tportForward.setEnabled(sessionOpen && canForwardPorts);\n\t\tportForward.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t@Override\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tTerminalView terminalView = adapter.getCurrentTerminalView();\n\t\t\t\tTerminalBridge bridge = terminalView.bridge;\n\n\t\t\t\tIntent intent = new Intent(ConsoleActivity.this, PortForwardListActivity.class);\n\t\t\t\tintent.putExtra(Intent.EXTRA_TITLE, bridge.host.getId());\n\t\t\t\tConsoleActivity.this.startActivityForResult(intent, REQUEST_EDIT);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\turlscan = menu.add(R.string.console_menu_urlscan);\n\t\tif (hardKeyboard)\n\t\t\turlscan.setAlphabeticShortcut('u');\n\t\turlscan.setIcon(android.R.drawable.ic_menu_search);\n\t\turlscan.setEnabled(activeTerminal);\n\t\turlscan.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t@Override\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tfinal TerminalView terminalView = adapter.getCurrentTerminalView();\n\n\t\t\t\tList<String> urls = terminalView.bridge.scanForURLs();\n\n\t\t\t\tDialog urlDialog = new Dialog(ConsoleActivity.this);\n\t\t\t\turlDialog.setTitle(R.string.console_menu_urlscan);\n\n\t\t\t\tListView urlListView = new ListView(ConsoleActivity.this);\n\t\t\t\tURLItemListener urlListener = new URLItemListener(ConsoleActivity.this);\n\t\t\t\turlListView.setOnItemClickListener(urlListener);\n\n\t\t\t\turlListView.setAdapter(new ArrayAdapter<>(ConsoleActivity.this, android.R.layout.simple_list_item_1, urls));\n\t\t\t\turlDialog.setContentView(urlListView);\n\t\t\t\turlDialog.show();\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\tresize = menu.add(R.string.console_menu_resize);\n\t\tif (hardKeyboard)\n\t\t\tresize.setAlphabeticShortcut('s');\n\t\tresize.setIcon(android.R.drawable.ic_menu_crop);\n\t\tresize.setEnabled(sessionOpen);\n\t\tresize.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t@Override\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tfinal TerminalView terminalView = adapter.getCurrentTerminalView();\n\n\t\t\t\t@SuppressLint(\"InflateParams\")  // Dialogs do not have a parent view.\n\t\t\t\tfinal View resizeView = inflater.inflate(R.layout.dia_resize, null, false);\n\t\t\t\tnew androidx.appcompat.app.AlertDialog.Builder(\n\t\t\t\t\t\t\t\tConsoleActivity.this, R.style.AlertDialogTheme)\n\t\t\t\t\t\t.setView(resizeView)\n\t\t\t\t\t\t.setPositiveButton(R.string.button_resize, new DialogInterface.OnClickListener() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\t\t\t\tint width, height;\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\twidth = Integer.parseInt(((EditText) resizeView\n\t\t\t\t\t\t\t\t\t\t\t.findViewById(R.id.width))\n\t\t\t\t\t\t\t\t\t\t\t.getText().toString());\n\t\t\t\t\t\t\t\t\theight = Integer.parseInt(((EditText) resizeView\n\t\t\t\t\t\t\t\t\t\t\t.findViewById(R.id.height))\n\t\t\t\t\t\t\t\t\t\t\t.getText().toString());\n\t\t\t\t\t\t\t\t} catch (NumberFormatException nfe) {\n\t\t\t\t\t\t\t\t\t// TODO change this to a real dialog where we can\n\t\t\t\t\t\t\t\t\t// make the input boxes turn red to indicate an error.\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tterminalView.forceSize(width, height);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}).setNegativeButton(android.R.string.cancel, null).create().show();\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean onPrepareOptionsMenu(Menu menu) {\n\t\tsuper.onPrepareOptionsMenu(menu);\n\n\t\tsetVolumeControlStream(AudioManager.STREAM_NOTIFICATION);\n\n\t\tfinal TerminalView view = adapter.getCurrentTerminalView();\n\t\tboolean activeTerminal = view != null;\n\t\tboolean sessionOpen = false;\n\t\tboolean disconnected = false;\n\t\tboolean canForwardPorts = false;\n\n\t\tif (activeTerminal) {\n\t\t\tTerminalBridge bridge = view.bridge;\n\t\t\tsessionOpen = bridge.isSessionOpen();\n\t\t\tdisconnected = bridge.isDisconnected();\n\t\t\tcanForwardPorts = bridge.canFowardPorts();\n\t\t}\n\n\t\tdisconnect.setEnabled(activeTerminal);\n\t\tif (sessionOpen || !disconnected)\n\t\t\tdisconnect.setTitle(R.string.list_host_disconnect);\n\t\telse\n\t\t\tdisconnect.setTitle(R.string.console_menu_close);\n\n\t\tpaste.setEnabled(activeTerminal);\n\t\tportForward.setEnabled(sessionOpen && canForwardPorts);\n\t\turlscan.setEnabled(activeTerminal);\n\t\tresize.setEnabled(sessionOpen);\n\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tif (item.getItemId() == android.R.id.home) {\n\t\t\tIntent intent = new Intent(this, HostListActivity.class);\n\t\t\tintent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n\t\t\tstartActivity(intent);\n\t\t\treturn true;\n\t\t}\n\t\treturn super.onOptionsItemSelected(item);\n\t}\n\n\t@Override\n\tpublic void onOptionsMenuClosed(Menu menu) {\n\t\tsuper.onOptionsMenuClosed(menu);\n\n\t\tsetVolumeControlStream(AudioManager.STREAM_MUSIC);\n\t}\n\n\t@Override\n\tpublic void onStart() {\n\t\tsuper.onStart();\n\n\t\t// connect with manager service to find all bridges\n\t\t// when connected it will insert all views\n\t\tbindService(new Intent(this, TerminalManager.class), connection, Context.BIND_AUTO_CREATE);\n\t}\n\n\t@Override\n\tpublic void onPause() {\n\t\tsuper.onPause();\n\t\tLog.d(TAG, \"onPause called\");\n\n\t\tif (forcedOrientation && bound != null) {\n\t\t\tbound.setResizeAllowed(false);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void onResume() {\n\t\tsuper.onResume();\n\t\tLog.d(TAG, \"onResume called\");\n\n\t\t// Make sure we don't let the screen fall asleep.\n\t\t// This also keeps the Wi-Fi chipset from disconnecting us.\n\t\tif (prefs.getBoolean(PreferenceConstants.KEEP_ALIVE, true)) {\n\t\t\tgetWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);\n\t\t} else {\n\t\t\tgetWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);\n\t\t}\n\n\t\tconfigureOrientation();\n\n\t\tif (forcedOrientation && bound != null) {\n\t\t\tbound.setResizeAllowed(true);\n\t\t}\n\t}\n\n\t/* (non-Javadoc)\n\t * @see android.app.Activity#onNewIntent(android.content.Intent)\n\t */\n\t@Override\n\tprotected void onNewIntent(Intent intent) {\n\t\tsuper.onNewIntent(intent);\n\n\t\tLog.d(TAG, \"onNewIntent called\");\n\n\t\trequested = intent.getData();\n\n\t\tif (requested == null) {\n\t\t\tLog.e(TAG, \"Got null intent data in onNewIntent()\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (bound == null) {\n\t\t\tLog.e(TAG, \"We're not bound in onNewIntent()\");\n\t\t\treturn;\n\t\t}\n\n\t\tTerminalBridge requestedBridge = bound.getConnectedBridge(requested.getFragment());\n\t\tint requestedIndex = 0;\n\n\t\tsynchronized (pager) {\n\t\t\tif (requestedBridge == null) {\n\t\t\t\t// If we didn't find the requested connection, try opening it\n\n\t\t\t\ttry {\n\t\t\t\t\tLog.d(TAG, String.format(\"We couldnt find an existing bridge with URI=%s (nickname=%s),\" +\n\t\t\t\t\t\t\t\"so creating one now\", requested.toString(), requested.getFragment()));\n\t\t\t\t\tbound.openConnection(requested);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tLog.e(TAG, \"Problem while trying to create new requested bridge from URI\", e);\n\t\t\t\t\t// TODO: We should display an error dialog here.\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tadapter.notifyDataSetChanged();\n\t\t\t\trequestedIndex = adapter.getCount();\n\t\t\t} else {\n\t\t\t\tfinal int flipIndex = bound.getBridges().indexOf(requestedBridge);\n\t\t\t\tif (flipIndex > requestedIndex) {\n\t\t\t\t\trequestedIndex = flipIndex;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsetDisplayedTerminal(requestedIndex);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void onStop() {\n\t\tsuper.onStop();\n\n\t\tunbindService(connection);\n\t}\n\n\t@Override\n\tpublic void onSaveInstanceState(Bundle savedInstanceState) {\n\t\t// Maintain selected host if connected.\n\t\tTerminalView currentTerminalView = adapter.getCurrentTerminalView();\n\t\tif (currentTerminalView != null\n\t\t\t\t&& !currentTerminalView.bridge.isDisconnected()) {\n\t\t\trequested = currentTerminalView.bridge.host.getUri();\n\t\t\tsavedInstanceState.putString(STATE_SELECTED_URI, requested.toString());\n\t\t}\n\n\t\tsuper.onSaveInstanceState(savedInstanceState);\n\t}\n\n\t/**\n\t * Save the currently shown {@link TerminalView} as the default. This is\n\t * saved back down into {@link TerminalManager} where we can read it again\n\t * later.\n\t */\n\tprivate void updateDefault() {\n\t\t// update the current default terminal\n\t\tTerminalView view = adapter.getCurrentTerminalView();\n\t\tif (view == null || bound == null) {\n\t\t\treturn;\n\t\t}\n\t\tbound.defaultBridge = view.bridge;\n\t}\n\n\tprotected void updateEmptyVisible() {\n\t\t// update visibility of empty status message\n\t\tempty.setVisibility((pager.getChildCount() == 0) ? View.VISIBLE : View.GONE);\n\t}\n\n\t/**\n\t * Show any prompts requested by the currently visible {@link TerminalView}.\n\t */\n\tprotected void updatePromptVisible() {\n\t\t// check if our currently-visible terminalbridge is requesting any prompt services\n\t\tTerminalView view = adapter.getCurrentTerminalView();\n\n\t\t// Hide all the prompts in case a prompt request was canceled\n\t\thideAllPrompts();\n\n\t\tif (view == null) {\n\t\t\t// we dont have an active view, so hide any prompts\n\t\t\treturn;\n\t\t}\n\n\t\tPromptHelper prompt = view.bridge.promptHelper;\n\t\tif (String.class.equals(prompt.promptRequested)) {\n\t\t\thideEmulatedKeys();\n\t\t\tstringPromptGroup.setVisibility(View.VISIBLE);\n\n\t\t\tString instructions = prompt.promptInstructions;\n\t\t\tif (instructions != null && instructions.length() > 0) {\n\t\t\t\tstringPromptInstructions.setVisibility(View.VISIBLE);\n\t\t\t\tstringPromptInstructions.setText(instructions);\n\t\t\t} else\n\t\t\t\tstringPromptInstructions.setVisibility(View.GONE);\n\t\t\tstringPrompt.setText(\"\");\n\t\t\tstringPrompt.setHint(prompt.promptHint);\n\t\t\tstringPrompt.requestFocus();\n\n\t\t} else if (Boolean.class.equals(prompt.promptRequested)) {\n\t\t\thideEmulatedKeys();\n\t\t\tbooleanPromptGroup.setVisibility(View.VISIBLE);\n\t\t\tbooleanPrompt.setText(prompt.promptHint);\n\t\t\tbooleanYes.requestFocus();\n\n\t\t} else {\n\t\t\thideAllPrompts();\n\t\t\tview.requestFocus();\n\t\t}\n\t}\n\n\tprivate static class URLItemListener implements OnItemClickListener {\n\t\tprivate final WeakReference<Context> contextRef;\n\n\t\tURLItemListener(Context context) {\n\t\t\tthis.contextRef = new WeakReference<>(context);\n\t\t}\n\n\t\t@Override\n\t\tpublic void onItemClick(AdapterView<?> arg0, View view, int position, long id) {\n\t\t\tContext context = contextRef.get();\n\n\t\t\tif (context == null)\n\t\t\t\treturn;\n\n\t\t\ttry {\n\t\t\t\tTextView urlView = (TextView) view;\n\n\t\t\t\tString url = urlView.getText().toString();\n\t\t\t\tIntent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));\n\t\t\t\tcontext.startActivity(intent);\n\t\t\t} catch (Exception e) {\n\t\t\t\tLog.e(TAG, \"couldn't open URL\", e);\n\t\t\t\t// We should probably tell the user that we couldn't find a handler...\n\t\t\t}\n\t\t}\n\n\t}\n\n\t@Override\n\tpublic void onConfigurationChanged(Configuration newConfig) {\n\t\tsuper.onConfigurationChanged(newConfig);\n\n\t\tLog.d(TAG, String.format(\"onConfigurationChanged; requestedOrientation=%d, newConfig.orientation=%d\", getRequestedOrientation(), newConfig.orientation));\n\t\tif (bound != null) {\n\t\t\tbound.setResizeAllowed(!forcedOrientation ||\n\t\t\t\t\t((newConfig.orientation == Configuration.ORIENTATION_LANDSCAPE ||\n\t\t\t\t\t\t\tgetRequestedOrientation() != ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE) &&\n\t\t\t\t\t\t\t(newConfig.orientation == Configuration.ORIENTATION_PORTRAIT ||\n\t\t\t\t\t\t\t\t\tgetRequestedOrientation() != ActivityInfo.SCREEN_ORIENTATION_PORTRAIT)));\n\n\t\t\tbound.hardKeyboardHidden = (newConfig.hardKeyboardHidden == Configuration.HARDKEYBOARDHIDDEN_YES);\n\n\t\t\tmKeyboardButton.setVisibility(bound.hardKeyboardHidden ? View.VISIBLE : View.GONE);\n\t\t}\n\t}\n\n\t/**\n\t * Called whenever the displayed terminal is changed.\n\t */\n\tprivate void onTerminalChanged() {\n\t\tView terminalNameOverlay = findCurrentView(R.id.terminal_name_overlay);\n\t\tif (terminalNameOverlay != null)\n\t\t\tterminalNameOverlay.startAnimation(fade_out_delayed);\n\t\tupdateDefault();\n\t\tupdatePromptVisible();\n\t\tActivityCompat.invalidateOptionsMenu(ConsoleActivity.this);\n\t}\n\n\t/**\n\t * Displays the child in the ViewPager at the requestedIndex and updates the prompts.\n\t *\n\t * @param requestedIndex the index of the terminal view to display\n\t */\n\tprivate void setDisplayedTerminal(int requestedIndex) {\n\t\tpager.setCurrentItem(requestedIndex);\n\t\t// set activity title\n\t\tsetTitle(adapter.getPageTitle(requestedIndex));\n\t\tonTerminalChanged();\n\t}\n\n\tprivate void pasteIntoTerminal() {\n\t\t// force insert of clipboard text into current console\n\t\tTerminalView terminalView = adapter.getCurrentTerminalView();\n\t\tTerminalBridge bridge = terminalView.bridge;\n\n\t\t// pull string from clipboard and generate all events to force down\n\t\tString clip = \"\";\n\t\tif (clipboard.hasText()) {\n\t\t\tclip = clipboard.getText().toString();\n\t\t}\n\t\tbridge.injectString(clip);\n\t}\n\n\tpublic class TerminalPagerAdapter extends PagerAdapter {\n\t\t@Override\n\t\tpublic int getCount() {\n\t\t\tif (bound != null) {\n\t\t\t\treturn bound.getBridges().size();\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Object instantiateItem(ViewGroup container, int position) {\n\t\t\tif (bound == null || bound.getBridges().size() <= position) {\n\t\t\t\tLog.w(TAG, \"Activity not bound when creating TerminalView.\");\n\t\t\t}\n\t\t\tTerminalBridge bridge = bound.getBridges().get(position);\n\t\t\tbridge.promptHelper.setHandler(promptHandler);\n\n\t\t\t// inflate each terminal view\n\t\t\tRelativeLayout view = (RelativeLayout) inflater.inflate(\n\t\t\t\t\tR.layout.item_terminal, container, false);\n\n\t\t\t// set the terminal name overlay text\n\t\t\tTextView terminalNameOverlay = view.findViewById(R.id.terminal_name_overlay);\n\t\t\tterminalNameOverlay.setText(bridge.host.getNickname());\n\n\t\t\t// and add our terminal view control, using index to place behind overlay\n\t\t\tfinal TerminalView terminal = new TerminalView(container.getContext(), bridge, pager);\n\t\t\tterminal.setId(R.id.terminal_view);\n\t\t\tview.addView(terminal, 0);\n\n\t\t\t// Tag the view with its bridge so it can be retrieved later.\n\t\t\tview.setTag(bridge);\n\n\t\t\tcontainer.addView(view);\n\t\t\tterminalNameOverlay.startAnimation(fade_out_delayed);\n\t\t\treturn view;\n\t\t}\n\n\t\t@Override\n\t\tpublic void destroyItem(ViewGroup container, int position, Object object) {\n\t\t\tfinal View view = (View) object;\n\n\t\t\tcontainer.removeView(view);\n\t\t}\n\n\t\t@Override\n\t\tpublic int getItemPosition(Object object) {\n\t\t\tif (bound == null) {\n\t\t\t\treturn POSITION_NONE;\n\t\t\t}\n\n\t\t\tView view = (View) object;\n\t\t\tTerminalView terminal = view.findViewById(R.id.terminal_view);\n\t\t\tHostBean host = terminal.bridge.host;\n\n\t\t\tint itemIndex = POSITION_NONE;\n\t\t\tint i = 0;\n\t\t\tfor (TerminalBridge bridge : bound.getBridges()) {\n\t\t\t\tif (bridge.host.equals(host)) {\n\t\t\t\t\titemIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t\treturn itemIndex;\n\t\t}\n\n\t\tpublic TerminalBridge getBridgeAtPosition(int position) {\n\t\t\tif (bound == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tArrayList<TerminalBridge> bridges = bound.getBridges();\n\t\t\tif (position < 0 || position >= bridges.size()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn bridges.get(position);\n\t\t}\n\n\t\t@Override\n\t\tpublic void notifyDataSetChanged() {\n\t\t\tsuper.notifyDataSetChanged();\n\t\t\tif (tabs != null) {\n\t\t\t\ttoolbar.setVisibility(this.getCount() > 1 ? View.VISIBLE : View.GONE);\n\t\t\t\ttabs.setTabsFromPagerAdapter(this);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isViewFromObject(View view, Object object) {\n\t\t\treturn view == object;\n\t\t}\n\n\t\t@Override\n\t\tpublic CharSequence getPageTitle(int position) {\n\t\t\tTerminalBridge bridge = getBridgeAtPosition(position);\n\t\t\tif (bridge == null) {\n\t\t\t\treturn \"???\";\n\t\t\t}\n\t\t\treturn bridge.host.getNickname();\n\t\t}\n\n\t\tpublic TerminalView getCurrentTerminalView() {\n\t\t\tView currentView = pager.findViewWithTag(getBridgeAtPosition(pager.getCurrentItem()));\n\t\t\tif (currentView == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn (TerminalView) currentView.findViewById(R.id.terminal_view);\n\t\t}\n\t}\n}\n","lineNo":303}
{"Smelly Sample":"/*\n * ConnectBot: simple, powerful, open-source SSH client for Android\n * Copyright 2015 Kenny Root, Jeffrey Sharkey\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.connectbot;\n\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.ServiceConnection;\nimport android.content.res.TypedArray;\nimport android.os.AsyncTask;\nimport android.os.IBinder;\nimport androidx.fragment.app.FragmentManager;\nimport androidx.appcompat.app.AppCompatActivity;\nimport android.os.Bundle;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\n\nimport org.connectbot.bean.HostBean;\nimport org.connectbot.service.TerminalBridge;\nimport org.connectbot.service.TerminalManager;\nimport org.connectbot.util.HostDatabase;\nimport org.connectbot.util.PubkeyDatabase;\n\npublic class EditHostActivity extends AppCompatActivity implements HostEditorFragment.Listener {\n\n\tprivate static final String EXTRA_EXISTING_HOST_ID = \"org.connectbot.existing_host_id\";\n\tprivate static final long NO_HOST_ID = -1;\n\tprivate static final int ENABLED_ALPHA = 255;\n\tprivate static final int DISABLED_ALPHA = 130;\n\n\tprivate HostDatabase mHostDb;\n\tprivate PubkeyDatabase mPubkeyDb;\n\tprivate ServiceConnection mTerminalConnection;\n\tprivate HostBean mHost;\n\tprivate TerminalBridge mBridge;\n\tprivate boolean mIsCreating;\n\tprivate MenuItem mSaveHostButton;\n\n\tpublic static Intent createIntentForExistingHost(Context context, long existingHostId) {\n\t\tIntent i = new Intent(context, EditHostActivity.class);\n\t\ti.putExtra(EXTRA_EXISTING_HOST_ID, existingHostId);\n\t\treturn i;\n\t}\n\n\tpublic static Intent createIntentForNewHost(Context context) {\n\t\treturn createIntentForExistingHost(context, NO_HOST_ID);\n\t}\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\n\t\tmHostDb = HostDatabase.get(this);\n\t\tmPubkeyDb = PubkeyDatabase.get(this);\n\n\t\tmTerminalConnection = new ServiceConnection() {\n\t\t\t@Override\n\t\t\tpublic void onServiceConnected(ComponentName className, IBinder service) {\n\t\t\t\tTerminalManager bound = ((TerminalManager.TerminalBinder) service).getService();\n\t\t\t\tmBridge = bound.getConnectedBridge(mHost);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void onServiceDisconnected(ComponentName name) {\n\t\t\t\tmBridge = null;\n\t\t\t}\n\t\t};\n\n\t\tlong hostId = getIntent().getLongExtra(EXTRA_EXISTING_HOST_ID, NO_HOST_ID);\n\t\tmIsCreating = hostId == NO_HOST_ID;\n\t\tmHost = mIsCreating ? null : mHostDb.findHostById(hostId);\n\n\t\t// Note that the lists must be explicitly declared as ArrayLists because Bundle only accepts\n\t\t// ArrayLists of Strings.\n\t\tArrayList<String> pubkeyNames = new ArrayList<>();\n\t\tArrayList<String> pubkeyValues = new ArrayList<>();\n\n\t\t// First, add default pubkey names and values (e.g., \"use any\" and \"don't use any\").\n\t\tTypedArray defaultPubkeyNames = getResources().obtainTypedArray(R.array.list_pubkeyids);\n\t\tfor (int i = 0; i < defaultPubkeyNames.length(); i++) {\n\t\t\tpubkeyNames.add(defaultPubkeyNames.getString(i));\n\t\t}\n\t\tTypedArray defaultPubkeyValues = getResources().obtainTypedArray(R.array.list_pubkeyids_value);\n\t\tfor (int i = 0; i < defaultPubkeyValues.length(); i++) {\n\t\t\tpubkeyValues.add(defaultPubkeyValues.getString(i));\n\t\t}\n\n\t\t// Now, add pubkeys which have been added by the user.\n\t\tfor (CharSequence cs : mPubkeyDb.allValues(PubkeyDatabase.FIELD_PUBKEY_NICKNAME)) {\n\t\t\tpubkeyNames.add(cs.toString());\n\t\t}\n\t\tfor (CharSequence cs : mPubkeyDb.allValues(\"_id\")) {\n\t\t\tpubkeyValues.add(cs.toString());\n\t\t}\n\n\t\tsetContentView(R.layout.activity_edit_host);\n\t\tFragmentManager fm = getSupportFragmentManager();\n\t\tHostEditorFragment fragment =\n\t\t\t\t(HostEditorFragment) fm.findFragmentById(R.id.fragment_container);\n\n\t\tif (fragment == null) {\n\t\t\tfragment = HostEditorFragment.newInstance(mHost, pubkeyNames, pubkeyValues);\n\t\t\tgetSupportFragmentManager().beginTransaction()\n\t\t\t\t\t.add(R.id.fragment_container, fragment).commit();\n\t\t}\n\n\t\tdefaultPubkeyNames.recycle();\n\t\tdefaultPubkeyValues.recycle();\n\t}\n\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu) {\n\t\tMenuInflater inflater = getMenuInflater();\n\t\tinflater.inflate(\n\t\t\t\tmIsCreating ? R.menu.edit_host_activity_add_menu : R.menu.edit_host_activity_edit_menu,\n\t\t\t\tmenu);\n\n\t\tmSaveHostButton = menu.getItem(0);\n\n\t\t// If the new host is being created, it can't be added until modifications have been made.\n\t\tsetAddSaveButtonEnabled(!mIsCreating);\n\n\t\treturn super.onCreateOptionsMenu(menu);\n\t}\n\n\t@Override\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tswitch (item.getItemId()) {\n\t\t\tcase R.id.save:\n\t\t\tcase android.R.id.home:\n\t\t\t\tattemptSaveAndExit();\n\t\t\t\treturn true;\n\t\t\tdefault:\n\t\t\t\treturn super.onOptionsItemSelected(item);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void onStart() {\n\t\tsuper.onStart();\n\n\t\tbindService(new Intent(\n\t\t\t\tthis, TerminalManager.class), mTerminalConnection, Context.BIND_AUTO_CREATE);\n\n\t\tfinal HostEditorFragment fragment = (HostEditorFragment) getSupportFragmentManager().\n\t\t\t\tfindFragmentById(R.id.fragment_container);\n\t\tif (CharsetHolder.isInitialized()) {\n\t\t\tfragment.setCharsetData(CharsetHolder.getCharsetData());\n\t\t} else {\n\t\t\t// If CharsetHolder is uninitialized, initialize it in an AsyncTask. This is necessary\n\t\t\t// because Charset must touch the disk, which cannot be performed on the UI thread.\n\t\t\tAsyncTask<Void, Void, Void> charsetTask = new AsyncTask<Void, Void, Void>() {\n\n\t\t\t\t@Override\n\t\t\t\tprotected Void doInBackground(Void... unused) {\n\t\t\t\t\tCharsetHolder.initialize();\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tprotected void onPostExecute(Void unused) {\n\t\t\t\t\tfragment.setCharsetData(CharsetHolder.getCharsetData());\n\t\t\t\t}\n\t\t\t};\n\t\t\tcharsetTask.execute();\n\t\t}\n\t}\n\n\t@Override\n\tpublic void onStop() {\n\t\tsuper.onStop();\n\n\t\tunbindService(mTerminalConnection);\n\t}\n\n\t@Override\n\tpublic void onValidHostConfigured(HostBean host) {\n\t\tmHost = host;\n\t\tif (mSaveHostButton != null)\n\t\t\tsetAddSaveButtonEnabled(true);\n\t}\n\n\t@Override\n\tpublic void onHostInvalidated() {\n\t\tmHost = null;\n\t\tif (mSaveHostButton != null)\n\t\t\tsetAddSaveButtonEnabled(false);\n\t}\n\n\t@Override\n\tpublic void onBackPressed() {\n\t\tattemptSaveAndExit();\n\t}\n\n\t/**\n\t * If the host represents a valid URI, save it and exit; otherwise, pop up a dialog asking\n\t * the user if he/she wants to discard the changes.\n\t */\n\tprivate void attemptSaveAndExit() {\n\t\tif (mHost == null) {\n\t\t\tshowDiscardDialog();\n\t\t\treturn;\n\t\t}\n\n\t\tmHostDb.saveHost(mHost);\n\n\t\tif (mBridge != null) {\n\t\t\t// If the console is already open, apply the new encoding now. If the console\n\t\t\t// was not yet opened, this will be applied automatically when it is opened.\n\t\t\tmBridge.setCharset(mHost.getEncoding());\n\t\t}\n\t\tfinish();\n\t}\n\n\tprivate void showDiscardDialog() {\n\t\tandroidx.appcompat.app.AlertDialog.Builder builder =\n\t\t\t\tnew androidx.appcompat.app.AlertDialog.Builder(this, R.style.AlertDialogTheme);\n\t\tbuilder.setMessage(R.string.discard_host_changes_message)\n\t\t\t\t.setPositiveButton(R.string.discard_host_button, new DialogInterface.OnClickListener() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\t\t// Do not save to the database - just exit.\n\t\t\t\t\t\tfinish();\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.setNegativeButton(R.string.discard_host_cancel_button, new DialogInterface.OnClickListener() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\t\t// Do nothing.\n\t\t\t\t\t}\n\t\t\t\t});\n\t\tbuilder.show();\n\t}\n\n\tprivate void setAddSaveButtonEnabled(boolean enabled) {\n\t\tmSaveHostButton.setEnabled(enabled);\n\t\tmSaveHostButton.getIcon().setAlpha(enabled ? ENABLED_ALPHA : DISABLED_ALPHA);\n\t}\n\n\t// Private static class used to generate a list of available Charsets. Note that this class\n\t// must not be initialized by the UI thread because it blocks on disk access.\n\tprivate static class CharsetHolder {\n\t\tprivate static boolean mInitialized = false;\n\n\t\t// Map from Charset display name to Charset value (i.e., unique ID).\n\t\tprivate static Map<String, String> mData;\n\n\t\tpublic static Map<String, String> getCharsetData() {\n\t\t\tif (mData == null)\n\t\t\t\tinitialize();\n\n\t\t\treturn mData;\n\t\t}\n\n\t\tprivate synchronized static void initialize() {\n\t\t\tif (mInitialized)\n\t\t\t\treturn;\n\n\t\t\tmData = new HashMap<>();\n\t\t\tfor (Map.Entry<String, Charset> entry : Charset.availableCharsets().entrySet()) {\n\t\t\t\tCharset c = entry.getValue();\n\t\t\t\tif (c.canEncode() && c.isRegistered()) {\n\t\t\t\t\tString key = entry.getKey();\n\t\t\t\t\tif (key.startsWith(\"cp\")) {\n\t\t\t\t\t\t// Custom CP437 charset changes.\n\t\t\t\t\t\tmData.put(\"CP437\", \"CP437\");\n\t\t\t\t\t}\n\t\t\t\t\tmData.put(c.displayName(), entry.getKey());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmInitialized = true;\n\t\t}\n\n\t\tpublic static boolean isInitialized() {\n\t\t\treturn mInitialized;\n\t\t}\n\t}\n}\n","Method after Refactoring":"/*\n * ConnectBot: simple, powerful, open-source SSH client for Android\n * Copyright 2015 Kenny Root, Jeffrey Sharkey\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.connectbot;\n\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.ServiceConnection;\nimport android.content.res.TypedArray;\nimport android.os.AsyncTask;\nimport android.os.IBinder;\nimport androidx.fragment.app.FragmentManager;\nimport androidx.appcompat.app.AppCompatActivity;\nimport android.os.Bundle;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\n\nimport org.connectbot.bean.HostBean;\nimport org.connectbot.service.TerminalBridge;\nimport org.connectbot.service.TerminalManager;\nimport org.connectbot.util.HostDatabase;\nimport org.connectbot.util.PubkeyDatabase;\n\npublic class EditHostActivity extends AppCompatActivity implements HostEditorFragment.Listener {\n\n\tprivate static final String EXTRA_EXISTING_HOST_ID = \"org.connectbot.existing_host_id\";\n\tprivate static final long NO_HOST_ID = -1;\n\tprivate static final int ENABLED_ALPHA = 255;\n\tprivate static final int DISABLED_ALPHA = 130;\n\n\tprivate HostDatabase mHostDb;\n\tprivate PubkeyDatabase mPubkeyDb;\n\tprivate ServiceConnection mTerminalConnection;\n\tprivate HostBean mHost;\n\tprivate TerminalBridge mBridge;\n\tprivate boolean mIsCreating;\n\tprivate MenuItem mSaveHostButton;\n\n\tpublic static Intent createIntentForExistingHost(Context context, long existingHostId) {\n\t\tIntent i = new Intent(context, EditHostActivity.class);\n\t\ti.putExtra(EXTRA_EXISTING_HOST_ID, existingHostId);\n\t\treturn i;\n\t}\n\n\tpublic static Intent createIntentForNewHost(Context context) {\n\t\treturn createIntentForExistingHost(context, NO_HOST_ID);\n\t}\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\n\t\tmHostDb = HostDatabase.get(this);\n\t\tmPubkeyDb = PubkeyDatabase.get(this);\n\n\t\tmTerminalConnection = new ServiceConnection() {\n\t\t\t@Override\n\t\t\tpublic void onServiceConnected(ComponentName className, IBinder service) {\n\t\t\t\tTerminalManager bound = ((TerminalManager.TerminalBinder) service).getService();\n\t\t\t\tmBridge = bound.getConnectedBridge(mHost);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void onServiceDisconnected(ComponentName name) {\n\t\t\t\tmBridge = null;\n\t\t\t}\n\t\t};\n\n\t\tlong hostId = getIntent().getLongExtra(EXTRA_EXISTING_HOST_ID, NO_HOST_ID);\n\t\tmIsCreating = hostId == NO_HOST_ID;\n\t\tmHost = mIsCreating ? null : mHostDb.findHostById(hostId);\n\n\t\t// Note that the lists must be explicitly declared as ArrayLists because Bundle only accepts\n\t\t// ArrayLists of Strings.\n\t\tArrayList<String> pubkeyNames = new ArrayList<>();\n\t\tArrayList<String> pubkeyValues = new ArrayList<>();\n\n\t\t// First, add default pubkey names and values (e.g., \"use any\" and \"don't use any\").\n\t\tTypedArray defaultPubkeyNames = getResources().obtainTypedArray(R.array.list_pubkeyids);\n\t\tfor (int i = 0; i < defaultPubkeyNames.length(); i++) {\n\t\t\tpubkeyNames.add(defaultPubkeyNames.getString(i));\n\t\t}\n\t\tTypedArray defaultPubkeyValues = getResources().obtainTypedArray(R.array.list_pubkeyids_value);\n\t\tfor (int i = 0; i < defaultPubkeyValues.length(); i++) {\n\t\t\tpubkeyValues.add(defaultPubkeyValues.getString(i));\n\t\t}\n\n\t\t// Now, add pubkeys which have been added by the user.\n\t\tfor (CharSequence cs : mPubkeyDb.allValues(PubkeyDatabase.FIELD_PUBKEY_NICKNAME)) {\n\t\t\tpubkeyNames.add(cs.toString());\n\t\t}\n\t\tfor (CharSequence cs : mPubkeyDb.allValues(\"_id\")) {\n\t\t\tpubkeyValues.add(cs.toString());\n\t\t}\n\n\t\tsetContentView(R.layout.activity_edit_host);\n\t\tFragmentManager fm = getSupportFragmentManager();\n\t\tHostEditorFragment fragment =\n\t\t\t\t(HostEditorFragment) fm.findFragmentById(R.id.fragment_container);\n\n\t\tif (fragment == null) {\n\t\t\tfragment = HostEditorFragment.newInstance(mHost, pubkeyNames, pubkeyValues);\n\t\t\tgetSupportFragmentManager().beginTransaction()\n\t\t\t\t\t.add(R.id.fragment_container, fragment).commit();\n\t\t}\n\n\t\tdefaultPubkeyNames.recycle();\n\t\tdefaultPubkeyValues.recycle();\n\t}\n\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu) {\n\t\tMenuInflater inflater = getMenuInflater();\n\t\tinflater.inflate(\n\t\t\t\tmIsCreating ? R.menu.edit_host_activity_add_menu : R.menu.edit_host_activity_edit_menu,\n\t\t\t\tmenu);\n\n\t\tmSaveHostButton = menu.getItem(0);\n\n\t\t// If the new host is being created, it can't be added until modifications have been made.\n\t\tsetAddSaveButtonEnabled(!mIsCreating);\n\n\t\treturn super.onCreateOptionsMenu(menu);\n\t}\n\n\t@Override\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tint itemId = item.getItemId();\n\t\tif (itemId == R.id.save || itemId == android.R.id.home) {\n\t\t\tattemptSaveAndExit();\n\t\t\treturn true;\n\t\t}\n\t\treturn super.onOptionsItemSelected(item);\n\t}\n\n\t@Override\n\tpublic void onStart() {\n\t\tsuper.onStart();\n\n\t\tbindService(new Intent(\n\t\t\t\tthis, TerminalManager.class), mTerminalConnection, Context.BIND_AUTO_CREATE);\n\n\t\tfinal HostEditorFragment fragment = (HostEditorFragment) getSupportFragmentManager().\n\t\t\t\tfindFragmentById(R.id.fragment_container);\n\t\tif (CharsetHolder.isInitialized()) {\n\t\t\tfragment.setCharsetData(CharsetHolder.getCharsetData());\n\t\t} else {\n\t\t\t// If CharsetHolder is uninitialized, initialize it in an AsyncTask. This is necessary\n\t\t\t// because Charset must touch the disk, which cannot be performed on the UI thread.\n\t\t\tAsyncTask<Void, Void, Void> charsetTask = new AsyncTask<Void, Void, Void>() {\n\n\t\t\t\t@Override\n\t\t\t\tprotected Void doInBackground(Void... unused) {\n\t\t\t\t\tCharsetHolder.initialize();\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tprotected void onPostExecute(Void unused) {\n\t\t\t\t\tfragment.setCharsetData(CharsetHolder.getCharsetData());\n\t\t\t\t}\n\t\t\t};\n\t\t\tcharsetTask.execute();\n\t\t}\n\t}\n\n\t@Override\n\tpublic void onStop() {\n\t\tsuper.onStop();\n\n\t\tunbindService(mTerminalConnection);\n\t}\n\n\t@Override\n\tpublic void onValidHostConfigured(HostBean host) {\n\t\tmHost = host;\n\t\tif (mSaveHostButton != null)\n\t\t\tsetAddSaveButtonEnabled(true);\n\t}\n\n\t@Override\n\tpublic void onHostInvalidated() {\n\t\tmHost = null;\n\t\tif (mSaveHostButton != null)\n\t\t\tsetAddSaveButtonEnabled(false);\n\t}\n\n\t@Override\n\tpublic void onBackPressed() {\n\t\tattemptSaveAndExit();\n\t}\n\n\t/**\n\t * If the host represents a valid URI, save it and exit; otherwise, pop up a dialog asking\n\t * the user if he/she wants to discard the changes.\n\t */\n\tprivate void attemptSaveAndExit() {\n\t\tif (mHost == null) {\n\t\t\tshowDiscardDialog();\n\t\t\treturn;\n\t\t}\n\n\t\tmHostDb.saveHost(mHost);\n\n\t\tif (mBridge != null) {\n\t\t\t// If the console is already open, apply the new encoding now. If the console\n\t\t\t// was not yet opened, this will be applied automatically when it is opened.\n\t\t\tmBridge.setCharset(mHost.getEncoding());\n\t\t}\n\t\tfinish();\n\t}\n\n\tprivate void showDiscardDialog() {\n\t\tandroidx.appcompat.app.AlertDialog.Builder builder =\n\t\t\t\tnew androidx.appcompat.app.AlertDialog.Builder(this, R.style.AlertDialogTheme);\n\t\tbuilder.setMessage(R.string.discard_host_changes_message)\n\t\t\t\t.setPositiveButton(R.string.discard_host_button, new DialogInterface.OnClickListener() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\t\t// Do not save to the database - just exit.\n\t\t\t\t\t\tfinish();\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.setNegativeButton(R.string.discard_host_cancel_button, new DialogInterface.OnClickListener() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\t\t// Do nothing.\n\t\t\t\t\t}\n\t\t\t\t});\n\t\tbuilder.show();\n\t}\n\n\tprivate void setAddSaveButtonEnabled(boolean enabled) {\n\t\tmSaveHostButton.setEnabled(enabled);\n\t\tmSaveHostButton.getIcon().setAlpha(enabled ? ENABLED_ALPHA : DISABLED_ALPHA);\n\t}\n\n\t// Private static class used to generate a list of available Charsets. Note that this class\n\t// must not be initialized by the UI thread because it blocks on disk access.\n\tprivate static class CharsetHolder {\n\t\tprivate static boolean mInitialized = false;\n\n\t\t// Map from Charset display name to Charset value (i.e., unique ID).\n\t\tprivate static Map<String, String> mData;\n\n\t\tpublic static Map<String, String> getCharsetData() {\n\t\t\tif (mData == null)\n\t\t\t\tinitialize();\n\n\t\t\treturn mData;\n\t\t}\n\n\t\tprivate synchronized static void initialize() {\n\t\t\tif (mInitialized)\n\t\t\t\treturn;\n\n\t\t\tmData = new HashMap<>();\n\t\t\tfor (Map.Entry<String, Charset> entry : Charset.availableCharsets().entrySet()) {\n\t\t\t\tCharset c = entry.getValue();\n\t\t\t\tif (c.canEncode() && c.isRegistered()) {\n\t\t\t\t\tString key = entry.getKey();\n\t\t\t\t\tif (key.startsWith(\"cp\")) {\n\t\t\t\t\t\t// Custom CP437 charset changes.\n\t\t\t\t\t\tmData.put(\"CP437\", \"CP437\");\n\t\t\t\t\t}\n\t\t\t\t\tmData.put(c.displayName(), entry.getKey());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmInitialized = true;\n\t\t}\n\n\t\tpublic static boolean isInitialized() {\n\t\t\treturn mInitialized;\n\t\t}\n\t}\n}\n","lineNo":150}
{"Smelly Sample":"/*\n * ConnectBot: simple, powerful, open-source SSH client for Android\n * Copyright 2007 Kenny Root, Jeffrey Sharkey\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.connectbot;\n\nimport java.io.BufferedReader;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.security.KeyPair;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.EventListener;\nimport java.util.List;\n\nimport org.connectbot.bean.PubkeyBean;\nimport org.connectbot.service.TerminalManager;\nimport org.connectbot.util.PubkeyDatabase;\nimport org.connectbot.util.PubkeyUtils;\nimport org.openintents.intents.FileManagerIntents;\n\nimport com.trilead.ssh2.crypto.Base64;\nimport com.trilead.ssh2.crypto.PEMDecoder;\nimport com.trilead.ssh2.crypto.PEMStructure;\n\nimport android.annotation.TargetApi;\nimport android.content.ActivityNotFoundException;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.DialogInterface.OnClickListener;\nimport android.content.Intent;\nimport android.content.ServiceConnection;\nimport android.net.Uri;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Environment;\nimport android.os.IBinder;\nimport androidx.annotation.VisibleForTesting;\nimport androidx.recyclerview.widget.LinearLayoutManager;\nimport android.text.ClipboardManager;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.LayoutInflater;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.MenuItem.OnMenuItemClickListener;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.EditText;\nimport android.widget.ImageView;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\n/**\n * List public keys in database by nickname and describe their properties. Allow users to import,\n * generate, rename, and delete key pairs.\n *\n * @author Kenny Root\n */\npublic class PubkeyListActivity extends AppCompatListActivity implements EventListener {\n\tpublic final static String TAG = \"CB.PubkeyListActivity\";\n\n\tprivate static final int MAX_KEYFILE_SIZE = 32768;\n\tprivate static final int REQUEST_CODE_PICK_FILE = 1;\n\n\t// Constants for AndExplorer's file picking intent\n\tprivate static final String ANDEXPLORER_TITLE = \"explorer_title\";\n\tprivate static final String MIME_TYPE_ANDEXPLORER_FILE = \"vnd.android.cursor.dir/lysesoft.andexplorer.file\";\n\n\tprotected ClipboardManager clipboard;\n\n\tprivate TerminalManager bound = null;\n\n\tprivate ServiceConnection connection = new ServiceConnection() {\n\t\t@Override\n\t\tpublic void onServiceConnected(ComponentName className, IBinder service) {\n\t\t\tbound = ((TerminalManager.TerminalBinder) service).getService();\n\n\t\t\t// update our listview binder to find the service\n\t\t\tupdateList();\n\t\t}\n\n\t\t@Override\n\t\tpublic void onServiceDisconnected(ComponentName className) {\n\t\t\tbound = null;\n\t\t\tupdateList();\n\t\t}\n\t};\n\n\t@Override\n\tpublic void onStart() {\n\t\tsuper.onStart();\n\n\t\tbindService(new Intent(this, TerminalManager.class), connection, Context.BIND_AUTO_CREATE);\n\n\t\tupdateList();\n\t}\n\n\t@Override\n\tpublic void onStop() {\n\t\tsuper.onStop();\n\n\t\tunbindService(connection);\n\t}\n\n\t@Override\n\tpublic void onCreate(Bundle icicle) {\n\t\tsuper.onCreate(icicle);\n\t\tsetContentView(R.layout.act_pubkeylist);\n\n\t\tmListView = findViewById(R.id.list);\n\t\tmListView.setHasFixedSize(true);\n\t\tmListView.setLayoutManager(new LinearLayoutManager(this));\n\t\tmListView.addItemDecoration(new ListItemDecoration(this));\n\n\t\tmEmptyView = findViewById(R.id.empty);\n\n\t\tregisterForContextMenu(mListView);\n\n\t\tclipboard = (ClipboardManager) getSystemService(CLIPBOARD_SERVICE);\n\t}\n\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu) {\n\t\tMenuInflater inflater = getMenuInflater();\n\t\tinflater.inflate(R.menu.pubkey_list_activity_menu, menu);\n\t\treturn super.onCreateOptionsMenu(menu);\n\t}\n\n\t@Override\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tswitch (item.getItemId()) {\n\t\tcase R.id.add_new_key_icon:\n\t\t\tstartActivity(new Intent(this, GeneratePubkeyActivity.class));\n\t\t\treturn true;\n\t\tcase R.id.import_existing_key_icon:\n\t\t\timportExistingKey();\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn super.onOptionsItemSelected(item);\n\t\t}\n\t}\n\n\tprivate boolean importExistingKey() {\n\t\tUri sdcard = Uri.fromFile(Environment.getExternalStorageDirectory());\n\t\tString pickerTitle = getString(R.string.pubkey_list_pick);\n\n\t\tif (Build.VERSION.SDK_INT >= 19 && importExistingKeyKitKat()) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn importExistingKeyOpenIntents(sdcard, pickerTitle)\n\t\t\t\t\t|| importExistingKeyAndExplorer(sdcard, pickerTitle) || pickFileSimple();\n\t\t}\n\t}\n\n\t/**\n\t * Fires an intent to spin up the \"file chooser\" UI and select a private key.\n\t */\n\t@TargetApi(19)\n\tpublic boolean importExistingKeyKitKat() {\n\t\t// ACTION_OPEN_DOCUMENT is the intent to choose a file via the system's file\n\t\t// browser.\n\t\tIntent intent = new Intent(Intent.ACTION_OPEN_DOCUMENT);\n\n\t\t// Filter to only show results that can be \"opened\", such as a\n\t\t// file (as opposed to a list of contacts or timezones)\n\t\tintent.addCategory(Intent.CATEGORY_OPENABLE);\n\n\t\t// PKCS#8 MIME types aren't widely supported, so we'll try */* fro now.\n\t\tintent.setType(\"*/*\");\n\n\t\ttry {\n\t\t\tstartActivityForResult(intent, REQUEST_CODE_PICK_FILE);\n\t\t\treturn true;\n\t\t} catch (ActivityNotFoundException e) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Imports an existing key using the OpenIntents-style request.\n\t */\n\tprivate boolean importExistingKeyOpenIntents(Uri sdcard, String pickerTitle) {\n\t\t// Try to use OpenIntent's file browser to pick a file\n\t\tIntent intent = new Intent(FileManagerIntents.ACTION_PICK_FILE);\n\t\tintent.setData(sdcard);\n\t\tintent.putExtra(FileManagerIntents.EXTRA_TITLE, pickerTitle);\n\t\tintent.putExtra(FileManagerIntents.EXTRA_BUTTON_TEXT, getString(android.R.string.ok));\n\n\t\ttry {\n\t\t\tstartActivityForResult(intent, REQUEST_CODE_PICK_FILE);\n\t\t\treturn true;\n\t\t} catch (ActivityNotFoundException e) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate boolean importExistingKeyAndExplorer(Uri sdcard, String pickerTitle) {\n\t\tIntent intent;\n\t\tintent = new Intent(Intent.ACTION_PICK);\n\t\tintent.setDataAndType(sdcard, MIME_TYPE_ANDEXPLORER_FILE);\n\t\tintent.putExtra(ANDEXPLORER_TITLE, pickerTitle);\n\n\t\ttry {\n\t\t\tstartActivityForResult(intent, REQUEST_CODE_PICK_FILE);\n\t\t\treturn true;\n\t\t} catch (ActivityNotFoundException e) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Builds a simple list of files to pick from.\n\t */\n\tprivate boolean pickFileSimple() {\n\t\t// build list of all files in sdcard root\n\t\tfinal File sdcard = Environment.getExternalStorageDirectory();\n\t\tLog.d(TAG, sdcard.toString());\n\n\t\t// Don't show a dialog if the SD card is completely absent.\n\t\tfinal String state = Environment.getExternalStorageState();\n\t\tif (!Environment.MEDIA_MOUNTED_READ_ONLY.equals(state)\n\t\t\t\t&& !Environment.MEDIA_MOUNTED.equals(state)) {\n\t\t\tnew androidx.appcompat.app.AlertDialog.Builder(\n\t\t\t\t\tPubkeyListActivity.this, R.style.AlertDialogTheme)\n\t\t\t\t\t.setMessage(R.string.alert_sdcard_absent)\n\t\t\t\t\t.setNegativeButton(android.R.string.cancel, null).create().show();\n\t\t\treturn true;\n\t\t}\n\n\t\tList<String> names = new ArrayList<>();\n\t\t{\n\t\t\tFile[] files = sdcard.listFiles();\n\t\t\tif (files != null) {\n\t\t\t\tfor (File file : sdcard.listFiles()) {\n\t\t\t\t\tif (file.isDirectory()) continue;\n\t\t\t\t\tnames.add(file.getName());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tCollections.sort(names);\n\n\t\tfinal String[] namesList = names.toArray(new String[] {});\n\t\tLog.d(TAG, names.toString());\n\n\t\t// prompt user to select any file from the sdcard root\n\t\tnew androidx.appcompat.app.AlertDialog.Builder(\n\t\t\t\tPubkeyListActivity.this, R.style.AlertDialogTheme)\n\t\t\t\t.setTitle(R.string.pubkey_list_pick)\n\t\t\t\t.setItems(namesList, new OnClickListener() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onClick(DialogInterface arg0, int arg1) {\n\t\t\t\t\t\tString name = namesList[arg1];\n\n\t\t\t\t\t\treadKeyFromFile(Uri.fromFile(new File(sdcard, name)));\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.setNegativeButton(android.R.string.cancel, null).create().show();\n\n\t\treturn true;\n\t}\n\n\tprotected void handleAddKey(final PubkeyBean pubkey) {\n\t\tif (pubkey.isEncrypted()) {\n\t\t\tfinal View view = View.inflate(this, R.layout.dia_password, null);\n\t\t\tfinal EditText passwordField = view.findViewById(android.R.id.text1);\n\n\t\t\tnew androidx.appcompat.app.AlertDialog.Builder(\n\t\t\t\t\tPubkeyListActivity.this, R.style.AlertDialogTheme)\n\t\t\t\t.setView(view)\n\t\t\t\t.setPositiveButton(R.string.pubkey_unlock, new DialogInterface.OnClickListener() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\t\thandleAddKey(pubkey, passwordField.getText().toString());\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.setNegativeButton(android.R.string.cancel, null).create().show();\n\t\t} else {\n\t\t\thandleAddKey(pubkey, null);\n\t\t}\n\t}\n\n\tprotected void handleAddKey(PubkeyBean keybean, String password) {\n\t\tKeyPair pair = null;\n\t\ttry {\n\t\t\tpair = PubkeyUtils.convertToKeyPair(keybean, password);\n\t\t} catch (PubkeyUtils.BadPasswordException e) {\n\t\t\tString message = getResources().getString(R.string.pubkey_failed_add, keybean.getNickname());\n\t\t\tToast.makeText(PubkeyListActivity.this, message, Toast.LENGTH_LONG).show();\n\t\t}\n\n\t\tif (pair == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tLog.d(TAG, String.format(\"Unlocked key '%s'\", keybean.getNickname()));\n\n\t\t// save this key in memory\n\t\tbound.addKey(keybean, pair, true);\n\n\t\tupdateList();\n\t}\n\n\tprotected void updateList() {\n\t\tPubkeyDatabase pubkeyDb = PubkeyDatabase.get(PubkeyListActivity.this);\n\n\t\tmAdapter = new PubkeyAdapter(this, pubkeyDb.allPubkeys());\n\t\tmListView.setAdapter(mAdapter);\n\t\tadjustViewVisibility();\n\t}\n\n\t@Override\n\tprotected void onActivityResult(int requestCode, int resultCode, Intent resultData) {\n\t\tsuper.onActivityResult(requestCode, resultCode, resultData);\n\n\t\tswitch (requestCode) {\n\t\tcase REQUEST_CODE_PICK_FILE:\n\t\t\tif (resultCode == RESULT_OK && resultData != null) {\n\t\t\t\tUri uri = resultData.getData();\n\t\t\t\ttry {\n\t\t\t\t\tif (uri != null) {\n\t\t\t\t\t\treadKeyFromFile(uri);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tString filename = resultData.getDataString();\n\t\t\t\t\t\tif (filename != null) {\n\t\t\t\t\t\t\treadKeyFromFile(Uri.parse(filename));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\t\tLog.e(TAG, \"Couldn't read from picked file\", e);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tpublic static byte[] getBytesFromInputStream(InputStream is, int maxSize) throws IOException {\n\t\tByteArrayOutputStream os = new ByteArrayOutputStream();\n\t\tbyte[] buffer = new byte[0xFFFF];\n\n\t\tfor (int len; (len = is.read(buffer)) != -1 && os.size() < maxSize; ) {\n\t\t\tos.write(buffer, 0, len);\n\t\t}\n\n\t\tif (os.size() >= maxSize) {\n\t\t\tthrow new IOException(\"File was too big\");\n\t\t}\n\n\t\tos.flush();\n\t\treturn os.toByteArray();\n\t}\n\n\tprivate KeyPair readPKCS8Key(byte[] keyData) {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(new ByteArrayInputStream(keyData)));\n\n\t\t// parse the actual key once to check if its encrypted\n\t\t// then save original file contents into our database\n\t\ttry {\n\t\t\tByteArrayOutputStream keyBytes = new ByteArrayOutputStream();\n\n\t\t\tString line;\n\t\t\tboolean inKey = false;\n\t\t\twhile ((line = reader.readLine()) != null) {\n\t\t\t\tif (line.equals(PubkeyUtils.PKCS8_START)) {\n\t\t\t\t\tinKey = true;\n\t\t\t\t} else if (line.equals(PubkeyUtils.PKCS8_END)) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (inKey) {\n\t\t\t\t\tkeyBytes.write(line.getBytes(\"US-ASCII\"));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (keyBytes.size() > 0) {\n\t\t\t\tbyte[] decoded = Base64.decode(keyBytes.toString().toCharArray());\n\n\t\t\t\treturn PubkeyUtils.recoverKeyPair(decoded);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\treturn null;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * @param uri URI to private key to read.\n\t */\n\tprivate void readKeyFromFile(Uri uri) {\n\t\tPubkeyBean pubkey = new PubkeyBean();\n\n\t\t// find the exact file selected\n\t\tpubkey.setNickname(uri.getLastPathSegment());\n\n\t\tbyte[] keyData;\n\t\ttry {\n\t\t\tContentResolver resolver = getContentResolver();\n\t\t\tkeyData = getBytesFromInputStream(resolver.openInputStream(uri), MAX_KEYFILE_SIZE);\n\t\t} catch (IOException e) {\n\t\t\tToast.makeText(PubkeyListActivity.this,\n\t\t\t\t\tR.string.pubkey_import_parse_problem,\n\t\t\t\t\tToast.LENGTH_LONG).show();\n\t\t\treturn;\n\t\t}\n\n\t\tKeyPair kp;\n\t\tif ((kp = readPKCS8Key(keyData)) != null) {\n\t\t\tString algorithm = convertAlgorithmName(kp.getPrivate().getAlgorithm());\n\t\t\tpubkey.setType(algorithm);\n\t\t\tpubkey.setPrivateKey(kp.getPrivate().getEncoded());\n\t\t\tpubkey.setPublicKey(kp.getPublic().getEncoded());\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tPEMStructure struct = PEMDecoder.parsePEM(new String(keyData).toCharArray());\n\t\t\t\tboolean encrypted = PEMDecoder.isPEMEncrypted(struct);\n\t\t\t\tpubkey.setEncrypted(encrypted);\n\t\t\t\tif (!encrypted) {\n\t\t\t\t\tkp = PEMDecoder.decode(struct, null);\n\t\t\t\t\tString algorithm = convertAlgorithmName(kp.getPrivate().getAlgorithm());\n\t\t\t\t\tpubkey.setType(algorithm);\n\t\t\t\t\tpubkey.setPrivateKey(kp.getPrivate().getEncoded());\n\t\t\t\t\tpubkey.setPublicKey(kp.getPublic().getEncoded());\n\t\t\t\t} else {\n\t\t\t\t\tpubkey.setType(PubkeyDatabase.KEY_TYPE_IMPORTED);\n\t\t\t\t\tpubkey.setPrivateKey(keyData);\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\tLog.e(TAG, \"Problem parsing imported private key\", e);\n\t\t\t\tToast.makeText(PubkeyListActivity.this, R.string.pubkey_import_parse_problem, Toast.LENGTH_LONG).show();\n\t\t\t}\n\t\t}\n\n\t\t// write new value into database\n\t\tPubkeyDatabase pubkeyDb = PubkeyDatabase.get(this);\n\t\tpubkeyDb.savePubkey(pubkey);\n\n\t\tupdateList();\n\t}\n\n\tprivate String convertAlgorithmName(String algorithm) {\n\t\tif (\"EdDSA\".equals(algorithm)) {\n\t\t\treturn PubkeyDatabase.KEY_TYPE_ED25519;\n\t\t} else {\n\t\t\treturn algorithm;\n\t\t}\n\t}\n\n\tpublic class PubkeyViewHolder extends ItemViewHolder {\n\t\tpublic final ImageView icon;\n\t\tpublic final TextView nickname;\n\t\tpublic final TextView caption;\n\n\t\tpublic PubkeyBean pubkey;\n\n\t\tpublic PubkeyViewHolder(View v) {\n\t\t\tsuper(v);\n\n\t\t\ticon = v.findViewById(android.R.id.icon);\n\t\t\tnickname = v.findViewById(android.R.id.text1);\n\t\t\tcaption = v.findViewById(android.R.id.text2);\n\t\t}\n\n\t\t@Override\n\t\tpublic void onClick(View v) {\n\t\t\tboolean loaded = bound != null && bound.isKeyLoaded(pubkey.getNickname());\n\n\t\t\t// handle toggling key in-memory on/off\n\t\t\tif (loaded) {\n\t\t\t\tbound.removeKey(pubkey.getNickname());\n\t\t\t\tupdateList();\n\t\t\t} else {\n\t\t\t\thandleAddKey(pubkey);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void onCreateContextMenu(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo) {\n\t\t\t// Create menu to handle deleting and editing pubkey\n\t\t\tmenu.setHeaderTitle(pubkey.getNickname());\n\n\t\t\t// TODO: option load/unload key from in-memory list\n\t\t\t// prompt for password as needed for passworded keys\n\n\t\t\t// cant change password or clipboard imported keys\n\t\t\tfinal boolean imported = PubkeyDatabase.KEY_TYPE_IMPORTED.equals(pubkey.getType());\n\t\t\tfinal boolean loaded = bound != null && bound.isKeyLoaded(pubkey.getNickname());\n\n\t\t\tMenuItem load = menu.add(loaded ? R.string.pubkey_memory_unload : R.string.pubkey_memory_load);\n\t\t\tload.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\tif (loaded) {\n\t\t\t\t\t\tbound.removeKey(pubkey.getNickname());\n\t\t\t\t\t\tupdateList();\n\t\t\t\t\t} else {\n\t\t\t\t\t\thandleAddKey(pubkey);\n\t\t\t\t\t\t//bound.addKey(nickname, trileadKey);\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tMenuItem onstartToggle = menu.add(R.string.pubkey_load_on_start);\n\t\t\tonstartToggle.setEnabled(!pubkey.isEncrypted());\n\t\t\tonstartToggle.setCheckable(true);\n\t\t\tonstartToggle.setChecked(pubkey.isStartup());\n\t\t\tonstartToggle.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\t// toggle onstart status\n\t\t\t\t\tpubkey.setStartup(!pubkey.isStartup());\n\t\t\t\t\tPubkeyDatabase pubkeyDb = PubkeyDatabase.get(PubkeyListActivity.this);\n\t\t\t\t\tpubkeyDb.savePubkey(pubkey);\n\t\t\t\t\tupdateList();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tMenuItem copyPublicToClipboard = menu.add(R.string.pubkey_copy_public);\n\t\t\tcopyPublicToClipboard.setEnabled(!imported);\n\t\t\tcopyPublicToClipboard.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tPublicKey pk = PubkeyUtils.decodePublic(pubkey.getPublicKey(), pubkey.getType());\n\t\t\t\t\t\tString openSSHPubkey = PubkeyUtils.convertToOpenSSHFormat(pk, pubkey.getNickname());\n\n\t\t\t\t\t\tclipboard.setText(openSSHPubkey);\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\tLog.d(TAG, \"Error converting to OpenSSH format\", e);\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tMenuItem copyPrivateToClipboard = menu.add(R.string.pubkey_copy_private);\n\t\t\tcopyPrivateToClipboard.setEnabled(!pubkey.isEncrypted() || imported);\n\t\t\tcopyPrivateToClipboard.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tString data = null;\n\n\t\t\t\t\t\tif (imported)\n\t\t\t\t\t\t\tdata = new String(pubkey.getPrivateKey());\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tPrivateKey pk = PubkeyUtils.decodePrivate(pubkey.getPrivateKey(), pubkey.getType());\n\t\t\t\t\t\t\tdata = PubkeyUtils.exportPEM(pk, null);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tclipboard.setText(data);\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\tLog.d(TAG, \"Error copying private key\", e);\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tMenuItem changePassword = menu.add(R.string.pubkey_change_password);\n\t\t\tchangePassword.setEnabled(!imported);\n\t\t\tchangePassword.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\tfinal View changePasswordView =\n\t\t\t\t\t\t\tView.inflate(PubkeyListActivity.this, R.layout.dia_changepassword, null);\n\t\t\t\t\tchangePasswordView.findViewById(R.id.old_password_prompt)\n\t\t\t\t\t\t\t.setVisibility(pubkey.isEncrypted() ? View.VISIBLE : View.GONE);\n\t\t\t\t\tnew androidx.appcompat.app.AlertDialog.Builder(\n\t\t\t\t\t\t\t\t\tPubkeyListActivity.this, R.style.AlertDialogTheme)\n\t\t\t\t\t\t\t.setView(changePasswordView)\n\t\t\t\t\t\t\t.setPositiveButton(R.string.button_change, new DialogInterface.OnClickListener() {\n\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\t\t\t\t\tString oldPassword = ((EditText) changePasswordView.findViewById(R.id.old_password)).getText().toString();\n\t\t\t\t\t\t\t\t\tString password1 = ((EditText) changePasswordView.findViewById(R.id.password1)).getText().toString();\n\t\t\t\t\t\t\t\t\tString password2 = ((EditText) changePasswordView.findViewById(R.id.password2)).getText().toString();\n\n\t\t\t\t\t\t\t\t\tif (!password1.equals(password2)) {\n\t\t\t\t\t\t\t\t\t\tnew androidx.appcompat.app.AlertDialog.Builder(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tPubkeyListActivity.this,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tR.style.AlertDialogTheme)\n\t\t\t\t\t\t\t\t\t\t\t\t.setMessage(R.string.alert_passwords_do_not_match_msg)\n\t\t\t\t\t\t\t\t\t\t\t\t.setPositiveButton(android.R.string.ok, null)\n\t\t\t\t\t\t\t\t\t\t\t\t.create().show();\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tif (!pubkey.changePassword(oldPassword, password1))\n\t\t\t\t\t\t\t\t\t\t\tnew androidx.appcompat.app.AlertDialog.Builder(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tPubkeyListActivity.this,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tR.style.AlertDialogTheme)\n\t\t\t\t\t\t\t\t\t\t\t\t\t.setMessage(R.string.alert_wrong_password_msg)\n\t\t\t\t\t\t\t\t\t\t\t\t\t.setPositiveButton(android.R.string.ok, null)\n\t\t\t\t\t\t\t\t\t\t\t\t\t.create().show();\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\tPubkeyDatabase pubkeyDb = PubkeyDatabase.get(PubkeyListActivity.this);\n\t\t\t\t\t\t\t\t\t\t\tpubkeyDb.savePubkey(pubkey);\n\t\t\t\t\t\t\t\t\t\t\tupdateList();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\t\t\t\tLog.e(TAG, \"Could not change private key password\", e);\n\t\t\t\t\t\t\t\t\t\tnew androidx.appcompat.app.AlertDialog.Builder(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tPubkeyListActivity.this,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tR.style.AlertDialogTheme)\n\t\t\t\t\t\t\t\t\t\t\t\t.setMessage(R.string.alert_key_corrupted_msg)\n\t\t\t\t\t\t\t\t\t\t\t\t.setPositiveButton(android.R.string.ok, null)\n\t\t\t\t\t\t\t\t\t\t\t\t.create().show();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t.setNegativeButton(android.R.string.cancel, null).create().show();\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tMenuItem confirmUse = menu.add(R.string.pubkey_confirm_use);\n\t\t\tconfirmUse.setCheckable(true);\n\t\t\tconfirmUse.setChecked(pubkey.isConfirmUse());\n\t\t\tconfirmUse.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\t// toggle confirm use\n\t\t\t\t\tpubkey.setConfirmUse(!pubkey.isConfirmUse());\n\t\t\t\t\tPubkeyDatabase pubkeyDb = PubkeyDatabase.get(PubkeyListActivity.this);\n\t\t\t\t\tpubkeyDb.savePubkey(pubkey);\n\t\t\t\t\tupdateList();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tMenuItem delete = menu.add(R.string.pubkey_delete);\n\t\t\tdelete.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\t// prompt user to make sure they really want this\n\t\t\t\t\tnew androidx.appcompat.app.AlertDialog.Builder(\n\t\t\t\t\t\t\t\t\tPubkeyListActivity.this, R.style.AlertDialogTheme)\n\t\t\t\t\t\t\t.setMessage(getString(R.string.delete_message, pubkey.getNickname()))\n\t\t\t\t\t\t\t.setPositiveButton(R.string.delete_pos, new DialogInterface.OnClickListener() {\n\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\n\t\t\t\t\t\t\t\t\t// dont forget to remove from in-memory\n\t\t\t\t\t\t\t\t\tif (loaded) {\n\t\t\t\t\t\t\t\t\t\tbound.removeKey(pubkey.getNickname());\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// delete from backend database and update gui\n\t\t\t\t\t\t\t\t\tPubkeyDatabase pubkeyDb = PubkeyDatabase.get(PubkeyListActivity.this);\n\t\t\t\t\t\t\t\t\tpubkeyDb.deletePubkey(pubkey);\n\t\t\t\t\t\t\t\t\tupdateList();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t.setNegativeButton(R.string.delete_neg, null).create().show();\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t@VisibleForTesting\n\tprivate class PubkeyAdapter extends ItemAdapter {\n\t\tprivate final List<PubkeyBean> pubkeys;\n\n\t\tpublic PubkeyAdapter(Context context, List<PubkeyBean> pubkeys) {\n\t\t\tsuper(context);\n\t\t\tthis.pubkeys = pubkeys;\n\t\t}\n\n\t\t@Override\n\t\tpublic PubkeyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n\t\t\tView v = LayoutInflater.from(parent.getContext())\n\t\t\t\t\t.inflate(R.layout.item_pubkey, parent, false);\n\t\t\treturn new PubkeyViewHolder(v);\n\t\t}\n\n\t\t@Override\n\t\tpublic void onBindViewHolder(ItemViewHolder holder, int position) {\n\t\t\tPubkeyViewHolder pubkeyHolder = (PubkeyViewHolder) holder;\n\n\t\t\tPubkeyBean pubkey = pubkeys.get(position);\n\t\t\tpubkeyHolder.pubkey = pubkey;\n\t\t\tif (pubkey == null) {\n\t\t\t\t// Well, something bad happened. We can't continue.\n\t\t\t\tLog.e(\"PubkeyAdapter\", \"Pubkey bean is null!\");\n\n\t\t\t\tpubkeyHolder.nickname.setText(\"Error during lookup\");\n\t\t\t} else {\n\t\t\t\tpubkeyHolder.nickname.setText(pubkey.getNickname());\n\t\t\t}\n\n\t\t\tboolean imported = PubkeyDatabase.KEY_TYPE_IMPORTED.equals(pubkey.getType());\n\n\t\t\tif (imported) {\n\t\t\t\ttry {\n\t\t\t\t\tPEMStructure struct = PEMDecoder.parsePEM(new String(pubkey.getPrivateKey()).toCharArray());\n\t\t\t\t\tString type;\n\t\t\t\t\tif (struct.pemType == PEMDecoder.PEM_RSA_PRIVATE_KEY) {\n\t\t\t\t\t\ttype = \"RSA\";\n\t\t\t\t\t} else if (struct.pemType == PEMDecoder.PEM_DSA_PRIVATE_KEY) {\n\t\t\t\t\t\ttype = \"DSA\";\n\t\t\t\t\t} else if (struct.pemType == PEMDecoder.PEM_EC_PRIVATE_KEY) {\n\t\t\t\t\t\ttype = \"EC\";\n\t\t\t\t\t} else if (struct.pemType == PEMDecoder.PEM_OPENSSH_PRIVATE_KEY) {\n\t\t\t\t\t\ttype = \"OpenSSH\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new RuntimeException(\"Unexpected key type: \" + struct.pemType);\n\t\t\t\t\t}\n\t\t\t\t\tpubkeyHolder.caption.setText(String.format(\"%s unknown-bit\", type));\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tLog.e(TAG, \"Error decoding IMPORTED public key at \" + pubkey.getId(), e);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tpubkeyHolder.caption.setText(pubkey.getDescription(getApplicationContext()));\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tLog.e(TAG, \"Error decoding public key at \" + pubkey.getId(), e);\n\t\t\t\t\tpubkeyHolder.caption.setText(R.string.pubkey_unknown_format);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (bound == null) {\n\t\t\t\tpubkeyHolder.icon.setVisibility(View.GONE);\n\t\t\t} else {\n\t\t\t\tpubkeyHolder.icon.setVisibility(View.VISIBLE);\n\n\t\t\t\tif (bound.isKeyLoaded(pubkey.getNickname()))\n\t\t\t\t\tpubkeyHolder.icon.setImageState(new int[] { android.R.attr.state_checked }, true);\n\t\t\t\telse\n\t\t\t\t\tpubkeyHolder.icon.setImageState(new int[] { }, true);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic int getItemCount() {\n\t\t\treturn pubkeys.size();\n\t\t}\n\n\t\t@Override\n\t\tpublic long getItemId(int position) {\n\t\t\treturn pubkeys.get(position).getId();\n\t\t}\n\t}\n}\n","Method after Refactoring":"/*\n * ConnectBot: simple, powerful, open-source SSH client for Android\n * Copyright 2007 Kenny Root, Jeffrey Sharkey\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.connectbot;\n\nimport java.io.BufferedReader;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.security.KeyPair;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.EventListener;\nimport java.util.List;\n\nimport org.connectbot.bean.PubkeyBean;\nimport org.connectbot.service.TerminalManager;\nimport org.connectbot.util.PubkeyDatabase;\nimport org.connectbot.util.PubkeyUtils;\nimport org.openintents.intents.FileManagerIntents;\n\nimport com.trilead.ssh2.crypto.Base64;\nimport com.trilead.ssh2.crypto.PEMDecoder;\nimport com.trilead.ssh2.crypto.PEMStructure;\n\nimport android.annotation.TargetApi;\nimport android.content.ActivityNotFoundException;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.DialogInterface.OnClickListener;\nimport android.content.Intent;\nimport android.content.ServiceConnection;\nimport android.net.Uri;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Environment;\nimport android.os.IBinder;\nimport androidx.annotation.VisibleForTesting;\nimport androidx.recyclerview.widget.LinearLayoutManager;\nimport android.text.ClipboardManager;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.LayoutInflater;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.MenuItem.OnMenuItemClickListener;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.EditText;\nimport android.widget.ImageView;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\n/**\n * List public keys in database by nickname and describe their properties. Allow users to import,\n * generate, rename, and delete key pairs.\n *\n * @author Kenny Root\n */\npublic class PubkeyListActivity extends AppCompatListActivity implements EventListener {\n\tpublic final static String TAG = \"CB.PubkeyListActivity\";\n\n\tprivate static final int MAX_KEYFILE_SIZE = 32768;\n\tprivate static final int REQUEST_CODE_PICK_FILE = 1;\n\n\t// Constants for AndExplorer's file picking intent\n\tprivate static final String ANDEXPLORER_TITLE = \"explorer_title\";\n\tprivate static final String MIME_TYPE_ANDEXPLORER_FILE = \"vnd.android.cursor.dir/lysesoft.andexplorer.file\";\n\n\tprotected ClipboardManager clipboard;\n\n\tprivate TerminalManager bound = null;\n\n\tprivate ServiceConnection connection = new ServiceConnection() {\n\t\t@Override\n\t\tpublic void onServiceConnected(ComponentName className, IBinder service) {\n\t\t\tbound = ((TerminalManager.TerminalBinder) service).getService();\n\n\t\t\t// update our listview binder to find the service\n\t\t\tupdateList();\n\t\t}\n\n\t\t@Override\n\t\tpublic void onServiceDisconnected(ComponentName className) {\n\t\t\tbound = null;\n\t\t\tupdateList();\n\t\t}\n\t};\n\n\t@Override\n\tpublic void onStart() {\n\t\tsuper.onStart();\n\n\t\tbindService(new Intent(this, TerminalManager.class), connection, Context.BIND_AUTO_CREATE);\n\n\t\tupdateList();\n\t}\n\n\t@Override\n\tpublic void onStop() {\n\t\tsuper.onStop();\n\n\t\tunbindService(connection);\n\t}\n\n\t@Override\n\tpublic void onCreate(Bundle icicle) {\n\t\tsuper.onCreate(icicle);\n\t\tsetContentView(R.layout.act_pubkeylist);\n\n\t\tmListView = findViewById(R.id.list);\n\t\tmListView.setHasFixedSize(true);\n\t\tmListView.setLayoutManager(new LinearLayoutManager(this));\n\t\tmListView.addItemDecoration(new ListItemDecoration(this));\n\n\t\tmEmptyView = findViewById(R.id.empty);\n\n\t\tregisterForContextMenu(mListView);\n\n\t\tclipboard = (ClipboardManager) getSystemService(CLIPBOARD_SERVICE);\n\t}\n\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu) {\n\t\tMenuInflater inflater = getMenuInflater();\n\t\tinflater.inflate(R.menu.pubkey_list_activity_menu, menu);\n\t\treturn super.onCreateOptionsMenu(menu);\n\t}\n\n\t@Override\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tint itemId = item.getItemId();\n\t\tif (itemId == R.id.add_new_key_icon) {\n\t\t\tstartActivity(new Intent(this, GeneratePubkeyActivity.class));\n\t\t\treturn true;\n\t\t} else if (itemId == R.id.import_existing_key_icon) {\n\t\t\timportExistingKey();\n\t\t\treturn true;\n\t\t}\n\t\treturn super.onOptionsItemSelected(item);\n\t}\n\n\tprivate boolean importExistingKey() {\n\t\tUri sdcard = Uri.fromFile(Environment.getExternalStorageDirectory());\n\t\tString pickerTitle = getString(R.string.pubkey_list_pick);\n\n\t\tif (Build.VERSION.SDK_INT >= 19 && importExistingKeyKitKat()) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn importExistingKeyOpenIntents(sdcard, pickerTitle)\n\t\t\t\t\t|| importExistingKeyAndExplorer(sdcard, pickerTitle) || pickFileSimple();\n\t\t}\n\t}\n\n\t/**\n\t * Fires an intent to spin up the \"file chooser\" UI and select a private key.\n\t */\n\t@TargetApi(19)\n\tpublic boolean importExistingKeyKitKat() {\n\t\t// ACTION_OPEN_DOCUMENT is the intent to choose a file via the system's file\n\t\t// browser.\n\t\tIntent intent = new Intent(Intent.ACTION_OPEN_DOCUMENT);\n\n\t\t// Filter to only show results that can be \"opened\", such as a\n\t\t// file (as opposed to a list of contacts or timezones)\n\t\tintent.addCategory(Intent.CATEGORY_OPENABLE);\n\n\t\t// PKCS#8 MIME types aren't widely supported, so we'll try */* fro now.\n\t\tintent.setType(\"*/*\");\n\n\t\ttry {\n\t\t\tstartActivityForResult(intent, REQUEST_CODE_PICK_FILE);\n\t\t\treturn true;\n\t\t} catch (ActivityNotFoundException e) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Imports an existing key using the OpenIntents-style request.\n\t */\n\tprivate boolean importExistingKeyOpenIntents(Uri sdcard, String pickerTitle) {\n\t\t// Try to use OpenIntent's file browser to pick a file\n\t\tIntent intent = new Intent(FileManagerIntents.ACTION_PICK_FILE);\n\t\tintent.setData(sdcard);\n\t\tintent.putExtra(FileManagerIntents.EXTRA_TITLE, pickerTitle);\n\t\tintent.putExtra(FileManagerIntents.EXTRA_BUTTON_TEXT, getString(android.R.string.ok));\n\n\t\ttry {\n\t\t\tstartActivityForResult(intent, REQUEST_CODE_PICK_FILE);\n\t\t\treturn true;\n\t\t} catch (ActivityNotFoundException e) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate boolean importExistingKeyAndExplorer(Uri sdcard, String pickerTitle) {\n\t\tIntent intent;\n\t\tintent = new Intent(Intent.ACTION_PICK);\n\t\tintent.setDataAndType(sdcard, MIME_TYPE_ANDEXPLORER_FILE);\n\t\tintent.putExtra(ANDEXPLORER_TITLE, pickerTitle);\n\n\t\ttry {\n\t\t\tstartActivityForResult(intent, REQUEST_CODE_PICK_FILE);\n\t\t\treturn true;\n\t\t} catch (ActivityNotFoundException e) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Builds a simple list of files to pick from.\n\t */\n\tprivate boolean pickFileSimple() {\n\t\t// build list of all files in sdcard root\n\t\tfinal File sdcard = Environment.getExternalStorageDirectory();\n\t\tLog.d(TAG, sdcard.toString());\n\n\t\t// Don't show a dialog if the SD card is completely absent.\n\t\tfinal String state = Environment.getExternalStorageState();\n\t\tif (!Environment.MEDIA_MOUNTED_READ_ONLY.equals(state)\n\t\t\t\t&& !Environment.MEDIA_MOUNTED.equals(state)) {\n\t\t\tnew androidx.appcompat.app.AlertDialog.Builder(\n\t\t\t\t\tPubkeyListActivity.this, R.style.AlertDialogTheme)\n\t\t\t\t\t.setMessage(R.string.alert_sdcard_absent)\n\t\t\t\t\t.setNegativeButton(android.R.string.cancel, null).create().show();\n\t\t\treturn true;\n\t\t}\n\n\t\tList<String> names = new ArrayList<>();\n\t\t{\n\t\t\tFile[] files = sdcard.listFiles();\n\t\t\tif (files != null) {\n\t\t\t\tfor (File file : sdcard.listFiles()) {\n\t\t\t\t\tif (file.isDirectory()) continue;\n\t\t\t\t\tnames.add(file.getName());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tCollections.sort(names);\n\n\t\tfinal String[] namesList = names.toArray(new String[] {});\n\t\tLog.d(TAG, names.toString());\n\n\t\t// prompt user to select any file from the sdcard root\n\t\tnew androidx.appcompat.app.AlertDialog.Builder(\n\t\t\t\tPubkeyListActivity.this, R.style.AlertDialogTheme)\n\t\t\t\t.setTitle(R.string.pubkey_list_pick)\n\t\t\t\t.setItems(namesList, new OnClickListener() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onClick(DialogInterface arg0, int arg1) {\n\t\t\t\t\t\tString name = namesList[arg1];\n\n\t\t\t\t\t\treadKeyFromFile(Uri.fromFile(new File(sdcard, name)));\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.setNegativeButton(android.R.string.cancel, null).create().show();\n\n\t\treturn true;\n\t}\n\n\tprotected void handleAddKey(final PubkeyBean pubkey) {\n\t\tif (pubkey.isEncrypted()) {\n\t\t\tfinal View view = View.inflate(this, R.layout.dia_password, null);\n\t\t\tfinal EditText passwordField = view.findViewById(android.R.id.text1);\n\n\t\t\tnew androidx.appcompat.app.AlertDialog.Builder(\n\t\t\t\t\tPubkeyListActivity.this, R.style.AlertDialogTheme)\n\t\t\t\t.setView(view)\n\t\t\t\t.setPositiveButton(R.string.pubkey_unlock, new DialogInterface.OnClickListener() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\t\thandleAddKey(pubkey, passwordField.getText().toString());\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.setNegativeButton(android.R.string.cancel, null).create().show();\n\t\t} else {\n\t\t\thandleAddKey(pubkey, null);\n\t\t}\n\t}\n\n\tprotected void handleAddKey(PubkeyBean keybean, String password) {\n\t\tKeyPair pair = null;\n\t\ttry {\n\t\t\tpair = PubkeyUtils.convertToKeyPair(keybean, password);\n\t\t} catch (PubkeyUtils.BadPasswordException e) {\n\t\t\tString message = getResources().getString(R.string.pubkey_failed_add, keybean.getNickname());\n\t\t\tToast.makeText(PubkeyListActivity.this, message, Toast.LENGTH_LONG).show();\n\t\t}\n\n\t\tif (pair == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tLog.d(TAG, String.format(\"Unlocked key '%s'\", keybean.getNickname()));\n\n\t\t// save this key in memory\n\t\tbound.addKey(keybean, pair, true);\n\n\t\tupdateList();\n\t}\n\n\tprotected void updateList() {\n\t\tPubkeyDatabase pubkeyDb = PubkeyDatabase.get(PubkeyListActivity.this);\n\n\t\tmAdapter = new PubkeyAdapter(this, pubkeyDb.allPubkeys());\n\t\tmListView.setAdapter(mAdapter);\n\t\tadjustViewVisibility();\n\t}\n\n\t@Override\n\tprotected void onActivityResult(int requestCode, int resultCode, Intent resultData) {\n\t\tsuper.onActivityResult(requestCode, resultCode, resultData);\n\n\t\tswitch (requestCode) {\n\t\tcase REQUEST_CODE_PICK_FILE:\n\t\t\tif (resultCode == RESULT_OK && resultData != null) {\n\t\t\t\tUri uri = resultData.getData();\n\t\t\t\ttry {\n\t\t\t\t\tif (uri != null) {\n\t\t\t\t\t\treadKeyFromFile(uri);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tString filename = resultData.getDataString();\n\t\t\t\t\t\tif (filename != null) {\n\t\t\t\t\t\t\treadKeyFromFile(Uri.parse(filename));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\t\tLog.e(TAG, \"Couldn't read from picked file\", e);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tpublic static byte[] getBytesFromInputStream(InputStream is, int maxSize) throws IOException {\n\t\tByteArrayOutputStream os = new ByteArrayOutputStream();\n\t\tbyte[] buffer = new byte[0xFFFF];\n\n\t\tfor (int len; (len = is.read(buffer)) != -1 && os.size() < maxSize; ) {\n\t\t\tos.write(buffer, 0, len);\n\t\t}\n\n\t\tif (os.size() >= maxSize) {\n\t\t\tthrow new IOException(\"File was too big\");\n\t\t}\n\n\t\tos.flush();\n\t\treturn os.toByteArray();\n\t}\n\n\tprivate KeyPair readPKCS8Key(byte[] keyData) {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(new ByteArrayInputStream(keyData)));\n\n\t\t// parse the actual key once to check if its encrypted\n\t\t// then save original file contents into our database\n\t\ttry {\n\t\t\tByteArrayOutputStream keyBytes = new ByteArrayOutputStream();\n\n\t\t\tString line;\n\t\t\tboolean inKey = false;\n\t\t\twhile ((line = reader.readLine()) != null) {\n\t\t\t\tif (line.equals(PubkeyUtils.PKCS8_START)) {\n\t\t\t\t\tinKey = true;\n\t\t\t\t} else if (line.equals(PubkeyUtils.PKCS8_END)) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (inKey) {\n\t\t\t\t\tkeyBytes.write(line.getBytes(\"US-ASCII\"));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (keyBytes.size() > 0) {\n\t\t\t\tbyte[] decoded = Base64.decode(keyBytes.toString().toCharArray());\n\n\t\t\t\treturn PubkeyUtils.recoverKeyPair(decoded);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\treturn null;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * @param uri URI to private key to read.\n\t */\n\tprivate void readKeyFromFile(Uri uri) {\n\t\tPubkeyBean pubkey = new PubkeyBean();\n\n\t\t// find the exact file selected\n\t\tpubkey.setNickname(uri.getLastPathSegment());\n\n\t\tbyte[] keyData;\n\t\ttry {\n\t\t\tContentResolver resolver = getContentResolver();\n\t\t\tkeyData = getBytesFromInputStream(resolver.openInputStream(uri), MAX_KEYFILE_SIZE);\n\t\t} catch (IOException e) {\n\t\t\tToast.makeText(PubkeyListActivity.this,\n\t\t\t\t\tR.string.pubkey_import_parse_problem,\n\t\t\t\t\tToast.LENGTH_LONG).show();\n\t\t\treturn;\n\t\t}\n\n\t\tKeyPair kp;\n\t\tif ((kp = readPKCS8Key(keyData)) != null) {\n\t\t\tString algorithm = convertAlgorithmName(kp.getPrivate().getAlgorithm());\n\t\t\tpubkey.setType(algorithm);\n\t\t\tpubkey.setPrivateKey(kp.getPrivate().getEncoded());\n\t\t\tpubkey.setPublicKey(kp.getPublic().getEncoded());\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tPEMStructure struct = PEMDecoder.parsePEM(new String(keyData).toCharArray());\n\t\t\t\tboolean encrypted = PEMDecoder.isPEMEncrypted(struct);\n\t\t\t\tpubkey.setEncrypted(encrypted);\n\t\t\t\tif (!encrypted) {\n\t\t\t\t\tkp = PEMDecoder.decode(struct, null);\n\t\t\t\t\tString algorithm = convertAlgorithmName(kp.getPrivate().getAlgorithm());\n\t\t\t\t\tpubkey.setType(algorithm);\n\t\t\t\t\tpubkey.setPrivateKey(kp.getPrivate().getEncoded());\n\t\t\t\t\tpubkey.setPublicKey(kp.getPublic().getEncoded());\n\t\t\t\t} else {\n\t\t\t\t\tpubkey.setType(PubkeyDatabase.KEY_TYPE_IMPORTED);\n\t\t\t\t\tpubkey.setPrivateKey(keyData);\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\tLog.e(TAG, \"Problem parsing imported private key\", e);\n\t\t\t\tToast.makeText(PubkeyListActivity.this, R.string.pubkey_import_parse_problem, Toast.LENGTH_LONG).show();\n\t\t\t}\n\t\t}\n\n\t\t// write new value into database\n\t\tPubkeyDatabase pubkeyDb = PubkeyDatabase.get(this);\n\t\tpubkeyDb.savePubkey(pubkey);\n\n\t\tupdateList();\n\t}\n\n\tprivate String convertAlgorithmName(String algorithm) {\n\t\tif (\"EdDSA\".equals(algorithm)) {\n\t\t\treturn PubkeyDatabase.KEY_TYPE_ED25519;\n\t\t} else {\n\t\t\treturn algorithm;\n\t\t}\n\t}\n\n\tpublic class PubkeyViewHolder extends ItemViewHolder {\n\t\tpublic final ImageView icon;\n\t\tpublic final TextView nickname;\n\t\tpublic final TextView caption;\n\n\t\tpublic PubkeyBean pubkey;\n\n\t\tpublic PubkeyViewHolder(View v) {\n\t\t\tsuper(v);\n\n\t\t\ticon = v.findViewById(android.R.id.icon);\n\t\t\tnickname = v.findViewById(android.R.id.text1);\n\t\t\tcaption = v.findViewById(android.R.id.text2);\n\t\t}\n\n\t\t@Override\n\t\tpublic void onClick(View v) {\n\t\t\tboolean loaded = bound != null && bound.isKeyLoaded(pubkey.getNickname());\n\n\t\t\t// handle toggling key in-memory on/off\n\t\t\tif (loaded) {\n\t\t\t\tbound.removeKey(pubkey.getNickname());\n\t\t\t\tupdateList();\n\t\t\t} else {\n\t\t\t\thandleAddKey(pubkey);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void onCreateContextMenu(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo) {\n\t\t\t// Create menu to handle deleting and editing pubkey\n\t\t\tmenu.setHeaderTitle(pubkey.getNickname());\n\n\t\t\t// TODO: option load/unload key from in-memory list\n\t\t\t// prompt for password as needed for passworded keys\n\n\t\t\t// cant change password or clipboard imported keys\n\t\t\tfinal boolean imported = PubkeyDatabase.KEY_TYPE_IMPORTED.equals(pubkey.getType());\n\t\t\tfinal boolean loaded = bound != null && bound.isKeyLoaded(pubkey.getNickname());\n\n\t\t\tMenuItem load = menu.add(loaded ? R.string.pubkey_memory_unload : R.string.pubkey_memory_load);\n\t\t\tload.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\tif (loaded) {\n\t\t\t\t\t\tbound.removeKey(pubkey.getNickname());\n\t\t\t\t\t\tupdateList();\n\t\t\t\t\t} else {\n\t\t\t\t\t\thandleAddKey(pubkey);\n\t\t\t\t\t\t//bound.addKey(nickname, trileadKey);\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tMenuItem onstartToggle = menu.add(R.string.pubkey_load_on_start);\n\t\t\tonstartToggle.setEnabled(!pubkey.isEncrypted());\n\t\t\tonstartToggle.setCheckable(true);\n\t\t\tonstartToggle.setChecked(pubkey.isStartup());\n\t\t\tonstartToggle.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\t// toggle onstart status\n\t\t\t\t\tpubkey.setStartup(!pubkey.isStartup());\n\t\t\t\t\tPubkeyDatabase pubkeyDb = PubkeyDatabase.get(PubkeyListActivity.this);\n\t\t\t\t\tpubkeyDb.savePubkey(pubkey);\n\t\t\t\t\tupdateList();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tMenuItem copyPublicToClipboard = menu.add(R.string.pubkey_copy_public);\n\t\t\tcopyPublicToClipboard.setEnabled(!imported);\n\t\t\tcopyPublicToClipboard.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tPublicKey pk = PubkeyUtils.decodePublic(pubkey.getPublicKey(), pubkey.getType());\n\t\t\t\t\t\tString openSSHPubkey = PubkeyUtils.convertToOpenSSHFormat(pk, pubkey.getNickname());\n\n\t\t\t\t\t\tclipboard.setText(openSSHPubkey);\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\tLog.d(TAG, \"Error converting to OpenSSH format\", e);\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tMenuItem copyPrivateToClipboard = menu.add(R.string.pubkey_copy_private);\n\t\t\tcopyPrivateToClipboard.setEnabled(!pubkey.isEncrypted() || imported);\n\t\t\tcopyPrivateToClipboard.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tString data = null;\n\n\t\t\t\t\t\tif (imported)\n\t\t\t\t\t\t\tdata = new String(pubkey.getPrivateKey());\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tPrivateKey pk = PubkeyUtils.decodePrivate(pubkey.getPrivateKey(), pubkey.getType());\n\t\t\t\t\t\t\tdata = PubkeyUtils.exportPEM(pk, null);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tclipboard.setText(data);\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\tLog.d(TAG, \"Error copying private key\", e);\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tMenuItem changePassword = menu.add(R.string.pubkey_change_password);\n\t\t\tchangePassword.setEnabled(!imported);\n\t\t\tchangePassword.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\tfinal View changePasswordView =\n\t\t\t\t\t\t\tView.inflate(PubkeyListActivity.this, R.layout.dia_changepassword, null);\n\t\t\t\t\tchangePasswordView.findViewById(R.id.old_password_prompt)\n\t\t\t\t\t\t\t.setVisibility(pubkey.isEncrypted() ? View.VISIBLE : View.GONE);\n\t\t\t\t\tnew androidx.appcompat.app.AlertDialog.Builder(\n\t\t\t\t\t\t\t\t\tPubkeyListActivity.this, R.style.AlertDialogTheme)\n\t\t\t\t\t\t\t.setView(changePasswordView)\n\t\t\t\t\t\t\t.setPositiveButton(R.string.button_change, new DialogInterface.OnClickListener() {\n\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\t\t\t\t\tString oldPassword = ((EditText) changePasswordView.findViewById(R.id.old_password)).getText().toString();\n\t\t\t\t\t\t\t\t\tString password1 = ((EditText) changePasswordView.findViewById(R.id.password1)).getText().toString();\n\t\t\t\t\t\t\t\t\tString password2 = ((EditText) changePasswordView.findViewById(R.id.password2)).getText().toString();\n\n\t\t\t\t\t\t\t\t\tif (!password1.equals(password2)) {\n\t\t\t\t\t\t\t\t\t\tnew androidx.appcompat.app.AlertDialog.Builder(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tPubkeyListActivity.this,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tR.style.AlertDialogTheme)\n\t\t\t\t\t\t\t\t\t\t\t\t.setMessage(R.string.alert_passwords_do_not_match_msg)\n\t\t\t\t\t\t\t\t\t\t\t\t.setPositiveButton(android.R.string.ok, null)\n\t\t\t\t\t\t\t\t\t\t\t\t.create().show();\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tif (!pubkey.changePassword(oldPassword, password1))\n\t\t\t\t\t\t\t\t\t\t\tnew androidx.appcompat.app.AlertDialog.Builder(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tPubkeyListActivity.this,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tR.style.AlertDialogTheme)\n\t\t\t\t\t\t\t\t\t\t\t\t\t.setMessage(R.string.alert_wrong_password_msg)\n\t\t\t\t\t\t\t\t\t\t\t\t\t.setPositiveButton(android.R.string.ok, null)\n\t\t\t\t\t\t\t\t\t\t\t\t\t.create().show();\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\tPubkeyDatabase pubkeyDb = PubkeyDatabase.get(PubkeyListActivity.this);\n\t\t\t\t\t\t\t\t\t\t\tpubkeyDb.savePubkey(pubkey);\n\t\t\t\t\t\t\t\t\t\t\tupdateList();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\t\t\t\tLog.e(TAG, \"Could not change private key password\", e);\n\t\t\t\t\t\t\t\t\t\tnew androidx.appcompat.app.AlertDialog.Builder(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tPubkeyListActivity.this,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tR.style.AlertDialogTheme)\n\t\t\t\t\t\t\t\t\t\t\t\t.setMessage(R.string.alert_key_corrupted_msg)\n\t\t\t\t\t\t\t\t\t\t\t\t.setPositiveButton(android.R.string.ok, null)\n\t\t\t\t\t\t\t\t\t\t\t\t.create().show();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t.setNegativeButton(android.R.string.cancel, null).create().show();\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tMenuItem confirmUse = menu.add(R.string.pubkey_confirm_use);\n\t\t\tconfirmUse.setCheckable(true);\n\t\t\tconfirmUse.setChecked(pubkey.isConfirmUse());\n\t\t\tconfirmUse.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\t// toggle confirm use\n\t\t\t\t\tpubkey.setConfirmUse(!pubkey.isConfirmUse());\n\t\t\t\t\tPubkeyDatabase pubkeyDb = PubkeyDatabase.get(PubkeyListActivity.this);\n\t\t\t\t\tpubkeyDb.savePubkey(pubkey);\n\t\t\t\t\tupdateList();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tMenuItem delete = menu.add(R.string.pubkey_delete);\n\t\t\tdelete.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\t// prompt user to make sure they really want this\n\t\t\t\t\tnew androidx.appcompat.app.AlertDialog.Builder(\n\t\t\t\t\t\t\t\t\tPubkeyListActivity.this, R.style.AlertDialogTheme)\n\t\t\t\t\t\t\t.setMessage(getString(R.string.delete_message, pubkey.getNickname()))\n\t\t\t\t\t\t\t.setPositiveButton(R.string.delete_pos, new DialogInterface.OnClickListener() {\n\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\n\t\t\t\t\t\t\t\t\t// dont forget to remove from in-memory\n\t\t\t\t\t\t\t\t\tif (loaded) {\n\t\t\t\t\t\t\t\t\t\tbound.removeKey(pubkey.getNickname());\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// delete from backend database and update gui\n\t\t\t\t\t\t\t\t\tPubkeyDatabase pubkeyDb = PubkeyDatabase.get(PubkeyListActivity.this);\n\t\t\t\t\t\t\t\t\tpubkeyDb.deletePubkey(pubkey);\n\t\t\t\t\t\t\t\t\tupdateList();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t.setNegativeButton(R.string.delete_neg, null).create().show();\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t@VisibleForTesting\n\tprivate class PubkeyAdapter extends ItemAdapter {\n\t\tprivate final List<PubkeyBean> pubkeys;\n\n\t\tpublic PubkeyAdapter(Context context, List<PubkeyBean> pubkeys) {\n\t\t\tsuper(context);\n\t\t\tthis.pubkeys = pubkeys;\n\t\t}\n\n\t\t@Override\n\t\tpublic PubkeyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n\t\t\tView v = LayoutInflater.from(parent.getContext())\n\t\t\t\t\t.inflate(R.layout.item_pubkey, parent, false);\n\t\t\treturn new PubkeyViewHolder(v);\n\t\t}\n\n\t\t@Override\n\t\tpublic void onBindViewHolder(ItemViewHolder holder, int position) {\n\t\t\tPubkeyViewHolder pubkeyHolder = (PubkeyViewHolder) holder;\n\n\t\t\tPubkeyBean pubkey = pubkeys.get(position);\n\t\t\tpubkeyHolder.pubkey = pubkey;\n\t\t\tif (pubkey == null) {\n\t\t\t\t// Well, something bad happened. We can't continue.\n\t\t\t\tLog.e(\"PubkeyAdapter\", \"Pubkey bean is null!\");\n\n\t\t\t\tpubkeyHolder.nickname.setText(\"Error during lookup\");\n\t\t\t} else {\n\t\t\t\tpubkeyHolder.nickname.setText(pubkey.getNickname());\n\t\t\t}\n\n\t\t\tboolean imported = PubkeyDatabase.KEY_TYPE_IMPORTED.equals(pubkey.getType());\n\n\t\t\tif (imported) {\n\t\t\t\ttry {\n\t\t\t\t\tPEMStructure struct = PEMDecoder.parsePEM(new String(pubkey.getPrivateKey()).toCharArray());\n\t\t\t\t\tString type;\n\t\t\t\t\tif (struct.pemType == PEMDecoder.PEM_RSA_PRIVATE_KEY) {\n\t\t\t\t\t\ttype = \"RSA\";\n\t\t\t\t\t} else if (struct.pemType == PEMDecoder.PEM_DSA_PRIVATE_KEY) {\n\t\t\t\t\t\ttype = \"DSA\";\n\t\t\t\t\t} else if (struct.pemType == PEMDecoder.PEM_EC_PRIVATE_KEY) {\n\t\t\t\t\t\ttype = \"EC\";\n\t\t\t\t\t} else if (struct.pemType == PEMDecoder.PEM_OPENSSH_PRIVATE_KEY) {\n\t\t\t\t\t\ttype = \"OpenSSH\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new RuntimeException(\"Unexpected key type: \" + struct.pemType);\n\t\t\t\t\t}\n\t\t\t\t\tpubkeyHolder.caption.setText(String.format(\"%s unknown-bit\", type));\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tLog.e(TAG, \"Error decoding IMPORTED public key at \" + pubkey.getId(), e);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tpubkeyHolder.caption.setText(pubkey.getDescription(getApplicationContext()));\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tLog.e(TAG, \"Error decoding public key at \" + pubkey.getId(), e);\n\t\t\t\t\tpubkeyHolder.caption.setText(R.string.pubkey_unknown_format);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (bound == null) {\n\t\t\t\tpubkeyHolder.icon.setVisibility(View.GONE);\n\t\t\t} else {\n\t\t\t\tpubkeyHolder.icon.setVisibility(View.VISIBLE);\n\n\t\t\t\tif (bound.isKeyLoaded(pubkey.getNickname()))\n\t\t\t\t\tpubkeyHolder.icon.setImageState(new int[] { android.R.attr.state_checked }, true);\n\t\t\t\telse\n\t\t\t\t\tpubkeyHolder.icon.setImageState(new int[] { }, true);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic int getItemCount() {\n\t\t\treturn pubkeys.size();\n\t\t}\n\n\t\t@Override\n\t\tpublic long getItemId(int position) {\n\t\t\treturn pubkeys.get(position).getId();\n\t\t}\n\t}\n}\n","lineNo":154}
{"Smelly Sample":"/*\n * ConnectBot: simple, powerful, open-source SSH client for Android\n * Copyright 2007 Kenny Root, Jeffrey Sharkey\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.connectbot.service;\n\nimport java.io.IOException;\nimport java.nio.charset.Charset;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.connectbot.R;\nimport org.connectbot.TerminalView;\nimport org.connectbot.bean.HostBean;\nimport org.connectbot.bean.PortForwardBean;\nimport org.connectbot.bean.SelectionArea;\nimport org.connectbot.transport.AbsTransport;\nimport org.connectbot.transport.TransportFactory;\nimport org.connectbot.util.HostDatabase;\n\nimport android.content.Context;\nimport android.graphics.Bitmap;\nimport android.graphics.Bitmap.Config;\nimport android.graphics.Canvas;\nimport android.graphics.Color;\nimport android.graphics.Paint;\nimport android.graphics.Paint.FontMetrics;\nimport android.graphics.Typeface;\nimport android.text.ClipboardManager;\nimport android.util.Log;\nimport de.mud.terminal.VDUBuffer;\nimport de.mud.terminal.VDUDisplay;\nimport de.mud.terminal.vt320;\n\n\n/**\n * Provides a bridge between a MUD terminal buffer and a possible TerminalView.\n * This separation allows us to keep the TerminalBridge running in a background\n * service. A TerminalView shares down a bitmap that we can use for rendering\n * when available.\n *\n * This class also provides SSH hostkey verification prompting, and password\n * prompting.\n */\n@SuppressWarnings(\"deprecation\") // for ClipboardManager\npublic class TerminalBridge implements VDUDisplay {\n\tpublic final static String TAG = \"CB.TerminalBridge\";\n\n\tprivate final static int DEFAULT_FONT_SIZE_DP = 10;\n\tprivate final static int FONT_SIZE_STEP = 2;\n\tprivate final float displayDensity;\n\n\tpublic int[] color;\n\n\tpublic int defaultFg = HostDatabase.DEFAULT_FG_COLOR;\n\tpublic int defaultBg = HostDatabase.DEFAULT_BG_COLOR;\n\n\tprotected final TerminalManager manager;\n\n\tpublic HostBean host;\n\n\t/* package */ AbsTransport transport;\n\n\tfinal Paint defaultPaint;\n\n\tprivate Relay relay;\n\n\tprivate final String emulation;\n\tprivate final int scrollback;\n\n\tpublic Bitmap bitmap = null;\n\tpublic VDUBuffer buffer = null;\n\n\tprivate TerminalView parent = null;\n\tprivate final Canvas canvas = new Canvas();\n\n\tprivate boolean disconnected = false;\n\tprivate boolean awaitingClose = false;\n\n\tprivate boolean forcedSize = false;\n\tprivate int columns;\n\tprivate int rows;\n\n\tprivate final TerminalKeyListener keyListener;\n\n\tprivate boolean selectingForCopy = false;\n\tprivate final SelectionArea selectionArea;\n\n\tpublic int charWidth = -1;\n\tpublic int charHeight = -1;\n\tprivate int charTop = -1;\n\n\tprivate float fontSizeDp = -1;\n\n\tprivate final List<FontSizeChangedListener> fontSizeChangedListeners;\n\n\tprivate final List<String> localOutput;\n\n\t/**\n\t * Flag indicating if we should perform a full-screen redraw during our next\n\t * rendering pass.\n\t */\n\tprivate boolean fullRedraw = false;\n\n\tpublic PromptHelper promptHelper;\n\n\tprivate BridgeDisconnectedListener disconnectListener = null;\n\n\t/**\n\t * Create a new terminal bridge suitable for unit testing.\n\t */\n\tpublic TerminalBridge() {\n\t\tbuffer = new vt320() {\n\t\t\t@Override\n\t\t\tpublic void write(byte[] b) {}\n\t\t\t@Override\n\t\t\tpublic void write(int b) {}\n\t\t\t@Override\n\t\t\tpublic void sendTelnetCommand(byte cmd) {}\n\t\t\t@Override\n\t\t\tpublic void setWindowSize(int c, int r) {}\n\t\t\t@Override\n\t\t\tpublic void debug(String s) {}\n\t\t};\n\n\t\temulation = null;\n\t\tmanager = null;\n\n\t\tdisplayDensity = 1f;\n\n\t\tdefaultPaint = new Paint();\n\n\t\tselectionArea = new SelectionArea();\n\t\tscrollback = 1;\n\n\t\tlocalOutput = new LinkedList<String>();\n\n\t\tfontSizeChangedListeners = new LinkedList<FontSizeChangedListener>();\n\n\t\ttransport = null;\n\n\t\tkeyListener = new TerminalKeyListener(null, this, buffer, null);\n\t}\n\n\t/**\n\t * Create new terminal bridge with following parameters. We will immediately\n\t * launch thread to start SSH connection and handle any hostkey verification\n\t * and password authentication.\n\t */\n\tpublic TerminalBridge(final TerminalManager manager, final HostBean host) throws IOException {\n\t\tthis.manager = manager;\n\t\tthis.host = host;\n\n\t\temulation = manager.getEmulation();\n\t\tscrollback = manager.getScrollback();\n\n\t\tthis.displayDensity = manager.getResources().getDisplayMetrics().density;\n\n\t\t// create prompt helper to relay password and hostkey requests up to gui\n\t\tpromptHelper = new PromptHelper(this);\n\n\t\t// create our default paint\n\t\tdefaultPaint = new Paint();\n\t\tdefaultPaint.setAntiAlias(true);\n\t\tdefaultPaint.setTypeface(Typeface.MONOSPACE);\n\t\tdefaultPaint.setFakeBoldText(true); // more readable?\n\n\t\tlocalOutput = new LinkedList<String>();\n\n\t\tfontSizeChangedListeners = new LinkedList<FontSizeChangedListener>();\n\n\t\tint hostFontSizeDp = host.getFontSize();\n\t\tif (hostFontSizeDp <= 0) {\n\t\t\thostFontSizeDp = DEFAULT_FONT_SIZE_DP;\n\t\t}\n\t\tsetFontSize(hostFontSizeDp);\n\n\t\t// create terminal buffer and handle outgoing data\n\t\t// this is probably status reply information\n\t\tbuffer = new vt320() {\n\t\t\t@Override\n\t\t\tpublic void debug(String s) {\n\t\t\t\tLog.d(TAG, s);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void write(byte[] b) {\n\t\t\t\ttry {\n\t\t\t\t\tif (b != null && transport != null)\n\t\t\t\t\t\ttransport.write(b);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tLog.e(TAG, \"Problem writing outgoing data in vt320() thread\", e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void write(int b) {\n\t\t\t\ttry {\n\t\t\t\t\tif (transport != null)\n\t\t\t\t\t\ttransport.write(b);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tLog.e(TAG, \"Problem writing outgoing data in vt320() thread\", e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// We don't use telnet sequences.\n\t\t\t@Override\n\t\t\tpublic void sendTelnetCommand(byte cmd) {\n\t\t\t}\n\n\t\t\t// We don't want remote to resize our window.\n\t\t\t@Override\n\t\t\tpublic void setWindowSize(int c, int r) {\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void beep() {\n\t\t\t\tif (parent.isShown())\n\t\t\t\t\tmanager.playBeep();\n\t\t\t\telse\n\t\t\t\t\tmanager.sendActivityNotification(host);\n\t\t\t}\n\t\t};\n\n\t\t// Don't keep any scrollback if a session is not being opened.\n\t\tif (host.getWantSession())\n\t\t\tbuffer.setBufferSize(scrollback);\n\t\telse\n\t\t\tbuffer.setBufferSize(0);\n\n\t\tresetColors();\n\t\tbuffer.setDisplay(this);\n\n\t\tselectionArea = new SelectionArea();\n\n\t\tkeyListener = new TerminalKeyListener(manager, this, buffer, host.getEncoding());\n\t}\n\n\tpublic PromptHelper getPromptHelper() {\n\t\treturn promptHelper;\n\t}\n\n\t/**\n\t * Spawn thread to open connection and start login process.\n\t */\n\tprotected void startConnection() {\n\t\ttransport = TransportFactory.getTransport(host.getProtocol());\n\t\tif (transport == null) {\n\t\t\tLog.i(TAG, \"No transport found for \" + host.getProtocol());\n\t\t\treturn;\n\t\t}\n\n\t\ttransport.setBridge(this);\n\t\ttransport.setManager(manager);\n\t\ttransport.setHost(host);\n\n\t\t// TODO make this more abstract so we don't litter on AbsTransport\n\t\ttransport.setCompression(host.getCompression());\n\t\ttransport.setUseAuthAgent(host.getUseAuthAgent());\n\t\ttransport.setEmulation(emulation);\n\n\t\tif (transport.canForwardPorts()) {\n\t\t\tfor (PortForwardBean portForward : manager.hostdb.getPortForwardsForHost(host))\n\t\t\t\ttransport.addPortForward(portForward);\n\t\t}\n\n\t\toutputLine(manager.res.getString(R.string.terminal_connecting, host.getHostname(), host.getPort(), host.getProtocol()));\n\n\t\tThread connectionThread = new Thread(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\ttransport.connect();\n\t\t\t}\n\t\t});\n\t\tconnectionThread.setName(\"Connection\");\n\t\tconnectionThread.setDaemon(true);\n\t\tconnectionThread.start();\n\t}\n\n\t/**\n\t * @return charset in use by bridge\n\t */\n\tpublic Charset getCharset() {\n\t\treturn relay.getCharset();\n\t}\n\n\t/**\n\t * Sets the encoding used by the terminal. If the connection is live,\n\t * then the character set is changed for the next read.\n\t * @param encoding the canonical name of the character encoding\n\t */\n\tpublic void setCharset(String encoding) {\n\t\tif (relay != null)\n\t\t\trelay.setCharset(encoding);\n\t\tkeyListener.setCharset(encoding);\n\t}\n\n\t/**\n\t * Convenience method for writing text into the underlying terminal buffer.\n\t * Should never be called once the session is established.\n\t */\n\tpublic final void outputLine(String output) {\n\t\tif (transport != null && transport.isSessionOpen()) {\n\t\t\tLog.e(TAG, \"Session established, cannot use outputLine!\",\n\t\t\t\t\tnew IOException(\"outputLine call traceback\"));\n\t\t}\n\n\t\tsynchronized (localOutput) {\n\t\t\tfor (String line : output.split(\"\\n\")) {\n\t\t\t\tif (line.length() > 0 && line.charAt(line.length() - 1) == '\\r') {\n\t\t\t\t\tline = line.substring(0, line.length() - 1);\n\t\t\t\t}\n\n\t\t\t\tfinal String s = line + \"\\r\\n\";\n\n\t\t\t\tlocalOutput.add(s);\n\n\t\t\t\t((vt320) buffer).putString(s);\n\n\t\t\t\t// For accessibility\n\t\t\t\tfinal char[] charArray = s.toCharArray();\n\t\t\t\tpropagateConsoleText(charArray, charArray.length);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Only intended for pre-Honeycomb devices.\n\t */\n\tpublic void setSelectingForCopy(boolean selectingForCopy) {\n\t\tthis.selectingForCopy = selectingForCopy;\n\t}\n\n\t/**\n\t * Only intended for pre-Honeycomb devices.\n\t */\n\tpublic boolean isSelectingForCopy() {\n\t\treturn selectingForCopy;\n\t}\n\n\t/**\n\t * Only intended for pre-Honeycomb devices.\n\t */\n\tpublic SelectionArea getSelectionArea() {\n\t\treturn selectionArea;\n\t}\n\n\tpublic void copyCurrentSelection() {\n\t\tif (parent != null) {\n\t\t\tparent.copyCurrentSelectionToClipboard();\n\t\t}\n\t}\n\n\t/**\n\t * Inject a specific string into this terminal. Used for post-login strings\n\t * and pasting clipboard.\n\t */\n\tpublic void injectString(final String string) {\n\t\tif (string == null || string.length() == 0)\n\t\t\treturn;\n\n\t\tThread injectStringThread = new Thread(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\ttransport.write(string.getBytes(host.getEncoding()));\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tLog.e(TAG, \"Couldn't inject string to remote host: \", e);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tinjectStringThread.setName(\"InjectString\");\n\t\tinjectStringThread.start();\n\t}\n\n\t/**\n\t * Internal method to request actual PTY terminal once we've finished\n\t * authentication. If called before authenticated, it will just fail.\n\t */\n\tpublic void onConnected() {\n\t\tdisconnected = false;\n\n\t\t((vt320) buffer).reset();\n\n\t\t// We no longer need our local output.\n\t\tlocalOutput.clear();\n\n\t\t// previously tried vt100 and xterm for emulation modes\n\t\t// \"screen\" works the best for color and escape codes\n\t\t((vt320) buffer).setAnswerBack(emulation);\n\n\t\tif (HostDatabase.DELKEY_BACKSPACE.equals(host.getDelKey()))\n\t\t\t((vt320) buffer).setBackspace(vt320.DELETE_IS_BACKSPACE);\n\t\telse\n\t\t\t((vt320) buffer).setBackspace(vt320.DELETE_IS_DEL);\n\n\t\tif (isSessionOpen()) {\n\t\t\t// create thread to relay incoming connection data to buffer\n\t\t\trelay = new Relay(this, transport, (vt320) buffer, host.getEncoding());\n\t\t\tThread relayThread = new Thread(relay);\n\t\t\trelayThread.setDaemon(true);\n\t\t\trelayThread.setName(\"Relay\");\n\t\t\trelayThread.start();\n\t\t}\n\n\t\t// force font-size to make sure we resizePTY as needed\n\t\tsetFontSize(fontSizeDp);\n\n\t\t// finally send any post-login string, if requested\n\t\tinjectString(host.getPostLogin());\n\t}\n\n\t/**\n\t * @return whether a session is open or not\n\t */\n\tpublic boolean isSessionOpen() {\n\t\tif (transport != null)\n\t\t\treturn transport.isSessionOpen();\n\t\treturn false;\n\t}\n\n\tpublic void setOnDisconnectedListener(BridgeDisconnectedListener disconnectListener) {\n\t\tthis.disconnectListener = disconnectListener;\n\t}\n\n\t/**\n\t * Force disconnection of this terminal bridge.\n\t */\n\tpublic void dispatchDisconnect(boolean immediate) {\n\t\t// We don't need to do this multiple times.\n\t\tsynchronized (this) {\n\t\t\tif (disconnected && !immediate)\n\t\t\t\treturn;\n\n\t\t\tdisconnected = true;\n\t\t}\n\n\t\t// Cancel any pending prompts.\n\t\tpromptHelper.cancelPrompt();\n\n\t\t// disconnection request hangs if we havent really connected to a host yet\n\t\t// temporary fix is to just spawn disconnection into a thread\n\t\tThread disconnectThread = new Thread(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tif (transport != null && transport.isConnected())\n\t\t\t\t\ttransport.close();\n\t\t\t}\n\t\t});\n\t\tdisconnectThread.setName(\"Disconnect\");\n\t\tdisconnectThread.start();\n\n\t\tif (immediate || (host.getQuickDisconnect() && !host.getStayConnected())) {\n\t\t\tawaitingClose = true;\n\t\t\ttriggerDisconnectListener();\n\t\t} else {\n\t\t\t{\n\t\t\t\tfinal String line = manager.res.getString(R.string.alert_disconnect_msg);\n\t\t\t\t((vt320) buffer).putString(\"\\r\\n\" + line + \"\\r\\n\");\n\t\t\t}\n\t\t\tif (host.getStayConnected()) {\n\t\t\t\tmanager.requestReconnect(this);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tThread disconnectPromptThread = new Thread(new Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tBoolean result = promptHelper.requestBooleanPrompt(null,\n\t\t\t\t\t\t\tmanager.res.getString(R.string.prompt_host_disconnected));\n\t\t\t\t\tif (result == null || result.booleanValue()) {\n\t\t\t\t\t\tawaitingClose = true;\n\t\t\t\t\t\ttriggerDisconnectListener();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\tdisconnectPromptThread.setName(\"DisconnectPrompt\");\n\t\t\tdisconnectPromptThread.setDaemon(true);\n\t\t\tdisconnectPromptThread.start();\n\t\t}\n\t}\n\n\t/**\n\t * Tells the TerminalManager that we can be destroyed now.\n\t */\n\tprivate void triggerDisconnectListener() {\n\t\tif (disconnectListener != null) {\n\t\t\t// The disconnect listener should be run on the main thread if possible.\n\t\t\tif (parent != null) {\n\t\t\t\tparent.post(new Runnable() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\tdisconnectListener.onDisconnected(TerminalBridge.this);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tdisconnectListener.onDisconnected(TerminalBridge.this);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic synchronized void tryKeyVibrate() {\n\t\tmanager.tryKeyVibrate();\n\t}\n\n\t/**\n\t * Request a different font size. Will make call to parentChanged() to make\n\t * sure we resize PTY if needed.\n\t *\n\t * @param sizeDp Size of font in dp\n\t */\n\tprivate final void setFontSize(float sizeDp) {\n\t\tif (sizeDp <= 0.0) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal int fontSizePx = (int) (sizeDp * this.displayDensity + 0.5f);\n\n\t\tdefaultPaint.setTextSize(fontSizePx);\n\t\tfontSizeDp = sizeDp;\n\n\t\t// read new metrics to get exact pixel dimensions\n\t\tFontMetrics fm = defaultPaint.getFontMetrics();\n\t\tcharTop = (int) Math.ceil(fm.top);\n\n\t\tfloat[] widths = new float[1];\n\t\tdefaultPaint.getTextWidths(\"X\", widths);\n\t\tcharWidth = (int) Math.ceil(widths[0]);\n\t\tcharHeight = (int) Math.ceil(fm.descent - fm.top);\n\n\t\t// refresh any bitmap with new font size\n\t\tif (parent != null) {\n\t\t\tparentChanged(parent);\n\t\t}\n\n\t\tfor (FontSizeChangedListener ofscl : fontSizeChangedListeners) {\n\t\t\tofscl.onFontSizeChanged(sizeDp);\n\t\t}\n\n\t\thost.setFontSize((int) sizeDp);\n\t\tmanager.hostdb.saveHost(host);\n\n\t\tforcedSize = false;\n\t}\n\n\tpublic float getFontSize() {\n\t\treturn fontSizeDp;\n\t}\n\n\t/**\n\t * Add an {@link FontSizeChangedListener} to the list of listeners for this\n\t * bridge.\n\t *\n\t * @param listener\n\t *            listener to add\n\t */\n\tpublic void addFontSizeChangedListener(FontSizeChangedListener listener) {\n\t\tfontSizeChangedListeners.add(listener);\n\t}\n\n\t/**\n\t * Remove an {@link FontSizeChangedListener} from the list of listeners for\n\t * this bridge.\n\t *\n\t * @param listener\n\t */\n\tpublic void removeFontSizeChangedListener(FontSizeChangedListener listener) {\n\t\tfontSizeChangedListeners.remove(listener);\n\t}\n\n\t/**\n\t * Something changed in our parent {@link TerminalView}, maybe it's a new\n\t * parent, or maybe it's an updated font size. We should recalculate\n\t * terminal size information and request a PTY resize.\n\t */\n\tpublic final synchronized void parentChanged(TerminalView parent) {\n\t\tif (manager != null && !manager.isResizeAllowed()) {\n\t\t\tLog.d(TAG, \"Resize is not allowed now\");\n\t\t\treturn;\n\t\t}\n\n\t\tthis.parent = parent;\n\t\tfinal int width = parent.getWidth();\n\t\tfinal int height = parent.getHeight();\n\n\t\t// Something has gone wrong with our layout; we're 0 width or height!\n\t\tif (width <= 0 || height <= 0)\n\t\t\treturn;\n\n\t\tClipboardManager clipboard = (ClipboardManager) parent.getContext().getSystemService(Context.CLIPBOARD_SERVICE);\n\t\tkeyListener.setClipboardManager(clipboard);\n\n\t\tif (!forcedSize) {\n\t\t\t// recalculate buffer size\n\t\t\tint newColumns, newRows;\n\n\t\t\tnewColumns = width / charWidth;\n\t\t\tnewRows = height / charHeight;\n\n\t\t\t// If nothing has changed in the terminal dimensions and not an intial\n\t\t\t// draw then don't blow away scroll regions and such.\n\t\t\tif (newColumns == columns && newRows == rows)\n\t\t\t\treturn;\n\n\t\t\tcolumns = newColumns;\n\t\t\trows = newRows;\n\t\t}\n\n\t\t// reallocate new bitmap if needed\n\t\tboolean newBitmap = (bitmap == null);\n\t\tif (bitmap != null)\n\t\t\tnewBitmap = (bitmap.getWidth() != width || bitmap.getHeight() != height);\n\n\t\tif (newBitmap) {\n\t\t\tdiscardBitmap();\n\t\t\tbitmap = Bitmap.createBitmap(width, height, Config.ARGB_8888);\n\t\t\tcanvas.setBitmap(bitmap);\n\t\t}\n\n\t\t// clear out any old buffer information\n\t\tdefaultPaint.setColor(Color.BLACK);\n\t\tcanvas.drawPaint(defaultPaint);\n\n\t\t// Stroke the border of the terminal if the size is being forced;\n\t\tif (forcedSize) {\n\t\t\tint borderX = (columns * charWidth) + 1;\n\t\t\tint borderY = (rows * charHeight) + 1;\n\n\t\t\tdefaultPaint.setColor(Color.GRAY);\n\t\t\tdefaultPaint.setStrokeWidth(0.0f);\n\t\t\tif (width >= borderX)\n\t\t\t\tcanvas.drawLine(borderX, 0, borderX, borderY + 1, defaultPaint);\n\t\t\tif (height >= borderY)\n\t\t\t\tcanvas.drawLine(0, borderY, borderX + 1, borderY, defaultPaint);\n\t\t}\n\n\t\ttry {\n\t\t\t// request a terminal pty resize\n\t\t\tsynchronized (buffer) {\n\t\t\t\tbuffer.setScreenSize(columns, rows, true);\n\t\t\t}\n\n\t\t\tif (transport != null)\n\t\t\t\ttransport.setDimensions(columns, rows, width, height);\n\t\t} catch (Exception e) {\n\t\t\tLog.e(TAG, \"Problem while trying to resize screen or PTY\", e);\n\t\t}\n\n\t\t// redraw local output if we don't have a sesson to receive our resize request\n\t\tif (transport == null) {\n\t\t\tsynchronized (localOutput) {\n\t\t\t\t((vt320) buffer).reset();\n\n\t\t\t\tfor (String line : localOutput)\n\t\t\t\t\t((vt320) buffer).putString(line);\n\t\t\t}\n\t\t}\n\n\t\t// force full redraw with new buffer size\n\t\tfullRedraw = true;\n\t\tredraw();\n\n\t\tparent.notifyUser(String.format(\"%d x %d\", columns, rows));\n\n\t\tLog.i(TAG, String.format(\"parentChanged() now width=%d, height=%d\", columns, rows));\n\t}\n\n\t/**\n\t * Somehow our parent {@link TerminalView} was destroyed. Now we don't need\n\t * to redraw anywhere, and we can recycle our internal bitmap.\n\t */\n\tpublic synchronized void parentDestroyed() {\n\t\tparent = null;\n\t\tdiscardBitmap();\n\t}\n\n\tprivate void discardBitmap() {\n\t\tif (bitmap != null)\n\t\t\tbitmap.recycle();\n\t\tbitmap = null;\n\t}\n\n\tpublic void setVDUBuffer(VDUBuffer buffer) {\n\t\tthis.buffer = buffer;\n\t}\n\n\tpublic VDUBuffer getVDUBuffer() {\n\t\treturn buffer;\n\t}\n\n\tpublic void propagateConsoleText(char[] rawText, int length) {\n\t\tif (parent != null) {\n\t\t\tparent.propagateConsoleText(rawText, length);\n\t\t}\n\t}\n\n\tpublic void onDraw() {\n\t\tint fg, bg;\n\t\tsynchronized (buffer) {\n\t\t\tboolean entireDirty = buffer.update[0] || fullRedraw;\n\t\t\tboolean isWideCharacter = false;\n\n\t\t\t// walk through all lines in the buffer\n\t\t\tfor (int l = 0; l < buffer.height; l++) {\n\n\t\t\t\t// check if this line is dirty and needs to be repainted\n\t\t\t\t// also check for entire-buffer dirty flags\n\t\t\t\tif (!entireDirty && !buffer.update[l + 1]) continue;\n\n\t\t\t\t// reset dirty flag for this line\n\t\t\t\tbuffer.update[l + 1] = false;\n\n\t\t\t\t// walk through all characters in this line\n\t\t\t\tfor (int c = 0; c < buffer.width; c++) {\n\t\t\t\t\tint addr = 0;\n\t\t\t\t\tlong currAttr = buffer.charAttributes[buffer.windowBase + l][c];\n\n\t\t\t\t\t{\n\t\t\t\t\t\tint fgcolor = defaultFg;\n\n\t\t\t\t\t\t// check if foreground color attribute is set\n\t\t\t\t\t\tif ((currAttr & VDUBuffer.COLOR_FG) != 0)\n\t\t\t\t\t\t\tfgcolor = (int) ((currAttr & VDUBuffer.COLOR_FG) >> VDUBuffer.COLOR_FG_SHIFT) - 1;\n\n\t\t\t\t\t\tif (fgcolor < 8 && (currAttr & VDUBuffer.BOLD) != 0)\n\t\t\t\t\t\t\tfg = color[fgcolor + 8];\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tfg = color[fgcolor];\n\t\t\t\t\t}\n\n\t\t\t\t\t// check if background color attribute is set\n\t\t\t\t\tif ((currAttr & VDUBuffer.COLOR_BG) != 0)\n\t\t\t\t\t\tbg = color[(int) ((currAttr & VDUBuffer.COLOR_BG) >> VDUBuffer.COLOR_BG_SHIFT) - 1];\n\t\t\t\t\telse\n\t\t\t\t\t\tbg = color[defaultBg];\n\n\t\t\t\t\t// support character inversion by swapping background and foreground color\n\t\t\t\t\tif ((currAttr & VDUBuffer.INVERT) != 0) {\n\t\t\t\t\t\tint swapc = bg;\n\t\t\t\t\t\tbg = fg;\n\t\t\t\t\t\tfg = swapc;\n\t\t\t\t\t}\n\n\t\t\t\t\t// set underlined attributes if requested\n\t\t\t\t\tdefaultPaint.setUnderlineText((currAttr & VDUBuffer.UNDERLINE) != 0);\n\n\t\t\t\t\tisWideCharacter = (currAttr & VDUBuffer.FULLWIDTH) != 0;\n\n\t\t\t\t\tif (isWideCharacter)\n\t\t\t\t\t\taddr++;\n\t\t\t\t\telse {\n\t\t\t\t\t\t// determine the amount of continuous characters with the same settings and print them all at once\n\t\t\t\t\t\twhile (c + addr < buffer.width\n\t\t\t\t\t\t\t\t&& buffer.charAttributes[buffer.windowBase + l][c + addr] == currAttr) {\n\t\t\t\t\t\t\taddr++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Save the current clip region\n\t\t\t\t\tcanvas.save(Canvas.CLIP_SAVE_FLAG);\n\n\t\t\t\t\t// clear this dirty area with background color\n\t\t\t\t\tdefaultPaint.setColor(bg);\n\t\t\t\t\tif (isWideCharacter) {\n\t\t\t\t\t\tcanvas.clipRect(c * charWidth,\n\t\t\t\t\t\t\t\tl * charHeight,\n\t\t\t\t\t\t\t\t(c + 2) * charWidth,\n\t\t\t\t\t\t\t\t(l + 1) * charHeight);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcanvas.clipRect(c * charWidth,\n\t\t\t\t\t\t\t\tl * charHeight,\n\t\t\t\t\t\t\t\t(c + addr) * charWidth,\n\t\t\t\t\t\t\t\t(l + 1) * charHeight);\n\t\t\t\t\t}\n\t\t\t\t\tcanvas.drawPaint(defaultPaint);\n\n\t\t\t\t\t// write the text string starting at 'c' for 'addr' number of characters\n\t\t\t\t\tdefaultPaint.setColor(fg);\n\t\t\t\t\tif ((currAttr & VDUBuffer.INVISIBLE) == 0)\n\t\t\t\t\t\tcanvas.drawText(buffer.charArray[buffer.windowBase + l], c,\n\t\t\t\t\t\t\taddr, c * charWidth, (l * charHeight) - charTop,\n\t\t\t\t\t\t\tdefaultPaint);\n\n\t\t\t\t\t// Restore the previous clip region\n\t\t\t\t\tcanvas.restore();\n\n\t\t\t\t\t// advance to the next text block with different characteristics\n\t\t\t\t\tc += addr - 1;\n\t\t\t\t\tif (isWideCharacter)\n\t\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// reset entire-buffer flags\n\t\t\tbuffer.update[0] = false;\n\t\t}\n\t\tfullRedraw = false;\n\t}\n\n\tpublic void redraw() {\n\t\tif (parent != null)\n\t\t\tparent.postInvalidate();\n\t}\n\n\t// We don't have a scroll bar.\n\tpublic void updateScrollBar() {\n\t}\n\n\t/**\n\t * Resize terminal to fit [rows]x[cols] in screen of size [width]x[height]\n\t *\n\t * @param rows desired number of text rows\n\t * @param cols desired numbor of text colums\n\t * @param width width of screen in pixels\n\t * @param height height of screen in pixels\n\t */\n\tpublic synchronized void resizeComputed(int cols, int rows, int width, int height) {\n\t\tfloat sizeDp = 8.0f;\n\t\tfloat step = 8.0f;\n\t\tfloat limit = 0.125f;\n\n\t\tint direction;\n\n\t\twhile ((direction = fontSizeCompare(sizeDp, cols, rows, width, height)) < 0)\n\t\t\tsizeDp += step;\n\n\t\tif (direction == 0) {\n\t\t\tLog.d(\"fontsize\", String.format(\"Found match at %f\", sizeDp));\n\t\t\treturn;\n\t\t}\n\n\t\tstep /= 2.0f;\n\t\tsizeDp -= step;\n\n\t\twhile ((direction = fontSizeCompare(sizeDp, cols, rows, width, height)) != 0\n\t\t\t\t&& step >= limit) {\n\t\t\tstep /= 2.0f;\n\t\t\tif (direction > 0) {\n\t\t\t\tsizeDp -= step;\n\t\t\t} else {\n\t\t\t\tsizeDp += step;\n\t\t\t}\n\t\t}\n\n\t\tif (direction > 0)\n\t\t\tsizeDp -= step;\n\n\t\tthis.columns = cols;\n\t\tthis.rows = rows;\n\t\tsetFontSize(sizeDp);\n\t\tforcedSize = true;\n\t}\n\n\tprivate int fontSizeCompare(float sizeDp, int cols, int rows, int width, int height) {\n\t\t// read new metrics to get exact pixel dimensions\n\t\tdefaultPaint.setTextSize((int) (sizeDp * this.displayDensity + 0.5f));\n\t\tFontMetrics fm = defaultPaint.getFontMetrics();\n\n\t\tfloat[] widths = new float[1];\n\t\tdefaultPaint.getTextWidths(\"X\", widths);\n\t\tint termWidth = (int) widths[0] * cols;\n\t\tint termHeight = (int) Math.ceil(fm.descent - fm.top) * rows;\n\n\t\tLog.d(\"fontsize\", String.format(\"font size %fdp resulted in %d x %d\", sizeDp, termWidth, termHeight));\n\n\t\t// Check to see if it fits in resolution specified.\n\t\tif (termWidth > width || termHeight > height)\n\t\t\treturn 1;\n\n\t\tif (termWidth == width || termHeight == height)\n\t\t\treturn 0;\n\n\t\treturn -1;\n\t}\n\n\t/**\n\t * @return whether underlying transport can forward ports\n\t */\n\tpublic boolean canFowardPorts() {\n\t\treturn transport.canForwardPorts();\n\t}\n\n\t/**\n\t * Adds the {@link PortForwardBean} to the list.\n\t * @param portForward the port forward bean to add\n\t * @return true on successful addition\n\t */\n\tpublic boolean addPortForward(PortForwardBean portForward) {\n\t\treturn transport.addPortForward(portForward);\n\t}\n\n\t/**\n\t * Removes the {@link PortForwardBean} from the list.\n\t * @param portForward the port forward bean to remove\n\t * @return true on successful removal\n\t */\n\tpublic boolean removePortForward(PortForwardBean portForward) {\n\t\treturn transport.removePortForward(portForward);\n\t}\n\n\t/**\n\t * @return the list of port forwards\n\t */\n\tpublic List<PortForwardBean> getPortForwards() {\n\t\treturn transport.getPortForwards();\n\t}\n\n\t/**\n\t * Enables a port forward member. After calling this method, the port forward should\n\t * be operational.\n\t * @param portForward member of our current port forwards list to enable\n\t * @return true on successful port forward setup\n\t */\n\tpublic boolean enablePortForward(PortForwardBean portForward) {\n\t\tif (!transport.isConnected()) {\n\t\t\tLog.i(TAG, \"Attempt to enable port forward while not connected\");\n\t\t\treturn false;\n\t\t}\n\n\t\treturn transport.enablePortForward(portForward);\n\t}\n\n\t/**\n\t * Disables a port forward member. After calling this method, the port forward should\n\t * be non-functioning.\n\t * @param portForward member of our current port forwards list to enable\n\t * @return true on successful port forward tear-down\n\t */\n\tpublic boolean disablePortForward(PortForwardBean portForward) {\n\t\tif (!transport.isConnected()) {\n\t\t\tLog.i(TAG, \"Attempt to disable port forward while not connected\");\n\t\t\treturn false;\n\t\t}\n\n\t\treturn transport.disablePortForward(portForward);\n\t}\n\n\t/**\n\t * @return whether the TerminalBridge should close\n\t */\n\tpublic boolean isAwaitingClose() {\n\t\treturn awaitingClose;\n\t}\n\n\t/**\n\t * @return whether this connection had started and subsequently disconnected\n\t */\n\tpublic boolean isDisconnected() {\n\t\treturn disconnected;\n\t}\n\n\t/* (non-Javadoc)\n\t * @see de.mud.terminal.VDUDisplay#setColor(byte, byte, byte, byte)\n\t */\n\tpublic void setColor(int index, int red, int green, int blue) {\n\t\t// Don't allow the system colors to be overwritten for now. May violate specs.\n\t\tif (index < color.length && index >= 16)\n\t\t\tcolor[index] = 0xff000000 | red << 16 | green << 8 | blue;\n\t}\n\n\tpublic final void resetColors() {\n\t\tint[] defaults = manager.colordb.getDefaultColorsForScheme(HostDatabase.DEFAULT_COLOR_SCHEME);\n\t\tdefaultFg = defaults[0];\n\t\tdefaultBg = defaults[1];\n\n\t\tcolor = manager.colordb.getColorsForScheme(HostDatabase.DEFAULT_COLOR_SCHEME);\n\t}\n\n\tprivate static class PatternHolder {\n\t\tstatic {\n\t\t\t// based on http://www.ietf.org/rfc/rfc2396.txt\n\t\t\tString scheme = \"[A-Za-z][-+.0-9A-Za-z]*\";\n\t\t\tString unreserved = \"[-._~0-9A-Za-z]\";\n\t\t\tString pctEncoded = \"%[0-9A-Fa-f]{2}\";\n\t\t\tString subDelims = \"[!$&'()*+,;:=]\";\n\t\t\tString userinfo = \"(?:\" + unreserved + \"|\" + pctEncoded + \"|\" + subDelims + \"|:)*\";\n\t\t\tString h16 = \"[0-9A-Fa-f]{1,4}\";\n\t\t\tString decOctet = \"(?:[0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\";\n\t\t\tString ipv4address = decOctet + \"\\\\.\" + decOctet + \"\\\\.\" + decOctet + \"\\\\.\" + decOctet;\n\t\t\tString ls32 = \"(?:\" + h16 + \":\" + h16 + \"|\" + ipv4address + \")\";\n\t\t\tString ipv6address = \"(?:(?:\" + h16 + \"){6}\" + ls32 + \")\";\n\t\t\tString ipvfuture = \"v[0-9A-Fa-f]+.(?:\" + unreserved + \"|\" + subDelims + \"|:)+\";\n\t\t\tString ipLiteral = \"\\\\[(?:\" + ipv6address + \"|\" + ipvfuture + \")\\\\]\";\n\t\t\tString regName = \"(?:\" + unreserved + \"|\" + pctEncoded + \"|\" + subDelims + \")*\";\n\t\t\tString host = \"(?:\" + ipLiteral + \"|\" + ipv4address + \"|\" + regName + \")\";\n\t\t\tString port = \"[0-9]*\";\n\t\t\tString authority = \"(?:\" + userinfo + \"@)?\" + host + \"(?::\" + port + \")?\";\n\t\t\tString pchar = \"(?:\" + unreserved + \"|\" + pctEncoded + \"|\" + subDelims + \"|@)\";\n\t\t\tString segment = pchar + \"*\";\n\t\t\tString pathAbempty = \"(?:/\" + segment + \")*\";\n\t\t\tString segmentNz = pchar + \"+\";\n\t\t\tString pathAbsolute = \"/(?:\" + segmentNz + \"(?:/\" + segment + \")*)?\";\n\t\t\tString pathRootless = segmentNz + \"(?:/\" + segment + \")*\";\n\t\t\tString hierPart = \"(?://\" + authority + pathAbempty + \"|\" + pathAbsolute + \"|\" + pathRootless + \")\";\n\t\t\tString query = \"(?:\" + pchar + \"|/|\\\\?)*\";\n\t\t\tString fragment = \"(?:\" + pchar + \"|/|\\\\?)*\";\n\t\t\tString uriRegex = scheme + \":\" + hierPart + \"(?:\" + query + \")?(?:#\" + fragment + \")?\";\n\t\t\turlPattern = Pattern.compile(uriRegex);\n\t\t}\n\t\tprivate static final Pattern urlPattern;\n\t}\n\n\t/**\n\t * @return\n\t */\n\tpublic List<String> scanForURLs() {\n\t\tList<String> urls = new LinkedList<String>();\n\n\t\tchar[] visibleBuffer = new char[buffer.height * buffer.width];\n\t\tfor (int l = 0; l < buffer.height; l++)\n\t\t\tSystem.arraycopy(buffer.charArray[buffer.windowBase + l], 0,\n\t\t\t\t\tvisibleBuffer, l * buffer.width, buffer.width);\n\n\t\tMatcher urlMatcher = PatternHolder.urlPattern.matcher(new String(visibleBuffer));\n\t\twhile (urlMatcher.find())\n\t\t\turls.add(urlMatcher.group());\n\n\t\treturn urls;\n\t}\n\n\t/**\n\t * @return\n\t */\n\tpublic boolean isUsingNetwork() {\n\t\treturn transport.usesNetwork();\n\t}\n\n\t/**\n\t * @return\n\t */\n\tpublic TerminalKeyListener getKeyHandler() {\n\t\treturn keyListener;\n\t}\n\n\t/**\n\t *\n\t */\n\tpublic void resetScrollPosition() {\n\t\t// if we're in scrollback, scroll to bottom of window on input\n\t\tif (buffer.windowBase != buffer.screenBase)\n\t\t\tbuffer.setWindowBase(buffer.screenBase);\n\t}\n\n\t/**\n\t * Convenience function to increase the font size by a given step.\n\t */\n\tpublic void increaseFontSize() {\n\t\tsetFontSize(fontSizeDp + FONT_SIZE_STEP);\n\t}\n\n\t/**\n\t * Convenience function to decrease the font size by a given step.\n\t */\n\tpublic void decreaseFontSize() {\n\t\tsetFontSize(fontSizeDp - FONT_SIZE_STEP);\n\t}\n}\n","Method after Refactoring":"/*\n * ConnectBot: simple, powerful, open-source SSH client for Android\n * Copyright 2007 Kenny Root, Jeffrey Sharkey\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.connectbot.service;\n\nimport java.io.IOException;\nimport java.nio.charset.Charset;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.connectbot.R;\nimport org.connectbot.TerminalView;\nimport org.connectbot.bean.HostBean;\nimport org.connectbot.bean.PortForwardBean;\nimport org.connectbot.bean.SelectionArea;\nimport org.connectbot.transport.AbsTransport;\nimport org.connectbot.transport.TransportFactory;\nimport org.connectbot.util.HostDatabase;\n\nimport android.content.Context;\nimport android.graphics.Bitmap;\nimport android.graphics.Bitmap.Config;\nimport android.graphics.Canvas;\nimport android.graphics.Color;\nimport android.graphics.Paint;\nimport android.graphics.Paint.FontMetrics;\nimport android.graphics.Typeface;\nimport android.text.ClipboardManager;\nimport android.util.Log;\nimport de.mud.terminal.VDUBuffer;\nimport de.mud.terminal.VDUDisplay;\nimport de.mud.terminal.vt320;\n\n\n/**\n * Provides a bridge between a MUD terminal buffer and a possible TerminalView.\n * This separation allows us to keep the TerminalBridge running in a background\n * service. A TerminalView shares down a bitmap that we can use for rendering\n * when available.\n *\n * This class also provides SSH hostkey verification prompting, and password\n * prompting.\n */\n@SuppressWarnings(\"deprecation\") // for ClipboardManager\npublic class TerminalBridge implements VDUDisplay {\n\tpublic final static String TAG = \"CB.TerminalBridge\";\n\n\tprivate final static int DEFAULT_FONT_SIZE_DP = 10;\n\tprivate final static int FONT_SIZE_STEP = 2;\n\tprivate final float displayDensity;\n\n\tpublic int[] color;\n\n\tpublic int defaultFg = HostDatabase.DEFAULT_FG_COLOR;\n\tpublic int defaultBg = HostDatabase.DEFAULT_BG_COLOR;\n\n\tprotected final TerminalManager manager;\n\n\tpublic HostBean host;\n\n\t/* package */ AbsTransport transport;\n\n\tfinal Paint defaultPaint;\n\n\tprivate Relay relay;\n\n\tprivate final String emulation;\n\tprivate final int scrollback;\n\n\tpublic Bitmap bitmap = null;\n\tpublic VDUBuffer buffer = null;\n\n\tprivate TerminalView parent = null;\n\tprivate final Canvas canvas = new Canvas();\n\n\tprivate boolean disconnected = false;\n\tprivate boolean awaitingClose = false;\n\n\tprivate boolean forcedSize = false;\n\tprivate int columns;\n\tprivate int rows;\n\n\tprivate final TerminalKeyListener keyListener;\n\n\tprivate boolean selectingForCopy = false;\n\tprivate final SelectionArea selectionArea;\n\n\tpublic int charWidth = -1;\n\tpublic int charHeight = -1;\n\tprivate int charTop = -1;\n\n\tprivate float fontSizeDp = -1;\n\n\tprivate final List<FontSizeChangedListener> fontSizeChangedListeners;\n\n\tprivate final List<String> localOutput;\n\n\t/**\n\t * Flag indicating if we should perform a full-screen redraw during our next\n\t * rendering pass.\n\t */\n\tprivate boolean fullRedraw = false;\n\n\tpublic PromptHelper promptHelper;\n\n\tprivate BridgeDisconnectedListener disconnectListener = null;\n\n\t/**\n\t * Create a new terminal bridge suitable for unit testing.\n\t */\n\tpublic TerminalBridge() {\n\t\tbuffer = new vt320() {\n\t\t\t@Override\n\t\t\tpublic void write(byte[] b) {}\n\t\t\t@Override\n\t\t\tpublic void write(int b) {}\n\t\t\t@Override\n\t\t\tpublic void sendTelnetCommand(byte cmd) {}\n\t\t\t@Override\n\t\t\tpublic void setWindowSize(int c, int r) {}\n\t\t\t@Override\n\t\t\tpublic void debug(String s) {}\n\t\t};\n\n\t\temulation = null;\n\t\tmanager = null;\n\n\t\tdisplayDensity = 1f;\n\n\t\tdefaultPaint = new Paint();\n\n\t\tselectionArea = new SelectionArea();\n\t\tscrollback = 1;\n\n\t\tlocalOutput = new LinkedList<String>();\n\n\t\tfontSizeChangedListeners = new LinkedList<FontSizeChangedListener>();\n\n\t\ttransport = null;\n\n\t\tkeyListener = new TerminalKeyListener(null, this, buffer, null);\n\t}\n\n\t/**\n\t * Create new terminal bridge with following parameters. We will immediately\n\t * launch thread to start SSH connection and handle any hostkey verification\n\t * and password authentication.\n\t */\n\tpublic TerminalBridge(final TerminalManager manager, final HostBean host) throws IOException {\n\t\tthis.manager = manager;\n\t\tthis.host = host;\n\n\t\temulation = manager.getEmulation();\n\t\tscrollback = manager.getScrollback();\n\n\t\tthis.displayDensity = manager.getResources().getDisplayMetrics().density;\n\n\t\t// create prompt helper to relay password and hostkey requests up to gui\n\t\tpromptHelper = new PromptHelper(this);\n\n\t\t// create our default paint\n\t\tdefaultPaint = new Paint();\n\t\tdefaultPaint.setAntiAlias(true);\n\t\tdefaultPaint.setTypeface(Typeface.MONOSPACE);\n\t\tdefaultPaint.setFakeBoldText(true); // more readable?\n\n\t\tlocalOutput = new LinkedList<String>();\n\n\t\tfontSizeChangedListeners = new LinkedList<FontSizeChangedListener>();\n\n\t\tint hostFontSizeDp = host.getFontSize();\n\t\tif (hostFontSizeDp <= 0) {\n\t\t\thostFontSizeDp = DEFAULT_FONT_SIZE_DP;\n\t\t}\n\t\tsetFontSize(hostFontSizeDp);\n\n\t\t// create terminal buffer and handle outgoing data\n\t\t// this is probably status reply information\n\t\tbuffer = new vt320() {\n\t\t\t@Override\n\t\t\tpublic void debug(String s) {\n\t\t\t\tLog.d(TAG, s);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void write(byte[] b) {\n\t\t\t\ttry {\n\t\t\t\t\tif (b != null && transport != null)\n\t\t\t\t\t\ttransport.write(b);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tLog.e(TAG, \"Problem writing outgoing data in vt320() thread\", e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void write(int b) {\n\t\t\t\ttry {\n\t\t\t\t\tif (transport != null)\n\t\t\t\t\t\ttransport.write(b);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tLog.e(TAG, \"Problem writing outgoing data in vt320() thread\", e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// We don't use telnet sequences.\n\t\t\t@Override\n\t\t\tpublic void sendTelnetCommand(byte cmd) {\n\t\t\t}\n\n\t\t\t// We don't want remote to resize our window.\n\t\t\t@Override\n\t\t\tpublic void setWindowSize(int c, int r) {\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void beep() {\n\t\t\t\tif (parent.isShown())\n\t\t\t\t\tmanager.playBeep();\n\t\t\t\telse\n\t\t\t\t\tmanager.sendActivityNotification(host);\n\t\t\t}\n\t\t};\n\n\t\t// Don't keep any scrollback if a session is not being opened.\n\t\tif (host.getWantSession())\n\t\t\tbuffer.setBufferSize(scrollback);\n\t\telse\n\t\t\tbuffer.setBufferSize(0);\n\n\t\tresetColors();\n\t\tbuffer.setDisplay(this);\n\n\t\tselectionArea = new SelectionArea();\n\n\t\tkeyListener = new TerminalKeyListener(manager, this, buffer, host.getEncoding());\n\t}\n\n\tpublic PromptHelper getPromptHelper() {\n\t\treturn promptHelper;\n\t}\n\n\t/**\n\t * Spawn thread to open connection and start login process.\n\t */\n\tprotected void startConnection() {\n\t\ttransport = TransportFactory.getTransport(host.getProtocol());\n\t\tif (transport == null) {\n\t\t\tLog.i(TAG, \"No transport found for \" + host.getProtocol());\n\t\t\treturn;\n\t\t}\n\n\t\ttransport.setBridge(this);\n\t\ttransport.setManager(manager);\n\t\ttransport.setHost(host);\n\n\t\t// TODO make this more abstract so we don't litter on AbsTransport\n\t\ttransport.setCompression(host.getCompression());\n\t\ttransport.setUseAuthAgent(host.getUseAuthAgent());\n\t\ttransport.setEmulation(emulation);\n\n\t\tif (transport.canForwardPorts()) {\n\t\t\tfor (PortForwardBean portForward : manager.hostdb.getPortForwardsForHost(host))\n\t\t\t\ttransport.addPortForward(portForward);\n\t\t}\n\n\t\toutputLine(manager.res.getString(R.string.terminal_connecting, host.getHostname(), host.getPort(), host.getProtocol()));\n\n\t\tThread connectionThread = new Thread(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\ttransport.connect();\n\t\t\t}\n\t\t});\n\t\tconnectionThread.setName(\"Connection\");\n\t\tconnectionThread.setDaemon(true);\n\t\tconnectionThread.start();\n\t}\n\n\t/**\n\t * @return charset in use by bridge\n\t */\n\tpublic Charset getCharset() {\n\t\treturn relay.getCharset();\n\t}\n\n\t/**\n\t * Sets the encoding used by the terminal. If the connection is live,\n\t * then the character set is changed for the next read.\n\t * @param encoding the canonical name of the character encoding\n\t */\n\tpublic void setCharset(String encoding) {\n\t\tif (relay != null)\n\t\t\trelay.setCharset(encoding);\n\t\tkeyListener.setCharset(encoding);\n\t}\n\n\t/**\n\t * Convenience method for writing text into the underlying terminal buffer.\n\t * Should never be called once the session is established.\n\t */\n\tpublic final void outputLine(String output) {\n\t\tif (transport != null && transport.isSessionOpen()) {\n\t\t\tLog.e(TAG, \"Session established, cannot use outputLine!\",\n\t\t\t\t\tnew IOException(\"outputLine call traceback\"));\n\t\t}\n\n\t\tsynchronized (localOutput) {\n\t\t\tfor (String line : output.split(\"\\n\")) {\n\t\t\t\tif (line.length() > 0 && line.charAt(line.length() - 1) == '\\r') {\n\t\t\t\t\tline = line.substring(0, line.length() - 1);\n\t\t\t\t}\n\n\t\t\t\tfinal String s = line + \"\\r\\n\";\n\n\t\t\t\tlocalOutput.add(s);\n\n\t\t\t\t((vt320) buffer).putString(s);\n\n\t\t\t\t// For accessibility\n\t\t\t\tfinal char[] charArray = s.toCharArray();\n\t\t\t\tpropagateConsoleText(charArray, charArray.length);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Only intended for pre-Honeycomb devices.\n\t */\n\tpublic void setSelectingForCopy(boolean selectingForCopy) {\n\t\tthis.selectingForCopy = selectingForCopy;\n\t}\n\n\t/**\n\t * Only intended for pre-Honeycomb devices.\n\t */\n\tpublic boolean isSelectingForCopy() {\n\t\treturn selectingForCopy;\n\t}\n\n\t/**\n\t * Only intended for pre-Honeycomb devices.\n\t */\n\tpublic SelectionArea getSelectionArea() {\n\t\treturn selectionArea;\n\t}\n\n\tpublic void copyCurrentSelection() {\n\t\tif (parent != null) {\n\t\t\tparent.copyCurrentSelectionToClipboard();\n\t\t}\n\t}\n\n\t/**\n\t * Inject a specific string into this terminal. Used for post-login strings\n\t * and pasting clipboard.\n\t */\n\tpublic void injectString(final String string) {\n\t\tif (string == null || string.length() == 0)\n\t\t\treturn;\n\n\t\tThread injectStringThread = new Thread(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\ttransport.write(string.getBytes(host.getEncoding()));\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tLog.e(TAG, \"Couldn't inject string to remote host: \", e);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tinjectStringThread.setName(\"InjectString\");\n\t\tinjectStringThread.start();\n\t}\n\n\t/**\n\t * Internal method to request actual PTY terminal once we've finished\n\t * authentication. If called before authenticated, it will just fail.\n\t */\n\tpublic void onConnected() {\n\t\tdisconnected = false;\n\n\t\t((vt320) buffer).reset();\n\n\t\t// We no longer need our local output.\n\t\tlocalOutput.clear();\n\n\t\t// previously tried vt100 and xterm for emulation modes\n\t\t// \"screen\" works the best for color and escape codes\n\t\t((vt320) buffer).setAnswerBack(emulation);\n\n\t\tif (HostDatabase.DELKEY_BACKSPACE.equals(host.getDelKey()))\n\t\t\t((vt320) buffer).setBackspace(vt320.DELETE_IS_BACKSPACE);\n\t\telse\n\t\t\t((vt320) buffer).setBackspace(vt320.DELETE_IS_DEL);\n\n\t\tif (isSessionOpen()) {\n\t\t\t// create thread to relay incoming connection data to buffer\n\t\t\trelay = new Relay(this, transport, (vt320) buffer, host.getEncoding());\n\t\t\tThread relayThread = new Thread(relay);\n\t\t\trelayThread.setDaemon(true);\n\t\t\trelayThread.setName(\"Relay\");\n\t\t\trelayThread.start();\n\t\t}\n\n\t\t// force font-size to make sure we resizePTY as needed\n\t\tsetFontSize(fontSizeDp);\n\n\t\t// finally send any post-login string, if requested\n\t\tinjectString(host.getPostLogin());\n\t}\n\n\t/**\n\t * @return whether a session is open or not\n\t */\n\tpublic boolean isSessionOpen() {\n\t\tif (transport != null)\n\t\t\treturn transport.isSessionOpen();\n\t\treturn false;\n\t}\n\n\tpublic void setOnDisconnectedListener(BridgeDisconnectedListener disconnectListener) {\n\t\tthis.disconnectListener = disconnectListener;\n\t}\n\n\t/**\n\t * Force disconnection of this terminal bridge.\n\t */\n\tpublic void dispatchDisconnect(boolean immediate) {\n\t\t// We don't need to do this multiple times.\n\t\tsynchronized (this) {\n\t\t\tif (disconnected && !immediate)\n\t\t\t\treturn;\n\n\t\t\tdisconnected = true;\n\t\t}\n\n\t\t// Cancel any pending prompts.\n\t\tpromptHelper.cancelPrompt();\n\n\t\t// disconnection request hangs if we havent really connected to a host yet\n\t\t// temporary fix is to just spawn disconnection into a thread\n\t\tThread disconnectThread = new Thread(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tif (transport != null && transport.isConnected())\n\t\t\t\t\ttransport.close();\n\t\t\t}\n\t\t});\n\t\tdisconnectThread.setName(\"Disconnect\");\n\t\tdisconnectThread.start();\n\n\t\tif (immediate || (host.getQuickDisconnect() && !host.getStayConnected())) {\n\t\t\tawaitingClose = true;\n\t\t\ttriggerDisconnectListener();\n\t\t} else {\n\t\t\t{\n\t\t\t\tfinal String line = manager.res.getString(R.string.alert_disconnect_msg);\n\t\t\t\t((vt320) buffer).putString(\"\\r\\n\" + line + \"\\r\\n\");\n\t\t\t}\n\t\t\tif (host.getStayConnected()) {\n\t\t\t\tmanager.requestReconnect(this);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tThread disconnectPromptThread = new Thread(new Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tBoolean result = promptHelper.requestBooleanPrompt(null,\n\t\t\t\t\t\t\tmanager.res.getString(R.string.prompt_host_disconnected));\n\t\t\t\t\tif (result == null || result.booleanValue()) {\n\t\t\t\t\t\tawaitingClose = true;\n\t\t\t\t\t\ttriggerDisconnectListener();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\tdisconnectPromptThread.setName(\"DisconnectPrompt\");\n\t\t\tdisconnectPromptThread.setDaemon(true);\n\t\t\tdisconnectPromptThread.start();\n\t\t}\n\t}\n\n\t/**\n\t * Tells the TerminalManager that we can be destroyed now.\n\t */\n\tprivate void triggerDisconnectListener() {\n\t\tif (disconnectListener != null) {\n\t\t\t// The disconnect listener should be run on the main thread if possible.\n\t\t\tif (parent != null) {\n\t\t\t\tparent.post(new Runnable() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\tdisconnectListener.onDisconnected(TerminalBridge.this);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tdisconnectListener.onDisconnected(TerminalBridge.this);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic synchronized void tryKeyVibrate() {\n\t\tmanager.tryKeyVibrate();\n\t}\n\n\t/**\n\t * Request a different font size. Will make call to parentChanged() to make\n\t * sure we resize PTY if needed.\n\t *\n\t * @param sizeDp Size of font in dp\n\t */\n\tprivate final void setFontSize(float sizeDp) {\n\t\tif (sizeDp <= 0.0) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal int fontSizePx = (int) (sizeDp * this.displayDensity + 0.5f);\n\n\t\tdefaultPaint.setTextSize(fontSizePx);\n\t\tfontSizeDp = sizeDp;\n\n\t\t// read new metrics to get exact pixel dimensions\n\t\tFontMetrics fm = defaultPaint.getFontMetrics();\n\t\tcharTop = (int) Math.ceil(fm.top);\n\n\t\tfloat[] widths = new float[1];\n\t\tdefaultPaint.getTextWidths(\"X\", widths);\n\t\tcharWidth = (int) Math.ceil(widths[0]);\n\t\tcharHeight = (int) Math.ceil(fm.descent - fm.top);\n\n\t\t// refresh any bitmap with new font size\n\t\tif (parent != null) {\n\t\t\tparentChanged(parent);\n\t\t}\n\n\t\tfor (FontSizeChangedListener ofscl : fontSizeChangedListeners) {\n\t\t\tofscl.onFontSizeChanged(sizeDp);\n\t\t}\n\n\t\thost.setFontSize((int) sizeDp);\n\t\tmanager.hostdb.saveHost(host);\n\n\t\tforcedSize = false;\n\t}\n\n\tpublic float getFontSize() {\n\t\treturn fontSizeDp;\n\t}\n\n\t/**\n\t * Add an {@link FontSizeChangedListener} to the list of listeners for this\n\t * bridge.\n\t *\n\t * @param listener\n\t *            listener to add\n\t */\n\tpublic void addFontSizeChangedListener(FontSizeChangedListener listener) {\n\t\tfontSizeChangedListeners.add(listener);\n\t}\n\n\t/**\n\t * Remove an {@link FontSizeChangedListener} from the list of listeners for\n\t * this bridge.\n\t *\n\t * @param listener\n\t */\n\tpublic void removeFontSizeChangedListener(FontSizeChangedListener listener) {\n\t\tfontSizeChangedListeners.remove(listener);\n\t}\n\n\t/**\n\t * Something changed in our parent {@link TerminalView}, maybe it's a new\n\t * parent, or maybe it's an updated font size. We should recalculate\n\t * terminal size information and request a PTY resize.\n\t */\n\tpublic final synchronized void parentChanged(TerminalView parent) {\n\t\tif (manager != null && !manager.isResizeAllowed()) {\n\t\t\tLog.d(TAG, \"Resize is not allowed now\");\n\t\t\treturn;\n\t\t}\n\n\t\tthis.parent = parent;\n\t\tfinal int width = parent.getWidth();\n\t\tfinal int height = parent.getHeight();\n\n\t\t// Something has gone wrong with our layout; we're 0 width or height!\n\t\tif (width <= 0 || height <= 0)\n\t\t\treturn;\n\n\t\tClipboardManager clipboard = (ClipboardManager) parent.getContext().getSystemService(Context.CLIPBOARD_SERVICE);\n\t\tkeyListener.setClipboardManager(clipboard);\n\n\t\tif (!forcedSize) {\n\t\t\t// recalculate buffer size\n\t\t\tint newColumns, newRows;\n\n\t\t\tnewColumns = width / charWidth;\n\t\t\tnewRows = height / charHeight;\n\n\t\t\t// If nothing has changed in the terminal dimensions and not an intial\n\t\t\t// draw then don't blow away scroll regions and such.\n\t\t\tif (newColumns == columns && newRows == rows)\n\t\t\t\treturn;\n\n\t\t\tcolumns = newColumns;\n\t\t\trows = newRows;\n\t\t}\n\n\t\t// reallocate new bitmap if needed\n\t\tboolean newBitmap = (bitmap == null);\n\t\tif (bitmap != null)\n\t\t\tnewBitmap = (bitmap.getWidth() != width || bitmap.getHeight() != height);\n\n\t\tif (newBitmap) {\n\t\t\tdiscardBitmap();\n\t\t\tbitmap = Bitmap.createBitmap(width, height, Config.ARGB_8888);\n\t\t\tcanvas.setBitmap(bitmap);\n\t\t}\n\n\t\t// clear out any old buffer information\n\t\tdefaultPaint.setColor(Color.BLACK);\n\t\tcanvas.drawPaint(defaultPaint);\n\n\t\t// Stroke the border of the terminal if the size is being forced;\n\t\tif (forcedSize) {\n\t\t\tint borderX = (columns * charWidth) + 1;\n\t\t\tint borderY = (rows * charHeight) + 1;\n\n\t\t\tdefaultPaint.setColor(Color.GRAY);\n\t\t\tdefaultPaint.setStrokeWidth(0.0f);\n\t\t\tif (width >= borderX)\n\t\t\t\tcanvas.drawLine(borderX, 0, borderX, borderY + 1, defaultPaint);\n\t\t\tif (height >= borderY)\n\t\t\t\tcanvas.drawLine(0, borderY, borderX + 1, borderY, defaultPaint);\n\t\t}\n\n\t\ttry {\n\t\t\t// request a terminal pty resize\n\t\t\tsynchronized (buffer) {\n\t\t\t\tbuffer.setScreenSize(columns, rows, true);\n\t\t\t}\n\n\t\t\tif (transport != null)\n\t\t\t\ttransport.setDimensions(columns, rows, width, height);\n\t\t} catch (Exception e) {\n\t\t\tLog.e(TAG, \"Problem while trying to resize screen or PTY\", e);\n\t\t}\n\n\t\t// redraw local output if we don't have a sesson to receive our resize request\n\t\tif (transport == null) {\n\t\t\tsynchronized (localOutput) {\n\t\t\t\t((vt320) buffer).reset();\n\n\t\t\t\tfor (String line : localOutput)\n\t\t\t\t\t((vt320) buffer).putString(line);\n\t\t\t}\n\t\t}\n\n\t\t// force full redraw with new buffer size\n\t\tfullRedraw = true;\n\t\tredraw();\n\n\t\tparent.notifyUser(String.format(\"%d x %d\", columns, rows));\n\n\t\tLog.i(TAG, String.format(\"parentChanged() now width=%d, height=%d\", columns, rows));\n\t}\n\n\t/**\n\t * Somehow our parent {@link TerminalView} was destroyed. Now we don't need\n\t * to redraw anywhere, and we can recycle our internal bitmap.\n\t */\n\tpublic synchronized void parentDestroyed() {\n\t\tparent = null;\n\t\tdiscardBitmap();\n\t}\n\n\tprivate void discardBitmap() {\n\t\tif (bitmap != null)\n\t\t\tbitmap.recycle();\n\t\tbitmap = null;\n\t}\n\n\tpublic void setVDUBuffer(VDUBuffer buffer) {\n\t\tthis.buffer = buffer;\n\t}\n\n\tpublic VDUBuffer getVDUBuffer() {\n\t\treturn buffer;\n\t}\n\n\tpublic void propagateConsoleText(char[] rawText, int length) {\n\t\tif (parent != null) {\n\t\t\tparent.propagateConsoleText(rawText, length);\n\t\t}\n\t}\n\n\tpublic void onDraw() {\n\t\tint fg, bg;\n\t\tsynchronized (buffer) {\n\t\t\tboolean entireDirty = buffer.update[0] || fullRedraw;\n\t\t\tboolean isWideCharacter = false;\n\n\t\t\t// walk through all lines in the buffer\n\t\t\tfor (int l = 0; l < buffer.height; l++) {\n\n\t\t\t\t// check if this line is dirty and needs to be repainted\n\t\t\t\t// also check for entire-buffer dirty flags\n\t\t\t\tif (!entireDirty && !buffer.update[l + 1]) continue;\n\n\t\t\t\t// reset dirty flag for this line\n\t\t\t\tbuffer.update[l + 1] = false;\n\n\t\t\t\t// walk through all characters in this line\n\t\t\t\tfor (int c = 0; c < buffer.width; c++) {\n\t\t\t\t\tint addr = 0;\n\t\t\t\t\tlong currAttr = buffer.charAttributes[buffer.windowBase + l][c];\n\n\t\t\t\t\t{\n\t\t\t\t\t\tint fgcolor = defaultFg;\n\t\t\t\t\t\tint bgcolor = defaultBg;\n\n\t\t\t\t\t\t// check if foreground color attribute is set\n\t\t\t\t\t\tif ((currAttr & VDUBuffer.COLOR_FG) != 0)\n\t\t\t\t\t\t\tfgcolor = (int) ((currAttr & VDUBuffer.COLOR_FG) >> VDUBuffer.COLOR_FG_SHIFT) - 1;\n\n\t\t\t\t\t\tif (fgcolor < 8 && (currAttr & VDUBuffer.BOLD) != 0)\n\t\t\t\t\t\t\tfg = color[fgcolor + 8];\n\t\t\t\t\t\telse if (fgcolor < 256)\n\t\t\t\t\t\t\tfg = color[fgcolor];\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tfg = 0xff000000 | (fgcolor - 256);\n\n\t\t\t\t\t\t// check if background color attribute is set\n\t\t\t\t\t\tif ((currAttr & VDUBuffer.COLOR_BG) != 0)\n\t\t\t\t\t\t\tbgcolor = (int) ((currAttr & VDUBuffer.COLOR_BG) >> VDUBuffer.COLOR_BG_SHIFT) - 1;\n\n\t\t\t\t\t\tif (bgcolor < 256)\n\t\t\t\t\t\t\tbg = color[bgcolor];\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tbg = 0xff000000 | (bgcolor - 256);\n\t\t\t\t\t}\n\n\t\t\t\t\t// support character inversion by swapping background and foreground color\n\t\t\t\t\tif ((currAttr & VDUBuffer.INVERT) != 0) {\n\t\t\t\t\t\tint swapc = bg;\n\t\t\t\t\t\tbg = fg;\n\t\t\t\t\t\tfg = swapc;\n\t\t\t\t\t}\n\n\t\t\t\t\t// set underlined attributes if requested\n\t\t\t\t\tdefaultPaint.setUnderlineText((currAttr & VDUBuffer.UNDERLINE) != 0);\n\n\t\t\t\t\tisWideCharacter = (currAttr & VDUBuffer.FULLWIDTH) != 0;\n\n\t\t\t\t\tif (isWideCharacter)\n\t\t\t\t\t\taddr++;\n\t\t\t\t\telse {\n\t\t\t\t\t\t// determine the amount of continuous characters with the same settings and print them all at once\n\t\t\t\t\t\twhile (c + addr < buffer.width\n\t\t\t\t\t\t\t\t&& buffer.charAttributes[buffer.windowBase + l][c + addr] == currAttr) {\n\t\t\t\t\t\t\taddr++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Save the current clip region\n\t\t\t\t\tcanvas.save(Canvas.CLIP_SAVE_FLAG);\n\n\t\t\t\t\t// clear this dirty area with background color\n\t\t\t\t\tdefaultPaint.setColor(bg);\n\t\t\t\t\tif (isWideCharacter) {\n\t\t\t\t\t\tcanvas.clipRect(c * charWidth,\n\t\t\t\t\t\t\t\tl * charHeight,\n\t\t\t\t\t\t\t\t(c + 2) * charWidth,\n\t\t\t\t\t\t\t\t(l + 1) * charHeight);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcanvas.clipRect(c * charWidth,\n\t\t\t\t\t\t\t\tl * charHeight,\n\t\t\t\t\t\t\t\t(c + addr) * charWidth,\n\t\t\t\t\t\t\t\t(l + 1) * charHeight);\n\t\t\t\t\t}\n\t\t\t\t\tcanvas.drawPaint(defaultPaint);\n\n\t\t\t\t\t// write the text string starting at 'c' for 'addr' number of characters\n\t\t\t\t\tdefaultPaint.setColor(fg);\n\t\t\t\t\tif ((currAttr & VDUBuffer.INVISIBLE) == 0)\n\t\t\t\t\t\tcanvas.drawText(buffer.charArray[buffer.windowBase + l], c,\n\t\t\t\t\t\t\taddr, c * charWidth, (l * charHeight) - charTop,\n\t\t\t\t\t\t\tdefaultPaint);\n\n\t\t\t\t\t// Restore the previous clip region\n\t\t\t\t\tcanvas.restore();\n\n\t\t\t\t\t// advance to the next text block with different characteristics\n\t\t\t\t\tc += addr - 1;\n\t\t\t\t\tif (isWideCharacter)\n\t\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// reset entire-buffer flags\n\t\t\tbuffer.update[0] = false;\n\t\t}\n\t\tfullRedraw = false;\n\t}\n\n\tpublic void redraw() {\n\t\tif (parent != null)\n\t\t\tparent.postInvalidate();\n\t}\n\n\t// We don't have a scroll bar.\n\tpublic void updateScrollBar() {\n\t}\n\n\t/**\n\t * Resize terminal to fit [rows]x[cols] in screen of size [width]x[height]\n\t *\n\t * @param rows desired number of text rows\n\t * @param cols desired numbor of text colums\n\t * @param width width of screen in pixels\n\t * @param height height of screen in pixels\n\t */\n\tpublic synchronized void resizeComputed(int cols, int rows, int width, int height) {\n\t\tfloat sizeDp = 8.0f;\n\t\tfloat step = 8.0f;\n\t\tfloat limit = 0.125f;\n\n\t\tint direction;\n\n\t\twhile ((direction = fontSizeCompare(sizeDp, cols, rows, width, height)) < 0)\n\t\t\tsizeDp += step;\n\n\t\tif (direction == 0) {\n\t\t\tLog.d(\"fontsize\", String.format(\"Found match at %f\", sizeDp));\n\t\t\treturn;\n\t\t}\n\n\t\tstep /= 2.0f;\n\t\tsizeDp -= step;\n\n\t\twhile ((direction = fontSizeCompare(sizeDp, cols, rows, width, height)) != 0\n\t\t\t\t&& step >= limit) {\n\t\t\tstep /= 2.0f;\n\t\t\tif (direction > 0) {\n\t\t\t\tsizeDp -= step;\n\t\t\t} else {\n\t\t\t\tsizeDp += step;\n\t\t\t}\n\t\t}\n\n\t\tif (direction > 0)\n\t\t\tsizeDp -= step;\n\n\t\tthis.columns = cols;\n\t\tthis.rows = rows;\n\t\tsetFontSize(sizeDp);\n\t\tforcedSize = true;\n\t}\n\n\tprivate int fontSizeCompare(float sizeDp, int cols, int rows, int width, int height) {\n\t\t// read new metrics to get exact pixel dimensions\n\t\tdefaultPaint.setTextSize((int) (sizeDp * this.displayDensity + 0.5f));\n\t\tFontMetrics fm = defaultPaint.getFontMetrics();\n\n\t\tfloat[] widths = new float[1];\n\t\tdefaultPaint.getTextWidths(\"X\", widths);\n\t\tint termWidth = (int) widths[0] * cols;\n\t\tint termHeight = (int) Math.ceil(fm.descent - fm.top) * rows;\n\n\t\tLog.d(\"fontsize\", String.format(\"font size %fdp resulted in %d x %d\", sizeDp, termWidth, termHeight));\n\n\t\t// Check to see if it fits in resolution specified.\n\t\tif (termWidth > width || termHeight > height)\n\t\t\treturn 1;\n\n\t\tif (termWidth == width || termHeight == height)\n\t\t\treturn 0;\n\n\t\treturn -1;\n\t}\n\n\t/**\n\t * @return whether underlying transport can forward ports\n\t */\n\tpublic boolean canFowardPorts() {\n\t\treturn transport.canForwardPorts();\n\t}\n\n\t/**\n\t * Adds the {@link PortForwardBean} to the list.\n\t * @param portForward the port forward bean to add\n\t * @return true on successful addition\n\t */\n\tpublic boolean addPortForward(PortForwardBean portForward) {\n\t\treturn transport.addPortForward(portForward);\n\t}\n\n\t/**\n\t * Removes the {@link PortForwardBean} from the list.\n\t * @param portForward the port forward bean to remove\n\t * @return true on successful removal\n\t */\n\tpublic boolean removePortForward(PortForwardBean portForward) {\n\t\treturn transport.removePortForward(portForward);\n\t}\n\n\t/**\n\t * @return the list of port forwards\n\t */\n\tpublic List<PortForwardBean> getPortForwards() {\n\t\treturn transport.getPortForwards();\n\t}\n\n\t/**\n\t * Enables a port forward member. After calling this method, the port forward should\n\t * be operational.\n\t * @param portForward member of our current port forwards list to enable\n\t * @return true on successful port forward setup\n\t */\n\tpublic boolean enablePortForward(PortForwardBean portForward) {\n\t\tif (!transport.isConnected()) {\n\t\t\tLog.i(TAG, \"Attempt to enable port forward while not connected\");\n\t\t\treturn false;\n\t\t}\n\n\t\treturn transport.enablePortForward(portForward);\n\t}\n\n\t/**\n\t * Disables a port forward member. After calling this method, the port forward should\n\t * be non-functioning.\n\t * @param portForward member of our current port forwards list to enable\n\t * @return true on successful port forward tear-down\n\t */\n\tpublic boolean disablePortForward(PortForwardBean portForward) {\n\t\tif (!transport.isConnected()) {\n\t\t\tLog.i(TAG, \"Attempt to disable port forward while not connected\");\n\t\t\treturn false;\n\t\t}\n\n\t\treturn transport.disablePortForward(portForward);\n\t}\n\n\t/**\n\t * @return whether the TerminalBridge should close\n\t */\n\tpublic boolean isAwaitingClose() {\n\t\treturn awaitingClose;\n\t}\n\n\t/**\n\t * @return whether this connection had started and subsequently disconnected\n\t */\n\tpublic boolean isDisconnected() {\n\t\treturn disconnected;\n\t}\n\n\t/* (non-Javadoc)\n\t * @see de.mud.terminal.VDUDisplay#setColor(byte, byte, byte, byte)\n\t */\n\tpublic void setColor(int index, int red, int green, int blue) {\n\t\t// Don't allow the system colors to be overwritten for now. May violate specs.\n\t\tif (index < color.length && index >= 16)\n\t\t\tcolor[index] = 0xff000000 | red << 16 | green << 8 | blue;\n\t}\n\n\tpublic final void resetColors() {\n\t\tint[] defaults = manager.colordb.getDefaultColorsForScheme(HostDatabase.DEFAULT_COLOR_SCHEME);\n\t\tdefaultFg = defaults[0];\n\t\tdefaultBg = defaults[1];\n\n\t\tcolor = manager.colordb.getColorsForScheme(HostDatabase.DEFAULT_COLOR_SCHEME);\n\t}\n\n\tprivate static class PatternHolder {\n\t\tstatic {\n\t\t\t// based on http://www.ietf.org/rfc/rfc2396.txt\n\t\t\tString scheme = \"[A-Za-z][-+.0-9A-Za-z]*\";\n\t\t\tString unreserved = \"[-._~0-9A-Za-z]\";\n\t\t\tString pctEncoded = \"%[0-9A-Fa-f]{2}\";\n\t\t\tString subDelims = \"[!$&'()*+,;:=]\";\n\t\t\tString userinfo = \"(?:\" + unreserved + \"|\" + pctEncoded + \"|\" + subDelims + \"|:)*\";\n\t\t\tString h16 = \"[0-9A-Fa-f]{1,4}\";\n\t\t\tString decOctet = \"(?:[0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\";\n\t\t\tString ipv4address = decOctet + \"\\\\.\" + decOctet + \"\\\\.\" + decOctet + \"\\\\.\" + decOctet;\n\t\t\tString ls32 = \"(?:\" + h16 + \":\" + h16 + \"|\" + ipv4address + \")\";\n\t\t\tString ipv6address = \"(?:(?:\" + h16 + \"){6}\" + ls32 + \")\";\n\t\t\tString ipvfuture = \"v[0-9A-Fa-f]+.(?:\" + unreserved + \"|\" + subDelims + \"|:)+\";\n\t\t\tString ipLiteral = \"\\\\[(?:\" + ipv6address + \"|\" + ipvfuture + \")\\\\]\";\n\t\t\tString regName = \"(?:\" + unreserved + \"|\" + pctEncoded + \"|\" + subDelims + \")*\";\n\t\t\tString host = \"(?:\" + ipLiteral + \"|\" + ipv4address + \"|\" + regName + \")\";\n\t\t\tString port = \"[0-9]*\";\n\t\t\tString authority = \"(?:\" + userinfo + \"@)?\" + host + \"(?::\" + port + \")?\";\n\t\t\tString pchar = \"(?:\" + unreserved + \"|\" + pctEncoded + \"|\" + subDelims + \"|@)\";\n\t\t\tString segment = pchar + \"*\";\n\t\t\tString pathAbempty = \"(?:/\" + segment + \")*\";\n\t\t\tString segmentNz = pchar + \"+\";\n\t\t\tString pathAbsolute = \"/(?:\" + segmentNz + \"(?:/\" + segment + \")*)?\";\n\t\t\tString pathRootless = segmentNz + \"(?:/\" + segment + \")*\";\n\t\t\tString hierPart = \"(?://\" + authority + pathAbempty + \"|\" + pathAbsolute + \"|\" + pathRootless + \")\";\n\t\t\tString query = \"(?:\" + pchar + \"|/|\\\\?)*\";\n\t\t\tString fragment = \"(?:\" + pchar + \"|/|\\\\?)*\";\n\t\t\tString uriRegex = scheme + \":\" + hierPart + \"(?:\" + query + \")?(?:#\" + fragment + \")?\";\n\t\t\turlPattern = Pattern.compile(uriRegex);\n\t\t}\n\t\tprivate static final Pattern urlPattern;\n\t}\n\n\t/**\n\t * @return\n\t */\n\tpublic List<String> scanForURLs() {\n\t\tList<String> urls = new LinkedList<String>();\n\n\t\tchar[] visibleBuffer = new char[buffer.height * buffer.width];\n\t\tfor (int l = 0; l < buffer.height; l++)\n\t\t\tSystem.arraycopy(buffer.charArray[buffer.windowBase + l], 0,\n\t\t\t\t\tvisibleBuffer, l * buffer.width, buffer.width);\n\n\t\tMatcher urlMatcher = PatternHolder.urlPattern.matcher(new String(visibleBuffer));\n\t\twhile (urlMatcher.find())\n\t\t\turls.add(urlMatcher.group());\n\n\t\treturn urls;\n\t}\n\n\t/**\n\t * @return\n\t */\n\tpublic boolean isUsingNetwork() {\n\t\treturn transport.usesNetwork();\n\t}\n\n\t/**\n\t * @return\n\t */\n\tpublic TerminalKeyListener getKeyHandler() {\n\t\treturn keyListener;\n\t}\n\n\t/**\n\t *\n\t */\n\tpublic void resetScrollPosition() {\n\t\t// if we're in scrollback, scroll to bottom of window on input\n\t\tif (buffer.windowBase != buffer.screenBase)\n\t\t\tbuffer.setWindowBase(buffer.screenBase);\n\t}\n\n\t/**\n\t * Convenience function to increase the font size by a given step.\n\t */\n\tpublic void increaseFontSize() {\n\t\tsetFontSize(fontSizeDp + FONT_SIZE_STEP);\n\t}\n\n\t/**\n\t * Convenience function to decrease the font size by a given step.\n\t */\n\tpublic void decreaseFontSize() {\n\t\tsetFontSize(fontSizeDp - FONT_SIZE_STEP);\n\t}\n}\n","lineNo":730}
{"Smelly Sample":"/*\n * ConnectBot: simple, powerful, open-source SSH client for Android\n * Copyright 2015 Kenny Root, Jeffrey Sharkey\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.connectbot;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.Map;\n\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.res.TypedArray;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Parcelable;\nimport android.support.design.widget.TextInputLayout;\nimport android.support.v4.app.Fragment;\nimport android.support.v7.widget.PopupMenu;\nimport android.text.Editable;\nimport android.text.TextWatcher;\nimport android.view.LayoutInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.CompoundButton;\nimport android.widget.EditText;\nimport android.widget.ImageButton;\nimport android.widget.SeekBar;\nimport android.widget.TextView;\n\nimport org.connectbot.bean.HostBean;\nimport org.connectbot.transport.SSH;\nimport org.connectbot.transport.Telnet;\nimport org.connectbot.transport.TransportFactory;\nimport org.connectbot.util.HostDatabase;\nimport org.connectbot.views.CheckableMenuItem;\n\npublic class HostEditorFragment extends Fragment {\n\n\tprivate static final String ARG_EXISTING_HOST_ID = \"existingHostId\";\n\tprivate static final String ARG_EXISTING_HOST = \"existingHost\";\n\tprivate static final String ARG_IS_EXPANDED = \"isExpanded\";\n\tprivate static final String ARG_PUBKEY_NAMES = \"pubkeyNames\";\n\tprivate static final String ARG_PUBKEY_VALUES = \"pubkeyValues\";\n\tprivate static final String ARG_QUICKCONNECT_STRING = \"quickConnectString\";\n\n\t// Note: The \"max\" value for mFontSizeSeekBar is 32. If these font values change, this value\n\t// must be changed in the SeekBar's XML.\n\tprivate static final int MINIMUM_FONT_SIZE = 8;\n\tprivate static final int MAXIMUM_FONT_SIZE = 40;\n\n\t// The host being edited.\n\tprivate HostBean mHost;\n\n\t// The pubkey lists (names and values). Note that these are declared as ArrayLists rather than\n\t// Lists because Bundles can only contain ArrayLists, not general Lists.\n\tprivate ArrayList<String> mPubkeyNames;\n\tprivate ArrayList<String> mPubkeyValues;\n\n\t// The listener for changes to this host.\n\tprivate Listener mListener;\n\n\t// Whether the URI parts subsection is expanded.\n\tprivate boolean mIsUriEditorExpanded = false;\n\n\t// Whether a URI text edit is in progress. When the quick-connect field is being edited, changes\n\t// automatically propagate to the URI part fields; likewise, when the URI part fields are\n\t// edited, changes are propagated to the quick-connect field. This boolean safeguards against\n\t// infinite loops which can be caused by one field changing the other field, which changes the\n\t// first field, etc.\n\tprivate boolean mUriFieldEditInProgress = false;\n\n\t// Names and values for the colors displayed in the color Spinner. Names are localized, while\n\t// values are the same across languages, so the values are the ones saved to the database.\n\tprivate TypedArray mColorNames;\n\tprivate TypedArray mColorValues;\n\n\t// Likewise, but for DEL key.\n\tprivate TypedArray mDelKeyNames;\n\tprivate TypedArray mDelKeyValues;\n\n\t// A map from Charset display name to Charset value (i.e., unique ID for the Charset).\n\tprivate Map<String, String> mCharsetData;\n\n\tprivate View mTransportItem;\n\tprivate TextView mTransportText;\n\tprivate TextInputLayout mQuickConnectContainer;\n\tprivate EditText mQuickConnectField;\n\tprivate ImageButton mExpandCollapseButton;\n\tprivate View mUriPartsContainer;\n\tprivate View mUsernameContainer;\n\tprivate EditText mUsernameField;\n\tprivate View mHostnameContainer;\n\tprivate EditText mHostnameField;\n\tprivate View mPortContainer;\n\tprivate EditText mPortField;\n\tprivate View mNicknameItem;\n\tprivate EditText mNicknameField;\n\tprivate View mColorItem;\n\tprivate TextView mColorText;\n\tprivate EditText mFontSizeText;\n\tprivate SeekBar mFontSizeSeekBar;\n\tprivate View mPubkeyItem;\n\tprivate TextView mPubkeyText;\n\tprivate View mDelKeyItem;\n\tprivate TextView mDelKeyText;\n\tprivate View mEncodingItem;\n\tprivate TextView mEncodingText;\n\tprivate CheckableMenuItem mUseSshAuthSwitch;\n\tprivate CheckableMenuItem mUseSshConfirmationSwitch;\n\tprivate CheckableMenuItem mCompressionSwitch;\n\tprivate CheckableMenuItem mStartShellSwitch;\n\tprivate CheckableMenuItem mStayConnectedSwitch;\n\tprivate CheckableMenuItem mCloseOnDisconnectSwitch;\n\tprivate EditText mPostLoginAutomationField;\n\tprivate HostTextFieldWatcher mFontSizeTextChangeListener;\n\n\tpublic static HostEditorFragment newInstance(\n\t\t\tHostBean existingHost, ArrayList<String> pubkeyNames, ArrayList<String> pubkeyValues) {\n\t\tHostEditorFragment fragment = new HostEditorFragment();\n\t\tBundle args = new Bundle();\n\t\tif (existingHost != null) {\n\t\t\targs.putLong(ARG_EXISTING_HOST_ID, existingHost.getId());\n\t\t\targs.putParcelable(ARG_EXISTING_HOST, existingHost.getValues());\n\t\t}\n\t\targs.putStringArrayList(ARG_PUBKEY_NAMES, pubkeyNames);\n\t\targs.putStringArrayList(ARG_PUBKEY_VALUES, pubkeyValues);\n\t\tfragment.setArguments(args);\n\t\treturn fragment;\n\t}\n\n\tpublic HostEditorFragment() {\n\t}\n\n\t@Override\n\tpublic void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\n\t\tBundle bundle = savedInstanceState == null ? getArguments() : savedInstanceState;\n\n\t\tParcelable existingHostParcelable = bundle.getParcelable(ARG_EXISTING_HOST);\n\t\tif (existingHostParcelable != null) {\n\t\t\tmHost = HostBean.fromContentValues((ContentValues) existingHostParcelable);\n\t\t\tmHost.setId(bundle.getLong(ARG_EXISTING_HOST_ID));\n\t\t} else {\n\t\t\tmHost = new HostBean();\n\t\t}\n\n\t\tmPubkeyNames = bundle.getStringArrayList(ARG_PUBKEY_NAMES);\n\t\tmPubkeyValues = bundle.getStringArrayList(ARG_PUBKEY_VALUES);\n\n\t\tmIsUriEditorExpanded = bundle.getBoolean(ARG_IS_EXPANDED);\n\t}\n\n\t@Override\n\tpublic View onCreateView(LayoutInflater inflater, ViewGroup container,\n\t\t\tBundle savedInstanceState) {\n\t\tView view = inflater.inflate(R.layout.fragment_host_editor, container, false);\n\n\t\tmTransportItem = view.findViewById(R.id.protocol_item);\n\t\tmTransportItem.setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tPopupMenu menu = new PopupMenu(getActivity(), v);\n\t\t\t\tfor (String name : TransportFactory.getTransportNames()) {\n\t\t\t\t\tmenu.getMenu().add(name);\n\t\t\t\t}\n\t\t\t\tmenu.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\t\tsetTransportType(\n\t\t\t\t\t\t\t\titem.getTitle().toString(), /* setDefaultPortInModel */ true);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tmenu.show();\n\t\t\t}\n\t\t});\n\n\t\tmTransportText = (TextView) view.findViewById(R.id.protocol_text);\n\n\t\tmQuickConnectContainer =\n\t\t\t\t(TextInputLayout) view.findViewById(R.id.quickconnect_field_container);\n\n\t\tmQuickConnectField = (EditText) view.findViewById(R.id.quickconnect_field);\n\t\tString oldQuickConnect = savedInstanceState == null ?\n\t\t\t\tnull : savedInstanceState.getString(ARG_QUICKCONNECT_STRING);\n\t\tmQuickConnectField.setText(oldQuickConnect == null ? mHost.toString() : oldQuickConnect);\n\t\tmQuickConnectField.addTextChangedListener(new TextWatcher() {\n\t\t\t@Override\n\t\t\tpublic void beforeTextChanged(CharSequence s, int start, int count, int after) {\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void onTextChanged(CharSequence s, int start, int before, int count) {\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void afterTextChanged(Editable s) {\n\t\t\t\tif (!mUriFieldEditInProgress) {\n\t\t\t\t\tapplyQuickConnectString(s.toString(), mHost.getProtocol());\n\n\t\t\t\t\tmUriFieldEditInProgress = true;\n\t\t\t\t\tmUsernameField.setText(mHost.getUsername());\n\t\t\t\t\tmHostnameField.setText(mHost.getHostname());\n\t\t\t\t\tmPortField.setText(Integer.toString(mHost.getPort()));\n\t\t\t\t\tmUriFieldEditInProgress = false;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tmExpandCollapseButton = (ImageButton) view.findViewById(R.id.expand_collapse_button);\n\t\tmExpandCollapseButton.setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tsetUriPartsContainerExpanded(!mIsUriEditorExpanded);\n\t\t\t}\n\t\t});\n\n\t\tmUriPartsContainer = view.findViewById(R.id.uri_parts_container);\n\n\t\tmUsernameContainer = view.findViewById(R.id.username_field_container);\n\t\tmUsernameField = (EditText) view.findViewById(R.id.username_edit_text);\n\t\tmUsernameField.setText(mHost.getUsername());\n\t\tmUsernameField.addTextChangedListener(new HostTextFieldWatcher(HostDatabase.FIELD_HOST_USERNAME));\n\n\t\tmHostnameContainer = view.findViewById(R.id.hostname_field_container);\n\t\tmHostnameField = (EditText) view.findViewById(R.id.hostname_edit_text);\n\t\tmHostnameField.setText(mHost.getHostname());\n\t\tmHostnameField.addTextChangedListener(new HostTextFieldWatcher(HostDatabase.FIELD_HOST_HOSTNAME));\n\n\t\tmPortContainer = view.findViewById(R.id.port_field_container);\n\t\tmPortField = (EditText) view.findViewById(R.id.port_edit_text);\n\t\tmPortField.setText(Integer.toString(mHost.getPort()));\n\t\tmPortField.addTextChangedListener(new HostTextFieldWatcher(HostDatabase.FIELD_HOST_PORT));\n\n\t\tmNicknameItem = view.findViewById(R.id.nickname_item);\n\n\t\tsetTransportType(mHost.getProtocol(), /* setDefaultPortInModel */ false);\n\n\t\tmNicknameField = (EditText) view.findViewById(R.id.nickname_field);\n\t\tmNicknameField.setText(mHost.getNickname());\n\t\tmNicknameField.addTextChangedListener(\n\t\t\t\tnew HostTextFieldWatcher(HostDatabase.FIELD_HOST_NICKNAME));\n\n\t\tmColorItem = view.findViewById(R.id.color_item);\n\t\tmColorItem.setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tPopupMenu menu = new PopupMenu(getActivity(), v);\n\t\t\t\tfor (int i = 0; i < mColorNames.length(); i++) {\n\t\t\t\t\tmenu.getMenu().add(mColorNames.getText(i));\n\t\t\t\t}\n\t\t\t\tmenu.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\t\tfor (int i = 0; i < mColorNames.length(); i++) {\n\t\t\t\t\t\t\tif (item.getTitle().toString().equals(mColorNames.getText(i).toString())) {\n\t\t\t\t\t\t\t\tmHost.setColor(mColorValues.getText(i).toString());\n\t\t\t\t\t\t\t\tmColorText.setText(mColorNames.getText(i));\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tmenu.show();\n\t\t\t}\n\t\t});\n\n\t\tmColorText = (TextView) view.findViewById(R.id.color_text);\n\t\tfor (int i = 0; i < mColorValues.length(); i++) {\n\t\t\tif (mColorValues.getText(i).toString().equals(mHost.getColor())) {\n\t\t\t\tmColorText.setText(mColorNames.getText(i));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tmFontSizeText = (EditText) view.findViewById(R.id.font_size_text);\n\t\tmFontSizeText.setText(Integer.toString(mHost.getFontSize()));\n\t\tmFontSizeTextChangeListener = new HostTextFieldWatcher(HostDatabase.FIELD_HOST_FONTSIZE);\n\t\tmFontSizeText.addTextChangedListener(mFontSizeTextChangeListener);\n\t\tmFontSizeText.setOnFocusChangeListener(new View.OnFocusChangeListener() {\n\t\t\t@Override\n\t\t\tpublic void onFocusChange(View v, boolean hasFocus) {\n\t\t\t\tif (!hasFocus)\n\t\t\t\t\tmFontSizeText.setText(Integer.toString(mHost.getFontSize()));\n\t\t\t}\n\t\t});\n\n\t\tmFontSizeSeekBar = (SeekBar) view.findViewById(R.id.font_size_bar);\n\t\tmFontSizeSeekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {\n\t\t\t@Override\n\t\t\tpublic void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {\n\t\t\t\tsetFontSize(MINIMUM_FONT_SIZE + progress);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void onStartTrackingTouch(SeekBar seekBar) {\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void onStopTrackingTouch(SeekBar seekBar) {\n\t\t\t}\n\t\t});\n\t\tmFontSizeSeekBar.setProgress(mHost.getFontSize() - MINIMUM_FONT_SIZE);\n\n\t\tmPubkeyItem = view.findViewById(R.id.pubkey_item);\n\t\tmPubkeyItem.setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tPopupMenu menu = new PopupMenu(getActivity(), v);\n\t\t\t\tfor (String name : mPubkeyNames) {\n\t\t\t\t\tmenu.getMenu().add(name);\n\t\t\t\t}\n\t\t\t\tmenu.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\t\tfor (int i = 0; i < mPubkeyNames.size(); i++) {\n\t\t\t\t\t\t\tif (mPubkeyNames.get(i).equals(item.getTitle())) {\n\t\t\t\t\t\t\t\tmHost.setPubkeyId(Long.parseLong(mPubkeyValues.get(i)));\n\t\t\t\t\t\t\t\tmPubkeyText.setText(mPubkeyNames.get(i));\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tmenu.show();\n\t\t\t}\n\t\t});\n\n\t\tmPubkeyText = (TextView) view.findViewById(R.id.pubkey_text);\n\t\tfor (int i = 0; i < mPubkeyValues.size(); i++) {\n\t\t\tif (mHost.getPubkeyId() == Long.parseLong(mPubkeyValues.get(i))) {\n\t\t\t\tmPubkeyText.setText(mPubkeyNames.get(i));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tmDelKeyItem = view.findViewById(R.id.delkey_item);\n\t\tmDelKeyItem.setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tPopupMenu menu = new PopupMenu(getActivity(), v);\n\t\t\t\tfor (int i = 0; i < mDelKeyNames.length(); i++) {\n\t\t\t\t\tmenu.getMenu().add(mDelKeyNames.getText(i));\n\t\t\t\t}\n\t\t\t\tmenu.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\t\tfor (int i = 0; i < mDelKeyNames.length(); i++) {\n\t\t\t\t\t\t\tif (mDelKeyNames.getText(i).equals(item.getTitle())) {\n\t\t\t\t\t\t\t\tmHost.setDelKey(mDelKeyValues.getText(i).toString());\n\t\t\t\t\t\t\t\tmDelKeyText.setText(mDelKeyNames.getText(i));\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tmenu.show();\n\t\t\t}\n\t\t});\n\n\t\tmDelKeyText = (TextView) view.findViewById(R.id.delkey_text);\n\t\tfor (int i = 0; i < mDelKeyValues.length(); i++) {\n\t\t\tif (mDelKeyValues.getText(i).toString().equals(mHost.getDelKey())) {\n\t\t\t\tmDelKeyText.setText(mDelKeyNames.getText(i));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tmEncodingItem = view.findViewById(R.id.encoding_item);\n\t\tmEncodingItem.setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tPopupMenu menu = new PopupMenu(getActivity(), v);\n\t\t\t\tfor (String displayName : mCharsetData.keySet()) {\n\t\t\t\t\tmenu.getMenu().add(displayName);\n\t\t\t\t}\n\t\t\t\tmenu.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\t\tfor (String displayName : mCharsetData.keySet()) {\n\t\t\t\t\t\t\tif (displayName.equals(item.getTitle())) {\n\t\t\t\t\t\t\t\tmHost.setEncoding(mCharsetData.get(displayName));\n\t\t\t\t\t\t\t\tmEncodingText.setText(displayName);\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tmenu.show();\n\t\t\t}\n\t\t});\n\n\t\t// The encoding text is initialized in setCharsetData() because Charset data is not always\n\t\t// available when this fragment is created.\n\t\tmEncodingText = (TextView) view.findViewById(R.id.encoding_text);\n\n\t\tmUseSshAuthSwitch = (CheckableMenuItem) view.findViewById(R.id.use_ssh_auth_item);\n\t\tmUseSshAuthSwitch.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {\n\t\t\t@Override\n\t\t\tpublic void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {\n\t\t\t\tprocessSshAuthChange();\n\t\t\t}\n\t\t});\n\n\t\tmUseSshConfirmationSwitch = (CheckableMenuItem) view.findViewById(R.id.ssh_auth_confirmation_item);\n\t\tmUseSshAuthSwitch.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {\n\t\t\t@Override\n\t\t\tpublic void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {\n\t\t\t\tprocessSshAuthChange();\n\t\t\t}\n\t\t});\n\n\t\tprocessSshAuthChange();\n\n\t\tmCompressionSwitch = (CheckableMenuItem) view.findViewById(R.id.compression_item);\n\t\tmCompressionSwitch.setChecked(mHost.getCompression());\n\t\tmCompressionSwitch.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {\n\t\t\t@Override\n\t\t\tpublic void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {\n\t\t\t\tmHost.setCompression(isChecked);\n\t\t\t\thandleHostChange();\n\t\t\t}\n\t\t});\n\n\t\tmStartShellSwitch = (CheckableMenuItem) view.findViewById(R.id.start_shell_item);\n\t\tmStartShellSwitch.setChecked(mHost.getWantSession());\n\t\tmStartShellSwitch.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {\n\t\t\t@Override\n\t\t\tpublic void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {\n\t\t\t\tmHost.setWantSession(isChecked);\n\t\t\t\thandleHostChange();\n\t\t\t}\n\t\t});\n\n\t\tmStayConnectedSwitch = (CheckableMenuItem) view.findViewById(R.id.stay_connected_item);\n\t\tmStayConnectedSwitch.setChecked(mHost.getStayConnected());\n\t\tmStayConnectedSwitch.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {\n\t\t\t@Override\n\t\t\tpublic void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {\n\t\t\t\tmHost.setStayConnected(isChecked);\n\t\t\t\thandleHostChange();\n\t\t\t}\n\t\t});\n\n\t\tmCloseOnDisconnectSwitch = (CheckableMenuItem) view.findViewById(R.id.close_on_disconnect_item);\n\t\tmCloseOnDisconnectSwitch.setChecked(mHost.getQuickDisconnect());\n\t\tmCloseOnDisconnectSwitch.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {\n\t\t\t@Override\n\t\t\tpublic void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {\n\t\t\t\tmHost.setQuickDisconnect(isChecked);\n\t\t\t\thandleHostChange();\n\t\t\t}\n\t\t});\n\n\t\tmPostLoginAutomationField = (EditText) view.findViewById(R.id.post_login_automation_field);\n\t\tmPostLoginAutomationField.setText(mHost.getPostLogin());\n\t\tmPostLoginAutomationField.addTextChangedListener(\n\t\t\t\tnew HostTextFieldWatcher(HostDatabase.FIELD_HOST_POSTLOGIN));\n\n\t\tsetUriPartsContainerExpanded(mIsUriEditorExpanded);\n\n\t\treturn view;\n\t}\n\n\t/**\n\t * @param protocol The protocol to set.\n\t * @param setDefaultPortInModel True if the model's port should be updated to the default port\n\t *     for the given protocol.\n\t */\n\tprivate void setTransportType(String protocol, boolean setDefaultPortInModel) {\n\t\tmHost.setProtocol(protocol);\n\t\tif (setDefaultPortInModel)\n\t\t\tmHost.setPort(TransportFactory.getTransport(protocol).getDefaultPort());\n\t\thandleHostChange();\n\n\t\tmTransportText.setText(protocol);\n\n\t\tmQuickConnectContainer.setHint(\n\t\t\t\tTransportFactory.getFormatHint(protocol, getActivity()));\n\n\t\t// Different protocols have different field types, so show only the fields needed.\n\t\tif (SSH.getProtocolName().equals(protocol)) {\n\t\t\tmUsernameContainer.setVisibility(View.VISIBLE);\n\t\t\tmHostnameContainer.setVisibility(View.VISIBLE);\n\t\t\tmPortContainer.setVisibility(View.VISIBLE);\n\t\t\tmExpandCollapseButton.setVisibility(View.VISIBLE);\n\t\t\tmNicknameItem.setVisibility(View.VISIBLE);\n\t\t} else if (Telnet.getProtocolName().equals(protocol)) {\n\t\t\tmUsernameContainer.setVisibility(View.GONE);\n\t\t\tmHostnameContainer.setVisibility(View.VISIBLE);\n\t\t\tmPortContainer.setVisibility(View.VISIBLE);\n\t\t\tmExpandCollapseButton.setVisibility(View.VISIBLE);\n\t\t\tmNicknameItem.setVisibility(View.VISIBLE);\n\t\t} else {\n\t\t\t// Local protocol has only one field, so no need to show the URI parts\n\t\t\t// container.\n\t\t\tsetUriPartsContainerExpanded(false);\n\t\t\tmExpandCollapseButton.setVisibility(View.GONE);\n\t\t\tmNicknameItem.setVisibility(View.GONE);\n\t\t}\n\t}\n\n\tprivate void setFontSize(int fontSize) {\n\t\tif (fontSize < MINIMUM_FONT_SIZE)\n\t\t\tfontSize = MINIMUM_FONT_SIZE;\n\n\t\tif (fontSize > MAXIMUM_FONT_SIZE)\n\t\t\tfontSize = MAXIMUM_FONT_SIZE;\n\n\t\tmHost.setFontSize(fontSize);\n\n\t\tif (mFontSizeSeekBar.getProgress() + MINIMUM_FONT_SIZE != fontSize) {\n\t\t\tmFontSizeSeekBar.setProgress(fontSize - MINIMUM_FONT_SIZE);\n\t\t}\n\n\t\tif (Integer.parseInt(mFontSizeText.getText().toString()) != fontSize) {\n\t\t\tmFontSizeText.removeTextChangedListener(mFontSizeTextChangeListener);\n\t\t\tmFontSizeText.setText(Integer.toString(fontSize));\n\t\t\tmFontSizeText.addTextChangedListener(mFontSizeTextChangeListener);\n\t\t}\n\n\t\thandleHostChange();\n\t}\n\n\tprivate void processSshAuthChange() {\n\t\tmUseSshConfirmationSwitch.setVisibility(\n\t\t\t\tmUseSshAuthSwitch.isChecked() ? View.VISIBLE : View.GONE);\n\n\t\tif (mUseSshAuthSwitch.isChecked()) {\n\t\t\t//noinspection ResourceType\n\t\t\tmHost.setUseAuthAgent(\n\t\t\t\t\tmUseSshConfirmationSwitch.isChecked() ?\n\t\t\t\t\t\t\t\t\tHostDatabase.AUTHAGENT_CONFIRM :\n\t\t\t\t\t\t\t\t\tHostDatabase.AUTHAGENT_YES);\n\t\t} else {\n\t\t\tmHost.setUseAuthAgent(HostDatabase.AUTHAGENT_NO);\n\t\t}\n\n\t\thandleHostChange();\n\t}\n\n\t@Override\n\tpublic void onAttach(Context context) {\n\t\tsuper.onAttach(context);\n\t\ttry {\n\t\t\tmListener = (Listener) context;\n\t\t} catch (ClassCastException e) {\n\t\t\tthrow new ClassCastException(context.toString() + \" must implement Listener\");\n\t\t}\n\n\t\t// Now that the fragment is attached to an Activity, fetch the arrays from the attached\n\t\t// Activity's resources.\n\t\tmColorNames = getResources().obtainTypedArray(R.array.list_colors);\n\t\tmColorValues = getResources().obtainTypedArray(R.array.list_color_values);\n\t\tmDelKeyNames = getResources().obtainTypedArray(R.array.list_delkey);\n\t\tmDelKeyValues = getResources().obtainTypedArray(R.array.list_delkey_values);\n\t}\n\n\t@Override\n\tpublic void onDetach() {\n\t\tsuper.onDetach();\n\t\tmListener = null;\n\t\tmColorNames.recycle();\n\t\tmColorValues.recycle();\n\t\tmDelKeyNames.recycle();\n\t\tmDelKeyValues.recycle();\n\t}\n\n\t@Override\n\tpublic void onSaveInstanceState(Bundle savedInstanceState) {\n\t\tsuper.onSaveInstanceState(savedInstanceState);\n\n\t\tsavedInstanceState.putLong(ARG_EXISTING_HOST_ID, mHost.getId());\n\t\tsavedInstanceState.putParcelable(ARG_EXISTING_HOST, mHost.getValues());\n\t\tsavedInstanceState.putBoolean(ARG_IS_EXPANDED, mIsUriEditorExpanded);\n\t\tsavedInstanceState.putString(\n\t\t\t\tARG_QUICKCONNECT_STRING, mQuickConnectField.getText().toString());\n\t\tsavedInstanceState.putStringArrayList(ARG_PUBKEY_NAMES, mPubkeyNames);\n\t\tsavedInstanceState.putStringArrayList(ARG_PUBKEY_VALUES, mPubkeyValues);\n\t}\n\n\t/**\n\t * Sets the Charset encoding data for the editor.\n\t * @param data A map from Charset display name to Charset value (i.e., unique ID for the\n\t *     Charset).\n\t */\n\tpublic void setCharsetData(final Map<String, String> data) {\n\t\tmCharsetData = data;\n\n\t\tif (mEncodingText != null) {\n\t\t\tIterator it = data.entrySet().iterator();\n\t\t\twhile (it.hasNext()) {\n\t\t\t\tMap.Entry<String, String> pair = (Map.Entry) it.next();\n\t\t\t\tif (pair.getValue().equals(mHost.getEncoding())) {\n\t\t\t\t\tmEncodingText.setText(pair.getKey());\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void setUriPartsContainerExpanded(boolean expanded) {\n\t\tmIsUriEditorExpanded = expanded;\n\n\t\tif (mIsUriEditorExpanded) {\n\t\t\tmExpandCollapseButton.setImageResource(R.drawable.ic_expand_less);\n\t\t\tmUriPartsContainer.setVisibility(View.VISIBLE);\n\t\t} else {\n\t\t\tmExpandCollapseButton.setImageResource(R.drawable.ic_expand_more);\n\t\t\tmUriPartsContainer.setVisibility(View.GONE);\n\t\t}\n\t}\n\n\t/**\n\t * Applies the quick-connect URI entered in the field by copying its URI parts to mHost's\n\t * fields.\n\t * @param quickConnectString The URI entered in the quick-connect field.\n\t * @param protocol The protocol for this connection.\n\t */\n\tprivate void applyQuickConnectString(String quickConnectString, String protocol) {\n\t\tif (quickConnectString == null || protocol == null)\n\t\t\treturn;\n\n\t\tUri uri = TransportFactory.getUri(protocol, quickConnectString);\n\t\tif (uri == null) {\n\t\t\t// If the URI was invalid, null out the associated fields.\n\t\t\tmHost.setProtocol(protocol);\n\t\t\tmHost.setUsername(null);\n\t\t\tmHost.setHostname(null);\n\t\t\tmHost.setNickname(null);\n\t\t\tmHost.setPort(TransportFactory.getTransport(protocol).getDefaultPort());\n\t\t\treturn;\n\t\t}\n\n\t\tHostBean host = TransportFactory.getTransport(protocol).createHost(uri);\n\t\tmHost.setProtocol(host.getProtocol());\n\t\tmHost.setUsername(host.getUsername());\n\t\tmHost.setHostname(host.getHostname());\n\t\tmHost.setNickname(host.getNickname());\n\t\tmHost.setPort(host.getPort());\n\t\thandleHostChange();\n\t}\n\n\t/**\n\t * Handles a change in the host caused by the user adjusting the values of one of the widgets\n\t * in this fragment. If the change has resulted in a valid host, the new value is sent back\n\t * to the listener; however, if the change ha resulted in an invalid host, the listener is\n\t * notified.\n\t */\n\tprivate void handleHostChange() {\n\t\tString quickConnectString = mQuickConnectField.getText().toString();\n\t\tif (quickConnectString == null || quickConnectString.equals(\"\")) {\n\t\t\t// Invalid protocol and/or string, so don't do anything.\n\t\t\tmListener.onHostInvalidated();\n\t\t\treturn;\n\t\t}\n\n\t\tUri uri = TransportFactory.getUri(mHost.getProtocol(), quickConnectString);\n\t\tif (uri == null) {\n\t\t\t// Valid string, but does not accurately describe a URI.\n\t\t\tmListener.onHostInvalidated();\n\t\t\treturn;\n\t\t}\n\n\t\t// Now, the host is confirmed to have a valid URI.\n\t\tmListener.onValidHostConfigured(mHost);\n\t}\n\n\tpublic interface Listener {\n\t\tvoid onValidHostConfigured(HostBean host);\n\t\tvoid onHostInvalidated();\n\t}\n\n\tprivate class HostTextFieldWatcher implements TextWatcher {\n\n\t\tprivate final String mFieldType;\n\n\t\tpublic HostTextFieldWatcher(String fieldType) {\n\t\t\tmFieldType = fieldType;\n\t\t}\n\n\t\t@Override\n\t\tpublic void beforeTextChanged(CharSequence s, int start, int count, int after) {}\n\n\t\t@Override\n\t\tpublic void onTextChanged(CharSequence s, int start, int before, int count) {}\n\n\t\t@Override\n\t\tpublic void afterTextChanged(Editable s) {\n\t\t\tString text = s.toString();\n\n\t\t\tif (HostDatabase.FIELD_HOST_USERNAME.equals(mFieldType)) {\n\t\t\t\tmHost.setUsername(text);\n\t\t\t} else if (HostDatabase.FIELD_HOST_HOSTNAME.equals(mFieldType)) {\n\t\t\t\tmHost.setHostname(text);\n\t\t\t} else if (HostDatabase.FIELD_HOST_PORT.equals(mFieldType)) {\n\t\t\t\ttry {\n\t\t\t\t\tmHost.setPort(Integer.parseInt(text));\n\t\t\t\t} catch (NumberFormatException e) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else if (HostDatabase.FIELD_HOST_NICKNAME.equals(mFieldType)) {\n\t\t\t\tmHost.setNickname(text);\n\t\t\t} else if (HostDatabase.FIELD_HOST_POSTLOGIN.equals(mFieldType)) {\n\t\t\t\tmHost.setPostLogin(text);\n\t\t\t} else if (HostDatabase.FIELD_HOST_FONTSIZE.equals(mFieldType)) {\n\t\t\t\tint fontSize = HostBean.DEFAULT_FONT_SIZE;\n\t\t\t\ttry {\n\t\t\t\t\tfontSize = Integer.parseInt(text);\n\t\t\t\t} catch (NumberFormatException e) {\n\t\t\t\t} finally {\n\t\t\t\t\tsetFontSize(fontSize);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new RuntimeException(\"Invalid field type.\");\n\t\t\t}\n\n\t\t\tif (isUriRelatedField(mFieldType)) {\n\t\t\t\tmNicknameField.setText(mHost.toString());\n\t\t\t\tmHost.setNickname(mHost.toString());\n\n\t\t\t\tif (!mUriFieldEditInProgress) {\n\t\t\t\t\tmUriFieldEditInProgress = true;\n\t\t\t\t\tmQuickConnectField.setText(mHost.toString());\n\t\t\t\t\tmUriFieldEditInProgress = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\thandleHostChange();\n\t\t}\n\n\t\tprivate boolean isUriRelatedField(String fieldType) {\n\t\t\treturn HostDatabase.FIELD_HOST_USERNAME.equals(fieldType) ||\n\t\t\t\t\tHostDatabase.FIELD_HOST_HOSTNAME.equals(fieldType) ||\n\t\t\t\t\tHostDatabase.FIELD_HOST_PORT.equals(fieldType);\n\t\t}\n\t}\n}\n","Method after Refactoring":"/*\n * ConnectBot: simple, powerful, open-source SSH client for Android\n * Copyright 2015 Kenny Root, Jeffrey Sharkey\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.connectbot;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.Map;\n\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.res.TypedArray;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Parcelable;\nimport android.support.design.widget.TextInputLayout;\nimport android.support.v4.app.Fragment;\nimport android.support.v7.widget.PopupMenu;\nimport android.text.Editable;\nimport android.text.TextWatcher;\nimport android.view.LayoutInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.CompoundButton;\nimport android.widget.EditText;\nimport android.widget.ImageButton;\nimport android.widget.SeekBar;\nimport android.widget.TextView;\n\nimport org.connectbot.bean.HostBean;\nimport org.connectbot.transport.SSH;\nimport org.connectbot.transport.Telnet;\nimport org.connectbot.transport.TransportFactory;\nimport org.connectbot.util.HostDatabase;\nimport org.connectbot.views.CheckableMenuItem;\n\npublic class HostEditorFragment extends Fragment {\n\n\tprivate static final String ARG_EXISTING_HOST_ID = \"existingHostId\";\n\tprivate static final String ARG_EXISTING_HOST = \"existingHost\";\n\tprivate static final String ARG_IS_EXPANDED = \"isExpanded\";\n\tprivate static final String ARG_PUBKEY_NAMES = \"pubkeyNames\";\n\tprivate static final String ARG_PUBKEY_VALUES = \"pubkeyValues\";\n\tprivate static final String ARG_QUICKCONNECT_STRING = \"quickConnectString\";\n\n\t// Note: The \"max\" value for mFontSizeSeekBar is 32. If these font values change, this value\n\t// must be changed in the SeekBar's XML.\n\tprivate static final int MINIMUM_FONT_SIZE = 8;\n\tprivate static final int MAXIMUM_FONT_SIZE = 40;\n\n\t// The host being edited.\n\tprivate HostBean mHost;\n\n\t// The pubkey lists (names and values). Note that these are declared as ArrayLists rather than\n\t// Lists because Bundles can only contain ArrayLists, not general Lists.\n\tprivate ArrayList<String> mPubkeyNames;\n\tprivate ArrayList<String> mPubkeyValues;\n\n\t// The listener for changes to this host.\n\tprivate Listener mListener;\n\n\t// Whether the URI parts subsection is expanded.\n\tprivate boolean mIsUriEditorExpanded = false;\n\n\t// Whether a URI text edit is in progress. When the quick-connect field is being edited, changes\n\t// automatically propagate to the URI part fields; likewise, when the URI part fields are\n\t// edited, changes are propagated to the quick-connect field. This boolean safeguards against\n\t// infinite loops which can be caused by one field changing the other field, which changes the\n\t// first field, etc.\n\tprivate boolean mUriFieldEditInProgress = false;\n\n\t// Names and values for the colors displayed in the color Spinner. Names are localized, while\n\t// values are the same across languages, so the values are the ones saved to the database.\n\tprivate TypedArray mColorNames;\n\tprivate TypedArray mColorValues;\n\n\t// Likewise, but for DEL key.\n\tprivate TypedArray mDelKeyNames;\n\tprivate TypedArray mDelKeyValues;\n\n\t// A map from Charset display name to Charset value (i.e., unique ID for the Charset).\n\tprivate Map<String, String> mCharsetData;\n\n\tprivate View mTransportItem;\n\tprivate TextView mTransportText;\n\tprivate TextInputLayout mQuickConnectContainer;\n\tprivate EditText mQuickConnectField;\n\tprivate ImageButton mExpandCollapseButton;\n\tprivate View mUriPartsContainer;\n\tprivate View mUsernameContainer;\n\tprivate EditText mUsernameField;\n\tprivate View mHostnameContainer;\n\tprivate EditText mHostnameField;\n\tprivate View mPortContainer;\n\tprivate EditText mPortField;\n\tprivate View mNicknameItem;\n\tprivate EditText mNicknameField;\n\tprivate View mColorItem;\n\tprivate TextView mColorText;\n\tprivate EditText mFontSizeText;\n\tprivate SeekBar mFontSizeSeekBar;\n\tprivate View mPubkeyItem;\n\tprivate TextView mPubkeyText;\n\tprivate View mDelKeyItem;\n\tprivate TextView mDelKeyText;\n\tprivate View mEncodingItem;\n\tprivate TextView mEncodingText;\n\tprivate CheckableMenuItem mUseSshAuthSwitch;\n\tprivate CheckableMenuItem mUseSshConfirmationSwitch;\n\tprivate CheckableMenuItem mCompressionSwitch;\n\tprivate CheckableMenuItem mStartShellSwitch;\n\tprivate CheckableMenuItem mStayConnectedSwitch;\n\tprivate CheckableMenuItem mCloseOnDisconnectSwitch;\n\tprivate EditText mPostLoginAutomationField;\n\tprivate HostTextFieldWatcher mFontSizeTextChangeListener;\n\n\tpublic static HostEditorFragment newInstance(\n\t\t\tHostBean existingHost, ArrayList<String> pubkeyNames, ArrayList<String> pubkeyValues) {\n\t\tHostEditorFragment fragment = new HostEditorFragment();\n\t\tBundle args = new Bundle();\n\t\tif (existingHost != null) {\n\t\t\targs.putLong(ARG_EXISTING_HOST_ID, existingHost.getId());\n\t\t\targs.putParcelable(ARG_EXISTING_HOST, existingHost.getValues());\n\t\t}\n\t\targs.putStringArrayList(ARG_PUBKEY_NAMES, pubkeyNames);\n\t\targs.putStringArrayList(ARG_PUBKEY_VALUES, pubkeyValues);\n\t\tfragment.setArguments(args);\n\t\treturn fragment;\n\t}\n\n\tpublic HostEditorFragment() {\n\t}\n\n\t@Override\n\tpublic void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\n\t\tBundle bundle = savedInstanceState == null ? getArguments() : savedInstanceState;\n\n\t\tParcelable existingHostParcelable = bundle.getParcelable(ARG_EXISTING_HOST);\n\t\tif (existingHostParcelable != null) {\n\t\t\tmHost = HostBean.fromContentValues((ContentValues) existingHostParcelable);\n\t\t\tmHost.setId(bundle.getLong(ARG_EXISTING_HOST_ID));\n\t\t} else {\n\t\t\tmHost = new HostBean();\n\t\t}\n\n\t\tmPubkeyNames = bundle.getStringArrayList(ARG_PUBKEY_NAMES);\n\t\tmPubkeyValues = bundle.getStringArrayList(ARG_PUBKEY_VALUES);\n\n\t\tmIsUriEditorExpanded = bundle.getBoolean(ARG_IS_EXPANDED);\n\t}\n\n\t@Override\n\tpublic View onCreateView(LayoutInflater inflater, ViewGroup container,\n\t\t\tBundle savedInstanceState) {\n\t\tView view = inflater.inflate(R.layout.fragment_host_editor, container, false);\n\n\t\tmTransportItem = view.findViewById(R.id.protocol_item);\n\t\tmTransportItem.setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tPopupMenu menu = new PopupMenu(getActivity(), v);\n\t\t\t\tfor (String name : TransportFactory.getTransportNames()) {\n\t\t\t\t\tmenu.getMenu().add(name);\n\t\t\t\t}\n\t\t\t\tmenu.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\t\tsetTransportType(\n\t\t\t\t\t\t\t\titem.getTitle().toString(), /* setDefaultPortInModel */ true);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tmenu.show();\n\t\t\t}\n\t\t});\n\n\t\tmTransportText = (TextView) view.findViewById(R.id.protocol_text);\n\n\t\tmQuickConnectContainer =\n\t\t\t\t(TextInputLayout) view.findViewById(R.id.quickconnect_field_container);\n\n\t\tmQuickConnectField = (EditText) view.findViewById(R.id.quickconnect_field);\n\t\tString oldQuickConnect = savedInstanceState == null ?\n\t\t\t\tnull : savedInstanceState.getString(ARG_QUICKCONNECT_STRING);\n\t\tmQuickConnectField.setText(oldQuickConnect == null ? mHost.toString() : oldQuickConnect);\n\t\tmQuickConnectField.addTextChangedListener(new TextWatcher() {\n\t\t\t@Override\n\t\t\tpublic void beforeTextChanged(CharSequence s, int start, int count, int after) {\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void onTextChanged(CharSequence s, int start, int before, int count) {\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void afterTextChanged(Editable s) {\n\t\t\t\tif (!mUriFieldEditInProgress) {\n\t\t\t\t\tapplyQuickConnectString(s.toString(), mHost.getProtocol());\n\n\t\t\t\t\tmUriFieldEditInProgress = true;\n\t\t\t\t\tmUsernameField.setText(mHost.getUsername());\n\t\t\t\t\tmHostnameField.setText(mHost.getHostname());\n\t\t\t\t\tmPortField.setText(Integer.toString(mHost.getPort()));\n\t\t\t\t\tmUriFieldEditInProgress = false;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tmExpandCollapseButton = (ImageButton) view.findViewById(R.id.expand_collapse_button);\n\t\tmExpandCollapseButton.setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tsetUriPartsContainerExpanded(!mIsUriEditorExpanded);\n\t\t\t}\n\t\t});\n\n\t\tmUriPartsContainer = view.findViewById(R.id.uri_parts_container);\n\n\t\tmUsernameContainer = view.findViewById(R.id.username_field_container);\n\t\tmUsernameField = (EditText) view.findViewById(R.id.username_edit_text);\n\t\tmUsernameField.setText(mHost.getUsername());\n\t\tmUsernameField.addTextChangedListener(new HostTextFieldWatcher(HostDatabase.FIELD_HOST_USERNAME));\n\n\t\tmHostnameContainer = view.findViewById(R.id.hostname_field_container);\n\t\tmHostnameField = (EditText) view.findViewById(R.id.hostname_edit_text);\n\t\tmHostnameField.setText(mHost.getHostname());\n\t\tmHostnameField.addTextChangedListener(new HostTextFieldWatcher(HostDatabase.FIELD_HOST_HOSTNAME));\n\n\t\tmPortContainer = view.findViewById(R.id.port_field_container);\n\t\tmPortField = (EditText) view.findViewById(R.id.port_edit_text);\n\t\tmPortField.setText(Integer.toString(mHost.getPort()));\n\t\tmPortField.addTextChangedListener(new HostTextFieldWatcher(HostDatabase.FIELD_HOST_PORT));\n\n\t\tmNicknameItem = view.findViewById(R.id.nickname_item);\n\n\t\tsetTransportType(mHost.getProtocol(), /* setDefaultPortInModel */ false);\n\n\t\tmNicknameField = (EditText) view.findViewById(R.id.nickname_field);\n\t\tmNicknameField.setText(mHost.getNickname());\n\t\tmNicknameField.addTextChangedListener(\n\t\t\t\tnew HostTextFieldWatcher(HostDatabase.FIELD_HOST_NICKNAME));\n\n\t\tmColorItem = view.findViewById(R.id.color_item);\n\t\tmColorItem.setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tPopupMenu menu = new PopupMenu(getActivity(), v);\n\t\t\t\tfor (int i = 0; i < mColorNames.length(); i++) {\n\t\t\t\t\tmenu.getMenu().add(mColorNames.getText(i));\n\t\t\t\t}\n\t\t\t\tmenu.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\t\tfor (int i = 0; i < mColorNames.length(); i++) {\n\t\t\t\t\t\t\tif (item.getTitle().toString().equals(mColorNames.getText(i).toString())) {\n\t\t\t\t\t\t\t\tmHost.setColor(mColorValues.getText(i).toString());\n\t\t\t\t\t\t\t\tmColorText.setText(mColorNames.getText(i));\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tmenu.show();\n\t\t\t}\n\t\t});\n\n\t\tmColorText = (TextView) view.findViewById(R.id.color_text);\n\t\tfor (int i = 0; i < mColorValues.length(); i++) {\n\t\t\tif (mColorValues.getText(i).toString().equals(mHost.getColor())) {\n\t\t\t\tmColorText.setText(mColorNames.getText(i));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tmFontSizeText = (EditText) view.findViewById(R.id.font_size_text);\n\t\tmFontSizeText.setText(Integer.toString(mHost.getFontSize()));\n\t\tmFontSizeTextChangeListener = new HostTextFieldWatcher(HostDatabase.FIELD_HOST_FONTSIZE);\n\t\tmFontSizeText.addTextChangedListener(mFontSizeTextChangeListener);\n\t\tmFontSizeText.setOnFocusChangeListener(new View.OnFocusChangeListener() {\n\t\t\t@Override\n\t\t\tpublic void onFocusChange(View v, boolean hasFocus) {\n\t\t\t\tif (!hasFocus)\n\t\t\t\t\tmFontSizeText.setText(Integer.toString(mHost.getFontSize()));\n\t\t\t}\n\t\t});\n\n\t\tmFontSizeSeekBar = (SeekBar) view.findViewById(R.id.font_size_bar);\n\t\tmFontSizeSeekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {\n\t\t\t@Override\n\t\t\tpublic void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {\n\t\t\t\tsetFontSize(MINIMUM_FONT_SIZE + progress);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void onStartTrackingTouch(SeekBar seekBar) {\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void onStopTrackingTouch(SeekBar seekBar) {\n\t\t\t}\n\t\t});\n\t\tmFontSizeSeekBar.setProgress(mHost.getFontSize() - MINIMUM_FONT_SIZE);\n\n\t\tmPubkeyItem = view.findViewById(R.id.pubkey_item);\n\t\tmPubkeyItem.setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tPopupMenu menu = new PopupMenu(getActivity(), v);\n\t\t\t\tfor (String name : mPubkeyNames) {\n\t\t\t\t\tmenu.getMenu().add(name);\n\t\t\t\t}\n\t\t\t\tmenu.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\t\tfor (int i = 0; i < mPubkeyNames.size(); i++) {\n\t\t\t\t\t\t\tif (mPubkeyNames.get(i).equals(item.getTitle())) {\n\t\t\t\t\t\t\t\tmHost.setPubkeyId(Long.parseLong(mPubkeyValues.get(i)));\n\t\t\t\t\t\t\t\tmPubkeyText.setText(mPubkeyNames.get(i));\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tmenu.show();\n\t\t\t}\n\t\t});\n\n\t\tmPubkeyText = (TextView) view.findViewById(R.id.pubkey_text);\n\t\tfor (int i = 0; i < mPubkeyValues.size(); i++) {\n\t\t\tif (mHost.getPubkeyId() == Long.parseLong(mPubkeyValues.get(i))) {\n\t\t\t\tmPubkeyText.setText(mPubkeyNames.get(i));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tmDelKeyItem = view.findViewById(R.id.delkey_item);\n\t\tmDelKeyItem.setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tPopupMenu menu = new PopupMenu(getActivity(), v);\n\t\t\t\tfor (int i = 0; i < mDelKeyNames.length(); i++) {\n\t\t\t\t\tmenu.getMenu().add(mDelKeyNames.getText(i));\n\t\t\t\t}\n\t\t\t\tmenu.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\t\tfor (int i = 0; i < mDelKeyNames.length(); i++) {\n\t\t\t\t\t\t\tif (mDelKeyNames.getText(i).equals(item.getTitle())) {\n\t\t\t\t\t\t\t\tmHost.setDelKey(mDelKeyValues.getText(i).toString());\n\t\t\t\t\t\t\t\tmDelKeyText.setText(mDelKeyNames.getText(i));\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tmenu.show();\n\t\t\t}\n\t\t});\n\n\t\tmDelKeyText = (TextView) view.findViewById(R.id.delkey_text);\n\t\tfor (int i = 0; i < mDelKeyValues.length(); i++) {\n\t\t\tif (mDelKeyValues.getText(i).toString().equals(mHost.getDelKey())) {\n\t\t\t\tmDelKeyText.setText(mDelKeyNames.getText(i));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tmEncodingItem = view.findViewById(R.id.encoding_item);\n\t\tmEncodingItem.setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tPopupMenu menu = new PopupMenu(getActivity(), v);\n\t\t\t\tfor (String displayName : mCharsetData.keySet()) {\n\t\t\t\t\tmenu.getMenu().add(displayName);\n\t\t\t\t}\n\t\t\t\tmenu.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\t\tfor (String displayName : mCharsetData.keySet()) {\n\t\t\t\t\t\t\tif (displayName.equals(item.getTitle())) {\n\t\t\t\t\t\t\t\tmHost.setEncoding(mCharsetData.get(displayName));\n\t\t\t\t\t\t\t\tmEncodingText.setText(displayName);\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tmenu.show();\n\t\t\t}\n\t\t});\n\n\t\t// The encoding text is initialized in setCharsetData() because Charset data is not always\n\t\t// available when this fragment is created.\n\t\tmEncodingText = (TextView) view.findViewById(R.id.encoding_text);\n\n\t\tmUseSshAuthSwitch = (CheckableMenuItem) view.findViewById(R.id.use_ssh_auth_item);\n\t\tmUseSshAuthSwitch.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {\n\t\t\t@Override\n\t\t\tpublic void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {\n\t\t\t\tprocessSshAuthChange();\n\t\t\t}\n\t\t});\n\n\t\tmUseSshConfirmationSwitch = (CheckableMenuItem) view.findViewById(R.id.ssh_auth_confirmation_item);\n\t\tmUseSshAuthSwitch.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {\n\t\t\t@Override\n\t\t\tpublic void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {\n\t\t\t\tprocessSshAuthChange();\n\t\t\t}\n\t\t});\n\n\t\tprocessSshAuthChange();\n\n\t\tmCompressionSwitch = (CheckableMenuItem) view.findViewById(R.id.compression_item);\n\t\tmCompressionSwitch.setChecked(mHost.getCompression());\n\t\tmCompressionSwitch.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {\n\t\t\t@Override\n\t\t\tpublic void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {\n\t\t\t\tmHost.setCompression(isChecked);\n\t\t\t\thandleHostChange();\n\t\t\t}\n\t\t});\n\n\t\tmStartShellSwitch = (CheckableMenuItem) view.findViewById(R.id.start_shell_item);\n\t\tmStartShellSwitch.setChecked(mHost.getWantSession());\n\t\tmStartShellSwitch.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {\n\t\t\t@Override\n\t\t\tpublic void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {\n\t\t\t\tmHost.setWantSession(isChecked);\n\t\t\t\thandleHostChange();\n\t\t\t}\n\t\t});\n\n\t\tmStayConnectedSwitch = (CheckableMenuItem) view.findViewById(R.id.stay_connected_item);\n\t\tmStayConnectedSwitch.setChecked(mHost.getStayConnected());\n\t\tmStayConnectedSwitch.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {\n\t\t\t@Override\n\t\t\tpublic void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {\n\t\t\t\tmHost.setStayConnected(isChecked);\n\t\t\t\thandleHostChange();\n\t\t\t}\n\t\t});\n\n\t\tmCloseOnDisconnectSwitch = (CheckableMenuItem) view.findViewById(R.id.close_on_disconnect_item);\n\t\tmCloseOnDisconnectSwitch.setChecked(mHost.getQuickDisconnect());\n\t\tmCloseOnDisconnectSwitch.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {\n\t\t\t@Override\n\t\t\tpublic void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {\n\t\t\t\tmHost.setQuickDisconnect(isChecked);\n\t\t\t\thandleHostChange();\n\t\t\t}\n\t\t});\n\n\t\tmPostLoginAutomationField = (EditText) view.findViewById(R.id.post_login_automation_field);\n\t\tmPostLoginAutomationField.setText(mHost.getPostLogin());\n\t\tmPostLoginAutomationField.addTextChangedListener(\n\t\t\t\tnew HostTextFieldWatcher(HostDatabase.FIELD_HOST_POSTLOGIN));\n\n\t\tsetUriPartsContainerExpanded(mIsUriEditorExpanded);\n\n\t\treturn view;\n\t}\n\n\t/**\n\t * @param protocol The protocol to set.\n\t * @param setDefaultPortInModel True if the model's port should be updated to the default port\n\t *     for the given protocol.\n\t */\n\tprivate void setTransportType(String protocol, boolean setDefaultPortInModel) {\n\t\tmHost.setProtocol(protocol);\n\t\tif (setDefaultPortInModel)\n\t\t\tmHost.setPort(TransportFactory.getTransport(protocol).getDefaultPort());\n\t\thandleHostChange();\n\n\t\tmTransportText.setText(protocol);\n\n\t\tmQuickConnectContainer.setHint(\n\t\t\t\tTransportFactory.getFormatHint(protocol, getActivity()));\n\n\t\t// Different protocols have different field types, so show only the fields needed.\n\t\tif (SSH.getProtocolName().equals(protocol)) {\n\t\t\tmUsernameContainer.setVisibility(View.VISIBLE);\n\t\t\tmHostnameContainer.setVisibility(View.VISIBLE);\n\t\t\tmPortContainer.setVisibility(View.VISIBLE);\n\t\t\tmExpandCollapseButton.setVisibility(View.VISIBLE);\n\t\t\tmNicknameItem.setVisibility(View.VISIBLE);\n\t\t} else if (Telnet.getProtocolName().equals(protocol)) {\n\t\t\tmUsernameContainer.setVisibility(View.GONE);\n\t\t\tmHostnameContainer.setVisibility(View.VISIBLE);\n\t\t\tmPortContainer.setVisibility(View.VISIBLE);\n\t\t\tmExpandCollapseButton.setVisibility(View.VISIBLE);\n\t\t\tmNicknameItem.setVisibility(View.VISIBLE);\n\t\t} else {\n\t\t\t// Local protocol has only one field, so no need to show the URI parts\n\t\t\t// container.\n\t\t\tsetUriPartsContainerExpanded(false);\n\t\t\tmExpandCollapseButton.setVisibility(View.GONE);\n\t\t\tmNicknameItem.setVisibility(View.GONE);\n\t\t}\n\t}\n\n\tprivate void setFontSize(int fontSize) {\n\t\tif (fontSize < MINIMUM_FONT_SIZE)\n\t\t\tfontSize = MINIMUM_FONT_SIZE;\n\n\t\tif (fontSize > MAXIMUM_FONT_SIZE)\n\t\t\tfontSize = MAXIMUM_FONT_SIZE;\n\n\t\tmHost.setFontSize(fontSize);\n\n\t\tif (mFontSizeSeekBar.getProgress() + MINIMUM_FONT_SIZE != fontSize) {\n\t\t\tmFontSizeSeekBar.setProgress(fontSize - MINIMUM_FONT_SIZE);\n\t\t}\n\n\t\tInteger fontSizeFromEditText = null;\n\t\ttry {\n\t\t\tfontSizeFromEditText = Integer.parseInt(mFontSizeText.getText().toString());\n\t\t} catch (NumberFormatException ignored) {\n\t\t}\n\n\t\tif (fontSizeFromEditText == null || fontSizeFromEditText != fontSize) {\n\t\t\tmFontSizeText.removeTextChangedListener(mFontSizeTextChangeListener);\n\t\t\tmFontSizeText.setText(Integer.toString(fontSize));\n\t\t\tmFontSizeText.addTextChangedListener(mFontSizeTextChangeListener);\n\t\t}\n\n\t\thandleHostChange();\n\t}\n\n\tprivate void processSshAuthChange() {\n\t\tmUseSshConfirmationSwitch.setVisibility(\n\t\t\t\tmUseSshAuthSwitch.isChecked() ? View.VISIBLE : View.GONE);\n\n\t\tif (mUseSshAuthSwitch.isChecked()) {\n\t\t\t//noinspection ResourceType\n\t\t\tmHost.setUseAuthAgent(\n\t\t\t\t\tmUseSshConfirmationSwitch.isChecked() ?\n\t\t\t\t\t\t\t\t\tHostDatabase.AUTHAGENT_CONFIRM :\n\t\t\t\t\t\t\t\t\tHostDatabase.AUTHAGENT_YES);\n\t\t} else {\n\t\t\tmHost.setUseAuthAgent(HostDatabase.AUTHAGENT_NO);\n\t\t}\n\n\t\thandleHostChange();\n\t}\n\n\t@Override\n\tpublic void onAttach(Context context) {\n\t\tsuper.onAttach(context);\n\t\ttry {\n\t\t\tmListener = (Listener) context;\n\t\t} catch (ClassCastException e) {\n\t\t\tthrow new ClassCastException(context.toString() + \" must implement Listener\");\n\t\t}\n\n\t\t// Now that the fragment is attached to an Activity, fetch the arrays from the attached\n\t\t// Activity's resources.\n\t\tmColorNames = getResources().obtainTypedArray(R.array.list_colors);\n\t\tmColorValues = getResources().obtainTypedArray(R.array.list_color_values);\n\t\tmDelKeyNames = getResources().obtainTypedArray(R.array.list_delkey);\n\t\tmDelKeyValues = getResources().obtainTypedArray(R.array.list_delkey_values);\n\t}\n\n\t@Override\n\tpublic void onDetach() {\n\t\tsuper.onDetach();\n\t\tmListener = null;\n\t\tmColorNames.recycle();\n\t\tmColorValues.recycle();\n\t\tmDelKeyNames.recycle();\n\t\tmDelKeyValues.recycle();\n\t}\n\n\t@Override\n\tpublic void onSaveInstanceState(Bundle savedInstanceState) {\n\t\tsuper.onSaveInstanceState(savedInstanceState);\n\n\t\tsavedInstanceState.putLong(ARG_EXISTING_HOST_ID, mHost.getId());\n\t\tsavedInstanceState.putParcelable(ARG_EXISTING_HOST, mHost.getValues());\n\t\tsavedInstanceState.putBoolean(ARG_IS_EXPANDED, mIsUriEditorExpanded);\n\t\tsavedInstanceState.putString(\n\t\t\t\tARG_QUICKCONNECT_STRING, mQuickConnectField.getText().toString());\n\t\tsavedInstanceState.putStringArrayList(ARG_PUBKEY_NAMES, mPubkeyNames);\n\t\tsavedInstanceState.putStringArrayList(ARG_PUBKEY_VALUES, mPubkeyValues);\n\t}\n\n\t/**\n\t * Sets the Charset encoding data for the editor.\n\t * @param data A map from Charset display name to Charset value (i.e., unique ID for the\n\t *     Charset).\n\t */\n\tpublic void setCharsetData(final Map<String, String> data) {\n\t\tmCharsetData = data;\n\n\t\tif (mEncodingText != null) {\n\t\t\tIterator it = data.entrySet().iterator();\n\t\t\twhile (it.hasNext()) {\n\t\t\t\tMap.Entry<String, String> pair = (Map.Entry) it.next();\n\t\t\t\tif (pair.getValue().equals(mHost.getEncoding())) {\n\t\t\t\t\tmEncodingText.setText(pair.getKey());\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void setUriPartsContainerExpanded(boolean expanded) {\n\t\tmIsUriEditorExpanded = expanded;\n\n\t\tif (mIsUriEditorExpanded) {\n\t\t\tmExpandCollapseButton.setImageResource(R.drawable.ic_expand_less);\n\t\t\tmUriPartsContainer.setVisibility(View.VISIBLE);\n\t\t} else {\n\t\t\tmExpandCollapseButton.setImageResource(R.drawable.ic_expand_more);\n\t\t\tmUriPartsContainer.setVisibility(View.GONE);\n\t\t}\n\t}\n\n\t/**\n\t * Applies the quick-connect URI entered in the field by copying its URI parts to mHost's\n\t * fields.\n\t * @param quickConnectString The URI entered in the quick-connect field.\n\t * @param protocol The protocol for this connection.\n\t */\n\tprivate void applyQuickConnectString(String quickConnectString, String protocol) {\n\t\tif (quickConnectString == null || protocol == null)\n\t\t\treturn;\n\n\t\tUri uri = TransportFactory.getUri(protocol, quickConnectString);\n\t\tif (uri == null) {\n\t\t\t// If the URI was invalid, null out the associated fields.\n\t\t\tmHost.setProtocol(protocol);\n\t\t\tmHost.setUsername(null);\n\t\t\tmHost.setHostname(null);\n\t\t\tmHost.setNickname(null);\n\t\t\tmHost.setPort(TransportFactory.getTransport(protocol).getDefaultPort());\n\t\t\treturn;\n\t\t}\n\n\t\tHostBean host = TransportFactory.getTransport(protocol).createHost(uri);\n\t\tmHost.setProtocol(host.getProtocol());\n\t\tmHost.setUsername(host.getUsername());\n\t\tmHost.setHostname(host.getHostname());\n\t\tmHost.setNickname(host.getNickname());\n\t\tmHost.setPort(host.getPort());\n\t\thandleHostChange();\n\t}\n\n\t/**\n\t * Handles a change in the host caused by the user adjusting the values of one of the widgets\n\t * in this fragment. If the change has resulted in a valid host, the new value is sent back\n\t * to the listener; however, if the change ha resulted in an invalid host, the listener is\n\t * notified.\n\t */\n\tprivate void handleHostChange() {\n\t\tString quickConnectString = mQuickConnectField.getText().toString();\n\t\tif (quickConnectString == null || quickConnectString.equals(\"\")) {\n\t\t\t// Invalid protocol and/or string, so don't do anything.\n\t\t\tmListener.onHostInvalidated();\n\t\t\treturn;\n\t\t}\n\n\t\tUri uri = TransportFactory.getUri(mHost.getProtocol(), quickConnectString);\n\t\tif (uri == null) {\n\t\t\t// Valid string, but does not accurately describe a URI.\n\t\t\tmListener.onHostInvalidated();\n\t\t\treturn;\n\t\t}\n\n\t\t// Now, the host is confirmed to have a valid URI.\n\t\tmListener.onValidHostConfigured(mHost);\n\t}\n\n\tpublic interface Listener {\n\t\tvoid onValidHostConfigured(HostBean host);\n\t\tvoid onHostInvalidated();\n\t}\n\n\tprivate class HostTextFieldWatcher implements TextWatcher {\n\n\t\tprivate final String mFieldType;\n\n\t\tpublic HostTextFieldWatcher(String fieldType) {\n\t\t\tmFieldType = fieldType;\n\t\t}\n\n\t\t@Override\n\t\tpublic void beforeTextChanged(CharSequence s, int start, int count, int after) {}\n\n\t\t@Override\n\t\tpublic void onTextChanged(CharSequence s, int start, int before, int count) {}\n\n\t\t@Override\n\t\tpublic void afterTextChanged(Editable s) {\n\t\t\tString text = s.toString();\n\n\t\t\tif (HostDatabase.FIELD_HOST_USERNAME.equals(mFieldType)) {\n\t\t\t\tmHost.setUsername(text);\n\t\t\t} else if (HostDatabase.FIELD_HOST_HOSTNAME.equals(mFieldType)) {\n\t\t\t\tmHost.setHostname(text);\n\t\t\t} else if (HostDatabase.FIELD_HOST_PORT.equals(mFieldType)) {\n\t\t\t\ttry {\n\t\t\t\t\tmHost.setPort(Integer.parseInt(text));\n\t\t\t\t} catch (NumberFormatException e) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else if (HostDatabase.FIELD_HOST_NICKNAME.equals(mFieldType)) {\n\t\t\t\tmHost.setNickname(text);\n\t\t\t} else if (HostDatabase.FIELD_HOST_POSTLOGIN.equals(mFieldType)) {\n\t\t\t\tmHost.setPostLogin(text);\n\t\t\t} else if (HostDatabase.FIELD_HOST_FONTSIZE.equals(mFieldType)) {\n\t\t\t\tint fontSize = HostBean.DEFAULT_FONT_SIZE;\n\t\t\t\ttry {\n\t\t\t\t\tfontSize = Integer.parseInt(text);\n\t\t\t\t} catch (NumberFormatException e) {\n\t\t\t\t} finally {\n\t\t\t\t\tsetFontSize(fontSize);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new RuntimeException(\"Invalid field type.\");\n\t\t\t}\n\n\t\t\tif (isUriRelatedField(mFieldType)) {\n\t\t\t\tmNicknameField.setText(mHost.toString());\n\t\t\t\tmHost.setNickname(mHost.toString());\n\n\t\t\t\tif (!mUriFieldEditInProgress) {\n\t\t\t\t\tmUriFieldEditInProgress = true;\n\t\t\t\t\tmQuickConnectField.setText(mHost.toString());\n\t\t\t\t\tmUriFieldEditInProgress = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\thandleHostChange();\n\t\t}\n\n\t\tprivate boolean isUriRelatedField(String fieldType) {\n\t\t\treturn HostDatabase.FIELD_HOST_USERNAME.equals(fieldType) ||\n\t\t\t\t\tHostDatabase.FIELD_HOST_HOSTNAME.equals(fieldType) ||\n\t\t\t\t\tHostDatabase.FIELD_HOST_PORT.equals(fieldType);\n\t\t}\n\t}\n}\n","lineNo":536}
{"Smelly Sample":"/*\n * ConnectBot: simple, powerful, open-source SSH client for Android\n * Copyright 2015 Kenny Root, Jeffrey Sharkey\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.connectbot.util;\n\nimport org.connectbot.R;\nimport org.connectbot.TerminalView;\nimport org.connectbot.service.TerminalBridge;\n\nimport android.annotation.TargetApi;\nimport android.content.Context;\nimport android.graphics.Color;\nimport android.graphics.Typeface;\nimport android.os.Build;\nimport android.support.v4.view.MotionEventCompat;\nimport android.text.ClipboardManager;\nimport android.view.ActionMode;\nimport android.view.InputDevice;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.MotionEvent;\nimport android.view.inputmethod.EditorInfo;\nimport android.view.inputmethod.InputConnection;\nimport android.widget.TextView;\nimport de.mud.terminal.VDUBuffer;\nimport de.mud.terminal.vt320;\n\n/**\n * Custom TextView {@link TextView} which is intended to (invisibly) be on top of the TerminalView\n * (@link TerminalView) in order to allow the user to select and copy the text of the bitmap below.\n *\n * @author rhansby\n */\n@TargetApi(11)\npublic class TerminalTextViewOverlay extends TextView {\n\tpublic TerminalView terminalView; // ryan: this name sucks\n\tprivate String currentSelection = \"\";\n\tprivate ActionMode selectionActionMode;\n\tprivate ClipboardManager clipboard;\n\n\tprivate int oldBufferHeight = 0;\n\tprivate int oldScrollY = -1;\n\n\tpublic TerminalTextViewOverlay(Context context, TerminalView terminalView) {\n\t\tsuper(context);\n\n\t\tthis.terminalView = terminalView;\n\t\tclipboard = (ClipboardManager) getContext().getSystemService(Context.CLIPBOARD_SERVICE);\n\n\t\tsetTextColor(Color.TRANSPARENT);\n\t\tsetTypeface(Typeface.MONOSPACE);\n\t\tsetTextIsSelectable(true);\n\t\tsetCustomSelectionActionModeCallback(new TextSelectionActionModeCallback());\n\t}\n\n\tpublic void refreshTextFromBuffer() {\n\t\tVDUBuffer vb = terminalView.bridge.getVDUBuffer();\n\t\tint numRows = vb.getBufferSize();\n\t\tint numCols = vb.getColumns() - 1;\n\t\toldBufferHeight = numRows;\n\n\t\tStringBuilder buffer = new StringBuilder();\n\n\t\tfor (int r = 0; r < numRows && vb.charArray[r] != null; r++) {\n\t\t\tfor (int c = 0; c < numCols; c++) {\n\t\t\t\tbuffer.append(vb.charArray[r][c]);\n\t\t\t}\n\t\t\twhile (buffer.length() > 0 &&\n\t\t\t\t\tCharacter.isWhitespace(buffer.charAt(buffer.length() - 1))) {\n\t\t\t\tbuffer.setLength(buffer.length() - 1);\n\t\t\t}\n\t\t\tbuffer.append('\\n');\n\t\t}\n\n\t\toldScrollY = vb.getWindowBase() * getLineHeight();\n\n\t\tsetText(buffer);\n\t}\n\n\t/**\n\t * If there is a new line in the buffer, add an empty line\n\t * in this TextView, so that selection seems to move up with the\n\t * rest of the buffer.\n\t */\n\tpublic void onBufferChanged() {\n\t\tVDUBuffer vb = terminalView.bridge.getVDUBuffer();\n\t\tint numRows = vb.getBufferSize();\n\t\tint numNewRows = numRows - oldBufferHeight;\n\n\t\tif (numNewRows <= 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tStringBuilder newLines = new StringBuilder(numNewRows);\n\t\tfor (int i = 0; i < numNewRows; i++) {\n\t\t\tnewLines.append('\\n');\n\t\t}\n\n\t\toldScrollY = (vb.getWindowBase() + numNewRows) * getLineHeight();\n\t\toldBufferHeight = numRows;\n\n\t\tappend(newLines);\n\t}\n\n\t@Override\n\tpublic boolean onPreDraw() {\n\t\tboolean superResult = super.onPreDraw();\n\n\t\tif (oldScrollY >= 0) {\n\t\t\tscrollTo(0, oldScrollY);\n\t\t\toldScrollY = -1;\n\t\t}\n\n\t\treturn superResult;\n\t}\n\n\tprivate void closeSelectionActionMode() {\n\t\tif (selectionActionMode != null) {\n\t\t\tselectionActionMode.finish();\n\t\t\tselectionActionMode = null;\n\t\t}\n\t}\n\n\tpublic void copyCurrentSelectionToClipboard() {\n\t\tif (currentSelection.length() != 0) {\n\t\t\tclipboard.setText(currentSelection);\n\t\t}\n\t\tcloseSelectionActionMode();\n\t}\n\n\tprivate void pasteClipboard() {\n\t\tString clip = \"\";\n\t\tif (clipboard.hasText()) {\n\t\t\tclip = clipboard.getText().toString();\n\t\t}\n\t\tterminalView.bridge.injectString(clip);\n\t}\n\n\t@Override\n\tprotected void onSelectionChanged(int selStart, int selEnd) {\n\t\tif (selStart >= 0 && selEnd >= 0 && selStart <= selEnd) {\n\t\t\tcurrentSelection = getText().toString().substring(selStart, selEnd);\n\t\t}\n\t\tsuper.onSelectionChanged(selStart, selEnd);\n\t}\n\n\t@Override\n\tpublic void scrollTo(int x, int y) {\n\t\tint lineMultiple = y / getLineHeight();\n\n\t\tTerminalBridge bridge = terminalView.bridge;\n\t\tbridge.buffer.setWindowBase(lineMultiple);\n\n\t\tsuper.scrollTo(0, lineMultiple * getLineHeight());\n\t}\n\n\t@Override\n\tpublic boolean onTouchEvent(MotionEvent event) {\n\t\tif (event.getAction() == MotionEvent.ACTION_DOWN) {\n\t\t\t// Selection may be beginning. Sync the TextView with the buffer.\n\t\t\trefreshTextFromBuffer();\n\t\t}\n\n\t\t// Mouse input is treated differently:\n\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH &&\n\t\t\t\tMotionEventCompat.getSource(event) == InputDevice.SOURCE_MOUSE) {\n\t\t\tif (onMouseEvent(event, terminalView.bridge)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tterminalView.viewPager.setPagingEnabled(true);\n\t\t} else {\n\t\t\tif (terminalView.onTouchEvent(event)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn super.onTouchEvent(event);\n\t}\n\n\t@Override\n\t@TargetApi(12)\n\tpublic boolean onGenericMotionEvent(MotionEvent event) {\n\t\tif ((MotionEventCompat.getSource(event) & InputDevice.SOURCE_CLASS_POINTER) != 0) {\n\t\t\tswitch (event.getAction()) {\n\t\t\tcase MotionEvent.ACTION_SCROLL:\n\t\t\t\t// Process scroll wheel movement:\n\t\t\t\tfloat yDistance = MotionEventCompat.getAxisValue(event, MotionEvent.AXIS_VSCROLL);\n\n\t\t\t\tvt320 vtBuffer = (vt320) terminalView.bridge.buffer;\n\t\t\t\tboolean mouseReport = vtBuffer.isMouseReportEnabled();\n\t\t\t\tif (mouseReport) {\n\t\t\t\t\tint row = (int) Math.floor(event.getY() / terminalView.bridge.charHeight);\n\t\t\t\t\tint col = (int) Math.floor(event.getX() / terminalView.bridge.charWidth);\n\n\t\t\t\t\tvtBuffer.mouseWheel(\n\t\t\t\t\t\t\tyDistance > 0,\n\t\t\t\t\t\t\tcol,\n\t\t\t\t\t\t\trow,\n\t\t\t\t\t\t\t(event.getMetaState() & KeyEvent.META_CTRL_ON) != 0,\n\t\t\t\t\t\t\t(event.getMetaState() & KeyEvent.META_SHIFT_ON) != 0,\n\t\t\t\t\t\t\t(event.getMetaState() & KeyEvent.META_META_ON) != 0);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn super.onGenericMotionEvent(event);\n\t}\n\n\t/**\n\t * @param event\n\t * @param bridge\n\t * @return True if the event is handled.\n\t */\n\t@TargetApi(14)\n\tprivate boolean onMouseEvent(MotionEvent event, TerminalBridge bridge) {\n\t\tint row = (int) Math.floor(event.getY() / bridge.charHeight);\n\t\tint col = (int) Math.floor(event.getX() / bridge.charWidth);\n\t\tint meta = event.getMetaState();\n\t\tboolean shiftOn = (meta & KeyEvent.META_SHIFT_ON) != 0;\n\t\tvt320 vtBuffer = (vt320) bridge.buffer;\n\t\tboolean mouseReport = vtBuffer.isMouseReportEnabled();\n\n\t\t// MouseReport can be \"defeated\" using the shift key.\n\t\tif (!mouseReport || shiftOn) {\n\t\t\tif (event.getAction() == MotionEvent.ACTION_DOWN) {\n\t\t\t\tif (event.getButtonState() == MotionEvent.BUTTON_TERTIARY) {\n\t\t\t\t\t// Middle click pastes.\n\t\t\t\t\tpasteClipboard();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\t// Begin \"selection mode\"\n\n\t\t\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {\n\t\t\t\t\tcloseSelectionActionMode();\n\t\t\t\t}\n\t\t\t} else if (event.getAction() == MotionEvent.ACTION_MOVE) {\n\t\t\t\t// In the middle of selection.\n\n\t\t\t\tif (selectionActionMode == null) {\n\t\t\t\t\tselectionActionMode = startActionMode(new TextSelectionActionModeCallback());\n\t\t\t\t}\n\n\t\t\t\tint selectionStart = getSelectionStart();\n\t\t\t\tint selectionEnd = getSelectionEnd();\n\n\t\t\t\tif (selectionStart > selectionEnd) {\n\t\t\t\t\tint tempStart = selectionStart;\n\t\t\t\t\tselectionStart = selectionEnd;\n\t\t\t\t\tselectionEnd = tempStart;\n\t\t\t\t}\n\n\t\t\t\tcurrentSelection = getText().toString().substring(selectionStart, selectionEnd);\n\t\t\t}\n\t\t} else if (event.getAction() == MotionEvent.ACTION_DOWN) {\n\t\t\tterminalView.viewPager.setPagingEnabled(false);\n\t\t\tvtBuffer.mousePressed(\n\t\t\t\t\tcol, row, mouseEventToJavaModifiers(event));\n\t\t\treturn true;\n\t\t} else if (event.getAction() == MotionEvent.ACTION_UP) {\n\t\t\tterminalView.viewPager.setPagingEnabled(true);\n\t\t\tvtBuffer.mouseReleased(col, row);\n\t\t\treturn true;\n\t\t} else if (event.getAction() == MotionEvent.ACTION_MOVE) {\n\t\t\tint buttonState = event.getButtonState();\n\t\t\tint button = (buttonState & MotionEvent.BUTTON_PRIMARY) != 0 ? 0 :\n\t\t\t\t\t(buttonState & MotionEvent.BUTTON_SECONDARY) != 0 ? 1 :\n\t\t\t\t\t\t\t(buttonState & MotionEvent.BUTTON_TERTIARY) != 0 ? 2 : 3;\n\t\t\tvtBuffer.mouseMoved(\n\t\t\t\t\tbutton,\n\t\t\t\t\tcol,\n\t\t\t\t\trow,\n\t\t\t\t\t(meta & KeyEvent.META_CTRL_ON) != 0,\n\t\t\t\t\t(meta & KeyEvent.META_SHIFT_ON) != 0,\n\t\t\t\t\t(meta & KeyEvent.META_META_ON) != 0);\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Takes an android mouse event and produces a Java InputEvent modifiers int which can be\n\t * passed to vt320.\n\t * @param mouseEvent The {@link MotionEvent} which should be a mouse click or release.\n\t * @return A Java InputEvent modifier int. See\n\t * http://docs.oracle.com/javase/7/docs/api/java/awt/event/InputEvent.html\n\t */\n\t@TargetApi(14)\n\tprivate static int mouseEventToJavaModifiers(MotionEvent mouseEvent) {\n\t\tif (MotionEventCompat.getSource(mouseEvent) != InputDevice.SOURCE_MOUSE) return 0;\n\n\t\tint mods = 0;\n\n\t\t// See http://docs.oracle.com/javase/7/docs/api/constant-values.html\n\t\tint buttonState = mouseEvent.getButtonState();\n\t\tif ((buttonState & MotionEvent.BUTTON_PRIMARY) != 0)\n\t\t\tmods |= 16;\n\t\tif ((buttonState & MotionEvent.BUTTON_SECONDARY) != 0)\n\t\t\tmods |= 8;\n\t\tif ((buttonState & MotionEvent.BUTTON_TERTIARY) != 0)\n\t\t\tmods |= 4;\n\n\t\t// Note: Meta and Ctrl are intentionally swapped here to keep logic in vt320 simple.\n\t\tint meta = mouseEvent.getMetaState();\n\t\tif ((meta & KeyEvent.META_META_ON) != 0)\n\t\t\tmods |= 2;\n\t\tif ((meta & KeyEvent.META_SHIFT_ON) != 0)\n\t\t\tmods |= 1;\n\t\tif ((meta & KeyEvent.META_CTRL_ON) != 0)\n\t\t\tmods |= 4;\n\n\t\treturn mods;\n\t}\n\n\t@Override\n\tpublic boolean onCheckIsTextEditor() {\n\t\t// This prevents a cursor being displayed within the text.\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic InputConnection onCreateInputConnection(EditorInfo outAttrs) {\n\t\treturn terminalView.onCreateInputConnection(outAttrs);\n\t}\n\n\tprivate class TextSelectionActionModeCallback implements ActionMode.Callback {\n\t\tprivate static final int COPY = 0;\n\t\tprivate static final int PASTE = 1;\n\n\t\t@Override\n\t\tpublic boolean onPrepareActionMode(ActionMode mode, Menu menu) {\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean onCreateActionMode(ActionMode mode, Menu menu) {\n\t\t\tTerminalTextViewOverlay.this.selectionActionMode = mode;\n\n\t\t\tmenu.clear();\n\n\t\t\tmenu.add(0, COPY, 0, R.string.console_menu_copy)\n\t\t\t\t\t.setIcon(R.drawable.ic_action_copy)\n\t\t\t\t\t.setShowAsAction(MenuItem.SHOW_AS_ACTION_WITH_TEXT | MenuItem.SHOW_AS_ACTION_IF_ROOM);\n\t\t\tmenu.add(0, PASTE, 1, R.string.console_menu_paste)\n\t\t\t\t\t.setIcon(R.drawable.ic_action_paste)\n\t\t\t\t\t.setShowAsAction(MenuItem.SHOW_AS_ACTION_WITH_TEXT | MenuItem.SHOW_AS_ACTION_IF_ROOM);\n\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean onActionItemClicked(ActionMode mode, MenuItem item) {\n\t\t\tswitch (item.getItemId()) {\n\t\t\tcase COPY:\n\t\t\t\tcopyCurrentSelectionToClipboard();\n\t\t\t\treturn true;\n\t\t\tcase PASTE:\n\t\t\t\tpasteClipboard();\n\t\t\t\tmode.finish();\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic void onDestroyActionMode(ActionMode mode) {\n\t\t}\n\t}\n}\n","Method after Refactoring":"/*\n * ConnectBot: simple, powerful, open-source SSH client for Android\n * Copyright 2015 Kenny Root, Jeffrey Sharkey\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.connectbot.util;\n\nimport org.connectbot.R;\nimport org.connectbot.TerminalView;\nimport org.connectbot.service.TerminalBridge;\n\nimport android.annotation.TargetApi;\nimport android.content.Context;\nimport android.graphics.Color;\nimport android.graphics.Typeface;\nimport android.os.Build;\nimport android.support.v4.view.MotionEventCompat;\nimport android.text.ClipboardManager;\nimport android.view.ActionMode;\nimport android.view.InputDevice;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.MotionEvent;\nimport android.view.inputmethod.EditorInfo;\nimport android.view.inputmethod.InputConnection;\nimport android.widget.TextView;\nimport de.mud.terminal.VDUBuffer;\nimport de.mud.terminal.vt320;\n\n/**\n * Custom TextView {@link TextView} which is intended to (invisibly) be on top of the TerminalView\n * (@link TerminalView) in order to allow the user to select and copy the text of the bitmap below.\n *\n * @author rhansby\n */\n@TargetApi(11)\npublic class TerminalTextViewOverlay extends TextView {\n\tpublic TerminalView terminalView; // ryan: this name sucks\n\tprivate String currentSelection = \"\";\n\tprivate ActionMode selectionActionMode;\n\tprivate ClipboardManager clipboard;\n\n\tprivate int oldBufferHeight = 0;\n\tprivate int oldScrollY = -1;\n\n\tpublic TerminalTextViewOverlay(Context context, TerminalView terminalView) {\n\t\tsuper(context);\n\n\t\tthis.terminalView = terminalView;\n\t\tclipboard = (ClipboardManager) getContext().getSystemService(Context.CLIPBOARD_SERVICE);\n\n\t\tsetTextColor(Color.TRANSPARENT);\n\t\tsetTypeface(Typeface.MONOSPACE);\n\t\tsetTextIsSelectable(true);\n\t\tsetCustomSelectionActionModeCallback(new TextSelectionActionModeCallback());\n\t}\n\n\tpublic void refreshTextFromBuffer() {\n\t\tVDUBuffer vb = terminalView.bridge.getVDUBuffer();\n\t\tint numRows = vb.getBufferSize();\n\t\tint numCols = vb.getColumns() - 1;\n\t\toldBufferHeight = numRows;\n\n\t\tStringBuilder buffer = new StringBuilder();\n\t\tint previousTotalLength = 0;\n\n\t\tfor (int r = 0; r < numRows && vb.charArray[r] != null; r++) {\n\t\t\tfor (int c = 0; c < numCols; c++) {\n\t\t\t\tbuffer.append(vb.charArray[r][c]);\n\t\t\t}\n\n\t\t\t// Truncate all the new whitespace without removing the old data.\n\t\t\twhile (buffer.length() > previousTotalLength &&\n\t\t\t\t\tCharacter.isWhitespace(buffer.charAt(buffer.length() - 1))) {\n\t\t\t\tbuffer.setLength(buffer.length() - 1);\n\t\t\t}\n\n\t\t\t// Make sure each line ends with a carriage return and then remember the buffer\n\t\t\t// at that length.\n\t\t\tbuffer.append('\\n');\n\t\t\tpreviousTotalLength = buffer.length();\n\t\t}\n\n\t\toldScrollY = vb.getWindowBase() * getLineHeight();\n\n\t\tsetText(buffer);\n\t}\n\n\t/**\n\t * If there is a new line in the buffer, add an empty line\n\t * in this TextView, so that selection seems to move up with the\n\t * rest of the buffer.\n\t */\n\tpublic void onBufferChanged() {\n\t\tVDUBuffer vb = terminalView.bridge.getVDUBuffer();\n\t\tint numRows = vb.getBufferSize();\n\t\tint numNewRows = numRows - oldBufferHeight;\n\n\t\tif (numNewRows <= 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tStringBuilder newLines = new StringBuilder(numNewRows);\n\t\tfor (int i = 0; i < numNewRows; i++) {\n\t\t\tnewLines.append('\\n');\n\t\t}\n\n\t\toldScrollY = (vb.getWindowBase() + numNewRows) * getLineHeight();\n\t\toldBufferHeight = numRows;\n\n\t\tappend(newLines);\n\t}\n\n\t@Override\n\tpublic boolean onPreDraw() {\n\t\tboolean superResult = super.onPreDraw();\n\n\t\tif (oldScrollY >= 0) {\n\t\t\tscrollTo(0, oldScrollY);\n\t\t\toldScrollY = -1;\n\t\t}\n\n\t\treturn superResult;\n\t}\n\n\tprivate void closeSelectionActionMode() {\n\t\tif (selectionActionMode != null) {\n\t\t\tselectionActionMode.finish();\n\t\t\tselectionActionMode = null;\n\t\t}\n\t}\n\n\tpublic void copyCurrentSelectionToClipboard() {\n\t\tif (currentSelection.length() != 0) {\n\t\t\tclipboard.setText(currentSelection);\n\t\t}\n\t\tcloseSelectionActionMode();\n\t}\n\n\tprivate void pasteClipboard() {\n\t\tString clip = \"\";\n\t\tif (clipboard.hasText()) {\n\t\t\tclip = clipboard.getText().toString();\n\t\t}\n\t\tterminalView.bridge.injectString(clip);\n\t}\n\n\t@Override\n\tprotected void onSelectionChanged(int selStart, int selEnd) {\n\t\tif (selStart >= 0 && selEnd >= 0 && selStart <= selEnd) {\n\t\t\tcurrentSelection = getText().toString().substring(selStart, selEnd);\n\t\t}\n\t\tsuper.onSelectionChanged(selStart, selEnd);\n\t}\n\n\t@Override\n\tpublic void scrollTo(int x, int y) {\n\t\tint lineMultiple = y / getLineHeight();\n\n\t\tTerminalBridge bridge = terminalView.bridge;\n\t\tbridge.buffer.setWindowBase(lineMultiple);\n\n\t\tsuper.scrollTo(0, lineMultiple * getLineHeight());\n\t}\n\n\t@Override\n\tpublic boolean onTouchEvent(MotionEvent event) {\n\t\tif (event.getAction() == MotionEvent.ACTION_DOWN) {\n\t\t\t// Selection may be beginning. Sync the TextView with the buffer.\n\t\t\trefreshTextFromBuffer();\n\t\t}\n\n\t\t// Mouse input is treated differently:\n\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH &&\n\t\t\t\tMotionEventCompat.getSource(event) == InputDevice.SOURCE_MOUSE) {\n\t\t\tif (onMouseEvent(event, terminalView.bridge)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tterminalView.viewPager.setPagingEnabled(true);\n\t\t} else {\n\t\t\tif (terminalView.onTouchEvent(event)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn super.onTouchEvent(event);\n\t}\n\n\t@Override\n\t@TargetApi(12)\n\tpublic boolean onGenericMotionEvent(MotionEvent event) {\n\t\tif ((MotionEventCompat.getSource(event) & InputDevice.SOURCE_CLASS_POINTER) != 0) {\n\t\t\tswitch (event.getAction()) {\n\t\t\tcase MotionEvent.ACTION_SCROLL:\n\t\t\t\t// Process scroll wheel movement:\n\t\t\t\tfloat yDistance = MotionEventCompat.getAxisValue(event, MotionEvent.AXIS_VSCROLL);\n\n\t\t\t\tvt320 vtBuffer = (vt320) terminalView.bridge.buffer;\n\t\t\t\tboolean mouseReport = vtBuffer.isMouseReportEnabled();\n\t\t\t\tif (mouseReport) {\n\t\t\t\t\tint row = (int) Math.floor(event.getY() / terminalView.bridge.charHeight);\n\t\t\t\t\tint col = (int) Math.floor(event.getX() / terminalView.bridge.charWidth);\n\n\t\t\t\t\tvtBuffer.mouseWheel(\n\t\t\t\t\t\t\tyDistance > 0,\n\t\t\t\t\t\t\tcol,\n\t\t\t\t\t\t\trow,\n\t\t\t\t\t\t\t(event.getMetaState() & KeyEvent.META_CTRL_ON) != 0,\n\t\t\t\t\t\t\t(event.getMetaState() & KeyEvent.META_SHIFT_ON) != 0,\n\t\t\t\t\t\t\t(event.getMetaState() & KeyEvent.META_META_ON) != 0);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn super.onGenericMotionEvent(event);\n\t}\n\n\t/**\n\t * @param event\n\t * @param bridge\n\t * @return True if the event is handled.\n\t */\n\t@TargetApi(14)\n\tprivate boolean onMouseEvent(MotionEvent event, TerminalBridge bridge) {\n\t\tint row = (int) Math.floor(event.getY() / bridge.charHeight);\n\t\tint col = (int) Math.floor(event.getX() / bridge.charWidth);\n\t\tint meta = event.getMetaState();\n\t\tboolean shiftOn = (meta & KeyEvent.META_SHIFT_ON) != 0;\n\t\tvt320 vtBuffer = (vt320) bridge.buffer;\n\t\tboolean mouseReport = vtBuffer.isMouseReportEnabled();\n\n\t\t// MouseReport can be \"defeated\" using the shift key.\n\t\tif (!mouseReport || shiftOn) {\n\t\t\tif (event.getAction() == MotionEvent.ACTION_DOWN) {\n\t\t\t\tif (event.getButtonState() == MotionEvent.BUTTON_TERTIARY) {\n\t\t\t\t\t// Middle click pastes.\n\t\t\t\t\tpasteClipboard();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\t// Begin \"selection mode\"\n\n\t\t\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {\n\t\t\t\t\tcloseSelectionActionMode();\n\t\t\t\t}\n\t\t\t} else if (event.getAction() == MotionEvent.ACTION_MOVE) {\n\t\t\t\t// In the middle of selection.\n\n\t\t\t\tif (selectionActionMode == null) {\n\t\t\t\t\tselectionActionMode = startActionMode(new TextSelectionActionModeCallback());\n\t\t\t\t}\n\n\t\t\t\tint selectionStart = getSelectionStart();\n\t\t\t\tint selectionEnd = getSelectionEnd();\n\n\t\t\t\tif (selectionStart > selectionEnd) {\n\t\t\t\t\tint tempStart = selectionStart;\n\t\t\t\t\tselectionStart = selectionEnd;\n\t\t\t\t\tselectionEnd = tempStart;\n\t\t\t\t}\n\n\t\t\t\tcurrentSelection = getText().toString().substring(selectionStart, selectionEnd);\n\t\t\t}\n\t\t} else if (event.getAction() == MotionEvent.ACTION_DOWN) {\n\t\t\tterminalView.viewPager.setPagingEnabled(false);\n\t\t\tvtBuffer.mousePressed(\n\t\t\t\t\tcol, row, mouseEventToJavaModifiers(event));\n\t\t\treturn true;\n\t\t} else if (event.getAction() == MotionEvent.ACTION_UP) {\n\t\t\tterminalView.viewPager.setPagingEnabled(true);\n\t\t\tvtBuffer.mouseReleased(col, row);\n\t\t\treturn true;\n\t\t} else if (event.getAction() == MotionEvent.ACTION_MOVE) {\n\t\t\tint buttonState = event.getButtonState();\n\t\t\tint button = (buttonState & MotionEvent.BUTTON_PRIMARY) != 0 ? 0 :\n\t\t\t\t\t(buttonState & MotionEvent.BUTTON_SECONDARY) != 0 ? 1 :\n\t\t\t\t\t\t\t(buttonState & MotionEvent.BUTTON_TERTIARY) != 0 ? 2 : 3;\n\t\t\tvtBuffer.mouseMoved(\n\t\t\t\t\tbutton,\n\t\t\t\t\tcol,\n\t\t\t\t\trow,\n\t\t\t\t\t(meta & KeyEvent.META_CTRL_ON) != 0,\n\t\t\t\t\t(meta & KeyEvent.META_SHIFT_ON) != 0,\n\t\t\t\t\t(meta & KeyEvent.META_META_ON) != 0);\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Takes an android mouse event and produces a Java InputEvent modifiers int which can be\n\t * passed to vt320.\n\t * @param mouseEvent The {@link MotionEvent} which should be a mouse click or release.\n\t * @return A Java InputEvent modifier int. See\n\t * http://docs.oracle.com/javase/7/docs/api/java/awt/event/InputEvent.html\n\t */\n\t@TargetApi(14)\n\tprivate static int mouseEventToJavaModifiers(MotionEvent mouseEvent) {\n\t\tif (MotionEventCompat.getSource(mouseEvent) != InputDevice.SOURCE_MOUSE) return 0;\n\n\t\tint mods = 0;\n\n\t\t// See http://docs.oracle.com/javase/7/docs/api/constant-values.html\n\t\tint buttonState = mouseEvent.getButtonState();\n\t\tif ((buttonState & MotionEvent.BUTTON_PRIMARY) != 0)\n\t\t\tmods |= 16;\n\t\tif ((buttonState & MotionEvent.BUTTON_SECONDARY) != 0)\n\t\t\tmods |= 8;\n\t\tif ((buttonState & MotionEvent.BUTTON_TERTIARY) != 0)\n\t\t\tmods |= 4;\n\n\t\t// Note: Meta and Ctrl are intentionally swapped here to keep logic in vt320 simple.\n\t\tint meta = mouseEvent.getMetaState();\n\t\tif ((meta & KeyEvent.META_META_ON) != 0)\n\t\t\tmods |= 2;\n\t\tif ((meta & KeyEvent.META_SHIFT_ON) != 0)\n\t\t\tmods |= 1;\n\t\tif ((meta & KeyEvent.META_CTRL_ON) != 0)\n\t\t\tmods |= 4;\n\n\t\treturn mods;\n\t}\n\n\t@Override\n\tpublic boolean onCheckIsTextEditor() {\n\t\t// This prevents a cursor being displayed within the text.\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic InputConnection onCreateInputConnection(EditorInfo outAttrs) {\n\t\treturn terminalView.onCreateInputConnection(outAttrs);\n\t}\n\n\tprivate class TextSelectionActionModeCallback implements ActionMode.Callback {\n\t\tprivate static final int COPY = 0;\n\t\tprivate static final int PASTE = 1;\n\n\t\t@Override\n\t\tpublic boolean onPrepareActionMode(ActionMode mode, Menu menu) {\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean onCreateActionMode(ActionMode mode, Menu menu) {\n\t\t\tTerminalTextViewOverlay.this.selectionActionMode = mode;\n\n\t\t\tmenu.clear();\n\n\t\t\tmenu.add(0, COPY, 0, R.string.console_menu_copy)\n\t\t\t\t\t.setIcon(R.drawable.ic_action_copy)\n\t\t\t\t\t.setShowAsAction(MenuItem.SHOW_AS_ACTION_WITH_TEXT | MenuItem.SHOW_AS_ACTION_IF_ROOM);\n\t\t\tmenu.add(0, PASTE, 1, R.string.console_menu_paste)\n\t\t\t\t\t.setIcon(R.drawable.ic_action_paste)\n\t\t\t\t\t.setShowAsAction(MenuItem.SHOW_AS_ACTION_WITH_TEXT | MenuItem.SHOW_AS_ACTION_IF_ROOM);\n\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean onActionItemClicked(ActionMode mode, MenuItem item) {\n\t\t\tswitch (item.getItemId()) {\n\t\t\tcase COPY:\n\t\t\t\tcopyCurrentSelectionToClipboard();\n\t\t\t\treturn true;\n\t\t\tcase PASTE:\n\t\t\t\tpasteClipboard();\n\t\t\t\tmode.finish();\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic void onDestroyActionMode(ActionMode mode) {\n\t\t}\n\t}\n}\n","lineNo":78}
{"Smelly Sample":"/*\n * ConnectBot: simple, powerful, open-source SSH client for Android\n * Copyright 2007 Kenny Root, Jeffrey Sharkey\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.connectbot;\n\nimport java.io.BufferedReader;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.DataInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URI;\nimport java.nio.charset.Charset;\nimport java.security.KeyPair;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.util.Collections;\nimport java.util.EventListener;\nimport java.util.LinkedList;\nimport java.util.List;\n\nimport org.connectbot.bean.PubkeyBean;\nimport org.connectbot.service.TerminalManager;\nimport org.connectbot.util.PubkeyDatabase;\nimport org.connectbot.util.PubkeyUtils;\nimport org.openintents.intents.FileManagerIntents;\n\nimport com.trilead.ssh2.crypto.Base64;\nimport com.trilead.ssh2.crypto.PEMDecoder;\nimport com.trilead.ssh2.crypto.PEMStructure;\n\nimport android.content.ActivityNotFoundException;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.DialogInterface.OnClickListener;\nimport android.content.Intent;\nimport android.content.ServiceConnection;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Environment;\nimport android.os.IBinder;\nimport android.support.annotation.VisibleForTesting;\nimport android.support.v7.widget.LinearLayoutManager;\nimport android.support.v7.widget.RecyclerView;\nimport android.text.ClipboardManager;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.LayoutInflater;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.MenuItem.OnMenuItemClickListener;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.EditText;\nimport android.widget.ImageView;\nimport android.widget.TableRow;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\n/**\n * List public keys in database by nickname and describe their properties. Allow users to import,\n * generate, rename, and delete key pairs.\n *\n * @author Kenny Root\n */\npublic class PubkeyListActivity extends AppCompatListActivity implements EventListener {\n\tpublic final static String TAG = \"CB.PubkeyListActivity\";\n\n\tprivate static final int MAX_KEYFILE_SIZE = 32768;\n\tprivate static final int REQUEST_CODE_PICK_FILE = 1;\n\n\t// Constants for AndExplorer's file picking intent\n\tprivate static final String ANDEXPLORER_TITLE = \"explorer_title\";\n\tprivate static final String MIME_TYPE_ANDEXPLORER_FILE = \"vnd.android.cursor.dir/lysesoft.andexplorer.file\";\n\n\tprivate List<PubkeyBean> pubkeys;\n\n\tprotected ClipboardManager clipboard;\n\n\tprotected LayoutInflater inflater = null;\n\n\tprotected TerminalManager bound = null;\n\n\tprivate MenuItem onstartToggle = null;\n\tprivate MenuItem confirmUse = null;\n\n\tprivate ServiceConnection connection = new ServiceConnection() {\n\t\tpublic void onServiceConnected(ComponentName className, IBinder service) {\n\t\t\tbound = ((TerminalManager.TerminalBinder) service).getService();\n\n\t\t\t// update our listview binder to find the service\n\t\t\tupdateList();\n\t\t}\n\n\t\tpublic void onServiceDisconnected(ComponentName className) {\n\t\t\tbound = null;\n\t\t\tupdateList();\n\t\t}\n\t};\n\n\t@Override\n\tpublic void onStart() {\n\t\tsuper.onStart();\n\n\t\tbindService(new Intent(this, TerminalManager.class), connection, Context.BIND_AUTO_CREATE);\n\n\t\tupdateList();\n\t}\n\n\t@Override\n\tpublic void onStop() {\n\t\tsuper.onStop();\n\n\t\tunbindService(connection);\n\t}\n\n\t@Override\n\tpublic void onCreate(Bundle icicle) {\n\t\tsuper.onCreate(icicle);\n\t\tsetContentView(R.layout.act_pubkeylist);\n\n\t\tmListView = (RecyclerView) findViewById(R.id.list);\n\t\tmListView.setHasFixedSize(true);\n\t\tmListView.setLayoutManager(new LinearLayoutManager(this));\n\t\tmListView.addItemDecoration(new ListItemDecoration(this));\n\n\t\tmEmptyView = findViewById(R.id.empty);\n\n\t\tregisterForContextMenu(mListView);\n\n\t\tclipboard = (ClipboardManager) getSystemService(CLIPBOARD_SERVICE);\n\n\t\tinflater = LayoutInflater.from(this);\n\t}\n\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu) {\n\t\tMenuInflater inflater = getMenuInflater();\n\t\tinflater.inflate(R.menu.pubkey_list_activity_menu, menu);\n\t\treturn super.onCreateOptionsMenu(menu);\n\t}\n\n\t@Override\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tswitch (item.getItemId()) {\n\t\tcase R.id.add_new_key_icon:\n\t\t\tstartActivity(new Intent(this, GeneratePubkeyActivity.class));\n\t\t\treturn true;\n\t\tcase R.id.import_existing_key_icon:\n\t\t\timportExistingKey();\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn super.onOptionsItemSelected(item);\n\t\t}\n\t}\n\n\tprivate boolean importExistingKey() {\n\t\tUri sdcard = Uri.fromFile(Environment.getExternalStorageDirectory());\n\t\tString pickerTitle = getString(R.string.pubkey_list_pick);\n\n\t\treturn importExistingKeyKitKat() || importExistingKeyOpenIntents(sdcard, pickerTitle)\n\t\t\t\t|| importExistingKeyAndExplorer(sdcard, pickerTitle) || pickFileSimple();\n\t}\n\n\t/**\n\t * Fires an intent to spin up the \"file chooser\" UI and select a private key.\n\t */\n\tpublic boolean importExistingKeyKitKat() {\n\t\t// ACTION_OPEN_DOCUMENT is the intent to choose a file via the system's file\n\t\t// browser.\n\t\tIntent intent = new Intent(Intent.ACTION_OPEN_DOCUMENT);\n\n\t\t// Filter to only show results that can be \"opened\", such as a\n\t\t// file (as opposed to a list of contacts or timezones)\n\t\tintent.addCategory(Intent.CATEGORY_OPENABLE);\n\n\t\t// PKCS#8 MIME types aren't widely supported, so we'll try */* fro now.\n\t\tintent.setType(\"*/*\");\n\n\t\ttry {\n\t\t\tstartActivityForResult(intent, REQUEST_CODE_PICK_FILE);\n\t\t\treturn true;\n\t\t} catch (ActivityNotFoundException e) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Imports an existing key using the OpenIntents-style request.\n\t */\n\tprivate boolean importExistingKeyOpenIntents(Uri sdcard, String pickerTitle) {\n\t\t// Try to use OpenIntent's file browser to pick a file\n\t\tIntent intent = new Intent(FileManagerIntents.ACTION_PICK_FILE);\n\t\tintent.setData(sdcard);\n\t\tintent.putExtra(FileManagerIntents.EXTRA_TITLE, pickerTitle);\n\t\tintent.putExtra(FileManagerIntents.EXTRA_BUTTON_TEXT, getString(android.R.string.ok));\n\n\t\ttry {\n\t\t\tstartActivityForResult(intent, REQUEST_CODE_PICK_FILE);\n\t\t\treturn true;\n\t\t} catch (ActivityNotFoundException e) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate boolean importExistingKeyAndExplorer(Uri sdcard, String pickerTitle) {\n\t\tIntent intent;// If OI didn't work, try AndExplorer\n\t\tintent = new Intent(Intent.ACTION_PICK);\n\t\tintent.setDataAndType(sdcard, MIME_TYPE_ANDEXPLORER_FILE);\n\t\tintent.putExtra(ANDEXPLORER_TITLE, pickerTitle);\n\n\t\ttry {\n\t\t\tstartActivityForResult(intent, REQUEST_CODE_PICK_FILE);\n\t\t\treturn true;\n\t\t} catch (ActivityNotFoundException e) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Builds a simple list of files to pick from.\n\t */\n\tprivate boolean pickFileSimple() {\n\t\t// build list of all files in sdcard root\n\t\tfinal File sdcard = Environment.getExternalStorageDirectory();\n\t\tLog.d(TAG, sdcard.toString());\n\n\t\t// Don't show a dialog if the SD card is completely absent.\n\t\tfinal String state = Environment.getExternalStorageState();\n\t\tif (!Environment.MEDIA_MOUNTED_READ_ONLY.equals(state)\n\t\t\t\t&& !Environment.MEDIA_MOUNTED.equals(state)) {\n\t\t\tnew android.support.v7.app.AlertDialog.Builder(\n\t\t\t\t\tPubkeyListActivity.this, R.style.AlertDialogTheme)\n\t\t\t\t\t.setMessage(R.string.alert_sdcard_absent)\n\t\t\t\t\t.setNegativeButton(android.R.string.cancel, null).create().show();\n\t\t\treturn true;\n\t\t}\n\n\t\tList<String> names = new LinkedList<String>();\n\t\t{\n\t\t\tFile[] files = sdcard.listFiles();\n\t\t\tif (files != null) {\n\t\t\t\tfor (File file : sdcard.listFiles()) {\n\t\t\t\t\tif (file.isDirectory()) continue;\n\t\t\t\t\tnames.add(file.getName());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tCollections.sort(names);\n\n\t\tfinal String[] namesList = names.toArray(new String[] {});\n\t\tLog.d(TAG, names.toString());\n\n\t\t// prompt user to select any file from the sdcard root\n\t\tnew android.support.v7.app.AlertDialog.Builder(\n\t\t\t\tPubkeyListActivity.this, R.style.AlertDialogTheme)\n\t\t\t\t.setTitle(R.string.pubkey_list_pick)\n\t\t\t\t.setItems(namesList, new OnClickListener() {\n\t\t\t\t\tpublic void onClick(DialogInterface arg0, int arg1) {\n\t\t\t\t\t\tString name = namesList[arg1];\n\n\t\t\t\t\t\treadKeyFromFile(Uri.fromFile(new File(sdcard, name)));\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.setNegativeButton(android.R.string.cancel, null).create().show();\n\n\t\treturn true;\n\t}\n\n\tprotected void handleAddKey(final PubkeyBean pubkey) {\n\t\tif (pubkey.isEncrypted()) {\n\t\t\tfinal View view = View.inflate(this, R.layout.dia_password, null);\n\t\t\tfinal EditText passwordField = (EditText) view.findViewById(android.R.id.text1);\n\n\t\t\tnew android.support.v7.app.AlertDialog.Builder(\n\t\t\t\t\tPubkeyListActivity.this, R.style.AlertDialogTheme)\n\t\t\t\t.setView(view)\n\t\t\t\t.setPositiveButton(R.string.pubkey_unlock, new DialogInterface.OnClickListener() {\n\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\t\thandleAddKey(pubkey, passwordField.getText().toString());\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.setNegativeButton(android.R.string.cancel, null).create().show();\n\t\t} else {\n\t\t\thandleAddKey(pubkey, null);\n\t\t}\n\t}\n\n\tprotected void handleAddKey(PubkeyBean keybean, String password) {\n\t\tKeyPair pair = null;\n\t\tif (PubkeyDatabase.KEY_TYPE_IMPORTED.equals(keybean.getType())) {\n\t\t\t// load specific key using pem format\n\t\t\ttry {\n\t\t\t\tpair = PEMDecoder.decode(new String(keybean.getPrivateKey()).toCharArray(), password);\n\t\t\t} catch (Exception e) {\n\t\t\t\tString message = getResources().getString(R.string.pubkey_failed_add, keybean.getNickname());\n\t\t\t\tLog.e(TAG, message, e);\n\t\t\t\tToast.makeText(PubkeyListActivity.this, message, Toast.LENGTH_LONG).show();\n\t\t\t}\n\t\t} else {\n\t\t\t// load using internal generated format\n\t\t\ttry {\n\t\t\t\tPrivateKey privKey = PubkeyUtils.decodePrivate(keybean.getPrivateKey(), keybean.getType(), password);\n\t\t\t\tPublicKey pubKey = PubkeyUtils.decodePublic(keybean.getPublicKey(), keybean.getType());\n\t\t\t\tLog.d(TAG, \"Unlocked key \" + PubkeyUtils.formatKey(pubKey));\n\n\t\t\t\tpair = new KeyPair(pubKey, privKey);\n\t\t\t} catch (Exception e) {\n\t\t\t\tString message = getResources().getString(R.string.pubkey_failed_add, keybean.getNickname());\n\t\t\t\tLog.e(TAG, message, e);\n\t\t\t\tToast.makeText(PubkeyListActivity.this, message, Toast.LENGTH_LONG).show();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (pair == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tLog.d(TAG, String.format(\"Unlocked key '%s'\", keybean.getNickname()));\n\n\t\t// save this key in memory\n\t\tbound.addKey(keybean, pair, true);\n\n\t\tupdateList();\n\t}\n\n\tprotected void updateList() {\n\t\tPubkeyDatabase pubkeyDb = PubkeyDatabase.get(PubkeyListActivity.this);\n\t\tpubkeys = pubkeyDb.allPubkeys();\n\n\t\tmAdapter = new PubkeyAdapter(this, pubkeys);\n\t\tmListView.setAdapter(mAdapter);\n\t\tadjustViewVisibility();\n\t}\n\n\t@Override\n\tprotected void onActivityResult(int requestCode, int resultCode, Intent resultData) {\n\t\tsuper.onActivityResult(requestCode, resultCode, resultData);\n\n\t\tswitch (requestCode) {\n\t\tcase REQUEST_CODE_PICK_FILE:\n\t\t\tif (resultCode == RESULT_OK && resultData != null) {\n\t\t\t\tUri uri = resultData.getData();\n\t\t\t\ttry {\n\t\t\t\t\tif (uri != null) {\n\t\t\t\t\t\treadKeyFromFile(uri);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tString filename = resultData.getDataString();\n\t\t\t\t\t\tif (filename != null) {\n\t\t\t\t\t\t\treadKeyFromFile(Uri.parse(filename));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\t\tLog.e(TAG, \"Couldn't read from picked file\", e);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tpublic static byte[] getBytesFromInputStream(InputStream is, int maxSize) throws IOException {\n\t\tByteArrayOutputStream os = new ByteArrayOutputStream();\n\t\tbyte[] buffer = new byte[0xFFFF];\n\n\t\tfor (int len; (len = is.read(buffer)) != -1 && os.size() < maxSize; ) {\n\t\t\tos.write(buffer, 0, len);\n\t\t}\n\n\t\tif (os.size() >= maxSize) {\n\t\t\tthrow new IOException(\"File was too big\");\n\t\t}\n\n\t\tos.flush();\n\t\treturn os.toByteArray();\n\t}\n\n\tprivate KeyPair readPKCS8Key(byte[] keyData) {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(new ByteArrayInputStream(keyData)));\n\n\t\t// parse the actual key once to check if its encrypted\n\t\t// then save original file contents into our database\n\t\ttry {\n\t\t\tByteArrayOutputStream keyBytes = new ByteArrayOutputStream();\n\n\t\t\tString line;\n\t\t\tboolean inKey = false;\n\t\t\twhile ((line = reader.readLine()) != null) {\n\t\t\t\tif (line.equals(PubkeyUtils.PKCS8_START)) {\n\t\t\t\t\tinKey = true;\n\t\t\t\t} else if (line.equals(PubkeyUtils.PKCS8_END)) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (inKey) {\n\t\t\t\t\tkeyBytes.write(line.getBytes(\"US-ASCII\"));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (keyBytes.size() > 0) {\n\t\t\t\tbyte[] decoded = Base64.decode(keyBytes.toString().toCharArray());\n\n\t\t\t\treturn PubkeyUtils.recoverKeyPair(decoded);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\treturn null;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * @param uri URI to private key to read.\n\t */\n\tprivate void readKeyFromFile(Uri uri) {\n\t\tPubkeyBean pubkey = new PubkeyBean();\n\n\t\t// find the exact file selected\n\t\tpubkey.setNickname(uri.getLastPathSegment());\n\n\t\tbyte[] keyData;\n\t\ttry {\n\t\t\tContentResolver resolver = getContentResolver();\n\t\t\tkeyData = getBytesFromInputStream(resolver.openInputStream(uri), MAX_KEYFILE_SIZE);\n\t\t} catch (IOException e) {\n\t\t\tToast.makeText(PubkeyListActivity.this,\n\t\t\t\t\tR.string.pubkey_import_parse_problem,\n\t\t\t\t\tToast.LENGTH_LONG).show();\n\t\t\treturn;\n\t\t}\n\n\t\tKeyPair kp;\n\t\tif ((kp = readPKCS8Key(keyData)) != null) {\n\t\t\tpubkey.setType(kp.getPrivate().getAlgorithm());\n\t\t\tpubkey.setPrivateKey(kp.getPrivate().getEncoded());\n\t\t\tpubkey.setPublicKey(kp.getPublic().getEncoded());\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tPEMStructure struct = PEMDecoder.parsePEM(new String(keyData).toCharArray());\n\t\t\t\tboolean encrypted = PEMDecoder.isPEMEncrypted(struct);\n\t\t\t\tpubkey.setEncrypted(encrypted);\n\t\t\t\tif (!encrypted) {\n\t\t\t\t\tkp = PEMDecoder.decode(struct, null);\n\t\t\t\t\tpubkey.setType(kp.getPrivate().getAlgorithm());\n\t\t\t\t\tpubkey.setPrivateKey(kp.getPrivate().getEncoded());\n\t\t\t\t\tpubkey.setPublicKey(kp.getPublic().getEncoded());\n\t\t\t\t} else {\n\t\t\t\t\tpubkey.setType(PubkeyDatabase.KEY_TYPE_IMPORTED);\n\t\t\t\t\tpubkey.setPrivateKey(keyData);\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\tLog.e(TAG, \"Problem parsing imported private key\", e);\n\t\t\t\tToast.makeText(PubkeyListActivity.this, R.string.pubkey_import_parse_problem, Toast.LENGTH_LONG).show();\n\t\t\t}\n\t\t}\n\n\t\t// write new value into database\n\t\tPubkeyDatabase pubkeyDb = PubkeyDatabase.get(this);\n\t\tpubkeyDb.savePubkey(pubkey);\n\n\t\tupdateList();\n\t}\n\n\t/**\n\t *\n\t */\n\tprivate void pickFileSimple() {\n\t\t// build list of all files in sdcard root\n\t\tfinal File sdcard = Environment.getExternalStorageDirectory();\n\t\tLog.d(TAG, sdcard.toString());\n\n\t\t// Don't show a dialog if the SD card is completely absent.\n\t\tfinal String state = Environment.getExternalStorageState();\n\t\tif (!Environment.MEDIA_MOUNTED_READ_ONLY.equals(state)\n\t\t\t\t&& !Environment.MEDIA_MOUNTED.equals(state)) {\n\t\t\tnew android.support.v7.app.AlertDialog.Builder(\n\t\t\t\t\tPubkeyListActivity.this, R.style.AlertDialogTheme)\n\t\t\t\t.setMessage(R.string.alert_sdcard_absent)\n\t\t\t\t.setNegativeButton(android.R.string.cancel, null).create().show();\n\t\t\treturn;\n\t\t}\n\n\t\tList<String> names = new LinkedList<String>();\n\t\t{\n\t\t\tFile[] files = sdcard.listFiles();\n\t\t\tif (files != null) {\n\t\t\t\tfor (File file : files) {\n\t\t\t\t\tif (file == null || file.isDirectory()) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tnames.add(file.getName());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tCollections.sort(names);\n\n\t\tfinal String[] namesList = names.toArray(new String[] {});\n\t\tLog.d(TAG, names.toString());\n\n\t\t// prompt user to select any file from the sdcard root\n\t\tnew android.support.v7.app.AlertDialog.Builder(\n\t\t\t\tPubkeyListActivity.this, R.style.AlertDialogTheme)\n\t\t\t.setTitle(R.string.pubkey_list_pick)\n\t\t\t.setItems(namesList, new OnClickListener() {\n\t\t\t\tpublic void onClick(DialogInterface arg0, int arg1) {\n\t\t\t\t\tString name = namesList[arg1];\n\n\t\t\t\t\treadKeyFromFile(new File(sdcard, name));\n\t\t\t\t}\n\t\t\t})\n\t\t\t.setNegativeButton(android.R.string.cancel, null).create().show();\n\t}\n\n\tpublic class PubkeyViewHolder extends ItemViewHolder {\n\t\tpublic final ImageView icon;\n\t\tpublic final TextView nickname;\n\t\tpublic final TextView caption;\n\n\t\tpublic PubkeyBean pubkey;\n\n\t\tpublic PubkeyViewHolder(View v) {\n\t\t\tsuper(v);\n\n\t\t\ticon = (ImageView) v.findViewById(android.R.id.icon);\n\t\t\tnickname = (TextView) v.findViewById(android.R.id.text1);\n\t\t\tcaption = (TextView) v.findViewById(android.R.id.text2);\n\t\t}\n\n\t\t@Override\n\t\tpublic void onClick(View v) {\n\t\t\tboolean loaded = bound != null && bound.isKeyLoaded(pubkey.getNickname());\n\n\t\t\t// handle toggling key in-memory on/off\n\t\t\tif (loaded) {\n\t\t\t\tbound.removeKey(pubkey.getNickname());\n\t\t\t\tupdateList();\n\t\t\t} else {\n\t\t\t\thandleAddKey(pubkey);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void onCreateContextMenu(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo) {\n\t\t\t// Create menu to handle deleting and editing pubkey\n\t\t\tmenu.setHeaderTitle(pubkey.getNickname());\n\n\t\t\t// TODO: option load/unload key from in-memory list\n\t\t\t// prompt for password as needed for passworded keys\n\n\t\t\t// cant change password or clipboard imported keys\n\t\t\tfinal boolean imported = PubkeyDatabase.KEY_TYPE_IMPORTED.equals(pubkey.getType());\n\t\t\tfinal boolean loaded = bound != null && bound.isKeyLoaded(pubkey.getNickname());\n\n\t\t\tMenuItem load = menu.add(loaded ? R.string.pubkey_memory_unload : R.string.pubkey_memory_load);\n\t\t\tload.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\tif (loaded) {\n\t\t\t\t\t\tbound.removeKey(pubkey.getNickname());\n\t\t\t\t\t\tupdateList();\n\t\t\t\t\t} else {\n\t\t\t\t\t\thandleAddKey(pubkey);\n\t\t\t\t\t\t//bound.addKey(nickname, trileadKey);\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tonstartToggle = menu.add(R.string.pubkey_load_on_start);\n\t\t\tonstartToggle.setEnabled(!pubkey.isEncrypted());\n\t\t\tonstartToggle.setCheckable(true);\n\t\t\tonstartToggle.setChecked(pubkey.isStartup());\n\t\t\tonstartToggle.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\t// toggle onstart status\n\t\t\t\t\tpubkey.setStartup(!pubkey.isStartup());\n\t\t\t\t\tPubkeyDatabase pubkeyDb = PubkeyDatabase.get(PubkeyListActivity.this);\n\t\t\t\t\tpubkeyDb.savePubkey(pubkey);\n\t\t\t\t\tupdateList();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tMenuItem copyPublicToClipboard = menu.add(R.string.pubkey_copy_public);\n\t\t\tcopyPublicToClipboard.setEnabled(!imported);\n\t\t\tcopyPublicToClipboard.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tPublicKey pk = PubkeyUtils.decodePublic(pubkey.getPublicKey(), pubkey.getType());\n\t\t\t\t\t\tString openSSHPubkey = PubkeyUtils.convertToOpenSSHFormat(pk, pubkey.getNickname());\n\n\t\t\t\t\t\tclipboard.setText(openSSHPubkey);\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tMenuItem copyPrivateToClipboard = menu.add(R.string.pubkey_copy_private);\n\t\t\tcopyPrivateToClipboard.setEnabled(!pubkey.isEncrypted() || imported);\n\t\t\tcopyPrivateToClipboard.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tString data = null;\n\n\t\t\t\t\t\tif (imported)\n\t\t\t\t\t\t\tdata = new String(pubkey.getPrivateKey());\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tPrivateKey pk = PubkeyUtils.decodePrivate(pubkey.getPrivateKey(), pubkey.getType());\n\t\t\t\t\t\t\tdata = PubkeyUtils.exportPEM(pk, null);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tclipboard.setText(data);\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tMenuItem changePassword = menu.add(R.string.pubkey_change_password);\n\t\t\tchangePassword.setEnabled(!imported);\n\t\t\tchangePassword.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\tfinal View changePasswordView =\n\t\t\t\t\t\t\tView.inflate(PubkeyListActivity.this, R.layout.dia_changepassword, null);\n\t\t\t\t\t((TableRow) changePasswordView.findViewById(R.id.old_password_prompt))\n\t\t\t\t\t\t\t.setVisibility(pubkey.isEncrypted() ? View.VISIBLE : View.GONE);\n\t\t\t\t\tnew android.support.v7.app.AlertDialog.Builder(\n\t\t\t\t\t\t\t\t\tPubkeyListActivity.this, R.style.AlertDialogTheme)\n\t\t\t\t\t\t\t.setView(changePasswordView)\n\t\t\t\t\t\t\t.setPositiveButton(R.string.button_change, new DialogInterface.OnClickListener() {\n\t\t\t\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\t\t\t\t\tString oldPassword = ((EditText) changePasswordView.findViewById(R.id.old_password)).getText().toString();\n\t\t\t\t\t\t\t\t\tString password1 = ((EditText) changePasswordView.findViewById(R.id.password1)).getText().toString();\n\t\t\t\t\t\t\t\t\tString password2 = ((EditText) changePasswordView.findViewById(R.id.password2)).getText().toString();\n\n\t\t\t\t\t\t\t\t\tif (!password1.equals(password2)) {\n\t\t\t\t\t\t\t\t\t\tnew android.support.v7.app.AlertDialog.Builder(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tPubkeyListActivity.this,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tR.style.AlertDialogTheme)\n\t\t\t\t\t\t\t\t\t\t\t\t.setMessage(R.string.alert_passwords_do_not_match_msg)\n\t\t\t\t\t\t\t\t\t\t\t\t.setPositiveButton(android.R.string.ok, null)\n\t\t\t\t\t\t\t\t\t\t\t\t.create().show();\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tif (!pubkey.changePassword(oldPassword, password1))\n\t\t\t\t\t\t\t\t\t\t\tnew android.support.v7.app.AlertDialog.Builder(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tPubkeyListActivity.this,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tR.style.AlertDialogTheme)\n\t\t\t\t\t\t\t\t\t\t\t\t\t.setMessage(R.string.alert_wrong_password_msg)\n\t\t\t\t\t\t\t\t\t\t\t\t\t.setPositiveButton(android.R.string.ok, null)\n\t\t\t\t\t\t\t\t\t\t\t\t\t.create().show();\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\tPubkeyDatabase pubkeyDb = PubkeyDatabase.get(PubkeyListActivity.this);\n\t\t\t\t\t\t\t\t\t\t\tpubkeyDb.savePubkey(pubkey);\n\t\t\t\t\t\t\t\t\t\t\tupdateList();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\t\t\t\tLog.e(TAG, \"Could not change private key password\", e);\n\t\t\t\t\t\t\t\t\t\tnew android.support.v7.app.AlertDialog.Builder(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tPubkeyListActivity.this,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tR.style.AlertDialogTheme)\n\t\t\t\t\t\t\t\t\t\t\t\t.setMessage(R.string.alert_key_corrupted_msg)\n\t\t\t\t\t\t\t\t\t\t\t\t.setPositiveButton(android.R.string.ok, null)\n\t\t\t\t\t\t\t\t\t\t\t\t.create().show();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t.setNegativeButton(android.R.string.cancel, null).create().show();\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tconfirmUse = menu.add(R.string.pubkey_confirm_use);\n\t\t\tconfirmUse.setCheckable(true);\n\t\t\tconfirmUse.setChecked(pubkey.isConfirmUse());\n\t\t\tconfirmUse.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\t// toggle confirm use\n\t\t\t\t\tpubkey.setConfirmUse(!pubkey.isConfirmUse());\n\t\t\t\t\tPubkeyDatabase pubkeyDb = PubkeyDatabase.get(PubkeyListActivity.this);\n\t\t\t\t\tpubkeyDb.savePubkey(pubkey);\n\t\t\t\t\tupdateList();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tMenuItem delete = menu.add(R.string.pubkey_delete);\n\t\t\tdelete.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\t// prompt user to make sure they really want this\n\t\t\t\t\tnew android.support.v7.app.AlertDialog.Builder(\n\t\t\t\t\t\t\t\t\tPubkeyListActivity.this, R.style.AlertDialogTheme)\n\t\t\t\t\t\t\t.setMessage(getString(R.string.delete_message, pubkey.getNickname()))\n\t\t\t\t\t\t\t.setPositiveButton(R.string.delete_pos, new DialogInterface.OnClickListener() {\n\t\t\t\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\n\t\t\t\t\t\t\t\t\t// dont forget to remove from in-memory\n\t\t\t\t\t\t\t\t\tif (loaded) {\n\t\t\t\t\t\t\t\t\t\tbound.removeKey(pubkey.getNickname());\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// delete from backend database and update gui\n\t\t\t\t\t\t\t\t\tPubkeyDatabase pubkeyDb = PubkeyDatabase.get(PubkeyListActivity.this);\n\t\t\t\t\t\t\t\t\tpubkeyDb.deletePubkey(pubkey);\n\t\t\t\t\t\t\t\t\tupdateList();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t.setNegativeButton(R.string.delete_neg, null).create().show();\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t@VisibleForTesting\n\tprivate class PubkeyAdapter extends ItemAdapter {\n\t\tprivate final List<PubkeyBean> pubkeys;\n\n\t\tpublic PubkeyAdapter(Context context, List<PubkeyBean> pubkeys) {\n\t\t\tsuper(context);\n\t\t\tthis.pubkeys = pubkeys;\n\t\t}\n\n\t\t@Override\n\t\tpublic PubkeyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n\t\t\tView v = LayoutInflater.from(parent.getContext())\n\t\t\t\t\t.inflate(R.layout.item_pubkey, parent, false);\n\t\t\tPubkeyViewHolder vh = new PubkeyViewHolder(v);\n\t\t\treturn vh;\n\t\t}\n\n\t\tpublic void onBindViewHolder(ItemViewHolder holder, int position) {\n\t\t\tPubkeyViewHolder pubkeyHolder = (PubkeyViewHolder) holder;\n\n\t\t\tPubkeyBean pubkey = pubkeys.get(position);\n\t\t\tpubkeyHolder.pubkey = pubkey;\n\t\t\tif (pubkey == null) {\n\t\t\t\t// Well, something bad happened. We can't continue.\n\t\t\t\tLog.e(\"PubkeyAdapter\", \"Pubkey bean is null!\");\n\n\t\t\t\tpubkeyHolder.nickname.setText(\"Error during lookup\");\n\t\t\t} else {\n\t\t\t\tpubkeyHolder.nickname.setText(pubkey.getNickname());\n\t\t\t}\n\n\t\t\tboolean imported = PubkeyDatabase.KEY_TYPE_IMPORTED.equals(pubkey.getType());\n\n\t\t\tif (imported) {\n\t\t\t\ttry {\n\t\t\t\t\tPEMStructure struct = PEMDecoder.parsePEM(new String(pubkey.getPrivateKey()).toCharArray());\n\t\t\t\t\tString type;\n\t\t\t\t\tif (struct.pemType == PEMDecoder.PEM_RSA_PRIVATE_KEY) {\n\t\t\t\t\t\ttype = \"RSA\";\n\t\t\t\t\t} else if (struct.pemType == PEMDecoder.PEM_DSA_PRIVATE_KEY) {\n\t\t\t\t\t\ttype = \"DSA\";\n\t\t\t\t\t} else if (struct.pemType == PEMDecoder.PEM_EC_PRIVATE_KEY) {\n\t\t\t\t\t\ttype = \"EC\";\n\t\t\t\t\t} else if (struct.pemType == PEMDecoder.PEM_OPENSSH_PRIVATE_KEY) {\n\t\t\t\t\t\ttype = \"OpenSSH\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new RuntimeException(\"Unexpected key type: \" + struct.pemType);\n\t\t\t\t\t}\n\t\t\t\t\tpubkeyHolder.caption.setText(String.format(\"%s unknown-bit\", type));\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tLog.e(TAG, \"Error decoding IMPORTED public key at \" + pubkey.getId(), e);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tpubkeyHolder.caption.setText(pubkey.getDescription());\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tLog.e(TAG, \"Error decoding public key at \" + pubkey.getId(), e);\n\t\t\t\t\tpubkeyHolder.caption.setText(R.string.pubkey_unknown_format);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (bound == null) {\n\t\t\t\tpubkeyHolder.icon.setVisibility(View.GONE);\n\t\t\t} else {\n\t\t\t\tpubkeyHolder.icon.setVisibility(View.VISIBLE);\n\n\t\t\t\tif (bound.isKeyLoaded(pubkey.getNickname()))\n\t\t\t\t\tpubkeyHolder.icon.setImageState(new int[] { android.R.attr.state_checked }, true);\n\t\t\t\telse\n\t\t\t\t\tpubkeyHolder.icon.setImageState(new int[] { }, true);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic int getItemCount() {\n\t\t\treturn pubkeys.size();\n\t\t}\n\n\t\t@Override\n\t\tpublic long getItemId(int position) {\n\t\t\treturn pubkeys.get(position).getId();\n\t\t}\n\t}\n}\n","Method after Refactoring":"/*\n * ConnectBot: simple, powerful, open-source SSH client for Android\n * Copyright 2007 Kenny Root, Jeffrey Sharkey\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.connectbot;\n\nimport java.io.BufferedReader;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.security.KeyPair;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.util.Collections;\nimport java.util.EventListener;\nimport java.util.LinkedList;\nimport java.util.List;\n\nimport org.connectbot.bean.PubkeyBean;\nimport org.connectbot.service.TerminalManager;\nimport org.connectbot.util.PubkeyDatabase;\nimport org.connectbot.util.PubkeyUtils;\nimport org.openintents.intents.FileManagerIntents;\n\nimport com.trilead.ssh2.crypto.Base64;\nimport com.trilead.ssh2.crypto.PEMDecoder;\nimport com.trilead.ssh2.crypto.PEMStructure;\n\nimport android.content.ActivityNotFoundException;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.DialogInterface.OnClickListener;\nimport android.content.Intent;\nimport android.content.ServiceConnection;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Environment;\nimport android.os.IBinder;\nimport android.support.annotation.VisibleForTesting;\nimport android.support.v7.widget.LinearLayoutManager;\nimport android.support.v7.widget.RecyclerView;\nimport android.text.ClipboardManager;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.LayoutInflater;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.MenuItem.OnMenuItemClickListener;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.EditText;\nimport android.widget.ImageView;\nimport android.widget.TableRow;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\n/**\n * List public keys in database by nickname and describe their properties. Allow users to import,\n * generate, rename, and delete key pairs.\n *\n * @author Kenny Root\n */\npublic class PubkeyListActivity extends AppCompatListActivity implements EventListener {\n\tpublic final static String TAG = \"CB.PubkeyListActivity\";\n\n\tprivate static final int MAX_KEYFILE_SIZE = 32768;\n\tprivate static final int REQUEST_CODE_PICK_FILE = 1;\n\n\t// Constants for AndExplorer's file picking intent\n\tprivate static final String ANDEXPLORER_TITLE = \"explorer_title\";\n\tprivate static final String MIME_TYPE_ANDEXPLORER_FILE = \"vnd.android.cursor.dir/lysesoft.andexplorer.file\";\n\n\tprivate List<PubkeyBean> pubkeys;\n\n\tprotected ClipboardManager clipboard;\n\n\tprotected LayoutInflater inflater = null;\n\n\tprotected TerminalManager bound = null;\n\n\tprivate MenuItem onstartToggle = null;\n\tprivate MenuItem confirmUse = null;\n\n\tprivate ServiceConnection connection = new ServiceConnection() {\n\t\tpublic void onServiceConnected(ComponentName className, IBinder service) {\n\t\t\tbound = ((TerminalManager.TerminalBinder) service).getService();\n\n\t\t\t// update our listview binder to find the service\n\t\t\tupdateList();\n\t\t}\n\n\t\tpublic void onServiceDisconnected(ComponentName className) {\n\t\t\tbound = null;\n\t\t\tupdateList();\n\t\t}\n\t};\n\n\t@Override\n\tpublic void onStart() {\n\t\tsuper.onStart();\n\n\t\tbindService(new Intent(this, TerminalManager.class), connection, Context.BIND_AUTO_CREATE);\n\n\t\tupdateList();\n\t}\n\n\t@Override\n\tpublic void onStop() {\n\t\tsuper.onStop();\n\n\t\tunbindService(connection);\n\t}\n\n\t@Override\n\tpublic void onCreate(Bundle icicle) {\n\t\tsuper.onCreate(icicle);\n\t\tsetContentView(R.layout.act_pubkeylist);\n\n\t\tmListView = (RecyclerView) findViewById(R.id.list);\n\t\tmListView.setHasFixedSize(true);\n\t\tmListView.setLayoutManager(new LinearLayoutManager(this));\n\t\tmListView.addItemDecoration(new ListItemDecoration(this));\n\n\t\tmEmptyView = findViewById(R.id.empty);\n\n\t\tregisterForContextMenu(mListView);\n\n\t\tclipboard = (ClipboardManager) getSystemService(CLIPBOARD_SERVICE);\n\n\t\tinflater = LayoutInflater.from(this);\n\t}\n\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu) {\n\t\tMenuInflater inflater = getMenuInflater();\n\t\tinflater.inflate(R.menu.pubkey_list_activity_menu, menu);\n\t\treturn super.onCreateOptionsMenu(menu);\n\t}\n\n\t@Override\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tswitch (item.getItemId()) {\n\t\tcase R.id.add_new_key_icon:\n\t\t\tstartActivity(new Intent(this, GeneratePubkeyActivity.class));\n\t\t\treturn true;\n\t\tcase R.id.import_existing_key_icon:\n\t\t\timportExistingKey();\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn super.onOptionsItemSelected(item);\n\t\t}\n\t}\n\n\tprivate boolean importExistingKey() {\n\t\tUri sdcard = Uri.fromFile(Environment.getExternalStorageDirectory());\n\t\tString pickerTitle = getString(R.string.pubkey_list_pick);\n\n\t\treturn importExistingKeyKitKat() || importExistingKeyOpenIntents(sdcard, pickerTitle)\n\t\t\t\t|| importExistingKeyAndExplorer(sdcard, pickerTitle) || pickFileSimple();\n\t}\n\n\t/**\n\t * Fires an intent to spin up the \"file chooser\" UI and select a private key.\n\t */\n\tpublic boolean importExistingKeyKitKat() {\n\t\t// ACTION_OPEN_DOCUMENT is the intent to choose a file via the system's file\n\t\t// browser.\n\t\tIntent intent = new Intent(Intent.ACTION_OPEN_DOCUMENT);\n\n\t\t// Filter to only show results that can be \"opened\", such as a\n\t\t// file (as opposed to a list of contacts or timezones)\n\t\tintent.addCategory(Intent.CATEGORY_OPENABLE);\n\n\t\t// PKCS#8 MIME types aren't widely supported, so we'll try */* fro now.\n\t\tintent.setType(\"*/*\");\n\n\t\ttry {\n\t\t\tstartActivityForResult(intent, REQUEST_CODE_PICK_FILE);\n\t\t\treturn true;\n\t\t} catch (ActivityNotFoundException e) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Imports an existing key using the OpenIntents-style request.\n\t */\n\tprivate boolean importExistingKeyOpenIntents(Uri sdcard, String pickerTitle) {\n\t\t// Try to use OpenIntent's file browser to pick a file\n\t\tIntent intent = new Intent(FileManagerIntents.ACTION_PICK_FILE);\n\t\tintent.setData(sdcard);\n\t\tintent.putExtra(FileManagerIntents.EXTRA_TITLE, pickerTitle);\n\t\tintent.putExtra(FileManagerIntents.EXTRA_BUTTON_TEXT, getString(android.R.string.ok));\n\n\t\ttry {\n\t\t\tstartActivityForResult(intent, REQUEST_CODE_PICK_FILE);\n\t\t\treturn true;\n\t\t} catch (ActivityNotFoundException e) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate boolean importExistingKeyAndExplorer(Uri sdcard, String pickerTitle) {\n\t\tIntent intent;\n\t\tintent = new Intent(Intent.ACTION_PICK);\n\t\tintent.setDataAndType(sdcard, MIME_TYPE_ANDEXPLORER_FILE);\n\t\tintent.putExtra(ANDEXPLORER_TITLE, pickerTitle);\n\n\t\ttry {\n\t\t\tstartActivityForResult(intent, REQUEST_CODE_PICK_FILE);\n\t\t\treturn true;\n\t\t} catch (ActivityNotFoundException e) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Builds a simple list of files to pick from.\n\t */\n\tprivate boolean pickFileSimple() {\n\t\t// build list of all files in sdcard root\n\t\tfinal File sdcard = Environment.getExternalStorageDirectory();\n\t\tLog.d(TAG, sdcard.toString());\n\n\t\t// Don't show a dialog if the SD card is completely absent.\n\t\tfinal String state = Environment.getExternalStorageState();\n\t\tif (!Environment.MEDIA_MOUNTED_READ_ONLY.equals(state)\n\t\t\t\t&& !Environment.MEDIA_MOUNTED.equals(state)) {\n\t\t\tnew android.support.v7.app.AlertDialog.Builder(\n\t\t\t\t\tPubkeyListActivity.this, R.style.AlertDialogTheme)\n\t\t\t\t\t.setMessage(R.string.alert_sdcard_absent)\n\t\t\t\t\t.setNegativeButton(android.R.string.cancel, null).create().show();\n\t\t\treturn true;\n\t\t}\n\n\t\tList<String> names = new LinkedList<String>();\n\t\t{\n\t\t\tFile[] files = sdcard.listFiles();\n\t\t\tif (files != null) {\n\t\t\t\tfor (File file : sdcard.listFiles()) {\n\t\t\t\t\tif (file.isDirectory()) continue;\n\t\t\t\t\tnames.add(file.getName());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tCollections.sort(names);\n\n\t\tfinal String[] namesList = names.toArray(new String[] {});\n\t\tLog.d(TAG, names.toString());\n\n\t\t// prompt user to select any file from the sdcard root\n\t\tnew android.support.v7.app.AlertDialog.Builder(\n\t\t\t\tPubkeyListActivity.this, R.style.AlertDialogTheme)\n\t\t\t\t.setTitle(R.string.pubkey_list_pick)\n\t\t\t\t.setItems(namesList, new OnClickListener() {\n\t\t\t\t\tpublic void onClick(DialogInterface arg0, int arg1) {\n\t\t\t\t\t\tString name = namesList[arg1];\n\n\t\t\t\t\t\treadKeyFromFile(Uri.fromFile(new File(sdcard, name)));\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.setNegativeButton(android.R.string.cancel, null).create().show();\n\n\t\treturn true;\n\t}\n\n\tprotected void handleAddKey(final PubkeyBean pubkey) {\n\t\tif (pubkey.isEncrypted()) {\n\t\t\tfinal View view = View.inflate(this, R.layout.dia_password, null);\n\t\t\tfinal EditText passwordField = (EditText) view.findViewById(android.R.id.text1);\n\n\t\t\tnew android.support.v7.app.AlertDialog.Builder(\n\t\t\t\t\tPubkeyListActivity.this, R.style.AlertDialogTheme)\n\t\t\t\t.setView(view)\n\t\t\t\t.setPositiveButton(R.string.pubkey_unlock, new DialogInterface.OnClickListener() {\n\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\t\thandleAddKey(pubkey, passwordField.getText().toString());\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.setNegativeButton(android.R.string.cancel, null).create().show();\n\t\t} else {\n\t\t\thandleAddKey(pubkey, null);\n\t\t}\n\t}\n\n\tprotected void handleAddKey(PubkeyBean keybean, String password) {\n\t\tKeyPair pair = null;\n\t\tif (PubkeyDatabase.KEY_TYPE_IMPORTED.equals(keybean.getType())) {\n\t\t\t// load specific key using pem format\n\t\t\ttry {\n\t\t\t\tpair = PEMDecoder.decode(new String(keybean.getPrivateKey()).toCharArray(), password);\n\t\t\t} catch (Exception e) {\n\t\t\t\tString message = getResources().getString(R.string.pubkey_failed_add, keybean.getNickname());\n\t\t\t\tLog.e(TAG, message, e);\n\t\t\t\tToast.makeText(PubkeyListActivity.this, message, Toast.LENGTH_LONG).show();\n\t\t\t}\n\t\t} else {\n\t\t\t// load using internal generated format\n\t\t\ttry {\n\t\t\t\tPrivateKey privKey = PubkeyUtils.decodePrivate(keybean.getPrivateKey(), keybean.getType(), password);\n\t\t\t\tPublicKey pubKey = PubkeyUtils.decodePublic(keybean.getPublicKey(), keybean.getType());\n\t\t\t\tLog.d(TAG, \"Unlocked key \" + PubkeyUtils.formatKey(pubKey));\n\n\t\t\t\tpair = new KeyPair(pubKey, privKey);\n\t\t\t} catch (Exception e) {\n\t\t\t\tString message = getResources().getString(R.string.pubkey_failed_add, keybean.getNickname());\n\t\t\t\tLog.e(TAG, message, e);\n\t\t\t\tToast.makeText(PubkeyListActivity.this, message, Toast.LENGTH_LONG).show();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (pair == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tLog.d(TAG, String.format(\"Unlocked key '%s'\", keybean.getNickname()));\n\n\t\t// save this key in memory\n\t\tbound.addKey(keybean, pair, true);\n\n\t\tupdateList();\n\t}\n\n\tprotected void updateList() {\n\t\tPubkeyDatabase pubkeyDb = PubkeyDatabase.get(PubkeyListActivity.this);\n\t\tpubkeys = pubkeyDb.allPubkeys();\n\n\t\tmAdapter = new PubkeyAdapter(this, pubkeys);\n\t\tmListView.setAdapter(mAdapter);\n\t\tadjustViewVisibility();\n\t}\n\n\t@Override\n\tprotected void onActivityResult(int requestCode, int resultCode, Intent resultData) {\n\t\tsuper.onActivityResult(requestCode, resultCode, resultData);\n\n\t\tswitch (requestCode) {\n\t\tcase REQUEST_CODE_PICK_FILE:\n\t\t\tif (resultCode == RESULT_OK && resultData != null) {\n\t\t\t\tUri uri = resultData.getData();\n\t\t\t\ttry {\n\t\t\t\t\tif (uri != null) {\n\t\t\t\t\t\treadKeyFromFile(uri);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tString filename = resultData.getDataString();\n\t\t\t\t\t\tif (filename != null) {\n\t\t\t\t\t\t\treadKeyFromFile(Uri.parse(filename));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\t\tLog.e(TAG, \"Couldn't read from picked file\", e);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tpublic static byte[] getBytesFromInputStream(InputStream is, int maxSize) throws IOException {\n\t\tByteArrayOutputStream os = new ByteArrayOutputStream();\n\t\tbyte[] buffer = new byte[0xFFFF];\n\n\t\tfor (int len; (len = is.read(buffer)) != -1 && os.size() < maxSize; ) {\n\t\t\tos.write(buffer, 0, len);\n\t\t}\n\n\t\tif (os.size() >= maxSize) {\n\t\t\tthrow new IOException(\"File was too big\");\n\t\t}\n\n\t\tos.flush();\n\t\treturn os.toByteArray();\n\t}\n\n\tprivate KeyPair readPKCS8Key(byte[] keyData) {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(new ByteArrayInputStream(keyData)));\n\n\t\t// parse the actual key once to check if its encrypted\n\t\t// then save original file contents into our database\n\t\ttry {\n\t\t\tByteArrayOutputStream keyBytes = new ByteArrayOutputStream();\n\n\t\t\tString line;\n\t\t\tboolean inKey = false;\n\t\t\twhile ((line = reader.readLine()) != null) {\n\t\t\t\tif (line.equals(PubkeyUtils.PKCS8_START)) {\n\t\t\t\t\tinKey = true;\n\t\t\t\t} else if (line.equals(PubkeyUtils.PKCS8_END)) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (inKey) {\n\t\t\t\t\tkeyBytes.write(line.getBytes(\"US-ASCII\"));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (keyBytes.size() > 0) {\n\t\t\t\tbyte[] decoded = Base64.decode(keyBytes.toString().toCharArray());\n\n\t\t\t\treturn PubkeyUtils.recoverKeyPair(decoded);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\treturn null;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * @param uri URI to private key to read.\n\t */\n\tprivate void readKeyFromFile(Uri uri) {\n\t\tPubkeyBean pubkey = new PubkeyBean();\n\n\t\t// find the exact file selected\n\t\tpubkey.setNickname(uri.getLastPathSegment());\n\n\t\tbyte[] keyData;\n\t\ttry {\n\t\t\tContentResolver resolver = getContentResolver();\n\t\t\tkeyData = getBytesFromInputStream(resolver.openInputStream(uri), MAX_KEYFILE_SIZE);\n\t\t} catch (IOException e) {\n\t\t\tToast.makeText(PubkeyListActivity.this,\n\t\t\t\t\tR.string.pubkey_import_parse_problem,\n\t\t\t\t\tToast.LENGTH_LONG).show();\n\t\t\treturn;\n\t\t}\n\n\t\tKeyPair kp;\n\t\tif ((kp = readPKCS8Key(keyData)) != null) {\n\t\t\tString algorithm = convertAlgorithmName(kp.getPrivate().getAlgorithm());\n\t\t\tpubkey.setType(algorithm);\n\t\t\tpubkey.setPrivateKey(kp.getPrivate().getEncoded());\n\t\t\tpubkey.setPublicKey(kp.getPublic().getEncoded());\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tPEMStructure struct = PEMDecoder.parsePEM(new String(keyData).toCharArray());\n\t\t\t\tboolean encrypted = PEMDecoder.isPEMEncrypted(struct);\n\t\t\t\tpubkey.setEncrypted(encrypted);\n\t\t\t\tif (!encrypted) {\n\t\t\t\t\tkp = PEMDecoder.decode(struct, null);\n\t\t\t\t\tString algorithm = convertAlgorithmName(kp.getPrivate().getAlgorithm());\n\t\t\t\t\tpubkey.setType(algorithm);\n\t\t\t\t\tpubkey.setPrivateKey(kp.getPrivate().getEncoded());\n\t\t\t\t\tpubkey.setPublicKey(kp.getPublic().getEncoded());\n\t\t\t\t} else {\n\t\t\t\t\tpubkey.setType(PubkeyDatabase.KEY_TYPE_IMPORTED);\n\t\t\t\t\tpubkey.setPrivateKey(keyData);\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\tLog.e(TAG, \"Problem parsing imported private key\", e);\n\t\t\t\tToast.makeText(PubkeyListActivity.this, R.string.pubkey_import_parse_problem, Toast.LENGTH_LONG).show();\n\t\t\t}\n\t\t}\n\n\t\t// write new value into database\n\t\tPubkeyDatabase pubkeyDb = PubkeyDatabase.get(this);\n\t\tpubkeyDb.savePubkey(pubkey);\n\n\t\tupdateList();\n\t}\n\n\tprivate String convertAlgorithmName(String algorithm) {\n\t\tif (\"EdDSA\".equals(algorithm)) {\n\t\t\treturn PubkeyDatabase.KEY_TYPE_ED25519;\n\t\t} else {\n\t\t\treturn algorithm;\n\t\t}\n\t}\n\n\tpublic class PubkeyViewHolder extends ItemViewHolder {\n\t\tpublic final ImageView icon;\n\t\tpublic final TextView nickname;\n\t\tpublic final TextView caption;\n\n\t\tpublic PubkeyBean pubkey;\n\n\t\tpublic PubkeyViewHolder(View v) {\n\t\t\tsuper(v);\n\n\t\t\ticon = (ImageView) v.findViewById(android.R.id.icon);\n\t\t\tnickname = (TextView) v.findViewById(android.R.id.text1);\n\t\t\tcaption = (TextView) v.findViewById(android.R.id.text2);\n\t\t}\n\n\t\t@Override\n\t\tpublic void onClick(View v) {\n\t\t\tboolean loaded = bound != null && bound.isKeyLoaded(pubkey.getNickname());\n\n\t\t\t// handle toggling key in-memory on/off\n\t\t\tif (loaded) {\n\t\t\t\tbound.removeKey(pubkey.getNickname());\n\t\t\t\tupdateList();\n\t\t\t} else {\n\t\t\t\thandleAddKey(pubkey);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void onCreateContextMenu(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo) {\n\t\t\t// Create menu to handle deleting and editing pubkey\n\t\t\tmenu.setHeaderTitle(pubkey.getNickname());\n\n\t\t\t// TODO: option load/unload key from in-memory list\n\t\t\t// prompt for password as needed for passworded keys\n\n\t\t\t// cant change password or clipboard imported keys\n\t\t\tfinal boolean imported = PubkeyDatabase.KEY_TYPE_IMPORTED.equals(pubkey.getType());\n\t\t\tfinal boolean loaded = bound != null && bound.isKeyLoaded(pubkey.getNickname());\n\n\t\t\tMenuItem load = menu.add(loaded ? R.string.pubkey_memory_unload : R.string.pubkey_memory_load);\n\t\t\tload.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\tif (loaded) {\n\t\t\t\t\t\tbound.removeKey(pubkey.getNickname());\n\t\t\t\t\t\tupdateList();\n\t\t\t\t\t} else {\n\t\t\t\t\t\thandleAddKey(pubkey);\n\t\t\t\t\t\t//bound.addKey(nickname, trileadKey);\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tonstartToggle = menu.add(R.string.pubkey_load_on_start);\n\t\t\tonstartToggle.setEnabled(!pubkey.isEncrypted());\n\t\t\tonstartToggle.setCheckable(true);\n\t\t\tonstartToggle.setChecked(pubkey.isStartup());\n\t\t\tonstartToggle.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\t// toggle onstart status\n\t\t\t\t\tpubkey.setStartup(!pubkey.isStartup());\n\t\t\t\t\tPubkeyDatabase pubkeyDb = PubkeyDatabase.get(PubkeyListActivity.this);\n\t\t\t\t\tpubkeyDb.savePubkey(pubkey);\n\t\t\t\t\tupdateList();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tMenuItem copyPublicToClipboard = menu.add(R.string.pubkey_copy_public);\n\t\t\tcopyPublicToClipboard.setEnabled(!imported);\n\t\t\tcopyPublicToClipboard.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tPublicKey pk = PubkeyUtils.decodePublic(pubkey.getPublicKey(), pubkey.getType());\n\t\t\t\t\t\tString openSSHPubkey = PubkeyUtils.convertToOpenSSHFormat(pk, pubkey.getNickname());\n\n\t\t\t\t\t\tclipboard.setText(openSSHPubkey);\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tMenuItem copyPrivateToClipboard = menu.add(R.string.pubkey_copy_private);\n\t\t\tcopyPrivateToClipboard.setEnabled(!pubkey.isEncrypted() || imported);\n\t\t\tcopyPrivateToClipboard.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tString data = null;\n\n\t\t\t\t\t\tif (imported)\n\t\t\t\t\t\t\tdata = new String(pubkey.getPrivateKey());\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tPrivateKey pk = PubkeyUtils.decodePrivate(pubkey.getPrivateKey(), pubkey.getType());\n\t\t\t\t\t\t\tdata = PubkeyUtils.exportPEM(pk, null);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tclipboard.setText(data);\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tMenuItem changePassword = menu.add(R.string.pubkey_change_password);\n\t\t\tchangePassword.setEnabled(!imported);\n\t\t\tchangePassword.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\tfinal View changePasswordView =\n\t\t\t\t\t\t\tView.inflate(PubkeyListActivity.this, R.layout.dia_changepassword, null);\n\t\t\t\t\t((TableRow) changePasswordView.findViewById(R.id.old_password_prompt))\n\t\t\t\t\t\t\t.setVisibility(pubkey.isEncrypted() ? View.VISIBLE : View.GONE);\n\t\t\t\t\tnew android.support.v7.app.AlertDialog.Builder(\n\t\t\t\t\t\t\t\t\tPubkeyListActivity.this, R.style.AlertDialogTheme)\n\t\t\t\t\t\t\t.setView(changePasswordView)\n\t\t\t\t\t\t\t.setPositiveButton(R.string.button_change, new DialogInterface.OnClickListener() {\n\t\t\t\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\t\t\t\t\tString oldPassword = ((EditText) changePasswordView.findViewById(R.id.old_password)).getText().toString();\n\t\t\t\t\t\t\t\t\tString password1 = ((EditText) changePasswordView.findViewById(R.id.password1)).getText().toString();\n\t\t\t\t\t\t\t\t\tString password2 = ((EditText) changePasswordView.findViewById(R.id.password2)).getText().toString();\n\n\t\t\t\t\t\t\t\t\tif (!password1.equals(password2)) {\n\t\t\t\t\t\t\t\t\t\tnew android.support.v7.app.AlertDialog.Builder(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tPubkeyListActivity.this,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tR.style.AlertDialogTheme)\n\t\t\t\t\t\t\t\t\t\t\t\t.setMessage(R.string.alert_passwords_do_not_match_msg)\n\t\t\t\t\t\t\t\t\t\t\t\t.setPositiveButton(android.R.string.ok, null)\n\t\t\t\t\t\t\t\t\t\t\t\t.create().show();\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tif (!pubkey.changePassword(oldPassword, password1))\n\t\t\t\t\t\t\t\t\t\t\tnew android.support.v7.app.AlertDialog.Builder(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tPubkeyListActivity.this,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tR.style.AlertDialogTheme)\n\t\t\t\t\t\t\t\t\t\t\t\t\t.setMessage(R.string.alert_wrong_password_msg)\n\t\t\t\t\t\t\t\t\t\t\t\t\t.setPositiveButton(android.R.string.ok, null)\n\t\t\t\t\t\t\t\t\t\t\t\t\t.create().show();\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\tPubkeyDatabase pubkeyDb = PubkeyDatabase.get(PubkeyListActivity.this);\n\t\t\t\t\t\t\t\t\t\t\tpubkeyDb.savePubkey(pubkey);\n\t\t\t\t\t\t\t\t\t\t\tupdateList();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\t\t\t\tLog.e(TAG, \"Could not change private key password\", e);\n\t\t\t\t\t\t\t\t\t\tnew android.support.v7.app.AlertDialog.Builder(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tPubkeyListActivity.this,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tR.style.AlertDialogTheme)\n\t\t\t\t\t\t\t\t\t\t\t\t.setMessage(R.string.alert_key_corrupted_msg)\n\t\t\t\t\t\t\t\t\t\t\t\t.setPositiveButton(android.R.string.ok, null)\n\t\t\t\t\t\t\t\t\t\t\t\t.create().show();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t.setNegativeButton(android.R.string.cancel, null).create().show();\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tconfirmUse = menu.add(R.string.pubkey_confirm_use);\n\t\t\tconfirmUse.setCheckable(true);\n\t\t\tconfirmUse.setChecked(pubkey.isConfirmUse());\n\t\t\tconfirmUse.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\t// toggle confirm use\n\t\t\t\t\tpubkey.setConfirmUse(!pubkey.isConfirmUse());\n\t\t\t\t\tPubkeyDatabase pubkeyDb = PubkeyDatabase.get(PubkeyListActivity.this);\n\t\t\t\t\tpubkeyDb.savePubkey(pubkey);\n\t\t\t\t\tupdateList();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tMenuItem delete = menu.add(R.string.pubkey_delete);\n\t\t\tdelete.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\t// prompt user to make sure they really want this\n\t\t\t\t\tnew android.support.v7.app.AlertDialog.Builder(\n\t\t\t\t\t\t\t\t\tPubkeyListActivity.this, R.style.AlertDialogTheme)\n\t\t\t\t\t\t\t.setMessage(getString(R.string.delete_message, pubkey.getNickname()))\n\t\t\t\t\t\t\t.setPositiveButton(R.string.delete_pos, new DialogInterface.OnClickListener() {\n\t\t\t\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\n\t\t\t\t\t\t\t\t\t// dont forget to remove from in-memory\n\t\t\t\t\t\t\t\t\tif (loaded) {\n\t\t\t\t\t\t\t\t\t\tbound.removeKey(pubkey.getNickname());\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// delete from backend database and update gui\n\t\t\t\t\t\t\t\t\tPubkeyDatabase pubkeyDb = PubkeyDatabase.get(PubkeyListActivity.this);\n\t\t\t\t\t\t\t\t\tpubkeyDb.deletePubkey(pubkey);\n\t\t\t\t\t\t\t\t\tupdateList();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t.setNegativeButton(R.string.delete_neg, null).create().show();\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t@VisibleForTesting\n\tprivate class PubkeyAdapter extends ItemAdapter {\n\t\tprivate final List<PubkeyBean> pubkeys;\n\n\t\tpublic PubkeyAdapter(Context context, List<PubkeyBean> pubkeys) {\n\t\t\tsuper(context);\n\t\t\tthis.pubkeys = pubkeys;\n\t\t}\n\n\t\t@Override\n\t\tpublic PubkeyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n\t\t\tView v = LayoutInflater.from(parent.getContext())\n\t\t\t\t\t.inflate(R.layout.item_pubkey, parent, false);\n\t\t\tPubkeyViewHolder vh = new PubkeyViewHolder(v);\n\t\t\treturn vh;\n\t\t}\n\n\t\tpublic void onBindViewHolder(ItemViewHolder holder, int position) {\n\t\t\tPubkeyViewHolder pubkeyHolder = (PubkeyViewHolder) holder;\n\n\t\t\tPubkeyBean pubkey = pubkeys.get(position);\n\t\t\tpubkeyHolder.pubkey = pubkey;\n\t\t\tif (pubkey == null) {\n\t\t\t\t// Well, something bad happened. We can't continue.\n\t\t\t\tLog.e(\"PubkeyAdapter\", \"Pubkey bean is null!\");\n\n\t\t\t\tpubkeyHolder.nickname.setText(\"Error during lookup\");\n\t\t\t} else {\n\t\t\t\tpubkeyHolder.nickname.setText(pubkey.getNickname());\n\t\t\t}\n\n\t\t\tboolean imported = PubkeyDatabase.KEY_TYPE_IMPORTED.equals(pubkey.getType());\n\n\t\t\tif (imported) {\n\t\t\t\ttry {\n\t\t\t\t\tPEMStructure struct = PEMDecoder.parsePEM(new String(pubkey.getPrivateKey()).toCharArray());\n\t\t\t\t\tString type;\n\t\t\t\t\tif (struct.pemType == PEMDecoder.PEM_RSA_PRIVATE_KEY) {\n\t\t\t\t\t\ttype = \"RSA\";\n\t\t\t\t\t} else if (struct.pemType == PEMDecoder.PEM_DSA_PRIVATE_KEY) {\n\t\t\t\t\t\ttype = \"DSA\";\n\t\t\t\t\t} else if (struct.pemType == PEMDecoder.PEM_EC_PRIVATE_KEY) {\n\t\t\t\t\t\ttype = \"EC\";\n\t\t\t\t\t} else if (struct.pemType == PEMDecoder.PEM_OPENSSH_PRIVATE_KEY) {\n\t\t\t\t\t\ttype = \"OpenSSH\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new RuntimeException(\"Unexpected key type: \" + struct.pemType);\n\t\t\t\t\t}\n\t\t\t\t\tpubkeyHolder.caption.setText(String.format(\"%s unknown-bit\", type));\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tLog.e(TAG, \"Error decoding IMPORTED public key at \" + pubkey.getId(), e);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tpubkeyHolder.caption.setText(pubkey.getDescription());\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tLog.e(TAG, \"Error decoding public key at \" + pubkey.getId(), e);\n\t\t\t\t\tpubkeyHolder.caption.setText(R.string.pubkey_unknown_format);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (bound == null) {\n\t\t\t\tpubkeyHolder.icon.setVisibility(View.GONE);\n\t\t\t} else {\n\t\t\t\tpubkeyHolder.icon.setVisibility(View.VISIBLE);\n\n\t\t\t\tif (bound.isKeyLoaded(pubkey.getNickname()))\n\t\t\t\t\tpubkeyHolder.icon.setImageState(new int[] { android.R.attr.state_checked }, true);\n\t\t\t\telse\n\t\t\t\t\tpubkeyHolder.icon.setImageState(new int[] { }, true);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic int getItemCount() {\n\t\t\treturn pubkeys.size();\n\t\t}\n\n\t\t@Override\n\t\tpublic long getItemId(int position) {\n\t\t\treturn pubkeys.get(position).getId();\n\t\t}\n\t}\n}\n","lineNo":447}
{"Smelly Sample":"/*\n * ConnectBot: simple, powerful, open-source SSH client for Android\n * Copyright 2007 Kenny Root, Jeffrey Sharkey\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.connectbot;\n\nimport java.io.BufferedReader;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.DataInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URI;\nimport java.nio.charset.Charset;\nimport java.security.KeyPair;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.util.Collections;\nimport java.util.EventListener;\nimport java.util.LinkedList;\nimport java.util.List;\n\nimport org.connectbot.bean.PubkeyBean;\nimport org.connectbot.service.TerminalManager;\nimport org.connectbot.util.PubkeyDatabase;\nimport org.connectbot.util.PubkeyUtils;\nimport org.openintents.intents.FileManagerIntents;\n\nimport com.trilead.ssh2.crypto.Base64;\nimport com.trilead.ssh2.crypto.PEMDecoder;\nimport com.trilead.ssh2.crypto.PEMStructure;\n\nimport android.content.ActivityNotFoundException;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.DialogInterface.OnClickListener;\nimport android.content.Intent;\nimport android.content.ServiceConnection;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Environment;\nimport android.os.IBinder;\nimport android.support.annotation.VisibleForTesting;\nimport android.support.v7.widget.LinearLayoutManager;\nimport android.support.v7.widget.RecyclerView;\nimport android.text.ClipboardManager;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.LayoutInflater;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.MenuItem.OnMenuItemClickListener;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.EditText;\nimport android.widget.ImageView;\nimport android.widget.TableRow;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\n/**\n * List public keys in database by nickname and describe their properties. Allow users to import,\n * generate, rename, and delete key pairs.\n *\n * @author Kenny Root\n */\npublic class PubkeyListActivity extends AppCompatListActivity implements EventListener {\n\tpublic final static String TAG = \"CB.PubkeyListActivity\";\n\n\tprivate static final int MAX_KEYFILE_SIZE = 32768;\n\tprivate static final int REQUEST_CODE_PICK_FILE = 1;\n\n\t// Constants for AndExplorer's file picking intent\n\tprivate static final String ANDEXPLORER_TITLE = \"explorer_title\";\n\tprivate static final String MIME_TYPE_ANDEXPLORER_FILE = \"vnd.android.cursor.dir/lysesoft.andexplorer.file\";\n\n\tprivate List<PubkeyBean> pubkeys;\n\n\tprotected ClipboardManager clipboard;\n\n\tprotected LayoutInflater inflater = null;\n\n\tprotected TerminalManager bound = null;\n\n\tprivate MenuItem onstartToggle = null;\n\tprivate MenuItem confirmUse = null;\n\n\tprivate ServiceConnection connection = new ServiceConnection() {\n\t\tpublic void onServiceConnected(ComponentName className, IBinder service) {\n\t\t\tbound = ((TerminalManager.TerminalBinder) service).getService();\n\n\t\t\t// update our listview binder to find the service\n\t\t\tupdateList();\n\t\t}\n\n\t\tpublic void onServiceDisconnected(ComponentName className) {\n\t\t\tbound = null;\n\t\t\tupdateList();\n\t\t}\n\t};\n\n\t@Override\n\tpublic void onStart() {\n\t\tsuper.onStart();\n\n\t\tbindService(new Intent(this, TerminalManager.class), connection, Context.BIND_AUTO_CREATE);\n\n\t\tupdateList();\n\t}\n\n\t@Override\n\tpublic void onStop() {\n\t\tsuper.onStop();\n\n\t\tunbindService(connection);\n\t}\n\n\t@Override\n\tpublic void onCreate(Bundle icicle) {\n\t\tsuper.onCreate(icicle);\n\t\tsetContentView(R.layout.act_pubkeylist);\n\n\t\tmListView = (RecyclerView) findViewById(R.id.list);\n\t\tmListView.setHasFixedSize(true);\n\t\tmListView.setLayoutManager(new LinearLayoutManager(this));\n\t\tmListView.addItemDecoration(new ListItemDecoration(this));\n\n\t\tmEmptyView = findViewById(R.id.empty);\n\n\t\tregisterForContextMenu(mListView);\n\n\t\tclipboard = (ClipboardManager) getSystemService(CLIPBOARD_SERVICE);\n\n\t\tinflater = LayoutInflater.from(this);\n\t}\n\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu) {\n\t\tMenuInflater inflater = getMenuInflater();\n\t\tinflater.inflate(R.menu.pubkey_list_activity_menu, menu);\n\t\treturn super.onCreateOptionsMenu(menu);\n\t}\n\n\t@Override\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tswitch (item.getItemId()) {\n\t\tcase R.id.add_new_key_icon:\n\t\t\tstartActivity(new Intent(this, GeneratePubkeyActivity.class));\n\t\t\treturn true;\n\t\tcase R.id.import_existing_key_icon:\n\t\t\timportExistingKey();\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn super.onOptionsItemSelected(item);\n\t\t}\n\t}\n\n\tprivate boolean importExistingKey() {\n\t\tUri sdcard = Uri.fromFile(Environment.getExternalStorageDirectory());\n\t\tString pickerTitle = getString(R.string.pubkey_list_pick);\n\n\t\treturn importExistingKeyKitKat() || importExistingKeyOpenIntents(sdcard, pickerTitle)\n\t\t\t\t|| importExistingKeyAndExplorer(sdcard, pickerTitle) || pickFileSimple();\n\t}\n\n\t/**\n\t * Fires an intent to spin up the \"file chooser\" UI and select a private key.\n\t */\n\tpublic boolean importExistingKeyKitKat() {\n\t\t// ACTION_OPEN_DOCUMENT is the intent to choose a file via the system's file\n\t\t// browser.\n\t\tIntent intent = new Intent(Intent.ACTION_OPEN_DOCUMENT);\n\n\t\t// Filter to only show results that can be \"opened\", such as a\n\t\t// file (as opposed to a list of contacts or timezones)\n\t\tintent.addCategory(Intent.CATEGORY_OPENABLE);\n\n\t\t// PKCS#8 MIME types aren't widely supported, so we'll try */* fro now.\n\t\tintent.setType(\"*/*\");\n\n\t\ttry {\n\t\t\tstartActivityForResult(intent, REQUEST_CODE_PICK_FILE);\n\t\t\treturn true;\n\t\t} catch (ActivityNotFoundException e) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Imports an existing key using the OpenIntents-style request.\n\t */\n\tprivate boolean importExistingKeyOpenIntents(Uri sdcard, String pickerTitle) {\n\t\t// Try to use OpenIntent's file browser to pick a file\n\t\tIntent intent = new Intent(FileManagerIntents.ACTION_PICK_FILE);\n\t\tintent.setData(sdcard);\n\t\tintent.putExtra(FileManagerIntents.EXTRA_TITLE, pickerTitle);\n\t\tintent.putExtra(FileManagerIntents.EXTRA_BUTTON_TEXT, getString(android.R.string.ok));\n\n\t\ttry {\n\t\t\tstartActivityForResult(intent, REQUEST_CODE_PICK_FILE);\n\t\t\treturn true;\n\t\t} catch (ActivityNotFoundException e) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate boolean importExistingKeyAndExplorer(Uri sdcard, String pickerTitle) {\n\t\tIntent intent;// If OI didn't work, try AndExplorer\n\t\tintent = new Intent(Intent.ACTION_PICK);\n\t\tintent.setDataAndType(sdcard, MIME_TYPE_ANDEXPLORER_FILE);\n\t\tintent.putExtra(ANDEXPLORER_TITLE, pickerTitle);\n\n\t\ttry {\n\t\t\tstartActivityForResult(intent, REQUEST_CODE_PICK_FILE);\n\t\t\treturn true;\n\t\t} catch (ActivityNotFoundException e) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Builds a simple list of files to pick from.\n\t */\n\tprivate boolean pickFileSimple() {\n\t\t// build list of all files in sdcard root\n\t\tfinal File sdcard = Environment.getExternalStorageDirectory();\n\t\tLog.d(TAG, sdcard.toString());\n\n\t\t// Don't show a dialog if the SD card is completely absent.\n\t\tfinal String state = Environment.getExternalStorageState();\n\t\tif (!Environment.MEDIA_MOUNTED_READ_ONLY.equals(state)\n\t\t\t\t&& !Environment.MEDIA_MOUNTED.equals(state)) {\n\t\t\tnew android.support.v7.app.AlertDialog.Builder(\n\t\t\t\t\tPubkeyListActivity.this, R.style.AlertDialogTheme)\n\t\t\t\t\t.setMessage(R.string.alert_sdcard_absent)\n\t\t\t\t\t.setNegativeButton(android.R.string.cancel, null).create().show();\n\t\t\treturn true;\n\t\t}\n\n\t\tList<String> names = new LinkedList<String>();\n\t\t{\n\t\t\tFile[] files = sdcard.listFiles();\n\t\t\tif (files != null) {\n\t\t\t\tfor (File file : sdcard.listFiles()) {\n\t\t\t\t\tif (file.isDirectory()) continue;\n\t\t\t\t\tnames.add(file.getName());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tCollections.sort(names);\n\n\t\tfinal String[] namesList = names.toArray(new String[] {});\n\t\tLog.d(TAG, names.toString());\n\n\t\t// prompt user to select any file from the sdcard root\n\t\tnew android.support.v7.app.AlertDialog.Builder(\n\t\t\t\tPubkeyListActivity.this, R.style.AlertDialogTheme)\n\t\t\t\t.setTitle(R.string.pubkey_list_pick)\n\t\t\t\t.setItems(namesList, new OnClickListener() {\n\t\t\t\t\tpublic void onClick(DialogInterface arg0, int arg1) {\n\t\t\t\t\t\tString name = namesList[arg1];\n\n\t\t\t\t\t\treadKeyFromFile(Uri.fromFile(new File(sdcard, name)));\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.setNegativeButton(android.R.string.cancel, null).create().show();\n\n\t\treturn true;\n\t}\n\n\tprotected void handleAddKey(final PubkeyBean pubkey) {\n\t\tif (pubkey.isEncrypted()) {\n\t\t\tfinal View view = View.inflate(this, R.layout.dia_password, null);\n\t\t\tfinal EditText passwordField = (EditText) view.findViewById(android.R.id.text1);\n\n\t\t\tnew android.support.v7.app.AlertDialog.Builder(\n\t\t\t\t\tPubkeyListActivity.this, R.style.AlertDialogTheme)\n\t\t\t\t.setView(view)\n\t\t\t\t.setPositiveButton(R.string.pubkey_unlock, new DialogInterface.OnClickListener() {\n\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\t\thandleAddKey(pubkey, passwordField.getText().toString());\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.setNegativeButton(android.R.string.cancel, null).create().show();\n\t\t} else {\n\t\t\thandleAddKey(pubkey, null);\n\t\t}\n\t}\n\n\tprotected void handleAddKey(PubkeyBean keybean, String password) {\n\t\tKeyPair pair = null;\n\t\tif (PubkeyDatabase.KEY_TYPE_IMPORTED.equals(keybean.getType())) {\n\t\t\t// load specific key using pem format\n\t\t\ttry {\n\t\t\t\tpair = PEMDecoder.decode(new String(keybean.getPrivateKey()).toCharArray(), password);\n\t\t\t} catch (Exception e) {\n\t\t\t\tString message = getResources().getString(R.string.pubkey_failed_add, keybean.getNickname());\n\t\t\t\tLog.e(TAG, message, e);\n\t\t\t\tToast.makeText(PubkeyListActivity.this, message, Toast.LENGTH_LONG).show();\n\t\t\t}\n\t\t} else {\n\t\t\t// load using internal generated format\n\t\t\ttry {\n\t\t\t\tPrivateKey privKey = PubkeyUtils.decodePrivate(keybean.getPrivateKey(), keybean.getType(), password);\n\t\t\t\tPublicKey pubKey = PubkeyUtils.decodePublic(keybean.getPublicKey(), keybean.getType());\n\t\t\t\tLog.d(TAG, \"Unlocked key \" + PubkeyUtils.formatKey(pubKey));\n\n\t\t\t\tpair = new KeyPair(pubKey, privKey);\n\t\t\t} catch (Exception e) {\n\t\t\t\tString message = getResources().getString(R.string.pubkey_failed_add, keybean.getNickname());\n\t\t\t\tLog.e(TAG, message, e);\n\t\t\t\tToast.makeText(PubkeyListActivity.this, message, Toast.LENGTH_LONG).show();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (pair == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tLog.d(TAG, String.format(\"Unlocked key '%s'\", keybean.getNickname()));\n\n\t\t// save this key in memory\n\t\tbound.addKey(keybean, pair, true);\n\n\t\tupdateList();\n\t}\n\n\tprotected void updateList() {\n\t\tPubkeyDatabase pubkeyDb = PubkeyDatabase.get(PubkeyListActivity.this);\n\t\tpubkeys = pubkeyDb.allPubkeys();\n\n\t\tmAdapter = new PubkeyAdapter(this, pubkeys);\n\t\tmListView.setAdapter(mAdapter);\n\t\tadjustViewVisibility();\n\t}\n\n\t@Override\n\tprotected void onActivityResult(int requestCode, int resultCode, Intent resultData) {\n\t\tsuper.onActivityResult(requestCode, resultCode, resultData);\n\n\t\tswitch (requestCode) {\n\t\tcase REQUEST_CODE_PICK_FILE:\n\t\t\tif (resultCode == RESULT_OK && resultData != null) {\n\t\t\t\tUri uri = resultData.getData();\n\t\t\t\ttry {\n\t\t\t\t\tif (uri != null) {\n\t\t\t\t\t\treadKeyFromFile(uri);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tString filename = resultData.getDataString();\n\t\t\t\t\t\tif (filename != null) {\n\t\t\t\t\t\t\treadKeyFromFile(Uri.parse(filename));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\t\tLog.e(TAG, \"Couldn't read from picked file\", e);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tpublic static byte[] getBytesFromInputStream(InputStream is, int maxSize) throws IOException {\n\t\tByteArrayOutputStream os = new ByteArrayOutputStream();\n\t\tbyte[] buffer = new byte[0xFFFF];\n\n\t\tfor (int len; (len = is.read(buffer)) != -1 && os.size() < maxSize; ) {\n\t\t\tos.write(buffer, 0, len);\n\t\t}\n\n\t\tif (os.size() >= maxSize) {\n\t\t\tthrow new IOException(\"File was too big\");\n\t\t}\n\n\t\tos.flush();\n\t\treturn os.toByteArray();\n\t}\n\n\tprivate KeyPair readPKCS8Key(byte[] keyData) {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(new ByteArrayInputStream(keyData)));\n\n\t\t// parse the actual key once to check if its encrypted\n\t\t// then save original file contents into our database\n\t\ttry {\n\t\t\tByteArrayOutputStream keyBytes = new ByteArrayOutputStream();\n\n\t\t\tString line;\n\t\t\tboolean inKey = false;\n\t\t\twhile ((line = reader.readLine()) != null) {\n\t\t\t\tif (line.equals(PubkeyUtils.PKCS8_START)) {\n\t\t\t\t\tinKey = true;\n\t\t\t\t} else if (line.equals(PubkeyUtils.PKCS8_END)) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (inKey) {\n\t\t\t\t\tkeyBytes.write(line.getBytes(\"US-ASCII\"));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (keyBytes.size() > 0) {\n\t\t\t\tbyte[] decoded = Base64.decode(keyBytes.toString().toCharArray());\n\n\t\t\t\treturn PubkeyUtils.recoverKeyPair(decoded);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\treturn null;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * @param uri URI to private key to read.\n\t */\n\tprivate void readKeyFromFile(Uri uri) {\n\t\tPubkeyBean pubkey = new PubkeyBean();\n\n\t\t// find the exact file selected\n\t\tpubkey.setNickname(uri.getLastPathSegment());\n\n\t\tbyte[] keyData;\n\t\ttry {\n\t\t\tContentResolver resolver = getContentResolver();\n\t\t\tkeyData = getBytesFromInputStream(resolver.openInputStream(uri), MAX_KEYFILE_SIZE);\n\t\t} catch (IOException e) {\n\t\t\tToast.makeText(PubkeyListActivity.this,\n\t\t\t\t\tR.string.pubkey_import_parse_problem,\n\t\t\t\t\tToast.LENGTH_LONG).show();\n\t\t\treturn;\n\t\t}\n\n\t\tKeyPair kp;\n\t\tif ((kp = readPKCS8Key(keyData)) != null) {\n\t\t\tpubkey.setType(kp.getPrivate().getAlgorithm());\n\t\t\tpubkey.setPrivateKey(kp.getPrivate().getEncoded());\n\t\t\tpubkey.setPublicKey(kp.getPublic().getEncoded());\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tPEMStructure struct = PEMDecoder.parsePEM(new String(keyData).toCharArray());\n\t\t\t\tboolean encrypted = PEMDecoder.isPEMEncrypted(struct);\n\t\t\t\tpubkey.setEncrypted(encrypted);\n\t\t\t\tif (!encrypted) {\n\t\t\t\t\tkp = PEMDecoder.decode(struct, null);\n\t\t\t\t\tpubkey.setType(kp.getPrivate().getAlgorithm());\n\t\t\t\t\tpubkey.setPrivateKey(kp.getPrivate().getEncoded());\n\t\t\t\t\tpubkey.setPublicKey(kp.getPublic().getEncoded());\n\t\t\t\t} else {\n\t\t\t\t\tpubkey.setType(PubkeyDatabase.KEY_TYPE_IMPORTED);\n\t\t\t\t\tpubkey.setPrivateKey(keyData);\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\tLog.e(TAG, \"Problem parsing imported private key\", e);\n\t\t\t\tToast.makeText(PubkeyListActivity.this, R.string.pubkey_import_parse_problem, Toast.LENGTH_LONG).show();\n\t\t\t}\n\t\t}\n\n\t\t// write new value into database\n\t\tPubkeyDatabase pubkeyDb = PubkeyDatabase.get(this);\n\t\tpubkeyDb.savePubkey(pubkey);\n\n\t\tupdateList();\n\t}\n\n\t/**\n\t *\n\t */\n\tprivate void pickFileSimple() {\n\t\t// build list of all files in sdcard root\n\t\tfinal File sdcard = Environment.getExternalStorageDirectory();\n\t\tLog.d(TAG, sdcard.toString());\n\n\t\t// Don't show a dialog if the SD card is completely absent.\n\t\tfinal String state = Environment.getExternalStorageState();\n\t\tif (!Environment.MEDIA_MOUNTED_READ_ONLY.equals(state)\n\t\t\t\t&& !Environment.MEDIA_MOUNTED.equals(state)) {\n\t\t\tnew android.support.v7.app.AlertDialog.Builder(\n\t\t\t\t\tPubkeyListActivity.this, R.style.AlertDialogTheme)\n\t\t\t\t.setMessage(R.string.alert_sdcard_absent)\n\t\t\t\t.setNegativeButton(android.R.string.cancel, null).create().show();\n\t\t\treturn;\n\t\t}\n\n\t\tList<String> names = new LinkedList<String>();\n\t\t{\n\t\t\tFile[] files = sdcard.listFiles();\n\t\t\tif (files != null) {\n\t\t\t\tfor (File file : files) {\n\t\t\t\t\tif (file == null || file.isDirectory()) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tnames.add(file.getName());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tCollections.sort(names);\n\n\t\tfinal String[] namesList = names.toArray(new String[] {});\n\t\tLog.d(TAG, names.toString());\n\n\t\t// prompt user to select any file from the sdcard root\n\t\tnew android.support.v7.app.AlertDialog.Builder(\n\t\t\t\tPubkeyListActivity.this, R.style.AlertDialogTheme)\n\t\t\t.setTitle(R.string.pubkey_list_pick)\n\t\t\t.setItems(namesList, new OnClickListener() {\n\t\t\t\tpublic void onClick(DialogInterface arg0, int arg1) {\n\t\t\t\t\tString name = namesList[arg1];\n\n\t\t\t\t\treadKeyFromFile(new File(sdcard, name));\n\t\t\t\t}\n\t\t\t})\n\t\t\t.setNegativeButton(android.R.string.cancel, null).create().show();\n\t}\n\n\tpublic class PubkeyViewHolder extends ItemViewHolder {\n\t\tpublic final ImageView icon;\n\t\tpublic final TextView nickname;\n\t\tpublic final TextView caption;\n\n\t\tpublic PubkeyBean pubkey;\n\n\t\tpublic PubkeyViewHolder(View v) {\n\t\t\tsuper(v);\n\n\t\t\ticon = (ImageView) v.findViewById(android.R.id.icon);\n\t\t\tnickname = (TextView) v.findViewById(android.R.id.text1);\n\t\t\tcaption = (TextView) v.findViewById(android.R.id.text2);\n\t\t}\n\n\t\t@Override\n\t\tpublic void onClick(View v) {\n\t\t\tboolean loaded = bound != null && bound.isKeyLoaded(pubkey.getNickname());\n\n\t\t\t// handle toggling key in-memory on/off\n\t\t\tif (loaded) {\n\t\t\t\tbound.removeKey(pubkey.getNickname());\n\t\t\t\tupdateList();\n\t\t\t} else {\n\t\t\t\thandleAddKey(pubkey);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void onCreateContextMenu(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo) {\n\t\t\t// Create menu to handle deleting and editing pubkey\n\t\t\tmenu.setHeaderTitle(pubkey.getNickname());\n\n\t\t\t// TODO: option load/unload key from in-memory list\n\t\t\t// prompt for password as needed for passworded keys\n\n\t\t\t// cant change password or clipboard imported keys\n\t\t\tfinal boolean imported = PubkeyDatabase.KEY_TYPE_IMPORTED.equals(pubkey.getType());\n\t\t\tfinal boolean loaded = bound != null && bound.isKeyLoaded(pubkey.getNickname());\n\n\t\t\tMenuItem load = menu.add(loaded ? R.string.pubkey_memory_unload : R.string.pubkey_memory_load);\n\t\t\tload.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\tif (loaded) {\n\t\t\t\t\t\tbound.removeKey(pubkey.getNickname());\n\t\t\t\t\t\tupdateList();\n\t\t\t\t\t} else {\n\t\t\t\t\t\thandleAddKey(pubkey);\n\t\t\t\t\t\t//bound.addKey(nickname, trileadKey);\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tonstartToggle = menu.add(R.string.pubkey_load_on_start);\n\t\t\tonstartToggle.setEnabled(!pubkey.isEncrypted());\n\t\t\tonstartToggle.setCheckable(true);\n\t\t\tonstartToggle.setChecked(pubkey.isStartup());\n\t\t\tonstartToggle.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\t// toggle onstart status\n\t\t\t\t\tpubkey.setStartup(!pubkey.isStartup());\n\t\t\t\t\tPubkeyDatabase pubkeyDb = PubkeyDatabase.get(PubkeyListActivity.this);\n\t\t\t\t\tpubkeyDb.savePubkey(pubkey);\n\t\t\t\t\tupdateList();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tMenuItem copyPublicToClipboard = menu.add(R.string.pubkey_copy_public);\n\t\t\tcopyPublicToClipboard.setEnabled(!imported);\n\t\t\tcopyPublicToClipboard.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tPublicKey pk = PubkeyUtils.decodePublic(pubkey.getPublicKey(), pubkey.getType());\n\t\t\t\t\t\tString openSSHPubkey = PubkeyUtils.convertToOpenSSHFormat(pk, pubkey.getNickname());\n\n\t\t\t\t\t\tclipboard.setText(openSSHPubkey);\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tMenuItem copyPrivateToClipboard = menu.add(R.string.pubkey_copy_private);\n\t\t\tcopyPrivateToClipboard.setEnabled(!pubkey.isEncrypted() || imported);\n\t\t\tcopyPrivateToClipboard.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tString data = null;\n\n\t\t\t\t\t\tif (imported)\n\t\t\t\t\t\t\tdata = new String(pubkey.getPrivateKey());\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tPrivateKey pk = PubkeyUtils.decodePrivate(pubkey.getPrivateKey(), pubkey.getType());\n\t\t\t\t\t\t\tdata = PubkeyUtils.exportPEM(pk, null);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tclipboard.setText(data);\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tMenuItem changePassword = menu.add(R.string.pubkey_change_password);\n\t\t\tchangePassword.setEnabled(!imported);\n\t\t\tchangePassword.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\tfinal View changePasswordView =\n\t\t\t\t\t\t\tView.inflate(PubkeyListActivity.this, R.layout.dia_changepassword, null);\n\t\t\t\t\t((TableRow) changePasswordView.findViewById(R.id.old_password_prompt))\n\t\t\t\t\t\t\t.setVisibility(pubkey.isEncrypted() ? View.VISIBLE : View.GONE);\n\t\t\t\t\tnew android.support.v7.app.AlertDialog.Builder(\n\t\t\t\t\t\t\t\t\tPubkeyListActivity.this, R.style.AlertDialogTheme)\n\t\t\t\t\t\t\t.setView(changePasswordView)\n\t\t\t\t\t\t\t.setPositiveButton(R.string.button_change, new DialogInterface.OnClickListener() {\n\t\t\t\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\t\t\t\t\tString oldPassword = ((EditText) changePasswordView.findViewById(R.id.old_password)).getText().toString();\n\t\t\t\t\t\t\t\t\tString password1 = ((EditText) changePasswordView.findViewById(R.id.password1)).getText().toString();\n\t\t\t\t\t\t\t\t\tString password2 = ((EditText) changePasswordView.findViewById(R.id.password2)).getText().toString();\n\n\t\t\t\t\t\t\t\t\tif (!password1.equals(password2)) {\n\t\t\t\t\t\t\t\t\t\tnew android.support.v7.app.AlertDialog.Builder(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tPubkeyListActivity.this,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tR.style.AlertDialogTheme)\n\t\t\t\t\t\t\t\t\t\t\t\t.setMessage(R.string.alert_passwords_do_not_match_msg)\n\t\t\t\t\t\t\t\t\t\t\t\t.setPositiveButton(android.R.string.ok, null)\n\t\t\t\t\t\t\t\t\t\t\t\t.create().show();\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tif (!pubkey.changePassword(oldPassword, password1))\n\t\t\t\t\t\t\t\t\t\t\tnew android.support.v7.app.AlertDialog.Builder(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tPubkeyListActivity.this,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tR.style.AlertDialogTheme)\n\t\t\t\t\t\t\t\t\t\t\t\t\t.setMessage(R.string.alert_wrong_password_msg)\n\t\t\t\t\t\t\t\t\t\t\t\t\t.setPositiveButton(android.R.string.ok, null)\n\t\t\t\t\t\t\t\t\t\t\t\t\t.create().show();\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\tPubkeyDatabase pubkeyDb = PubkeyDatabase.get(PubkeyListActivity.this);\n\t\t\t\t\t\t\t\t\t\t\tpubkeyDb.savePubkey(pubkey);\n\t\t\t\t\t\t\t\t\t\t\tupdateList();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\t\t\t\tLog.e(TAG, \"Could not change private key password\", e);\n\t\t\t\t\t\t\t\t\t\tnew android.support.v7.app.AlertDialog.Builder(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tPubkeyListActivity.this,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tR.style.AlertDialogTheme)\n\t\t\t\t\t\t\t\t\t\t\t\t.setMessage(R.string.alert_key_corrupted_msg)\n\t\t\t\t\t\t\t\t\t\t\t\t.setPositiveButton(android.R.string.ok, null)\n\t\t\t\t\t\t\t\t\t\t\t\t.create().show();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t.setNegativeButton(android.R.string.cancel, null).create().show();\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tconfirmUse = menu.add(R.string.pubkey_confirm_use);\n\t\t\tconfirmUse.setCheckable(true);\n\t\t\tconfirmUse.setChecked(pubkey.isConfirmUse());\n\t\t\tconfirmUse.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\t// toggle confirm use\n\t\t\t\t\tpubkey.setConfirmUse(!pubkey.isConfirmUse());\n\t\t\t\t\tPubkeyDatabase pubkeyDb = PubkeyDatabase.get(PubkeyListActivity.this);\n\t\t\t\t\tpubkeyDb.savePubkey(pubkey);\n\t\t\t\t\tupdateList();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tMenuItem delete = menu.add(R.string.pubkey_delete);\n\t\t\tdelete.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\t// prompt user to make sure they really want this\n\t\t\t\t\tnew android.support.v7.app.AlertDialog.Builder(\n\t\t\t\t\t\t\t\t\tPubkeyListActivity.this, R.style.AlertDialogTheme)\n\t\t\t\t\t\t\t.setMessage(getString(R.string.delete_message, pubkey.getNickname()))\n\t\t\t\t\t\t\t.setPositiveButton(R.string.delete_pos, new DialogInterface.OnClickListener() {\n\t\t\t\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\n\t\t\t\t\t\t\t\t\t// dont forget to remove from in-memory\n\t\t\t\t\t\t\t\t\tif (loaded) {\n\t\t\t\t\t\t\t\t\t\tbound.removeKey(pubkey.getNickname());\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// delete from backend database and update gui\n\t\t\t\t\t\t\t\t\tPubkeyDatabase pubkeyDb = PubkeyDatabase.get(PubkeyListActivity.this);\n\t\t\t\t\t\t\t\t\tpubkeyDb.deletePubkey(pubkey);\n\t\t\t\t\t\t\t\t\tupdateList();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t.setNegativeButton(R.string.delete_neg, null).create().show();\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t@VisibleForTesting\n\tprivate class PubkeyAdapter extends ItemAdapter {\n\t\tprivate final List<PubkeyBean> pubkeys;\n\n\t\tpublic PubkeyAdapter(Context context, List<PubkeyBean> pubkeys) {\n\t\t\tsuper(context);\n\t\t\tthis.pubkeys = pubkeys;\n\t\t}\n\n\t\t@Override\n\t\tpublic PubkeyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n\t\t\tView v = LayoutInflater.from(parent.getContext())\n\t\t\t\t\t.inflate(R.layout.item_pubkey, parent, false);\n\t\t\tPubkeyViewHolder vh = new PubkeyViewHolder(v);\n\t\t\treturn vh;\n\t\t}\n\n\t\tpublic void onBindViewHolder(ItemViewHolder holder, int position) {\n\t\t\tPubkeyViewHolder pubkeyHolder = (PubkeyViewHolder) holder;\n\n\t\t\tPubkeyBean pubkey = pubkeys.get(position);\n\t\t\tpubkeyHolder.pubkey = pubkey;\n\t\t\tif (pubkey == null) {\n\t\t\t\t// Well, something bad happened. We can't continue.\n\t\t\t\tLog.e(\"PubkeyAdapter\", \"Pubkey bean is null!\");\n\n\t\t\t\tpubkeyHolder.nickname.setText(\"Error during lookup\");\n\t\t\t} else {\n\t\t\t\tpubkeyHolder.nickname.setText(pubkey.getNickname());\n\t\t\t}\n\n\t\t\tboolean imported = PubkeyDatabase.KEY_TYPE_IMPORTED.equals(pubkey.getType());\n\n\t\t\tif (imported) {\n\t\t\t\ttry {\n\t\t\t\t\tPEMStructure struct = PEMDecoder.parsePEM(new String(pubkey.getPrivateKey()).toCharArray());\n\t\t\t\t\tString type;\n\t\t\t\t\tif (struct.pemType == PEMDecoder.PEM_RSA_PRIVATE_KEY) {\n\t\t\t\t\t\ttype = \"RSA\";\n\t\t\t\t\t} else if (struct.pemType == PEMDecoder.PEM_DSA_PRIVATE_KEY) {\n\t\t\t\t\t\ttype = \"DSA\";\n\t\t\t\t\t} else if (struct.pemType == PEMDecoder.PEM_EC_PRIVATE_KEY) {\n\t\t\t\t\t\ttype = \"EC\";\n\t\t\t\t\t} else if (struct.pemType == PEMDecoder.PEM_OPENSSH_PRIVATE_KEY) {\n\t\t\t\t\t\ttype = \"OpenSSH\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new RuntimeException(\"Unexpected key type: \" + struct.pemType);\n\t\t\t\t\t}\n\t\t\t\t\tpubkeyHolder.caption.setText(String.format(\"%s unknown-bit\", type));\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tLog.e(TAG, \"Error decoding IMPORTED public key at \" + pubkey.getId(), e);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tpubkeyHolder.caption.setText(pubkey.getDescription());\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tLog.e(TAG, \"Error decoding public key at \" + pubkey.getId(), e);\n\t\t\t\t\tpubkeyHolder.caption.setText(R.string.pubkey_unknown_format);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (bound == null) {\n\t\t\t\tpubkeyHolder.icon.setVisibility(View.GONE);\n\t\t\t} else {\n\t\t\t\tpubkeyHolder.icon.setVisibility(View.VISIBLE);\n\n\t\t\t\tif (bound.isKeyLoaded(pubkey.getNickname()))\n\t\t\t\t\tpubkeyHolder.icon.setImageState(new int[] { android.R.attr.state_checked }, true);\n\t\t\t\telse\n\t\t\t\t\tpubkeyHolder.icon.setImageState(new int[] { }, true);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic int getItemCount() {\n\t\t\treturn pubkeys.size();\n\t\t}\n\n\t\t@Override\n\t\tpublic long getItemId(int position) {\n\t\t\treturn pubkeys.get(position).getId();\n\t\t}\n\t}\n}\n","Method after Refactoring":"/*\n * ConnectBot: simple, powerful, open-source SSH client for Android\n * Copyright 2007 Kenny Root, Jeffrey Sharkey\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.connectbot;\n\nimport java.io.BufferedReader;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.security.KeyPair;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.util.Collections;\nimport java.util.EventListener;\nimport java.util.LinkedList;\nimport java.util.List;\n\nimport org.connectbot.bean.PubkeyBean;\nimport org.connectbot.service.TerminalManager;\nimport org.connectbot.util.PubkeyDatabase;\nimport org.connectbot.util.PubkeyUtils;\nimport org.openintents.intents.FileManagerIntents;\n\nimport com.trilead.ssh2.crypto.Base64;\nimport com.trilead.ssh2.crypto.PEMDecoder;\nimport com.trilead.ssh2.crypto.PEMStructure;\n\nimport android.content.ActivityNotFoundException;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.DialogInterface.OnClickListener;\nimport android.content.Intent;\nimport android.content.ServiceConnection;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Environment;\nimport android.os.IBinder;\nimport android.support.annotation.VisibleForTesting;\nimport android.support.v7.widget.LinearLayoutManager;\nimport android.support.v7.widget.RecyclerView;\nimport android.text.ClipboardManager;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.LayoutInflater;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.MenuItem.OnMenuItemClickListener;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.EditText;\nimport android.widget.ImageView;\nimport android.widget.TableRow;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\n/**\n * List public keys in database by nickname and describe their properties. Allow users to import,\n * generate, rename, and delete key pairs.\n *\n * @author Kenny Root\n */\npublic class PubkeyListActivity extends AppCompatListActivity implements EventListener {\n\tpublic final static String TAG = \"CB.PubkeyListActivity\";\n\n\tprivate static final int MAX_KEYFILE_SIZE = 32768;\n\tprivate static final int REQUEST_CODE_PICK_FILE = 1;\n\n\t// Constants for AndExplorer's file picking intent\n\tprivate static final String ANDEXPLORER_TITLE = \"explorer_title\";\n\tprivate static final String MIME_TYPE_ANDEXPLORER_FILE = \"vnd.android.cursor.dir/lysesoft.andexplorer.file\";\n\n\tprivate List<PubkeyBean> pubkeys;\n\n\tprotected ClipboardManager clipboard;\n\n\tprotected LayoutInflater inflater = null;\n\n\tprotected TerminalManager bound = null;\n\n\tprivate MenuItem onstartToggle = null;\n\tprivate MenuItem confirmUse = null;\n\n\tprivate ServiceConnection connection = new ServiceConnection() {\n\t\tpublic void onServiceConnected(ComponentName className, IBinder service) {\n\t\t\tbound = ((TerminalManager.TerminalBinder) service).getService();\n\n\t\t\t// update our listview binder to find the service\n\t\t\tupdateList();\n\t\t}\n\n\t\tpublic void onServiceDisconnected(ComponentName className) {\n\t\t\tbound = null;\n\t\t\tupdateList();\n\t\t}\n\t};\n\n\t@Override\n\tpublic void onStart() {\n\t\tsuper.onStart();\n\n\t\tbindService(new Intent(this, TerminalManager.class), connection, Context.BIND_AUTO_CREATE);\n\n\t\tupdateList();\n\t}\n\n\t@Override\n\tpublic void onStop() {\n\t\tsuper.onStop();\n\n\t\tunbindService(connection);\n\t}\n\n\t@Override\n\tpublic void onCreate(Bundle icicle) {\n\t\tsuper.onCreate(icicle);\n\t\tsetContentView(R.layout.act_pubkeylist);\n\n\t\tmListView = (RecyclerView) findViewById(R.id.list);\n\t\tmListView.setHasFixedSize(true);\n\t\tmListView.setLayoutManager(new LinearLayoutManager(this));\n\t\tmListView.addItemDecoration(new ListItemDecoration(this));\n\n\t\tmEmptyView = findViewById(R.id.empty);\n\n\t\tregisterForContextMenu(mListView);\n\n\t\tclipboard = (ClipboardManager) getSystemService(CLIPBOARD_SERVICE);\n\n\t\tinflater = LayoutInflater.from(this);\n\t}\n\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu) {\n\t\tMenuInflater inflater = getMenuInflater();\n\t\tinflater.inflate(R.menu.pubkey_list_activity_menu, menu);\n\t\treturn super.onCreateOptionsMenu(menu);\n\t}\n\n\t@Override\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tswitch (item.getItemId()) {\n\t\tcase R.id.add_new_key_icon:\n\t\t\tstartActivity(new Intent(this, GeneratePubkeyActivity.class));\n\t\t\treturn true;\n\t\tcase R.id.import_existing_key_icon:\n\t\t\timportExistingKey();\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn super.onOptionsItemSelected(item);\n\t\t}\n\t}\n\n\tprivate boolean importExistingKey() {\n\t\tUri sdcard = Uri.fromFile(Environment.getExternalStorageDirectory());\n\t\tString pickerTitle = getString(R.string.pubkey_list_pick);\n\n\t\treturn importExistingKeyKitKat() || importExistingKeyOpenIntents(sdcard, pickerTitle)\n\t\t\t\t|| importExistingKeyAndExplorer(sdcard, pickerTitle) || pickFileSimple();\n\t}\n\n\t/**\n\t * Fires an intent to spin up the \"file chooser\" UI and select a private key.\n\t */\n\tpublic boolean importExistingKeyKitKat() {\n\t\t// ACTION_OPEN_DOCUMENT is the intent to choose a file via the system's file\n\t\t// browser.\n\t\tIntent intent = new Intent(Intent.ACTION_OPEN_DOCUMENT);\n\n\t\t// Filter to only show results that can be \"opened\", such as a\n\t\t// file (as opposed to a list of contacts or timezones)\n\t\tintent.addCategory(Intent.CATEGORY_OPENABLE);\n\n\t\t// PKCS#8 MIME types aren't widely supported, so we'll try */* fro now.\n\t\tintent.setType(\"*/*\");\n\n\t\ttry {\n\t\t\tstartActivityForResult(intent, REQUEST_CODE_PICK_FILE);\n\t\t\treturn true;\n\t\t} catch (ActivityNotFoundException e) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Imports an existing key using the OpenIntents-style request.\n\t */\n\tprivate boolean importExistingKeyOpenIntents(Uri sdcard, String pickerTitle) {\n\t\t// Try to use OpenIntent's file browser to pick a file\n\t\tIntent intent = new Intent(FileManagerIntents.ACTION_PICK_FILE);\n\t\tintent.setData(sdcard);\n\t\tintent.putExtra(FileManagerIntents.EXTRA_TITLE, pickerTitle);\n\t\tintent.putExtra(FileManagerIntents.EXTRA_BUTTON_TEXT, getString(android.R.string.ok));\n\n\t\ttry {\n\t\t\tstartActivityForResult(intent, REQUEST_CODE_PICK_FILE);\n\t\t\treturn true;\n\t\t} catch (ActivityNotFoundException e) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate boolean importExistingKeyAndExplorer(Uri sdcard, String pickerTitle) {\n\t\tIntent intent;\n\t\tintent = new Intent(Intent.ACTION_PICK);\n\t\tintent.setDataAndType(sdcard, MIME_TYPE_ANDEXPLORER_FILE);\n\t\tintent.putExtra(ANDEXPLORER_TITLE, pickerTitle);\n\n\t\ttry {\n\t\t\tstartActivityForResult(intent, REQUEST_CODE_PICK_FILE);\n\t\t\treturn true;\n\t\t} catch (ActivityNotFoundException e) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Builds a simple list of files to pick from.\n\t */\n\tprivate boolean pickFileSimple() {\n\t\t// build list of all files in sdcard root\n\t\tfinal File sdcard = Environment.getExternalStorageDirectory();\n\t\tLog.d(TAG, sdcard.toString());\n\n\t\t// Don't show a dialog if the SD card is completely absent.\n\t\tfinal String state = Environment.getExternalStorageState();\n\t\tif (!Environment.MEDIA_MOUNTED_READ_ONLY.equals(state)\n\t\t\t\t&& !Environment.MEDIA_MOUNTED.equals(state)) {\n\t\t\tnew android.support.v7.app.AlertDialog.Builder(\n\t\t\t\t\tPubkeyListActivity.this, R.style.AlertDialogTheme)\n\t\t\t\t\t.setMessage(R.string.alert_sdcard_absent)\n\t\t\t\t\t.setNegativeButton(android.R.string.cancel, null).create().show();\n\t\t\treturn true;\n\t\t}\n\n\t\tList<String> names = new LinkedList<String>();\n\t\t{\n\t\t\tFile[] files = sdcard.listFiles();\n\t\t\tif (files != null) {\n\t\t\t\tfor (File file : sdcard.listFiles()) {\n\t\t\t\t\tif (file.isDirectory()) continue;\n\t\t\t\t\tnames.add(file.getName());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tCollections.sort(names);\n\n\t\tfinal String[] namesList = names.toArray(new String[] {});\n\t\tLog.d(TAG, names.toString());\n\n\t\t// prompt user to select any file from the sdcard root\n\t\tnew android.support.v7.app.AlertDialog.Builder(\n\t\t\t\tPubkeyListActivity.this, R.style.AlertDialogTheme)\n\t\t\t\t.setTitle(R.string.pubkey_list_pick)\n\t\t\t\t.setItems(namesList, new OnClickListener() {\n\t\t\t\t\tpublic void onClick(DialogInterface arg0, int arg1) {\n\t\t\t\t\t\tString name = namesList[arg1];\n\n\t\t\t\t\t\treadKeyFromFile(Uri.fromFile(new File(sdcard, name)));\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.setNegativeButton(android.R.string.cancel, null).create().show();\n\n\t\treturn true;\n\t}\n\n\tprotected void handleAddKey(final PubkeyBean pubkey) {\n\t\tif (pubkey.isEncrypted()) {\n\t\t\tfinal View view = View.inflate(this, R.layout.dia_password, null);\n\t\t\tfinal EditText passwordField = (EditText) view.findViewById(android.R.id.text1);\n\n\t\t\tnew android.support.v7.app.AlertDialog.Builder(\n\t\t\t\t\tPubkeyListActivity.this, R.style.AlertDialogTheme)\n\t\t\t\t.setView(view)\n\t\t\t\t.setPositiveButton(R.string.pubkey_unlock, new DialogInterface.OnClickListener() {\n\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\t\thandleAddKey(pubkey, passwordField.getText().toString());\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.setNegativeButton(android.R.string.cancel, null).create().show();\n\t\t} else {\n\t\t\thandleAddKey(pubkey, null);\n\t\t}\n\t}\n\n\tprotected void handleAddKey(PubkeyBean keybean, String password) {\n\t\tKeyPair pair = null;\n\t\tif (PubkeyDatabase.KEY_TYPE_IMPORTED.equals(keybean.getType())) {\n\t\t\t// load specific key using pem format\n\t\t\ttry {\n\t\t\t\tpair = PEMDecoder.decode(new String(keybean.getPrivateKey()).toCharArray(), password);\n\t\t\t} catch (Exception e) {\n\t\t\t\tString message = getResources().getString(R.string.pubkey_failed_add, keybean.getNickname());\n\t\t\t\tLog.e(TAG, message, e);\n\t\t\t\tToast.makeText(PubkeyListActivity.this, message, Toast.LENGTH_LONG).show();\n\t\t\t}\n\t\t} else {\n\t\t\t// load using internal generated format\n\t\t\ttry {\n\t\t\t\tPrivateKey privKey = PubkeyUtils.decodePrivate(keybean.getPrivateKey(), keybean.getType(), password);\n\t\t\t\tPublicKey pubKey = PubkeyUtils.decodePublic(keybean.getPublicKey(), keybean.getType());\n\t\t\t\tLog.d(TAG, \"Unlocked key \" + PubkeyUtils.formatKey(pubKey));\n\n\t\t\t\tpair = new KeyPair(pubKey, privKey);\n\t\t\t} catch (Exception e) {\n\t\t\t\tString message = getResources().getString(R.string.pubkey_failed_add, keybean.getNickname());\n\t\t\t\tLog.e(TAG, message, e);\n\t\t\t\tToast.makeText(PubkeyListActivity.this, message, Toast.LENGTH_LONG).show();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (pair == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tLog.d(TAG, String.format(\"Unlocked key '%s'\", keybean.getNickname()));\n\n\t\t// save this key in memory\n\t\tbound.addKey(keybean, pair, true);\n\n\t\tupdateList();\n\t}\n\n\tprotected void updateList() {\n\t\tPubkeyDatabase pubkeyDb = PubkeyDatabase.get(PubkeyListActivity.this);\n\t\tpubkeys = pubkeyDb.allPubkeys();\n\n\t\tmAdapter = new PubkeyAdapter(this, pubkeys);\n\t\tmListView.setAdapter(mAdapter);\n\t\tadjustViewVisibility();\n\t}\n\n\t@Override\n\tprotected void onActivityResult(int requestCode, int resultCode, Intent resultData) {\n\t\tsuper.onActivityResult(requestCode, resultCode, resultData);\n\n\t\tswitch (requestCode) {\n\t\tcase REQUEST_CODE_PICK_FILE:\n\t\t\tif (resultCode == RESULT_OK && resultData != null) {\n\t\t\t\tUri uri = resultData.getData();\n\t\t\t\ttry {\n\t\t\t\t\tif (uri != null) {\n\t\t\t\t\t\treadKeyFromFile(uri);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tString filename = resultData.getDataString();\n\t\t\t\t\t\tif (filename != null) {\n\t\t\t\t\t\t\treadKeyFromFile(Uri.parse(filename));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\t\tLog.e(TAG, \"Couldn't read from picked file\", e);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tpublic static byte[] getBytesFromInputStream(InputStream is, int maxSize) throws IOException {\n\t\tByteArrayOutputStream os = new ByteArrayOutputStream();\n\t\tbyte[] buffer = new byte[0xFFFF];\n\n\t\tfor (int len; (len = is.read(buffer)) != -1 && os.size() < maxSize; ) {\n\t\t\tos.write(buffer, 0, len);\n\t\t}\n\n\t\tif (os.size() >= maxSize) {\n\t\t\tthrow new IOException(\"File was too big\");\n\t\t}\n\n\t\tos.flush();\n\t\treturn os.toByteArray();\n\t}\n\n\tprivate KeyPair readPKCS8Key(byte[] keyData) {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(new ByteArrayInputStream(keyData)));\n\n\t\t// parse the actual key once to check if its encrypted\n\t\t// then save original file contents into our database\n\t\ttry {\n\t\t\tByteArrayOutputStream keyBytes = new ByteArrayOutputStream();\n\n\t\t\tString line;\n\t\t\tboolean inKey = false;\n\t\t\twhile ((line = reader.readLine()) != null) {\n\t\t\t\tif (line.equals(PubkeyUtils.PKCS8_START)) {\n\t\t\t\t\tinKey = true;\n\t\t\t\t} else if (line.equals(PubkeyUtils.PKCS8_END)) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (inKey) {\n\t\t\t\t\tkeyBytes.write(line.getBytes(\"US-ASCII\"));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (keyBytes.size() > 0) {\n\t\t\t\tbyte[] decoded = Base64.decode(keyBytes.toString().toCharArray());\n\n\t\t\t\treturn PubkeyUtils.recoverKeyPair(decoded);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\treturn null;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * @param uri URI to private key to read.\n\t */\n\tprivate void readKeyFromFile(Uri uri) {\n\t\tPubkeyBean pubkey = new PubkeyBean();\n\n\t\t// find the exact file selected\n\t\tpubkey.setNickname(uri.getLastPathSegment());\n\n\t\tbyte[] keyData;\n\t\ttry {\n\t\t\tContentResolver resolver = getContentResolver();\n\t\t\tkeyData = getBytesFromInputStream(resolver.openInputStream(uri), MAX_KEYFILE_SIZE);\n\t\t} catch (IOException e) {\n\t\t\tToast.makeText(PubkeyListActivity.this,\n\t\t\t\t\tR.string.pubkey_import_parse_problem,\n\t\t\t\t\tToast.LENGTH_LONG).show();\n\t\t\treturn;\n\t\t}\n\n\t\tKeyPair kp;\n\t\tif ((kp = readPKCS8Key(keyData)) != null) {\n\t\t\tString algorithm = convertAlgorithmName(kp.getPrivate().getAlgorithm());\n\t\t\tpubkey.setType(algorithm);\n\t\t\tpubkey.setPrivateKey(kp.getPrivate().getEncoded());\n\t\t\tpubkey.setPublicKey(kp.getPublic().getEncoded());\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tPEMStructure struct = PEMDecoder.parsePEM(new String(keyData).toCharArray());\n\t\t\t\tboolean encrypted = PEMDecoder.isPEMEncrypted(struct);\n\t\t\t\tpubkey.setEncrypted(encrypted);\n\t\t\t\tif (!encrypted) {\n\t\t\t\t\tkp = PEMDecoder.decode(struct, null);\n\t\t\t\t\tString algorithm = convertAlgorithmName(kp.getPrivate().getAlgorithm());\n\t\t\t\t\tpubkey.setType(algorithm);\n\t\t\t\t\tpubkey.setPrivateKey(kp.getPrivate().getEncoded());\n\t\t\t\t\tpubkey.setPublicKey(kp.getPublic().getEncoded());\n\t\t\t\t} else {\n\t\t\t\t\tpubkey.setType(PubkeyDatabase.KEY_TYPE_IMPORTED);\n\t\t\t\t\tpubkey.setPrivateKey(keyData);\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\tLog.e(TAG, \"Problem parsing imported private key\", e);\n\t\t\t\tToast.makeText(PubkeyListActivity.this, R.string.pubkey_import_parse_problem, Toast.LENGTH_LONG).show();\n\t\t\t}\n\t\t}\n\n\t\t// write new value into database\n\t\tPubkeyDatabase pubkeyDb = PubkeyDatabase.get(this);\n\t\tpubkeyDb.savePubkey(pubkey);\n\n\t\tupdateList();\n\t}\n\n\tprivate String convertAlgorithmName(String algorithm) {\n\t\tif (\"EdDSA\".equals(algorithm)) {\n\t\t\treturn PubkeyDatabase.KEY_TYPE_ED25519;\n\t\t} else {\n\t\t\treturn algorithm;\n\t\t}\n\t}\n\n\tpublic class PubkeyViewHolder extends ItemViewHolder {\n\t\tpublic final ImageView icon;\n\t\tpublic final TextView nickname;\n\t\tpublic final TextView caption;\n\n\t\tpublic PubkeyBean pubkey;\n\n\t\tpublic PubkeyViewHolder(View v) {\n\t\t\tsuper(v);\n\n\t\t\ticon = (ImageView) v.findViewById(android.R.id.icon);\n\t\t\tnickname = (TextView) v.findViewById(android.R.id.text1);\n\t\t\tcaption = (TextView) v.findViewById(android.R.id.text2);\n\t\t}\n\n\t\t@Override\n\t\tpublic void onClick(View v) {\n\t\t\tboolean loaded = bound != null && bound.isKeyLoaded(pubkey.getNickname());\n\n\t\t\t// handle toggling key in-memory on/off\n\t\t\tif (loaded) {\n\t\t\t\tbound.removeKey(pubkey.getNickname());\n\t\t\t\tupdateList();\n\t\t\t} else {\n\t\t\t\thandleAddKey(pubkey);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void onCreateContextMenu(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo) {\n\t\t\t// Create menu to handle deleting and editing pubkey\n\t\t\tmenu.setHeaderTitle(pubkey.getNickname());\n\n\t\t\t// TODO: option load/unload key from in-memory list\n\t\t\t// prompt for password as needed for passworded keys\n\n\t\t\t// cant change password or clipboard imported keys\n\t\t\tfinal boolean imported = PubkeyDatabase.KEY_TYPE_IMPORTED.equals(pubkey.getType());\n\t\t\tfinal boolean loaded = bound != null && bound.isKeyLoaded(pubkey.getNickname());\n\n\t\t\tMenuItem load = menu.add(loaded ? R.string.pubkey_memory_unload : R.string.pubkey_memory_load);\n\t\t\tload.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\tif (loaded) {\n\t\t\t\t\t\tbound.removeKey(pubkey.getNickname());\n\t\t\t\t\t\tupdateList();\n\t\t\t\t\t} else {\n\t\t\t\t\t\thandleAddKey(pubkey);\n\t\t\t\t\t\t//bound.addKey(nickname, trileadKey);\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tonstartToggle = menu.add(R.string.pubkey_load_on_start);\n\t\t\tonstartToggle.setEnabled(!pubkey.isEncrypted());\n\t\t\tonstartToggle.setCheckable(true);\n\t\t\tonstartToggle.setChecked(pubkey.isStartup());\n\t\t\tonstartToggle.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\t// toggle onstart status\n\t\t\t\t\tpubkey.setStartup(!pubkey.isStartup());\n\t\t\t\t\tPubkeyDatabase pubkeyDb = PubkeyDatabase.get(PubkeyListActivity.this);\n\t\t\t\t\tpubkeyDb.savePubkey(pubkey);\n\t\t\t\t\tupdateList();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tMenuItem copyPublicToClipboard = menu.add(R.string.pubkey_copy_public);\n\t\t\tcopyPublicToClipboard.setEnabled(!imported);\n\t\t\tcopyPublicToClipboard.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tPublicKey pk = PubkeyUtils.decodePublic(pubkey.getPublicKey(), pubkey.getType());\n\t\t\t\t\t\tString openSSHPubkey = PubkeyUtils.convertToOpenSSHFormat(pk, pubkey.getNickname());\n\n\t\t\t\t\t\tclipboard.setText(openSSHPubkey);\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tMenuItem copyPrivateToClipboard = menu.add(R.string.pubkey_copy_private);\n\t\t\tcopyPrivateToClipboard.setEnabled(!pubkey.isEncrypted() || imported);\n\t\t\tcopyPrivateToClipboard.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tString data = null;\n\n\t\t\t\t\t\tif (imported)\n\t\t\t\t\t\t\tdata = new String(pubkey.getPrivateKey());\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tPrivateKey pk = PubkeyUtils.decodePrivate(pubkey.getPrivateKey(), pubkey.getType());\n\t\t\t\t\t\t\tdata = PubkeyUtils.exportPEM(pk, null);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tclipboard.setText(data);\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tMenuItem changePassword = menu.add(R.string.pubkey_change_password);\n\t\t\tchangePassword.setEnabled(!imported);\n\t\t\tchangePassword.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\tfinal View changePasswordView =\n\t\t\t\t\t\t\tView.inflate(PubkeyListActivity.this, R.layout.dia_changepassword, null);\n\t\t\t\t\t((TableRow) changePasswordView.findViewById(R.id.old_password_prompt))\n\t\t\t\t\t\t\t.setVisibility(pubkey.isEncrypted() ? View.VISIBLE : View.GONE);\n\t\t\t\t\tnew android.support.v7.app.AlertDialog.Builder(\n\t\t\t\t\t\t\t\t\tPubkeyListActivity.this, R.style.AlertDialogTheme)\n\t\t\t\t\t\t\t.setView(changePasswordView)\n\t\t\t\t\t\t\t.setPositiveButton(R.string.button_change, new DialogInterface.OnClickListener() {\n\t\t\t\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\t\t\t\t\tString oldPassword = ((EditText) changePasswordView.findViewById(R.id.old_password)).getText().toString();\n\t\t\t\t\t\t\t\t\tString password1 = ((EditText) changePasswordView.findViewById(R.id.password1)).getText().toString();\n\t\t\t\t\t\t\t\t\tString password2 = ((EditText) changePasswordView.findViewById(R.id.password2)).getText().toString();\n\n\t\t\t\t\t\t\t\t\tif (!password1.equals(password2)) {\n\t\t\t\t\t\t\t\t\t\tnew android.support.v7.app.AlertDialog.Builder(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tPubkeyListActivity.this,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tR.style.AlertDialogTheme)\n\t\t\t\t\t\t\t\t\t\t\t\t.setMessage(R.string.alert_passwords_do_not_match_msg)\n\t\t\t\t\t\t\t\t\t\t\t\t.setPositiveButton(android.R.string.ok, null)\n\t\t\t\t\t\t\t\t\t\t\t\t.create().show();\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tif (!pubkey.changePassword(oldPassword, password1))\n\t\t\t\t\t\t\t\t\t\t\tnew android.support.v7.app.AlertDialog.Builder(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tPubkeyListActivity.this,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tR.style.AlertDialogTheme)\n\t\t\t\t\t\t\t\t\t\t\t\t\t.setMessage(R.string.alert_wrong_password_msg)\n\t\t\t\t\t\t\t\t\t\t\t\t\t.setPositiveButton(android.R.string.ok, null)\n\t\t\t\t\t\t\t\t\t\t\t\t\t.create().show();\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\tPubkeyDatabase pubkeyDb = PubkeyDatabase.get(PubkeyListActivity.this);\n\t\t\t\t\t\t\t\t\t\t\tpubkeyDb.savePubkey(pubkey);\n\t\t\t\t\t\t\t\t\t\t\tupdateList();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\t\t\t\tLog.e(TAG, \"Could not change private key password\", e);\n\t\t\t\t\t\t\t\t\t\tnew android.support.v7.app.AlertDialog.Builder(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tPubkeyListActivity.this,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tR.style.AlertDialogTheme)\n\t\t\t\t\t\t\t\t\t\t\t\t.setMessage(R.string.alert_key_corrupted_msg)\n\t\t\t\t\t\t\t\t\t\t\t\t.setPositiveButton(android.R.string.ok, null)\n\t\t\t\t\t\t\t\t\t\t\t\t.create().show();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t.setNegativeButton(android.R.string.cancel, null).create().show();\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tconfirmUse = menu.add(R.string.pubkey_confirm_use);\n\t\t\tconfirmUse.setCheckable(true);\n\t\t\tconfirmUse.setChecked(pubkey.isConfirmUse());\n\t\t\tconfirmUse.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\t// toggle confirm use\n\t\t\t\t\tpubkey.setConfirmUse(!pubkey.isConfirmUse());\n\t\t\t\t\tPubkeyDatabase pubkeyDb = PubkeyDatabase.get(PubkeyListActivity.this);\n\t\t\t\t\tpubkeyDb.savePubkey(pubkey);\n\t\t\t\t\tupdateList();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tMenuItem delete = menu.add(R.string.pubkey_delete);\n\t\t\tdelete.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\t// prompt user to make sure they really want this\n\t\t\t\t\tnew android.support.v7.app.AlertDialog.Builder(\n\t\t\t\t\t\t\t\t\tPubkeyListActivity.this, R.style.AlertDialogTheme)\n\t\t\t\t\t\t\t.setMessage(getString(R.string.delete_message, pubkey.getNickname()))\n\t\t\t\t\t\t\t.setPositiveButton(R.string.delete_pos, new DialogInterface.OnClickListener() {\n\t\t\t\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\n\t\t\t\t\t\t\t\t\t// dont forget to remove from in-memory\n\t\t\t\t\t\t\t\t\tif (loaded) {\n\t\t\t\t\t\t\t\t\t\tbound.removeKey(pubkey.getNickname());\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// delete from backend database and update gui\n\t\t\t\t\t\t\t\t\tPubkeyDatabase pubkeyDb = PubkeyDatabase.get(PubkeyListActivity.this);\n\t\t\t\t\t\t\t\t\tpubkeyDb.deletePubkey(pubkey);\n\t\t\t\t\t\t\t\t\tupdateList();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t.setNegativeButton(R.string.delete_neg, null).create().show();\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t@VisibleForTesting\n\tprivate class PubkeyAdapter extends ItemAdapter {\n\t\tprivate final List<PubkeyBean> pubkeys;\n\n\t\tpublic PubkeyAdapter(Context context, List<PubkeyBean> pubkeys) {\n\t\t\tsuper(context);\n\t\t\tthis.pubkeys = pubkeys;\n\t\t}\n\n\t\t@Override\n\t\tpublic PubkeyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n\t\t\tView v = LayoutInflater.from(parent.getContext())\n\t\t\t\t\t.inflate(R.layout.item_pubkey, parent, false);\n\t\t\tPubkeyViewHolder vh = new PubkeyViewHolder(v);\n\t\t\treturn vh;\n\t\t}\n\n\t\tpublic void onBindViewHolder(ItemViewHolder holder, int position) {\n\t\t\tPubkeyViewHolder pubkeyHolder = (PubkeyViewHolder) holder;\n\n\t\t\tPubkeyBean pubkey = pubkeys.get(position);\n\t\t\tpubkeyHolder.pubkey = pubkey;\n\t\t\tif (pubkey == null) {\n\t\t\t\t// Well, something bad happened. We can't continue.\n\t\t\t\tLog.e(\"PubkeyAdapter\", \"Pubkey bean is null!\");\n\n\t\t\t\tpubkeyHolder.nickname.setText(\"Error during lookup\");\n\t\t\t} else {\n\t\t\t\tpubkeyHolder.nickname.setText(pubkey.getNickname());\n\t\t\t}\n\n\t\t\tboolean imported = PubkeyDatabase.KEY_TYPE_IMPORTED.equals(pubkey.getType());\n\n\t\t\tif (imported) {\n\t\t\t\ttry {\n\t\t\t\t\tPEMStructure struct = PEMDecoder.parsePEM(new String(pubkey.getPrivateKey()).toCharArray());\n\t\t\t\t\tString type;\n\t\t\t\t\tif (struct.pemType == PEMDecoder.PEM_RSA_PRIVATE_KEY) {\n\t\t\t\t\t\ttype = \"RSA\";\n\t\t\t\t\t} else if (struct.pemType == PEMDecoder.PEM_DSA_PRIVATE_KEY) {\n\t\t\t\t\t\ttype = \"DSA\";\n\t\t\t\t\t} else if (struct.pemType == PEMDecoder.PEM_EC_PRIVATE_KEY) {\n\t\t\t\t\t\ttype = \"EC\";\n\t\t\t\t\t} else if (struct.pemType == PEMDecoder.PEM_OPENSSH_PRIVATE_KEY) {\n\t\t\t\t\t\ttype = \"OpenSSH\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new RuntimeException(\"Unexpected key type: \" + struct.pemType);\n\t\t\t\t\t}\n\t\t\t\t\tpubkeyHolder.caption.setText(String.format(\"%s unknown-bit\", type));\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tLog.e(TAG, \"Error decoding IMPORTED public key at \" + pubkey.getId(), e);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tpubkeyHolder.caption.setText(pubkey.getDescription());\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tLog.e(TAG, \"Error decoding public key at \" + pubkey.getId(), e);\n\t\t\t\t\tpubkeyHolder.caption.setText(R.string.pubkey_unknown_format);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (bound == null) {\n\t\t\t\tpubkeyHolder.icon.setVisibility(View.GONE);\n\t\t\t} else {\n\t\t\t\tpubkeyHolder.icon.setVisibility(View.VISIBLE);\n\n\t\t\t\tif (bound.isKeyLoaded(pubkey.getNickname()))\n\t\t\t\t\tpubkeyHolder.icon.setImageState(new int[] { android.R.attr.state_checked }, true);\n\t\t\t\telse\n\t\t\t\t\tpubkeyHolder.icon.setImageState(new int[] { }, true);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic int getItemCount() {\n\t\t\treturn pubkeys.size();\n\t\t}\n\n\t\t@Override\n\t\tpublic long getItemId(int position) {\n\t\t\treturn pubkeys.get(position).getId();\n\t\t}\n\t}\n}\n","lineNo":458}
{"Smelly Sample":"/*\n * ConnectBot: simple, powerful, open-source SSH client for Android\n * Copyright 2007 Kenny Root, Jeffrey Sharkey\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.connectbot;\n\nimport java.lang.ref.WeakReference;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.connectbot.bean.HostBean;\nimport org.connectbot.service.BridgeDisconnectedListener;\nimport org.connectbot.service.PromptHelper;\nimport org.connectbot.service.TerminalBridge;\nimport org.connectbot.service.TerminalKeyListener;\nimport org.connectbot.service.TerminalManager;\nimport org.connectbot.util.PreferenceConstants;\nimport org.connectbot.util.TerminalViewPager;\n\nimport android.annotation.TargetApi;\nimport android.app.Dialog;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.ServiceConnection;\nimport android.content.SharedPreferences;\nimport android.content.pm.ActivityInfo;\nimport android.content.res.Configuration;\nimport android.media.AudioManager;\nimport android.net.Uri;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Message;\nimport android.preference.PreferenceManager;\nimport android.support.annotation.Nullable;\nimport android.support.design.widget.TabLayout;\nimport android.support.v4.app.ActivityCompat;\nimport android.support.v4.view.MenuItemCompat;\nimport android.support.v4.view.PagerAdapter;\nimport android.support.v7.app.ActionBar;\nimport android.support.v7.app.AppCompatActivity;\nimport android.support.v7.widget.Toolbar;\nimport android.text.ClipboardManager;\nimport android.util.Log;\nimport android.view.KeyEvent;\nimport android.view.LayoutInflater;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.MenuItem.OnMenuItemClickListener;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.view.View.OnClickListener;\nimport android.view.View.OnKeyListener;\nimport android.view.View.OnTouchListener;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.WindowManager;\nimport android.view.animation.Animation;\nimport android.view.animation.AnimationUtils;\nimport android.view.inputmethod.InputMethodManager;\nimport android.widget.AdapterView;\nimport android.widget.AdapterView.OnItemClickListener;\nimport android.widget.ArrayAdapter;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.HorizontalScrollView;\nimport android.widget.ImageView;\nimport android.widget.LinearLayout;\nimport android.widget.ListView;\nimport android.widget.RelativeLayout;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport de.mud.terminal.vt320;\n\npublic class ConsoleActivity extends AppCompatActivity implements BridgeDisconnectedListener {\n\tpublic final static String TAG = \"CB.ConsoleActivity\";\n\n\tprotected static final int REQUEST_EDIT = 1;\n\n\tprivate static final int KEYBOARD_DISPLAY_TIME = 3000;\n\tprivate static final int KEYBOARD_REPEAT_INITIAL = 500;\n\tprivate static final int KEYBOARD_REPEAT = 100;\n\tprivate static final String STATE_SELECTED_URI = \"selectedUri\";\n\n\tprotected TerminalViewPager pager = null;\n\tprotected TabLayout tabs = null;\n\tprotected Toolbar toolbar = null;\n\t@Nullable\n\tprotected TerminalManager bound = null;\n\tprotected TerminalPagerAdapter adapter = null;\n\tprotected LayoutInflater inflater = null;\n\n\tprivate SharedPreferences prefs = null;\n\n\t// determines whether or not menuitem accelerators are bound\n\t// otherwise they collide with an external keyboard's CTRL-char\n\tprivate boolean hardKeyboard = false;\n\n\tprotected Uri requested;\n\n\tprotected ClipboardManager clipboard;\n\tprivate RelativeLayout stringPromptGroup;\n\tprotected EditText stringPrompt;\n\tprivate TextView stringPromptInstructions;\n\n\tprivate RelativeLayout booleanPromptGroup;\n\tprivate TextView booleanPrompt;\n\tprivate Button booleanYes, booleanNo;\n\n\tprivate LinearLayout keyboardGroup;\n\tprivate Runnable keyboardGroupHider;\n\n\tprivate TextView empty;\n\n\tprivate Animation fade_out_delayed;\n\n\tprivate Animation keyboard_fade_in, keyboard_fade_out;\n\n\tprivate InputMethodManager inputManager;\n\n\tprivate MenuItem disconnect, copy, paste, portForward, resize, urlscan;\n\n\tprivate boolean forcedOrientation;\n\n\tprivate Handler handler = new Handler();\n\n\tprivate ImageView mKeyboardButton;\n\n\t@Nullable private ActionBar actionBar;\n\tprivate boolean inActionBarMenu = false;\n\tprivate boolean titleBarHide;\n\tprivate boolean keyboardAlwaysVisible = false;\n\n\tprivate ServiceConnection connection = new ServiceConnection() {\n\t\tpublic void onServiceConnected(ComponentName className, IBinder service) {\n\t\t\tbound = ((TerminalManager.TerminalBinder) service).getService();\n\n\t\t\t// let manager know about our event handling services\n\t\t\tbound.disconnectListener = ConsoleActivity.this;\n\t\t\tbound.setResizeAllowed(true);\n\n\t\t\tfinal String requestedNickname = (requested != null) ? requested.getFragment() : null;\n\t\t\tTerminalBridge requestedBridge = bound.getConnectedBridge(requestedNickname);\n\n\t\t\t// If we didn't find the requested connection, try opening it\n\t\t\tif (requestedNickname != null && requestedBridge == null) {\n\t\t\t\ttry {\n\t\t\t\t\tLog.d(TAG, String.format(\"We couldnt find an existing bridge with URI=%s (nickname=%s), so creating one now\", requested.toString(), requestedNickname));\n\t\t\t\t\trequestedBridge = bound.openConnection(requested);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tLog.e(TAG, \"Problem while trying to create new requested bridge from URI\", e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// create views for all bridges on this service\n\t\t\tadapter.notifyDataSetChanged();\n\t\t\tfinal int requestedIndex = bound.getBridges().indexOf(requestedBridge);\n\n\t\t\tif (requestedBridge != null)\n\t\t\t\trequestedBridge.promptHelper.setHandler(promptHandler);\n\n\n\t\t\tif (requestedIndex != -1) {\n\t\t\t\tpager.post(new Runnable() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\tsetDisplayedTerminal(requestedIndex);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tpublic void onServiceDisconnected(ComponentName className) {\n\t\t\tbound = null;\n\t\t\tadapter.notifyDataSetChanged();\n\t\t\tupdateEmptyVisible();\n\t\t}\n\t};\n\n\tprotected Handler promptHandler = new Handler() {\n\t\t@Override\n\t\tpublic void handleMessage(Message msg) {\n\t\t\t// someone below us requested to display a prompt\n\t\t\tupdatePromptVisible();\n\t\t}\n\t};\n\n\tpublic void onDisconnected(TerminalBridge bridge) {\n\t\tsynchronized (adapter) {\n\t\t\tadapter.notifyDataSetChanged();\n\t\t\tLog.d(TAG, \"Someone sending HANDLE_DISCONNECT to parentHandler\");\n\n\t\t\tif (bridge.isAwaitingClose()) {\n\t\t\t\tcloseBridge(bridge);\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected OnClickListener emulatedKeysListener = new OnClickListener() {\n\t\t@Override\n\t\tpublic void onClick(View v) {\n\t\t\tonEmulatedKeyClicked(v);\n\t\t}\n\t};\n\n\tprotected Handler keyRepeatHandler = new Handler();\n\n\n\t/**\n\t * Handle repeatable virtual keys and touch events\n\t */\n\tpublic class KeyRepeater implements Runnable, OnTouchListener, OnClickListener {\n\t\tprivate View mView;\n\t\tprivate Handler mHandler;\n\t\tprivate boolean mDown;\n\n\t\tpublic KeyRepeater(Handler handler, View view) {\n\t\t\tmView = view;\n\t\t\tmHandler = handler;\n\t\t\tmDown = false;\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tmDown = true;\n\t\t\tmHandler.removeCallbacks(this);\n\t\t\tmHandler.postDelayed(this, KEYBOARD_REPEAT);\n\t\t\tmView.performClick();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean onTouch(View v, MotionEvent event) {\n\t\t\tif (BuildConfig.DEBUG) {\n\t\t\t\tLog.d(TAG, \"KeyRepeater.onTouch(\" + v.getId() + \", \" +\n\t\t\t\t\t\tevent.getAction() + \", \" +\n\t\t\t\t\t\tevent.getActionIndex() + \", \" +\n\t\t\t\t\t\tevent.getActionMasked() + \");\");\n\t\t\t}\n\t\t\tswitch (event.getAction()) {\n\t\t\tcase MotionEvent.ACTION_DOWN:\n\t\t\t\tmDown = false;\n\t\t\t\tmHandler.postDelayed(this, KEYBOARD_REPEAT_INITIAL);\n\t\t\t\tmView.setPressed(true);\n\t\t\t\treturn (true);\n\n\t\t\tcase MotionEvent.ACTION_CANCEL:\n\t\t\t\tmHandler.removeCallbacks(this);\n\t\t\t\tmView.setPressed(false);\n\t\t\t\treturn (true);\n\n\t\t\tcase MotionEvent.ACTION_UP:\n\t\t\t\tmHandler.removeCallbacks(this);\n\t\t\t\tmView.setPressed(false);\n\n\t\t\t\tif (!mDown) {\n\t\t\t\t\tmView.performClick();\n\t\t\t\t}\n\t\t\t\treturn (true);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic void onClick(View view) {\n\t\t\tonEmulatedKeyClicked(view);\n\t\t}\n\t}\n\n\tprivate void onEmulatedKeyClicked(View v) {\n\t\tTerminalView terminal = adapter.getCurrentTerminalView();\n\t\tif (terminal == null) return;\n\n\t\tif (BuildConfig.DEBUG) {\n\t\t\tLog.d(TAG, \"onEmulatedKeyClicked(\" + v.getId() + \")\");\n\t\t}\n\t\tTerminalKeyListener handler = terminal.bridge.getKeyHandler();\n\t\tboolean hideKeys = false;\n\n\t\tswitch (v.getId()) {\n\t\tcase R.id.button_ctrl:\n\t\t\thandler.metaPress(TerminalKeyListener.OUR_CTRL_ON, true);\n\t\t\thideKeys = true;\n\t\t\tbreak;\n\t\tcase R.id.button_esc:\n\t\t\thandler.sendEscape();\n\t\t\thideKeys = true;\n\t\t\tbreak;\n\t\tcase R.id.button_tab:\n\t\t\thandler.sendTab();\n\t\t\thideKeys = true;\n\t\t\tbreak;\n\n\t\tcase R.id.button_up:\n\t\t\thandler.sendPressedKey(vt320.KEY_UP);\n\t\t\tbreak;\n\t\tcase R.id.button_down:\n\t\t\thandler.sendPressedKey(vt320.KEY_DOWN);\n\t\t\tbreak;\n\t\tcase R.id.button_left:\n\t\t\thandler.sendPressedKey(vt320.KEY_LEFT);\n\t\t\tbreak;\n\t\tcase R.id.button_right:\n\t\t\thandler.sendPressedKey(vt320.KEY_RIGHT);\n\t\t\tbreak;\n\n\t\tcase R.id.button_home:\n\t\t\thandler.sendPressedKey(vt320.KEY_HOME);\n\t\t\tbreak;\n\t\tcase R.id.button_end:\n\t\t\thandler.sendPressedKey(vt320.KEY_END);\n\t\t\tbreak;\n\t\tcase R.id.button_pgup:\n\t\t\thandler.sendPressedKey(vt320.KEY_PAGE_UP);\n\t\t\tbreak;\n\t\tcase R.id.button_pgdn:\n\t\t\thandler.sendPressedKey(vt320.KEY_PAGE_DOWN);\n\t\t\tbreak;\n\n\t\tcase R.id.button_f1:\n\t\t\thandler.sendPressedKey(vt320.KEY_F1);\n\t\t\tbreak;\n\t\tcase R.id.button_f2:\n\t\t\thandler.sendPressedKey(vt320.KEY_F2);\n\t\t\tbreak;\n\t\tcase R.id.button_f3:\n\t\t\thandler.sendPressedKey(vt320.KEY_F3);\n\t\t\tbreak;\n\t\tcase R.id.button_f4:\n\t\t\thandler.sendPressedKey(vt320.KEY_F4);\n\t\t\tbreak;\n\t\tcase R.id.button_f5:\n\t\t\thandler.sendPressedKey(vt320.KEY_F5);\n\t\t\tbreak;\n\t\tcase R.id.button_f6:\n\t\t\thandler.sendPressedKey(vt320.KEY_F6);\n\t\t\tbreak;\n\t\tcase R.id.button_f7:\n\t\t\thandler.sendPressedKey(vt320.KEY_F7);\n\t\t\tbreak;\n\t\tcase R.id.button_f8:\n\t\t\thandler.sendPressedKey(vt320.KEY_F8);\n\t\t\tbreak;\n\t\tcase R.id.button_f9:\n\t\t\thandler.sendPressedKey(vt320.KEY_F9);\n\t\t\tbreak;\n\t\tcase R.id.button_f10:\n\t\t\thandler.sendPressedKey(vt320.KEY_F10);\n\t\t\tbreak;\n\t\tcase R.id.button_f11:\n\t\t\thandler.sendPressedKey(vt320.KEY_F11);\n\t\t\tbreak;\n\t\tcase R.id.button_f12:\n\t\t\thandler.sendPressedKey(vt320.KEY_F12);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLog.e(TAG, \"Unknown emulated key clicked: \" + v.getId());\n\t\t\tbreak;\n\t\t}\n\n\t\tif (hideKeys)\n\t\t\thideEmulatedKeys();\n\t\telse\n\t\t\tautoHideEmulatedKeys();\n\n\t\tterminal.bridge.tryKeyVibrate();\n\t\thideActionBarIfRequested();\n\t}\n\n\tprivate void hideActionBarIfRequested() {\n\t\tif (titleBarHide && actionBar != null) {\n\t\t\tactionBar.hide();\n\t\t}\n\t}\n\n\t/**\n\t * @param bridge\n\t */\n\tprivate void closeBridge(final TerminalBridge bridge) {\n\t\tupdateEmptyVisible();\n\t\tupdatePromptVisible();\n\n\t\t// If we just closed the last bridge, go back to the previous activity.\n\t\tif (pager.getChildCount() == 0) {\n\t\t\tfinish();\n\t\t}\n\t}\n\n\tprotected View findCurrentView(int id) {\n\t\tView view = pager.findViewWithTag(adapter.getBridgeAtPosition(pager.getCurrentItem()));\n\t\tif (view == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn view.findViewById(id);\n\t}\n\n\tprotected PromptHelper getCurrentPromptHelper() {\n\t\tTerminalView view = adapter.getCurrentTerminalView();\n\t\tif (view == null) return null;\n\t\treturn view.bridge.promptHelper;\n\t}\n\n\tprotected void hideAllPrompts() {\n\t\tstringPromptGroup.setVisibility(View.GONE);\n\t\tbooleanPromptGroup.setVisibility(View.GONE);\n\t}\n\n\tprivate void showEmulatedKeys(boolean showActionBar) {\n\t\tif (keyboardGroup.getVisibility() == View.GONE) {\n\t\t\tkeyboardGroup.startAnimation(keyboard_fade_in);\n\t\t\tkeyboardGroup.setVisibility(View.VISIBLE);\n\t\t}\n\t\tif (showActionBar) {\n\t\t\tactionBar.show();\n\t\t}\n\t\tautoHideEmulatedKeys();\n\t}\n\n\tprivate void autoHideEmulatedKeys() {\n\t\tif (keyboardGroupHider != null)\n\t\t\thandler.removeCallbacks(keyboardGroupHider);\n\t\tkeyboardGroupHider = new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tif (keyboardGroup.getVisibility() == View.GONE || inActionBarMenu)\n\t\t\t\t\treturn;\n\n\t\t\t\tif (keyboardAlwaysVisible == false) {\n\t\t\t\t\tkeyboardGroup.startAnimation(keyboard_fade_out);\n\t\t\t\t\tkeyboardGroup.setVisibility(View.GONE);\n\t\t\t\t}\n\t\t\t\thideActionBarIfRequested();\n\t\t\t\tkeyboardGroupHider = null;\n\t\t\t}\n\t\t};\n\t\thandler.postDelayed(keyboardGroupHider, KEYBOARD_DISPLAY_TIME);\n\t}\n\n\tprivate void hideEmulatedKeys() {\n\t\tif (keyboardAlwaysVisible == false) {\n\t\t\tif (keyboardGroupHider != null)\n\t\t\t\thandler.removeCallbacks(keyboardGroupHider);\n\t\t\tkeyboardGroup.setVisibility(View.GONE);\n\t\t}\n\t\thideActionBarIfRequested();\n\t}\n\n\t@TargetApi(11)\n\tprivate void requestActionBar() {\n\t\tsupportRequestWindowFeature(Window.FEATURE_ACTION_BAR_OVERLAY);\n\t}\n\n\t@Override\n\tpublic void onCreate(Bundle icicle) {\n\t\tsuper.onCreate(icicle);\n\n\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD) {\n\t\t\tStrictModeSetup.run();\n\t\t}\n\n\t\thardKeyboard = getResources().getConfiguration().keyboard ==\n\t\t\t\tConfiguration.KEYBOARD_QWERTY;\n\n\t\tclipboard = (ClipboardManager) getSystemService(CLIPBOARD_SERVICE);\n\t\tprefs = PreferenceManager.getDefaultSharedPreferences(this);\n\n\t\ttitleBarHide = prefs.getBoolean(PreferenceConstants.TITLEBARHIDE, false);\n\t\tif (titleBarHide && Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {\n\t\t\t// This is a separate method because Gradle does not uniformly respect the conditional\n\t\t\t// Build check. See: https://code.google.com/p/android/issues/detail?id=137195\n\t\t\trequestActionBar();\n\t\t}\n\n\t\tthis.setContentView(R.layout.act_console);\n\n\t\t// hide status bar if requested by user\n\t\tif (prefs.getBoolean(PreferenceConstants.FULLSCREEN, false)) {\n\t\t\tgetWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,\n\t\t\t\t\tWindowManager.LayoutParams.FLAG_FULLSCREEN);\n\t\t}\n\n\t\t// TODO find proper way to disable volume key beep if it exists.\n\t\tsetVolumeControlStream(AudioManager.STREAM_MUSIC);\n\n\t\t// handle requested console from incoming intent\n\t\tif (icicle == null) {\n\t\t\trequested = getIntent().getData();\n\t\t} else {\n\t\t\tString uri = icicle.getString(STATE_SELECTED_URI);\n\t\t\tif (uri != null) {\n\t\t\t\trequested = Uri.parse(uri);\n\t\t\t}\n\t\t}\n\n\t\tinflater = LayoutInflater.from(this);\n\n\t\ttoolbar = (Toolbar) findViewById(R.id.toolbar);\n\n\t\tpager = (TerminalViewPager) findViewById(R.id.console_flip);\n\t\tpager.addOnPageChangeListener(\n\t\t\t\tnew TerminalViewPager.SimpleOnPageChangeListener() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onPageSelected(int position) {\n\t\t\t\t\t\tsetTitle(adapter.getPageTitle(position));\n\t\t\t\t\t\tonTerminalChanged();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\tadapter = new TerminalPagerAdapter();\n\t\tpager.setAdapter(adapter);\n\n\t\tempty = (TextView) findViewById(android.R.id.empty);\n\n\t\tstringPromptGroup = (RelativeLayout) findViewById(R.id.console_password_group);\n\t\tstringPromptInstructions = (TextView) findViewById(R.id.console_password_instructions);\n\t\tstringPrompt = (EditText) findViewById(R.id.console_password);\n\t\tstringPrompt.setOnKeyListener(new OnKeyListener() {\n\t\t\tpublic boolean onKey(View v, int keyCode, KeyEvent event) {\n\t\t\t\tif (event.getAction() == KeyEvent.ACTION_UP) return false;\n\t\t\t\tif (keyCode != KeyEvent.KEYCODE_ENTER) return false;\n\n\t\t\t\t// pass collected password down to current terminal\n\t\t\t\tString value = stringPrompt.getText().toString();\n\n\t\t\t\tPromptHelper helper = getCurrentPromptHelper();\n\t\t\t\tif (helper == null) return false;\n\t\t\t\thelper.setResponse(value);\n\n\t\t\t\t// finally clear password for next user\n\t\t\t\tstringPrompt.setText(\"\");\n\t\t\t\tupdatePromptVisible();\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\tbooleanPromptGroup = (RelativeLayout) findViewById(R.id.console_boolean_group);\n\t\tbooleanPrompt = (TextView) findViewById(R.id.console_prompt);\n\n\t\tbooleanYes = (Button) findViewById(R.id.console_prompt_yes);\n\t\tbooleanYes.setOnClickListener(new OnClickListener() {\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tPromptHelper helper = getCurrentPromptHelper();\n\t\t\t\tif (helper == null) return;\n\t\t\t\thelper.setResponse(Boolean.TRUE);\n\t\t\t\tupdatePromptVisible();\n\t\t\t}\n\t\t});\n\n\t\tbooleanNo = (Button) findViewById(R.id.console_prompt_no);\n\t\tbooleanNo.setOnClickListener(new OnClickListener() {\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tPromptHelper helper = getCurrentPromptHelper();\n\t\t\t\tif (helper == null) return;\n\t\t\t\thelper.setResponse(Boolean.FALSE);\n\t\t\t\tupdatePromptVisible();\n\t\t\t}\n\t\t});\n\n\t\tfade_out_delayed = AnimationUtils.loadAnimation(this, R.anim.fade_out_delayed);\n\n\t\t// Preload animation for keyboard button\n\t\tkeyboard_fade_in = AnimationUtils.loadAnimation(this, R.anim.keyboard_fade_in);\n\t\tkeyboard_fade_out = AnimationUtils.loadAnimation(this, R.anim.keyboard_fade_out);\n\n\t\tinputManager = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);\n\n\t\tkeyboardGroup = (LinearLayout) findViewById(R.id.keyboard_group);\n\n\t\tkeyboardAlwaysVisible = prefs.getBoolean(PreferenceConstants.KEY_ALWAYS_VISIVLE, false);\n\t\tif (keyboardAlwaysVisible) {\n\t\t\t// equivalent to android:layout_above=keyboard_group\n\t\t\tRelativeLayout.LayoutParams layoutParams = new RelativeLayout.LayoutParams(\n\t\t\t\t\tViewGroup.LayoutParams.MATCH_PARENT,\n\t\t\t\t\tViewGroup.LayoutParams.MATCH_PARENT);\n\t\t\tlayoutParams.addRule(RelativeLayout.ABOVE, R.id.keyboard_group);\n\t\t\tpager.setLayoutParams(layoutParams);\n\n\t\t\t// Show virtual keyboard\n\t\t\tkeyboardGroup.setVisibility(View.VISIBLE);\n\t\t}\n\n\t\tmKeyboardButton = (ImageView) findViewById(R.id.button_keyboard);\n\t\tmKeyboardButton.setOnClickListener(new OnClickListener() {\n\t\t\tpublic void onClick(View view) {\n\t\t\t\tView terminal = adapter.getCurrentTerminalView();\n\t\t\t\tif (terminal == null)\n\t\t\t\t\treturn;\n\n\t\t\t\tinputManager.showSoftInput(terminal, InputMethodManager.SHOW_FORCED);\n\t\t\t\thideEmulatedKeys();\n\t\t\t}\n\t\t});\n\n\t\tfindViewById(R.id.button_ctrl).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_esc).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_tab).setOnClickListener(emulatedKeysListener);\n\n\t\taddKeyRepeater(findViewById(R.id.button_up));\n\t\taddKeyRepeater(findViewById(R.id.button_up));\n\t\taddKeyRepeater(findViewById(R.id.button_down));\n\t\taddKeyRepeater(findViewById(R.id.button_left));\n\t\taddKeyRepeater(findViewById(R.id.button_right));\n\n\t\tfindViewById(R.id.button_home).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_end).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_pgup).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_pgdn).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f1).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f2).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f3).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f4).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f5).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f6).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f7).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f8).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f9).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f10).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f11).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f12).setOnClickListener(emulatedKeysListener);\n\n\n\t\tactionBar = getSupportActionBar();\n\t\tif (actionBar != null) {\n\t\t\tactionBar.setDisplayHomeAsUpEnabled(true);\n\t\t\tif (titleBarHide) {\n\t\t\t\tactionBar.hide();\n\t\t\t}\n\t\t\tactionBar.addOnMenuVisibilityListener(new ActionBar.OnMenuVisibilityListener() {\n\t\t\t\tpublic void onMenuVisibilityChanged(boolean isVisible) {\n\t\t\t\t\tinActionBarMenu = isVisible;\n\t\t\t\t\tif (isVisible == false) {\n\t\t\t\t\t\thideEmulatedKeys();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tfinal HorizontalScrollView keyboardScroll = (HorizontalScrollView) findViewById(R.id.keyboard_hscroll);\n\t\tif (!hardKeyboard) {\n\t\t\t// Show virtual keyboard and scroll back and forth\n\t\t\tshowEmulatedKeys(false);\n\t\t\tkeyboardScroll.postDelayed(new Runnable() {\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\tfinal int xscroll = findViewById(R.id.button_f12).getRight();\n\t\t\t\t\tif (BuildConfig.DEBUG) {\n\t\t\t\t\t\tLog.d(TAG, \"smoothScrollBy(toEnd[\" + xscroll + \"])\");\n\t\t\t\t\t}\n\t\t\t\t\tkeyboardScroll.smoothScrollBy(xscroll, 0);\n\t\t\t\t\tkeyboardScroll.postDelayed(new Runnable() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\tif (BuildConfig.DEBUG) {\n\t\t\t\t\t\t\t\tLog.d(TAG, \"smoothScrollBy(toStart[\" + (-xscroll) + \"])\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tkeyboardScroll.smoothScrollBy(-xscroll, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, 500);\n\t\t\t\t}\n\t\t\t}, 500);\n\t\t}\n\n\t\t// Reset keyboard auto-hide timer when scrolling\n\t\tkeyboardScroll.setOnTouchListener(\n\t\t\t\tnew OnTouchListener() {\n\t\t\t\t\tpublic boolean onTouch(View v, MotionEvent event) {\n\t\t\t\t\t\tswitch (event.getAction()) {\n\t\t\t\t\t\tcase MotionEvent.ACTION_MOVE:\n\t\t\t\t\t\t\tautoHideEmulatedKeys();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase MotionEvent.ACTION_UP:\n\t\t\t\t\t\t\tv.performClick();\n\t\t\t\t\t\t\treturn (true);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn (false);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\ttabs = (TabLayout) findViewById(R.id.tabs);\n\t\tif (tabs != null)\n\t\t\tsetupTabLayoutWithViewPager();\n\n\t\tpager.setOnClickListener(new OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tshowEmulatedKeys(true);\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate void addKeyRepeater(View view) {\n\t\tKeyRepeater keyRepeater = new KeyRepeater(keyRepeatHandler, view);\n\t\tview.setOnClickListener(keyRepeater);\n\t\tview.setOnTouchListener(keyRepeater);\n\t}\n\n\t/**\n\t * Ties the {@link TabLayout} to the {@link ViewPager}.\n\t *\n\t * <p>This method will:\n\t * <ul>\n\t *     <li>Add a {@link ViewPager.OnPageChangeListener} that will forward events to\n\t *     this TabLayout.<\/li>\n\t *     <li>Populate the TabLayout's tabs from the ViewPager's {@link PagerAdapter}.<\/li>\n\t *     <li>Set our {@link TabLayout.OnTabSelectedListener} which will forward\n\t *     selected events to the ViewPager<\/li>\n\t * <\/ul>\n\t * <\/p>\n\t */\n\tpublic void setupTabLayoutWithViewPager() {\n\t\ttabs.setTabsFromPagerAdapter(adapter);\n\t\tpager.addOnPageChangeListener(new TabLayout.TabLayoutOnPageChangeListener(tabs));\n\t\ttabs.setOnTabSelectedListener(new TabLayout.ViewPagerOnTabSelectedListener(pager));\n\n\t\tif (adapter.getCount() > 0) {\n\t\t\tfinal int curItem = pager.getCurrentItem();\n\t\t\tif (tabs.getSelectedTabPosition() != curItem) {\n\t\t\t\ttabs.getTabAt(curItem).select();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t *\n\t */\n\tprivate void configureOrientation() {\n\t\tString rotateDefault;\n\t\tif (getResources().getConfiguration().keyboard == Configuration.KEYBOARD_NOKEYS)\n\t\t\trotateDefault = PreferenceConstants.ROTATION_PORTRAIT;\n\t\telse\n\t\t\trotateDefault = PreferenceConstants.ROTATION_LANDSCAPE;\n\n\t\tString rotate = prefs.getString(PreferenceConstants.ROTATION, rotateDefault);\n\t\tif (PreferenceConstants.ROTATION_DEFAULT.equals(rotate))\n\t\t\trotate = rotateDefault;\n\n\t\t// request a forced orientation if requested by user\n\t\tif (PreferenceConstants.ROTATION_LANDSCAPE.equals(rotate)) {\n\t\t\tsetRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);\n\t\t\tforcedOrientation = true;\n\t\t} else if (PreferenceConstants.ROTATION_PORTRAIT.equals(rotate)) {\n\t\t\tsetRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);\n\t\t\tforcedOrientation = true;\n\t\t} else {\n\t\t\tsetRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);\n\t\t\tforcedOrientation = false;\n\t\t}\n\t}\n\n\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu) {\n\t\tsuper.onCreateOptionsMenu(menu);\n\n\t\tTerminalView view = adapter.getCurrentTerminalView();\n\t\tfinal boolean activeTerminal = view != null;\n\t\tboolean sessionOpen = false;\n\t\tboolean disconnected = false;\n\t\tboolean canForwardPorts = false;\n\n\t\tif (activeTerminal) {\n\t\t\tTerminalBridge bridge = view.bridge;\n\t\t\tsessionOpen = bridge.isSessionOpen();\n\t\t\tdisconnected = bridge.isDisconnected();\n\t\t\tcanForwardPorts = bridge.canFowardPorts();\n\t\t}\n\n\t\tmenu.setQwertyMode(true);\n\n\t\tdisconnect = menu.add(R.string.list_host_disconnect);\n\t\tif (hardKeyboard)\n\t\t\tdisconnect.setAlphabeticShortcut('w');\n\t\tif (!sessionOpen && disconnected)\n\t\t\tdisconnect.setTitle(R.string.console_menu_close);\n\t\tdisconnect.setEnabled(activeTerminal);\n\t\tdisconnect.setIcon(android.R.drawable.ic_menu_close_clear_cancel);\n\t\tdisconnect.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t// disconnect or close the currently visible session\n\t\t\t\tTerminalView terminalView = adapter.getCurrentTerminalView();\n\t\t\t\tTerminalBridge bridge = terminalView.bridge;\n\n\t\t\t\tbridge.dispatchDisconnect(true);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\tif (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB) {\n\t\t\tcopy = menu.add(R.string.console_menu_copy);\n\t\t\tif (hardKeyboard)\n\t\t\t\tcopy.setAlphabeticShortcut('c');\n\t\t\tMenuItemCompat.setShowAsAction(copy, MenuItemCompat.SHOW_AS_ACTION_IF_ROOM);\n\t\t\tcopy.setIcon(R.drawable.ic_action_copy);\n\t\t\tcopy.setEnabled(activeTerminal);\n\t\t\tcopy.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\tadapter.getCurrentTerminalView().startPreHoneycombCopyMode();\n\t\t\t\t\tToast.makeText(ConsoleActivity.this, getString(R.string.console_copy_start), Toast.LENGTH_LONG).show();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tpaste = menu.add(R.string.console_menu_paste);\n\t\tif (hardKeyboard)\n\t\t\tpaste.setAlphabeticShortcut('v');\n\t\tMenuItemCompat.setShowAsAction(paste, MenuItemCompat.SHOW_AS_ACTION_IF_ROOM);\n\t\tpaste.setIcon(R.drawable.ic_action_paste);\n\t\tpaste.setEnabled(activeTerminal);\n\t\tpaste.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tpasteIntoTerminal();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\tportForward = menu.add(R.string.console_menu_portforwards);\n\t\tif (hardKeyboard)\n\t\t\tportForward.setAlphabeticShortcut('f');\n\t\tportForward.setIcon(android.R.drawable.ic_menu_manage);\n\t\tportForward.setEnabled(sessionOpen && canForwardPorts);\n\t\tportForward.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tTerminalView terminalView = adapter.getCurrentTerminalView();\n\t\t\t\tTerminalBridge bridge = terminalView.bridge;\n\n\t\t\t\tIntent intent = new Intent(ConsoleActivity.this, PortForwardListActivity.class);\n\t\t\t\tintent.putExtra(Intent.EXTRA_TITLE, bridge.host.getId());\n\t\t\t\tConsoleActivity.this.startActivityForResult(intent, REQUEST_EDIT);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\turlscan = menu.add(R.string.console_menu_urlscan);\n\t\tif (hardKeyboard)\n\t\t\turlscan.setAlphabeticShortcut('u');\n\t\turlscan.setIcon(android.R.drawable.ic_menu_search);\n\t\turlscan.setEnabled(activeTerminal);\n\t\turlscan.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tfinal TerminalView terminalView = adapter.getCurrentTerminalView();\n\n\t\t\t\tList<String> urls = terminalView.bridge.scanForURLs();\n\n\t\t\t\tDialog urlDialog = new Dialog(ConsoleActivity.this);\n\t\t\t\turlDialog.setTitle(R.string.console_menu_urlscan);\n\n\t\t\t\tListView urlListView = new ListView(ConsoleActivity.this);\n\t\t\t\tURLItemListener urlListener = new URLItemListener(ConsoleActivity.this);\n\t\t\t\turlListView.setOnItemClickListener(urlListener);\n\n\t\t\t\turlListView.setAdapter(new ArrayAdapter<String>(ConsoleActivity.this, android.R.layout.simple_list_item_1, urls));\n\t\t\t\turlDialog.setContentView(urlListView);\n\t\t\t\turlDialog.show();\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\tresize = menu.add(R.string.console_menu_resize);\n\t\tif (hardKeyboard)\n\t\t\tresize.setAlphabeticShortcut('s');\n\t\tresize.setIcon(android.R.drawable.ic_menu_crop);\n\t\tresize.setEnabled(sessionOpen);\n\t\tresize.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tfinal TerminalView terminalView = adapter.getCurrentTerminalView();\n\n\t\t\t\tfinal View resizeView = inflater.inflate(R.layout.dia_resize, null, false);\n\t\t\t\tnew android.support.v7.app.AlertDialog.Builder(\n\t\t\t\t\t\t\t\tConsoleActivity.this, R.style.AlertDialogTheme)\n\t\t\t\t\t\t.setView(resizeView)\n\t\t\t\t\t\t.setPositiveButton(R.string.button_resize, new DialogInterface.OnClickListener() {\n\t\t\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\t\t\t\tint width, height;\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\twidth = Integer.parseInt(((EditText) resizeView\n\t\t\t\t\t\t\t\t\t\t\t.findViewById(R.id.width))\n\t\t\t\t\t\t\t\t\t\t\t.getText().toString());\n\t\t\t\t\t\t\t\t\theight = Integer.parseInt(((EditText) resizeView\n\t\t\t\t\t\t\t\t\t\t\t.findViewById(R.id.height))\n\t\t\t\t\t\t\t\t\t\t\t.getText().toString());\n\t\t\t\t\t\t\t\t} catch (NumberFormatException nfe) {\n\t\t\t\t\t\t\t\t\t// TODO change this to a real dialog where we can\n\t\t\t\t\t\t\t\t\t// make the input boxes turn red to indicate an error.\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tterminalView.forceSize(width, height);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}).setNegativeButton(android.R.string.cancel, null).create().show();\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean onPrepareOptionsMenu(Menu menu) {\n\t\tsuper.onPrepareOptionsMenu(menu);\n\n\t\tsetVolumeControlStream(AudioManager.STREAM_NOTIFICATION);\n\n\t\tfinal TerminalView view = adapter.getCurrentTerminalView();\n\t\tboolean activeTerminal = view != null;\n\t\tboolean sessionOpen = false;\n\t\tboolean disconnected = false;\n\t\tboolean canForwardPorts = false;\n\n\t\tif (activeTerminal) {\n\t\t\tTerminalBridge bridge = view.bridge;\n\t\t\tsessionOpen = bridge.isSessionOpen();\n\t\t\tdisconnected = bridge.isDisconnected();\n\t\t\tcanForwardPorts = bridge.canFowardPorts();\n\t\t}\n\n\t\tdisconnect.setEnabled(activeTerminal);\n\t\tif (sessionOpen || !disconnected)\n\t\t\tdisconnect.setTitle(R.string.list_host_disconnect);\n\t\telse\n\t\t\tdisconnect.setTitle(R.string.console_menu_close);\n\n\t\tif (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB) {\n\t\t\tcopy.setEnabled(activeTerminal);\n\t\t}\n\t\tpaste.setEnabled(activeTerminal);\n\t\tportForward.setEnabled(sessionOpen && canForwardPorts);\n\t\turlscan.setEnabled(activeTerminal);\n\t\tresize.setEnabled(sessionOpen);\n\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tswitch (item.getItemId()) {\n\t\tcase android.R.id.home:\n\t\t\tIntent intent = new Intent(this, HostListActivity.class);\n\t\t\tintent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n\t\t\tstartActivity(intent);\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn super.onOptionsItemSelected(item);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void onOptionsMenuClosed(Menu menu) {\n\t\tsuper.onOptionsMenuClosed(menu);\n\n\t\tsetVolumeControlStream(AudioManager.STREAM_MUSIC);\n\t}\n\n\t@Override\n\tpublic void onStart() {\n\t\tsuper.onStart();\n\n\t\t// connect with manager service to find all bridges\n\t\t// when connected it will insert all views\n\t\tbindService(new Intent(this, TerminalManager.class), connection, Context.BIND_AUTO_CREATE);\n\t}\n\n\t@Override\n\tpublic void onPause() {\n\t\tsuper.onPause();\n\t\tLog.d(TAG, \"onPause called\");\n\n\t\tif (forcedOrientation && bound != null) {\n\t\t\tbound.setResizeAllowed(false);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void onResume() {\n\t\tsuper.onResume();\n\t\tLog.d(TAG, \"onResume called\");\n\n\t\t// Make sure we don't let the screen fall asleep.\n\t\t// This also keeps the Wi-Fi chipset from disconnecting us.\n\t\tif (prefs.getBoolean(PreferenceConstants.KEEP_ALIVE, true)) {\n\t\t\tgetWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);\n\t\t} else {\n\t\t\tgetWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);\n\t\t}\n\n\t\tconfigureOrientation();\n\n\t\tif (forcedOrientation && bound != null) {\n\t\t\tbound.setResizeAllowed(true);\n\t\t}\n\t}\n\n\t/* (non-Javadoc)\n\t * @see android.app.Activity#onNewIntent(android.content.Intent)\n\t */\n\t@Override\n\tprotected void onNewIntent(Intent intent) {\n\t\tsuper.onNewIntent(intent);\n\n\t\tLog.d(TAG, \"onNewIntent called\");\n\n\t\trequested = intent.getData();\n\n\t\tif (requested == null) {\n\t\t\tLog.e(TAG, \"Got null intent data in onNewIntent()\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (bound == null) {\n\t\t\tLog.e(TAG, \"We're not bound in onNewIntent()\");\n\t\t\treturn;\n\t\t}\n\n\t\tTerminalBridge requestedBridge = bound.getConnectedBridge(requested.getFragment());\n\t\tint requestedIndex = 0;\n\n\t\tsynchronized (pager) {\n\t\t\tif (requestedBridge == null) {\n\t\t\t\t// If we didn't find the requested connection, try opening it\n\n\t\t\t\ttry {\n\t\t\t\t\tLog.d(TAG, String.format(\"We couldnt find an existing bridge with URI=%s (nickname=%s),\" +\n\t\t\t\t\t\t\t\"so creating one now\", requested.toString(), requested.getFragment()));\n\t\t\t\t\tbound.openConnection(requested);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tLog.e(TAG, \"Problem while trying to create new requested bridge from URI\", e);\n\t\t\t\t\t// TODO: We should display an error dialog here.\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tadapter.notifyDataSetChanged();\n\t\t\t\trequestedIndex = adapter.getCount();\n\t\t\t} else {\n\t\t\t\tfinal int flipIndex = bound.getBridges().indexOf(requestedBridge);\n\t\t\t\tif (flipIndex > requestedIndex) {\n\t\t\t\t\trequestedIndex = flipIndex;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsetDisplayedTerminal(requestedIndex);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void onStop() {\n\t\tsuper.onStop();\n\n\t\tunbindService(connection);\n\t}\n\n\t@Override\n\tpublic void onSaveInstanceState(Bundle savedInstanceState) {\n\t\t// Maintain selected host if connected.\n\t\tif (adapter.getCurrentTerminalView() != null\n\t\t\t\t&& !adapter.getCurrentTerminalView().bridge.isDisconnected()) {\n\t\t\trequested = adapter.getCurrentTerminalView().bridge.host.getUri();\n\t\t\tsavedInstanceState.putString(STATE_SELECTED_URI, requested.toString());\n\t\t}\n\n\t\tsuper.onSaveInstanceState(savedInstanceState);\n\t}\n\n\t/**\n\t * Save the currently shown {@link TerminalView} as the default. This is\n\t * saved back down into {@link TerminalManager} where we can read it again\n\t * later.\n\t */\n\tprivate void updateDefault() {\n\t\t// update the current default terminal\n\t\tTerminalView view = adapter.getCurrentTerminalView();\n\t\tif (view == null || bound == null) {\n\t\t\treturn;\n\t\t}\n\t\tbound.defaultBridge = view.bridge;\n\t}\n\n\tprotected void updateEmptyVisible() {\n\t\t// update visibility of empty status message\n\t\tempty.setVisibility((pager.getChildCount() == 0) ? View.VISIBLE : View.GONE);\n\t}\n\n\t/**\n\t * Show any prompts requested by the currently visible {@link TerminalView}.\n\t */\n\tprotected void updatePromptVisible() {\n\t\t// check if our currently-visible terminalbridge is requesting any prompt services\n\t\tTerminalView view = adapter.getCurrentTerminalView();\n\n\t\t// Hide all the prompts in case a prompt request was canceled\n\t\thideAllPrompts();\n\n\t\tif (view == null) {\n\t\t\t// we dont have an active view, so hide any prompts\n\t\t\treturn;\n\t\t}\n\n\t\tPromptHelper prompt = view.bridge.promptHelper;\n\t\tif (String.class.equals(prompt.promptRequested)) {\n\t\t\tstringPromptGroup.setVisibility(View.VISIBLE);\n\n\t\t\tString instructions = prompt.promptInstructions;\n\t\t\tif (instructions != null && instructions.length() > 0) {\n\t\t\t\tstringPromptInstructions.setVisibility(View.VISIBLE);\n\t\t\t\tstringPromptInstructions.setText(instructions);\n\t\t\t} else\n\t\t\t\tstringPromptInstructions.setVisibility(View.GONE);\n\t\t\tstringPrompt.setText(\"\");\n\t\t\tstringPrompt.setHint(prompt.promptHint);\n\t\t\tstringPrompt.requestFocus();\n\n\t\t} else if (Boolean.class.equals(prompt.promptRequested)) {\n\t\t\tbooleanPromptGroup.setVisibility(View.VISIBLE);\n\t\t\tbooleanPrompt.setText(prompt.promptHint);\n\t\t\tbooleanYes.requestFocus();\n\n\t\t} else {\n\t\t\thideAllPrompts();\n\t\t\tview.requestFocus();\n\t\t}\n\t}\n\n\tprivate class URLItemListener implements OnItemClickListener {\n\t\tprivate WeakReference<Context> contextRef;\n\n\t\tURLItemListener(Context context) {\n\t\t\tthis.contextRef = new WeakReference<Context>(context);\n\t\t}\n\n\t\tpublic void onItemClick(AdapterView<?> arg0, View view, int position, long id) {\n\t\t\tContext context = contextRef.get();\n\n\t\t\tif (context == null)\n\t\t\t\treturn;\n\n\t\t\ttry {\n\t\t\t\tTextView urlView = (TextView) view;\n\n\t\t\t\tString url = urlView.getText().toString();\n\t\t\t\tif (url.indexOf(\"://\") < 0)\n\t\t\t\t\turl = \"http://\" + url;\n\n\t\t\t\tIntent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));\n\t\t\t\tcontext.startActivity(intent);\n\t\t\t} catch (Exception e) {\n\t\t\t\tLog.e(TAG, \"couldn't open URL\", e);\n\t\t\t\t// We should probably tell the user that we couldn't find a handler...\n\t\t\t}\n\t\t}\n\n\t}\n\n\t@Override\n\tpublic void onConfigurationChanged(Configuration newConfig) {\n\t\tsuper.onConfigurationChanged(newConfig);\n\n\t\tLog.d(TAG, String.format(\"onConfigurationChanged; requestedOrientation=%d, newConfig.orientation=%d\", getRequestedOrientation(), newConfig.orientation));\n\t\tif (bound != null) {\n\t\t\tif (forcedOrientation &&\n\t\t\t\t\t(newConfig.orientation != Configuration.ORIENTATION_LANDSCAPE &&\n\t\t\t\t\t\t\tgetRequestedOrientation() == ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE) ||\n\t\t\t\t\t(newConfig.orientation != Configuration.ORIENTATION_PORTRAIT &&\n\t\t\t\t\t\t\tgetRequestedOrientation() == ActivityInfo.SCREEN_ORIENTATION_PORTRAIT))\n\t\t\t\tbound.setResizeAllowed(false);\n\t\t\telse\n\t\t\t\tbound.setResizeAllowed(true);\n\n\t\t\tbound.hardKeyboardHidden = (newConfig.hardKeyboardHidden == Configuration.HARDKEYBOARDHIDDEN_YES);\n\n\t\t\tmKeyboardButton.setVisibility(bound.hardKeyboardHidden ? View.VISIBLE : View.GONE);\n\t\t}\n\t}\n\n\t/**\n\t * Called whenever the displayed terminal is changed.\n\t */\n\tprivate void onTerminalChanged() {\n\t\tView terminalNameOverlay = findCurrentView(R.id.terminal_name_overlay);\n\t\tif (terminalNameOverlay != null)\n\t\t\tterminalNameOverlay.startAnimation(fade_out_delayed);\n\t\tupdateDefault();\n\t\tupdatePromptVisible();\n\t\tActivityCompat.invalidateOptionsMenu(ConsoleActivity.this);\n\t}\n\n\t/**\n\t * Displays the child in the ViewPager at the requestedIndex and updates the prompts.\n\t *\n\t * @param requestedIndex the index of the terminal view to display\n\t */\n\tprivate void setDisplayedTerminal(int requestedIndex) {\n\t\tpager.setCurrentItem(requestedIndex);\n\t\t// set activity title\n\t\tsetTitle(adapter.getPageTitle(requestedIndex));\n\t\tonTerminalChanged();\n\t}\n\n\tprivate void pasteIntoTerminal() {\n\t\t// force insert of clipboard text into current console\n\t\tTerminalView terminalView = adapter.getCurrentTerminalView();\n\t\tTerminalBridge bridge = terminalView.bridge;\n\n\t\t// pull string from clipboard and generate all events to force down\n\t\tString clip = \"\";\n\t\tif (clipboard.hasText()) {\n\t\t\tclip = clipboard.getText().toString();\n\t\t}\n\t\tbridge.injectString(clip);\n\t}\n\n\tpublic class TerminalPagerAdapter extends PagerAdapter {\n\t\t@Override\n\t\tpublic int getCount() {\n\t\t\tif (bound != null) {\n\t\t\t\treturn bound.getBridges().size();\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Object instantiateItem(ViewGroup container, int position) {\n\t\t\tif (bound == null || bound.getBridges().size() <= position) {\n\t\t\t\tLog.w(TAG, \"Activity not bound when creating TerminalView.\");\n\t\t\t}\n\t\t\tTerminalBridge bridge = bound.getBridges().get(position);\n\t\t\tbridge.promptHelper.setHandler(promptHandler);\n\n\t\t\t// inflate each terminal view\n\t\t\tRelativeLayout view = (RelativeLayout) inflater.inflate(\n\t\t\t\t\tR.layout.item_terminal, container, false);\n\n\t\t\t// set the terminal name overlay text\n\t\t\tTextView terminalNameOverlay = (TextView) view.findViewById(R.id.terminal_name_overlay);\n\t\t\tterminalNameOverlay.setText(bridge.host.getNickname());\n\n\t\t\t// and add our terminal view control, using index to place behind overlay\n\t\t\tfinal TerminalView terminal = new TerminalView(container.getContext(), bridge, pager);\n\t\t\tterminal.setId(R.id.terminal_view);\n\t\t\tview.addView(terminal, 0);\n\n\t\t\t// Tag the view with its bridge so it can be retrieved later.\n\t\t\tview.setTag(bridge);\n\n\t\t\tcontainer.addView(view);\n\t\t\tterminalNameOverlay.startAnimation(fade_out_delayed);\n\t\t\treturn view;\n\t\t}\n\n\t\t@Override\n\t\tpublic void destroyItem(ViewGroup container, int position, Object object) {\n\t\t\tfinal View view = (View) object;\n\n\t\t\tcontainer.removeView(view);\n\t\t}\n\n\t\t@Override\n\t\tpublic int getItemPosition(Object object) {\n\t\t\tif (bound == null) {\n\t\t\t\treturn POSITION_NONE;\n\t\t\t}\n\n\t\t\tView view = (View) object;\n\t\t\tTerminalView terminal = (TerminalView) view.findViewById(R.id.terminal_view);\n\t\t\tHostBean host = terminal.bridge.host;\n\n\t\t\tint itemIndex = POSITION_NONE;\n\t\t\tint i = 0;\n\t\t\tfor (TerminalBridge bridge : bound.getBridges()) {\n\t\t\t\tif (bridge.host.equals(host)) {\n\t\t\t\t\titemIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t\treturn itemIndex;\n\t\t}\n\n\t\tpublic TerminalBridge getBridgeAtPosition(int position) {\n\t\t\tif (bound == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tArrayList<TerminalBridge> bridges = bound.getBridges();\n\t\t\tif (position < 0 || position >= bridges.size()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn bridges.get(position);\n\t\t}\n\n\t\t@Override\n\t\tpublic void notifyDataSetChanged() {\n\t\t\tsuper.notifyDataSetChanged();\n\t\t\tif (tabs != null) {\n\t\t\t\ttoolbar.setVisibility(this.getCount() > 1 ? View.VISIBLE : View.GONE);\n\t\t\t\ttabs.setTabsFromPagerAdapter(this);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isViewFromObject(View view, Object object) {\n\t\t\treturn view == object;\n\t\t}\n\n\t\t@Override\n\t\tpublic CharSequence getPageTitle(int position) {\n\t\t\tTerminalBridge bridge = getBridgeAtPosition(position);\n\t\t\tif (bridge == null) {\n\t\t\t\treturn \"???\";\n\t\t\t}\n\t\t\treturn bridge.host.getNickname();\n\t\t}\n\n\t\tpublic TerminalView getCurrentTerminalView() {\n\t\t\tView currentView = pager.findViewWithTag(getBridgeAtPosition(pager.getCurrentItem()));\n\t\t\tif (currentView == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn (TerminalView) currentView.findViewById(R.id.terminal_view);\n\t\t}\n\t}\n}\n","Method after Refactoring":"/*\n * ConnectBot: simple, powerful, open-source SSH client for Android\n * Copyright 2007 Kenny Root, Jeffrey Sharkey\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.connectbot;\n\nimport java.lang.ref.WeakReference;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.connectbot.bean.HostBean;\nimport org.connectbot.service.BridgeDisconnectedListener;\nimport org.connectbot.service.PromptHelper;\nimport org.connectbot.service.TerminalBridge;\nimport org.connectbot.service.TerminalKeyListener;\nimport org.connectbot.service.TerminalManager;\nimport org.connectbot.util.PreferenceConstants;\nimport org.connectbot.util.TerminalViewPager;\n\nimport android.annotation.TargetApi;\nimport android.app.Dialog;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.ServiceConnection;\nimport android.content.SharedPreferences;\nimport android.content.pm.ActivityInfo;\nimport android.content.res.Configuration;\nimport android.media.AudioManager;\nimport android.net.Uri;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Message;\nimport android.preference.PreferenceManager;\nimport android.support.annotation.Nullable;\nimport android.support.design.widget.TabLayout;\nimport android.support.v4.app.ActivityCompat;\nimport android.support.v4.view.MenuItemCompat;\nimport android.support.v4.view.PagerAdapter;\nimport android.support.v7.app.ActionBar;\nimport android.support.v7.app.AppCompatActivity;\nimport android.support.v7.widget.Toolbar;\nimport android.text.ClipboardManager;\nimport android.util.Log;\nimport android.view.KeyEvent;\nimport android.view.LayoutInflater;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.MenuItem.OnMenuItemClickListener;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.view.View.OnClickListener;\nimport android.view.View.OnKeyListener;\nimport android.view.View.OnTouchListener;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.WindowManager;\nimport android.view.animation.Animation;\nimport android.view.animation.AnimationUtils;\nimport android.view.inputmethod.InputMethodManager;\nimport android.widget.AdapterView;\nimport android.widget.AdapterView.OnItemClickListener;\nimport android.widget.ArrayAdapter;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.HorizontalScrollView;\nimport android.widget.ImageView;\nimport android.widget.LinearLayout;\nimport android.widget.ListView;\nimport android.widget.RelativeLayout;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport de.mud.terminal.vt320;\n\npublic class ConsoleActivity extends AppCompatActivity implements BridgeDisconnectedListener {\n\tpublic final static String TAG = \"CB.ConsoleActivity\";\n\n\tprotected static final int REQUEST_EDIT = 1;\n\n\tprivate static final int KEYBOARD_DISPLAY_TIME = 3000;\n\tprivate static final int KEYBOARD_REPEAT_INITIAL = 500;\n\tprivate static final int KEYBOARD_REPEAT = 100;\n\tprivate static final String STATE_SELECTED_URI = \"selectedUri\";\n\n\tprotected TerminalViewPager pager = null;\n\tprotected TabLayout tabs = null;\n\tprotected Toolbar toolbar = null;\n\t@Nullable\n\tprotected TerminalManager bound = null;\n\tprotected TerminalPagerAdapter adapter = null;\n\tprotected LayoutInflater inflater = null;\n\n\tprivate SharedPreferences prefs = null;\n\n\t// determines whether or not menuitem accelerators are bound\n\t// otherwise they collide with an external keyboard's CTRL-char\n\tprivate boolean hardKeyboard = false;\n\n\tprotected Uri requested;\n\n\tprotected ClipboardManager clipboard;\n\tprivate RelativeLayout stringPromptGroup;\n\tprotected EditText stringPrompt;\n\tprivate TextView stringPromptInstructions;\n\n\tprivate RelativeLayout booleanPromptGroup;\n\tprivate TextView booleanPrompt;\n\tprivate Button booleanYes, booleanNo;\n\n\tprivate LinearLayout keyboardGroup;\n\tprivate Runnable keyboardGroupHider;\n\n\tprivate TextView empty;\n\n\tprivate Animation fade_out_delayed;\n\n\tprivate Animation keyboard_fade_in, keyboard_fade_out;\n\n\tprivate InputMethodManager inputManager;\n\n\tprivate MenuItem disconnect, copy, paste, portForward, resize, urlscan;\n\n\tprivate boolean forcedOrientation;\n\n\tprivate Handler handler = new Handler();\n\n\tprivate ImageView mKeyboardButton;\n\n\t@Nullable private ActionBar actionBar;\n\tprivate boolean inActionBarMenu = false;\n\tprivate boolean titleBarHide;\n\tprivate boolean keyboardAlwaysVisible = false;\n\n\tprivate ServiceConnection connection = new ServiceConnection() {\n\t\tpublic void onServiceConnected(ComponentName className, IBinder service) {\n\t\t\tbound = ((TerminalManager.TerminalBinder) service).getService();\n\n\t\t\t// let manager know about our event handling services\n\t\t\tbound.disconnectListener = ConsoleActivity.this;\n\t\t\tbound.setResizeAllowed(true);\n\n\t\t\tfinal String requestedNickname = (requested != null) ? requested.getFragment() : null;\n\t\t\tTerminalBridge requestedBridge = bound.getConnectedBridge(requestedNickname);\n\n\t\t\t// If we didn't find the requested connection, try opening it\n\t\t\tif (requestedNickname != null && requestedBridge == null) {\n\t\t\t\ttry {\n\t\t\t\t\tLog.d(TAG, String.format(\"We couldnt find an existing bridge with URI=%s (nickname=%s), so creating one now\", requested.toString(), requestedNickname));\n\t\t\t\t\trequestedBridge = bound.openConnection(requested);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tLog.e(TAG, \"Problem while trying to create new requested bridge from URI\", e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// create views for all bridges on this service\n\t\t\tadapter.notifyDataSetChanged();\n\t\t\tfinal int requestedIndex = bound.getBridges().indexOf(requestedBridge);\n\n\t\t\tif (requestedBridge != null)\n\t\t\t\trequestedBridge.promptHelper.setHandler(promptHandler);\n\n\n\t\t\tif (requestedIndex != -1) {\n\t\t\t\tpager.post(new Runnable() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\tsetDisplayedTerminal(requestedIndex);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tpublic void onServiceDisconnected(ComponentName className) {\n\t\t\tbound = null;\n\t\t\tadapter.notifyDataSetChanged();\n\t\t\tupdateEmptyVisible();\n\t\t}\n\t};\n\n\tprotected Handler promptHandler = new Handler() {\n\t\t@Override\n\t\tpublic void handleMessage(Message msg) {\n\t\t\t// someone below us requested to display a prompt\n\t\t\tupdatePromptVisible();\n\t\t}\n\t};\n\n\tpublic void onDisconnected(TerminalBridge bridge) {\n\t\tsynchronized (adapter) {\n\t\t\tadapter.notifyDataSetChanged();\n\t\t\tLog.d(TAG, \"Someone sending HANDLE_DISCONNECT to parentHandler\");\n\n\t\t\tif (bridge.isAwaitingClose()) {\n\t\t\t\tcloseBridge(bridge);\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected OnClickListener emulatedKeysListener = new OnClickListener() {\n\t\t@Override\n\t\tpublic void onClick(View v) {\n\t\t\tonEmulatedKeyClicked(v);\n\t\t}\n\t};\n\n\tprotected Handler keyRepeatHandler = new Handler();\n\n\n\t/**\n\t * Handle repeatable virtual keys and touch events\n\t */\n\tpublic class KeyRepeater implements Runnable, OnTouchListener, OnClickListener {\n\t\tprivate View mView;\n\t\tprivate Handler mHandler;\n\t\tprivate boolean mDown;\n\n\t\tpublic KeyRepeater(Handler handler, View view) {\n\t\t\tmView = view;\n\t\t\tmHandler = handler;\n\t\t\tmDown = false;\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tmDown = true;\n\t\t\tmHandler.removeCallbacks(this);\n\t\t\tmHandler.postDelayed(this, KEYBOARD_REPEAT);\n\t\t\tmView.performClick();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean onTouch(View v, MotionEvent event) {\n\t\t\tif (BuildConfig.DEBUG) {\n\t\t\t\tLog.d(TAG, \"KeyRepeater.onTouch(\" + v.getId() + \", \" +\n\t\t\t\t\t\tevent.getAction() + \", \" +\n\t\t\t\t\t\tevent.getActionIndex() + \", \" +\n\t\t\t\t\t\tevent.getActionMasked() + \");\");\n\t\t\t}\n\t\t\tswitch (event.getAction()) {\n\t\t\tcase MotionEvent.ACTION_DOWN:\n\t\t\t\tmDown = false;\n\t\t\t\tmHandler.postDelayed(this, KEYBOARD_REPEAT_INITIAL);\n\t\t\t\tmView.setPressed(true);\n\t\t\t\treturn (true);\n\n\t\t\tcase MotionEvent.ACTION_CANCEL:\n\t\t\t\tmHandler.removeCallbacks(this);\n\t\t\t\tmView.setPressed(false);\n\t\t\t\treturn (true);\n\n\t\t\tcase MotionEvent.ACTION_UP:\n\t\t\t\tmHandler.removeCallbacks(this);\n\t\t\t\tmView.setPressed(false);\n\n\t\t\t\tif (!mDown) {\n\t\t\t\t\tmView.performClick();\n\t\t\t\t}\n\t\t\t\treturn (true);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic void onClick(View view) {\n\t\t\tonEmulatedKeyClicked(view);\n\t\t}\n\t}\n\n\tprivate void onEmulatedKeyClicked(View v) {\n\t\tTerminalView terminal = adapter.getCurrentTerminalView();\n\t\tif (terminal == null) return;\n\n\t\tif (BuildConfig.DEBUG) {\n\t\t\tLog.d(TAG, \"onEmulatedKeyClicked(\" + v.getId() + \")\");\n\t\t}\n\t\tTerminalKeyListener handler = terminal.bridge.getKeyHandler();\n\t\tboolean hideKeys = false;\n\n\t\tswitch (v.getId()) {\n\t\tcase R.id.button_ctrl:\n\t\t\thandler.metaPress(TerminalKeyListener.OUR_CTRL_ON, true);\n\t\t\thideKeys = true;\n\t\t\tbreak;\n\t\tcase R.id.button_esc:\n\t\t\thandler.sendEscape();\n\t\t\thideKeys = true;\n\t\t\tbreak;\n\t\tcase R.id.button_tab:\n\t\t\thandler.sendTab();\n\t\t\thideKeys = true;\n\t\t\tbreak;\n\n\t\tcase R.id.button_up:\n\t\t\thandler.sendPressedKey(vt320.KEY_UP);\n\t\t\tbreak;\n\t\tcase R.id.button_down:\n\t\t\thandler.sendPressedKey(vt320.KEY_DOWN);\n\t\t\tbreak;\n\t\tcase R.id.button_left:\n\t\t\thandler.sendPressedKey(vt320.KEY_LEFT);\n\t\t\tbreak;\n\t\tcase R.id.button_right:\n\t\t\thandler.sendPressedKey(vt320.KEY_RIGHT);\n\t\t\tbreak;\n\n\t\tcase R.id.button_home:\n\t\t\thandler.sendPressedKey(vt320.KEY_HOME);\n\t\t\tbreak;\n\t\tcase R.id.button_end:\n\t\t\thandler.sendPressedKey(vt320.KEY_END);\n\t\t\tbreak;\n\t\tcase R.id.button_pgup:\n\t\t\thandler.sendPressedKey(vt320.KEY_PAGE_UP);\n\t\t\tbreak;\n\t\tcase R.id.button_pgdn:\n\t\t\thandler.sendPressedKey(vt320.KEY_PAGE_DOWN);\n\t\t\tbreak;\n\n\t\tcase R.id.button_f1:\n\t\t\thandler.sendPressedKey(vt320.KEY_F1);\n\t\t\tbreak;\n\t\tcase R.id.button_f2:\n\t\t\thandler.sendPressedKey(vt320.KEY_F2);\n\t\t\tbreak;\n\t\tcase R.id.button_f3:\n\t\t\thandler.sendPressedKey(vt320.KEY_F3);\n\t\t\tbreak;\n\t\tcase R.id.button_f4:\n\t\t\thandler.sendPressedKey(vt320.KEY_F4);\n\t\t\tbreak;\n\t\tcase R.id.button_f5:\n\t\t\thandler.sendPressedKey(vt320.KEY_F5);\n\t\t\tbreak;\n\t\tcase R.id.button_f6:\n\t\t\thandler.sendPressedKey(vt320.KEY_F6);\n\t\t\tbreak;\n\t\tcase R.id.button_f7:\n\t\t\thandler.sendPressedKey(vt320.KEY_F7);\n\t\t\tbreak;\n\t\tcase R.id.button_f8:\n\t\t\thandler.sendPressedKey(vt320.KEY_F8);\n\t\t\tbreak;\n\t\tcase R.id.button_f9:\n\t\t\thandler.sendPressedKey(vt320.KEY_F9);\n\t\t\tbreak;\n\t\tcase R.id.button_f10:\n\t\t\thandler.sendPressedKey(vt320.KEY_F10);\n\t\t\tbreak;\n\t\tcase R.id.button_f11:\n\t\t\thandler.sendPressedKey(vt320.KEY_F11);\n\t\t\tbreak;\n\t\tcase R.id.button_f12:\n\t\t\thandler.sendPressedKey(vt320.KEY_F12);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tLog.e(TAG, \"Unknown emulated key clicked: \" + v.getId());\n\t\t\tbreak;\n\t\t}\n\n\t\tif (hideKeys)\n\t\t\thideEmulatedKeys();\n\t\telse\n\t\t\tautoHideEmulatedKeys();\n\n\t\tterminal.bridge.tryKeyVibrate();\n\t\thideActionBarIfRequested();\n\t}\n\n\tprivate void hideActionBarIfRequested() {\n\t\tif (titleBarHide && actionBar != null) {\n\t\t\tactionBar.hide();\n\t\t}\n\t}\n\n\t/**\n\t * @param bridge\n\t */\n\tprivate void closeBridge(final TerminalBridge bridge) {\n\t\tupdateEmptyVisible();\n\t\tupdatePromptVisible();\n\n\t\t// If we just closed the last bridge, go back to the previous activity.\n\t\tif (pager.getChildCount() == 0) {\n\t\t\tfinish();\n\t\t}\n\t}\n\n\tprotected View findCurrentView(int id) {\n\t\tView view = pager.findViewWithTag(adapter.getBridgeAtPosition(pager.getCurrentItem()));\n\t\tif (view == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn view.findViewById(id);\n\t}\n\n\tprotected PromptHelper getCurrentPromptHelper() {\n\t\tTerminalView view = adapter.getCurrentTerminalView();\n\t\tif (view == null) return null;\n\t\treturn view.bridge.promptHelper;\n\t}\n\n\tprotected void hideAllPrompts() {\n\t\tstringPromptGroup.setVisibility(View.GONE);\n\t\tbooleanPromptGroup.setVisibility(View.GONE);\n\t}\n\n\tprivate void showEmulatedKeys(boolean showActionBar) {\n\t\tif (keyboardGroup.getVisibility() == View.GONE) {\n\t\t\tkeyboardGroup.startAnimation(keyboard_fade_in);\n\t\t\tkeyboardGroup.setVisibility(View.VISIBLE);\n\t\t}\n\t\tif (showActionBar) {\n\t\t\tactionBar.show();\n\t\t}\n\t\tautoHideEmulatedKeys();\n\t}\n\n\tprivate void autoHideEmulatedKeys() {\n\t\tif (keyboardGroupHider != null)\n\t\t\thandler.removeCallbacks(keyboardGroupHider);\n\t\tkeyboardGroupHider = new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tif (keyboardGroup.getVisibility() == View.GONE || inActionBarMenu)\n\t\t\t\t\treturn;\n\n\t\t\t\tif (keyboardAlwaysVisible == false) {\n\t\t\t\t\tkeyboardGroup.startAnimation(keyboard_fade_out);\n\t\t\t\t\tkeyboardGroup.setVisibility(View.GONE);\n\t\t\t\t}\n\t\t\t\thideActionBarIfRequested();\n\t\t\t\tkeyboardGroupHider = null;\n\t\t\t}\n\t\t};\n\t\thandler.postDelayed(keyboardGroupHider, KEYBOARD_DISPLAY_TIME);\n\t}\n\n\tprivate void hideEmulatedKeys() {\n\t\tif (keyboardAlwaysVisible == false) {\n\t\t\tif (keyboardGroupHider != null)\n\t\t\t\thandler.removeCallbacks(keyboardGroupHider);\n\t\t\tkeyboardGroup.setVisibility(View.GONE);\n\t\t}\n\t\thideActionBarIfRequested();\n\t}\n\n\t@TargetApi(11)\n\tprivate void requestActionBar() {\n\t\tsupportRequestWindowFeature(Window.FEATURE_ACTION_BAR_OVERLAY);\n\t}\n\n\t@Override\n\tpublic void onCreate(Bundle icicle) {\n\t\tsuper.onCreate(icicle);\n\n\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD) {\n\t\t\tStrictModeSetup.run();\n\t\t}\n\n\t\thardKeyboard = getResources().getConfiguration().keyboard ==\n\t\t\t\tConfiguration.KEYBOARD_QWERTY;\n\n\t\tclipboard = (ClipboardManager) getSystemService(CLIPBOARD_SERVICE);\n\t\tprefs = PreferenceManager.getDefaultSharedPreferences(this);\n\n\t\ttitleBarHide = prefs.getBoolean(PreferenceConstants.TITLEBARHIDE, false);\n\t\tif (titleBarHide && Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {\n\t\t\t// This is a separate method because Gradle does not uniformly respect the conditional\n\t\t\t// Build check. See: https://code.google.com/p/android/issues/detail?id=137195\n\t\t\trequestActionBar();\n\t\t}\n\n\t\tthis.setContentView(R.layout.act_console);\n\n\t\t// hide status bar if requested by user\n\t\tif (prefs.getBoolean(PreferenceConstants.FULLSCREEN, false)) {\n\t\t\tgetWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,\n\t\t\t\t\tWindowManager.LayoutParams.FLAG_FULLSCREEN);\n\t\t}\n\n\t\t// TODO find proper way to disable volume key beep if it exists.\n\t\tsetVolumeControlStream(AudioManager.STREAM_MUSIC);\n\n\t\t// handle requested console from incoming intent\n\t\tif (icicle == null) {\n\t\t\trequested = getIntent().getData();\n\t\t} else {\n\t\t\tString uri = icicle.getString(STATE_SELECTED_URI);\n\t\t\tif (uri != null) {\n\t\t\t\trequested = Uri.parse(uri);\n\t\t\t}\n\t\t}\n\n\t\tinflater = LayoutInflater.from(this);\n\n\t\ttoolbar = (Toolbar) findViewById(R.id.toolbar);\n\n\t\tpager = (TerminalViewPager) findViewById(R.id.console_flip);\n\t\tpager.addOnPageChangeListener(\n\t\t\t\tnew TerminalViewPager.SimpleOnPageChangeListener() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onPageSelected(int position) {\n\t\t\t\t\t\tsetTitle(adapter.getPageTitle(position));\n\t\t\t\t\t\tonTerminalChanged();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\tadapter = new TerminalPagerAdapter();\n\t\tpager.setAdapter(adapter);\n\n\t\tempty = (TextView) findViewById(android.R.id.empty);\n\n\t\tstringPromptGroup = (RelativeLayout) findViewById(R.id.console_password_group);\n\t\tstringPromptInstructions = (TextView) findViewById(R.id.console_password_instructions);\n\t\tstringPrompt = (EditText) findViewById(R.id.console_password);\n\t\tstringPrompt.setOnKeyListener(new OnKeyListener() {\n\t\t\tpublic boolean onKey(View v, int keyCode, KeyEvent event) {\n\t\t\t\tif (event.getAction() == KeyEvent.ACTION_UP) return false;\n\t\t\t\tif (keyCode != KeyEvent.KEYCODE_ENTER) return false;\n\n\t\t\t\t// pass collected password down to current terminal\n\t\t\t\tString value = stringPrompt.getText().toString();\n\n\t\t\t\tPromptHelper helper = getCurrentPromptHelper();\n\t\t\t\tif (helper == null) return false;\n\t\t\t\thelper.setResponse(value);\n\n\t\t\t\t// finally clear password for next user\n\t\t\t\tstringPrompt.setText(\"\");\n\t\t\t\tupdatePromptVisible();\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\tbooleanPromptGroup = (RelativeLayout) findViewById(R.id.console_boolean_group);\n\t\tbooleanPrompt = (TextView) findViewById(R.id.console_prompt);\n\n\t\tbooleanYes = (Button) findViewById(R.id.console_prompt_yes);\n\t\tbooleanYes.setOnClickListener(new OnClickListener() {\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tPromptHelper helper = getCurrentPromptHelper();\n\t\t\t\tif (helper == null) return;\n\t\t\t\thelper.setResponse(Boolean.TRUE);\n\t\t\t\tupdatePromptVisible();\n\t\t\t}\n\t\t});\n\n\t\tbooleanNo = (Button) findViewById(R.id.console_prompt_no);\n\t\tbooleanNo.setOnClickListener(new OnClickListener() {\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tPromptHelper helper = getCurrentPromptHelper();\n\t\t\t\tif (helper == null) return;\n\t\t\t\thelper.setResponse(Boolean.FALSE);\n\t\t\t\tupdatePromptVisible();\n\t\t\t}\n\t\t});\n\n\t\tfade_out_delayed = AnimationUtils.loadAnimation(this, R.anim.fade_out_delayed);\n\n\t\t// Preload animation for keyboard button\n\t\tkeyboard_fade_in = AnimationUtils.loadAnimation(this, R.anim.keyboard_fade_in);\n\t\tkeyboard_fade_out = AnimationUtils.loadAnimation(this, R.anim.keyboard_fade_out);\n\n\t\tinputManager = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);\n\n\t\tkeyboardGroup = (LinearLayout) findViewById(R.id.keyboard_group);\n\n\t\tkeyboardAlwaysVisible = prefs.getBoolean(PreferenceConstants.KEY_ALWAYS_VISIVLE, false);\n\t\tif (keyboardAlwaysVisible) {\n\t\t\t// equivalent to android:layout_above=keyboard_group\n\t\t\tRelativeLayout.LayoutParams layoutParams = new RelativeLayout.LayoutParams(\n\t\t\t\t\tViewGroup.LayoutParams.MATCH_PARENT,\n\t\t\t\t\tViewGroup.LayoutParams.MATCH_PARENT);\n\t\t\tlayoutParams.addRule(RelativeLayout.ABOVE, R.id.keyboard_group);\n\t\t\tpager.setLayoutParams(layoutParams);\n\n\t\t\t// Show virtual keyboard\n\t\t\tkeyboardGroup.setVisibility(View.VISIBLE);\n\t\t}\n\n\t\tmKeyboardButton = (ImageView) findViewById(R.id.button_keyboard);\n\t\tmKeyboardButton.setOnClickListener(new OnClickListener() {\n\t\t\tpublic void onClick(View view) {\n\t\t\t\tView terminal = adapter.getCurrentTerminalView();\n\t\t\t\tif (terminal == null)\n\t\t\t\t\treturn;\n\n\t\t\t\tinputManager.showSoftInput(terminal, InputMethodManager.SHOW_FORCED);\n\t\t\t\thideEmulatedKeys();\n\t\t\t}\n\t\t});\n\n\t\tfindViewById(R.id.button_ctrl).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_esc).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_tab).setOnClickListener(emulatedKeysListener);\n\n\t\taddKeyRepeater(findViewById(R.id.button_up));\n\t\taddKeyRepeater(findViewById(R.id.button_up));\n\t\taddKeyRepeater(findViewById(R.id.button_down));\n\t\taddKeyRepeater(findViewById(R.id.button_left));\n\t\taddKeyRepeater(findViewById(R.id.button_right));\n\n\t\tfindViewById(R.id.button_home).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_end).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_pgup).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_pgdn).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f1).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f2).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f3).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f4).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f5).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f6).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f7).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f8).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f9).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f10).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f11).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f12).setOnClickListener(emulatedKeysListener);\n\n\n\t\tactionBar = getSupportActionBar();\n\t\tif (actionBar != null) {\n\t\t\tactionBar.setDisplayHomeAsUpEnabled(true);\n\t\t\tif (titleBarHide) {\n\t\t\t\tactionBar.hide();\n\t\t\t}\n\t\t\tactionBar.addOnMenuVisibilityListener(new ActionBar.OnMenuVisibilityListener() {\n\t\t\t\tpublic void onMenuVisibilityChanged(boolean isVisible) {\n\t\t\t\t\tinActionBarMenu = isVisible;\n\t\t\t\t\tif (isVisible == false) {\n\t\t\t\t\t\thideEmulatedKeys();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tfinal HorizontalScrollView keyboardScroll = (HorizontalScrollView) findViewById(R.id.keyboard_hscroll);\n\t\tif (!hardKeyboard) {\n\t\t\t// Show virtual keyboard and scroll back and forth\n\t\t\tshowEmulatedKeys(false);\n\t\t\tkeyboardScroll.postDelayed(new Runnable() {\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\tfinal int xscroll = findViewById(R.id.button_f12).getRight();\n\t\t\t\t\tif (BuildConfig.DEBUG) {\n\t\t\t\t\t\tLog.d(TAG, \"smoothScrollBy(toEnd[\" + xscroll + \"])\");\n\t\t\t\t\t}\n\t\t\t\t\tkeyboardScroll.smoothScrollBy(xscroll, 0);\n\t\t\t\t\tkeyboardScroll.postDelayed(new Runnable() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\tif (BuildConfig.DEBUG) {\n\t\t\t\t\t\t\t\tLog.d(TAG, \"smoothScrollBy(toStart[\" + (-xscroll) + \"])\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tkeyboardScroll.smoothScrollBy(-xscroll, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, 500);\n\t\t\t\t}\n\t\t\t}, 500);\n\t\t}\n\n\t\t// Reset keyboard auto-hide timer when scrolling\n\t\tkeyboardScroll.setOnTouchListener(\n\t\t\t\tnew OnTouchListener() {\n\t\t\t\t\tpublic boolean onTouch(View v, MotionEvent event) {\n\t\t\t\t\t\tswitch (event.getAction()) {\n\t\t\t\t\t\tcase MotionEvent.ACTION_MOVE:\n\t\t\t\t\t\t\tautoHideEmulatedKeys();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase MotionEvent.ACTION_UP:\n\t\t\t\t\t\t\tv.performClick();\n\t\t\t\t\t\t\treturn (true);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn (false);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\ttabs = (TabLayout) findViewById(R.id.tabs);\n\t\tif (tabs != null)\n\t\t\tsetupTabLayoutWithViewPager();\n\n\t\tpager.setOnClickListener(new OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tshowEmulatedKeys(true);\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate void addKeyRepeater(View view) {\n\t\tKeyRepeater keyRepeater = new KeyRepeater(keyRepeatHandler, view);\n\t\tview.setOnClickListener(keyRepeater);\n\t\tview.setOnTouchListener(keyRepeater);\n\t}\n\n\t/**\n\t * Ties the {@link TabLayout} to the {@link ViewPager}.\n\t *\n\t * <p>This method will:\n\t * <ul>\n\t *     <li>Add a {@link ViewPager.OnPageChangeListener} that will forward events to\n\t *     this TabLayout.<\/li>\n\t *     <li>Populate the TabLayout's tabs from the ViewPager's {@link PagerAdapter}.<\/li>\n\t *     <li>Set our {@link TabLayout.OnTabSelectedListener} which will forward\n\t *     selected events to the ViewPager<\/li>\n\t * <\/ul>\n\t * <\/p>\n\t */\n\tpublic void setupTabLayoutWithViewPager() {\n\t\ttabs.setTabsFromPagerAdapter(adapter);\n\t\tpager.addOnPageChangeListener(new TabLayout.TabLayoutOnPageChangeListener(tabs));\n\t\ttabs.setOnTabSelectedListener(new TabLayout.ViewPagerOnTabSelectedListener(pager));\n\n\t\tif (adapter.getCount() > 0) {\n\t\t\tfinal int curItem = pager.getCurrentItem();\n\t\t\tif (tabs.getSelectedTabPosition() != curItem) {\n\t\t\t\ttabs.getTabAt(curItem).select();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t *\n\t */\n\tprivate void configureOrientation() {\n\t\tString rotateDefault;\n\t\tif (getResources().getConfiguration().keyboard == Configuration.KEYBOARD_NOKEYS)\n\t\t\trotateDefault = PreferenceConstants.ROTATION_PORTRAIT;\n\t\telse\n\t\t\trotateDefault = PreferenceConstants.ROTATION_LANDSCAPE;\n\n\t\tString rotate = prefs.getString(PreferenceConstants.ROTATION, rotateDefault);\n\t\tif (PreferenceConstants.ROTATION_DEFAULT.equals(rotate))\n\t\t\trotate = rotateDefault;\n\n\t\t// request a forced orientation if requested by user\n\t\tif (PreferenceConstants.ROTATION_LANDSCAPE.equals(rotate)) {\n\t\t\tsetRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);\n\t\t\tforcedOrientation = true;\n\t\t} else if (PreferenceConstants.ROTATION_PORTRAIT.equals(rotate)) {\n\t\t\tsetRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);\n\t\t\tforcedOrientation = true;\n\t\t} else {\n\t\t\tsetRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);\n\t\t\tforcedOrientation = false;\n\t\t}\n\t}\n\n\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu) {\n\t\tsuper.onCreateOptionsMenu(menu);\n\n\t\tTerminalView view = adapter.getCurrentTerminalView();\n\t\tfinal boolean activeTerminal = view != null;\n\t\tboolean sessionOpen = false;\n\t\tboolean disconnected = false;\n\t\tboolean canForwardPorts = false;\n\n\t\tif (activeTerminal) {\n\t\t\tTerminalBridge bridge = view.bridge;\n\t\t\tsessionOpen = bridge.isSessionOpen();\n\t\t\tdisconnected = bridge.isDisconnected();\n\t\t\tcanForwardPorts = bridge.canFowardPorts();\n\t\t}\n\n\t\tmenu.setQwertyMode(true);\n\n\t\tdisconnect = menu.add(R.string.list_host_disconnect);\n\t\tif (hardKeyboard)\n\t\t\tdisconnect.setAlphabeticShortcut('w');\n\t\tif (!sessionOpen && disconnected)\n\t\t\tdisconnect.setTitle(R.string.console_menu_close);\n\t\tdisconnect.setEnabled(activeTerminal);\n\t\tdisconnect.setIcon(android.R.drawable.ic_menu_close_clear_cancel);\n\t\tdisconnect.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t// disconnect or close the currently visible session\n\t\t\t\tTerminalView terminalView = adapter.getCurrentTerminalView();\n\t\t\t\tTerminalBridge bridge = terminalView.bridge;\n\n\t\t\t\tbridge.dispatchDisconnect(true);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\tif (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB) {\n\t\t\tcopy = menu.add(R.string.console_menu_copy);\n\t\t\tif (hardKeyboard)\n\t\t\t\tcopy.setAlphabeticShortcut('c');\n\t\t\tMenuItemCompat.setShowAsAction(copy, MenuItemCompat.SHOW_AS_ACTION_IF_ROOM);\n\t\t\tcopy.setIcon(R.drawable.ic_action_copy);\n\t\t\tcopy.setEnabled(activeTerminal);\n\t\t\tcopy.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\tadapter.getCurrentTerminalView().startPreHoneycombCopyMode();\n\t\t\t\t\tToast.makeText(ConsoleActivity.this, getString(R.string.console_copy_start), Toast.LENGTH_LONG).show();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tpaste = menu.add(R.string.console_menu_paste);\n\t\tif (hardKeyboard)\n\t\t\tpaste.setAlphabeticShortcut('v');\n\t\tMenuItemCompat.setShowAsAction(paste, MenuItemCompat.SHOW_AS_ACTION_IF_ROOM);\n\t\tpaste.setIcon(R.drawable.ic_action_paste);\n\t\tpaste.setEnabled(activeTerminal);\n\t\tpaste.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tpasteIntoTerminal();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\tportForward = menu.add(R.string.console_menu_portforwards);\n\t\tif (hardKeyboard)\n\t\t\tportForward.setAlphabeticShortcut('f');\n\t\tportForward.setIcon(android.R.drawable.ic_menu_manage);\n\t\tportForward.setEnabled(sessionOpen && canForwardPorts);\n\t\tportForward.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tTerminalView terminalView = adapter.getCurrentTerminalView();\n\t\t\t\tTerminalBridge bridge = terminalView.bridge;\n\n\t\t\t\tIntent intent = new Intent(ConsoleActivity.this, PortForwardListActivity.class);\n\t\t\t\tintent.putExtra(Intent.EXTRA_TITLE, bridge.host.getId());\n\t\t\t\tConsoleActivity.this.startActivityForResult(intent, REQUEST_EDIT);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\turlscan = menu.add(R.string.console_menu_urlscan);\n\t\tif (hardKeyboard)\n\t\t\turlscan.setAlphabeticShortcut('u');\n\t\turlscan.setIcon(android.R.drawable.ic_menu_search);\n\t\turlscan.setEnabled(activeTerminal);\n\t\turlscan.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tfinal TerminalView terminalView = adapter.getCurrentTerminalView();\n\n\t\t\t\tList<String> urls = terminalView.bridge.scanForURLs();\n\n\t\t\t\tDialog urlDialog = new Dialog(ConsoleActivity.this);\n\t\t\t\turlDialog.setTitle(R.string.console_menu_urlscan);\n\n\t\t\t\tListView urlListView = new ListView(ConsoleActivity.this);\n\t\t\t\tURLItemListener urlListener = new URLItemListener(ConsoleActivity.this);\n\t\t\t\turlListView.setOnItemClickListener(urlListener);\n\n\t\t\t\turlListView.setAdapter(new ArrayAdapter<String>(ConsoleActivity.this, android.R.layout.simple_list_item_1, urls));\n\t\t\t\turlDialog.setContentView(urlListView);\n\t\t\t\turlDialog.show();\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\tresize = menu.add(R.string.console_menu_resize);\n\t\tif (hardKeyboard)\n\t\t\tresize.setAlphabeticShortcut('s');\n\t\tresize.setIcon(android.R.drawable.ic_menu_crop);\n\t\tresize.setEnabled(sessionOpen);\n\t\tresize.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tfinal TerminalView terminalView = adapter.getCurrentTerminalView();\n\n\t\t\t\tfinal View resizeView = inflater.inflate(R.layout.dia_resize, null, false);\n\t\t\t\tnew android.support.v7.app.AlertDialog.Builder(\n\t\t\t\t\t\t\t\tConsoleActivity.this, R.style.AlertDialogTheme)\n\t\t\t\t\t\t.setView(resizeView)\n\t\t\t\t\t\t.setPositiveButton(R.string.button_resize, new DialogInterface.OnClickListener() {\n\t\t\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\t\t\t\tint width, height;\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\twidth = Integer.parseInt(((EditText) resizeView\n\t\t\t\t\t\t\t\t\t\t\t.findViewById(R.id.width))\n\t\t\t\t\t\t\t\t\t\t\t.getText().toString());\n\t\t\t\t\t\t\t\t\theight = Integer.parseInt(((EditText) resizeView\n\t\t\t\t\t\t\t\t\t\t\t.findViewById(R.id.height))\n\t\t\t\t\t\t\t\t\t\t\t.getText().toString());\n\t\t\t\t\t\t\t\t} catch (NumberFormatException nfe) {\n\t\t\t\t\t\t\t\t\t// TODO change this to a real dialog where we can\n\t\t\t\t\t\t\t\t\t// make the input boxes turn red to indicate an error.\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tterminalView.forceSize(width, height);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}).setNegativeButton(android.R.string.cancel, null).create().show();\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean onPrepareOptionsMenu(Menu menu) {\n\t\tsuper.onPrepareOptionsMenu(menu);\n\n\t\tsetVolumeControlStream(AudioManager.STREAM_NOTIFICATION);\n\n\t\tfinal TerminalView view = adapter.getCurrentTerminalView();\n\t\tboolean activeTerminal = view != null;\n\t\tboolean sessionOpen = false;\n\t\tboolean disconnected = false;\n\t\tboolean canForwardPorts = false;\n\n\t\tif (activeTerminal) {\n\t\t\tTerminalBridge bridge = view.bridge;\n\t\t\tsessionOpen = bridge.isSessionOpen();\n\t\t\tdisconnected = bridge.isDisconnected();\n\t\t\tcanForwardPorts = bridge.canFowardPorts();\n\t\t}\n\n\t\tdisconnect.setEnabled(activeTerminal);\n\t\tif (sessionOpen || !disconnected)\n\t\t\tdisconnect.setTitle(R.string.list_host_disconnect);\n\t\telse\n\t\t\tdisconnect.setTitle(R.string.console_menu_close);\n\n\t\tif (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB) {\n\t\t\tcopy.setEnabled(activeTerminal);\n\t\t}\n\t\tpaste.setEnabled(activeTerminal);\n\t\tportForward.setEnabled(sessionOpen && canForwardPorts);\n\t\turlscan.setEnabled(activeTerminal);\n\t\tresize.setEnabled(sessionOpen);\n\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tswitch (item.getItemId()) {\n\t\tcase android.R.id.home:\n\t\t\tIntent intent = new Intent(this, HostListActivity.class);\n\t\t\tintent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n\t\t\tstartActivity(intent);\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn super.onOptionsItemSelected(item);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void onOptionsMenuClosed(Menu menu) {\n\t\tsuper.onOptionsMenuClosed(menu);\n\n\t\tsetVolumeControlStream(AudioManager.STREAM_MUSIC);\n\t}\n\n\t@Override\n\tpublic void onStart() {\n\t\tsuper.onStart();\n\n\t\t// connect with manager service to find all bridges\n\t\t// when connected it will insert all views\n\t\tbindService(new Intent(this, TerminalManager.class), connection, Context.BIND_AUTO_CREATE);\n\t}\n\n\t@Override\n\tpublic void onPause() {\n\t\tsuper.onPause();\n\t\tLog.d(TAG, \"onPause called\");\n\n\t\tif (forcedOrientation && bound != null) {\n\t\t\tbound.setResizeAllowed(false);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void onResume() {\n\t\tsuper.onResume();\n\t\tLog.d(TAG, \"onResume called\");\n\n\t\t// Make sure we don't let the screen fall asleep.\n\t\t// This also keeps the Wi-Fi chipset from disconnecting us.\n\t\tif (prefs.getBoolean(PreferenceConstants.KEEP_ALIVE, true)) {\n\t\t\tgetWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);\n\t\t} else {\n\t\t\tgetWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);\n\t\t}\n\n\t\tconfigureOrientation();\n\n\t\tif (forcedOrientation && bound != null) {\n\t\t\tbound.setResizeAllowed(true);\n\t\t}\n\t}\n\n\t/* (non-Javadoc)\n\t * @see android.app.Activity#onNewIntent(android.content.Intent)\n\t */\n\t@Override\n\tprotected void onNewIntent(Intent intent) {\n\t\tsuper.onNewIntent(intent);\n\n\t\tLog.d(TAG, \"onNewIntent called\");\n\n\t\trequested = intent.getData();\n\n\t\tif (requested == null) {\n\t\t\tLog.e(TAG, \"Got null intent data in onNewIntent()\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (bound == null) {\n\t\t\tLog.e(TAG, \"We're not bound in onNewIntent()\");\n\t\t\treturn;\n\t\t}\n\n\t\tTerminalBridge requestedBridge = bound.getConnectedBridge(requested.getFragment());\n\t\tint requestedIndex = 0;\n\n\t\tsynchronized (pager) {\n\t\t\tif (requestedBridge == null) {\n\t\t\t\t// If we didn't find the requested connection, try opening it\n\n\t\t\t\ttry {\n\t\t\t\t\tLog.d(TAG, String.format(\"We couldnt find an existing bridge with URI=%s (nickname=%s),\" +\n\t\t\t\t\t\t\t\"so creating one now\", requested.toString(), requested.getFragment()));\n\t\t\t\t\tbound.openConnection(requested);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tLog.e(TAG, \"Problem while trying to create new requested bridge from URI\", e);\n\t\t\t\t\t// TODO: We should display an error dialog here.\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tadapter.notifyDataSetChanged();\n\t\t\t\trequestedIndex = adapter.getCount();\n\t\t\t} else {\n\t\t\t\tfinal int flipIndex = bound.getBridges().indexOf(requestedBridge);\n\t\t\t\tif (flipIndex > requestedIndex) {\n\t\t\t\t\trequestedIndex = flipIndex;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsetDisplayedTerminal(requestedIndex);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void onStop() {\n\t\tsuper.onStop();\n\n\t\tunbindService(connection);\n\t}\n\n\t@Override\n\tpublic void onSaveInstanceState(Bundle savedInstanceState) {\n\t\t// Maintain selected host if connected.\n\t\tTerminalView currentTerminalView = adapter.getCurrentTerminalView();\n\t\tif (currentTerminalView != null\n\t\t\t\t&& !currentTerminalView.bridge.isDisconnected()) {\n\t\t\trequested = currentTerminalView.bridge.host.getUri();\n\t\t\tsavedInstanceState.putString(STATE_SELECTED_URI, requested.toString());\n\t\t}\n\n\t\tsuper.onSaveInstanceState(savedInstanceState);\n\t}\n\n\t/**\n\t * Save the currently shown {@link TerminalView} as the default. This is\n\t * saved back down into {@link TerminalManager} where we can read it again\n\t * later.\n\t */\n\tprivate void updateDefault() {\n\t\t// update the current default terminal\n\t\tTerminalView view = adapter.getCurrentTerminalView();\n\t\tif (view == null || bound == null) {\n\t\t\treturn;\n\t\t}\n\t\tbound.defaultBridge = view.bridge;\n\t}\n\n\tprotected void updateEmptyVisible() {\n\t\t// update visibility of empty status message\n\t\tempty.setVisibility((pager.getChildCount() == 0) ? View.VISIBLE : View.GONE);\n\t}\n\n\t/**\n\t * Show any prompts requested by the currently visible {@link TerminalView}.\n\t */\n\tprotected void updatePromptVisible() {\n\t\t// check if our currently-visible terminalbridge is requesting any prompt services\n\t\tTerminalView view = adapter.getCurrentTerminalView();\n\n\t\t// Hide all the prompts in case a prompt request was canceled\n\t\thideAllPrompts();\n\n\t\tif (view == null) {\n\t\t\t// we dont have an active view, so hide any prompts\n\t\t\treturn;\n\t\t}\n\n\t\tPromptHelper prompt = view.bridge.promptHelper;\n\t\tif (String.class.equals(prompt.promptRequested)) {\n\t\t\tstringPromptGroup.setVisibility(View.VISIBLE);\n\n\t\t\tString instructions = prompt.promptInstructions;\n\t\t\tif (instructions != null && instructions.length() > 0) {\n\t\t\t\tstringPromptInstructions.setVisibility(View.VISIBLE);\n\t\t\t\tstringPromptInstructions.setText(instructions);\n\t\t\t} else\n\t\t\t\tstringPromptInstructions.setVisibility(View.GONE);\n\t\t\tstringPrompt.setText(\"\");\n\t\t\tstringPrompt.setHint(prompt.promptHint);\n\t\t\tstringPrompt.requestFocus();\n\n\t\t} else if (Boolean.class.equals(prompt.promptRequested)) {\n\t\t\tbooleanPromptGroup.setVisibility(View.VISIBLE);\n\t\t\tbooleanPrompt.setText(prompt.promptHint);\n\t\t\tbooleanYes.requestFocus();\n\n\t\t} else {\n\t\t\thideAllPrompts();\n\t\t\tview.requestFocus();\n\t\t}\n\t}\n\n\tprivate class URLItemListener implements OnItemClickListener {\n\t\tprivate WeakReference<Context> contextRef;\n\n\t\tURLItemListener(Context context) {\n\t\t\tthis.contextRef = new WeakReference<Context>(context);\n\t\t}\n\n\t\tpublic void onItemClick(AdapterView<?> arg0, View view, int position, long id) {\n\t\t\tContext context = contextRef.get();\n\n\t\t\tif (context == null)\n\t\t\t\treturn;\n\n\t\t\ttry {\n\t\t\t\tTextView urlView = (TextView) view;\n\n\t\t\t\tString url = urlView.getText().toString();\n\t\t\t\tif (url.indexOf(\"://\") < 0)\n\t\t\t\t\turl = \"http://\" + url;\n\n\t\t\t\tIntent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));\n\t\t\t\tcontext.startActivity(intent);\n\t\t\t} catch (Exception e) {\n\t\t\t\tLog.e(TAG, \"couldn't open URL\", e);\n\t\t\t\t// We should probably tell the user that we couldn't find a handler...\n\t\t\t}\n\t\t}\n\n\t}\n\n\t@Override\n\tpublic void onConfigurationChanged(Configuration newConfig) {\n\t\tsuper.onConfigurationChanged(newConfig);\n\n\t\tLog.d(TAG, String.format(\"onConfigurationChanged; requestedOrientation=%d, newConfig.orientation=%d\", getRequestedOrientation(), newConfig.orientation));\n\t\tif (bound != null) {\n\t\t\tif (forcedOrientation &&\n\t\t\t\t\t(newConfig.orientation != Configuration.ORIENTATION_LANDSCAPE &&\n\t\t\t\t\t\t\tgetRequestedOrientation() == ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE) ||\n\t\t\t\t\t(newConfig.orientation != Configuration.ORIENTATION_PORTRAIT &&\n\t\t\t\t\t\t\tgetRequestedOrientation() == ActivityInfo.SCREEN_ORIENTATION_PORTRAIT))\n\t\t\t\tbound.setResizeAllowed(false);\n\t\t\telse\n\t\t\t\tbound.setResizeAllowed(true);\n\n\t\t\tbound.hardKeyboardHidden = (newConfig.hardKeyboardHidden == Configuration.HARDKEYBOARDHIDDEN_YES);\n\n\t\t\tmKeyboardButton.setVisibility(bound.hardKeyboardHidden ? View.VISIBLE : View.GONE);\n\t\t}\n\t}\n\n\t/**\n\t * Called whenever the displayed terminal is changed.\n\t */\n\tprivate void onTerminalChanged() {\n\t\tView terminalNameOverlay = findCurrentView(R.id.terminal_name_overlay);\n\t\tif (terminalNameOverlay != null)\n\t\t\tterminalNameOverlay.startAnimation(fade_out_delayed);\n\t\tupdateDefault();\n\t\tupdatePromptVisible();\n\t\tActivityCompat.invalidateOptionsMenu(ConsoleActivity.this);\n\t}\n\n\t/**\n\t * Displays the child in the ViewPager at the requestedIndex and updates the prompts.\n\t *\n\t * @param requestedIndex the index of the terminal view to display\n\t */\n\tprivate void setDisplayedTerminal(int requestedIndex) {\n\t\tpager.setCurrentItem(requestedIndex);\n\t\t// set activity title\n\t\tsetTitle(adapter.getPageTitle(requestedIndex));\n\t\tonTerminalChanged();\n\t}\n\n\tprivate void pasteIntoTerminal() {\n\t\t// force insert of clipboard text into current console\n\t\tTerminalView terminalView = adapter.getCurrentTerminalView();\n\t\tTerminalBridge bridge = terminalView.bridge;\n\n\t\t// pull string from clipboard and generate all events to force down\n\t\tString clip = \"\";\n\t\tif (clipboard.hasText()) {\n\t\t\tclip = clipboard.getText().toString();\n\t\t}\n\t\tbridge.injectString(clip);\n\t}\n\n\tpublic class TerminalPagerAdapter extends PagerAdapter {\n\t\t@Override\n\t\tpublic int getCount() {\n\t\t\tif (bound != null) {\n\t\t\t\treturn bound.getBridges().size();\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Object instantiateItem(ViewGroup container, int position) {\n\t\t\tif (bound == null || bound.getBridges().size() <= position) {\n\t\t\t\tLog.w(TAG, \"Activity not bound when creating TerminalView.\");\n\t\t\t}\n\t\t\tTerminalBridge bridge = bound.getBridges().get(position);\n\t\t\tbridge.promptHelper.setHandler(promptHandler);\n\n\t\t\t// inflate each terminal view\n\t\t\tRelativeLayout view = (RelativeLayout) inflater.inflate(\n\t\t\t\t\tR.layout.item_terminal, container, false);\n\n\t\t\t// set the terminal name overlay text\n\t\t\tTextView terminalNameOverlay = (TextView) view.findViewById(R.id.terminal_name_overlay);\n\t\t\tterminalNameOverlay.setText(bridge.host.getNickname());\n\n\t\t\t// and add our terminal view control, using index to place behind overlay\n\t\t\tfinal TerminalView terminal = new TerminalView(container.getContext(), bridge, pager);\n\t\t\tterminal.setId(R.id.terminal_view);\n\t\t\tview.addView(terminal, 0);\n\n\t\t\t// Tag the view with its bridge so it can be retrieved later.\n\t\t\tview.setTag(bridge);\n\n\t\t\tcontainer.addView(view);\n\t\t\tterminalNameOverlay.startAnimation(fade_out_delayed);\n\t\t\treturn view;\n\t\t}\n\n\t\t@Override\n\t\tpublic void destroyItem(ViewGroup container, int position, Object object) {\n\t\t\tfinal View view = (View) object;\n\n\t\t\tcontainer.removeView(view);\n\t\t}\n\n\t\t@Override\n\t\tpublic int getItemPosition(Object object) {\n\t\t\tif (bound == null) {\n\t\t\t\treturn POSITION_NONE;\n\t\t\t}\n\n\t\t\tView view = (View) object;\n\t\t\tTerminalView terminal = (TerminalView) view.findViewById(R.id.terminal_view);\n\t\t\tHostBean host = terminal.bridge.host;\n\n\t\t\tint itemIndex = POSITION_NONE;\n\t\t\tint i = 0;\n\t\t\tfor (TerminalBridge bridge : bound.getBridges()) {\n\t\t\t\tif (bridge.host.equals(host)) {\n\t\t\t\t\titemIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t\treturn itemIndex;\n\t\t}\n\n\t\tpublic TerminalBridge getBridgeAtPosition(int position) {\n\t\t\tif (bound == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tArrayList<TerminalBridge> bridges = bound.getBridges();\n\t\t\tif (position < 0 || position >= bridges.size()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn bridges.get(position);\n\t\t}\n\n\t\t@Override\n\t\tpublic void notifyDataSetChanged() {\n\t\t\tsuper.notifyDataSetChanged();\n\t\t\tif (tabs != null) {\n\t\t\t\ttoolbar.setVisibility(this.getCount() > 1 ? View.VISIBLE : View.GONE);\n\t\t\t\ttabs.setTabsFromPagerAdapter(this);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isViewFromObject(View view, Object object) {\n\t\t\treturn view == object;\n\t\t}\n\n\t\t@Override\n\t\tpublic CharSequence getPageTitle(int position) {\n\t\t\tTerminalBridge bridge = getBridgeAtPosition(position);\n\t\t\tif (bridge == null) {\n\t\t\t\treturn \"???\";\n\t\t\t}\n\t\t\treturn bridge.host.getNickname();\n\t\t}\n\n\t\tpublic TerminalView getCurrentTerminalView() {\n\t\t\tView currentView = pager.findViewWithTag(getBridgeAtPosition(pager.getCurrentItem()));\n\t\t\tif (currentView == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn (TerminalView) currentView.findViewById(R.id.terminal_view);\n\t\t}\n\t}\n}\n","lineNo":1070}
{"Smelly Sample":"/*\n * ConnectBot: simple, powerful, open-source SSH client for Android\n * Copyright 2007 Kenny Root, Jeffrey Sharkey\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.connectbot.util;\n\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\nimport org.connectbot.bean.HostBean;\nimport org.connectbot.bean.PortForwardBean;\nimport org.connectbot.data.ColorStorage;\nimport org.connectbot.data.HostStorage;\n\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteException;\nimport android.support.annotation.VisibleForTesting;\nimport android.util.Log;\n\nimport com.trilead.ssh2.KnownHosts;\n\n/**\n * Contains information about various SSH hosts, include public hostkey if known\n * from previous sessions.\n *\n * @author jsharkey\n */\npublic class HostDatabase extends RobustSQLiteOpenHelper implements HostStorage, ColorStorage {\n\n\tpublic final static String TAG = \"CB.HostDatabase\";\n\n\tpublic final static String DB_NAME = \"hosts\";\n\tpublic final static int DB_VERSION = 25;\n\n\tpublic final static String TABLE_HOSTS = \"hosts\";\n\tpublic final static String FIELD_HOST_NICKNAME = \"nickname\";\n\tpublic final static String FIELD_HOST_PROTOCOL = \"protocol\";\n\tpublic final static String FIELD_HOST_USERNAME = \"username\";\n\tpublic final static String FIELD_HOST_HOSTNAME = \"hostname\";\n\tpublic final static String FIELD_HOST_PORT = \"port\";\n\tpublic final static String FIELD_HOST_LASTCONNECT = \"lastconnect\";\n\tpublic final static String FIELD_HOST_COLOR = \"color\";\n\tpublic final static String FIELD_HOST_USEKEYS = \"usekeys\";\n\tpublic final static String FIELD_HOST_USEAUTHAGENT = \"useauthagent\";\n\tpublic final static String FIELD_HOST_POSTLOGIN = \"postlogin\";\n\tpublic final static String FIELD_HOST_PUBKEYID = \"pubkeyid\";\n\tpublic final static String FIELD_HOST_WANTSESSION = \"wantsession\";\n\tpublic final static String FIELD_HOST_DELKEY = \"delkey\";\n\tpublic final static String FIELD_HOST_FONTSIZE = \"fontsize\";\n\tpublic final static String FIELD_HOST_COMPRESSION = \"compression\";\n\tpublic final static String FIELD_HOST_ENCODING = \"encoding\";\n\tpublic final static String FIELD_HOST_STAYCONNECTED = \"stayconnected\";\n\tpublic final static String FIELD_HOST_QUICKDISCONNECT = \"quickdisconnect\";\n\n\tpublic final static String TABLE_KNOWNHOSTS = \"knownhosts\";\n\tpublic final static String FIELD_KNOWNHOSTS_HOSTID = \"hostid\";\n\tpublic final static String FIELD_KNOWNHOSTS_HOSTKEYALGO = \"hostkeyalgo\";\n\tpublic final static String FIELD_KNOWNHOSTS_HOSTKEY = \"hostkey\";\n\n\tpublic final static String TABLE_PORTFORWARDS = \"portforwards\";\n\tpublic final static String FIELD_PORTFORWARD_HOSTID = \"hostid\";\n\tpublic final static String FIELD_PORTFORWARD_NICKNAME = \"nickname\";\n\tpublic final static String FIELD_PORTFORWARD_TYPE = \"type\";\n\tpublic final static String FIELD_PORTFORWARD_SOURCEPORT = \"sourceport\";\n\tpublic final static String FIELD_PORTFORWARD_DESTADDR = \"destaddr\";\n\tpublic final static String FIELD_PORTFORWARD_DESTPORT = \"destport\";\n\n\tpublic final static String TABLE_COLORS = \"colors\";\n\tpublic final static String FIELD_COLOR_SCHEME = \"scheme\";\n\tpublic final static String FIELD_COLOR_NUMBER = \"number\";\n\tpublic final static String FIELD_COLOR_VALUE = \"value\";\n\n\tpublic final static String TABLE_COLOR_DEFAULTS = \"colorDefaults\";\n\tpublic final static String FIELD_COLOR_FG = \"fg\";\n\tpublic final static String FIELD_COLOR_BG = \"bg\";\n\n\tpublic final static int DEFAULT_FG_COLOR = 7;\n\tpublic final static int DEFAULT_BG_COLOR = 0;\n\n\tpublic final static String COLOR_RED = \"red\";\n\tpublic final static String COLOR_GREEN = \"green\";\n\tpublic final static String COLOR_BLUE = \"blue\";\n\tpublic final static String COLOR_GRAY = \"gray\";\n\n\tpublic final static String PORTFORWARD_LOCAL = \"local\";\n\tpublic final static String PORTFORWARD_REMOTE = \"remote\";\n\tpublic final static String PORTFORWARD_DYNAMIC4 = \"dynamic4\";\n\tpublic final static String PORTFORWARD_DYNAMIC5 = \"dynamic5\";\n\n\tpublic final static String DELKEY_DEL = \"del\";\n\tpublic final static String DELKEY_BACKSPACE = \"backspace\";\n\n\tpublic final static String AUTHAGENT_NO = \"no\";\n\tpublic final static String AUTHAGENT_CONFIRM = \"confirm\";\n\tpublic final static String AUTHAGENT_YES = \"yes\";\n\n\tpublic final static String ENCODING_DEFAULT = Charset.defaultCharset().name();\n\n\tpublic final static long PUBKEYID_NEVER = -2;\n\tpublic final static long PUBKEYID_ANY = -1;\n\n\tpublic static final int DEFAULT_COLOR_SCHEME = 0;\n\n\t// Table creation strings\n\tpublic static final String TABLE_HOSTS_COLUMNS = \"_id INTEGER PRIMARY KEY, \"\n\t\t\t+ FIELD_HOST_NICKNAME + \" TEXT, \"\n\t\t\t+ FIELD_HOST_PROTOCOL + \" TEXT DEFAULT 'ssh', \"\n\t\t\t+ FIELD_HOST_USERNAME + \" TEXT, \"\n\t\t\t+ FIELD_HOST_HOSTNAME + \" TEXT, \"\n\t\t\t+ FIELD_HOST_PORT + \" INTEGER, \"\n\t\t\t+ FIELD_HOST_LASTCONNECT + \" INTEGER, \"\n\t\t\t+ FIELD_HOST_COLOR + \" TEXT, \"\n\t\t\t+ FIELD_HOST_USEKEYS + \" TEXT, \"\n\t\t\t+ FIELD_HOST_USEAUTHAGENT + \" TEXT, \"\n\t\t\t+ FIELD_HOST_POSTLOGIN + \" TEXT, \"\n\t\t\t+ FIELD_HOST_PUBKEYID + \" INTEGER DEFAULT \" + PUBKEYID_ANY + \", \"\n\t\t\t+ FIELD_HOST_DELKEY + \" TEXT DEFAULT '\" + DELKEY_DEL + \"', \"\n\t\t\t+ FIELD_HOST_FONTSIZE + \" INTEGER, \"\n\t\t\t+ FIELD_HOST_WANTSESSION + \" TEXT DEFAULT '\" + Boolean.toString(true) + \"', \"\n\t\t\t+ FIELD_HOST_COMPRESSION + \" TEXT DEFAULT '\" + Boolean.toString(false) + \"', \"\n\t\t\t+ FIELD_HOST_ENCODING + \" TEXT DEFAULT '\" + ENCODING_DEFAULT + \"', \"\n\t\t\t+ FIELD_HOST_STAYCONNECTED + \" TEXT DEFAULT '\" + Boolean.toString(false) + \"', \"\n\t\t\t+ FIELD_HOST_QUICKDISCONNECT + \" TEXT DEFAULT '\" + Boolean.toString(false) + \"'\";\n\n\tpublic static final String CREATE_TABLE_HOSTS = \"CREATE TABLE \" + TABLE_HOSTS\n\t\t\t+ \" (\" + TABLE_HOSTS_COLUMNS + \")\";\n\n\tpublic static final String CREATE_TABLE_COLOR_DEFAULTS =\n\t\t\"CREATE TABLE \" + TABLE_COLOR_DEFAULTS\n\t\t+ \" (\" + FIELD_COLOR_SCHEME + \" INTEGER NOT NULL, \"\n\t\t+ FIELD_COLOR_FG + \" INTEGER NOT NULL DEFAULT \" + DEFAULT_FG_COLOR + \", \"\n\t\t+ FIELD_COLOR_BG + \" INTEGER NOT NULL DEFAULT \" + DEFAULT_BG_COLOR + \")\";\n\n\tpublic static final String CREATE_TABLE_COLOR_DEFAULTS_INDEX =\n\t\t\"CREATE INDEX \" + TABLE_COLOR_DEFAULTS + FIELD_COLOR_SCHEME + \"index ON \"\n\t\t+ TABLE_COLOR_DEFAULTS + \" (\" + FIELD_COLOR_SCHEME + \");\";\n\n\tprivate static final String WHERE_SCHEME_AND_COLOR = FIELD_COLOR_SCHEME + \" = ? AND \"\n\t\t\t+ FIELD_COLOR_NUMBER + \" = ?\";\n\n\tstatic {\n\t\taddTableName(TABLE_HOSTS);\n\t\taddTableName(TABLE_KNOWNHOSTS);\n\t\taddIndexName(TABLE_KNOWNHOSTS + FIELD_KNOWNHOSTS_HOSTID + \"index\");\n\t\taddTableName(TABLE_PORTFORWARDS);\n\t\taddIndexName(TABLE_PORTFORWARDS + FIELD_PORTFORWARD_HOSTID + \"index\");\n\t\taddTableName(TABLE_COLORS);\n\t\taddIndexName(TABLE_COLORS + FIELD_COLOR_SCHEME + \"index\");\n\t\taddTableName(TABLE_COLOR_DEFAULTS);\n\t\taddIndexName(TABLE_COLOR_DEFAULTS + FIELD_COLOR_SCHEME + \"index\");\n\t}\n\n\t/** Used during upgrades from DB version 23 to 24. */\n\tprivate final float displayDensity;\n\n\tprivate static final Object sInstanceLock = new Object();\n\n\tprivate static HostDatabase sInstance;\n\n\tprivate final SQLiteDatabase mDb;\n\n\tpublic static HostDatabase get(Context context) {\n\t\tsynchronized (sInstanceLock) {\n\t\t\tif (sInstance != null) {\n\t\t\t\treturn sInstance;\n\t\t\t}\n\n\t\t\tsInstance = new HostDatabase(context.getApplicationContext());\n\t\t\treturn sInstance;\n\t\t}\n\t}\n\n\tprivate HostDatabase(Context context) {\n\t\tthis(context, DB_NAME);\n\t}\n\n\tprivate HostDatabase(Context context, String dbName) {\n\t\tsuper(context, dbName, null, DB_VERSION);\n\n\t\tthis.displayDensity = context.getResources().getDisplayMetrics().density;\n\t\tmDb = getWritableDatabase();\n\t}\n\n\t@Override\n\tpublic void onCreate(SQLiteDatabase db) {\n\t\tsuper.onCreate(db);\n\n\t\tcreateTables(db);\n\t}\n\n\tprivate void createTables(SQLiteDatabase db) {\n\t\tdb.execSQL(CREATE_TABLE_HOSTS);\n\n\t\tdb.execSQL(\"CREATE TABLE \" + TABLE_KNOWNHOSTS\n\t\t\t\t+ \" (_id INTEGER PRIMARY KEY, \"\n\t\t\t\t+ FIELD_KNOWNHOSTS_HOSTID + \" INTEGER, \"\n\t\t\t\t+ FIELD_KNOWNHOSTS_HOSTKEYALGO + \" TEXT, \"\n\t\t\t\t+ FIELD_KNOWNHOSTS_HOSTKEY + \" BLOB)\");\n\n\t\tdb.execSQL(\"CREATE INDEX \" + TABLE_KNOWNHOSTS + FIELD_KNOWNHOSTS_HOSTID + \"index ON \"\n\t\t\t\t+ TABLE_KNOWNHOSTS + \" (\" + FIELD_KNOWNHOSTS_HOSTID + \");\");\n\n\t\tdb.execSQL(\"CREATE TABLE \" + TABLE_PORTFORWARDS\n\t\t\t\t+ \" (_id INTEGER PRIMARY KEY, \"\n\t\t\t\t+ FIELD_PORTFORWARD_HOSTID + \" INTEGER, \"\n\t\t\t\t+ FIELD_PORTFORWARD_NICKNAME + \" TEXT, \"\n\t\t\t\t+ FIELD_PORTFORWARD_TYPE + \" TEXT NOT NULL DEFAULT \" + PORTFORWARD_LOCAL + \", \"\n\t\t\t\t+ FIELD_PORTFORWARD_SOURCEPORT + \" INTEGER NOT NULL DEFAULT 8080, \"\n\t\t\t\t+ FIELD_PORTFORWARD_DESTADDR + \" TEXT, \"\n\t\t\t\t+ FIELD_PORTFORWARD_DESTPORT + \" TEXT)\");\n\n\t\tdb.execSQL(\"CREATE INDEX \" + TABLE_PORTFORWARDS + FIELD_PORTFORWARD_HOSTID + \"index ON \"\n\t\t\t\t+ TABLE_PORTFORWARDS + \" (\" + FIELD_PORTFORWARD_HOSTID + \");\");\n\n\t\tdb.execSQL(\"CREATE TABLE \" + TABLE_COLORS\n\t\t\t\t+ \" (_id INTEGER PRIMARY KEY, \"\n\t\t\t\t+ FIELD_COLOR_NUMBER + \" INTEGER, \"\n\t\t\t\t+ FIELD_COLOR_VALUE + \" INTEGER, \"\n\t\t\t\t+ FIELD_COLOR_SCHEME + \" INTEGER)\");\n\n\t\tdb.execSQL(\"CREATE INDEX \" + TABLE_COLORS + FIELD_COLOR_SCHEME + \"index ON \"\n\t\t\t\t+ TABLE_COLORS + \" (\" + FIELD_COLOR_SCHEME + \");\");\n\n\t\tdb.execSQL(CREATE_TABLE_COLOR_DEFAULTS);\n\t\tdb.execSQL(CREATE_TABLE_COLOR_DEFAULTS_INDEX);\n\t}\n\n\t@VisibleForTesting\n\tpublic void resetDatabase() {\n\t\ttry {\n\t\t\tmDb.beginTransaction();\n\n\t\t\tmDb.execSQL(\"DROP TABLE IF EXISTS \" + TABLE_HOSTS);\n\t\t\tmDb.execSQL(\"DROP TABLE IF EXISTS \" + TABLE_KNOWNHOSTS);\n\t\t\tmDb.execSQL(\"DROP TABLE IF EXISTS \" + TABLE_PORTFORWARDS);\n\t\t\tmDb.execSQL(\"DROP TABLE IF EXISTS \" + TABLE_COLORS);\n\t\t\tmDb.execSQL(\"DROP TABLE IF EXISTS \" + TABLE_COLOR_DEFAULTS);\n\n\t\t\tcreateTables(mDb);\n\n\t\t\tmDb.setTransactionSuccessful();\n\t\t} finally {\n\t\t\tmDb.endTransaction();\n\t\t}\n\t}\n\n\t@VisibleForTesting\n\tpublic static void resetInMemoryInstance(Context context) {\n\t\tget(context).resetDatabase();\n\t}\n\n\t@Override\n\tpublic void onRobustUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) throws SQLiteException {\n\t\t// Versions of the database before the Android Market release will be\n\t\t// shot without warning.\n\t\tif (oldVersion <= 9) {\n\t\t\tdb.execSQL(\"DROP TABLE IF EXISTS \" + TABLE_HOSTS);\n\t\t\tonCreate(db);\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (oldVersion) {\n\t\tcase 10:\n\t\t\tdb.execSQL(\"ALTER TABLE \" + TABLE_HOSTS\n\t\t\t\t\t+ \" ADD COLUMN \" + FIELD_HOST_PUBKEYID + \" INTEGER DEFAULT \" + PUBKEYID_ANY);\n\t\tcase 11:\n\t\t\tdb.execSQL(\"CREATE TABLE \" + TABLE_PORTFORWARDS\n\t\t\t\t\t+ \" (_id INTEGER PRIMARY KEY, \"\n\t\t\t\t\t+ FIELD_PORTFORWARD_HOSTID + \" INTEGER, \"\n\t\t\t\t\t+ FIELD_PORTFORWARD_NICKNAME + \" TEXT, \"\n\t\t\t\t\t+ FIELD_PORTFORWARD_TYPE + \" TEXT NOT NULL DEFAULT \" + PORTFORWARD_LOCAL + \", \"\n\t\t\t\t\t+ FIELD_PORTFORWARD_SOURCEPORT + \" INTEGER NOT NULL DEFAULT 8080, \"\n\t\t\t\t\t+ FIELD_PORTFORWARD_DESTADDR + \" TEXT, \"\n\t\t\t\t\t+ FIELD_PORTFORWARD_DESTPORT + \" INTEGER)\");\n\t\tcase 12:\n\t\t\tdb.execSQL(\"ALTER TABLE \" + TABLE_HOSTS\n\t\t\t\t\t+ \" ADD COLUMN \" + FIELD_HOST_WANTSESSION + \" TEXT DEFAULT '\" + Boolean.toString(true) + \"'\");\n\t\tcase 13:\n\t\t\tdb.execSQL(\"ALTER TABLE \" + TABLE_HOSTS\n\t\t\t\t\t+ \" ADD COLUMN \" + FIELD_HOST_COMPRESSION + \" TEXT DEFAULT '\" + Boolean.toString(false) + \"'\");\n\t\tcase 14:\n\t\t\tdb.execSQL(\"ALTER TABLE \" + TABLE_HOSTS\n\t\t\t\t\t+ \" ADD COLUMN \" + FIELD_HOST_ENCODING + \" TEXT DEFAULT '\" + ENCODING_DEFAULT + \"'\");\n\t\tcase 15:\n\t\t\tdb.execSQL(\"ALTER TABLE \" + TABLE_HOSTS\n\t\t\t\t\t+ \" ADD COLUMN \" + FIELD_HOST_PROTOCOL + \" TEXT DEFAULT 'ssh'\");\n\t\tcase 16:\n\t\t\tdb.execSQL(\"ALTER TABLE \" + TABLE_HOSTS\n\t\t\t\t\t+ \" ADD COLUMN \" + FIELD_HOST_DELKEY + \" TEXT DEFAULT '\" + DELKEY_DEL + \"'\");\n\t\tcase 17:\n\t\t\tdb.execSQL(\"CREATE INDEX \" + TABLE_PORTFORWARDS + FIELD_PORTFORWARD_HOSTID + \"index ON \"\n\t\t\t\t\t+ TABLE_PORTFORWARDS + \" (\" + FIELD_PORTFORWARD_HOSTID + \");\");\n\n\t\t\t// Add colors\n\t\t\tdb.execSQL(\"CREATE TABLE \" + TABLE_COLORS\n\t\t\t\t\t+ \" (_id INTEGER PRIMARY KEY, \"\n\t\t\t\t\t+ FIELD_COLOR_NUMBER + \" INTEGER, \"\n\t\t\t\t\t+ FIELD_COLOR_VALUE + \" INTEGER, \"\n\t\t\t\t\t+ FIELD_COLOR_SCHEME + \" INTEGER)\");\n\t\t\tdb.execSQL(\"CREATE INDEX \" + TABLE_COLORS + FIELD_COLOR_SCHEME + \"index ON \"\n\t\t\t\t\t+ TABLE_COLORS + \" (\" + FIELD_COLOR_SCHEME + \");\");\n\t\tcase 18:\n\t\t\tdb.execSQL(\"ALTER TABLE \" + TABLE_HOSTS\n\t\t\t\t\t+ \" ADD COLUMN \" + FIELD_HOST_USEAUTHAGENT + \" TEXT DEFAULT '\" + AUTHAGENT_NO + \"'\");\n\t\tcase 19:\n\t\t\tdb.execSQL(\"ALTER TABLE \" + TABLE_HOSTS\n\t\t\t\t\t+ \" ADD COLUMN \" + FIELD_HOST_STAYCONNECTED + \" TEXT\");\n\t\tcase 20:\n\t\t\tdb.execSQL(\"ALTER TABLE \" + TABLE_HOSTS\n\t\t\t\t\t+ \" ADD COLUMN \" + FIELD_HOST_FONTSIZE + \" INTEGER\");\n\t\tcase 21:\n\t\t\tdb.execSQL(\"DROP TABLE IF EXISTS \" + TABLE_COLOR_DEFAULTS);\n\t\t\tdb.execSQL(CREATE_TABLE_COLOR_DEFAULTS);\n\t\t\tdb.execSQL(CREATE_TABLE_COLOR_DEFAULTS_INDEX);\n\t\tcase 22:\n\t\t\tdb.execSQL(\"ALTER TABLE \" + TABLE_HOSTS\n\t\t\t\t\t+ \" ADD COLUMN \" + FIELD_HOST_QUICKDISCONNECT + \" TEXT DEFAULT '\" + Boolean.toString(false) + \"'\");\n\t\tcase 23:\n\t\t\tdb.execSQL(\"UPDATE \" + TABLE_HOSTS\n\t\t\t\t\t+ \" SET \" + FIELD_HOST_FONTSIZE + \" = \" + FIELD_HOST_FONTSIZE + \" / \" + displayDensity);\n\t\tcase 24:\n\t\t\t// Move all the existing known hostkeys into their own table.\n\t\t\tdb.execSQL(\"DROP TABLE IF EXISTS \" + TABLE_KNOWNHOSTS);\n\t\t\tdb.execSQL(\"CREATE TABLE \" + TABLE_KNOWNHOSTS\n\t\t\t\t\t+ \" (_id INTEGER PRIMARY KEY, \"\n\t\t\t\t\t+ FIELD_KNOWNHOSTS_HOSTID + \" INTEGER, \"\n\t\t\t\t\t+ FIELD_KNOWNHOSTS_HOSTKEYALGO + \" TEXT, \"\n\t\t\t\t\t+ FIELD_KNOWNHOSTS_HOSTKEY + \" BLOB)\");\n\t\t\tdb.execSQL(\"INSERT INTO \" + TABLE_KNOWNHOSTS + \" (\"\n\t\t\t\t\t+ FIELD_KNOWNHOSTS_HOSTID + \", \"\n\t\t\t\t\t+ FIELD_KNOWNHOSTS_HOSTKEYALGO + \", \"\n\t\t\t\t\t+ FIELD_KNOWNHOSTS_HOSTKEY + \") \"\n\t\t\t\t\t+ \"SELECT _id, \"\n\t\t\t\t\t+ FIELD_KNOWNHOSTS_HOSTKEYALGO + \", \"\n\t\t\t\t\t+ FIELD_KNOWNHOSTS_HOSTKEY\n\t\t\t\t\t+ \" FROM \" + TABLE_HOSTS);\n\t\t\t// Work around SQLite not supporting dropping columns\n\t\t\tdb.execSQL(\"DROP TABLE IF EXISTS \" + TABLE_HOSTS + \"_upgrade\");\n\t\t\tdb.execSQL(\"CREATE TABLE \" + TABLE_HOSTS + \"_upgrade (\" + TABLE_HOSTS_COLUMNS + \")\");\n\t\t\tdb.execSQL(\"INSERT INTO \" + TABLE_HOSTS + \"_upgrade SELECT _id, \"\n\t\t\t\t\t+ FIELD_HOST_NICKNAME + \", \"\n\t\t\t\t\t+ FIELD_HOST_PROTOCOL + \", \"\n\t\t\t\t\t+ FIELD_HOST_USERNAME + \", \"\n\t\t\t\t\t+ FIELD_HOST_HOSTNAME + \", \"\n\t\t\t\t\t+ FIELD_HOST_PORT + \", \"\n\t\t\t\t\t+ FIELD_HOST_LASTCONNECT + \", \"\n\t\t\t\t\t+ FIELD_HOST_COLOR + \", \"\n\t\t\t\t\t+ FIELD_HOST_USEKEYS + \", \"\n\t\t\t\t\t+ FIELD_HOST_USEAUTHAGENT + \", \"\n\t\t\t\t\t+ FIELD_HOST_POSTLOGIN + \", \"\n\t\t\t\t\t+ FIELD_HOST_PUBKEYID + \", \"\n\t\t\t\t\t+ FIELD_HOST_DELKEY + \", \"\n\t\t\t\t\t+ FIELD_HOST_FONTSIZE + \", \"\n\t\t\t\t\t+ FIELD_HOST_WANTSESSION + \", \"\n\t\t\t\t\t+ FIELD_HOST_COMPRESSION + \", \"\n\t\t\t\t\t+ FIELD_HOST_ENCODING + \", \"\n\t\t\t\t\t+ FIELD_HOST_STAYCONNECTED + \", \"\n\t\t\t\t\t+ FIELD_HOST_QUICKDISCONNECT\n\t\t\t\t\t+ \" FROM \" + TABLE_HOSTS);\n\t\t\tdb.execSQL(\"DROP TABLE \" + TABLE_HOSTS);\n\t\t\tdb.execSQL(\"ALTER TABLE \" + TABLE_HOSTS + \"_upgrade RENAME TO \" + TABLE_HOSTS);\n\t\t}\n\t}\n\n\t/**\n\t * Touch a specific host to update its \"last connected\" field.\n\t * @param host host to update\n\t */\n\tpublic void touchHost(HostBean host) {\n\t\tlong now = System.currentTimeMillis() / 1000;\n\n\t\tContentValues values = new ContentValues();\n\t\tvalues.put(FIELD_HOST_LASTCONNECT, now);\n\n\t\tmDb.beginTransaction();\n\t\ttry {\n\t\t\tmDb.update(TABLE_HOSTS, values, \"_id = ?\", new String[] {String.valueOf(host.getId())});\n\t\t\tmDb.setTransactionSuccessful();\n\t\t} finally {\n\t\t\tmDb.endTransaction();\n\t\t}\n\t}\n\n\t/**\n\t * Create a new or update an existing {@code host}.\n\t */\n\tpublic HostBean saveHost(HostBean host) {\n\t\tlong id = host.getId();\n\n\t\tmDb.beginTransaction();\n\t\ttry {\n\t\t\tif (id == -1) {\n\t\t\t\tid = mDb.insert(TABLE_HOSTS, null, host.getValues());\n\t\t\t} else {\n\t\t\t\tmDb.update(TABLE_HOSTS, host.getValues(), \"_id = ?\", new String[] {String.valueOf(id)});\n\t\t\t}\n\t\t\tmDb.setTransactionSuccessful();\n\t\t} finally {\n\t\t\tmDb.endTransaction();\n\t\t}\n\n\t\thost.setId(id);\n\n\t\treturn host;\n\t}\n\n\t/**\n\t * Delete a specific host by its <code>_id<\/code> value.\n\t */\n\tpublic void deleteHost(HostBean host) {\n\t\tif (host.getId() < 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tmDb.beginTransaction();\n\t\ttry {\n\t\t\tmDb.delete(TABLE_HOSTS, \"_id = ?\", new String[] {String.valueOf(host.getId())});\n\t\t\tmDb.setTransactionSuccessful();\n\t\t} finally {\n\t\t\tmDb.endTransaction();\n\t\t}\n\t}\n\n\t/**\n\t * Return a cursor that contains information about all known hosts.\n\t * @param sortColors If true, sort by color, otherwise sort by nickname.\n\t */\n\tpublic List<HostBean> getHosts(boolean sortColors) {\n\t\tString sortField = sortColors ? FIELD_HOST_COLOR : FIELD_HOST_NICKNAME;\n\t\tList<HostBean> hosts;\n\n\t\tCursor c = mDb.query(TABLE_HOSTS, null, null, null, null, null, sortField + \" ASC\");\n\n\t\thosts = createHostBeans(c);\n\n\t\tc.close();\n\n\t\treturn hosts;\n\t}\n\n\t/**\n\t * @param c cursor to read from\n\t */\n\tprivate List<HostBean> createHostBeans(Cursor c) {\n\t\tList<HostBean> hosts = new LinkedList<HostBean>();\n\n\t\tfinal int COL_ID = c.getColumnIndexOrThrow(\"_id\"),\n\t\t\tCOL_NICKNAME = c.getColumnIndexOrThrow(FIELD_HOST_NICKNAME),\n\t\t\tCOL_PROTOCOL = c.getColumnIndexOrThrow(FIELD_HOST_PROTOCOL),\n\t\t\tCOL_USERNAME = c.getColumnIndexOrThrow(FIELD_HOST_USERNAME),\n\t\t\tCOL_HOSTNAME = c.getColumnIndexOrThrow(FIELD_HOST_HOSTNAME),\n\t\t\tCOL_PORT = c.getColumnIndexOrThrow(FIELD_HOST_PORT),\n\t\t\tCOL_LASTCONNECT = c.getColumnIndexOrThrow(FIELD_HOST_LASTCONNECT),\n\t\t\tCOL_COLOR = c.getColumnIndexOrThrow(FIELD_HOST_COLOR),\n\t\t\tCOL_USEKEYS = c.getColumnIndexOrThrow(FIELD_HOST_USEKEYS),\n\t\t\tCOL_USEAUTHAGENT = c.getColumnIndexOrThrow(FIELD_HOST_USEAUTHAGENT),\n\t\t\tCOL_POSTLOGIN = c.getColumnIndexOrThrow(FIELD_HOST_POSTLOGIN),\n\t\t\tCOL_PUBKEYID = c.getColumnIndexOrThrow(FIELD_HOST_PUBKEYID),\n\t\t\tCOL_WANTSESSION = c.getColumnIndexOrThrow(FIELD_HOST_WANTSESSION),\n\t\t\tCOL_DELKEY = c.getColumnIndexOrThrow(FIELD_HOST_DELKEY),\n\t\t\tCOL_FONTSIZE = c.getColumnIndexOrThrow(FIELD_HOST_FONTSIZE),\n\t\t\tCOL_COMPRESSION = c.getColumnIndexOrThrow(FIELD_HOST_COMPRESSION),\n\t\t\tCOL_ENCODING = c.getColumnIndexOrThrow(FIELD_HOST_ENCODING),\n\t\t\tCOL_STAYCONNECTED = c.getColumnIndexOrThrow(FIELD_HOST_STAYCONNECTED),\n\t\t\tCOL_QUICKDISCONNECT = c.getColumnIndexOrThrow(FIELD_HOST_QUICKDISCONNECT);\n\n\t\twhile (c.moveToNext()) {\n\t\t\tHostBean host = new HostBean();\n\n\t\t\thost.setId(c.getLong(COL_ID));\n\t\t\thost.setNickname(c.getString(COL_NICKNAME));\n\t\t\thost.setProtocol(c.getString(COL_PROTOCOL));\n\t\t\thost.setUsername(c.getString(COL_USERNAME));\n\t\t\thost.setHostname(c.getString(COL_HOSTNAME));\n\t\t\thost.setPort(c.getInt(COL_PORT));\n\t\t\thost.setLastConnect(c.getLong(COL_LASTCONNECT));\n\t\t\thost.setColor(c.getString(COL_COLOR));\n\t\t\thost.setUseKeys(Boolean.valueOf(c.getString(COL_USEKEYS)));\n\t\t\thost.setUseAuthAgent(c.getString(COL_USEAUTHAGENT));\n\t\t\thost.setPostLogin(c.getString(COL_POSTLOGIN));\n\t\t\thost.setPubkeyId(c.getLong(COL_PUBKEYID));\n\t\t\thost.setWantSession(Boolean.valueOf(c.getString(COL_WANTSESSION)));\n\t\t\thost.setDelKey(c.getString(COL_DELKEY));\n\t\t\thost.setFontSize(c.getInt(COL_FONTSIZE));\n\t\t\thost.setCompression(Boolean.valueOf(c.getString(COL_COMPRESSION)));\n\t\t\thost.setEncoding(c.getString(COL_ENCODING));\n\t\t\thost.setStayConnected(Boolean.valueOf(c.getString(COL_STAYCONNECTED)));\n\t\t\thost.setQuickDisconnect(Boolean.valueOf(c.getString(COL_QUICKDISCONNECT)));\n\n\t\t\thosts.add(host);\n\t\t}\n\n\t\treturn hosts;\n\t}\n\n\t/**\n\t * @param c cursor with zero or more hosts\n\t * @return the first host from the cursor or {@code null} if none.\n\t */\n\tprivate HostBean getFirstHostBean(Cursor c) {\n\t\tHostBean host = null;\n\n\t\tList<HostBean> hosts = createHostBeans(c);\n\t\tif (hosts.size() > 0)\n\t\t\thost = hosts.get(0);\n\n\t\tc.close();\n\n\t\treturn host;\n\t}\n\n\t/**\n\t * @param selection parameters describing the desired host\n\t * @return host matching selection or {@code null}.\n\t */\n\tpublic HostBean findHost(Map<String, String> selection) {\n\t\tStringBuilder selectionBuilder = new StringBuilder();\n\n\t\tIterator<Entry<String, String>> i = selection.entrySet().iterator();\n\n\t\tList<String> selectionValuesList = new LinkedList<String>();\n\t\tint n = 0;\n\t\twhile (i.hasNext()) {\n\t\t\tEntry<String, String> entry = i.next();\n\n\t\t\tif (entry.getValue() == null)\n\t\t\t\tcontinue;\n\n\t\t\tif (n++ > 0)\n\t\t\t\tselectionBuilder.append(\" AND \");\n\n\t\t\tselectionBuilder.append(entry.getKey())\n\t\t\t\t.append(\" = ?\");\n\n\t\t\tselectionValuesList.add(entry.getValue());\n\t\t}\n\n\t\tString selectionValues[] = new String[selectionValuesList.size()];\n\t\tselectionValuesList.toArray(selectionValues);\n\n\t\tCursor c = mDb.query(TABLE_HOSTS, null,\n\t\t\t\tselectionBuilder.toString(),\n\t\t\t\tselectionValues,\n\t\t\t\tnull, null, null);\n\n\t\tHostBean host = getFirstHostBean(c);\n\n\t\treturn host;\n\t}\n\n\t/**\n\t * @param hostId host id for the host\n\t * @return host matching the hostId or {@code null} if none match\n\t */\n\tpublic HostBean findHostById(long hostId) {\n\t\tCursor c = mDb.query(TABLE_HOSTS, null,\n\t\t\t\t\"_id = ?\", new String[] {String.valueOf(hostId)},\n\t\t\t\tnull, null, null);\n\n\t\treturn getFirstHostBean(c);\n\t}\n\n\t/**\n\t * Record the given hostkey into database under this nickname.\n\t * @param hostname hostname to match\n\t * @param port port to match\n\t * @param hostkeyalgo algorithm for host key\n\t * @param hostkey the bytes of the host key itself\n\t */\n\tpublic void saveKnownHost(String hostname, int port, String hostkeyalgo, byte[] hostkey) {\n\t\tContentValues values = new ContentValues();\n\t\tvalues.put(FIELD_KNOWNHOSTS_HOSTKEYALGO, hostkeyalgo);\n\t\tvalues.put(FIELD_KNOWNHOSTS_HOSTKEY, hostkey);\n\n\t\tHashMap<String, String> selection = new HashMap<>();\n\t\tselection.put(FIELD_HOST_HOSTNAME, hostname);\n\t\tselection.put(FIELD_HOST_PORT, String.valueOf(port));\n\t\tHostBean hostBean = findHost(selection);\n\n\t\tif (hostBean == null) {\n\t\t\tLog.e(TAG, \"Tried to save known host for \" + hostname + \":\" + port\n\t\t\t\t\t+ \" it doesn't exist in the database\");\n\t\t\treturn;\n\t\t}\n\n\t\tint numUpdated;\n\t\tmDb.beginTransaction();\n\t\ttry {\n\t\t\tnumUpdated = mDb.update(TABLE_KNOWNHOSTS, values,\n\t\t\t\t\tFIELD_KNOWNHOSTS_HOSTID + \" = ?\",\n\t\t\t\t\tnew String[] {String.valueOf(hostBean.getId())});\n\t\t\tmDb.setTransactionSuccessful();\n\t\t} finally {\n\t\t\tmDb.endTransaction();\n\t\t}\n\t\tLog.d(TAG, String.format(\"Finished saving hostkey information for '%s' (affected %d entries)\",\n\t\t\t\thostname, numUpdated));\n\t}\n\n\t@Override\n\tpublic void removeKnownHost(String host, int port, String serverHostKeyAlgorithm, byte[] serverHostKey) {\n\t\tthrow new UnsupportedOperationException(\"removeKnownHost is not implemented\");\n\t}\n\n\t/**\n\t * Build list of known hosts for Trilead library.\n\t * @return\n\t */\n\tpublic KnownHosts getKnownHosts() {\n\t\tKnownHosts known = new KnownHosts();\n\n\t\tCursor c = mDb.query(TABLE_HOSTS + \" LEFT OUTER JOIN \" + TABLE_KNOWNHOSTS\n\t\t\t\t\t\t+ \" ON \" + TABLE_HOSTS + \"._id = \"\n\t\t\t\t\t\t+ TABLE_KNOWNHOSTS + \".\" + FIELD_KNOWNHOSTS_HOSTID,\n\t\t\t\tnew String[] {FIELD_HOST_HOSTNAME, FIELD_HOST_PORT, FIELD_KNOWNHOSTS_HOSTKEYALGO,\n\t\t\t\t\t\tFIELD_KNOWNHOSTS_HOSTKEY},\n\t\t\t\tnull, null, null, null, null);\n\n\t\tif (c != null) {\n\t\t\tint COL_HOSTNAME = c.getColumnIndexOrThrow(FIELD_HOST_HOSTNAME),\n\t\t\t\t\tCOL_PORT = c.getColumnIndexOrThrow(FIELD_HOST_PORT),\n\t\t\t\t\tCOL_HOSTKEYALGO = c.getColumnIndexOrThrow(FIELD_KNOWNHOSTS_HOSTKEYALGO),\n\t\t\t\t\tCOL_HOSTKEY = c.getColumnIndexOrThrow(FIELD_KNOWNHOSTS_HOSTKEY);\n\n\t\t\twhile (c.moveToNext()) {\n\t\t\t\tString hostname = c.getString(COL_HOSTNAME);\n\t\t\t\tString hostkeyalgo = c.getString(COL_HOSTKEYALGO);\n\t\t\t\tint port = c.getInt(COL_PORT);\n\t\t\t\tbyte[] hostkey = c.getBlob(COL_HOSTKEY);\n\n\t\t\t\tif (hostkeyalgo == null || hostkeyalgo.length() == 0) continue;\n\t\t\t\tif (hostkey == null || hostkey.length == 0) continue;\n\n\t\t\t\ttry {\n\t\t\t\t\tknown.addHostkey(new String[] {String.format(\"%s:%d\", hostname, port)}, hostkeyalgo, hostkey);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tLog.e(TAG, \"Problem while adding a known host from database\", e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc.close();\n\t\t}\n\n\t\treturn known;\n\t}\n\n\t@Override\n\tpublic List<String> getHostKeyAlgorithmsForHost(String hostname, int port) {\n\t\tHashMap<String, String> selection = new HashMap<>();\n\t\tselection.put(FIELD_HOST_HOSTNAME, hostname);\n\t\tselection.put(FIELD_HOST_PORT, String.valueOf(port));\n\t\tHostBean hostBean = findHost(selection);\n\n\t\tif (hostBean == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tArrayList<String> knownAlgorithms = new ArrayList<>();\n\n\t\tCursor c = mDb.query(TABLE_KNOWNHOSTS, new String[] {FIELD_KNOWNHOSTS_HOSTKEYALGO},\n\t\t\t\tFIELD_KNOWNHOSTS_HOSTID + \" = ?\",\n\t\t\t\tnew String[] {String.valueOf(hostBean.getId())}, null, null, null);\n\n\t\tif (c != null) {\n\t\t\tint COL_ALGO = c.getColumnIndexOrThrow(FIELD_KNOWNHOSTS_HOSTKEYALGO);\n\n\t\t\twhile (c.moveToNext()) {\n\t\t\t\tString keyAlgo = c.getString(COL_ALGO);\n\t\t\t\tif (keyAlgo != null) {\n\t\t\t\t\tknownAlgorithms.add(keyAlgo);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc.close();\n\t\t}\n\n\t\treturn knownAlgorithms;\n\t}\n\n\t/**\n\t * Unset any hosts using a pubkey ID that has been deleted.\n\t * @param pubkeyId\n\t */\n\tpublic void stopUsingPubkey(long pubkeyId) {\n\t\tif (pubkeyId < 0) return;\n\n\t\tContentValues values = new ContentValues();\n\t\tvalues.put(FIELD_HOST_PUBKEYID, PUBKEYID_ANY);\n\n\t\tmDb.beginTransaction();\n\t\ttry {\n\t\t\tmDb.update(TABLE_HOSTS, values, FIELD_HOST_PUBKEYID + \" = ?\", new String[] {String.valueOf(pubkeyId)});\n\t\t\tmDb.setTransactionSuccessful();\n\t\t} finally {\n\t\t\tmDb.endTransaction();\n\t\t}\n\n\t\tLog.d(TAG, String.format(\"Set all hosts using pubkey id %d to -1\", pubkeyId));\n\t}\n\n\t/*\n\t * Methods for dealing with port forwards attached to hosts\n\t */\n\n\t/**\n\t * Returns a list of all the port forwards associated with a particular host ID.\n\t * @param host the host for which we want the port forward list\n\t * @return port forwards associated with host ID or empty list if no match\n\t */\n\tpublic List<PortForwardBean> getPortForwardsForHost(HostBean host) {\n\t\tList<PortForwardBean> portForwards = new LinkedList<PortForwardBean>();\n\t\tif (host == null) {\n\t\t\treturn portForwards;\n\t\t}\n\n\t\tCursor c = mDb.query(TABLE_PORTFORWARDS, new String[] {\n\t\t\t\t\t\t\"_id\", FIELD_PORTFORWARD_NICKNAME, FIELD_PORTFORWARD_TYPE, FIELD_PORTFORWARD_SOURCEPORT,\n\t\t\t\t\t\tFIELD_PORTFORWARD_DESTADDR, FIELD_PORTFORWARD_DESTPORT},\n\t\t\t\tFIELD_PORTFORWARD_HOSTID + \" = ?\", new String[] {String.valueOf(host.getId())},\n\t\t\t\tnull, null, null);\n\n\t\twhile (c.moveToNext()) {\n\t\t\tPortForwardBean pfb = new PortForwardBean(\n\t\t\t\t\tc.getInt(0),\n\t\t\t\t\thost.getId(),\n\t\t\t\t\tc.getString(1),\n\t\t\t\t\tc.getString(2),\n\t\t\t\t\tc.getInt(3),\n\t\t\t\t\tc.getString(4),\n\t\t\t\t\tc.getInt(5));\n\t\t\tportForwards.add(pfb);\n\t\t}\n\n\t\tc.close();\n\n\t\treturn portForwards;\n\t}\n\n\t/**\n\t * Update the parameters of a port forward in the database.\n\t * @param pfb {@link PortForwardBean} to save\n\t * @return true on success\n\t */\n\tpublic boolean savePortForward(PortForwardBean pfb) {\n\t\tmDb.beginTransaction();\n\t\ttry {\n\t\t\tif (pfb.getId() < 0) {\n\t\t\t\tlong addedId = mDb.insert(TABLE_PORTFORWARDS, null, pfb.getValues());\n\t\t\t\tif (addedId == -1) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tpfb.setId(addedId);\n\t\t\t} else {\n\t\t\t\tif (mDb.update(TABLE_PORTFORWARDS, pfb.getValues(), \"_id = ?\", new String[] {String.valueOf(pfb.getId())}) <= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmDb.setTransactionSuccessful();\n\t\t\treturn true;\n\t\t} finally {\n\t\t\tmDb.endTransaction();\n\t\t}\n\t}\n\n\t/**\n\t * Deletes a port forward from the database.\n\t * @param pfb {@link PortForwardBean} to delete\n\t */\n\tpublic void deletePortForward(PortForwardBean pfb) {\n\t\tif (pfb.getId() < 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tmDb.beginTransaction();\n\t\ttry {\n\t\t\tmDb.delete(TABLE_PORTFORWARDS, \"_id = ?\", new String[] {String.valueOf(pfb.getId())});\n\t\t\tmDb.setTransactionSuccessful();\n\t\t} finally {\n\t\t\tmDb.endTransaction();\n\t\t}\n\t}\n\n\tpublic int[] getColorsForScheme(int scheme) {\n\t\tint[] colors = Colors.defaults.clone();\n\n\t\tCursor c = mDb.query(TABLE_COLORS, new String[] {\n\t\t\t\t\t\tFIELD_COLOR_NUMBER, FIELD_COLOR_VALUE},\n\t\t\t\tFIELD_COLOR_SCHEME + \" = ?\",\n\t\t\t\tnew String[] {String.valueOf(scheme)},\n\t\t\t\tnull, null, null);\n\n\t\twhile (c.moveToNext()) {\n\t\t\tcolors[c.getInt(0)] = Integer.valueOf(c.getInt(1));\n\t\t}\n\n\t\tc.close();\n\n\t\treturn colors;\n\t}\n\n\tpublic void setColorForScheme(int scheme, int number, int value) {\n\t\tfinal SQLiteDatabase db;\n\n\t\tfinal String[] whereArgs = new String[] { String.valueOf(scheme), String.valueOf(number) };\n\n\t\tif (value == Colors.defaults[number]) {\n\t\t\tmDb.beginTransaction();\n\t\t\ttry {\n\t\t\t\tmDb.delete(TABLE_COLORS,\n\t\t\t\t\t\tWHERE_SCHEME_AND_COLOR, whereArgs);\n\t\t\t\tmDb.setTransactionSuccessful();\n\t\t\t} finally {\n\t\t\t\tmDb.endTransaction();\n\t\t\t}\n\t\t} else {\n\t\t\tfinal ContentValues values = new ContentValues();\n\t\t\tvalues.put(FIELD_COLOR_VALUE, value);\n\n\t\t\tmDb.beginTransaction();\n\t\t\ttry {\n\t\t\t\tfinal int rowsAffected = mDb.update(TABLE_COLORS, values,\n\t\t\t\t\t\tWHERE_SCHEME_AND_COLOR, whereArgs);\n\n\t\t\t\tif (rowsAffected == 0) {\n\t\t\t\t\tvalues.put(FIELD_COLOR_SCHEME, scheme);\n\t\t\t\t\tvalues.put(FIELD_COLOR_NUMBER, number);\n\t\t\t\t\tmDb.insert(TABLE_COLORS, null, values);\n\t\t\t\t}\n\t\t\t\tmDb.setTransactionSuccessful();\n\t\t\t} finally {\n\t\t\t\tmDb.endTransaction();\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void setGlobalColor(int number, int value) {\n\t\tsetColorForScheme(DEFAULT_COLOR_SCHEME, number, value);\n\t}\n\n\tpublic int[] getDefaultColorsForScheme(int scheme) {\n\t\tint[] colors = new int[] { DEFAULT_FG_COLOR, DEFAULT_BG_COLOR };\n\n\t\tCursor c = mDb.query(TABLE_COLOR_DEFAULTS,\n\t\t\t\tnew String[] {FIELD_COLOR_FG, FIELD_COLOR_BG},\n\t\t\t\tFIELD_COLOR_SCHEME + \" = ?\",\n\t\t\t\tnew String[] {String.valueOf(scheme)},\n\t\t\t\tnull, null, null);\n\n\t\tif (c.moveToFirst()) {\n\t\t\tcolors[0] = c.getInt(0);\n\t\t\tcolors[1] = c.getInt(1);\n\t\t}\n\n\t\tc.close();\n\n\t\treturn colors;\n\t}\n\n\tpublic int[] getGlobalDefaultColors() {\n\t\treturn getDefaultColorsForScheme(DEFAULT_COLOR_SCHEME);\n\t}\n\n\tpublic void setDefaultColorsForScheme(int scheme, int fg, int bg) {\n\t\tSQLiteDatabase db;\n\n\t\tString schemeWhere = null;\n\t\tString[] whereArgs;\n\n\t\tschemeWhere = FIELD_COLOR_SCHEME + \" = ?\";\n\t\twhereArgs = new String[] { String.valueOf(scheme) };\n\n\t\tContentValues values = new ContentValues();\n\t\tvalues.put(FIELD_COLOR_FG, fg);\n\t\tvalues.put(FIELD_COLOR_BG, bg);\n\n\t\tmDb.beginTransaction();\n\t\ttry {\n\t\t\tint rowsAffected = mDb.update(TABLE_COLOR_DEFAULTS, values,\n\t\t\t\t\tschemeWhere, whereArgs);\n\n\t\t\tif (rowsAffected == 0) {\n\t\t\t\tvalues.put(FIELD_COLOR_SCHEME, scheme);\n\t\t\t\tmDb.insert(TABLE_COLOR_DEFAULTS, null, values);\n\t\t\t}\n\t\t\tmDb.setTransactionSuccessful();\n\t\t} finally {\n\t\t\tmDb.endTransaction();\n\t\t}\n\t}\n}\n","Method after Refactoring":"/*\n * ConnectBot: simple, powerful, open-source SSH client for Android\n * Copyright 2007 Kenny Root, Jeffrey Sharkey\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.connectbot.util;\n\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\nimport org.connectbot.bean.HostBean;\nimport org.connectbot.bean.PortForwardBean;\nimport org.connectbot.data.ColorStorage;\nimport org.connectbot.data.HostStorage;\n\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteException;\nimport android.support.annotation.VisibleForTesting;\nimport android.util.Log;\n\nimport com.trilead.ssh2.KnownHosts;\n\n/**\n * Contains information about various SSH hosts, include public hostkey if known\n * from previous sessions.\n *\n * @author jsharkey\n */\npublic class HostDatabase extends RobustSQLiteOpenHelper implements HostStorage, ColorStorage {\n\n\tpublic final static String TAG = \"CB.HostDatabase\";\n\n\tpublic final static String DB_NAME = \"hosts\";\n\tpublic final static int DB_VERSION = 25;\n\n\tpublic final static String TABLE_HOSTS = \"hosts\";\n\tpublic final static String FIELD_HOST_NICKNAME = \"nickname\";\n\tpublic final static String FIELD_HOST_PROTOCOL = \"protocol\";\n\tpublic final static String FIELD_HOST_USERNAME = \"username\";\n\tpublic final static String FIELD_HOST_HOSTNAME = \"hostname\";\n\tpublic final static String FIELD_HOST_PORT = \"port\";\n\tpublic final static String FIELD_HOST_LASTCONNECT = \"lastconnect\";\n\tpublic final static String FIELD_HOST_COLOR = \"color\";\n\tpublic final static String FIELD_HOST_USEKEYS = \"usekeys\";\n\tpublic final static String FIELD_HOST_USEAUTHAGENT = \"useauthagent\";\n\tpublic final static String FIELD_HOST_POSTLOGIN = \"postlogin\";\n\tpublic final static String FIELD_HOST_PUBKEYID = \"pubkeyid\";\n\tpublic final static String FIELD_HOST_WANTSESSION = \"wantsession\";\n\tpublic final static String FIELD_HOST_DELKEY = \"delkey\";\n\tpublic final static String FIELD_HOST_FONTSIZE = \"fontsize\";\n\tpublic final static String FIELD_HOST_COMPRESSION = \"compression\";\n\tpublic final static String FIELD_HOST_ENCODING = \"encoding\";\n\tpublic final static String FIELD_HOST_STAYCONNECTED = \"stayconnected\";\n\tpublic final static String FIELD_HOST_QUICKDISCONNECT = \"quickdisconnect\";\n\n\tpublic final static String TABLE_KNOWNHOSTS = \"knownhosts\";\n\tpublic final static String FIELD_KNOWNHOSTS_HOSTID = \"hostid\";\n\tpublic final static String FIELD_KNOWNHOSTS_HOSTKEYALGO = \"hostkeyalgo\";\n\tpublic final static String FIELD_KNOWNHOSTS_HOSTKEY = \"hostkey\";\n\n\tpublic final static String TABLE_PORTFORWARDS = \"portforwards\";\n\tpublic final static String FIELD_PORTFORWARD_HOSTID = \"hostid\";\n\tpublic final static String FIELD_PORTFORWARD_NICKNAME = \"nickname\";\n\tpublic final static String FIELD_PORTFORWARD_TYPE = \"type\";\n\tpublic final static String FIELD_PORTFORWARD_SOURCEPORT = \"sourceport\";\n\tpublic final static String FIELD_PORTFORWARD_DESTADDR = \"destaddr\";\n\tpublic final static String FIELD_PORTFORWARD_DESTPORT = \"destport\";\n\n\tpublic final static String TABLE_COLORS = \"colors\";\n\tpublic final static String FIELD_COLOR_SCHEME = \"scheme\";\n\tpublic final static String FIELD_COLOR_NUMBER = \"number\";\n\tpublic final static String FIELD_COLOR_VALUE = \"value\";\n\n\tpublic final static String TABLE_COLOR_DEFAULTS = \"colorDefaults\";\n\tpublic final static String FIELD_COLOR_FG = \"fg\";\n\tpublic final static String FIELD_COLOR_BG = \"bg\";\n\n\tpublic final static int DEFAULT_FG_COLOR = 7;\n\tpublic final static int DEFAULT_BG_COLOR = 0;\n\n\tpublic final static String COLOR_RED = \"red\";\n\tpublic final static String COLOR_GREEN = \"green\";\n\tpublic final static String COLOR_BLUE = \"blue\";\n\tpublic final static String COLOR_GRAY = \"gray\";\n\n\tpublic final static String PORTFORWARD_LOCAL = \"local\";\n\tpublic final static String PORTFORWARD_REMOTE = \"remote\";\n\tpublic final static String PORTFORWARD_DYNAMIC4 = \"dynamic4\";\n\tpublic final static String PORTFORWARD_DYNAMIC5 = \"dynamic5\";\n\n\tpublic final static String DELKEY_DEL = \"del\";\n\tpublic final static String DELKEY_BACKSPACE = \"backspace\";\n\n\tpublic final static String AUTHAGENT_NO = \"no\";\n\tpublic final static String AUTHAGENT_CONFIRM = \"confirm\";\n\tpublic final static String AUTHAGENT_YES = \"yes\";\n\n\tpublic final static String ENCODING_DEFAULT = Charset.defaultCharset().name();\n\n\tpublic final static long PUBKEYID_NEVER = -2;\n\tpublic final static long PUBKEYID_ANY = -1;\n\n\tpublic static final int DEFAULT_COLOR_SCHEME = 0;\n\n\t// Table creation strings\n\tpublic static final String TABLE_HOSTS_COLUMNS = \"_id INTEGER PRIMARY KEY, \"\n\t\t\t+ FIELD_HOST_NICKNAME + \" TEXT, \"\n\t\t\t+ FIELD_HOST_PROTOCOL + \" TEXT DEFAULT 'ssh', \"\n\t\t\t+ FIELD_HOST_USERNAME + \" TEXT, \"\n\t\t\t+ FIELD_HOST_HOSTNAME + \" TEXT, \"\n\t\t\t+ FIELD_HOST_PORT + \" INTEGER, \"\n\t\t\t+ FIELD_HOST_LASTCONNECT + \" INTEGER, \"\n\t\t\t+ FIELD_HOST_COLOR + \" TEXT, \"\n\t\t\t+ FIELD_HOST_USEKEYS + \" TEXT, \"\n\t\t\t+ FIELD_HOST_USEAUTHAGENT + \" TEXT, \"\n\t\t\t+ FIELD_HOST_POSTLOGIN + \" TEXT, \"\n\t\t\t+ FIELD_HOST_PUBKEYID + \" INTEGER DEFAULT \" + PUBKEYID_ANY + \", \"\n\t\t\t+ FIELD_HOST_DELKEY + \" TEXT DEFAULT '\" + DELKEY_DEL + \"', \"\n\t\t\t+ FIELD_HOST_FONTSIZE + \" INTEGER, \"\n\t\t\t+ FIELD_HOST_WANTSESSION + \" TEXT DEFAULT '\" + Boolean.toString(true) + \"', \"\n\t\t\t+ FIELD_HOST_COMPRESSION + \" TEXT DEFAULT '\" + Boolean.toString(false) + \"', \"\n\t\t\t+ FIELD_HOST_ENCODING + \" TEXT DEFAULT '\" + ENCODING_DEFAULT + \"', \"\n\t\t\t+ FIELD_HOST_STAYCONNECTED + \" TEXT DEFAULT '\" + Boolean.toString(false) + \"', \"\n\t\t\t+ FIELD_HOST_QUICKDISCONNECT + \" TEXT DEFAULT '\" + Boolean.toString(false) + \"'\";\n\n\tpublic static final String CREATE_TABLE_HOSTS = \"CREATE TABLE \" + TABLE_HOSTS\n\t\t\t+ \" (\" + TABLE_HOSTS_COLUMNS + \")\";\n\n\tpublic static final String CREATE_TABLE_COLOR_DEFAULTS =\n\t\t\"CREATE TABLE \" + TABLE_COLOR_DEFAULTS\n\t\t+ \" (\" + FIELD_COLOR_SCHEME + \" INTEGER NOT NULL, \"\n\t\t+ FIELD_COLOR_FG + \" INTEGER NOT NULL DEFAULT \" + DEFAULT_FG_COLOR + \", \"\n\t\t+ FIELD_COLOR_BG + \" INTEGER NOT NULL DEFAULT \" + DEFAULT_BG_COLOR + \")\";\n\n\tpublic static final String CREATE_TABLE_COLOR_DEFAULTS_INDEX =\n\t\t\"CREATE INDEX \" + TABLE_COLOR_DEFAULTS + FIELD_COLOR_SCHEME + \"index ON \"\n\t\t+ TABLE_COLOR_DEFAULTS + \" (\" + FIELD_COLOR_SCHEME + \");\";\n\n\tprivate static final String WHERE_SCHEME_AND_COLOR = FIELD_COLOR_SCHEME + \" = ? AND \"\n\t\t\t+ FIELD_COLOR_NUMBER + \" = ?\";\n\n\tstatic {\n\t\taddTableName(TABLE_HOSTS);\n\t\taddTableName(TABLE_KNOWNHOSTS);\n\t\taddIndexName(TABLE_KNOWNHOSTS + FIELD_KNOWNHOSTS_HOSTID + \"index\");\n\t\taddTableName(TABLE_PORTFORWARDS);\n\t\taddIndexName(TABLE_PORTFORWARDS + FIELD_PORTFORWARD_HOSTID + \"index\");\n\t\taddTableName(TABLE_COLORS);\n\t\taddIndexName(TABLE_COLORS + FIELD_COLOR_SCHEME + \"index\");\n\t\taddTableName(TABLE_COLOR_DEFAULTS);\n\t\taddIndexName(TABLE_COLOR_DEFAULTS + FIELD_COLOR_SCHEME + \"index\");\n\t}\n\n\t/** Used during upgrades from DB version 23 to 24. */\n\tprivate final float displayDensity;\n\n\tprivate static final Object sInstanceLock = new Object();\n\n\tprivate static HostDatabase sInstance;\n\n\tprivate final SQLiteDatabase mDb;\n\n\tpublic static HostDatabase get(Context context) {\n\t\tsynchronized (sInstanceLock) {\n\t\t\tif (sInstance != null) {\n\t\t\t\treturn sInstance;\n\t\t\t}\n\n\t\t\tsInstance = new HostDatabase(context.getApplicationContext());\n\t\t\treturn sInstance;\n\t\t}\n\t}\n\n\tprivate HostDatabase(Context context) {\n\t\tthis(context, DB_NAME);\n\t}\n\n\tprivate HostDatabase(Context context, String dbName) {\n\t\tsuper(context, dbName, null, DB_VERSION);\n\n\t\tthis.displayDensity = context.getResources().getDisplayMetrics().density;\n\t\tmDb = getWritableDatabase();\n\t}\n\n\t@Override\n\tpublic void onCreate(SQLiteDatabase db) {\n\t\tsuper.onCreate(db);\n\n\t\tcreateTables(db);\n\t}\n\n\tprivate void createTables(SQLiteDatabase db) {\n\t\tdb.execSQL(CREATE_TABLE_HOSTS);\n\n\t\tdb.execSQL(\"CREATE TABLE \" + TABLE_KNOWNHOSTS\n\t\t\t\t+ \" (_id INTEGER PRIMARY KEY, \"\n\t\t\t\t+ FIELD_KNOWNHOSTS_HOSTID + \" INTEGER, \"\n\t\t\t\t+ FIELD_KNOWNHOSTS_HOSTKEYALGO + \" TEXT, \"\n\t\t\t\t+ FIELD_KNOWNHOSTS_HOSTKEY + \" BLOB)\");\n\n\t\tdb.execSQL(\"CREATE INDEX \" + TABLE_KNOWNHOSTS + FIELD_KNOWNHOSTS_HOSTID + \"index ON \"\n\t\t\t\t+ TABLE_KNOWNHOSTS + \" (\" + FIELD_KNOWNHOSTS_HOSTID + \");\");\n\n\t\tdb.execSQL(\"CREATE TABLE \" + TABLE_PORTFORWARDS\n\t\t\t\t+ \" (_id INTEGER PRIMARY KEY, \"\n\t\t\t\t+ FIELD_PORTFORWARD_HOSTID + \" INTEGER, \"\n\t\t\t\t+ FIELD_PORTFORWARD_NICKNAME + \" TEXT, \"\n\t\t\t\t+ FIELD_PORTFORWARD_TYPE + \" TEXT NOT NULL DEFAULT \" + PORTFORWARD_LOCAL + \", \"\n\t\t\t\t+ FIELD_PORTFORWARD_SOURCEPORT + \" INTEGER NOT NULL DEFAULT 8080, \"\n\t\t\t\t+ FIELD_PORTFORWARD_DESTADDR + \" TEXT, \"\n\t\t\t\t+ FIELD_PORTFORWARD_DESTPORT + \" TEXT)\");\n\n\t\tdb.execSQL(\"CREATE INDEX \" + TABLE_PORTFORWARDS + FIELD_PORTFORWARD_HOSTID + \"index ON \"\n\t\t\t\t+ TABLE_PORTFORWARDS + \" (\" + FIELD_PORTFORWARD_HOSTID + \");\");\n\n\t\tdb.execSQL(\"CREATE TABLE \" + TABLE_COLORS\n\t\t\t\t+ \" (_id INTEGER PRIMARY KEY, \"\n\t\t\t\t+ FIELD_COLOR_NUMBER + \" INTEGER, \"\n\t\t\t\t+ FIELD_COLOR_VALUE + \" INTEGER, \"\n\t\t\t\t+ FIELD_COLOR_SCHEME + \" INTEGER)\");\n\n\t\tdb.execSQL(\"CREATE INDEX \" + TABLE_COLORS + FIELD_COLOR_SCHEME + \"index ON \"\n\t\t\t\t+ TABLE_COLORS + \" (\" + FIELD_COLOR_SCHEME + \");\");\n\n\t\tdb.execSQL(CREATE_TABLE_COLOR_DEFAULTS);\n\t\tdb.execSQL(CREATE_TABLE_COLOR_DEFAULTS_INDEX);\n\t}\n\n\t@VisibleForTesting\n\tpublic void resetDatabase() {\n\t\ttry {\n\t\t\tmDb.beginTransaction();\n\n\t\t\tmDb.execSQL(\"DROP TABLE IF EXISTS \" + TABLE_HOSTS);\n\t\t\tmDb.execSQL(\"DROP TABLE IF EXISTS \" + TABLE_KNOWNHOSTS);\n\t\t\tmDb.execSQL(\"DROP TABLE IF EXISTS \" + TABLE_PORTFORWARDS);\n\t\t\tmDb.execSQL(\"DROP TABLE IF EXISTS \" + TABLE_COLORS);\n\t\t\tmDb.execSQL(\"DROP TABLE IF EXISTS \" + TABLE_COLOR_DEFAULTS);\n\n\t\t\tcreateTables(mDb);\n\n\t\t\tmDb.setTransactionSuccessful();\n\t\t} finally {\n\t\t\tmDb.endTransaction();\n\t\t}\n\t}\n\n\t@VisibleForTesting\n\tpublic static void resetInMemoryInstance(Context context) {\n\t\tget(context).resetDatabase();\n\t}\n\n\t@Override\n\tpublic void onRobustUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) throws SQLiteException {\n\t\t// Versions of the database before the Android Market release will be\n\t\t// shot without warning.\n\t\tif (oldVersion <= 9) {\n\t\t\tdb.execSQL(\"DROP TABLE IF EXISTS \" + TABLE_HOSTS);\n\t\t\tonCreate(db);\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (oldVersion) {\n\t\tcase 10:\n\t\t\tdb.execSQL(\"ALTER TABLE \" + TABLE_HOSTS\n\t\t\t\t\t+ \" ADD COLUMN \" + FIELD_HOST_PUBKEYID + \" INTEGER DEFAULT \" + PUBKEYID_ANY);\n\t\tcase 11:\n\t\t\tdb.execSQL(\"CREATE TABLE \" + TABLE_PORTFORWARDS\n\t\t\t\t\t+ \" (_id INTEGER PRIMARY KEY, \"\n\t\t\t\t\t+ FIELD_PORTFORWARD_HOSTID + \" INTEGER, \"\n\t\t\t\t\t+ FIELD_PORTFORWARD_NICKNAME + \" TEXT, \"\n\t\t\t\t\t+ FIELD_PORTFORWARD_TYPE + \" TEXT NOT NULL DEFAULT \" + PORTFORWARD_LOCAL + \", \"\n\t\t\t\t\t+ FIELD_PORTFORWARD_SOURCEPORT + \" INTEGER NOT NULL DEFAULT 8080, \"\n\t\t\t\t\t+ FIELD_PORTFORWARD_DESTADDR + \" TEXT, \"\n\t\t\t\t\t+ FIELD_PORTFORWARD_DESTPORT + \" INTEGER)\");\n\t\tcase 12:\n\t\t\tdb.execSQL(\"ALTER TABLE \" + TABLE_HOSTS\n\t\t\t\t\t+ \" ADD COLUMN \" + FIELD_HOST_WANTSESSION + \" TEXT DEFAULT '\" + Boolean.toString(true) + \"'\");\n\t\tcase 13:\n\t\t\tdb.execSQL(\"ALTER TABLE \" + TABLE_HOSTS\n\t\t\t\t\t+ \" ADD COLUMN \" + FIELD_HOST_COMPRESSION + \" TEXT DEFAULT '\" + Boolean.toString(false) + \"'\");\n\t\tcase 14:\n\t\t\tdb.execSQL(\"ALTER TABLE \" + TABLE_HOSTS\n\t\t\t\t\t+ \" ADD COLUMN \" + FIELD_HOST_ENCODING + \" TEXT DEFAULT '\" + ENCODING_DEFAULT + \"'\");\n\t\tcase 15:\n\t\t\tdb.execSQL(\"ALTER TABLE \" + TABLE_HOSTS\n\t\t\t\t\t+ \" ADD COLUMN \" + FIELD_HOST_PROTOCOL + \" TEXT DEFAULT 'ssh'\");\n\t\tcase 16:\n\t\t\tdb.execSQL(\"ALTER TABLE \" + TABLE_HOSTS\n\t\t\t\t\t+ \" ADD COLUMN \" + FIELD_HOST_DELKEY + \" TEXT DEFAULT '\" + DELKEY_DEL + \"'\");\n\t\tcase 17:\n\t\t\tdb.execSQL(\"CREATE INDEX \" + TABLE_PORTFORWARDS + FIELD_PORTFORWARD_HOSTID + \"index ON \"\n\t\t\t\t\t+ TABLE_PORTFORWARDS + \" (\" + FIELD_PORTFORWARD_HOSTID + \");\");\n\n\t\t\t// Add colors\n\t\t\tdb.execSQL(\"CREATE TABLE \" + TABLE_COLORS\n\t\t\t\t\t+ \" (_id INTEGER PRIMARY KEY, \"\n\t\t\t\t\t+ FIELD_COLOR_NUMBER + \" INTEGER, \"\n\t\t\t\t\t+ FIELD_COLOR_VALUE + \" INTEGER, \"\n\t\t\t\t\t+ FIELD_COLOR_SCHEME + \" INTEGER)\");\n\t\t\tdb.execSQL(\"CREATE INDEX \" + TABLE_COLORS + FIELD_COLOR_SCHEME + \"index ON \"\n\t\t\t\t\t+ TABLE_COLORS + \" (\" + FIELD_COLOR_SCHEME + \");\");\n\t\tcase 18:\n\t\t\tdb.execSQL(\"ALTER TABLE \" + TABLE_HOSTS\n\t\t\t\t\t+ \" ADD COLUMN \" + FIELD_HOST_USEAUTHAGENT + \" TEXT DEFAULT '\" + AUTHAGENT_NO + \"'\");\n\t\tcase 19:\n\t\t\tdb.execSQL(\"ALTER TABLE \" + TABLE_HOSTS\n\t\t\t\t\t+ \" ADD COLUMN \" + FIELD_HOST_STAYCONNECTED + \" TEXT\");\n\t\tcase 20:\n\t\t\tdb.execSQL(\"ALTER TABLE \" + TABLE_HOSTS\n\t\t\t\t\t+ \" ADD COLUMN \" + FIELD_HOST_FONTSIZE + \" INTEGER\");\n\t\tcase 21:\n\t\t\tdb.execSQL(\"DROP TABLE IF EXISTS \" + TABLE_COLOR_DEFAULTS);\n\t\t\tdb.execSQL(CREATE_TABLE_COLOR_DEFAULTS);\n\t\t\tdb.execSQL(CREATE_TABLE_COLOR_DEFAULTS_INDEX);\n\t\tcase 22:\n\t\t\tdb.execSQL(\"ALTER TABLE \" + TABLE_HOSTS\n\t\t\t\t\t+ \" ADD COLUMN \" + FIELD_HOST_QUICKDISCONNECT + \" TEXT DEFAULT '\" + Boolean.toString(false) + \"'\");\n\t\tcase 23:\n\t\t\tdb.execSQL(\"UPDATE \" + TABLE_HOSTS\n\t\t\t\t\t+ \" SET \" + FIELD_HOST_FONTSIZE + \" = \" + FIELD_HOST_FONTSIZE + \" / \" + displayDensity);\n\t\tcase 24:\n\t\t\t// Move all the existing known hostkeys into their own table.\n\t\t\tdb.execSQL(\"DROP TABLE IF EXISTS \" + TABLE_KNOWNHOSTS);\n\t\t\tdb.execSQL(\"CREATE TABLE \" + TABLE_KNOWNHOSTS\n\t\t\t\t\t+ \" (_id INTEGER PRIMARY KEY, \"\n\t\t\t\t\t+ FIELD_KNOWNHOSTS_HOSTID + \" INTEGER, \"\n\t\t\t\t\t+ FIELD_KNOWNHOSTS_HOSTKEYALGO + \" TEXT, \"\n\t\t\t\t\t+ FIELD_KNOWNHOSTS_HOSTKEY + \" BLOB)\");\n\t\t\tdb.execSQL(\"INSERT INTO \" + TABLE_KNOWNHOSTS + \" (\"\n\t\t\t\t\t+ FIELD_KNOWNHOSTS_HOSTID + \", \"\n\t\t\t\t\t+ FIELD_KNOWNHOSTS_HOSTKEYALGO + \", \"\n\t\t\t\t\t+ FIELD_KNOWNHOSTS_HOSTKEY + \") \"\n\t\t\t\t\t+ \"SELECT _id, \"\n\t\t\t\t\t+ FIELD_KNOWNHOSTS_HOSTKEYALGO + \", \"\n\t\t\t\t\t+ FIELD_KNOWNHOSTS_HOSTKEY\n\t\t\t\t\t+ \" FROM \" + TABLE_HOSTS);\n\t\t\t// Work around SQLite not supporting dropping columns\n\t\t\tdb.execSQL(\"DROP TABLE IF EXISTS \" + TABLE_HOSTS + \"_upgrade\");\n\t\t\tdb.execSQL(\"CREATE TABLE \" + TABLE_HOSTS + \"_upgrade (\" + TABLE_HOSTS_COLUMNS + \")\");\n\t\t\tdb.execSQL(\"INSERT INTO \" + TABLE_HOSTS + \"_upgrade SELECT _id, \"\n\t\t\t\t\t+ FIELD_HOST_NICKNAME + \", \"\n\t\t\t\t\t+ FIELD_HOST_PROTOCOL + \", \"\n\t\t\t\t\t+ FIELD_HOST_USERNAME + \", \"\n\t\t\t\t\t+ FIELD_HOST_HOSTNAME + \", \"\n\t\t\t\t\t+ FIELD_HOST_PORT + \", \"\n\t\t\t\t\t+ FIELD_HOST_LASTCONNECT + \", \"\n\t\t\t\t\t+ FIELD_HOST_COLOR + \", \"\n\t\t\t\t\t+ FIELD_HOST_USEKEYS + \", \"\n\t\t\t\t\t+ FIELD_HOST_USEAUTHAGENT + \", \"\n\t\t\t\t\t+ FIELD_HOST_POSTLOGIN + \", \"\n\t\t\t\t\t+ FIELD_HOST_PUBKEYID + \", \"\n\t\t\t\t\t+ FIELD_HOST_DELKEY + \", \"\n\t\t\t\t\t+ FIELD_HOST_FONTSIZE + \", \"\n\t\t\t\t\t+ FIELD_HOST_WANTSESSION + \", \"\n\t\t\t\t\t+ FIELD_HOST_COMPRESSION + \", \"\n\t\t\t\t\t+ FIELD_HOST_ENCODING + \", \"\n\t\t\t\t\t+ FIELD_HOST_STAYCONNECTED + \", \"\n\t\t\t\t\t+ FIELD_HOST_QUICKDISCONNECT\n\t\t\t\t\t+ \" FROM \" + TABLE_HOSTS);\n\t\t\tdb.execSQL(\"DROP TABLE \" + TABLE_HOSTS);\n\t\t\tdb.execSQL(\"ALTER TABLE \" + TABLE_HOSTS + \"_upgrade RENAME TO \" + TABLE_HOSTS);\n\t\t}\n\t}\n\n\t/**\n\t * Touch a specific host to update its \"last connected\" field.\n\t * @param host host to update\n\t */\n\tpublic void touchHost(HostBean host) {\n\t\tlong now = System.currentTimeMillis() / 1000;\n\n\t\tContentValues values = new ContentValues();\n\t\tvalues.put(FIELD_HOST_LASTCONNECT, now);\n\n\t\tmDb.beginTransaction();\n\t\ttry {\n\t\t\tmDb.update(TABLE_HOSTS, values, \"_id = ?\", new String[] {String.valueOf(host.getId())});\n\t\t\tmDb.setTransactionSuccessful();\n\t\t} finally {\n\t\t\tmDb.endTransaction();\n\t\t}\n\t}\n\n\t/**\n\t * Create a new or update an existing {@code host}.\n\t */\n\tpublic HostBean saveHost(HostBean host) {\n\t\tlong id = host.getId();\n\n\t\tmDb.beginTransaction();\n\t\ttry {\n\t\t\tif (id == -1) {\n\t\t\t\tid = mDb.insert(TABLE_HOSTS, null, host.getValues());\n\t\t\t} else {\n\t\t\t\tmDb.update(TABLE_HOSTS, host.getValues(), \"_id = ?\", new String[] {String.valueOf(id)});\n\t\t\t}\n\t\t\tmDb.setTransactionSuccessful();\n\t\t} finally {\n\t\t\tmDb.endTransaction();\n\t\t}\n\n\t\thost.setId(id);\n\n\t\treturn host;\n\t}\n\n\t/**\n\t * Delete a specific host by its <code>_id<\/code> value.\n\t */\n\tpublic void deleteHost(HostBean host) {\n\t\tif (host.getId() < 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tString[] hostIdArg = new String[] {String.valueOf(host.getId())};\n\t\tmDb.beginTransaction();\n\t\ttry {\n\t\t\tmDb.delete(TABLE_KNOWNHOSTS, FIELD_KNOWNHOSTS_HOSTID + \" = ?\", hostIdArg);\n\t\t\tmDb.delete(TABLE_HOSTS, \"_id = ?\", hostIdArg);\n\t\t\tmDb.setTransactionSuccessful();\n\t\t} finally {\n\t\t\tmDb.endTransaction();\n\t\t}\n\t}\n\n\t/**\n\t * Return a cursor that contains information about all known hosts.\n\t * @param sortColors If true, sort by color, otherwise sort by nickname.\n\t */\n\tpublic List<HostBean> getHosts(boolean sortColors) {\n\t\tString sortField = sortColors ? FIELD_HOST_COLOR : FIELD_HOST_NICKNAME;\n\t\tList<HostBean> hosts;\n\n\t\tCursor c = mDb.query(TABLE_HOSTS, null, null, null, null, null, sortField + \" ASC\");\n\n\t\thosts = createHostBeans(c);\n\n\t\tc.close();\n\n\t\treturn hosts;\n\t}\n\n\t/**\n\t * @param c cursor to read from\n\t */\n\tprivate List<HostBean> createHostBeans(Cursor c) {\n\t\tList<HostBean> hosts = new LinkedList<HostBean>();\n\n\t\tfinal int COL_ID = c.getColumnIndexOrThrow(\"_id\"),\n\t\t\tCOL_NICKNAME = c.getColumnIndexOrThrow(FIELD_HOST_NICKNAME),\n\t\t\tCOL_PROTOCOL = c.getColumnIndexOrThrow(FIELD_HOST_PROTOCOL),\n\t\t\tCOL_USERNAME = c.getColumnIndexOrThrow(FIELD_HOST_USERNAME),\n\t\t\tCOL_HOSTNAME = c.getColumnIndexOrThrow(FIELD_HOST_HOSTNAME),\n\t\t\tCOL_PORT = c.getColumnIndexOrThrow(FIELD_HOST_PORT),\n\t\t\tCOL_LASTCONNECT = c.getColumnIndexOrThrow(FIELD_HOST_LASTCONNECT),\n\t\t\tCOL_COLOR = c.getColumnIndexOrThrow(FIELD_HOST_COLOR),\n\t\t\tCOL_USEKEYS = c.getColumnIndexOrThrow(FIELD_HOST_USEKEYS),\n\t\t\tCOL_USEAUTHAGENT = c.getColumnIndexOrThrow(FIELD_HOST_USEAUTHAGENT),\n\t\t\tCOL_POSTLOGIN = c.getColumnIndexOrThrow(FIELD_HOST_POSTLOGIN),\n\t\t\tCOL_PUBKEYID = c.getColumnIndexOrThrow(FIELD_HOST_PUBKEYID),\n\t\t\tCOL_WANTSESSION = c.getColumnIndexOrThrow(FIELD_HOST_WANTSESSION),\n\t\t\tCOL_DELKEY = c.getColumnIndexOrThrow(FIELD_HOST_DELKEY),\n\t\t\tCOL_FONTSIZE = c.getColumnIndexOrThrow(FIELD_HOST_FONTSIZE),\n\t\t\tCOL_COMPRESSION = c.getColumnIndexOrThrow(FIELD_HOST_COMPRESSION),\n\t\t\tCOL_ENCODING = c.getColumnIndexOrThrow(FIELD_HOST_ENCODING),\n\t\t\tCOL_STAYCONNECTED = c.getColumnIndexOrThrow(FIELD_HOST_STAYCONNECTED),\n\t\t\tCOL_QUICKDISCONNECT = c.getColumnIndexOrThrow(FIELD_HOST_QUICKDISCONNECT);\n\n\t\twhile (c.moveToNext()) {\n\t\t\tHostBean host = new HostBean();\n\n\t\t\thost.setId(c.getLong(COL_ID));\n\t\t\thost.setNickname(c.getString(COL_NICKNAME));\n\t\t\thost.setProtocol(c.getString(COL_PROTOCOL));\n\t\t\thost.setUsername(c.getString(COL_USERNAME));\n\t\t\thost.setHostname(c.getString(COL_HOSTNAME));\n\t\t\thost.setPort(c.getInt(COL_PORT));\n\t\t\thost.setLastConnect(c.getLong(COL_LASTCONNECT));\n\t\t\thost.setColor(c.getString(COL_COLOR));\n\t\t\thost.setUseKeys(Boolean.valueOf(c.getString(COL_USEKEYS)));\n\t\t\thost.setUseAuthAgent(c.getString(COL_USEAUTHAGENT));\n\t\t\thost.setPostLogin(c.getString(COL_POSTLOGIN));\n\t\t\thost.setPubkeyId(c.getLong(COL_PUBKEYID));\n\t\t\thost.setWantSession(Boolean.valueOf(c.getString(COL_WANTSESSION)));\n\t\t\thost.setDelKey(c.getString(COL_DELKEY));\n\t\t\thost.setFontSize(c.getInt(COL_FONTSIZE));\n\t\t\thost.setCompression(Boolean.valueOf(c.getString(COL_COMPRESSION)));\n\t\t\thost.setEncoding(c.getString(COL_ENCODING));\n\t\t\thost.setStayConnected(Boolean.valueOf(c.getString(COL_STAYCONNECTED)));\n\t\t\thost.setQuickDisconnect(Boolean.valueOf(c.getString(COL_QUICKDISCONNECT)));\n\n\t\t\thosts.add(host);\n\t\t}\n\n\t\treturn hosts;\n\t}\n\n\t/**\n\t * @param c cursor with zero or more hosts\n\t * @return the first host from the cursor or {@code null} if none.\n\t */\n\tprivate HostBean getFirstHostBean(Cursor c) {\n\t\tHostBean host = null;\n\n\t\tList<HostBean> hosts = createHostBeans(c);\n\t\tif (hosts.size() > 0)\n\t\t\thost = hosts.get(0);\n\n\t\tc.close();\n\n\t\treturn host;\n\t}\n\n\t/**\n\t * @param selection parameters describing the desired host\n\t * @return host matching selection or {@code null}.\n\t */\n\tpublic HostBean findHost(Map<String, String> selection) {\n\t\tStringBuilder selectionBuilder = new StringBuilder();\n\n\t\tIterator<Entry<String, String>> i = selection.entrySet().iterator();\n\n\t\tList<String> selectionValuesList = new LinkedList<String>();\n\t\tint n = 0;\n\t\twhile (i.hasNext()) {\n\t\t\tEntry<String, String> entry = i.next();\n\n\t\t\tif (entry.getValue() == null)\n\t\t\t\tcontinue;\n\n\t\t\tif (n++ > 0)\n\t\t\t\tselectionBuilder.append(\" AND \");\n\n\t\t\tselectionBuilder.append(entry.getKey())\n\t\t\t\t.append(\" = ?\");\n\n\t\t\tselectionValuesList.add(entry.getValue());\n\t\t}\n\n\t\tString selectionValues[] = new String[selectionValuesList.size()];\n\t\tselectionValuesList.toArray(selectionValues);\n\n\t\tCursor c = mDb.query(TABLE_HOSTS, null,\n\t\t\t\tselectionBuilder.toString(),\n\t\t\t\tselectionValues,\n\t\t\t\tnull, null, null);\n\n\t\tHostBean host = getFirstHostBean(c);\n\n\t\treturn host;\n\t}\n\n\t/**\n\t * @param hostId host id for the host\n\t * @return host matching the hostId or {@code null} if none match\n\t */\n\tpublic HostBean findHostById(long hostId) {\n\t\tCursor c = mDb.query(TABLE_HOSTS, null,\n\t\t\t\t\"_id = ?\", new String[] {String.valueOf(hostId)},\n\t\t\t\tnull, null, null);\n\n\t\treturn getFirstHostBean(c);\n\t}\n\n\t/**\n\t * Record the given hostkey into database under this nickname.\n\t * @param hostname hostname to match\n\t * @param port port to match\n\t * @param hostkeyalgo algorithm for host key\n\t * @param hostkey the bytes of the host key itself\n\t */\n\tpublic void saveKnownHost(String hostname, int port, String hostkeyalgo, byte[] hostkey) {\n\t\tHashMap<String, String> selection = new HashMap<>();\n\t\tselection.put(FIELD_HOST_HOSTNAME, hostname);\n\t\tselection.put(FIELD_HOST_PORT, String.valueOf(port));\n\t\tHostBean hostBean = findHost(selection);\n\n\t\tif (hostBean == null) {\n\t\t\tLog.e(TAG, \"Tried to save known host for \" + hostname + \":\" + port\n\t\t\t\t\t+ \" it doesn't exist in the database\");\n\t\t\treturn;\n\t\t}\n\n\t\tContentValues values = new ContentValues();\n\t\tvalues.put(FIELD_KNOWNHOSTS_HOSTKEYALGO, hostkeyalgo);\n\t\tvalues.put(FIELD_KNOWNHOSTS_HOSTKEY, hostkey);\n\t\tvalues.put(FIELD_KNOWNHOSTS_HOSTID, hostBean.getId());\n\n\t\tmDb.beginTransaction();\n\t\ttry {\n\t\t\tmDb.delete(TABLE_KNOWNHOSTS, FIELD_KNOWNHOSTS_HOSTID + \" = ? AND \"\n\t\t\t\t\t\t\t+ FIELD_KNOWNHOSTS_HOSTKEYALGO + \" = ?\",\n\t\t\t\t\tnew String[] {String.valueOf(hostBean.getId()), hostkeyalgo});\n\t\t\tmDb.insert(TABLE_KNOWNHOSTS, null, values);\n\t\t\tmDb.setTransactionSuccessful();\n\t\t} finally {\n\t\t\tmDb.endTransaction();\n\t\t}\n\t\tLog.d(TAG, String.format(\"Finished saving hostkey information for '%s:%d' algo %s\",\n\t\t\t\thostname, port, hostkeyalgo));\n\t}\n\n\t@Override\n\tpublic void removeKnownHost(String host, int port, String serverHostKeyAlgorithm, byte[] serverHostKey) {\n\t\tthrow new UnsupportedOperationException(\"removeKnownHost is not implemented\");\n\t}\n\n\t/**\n\t * Build list of known hosts for Trilead library.\n\t * @return\n\t */\n\tpublic KnownHosts getKnownHosts() {\n\t\tKnownHosts known = new KnownHosts();\n\n\t\tCursor c = mDb.query(TABLE_HOSTS + \" LEFT OUTER JOIN \" + TABLE_KNOWNHOSTS\n\t\t\t\t\t\t+ \" ON \" + TABLE_HOSTS + \"._id = \"\n\t\t\t\t\t\t+ TABLE_KNOWNHOSTS + \".\" + FIELD_KNOWNHOSTS_HOSTID,\n\t\t\t\tnew String[] {FIELD_HOST_HOSTNAME, FIELD_HOST_PORT, FIELD_KNOWNHOSTS_HOSTKEYALGO,\n\t\t\t\t\t\tFIELD_KNOWNHOSTS_HOSTKEY},\n\t\t\t\tnull, null, null, null, null);\n\n\t\tif (c != null) {\n\t\t\tint COL_HOSTNAME = c.getColumnIndexOrThrow(FIELD_HOST_HOSTNAME),\n\t\t\t\t\tCOL_PORT = c.getColumnIndexOrThrow(FIELD_HOST_PORT),\n\t\t\t\t\tCOL_HOSTKEYALGO = c.getColumnIndexOrThrow(FIELD_KNOWNHOSTS_HOSTKEYALGO),\n\t\t\t\t\tCOL_HOSTKEY = c.getColumnIndexOrThrow(FIELD_KNOWNHOSTS_HOSTKEY);\n\n\t\t\twhile (c.moveToNext()) {\n\t\t\t\tString hostname = c.getString(COL_HOSTNAME);\n\t\t\t\tString hostkeyalgo = c.getString(COL_HOSTKEYALGO);\n\t\t\t\tint port = c.getInt(COL_PORT);\n\t\t\t\tbyte[] hostkey = c.getBlob(COL_HOSTKEY);\n\n\t\t\t\tif (hostkeyalgo == null || hostkeyalgo.length() == 0) continue;\n\t\t\t\tif (hostkey == null || hostkey.length == 0) continue;\n\n\t\t\t\ttry {\n\t\t\t\t\tknown.addHostkey(new String[] {String.format(\"%s:%d\", hostname, port)}, hostkeyalgo, hostkey);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tLog.e(TAG, \"Problem while adding a known host from database\", e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc.close();\n\t\t}\n\n\t\treturn known;\n\t}\n\n\t@Override\n\tpublic List<String> getHostKeyAlgorithmsForHost(String hostname, int port) {\n\t\tHashMap<String, String> selection = new HashMap<>();\n\t\tselection.put(FIELD_HOST_HOSTNAME, hostname);\n\t\tselection.put(FIELD_HOST_PORT, String.valueOf(port));\n\t\tHostBean hostBean = findHost(selection);\n\n\t\tif (hostBean == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tArrayList<String> knownAlgorithms = new ArrayList<>();\n\n\t\tCursor c = mDb.query(TABLE_KNOWNHOSTS, new String[] {FIELD_KNOWNHOSTS_HOSTKEYALGO},\n\t\t\t\tFIELD_KNOWNHOSTS_HOSTID + \" = ?\",\n\t\t\t\tnew String[] {String.valueOf(hostBean.getId())}, null, null, null);\n\n\t\tif (c != null) {\n\t\t\tint COL_ALGO = c.getColumnIndexOrThrow(FIELD_KNOWNHOSTS_HOSTKEYALGO);\n\n\t\t\twhile (c.moveToNext()) {\n\t\t\t\tString keyAlgo = c.getString(COL_ALGO);\n\t\t\t\tif (keyAlgo != null) {\n\t\t\t\t\tknownAlgorithms.add(keyAlgo);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc.close();\n\t\t}\n\n\t\treturn knownAlgorithms;\n\t}\n\n\t/**\n\t * Unset any hosts using a pubkey ID that has been deleted.\n\t * @param pubkeyId\n\t */\n\tpublic void stopUsingPubkey(long pubkeyId) {\n\t\tif (pubkeyId < 0) return;\n\n\t\tContentValues values = new ContentValues();\n\t\tvalues.put(FIELD_HOST_PUBKEYID, PUBKEYID_ANY);\n\n\t\tmDb.beginTransaction();\n\t\ttry {\n\t\t\tmDb.update(TABLE_HOSTS, values, FIELD_HOST_PUBKEYID + \" = ?\", new String[] {String.valueOf(pubkeyId)});\n\t\t\tmDb.setTransactionSuccessful();\n\t\t} finally {\n\t\t\tmDb.endTransaction();\n\t\t}\n\n\t\tLog.d(TAG, String.format(\"Set all hosts using pubkey id %d to -1\", pubkeyId));\n\t}\n\n\t/*\n\t * Methods for dealing with port forwards attached to hosts\n\t */\n\n\t/**\n\t * Returns a list of all the port forwards associated with a particular host ID.\n\t * @param host the host for which we want the port forward list\n\t * @return port forwards associated with host ID or empty list if no match\n\t */\n\tpublic List<PortForwardBean> getPortForwardsForHost(HostBean host) {\n\t\tList<PortForwardBean> portForwards = new LinkedList<PortForwardBean>();\n\t\tif (host == null) {\n\t\t\treturn portForwards;\n\t\t}\n\n\t\tCursor c = mDb.query(TABLE_PORTFORWARDS, new String[] {\n\t\t\t\t\t\t\"_id\", FIELD_PORTFORWARD_NICKNAME, FIELD_PORTFORWARD_TYPE, FIELD_PORTFORWARD_SOURCEPORT,\n\t\t\t\t\t\tFIELD_PORTFORWARD_DESTADDR, FIELD_PORTFORWARD_DESTPORT},\n\t\t\t\tFIELD_PORTFORWARD_HOSTID + \" = ?\", new String[] {String.valueOf(host.getId())},\n\t\t\t\tnull, null, null);\n\n\t\twhile (c.moveToNext()) {\n\t\t\tPortForwardBean pfb = new PortForwardBean(\n\t\t\t\t\tc.getInt(0),\n\t\t\t\t\thost.getId(),\n\t\t\t\t\tc.getString(1),\n\t\t\t\t\tc.getString(2),\n\t\t\t\t\tc.getInt(3),\n\t\t\t\t\tc.getString(4),\n\t\t\t\t\tc.getInt(5));\n\t\t\tportForwards.add(pfb);\n\t\t}\n\n\t\tc.close();\n\n\t\treturn portForwards;\n\t}\n\n\t/**\n\t * Update the parameters of a port forward in the database.\n\t * @param pfb {@link PortForwardBean} to save\n\t * @return true on success\n\t */\n\tpublic boolean savePortForward(PortForwardBean pfb) {\n\t\tmDb.beginTransaction();\n\t\ttry {\n\t\t\tif (pfb.getId() < 0) {\n\t\t\t\tlong addedId = mDb.insert(TABLE_PORTFORWARDS, null, pfb.getValues());\n\t\t\t\tif (addedId == -1) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tpfb.setId(addedId);\n\t\t\t} else {\n\t\t\t\tif (mDb.update(TABLE_PORTFORWARDS, pfb.getValues(), \"_id = ?\", new String[] {String.valueOf(pfb.getId())}) <= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmDb.setTransactionSuccessful();\n\t\t\treturn true;\n\t\t} finally {\n\t\t\tmDb.endTransaction();\n\t\t}\n\t}\n\n\t/**\n\t * Deletes a port forward from the database.\n\t * @param pfb {@link PortForwardBean} to delete\n\t */\n\tpublic void deletePortForward(PortForwardBean pfb) {\n\t\tif (pfb.getId() < 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tmDb.beginTransaction();\n\t\ttry {\n\t\t\tmDb.delete(TABLE_PORTFORWARDS, \"_id = ?\", new String[] {String.valueOf(pfb.getId())});\n\t\t\tmDb.setTransactionSuccessful();\n\t\t} finally {\n\t\t\tmDb.endTransaction();\n\t\t}\n\t}\n\n\tpublic int[] getColorsForScheme(int scheme) {\n\t\tint[] colors = Colors.defaults.clone();\n\n\t\tCursor c = mDb.query(TABLE_COLORS, new String[] {\n\t\t\t\t\t\tFIELD_COLOR_NUMBER, FIELD_COLOR_VALUE},\n\t\t\t\tFIELD_COLOR_SCHEME + \" = ?\",\n\t\t\t\tnew String[] {String.valueOf(scheme)},\n\t\t\t\tnull, null, null);\n\n\t\twhile (c.moveToNext()) {\n\t\t\tcolors[c.getInt(0)] = Integer.valueOf(c.getInt(1));\n\t\t}\n\n\t\tc.close();\n\n\t\treturn colors;\n\t}\n\n\tpublic void setColorForScheme(int scheme, int number, int value) {\n\t\tfinal SQLiteDatabase db;\n\n\t\tfinal String[] whereArgs = new String[] { String.valueOf(scheme), String.valueOf(number) };\n\n\t\tif (value == Colors.defaults[number]) {\n\t\t\tmDb.beginTransaction();\n\t\t\ttry {\n\t\t\t\tmDb.delete(TABLE_COLORS,\n\t\t\t\t\t\tWHERE_SCHEME_AND_COLOR, whereArgs);\n\t\t\t\tmDb.setTransactionSuccessful();\n\t\t\t} finally {\n\t\t\t\tmDb.endTransaction();\n\t\t\t}\n\t\t} else {\n\t\t\tfinal ContentValues values = new ContentValues();\n\t\t\tvalues.put(FIELD_COLOR_VALUE, value);\n\n\t\t\tmDb.beginTransaction();\n\t\t\ttry {\n\t\t\t\tfinal int rowsAffected = mDb.update(TABLE_COLORS, values,\n\t\t\t\t\t\tWHERE_SCHEME_AND_COLOR, whereArgs);\n\n\t\t\t\tif (rowsAffected == 0) {\n\t\t\t\t\tvalues.put(FIELD_COLOR_SCHEME, scheme);\n\t\t\t\t\tvalues.put(FIELD_COLOR_NUMBER, number);\n\t\t\t\t\tmDb.insert(TABLE_COLORS, null, values);\n\t\t\t\t}\n\t\t\t\tmDb.setTransactionSuccessful();\n\t\t\t} finally {\n\t\t\t\tmDb.endTransaction();\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void setGlobalColor(int number, int value) {\n\t\tsetColorForScheme(DEFAULT_COLOR_SCHEME, number, value);\n\t}\n\n\tpublic int[] getDefaultColorsForScheme(int scheme) {\n\t\tint[] colors = new int[] { DEFAULT_FG_COLOR, DEFAULT_BG_COLOR };\n\n\t\tCursor c = mDb.query(TABLE_COLOR_DEFAULTS,\n\t\t\t\tnew String[] {FIELD_COLOR_FG, FIELD_COLOR_BG},\n\t\t\t\tFIELD_COLOR_SCHEME + \" = ?\",\n\t\t\t\tnew String[] {String.valueOf(scheme)},\n\t\t\t\tnull, null, null);\n\n\t\tif (c.moveToFirst()) {\n\t\t\tcolors[0] = c.getInt(0);\n\t\t\tcolors[1] = c.getInt(1);\n\t\t}\n\n\t\tc.close();\n\n\t\treturn colors;\n\t}\n\n\tpublic int[] getGlobalDefaultColors() {\n\t\treturn getDefaultColorsForScheme(DEFAULT_COLOR_SCHEME);\n\t}\n\n\tpublic void setDefaultColorsForScheme(int scheme, int fg, int bg) {\n\t\tSQLiteDatabase db;\n\n\t\tString schemeWhere = null;\n\t\tString[] whereArgs;\n\n\t\tschemeWhere = FIELD_COLOR_SCHEME + \" = ?\";\n\t\twhereArgs = new String[] { String.valueOf(scheme) };\n\n\t\tContentValues values = new ContentValues();\n\t\tvalues.put(FIELD_COLOR_FG, fg);\n\t\tvalues.put(FIELD_COLOR_BG, bg);\n\n\t\tmDb.beginTransaction();\n\t\ttry {\n\t\t\tint rowsAffected = mDb.update(TABLE_COLOR_DEFAULTS, values,\n\t\t\t\t\tschemeWhere, whereArgs);\n\n\t\t\tif (rowsAffected == 0) {\n\t\t\t\tvalues.put(FIELD_COLOR_SCHEME, scheme);\n\t\t\t\tmDb.insert(TABLE_COLOR_DEFAULTS, null, values);\n\t\t\t}\n\t\t\tmDb.setTransactionSuccessful();\n\t\t} finally {\n\t\t\tmDb.endTransaction();\n\t\t}\n\t}\n}\n","lineNo":437}
{"Smelly Sample":"/*\n * ConnectBot: simple, powerful, open-source SSH client for Android\n * Copyright 2015 Kenny Root, Jeffrey Sharkey\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.connectbot;\n\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\n\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.ServiceConnection;\nimport android.content.res.TypedArray;\nimport android.os.AsyncTask;\nimport android.os.IBinder;\nimport android.support.annotation.Nullable;\nimport android.support.v4.app.FragmentManager;\nimport android.support.v7.app.AppCompatActivity;\nimport android.os.Bundle;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\n\nimport org.connectbot.bean.HostBean;\nimport org.connectbot.service.TerminalBridge;\nimport org.connectbot.service.TerminalManager;\nimport org.connectbot.util.HostDatabase;\nimport org.connectbot.util.PubkeyDatabase;\n\npublic class EditHostActivity extends AppCompatActivity implements HostEditorFragment.Listener {\n\n\tprivate static final String EXTRA_EXISTING_HOST_ID = \"org.connectbot.existing_host_id\";\n\tprivate static final long NO_HOST_ID = -1;\n\n\tprivate HostDatabase mHostDb;\n\tprivate PubkeyDatabase mPubkeyDb;\n\tprivate ServiceConnection mTerminalConnection;\n\tprivate HostBean mHost;\n\tprivate TerminalBridge mBridge;\n\tprivate boolean mIsCreating;\n\tprivate MenuItem mSaveHostButton;\n\n\tpublic static Intent createIntentForExistingHost(Context context, long existingHostId) {\n\t\tIntent i = new Intent(context, EditHostActivity.class);\n\t\ti.putExtra(EXTRA_EXISTING_HOST_ID, existingHostId);\n\t\treturn i;\n\t}\n\n\tpublic static Intent createIntentForNewHost(Context context) {\n\t\treturn createIntentForExistingHost(context, NO_HOST_ID);\n\t}\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\n\t\tmHostDb = HostDatabase.get(this);\n\t\tmPubkeyDb = PubkeyDatabase.get(this);\n\n\t\tmTerminalConnection = new ServiceConnection() {\n\t\t\tpublic void onServiceConnected(ComponentName className, IBinder service) {\n\t\t\t\tTerminalManager bound = ((TerminalManager.TerminalBinder) service).getService();\n\t\t\t\tmBridge = bound.getConnectedBridge(mHost);\n\t\t\t}\n\n\t\t\tpublic void onServiceDisconnected(ComponentName name) {\n\t\t\t\tmBridge = null;\n\t\t\t}\n\t\t};\n\n\t\tlong hostId = getIntent().getLongExtra(EXTRA_EXISTING_HOST_ID, NO_HOST_ID);\n\t\tmIsCreating = hostId == NO_HOST_ID;\n\t\tmHost = mIsCreating ? null : mHostDb.findHostById(hostId);\n\n\t\t// Note that the lists must be explicitly declared as ArrayLists because Bundle only accepts\n\t\t// ArrayLists of Strings.\n\t\tArrayList<String> pubkeyNames = new ArrayList<>();\n\t\tArrayList<String> pubkeyValues = new ArrayList<>();\n\n\t\t// First, add default pubkey names and values (e.g., \"use any\" and \"don't use any\").\n\t\tTypedArray defaultPubkeyNames = getResources().obtainTypedArray(R.array.list_pubkeyids);\n\t\tfor (int i = 0; i < defaultPubkeyNames.length(); i++) {\n\t\t\tpubkeyNames.add(defaultPubkeyNames.getString(i));\n\t\t}\n\t\tTypedArray defaultPubkeyValues = getResources().obtainTypedArray(R.array.list_pubkeyids_value);\n\t\tfor (int i = 0; i < defaultPubkeyValues.length(); i++) {\n\t\t\tpubkeyValues.add(defaultPubkeyValues.getString(i));\n\t\t}\n\n\t\t// Now, add pubkeys which have been added by the user.\n\t\tfor (CharSequence cs : mPubkeyDb.allValues(PubkeyDatabase.FIELD_PUBKEY_NICKNAME)) {\n\t\t\tpubkeyNames.add(cs.toString());\n\t\t}\n\t\tfor (CharSequence cs : mPubkeyDb.allValues(\"_id\")) {\n\t\t\tpubkeyValues.add(cs.toString());\n\t\t}\n\n\t\tsetContentView(R.layout.activity_edit_host);\n\t\tFragmentManager fm = getSupportFragmentManager();\n\t\tHostEditorFragment fragment =\n\t\t\t\t(HostEditorFragment) fm.findFragmentById(R.id.fragment_container);\n\n\t\tif (fragment == null) {\n\t\t\tfragment = HostEditorFragment.newInstance(mHost, pubkeyNames, pubkeyValues);\n\t\t\tgetSupportFragmentManager().beginTransaction()\n\t\t\t\t\t.add(R.id.fragment_container, fragment).commit();\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu) {\n\t\tMenuInflater inflater = getMenuInflater();\n\t\tinflater.inflate(\n\t\t\t\tmIsCreating ? R.menu.edit_host_activity_add_menu : R.menu.edit_host_activity_edit_menu,\n\t\t\t\tmenu);\n\n\t\tmSaveHostButton = menu.getItem(0);\n\n\t\t// If the new host is being created, it can't be added until modifications have been made.\n\t\tmSaveHostButton.setEnabled(!mIsCreating);\n\n\t\treturn super.onCreateOptionsMenu(menu);\n\t}\n\n\t@Override\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tswitch (item.getItemId()) {\n\t\t\tcase R.id.save:\n\t\t\t\tmHostDb.saveHost(mHost);\n\n\t\t\t\tif (mBridge != null) {\n\t\t\t\t\t// If the console is already open, apply the new encoding now. If the console\n\t\t\t\t\t// was not yet opened, this will be applied automatically when it is opened.\n\t\t\t\t\tmBridge.setCharset(mHost.getEncoding());\n\t\t\t\t}\n\t\t\t\tfinish();\n\t\t\t\treturn true;\n\t\t\tdefault:\n\t\t\t\treturn super.onOptionsItemSelected(item);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void onStart() {\n\t\tsuper.onStart();\n\n\t\tbindService(new Intent(\n\t\t\t\tthis, TerminalManager.class), mTerminalConnection, Context.BIND_AUTO_CREATE);\n\n\t\tfinal HostEditorFragment fragment = (HostEditorFragment) getSupportFragmentManager().\n\t\t\t\tfindFragmentById(R.id.fragment_container);\n\t\tif (CharsetHolder.isInitialized()) {\n\t\t\tfragment.setCharsetData(CharsetHolder.getCharsetData());\n\t\t} else {\n\t\t\t// If CharsetHolder is uninitialized, initialize it in an AsyncTask. This is necessary\n\t\t\t// because Charset must touch the disk, which cannot be performed on the UI thread.\n\t\t\tnew AsyncTask<Void, Void, Void>() {\n\n\t\t\t\t@Override\n\t\t\t\tprotected Void doInBackground(Void... unused) {\n\t\t\t\t\tCharsetHolder.initialize();\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tprotected void onPostExecute(Void unused) {\n\t\t\t\t\tfragment.setCharsetData(CharsetHolder.getCharsetData());\n\t\t\t\t}\n\t\t\t}.execute();\n\t\t}\n\t}\n\n\t@Override\n\tpublic void onStop() {\n\t\tsuper.onStop();\n\n\t\tunbindService(mTerminalConnection);\n\t}\n\n\t@Override\n\tpublic void onValidHostConfigured(HostBean host) {\n\t\tmHost = host;\n\t\tif (mSaveHostButton != null)\n\t\t\tmSaveHostButton.setEnabled(true);\n\t}\n\n\t@Override\n\tpublic void onHostInvalidated() {\n\t\tmHost = null;\n\t\tif (mSaveHostButton != null)\n\t\t\tmSaveHostButton.setEnabled(false);\n\t}\n\n\t// Private static class used to generate a list of available Charsets. Note that this class\n\t// must not be initialized by the UI thread because it blocks on disk access.\n\tprivate static class CharsetHolder {\n\t\tprivate static boolean mInitialized = false;\n\n\t\t// Map from Charset display name to Charset value (i.e., unique ID).\n\t\tprivate static Map<String, String> mData;\n\n\t\tpublic static Map<String, String> getCharsetData() {\n\t\t\tif (mData== null)\n\t\t\t\tinitialize();\n\n\t\t\treturn mData;\n\t\t}\n\n\t\tprivate synchronized static void initialize() {\n\t\t\tif (mInitialized)\n\t\t\t\treturn;\n\n\t\t\tmData = new HashMap<>();\n\t\t\tfor (Map.Entry<String, Charset> entry : Charset.availableCharsets().entrySet()) {\n\t\t\t\tCharset c = entry.getValue();\n\t\t\t\tif (c.canEncode() && c.isRegistered()) {\n\t\t\t\t\tString key = entry.getKey();\n\t\t\t\t\tif (key.startsWith(\"cp\")) {\n\t\t\t\t\t\t// Custom CP437 charset changes.\n\t\t\t\t\t\tmData.put(\"CP437\", \"CP437\");\n\t\t\t\t\t}\n\t\t\t\t\tmData.put(c.displayName(), entry.getKey());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmInitialized = true;\n\t\t}\n\n\t\tpublic static boolean isInitialized() {\n\t\t\treturn mInitialized;\n\t\t}\n\t}\n}\n","Method after Refactoring":"/*\n * ConnectBot: simple, powerful, open-source SSH client for Android\n * Copyright 2015 Kenny Root, Jeffrey Sharkey\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.connectbot;\n\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.ServiceConnection;\nimport android.content.res.TypedArray;\nimport android.os.AsyncTask;\nimport android.os.IBinder;\nimport android.support.v4.app.FragmentManager;\nimport android.support.v7.app.AppCompatActivity;\nimport android.os.Bundle;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\n\nimport org.connectbot.bean.HostBean;\nimport org.connectbot.service.TerminalBridge;\nimport org.connectbot.service.TerminalManager;\nimport org.connectbot.util.HostDatabase;\nimport org.connectbot.util.PubkeyDatabase;\n\npublic class EditHostActivity extends AppCompatActivity implements HostEditorFragment.Listener {\n\n\tprivate static final String EXTRA_EXISTING_HOST_ID = \"org.connectbot.existing_host_id\";\n\tprivate static final long NO_HOST_ID = -1;\n\n\tprivate HostDatabase mHostDb;\n\tprivate PubkeyDatabase mPubkeyDb;\n\tprivate ServiceConnection mTerminalConnection;\n\tprivate HostBean mHost;\n\tprivate TerminalBridge mBridge;\n\tprivate boolean mIsCreating;\n\tprivate MenuItem mSaveHostButton;\n\n\tpublic static Intent createIntentForExistingHost(Context context, long existingHostId) {\n\t\tIntent i = new Intent(context, EditHostActivity.class);\n\t\ti.putExtra(EXTRA_EXISTING_HOST_ID, existingHostId);\n\t\treturn i;\n\t}\n\n\tpublic static Intent createIntentForNewHost(Context context) {\n\t\treturn createIntentForExistingHost(context, NO_HOST_ID);\n\t}\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\n\t\tmHostDb = HostDatabase.get(this);\n\t\tmPubkeyDb = PubkeyDatabase.get(this);\n\n\t\tmTerminalConnection = new ServiceConnection() {\n\t\t\tpublic void onServiceConnected(ComponentName className, IBinder service) {\n\t\t\t\tTerminalManager bound = ((TerminalManager.TerminalBinder) service).getService();\n\t\t\t\tmBridge = bound.getConnectedBridge(mHost);\n\t\t\t}\n\n\t\t\tpublic void onServiceDisconnected(ComponentName name) {\n\t\t\t\tmBridge = null;\n\t\t\t}\n\t\t};\n\n\t\tlong hostId = getIntent().getLongExtra(EXTRA_EXISTING_HOST_ID, NO_HOST_ID);\n\t\tmIsCreating = hostId == NO_HOST_ID;\n\t\tmHost = mIsCreating ? null : mHostDb.findHostById(hostId);\n\n\t\t// Note that the lists must be explicitly declared as ArrayLists because Bundle only accepts\n\t\t// ArrayLists of Strings.\n\t\tArrayList<String> pubkeyNames = new ArrayList<>();\n\t\tArrayList<String> pubkeyValues = new ArrayList<>();\n\n\t\t// First, add default pubkey names and values (e.g., \"use any\" and \"don't use any\").\n\t\tTypedArray defaultPubkeyNames = getResources().obtainTypedArray(R.array.list_pubkeyids);\n\t\tfor (int i = 0; i < defaultPubkeyNames.length(); i++) {\n\t\t\tpubkeyNames.add(defaultPubkeyNames.getString(i));\n\t\t}\n\t\tTypedArray defaultPubkeyValues = getResources().obtainTypedArray(R.array.list_pubkeyids_value);\n\t\tfor (int i = 0; i < defaultPubkeyValues.length(); i++) {\n\t\t\tpubkeyValues.add(defaultPubkeyValues.getString(i));\n\t\t}\n\n\t\t// Now, add pubkeys which have been added by the user.\n\t\tfor (CharSequence cs : mPubkeyDb.allValues(PubkeyDatabase.FIELD_PUBKEY_NICKNAME)) {\n\t\t\tpubkeyNames.add(cs.toString());\n\t\t}\n\t\tfor (CharSequence cs : mPubkeyDb.allValues(\"_id\")) {\n\t\t\tpubkeyValues.add(cs.toString());\n\t\t}\n\n\t\tsetContentView(R.layout.activity_edit_host);\n\t\tFragmentManager fm = getSupportFragmentManager();\n\t\tHostEditorFragment fragment =\n\t\t\t\t(HostEditorFragment) fm.findFragmentById(R.id.fragment_container);\n\n\t\tif (fragment == null) {\n\t\t\tfragment = HostEditorFragment.newInstance(mHost, pubkeyNames, pubkeyValues);\n\t\t\tgetSupportFragmentManager().beginTransaction()\n\t\t\t\t\t.add(R.id.fragment_container, fragment).commit();\n\t\t}\n\n\t\tdefaultPubkeyNames.recycle();\n\t\tdefaultPubkeyValues.recycle();\n\t}\n\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu) {\n\t\tMenuInflater inflater = getMenuInflater();\n\t\tinflater.inflate(\n\t\t\t\tmIsCreating ? R.menu.edit_host_activity_add_menu : R.menu.edit_host_activity_edit_menu,\n\t\t\t\tmenu);\n\n\t\tmSaveHostButton = menu.getItem(0);\n\n\t\t// If the new host is being created, it can't be added until modifications have been made.\n\t\tmSaveHostButton.setEnabled(!mIsCreating);\n\n\t\treturn super.onCreateOptionsMenu(menu);\n\t}\n\n\t@Override\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tswitch (item.getItemId()) {\n\t\t\tcase R.id.save:\n\t\t\t\tmHostDb.saveHost(mHost);\n\n\t\t\t\tif (mBridge != null) {\n\t\t\t\t\t// If the console is already open, apply the new encoding now. If the console\n\t\t\t\t\t// was not yet opened, this will be applied automatically when it is opened.\n\t\t\t\t\tmBridge.setCharset(mHost.getEncoding());\n\t\t\t\t}\n\t\t\t\tfinish();\n\t\t\t\treturn true;\n\t\t\tdefault:\n\t\t\t\treturn super.onOptionsItemSelected(item);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void onStart() {\n\t\tsuper.onStart();\n\n\t\tbindService(new Intent(\n\t\t\t\tthis, TerminalManager.class), mTerminalConnection, Context.BIND_AUTO_CREATE);\n\n\t\tfinal HostEditorFragment fragment = (HostEditorFragment) getSupportFragmentManager().\n\t\t\t\tfindFragmentById(R.id.fragment_container);\n\t\tif (CharsetHolder.isInitialized()) {\n\t\t\tfragment.setCharsetData(CharsetHolder.getCharsetData());\n\t\t} else {\n\t\t\t// If CharsetHolder is uninitialized, initialize it in an AsyncTask. This is necessary\n\t\t\t// because Charset must touch the disk, which cannot be performed on the UI thread.\n\t\t\tAsyncTask<Void, Void, Void> charsetTask = new AsyncTask<Void, Void, Void>() {\n\n\t\t\t\t@Override\n\t\t\t\tprotected Void doInBackground(Void... unused) {\n\t\t\t\t\tCharsetHolder.initialize();\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tprotected void onPostExecute(Void unused) {\n\t\t\t\t\tfragment.setCharsetData(CharsetHolder.getCharsetData());\n\t\t\t\t}\n\t\t\t};\n\t\t\tcharsetTask.execute();\n\t\t}\n\t}\n\n\t@Override\n\tpublic void onStop() {\n\t\tsuper.onStop();\n\n\t\tunbindService(mTerminalConnection);\n\t}\n\n\t@Override\n\tpublic void onValidHostConfigured(HostBean host) {\n\t\tmHost = host;\n\t\tif (mSaveHostButton != null)\n\t\t\tmSaveHostButton.setEnabled(true);\n\t}\n\n\t@Override\n\tpublic void onHostInvalidated() {\n\t\tmHost = null;\n\t\tif (mSaveHostButton != null)\n\t\t\tmSaveHostButton.setEnabled(false);\n\t}\n\n\t// Private static class used to generate a list of available Charsets. Note that this class\n\t// must not be initialized by the UI thread because it blocks on disk access.\n\tprivate static class CharsetHolder {\n\t\tprivate static boolean mInitialized = false;\n\n\t\t// Map from Charset display name to Charset value (i.e., unique ID).\n\t\tprivate static Map<String, String> mData;\n\n\t\tpublic static Map<String, String> getCharsetData() {\n\t\t\tif (mData == null)\n\t\t\t\tinitialize();\n\n\t\t\treturn mData;\n\t\t}\n\n\t\tprivate synchronized static void initialize() {\n\t\t\tif (mInitialized)\n\t\t\t\treturn;\n\n\t\t\tmData = new HashMap<>();\n\t\t\tfor (Map.Entry<String, Charset> entry : Charset.availableCharsets().entrySet()) {\n\t\t\t\tCharset c = entry.getValue();\n\t\t\t\tif (c.canEncode() && c.isRegistered()) {\n\t\t\t\t\tString key = entry.getKey();\n\t\t\t\t\tif (key.startsWith(\"cp\")) {\n\t\t\t\t\t\t// Custom CP437 charset changes.\n\t\t\t\t\t\tmData.put(\"CP437\", \"CP437\");\n\t\t\t\t\t}\n\t\t\t\t\tmData.put(c.displayName(), entry.getKey());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmInitialized = true;\n\t\t}\n\n\t\tpublic static boolean isInitialized() {\n\t\t\treturn mInitialized;\n\t\t}\n\t}\n}\n","lineNo":175}
{"Smelly Sample":"/*\n * ConnectBot: simple, powerful, open-source SSH client for Android\n * Copyright 2007 Kenny Root, Jeffrey Sharkey\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.connectbot;\n\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.connectbot.bean.SelectionArea;\nimport org.connectbot.service.FontSizeChangedListener;\nimport org.connectbot.service.TerminalBridge;\nimport org.connectbot.service.TerminalKeyListener;\nimport org.connectbot.util.TerminalViewPager;\n\nimport android.annotation.TargetApi;\nimport android.app.Activity;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.pm.ResolveInfo;\nimport android.database.Cursor;\nimport android.graphics.Canvas;\nimport android.graphics.Color;\nimport android.graphics.Matrix;\nimport android.graphics.Paint;\nimport android.graphics.Path;\nimport android.graphics.PixelXorXfermode;\nimport android.graphics.RectF;\nimport android.graphics.Typeface;\nimport android.net.Uri;\nimport android.os.AsyncTask;\nimport android.os.Build;\nimport android.support.v4.view.MotionEventCompat;\nimport android.text.ClipboardManager;\nimport android.view.ActionMode;\nimport android.view.GestureDetector;\nimport android.view.InputDevice;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.MotionEvent;\nimport android.view.ViewGroup.LayoutParams;\nimport android.view.accessibility.AccessibilityEvent;\nimport android.view.accessibility.AccessibilityManager;\nimport android.view.inputmethod.BaseInputConnection;\nimport android.view.inputmethod.EditorInfo;\nimport android.view.inputmethod.InputConnection;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport de.mud.terminal.VDUBuffer;\nimport de.mud.terminal.vt320;\n\n/**\n * User interface {@link TextView} for showing a TerminalBridge in an\n * {@link android.app.Activity}. Handles drawing bitmap updates and passing keystrokes down\n * to terminal.\n *\n * On Honeycomb devices and above (>= APIv11), a TextView with transparent text (which is identical\n * to the bitmap) is drawn above the bitmap. This TextView exists to allow the user to\n * select and copy text.\n *\n * @author jsharkey\n */\npublic class TerminalView extends TextView implements FontSizeChangedListener {\n\n\tprivate final Context context;\n\tpublic final TerminalBridge bridge;\n\n\tprivate final TerminalViewPager viewPager;\n\tprivate GestureDetector gestureDetector;\n\n\tprivate ClipboardManager clipboard;\n\tprivate ActionMode selectionActionMode = null;\n\tprivate String currentSelection = \"\";\n\n\t// These are only used for pre-Honeycomb copying.\n\tprivate int lastTouchedRow, lastTouchedCol;\n\n\tprivate final Paint paint;\n\tprivate final Paint cursorPaint;\n\tprivate final Paint cursorStrokePaint;\n\n\t// Cursor paints to distinguish modes\n\tprivate Path ctrlCursor, altCursor, shiftCursor;\n\tprivate RectF tempSrc, tempDst;\n\tprivate Matrix scaleMatrix;\n\tprivate static final Matrix.ScaleToFit scaleType = Matrix.ScaleToFit.FILL;\n\n\tprivate Toast notification = null;\n\tprivate String lastNotification = null;\n\tprivate volatile boolean notifications = true;\n\n\t// Related to Accessibility Features\n\tprivate boolean mAccessibilityInitialized = false;\n\tprivate boolean mAccessibilityActive = true;\n\tprivate Object[] mAccessibilityLock = new Object[0];\n\tprivate StringBuffer mAccessibilityBuffer;\n\tprivate Pattern mControlCodes = null;\n\tprivate Matcher mCodeMatcher = null;\n\tprivate AccessibilityEventSender mEventSender = null;\n\n\tprivate static final String BACKSPACE_CODE = \"\\\\x08\\\\x1b\\\\[K\";\n\tprivate static final String CONTROL_CODE_PATTERN = \"\\\\x1b\\\\[K[^m]+[m|:]\";\n\n\tprivate static final int ACCESSIBILITY_EVENT_THRESHOLD = 1000;\n\tprivate static final String SCREENREADER_INTENT_ACTION = \"android.accessibilityservice.AccessibilityService\";\n\tprivate static final String SCREENREADER_INTENT_CATEGORY = \"android.accessibilityservice.category.FEEDBACK_SPOKEN\";\n\n\tpublic TerminalView(Context context, TerminalBridge bridge, TerminalViewPager pager) {\n\t\tsuper(context);\n\n\t\tthis.context = context;\n\t\tthis.bridge = bridge;\n\t\tthis.viewPager = pager;\n\n\t\tsetLayoutParams(new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT));\n\t\tsetFocusable(true);\n\t\tsetFocusableInTouchMode(true);\n\n\t\tpaint = new Paint();\n\n\t\tcursorPaint = new Paint();\n\t\tcursorPaint.setColor(bridge.color[bridge.defaultFg]);\n\t\tcursorPaint.setXfermode(new PixelXorXfermode(bridge.color[bridge.defaultBg]));\n\t\tcursorPaint.setAntiAlias(true);\n\n\t\tcursorStrokePaint = new Paint(cursorPaint);\n\t\tcursorStrokePaint.setStrokeWidth(0.1f);\n\t\tcursorStrokePaint.setStyle(Paint.Style.STROKE);\n\n\t\t/*\n\t\t * Set up our cursor indicators on a 1x1 Path object which we can later\n\t\t * transform to our character width and height\n\t\t */\n\t\t// TODO make this into a resource somehow\n\t\tshiftCursor = new Path();\n\t\tshiftCursor.lineTo(0.5f, 0.33f);\n\t\tshiftCursor.lineTo(1.0f, 0.0f);\n\n\t\taltCursor = new Path();\n\t\taltCursor.moveTo(0.0f, 1.0f);\n\t\taltCursor.lineTo(0.5f, 0.66f);\n\t\taltCursor.lineTo(1.0f, 1.0f);\n\n\t\tctrlCursor = new Path();\n\t\tctrlCursor.moveTo(0.0f, 0.25f);\n\t\tctrlCursor.lineTo(1.0f, 0.5f);\n\t\tctrlCursor.lineTo(0.0f, 0.75f);\n\n\t\t// For creating the transform when the terminal resizes\n\t\ttempSrc = new RectF();\n\t\ttempSrc.set(0.0f, 0.0f, 1.0f, 1.0f);\n\t\ttempDst = new RectF();\n\t\tscaleMatrix = new Matrix();\n\n\t\tbridge.addFontSizeChangedListener(this);\n\t\tbridge.parentChanged(this);\n\n\t\t// connect our view up to the bridge\n\t\tsetOnKeyListener(bridge.getKeyHandler());\n\n\t\tmAccessibilityBuffer = new StringBuffer();\n\n\t\t// Enable accessibility features if a screen reader is active.\n\t\tnew AccessibilityStateTester().execute((Void) null);\n\n\t\tclipboard = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE);\n\n\t\tsetTextColor(Color.TRANSPARENT);\n\t\tsetTypeface(Typeface.MONOSPACE);\n\t\tonFontSizeChanged(bridge.getFontSize());\n\n\t\t// Allow selection of and copying text for Honeycomb and above devices.\n\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {\n\t\t\tsetTextIsSelectable(true);\n\t\t\tsetCustomSelectionActionModeCallback(new TextSelectionActionModeCallback());\n\t\t}\n\n\t\tgestureDetector = new GestureDetector(context, new GestureDetector.SimpleOnGestureListener() {\n\t\t\tprivate TerminalBridge bridge = TerminalView.this.bridge;\n\t\t\tprivate float totalY = 0;\n\n\t\t\t@Override\n\t\t\tpublic boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {\n\t\t\t\t// if releasing then reset total scroll\n\t\t\t\tif (e2.getAction() == MotionEvent.ACTION_UP) {\n\t\t\t\t\ttotalY = 0;\n\t\t\t\t}\n\n\t\t\t\ttotalY += distanceY;\n\t\t\t\tfinal int moved = (int) (totalY / bridge.charHeight);\n\n\t\t\t\tif (moved != 0) {\n\t\t\t\t\tint base = bridge.buffer.getWindowBase();\n\t\t\t\t\tbridge.buffer.setWindowBase(base + moved);\n\t\t\t\t\ttotalY = 0;\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean onSingleTapConfirmed(MotionEvent e) {\n\t\t\t\tviewPager.performClick();\n\t\t\t\treturn super.onSingleTapConfirmed(e);\n\t\t\t}\n\t\t});\n\t}\n\n\t@TargetApi(11)\n\tprivate void closeSelectionActionMode() {\n\t\tif (selectionActionMode != null) {\n\t\t\tselectionActionMode.finish();\n\t\t\tselectionActionMode = null;\n\t\t}\n\t}\n\n\tpublic void copyCurrentSelectionToClipboard() {\n\t\tClipboardManager clipboard =\n\t\t\t\t(ClipboardManager) TerminalView.this.context.getSystemService(Context.CLIPBOARD_SERVICE);\n\t\tif (currentSelection.length() != 0) {\n\t\t\tclipboard.setText(currentSelection);\n\t\t}\n\n\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {\n\t\t\tcloseSelectionActionMode();\n\t\t}\n\t}\n\n\t@Override\n\tprotected void onSelectionChanged(int selStart, int selEnd) {\n\t\tif (selStart <= selEnd) {\n\t\t\tcurrentSelection = getText().toString().substring(selStart, selEnd);\n\t\t}\n\t\tsuper.onSelectionChanged(selStart, selEnd);\n\t}\n\n\t@Override\n\tpublic boolean onTouchEvent(MotionEvent event) {\n\t\tif (event.getAction() == MotionEvent.ACTION_DOWN) {\n\t\t\t// Selection may be beginning. Sync the TextView with the buffer.\n\t\t\trefreshTextFromBuffer();\n\t\t}\n\n\t\t// Mouse input is treated differently:\n\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH &&\n\t\t\t\tMotionEventCompat.getSource(event) == InputDevice.SOURCE_MOUSE) {\n\t\t\tif (onMouseEvent(event, bridge)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tviewPager.setPagingEnabled(true);\n\t\t} else if (gestureDetector != null) {\n\t\t\t// The gesture detector should not be called if touch event was from mouse.\n\t\t\tgestureDetector.onTouchEvent(event);\n\t\t}\n\n\t\t// Old version of copying, only for pre-Honeycomb.\n\t\tif (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB) {\n\t\t\t// when copying, highlight the area\n\t\t\tif (bridge.isSelectingForCopy()) {\n\t\t\t\tSelectionArea area = bridge.getSelectionArea();\n\t\t\t\tint row = (int) Math.floor(event.getY() / bridge.charHeight);\n\t\t\t\tint col = (int) Math.floor(event.getX() / bridge.charWidth);\n\n\t\t\t\tswitch (event.getAction()) {\n\t\t\t\tcase MotionEvent.ACTION_DOWN:\n\t\t\t\t\t// recording starting area\n\t\t\t\t\tviewPager.setPagingEnabled(false);\n\t\t\t\t\tif (area.isSelectingOrigin()) {\n\t\t\t\t\t\tarea.setRow(row);\n\t\t\t\t\t\tarea.setColumn(col);\n\t\t\t\t\t\tlastTouchedRow = row;\n\t\t\t\t\t\tlastTouchedCol = col;\n\t\t\t\t\t\tbridge.redraw();\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\tcase MotionEvent.ACTION_MOVE:\n\t\t\t\t\t\t\t/* ignore when user hasn't moved since last time so\n\t\t\t\t\t\t\t * we can fine-tune with directional pad\n\t\t\t\t\t\t\t */\n\t\t\t\t\tif (row == lastTouchedRow && col == lastTouchedCol)\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t// if the user moves, start the selection for other corner\n\t\t\t\t\tarea.finishSelectingOrigin();\n\n\t\t\t\t\t// update selected area\n\t\t\t\t\tarea.setRow(row);\n\t\t\t\t\tarea.setColumn(col);\n\t\t\t\t\tlastTouchedRow = row;\n\t\t\t\t\tlastTouchedCol = col;\n\t\t\t\t\tbridge.redraw();\n\t\t\t\t\treturn true;\n\t\t\t\tcase MotionEvent.ACTION_UP:\n\t\t\t\t\t\t\t/* If they didn't move their finger, maybe they meant to\n\t\t\t\t\t\t\t * select the rest of the text with the directional pad.\n\t\t\t\t\t\t\t */\n\t\t\t\t\tif (area.getLeft() == area.getRight() &&\n\t\t\t\t\t\t\tarea.getTop() == area.getBottom()) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\t// copy selected area to clipboard\n\t\t\t\t\tString copiedText = area.copyFrom(bridge.buffer);\n\n\t\t\t\t\tclipboard.setText(copiedText);\n\t\t\t\t\tToast.makeText(\n\t\t\t\t\t\tcontext,\n\t\t\t\t\t\tcontext.getString(R.string.console_copy_done, copiedText.length()),\n\t\t\t\t\t\tToast.LENGTH_LONG).show();\n\n\t\t\t\t\t// fall through to clear state\n\n\t\t\t\tcase MotionEvent.ACTION_CANCEL:\n\t\t\t\t\t// make sure we clear any highlighted area\n\t\t\t\t\tarea.reset();\n\t\t\t\t\tbridge.setSelectingForCopy(false);\n\t\t\t\t\tbridge.redraw();\n\t\t\t\t\tviewPager.setPagingEnabled(true);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\tsuper.onTouchEvent(event);\n\n\t\treturn true;\n\t}\n\n\t@TargetApi(11)\n\tprivate class TextSelectionActionModeCallback implements ActionMode.Callback {\n\t\tprivate static final int COPY = 0;\n\t\tprivate static final int PASTE = 1;\n\n\t\t@Override\n\t\tpublic boolean onPrepareActionMode(ActionMode mode, Menu menu) {\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean onCreateActionMode(ActionMode mode, Menu menu) {\n\t\t\tTerminalView.this.selectionActionMode = mode;\n\n\t\t\tmenu.clear();\n\n\t\t\tmenu.add(0, COPY, 0, R.string.console_menu_copy)\n\t\t\t\t\t.setIcon(R.drawable.ic_action_copy)\n\t\t\t\t\t.setShowAsAction(MenuItem.SHOW_AS_ACTION_WITH_TEXT | MenuItem.SHOW_AS_ACTION_IF_ROOM);\n\t\t\tmenu.add(0, PASTE, 1, R.string.console_menu_paste)\n\t\t\t\t\t.setIcon(R.drawable.ic_action_paste)\n\t\t\t\t\t.setShowAsAction(MenuItem.SHOW_AS_ACTION_WITH_TEXT | MenuItem.SHOW_AS_ACTION_IF_ROOM);\n\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean onActionItemClicked(ActionMode mode, MenuItem item) {\n\t\t\tswitch (item.getItemId()) {\n\t\t\tcase COPY:\n\t\t\t\tcopyCurrentSelectionToClipboard();\n\t\t\t\treturn true;\n\t\t\tcase PASTE:\n\t\t\t\tString clip = clipboard.getText().toString();\n\t\t\t\tTerminalView.this.bridge.injectString(clip);\n\t\t\t\tmode.finish();\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic void onDestroyActionMode(ActionMode mode) {\n\t\t}\n\t}\n\n\t/**\n\t * @param event\n\t * @param bridge\n\t * @return True if the event is handled.\n\t */\n\t@TargetApi(14)\n\tprivate boolean onMouseEvent(MotionEvent event, TerminalBridge bridge) {\n\t\tint row = (int) Math.floor(event.getY() / bridge.charHeight);\n\t\tint col = (int) Math.floor(event.getX() / bridge.charWidth);\n\t\tint meta = event.getMetaState();\n\t\tboolean shiftOn = (meta & KeyEvent.META_SHIFT_ON) != 0;\n\t\tboolean mouseReport = ((vt320) bridge.buffer).isMouseReportEnabled();\n\n\t\t// MouseReport can be \"defeated\" using the shift key.\n\t\tif (!mouseReport || shiftOn) {\n\t\t\tif (event.getAction() == MotionEvent.ACTION_DOWN) {\n\t\t\t\tif (event.getButtonState() == MotionEvent.BUTTON_TERTIARY) {\n\t\t\t\t\t// Middle click pastes.\n\t\t\t\t\tString clip = clipboard.getText().toString();\n\t\t\t\t\tbridge.injectString(clip);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\t// Begin \"selection mode\"\n\n\t\t\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {\n\t\t\t\t\tcloseSelectionActionMode();\n\t\t\t\t}\n\t\t\t} else if (event.getAction() == MotionEvent.ACTION_MOVE) {\n\t\t\t\t// In the middle of selection.\n\n\t\t\t\tif (selectionActionMode == null) {\n\t\t\t\t\tselectionActionMode = startActionMode(new TextSelectionActionModeCallback());\n\t\t\t\t}\n\n\t\t\t\tint selectionStart = getSelectionStart();\n\t\t\t\tint selectionEnd = getSelectionEnd();\n\n\t\t\t\tif (selectionStart > selectionEnd) {\n\t\t\t\t\tint tempStart = selectionStart;\n\t\t\t\t\tselectionStart = selectionEnd;\n\t\t\t\t\tselectionEnd = tempStart;\n\t\t\t\t}\n\n\t\t\t\tcurrentSelection = getText().toString().substring(selectionStart, selectionEnd);\n\t\t\t}\n\t\t} else if (event.getAction() == MotionEvent.ACTION_DOWN) {\n\t\t\tviewPager.setPagingEnabled(false);\n\t\t\t((vt320) bridge.buffer).mousePressed(\n\t\t\t\tcol, row, mouseEventToJavaModifiers(event));\n\t\t\treturn true;\n\t\t} else if (event.getAction() == MotionEvent.ACTION_UP) {\n\t\t\tviewPager.setPagingEnabled(true);\n\t\t\t((vt320) bridge.buffer).mouseReleased(col, row);\n\t\t\treturn true;\n\t\t} else if (event.getAction() == MotionEvent.ACTION_MOVE) {\n\t\t\tint buttonState = event.getButtonState();\n\t\t\tint button = (buttonState & MotionEvent.BUTTON_PRIMARY) != 0 ? 0 :\n\t\t\t\t(buttonState & MotionEvent.BUTTON_SECONDARY) != 0 ? 1 :\n\t\t\t\t(buttonState & MotionEvent.BUTTON_TERTIARY) != 0 ? 2 : 3;\n\t\t\t((vt320) bridge.buffer).mouseMoved(\n\t\t\t\tbutton,\n\t\t\t\tcol,\n\t\t\t\trow,\n\t\t\t\t(meta & KeyEvent.META_CTRL_ON) != 0,\n\t\t\t\t(meta & KeyEvent.META_SHIFT_ON) != 0,\n\t\t\t\t(meta & KeyEvent.META_META_ON) != 0);\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Takes an android mouse event and produces a Java InputEvent modifiers int which can be\n\t * passed to vt320.\n\t * @param mouseEvent The {@link MotionEvent} which should be a mouse click or release.\n\t * @return A Java InputEvent modifier int. See\n\t * http://docs.oracle.com/javase/7/docs/api/java/awt/event/InputEvent.html\n\t */\n\t@TargetApi(14)\n\tprivate static int mouseEventToJavaModifiers(MotionEvent mouseEvent) {\n\t\tif (MotionEventCompat.getSource(mouseEvent) != InputDevice.SOURCE_MOUSE) return 0;\n\n\t\tint mods = 0;\n\n\t\t// See http://docs.oracle.com/javase/7/docs/api/constant-values.html\n\t\tint buttonState = mouseEvent.getButtonState();\n\t\tif ((buttonState & MotionEvent.BUTTON_PRIMARY) != 0)\n\t\t\tmods |= 16;\n\t\tif ((buttonState & MotionEvent.BUTTON_SECONDARY) != 0)\n\t\t\tmods |= 8;\n\t\tif ((buttonState & MotionEvent.BUTTON_TERTIARY) != 0)\n\t\t\tmods |= 4;\n\n\t\t// Note: Meta and Ctrl are intentionally swapped here to keep logic in vt320 simple.\n\t\tint meta = mouseEvent.getMetaState();\n\t\tif ((meta & KeyEvent.META_META_ON) != 0)\n\t\t\tmods |= 2;\n\t\tif ((meta & KeyEvent.META_SHIFT_ON) != 0)\n\t\t\tmods |= 1;\n\t\tif ((meta & KeyEvent.META_CTRL_ON) != 0)\n\t\t\tmods |= 4;\n\n\t\treturn mods;\n\t}\n\n\t@Override\n\t@TargetApi(12)\n\tpublic boolean onGenericMotionEvent(MotionEvent event) {\n\t\tif ((MotionEventCompat.getSource(event) & InputDevice.SOURCE_CLASS_POINTER) != 0) {\n\t\t\tswitch (event.getAction()) {\n\t\t\tcase MotionEvent.ACTION_SCROLL:\n\t\t\t\t// Process scroll wheel movement:\n\t\t\t\tfloat yDistance = MotionEventCompat.getAxisValue(event, MotionEvent.AXIS_VSCROLL);\n\t\t\t\tboolean mouseReport = ((vt320) bridge.buffer).isMouseReportEnabled();\n\t\t\t\tif (mouseReport) {\n\t\t\t\t\tint row = (int) Math.floor(event.getY() / bridge.charHeight);\n\t\t\t\t\tint col = (int) Math.floor(event.getX() / bridge.charWidth);\n\n\t\t\t\t\t\t\t((vt320) bridge.buffer).mouseWheel(\n\t\t\t\t\t\t\t\t\t\t\tyDistance > 0,\n\t\t\t\t\t\t\t\t\t\t\tcol,\n\t\t\t\t\t\t\t\t\t\t\trow,\n\t\t\t\t\t\t\t\t\t\t\t(event.getMetaState() & KeyEvent.META_CTRL_ON) != 0,\n\t\t\t\t\t\t\t\t\t\t\t(event.getMetaState() & KeyEvent.META_SHIFT_ON) != 0,\n\t\t\t\t\t\t\t\t\t\t\t(event.getMetaState() & KeyEvent.META_META_ON) != 0);\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (yDistance != 0) {\n\t\t\t\t\tint base = bridge.buffer.getWindowBase();\n\t\t\t\t\tbridge.buffer.setWindowBase(base - Math.round(yDistance));\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn super.onGenericMotionEvent(event);\n\t}\n\n\t// TODO: cleanup and possibly optimize\n\tprivate void refreshTextFromBuffer() {\n\t\tif (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB) {\n\t\t\t// Do not run this function because the textView is not selectable pre-Honeycomb.\n\t\t\treturn;\n\t\t}\n\n\t\tVDUBuffer vb = bridge.getVDUBuffer();\n\n\t\tString line = \"\";\n\t\tString buffer = \"\";\n\n\t\tint windowBase = vb.getWindowBase();\n\t\tint rowBegin = vb.getTopMargin();\n\t\tint rowEnd = vb.getBottomMargin();\n\t\tint numCols = vb.getColumns() - 1;\n\n\t\tfor (int r = rowBegin; r <= rowEnd; r++) {\n\t\t\tfor (int c = 0; c < numCols; c++) {\n\t\t\t\tline += vb.charArray[windowBase + r][c];\n\t\t\t}\n\t\t\tbuffer += line.replaceAll(\"\\\\s+$\", \"\") + \"\\n\";\n\t\t\tline = \"\";\n\t\t}\n\n\t\tsetText(buffer);\n\t}\n\n\t/**\n\t * Only intended for pre-Honeycomb devices.\n\t */\n\tpublic void startPreHoneycombCopyMode() {\n\t\t// mark as copying and reset any previous bounds\n\t\tSelectionArea area = bridge.getSelectionArea();\n\t\tarea.reset();\n\t\tarea.setBounds(bridge.buffer.getColumns(), bridge.buffer.getRows());\n\n\t\tbridge.setSelectingForCopy(true);\n\n\t\t// Make sure we show the initial selection\n\t\tbridge.redraw();\n\t}\n\n\tpublic void destroy() {\n\t\t// tell bridge to destroy its bitmap\n\t\tbridge.parentDestroyed();\n\t}\n\n\t@Override\n\tprotected void onSizeChanged(int w, int h, int oldw, int oldh) {\n\t\tsuper.onSizeChanged(w, h, oldw, oldh);\n\n\t\tbridge.parentChanged(this);\n\n\t\tscaleCursors();\n\t}\n\n\tpublic void onFontSizeChanged(final float size) {\n\t\tscaleCursors();\n\n\t\t((Activity) context).runOnUiThread(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tsetTextSize(size);\n\n\t\t\t\t// For the TextView to line up with the bitmap text, lineHeight must be equal to\n\t\t\t\t// the bridge's charHeight. See TextView.getLineHeight(), which has been reversed to\n\t\t\t\t// derive lineSpacingMultiplier.\n\t\t\t\tfloat lineSpacingMultiplier = (float) bridge.charHeight / getPaint().getFontMetricsInt(null);\n\t\t\t\tsetLineSpacing(0.0f, lineSpacingMultiplier);\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate void scaleCursors() {\n\t\t// Create a scale matrix to scale our 1x1 representation of the cursor\n\t\ttempDst.set(0.0f, 0.0f, bridge.charWidth, bridge.charHeight);\n\t\tscaleMatrix.setRectToRect(tempSrc, tempDst, scaleType);\n\t}\n\n\t@Override\n\tpublic void onDraw(Canvas canvas) {\n\t\tif (bridge.bitmap != null) {\n\t\t\t// draw the bitmap\n\t\t\tbridge.onDraw();\n\n\t\t\t// draw the bridge bitmap if it exists\n\t\t\tcanvas.drawBitmap(bridge.bitmap, 0, 0, paint);\n\n\t\t\t// also draw cursor if visible\n\t\t\tif (bridge.buffer.isCursorVisible()) {\n\t\t\t\tint cursorColumn = bridge.buffer.getCursorColumn();\n\t\t\t\tfinal int cursorRow = bridge.buffer.getCursorRow();\n\n\t\t\t\tfinal int columns = bridge.buffer.getColumns();\n\n\t\t\t\tif (cursorColumn == columns)\n\t\t\t\t\tcursorColumn = columns - 1;\n\n\t\t\t\tif (cursorColumn < 0 || cursorRow < 0)\n\t\t\t\t\treturn;\n\n\t\t\t\tint currentAttribute = bridge.buffer.getAttributes(\n\t\t\t\t\t\tcursorColumn, cursorRow);\n\t\t\t\tboolean onWideCharacter = (currentAttribute & VDUBuffer.FULLWIDTH) != 0;\n\n\t\t\t\tint x = cursorColumn * bridge.charWidth;\n\t\t\t\tint y = (bridge.buffer.getCursorRow()\n\t\t\t\t\t\t+ bridge.buffer.screenBase - bridge.buffer.windowBase)\n\t\t\t\t\t\t* bridge.charHeight;\n\n\t\t\t\t// Save the current clip and translation\n\t\t\t\tcanvas.save();\n\n\t\t\t\tcanvas.translate(x, y);\n\t\t\t\tcanvas.clipRect(0, 0,\n\t\t\t\t\t\tbridge.charWidth * (onWideCharacter ? 2 : 1),\n\t\t\t\t\t\tbridge.charHeight);\n\t\t\t\tcanvas.drawPaint(cursorPaint);\n\n\t\t\t\tfinal int deadKey = bridge.getKeyHandler().getDeadKey();\n\t\t\t\tif (deadKey != 0) {\n\t\t\t\t\tcanvas.drawText(new char[] { (char) deadKey }, 0, 1, 0, 0, cursorStrokePaint);\n\t\t\t\t}\n\n\t\t\t\t// Make sure we scale our decorations to the correct size.\n\t\t\t\tcanvas.concat(scaleMatrix);\n\n\t\t\t\tint metaState = bridge.getKeyHandler().getMetaState();\n\n\t\t\t\tif ((metaState & TerminalKeyListener.OUR_SHIFT_ON) != 0)\n\t\t\t\t\tcanvas.drawPath(shiftCursor, cursorStrokePaint);\n\t\t\t\telse if ((metaState & TerminalKeyListener.OUR_SHIFT_LOCK) != 0)\n\t\t\t\t\tcanvas.drawPath(shiftCursor, cursorPaint);\n\n\t\t\t\tif ((metaState & TerminalKeyListener.OUR_ALT_ON) != 0)\n\t\t\t\t\tcanvas.drawPath(altCursor, cursorStrokePaint);\n\t\t\t\telse if ((metaState & TerminalKeyListener.OUR_ALT_LOCK) != 0)\n\t\t\t\t\tcanvas.drawPath(altCursor, cursorPaint);\n\n\t\t\t\tif ((metaState & TerminalKeyListener.OUR_CTRL_ON) != 0)\n\t\t\t\t\tcanvas.drawPath(ctrlCursor, cursorStrokePaint);\n\t\t\t\telse if ((metaState & TerminalKeyListener.OUR_CTRL_LOCK) != 0)\n\t\t\t\t\tcanvas.drawPath(ctrlCursor, cursorPaint);\n\n\t\t\t\t// Restore previous clip region\n\t\t\t\tcanvas.restore();\n\t\t\t}\n\n\t\t\t// draw any highlighted area\n\t\t\tif (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB &&\n\t\t\t\tbridge.isSelectingForCopy()) {\n\t\t\t\tSelectionArea area = bridge.getSelectionArea();\n\t\t\t\tcanvas.save(Canvas.CLIP_SAVE_FLAG);\n\t\t\t\tcanvas.clipRect(\n\t\t\t\t\tarea.getLeft() * bridge.charWidth,\n\t\t\t\t\tarea.getTop() * bridge.charHeight,\n\t\t\t\t\t(area.getRight() + 1) * bridge.charWidth,\n\t\t\t\t\t(area.getBottom() + 1) * bridge.charHeight\n\t\t\t\t);\n\t\t\t\tcanvas.drawPaint(cursorPaint);\n\t\t\t\tcanvas.restore();\n\t\t\t}\n\t\t}\n\n\t\tsuper.onDraw(canvas);\n\t}\n\n\tpublic void notifyUser(String message) {\n\t\tif (!notifications)\n\t\t\treturn;\n\n\t\tif (notification != null) {\n\t\t\t// Don't keep telling the user the same thing.\n\t\t\tif (lastNotification != null && lastNotification.equals(message))\n\t\t\t\treturn;\n\n\t\t\tnotification.setText(message);\n\t\t\tnotification.show();\n\t\t} else {\n\t\t\tnotification = Toast.makeText(context, message, Toast.LENGTH_SHORT);\n\t\t\tnotification.show();\n\t\t}\n\n\t\tlastNotification = message;\n\t}\n\n\t/**\n\t * Ask the {@link TerminalBridge} we're connected to to resize to a specific size.\n\t * @param width\n\t * @param height\n\t */\n\tpublic void forceSize(int width, int height) {\n\t\tbridge.resizeComputed(width, height, getWidth(), getHeight());\n\t}\n\n\t/**\n\t * Sets the ability for the TerminalView to display Toast notifications to the user.\n\t * @param value whether to enable notifications or not\n\t */\n\tpublic void setNotifications(boolean value) {\n\t\tnotifications = value;\n\t}\n\n\t@Override\n\tpublic boolean onCheckIsTextEditor() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic InputConnection onCreateInputConnection(EditorInfo outAttrs) {\n\t\toutAttrs.imeOptions |=\n\t\t\tEditorInfo.IME_FLAG_NO_EXTRACT_UI |\n\t\t\tEditorInfo.IME_FLAG_NO_ENTER_ACTION |\n\t\t\tEditorInfo.IME_ACTION_NONE;\n\t\toutAttrs.inputType = EditorInfo.TYPE_NULL;\n\t\treturn new BaseInputConnection(this, false) {\n\t\t\t@Override\n\t\t\tpublic boolean deleteSurroundingText (int leftLength, int rightLength) {\n\t\t\t\tif (rightLength == 0 && leftLength == 0) {\n\t\t\t\t\treturn this.sendKeyEvent(new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_DEL));\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < leftLength; i++) {\n\t\t\t\t\tthis.sendKeyEvent(new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_DEL));\n\t\t\t\t}\n\t\t\t\t// TODO: forward delete\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\t}\n\n\tpublic void propagateConsoleText(char[] rawText, int length) {\n\t\tif (mAccessibilityActive) {\n\t\t\tsynchronized (mAccessibilityLock) {\n\t\t\t\tmAccessibilityBuffer.append(rawText, 0, length);\n\t\t\t}\n\n\t\t\tif (mAccessibilityInitialized) {\n\t\t\t\tif (mEventSender != null) {\n\t\t\t\t\tremoveCallbacks(mEventSender);\n\t\t\t\t} else {\n\t\t\t\t\tmEventSender = new AccessibilityEventSender();\n\t\t\t\t}\n\n\t\t\t\tpostDelayed(mEventSender, ACCESSIBILITY_EVENT_THRESHOLD);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate class AccessibilityEventSender implements Runnable {\n\t\tpublic void run() {\n\t\t\tsynchronized (mAccessibilityLock) {\n\t\t\t\tif (mCodeMatcher == null) {\n\t\t\t\t\tmCodeMatcher = mControlCodes.matcher(mAccessibilityBuffer);\n\t\t\t\t} else {\n\t\t\t\t\tmCodeMatcher.reset(mAccessibilityBuffer);\n\t\t\t\t}\n\n\t\t\t\t// Strip all control codes out.\n\t\t\t\tmAccessibilityBuffer = new StringBuffer(mCodeMatcher.replaceAll(\" \"));\n\n\t\t\t\t// Apply Backspaces using backspace character sequence\n\t\t\t\tint i = mAccessibilityBuffer.indexOf(BACKSPACE_CODE);\n\t\t\t\twhile (i != -1) {\n\t\t\t\t\tmAccessibilityBuffer = mAccessibilityBuffer.replace(i == 0 ? 0 : i - 1, i\n\t\t\t\t\t\t\t+ BACKSPACE_CODE.length(), \"\");\n\t\t\t\t\ti = mAccessibilityBuffer.indexOf(BACKSPACE_CODE);\n\t\t\t\t}\n\n\t\t\t\tif (mAccessibilityBuffer.length() > 0) {\n\t\t\t\t\tAccessibilityEvent event = AccessibilityEvent.obtain(\n\t\t\t\t\t\t\tAccessibilityEvent.TYPE_VIEW_TEXT_CHANGED);\n\t\t\t\t\tevent.setFromIndex(0);\n\t\t\t\t\tevent.setAddedCount(mAccessibilityBuffer.length());\n\t\t\t\t\tevent.getText().add(mAccessibilityBuffer);\n\n\t\t\t\t\tsendAccessibilityEventUnchecked(event);\n\t\t\t\t\tmAccessibilityBuffer.setLength(0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate class AccessibilityStateTester extends AsyncTask<Void, Void, Boolean> {\n\t\t@Override\n\t\tprotected Boolean doInBackground(Void... params) {\n\t\t\t/*\n\t\t\t * Presumably if the accessibility manager is not enabled, we don't\n\t\t\t * need to send accessibility events.\n\t\t\t */\n\t\t\tfinal AccessibilityManager accessibility = (AccessibilityManager) context\n\t\t\t\t\t.getSystemService(Context.ACCESSIBILITY_SERVICE);\n\t\t\tif (!accessibility.isEnabled()) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Restrict the set of intents to only accessibility services that\n\t\t\t * have the category FEEDBACK_SPOKEN (aka, screen readers).\n\t\t\t */\n\t\t\tfinal Intent screenReaderIntent = new Intent(SCREENREADER_INTENT_ACTION);\n\t\t\tscreenReaderIntent.addCategory(SCREENREADER_INTENT_CATEGORY);\n\n\t\t\tfinal ContentResolver cr = context.getContentResolver();\n\n\t\t\tfinal List<ResolveInfo> screenReaders = context.getPackageManager().queryIntentServices(\n\t\t\t\t\tscreenReaderIntent, 0);\n\n\t\t\tboolean foundScreenReader = false;\n\n\t\t\tfinal int N = screenReaders.size();\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfinal ResolveInfo screenReader = screenReaders.get(i);\n\n\t\t\t\t/*\n\t\t\t\t * All screen readers are expected to implement a content\n\t\t\t\t * provider that responds to:\n\t\t\t\t * content://<nameofpackage>.providers.StatusProvider\n\t\t\t\t */\n\t\t\t\tfinal Cursor cursor = cr.query(\n\t\t\t\t\t\tUri.parse(\"content://\" + screenReader.serviceInfo.packageName\n\t\t\t\t\t\t\t\t+ \".providers.StatusProvider\"), null, null, null, null);\n\t\t\t\tif (cursor != null && cursor.moveToFirst()) {\n\t\t\t\t\t/*\n\t\t\t\t\t * These content providers use a special cursor that only has\n\t\t\t\t\t * one element, an integer that is 1 if the screen reader is\n\t\t\t\t\t * running.\n\t\t\t\t\t */\n\t\t\t\t\tfinal int status = cursor.getInt(0);\n\n\t\t\t\t\tcursor.close();\n\n\t\t\t\t\tif (status == 1) {\n\t\t\t\t\t\tfoundScreenReader = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (foundScreenReader) {\n\t\t\t\tmControlCodes = Pattern.compile(CONTROL_CODE_PATTERN);\n\t\t\t}\n\n\t\t\treturn foundScreenReader;\n\t\t}\n\n\t\t@Override\n\t\tprotected void onPostExecute(Boolean result) {\n\t\t\tmAccessibilityActive = result;\n\n\t\t\tmAccessibilityInitialized = true;\n\n\t\t\tif (result) {\n\t\t\t\tmEventSender = new AccessibilityEventSender();\n\t\t\t\tpostDelayed(mEventSender, ACCESSIBILITY_EVENT_THRESHOLD);\n\t\t\t} else {\n\t\t\t\tmAccessibilityBuffer = null;\n\t\t\t}\n\t\t}\n\t}\n}\n","Method after Refactoring":"/*\n * ConnectBot: simple, powerful, open-source SSH client for Android\n * Copyright 2007 Kenny Root, Jeffrey Sharkey\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.connectbot;\n\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.connectbot.bean.SelectionArea;\nimport org.connectbot.service.FontSizeChangedListener;\nimport org.connectbot.service.TerminalBridge;\nimport org.connectbot.service.TerminalKeyListener;\nimport org.connectbot.util.TerminalViewPager;\n\nimport android.annotation.TargetApi;\nimport android.app.Activity;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.pm.ResolveInfo;\nimport android.database.Cursor;\nimport android.graphics.Canvas;\nimport android.graphics.Color;\nimport android.graphics.Matrix;\nimport android.graphics.Paint;\nimport android.graphics.Path;\nimport android.graphics.PixelXorXfermode;\nimport android.graphics.RectF;\nimport android.graphics.Typeface;\nimport android.net.Uri;\nimport android.os.AsyncTask;\nimport android.os.Build;\nimport android.support.v4.view.MotionEventCompat;\nimport android.text.ClipboardManager;\nimport android.view.ActionMode;\nimport android.view.GestureDetector;\nimport android.view.InputDevice;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.MotionEvent;\nimport android.view.ViewGroup.LayoutParams;\nimport android.view.accessibility.AccessibilityEvent;\nimport android.view.accessibility.AccessibilityManager;\nimport android.view.inputmethod.BaseInputConnection;\nimport android.view.inputmethod.EditorInfo;\nimport android.view.inputmethod.InputConnection;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport de.mud.terminal.VDUBuffer;\nimport de.mud.terminal.vt320;\n\n/**\n * User interface {@link TextView} for showing a TerminalBridge in an\n * {@link android.app.Activity}. Handles drawing bitmap updates and passing keystrokes down\n * to terminal.\n *\n * On Honeycomb devices and above (>= APIv11), a TextView with transparent text (which is identical\n * to the bitmap) is drawn above the bitmap. This TextView exists to allow the user to\n * select and copy text.\n *\n * @author jsharkey\n */\npublic class TerminalView extends TextView implements FontSizeChangedListener {\n\n\tprivate final Context context;\n\tpublic final TerminalBridge bridge;\n\n\tprivate final TerminalViewPager viewPager;\n\tprivate GestureDetector gestureDetector;\n\n\tprivate ClipboardManager clipboard;\n\tprivate ActionMode selectionActionMode = null;\n\tprivate String currentSelection = \"\";\n\n\t// These are only used for pre-Honeycomb copying.\n\tprivate int lastTouchedRow, lastTouchedCol;\n\n\tprivate final Paint paint;\n\tprivate final Paint cursorPaint;\n\tprivate final Paint cursorStrokePaint;\n\n\t// Cursor paints to distinguish modes\n\tprivate Path ctrlCursor, altCursor, shiftCursor;\n\tprivate RectF tempSrc, tempDst;\n\tprivate Matrix scaleMatrix;\n\tprivate static final Matrix.ScaleToFit scaleType = Matrix.ScaleToFit.FILL;\n\n\tprivate Toast notification = null;\n\tprivate String lastNotification = null;\n\tprivate volatile boolean notifications = true;\n\n\t// Related to Accessibility Features\n\tprivate boolean mAccessibilityInitialized = false;\n\tprivate boolean mAccessibilityActive = true;\n\tprivate Object[] mAccessibilityLock = new Object[0];\n\tprivate StringBuffer mAccessibilityBuffer;\n\tprivate Pattern mControlCodes = null;\n\tprivate Matcher mCodeMatcher = null;\n\tprivate AccessibilityEventSender mEventSender = null;\n\n\tprivate static final String BACKSPACE_CODE = \"\\\\x08\\\\x1b\\\\[K\";\n\tprivate static final String CONTROL_CODE_PATTERN = \"\\\\x1b\\\\[K[^m]+[m|:]\";\n\n\tprivate static final int ACCESSIBILITY_EVENT_THRESHOLD = 1000;\n\tprivate static final String SCREENREADER_INTENT_ACTION = \"android.accessibilityservice.AccessibilityService\";\n\tprivate static final String SCREENREADER_INTENT_CATEGORY = \"android.accessibilityservice.category.FEEDBACK_SPOKEN\";\n\n\tpublic TerminalView(Context context, TerminalBridge bridge, TerminalViewPager pager) {\n\t\tsuper(context);\n\n\t\tthis.context = context;\n\t\tthis.bridge = bridge;\n\t\tthis.viewPager = pager;\n\n\t\tsetLayoutParams(new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT));\n\t\tsetFocusable(true);\n\t\tsetFocusableInTouchMode(true);\n\n\t\tpaint = new Paint();\n\n\t\tcursorPaint = new Paint();\n\t\tcursorPaint.setColor(bridge.color[bridge.defaultFg]);\n\t\tcursorPaint.setXfermode(new PixelXorXfermode(bridge.color[bridge.defaultBg]));\n\t\tcursorPaint.setAntiAlias(true);\n\n\t\tcursorStrokePaint = new Paint(cursorPaint);\n\t\tcursorStrokePaint.setStrokeWidth(0.1f);\n\t\tcursorStrokePaint.setStyle(Paint.Style.STROKE);\n\n\t\t/*\n\t\t * Set up our cursor indicators on a 1x1 Path object which we can later\n\t\t * transform to our character width and height\n\t\t */\n\t\t// TODO make this into a resource somehow\n\t\tshiftCursor = new Path();\n\t\tshiftCursor.lineTo(0.5f, 0.33f);\n\t\tshiftCursor.lineTo(1.0f, 0.0f);\n\n\t\taltCursor = new Path();\n\t\taltCursor.moveTo(0.0f, 1.0f);\n\t\taltCursor.lineTo(0.5f, 0.66f);\n\t\taltCursor.lineTo(1.0f, 1.0f);\n\n\t\tctrlCursor = new Path();\n\t\tctrlCursor.moveTo(0.0f, 0.25f);\n\t\tctrlCursor.lineTo(1.0f, 0.5f);\n\t\tctrlCursor.lineTo(0.0f, 0.75f);\n\n\t\t// For creating the transform when the terminal resizes\n\t\ttempSrc = new RectF();\n\t\ttempSrc.set(0.0f, 0.0f, 1.0f, 1.0f);\n\t\ttempDst = new RectF();\n\t\tscaleMatrix = new Matrix();\n\n\t\tbridge.addFontSizeChangedListener(this);\n\t\tbridge.parentChanged(this);\n\n\t\t// connect our view up to the bridge\n\t\tsetOnKeyListener(bridge.getKeyHandler());\n\n\t\tmAccessibilityBuffer = new StringBuffer();\n\n\t\t// Enable accessibility features if a screen reader is active.\n\t\tnew AccessibilityStateTester().execute((Void) null);\n\n\t\tclipboard = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE);\n\n\t\tsetTextColor(Color.TRANSPARENT);\n\t\tsetTypeface(Typeface.MONOSPACE);\n\t\tonFontSizeChanged(bridge.getFontSize());\n\n\t\t// Allow selection of and copying text for Honeycomb and above devices.\n\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {\n\t\t\tsetTextIsSelectable(true);\n\t\t\tsetCustomSelectionActionModeCallback(new TextSelectionActionModeCallback());\n\t\t}\n\n\t\tgestureDetector = new GestureDetector(context, new GestureDetector.SimpleOnGestureListener() {\n\t\t\tprivate TerminalBridge bridge = TerminalView.this.bridge;\n\t\t\tprivate float totalY = 0;\n\n\t\t\t@Override\n\t\t\tpublic boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {\n\t\t\t\t// if releasing then reset total scroll\n\t\t\t\tif (e2.getAction() == MotionEvent.ACTION_UP) {\n\t\t\t\t\ttotalY = 0;\n\t\t\t\t}\n\n\t\t\t\ttotalY += distanceY;\n\t\t\t\tfinal int moved = (int) (totalY / bridge.charHeight);\n\n\t\t\t\tif (moved != 0) {\n\t\t\t\t\tint base = bridge.buffer.getWindowBase();\n\t\t\t\t\tbridge.buffer.setWindowBase(base + moved);\n\t\t\t\t\ttotalY = 0;\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean onSingleTapConfirmed(MotionEvent e) {\n\t\t\t\tviewPager.performClick();\n\t\t\t\treturn super.onSingleTapConfirmed(e);\n\t\t\t}\n\t\t});\n\t}\n\n\t@TargetApi(11)\n\tprivate void closeSelectionActionMode() {\n\t\tif (selectionActionMode != null) {\n\t\t\tselectionActionMode.finish();\n\t\t\tselectionActionMode = null;\n\t\t}\n\t}\n\n\tpublic void copyCurrentSelectionToClipboard() {\n\t\tClipboardManager clipboard =\n\t\t\t\t(ClipboardManager) TerminalView.this.context.getSystemService(Context.CLIPBOARD_SERVICE);\n\t\tif (currentSelection.length() != 0) {\n\t\t\tclipboard.setText(currentSelection);\n\t\t}\n\n\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {\n\t\t\tcloseSelectionActionMode();\n\t\t}\n\t}\n\n\t@Override\n\tprotected void onSelectionChanged(int selStart, int selEnd) {\n\t\tif (selStart <= selEnd) {\n\t\t\tcurrentSelection = getText().toString().substring(selStart, selEnd);\n\t\t}\n\t\tsuper.onSelectionChanged(selStart, selEnd);\n\t}\n\n\t@Override\n\tpublic boolean onTouchEvent(MotionEvent event) {\n\t\tif (event.getAction() == MotionEvent.ACTION_DOWN) {\n\t\t\t// Selection may be beginning. Sync the TextView with the buffer.\n\t\t\trefreshTextFromBuffer();\n\t\t}\n\n\t\t// Mouse input is treated differently:\n\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH &&\n\t\t\t\tMotionEventCompat.getSource(event) == InputDevice.SOURCE_MOUSE) {\n\t\t\tif (onMouseEvent(event, bridge)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tviewPager.setPagingEnabled(true);\n\t\t} else if (gestureDetector != null) {\n\t\t\t// The gesture detector should not be called if touch event was from mouse.\n\t\t\tgestureDetector.onTouchEvent(event);\n\t\t}\n\n\t\t// Old version of copying, only for pre-Honeycomb.\n\t\tif (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB) {\n\t\t\t// when copying, highlight the area\n\t\t\tif (bridge.isSelectingForCopy()) {\n\t\t\t\tSelectionArea area = bridge.getSelectionArea();\n\t\t\t\tint row = (int) Math.floor(event.getY() / bridge.charHeight);\n\t\t\t\tint col = (int) Math.floor(event.getX() / bridge.charWidth);\n\n\t\t\t\tswitch (event.getAction()) {\n\t\t\t\tcase MotionEvent.ACTION_DOWN:\n\t\t\t\t\t// recording starting area\n\t\t\t\t\tviewPager.setPagingEnabled(false);\n\t\t\t\t\tif (area.isSelectingOrigin()) {\n\t\t\t\t\t\tarea.setRow(row);\n\t\t\t\t\t\tarea.setColumn(col);\n\t\t\t\t\t\tlastTouchedRow = row;\n\t\t\t\t\t\tlastTouchedCol = col;\n\t\t\t\t\t\tbridge.redraw();\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\tcase MotionEvent.ACTION_MOVE:\n\t\t\t\t\t\t\t/* ignore when user hasn't moved since last time so\n\t\t\t\t\t\t\t * we can fine-tune with directional pad\n\t\t\t\t\t\t\t */\n\t\t\t\t\tif (row == lastTouchedRow && col == lastTouchedCol)\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t// if the user moves, start the selection for other corner\n\t\t\t\t\tarea.finishSelectingOrigin();\n\n\t\t\t\t\t// update selected area\n\t\t\t\t\tarea.setRow(row);\n\t\t\t\t\tarea.setColumn(col);\n\t\t\t\t\tlastTouchedRow = row;\n\t\t\t\t\tlastTouchedCol = col;\n\t\t\t\t\tbridge.redraw();\n\t\t\t\t\treturn true;\n\t\t\t\tcase MotionEvent.ACTION_UP:\n\t\t\t\t\t\t\t/* If they didn't move their finger, maybe they meant to\n\t\t\t\t\t\t\t * select the rest of the text with the directional pad.\n\t\t\t\t\t\t\t */\n\t\t\t\t\tif (area.getLeft() == area.getRight() &&\n\t\t\t\t\t\t\tarea.getTop() == area.getBottom()) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\t// copy selected area to clipboard\n\t\t\t\t\tString copiedText = area.copyFrom(bridge.buffer);\n\n\t\t\t\t\tclipboard.setText(copiedText);\n\t\t\t\t\tToast.makeText(\n\t\t\t\t\t\tcontext,\n\t\t\t\t\t\tcontext.getString(R.string.console_copy_done, copiedText.length()),\n\t\t\t\t\t\tToast.LENGTH_LONG).show();\n\n\t\t\t\t\t// fall through to clear state\n\n\t\t\t\tcase MotionEvent.ACTION_CANCEL:\n\t\t\t\t\t// make sure we clear any highlighted area\n\t\t\t\t\tarea.reset();\n\t\t\t\t\tbridge.setSelectingForCopy(false);\n\t\t\t\t\tbridge.redraw();\n\t\t\t\t\tviewPager.setPagingEnabled(true);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\tsuper.onTouchEvent(event);\n\n\t\treturn true;\n\t}\n\n\t@TargetApi(11)\n\tprivate class TextSelectionActionModeCallback implements ActionMode.Callback {\n\t\tprivate static final int COPY = 0;\n\t\tprivate static final int PASTE = 1;\n\n\t\t@Override\n\t\tpublic boolean onPrepareActionMode(ActionMode mode, Menu menu) {\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean onCreateActionMode(ActionMode mode, Menu menu) {\n\t\t\tTerminalView.this.selectionActionMode = mode;\n\n\t\t\tmenu.clear();\n\n\t\t\tmenu.add(0, COPY, 0, R.string.console_menu_copy)\n\t\t\t\t\t.setIcon(R.drawable.ic_action_copy)\n\t\t\t\t\t.setShowAsAction(MenuItem.SHOW_AS_ACTION_WITH_TEXT | MenuItem.SHOW_AS_ACTION_IF_ROOM);\n\t\t\tmenu.add(0, PASTE, 1, R.string.console_menu_paste)\n\t\t\t\t\t.setIcon(R.drawable.ic_action_paste)\n\t\t\t\t\t.setShowAsAction(MenuItem.SHOW_AS_ACTION_WITH_TEXT | MenuItem.SHOW_AS_ACTION_IF_ROOM);\n\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean onActionItemClicked(ActionMode mode, MenuItem item) {\n\t\t\tswitch (item.getItemId()) {\n\t\t\tcase COPY:\n\t\t\t\tcopyCurrentSelectionToClipboard();\n\t\t\t\treturn true;\n\t\t\tcase PASTE:\n\t\t\t\tString clip = clipboard.getText().toString();\n\t\t\t\tTerminalView.this.bridge.injectString(clip);\n\t\t\t\tmode.finish();\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic void onDestroyActionMode(ActionMode mode) {\n\t\t}\n\t}\n\n\t/**\n\t * @param event\n\t * @param bridge\n\t * @return True if the event is handled.\n\t */\n\t@TargetApi(14)\n\tprivate boolean onMouseEvent(MotionEvent event, TerminalBridge bridge) {\n\t\tint row = (int) Math.floor(event.getY() / bridge.charHeight);\n\t\tint col = (int) Math.floor(event.getX() / bridge.charWidth);\n\t\tint meta = event.getMetaState();\n\t\tboolean shiftOn = (meta & KeyEvent.META_SHIFT_ON) != 0;\n\t\tvt320 vtBuffer = (vt320) bridge.buffer;\n\t\tboolean mouseReport = vtBuffer.isMouseReportEnabled();\n\n\t\t// MouseReport can be \"defeated\" using the shift key.\n\t\tif (!mouseReport || shiftOn) {\n\t\t\tif (event.getAction() == MotionEvent.ACTION_DOWN) {\n\t\t\t\tif (event.getButtonState() == MotionEvent.BUTTON_TERTIARY) {\n\t\t\t\t\t// Middle click pastes.\n\t\t\t\t\tString clip = clipboard.getText().toString();\n\t\t\t\t\tbridge.injectString(clip);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\t// Begin \"selection mode\"\n\n\t\t\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {\n\t\t\t\t\tcloseSelectionActionMode();\n\t\t\t\t}\n\t\t\t} else if (event.getAction() == MotionEvent.ACTION_MOVE) {\n\t\t\t\t// In the middle of selection.\n\n\t\t\t\tif (selectionActionMode == null) {\n\t\t\t\t\tselectionActionMode = startActionMode(new TextSelectionActionModeCallback());\n\t\t\t\t}\n\n\t\t\t\tint selectionStart = getSelectionStart();\n\t\t\t\tint selectionEnd = getSelectionEnd();\n\n\t\t\t\tif (selectionStart > selectionEnd) {\n\t\t\t\t\tint tempStart = selectionStart;\n\t\t\t\t\tselectionStart = selectionEnd;\n\t\t\t\t\tselectionEnd = tempStart;\n\t\t\t\t}\n\n\t\t\t\tcurrentSelection = getText().toString().substring(selectionStart, selectionEnd);\n\t\t\t}\n\t\t} else if (event.getAction() == MotionEvent.ACTION_DOWN) {\n\t\t\tviewPager.setPagingEnabled(false);\n\t\t\tvtBuffer.mousePressed(\n\t\t\t\t\tcol, row, mouseEventToJavaModifiers(event));\n\t\t\treturn true;\n\t\t} else if (event.getAction() == MotionEvent.ACTION_UP) {\n\t\t\tviewPager.setPagingEnabled(true);\n\t\t\tvtBuffer.mouseReleased(col, row);\n\t\t\treturn true;\n\t\t} else if (event.getAction() == MotionEvent.ACTION_MOVE) {\n\t\t\tint buttonState = event.getButtonState();\n\t\t\tint button = (buttonState & MotionEvent.BUTTON_PRIMARY) != 0 ? 0 :\n\t\t\t\t(buttonState & MotionEvent.BUTTON_SECONDARY) != 0 ? 1 :\n\t\t\t\t(buttonState & MotionEvent.BUTTON_TERTIARY) != 0 ? 2 : 3;\n\t\t\tvtBuffer.mouseMoved(\n\t\t\t\tbutton,\n\t\t\t\tcol,\n\t\t\t\trow,\n\t\t\t\t(meta & KeyEvent.META_CTRL_ON) != 0,\n\t\t\t\t(meta & KeyEvent.META_SHIFT_ON) != 0,\n\t\t\t\t(meta & KeyEvent.META_META_ON) != 0);\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Takes an android mouse event and produces a Java InputEvent modifiers int which can be\n\t * passed to vt320.\n\t * @param mouseEvent The {@link MotionEvent} which should be a mouse click or release.\n\t * @return A Java InputEvent modifier int. See\n\t * http://docs.oracle.com/javase/7/docs/api/java/awt/event/InputEvent.html\n\t */\n\t@TargetApi(14)\n\tprivate static int mouseEventToJavaModifiers(MotionEvent mouseEvent) {\n\t\tif (MotionEventCompat.getSource(mouseEvent) != InputDevice.SOURCE_MOUSE) return 0;\n\n\t\tint mods = 0;\n\n\t\t// See http://docs.oracle.com/javase/7/docs/api/constant-values.html\n\t\tint buttonState = mouseEvent.getButtonState();\n\t\tif ((buttonState & MotionEvent.BUTTON_PRIMARY) != 0)\n\t\t\tmods |= 16;\n\t\tif ((buttonState & MotionEvent.BUTTON_SECONDARY) != 0)\n\t\t\tmods |= 8;\n\t\tif ((buttonState & MotionEvent.BUTTON_TERTIARY) != 0)\n\t\t\tmods |= 4;\n\n\t\t// Note: Meta and Ctrl are intentionally swapped here to keep logic in vt320 simple.\n\t\tint meta = mouseEvent.getMetaState();\n\t\tif ((meta & KeyEvent.META_META_ON) != 0)\n\t\t\tmods |= 2;\n\t\tif ((meta & KeyEvent.META_SHIFT_ON) != 0)\n\t\t\tmods |= 1;\n\t\tif ((meta & KeyEvent.META_CTRL_ON) != 0)\n\t\t\tmods |= 4;\n\n\t\treturn mods;\n\t}\n\n\t@Override\n\t@TargetApi(12)\n\tpublic boolean onGenericMotionEvent(MotionEvent event) {\n\t\tif ((MotionEventCompat.getSource(event) & InputDevice.SOURCE_CLASS_POINTER) != 0) {\n\t\t\tswitch (event.getAction()) {\n\t\t\tcase MotionEvent.ACTION_SCROLL:\n\t\t\t\t// Process scroll wheel movement:\n\t\t\t\tfloat yDistance = MotionEventCompat.getAxisValue(event, MotionEvent.AXIS_VSCROLL);\n\t\t\t\tvt320 vtBuffer = (vt320) bridge.buffer;\n\t\t\t\tboolean mouseReport = vtBuffer.isMouseReportEnabled();\n\t\t\t\tif (mouseReport) {\n\t\t\t\t\tint row = (int) Math.floor(event.getY() / bridge.charHeight);\n\t\t\t\t\tint col = (int) Math.floor(event.getX() / bridge.charWidth);\n\n\t\t\t\t\tvtBuffer.mouseWheel(\n\t\t\t\t\t\t\tyDistance > 0,\n\t\t\t\t\t\t\tcol,\n\t\t\t\t\t\t\trow,\n\t\t\t\t\t\t\t(event.getMetaState() & KeyEvent.META_CTRL_ON) != 0,\n\t\t\t\t\t\t\t(event.getMetaState() & KeyEvent.META_SHIFT_ON) != 0,\n\t\t\t\t\t\t\t(event.getMetaState() & KeyEvent.META_META_ON) != 0);\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (yDistance != 0) {\n\t\t\t\t\tint base = bridge.buffer.getWindowBase();\n\t\t\t\t\tbridge.buffer.setWindowBase(base - Math.round(yDistance));\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn super.onGenericMotionEvent(event);\n\t}\n\n\t// TODO: cleanup and possibly optimize\n\tprivate void refreshTextFromBuffer() {\n\t\tif (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB) {\n\t\t\t// Do not run this function because the textView is not selectable pre-Honeycomb.\n\t\t\treturn;\n\t\t}\n\n\t\tVDUBuffer vb = bridge.getVDUBuffer();\n\n\t\tString line = \"\";\n\t\tString buffer = \"\";\n\n\t\tint windowBase = vb.getWindowBase();\n\t\tint rowBegin = vb.getTopMargin();\n\t\tint rowEnd = vb.getBottomMargin();\n\t\tint numCols = vb.getColumns() - 1;\n\n\t\tfor (int r = rowBegin; r <= rowEnd; r++) {\n\t\t\tfor (int c = 0; c < numCols; c++) {\n\t\t\t\tline += vb.charArray[windowBase + r][c];\n\t\t\t}\n\t\t\tbuffer += line.replaceAll(\"\\\\s+$\", \"\") + \"\\n\";\n\t\t\tline = \"\";\n\t\t}\n\n\t\tsetText(buffer);\n\t}\n\n\t/**\n\t * Only intended for pre-Honeycomb devices.\n\t */\n\tpublic void startPreHoneycombCopyMode() {\n\t\t// mark as copying and reset any previous bounds\n\t\tSelectionArea area = bridge.getSelectionArea();\n\t\tarea.reset();\n\t\tarea.setBounds(bridge.buffer.getColumns(), bridge.buffer.getRows());\n\n\t\tbridge.setSelectingForCopy(true);\n\n\t\t// Make sure we show the initial selection\n\t\tbridge.redraw();\n\t}\n\n\tpublic void destroy() {\n\t\t// tell bridge to destroy its bitmap\n\t\tbridge.parentDestroyed();\n\t}\n\n\t@Override\n\tprotected void onSizeChanged(int w, int h, int oldw, int oldh) {\n\t\tsuper.onSizeChanged(w, h, oldw, oldh);\n\n\t\tbridge.parentChanged(this);\n\n\t\tscaleCursors();\n\t}\n\n\tpublic void onFontSizeChanged(final float size) {\n\t\tscaleCursors();\n\n\t\t((Activity) context).runOnUiThread(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tsetTextSize(size);\n\n\t\t\t\t// For the TextView to line up with the bitmap text, lineHeight must be equal to\n\t\t\t\t// the bridge's charHeight. See TextView.getLineHeight(), which has been reversed to\n\t\t\t\t// derive lineSpacingMultiplier.\n\t\t\t\tfloat lineSpacingMultiplier = (float) bridge.charHeight / getPaint().getFontMetricsInt(null);\n\t\t\t\tsetLineSpacing(0.0f, lineSpacingMultiplier);\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate void scaleCursors() {\n\t\t// Create a scale matrix to scale our 1x1 representation of the cursor\n\t\ttempDst.set(0.0f, 0.0f, bridge.charWidth, bridge.charHeight);\n\t\tscaleMatrix.setRectToRect(tempSrc, tempDst, scaleType);\n\t}\n\n\t@Override\n\tpublic void onDraw(Canvas canvas) {\n\t\tif (bridge.bitmap != null) {\n\t\t\t// draw the bitmap\n\t\t\tbridge.onDraw();\n\n\t\t\t// draw the bridge bitmap if it exists\n\t\t\tcanvas.drawBitmap(bridge.bitmap, 0, 0, paint);\n\n\t\t\t// also draw cursor if visible\n\t\t\tif (bridge.buffer.isCursorVisible()) {\n\t\t\t\tint cursorColumn = bridge.buffer.getCursorColumn();\n\t\t\t\tfinal int cursorRow = bridge.buffer.getCursorRow();\n\n\t\t\t\tfinal int columns = bridge.buffer.getColumns();\n\n\t\t\t\tif (cursorColumn == columns)\n\t\t\t\t\tcursorColumn = columns - 1;\n\n\t\t\t\tif (cursorColumn < 0 || cursorRow < 0)\n\t\t\t\t\treturn;\n\n\t\t\t\tint currentAttribute = bridge.buffer.getAttributes(\n\t\t\t\t\t\tcursorColumn, cursorRow);\n\t\t\t\tboolean onWideCharacter = (currentAttribute & VDUBuffer.FULLWIDTH) != 0;\n\n\t\t\t\tint x = cursorColumn * bridge.charWidth;\n\t\t\t\tint y = (bridge.buffer.getCursorRow()\n\t\t\t\t\t\t+ bridge.buffer.screenBase - bridge.buffer.windowBase)\n\t\t\t\t\t\t* bridge.charHeight;\n\n\t\t\t\t// Save the current clip and translation\n\t\t\t\tcanvas.save();\n\n\t\t\t\tcanvas.translate(x, y);\n\t\t\t\tcanvas.clipRect(0, 0,\n\t\t\t\t\t\tbridge.charWidth * (onWideCharacter ? 2 : 1),\n\t\t\t\t\t\tbridge.charHeight);\n\t\t\t\tcanvas.drawPaint(cursorPaint);\n\n\t\t\t\tfinal int deadKey = bridge.getKeyHandler().getDeadKey();\n\t\t\t\tif (deadKey != 0) {\n\t\t\t\t\tcanvas.drawText(new char[] { (char) deadKey }, 0, 1, 0, 0, cursorStrokePaint);\n\t\t\t\t}\n\n\t\t\t\t// Make sure we scale our decorations to the correct size.\n\t\t\t\tcanvas.concat(scaleMatrix);\n\n\t\t\t\tint metaState = bridge.getKeyHandler().getMetaState();\n\n\t\t\t\tif ((metaState & TerminalKeyListener.OUR_SHIFT_ON) != 0)\n\t\t\t\t\tcanvas.drawPath(shiftCursor, cursorStrokePaint);\n\t\t\t\telse if ((metaState & TerminalKeyListener.OUR_SHIFT_LOCK) != 0)\n\t\t\t\t\tcanvas.drawPath(shiftCursor, cursorPaint);\n\n\t\t\t\tif ((metaState & TerminalKeyListener.OUR_ALT_ON) != 0)\n\t\t\t\t\tcanvas.drawPath(altCursor, cursorStrokePaint);\n\t\t\t\telse if ((metaState & TerminalKeyListener.OUR_ALT_LOCK) != 0)\n\t\t\t\t\tcanvas.drawPath(altCursor, cursorPaint);\n\n\t\t\t\tif ((metaState & TerminalKeyListener.OUR_CTRL_ON) != 0)\n\t\t\t\t\tcanvas.drawPath(ctrlCursor, cursorStrokePaint);\n\t\t\t\telse if ((metaState & TerminalKeyListener.OUR_CTRL_LOCK) != 0)\n\t\t\t\t\tcanvas.drawPath(ctrlCursor, cursorPaint);\n\n\t\t\t\t// Restore previous clip region\n\t\t\t\tcanvas.restore();\n\t\t\t}\n\n\t\t\t// draw any highlighted area\n\t\t\tif (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB &&\n\t\t\t\tbridge.isSelectingForCopy()) {\n\t\t\t\tSelectionArea area = bridge.getSelectionArea();\n\t\t\t\tcanvas.save(Canvas.CLIP_SAVE_FLAG);\n\t\t\t\tcanvas.clipRect(\n\t\t\t\t\tarea.getLeft() * bridge.charWidth,\n\t\t\t\t\tarea.getTop() * bridge.charHeight,\n\t\t\t\t\t(area.getRight() + 1) * bridge.charWidth,\n\t\t\t\t\t(area.getBottom() + 1) * bridge.charHeight\n\t\t\t\t);\n\t\t\t\tcanvas.drawPaint(cursorPaint);\n\t\t\t\tcanvas.restore();\n\t\t\t}\n\t\t}\n\n\t\tsuper.onDraw(canvas);\n\t}\n\n\tpublic void notifyUser(String message) {\n\t\tif (!notifications)\n\t\t\treturn;\n\n\t\tif (notification != null) {\n\t\t\t// Don't keep telling the user the same thing.\n\t\t\tif (lastNotification != null && lastNotification.equals(message))\n\t\t\t\treturn;\n\n\t\t\tnotification.setText(message);\n\t\t\tnotification.show();\n\t\t} else {\n\t\t\tnotification = Toast.makeText(context, message, Toast.LENGTH_SHORT);\n\t\t\tnotification.show();\n\t\t}\n\n\t\tlastNotification = message;\n\t}\n\n\t/**\n\t * Ask the {@link TerminalBridge} we're connected to to resize to a specific size.\n\t * @param width\n\t * @param height\n\t */\n\tpublic void forceSize(int width, int height) {\n\t\tbridge.resizeComputed(width, height, getWidth(), getHeight());\n\t}\n\n\t/**\n\t * Sets the ability for the TerminalView to display Toast notifications to the user.\n\t * @param value whether to enable notifications or not\n\t */\n\tpublic void setNotifications(boolean value) {\n\t\tnotifications = value;\n\t}\n\n\t@Override\n\tpublic boolean onCheckIsTextEditor() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic InputConnection onCreateInputConnection(EditorInfo outAttrs) {\n\t\toutAttrs.imeOptions |=\n\t\t\tEditorInfo.IME_FLAG_NO_EXTRACT_UI |\n\t\t\tEditorInfo.IME_FLAG_NO_ENTER_ACTION |\n\t\t\tEditorInfo.IME_ACTION_NONE;\n\t\toutAttrs.inputType = EditorInfo.TYPE_NULL;\n\t\treturn new BaseInputConnection(this, false) {\n\t\t\t@Override\n\t\t\tpublic boolean deleteSurroundingText (int leftLength, int rightLength) {\n\t\t\t\tif (rightLength == 0 && leftLength == 0) {\n\t\t\t\t\treturn this.sendKeyEvent(new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_DEL));\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < leftLength; i++) {\n\t\t\t\t\tthis.sendKeyEvent(new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_DEL));\n\t\t\t\t}\n\t\t\t\t// TODO: forward delete\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\t}\n\n\tpublic void propagateConsoleText(char[] rawText, int length) {\n\t\tif (mAccessibilityActive) {\n\t\t\tsynchronized (mAccessibilityLock) {\n\t\t\t\tmAccessibilityBuffer.append(rawText, 0, length);\n\t\t\t}\n\n\t\t\tif (mAccessibilityInitialized) {\n\t\t\t\tif (mEventSender != null) {\n\t\t\t\t\tremoveCallbacks(mEventSender);\n\t\t\t\t} else {\n\t\t\t\t\tmEventSender = new AccessibilityEventSender();\n\t\t\t\t}\n\n\t\t\t\tpostDelayed(mEventSender, ACCESSIBILITY_EVENT_THRESHOLD);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate class AccessibilityEventSender implements Runnable {\n\t\tpublic void run() {\n\t\t\tsynchronized (mAccessibilityLock) {\n\t\t\t\tif (mCodeMatcher == null) {\n\t\t\t\t\tmCodeMatcher = mControlCodes.matcher(mAccessibilityBuffer);\n\t\t\t\t} else {\n\t\t\t\t\tmCodeMatcher.reset(mAccessibilityBuffer);\n\t\t\t\t}\n\n\t\t\t\t// Strip all control codes out.\n\t\t\t\tmAccessibilityBuffer = new StringBuffer(mCodeMatcher.replaceAll(\" \"));\n\n\t\t\t\t// Apply Backspaces using backspace character sequence\n\t\t\t\tint i = mAccessibilityBuffer.indexOf(BACKSPACE_CODE);\n\t\t\t\twhile (i != -1) {\n\t\t\t\t\tmAccessibilityBuffer = mAccessibilityBuffer.replace(i == 0 ? 0 : i - 1, i\n\t\t\t\t\t\t\t+ BACKSPACE_CODE.length(), \"\");\n\t\t\t\t\ti = mAccessibilityBuffer.indexOf(BACKSPACE_CODE);\n\t\t\t\t}\n\n\t\t\t\tif (mAccessibilityBuffer.length() > 0) {\n\t\t\t\t\tAccessibilityEvent event = AccessibilityEvent.obtain(\n\t\t\t\t\t\t\tAccessibilityEvent.TYPE_VIEW_TEXT_CHANGED);\n\t\t\t\t\tevent.setFromIndex(0);\n\t\t\t\t\tevent.setAddedCount(mAccessibilityBuffer.length());\n\t\t\t\t\tevent.getText().add(mAccessibilityBuffer);\n\n\t\t\t\t\tsendAccessibilityEventUnchecked(event);\n\t\t\t\t\tmAccessibilityBuffer.setLength(0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate class AccessibilityStateTester extends AsyncTask<Void, Void, Boolean> {\n\t\t@Override\n\t\tprotected Boolean doInBackground(Void... params) {\n\t\t\t/*\n\t\t\t * Presumably if the accessibility manager is not enabled, we don't\n\t\t\t * need to send accessibility events.\n\t\t\t */\n\t\t\tfinal AccessibilityManager accessibility = (AccessibilityManager) context\n\t\t\t\t\t.getSystemService(Context.ACCESSIBILITY_SERVICE);\n\t\t\tif (!accessibility.isEnabled()) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Restrict the set of intents to only accessibility services that\n\t\t\t * have the category FEEDBACK_SPOKEN (aka, screen readers).\n\t\t\t */\n\t\t\tfinal Intent screenReaderIntent = new Intent(SCREENREADER_INTENT_ACTION);\n\t\t\tscreenReaderIntent.addCategory(SCREENREADER_INTENT_CATEGORY);\n\n\t\t\tfinal ContentResolver cr = context.getContentResolver();\n\n\t\t\tfinal List<ResolveInfo> screenReaders = context.getPackageManager().queryIntentServices(\n\t\t\t\t\tscreenReaderIntent, 0);\n\n\t\t\tboolean foundScreenReader = false;\n\n\t\t\tfinal int N = screenReaders.size();\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfinal ResolveInfo screenReader = screenReaders.get(i);\n\n\t\t\t\t/*\n\t\t\t\t * All screen readers are expected to implement a content\n\t\t\t\t * provider that responds to:\n\t\t\t\t * content://<nameofpackage>.providers.StatusProvider\n\t\t\t\t */\n\t\t\t\tfinal Cursor cursor = cr.query(\n\t\t\t\t\t\tUri.parse(\"content://\" + screenReader.serviceInfo.packageName\n\t\t\t\t\t\t\t\t+ \".providers.StatusProvider\"), null, null, null, null);\n\t\t\t\tif (cursor != null && cursor.moveToFirst()) {\n\t\t\t\t\t/*\n\t\t\t\t\t * These content providers use a special cursor that only has\n\t\t\t\t\t * one element, an integer that is 1 if the screen reader is\n\t\t\t\t\t * running.\n\t\t\t\t\t */\n\t\t\t\t\tfinal int status = cursor.getInt(0);\n\n\t\t\t\t\tcursor.close();\n\n\t\t\t\t\tif (status == 1) {\n\t\t\t\t\t\tfoundScreenReader = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (foundScreenReader) {\n\t\t\t\tmControlCodes = Pattern.compile(CONTROL_CODE_PATTERN);\n\t\t\t}\n\n\t\t\treturn foundScreenReader;\n\t\t}\n\n\t\t@Override\n\t\tprotected void onPostExecute(Boolean result) {\n\t\t\tmAccessibilityActive = result;\n\n\t\t\tmAccessibilityInitialized = true;\n\n\t\t\tif (result) {\n\t\t\t\tmEventSender = new AccessibilityEventSender();\n\t\t\t\tpostDelayed(mEventSender, ACCESSIBILITY_EVENT_THRESHOLD);\n\t\t\t} else {\n\t\t\t\tmAccessibilityBuffer = null;\n\t\t\t}\n\t\t}\n\t}\n}\n","lineNo":405}
{"Smelly Sample":"/*\n * ConnectBot: simple, powerful, open-source SSH client for Android\n * Copyright 2007 Kenny Root, Jeffrey Sharkey\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.connectbot;\n\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.connectbot.bean.SelectionArea;\nimport org.connectbot.service.FontSizeChangedListener;\nimport org.connectbot.service.TerminalBridge;\nimport org.connectbot.service.TerminalKeyListener;\nimport org.connectbot.util.TerminalViewPager;\n\nimport android.annotation.TargetApi;\nimport android.app.Activity;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.pm.ResolveInfo;\nimport android.database.Cursor;\nimport android.graphics.Canvas;\nimport android.graphics.Color;\nimport android.graphics.Matrix;\nimport android.graphics.Paint;\nimport android.graphics.Path;\nimport android.graphics.PixelXorXfermode;\nimport android.graphics.RectF;\nimport android.graphics.Typeface;\nimport android.net.Uri;\nimport android.os.AsyncTask;\nimport android.os.Build;\nimport android.support.v4.view.MotionEventCompat;\nimport android.text.ClipboardManager;\nimport android.view.ActionMode;\nimport android.view.GestureDetector;\nimport android.view.InputDevice;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.MotionEvent;\nimport android.view.ViewGroup.LayoutParams;\nimport android.view.accessibility.AccessibilityEvent;\nimport android.view.accessibility.AccessibilityManager;\nimport android.view.inputmethod.BaseInputConnection;\nimport android.view.inputmethod.EditorInfo;\nimport android.view.inputmethod.InputConnection;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport de.mud.terminal.VDUBuffer;\nimport de.mud.terminal.vt320;\n\n/**\n * User interface {@link TextView} for showing a TerminalBridge in an\n * {@link android.app.Activity}. Handles drawing bitmap updates and passing keystrokes down\n * to terminal.\n *\n * On Honeycomb devices and above (>= APIv11), a TextView with transparent text (which is identical\n * to the bitmap) is drawn above the bitmap. This TextView exists to allow the user to\n * select and copy text.\n *\n * @author jsharkey\n */\npublic class TerminalView extends TextView implements FontSizeChangedListener {\n\n\tprivate final Context context;\n\tpublic final TerminalBridge bridge;\n\n\tprivate final TerminalViewPager viewPager;\n\tprivate GestureDetector gestureDetector;\n\n\tprivate ClipboardManager clipboard;\n\tprivate ActionMode selectionActionMode = null;\n\tprivate String currentSelection = \"\";\n\n\t// These are only used for pre-Honeycomb copying.\n\tprivate int lastTouchedRow, lastTouchedCol;\n\n\tprivate final Paint paint;\n\tprivate final Paint cursorPaint;\n\tprivate final Paint cursorStrokePaint;\n\n\t// Cursor paints to distinguish modes\n\tprivate Path ctrlCursor, altCursor, shiftCursor;\n\tprivate RectF tempSrc, tempDst;\n\tprivate Matrix scaleMatrix;\n\tprivate static final Matrix.ScaleToFit scaleType = Matrix.ScaleToFit.FILL;\n\n\tprivate Toast notification = null;\n\tprivate String lastNotification = null;\n\tprivate volatile boolean notifications = true;\n\n\t// Related to Accessibility Features\n\tprivate boolean mAccessibilityInitialized = false;\n\tprivate boolean mAccessibilityActive = true;\n\tprivate Object[] mAccessibilityLock = new Object[0];\n\tprivate StringBuffer mAccessibilityBuffer;\n\tprivate Pattern mControlCodes = null;\n\tprivate Matcher mCodeMatcher = null;\n\tprivate AccessibilityEventSender mEventSender = null;\n\n\tprivate static final String BACKSPACE_CODE = \"\\\\x08\\\\x1b\\\\[K\";\n\tprivate static final String CONTROL_CODE_PATTERN = \"\\\\x1b\\\\[K[^m]+[m|:]\";\n\n\tprivate static final int ACCESSIBILITY_EVENT_THRESHOLD = 1000;\n\tprivate static final String SCREENREADER_INTENT_ACTION = \"android.accessibilityservice.AccessibilityService\";\n\tprivate static final String SCREENREADER_INTENT_CATEGORY = \"android.accessibilityservice.category.FEEDBACK_SPOKEN\";\n\n\tpublic TerminalView(Context context, TerminalBridge bridge, TerminalViewPager pager) {\n\t\tsuper(context);\n\n\t\tthis.context = context;\n\t\tthis.bridge = bridge;\n\t\tthis.viewPager = pager;\n\n\t\tsetLayoutParams(new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT));\n\t\tsetFocusable(true);\n\t\tsetFocusableInTouchMode(true);\n\n\t\tpaint = new Paint();\n\n\t\tcursorPaint = new Paint();\n\t\tcursorPaint.setColor(bridge.color[bridge.defaultFg]);\n\t\tcursorPaint.setXfermode(new PixelXorXfermode(bridge.color[bridge.defaultBg]));\n\t\tcursorPaint.setAntiAlias(true);\n\n\t\tcursorStrokePaint = new Paint(cursorPaint);\n\t\tcursorStrokePaint.setStrokeWidth(0.1f);\n\t\tcursorStrokePaint.setStyle(Paint.Style.STROKE);\n\n\t\t/*\n\t\t * Set up our cursor indicators on a 1x1 Path object which we can later\n\t\t * transform to our character width and height\n\t\t */\n\t\t// TODO make this into a resource somehow\n\t\tshiftCursor = new Path();\n\t\tshiftCursor.lineTo(0.5f, 0.33f);\n\t\tshiftCursor.lineTo(1.0f, 0.0f);\n\n\t\taltCursor = new Path();\n\t\taltCursor.moveTo(0.0f, 1.0f);\n\t\taltCursor.lineTo(0.5f, 0.66f);\n\t\taltCursor.lineTo(1.0f, 1.0f);\n\n\t\tctrlCursor = new Path();\n\t\tctrlCursor.moveTo(0.0f, 0.25f);\n\t\tctrlCursor.lineTo(1.0f, 0.5f);\n\t\tctrlCursor.lineTo(0.0f, 0.75f);\n\n\t\t// For creating the transform when the terminal resizes\n\t\ttempSrc = new RectF();\n\t\ttempSrc.set(0.0f, 0.0f, 1.0f, 1.0f);\n\t\ttempDst = new RectF();\n\t\tscaleMatrix = new Matrix();\n\n\t\tbridge.addFontSizeChangedListener(this);\n\t\tbridge.parentChanged(this);\n\n\t\t// connect our view up to the bridge\n\t\tsetOnKeyListener(bridge.getKeyHandler());\n\n\t\tmAccessibilityBuffer = new StringBuffer();\n\n\t\t// Enable accessibility features if a screen reader is active.\n\t\tnew AccessibilityStateTester().execute((Void) null);\n\n\t\tclipboard = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE);\n\n\t\tsetTextColor(Color.TRANSPARENT);\n\t\tsetTypeface(Typeface.MONOSPACE);\n\t\tonFontSizeChanged(bridge.getFontSize());\n\n\t\t// Allow selection of and copying text for Honeycomb and above devices.\n\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {\n\t\t\tsetTextIsSelectable(true);\n\t\t\tsetCustomSelectionActionModeCallback(new TextSelectionActionModeCallback());\n\t\t}\n\n\t\tgestureDetector = new GestureDetector(context, new GestureDetector.SimpleOnGestureListener() {\n\t\t\tprivate TerminalBridge bridge = TerminalView.this.bridge;\n\t\t\tprivate float totalY = 0;\n\n\t\t\t@Override\n\t\t\tpublic boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {\n\t\t\t\t// if releasing then reset total scroll\n\t\t\t\tif (e2.getAction() == MotionEvent.ACTION_UP) {\n\t\t\t\t\ttotalY = 0;\n\t\t\t\t}\n\n\t\t\t\ttotalY += distanceY;\n\t\t\t\tfinal int moved = (int) (totalY / bridge.charHeight);\n\n\t\t\t\tif (moved != 0) {\n\t\t\t\t\tint base = bridge.buffer.getWindowBase();\n\t\t\t\t\tbridge.buffer.setWindowBase(base + moved);\n\t\t\t\t\ttotalY = 0;\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean onSingleTapConfirmed(MotionEvent e) {\n\t\t\t\tviewPager.performClick();\n\t\t\t\treturn super.onSingleTapConfirmed(e);\n\t\t\t}\n\t\t});\n\t}\n\n\t@TargetApi(11)\n\tprivate void closeSelectionActionMode() {\n\t\tif (selectionActionMode != null) {\n\t\t\tselectionActionMode.finish();\n\t\t\tselectionActionMode = null;\n\t\t}\n\t}\n\n\tpublic void copyCurrentSelectionToClipboard() {\n\t\tClipboardManager clipboard =\n\t\t\t\t(ClipboardManager) TerminalView.this.context.getSystemService(Context.CLIPBOARD_SERVICE);\n\t\tif (currentSelection.length() != 0) {\n\t\t\tclipboard.setText(currentSelection);\n\t\t}\n\n\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {\n\t\t\tcloseSelectionActionMode();\n\t\t}\n\t}\n\n\t@Override\n\tprotected void onSelectionChanged(int selStart, int selEnd) {\n\t\tif (selStart <= selEnd) {\n\t\t\tcurrentSelection = getText().toString().substring(selStart, selEnd);\n\t\t}\n\t\tsuper.onSelectionChanged(selStart, selEnd);\n\t}\n\n\t@Override\n\tpublic boolean onTouchEvent(MotionEvent event) {\n\t\tif (event.getAction() == MotionEvent.ACTION_DOWN) {\n\t\t\t// Selection may be beginning. Sync the TextView with the buffer.\n\t\t\trefreshTextFromBuffer();\n\t\t}\n\n\t\t// Mouse input is treated differently:\n\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH &&\n\t\t\t\tMotionEventCompat.getSource(event) == InputDevice.SOURCE_MOUSE) {\n\t\t\tif (onMouseEvent(event, bridge)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tviewPager.setPagingEnabled(true);\n\t\t} else if (gestureDetector != null) {\n\t\t\t// The gesture detector should not be called if touch event was from mouse.\n\t\t\tgestureDetector.onTouchEvent(event);\n\t\t}\n\n\t\t// Old version of copying, only for pre-Honeycomb.\n\t\tif (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB) {\n\t\t\t// when copying, highlight the area\n\t\t\tif (bridge.isSelectingForCopy()) {\n\t\t\t\tSelectionArea area = bridge.getSelectionArea();\n\t\t\t\tint row = (int) Math.floor(event.getY() / bridge.charHeight);\n\t\t\t\tint col = (int) Math.floor(event.getX() / bridge.charWidth);\n\n\t\t\t\tswitch (event.getAction()) {\n\t\t\t\tcase MotionEvent.ACTION_DOWN:\n\t\t\t\t\t// recording starting area\n\t\t\t\t\tviewPager.setPagingEnabled(false);\n\t\t\t\t\tif (area.isSelectingOrigin()) {\n\t\t\t\t\t\tarea.setRow(row);\n\t\t\t\t\t\tarea.setColumn(col);\n\t\t\t\t\t\tlastTouchedRow = row;\n\t\t\t\t\t\tlastTouchedCol = col;\n\t\t\t\t\t\tbridge.redraw();\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\tcase MotionEvent.ACTION_MOVE:\n\t\t\t\t\t\t\t/* ignore when user hasn't moved since last time so\n\t\t\t\t\t\t\t * we can fine-tune with directional pad\n\t\t\t\t\t\t\t */\n\t\t\t\t\tif (row == lastTouchedRow && col == lastTouchedCol)\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t// if the user moves, start the selection for other corner\n\t\t\t\t\tarea.finishSelectingOrigin();\n\n\t\t\t\t\t// update selected area\n\t\t\t\t\tarea.setRow(row);\n\t\t\t\t\tarea.setColumn(col);\n\t\t\t\t\tlastTouchedRow = row;\n\t\t\t\t\tlastTouchedCol = col;\n\t\t\t\t\tbridge.redraw();\n\t\t\t\t\treturn true;\n\t\t\t\tcase MotionEvent.ACTION_UP:\n\t\t\t\t\t\t\t/* If they didn't move their finger, maybe they meant to\n\t\t\t\t\t\t\t * select the rest of the text with the directional pad.\n\t\t\t\t\t\t\t */\n\t\t\t\t\tif (area.getLeft() == area.getRight() &&\n\t\t\t\t\t\t\tarea.getTop() == area.getBottom()) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\t// copy selected area to clipboard\n\t\t\t\t\tString copiedText = area.copyFrom(bridge.buffer);\n\n\t\t\t\t\tclipboard.setText(copiedText);\n\t\t\t\t\tToast.makeText(\n\t\t\t\t\t\tcontext,\n\t\t\t\t\t\tcontext.getString(R.string.console_copy_done, copiedText.length()),\n\t\t\t\t\t\tToast.LENGTH_LONG).show();\n\n\t\t\t\t\t// fall through to clear state\n\n\t\t\t\tcase MotionEvent.ACTION_CANCEL:\n\t\t\t\t\t// make sure we clear any highlighted area\n\t\t\t\t\tarea.reset();\n\t\t\t\t\tbridge.setSelectingForCopy(false);\n\t\t\t\t\tbridge.redraw();\n\t\t\t\t\tviewPager.setPagingEnabled(true);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\tsuper.onTouchEvent(event);\n\n\t\treturn true;\n\t}\n\n\t@TargetApi(11)\n\tprivate class TextSelectionActionModeCallback implements ActionMode.Callback {\n\t\tprivate static final int COPY = 0;\n\t\tprivate static final int PASTE = 1;\n\n\t\t@Override\n\t\tpublic boolean onPrepareActionMode(ActionMode mode, Menu menu) {\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean onCreateActionMode(ActionMode mode, Menu menu) {\n\t\t\tTerminalView.this.selectionActionMode = mode;\n\n\t\t\tmenu.clear();\n\n\t\t\tmenu.add(0, COPY, 0, R.string.console_menu_copy)\n\t\t\t\t\t.setIcon(R.drawable.ic_action_copy)\n\t\t\t\t\t.setShowAsAction(MenuItem.SHOW_AS_ACTION_WITH_TEXT | MenuItem.SHOW_AS_ACTION_IF_ROOM);\n\t\t\tmenu.add(0, PASTE, 1, R.string.console_menu_paste)\n\t\t\t\t\t.setIcon(R.drawable.ic_action_paste)\n\t\t\t\t\t.setShowAsAction(MenuItem.SHOW_AS_ACTION_WITH_TEXT | MenuItem.SHOW_AS_ACTION_IF_ROOM);\n\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean onActionItemClicked(ActionMode mode, MenuItem item) {\n\t\t\tswitch (item.getItemId()) {\n\t\t\tcase COPY:\n\t\t\t\tcopyCurrentSelectionToClipboard();\n\t\t\t\treturn true;\n\t\t\tcase PASTE:\n\t\t\t\tString clip = clipboard.getText().toString();\n\t\t\t\tTerminalView.this.bridge.injectString(clip);\n\t\t\t\tmode.finish();\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic void onDestroyActionMode(ActionMode mode) {\n\t\t}\n\t}\n\n\t/**\n\t * @param event\n\t * @param bridge\n\t * @return True if the event is handled.\n\t */\n\t@TargetApi(14)\n\tprivate boolean onMouseEvent(MotionEvent event, TerminalBridge bridge) {\n\t\tint row = (int) Math.floor(event.getY() / bridge.charHeight);\n\t\tint col = (int) Math.floor(event.getX() / bridge.charWidth);\n\t\tint meta = event.getMetaState();\n\t\tboolean shiftOn = (meta & KeyEvent.META_SHIFT_ON) != 0;\n\t\tboolean mouseReport = ((vt320) bridge.buffer).isMouseReportEnabled();\n\n\t\t// MouseReport can be \"defeated\" using the shift key.\n\t\tif (!mouseReport || shiftOn) {\n\t\t\tif (event.getAction() == MotionEvent.ACTION_DOWN) {\n\t\t\t\tif (event.getButtonState() == MotionEvent.BUTTON_TERTIARY) {\n\t\t\t\t\t// Middle click pastes.\n\t\t\t\t\tString clip = clipboard.getText().toString();\n\t\t\t\t\tbridge.injectString(clip);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\t// Begin \"selection mode\"\n\n\t\t\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {\n\t\t\t\t\tcloseSelectionActionMode();\n\t\t\t\t}\n\t\t\t} else if (event.getAction() == MotionEvent.ACTION_MOVE) {\n\t\t\t\t// In the middle of selection.\n\n\t\t\t\tif (selectionActionMode == null) {\n\t\t\t\t\tselectionActionMode = startActionMode(new TextSelectionActionModeCallback());\n\t\t\t\t}\n\n\t\t\t\tint selectionStart = getSelectionStart();\n\t\t\t\tint selectionEnd = getSelectionEnd();\n\n\t\t\t\tif (selectionStart > selectionEnd) {\n\t\t\t\t\tint tempStart = selectionStart;\n\t\t\t\t\tselectionStart = selectionEnd;\n\t\t\t\t\tselectionEnd = tempStart;\n\t\t\t\t}\n\n\t\t\t\tcurrentSelection = getText().toString().substring(selectionStart, selectionEnd);\n\t\t\t}\n\t\t} else if (event.getAction() == MotionEvent.ACTION_DOWN) {\n\t\t\tviewPager.setPagingEnabled(false);\n\t\t\t((vt320) bridge.buffer).mousePressed(\n\t\t\t\tcol, row, mouseEventToJavaModifiers(event));\n\t\t\treturn true;\n\t\t} else if (event.getAction() == MotionEvent.ACTION_UP) {\n\t\t\tviewPager.setPagingEnabled(true);\n\t\t\t((vt320) bridge.buffer).mouseReleased(col, row);\n\t\t\treturn true;\n\t\t} else if (event.getAction() == MotionEvent.ACTION_MOVE) {\n\t\t\tint buttonState = event.getButtonState();\n\t\t\tint button = (buttonState & MotionEvent.BUTTON_PRIMARY) != 0 ? 0 :\n\t\t\t\t(buttonState & MotionEvent.BUTTON_SECONDARY) != 0 ? 1 :\n\t\t\t\t(buttonState & MotionEvent.BUTTON_TERTIARY) != 0 ? 2 : 3;\n\t\t\t((vt320) bridge.buffer).mouseMoved(\n\t\t\t\tbutton,\n\t\t\t\tcol,\n\t\t\t\trow,\n\t\t\t\t(meta & KeyEvent.META_CTRL_ON) != 0,\n\t\t\t\t(meta & KeyEvent.META_SHIFT_ON) != 0,\n\t\t\t\t(meta & KeyEvent.META_META_ON) != 0);\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Takes an android mouse event and produces a Java InputEvent modifiers int which can be\n\t * passed to vt320.\n\t * @param mouseEvent The {@link MotionEvent} which should be a mouse click or release.\n\t * @return A Java InputEvent modifier int. See\n\t * http://docs.oracle.com/javase/7/docs/api/java/awt/event/InputEvent.html\n\t */\n\t@TargetApi(14)\n\tprivate static int mouseEventToJavaModifiers(MotionEvent mouseEvent) {\n\t\tif (MotionEventCompat.getSource(mouseEvent) != InputDevice.SOURCE_MOUSE) return 0;\n\n\t\tint mods = 0;\n\n\t\t// See http://docs.oracle.com/javase/7/docs/api/constant-values.html\n\t\tint buttonState = mouseEvent.getButtonState();\n\t\tif ((buttonState & MotionEvent.BUTTON_PRIMARY) != 0)\n\t\t\tmods |= 16;\n\t\tif ((buttonState & MotionEvent.BUTTON_SECONDARY) != 0)\n\t\t\tmods |= 8;\n\t\tif ((buttonState & MotionEvent.BUTTON_TERTIARY) != 0)\n\t\t\tmods |= 4;\n\n\t\t// Note: Meta and Ctrl are intentionally swapped here to keep logic in vt320 simple.\n\t\tint meta = mouseEvent.getMetaState();\n\t\tif ((meta & KeyEvent.META_META_ON) != 0)\n\t\t\tmods |= 2;\n\t\tif ((meta & KeyEvent.META_SHIFT_ON) != 0)\n\t\t\tmods |= 1;\n\t\tif ((meta & KeyEvent.META_CTRL_ON) != 0)\n\t\t\tmods |= 4;\n\n\t\treturn mods;\n\t}\n\n\t@Override\n\t@TargetApi(12)\n\tpublic boolean onGenericMotionEvent(MotionEvent event) {\n\t\tif ((MotionEventCompat.getSource(event) & InputDevice.SOURCE_CLASS_POINTER) != 0) {\n\t\t\tswitch (event.getAction()) {\n\t\t\tcase MotionEvent.ACTION_SCROLL:\n\t\t\t\t// Process scroll wheel movement:\n\t\t\t\tfloat yDistance = MotionEventCompat.getAxisValue(event, MotionEvent.AXIS_VSCROLL);\n\t\t\t\tboolean mouseReport = ((vt320) bridge.buffer).isMouseReportEnabled();\n\t\t\t\tif (mouseReport) {\n\t\t\t\t\tint row = (int) Math.floor(event.getY() / bridge.charHeight);\n\t\t\t\t\tint col = (int) Math.floor(event.getX() / bridge.charWidth);\n\n\t\t\t\t\t\t\t((vt320) bridge.buffer).mouseWheel(\n\t\t\t\t\t\t\t\t\t\t\tyDistance > 0,\n\t\t\t\t\t\t\t\t\t\t\tcol,\n\t\t\t\t\t\t\t\t\t\t\trow,\n\t\t\t\t\t\t\t\t\t\t\t(event.getMetaState() & KeyEvent.META_CTRL_ON) != 0,\n\t\t\t\t\t\t\t\t\t\t\t(event.getMetaState() & KeyEvent.META_SHIFT_ON) != 0,\n\t\t\t\t\t\t\t\t\t\t\t(event.getMetaState() & KeyEvent.META_META_ON) != 0);\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (yDistance != 0) {\n\t\t\t\t\tint base = bridge.buffer.getWindowBase();\n\t\t\t\t\tbridge.buffer.setWindowBase(base - Math.round(yDistance));\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn super.onGenericMotionEvent(event);\n\t}\n\n\t// TODO: cleanup and possibly optimize\n\tprivate void refreshTextFromBuffer() {\n\t\tif (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB) {\n\t\t\t// Do not run this function because the textView is not selectable pre-Honeycomb.\n\t\t\treturn;\n\t\t}\n\n\t\tVDUBuffer vb = bridge.getVDUBuffer();\n\n\t\tString line = \"\";\n\t\tString buffer = \"\";\n\n\t\tint windowBase = vb.getWindowBase();\n\t\tint rowBegin = vb.getTopMargin();\n\t\tint rowEnd = vb.getBottomMargin();\n\t\tint numCols = vb.getColumns() - 1;\n\n\t\tfor (int r = rowBegin; r <= rowEnd; r++) {\n\t\t\tfor (int c = 0; c < numCols; c++) {\n\t\t\t\tline += vb.charArray[windowBase + r][c];\n\t\t\t}\n\t\t\tbuffer += line.replaceAll(\"\\\\s+$\", \"\") + \"\\n\";\n\t\t\tline = \"\";\n\t\t}\n\n\t\tsetText(buffer);\n\t}\n\n\t/**\n\t * Only intended for pre-Honeycomb devices.\n\t */\n\tpublic void startPreHoneycombCopyMode() {\n\t\t// mark as copying and reset any previous bounds\n\t\tSelectionArea area = bridge.getSelectionArea();\n\t\tarea.reset();\n\t\tarea.setBounds(bridge.buffer.getColumns(), bridge.buffer.getRows());\n\n\t\tbridge.setSelectingForCopy(true);\n\n\t\t// Make sure we show the initial selection\n\t\tbridge.redraw();\n\t}\n\n\tpublic void destroy() {\n\t\t// tell bridge to destroy its bitmap\n\t\tbridge.parentDestroyed();\n\t}\n\n\t@Override\n\tprotected void onSizeChanged(int w, int h, int oldw, int oldh) {\n\t\tsuper.onSizeChanged(w, h, oldw, oldh);\n\n\t\tbridge.parentChanged(this);\n\n\t\tscaleCursors();\n\t}\n\n\tpublic void onFontSizeChanged(final float size) {\n\t\tscaleCursors();\n\n\t\t((Activity) context).runOnUiThread(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tsetTextSize(size);\n\n\t\t\t\t// For the TextView to line up with the bitmap text, lineHeight must be equal to\n\t\t\t\t// the bridge's charHeight. See TextView.getLineHeight(), which has been reversed to\n\t\t\t\t// derive lineSpacingMultiplier.\n\t\t\t\tfloat lineSpacingMultiplier = (float) bridge.charHeight / getPaint().getFontMetricsInt(null);\n\t\t\t\tsetLineSpacing(0.0f, lineSpacingMultiplier);\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate void scaleCursors() {\n\t\t// Create a scale matrix to scale our 1x1 representation of the cursor\n\t\ttempDst.set(0.0f, 0.0f, bridge.charWidth, bridge.charHeight);\n\t\tscaleMatrix.setRectToRect(tempSrc, tempDst, scaleType);\n\t}\n\n\t@Override\n\tpublic void onDraw(Canvas canvas) {\n\t\tif (bridge.bitmap != null) {\n\t\t\t// draw the bitmap\n\t\t\tbridge.onDraw();\n\n\t\t\t// draw the bridge bitmap if it exists\n\t\t\tcanvas.drawBitmap(bridge.bitmap, 0, 0, paint);\n\n\t\t\t// also draw cursor if visible\n\t\t\tif (bridge.buffer.isCursorVisible()) {\n\t\t\t\tint cursorColumn = bridge.buffer.getCursorColumn();\n\t\t\t\tfinal int cursorRow = bridge.buffer.getCursorRow();\n\n\t\t\t\tfinal int columns = bridge.buffer.getColumns();\n\n\t\t\t\tif (cursorColumn == columns)\n\t\t\t\t\tcursorColumn = columns - 1;\n\n\t\t\t\tif (cursorColumn < 0 || cursorRow < 0)\n\t\t\t\t\treturn;\n\n\t\t\t\tint currentAttribute = bridge.buffer.getAttributes(\n\t\t\t\t\t\tcursorColumn, cursorRow);\n\t\t\t\tboolean onWideCharacter = (currentAttribute & VDUBuffer.FULLWIDTH) != 0;\n\n\t\t\t\tint x = cursorColumn * bridge.charWidth;\n\t\t\t\tint y = (bridge.buffer.getCursorRow()\n\t\t\t\t\t\t+ bridge.buffer.screenBase - bridge.buffer.windowBase)\n\t\t\t\t\t\t* bridge.charHeight;\n\n\t\t\t\t// Save the current clip and translation\n\t\t\t\tcanvas.save();\n\n\t\t\t\tcanvas.translate(x, y);\n\t\t\t\tcanvas.clipRect(0, 0,\n\t\t\t\t\t\tbridge.charWidth * (onWideCharacter ? 2 : 1),\n\t\t\t\t\t\tbridge.charHeight);\n\t\t\t\tcanvas.drawPaint(cursorPaint);\n\n\t\t\t\tfinal int deadKey = bridge.getKeyHandler().getDeadKey();\n\t\t\t\tif (deadKey != 0) {\n\t\t\t\t\tcanvas.drawText(new char[] { (char) deadKey }, 0, 1, 0, 0, cursorStrokePaint);\n\t\t\t\t}\n\n\t\t\t\t// Make sure we scale our decorations to the correct size.\n\t\t\t\tcanvas.concat(scaleMatrix);\n\n\t\t\t\tint metaState = bridge.getKeyHandler().getMetaState();\n\n\t\t\t\tif ((metaState & TerminalKeyListener.OUR_SHIFT_ON) != 0)\n\t\t\t\t\tcanvas.drawPath(shiftCursor, cursorStrokePaint);\n\t\t\t\telse if ((metaState & TerminalKeyListener.OUR_SHIFT_LOCK) != 0)\n\t\t\t\t\tcanvas.drawPath(shiftCursor, cursorPaint);\n\n\t\t\t\tif ((metaState & TerminalKeyListener.OUR_ALT_ON) != 0)\n\t\t\t\t\tcanvas.drawPath(altCursor, cursorStrokePaint);\n\t\t\t\telse if ((metaState & TerminalKeyListener.OUR_ALT_LOCK) != 0)\n\t\t\t\t\tcanvas.drawPath(altCursor, cursorPaint);\n\n\t\t\t\tif ((metaState & TerminalKeyListener.OUR_CTRL_ON) != 0)\n\t\t\t\t\tcanvas.drawPath(ctrlCursor, cursorStrokePaint);\n\t\t\t\telse if ((metaState & TerminalKeyListener.OUR_CTRL_LOCK) != 0)\n\t\t\t\t\tcanvas.drawPath(ctrlCursor, cursorPaint);\n\n\t\t\t\t// Restore previous clip region\n\t\t\t\tcanvas.restore();\n\t\t\t}\n\n\t\t\t// draw any highlighted area\n\t\t\tif (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB &&\n\t\t\t\tbridge.isSelectingForCopy()) {\n\t\t\t\tSelectionArea area = bridge.getSelectionArea();\n\t\t\t\tcanvas.save(Canvas.CLIP_SAVE_FLAG);\n\t\t\t\tcanvas.clipRect(\n\t\t\t\t\tarea.getLeft() * bridge.charWidth,\n\t\t\t\t\tarea.getTop() * bridge.charHeight,\n\t\t\t\t\t(area.getRight() + 1) * bridge.charWidth,\n\t\t\t\t\t(area.getBottom() + 1) * bridge.charHeight\n\t\t\t\t);\n\t\t\t\tcanvas.drawPaint(cursorPaint);\n\t\t\t\tcanvas.restore();\n\t\t\t}\n\t\t}\n\n\t\tsuper.onDraw(canvas);\n\t}\n\n\tpublic void notifyUser(String message) {\n\t\tif (!notifications)\n\t\t\treturn;\n\n\t\tif (notification != null) {\n\t\t\t// Don't keep telling the user the same thing.\n\t\t\tif (lastNotification != null && lastNotification.equals(message))\n\t\t\t\treturn;\n\n\t\t\tnotification.setText(message);\n\t\t\tnotification.show();\n\t\t} else {\n\t\t\tnotification = Toast.makeText(context, message, Toast.LENGTH_SHORT);\n\t\t\tnotification.show();\n\t\t}\n\n\t\tlastNotification = message;\n\t}\n\n\t/**\n\t * Ask the {@link TerminalBridge} we're connected to to resize to a specific size.\n\t * @param width\n\t * @param height\n\t */\n\tpublic void forceSize(int width, int height) {\n\t\tbridge.resizeComputed(width, height, getWidth(), getHeight());\n\t}\n\n\t/**\n\t * Sets the ability for the TerminalView to display Toast notifications to the user.\n\t * @param value whether to enable notifications or not\n\t */\n\tpublic void setNotifications(boolean value) {\n\t\tnotifications = value;\n\t}\n\n\t@Override\n\tpublic boolean onCheckIsTextEditor() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic InputConnection onCreateInputConnection(EditorInfo outAttrs) {\n\t\toutAttrs.imeOptions |=\n\t\t\tEditorInfo.IME_FLAG_NO_EXTRACT_UI |\n\t\t\tEditorInfo.IME_FLAG_NO_ENTER_ACTION |\n\t\t\tEditorInfo.IME_ACTION_NONE;\n\t\toutAttrs.inputType = EditorInfo.TYPE_NULL;\n\t\treturn new BaseInputConnection(this, false) {\n\t\t\t@Override\n\t\t\tpublic boolean deleteSurroundingText (int leftLength, int rightLength) {\n\t\t\t\tif (rightLength == 0 && leftLength == 0) {\n\t\t\t\t\treturn this.sendKeyEvent(new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_DEL));\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < leftLength; i++) {\n\t\t\t\t\tthis.sendKeyEvent(new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_DEL));\n\t\t\t\t}\n\t\t\t\t// TODO: forward delete\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\t}\n\n\tpublic void propagateConsoleText(char[] rawText, int length) {\n\t\tif (mAccessibilityActive) {\n\t\t\tsynchronized (mAccessibilityLock) {\n\t\t\t\tmAccessibilityBuffer.append(rawText, 0, length);\n\t\t\t}\n\n\t\t\tif (mAccessibilityInitialized) {\n\t\t\t\tif (mEventSender != null) {\n\t\t\t\t\tremoveCallbacks(mEventSender);\n\t\t\t\t} else {\n\t\t\t\t\tmEventSender = new AccessibilityEventSender();\n\t\t\t\t}\n\n\t\t\t\tpostDelayed(mEventSender, ACCESSIBILITY_EVENT_THRESHOLD);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate class AccessibilityEventSender implements Runnable {\n\t\tpublic void run() {\n\t\t\tsynchronized (mAccessibilityLock) {\n\t\t\t\tif (mCodeMatcher == null) {\n\t\t\t\t\tmCodeMatcher = mControlCodes.matcher(mAccessibilityBuffer);\n\t\t\t\t} else {\n\t\t\t\t\tmCodeMatcher.reset(mAccessibilityBuffer);\n\t\t\t\t}\n\n\t\t\t\t// Strip all control codes out.\n\t\t\t\tmAccessibilityBuffer = new StringBuffer(mCodeMatcher.replaceAll(\" \"));\n\n\t\t\t\t// Apply Backspaces using backspace character sequence\n\t\t\t\tint i = mAccessibilityBuffer.indexOf(BACKSPACE_CODE);\n\t\t\t\twhile (i != -1) {\n\t\t\t\t\tmAccessibilityBuffer = mAccessibilityBuffer.replace(i == 0 ? 0 : i - 1, i\n\t\t\t\t\t\t\t+ BACKSPACE_CODE.length(), \"\");\n\t\t\t\t\ti = mAccessibilityBuffer.indexOf(BACKSPACE_CODE);\n\t\t\t\t}\n\n\t\t\t\tif (mAccessibilityBuffer.length() > 0) {\n\t\t\t\t\tAccessibilityEvent event = AccessibilityEvent.obtain(\n\t\t\t\t\t\t\tAccessibilityEvent.TYPE_VIEW_TEXT_CHANGED);\n\t\t\t\t\tevent.setFromIndex(0);\n\t\t\t\t\tevent.setAddedCount(mAccessibilityBuffer.length());\n\t\t\t\t\tevent.getText().add(mAccessibilityBuffer);\n\n\t\t\t\t\tsendAccessibilityEventUnchecked(event);\n\t\t\t\t\tmAccessibilityBuffer.setLength(0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate class AccessibilityStateTester extends AsyncTask<Void, Void, Boolean> {\n\t\t@Override\n\t\tprotected Boolean doInBackground(Void... params) {\n\t\t\t/*\n\t\t\t * Presumably if the accessibility manager is not enabled, we don't\n\t\t\t * need to send accessibility events.\n\t\t\t */\n\t\t\tfinal AccessibilityManager accessibility = (AccessibilityManager) context\n\t\t\t\t\t.getSystemService(Context.ACCESSIBILITY_SERVICE);\n\t\t\tif (!accessibility.isEnabled()) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Restrict the set of intents to only accessibility services that\n\t\t\t * have the category FEEDBACK_SPOKEN (aka, screen readers).\n\t\t\t */\n\t\t\tfinal Intent screenReaderIntent = new Intent(SCREENREADER_INTENT_ACTION);\n\t\t\tscreenReaderIntent.addCategory(SCREENREADER_INTENT_CATEGORY);\n\n\t\t\tfinal ContentResolver cr = context.getContentResolver();\n\n\t\t\tfinal List<ResolveInfo> screenReaders = context.getPackageManager().queryIntentServices(\n\t\t\t\t\tscreenReaderIntent, 0);\n\n\t\t\tboolean foundScreenReader = false;\n\n\t\t\tfinal int N = screenReaders.size();\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfinal ResolveInfo screenReader = screenReaders.get(i);\n\n\t\t\t\t/*\n\t\t\t\t * All screen readers are expected to implement a content\n\t\t\t\t * provider that responds to:\n\t\t\t\t * content://<nameofpackage>.providers.StatusProvider\n\t\t\t\t */\n\t\t\t\tfinal Cursor cursor = cr.query(\n\t\t\t\t\t\tUri.parse(\"content://\" + screenReader.serviceInfo.packageName\n\t\t\t\t\t\t\t\t+ \".providers.StatusProvider\"), null, null, null, null);\n\t\t\t\tif (cursor != null && cursor.moveToFirst()) {\n\t\t\t\t\t/*\n\t\t\t\t\t * These content providers use a special cursor that only has\n\t\t\t\t\t * one element, an integer that is 1 if the screen reader is\n\t\t\t\t\t * running.\n\t\t\t\t\t */\n\t\t\t\t\tfinal int status = cursor.getInt(0);\n\n\t\t\t\t\tcursor.close();\n\n\t\t\t\t\tif (status == 1) {\n\t\t\t\t\t\tfoundScreenReader = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (foundScreenReader) {\n\t\t\t\tmControlCodes = Pattern.compile(CONTROL_CODE_PATTERN);\n\t\t\t}\n\n\t\t\treturn foundScreenReader;\n\t\t}\n\n\t\t@Override\n\t\tprotected void onPostExecute(Boolean result) {\n\t\t\tmAccessibilityActive = result;\n\n\t\t\tmAccessibilityInitialized = true;\n\n\t\t\tif (result) {\n\t\t\t\tmEventSender = new AccessibilityEventSender();\n\t\t\t\tpostDelayed(mEventSender, ACCESSIBILITY_EVENT_THRESHOLD);\n\t\t\t} else {\n\t\t\t\tmAccessibilityBuffer = null;\n\t\t\t}\n\t\t}\n\t}\n}\n","Method after Refactoring":"/*\n * ConnectBot: simple, powerful, open-source SSH client for Android\n * Copyright 2007 Kenny Root, Jeffrey Sharkey\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.connectbot;\n\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.connectbot.bean.SelectionArea;\nimport org.connectbot.service.FontSizeChangedListener;\nimport org.connectbot.service.TerminalBridge;\nimport org.connectbot.service.TerminalKeyListener;\nimport org.connectbot.util.TerminalViewPager;\n\nimport android.annotation.TargetApi;\nimport android.app.Activity;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.pm.ResolveInfo;\nimport android.database.Cursor;\nimport android.graphics.Canvas;\nimport android.graphics.Color;\nimport android.graphics.Matrix;\nimport android.graphics.Paint;\nimport android.graphics.Path;\nimport android.graphics.PixelXorXfermode;\nimport android.graphics.RectF;\nimport android.graphics.Typeface;\nimport android.net.Uri;\nimport android.os.AsyncTask;\nimport android.os.Build;\nimport android.support.v4.view.MotionEventCompat;\nimport android.text.ClipboardManager;\nimport android.view.ActionMode;\nimport android.view.GestureDetector;\nimport android.view.InputDevice;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.MotionEvent;\nimport android.view.ViewGroup.LayoutParams;\nimport android.view.accessibility.AccessibilityEvent;\nimport android.view.accessibility.AccessibilityManager;\nimport android.view.inputmethod.BaseInputConnection;\nimport android.view.inputmethod.EditorInfo;\nimport android.view.inputmethod.InputConnection;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport de.mud.terminal.VDUBuffer;\nimport de.mud.terminal.vt320;\n\n/**\n * User interface {@link TextView} for showing a TerminalBridge in an\n * {@link android.app.Activity}. Handles drawing bitmap updates and passing keystrokes down\n * to terminal.\n *\n * On Honeycomb devices and above (>= APIv11), a TextView with transparent text (which is identical\n * to the bitmap) is drawn above the bitmap. This TextView exists to allow the user to\n * select and copy text.\n *\n * @author jsharkey\n */\npublic class TerminalView extends TextView implements FontSizeChangedListener {\n\n\tprivate final Context context;\n\tpublic final TerminalBridge bridge;\n\n\tprivate final TerminalViewPager viewPager;\n\tprivate GestureDetector gestureDetector;\n\n\tprivate ClipboardManager clipboard;\n\tprivate ActionMode selectionActionMode = null;\n\tprivate String currentSelection = \"\";\n\n\t// These are only used for pre-Honeycomb copying.\n\tprivate int lastTouchedRow, lastTouchedCol;\n\n\tprivate final Paint paint;\n\tprivate final Paint cursorPaint;\n\tprivate final Paint cursorStrokePaint;\n\n\t// Cursor paints to distinguish modes\n\tprivate Path ctrlCursor, altCursor, shiftCursor;\n\tprivate RectF tempSrc, tempDst;\n\tprivate Matrix scaleMatrix;\n\tprivate static final Matrix.ScaleToFit scaleType = Matrix.ScaleToFit.FILL;\n\n\tprivate Toast notification = null;\n\tprivate String lastNotification = null;\n\tprivate volatile boolean notifications = true;\n\n\t// Related to Accessibility Features\n\tprivate boolean mAccessibilityInitialized = false;\n\tprivate boolean mAccessibilityActive = true;\n\tprivate Object[] mAccessibilityLock = new Object[0];\n\tprivate StringBuffer mAccessibilityBuffer;\n\tprivate Pattern mControlCodes = null;\n\tprivate Matcher mCodeMatcher = null;\n\tprivate AccessibilityEventSender mEventSender = null;\n\n\tprivate static final String BACKSPACE_CODE = \"\\\\x08\\\\x1b\\\\[K\";\n\tprivate static final String CONTROL_CODE_PATTERN = \"\\\\x1b\\\\[K[^m]+[m|:]\";\n\n\tprivate static final int ACCESSIBILITY_EVENT_THRESHOLD = 1000;\n\tprivate static final String SCREENREADER_INTENT_ACTION = \"android.accessibilityservice.AccessibilityService\";\n\tprivate static final String SCREENREADER_INTENT_CATEGORY = \"android.accessibilityservice.category.FEEDBACK_SPOKEN\";\n\n\tpublic TerminalView(Context context, TerminalBridge bridge, TerminalViewPager pager) {\n\t\tsuper(context);\n\n\t\tthis.context = context;\n\t\tthis.bridge = bridge;\n\t\tthis.viewPager = pager;\n\n\t\tsetLayoutParams(new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT));\n\t\tsetFocusable(true);\n\t\tsetFocusableInTouchMode(true);\n\n\t\tpaint = new Paint();\n\n\t\tcursorPaint = new Paint();\n\t\tcursorPaint.setColor(bridge.color[bridge.defaultFg]);\n\t\tcursorPaint.setXfermode(new PixelXorXfermode(bridge.color[bridge.defaultBg]));\n\t\tcursorPaint.setAntiAlias(true);\n\n\t\tcursorStrokePaint = new Paint(cursorPaint);\n\t\tcursorStrokePaint.setStrokeWidth(0.1f);\n\t\tcursorStrokePaint.setStyle(Paint.Style.STROKE);\n\n\t\t/*\n\t\t * Set up our cursor indicators on a 1x1 Path object which we can later\n\t\t * transform to our character width and height\n\t\t */\n\t\t// TODO make this into a resource somehow\n\t\tshiftCursor = new Path();\n\t\tshiftCursor.lineTo(0.5f, 0.33f);\n\t\tshiftCursor.lineTo(1.0f, 0.0f);\n\n\t\taltCursor = new Path();\n\t\taltCursor.moveTo(0.0f, 1.0f);\n\t\taltCursor.lineTo(0.5f, 0.66f);\n\t\taltCursor.lineTo(1.0f, 1.0f);\n\n\t\tctrlCursor = new Path();\n\t\tctrlCursor.moveTo(0.0f, 0.25f);\n\t\tctrlCursor.lineTo(1.0f, 0.5f);\n\t\tctrlCursor.lineTo(0.0f, 0.75f);\n\n\t\t// For creating the transform when the terminal resizes\n\t\ttempSrc = new RectF();\n\t\ttempSrc.set(0.0f, 0.0f, 1.0f, 1.0f);\n\t\ttempDst = new RectF();\n\t\tscaleMatrix = new Matrix();\n\n\t\tbridge.addFontSizeChangedListener(this);\n\t\tbridge.parentChanged(this);\n\n\t\t// connect our view up to the bridge\n\t\tsetOnKeyListener(bridge.getKeyHandler());\n\n\t\tmAccessibilityBuffer = new StringBuffer();\n\n\t\t// Enable accessibility features if a screen reader is active.\n\t\tnew AccessibilityStateTester().execute((Void) null);\n\n\t\tclipboard = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE);\n\n\t\tsetTextColor(Color.TRANSPARENT);\n\t\tsetTypeface(Typeface.MONOSPACE);\n\t\tonFontSizeChanged(bridge.getFontSize());\n\n\t\t// Allow selection of and copying text for Honeycomb and above devices.\n\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {\n\t\t\tsetTextIsSelectable(true);\n\t\t\tsetCustomSelectionActionModeCallback(new TextSelectionActionModeCallback());\n\t\t}\n\n\t\tgestureDetector = new GestureDetector(context, new GestureDetector.SimpleOnGestureListener() {\n\t\t\tprivate TerminalBridge bridge = TerminalView.this.bridge;\n\t\t\tprivate float totalY = 0;\n\n\t\t\t@Override\n\t\t\tpublic boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {\n\t\t\t\t// if releasing then reset total scroll\n\t\t\t\tif (e2.getAction() == MotionEvent.ACTION_UP) {\n\t\t\t\t\ttotalY = 0;\n\t\t\t\t}\n\n\t\t\t\ttotalY += distanceY;\n\t\t\t\tfinal int moved = (int) (totalY / bridge.charHeight);\n\n\t\t\t\tif (moved != 0) {\n\t\t\t\t\tint base = bridge.buffer.getWindowBase();\n\t\t\t\t\tbridge.buffer.setWindowBase(base + moved);\n\t\t\t\t\ttotalY = 0;\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean onSingleTapConfirmed(MotionEvent e) {\n\t\t\t\tviewPager.performClick();\n\t\t\t\treturn super.onSingleTapConfirmed(e);\n\t\t\t}\n\t\t});\n\t}\n\n\t@TargetApi(11)\n\tprivate void closeSelectionActionMode() {\n\t\tif (selectionActionMode != null) {\n\t\t\tselectionActionMode.finish();\n\t\t\tselectionActionMode = null;\n\t\t}\n\t}\n\n\tpublic void copyCurrentSelectionToClipboard() {\n\t\tClipboardManager clipboard =\n\t\t\t\t(ClipboardManager) TerminalView.this.context.getSystemService(Context.CLIPBOARD_SERVICE);\n\t\tif (currentSelection.length() != 0) {\n\t\t\tclipboard.setText(currentSelection);\n\t\t}\n\n\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {\n\t\t\tcloseSelectionActionMode();\n\t\t}\n\t}\n\n\t@Override\n\tprotected void onSelectionChanged(int selStart, int selEnd) {\n\t\tif (selStart <= selEnd) {\n\t\t\tcurrentSelection = getText().toString().substring(selStart, selEnd);\n\t\t}\n\t\tsuper.onSelectionChanged(selStart, selEnd);\n\t}\n\n\t@Override\n\tpublic boolean onTouchEvent(MotionEvent event) {\n\t\tif (event.getAction() == MotionEvent.ACTION_DOWN) {\n\t\t\t// Selection may be beginning. Sync the TextView with the buffer.\n\t\t\trefreshTextFromBuffer();\n\t\t}\n\n\t\t// Mouse input is treated differently:\n\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH &&\n\t\t\t\tMotionEventCompat.getSource(event) == InputDevice.SOURCE_MOUSE) {\n\t\t\tif (onMouseEvent(event, bridge)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tviewPager.setPagingEnabled(true);\n\t\t} else if (gestureDetector != null) {\n\t\t\t// The gesture detector should not be called if touch event was from mouse.\n\t\t\tgestureDetector.onTouchEvent(event);\n\t\t}\n\n\t\t// Old version of copying, only for pre-Honeycomb.\n\t\tif (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB) {\n\t\t\t// when copying, highlight the area\n\t\t\tif (bridge.isSelectingForCopy()) {\n\t\t\t\tSelectionArea area = bridge.getSelectionArea();\n\t\t\t\tint row = (int) Math.floor(event.getY() / bridge.charHeight);\n\t\t\t\tint col = (int) Math.floor(event.getX() / bridge.charWidth);\n\n\t\t\t\tswitch (event.getAction()) {\n\t\t\t\tcase MotionEvent.ACTION_DOWN:\n\t\t\t\t\t// recording starting area\n\t\t\t\t\tviewPager.setPagingEnabled(false);\n\t\t\t\t\tif (area.isSelectingOrigin()) {\n\t\t\t\t\t\tarea.setRow(row);\n\t\t\t\t\t\tarea.setColumn(col);\n\t\t\t\t\t\tlastTouchedRow = row;\n\t\t\t\t\t\tlastTouchedCol = col;\n\t\t\t\t\t\tbridge.redraw();\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\tcase MotionEvent.ACTION_MOVE:\n\t\t\t\t\t\t\t/* ignore when user hasn't moved since last time so\n\t\t\t\t\t\t\t * we can fine-tune with directional pad\n\t\t\t\t\t\t\t */\n\t\t\t\t\tif (row == lastTouchedRow && col == lastTouchedCol)\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t// if the user moves, start the selection for other corner\n\t\t\t\t\tarea.finishSelectingOrigin();\n\n\t\t\t\t\t// update selected area\n\t\t\t\t\tarea.setRow(row);\n\t\t\t\t\tarea.setColumn(col);\n\t\t\t\t\tlastTouchedRow = row;\n\t\t\t\t\tlastTouchedCol = col;\n\t\t\t\t\tbridge.redraw();\n\t\t\t\t\treturn true;\n\t\t\t\tcase MotionEvent.ACTION_UP:\n\t\t\t\t\t\t\t/* If they didn't move their finger, maybe they meant to\n\t\t\t\t\t\t\t * select the rest of the text with the directional pad.\n\t\t\t\t\t\t\t */\n\t\t\t\t\tif (area.getLeft() == area.getRight() &&\n\t\t\t\t\t\t\tarea.getTop() == area.getBottom()) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\t// copy selected area to clipboard\n\t\t\t\t\tString copiedText = area.copyFrom(bridge.buffer);\n\n\t\t\t\t\tclipboard.setText(copiedText);\n\t\t\t\t\tToast.makeText(\n\t\t\t\t\t\tcontext,\n\t\t\t\t\t\tcontext.getString(R.string.console_copy_done, copiedText.length()),\n\t\t\t\t\t\tToast.LENGTH_LONG).show();\n\n\t\t\t\t\t// fall through to clear state\n\n\t\t\t\tcase MotionEvent.ACTION_CANCEL:\n\t\t\t\t\t// make sure we clear any highlighted area\n\t\t\t\t\tarea.reset();\n\t\t\t\t\tbridge.setSelectingForCopy(false);\n\t\t\t\t\tbridge.redraw();\n\t\t\t\t\tviewPager.setPagingEnabled(true);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\tsuper.onTouchEvent(event);\n\n\t\treturn true;\n\t}\n\n\t@TargetApi(11)\n\tprivate class TextSelectionActionModeCallback implements ActionMode.Callback {\n\t\tprivate static final int COPY = 0;\n\t\tprivate static final int PASTE = 1;\n\n\t\t@Override\n\t\tpublic boolean onPrepareActionMode(ActionMode mode, Menu menu) {\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean onCreateActionMode(ActionMode mode, Menu menu) {\n\t\t\tTerminalView.this.selectionActionMode = mode;\n\n\t\t\tmenu.clear();\n\n\t\t\tmenu.add(0, COPY, 0, R.string.console_menu_copy)\n\t\t\t\t\t.setIcon(R.drawable.ic_action_copy)\n\t\t\t\t\t.setShowAsAction(MenuItem.SHOW_AS_ACTION_WITH_TEXT | MenuItem.SHOW_AS_ACTION_IF_ROOM);\n\t\t\tmenu.add(0, PASTE, 1, R.string.console_menu_paste)\n\t\t\t\t\t.setIcon(R.drawable.ic_action_paste)\n\t\t\t\t\t.setShowAsAction(MenuItem.SHOW_AS_ACTION_WITH_TEXT | MenuItem.SHOW_AS_ACTION_IF_ROOM);\n\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean onActionItemClicked(ActionMode mode, MenuItem item) {\n\t\t\tswitch (item.getItemId()) {\n\t\t\tcase COPY:\n\t\t\t\tcopyCurrentSelectionToClipboard();\n\t\t\t\treturn true;\n\t\t\tcase PASTE:\n\t\t\t\tString clip = clipboard.getText().toString();\n\t\t\t\tTerminalView.this.bridge.injectString(clip);\n\t\t\t\tmode.finish();\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic void onDestroyActionMode(ActionMode mode) {\n\t\t}\n\t}\n\n\t/**\n\t * @param event\n\t * @param bridge\n\t * @return True if the event is handled.\n\t */\n\t@TargetApi(14)\n\tprivate boolean onMouseEvent(MotionEvent event, TerminalBridge bridge) {\n\t\tint row = (int) Math.floor(event.getY() / bridge.charHeight);\n\t\tint col = (int) Math.floor(event.getX() / bridge.charWidth);\n\t\tint meta = event.getMetaState();\n\t\tboolean shiftOn = (meta & KeyEvent.META_SHIFT_ON) != 0;\n\t\tvt320 vtBuffer = (vt320) bridge.buffer;\n\t\tboolean mouseReport = vtBuffer.isMouseReportEnabled();\n\n\t\t// MouseReport can be \"defeated\" using the shift key.\n\t\tif (!mouseReport || shiftOn) {\n\t\t\tif (event.getAction() == MotionEvent.ACTION_DOWN) {\n\t\t\t\tif (event.getButtonState() == MotionEvent.BUTTON_TERTIARY) {\n\t\t\t\t\t// Middle click pastes.\n\t\t\t\t\tString clip = clipboard.getText().toString();\n\t\t\t\t\tbridge.injectString(clip);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\t// Begin \"selection mode\"\n\n\t\t\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {\n\t\t\t\t\tcloseSelectionActionMode();\n\t\t\t\t}\n\t\t\t} else if (event.getAction() == MotionEvent.ACTION_MOVE) {\n\t\t\t\t// In the middle of selection.\n\n\t\t\t\tif (selectionActionMode == null) {\n\t\t\t\t\tselectionActionMode = startActionMode(new TextSelectionActionModeCallback());\n\t\t\t\t}\n\n\t\t\t\tint selectionStart = getSelectionStart();\n\t\t\t\tint selectionEnd = getSelectionEnd();\n\n\t\t\t\tif (selectionStart > selectionEnd) {\n\t\t\t\t\tint tempStart = selectionStart;\n\t\t\t\t\tselectionStart = selectionEnd;\n\t\t\t\t\tselectionEnd = tempStart;\n\t\t\t\t}\n\n\t\t\t\tcurrentSelection = getText().toString().substring(selectionStart, selectionEnd);\n\t\t\t}\n\t\t} else if (event.getAction() == MotionEvent.ACTION_DOWN) {\n\t\t\tviewPager.setPagingEnabled(false);\n\t\t\tvtBuffer.mousePressed(\n\t\t\t\t\tcol, row, mouseEventToJavaModifiers(event));\n\t\t\treturn true;\n\t\t} else if (event.getAction() == MotionEvent.ACTION_UP) {\n\t\t\tviewPager.setPagingEnabled(true);\n\t\t\tvtBuffer.mouseReleased(col, row);\n\t\t\treturn true;\n\t\t} else if (event.getAction() == MotionEvent.ACTION_MOVE) {\n\t\t\tint buttonState = event.getButtonState();\n\t\t\tint button = (buttonState & MotionEvent.BUTTON_PRIMARY) != 0 ? 0 :\n\t\t\t\t(buttonState & MotionEvent.BUTTON_SECONDARY) != 0 ? 1 :\n\t\t\t\t(buttonState & MotionEvent.BUTTON_TERTIARY) != 0 ? 2 : 3;\n\t\t\tvtBuffer.mouseMoved(\n\t\t\t\tbutton,\n\t\t\t\tcol,\n\t\t\t\trow,\n\t\t\t\t(meta & KeyEvent.META_CTRL_ON) != 0,\n\t\t\t\t(meta & KeyEvent.META_SHIFT_ON) != 0,\n\t\t\t\t(meta & KeyEvent.META_META_ON) != 0);\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Takes an android mouse event and produces a Java InputEvent modifiers int which can be\n\t * passed to vt320.\n\t * @param mouseEvent The {@link MotionEvent} which should be a mouse click or release.\n\t * @return A Java InputEvent modifier int. See\n\t * http://docs.oracle.com/javase/7/docs/api/java/awt/event/InputEvent.html\n\t */\n\t@TargetApi(14)\n\tprivate static int mouseEventToJavaModifiers(MotionEvent mouseEvent) {\n\t\tif (MotionEventCompat.getSource(mouseEvent) != InputDevice.SOURCE_MOUSE) return 0;\n\n\t\tint mods = 0;\n\n\t\t// See http://docs.oracle.com/javase/7/docs/api/constant-values.html\n\t\tint buttonState = mouseEvent.getButtonState();\n\t\tif ((buttonState & MotionEvent.BUTTON_PRIMARY) != 0)\n\t\t\tmods |= 16;\n\t\tif ((buttonState & MotionEvent.BUTTON_SECONDARY) != 0)\n\t\t\tmods |= 8;\n\t\tif ((buttonState & MotionEvent.BUTTON_TERTIARY) != 0)\n\t\t\tmods |= 4;\n\n\t\t// Note: Meta and Ctrl are intentionally swapped here to keep logic in vt320 simple.\n\t\tint meta = mouseEvent.getMetaState();\n\t\tif ((meta & KeyEvent.META_META_ON) != 0)\n\t\t\tmods |= 2;\n\t\tif ((meta & KeyEvent.META_SHIFT_ON) != 0)\n\t\t\tmods |= 1;\n\t\tif ((meta & KeyEvent.META_CTRL_ON) != 0)\n\t\t\tmods |= 4;\n\n\t\treturn mods;\n\t}\n\n\t@Override\n\t@TargetApi(12)\n\tpublic boolean onGenericMotionEvent(MotionEvent event) {\n\t\tif ((MotionEventCompat.getSource(event) & InputDevice.SOURCE_CLASS_POINTER) != 0) {\n\t\t\tswitch (event.getAction()) {\n\t\t\tcase MotionEvent.ACTION_SCROLL:\n\t\t\t\t// Process scroll wheel movement:\n\t\t\t\tfloat yDistance = MotionEventCompat.getAxisValue(event, MotionEvent.AXIS_VSCROLL);\n\t\t\t\tvt320 vtBuffer = (vt320) bridge.buffer;\n\t\t\t\tboolean mouseReport = vtBuffer.isMouseReportEnabled();\n\t\t\t\tif (mouseReport) {\n\t\t\t\t\tint row = (int) Math.floor(event.getY() / bridge.charHeight);\n\t\t\t\t\tint col = (int) Math.floor(event.getX() / bridge.charWidth);\n\n\t\t\t\t\tvtBuffer.mouseWheel(\n\t\t\t\t\t\t\tyDistance > 0,\n\t\t\t\t\t\t\tcol,\n\t\t\t\t\t\t\trow,\n\t\t\t\t\t\t\t(event.getMetaState() & KeyEvent.META_CTRL_ON) != 0,\n\t\t\t\t\t\t\t(event.getMetaState() & KeyEvent.META_SHIFT_ON) != 0,\n\t\t\t\t\t\t\t(event.getMetaState() & KeyEvent.META_META_ON) != 0);\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (yDistance != 0) {\n\t\t\t\t\tint base = bridge.buffer.getWindowBase();\n\t\t\t\t\tbridge.buffer.setWindowBase(base - Math.round(yDistance));\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn super.onGenericMotionEvent(event);\n\t}\n\n\t// TODO: cleanup and possibly optimize\n\tprivate void refreshTextFromBuffer() {\n\t\tif (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB) {\n\t\t\t// Do not run this function because the textView is not selectable pre-Honeycomb.\n\t\t\treturn;\n\t\t}\n\n\t\tVDUBuffer vb = bridge.getVDUBuffer();\n\n\t\tString line = \"\";\n\t\tString buffer = \"\";\n\n\t\tint windowBase = vb.getWindowBase();\n\t\tint rowBegin = vb.getTopMargin();\n\t\tint rowEnd = vb.getBottomMargin();\n\t\tint numCols = vb.getColumns() - 1;\n\n\t\tfor (int r = rowBegin; r <= rowEnd; r++) {\n\t\t\tfor (int c = 0; c < numCols; c++) {\n\t\t\t\tline += vb.charArray[windowBase + r][c];\n\t\t\t}\n\t\t\tbuffer += line.replaceAll(\"\\\\s+$\", \"\") + \"\\n\";\n\t\t\tline = \"\";\n\t\t}\n\n\t\tsetText(buffer);\n\t}\n\n\t/**\n\t * Only intended for pre-Honeycomb devices.\n\t */\n\tpublic void startPreHoneycombCopyMode() {\n\t\t// mark as copying and reset any previous bounds\n\t\tSelectionArea area = bridge.getSelectionArea();\n\t\tarea.reset();\n\t\tarea.setBounds(bridge.buffer.getColumns(), bridge.buffer.getRows());\n\n\t\tbridge.setSelectingForCopy(true);\n\n\t\t// Make sure we show the initial selection\n\t\tbridge.redraw();\n\t}\n\n\tpublic void destroy() {\n\t\t// tell bridge to destroy its bitmap\n\t\tbridge.parentDestroyed();\n\t}\n\n\t@Override\n\tprotected void onSizeChanged(int w, int h, int oldw, int oldh) {\n\t\tsuper.onSizeChanged(w, h, oldw, oldh);\n\n\t\tbridge.parentChanged(this);\n\n\t\tscaleCursors();\n\t}\n\n\tpublic void onFontSizeChanged(final float size) {\n\t\tscaleCursors();\n\n\t\t((Activity) context).runOnUiThread(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tsetTextSize(size);\n\n\t\t\t\t// For the TextView to line up with the bitmap text, lineHeight must be equal to\n\t\t\t\t// the bridge's charHeight. See TextView.getLineHeight(), which has been reversed to\n\t\t\t\t// derive lineSpacingMultiplier.\n\t\t\t\tfloat lineSpacingMultiplier = (float) bridge.charHeight / getPaint().getFontMetricsInt(null);\n\t\t\t\tsetLineSpacing(0.0f, lineSpacingMultiplier);\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate void scaleCursors() {\n\t\t// Create a scale matrix to scale our 1x1 representation of the cursor\n\t\ttempDst.set(0.0f, 0.0f, bridge.charWidth, bridge.charHeight);\n\t\tscaleMatrix.setRectToRect(tempSrc, tempDst, scaleType);\n\t}\n\n\t@Override\n\tpublic void onDraw(Canvas canvas) {\n\t\tif (bridge.bitmap != null) {\n\t\t\t// draw the bitmap\n\t\t\tbridge.onDraw();\n\n\t\t\t// draw the bridge bitmap if it exists\n\t\t\tcanvas.drawBitmap(bridge.bitmap, 0, 0, paint);\n\n\t\t\t// also draw cursor if visible\n\t\t\tif (bridge.buffer.isCursorVisible()) {\n\t\t\t\tint cursorColumn = bridge.buffer.getCursorColumn();\n\t\t\t\tfinal int cursorRow = bridge.buffer.getCursorRow();\n\n\t\t\t\tfinal int columns = bridge.buffer.getColumns();\n\n\t\t\t\tif (cursorColumn == columns)\n\t\t\t\t\tcursorColumn = columns - 1;\n\n\t\t\t\tif (cursorColumn < 0 || cursorRow < 0)\n\t\t\t\t\treturn;\n\n\t\t\t\tint currentAttribute = bridge.buffer.getAttributes(\n\t\t\t\t\t\tcursorColumn, cursorRow);\n\t\t\t\tboolean onWideCharacter = (currentAttribute & VDUBuffer.FULLWIDTH) != 0;\n\n\t\t\t\tint x = cursorColumn * bridge.charWidth;\n\t\t\t\tint y = (bridge.buffer.getCursorRow()\n\t\t\t\t\t\t+ bridge.buffer.screenBase - bridge.buffer.windowBase)\n\t\t\t\t\t\t* bridge.charHeight;\n\n\t\t\t\t// Save the current clip and translation\n\t\t\t\tcanvas.save();\n\n\t\t\t\tcanvas.translate(x, y);\n\t\t\t\tcanvas.clipRect(0, 0,\n\t\t\t\t\t\tbridge.charWidth * (onWideCharacter ? 2 : 1),\n\t\t\t\t\t\tbridge.charHeight);\n\t\t\t\tcanvas.drawPaint(cursorPaint);\n\n\t\t\t\tfinal int deadKey = bridge.getKeyHandler().getDeadKey();\n\t\t\t\tif (deadKey != 0) {\n\t\t\t\t\tcanvas.drawText(new char[] { (char) deadKey }, 0, 1, 0, 0, cursorStrokePaint);\n\t\t\t\t}\n\n\t\t\t\t// Make sure we scale our decorations to the correct size.\n\t\t\t\tcanvas.concat(scaleMatrix);\n\n\t\t\t\tint metaState = bridge.getKeyHandler().getMetaState();\n\n\t\t\t\tif ((metaState & TerminalKeyListener.OUR_SHIFT_ON) != 0)\n\t\t\t\t\tcanvas.drawPath(shiftCursor, cursorStrokePaint);\n\t\t\t\telse if ((metaState & TerminalKeyListener.OUR_SHIFT_LOCK) != 0)\n\t\t\t\t\tcanvas.drawPath(shiftCursor, cursorPaint);\n\n\t\t\t\tif ((metaState & TerminalKeyListener.OUR_ALT_ON) != 0)\n\t\t\t\t\tcanvas.drawPath(altCursor, cursorStrokePaint);\n\t\t\t\telse if ((metaState & TerminalKeyListener.OUR_ALT_LOCK) != 0)\n\t\t\t\t\tcanvas.drawPath(altCursor, cursorPaint);\n\n\t\t\t\tif ((metaState & TerminalKeyListener.OUR_CTRL_ON) != 0)\n\t\t\t\t\tcanvas.drawPath(ctrlCursor, cursorStrokePaint);\n\t\t\t\telse if ((metaState & TerminalKeyListener.OUR_CTRL_LOCK) != 0)\n\t\t\t\t\tcanvas.drawPath(ctrlCursor, cursorPaint);\n\n\t\t\t\t// Restore previous clip region\n\t\t\t\tcanvas.restore();\n\t\t\t}\n\n\t\t\t// draw any highlighted area\n\t\t\tif (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB &&\n\t\t\t\tbridge.isSelectingForCopy()) {\n\t\t\t\tSelectionArea area = bridge.getSelectionArea();\n\t\t\t\tcanvas.save(Canvas.CLIP_SAVE_FLAG);\n\t\t\t\tcanvas.clipRect(\n\t\t\t\t\tarea.getLeft() * bridge.charWidth,\n\t\t\t\t\tarea.getTop() * bridge.charHeight,\n\t\t\t\t\t(area.getRight() + 1) * bridge.charWidth,\n\t\t\t\t\t(area.getBottom() + 1) * bridge.charHeight\n\t\t\t\t);\n\t\t\t\tcanvas.drawPaint(cursorPaint);\n\t\t\t\tcanvas.restore();\n\t\t\t}\n\t\t}\n\n\t\tsuper.onDraw(canvas);\n\t}\n\n\tpublic void notifyUser(String message) {\n\t\tif (!notifications)\n\t\t\treturn;\n\n\t\tif (notification != null) {\n\t\t\t// Don't keep telling the user the same thing.\n\t\t\tif (lastNotification != null && lastNotification.equals(message))\n\t\t\t\treturn;\n\n\t\t\tnotification.setText(message);\n\t\t\tnotification.show();\n\t\t} else {\n\t\t\tnotification = Toast.makeText(context, message, Toast.LENGTH_SHORT);\n\t\t\tnotification.show();\n\t\t}\n\n\t\tlastNotification = message;\n\t}\n\n\t/**\n\t * Ask the {@link TerminalBridge} we're connected to to resize to a specific size.\n\t * @param width\n\t * @param height\n\t */\n\tpublic void forceSize(int width, int height) {\n\t\tbridge.resizeComputed(width, height, getWidth(), getHeight());\n\t}\n\n\t/**\n\t * Sets the ability for the TerminalView to display Toast notifications to the user.\n\t * @param value whether to enable notifications or not\n\t */\n\tpublic void setNotifications(boolean value) {\n\t\tnotifications = value;\n\t}\n\n\t@Override\n\tpublic boolean onCheckIsTextEditor() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic InputConnection onCreateInputConnection(EditorInfo outAttrs) {\n\t\toutAttrs.imeOptions |=\n\t\t\tEditorInfo.IME_FLAG_NO_EXTRACT_UI |\n\t\t\tEditorInfo.IME_FLAG_NO_ENTER_ACTION |\n\t\t\tEditorInfo.IME_ACTION_NONE;\n\t\toutAttrs.inputType = EditorInfo.TYPE_NULL;\n\t\treturn new BaseInputConnection(this, false) {\n\t\t\t@Override\n\t\t\tpublic boolean deleteSurroundingText (int leftLength, int rightLength) {\n\t\t\t\tif (rightLength == 0 && leftLength == 0) {\n\t\t\t\t\treturn this.sendKeyEvent(new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_DEL));\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < leftLength; i++) {\n\t\t\t\t\tthis.sendKeyEvent(new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_DEL));\n\t\t\t\t}\n\t\t\t\t// TODO: forward delete\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\t}\n\n\tpublic void propagateConsoleText(char[] rawText, int length) {\n\t\tif (mAccessibilityActive) {\n\t\t\tsynchronized (mAccessibilityLock) {\n\t\t\t\tmAccessibilityBuffer.append(rawText, 0, length);\n\t\t\t}\n\n\t\t\tif (mAccessibilityInitialized) {\n\t\t\t\tif (mEventSender != null) {\n\t\t\t\t\tremoveCallbacks(mEventSender);\n\t\t\t\t} else {\n\t\t\t\t\tmEventSender = new AccessibilityEventSender();\n\t\t\t\t}\n\n\t\t\t\tpostDelayed(mEventSender, ACCESSIBILITY_EVENT_THRESHOLD);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate class AccessibilityEventSender implements Runnable {\n\t\tpublic void run() {\n\t\t\tsynchronized (mAccessibilityLock) {\n\t\t\t\tif (mCodeMatcher == null) {\n\t\t\t\t\tmCodeMatcher = mControlCodes.matcher(mAccessibilityBuffer);\n\t\t\t\t} else {\n\t\t\t\t\tmCodeMatcher.reset(mAccessibilityBuffer);\n\t\t\t\t}\n\n\t\t\t\t// Strip all control codes out.\n\t\t\t\tmAccessibilityBuffer = new StringBuffer(mCodeMatcher.replaceAll(\" \"));\n\n\t\t\t\t// Apply Backspaces using backspace character sequence\n\t\t\t\tint i = mAccessibilityBuffer.indexOf(BACKSPACE_CODE);\n\t\t\t\twhile (i != -1) {\n\t\t\t\t\tmAccessibilityBuffer = mAccessibilityBuffer.replace(i == 0 ? 0 : i - 1, i\n\t\t\t\t\t\t\t+ BACKSPACE_CODE.length(), \"\");\n\t\t\t\t\ti = mAccessibilityBuffer.indexOf(BACKSPACE_CODE);\n\t\t\t\t}\n\n\t\t\t\tif (mAccessibilityBuffer.length() > 0) {\n\t\t\t\t\tAccessibilityEvent event = AccessibilityEvent.obtain(\n\t\t\t\t\t\t\tAccessibilityEvent.TYPE_VIEW_TEXT_CHANGED);\n\t\t\t\t\tevent.setFromIndex(0);\n\t\t\t\t\tevent.setAddedCount(mAccessibilityBuffer.length());\n\t\t\t\t\tevent.getText().add(mAccessibilityBuffer);\n\n\t\t\t\t\tsendAccessibilityEventUnchecked(event);\n\t\t\t\t\tmAccessibilityBuffer.setLength(0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate class AccessibilityStateTester extends AsyncTask<Void, Void, Boolean> {\n\t\t@Override\n\t\tprotected Boolean doInBackground(Void... params) {\n\t\t\t/*\n\t\t\t * Presumably if the accessibility manager is not enabled, we don't\n\t\t\t * need to send accessibility events.\n\t\t\t */\n\t\t\tfinal AccessibilityManager accessibility = (AccessibilityManager) context\n\t\t\t\t\t.getSystemService(Context.ACCESSIBILITY_SERVICE);\n\t\t\tif (!accessibility.isEnabled()) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Restrict the set of intents to only accessibility services that\n\t\t\t * have the category FEEDBACK_SPOKEN (aka, screen readers).\n\t\t\t */\n\t\t\tfinal Intent screenReaderIntent = new Intent(SCREENREADER_INTENT_ACTION);\n\t\t\tscreenReaderIntent.addCategory(SCREENREADER_INTENT_CATEGORY);\n\n\t\t\tfinal ContentResolver cr = context.getContentResolver();\n\n\t\t\tfinal List<ResolveInfo> screenReaders = context.getPackageManager().queryIntentServices(\n\t\t\t\t\tscreenReaderIntent, 0);\n\n\t\t\tboolean foundScreenReader = false;\n\n\t\t\tfinal int N = screenReaders.size();\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfinal ResolveInfo screenReader = screenReaders.get(i);\n\n\t\t\t\t/*\n\t\t\t\t * All screen readers are expected to implement a content\n\t\t\t\t * provider that responds to:\n\t\t\t\t * content://<nameofpackage>.providers.StatusProvider\n\t\t\t\t */\n\t\t\t\tfinal Cursor cursor = cr.query(\n\t\t\t\t\t\tUri.parse(\"content://\" + screenReader.serviceInfo.packageName\n\t\t\t\t\t\t\t\t+ \".providers.StatusProvider\"), null, null, null, null);\n\t\t\t\tif (cursor != null && cursor.moveToFirst()) {\n\t\t\t\t\t/*\n\t\t\t\t\t * These content providers use a special cursor that only has\n\t\t\t\t\t * one element, an integer that is 1 if the screen reader is\n\t\t\t\t\t * running.\n\t\t\t\t\t */\n\t\t\t\t\tfinal int status = cursor.getInt(0);\n\n\t\t\t\t\tcursor.close();\n\n\t\t\t\t\tif (status == 1) {\n\t\t\t\t\t\tfoundScreenReader = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (foundScreenReader) {\n\t\t\t\tmControlCodes = Pattern.compile(CONTROL_CODE_PATTERN);\n\t\t\t}\n\n\t\t\treturn foundScreenReader;\n\t\t}\n\n\t\t@Override\n\t\tprotected void onPostExecute(Boolean result) {\n\t\t\tmAccessibilityActive = result;\n\n\t\t\tmAccessibilityInitialized = true;\n\n\t\t\tif (result) {\n\t\t\t\tmEventSender = new AccessibilityEventSender();\n\t\t\t\tpostDelayed(mEventSender, ACCESSIBILITY_EVENT_THRESHOLD);\n\t\t\t} else {\n\t\t\t\tmAccessibilityBuffer = null;\n\t\t\t}\n\t\t}\n\t}\n}\n","lineNo":510}
{"Smelly Sample":"/*\n * ConnectBot: simple, powerful, open-source SSH client for Android\n * Copyright 2007 Kenny Root, Jeffrey Sharkey\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.connectbot;\n\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.connectbot.bean.SelectionArea;\nimport org.connectbot.service.FontSizeChangedListener;\nimport org.connectbot.service.TerminalBridge;\nimport org.connectbot.service.TerminalKeyListener;\nimport org.connectbot.util.TerminalViewPager;\n\nimport android.annotation.SuppressLint;\nimport android.annotation.TargetApi;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.pm.ResolveInfo;\nimport android.database.Cursor;\nimport android.graphics.Canvas;\nimport android.graphics.Matrix;\nimport android.graphics.Paint;\nimport android.graphics.Path;\nimport android.graphics.PixelXorXfermode;\nimport android.graphics.RectF;\nimport android.graphics.Typeface;\nimport android.net.Uri;\nimport android.os.AsyncTask;\nimport android.os.Build;\nimport android.support.v4.view.MotionEventCompat;\nimport android.text.ClipboardManager;\nimport android.view.ActionMode;\nimport android.view.GestureDetector;\nimport android.view.InputDevice;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.view.ViewGroup.LayoutParams;\nimport android.view.accessibility.AccessibilityEvent;\nimport android.view.accessibility.AccessibilityManager;\nimport android.view.inputmethod.BaseInputConnection;\nimport android.view.inputmethod.EditorInfo;\nimport android.view.inputmethod.InputConnection;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport de.mud.terminal.VDUBuffer;\nimport de.mud.terminal.vt320;\n\n/**\n * User interface {@link View} for showing a TerminalBridge in an\n * {@link android.app.Activity}. Handles drawing bitmap updates and passing keystrokes down\n * to terminal.\n *\n * @author jsharkey\n */\npublic class TerminalView extends TextView implements FontSizeChangedListener {\n\n\tprivate final Context context;\n\tpublic final TerminalBridge bridge;\n\n\tprivate final TerminalViewPager viewPager;\n\tprivate GestureDetector gestureDetector;\n\n\tprivate ClipboardManager clipboard;\n\tprivate ActionMode selectionActionMode = null;\n\tprivate String currentSelection = \"\";\n\n\tprivate final Paint paint;\n\tprivate final Paint cursorPaint;\n\tprivate final Paint cursorStrokePaint;\n\n\t// Cursor paints to distinguish modes\n\tprivate Path ctrlCursor, altCursor, shiftCursor;\n\tprivate RectF tempSrc, tempDst;\n\tprivate Matrix scaleMatrix;\n\tprivate static final Matrix.ScaleToFit scaleType = Matrix.ScaleToFit.FILL;\n\n\tprivate Toast notification = null;\n\tprivate String lastNotification = null;\n\tprivate volatile boolean notifications = true;\n\n\t// Related to Accessibility Features\n\tprivate boolean mAccessibilityInitialized = false;\n\tprivate boolean mAccessibilityActive = true;\n\tprivate Object[] mAccessibilityLock = new Object[0];\n\tprivate StringBuffer mAccessibilityBuffer;\n\tprivate Pattern mControlCodes = null;\n\tprivate Matcher mCodeMatcher = null;\n\tprivate AccessibilityEventSender mEventSender = null;\n\n\tprivate static final String BACKSPACE_CODE = \"\\\\x08\\\\x1b\\\\[K\";\n\tprivate static final String CONTROL_CODE_PATTERN = \"\\\\x1b\\\\[K[^m]+[m|:]\";\n\n\tprivate static final int ACCESSIBILITY_EVENT_THRESHOLD = 1000;\n\tprivate static final String SCREENREADER_INTENT_ACTION = \"android.accessibilityservice.AccessibilityService\";\n\tprivate static final String SCREENREADER_INTENT_CATEGORY = \"android.accessibilityservice.category.FEEDBACK_SPOKEN\";\n\n\tpublic TerminalView(Context context, TerminalBridge bridge, TerminalViewPager pager) {\n\t\tsuper(context);\n\n\t\tthis.context = context;\n\t\tthis.bridge = bridge;\n\t\tthis.viewPager = pager;\n\n\t\tsetLayoutParams(new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT));\n\t\tsetFocusable(true);\n\t\tsetFocusableInTouchMode(true);\n\n\t\tpaint = new Paint();\n\n\t\tcursorPaint = new Paint();\n\t\tcursorPaint.setColor(bridge.color[bridge.defaultFg]);\n\t\tcursorPaint.setXfermode(new PixelXorXfermode(bridge.color[bridge.defaultBg]));\n\t\tcursorPaint.setAntiAlias(true);\n\n\t\tcursorStrokePaint = new Paint(cursorPaint);\n\t\tcursorStrokePaint.setStrokeWidth(0.1f);\n\t\tcursorStrokePaint.setStyle(Paint.Style.STROKE);\n\n\t\t/*\n\t\t * Set up our cursor indicators on a 1x1 Path object which we can later\n\t\t * transform to our character width and height\n\t\t */\n\t\t// TODO make this into a resource somehow\n\t\tshiftCursor = new Path();\n\t\tshiftCursor.lineTo(0.5f, 0.33f);\n\t\tshiftCursor.lineTo(1.0f, 0.0f);\n\n\t\taltCursor = new Path();\n\t\taltCursor.moveTo(0.0f, 1.0f);\n\t\taltCursor.lineTo(0.5f, 0.66f);\n\t\taltCursor.lineTo(1.0f, 1.0f);\n\n\t\tctrlCursor = new Path();\n\t\tctrlCursor.moveTo(0.0f, 0.25f);\n\t\tctrlCursor.lineTo(1.0f, 0.5f);\n\t\tctrlCursor.lineTo(0.0f, 0.75f);\n\n\t\t// For creating the transform when the terminal resizes\n\t\ttempSrc = new RectF();\n\t\ttempSrc.set(0.0f, 0.0f, 1.0f, 1.0f);\n\t\ttempDst = new RectF();\n\t\tscaleMatrix = new Matrix();\n\n\t\tbridge.addFontSizeChangedListener(this);\n\t\tbridge.terminalView = this;\n\n\t\t// connect our view up to the bridge\n\t\tsetOnKeyListener(bridge.getKeyHandler());\n\n\t\tmAccessibilityBuffer = new StringBuffer();\n\n\t\t// Enable accessibility features if a screen reader is active.\n\t\tnew AccessibilityStateTester().execute((Void) null);\n\n\t\tclipboard = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE);\n\n\t\tsetTextColor(0x00000000);\n\t\tsetTypeface(Typeface.MONOSPACE);\n\t\tonFontSizeChanged(bridge.getFontSize());\n\n\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {\n\t\t\tsetTextIsSelectable(true);\n\n\t\t\tthis.setCustomSelectionActionModeCallback(new ActionMode.Callback() {\n\t\t\t\tprivate static final int PASTE = 0;\n\n\t\t\t\t@Override\n\t\t\t\t@SuppressLint(\"NewApi\")\n\t\t\t\tpublic boolean onCreateActionMode(ActionMode mode, Menu menu) {\n\t\t\t\t\tTerminalView.this.selectionActionMode = mode;\n\n\t\t\t\t\tmenu.add(0, PASTE, 2, \"Paste\")\n\t\t\t\t\t\t\t.setIcon(R.drawable.ic_action_paste)\n\t\t\t\t\t\t\t.setShowAsAction(MenuItem.SHOW_AS_ACTION_WITH_TEXT | MenuItem.SHOW_AS_ACTION_ALWAYS);\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\t@SuppressLint(\"NewApi\")\n\t\t\t\tpublic boolean onActionItemClicked(ActionMode mode, MenuItem item) {\n\t\t\t\t\tif (item.getItemId() == PASTE) {\n\t\t\t\t\t\tString clip = clipboard.getText().toString();\n\t\t\t\t\t\tTerminalView.this.bridge.injectString(clip);\n\t\t\t\t\t\tmode.finish();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic boolean onPrepareActionMode(ActionMode mode, Menu menu) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void onDestroyActionMode(ActionMode mode) {\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tgestureDetector = new GestureDetector(context, new GestureDetector.SimpleOnGestureListener() {\n\t\t\t\tprivate TerminalBridge bridge = TerminalView.this.bridge;\n\t\t\t\tprivate float totalY = 0;\n\n\t\t\t\t@Override\n\t\t\t\tpublic boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {\n\t\t\t\t\t// if releasing then reset total scroll\n\t\t\t\t\tif (e2.getAction() == MotionEvent.ACTION_UP) {\n\t\t\t\t\t\ttotalY = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\ttotalY += distanceY;\n\t\t\t\t\tfinal int moved = (int) (totalY / bridge.charHeight);\n\n\t\t\t\t\tif (moved != 0) {\n\t\t\t\t\t\tint base = bridge.buffer.getWindowBase();\n\t\t\t\t\t\tbridge.buffer.setWindowBase(base + moved);\n\t\t\t\t\t\ttotalY = 0;\n\n\t\t\t\t\t\tcopyBufferToText();\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic boolean onSingleTapConfirmed(MotionEvent e) {\n\t\t\t\t\tviewPager.performClick();\n\t\t\t\t\treturn super.onSingleTapConfirmed(e);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tpublic void copyCurrentSelectionToClipboard() {\n\t\tClipboardManager clipboard =\n\t\t\t\t(ClipboardManager) TerminalView.this.context.getSystemService(Context.CLIPBOARD_SERVICE);\n\t\tif (currentSelection.length() != 0) {\n\t\t\tclipboard.setText(currentSelection);\n\t\t}\n\n\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB &&\n\t\t\tselectionActionMode != null) {\n\t\t\tselectionActionMode.finish();\n\t\t\tselectionActionMode = null;\n\t\t}\n\t}\n\n\t@Override\n\tprotected void onSelectionChanged(int selStart, int selEnd) {\n\t\tif (selStart <= selEnd) {\n\t\t\tcurrentSelection = getText().toString().substring(selStart, selEnd);\n\t\t}\n\t\tsuper.onSelectionChanged(selStart, selEnd);\n\t}\n\n\t@Override\n\tpublic boolean performLongClick() {\n\t\tcopyBufferToText();\n\t\treturn super.performLongClick();\n\t}\n\n\t@Override\n\tpublic boolean onTouchEvent(MotionEvent event) {\n\t\tif (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH &&\n\t\t\t\tMotionEventCompat.getSource(event) == InputDevice.SOURCE_MOUSE) {\n\t\t\tif (onMouseEvent(event, bridge)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tviewPager.setPagingEnabled(true);\n\t\t}\n\n\t\tsuper.onTouchEvent(event);\n\t\tif (gestureDetector != null) {\n\t\t\tgestureDetector.onTouchEvent(event);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param event\n\t * @param bridge\n\t * @return True if the event is handled.\n\t */\n\t@TargetApi(14)\n\tprivate boolean onMouseEvent(MotionEvent event, TerminalBridge bridge) {\n\t\tint row = (int) Math.floor(event.getY() / bridge.charHeight);\n\t\tint col = (int) Math.floor(event.getX() / bridge.charWidth);\n\t\tint meta = event.getMetaState();\n\t\tboolean shiftOn = (meta & KeyEvent.META_SHIFT_ON) != 0;\n\t\tboolean mouseReport = ((vt320) bridge.buffer).isMouseReportEnabled();\n\n\t\t// MouseReport can be \"defeated\" using the shift key.\n\t\tif ((!mouseReport || shiftOn)) {\n\t\t\tif (event.getAction() == MotionEvent.ACTION_DOWN) {\n\t\t\t\tswitch (event.getButtonState()) {\n\t\t\t\tcase MotionEvent.BUTTON_TERTIARY:\n\t\t\t\t\t// Middle click pastes.\n\t\t\t\t\tString clip = clipboard.getText().toString();\n\t\t\t\t\tbridge.injectString(clip);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (event.getAction() == MotionEvent.ACTION_DOWN) {\n\t\t\tviewPager.setPagingEnabled(false);\n\t\t\t((vt320) bridge.buffer).mousePressed(\n\t\t\t\tcol, row, mouseEventToJavaModifiers(event));\n\t\t\treturn true;\n\t\t} else if (event.getAction() == MotionEvent.ACTION_UP) {\n\t\t\tviewPager.setPagingEnabled(true);\n\t\t\t((vt320) bridge.buffer).mouseReleased(col, row);\n\t\t\treturn true;\n\t\t} else if (event.getAction() == MotionEvent.ACTION_MOVE) {\n\t\t\tint buttonState = event.getButtonState();\n\t\t\tint button = (buttonState & MotionEvent.BUTTON_PRIMARY) != 0 ? 0 :\n\t\t\t\t(buttonState & MotionEvent.BUTTON_SECONDARY) != 0 ? 1 :\n\t\t\t\t(buttonState & MotionEvent.BUTTON_TERTIARY) != 0 ? 2 : 3;\n\t\t\t((vt320) bridge.buffer).mouseMoved(\n\t\t\t\tbutton,\n\t\t\t\tcol,\n\t\t\t\trow,\n\t\t\t\t(meta & KeyEvent.META_CTRL_ON) != 0,\n\t\t\t\t(meta & KeyEvent.META_SHIFT_ON) != 0,\n\t\t\t\t(meta & KeyEvent.META_META_ON) != 0);\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Takes an android mouse event and produces a Java InputEvent modifiers int which can be\n\t * passed to vt320.\n\t * @param mouseEvent The {@link MotionEvent} which should be a mouse click or release.\n\t * @return A Java InputEvent modifier int. See\n\t * http://docs.oracle.com/javase/7/docs/api/java/awt/event/InputEvent.html\n\t */\n\t@TargetApi(14)\n\tprivate static int mouseEventToJavaModifiers(MotionEvent mouseEvent) {\n\t\tif (MotionEventCompat.getSource(mouseEvent) != InputDevice.SOURCE_MOUSE) return 0;\n\n\t\tint mods = 0;\n\n\t\t// See http://docs.oracle.com/javase/7/docs/api/constant-values.html\n\t\tint buttonState = mouseEvent.getButtonState();\n\t\tif ((buttonState & MotionEvent.BUTTON_PRIMARY) != 0)\n\t\t\tmods |= 16;\n\t\tif ((buttonState & MotionEvent.BUTTON_SECONDARY) != 0)\n\t\t\tmods |= 8;\n\t\tif ((buttonState & MotionEvent.BUTTON_TERTIARY) != 0)\n\t\t\tmods |= 4;\n\n\t\t// Note: Meta and Ctrl are intentionally swapped here to keep logic in vt320 simple.\n\t\tint meta = mouseEvent.getMetaState();\n\t\tif ((meta & KeyEvent.META_META_ON) != 0)\n\t\t\tmods |= 2;\n\t\tif ((meta & KeyEvent.META_SHIFT_ON) != 0)\n\t\t\tmods |= 1;\n\t\tif ((meta & KeyEvent.META_CTRL_ON) != 0)\n\t\t\tmods |= 4;\n\n\t\treturn mods;\n\t}\n\n\t@Override\n\t@TargetApi(12)\n\tpublic boolean onGenericMotionEvent(MotionEvent event) {\n\t\tif ((MotionEventCompat.getSource(event) & InputDevice.SOURCE_CLASS_POINTER) != 0) {\n\t\t\tswitch (event.getAction()) {\n\t\t\tcase MotionEvent.ACTION_SCROLL:\n\t\t\t\t// Process scroll wheel movement:\n\t\t\t\tfloat yDistance = MotionEventCompat.getAxisValue(event, MotionEvent.AXIS_VSCROLL);\n\t\t\t\tboolean mouseReport = ((vt320) bridge.buffer).isMouseReportEnabled();\n\t\t\t\tif (mouseReport) {\n\t\t\t\t\tint row = (int) Math.floor(event.getY() / bridge.charHeight);\n\t\t\t\t\tint col = (int) Math.floor(event.getX() / bridge.charWidth);\n\n\t\t\t\t\t\t\t((vt320) bridge.buffer).mouseWheel(\n\t\t\t\t\t\t\t\t\t\t\tyDistance > 0,\n\t\t\t\t\t\t\t\t\t\t\tcol,\n\t\t\t\t\t\t\t\t\t\t\trow,\n\t\t\t\t\t\t\t\t\t\t\t(event.getMetaState() & KeyEvent.META_CTRL_ON) != 0,\n\t\t\t\t\t\t\t\t\t\t\t(event.getMetaState() & KeyEvent.META_SHIFT_ON) != 0,\n\t\t\t\t\t\t\t\t\t\t\t(event.getMetaState() & KeyEvent.META_META_ON) != 0);\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (yDistance != 0) {\n\t\t\t\t\tint base = bridge.buffer.getWindowBase();\n\t\t\t\t\tbridge.buffer.setWindowBase(base - Math.round(yDistance));\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn super.onGenericMotionEvent(event);\n\t}\n\n\tprivate void copyBufferToText() {\n\t\tif (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB) {\n\t\t\t// It is pointless to run this function because the textView is not selectable pre-Honeycomb.\n\t\t\treturn;\n\t\t}\n\n\t\tVDUBuffer vb = bridge.getVDUBuffer();\n\n\t\tString line = \"\";\n\t\tString buffer = \"\";\n\n\t\tint windowBase = vb.getWindowBase();\n\t\tint rowBegin = vb.getTopMargin();\n\t\tint rowEnd = vb.getBottomMargin();\n\t\tint numCols = vb.getColumns() - 1;\n\n\t\tfor (int r = rowBegin; r <= rowEnd; r++) {\n\t\t\tfor (int c = 0; c < numCols; c++) {\n\t\t\t\tline += vb.charArray[windowBase + r][c];\n\t\t\t}\n\t\t\tbuffer += line.replaceAll(\"\\\\s+$\", \"\") + \"\\n\";\n\t\t\tline = \"\";\n\t\t}\n\n\t\tsetText(buffer);\n\t}\n\n\tpublic void destroy() {\n\t\t// tell bridge to destroy its bitmap\n\t\tbridge.parentDestroyed();\n\t}\n\n\t@Override\n\tprotected void onSizeChanged(int w, int h, int oldw, int oldh) {\n\t\tsuper.onSizeChanged(w, h, oldw, oldh);\n\n\t\tbridge.parentChanged(this);\n\n\t\tscaleCursors();\n\t}\n\n\tpublic void onFontSizeChanged(float size) {\n\t\tscaleCursors();\n\t\tsetTextSize(size);\n\t\tsetLineSpacing(0.0f, 1.1f); // KLUDGE: doesnt work on certain font sizes\n\t\tcopyBufferToText();\n\t}\n\n\tprivate void scaleCursors() {\n\t\t// Create a scale matrix to scale our 1x1 representation of the cursor\n\t\ttempDst.set(0.0f, 0.0f, bridge.charWidth, bridge.charHeight);\n\t\tscaleMatrix.setRectToRect(tempSrc, tempDst, scaleType);\n\t}\n\n\t@Override\n\tpublic void onDraw(Canvas canvas) {\n\t\tif (bridge.bitmap != null) {\n\t\t\t// draw the bitmap\n\t\t\tbridge.onDraw();\n\n\t\t\t// draw the bridge bitmap if it exists\n\t\t\tcanvas.drawBitmap(bridge.bitmap, 0, 0, paint);\n\n\t\t\t// also draw cursor if visible\n\t\t\tif (bridge.buffer.isCursorVisible()) {\n\t\t\t\tint cursorColumn = bridge.buffer.getCursorColumn();\n\t\t\t\tfinal int cursorRow = bridge.buffer.getCursorRow();\n\n\t\t\t\tfinal int columns = bridge.buffer.getColumns();\n\n\t\t\t\tif (cursorColumn == columns)\n\t\t\t\t\tcursorColumn = columns - 1;\n\n\t\t\t\tif (cursorColumn < 0 || cursorRow < 0)\n\t\t\t\t\treturn;\n\n\t\t\t\tint currentAttribute = bridge.buffer.getAttributes(\n\t\t\t\t\t\tcursorColumn, cursorRow);\n\t\t\t\tboolean onWideCharacter = (currentAttribute & VDUBuffer.FULLWIDTH) != 0;\n\n\t\t\t\tint x = cursorColumn * bridge.charWidth;\n\t\t\t\tint y = (bridge.buffer.getCursorRow()\n\t\t\t\t\t\t+ bridge.buffer.screenBase - bridge.buffer.windowBase)\n\t\t\t\t\t\t* bridge.charHeight;\n\n\t\t\t\t// Save the current clip and translation\n\t\t\t\tcanvas.save();\n\n\t\t\t\tcanvas.translate(x, y);\n\t\t\t\tcanvas.clipRect(0, 0,\n\t\t\t\t\t\tbridge.charWidth * (onWideCharacter ? 2 : 1),\n\t\t\t\t\t\tbridge.charHeight);\n\t\t\t\tcanvas.drawPaint(cursorPaint);\n\n\t\t\t\tfinal int deadKey = bridge.getKeyHandler().getDeadKey();\n\t\t\t\tif (deadKey != 0) {\n\t\t\t\t\tcanvas.drawText(new char[] { (char) deadKey }, 0, 1, 0, 0, cursorStrokePaint);\n\t\t\t\t}\n\n\t\t\t\t// Make sure we scale our decorations to the correct size.\n\t\t\t\tcanvas.concat(scaleMatrix);\n\n\t\t\t\tint metaState = bridge.getKeyHandler().getMetaState();\n\n\t\t\t\tif ((metaState & TerminalKeyListener.OUR_SHIFT_ON) != 0)\n\t\t\t\t\tcanvas.drawPath(shiftCursor, cursorStrokePaint);\n\t\t\t\telse if ((metaState & TerminalKeyListener.OUR_SHIFT_LOCK) != 0)\n\t\t\t\t\tcanvas.drawPath(shiftCursor, cursorPaint);\n\n\t\t\t\tif ((metaState & TerminalKeyListener.OUR_ALT_ON) != 0)\n\t\t\t\t\tcanvas.drawPath(altCursor, cursorStrokePaint);\n\t\t\t\telse if ((metaState & TerminalKeyListener.OUR_ALT_LOCK) != 0)\n\t\t\t\t\tcanvas.drawPath(altCursor, cursorPaint);\n\n\t\t\t\tif ((metaState & TerminalKeyListener.OUR_CTRL_ON) != 0)\n\t\t\t\t\tcanvas.drawPath(ctrlCursor, cursorStrokePaint);\n\t\t\t\telse if ((metaState & TerminalKeyListener.OUR_CTRL_LOCK) != 0)\n\t\t\t\t\tcanvas.drawPath(ctrlCursor, cursorPaint);\n\n\t\t\t\t// Restore previous clip region\n\t\t\t\tcanvas.restore();\n\t\t\t}\n\n\t\t\t// draw any highlighted area\n\t\t\tif (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB &&\n\t\t\t\tbridge.isSelectingForCopy()) {\n\t\t\t\tSelectionArea area = bridge.getSelectionArea();\n\t\t\t\tcanvas.save(Canvas.CLIP_SAVE_FLAG);\n\t\t\t\tcanvas.clipRect(\n\t\t\t\t\tarea.getLeft() * bridge.charWidth,\n\t\t\t\t\tarea.getTop() * bridge.charHeight,\n\t\t\t\t\t(area.getRight() + 1) * bridge.charWidth,\n\t\t\t\t\t(area.getBottom() + 1) * bridge.charHeight\n\t\t\t\t);\n\t\t\t\tcanvas.drawPaint(cursorPaint);\n\t\t\t\tcanvas.restore();\n\t\t\t}\n\t\t}\n\n\t\tsuper.onDraw(canvas);\n\t}\n\n\tpublic void notifyUser(String message) {\n\t\tif (!notifications)\n\t\t\treturn;\n\n\t\tif (notification != null) {\n\t\t\t// Don't keep telling the user the same thing.\n\t\t\tif (lastNotification != null && lastNotification.equals(message))\n\t\t\t\treturn;\n\n\t\t\tnotification.setText(message);\n\t\t\tnotification.show();\n\t\t} else {\n\t\t\tnotification = Toast.makeText(context, message, Toast.LENGTH_SHORT);\n\t\t\tnotification.show();\n\t\t}\n\n\t\tlastNotification = message;\n\t}\n\n\t/**\n\t * Ask the {@link TerminalBridge} we're connected to to resize to a specific size.\n\t * @param width\n\t * @param height\n\t */\n\tpublic void forceSize(int width, int height) {\n\t\tbridge.resizeComputed(width, height, getWidth(), getHeight());\n\t}\n\n\t/**\n\t * Sets the ability for the TerminalView to display Toast notifications to the user.\n\t * @param value whether to enable notifications or not\n\t */\n\tpublic void setNotifications(boolean value) {\n\t\tnotifications = value;\n\t}\n\n\t@Override\n\tpublic boolean onCheckIsTextEditor() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic InputConnection onCreateInputConnection(EditorInfo outAttrs) {\n\t\toutAttrs.imeOptions |=\n\t\t\tEditorInfo.IME_FLAG_NO_EXTRACT_UI |\n\t\t\tEditorInfo.IME_FLAG_NO_ENTER_ACTION |\n\t\t\tEditorInfo.IME_ACTION_NONE;\n\t\toutAttrs.inputType = EditorInfo.TYPE_NULL;\n\t\treturn new BaseInputConnection(this, false) {\n\t\t\t@Override\n\t\t\tpublic boolean deleteSurroundingText (int leftLength, int rightLength) {\n\t\t\t\tif (rightLength == 0 && leftLength == 0) {\n\t\t\t\t\treturn this.sendKeyEvent(new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_DEL));\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < leftLength; i++) {\n\t\t\t\t\tthis.sendKeyEvent(new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_DEL));\n\t\t\t\t}\n\t\t\t\t// TODO: forward delete\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\t}\n\n\tpublic void propagateConsoleText(char[] rawText, int length) {\n\t\tif (mAccessibilityActive) {\n\t\t\tsynchronized (mAccessibilityLock) {\n\t\t\t\tmAccessibilityBuffer.append(rawText, 0, length);\n\t\t\t}\n\n\t\t\tif (mAccessibilityInitialized) {\n\t\t\t\tif (mEventSender != null) {\n\t\t\t\t\tremoveCallbacks(mEventSender);\n\t\t\t\t} else {\n\t\t\t\t\tmEventSender = new AccessibilityEventSender();\n\t\t\t\t}\n\n\t\t\t\tpostDelayed(mEventSender, ACCESSIBILITY_EVENT_THRESHOLD);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate class AccessibilityEventSender implements Runnable {\n\t\tpublic void run() {\n\t\t\tsynchronized (mAccessibilityLock) {\n\t\t\t\tif (mCodeMatcher == null) {\n\t\t\t\t\tmCodeMatcher = mControlCodes.matcher(mAccessibilityBuffer);\n\t\t\t\t} else {\n\t\t\t\t\tmCodeMatcher.reset(mAccessibilityBuffer);\n\t\t\t\t}\n\n\t\t\t\t// Strip all control codes out.\n\t\t\t\tmAccessibilityBuffer = new StringBuffer(mCodeMatcher.replaceAll(\" \"));\n\n\t\t\t\t// Apply Backspaces using backspace character sequence\n\t\t\t\tint i = mAccessibilityBuffer.indexOf(BACKSPACE_CODE);\n\t\t\t\twhile (i != -1) {\n\t\t\t\t\tmAccessibilityBuffer = mAccessibilityBuffer.replace(i == 0 ? 0 : i - 1, i\n\t\t\t\t\t\t\t+ BACKSPACE_CODE.length(), \"\");\n\t\t\t\t\ti = mAccessibilityBuffer.indexOf(BACKSPACE_CODE);\n\t\t\t\t}\n\n\t\t\t\tif (mAccessibilityBuffer.length() > 0) {\n\t\t\t\t\tAccessibilityEvent event = AccessibilityEvent.obtain(\n\t\t\t\t\t\t\tAccessibilityEvent.TYPE_VIEW_TEXT_CHANGED);\n\t\t\t\t\tevent.setFromIndex(0);\n\t\t\t\t\tevent.setAddedCount(mAccessibilityBuffer.length());\n\t\t\t\t\tevent.getText().add(mAccessibilityBuffer);\n\n\t\t\t\t\tsendAccessibilityEventUnchecked(event);\n\t\t\t\t\tmAccessibilityBuffer.setLength(0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate class AccessibilityStateTester extends AsyncTask<Void, Void, Boolean> {\n\t\t@Override\n\t\tprotected Boolean doInBackground(Void... params) {\n\t\t\t/*\n\t\t\t * Presumably if the accessibility manager is not enabled, we don't\n\t\t\t * need to send accessibility events.\n\t\t\t */\n\t\t\tfinal AccessibilityManager accessibility = (AccessibilityManager) context\n\t\t\t\t\t.getSystemService(Context.ACCESSIBILITY_SERVICE);\n\t\t\tif (!accessibility.isEnabled()) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Restrict the set of intents to only accessibility services that\n\t\t\t * have the category FEEDBACK_SPOKEN (aka, screen readers).\n\t\t\t */\n\t\t\tfinal Intent screenReaderIntent = new Intent(SCREENREADER_INTENT_ACTION);\n\t\t\tscreenReaderIntent.addCategory(SCREENREADER_INTENT_CATEGORY);\n\n\t\t\tfinal ContentResolver cr = context.getContentResolver();\n\n\t\t\tfinal List<ResolveInfo> screenReaders = context.getPackageManager().queryIntentServices(\n\t\t\t\t\tscreenReaderIntent, 0);\n\n\t\t\tboolean foundScreenReader = false;\n\n\t\t\tfinal int N = screenReaders.size();\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfinal ResolveInfo screenReader = screenReaders.get(i);\n\n\t\t\t\t/*\n\t\t\t\t * All screen readers are expected to implement a content\n\t\t\t\t * provider that responds to:\n\t\t\t\t * content://<nameofpackage>.providers.StatusProvider\n\t\t\t\t */\n\t\t\t\tfinal Cursor cursor = cr.query(\n\t\t\t\t\t\tUri.parse(\"content://\" + screenReader.serviceInfo.packageName\n\t\t\t\t\t\t\t\t+ \".providers.StatusProvider\"), null, null, null, null);\n\t\t\t\tif (cursor != null && cursor.moveToFirst()) {\n\t\t\t\t\t/*\n\t\t\t\t\t * These content providers use a special cursor that only has\n\t\t\t\t\t * one element, an integer that is 1 if the screen reader is\n\t\t\t\t\t * running.\n\t\t\t\t\t */\n\t\t\t\t\tfinal int status = cursor.getInt(0);\n\n\t\t\t\t\tcursor.close();\n\n\t\t\t\t\tif (status == 1) {\n\t\t\t\t\t\tfoundScreenReader = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (foundScreenReader) {\n\t\t\t\tmControlCodes = Pattern.compile(CONTROL_CODE_PATTERN);\n\t\t\t}\n\n\t\t\treturn foundScreenReader;\n\t\t}\n\n\t\t@Override\n\t\tprotected void onPostExecute(Boolean result) {\n\t\t\tmAccessibilityActive = result;\n\n\t\t\tmAccessibilityInitialized = true;\n\n\t\t\tif (result) {\n\t\t\t\tmEventSender = new AccessibilityEventSender();\n\t\t\t\tpostDelayed(mEventSender, ACCESSIBILITY_EVENT_THRESHOLD);\n\t\t\t} else {\n\t\t\t\tmAccessibilityBuffer = null;\n\t\t\t}\n\t\t}\n\t}\n}\n","Method after Refactoring":"/*\n * ConnectBot: simple, powerful, open-source SSH client for Android\n * Copyright 2007 Kenny Root, Jeffrey Sharkey\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.connectbot;\n\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.connectbot.bean.SelectionArea;\nimport org.connectbot.service.FontSizeChangedListener;\nimport org.connectbot.service.TerminalBridge;\nimport org.connectbot.service.TerminalKeyListener;\nimport org.connectbot.util.TerminalViewPager;\n\nimport android.annotation.SuppressLint;\nimport android.annotation.TargetApi;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.pm.ResolveInfo;\nimport android.database.Cursor;\nimport android.graphics.Canvas;\nimport android.graphics.Matrix;\nimport android.graphics.Paint;\nimport android.graphics.Path;\nimport android.graphics.PixelXorXfermode;\nimport android.graphics.RectF;\nimport android.graphics.Typeface;\nimport android.net.Uri;\nimport android.os.AsyncTask;\nimport android.os.Build;\nimport android.support.v4.view.MotionEventCompat;\nimport android.text.ClipboardManager;\nimport android.util.Log;\nimport android.view.ActionMode;\nimport android.view.GestureDetector;\nimport android.view.InputDevice;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.view.ViewGroup.LayoutParams;\nimport android.view.accessibility.AccessibilityEvent;\nimport android.view.accessibility.AccessibilityManager;\nimport android.view.inputmethod.BaseInputConnection;\nimport android.view.inputmethod.EditorInfo;\nimport android.view.inputmethod.InputConnection;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport de.mud.terminal.VDUBuffer;\nimport de.mud.terminal.vt320;\n\n/**\n * User interface {@link View} for showing a TerminalBridge in an\n * {@link android.app.Activity}. Handles drawing bitmap updates and passing keystrokes down\n * to terminal.\n *\n * @author jsharkey\n */\npublic class TerminalView extends TextView implements FontSizeChangedListener {\n\n\tprivate final Context context;\n\tpublic final TerminalBridge bridge;\n\n\tprivate final TerminalViewPager viewPager;\n\tprivate GestureDetector gestureDetector;\n\n\tprivate ClipboardManager clipboard;\n\tprivate ActionMode selectionActionMode = null;\n\tprivate String currentSelection = \"\";\n\n\tprivate final Paint paint;\n\tprivate final Paint cursorPaint;\n\tprivate final Paint cursorStrokePaint;\n\n\t// Cursor paints to distinguish modes\n\tprivate Path ctrlCursor, altCursor, shiftCursor;\n\tprivate RectF tempSrc, tempDst;\n\tprivate Matrix scaleMatrix;\n\tprivate static final Matrix.ScaleToFit scaleType = Matrix.ScaleToFit.FILL;\n\n\tprivate Toast notification = null;\n\tprivate String lastNotification = null;\n\tprivate volatile boolean notifications = true;\n\n\t// Related to Accessibility Features\n\tprivate boolean mAccessibilityInitialized = false;\n\tprivate boolean mAccessibilityActive = true;\n\tprivate Object[] mAccessibilityLock = new Object[0];\n\tprivate StringBuffer mAccessibilityBuffer;\n\tprivate Pattern mControlCodes = null;\n\tprivate Matcher mCodeMatcher = null;\n\tprivate AccessibilityEventSender mEventSender = null;\n\n\tprivate static final String BACKSPACE_CODE = \"\\\\x08\\\\x1b\\\\[K\";\n\tprivate static final String CONTROL_CODE_PATTERN = \"\\\\x1b\\\\[K[^m]+[m|:]\";\n\n\tprivate static final int ACCESSIBILITY_EVENT_THRESHOLD = 1000;\n\tprivate static final String SCREENREADER_INTENT_ACTION = \"android.accessibilityservice.AccessibilityService\";\n\tprivate static final String SCREENREADER_INTENT_CATEGORY = \"android.accessibilityservice.category.FEEDBACK_SPOKEN\";\n\n\tpublic TerminalView(Context context, TerminalBridge bridge, TerminalViewPager pager) {\n\t\tsuper(context);\n\n\t\tthis.context = context;\n\t\tthis.bridge = bridge;\n\t\tthis.viewPager = pager;\n\n\t\tsetLayoutParams(new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT));\n\t\tsetFocusable(true);\n\t\tsetFocusableInTouchMode(true);\n\n\t\tpaint = new Paint();\n\n\t\tcursorPaint = new Paint();\n\t\tcursorPaint.setColor(bridge.color[bridge.defaultFg]);\n\t\tcursorPaint.setXfermode(new PixelXorXfermode(bridge.color[bridge.defaultBg]));\n\t\tcursorPaint.setAntiAlias(true);\n\n\t\tcursorStrokePaint = new Paint(cursorPaint);\n\t\tcursorStrokePaint.setStrokeWidth(0.1f);\n\t\tcursorStrokePaint.setStyle(Paint.Style.STROKE);\n\n\t\t/*\n\t\t * Set up our cursor indicators on a 1x1 Path object which we can later\n\t\t * transform to our character width and height\n\t\t */\n\t\t// TODO make this into a resource somehow\n\t\tshiftCursor = new Path();\n\t\tshiftCursor.lineTo(0.5f, 0.33f);\n\t\tshiftCursor.lineTo(1.0f, 0.0f);\n\n\t\taltCursor = new Path();\n\t\taltCursor.moveTo(0.0f, 1.0f);\n\t\taltCursor.lineTo(0.5f, 0.66f);\n\t\taltCursor.lineTo(1.0f, 1.0f);\n\n\t\tctrlCursor = new Path();\n\t\tctrlCursor.moveTo(0.0f, 0.25f);\n\t\tctrlCursor.lineTo(1.0f, 0.5f);\n\t\tctrlCursor.lineTo(0.0f, 0.75f);\n\n\t\t// For creating the transform when the terminal resizes\n\t\ttempSrc = new RectF();\n\t\ttempSrc.set(0.0f, 0.0f, 1.0f, 1.0f);\n\t\ttempDst = new RectF();\n\t\tscaleMatrix = new Matrix();\n\n\t\tbridge.addFontSizeChangedListener(this);\n\t\tbridge.terminalView = this;\n\n\t\t// connect our view up to the bridge\n\t\tsetOnKeyListener(bridge.getKeyHandler());\n\n\t\tmAccessibilityBuffer = new StringBuffer();\n\n\t\t// Enable accessibility features if a screen reader is active.\n\t\tnew AccessibilityStateTester().execute((Void) null);\n\n\t\tclipboard = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE);\n\n\t\tsetTextColor(0x00000000);\n\t\tsetTypeface(Typeface.MONOSPACE);\n\t\tonFontSizeChanged(bridge.getFontSize());\n\n\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {\n\t\t\tsetTextIsSelectable(true);\n\n\t\t\tthis.setCustomSelectionActionModeCallback(new ActionMode.Callback() {\n\t\t\t\tprivate static final int PASTE = 0;\n\n\t\t\t\t@Override\n\t\t\t\t@SuppressLint(\"NewApi\")\n\t\t\t\tpublic boolean onCreateActionMode(ActionMode mode, Menu menu) {\n\t\t\t\t\tTerminalView.this.selectionActionMode = mode;\n\n\t\t\t\t\tmenu.add(0, PASTE, 2, \"Paste\")\n\t\t\t\t\t\t\t.setIcon(R.drawable.ic_action_paste)\n\t\t\t\t\t\t\t.setShowAsAction(MenuItem.SHOW_AS_ACTION_WITH_TEXT | MenuItem.SHOW_AS_ACTION_ALWAYS);\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\t@SuppressLint(\"NewApi\")\n\t\t\t\tpublic boolean onActionItemClicked(ActionMode mode, MenuItem item) {\n\t\t\t\t\tif (item.getItemId() == PASTE) {\n\t\t\t\t\t\tString clip = clipboard.getText().toString();\n\t\t\t\t\t\tTerminalView.this.bridge.injectString(clip);\n\t\t\t\t\t\tmode.finish();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic boolean onPrepareActionMode(ActionMode mode, Menu menu) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void onDestroyActionMode(ActionMode mode) {\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tgestureDetector = new GestureDetector(context, new GestureDetector.SimpleOnGestureListener() {\n\t\t\t\tprivate TerminalBridge bridge = TerminalView.this.bridge;\n\t\t\t\tprivate float totalY = 0;\n\n\t\t\t\t@Override\n\t\t\t\tpublic boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {\n\t\t\t\t\t// if releasing then reset total scroll\n\t\t\t\t\tif (e2.getAction() == MotionEvent.ACTION_UP) {\n\t\t\t\t\t\ttotalY = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\ttotalY += distanceY;\n\t\t\t\t\tfinal int moved = (int) (totalY / bridge.charHeight);\n\n\t\t\t\t\tif (moved != 0) {\n\t\t\t\t\t\tint base = bridge.buffer.getWindowBase();\n\t\t\t\t\t\tbridge.buffer.setWindowBase(base + moved);\n\t\t\t\t\t\ttotalY = 0;\n\n\t\t\t\t\t\tcopyBufferToText();\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic boolean onSingleTapConfirmed(MotionEvent e) {\n\t\t\t\t\tviewPager.performClick();\n\t\t\t\t\treturn super.onSingleTapConfirmed(e);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tpublic void copyCurrentSelectionToClipboard() {\n\t\tClipboardManager clipboard =\n\t\t\t\t(ClipboardManager) TerminalView.this.context.getSystemService(Context.CLIPBOARD_SERVICE);\n\t\tif (currentSelection.length() != 0) {\n\t\t\tclipboard.setText(currentSelection);\n\t\t}\n\n\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB &&\n\t\t\tselectionActionMode != null) {\n\t\t\tselectionActionMode.finish();\n\t\t\tselectionActionMode = null;\n\t\t}\n\t}\n\n\t@Override\n\tprotected void onSelectionChanged(int selStart, int selEnd) {\n\t\tif (selStart <= selEnd) {\n\t\t\tcurrentSelection = getText().toString().substring(selStart, selEnd);\n\t\t}\n\t\tsuper.onSelectionChanged(selStart, selEnd);\n\t}\n\n\t@Override\n\tpublic boolean performLongClick() {\n\t\tcopyBufferToText();\n\t\treturn super.performLongClick();\n\t}\n\n\t@Override\n\tpublic boolean onTouchEvent(MotionEvent event) {\n\t\tif (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH &&\n\t\t\t\tMotionEventCompat.getSource(event) == InputDevice.SOURCE_MOUSE) {\n\t\t\tif (onMouseEvent(event, bridge)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tviewPager.setPagingEnabled(true);\n\t\t}\n\n\t\tsuper.onTouchEvent(event);\n\t\tif (gestureDetector != null) {\n\t\t\tgestureDetector.onTouchEvent(event);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param event\n\t * @param bridge\n\t * @return True if the event is handled.\n\t */\n\t@TargetApi(14)\n\tprivate boolean onMouseEvent(MotionEvent event, TerminalBridge bridge) {\n\t\tint row = (int) Math.floor(event.getY() / bridge.charHeight);\n\t\tint col = (int) Math.floor(event.getX() / bridge.charWidth);\n\t\tint meta = event.getMetaState();\n\t\tboolean shiftOn = (meta & KeyEvent.META_SHIFT_ON) != 0;\n\t\tboolean mouseReport = ((vt320) bridge.buffer).isMouseReportEnabled();\n\n\t\t// MouseReport can be \"defeated\" using the shift key.\n\t\tif ((!mouseReport || shiftOn)) {\n\t\t\tif (event.getAction() == MotionEvent.ACTION_DOWN) {\n\t\t\t\tswitch (event.getButtonState()) {\n\t\t\t\tcase MotionEvent.BUTTON_TERTIARY:\n\t\t\t\t\t// Middle click pastes.\n\t\t\t\t\tString clip = clipboard.getText().toString();\n\t\t\t\t\tbridge.injectString(clip);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (event.getAction() == MotionEvent.ACTION_DOWN) {\n\t\t\tviewPager.setPagingEnabled(false);\n\t\t\t((vt320) bridge.buffer).mousePressed(\n\t\t\t\tcol, row, mouseEventToJavaModifiers(event));\n\t\t\treturn true;\n\t\t} else if (event.getAction() == MotionEvent.ACTION_UP) {\n\t\t\tviewPager.setPagingEnabled(true);\n\t\t\t((vt320) bridge.buffer).mouseReleased(col, row);\n\t\t\treturn true;\n\t\t} else if (event.getAction() == MotionEvent.ACTION_MOVE) {\n\t\t\tint buttonState = event.getButtonState();\n\t\t\tint button = (buttonState & MotionEvent.BUTTON_PRIMARY) != 0 ? 0 :\n\t\t\t\t(buttonState & MotionEvent.BUTTON_SECONDARY) != 0 ? 1 :\n\t\t\t\t(buttonState & MotionEvent.BUTTON_TERTIARY) != 0 ? 2 : 3;\n\t\t\t((vt320) bridge.buffer).mouseMoved(\n\t\t\t\tbutton,\n\t\t\t\tcol,\n\t\t\t\trow,\n\t\t\t\t(meta & KeyEvent.META_CTRL_ON) != 0,\n\t\t\t\t(meta & KeyEvent.META_SHIFT_ON) != 0,\n\t\t\t\t(meta & KeyEvent.META_META_ON) != 0);\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Takes an android mouse event and produces a Java InputEvent modifiers int which can be\n\t * passed to vt320.\n\t * @param mouseEvent The {@link MotionEvent} which should be a mouse click or release.\n\t * @return A Java InputEvent modifier int. See\n\t * http://docs.oracle.com/javase/7/docs/api/java/awt/event/InputEvent.html\n\t */\n\t@TargetApi(14)\n\tprivate static int mouseEventToJavaModifiers(MotionEvent mouseEvent) {\n\t\tif (MotionEventCompat.getSource(mouseEvent) != InputDevice.SOURCE_MOUSE) return 0;\n\n\t\tint mods = 0;\n\n\t\t// See http://docs.oracle.com/javase/7/docs/api/constant-values.html\n\t\tint buttonState = mouseEvent.getButtonState();\n\t\tif ((buttonState & MotionEvent.BUTTON_PRIMARY) != 0)\n\t\t\tmods |= 16;\n\t\tif ((buttonState & MotionEvent.BUTTON_SECONDARY) != 0)\n\t\t\tmods |= 8;\n\t\tif ((buttonState & MotionEvent.BUTTON_TERTIARY) != 0)\n\t\t\tmods |= 4;\n\n\t\t// Note: Meta and Ctrl are intentionally swapped here to keep logic in vt320 simple.\n\t\tint meta = mouseEvent.getMetaState();\n\t\tif ((meta & KeyEvent.META_META_ON) != 0)\n\t\t\tmods |= 2;\n\t\tif ((meta & KeyEvent.META_SHIFT_ON) != 0)\n\t\t\tmods |= 1;\n\t\tif ((meta & KeyEvent.META_CTRL_ON) != 0)\n\t\t\tmods |= 4;\n\n\t\treturn mods;\n\t}\n\n\t@Override\n\t@TargetApi(12)\n\tpublic boolean onGenericMotionEvent(MotionEvent event) {\n\t\tif ((MotionEventCompat.getSource(event) & InputDevice.SOURCE_CLASS_POINTER) != 0) {\n\t\t\tswitch (event.getAction()) {\n\t\t\tcase MotionEvent.ACTION_SCROLL:\n\t\t\t\t// Process scroll wheel movement:\n\t\t\t\tfloat yDistance = MotionEventCompat.getAxisValue(event, MotionEvent.AXIS_VSCROLL);\n\t\t\t\tboolean mouseReport = ((vt320) bridge.buffer).isMouseReportEnabled();\n\t\t\t\tif (mouseReport) {\n\t\t\t\t\tint row = (int) Math.floor(event.getY() / bridge.charHeight);\n\t\t\t\t\tint col = (int) Math.floor(event.getX() / bridge.charWidth);\n\n\t\t\t\t\t\t\t((vt320) bridge.buffer).mouseWheel(\n\t\t\t\t\t\t\t\t\t\t\tyDistance > 0,\n\t\t\t\t\t\t\t\t\t\t\tcol,\n\t\t\t\t\t\t\t\t\t\t\trow,\n\t\t\t\t\t\t\t\t\t\t\t(event.getMetaState() & KeyEvent.META_CTRL_ON) != 0,\n\t\t\t\t\t\t\t\t\t\t\t(event.getMetaState() & KeyEvent.META_SHIFT_ON) != 0,\n\t\t\t\t\t\t\t\t\t\t\t(event.getMetaState() & KeyEvent.META_META_ON) != 0);\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (yDistance != 0) {\n\t\t\t\t\tint base = bridge.buffer.getWindowBase();\n\t\t\t\t\tbridge.buffer.setWindowBase(base - Math.round(yDistance));\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn super.onGenericMotionEvent(event);\n\t}\n\n\tprivate void copyBufferToText() {\n\t\tif (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB) {\n\t\t\t// Do not run this function because the textView is not selectable pre-Honeycomb.\n\t\t\treturn;\n\t\t}\n\n\t\tVDUBuffer vb = bridge.getVDUBuffer();\n\n\t\tString line = \"\";\n\t\tString buffer = \"\";\n\n\t\tint windowBase = vb.getWindowBase();\n\t\tint rowBegin = vb.getTopMargin();\n\t\tint rowEnd = vb.getBottomMargin();\n\t\tint numCols = vb.getColumns() - 1;\n\n\t\tfor (int r = rowBegin; r <= rowEnd; r++) {\n\t\t\tfor (int c = 0; c < numCols; c++) {\n\t\t\t\tline += vb.charArray[windowBase + r][c];\n\t\t\t}\n\t\t\tbuffer += line.replaceAll(\"\\\\s+$\", \"\") + \"\\n\";\n\t\t\tline = \"\";\n\t\t}\n\n\t\tsetText(buffer);\n\t}\n\n\tpublic void destroy() {\n\t\t// tell bridge to destroy its bitmap\n\t\tbridge.parentDestroyed();\n\t}\n\n\t@Override\n\tprotected void onSizeChanged(int w, int h, int oldw, int oldh) {\n\t\tsuper.onSizeChanged(w, h, oldw, oldh);\n\n\t\tbridge.parentChanged(this);\n\n\t\tscaleCursors();\n\t}\n\n\tpublic void onFontSizeChanged(float size) {\n\t\tscaleCursors();\n\t\tsetTextSize(size);\n\n\t\tint iterationGuard = 100;\n\t\tint heightDifference = 100;\n\t\tfloat lineSpacingMultiplier = 1.0f;\n\n\t\twhile (Math.abs(heightDifference) > 0) {\n\t\t\tif (heightDifference > 0) {\n\t\t\t\tlineSpacingMultiplier += 0.01f;\n\t\t\t} else {\n\t\t\t\tlineSpacingMultiplier -= 0.01f;\n\t\t\t}\n\n\t\t\tsetLineSpacing(0.0f, lineSpacingMultiplier);\n\t\t\theightDifference = bridge.charHeight - getLineHeight();\n\n\t\t\titerationGuard--;\n\t\t\tif (iterationGuard < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tcopyBufferToText();\n\t}\n\n\tprivate void scaleCursors() {\n\t\t// Create a scale matrix to scale our 1x1 representation of the cursor\n\t\ttempDst.set(0.0f, 0.0f, bridge.charWidth, bridge.charHeight);\n\t\tscaleMatrix.setRectToRect(tempSrc, tempDst, scaleType);\n\t}\n\n\t@Override\n\tpublic void onDraw(Canvas canvas) {\n\t\tif (bridge.bitmap != null) {\n\t\t\t// draw the bitmap\n\t\t\tbridge.onDraw();\n\n\t\t\t// draw the bridge bitmap if it exists\n\t\t\tcanvas.drawBitmap(bridge.bitmap, 0, 0, paint);\n\n\t\t\t// also draw cursor if visible\n\t\t\tif (bridge.buffer.isCursorVisible()) {\n\t\t\t\tint cursorColumn = bridge.buffer.getCursorColumn();\n\t\t\t\tfinal int cursorRow = bridge.buffer.getCursorRow();\n\n\t\t\t\tfinal int columns = bridge.buffer.getColumns();\n\n\t\t\t\tif (cursorColumn == columns)\n\t\t\t\t\tcursorColumn = columns - 1;\n\n\t\t\t\tif (cursorColumn < 0 || cursorRow < 0)\n\t\t\t\t\treturn;\n\n\t\t\t\tint currentAttribute = bridge.buffer.getAttributes(\n\t\t\t\t\t\tcursorColumn, cursorRow);\n\t\t\t\tboolean onWideCharacter = (currentAttribute & VDUBuffer.FULLWIDTH) != 0;\n\n\t\t\t\tint x = cursorColumn * bridge.charWidth;\n\t\t\t\tint y = (bridge.buffer.getCursorRow()\n\t\t\t\t\t\t+ bridge.buffer.screenBase - bridge.buffer.windowBase)\n\t\t\t\t\t\t* bridge.charHeight;\n\n\t\t\t\t// Save the current clip and translation\n\t\t\t\tcanvas.save();\n\n\t\t\t\tcanvas.translate(x, y);\n\t\t\t\tcanvas.clipRect(0, 0,\n\t\t\t\t\t\tbridge.charWidth * (onWideCharacter ? 2 : 1),\n\t\t\t\t\t\tbridge.charHeight);\n\t\t\t\tcanvas.drawPaint(cursorPaint);\n\n\t\t\t\tfinal int deadKey = bridge.getKeyHandler().getDeadKey();\n\t\t\t\tif (deadKey != 0) {\n\t\t\t\t\tcanvas.drawText(new char[] { (char) deadKey }, 0, 1, 0, 0, cursorStrokePaint);\n\t\t\t\t}\n\n\t\t\t\t// Make sure we scale our decorations to the correct size.\n\t\t\t\tcanvas.concat(scaleMatrix);\n\n\t\t\t\tint metaState = bridge.getKeyHandler().getMetaState();\n\n\t\t\t\tif ((metaState & TerminalKeyListener.OUR_SHIFT_ON) != 0)\n\t\t\t\t\tcanvas.drawPath(shiftCursor, cursorStrokePaint);\n\t\t\t\telse if ((metaState & TerminalKeyListener.OUR_SHIFT_LOCK) != 0)\n\t\t\t\t\tcanvas.drawPath(shiftCursor, cursorPaint);\n\n\t\t\t\tif ((metaState & TerminalKeyListener.OUR_ALT_ON) != 0)\n\t\t\t\t\tcanvas.drawPath(altCursor, cursorStrokePaint);\n\t\t\t\telse if ((metaState & TerminalKeyListener.OUR_ALT_LOCK) != 0)\n\t\t\t\t\tcanvas.drawPath(altCursor, cursorPaint);\n\n\t\t\t\tif ((metaState & TerminalKeyListener.OUR_CTRL_ON) != 0)\n\t\t\t\t\tcanvas.drawPath(ctrlCursor, cursorStrokePaint);\n\t\t\t\telse if ((metaState & TerminalKeyListener.OUR_CTRL_LOCK) != 0)\n\t\t\t\t\tcanvas.drawPath(ctrlCursor, cursorPaint);\n\n\t\t\t\t// Restore previous clip region\n\t\t\t\tcanvas.restore();\n\t\t\t}\n\n\t\t\t// draw any highlighted area\n\t\t\tif (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB &&\n\t\t\t\tbridge.isSelectingForCopy()) {\n\t\t\t\tSelectionArea area = bridge.getSelectionArea();\n\t\t\t\tcanvas.save(Canvas.CLIP_SAVE_FLAG);\n\t\t\t\tcanvas.clipRect(\n\t\t\t\t\tarea.getLeft() * bridge.charWidth,\n\t\t\t\t\tarea.getTop() * bridge.charHeight,\n\t\t\t\t\t(area.getRight() + 1) * bridge.charWidth,\n\t\t\t\t\t(area.getBottom() + 1) * bridge.charHeight\n\t\t\t\t);\n\t\t\t\tcanvas.drawPaint(cursorPaint);\n\t\t\t\tcanvas.restore();\n\t\t\t}\n\t\t}\n\n\t\tsuper.onDraw(canvas);\n\t}\n\n\tpublic void notifyUser(String message) {\n\t\tif (!notifications)\n\t\t\treturn;\n\n\t\tif (notification != null) {\n\t\t\t// Don't keep telling the user the same thing.\n\t\t\tif (lastNotification != null && lastNotification.equals(message))\n\t\t\t\treturn;\n\n\t\t\tnotification.setText(message);\n\t\t\tnotification.show();\n\t\t} else {\n\t\t\tnotification = Toast.makeText(context, message, Toast.LENGTH_SHORT);\n\t\t\tnotification.show();\n\t\t}\n\n\t\tlastNotification = message;\n\t}\n\n\t/**\n\t * Ask the {@link TerminalBridge} we're connected to to resize to a specific size.\n\t * @param width\n\t * @param height\n\t */\n\tpublic void forceSize(int width, int height) {\n\t\tbridge.resizeComputed(width, height, getWidth(), getHeight());\n\t}\n\n\t/**\n\t * Sets the ability for the TerminalView to display Toast notifications to the user.\n\t * @param value whether to enable notifications or not\n\t */\n\tpublic void setNotifications(boolean value) {\n\t\tnotifications = value;\n\t}\n\n\t@Override\n\tpublic boolean onCheckIsTextEditor() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic InputConnection onCreateInputConnection(EditorInfo outAttrs) {\n\t\toutAttrs.imeOptions |=\n\t\t\tEditorInfo.IME_FLAG_NO_EXTRACT_UI |\n\t\t\tEditorInfo.IME_FLAG_NO_ENTER_ACTION |\n\t\t\tEditorInfo.IME_ACTION_NONE;\n\t\toutAttrs.inputType = EditorInfo.TYPE_NULL;\n\t\treturn new BaseInputConnection(this, false) {\n\t\t\t@Override\n\t\t\tpublic boolean deleteSurroundingText (int leftLength, int rightLength) {\n\t\t\t\tif (rightLength == 0 && leftLength == 0) {\n\t\t\t\t\treturn this.sendKeyEvent(new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_DEL));\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < leftLength; i++) {\n\t\t\t\t\tthis.sendKeyEvent(new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_DEL));\n\t\t\t\t}\n\t\t\t\t// TODO: forward delete\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\t}\n\n\tpublic void propagateConsoleText(char[] rawText, int length) {\n\t\tif (mAccessibilityActive) {\n\t\t\tsynchronized (mAccessibilityLock) {\n\t\t\t\tmAccessibilityBuffer.append(rawText, 0, length);\n\t\t\t}\n\n\t\t\tif (mAccessibilityInitialized) {\n\t\t\t\tif (mEventSender != null) {\n\t\t\t\t\tremoveCallbacks(mEventSender);\n\t\t\t\t} else {\n\t\t\t\t\tmEventSender = new AccessibilityEventSender();\n\t\t\t\t}\n\n\t\t\t\tpostDelayed(mEventSender, ACCESSIBILITY_EVENT_THRESHOLD);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate class AccessibilityEventSender implements Runnable {\n\t\tpublic void run() {\n\t\t\tsynchronized (mAccessibilityLock) {\n\t\t\t\tif (mCodeMatcher == null) {\n\t\t\t\t\tmCodeMatcher = mControlCodes.matcher(mAccessibilityBuffer);\n\t\t\t\t} else {\n\t\t\t\t\tmCodeMatcher.reset(mAccessibilityBuffer);\n\t\t\t\t}\n\n\t\t\t\t// Strip all control codes out.\n\t\t\t\tmAccessibilityBuffer = new StringBuffer(mCodeMatcher.replaceAll(\" \"));\n\n\t\t\t\t// Apply Backspaces using backspace character sequence\n\t\t\t\tint i = mAccessibilityBuffer.indexOf(BACKSPACE_CODE);\n\t\t\t\twhile (i != -1) {\n\t\t\t\t\tmAccessibilityBuffer = mAccessibilityBuffer.replace(i == 0 ? 0 : i - 1, i\n\t\t\t\t\t\t\t+ BACKSPACE_CODE.length(), \"\");\n\t\t\t\t\ti = mAccessibilityBuffer.indexOf(BACKSPACE_CODE);\n\t\t\t\t}\n\n\t\t\t\tif (mAccessibilityBuffer.length() > 0) {\n\t\t\t\t\tAccessibilityEvent event = AccessibilityEvent.obtain(\n\t\t\t\t\t\t\tAccessibilityEvent.TYPE_VIEW_TEXT_CHANGED);\n\t\t\t\t\tevent.setFromIndex(0);\n\t\t\t\t\tevent.setAddedCount(mAccessibilityBuffer.length());\n\t\t\t\t\tevent.getText().add(mAccessibilityBuffer);\n\n\t\t\t\t\tsendAccessibilityEventUnchecked(event);\n\t\t\t\t\tmAccessibilityBuffer.setLength(0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate class AccessibilityStateTester extends AsyncTask<Void, Void, Boolean> {\n\t\t@Override\n\t\tprotected Boolean doInBackground(Void... params) {\n\t\t\t/*\n\t\t\t * Presumably if the accessibility manager is not enabled, we don't\n\t\t\t * need to send accessibility events.\n\t\t\t */\n\t\t\tfinal AccessibilityManager accessibility = (AccessibilityManager) context\n\t\t\t\t\t.getSystemService(Context.ACCESSIBILITY_SERVICE);\n\t\t\tif (!accessibility.isEnabled()) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Restrict the set of intents to only accessibility services that\n\t\t\t * have the category FEEDBACK_SPOKEN (aka, screen readers).\n\t\t\t */\n\t\t\tfinal Intent screenReaderIntent = new Intent(SCREENREADER_INTENT_ACTION);\n\t\t\tscreenReaderIntent.addCategory(SCREENREADER_INTENT_CATEGORY);\n\n\t\t\tfinal ContentResolver cr = context.getContentResolver();\n\n\t\t\tfinal List<ResolveInfo> screenReaders = context.getPackageManager().queryIntentServices(\n\t\t\t\t\tscreenReaderIntent, 0);\n\n\t\t\tboolean foundScreenReader = false;\n\n\t\t\tfinal int N = screenReaders.size();\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfinal ResolveInfo screenReader = screenReaders.get(i);\n\n\t\t\t\t/*\n\t\t\t\t * All screen readers are expected to implement a content\n\t\t\t\t * provider that responds to:\n\t\t\t\t * content://<nameofpackage>.providers.StatusProvider\n\t\t\t\t */\n\t\t\t\tfinal Cursor cursor = cr.query(\n\t\t\t\t\t\tUri.parse(\"content://\" + screenReader.serviceInfo.packageName\n\t\t\t\t\t\t\t\t+ \".providers.StatusProvider\"), null, null, null, null);\n\t\t\t\tif (cursor != null && cursor.moveToFirst()) {\n\t\t\t\t\t/*\n\t\t\t\t\t * These content providers use a special cursor that only has\n\t\t\t\t\t * one element, an integer that is 1 if the screen reader is\n\t\t\t\t\t * running.\n\t\t\t\t\t */\n\t\t\t\t\tfinal int status = cursor.getInt(0);\n\n\t\t\t\t\tcursor.close();\n\n\t\t\t\t\tif (status == 1) {\n\t\t\t\t\t\tfoundScreenReader = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (foundScreenReader) {\n\t\t\t\tmControlCodes = Pattern.compile(CONTROL_CODE_PATTERN);\n\t\t\t}\n\n\t\t\treturn foundScreenReader;\n\t\t}\n\n\t\t@Override\n\t\tprotected void onPostExecute(Boolean result) {\n\t\t\tmAccessibilityActive = result;\n\n\t\t\tmAccessibilityInitialized = true;\n\n\t\t\tif (result) {\n\t\t\t\tmEventSender = new AccessibilityEventSender();\n\t\t\t\tpostDelayed(mEventSender, ACCESSIBILITY_EVENT_THRESHOLD);\n\t\t\t} else {\n\t\t\t\tmAccessibilityBuffer = null;\n\t\t\t}\n\t\t}\n\t}\n}\n","lineNo":470}
{"Smelly Sample":"/*\n * ConnectBot: simple, powerful, open-source SSH client for Android\n * Copyright 2007 Kenny Root, Jeffrey Sharkey\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.connectbot;\n\nimport java.lang.ref.WeakReference;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.connectbot.bean.HostBean;\nimport org.connectbot.bean.SelectionArea;\nimport org.connectbot.service.BridgeDisconnectedListener;\nimport org.connectbot.service.PromptHelper;\nimport org.connectbot.service.TerminalBridge;\nimport org.connectbot.service.TerminalKeyListener;\nimport org.connectbot.service.TerminalManager;\nimport org.connectbot.util.PreferenceConstants;\n\nimport android.annotation.TargetApi;\nimport android.app.AlertDialog;\nimport android.app.Dialog;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.ServiceConnection;\nimport android.content.SharedPreferences;\nimport android.content.pm.ActivityInfo;\nimport android.content.res.Configuration;\nimport android.media.AudioManager;\nimport android.net.Uri;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Message;\nimport android.preference.PreferenceManager;\nimport android.support.annotation.Nullable;\nimport android.support.v4.app.ActivityCompat;\nimport android.support.design.widget.TabLayout;\nimport android.support.v4.view.MenuItemCompat;\nimport android.support.v4.view.MotionEventCompat;\nimport android.support.v4.view.PagerAdapter;\nimport android.support.v4.view.ViewPager;\nimport android.support.v7.app.ActionBar;\nimport android.support.v7.app.AppCompatActivity;\nimport android.support.v7.widget.Toolbar;\nimport android.text.ClipboardManager;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.GestureDetector;\nimport android.view.InputDevice;\nimport android.view.KeyEvent;\nimport android.view.LayoutInflater;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.MenuItem.OnMenuItemClickListener;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.view.View.OnClickListener;\nimport android.view.View.OnKeyListener;\nimport android.view.View.OnTouchListener;\nimport android.view.ViewConfiguration;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.WindowManager;\nimport android.view.animation.Animation;\nimport android.view.animation.AnimationUtils;\nimport android.view.inputmethod.InputMethodManager;\nimport android.widget.AdapterView;\nimport android.widget.AdapterView.OnItemClickListener;\nimport android.widget.ArrayAdapter;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.HorizontalScrollView;\nimport android.widget.ImageView;\nimport android.widget.LinearLayout;\nimport android.widget.ListView;\nimport android.widget.RelativeLayout;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport de.mud.terminal.vt320;\n\npublic class ConsoleActivity extends AppCompatActivity implements BridgeDisconnectedListener {\n\tpublic final static String TAG = \"CB.ConsoleActivity\";\n\n\tprotected static final int REQUEST_EDIT = 1;\n\n\tprivate static final int CLICK_TIME = 400;\n\tprivate static final float MAX_CLICK_DISTANCE = 25f;\n\tprivate static final int KEYBOARD_DISPLAY_TIME = 3000;\n\tprivate static final int KEYBOARD_REPEAT_INITIAL = 500;\n\tprivate static final int KEYBOARD_REPEAT = 100;\n\tprivate static final String STATE_SELECTED_URI = \"selectedUri\";\n\n\tprotected ViewPager pager = null;\n\tprotected TabLayout tabs = null;\n\tprotected Toolbar toolbar = null;\n\t@Nullable\n\tprotected TerminalManager bound = null;\n\tprotected TerminalPagerAdapter adapter = null;\n\tprotected LayoutInflater inflater = null;\n\n\tprivate SharedPreferences prefs = null;\n\n\t// determines whether or not menuitem accelerators are bound\n\t// otherwise they collide with an external keyboard's CTRL-char\n\tprivate boolean hardKeyboard = false;\n\n\tprotected Uri requested;\n\n\tprotected ClipboardManager clipboard;\n\tprivate RelativeLayout stringPromptGroup;\n\tprotected EditText stringPrompt;\n\tprivate TextView stringPromptInstructions;\n\n\tprivate RelativeLayout booleanPromptGroup;\n\tprivate TextView booleanPrompt;\n\tprivate Button booleanYes, booleanNo;\n\n\tprivate LinearLayout keyboardGroup;\n\tprivate Runnable keyboardGroupHider;\n\n\tprivate TextView empty;\n\n\tprivate Animation fade_out_delayed;\n\n\tprivate Animation keyboard_fade_in, keyboard_fade_out;\n\tprivate float lastX, lastY;\n\n\tprivate InputMethodManager inputManager;\n\n\tprivate MenuItem disconnect, copy, paste, portForward, resize, urlscan;\n\n\tprotected TerminalBridge copySource = null;\n\tprivate int lastTouchRow, lastTouchCol;\n\n\tprivate boolean forcedOrientation;\n\n\tprivate Handler handler = new Handler();\n\n\tprivate ImageView mKeyboardButton;\n\n\t@Nullable private ActionBar actionBar;\n\tprivate boolean inActionBarMenu = false;\n\tprivate boolean titleBarHide;\n\n\tprivate ServiceConnection connection = new ServiceConnection() {\n\t\tpublic void onServiceConnected(ComponentName className, IBinder service) {\n\t\t\tbound = ((TerminalManager.TerminalBinder) service).getService();\n\n\t\t\t// let manager know about our event handling services\n\t\t\tbound.disconnectListener = ConsoleActivity.this;\n\t\t\tbound.setResizeAllowed(true);\n\n\t\t\tfinal String requestedNickname = (requested != null) ? requested.getFragment() : null;\n\t\t\tTerminalBridge requestedBridge = bound.getConnectedBridge(requestedNickname);\n\n\t\t\t// If we didn't find the requested connection, try opening it\n\t\t\tif (requestedNickname != null && requestedBridge == null) {\n\t\t\t\ttry {\n\t\t\t\t\tLog.d(TAG, String.format(\"We couldnt find an existing bridge with URI=%s (nickname=%s), so creating one now\", requested.toString(), requestedNickname));\n\t\t\t\t\trequestedBridge = bound.openConnection(requested);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tLog.e(TAG, \"Problem while trying to create new requested bridge from URI\", e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// create views for all bridges on this service\n\t\t\tadapter.notifyDataSetChanged();\n\t\t\tint requestedIndex = bound.getBridges().indexOf(requestedBridge);\n\n\t\t\tif (requestedIndex != -1) {\n\t\t\t\tsetDisplayedTerminal(requestedIndex);\n\t\t\t}\n\t\t}\n\n\t\tpublic void onServiceDisconnected(ComponentName className) {\n\t\t\tadapter.notifyDataSetChanged();\n\t\t\tupdateEmptyVisible();\n\t\t\tbound = null;\n\t\t}\n\t};\n\n\tprotected Handler promptHandler = new Handler() {\n\t\t@Override\n\t\tpublic void handleMessage(Message msg) {\n\t\t\t// someone below us requested to display a prompt\n\t\t\tupdatePromptVisible();\n\t\t}\n\t};\n\n\tpublic void onDisconnected(TerminalBridge bridge) {\n\t\tsynchronized (adapter) {\n\t\t\tadapter.notifyDataSetChanged();\n\t\t\tLog.d(TAG, \"Someone sending HANDLE_DISCONNECT to parentHandler\");\n\n\t\t\tif (bridge.isAwaitingClose()) {\n\t\t\t\tcloseBridge(bridge);\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected OnClickListener emulatedKeysListener = new OnClickListener() {\n\t\t@Override\n\t\tpublic void onClick(View v) {\n\t\t\tonEmulatedKeyClicked(v);\n\t\t}\n\t};\n\n\tprotected Handler keyRepeatHandler = new Handler();\n\n\n\t/**\n\t * Handle repeatable virtual keys and touch events\n\t */\n\tpublic class KeyRepeater implements Runnable, OnTouchListener, OnClickListener {\n\t\tprivate View mView;\n\t\tprivate Handler mHandler;\n\t\tprivate boolean mDown;\n\n\t\tpublic KeyRepeater(Handler handler, View view) {\n\t\t\tmView = view;\n\t\t\tmHandler = handler;\n\t\t\tmView.setOnTouchListener(this);\n\t\t\tmView.setOnClickListener(this);\n\t\t\tmDown = false;\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tmDown = true;\n\t\t\tmHandler.removeCallbacks(this);\n\t\t\tmHandler.postDelayed(this, KEYBOARD_REPEAT);\n\t\t\tmView.performClick();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean onTouch(View v, MotionEvent event) {\n\t\t\tif (BuildConfig.DEBUG) {\n\t\t\t\tLog.d(TAG, \"KeyRepeater.onTouch(\" + v.getId() + \", \" +\n\t\t\t\t\t\tevent.getAction() + \", \" +\n\t\t\t\t\t\tevent.getActionIndex() + \", \" +\n\t\t\t\t\t\tevent.getActionMasked() + \");\");\n\t\t\t}\n\t\t\tswitch (event.getAction()) {\n\t\t\tcase MotionEvent.ACTION_DOWN:\n\t\t\t\tmDown = false;\n\t\t\t\tmHandler.postDelayed(this, KEYBOARD_REPEAT_INITIAL);\n\t\t\t\tmView.setPressed(true);\n\t\t\t\treturn (true);\n\n\t\t\tcase MotionEvent.ACTION_CANCEL:\n\t\t\t\tmHandler.removeCallbacks(this);\n\t\t\t\tmView.setPressed(false);\n\t\t\t\treturn (true);\n\n\t\t\tcase MotionEvent.ACTION_UP:\n\t\t\t\tmHandler.removeCallbacks(this);\n\t\t\t\tmView.setPressed(false);\n\n\t\t\t\tif (!mDown) {\n\t\t\t\t\tmView.performClick();\n\t\t\t\t}\n\t\t\t\treturn (true);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic void onClick(View view) {\n\t\t\tonEmulatedKeyClicked(view);\n\t\t}\n\t}\n\n\tprivate void onEmulatedKeyClicked(View v) {\n\t\tTerminalView terminal = adapter.getCurrentTerminalView();\n\t\tif (terminal == null) return;\n\n\t\tif (BuildConfig.DEBUG) {\n\t\t\tLog.d(TAG, \"onEmulatedKeyClicked(\" + v.getId() + \")\");\n\t\t}\n\t\tTerminalKeyListener handler = terminal.bridge.getKeyHandler();\n\t\tboolean hideKeys = false;\n\n\t\tswitch (v.getId()) {\n\t\tcase R.id.button_ctrl:\n\t\t\thandler.metaPress(TerminalKeyListener.OUR_CTRL_ON, true);\n\t\t\thideKeys = true;\n\t\t\tbreak;\n\t\tcase R.id.button_esc:\n\t\t\thandler.sendEscape();\n\t\t\thideKeys = true;\n\t\t\tbreak;\n\t\tcase R.id.button_tab:\n\t\t\thandler.sendTab();\n\t\t\thideKeys = true;\n\t\t\tbreak;\n\n\t\tcase R.id.button_up:\n\t\t\thandler.sendPressedKey(vt320.KEY_UP);\n\t\t\tbreak;\n\t\tcase R.id.button_down:\n\t\t\thandler.sendPressedKey(vt320.KEY_DOWN);\n\t\t\tbreak;\n\t\tcase R.id.button_left:\n\t\t\thandler.sendPressedKey(vt320.KEY_LEFT);\n\t\t\tbreak;\n\t\tcase R.id.button_right:\n\t\t\thandler.sendPressedKey(vt320.KEY_RIGHT);\n\t\t\tbreak;\n\n\t\tcase R.id.button_home:\n\t\t\thandler.sendPressedKey(vt320.KEY_HOME);\n\t\t\tbreak;\n\t\tcase R.id.button_end:\n\t\t\thandler.sendPressedKey(vt320.KEY_END);\n\t\t\tbreak;\n\t\tcase R.id.button_pgup:\n\t\t\thandler.sendPressedKey(vt320.KEY_PAGE_UP);\n\t\t\tbreak;\n\t\tcase R.id.button_pgdn:\n\t\t\thandler.sendPressedKey(vt320.KEY_PAGE_DOWN);\n\t\t\tbreak;\n\n\t\tcase R.id.button_f1:\n\t\t\thandler.sendPressedKey(vt320.KEY_F1);\n\t\t\tbreak;\n\t\tcase R.id.button_f2:\n\t\t\thandler.sendPressedKey(vt320.KEY_F2);\n\t\t\tbreak;\n\t\tcase R.id.button_f3:\n\t\t\thandler.sendPressedKey(vt320.KEY_F3);\n\t\t\tbreak;\n\t\tcase R.id.button_f4:\n\t\t\thandler.sendPressedKey(vt320.KEY_F4);\n\t\t\tbreak;\n\t\tcase R.id.button_f5:\n\t\t\thandler.sendPressedKey(vt320.KEY_F5);\n\t\t\tbreak;\n\t\tcase R.id.button_f6:\n\t\t\thandler.sendPressedKey(vt320.KEY_F6);\n\t\t\tbreak;\n\t\tcase R.id.button_f7:\n\t\t\thandler.sendPressedKey(vt320.KEY_F7);\n\t\t\tbreak;\n\t\tcase R.id.button_f8:\n\t\t\thandler.sendPressedKey(vt320.KEY_F8);\n\t\t\tbreak;\n\t\tcase R.id.button_f9:\n\t\t\thandler.sendPressedKey(vt320.KEY_F9);\n\t\t\tbreak;\n\t\tcase R.id.button_f10:\n\t\t\thandler.sendPressedKey(vt320.KEY_F10);\n\t\t\tbreak;\n\t\tcase R.id.button_f11:\n\t\t\thandler.sendPressedKey(vt320.KEY_F11);\n\t\t\tbreak;\n\t\tcase R.id.button_f12:\n\t\t\thandler.sendPressedKey(vt320.KEY_F12);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (hideKeys)\n\t\t\thideEmulatedKeys();\n\t\telse\n\t\t\tautoHideEmulatedKeys();\n\n\t\tterminal.bridge.tryKeyVibrate();\n\t\thideActionBarIfRequested();\n\t}\n\n\tprivate void hideActionBarIfRequested() {\n\t\tif (titleBarHide && actionBar != null) {\n\t\t\tactionBar.hide();\n\t\t}\n\t}\n\n\t/**\n\t * @param bridge\n\t */\n\tprivate void closeBridge(final TerminalBridge bridge) {\n\t\tupdateEmptyVisible();\n\t\tupdatePromptVisible();\n\n\t\t// If we just closed the last bridge, go back to the previous activity.\n\t\tif (pager.getChildCount() == 0) {\n\t\t\tfinish();\n\t\t}\n\t}\n\n\tprotected View findCurrentView(int id) {\n\t\tView view = pager.findViewWithTag(adapter.getBridgeAtPosition(pager.getCurrentItem()));\n\t\tif (view == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn view.findViewById(id);\n\t}\n\n\tprotected PromptHelper getCurrentPromptHelper() {\n\t\tTerminalView view = adapter.getCurrentTerminalView();\n\t\tif (view == null) return null;\n\t\treturn view.bridge.promptHelper;\n\t}\n\n\tprotected void hideAllPrompts() {\n\t\tstringPromptGroup.setVisibility(View.GONE);\n\t\tbooleanPromptGroup.setVisibility(View.GONE);\n\t}\n\n\tprivate void showEmulatedKeys(boolean showActionBar) {\n\t\tkeyboardGroup.startAnimation(keyboard_fade_in);\n\t\tkeyboardGroup.setVisibility(View.VISIBLE);\n\t\tif (showActionBar) {\n\t\t\tactionBar.show();\n\t\t}\n\t\tautoHideEmulatedKeys();\n\t}\n\n\tprivate void autoHideEmulatedKeys() {\n\t\tif (keyboardGroupHider != null)\n\t\t\thandler.removeCallbacks(keyboardGroupHider);\n\t\tkeyboardGroupHider = new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tif (keyboardGroup.getVisibility() == View.GONE || inActionBarMenu)\n\t\t\t\t\treturn;\n\n\t\t\t\tkeyboardGroup.startAnimation(keyboard_fade_out);\n\t\t\t\tkeyboardGroup.setVisibility(View.GONE);\n\t\t\t\thideActionBarIfRequested();\n\t\t\t\tkeyboardGroupHider = null;\n\t\t\t}\n\t\t};\n\t\thandler.postDelayed(keyboardGroupHider, KEYBOARD_DISPLAY_TIME);\n\t}\n\n\tprivate void hideEmulatedKeys() {\n\t\tif (keyboardGroupHider != null)\n\t\t\thandler.removeCallbacks(keyboardGroupHider);\n\t\tkeyboardGroup.setVisibility(View.GONE);\n\t\thideActionBarIfRequested();\n\t}\n\n\t@Override\n\tpublic void onCreate(Bundle icicle) {\n\t\tsuper.onCreate(icicle);\n\n\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD) {\n\t\t\tStrictModeSetup.run();\n\t\t}\n\n\t\thardKeyboard = getResources().getConfiguration().keyboard ==\n\t\t\t\tConfiguration.KEYBOARD_QWERTY;\n\n\t\tclipboard = (ClipboardManager) getSystemService(CLIPBOARD_SERVICE);\n\t\tprefs = PreferenceManager.getDefaultSharedPreferences(this);\n\n\t\ttitleBarHide = prefs.getBoolean(PreferenceConstants.TITLEBARHIDE, false);\n\t\tif (titleBarHide) {\n\t\t\tsupportRequestWindowFeature(Window.FEATURE_ACTION_BAR_OVERLAY);\n\t\t}\n\n\t\tthis.setContentView(R.layout.act_console);\n\n\t\t// hide status bar if requested by user\n\t\tif (prefs.getBoolean(PreferenceConstants.FULLSCREEN, false)) {\n\t\t\tgetWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,\n\t\t\t\t\tWindowManager.LayoutParams.FLAG_FULLSCREEN);\n\t\t}\n\n\t\t// TODO find proper way to disable volume key beep if it exists.\n\t\tsetVolumeControlStream(AudioManager.STREAM_MUSIC);\n\n\t\t// handle requested console from incoming intent\n\t\tif (icicle == null) {\n\t\t\trequested = getIntent().getData();\n\t\t} else {\n\t\t\tString uri = icicle.getString(STATE_SELECTED_URI);\n\t\t\tif (uri != null) {\n\t\t\t\trequested = Uri.parse(uri);\n\t\t\t}\n\t\t}\n\n\t\tinflater = LayoutInflater.from(this);\n\n\t\ttoolbar = (Toolbar) findViewById(R.id.toolbar);\n\t\tpager = (ViewPager) findViewById(R.id.console_flip);\n\t\tregisterForContextMenu(pager);\n\t\tpager.addOnPageChangeListener(\n\t\t\t\tnew ViewPager.SimpleOnPageChangeListener() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onPageSelected(int position) {\n\t\t\t\t\t\tsetTitle(adapter.getPageTitle(position));\n\t\t\t\t\t\tonTerminalChanged();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\tadapter = new TerminalPagerAdapter();\n\t\tpager.setAdapter(adapter);\n\n\t\tempty = (TextView) findViewById(android.R.id.empty);\n\n\t\tstringPromptGroup = (RelativeLayout) findViewById(R.id.console_password_group);\n\t\tstringPromptInstructions = (TextView) findViewById(R.id.console_password_instructions);\n\t\tstringPrompt = (EditText) findViewById(R.id.console_password);\n\t\tstringPrompt.setOnKeyListener(new OnKeyListener() {\n\t\t\tpublic boolean onKey(View v, int keyCode, KeyEvent event) {\n\t\t\t\tif (event.getAction() == KeyEvent.ACTION_UP) return false;\n\t\t\t\tif (keyCode != KeyEvent.KEYCODE_ENTER) return false;\n\n\t\t\t\t// pass collected password down to current terminal\n\t\t\t\tString value = stringPrompt.getText().toString();\n\n\t\t\t\tPromptHelper helper = getCurrentPromptHelper();\n\t\t\t\tif (helper == null) return false;\n\t\t\t\thelper.setResponse(value);\n\n\t\t\t\t// finally clear password for next user\n\t\t\t\tstringPrompt.setText(\"\");\n\t\t\t\tupdatePromptVisible();\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\tbooleanPromptGroup = (RelativeLayout) findViewById(R.id.console_boolean_group);\n\t\tbooleanPrompt = (TextView) findViewById(R.id.console_prompt);\n\n\t\tbooleanYes = (Button) findViewById(R.id.console_prompt_yes);\n\t\tbooleanYes.setOnClickListener(new OnClickListener() {\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tPromptHelper helper = getCurrentPromptHelper();\n\t\t\t\tif (helper == null) return;\n\t\t\t\thelper.setResponse(Boolean.TRUE);\n\t\t\t\tupdatePromptVisible();\n\t\t\t}\n\t\t});\n\n\t\tbooleanNo = (Button) findViewById(R.id.console_prompt_no);\n\t\tbooleanNo.setOnClickListener(new OnClickListener() {\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tPromptHelper helper = getCurrentPromptHelper();\n\t\t\t\tif (helper == null) return;\n\t\t\t\thelper.setResponse(Boolean.FALSE);\n\t\t\t\tupdatePromptVisible();\n\t\t\t}\n\t\t});\n\n\t\tfade_out_delayed = AnimationUtils.loadAnimation(this, R.anim.fade_out_delayed);\n\n\t\t// Preload animation for keyboard button\n\t\tkeyboard_fade_in = AnimationUtils.loadAnimation(this, R.anim.keyboard_fade_in);\n\t\tkeyboard_fade_out = AnimationUtils.loadAnimation(this, R.anim.keyboard_fade_out);\n\n\t\tinputManager = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);\n\n\t\tkeyboardGroup = (LinearLayout) findViewById(R.id.keyboard_group);\n\n\t\tmKeyboardButton = (ImageView) findViewById(R.id.button_keyboard);\n\t\tmKeyboardButton.setOnClickListener(new OnClickListener() {\n\t\t\tpublic void onClick(View view) {\n\t\t\t\tView terminal = adapter.getCurrentTerminalView();\n\t\t\t\tif (terminal == null)\n\t\t\t\t\treturn;\n\n\t\t\t\tinputManager.showSoftInput(terminal, InputMethodManager.SHOW_FORCED);\n\t\t\t\thideEmulatedKeys();\n\t\t\t}\n\t\t});\n\n\t\tfindViewById(R.id.button_ctrl).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_esc).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_tab).setOnClickListener(emulatedKeysListener);\n\n\t\tnew KeyRepeater(keyRepeatHandler, findViewById(R.id.button_up));\n\t\tnew KeyRepeater(keyRepeatHandler, findViewById(R.id.button_down));\n\t\tnew KeyRepeater(keyRepeatHandler, findViewById(R.id.button_left));\n\t\tnew KeyRepeater(keyRepeatHandler, findViewById(R.id.button_right));\n\n\t\tfindViewById(R.id.button_home).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_end).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_pgup).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_pgdn).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f1).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f2).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f3).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f4).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f5).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f6).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f7).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f8).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f9).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f10).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f11).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f12).setOnClickListener(emulatedKeysListener);\n\n\n\t\tactionBar = getSupportActionBar();\n\t\tif (actionBar != null) {\n\t\t\tactionBar.setDisplayHomeAsUpEnabled(true);\n\t\t\tif (titleBarHide) {\n\t\t\t\tactionBar.hide();\n\t\t\t}\n\t\t\tactionBar.addOnMenuVisibilityListener(new ActionBar.OnMenuVisibilityListener() {\n\t\t\t\tpublic void onMenuVisibilityChanged(boolean isVisible) {\n\t\t\t\t\tinActionBarMenu = isVisible;\n\t\t\t\t\tif (isVisible == false) {\n\t\t\t\t\t\thideEmulatedKeys();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tfinal HorizontalScrollView keyboardScroll = (HorizontalScrollView) findViewById(R.id.keyboard_hscroll);\n\t\tif (!hardKeyboard) {\n\t\t\t// Show virtual keyboard and scroll back and forth\n\t\t\tshowEmulatedKeys(false);\n\t\t\tkeyboardScroll.postDelayed(new Runnable() {\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\tfinal int xscroll = findViewById(R.id.button_f12).getRight();\n\t\t\t\t\tif (BuildConfig.DEBUG) {\n\t\t\t\t\t\tLog.d(TAG, \"smoothScrollBy(toEnd[\" + xscroll + \"])\");\n\t\t\t\t\t}\n\t\t\t\t\tkeyboardScroll.smoothScrollBy(xscroll, 0);\n\t\t\t\t\tkeyboardScroll.postDelayed(new Runnable() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\tif (BuildConfig.DEBUG) {\n\t\t\t\t\t\t\t\tLog.d(TAG, \"smoothScrollBy(toStart[\" + (-xscroll) + \"])\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tkeyboardScroll.smoothScrollBy(-xscroll, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, 500);\n\t\t\t\t}\n\t\t\t}, 500);\n\t\t}\n\n\t\t// Reset keyboard auto-hide timer when scrolling\n\t\tkeyboardScroll.setOnTouchListener(\n\t\t\t\tnew OnTouchListener() {\n\t\t\t\t\tpublic boolean onTouch(View v, MotionEvent event) {\n\t\t\t\t\t\tswitch (event.getAction()) {\n\t\t\t\t\t\tcase MotionEvent.ACTION_MOVE:\n\t\t\t\t\t\t\tautoHideEmulatedKeys();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase MotionEvent.ACTION_UP:\n\t\t\t\t\t\t\tv.performClick();\n\t\t\t\t\t\t\treturn (true);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn (false);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\ttabs = (TabLayout) findViewById(R.id.tabs);\n\t\tif (tabs != null)\n\t\t\tsetupTabLayoutWithViewPager();\n\n\t\t// detect fling gestures to switch between terminals\n\t\tfinal GestureDetector detect = new GestureDetector(this, new GestureDetector.SimpleOnGestureListener() {\n\t\t\tprivate float totalY = 0;\n\n\t\t\t@Override\n\t\t\tpublic void onLongPress(MotionEvent e) {\n\t\t\t\tsuper.onLongPress(e);\n\t\t\t\topenContextMenu(pager);\n\t\t\t}\n\n\n\t\t\t@Override\n\t\t\tpublic boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {\n\n\t\t\t\t// if copying, then ignore\n\t\t\t\tif (copySource != null && copySource.isSelectingForCopy())\n\t\t\t\t\treturn false;\n\n\t\t\t\tif (e1 == null || e2 == null)\n\t\t\t\t\treturn false;\n\n\t\t\t\t// if releasing then reset total scroll\n\t\t\t\tif (e2.getAction() == MotionEvent.ACTION_UP) {\n\t\t\t\t\ttotalY = 0;\n\t\t\t\t}\n\n\t\t\t\t// activate consider if within x tolerance\n\t\t\t\tint touchSlop = ViewConfiguration.get(ConsoleActivity.this).getScaledTouchSlop();\n\t\t\t\tif (Math.abs(e1.getX() - e2.getX()) < touchSlop * 4) {\n\n\t\t\t\t\tView view = adapter.getCurrentTerminalView();\n\t\t\t\t\tif (view == null) return false;\n\t\t\t\t\tTerminalView terminal = (TerminalView) view;\n\n\t\t\t\t\t// estimate how many rows we have scrolled through\n\t\t\t\t\t// accumulate distance that doesn't trigger immediate scroll\n\t\t\t\t\ttotalY += distanceY;\n\t\t\t\t\tfinal int moved = (int) (totalY / terminal.bridge.charHeight);\n\n\t\t\t\t\t// consume as scrollback only if towards right half of screen\n\t\t\t\t\tif (e2.getX() > view.getWidth() / 2) {\n\t\t\t\t\t\tif (moved != 0) {\n\t\t\t\t\t\t\tint base = terminal.bridge.buffer.getWindowBase();\n\t\t\t\t\t\t\tterminal.bridge.buffer.setWindowBase(base + moved);\n\t\t\t\t\t\t\ttotalY = 0;\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// otherwise consume as pgup/pgdown for every 5 lines\n\t\t\t\t\t\tif (moved > 5) {\n\t\t\t\t\t\t\t((vt320) terminal.bridge.buffer).keyPressed(vt320.KEY_PAGE_DOWN, ' ', 0);\n\t\t\t\t\t\t\tterminal.bridge.tryKeyVibrate();\n\t\t\t\t\t\t\ttotalY = 0;\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t} else if (moved < -5) {\n\t\t\t\t\t\t\t((vt320) terminal.bridge.buffer).keyPressed(vt320.KEY_PAGE_UP, ' ', 0);\n\t\t\t\t\t\t\tterminal.bridge.tryKeyVibrate();\n\t\t\t\t\t\t\ttotalY = 0;\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t}\n\n\n\t\t});\n\n\t\tpager.setLongClickable(true);\n\t\tpager.setOnTouchListener(new OnTouchListener() {\n\n\t\t\tpublic boolean onTouch(View v, MotionEvent event) {\n\t\t\t\tTerminalBridge bridge = adapter.getCurrentTerminalView().bridge;\n\n\t\t\t\t// Handle mouse-specific actions.\n\t\t\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH &&\n\t\t\t\t\t\tMotionEventCompat.getSource(event) == InputDevice.SOURCE_MOUSE) {\n\t\t\t\t\tif (onMouseEvent(event, bridge)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// when copying, highlight the area\n\t\t\t\tif (copySource != null && copySource.isSelectingForCopy()) {\n\t\t\t\t\tSelectionArea area = copySource.getSelectionArea();\n\t\t\t\t\tint row = (int) Math.floor(event.getY() / bridge.charHeight);\n\t\t\t\t\tint col = (int) Math.floor(event.getX() / bridge.charWidth);\n\n\t\t\t\t\tswitch (event.getAction()) {\n\t\t\t\t\tcase MotionEvent.ACTION_DOWN:\n\t\t\t\t\t\t// recording starting area\n\t\t\t\t\t\tif (area.isSelectingOrigin()) {\n\t\t\t\t\t\t\tarea.setRow(row);\n\t\t\t\t\t\t\tarea.setColumn(col);\n\t\t\t\t\t\t\tlastTouchRow = row;\n\t\t\t\t\t\t\tlastTouchCol = col;\n\t\t\t\t\t\t\tcopySource.redraw();\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tcase MotionEvent.ACTION_MOVE:\n\t\t\t\t\t\t/* ignore when user hasn't moved since last time so\n\t\t\t\t\t\t * we can fine-tune with directional pad\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (row == lastTouchRow && col == lastTouchCol)\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t// if the user moves, start the selection for other corner\n\t\t\t\t\t\tarea.finishSelectingOrigin();\n\n\t\t\t\t\t\t// update selected area\n\t\t\t\t\t\tarea.setRow(row);\n\t\t\t\t\t\tarea.setColumn(col);\n\t\t\t\t\t\tlastTouchRow = row;\n\t\t\t\t\t\tlastTouchCol = col;\n\t\t\t\t\t\tcopySource.redraw();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tcase MotionEvent.ACTION_UP:\n\t\t\t\t\t\t/* If they didn't move their finger, maybe they meant to\n\t\t\t\t\t\t * select the rest of the text with the directional pad.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (area.getLeft() == area.getRight() &&\n\t\t\t\t\t\t\t\tarea.getTop() == area.getBottom()) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// copy selected area to clipboard\n\t\t\t\t\t\tString copiedText = area.copyFrom(copySource.buffer);\n\n\t\t\t\t\t\tclipboard.setText(copiedText);\n\t\t\t\t\t\tToast.makeText(ConsoleActivity.this, getString(R.string.console_copy_done, copiedText.length()), Toast.LENGTH_LONG).show();\n\t\t\t\t\t\t// fall through to clear state\n\n\t\t\t\t\tcase MotionEvent.ACTION_CANCEL:\n\t\t\t\t\t\t// make sure we clear any highlighted area\n\t\t\t\t\t\tarea.reset();\n\t\t\t\t\t\tcopySource.setSelectingForCopy(false);\n\t\t\t\t\t\tcopySource.redraw();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (event.getAction() == MotionEvent.ACTION_DOWN) {\n\t\t\t\t\tlastX = event.getX();\n\t\t\t\t\tlastY = event.getY();\n\t\t\t\t} else if (event.getAction() == MotionEvent.ACTION_UP\n\t\t\t\t\t\t&& keyboardGroup.getVisibility() == View.GONE\n\t\t\t\t\t\t&& event.getEventTime() - event.getDownTime() < CLICK_TIME\n\t\t\t\t\t\t&& Math.abs(event.getX() - lastX) < MAX_CLICK_DISTANCE\n\t\t\t\t\t\t&& Math.abs(event.getY() - lastY) < MAX_CLICK_DISTANCE) {\n\t\t\t\t\tshowEmulatedKeys(true);\n\t\t\t\t}\n\n\t\t\t\t// pass any touch events back to detector\n\t\t\t\treturn detect.onTouchEvent(event);\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * @param event\n\t\t\t * @param bridge\n\t\t\t * @return True if the event is handled.\n\t\t\t */\n\t\t\t@TargetApi(14)\n\t\t\tprivate boolean onMouseEvent(MotionEvent event, TerminalBridge bridge) {\n\t\t\t\tint row = (int) Math.floor(event.getY() / bridge.charHeight);\n\t\t\t\tint col = (int) Math.floor(event.getX() / bridge.charWidth);\n\t\t\t\tint meta = event.getMetaState();\n\t\t\t\tboolean shiftOn = (meta & KeyEvent.META_SHIFT_ON) != 0;\n\t\t\t\tboolean mouseReport = ((vt320) bridge.buffer).isMouseReportEnabled();\n\n\t\t\t\t// MouseReport can be \"defeated\" using the shift key.\n\t\t\t\tif ((!mouseReport || shiftOn)) {\n\t\t\t\t\tif (event.getAction() == MotionEvent.ACTION_DOWN) {\n\t\t\t\t\t\tswitch (event.getButtonState()) {\n\t\t\t\t\t\tcase MotionEvent.BUTTON_PRIMARY:\n\t\t\t\t\t\t\t// Automatically start copy mode if using a mouse.\n\t\t\t\t\t\t\tstartCopyMode();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase MotionEvent.BUTTON_SECONDARY:\n\t\t\t\t\t\t\topenContextMenu(pager);\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\tcase MotionEvent.BUTTON_TERTIARY:\n\t\t\t\t\t\t\t// Middle click pastes.\n\t\t\t\t\t\t\tpasteIntoTerminal();\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (event.getAction() == MotionEvent.ACTION_DOWN) {\n\t\t\t\t\t((vt320) bridge.buffer).mousePressed(\n\t\t\t\t\t\t\tcol, row, mouseEventToJavaModifiers(event));\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (event.getAction() == MotionEvent.ACTION_UP) {\n\t\t\t\t\t((vt320) bridge.buffer).mouseReleased(col, row);\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (event.getAction() == MotionEvent.ACTION_MOVE) {\n\t\t\t\t\tint buttonState = event.getButtonState();\n\t\t\t\t\tint button = (buttonState & MotionEvent.BUTTON_PRIMARY) != 0 ? 0 :\n\t\t\t\t\t\t\t(buttonState & MotionEvent.BUTTON_SECONDARY) != 0 ? 1 :\n\t\t\t\t\t\t\t\t\t(buttonState & MotionEvent.BUTTON_TERTIARY) != 0 ? 2 : 3;\n\t\t\t\t\t((vt320) bridge.buffer).mouseMoved(\n\t\t\t\t\t\t\tbutton,\n\t\t\t\t\t\t\tcol,\n\t\t\t\t\t\t\trow,\n\t\t\t\t\t\t\t(meta & KeyEvent.META_CTRL_ON) != 0,\n\t\t\t\t\t\t\t(meta & KeyEvent.META_SHIFT_ON) != 0,\n\t\t\t\t\t\t\t(meta & KeyEvent.META_META_ON) != 0);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t});\n\t}\n\n\t/**\n\t * Takes an android mouse event and produces a Java InputEvent modifiers int which can be\n\t * passed to vt320.\n\t * @param mouseEvent The {@link MotionEvent} which should be a mouse click or release.\n\t * @return A Java InputEvent modifier int. See\n\t * http://docs.oracle.com/javase/7/docs/api/java/awt/event/InputEvent.html\n\t */\n\t@TargetApi(14)\n\tprivate static int mouseEventToJavaModifiers(MotionEvent mouseEvent) {\n\t\tif (MotionEventCompat.getSource(mouseEvent) != InputDevice.SOURCE_MOUSE) return 0;\n\n\t\tint mods = 0;\n\n\t\t// See http://docs.oracle.com/javase/7/docs/api/constant-values.html\n\t\tint buttonState = mouseEvent.getButtonState();\n\t\tif ((buttonState & MotionEvent.BUTTON_PRIMARY) != 0)\n\t\t\tmods |= 16;\n\t\tif ((buttonState & MotionEvent.BUTTON_SECONDARY) != 0)\n\t\t\tmods |= 8;\n\t\tif ((buttonState & MotionEvent.BUTTON_TERTIARY) != 0)\n\t\t\tmods |= 4;\n\n\t\t// Note: Meta and Ctrl are intentionally swapped here to keep logic in vt320 simple.\n\t\tint meta = mouseEvent.getMetaState();\n\t\tif ((meta & KeyEvent.META_META_ON) != 0)\n\t\t\tmods |= 2;\n\t\tif ((meta & KeyEvent.META_SHIFT_ON) != 0)\n\t\t\tmods |= 1;\n\t\tif ((meta & KeyEvent.META_CTRL_ON) != 0)\n\t\t\tmods |= 4;\n\n\t\treturn mods;\n\t}\n\n\t/**\n\t * Ties the {@link TabLayout} to the {@link ViewPager}.\n\t *\n\t * <p>This method will:\n\t * <ul>\n\t *     <li>Add a {@link ViewPager.OnPageChangeListener} that will forward events to\n\t *     this TabLayout.<\/li>\n\t *     <li>Populate the TabLayout's tabs from the ViewPager's {@link PagerAdapter}.<\/li>\n\t *     <li>Set our {@link TabLayout.OnTabSelectedListener} which will forward\n\t *     selected events to the ViewPager<\/li>\n\t * <\/ul>\n\t * <\/p>\n\t */\n\tpublic void setupTabLayoutWithViewPager() {\n\t\ttabs.setTabsFromPagerAdapter(adapter);\n\t\tpager.addOnPageChangeListener(new TabLayout.TabLayoutOnPageChangeListener(tabs));\n\t\ttabs.setOnTabSelectedListener(new TabLayout.ViewPagerOnTabSelectedListener(pager));\n\n\t\tif (adapter.getCount() > 0) {\n\t\t\tfinal int curItem = pager.getCurrentItem();\n\t\t\tif (tabs.getSelectedTabPosition() != curItem) {\n\t\t\t\ttabs.getTabAt(curItem).select();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t *\n\t */\n\tprivate void configureOrientation() {\n\t\tString rotateDefault;\n\t\tif (getResources().getConfiguration().keyboard == Configuration.KEYBOARD_NOKEYS)\n\t\t\trotateDefault = PreferenceConstants.ROTATION_PORTRAIT;\n\t\telse\n\t\t\trotateDefault = PreferenceConstants.ROTATION_LANDSCAPE;\n\n\t\tString rotate = prefs.getString(PreferenceConstants.ROTATION, rotateDefault);\n\t\tif (PreferenceConstants.ROTATION_DEFAULT.equals(rotate))\n\t\t\trotate = rotateDefault;\n\n\t\t// request a forced orientation if requested by user\n\t\tif (PreferenceConstants.ROTATION_LANDSCAPE.equals(rotate)) {\n\t\t\tsetRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);\n\t\t\tforcedOrientation = true;\n\t\t} else if (PreferenceConstants.ROTATION_PORTRAIT.equals(rotate)) {\n\t\t\tsetRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);\n\t\t\tforcedOrientation = true;\n\t\t} else {\n\t\t\tsetRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);\n\t\t\tforcedOrientation = false;\n\t\t}\n\t}\n\n\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu) {\n\t\tsuper.onCreateOptionsMenu(menu);\n\n\t\tTerminalView view = adapter.getCurrentTerminalView();\n\t\tfinal boolean activeTerminal = view != null;\n\t\tboolean sessionOpen = false;\n\t\tboolean disconnected = false;\n\t\tboolean canForwardPorts = false;\n\n\t\tif (activeTerminal) {\n\t\t\tTerminalBridge bridge = view.bridge;\n\t\t\tsessionOpen = bridge.isSessionOpen();\n\t\t\tdisconnected = bridge.isDisconnected();\n\t\t\tcanForwardPorts = bridge.canFowardPorts();\n\t\t}\n\n\t\tmenu.setQwertyMode(true);\n\n\t\tdisconnect = menu.add(R.string.list_host_disconnect);\n\t\tif (hardKeyboard)\n\t\t\tdisconnect.setAlphabeticShortcut('w');\n\t\tif (!sessionOpen && disconnected)\n\t\t\tdisconnect.setTitle(R.string.console_menu_close);\n\t\tdisconnect.setEnabled(activeTerminal);\n\t\tdisconnect.setIcon(android.R.drawable.ic_menu_close_clear_cancel);\n\t\tdisconnect.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t// disconnect or close the currently visible session\n\t\t\t\tTerminalView terminalView = adapter.getCurrentTerminalView();\n\t\t\t\tTerminalBridge bridge = terminalView.bridge;\n\n\t\t\t\tbridge.dispatchDisconnect(true);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\tcopy = menu.add(R.string.console_menu_copy);\n\t\tif (hardKeyboard)\n\t\t\tcopy.setAlphabeticShortcut('c');\n\t\tMenuItemCompat.setShowAsAction(copy, MenuItemCompat.SHOW_AS_ACTION_IF_ROOM);\n\t\tcopy.setIcon(R.drawable.ic_action_copy);\n\t\tcopy.setEnabled(activeTerminal);\n\t\tcopy.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tstartCopyMode();\n\t\t\t\tToast.makeText(ConsoleActivity.this, getString(R.string.console_copy_start), Toast.LENGTH_LONG).show();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\tpaste = menu.add(R.string.console_menu_paste);\n\t\tif (hardKeyboard)\n\t\t\tpaste.setAlphabeticShortcut('v');\n\t\tMenuItemCompat.setShowAsAction(paste, MenuItemCompat.SHOW_AS_ACTION_IF_ROOM);\n\t\tpaste.setIcon(R.drawable.ic_action_paste);\n\t\tpaste.setEnabled(clipboard.hasText() && sessionOpen);\n\t\tpaste.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tpasteIntoTerminal();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\tportForward = menu.add(R.string.console_menu_portforwards);\n\t\tif (hardKeyboard)\n\t\t\tportForward.setAlphabeticShortcut('f');\n\t\tportForward.setIcon(android.R.drawable.ic_menu_manage);\n\t\tportForward.setEnabled(sessionOpen && canForwardPorts);\n\t\tportForward.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tTerminalView terminalView = adapter.getCurrentTerminalView();\n\t\t\t\tTerminalBridge bridge = terminalView.bridge;\n\n\t\t\t\tIntent intent = new Intent(ConsoleActivity.this, PortForwardListActivity.class);\n\t\t\t\tintent.putExtra(Intent.EXTRA_TITLE, bridge.host.getId());\n\t\t\t\tConsoleActivity.this.startActivityForResult(intent, REQUEST_EDIT);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\turlscan = menu.add(R.string.console_menu_urlscan);\n\t\tif (hardKeyboard)\n\t\t\turlscan.setAlphabeticShortcut('u');\n\t\turlscan.setIcon(android.R.drawable.ic_menu_search);\n\t\turlscan.setEnabled(activeTerminal);\n\t\turlscan.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tfinal TerminalView terminalView = adapter.getCurrentTerminalView();\n\n\t\t\t\tList<String> urls = terminalView.bridge.scanForURLs();\n\n\t\t\t\tDialog urlDialog = new Dialog(ConsoleActivity.this);\n\t\t\t\turlDialog.setTitle(R.string.console_menu_urlscan);\n\n\t\t\t\tListView urlListView = new ListView(ConsoleActivity.this);\n\t\t\t\tURLItemListener urlListener = new URLItemListener(ConsoleActivity.this);\n\t\t\t\turlListView.setOnItemClickListener(urlListener);\n\n\t\t\t\turlListView.setAdapter(new ArrayAdapter<String>(ConsoleActivity.this, android.R.layout.simple_list_item_1, urls));\n\t\t\t\turlDialog.setContentView(urlListView);\n\t\t\t\turlDialog.show();\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\tresize = menu.add(R.string.console_menu_resize);\n\t\tif (hardKeyboard)\n\t\t\tresize.setAlphabeticShortcut('s');\n\t\tresize.setIcon(android.R.drawable.ic_menu_crop);\n\t\tresize.setEnabled(sessionOpen);\n\t\tresize.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tfinal TerminalView terminalView = adapter.getCurrentTerminalView();\n\n\t\t\t\tfinal View resizeView = inflater.inflate(R.layout.dia_resize, null, false);\n\t\t\t\tnew AlertDialog.Builder(ConsoleActivity.this)\n\t\t\t\t\t\t.setView(resizeView)\n\t\t\t\t\t\t.setPositiveButton(R.string.button_resize, new DialogInterface.OnClickListener() {\n\t\t\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\t\t\t\tint width, height;\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\twidth = Integer.parseInt(((EditText) resizeView\n\t\t\t\t\t\t\t\t\t\t\t.findViewById(R.id.width))\n\t\t\t\t\t\t\t\t\t\t\t.getText().toString());\n\t\t\t\t\t\t\t\t\theight = Integer.parseInt(((EditText) resizeView\n\t\t\t\t\t\t\t\t\t\t\t.findViewById(R.id.height))\n\t\t\t\t\t\t\t\t\t\t\t.getText().toString());\n\t\t\t\t\t\t\t\t} catch (NumberFormatException nfe) {\n\t\t\t\t\t\t\t\t\t// TODO change this to a real dialog where we can\n\t\t\t\t\t\t\t\t\t// make the input boxes turn red to indicate an error.\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tterminalView.forceSize(width, height);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}).setNegativeButton(android.R.string.cancel, null).create().show();\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean onPrepareOptionsMenu(Menu menu) {\n\t\tsuper.onPrepareOptionsMenu(menu);\n\n\t\tsetVolumeControlStream(AudioManager.STREAM_NOTIFICATION);\n\n\t\tfinal TerminalView view = adapter.getCurrentTerminalView();\n\t\tboolean activeTerminal = view != null;\n\t\tboolean sessionOpen = false;\n\t\tboolean disconnected = false;\n\t\tboolean canForwardPorts = false;\n\n\t\tif (activeTerminal) {\n\t\t\tTerminalBridge bridge = view.bridge;\n\t\t\tsessionOpen = bridge.isSessionOpen();\n\t\t\tdisconnected = bridge.isDisconnected();\n\t\t\tcanForwardPorts = bridge.canFowardPorts();\n\t\t}\n\n\t\tdisconnect.setEnabled(activeTerminal);\n\t\tif (sessionOpen || !disconnected)\n\t\t\tdisconnect.setTitle(R.string.list_host_disconnect);\n\t\telse\n\t\t\tdisconnect.setTitle(R.string.console_menu_close);\n\t\tcopy.setEnabled(activeTerminal);\n\t\tpaste.setEnabled(clipboard.hasText() && sessionOpen);\n\t\tportForward.setEnabled(sessionOpen && canForwardPorts);\n\t\turlscan.setEnabled(activeTerminal);\n\t\tresize.setEnabled(sessionOpen);\n\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tswitch (item.getItemId()) {\n\t\tcase android.R.id.home:\n\t\t\tIntent intent = new Intent(this, HostListActivity.class);\n\t\t\tintent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n\t\t\tstartActivity(intent);\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn super.onOptionsItemSelected(item);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void onOptionsMenuClosed(Menu menu) {\n\t\tsuper.onOptionsMenuClosed(menu);\n\n\t\tsetVolumeControlStream(AudioManager.STREAM_MUSIC);\n\t}\n\n\t@Override\n\tpublic void onCreateContextMenu(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo) {\n\t\tfinal TerminalView view = adapter.getCurrentTerminalView();\n\t\tboolean activeTerminal = view != null;\n\t\tboolean sessionOpen = false;\n\n\t\tif (activeTerminal) {\n\t\t\tTerminalBridge bridge = view.bridge;\n\t\t\tsessionOpen = bridge.isSessionOpen();\n\t\t}\n\n\t\tMenuItem paste = menu.add(R.string.console_menu_paste);\n\t\tif (hardKeyboard)\n\t\t\tpaste.setAlphabeticShortcut('v');\n\t\tpaste.setIcon(android.R.drawable.ic_menu_edit);\n\t\tpaste.setEnabled(clipboard.hasText() && sessionOpen);\n\t\tpaste.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tpasteIntoTerminal();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\n\t}\n\n\t@Override\n\tpublic void onStart() {\n\t\tsuper.onStart();\n\n\t\t// connect with manager service to find all bridges\n\t\t// when connected it will insert all views\n\t\tbindService(new Intent(this, TerminalManager.class), connection, Context.BIND_AUTO_CREATE);\n\t}\n\n\t@Override\n\tpublic void onPause() {\n\t\tsuper.onPause();\n\t\tLog.d(TAG, \"onPause called\");\n\n\t\tif (forcedOrientation && bound != null) {\n\t\t\tbound.setResizeAllowed(false);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void onResume() {\n\t\tsuper.onResume();\n\t\tLog.d(TAG, \"onResume called\");\n\n\t\t// Make sure we don't let the screen fall asleep.\n\t\t// This also keeps the Wi-Fi chipset from disconnecting us.\n\t\tif (prefs.getBoolean(PreferenceConstants.KEEP_ALIVE, true)) {\n\t\t\tgetWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);\n\t\t} else {\n\t\t\tgetWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);\n\t\t}\n\n\t\tconfigureOrientation();\n\n\t\tif (forcedOrientation && bound != null) {\n\t\t\tbound.setResizeAllowed(true);\n\t\t}\n\t}\n\n\t/* (non-Javadoc)\n\t * @see android.app.Activity#onNewIntent(android.content.Intent)\n\t */\n\t@Override\n\tprotected void onNewIntent(Intent intent) {\n\t\tsuper.onNewIntent(intent);\n\n\t\tLog.d(TAG, \"onNewIntent called\");\n\n\t\trequested = intent.getData();\n\n\t\tif (requested == null) {\n\t\t\tLog.e(TAG, \"Got null intent data in onNewIntent()\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (bound == null) {\n\t\t\tLog.e(TAG, \"We're not bound in onNewIntent()\");\n\t\t\treturn;\n\t\t}\n\n\t\tTerminalBridge requestedBridge = bound.getConnectedBridge(requested.getFragment());\n\t\tint requestedIndex = 0;\n\n\t\tsynchronized (pager) {\n\t\t\tif (requestedBridge == null) {\n\t\t\t\t// If we didn't find the requested connection, try opening it\n\n\t\t\t\ttry {\n\t\t\t\t\tLog.d(TAG, String.format(\"We couldnt find an existing bridge with URI=%s (nickname=%s),\" +\n\t\t\t\t\t\t\t\"so creating one now\", requested.toString(), requested.getFragment()));\n\t\t\t\t\trequestedBridge = bound.openConnection(requested);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tLog.e(TAG, \"Problem while trying to create new requested bridge from URI\", e);\n\t\t\t\t\t// TODO: We should display an error dialog here.\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tadapter.notifyDataSetChanged();\n\t\t\t\trequestedIndex = adapter.getCount();\n\t\t\t} else {\n\t\t\t\tfinal int flipIndex = bound.getBridges().indexOf(requestedBridge);\n\t\t\t\tif (flipIndex > requestedIndex) {\n\t\t\t\t\trequestedIndex = flipIndex;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsetDisplayedTerminal(requestedIndex);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void onStop() {\n\t\tsuper.onStop();\n\n\t\tunbindService(connection);\n\t}\n\n\t@Override\n\tpublic void onSaveInstanceState(Bundle savedInstanceState) {\n\t\t// Maintain selected host if connected.\n\t\tif (adapter.getCurrentTerminalView() != null\n\t\t\t\t&& !adapter.getCurrentTerminalView().bridge.isDisconnected()) {\n\t\t\tUri uri = adapter.getCurrentTerminalView().bridge.host.getUri();\n\t\t\tsavedInstanceState.putString(STATE_SELECTED_URI, uri.toString());\n\t\t}\n\n\t\tsuper.onSaveInstanceState(savedInstanceState);\n\t}\n\n\tprivate void startCopyMode() {\n\t\t// mark as copying and reset any previous bounds\n\t\tTerminalView terminalView = (TerminalView) adapter.getCurrentTerminalView();\n\t\tcopySource = terminalView.bridge;\n\n\t\tSelectionArea area = copySource.getSelectionArea();\n\t\tarea.reset();\n\t\tarea.setBounds(copySource.buffer.getColumns(), copySource.buffer.getRows());\n\n\t\tcopySource.setSelectingForCopy(true);\n\n\t\t// Make sure we show the initial selection\n\t\tcopySource.redraw();\n\t}\n\n\t/**\n\t * Save the currently shown {@link TerminalView} as the default. This is\n\t * saved back down into {@link TerminalManager} where we can read it again\n\t * later.\n\t */\n\tprivate void updateDefault() {\n\t\t// update the current default terminal\n\t\tTerminalView view = adapter.getCurrentTerminalView();\n\t\tif (view == null || bound == null) {\n\t\t\treturn;\n\t\t}\n\t\tbound.defaultBridge = view.bridge;\n\t}\n\n\tprotected void updateEmptyVisible() {\n\t\t// update visibility of empty status message\n\t\tempty.setVisibility((pager.getChildCount() == 0) ? View.VISIBLE : View.GONE);\n\t}\n\n\t/**\n\t * Show any prompts requested by the currently visible {@link TerminalView}.\n\t */\n\tprotected void updatePromptVisible() {\n\t\t// check if our currently-visible terminalbridge is requesting any prompt services\n\t\tTerminalView view = adapter.getCurrentTerminalView();\n\n\t\t// Hide all the prompts in case a prompt request was canceled\n\t\thideAllPrompts();\n\n\t\tif (view == null) {\n\t\t\t// we dont have an active view, so hide any prompts\n\t\t\treturn;\n\t\t}\n\n\t\tPromptHelper prompt = view.bridge.promptHelper;\n\t\tif (String.class.equals(prompt.promptRequested)) {\n\t\t\tstringPromptGroup.setVisibility(View.VISIBLE);\n\n\t\t\tString instructions = prompt.promptInstructions;\n\t\t\tif (instructions != null && instructions.length() > 0) {\n\t\t\t\tstringPromptInstructions.setVisibility(View.VISIBLE);\n\t\t\t\tstringPromptInstructions.setText(instructions);\n\t\t\t} else\n\t\t\t\tstringPromptInstructions.setVisibility(View.GONE);\n\t\t\tstringPrompt.setText(\"\");\n\t\t\tstringPrompt.setHint(prompt.promptHint);\n\t\t\tstringPrompt.requestFocus();\n\n\t\t} else if (Boolean.class.equals(prompt.promptRequested)) {\n\t\t\tbooleanPromptGroup.setVisibility(View.VISIBLE);\n\t\t\tbooleanPrompt.setText(prompt.promptHint);\n\t\t\tbooleanYes.requestFocus();\n\n\t\t} else {\n\t\t\thideAllPrompts();\n\t\t\tview.requestFocus();\n\t\t}\n\t}\n\n\tprivate class URLItemListener implements OnItemClickListener {\n\t\tprivate WeakReference<Context> contextRef;\n\n\t\tURLItemListener(Context context) {\n\t\t\tthis.contextRef = new WeakReference<Context>(context);\n\t\t}\n\n\t\tpublic void onItemClick(AdapterView<?> arg0, View view, int position, long id) {\n\t\t\tContext context = contextRef.get();\n\n\t\t\tif (context == null)\n\t\t\t\treturn;\n\n\t\t\ttry {\n\t\t\t\tTextView urlView = (TextView) view;\n\n\t\t\t\tString url = urlView.getText().toString();\n\t\t\t\tif (url.indexOf(\"://\") < 0)\n\t\t\t\t\turl = \"http://\" + url;\n\n\t\t\t\tIntent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));\n\t\t\t\tcontext.startActivity(intent);\n\t\t\t} catch (Exception e) {\n\t\t\t\tLog.e(TAG, \"couldn't open URL\", e);\n\t\t\t\t// We should probably tell the user that we couldn't find a handler...\n\t\t\t}\n\t\t}\n\n\t}\n\n\t@Override\n\tpublic void onConfigurationChanged(Configuration newConfig) {\n\t\tsuper.onConfigurationChanged(newConfig);\n\n\t\tLog.d(TAG, String.format(\"onConfigurationChanged; requestedOrientation=%d, newConfig.orientation=%d\", getRequestedOrientation(), newConfig.orientation));\n\t\tif (bound != null) {\n\t\t\tif (forcedOrientation &&\n\t\t\t\t\t(newConfig.orientation != Configuration.ORIENTATION_LANDSCAPE &&\n\t\t\t\t\t\t\tgetRequestedOrientation() == ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE) ||\n\t\t\t\t\t(newConfig.orientation != Configuration.ORIENTATION_PORTRAIT &&\n\t\t\t\t\t\t\tgetRequestedOrientation() == ActivityInfo.SCREEN_ORIENTATION_PORTRAIT))\n\t\t\t\tbound.setResizeAllowed(false);\n\t\t\telse\n\t\t\t\tbound.setResizeAllowed(true);\n\n\t\t\tbound.hardKeyboardHidden = (newConfig.hardKeyboardHidden == Configuration.HARDKEYBOARDHIDDEN_YES);\n\n\t\t\tmKeyboardButton.setVisibility(bound.hardKeyboardHidden ? View.VISIBLE : View.GONE);\n\t\t}\n\t}\n\n\t/**\n\t * Called whenever the displayed terminal is changed.\n\t */\n\tprivate void onTerminalChanged() {\n\t\tView overlay = findCurrentView(R.id.terminal_overlay);\n\t\tif (overlay != null)\n\t\t\toverlay.startAnimation(fade_out_delayed);\n\t\tupdateDefault();\n\t\tupdatePromptVisible();\n\t\tActivityCompat.invalidateOptionsMenu(ConsoleActivity.this);\n\t}\n\n\t/**\n\t * Displays the child in the ViewPager at the requestedIndex and updates the prompts.\n\t *\n\t * @param requestedIndex the index of the terminal view to display\n\t */\n\tprivate void setDisplayedTerminal(int requestedIndex) {\n\t\tpager.setCurrentItem(requestedIndex);\n\t\t// set activity title\n\t\tsetTitle(adapter.getPageTitle(requestedIndex));\n\t\tonTerminalChanged();\n\t}\n\n\tprivate void pasteIntoTerminal() {\n\t\t// force insert of clipboard text into current console\n\t\tTerminalView terminalView = adapter.getCurrentTerminalView();\n\t\tTerminalBridge bridge = terminalView.bridge;\n\n\t\t// pull string from clipboard and generate all events to force down\n\t\tString clip = clipboard.getText().toString();\n\t\tbridge.injectString(clip);\n\t}\n\n\tpublic class TerminalPagerAdapter extends PagerAdapter {\n\t\t@Override\n\t\tpublic int getCount() {\n\t\t\tif (bound != null) {\n\t\t\t\treturn bound.getBridges().size();\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Object instantiateItem(ViewGroup container, int position) {\n\t\t\tif (bound == null || bound.getBridges().size() <= position) {\n\t\t\t\tLog.w(TAG, \"Activity not bound when creating TerminalView.\");\n\t\t\t}\n\t\t\tTerminalBridge bridge = bound.getBridges().get(position);\n\t\t\tbridge.promptHelper.setHandler(promptHandler);\n\n\t\t\t// inflate each terminal view\n\t\t\tRelativeLayout view = (RelativeLayout) inflater.inflate(\n\t\t\t\t\tR.layout.item_terminal, container, false);\n\n\t\t\t// set the terminal overlay text\n\t\t\tTextView overlay = (TextView) view.findViewById(R.id.terminal_overlay);\n\t\t\toverlay.setText(bridge.host.getNickname());\n\n\t\t\t// and add our terminal view control, using index to place behind overlay\n\t\t\tfinal TerminalView terminal = new TerminalView(container.getContext(), bridge);\n\t\t\tterminal.setId(R.id.terminal_view);\n\t\t\tview.addView(terminal, 0);\n\n\t\t\t// Tag the view with its bridge so it can be retrieved later.\n\t\t\tview.setTag(bridge);\n\n\t\t\tcontainer.addView(view);\n\t\t\toverlay.startAnimation(fade_out_delayed);\n\t\t\treturn view;\n\t\t}\n\n\t\t@Override\n\t\tpublic void destroyItem(ViewGroup container, int position, Object object) {\n\t\t\tfinal View view = (View) object;\n\n\t\t\tcontainer.removeView(view);\n\t\t}\n\n\t\t@Override\n\t\tpublic int getItemPosition(Object object) {\n\t\t\tif (bound == null) {\n\t\t\t\treturn POSITION_NONE;\n\t\t\t}\n\n\t\t\tView view = (View) object;\n\t\t\tTerminalView terminal = (TerminalView) view.findViewById(R.id.terminal_view);\n\t\t\tHostBean host = terminal.bridge.host;\n\n\t\t\tint itemIndex = POSITION_NONE;\n\t\t\tint i = 0;\n\t\t\tfor (TerminalBridge bridge : bound.getBridges()) {\n\t\t\t\tif (bridge.host.equals(host)) {\n\t\t\t\t\titemIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t\treturn itemIndex;\n\t\t}\n\n\t\tpublic TerminalBridge getBridgeAtPosition(int position) {\n\t\t\tif (bound == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tArrayList<TerminalBridge> bridges = bound.getBridges();\n\t\t\tif (position < 0 || position >= bridges.size()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn bridges.get(position);\n\t\t}\n\n\t\t@Override\n\t\tpublic void notifyDataSetChanged() {\n\t\t\tsuper.notifyDataSetChanged();\n\t\t\tif (tabs != null) {\n\t\t\t\ttoolbar.setVisibility(this.getCount() > 1 ? View.VISIBLE : View.GONE);\n\t\t\t\ttabs.setTabsFromPagerAdapter(this);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isViewFromObject(View view, Object object) {\n\t\t\treturn view == object;\n\t\t}\n\n\t\t@Override\n\t\tpublic CharSequence getPageTitle(int position) {\n\t\t\tTerminalBridge bridge = getBridgeAtPosition(position);\n\t\t\tif (bridge == null) {\n\t\t\t\treturn \"???\";\n\t\t\t}\n\t\t\treturn bridge.host.getNickname();\n\t\t}\n\n\t\tpublic TerminalView getCurrentTerminalView() {\n\t\t\tView currentView = pager.findViewWithTag(getBridgeAtPosition(pager.getCurrentItem()));\n\t\t\tif (currentView == null) return null;\n\t\t\treturn (TerminalView) currentView.findViewById(R.id.terminal_view);\n\t\t}\n\t}\n}\n","Method after Refactoring":"/*\n * ConnectBot: simple, powerful, open-source SSH client for Android\n * Copyright 2007 Kenny Root, Jeffrey Sharkey\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.connectbot;\n\nimport java.lang.ref.WeakReference;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.connectbot.bean.HostBean;\nimport org.connectbot.bean.SelectionArea;\nimport org.connectbot.service.BridgeDisconnectedListener;\nimport org.connectbot.service.PromptHelper;\nimport org.connectbot.service.TerminalBridge;\nimport org.connectbot.service.TerminalKeyListener;\nimport org.connectbot.service.TerminalManager;\nimport org.connectbot.util.PreferenceConstants;\n\nimport android.annotation.TargetApi;\nimport android.app.AlertDialog;\nimport android.app.Dialog;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.ServiceConnection;\nimport android.content.SharedPreferences;\nimport android.content.pm.ActivityInfo;\nimport android.content.res.Configuration;\nimport android.media.AudioManager;\nimport android.net.Uri;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Message;\nimport android.preference.PreferenceManager;\nimport android.support.annotation.Nullable;\nimport android.support.design.widget.TabLayout;\nimport android.support.v4.app.ActivityCompat;\nimport android.support.v4.view.MenuItemCompat;\nimport android.support.v4.view.PagerAdapter;\nimport android.support.v4.view.ViewPager;\nimport android.support.v7.app.ActionBar;\nimport android.support.v7.app.AppCompatActivity;\nimport android.support.v7.widget.Toolbar;\nimport android.text.ClipboardManager;\nimport android.util.Log;\nimport android.view.KeyEvent;\nimport android.view.LayoutInflater;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.MenuItem.OnMenuItemClickListener;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.view.View.OnClickListener;\nimport android.view.View.OnKeyListener;\nimport android.view.View.OnTouchListener;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.WindowManager;\nimport android.view.animation.Animation;\nimport android.view.animation.AnimationUtils;\nimport android.view.inputmethod.InputMethodManager;\nimport android.widget.AdapterView;\nimport android.widget.AdapterView.OnItemClickListener;\nimport android.widget.ArrayAdapter;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.HorizontalScrollView;\nimport android.widget.ImageView;\nimport android.widget.LinearLayout;\nimport android.widget.ListView;\nimport android.widget.RelativeLayout;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport de.mud.terminal.vt320;\n\npublic class ConsoleActivity extends AppCompatActivity implements BridgeDisconnectedListener {\n\tpublic final static String TAG = \"CB.ConsoleActivity\";\n\n\tprotected static final int REQUEST_EDIT = 1;\n\n\tprivate static final int KEYBOARD_DISPLAY_TIME = 3000;\n\tprivate static final int KEYBOARD_REPEAT_INITIAL = 500;\n\tprivate static final int KEYBOARD_REPEAT = 100;\n\tprivate static final String STATE_SELECTED_URI = \"selectedUri\";\n\n\tprotected ViewPager pager = null;\n\tprotected TabLayout tabs = null;\n\tprotected Toolbar toolbar = null;\n\t@Nullable\n\tprotected TerminalManager bound = null;\n\tprotected TerminalPagerAdapter adapter = null;\n\tprotected LayoutInflater inflater = null;\n\n\tprivate SharedPreferences prefs = null;\n\n\t// determines whether or not menuitem accelerators are bound\n\t// otherwise they collide with an external keyboard's CTRL-char\n\tprivate boolean hardKeyboard = false;\n\n\tprotected Uri requested;\n\n\tprotected ClipboardManager clipboard;\n\tprivate RelativeLayout stringPromptGroup;\n\tprotected EditText stringPrompt;\n\tprivate TextView stringPromptInstructions;\n\n\tprivate RelativeLayout booleanPromptGroup;\n\tprivate TextView booleanPrompt;\n\tprivate Button booleanYes, booleanNo;\n\n\tprivate LinearLayout keyboardGroup;\n\tprivate Runnable keyboardGroupHider;\n\n\tprivate TextView empty;\n\n\tprivate Animation fade_out_delayed;\n\n\tprivate Animation keyboard_fade_in, keyboard_fade_out;\n\n\tprivate InputMethodManager inputManager;\n\n\tprivate MenuItem disconnect, copy, paste, portForward, resize, urlscan;\n\n\tprotected TerminalBridge copySource = null;\n\tprivate int lastTouchRow, lastTouchCol;\n\n\tprivate boolean forcedOrientation;\n\n\tprivate Handler handler = new Handler();\n\n\tprivate ImageView mKeyboardButton;\n\n\t@Nullable private ActionBar actionBar;\n\tprivate boolean inActionBarMenu = false;\n\tprivate boolean titleBarHide;\n\n\tprivate ServiceConnection connection = new ServiceConnection() {\n\t\tpublic void onServiceConnected(ComponentName className, IBinder service) {\n\t\t\tbound = ((TerminalManager.TerminalBinder) service).getService();\n\n\t\t\t// let manager know about our event handling services\n\t\t\tbound.disconnectListener = ConsoleActivity.this;\n\t\t\tbound.setResizeAllowed(true);\n\n\t\t\tfinal String requestedNickname = (requested != null) ? requested.getFragment() : null;\n\t\t\tTerminalBridge requestedBridge = bound.getConnectedBridge(requestedNickname);\n\n\t\t\t// If we didn't find the requested connection, try opening it\n\t\t\tif (requestedNickname != null && requestedBridge == null) {\n\t\t\t\ttry {\n\t\t\t\t\tLog.d(TAG, String.format(\"We couldnt find an existing bridge with URI=%s (nickname=%s), so creating one now\", requested.toString(), requestedNickname));\n\t\t\t\t\trequestedBridge = bound.openConnection(requested);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tLog.e(TAG, \"Problem while trying to create new requested bridge from URI\", e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// create views for all bridges on this service\n\t\t\tadapter.notifyDataSetChanged();\n\t\t\tint requestedIndex = bound.getBridges().indexOf(requestedBridge);\n\n\t\t\tif (requestedIndex != -1) {\n\t\t\t\tsetDisplayedTerminal(requestedIndex);\n\t\t\t}\n\t\t}\n\n\t\tpublic void onServiceDisconnected(ComponentName className) {\n\t\t\tadapter.notifyDataSetChanged();\n\t\t\tupdateEmptyVisible();\n\t\t\tbound = null;\n\t\t}\n\t};\n\n\tprotected Handler promptHandler = new Handler() {\n\t\t@Override\n\t\tpublic void handleMessage(Message msg) {\n\t\t\t// someone below us requested to display a prompt\n\t\t\tupdatePromptVisible();\n\t\t}\n\t};\n\n\tpublic void onDisconnected(TerminalBridge bridge) {\n\t\tsynchronized (adapter) {\n\t\t\tadapter.notifyDataSetChanged();\n\t\t\tLog.d(TAG, \"Someone sending HANDLE_DISCONNECT to parentHandler\");\n\n\t\t\tif (bridge.isAwaitingClose()) {\n\t\t\t\tcloseBridge(bridge);\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected OnClickListener emulatedKeysListener = new OnClickListener() {\n\t\t@Override\n\t\tpublic void onClick(View v) {\n\t\t\tonEmulatedKeyClicked(v);\n\t\t}\n\t};\n\n\tprotected Handler keyRepeatHandler = new Handler();\n\n\n\t/**\n\t * Handle repeatable virtual keys and touch events\n\t */\n\tpublic class KeyRepeater implements Runnable, OnTouchListener, OnClickListener {\n\t\tprivate View mView;\n\t\tprivate Handler mHandler;\n\t\tprivate boolean mDown;\n\n\t\tpublic KeyRepeater(Handler handler, View view) {\n\t\t\tmView = view;\n\t\t\tmHandler = handler;\n\t\t\tmView.setOnTouchListener(this);\n\t\t\tmView.setOnClickListener(this);\n\t\t\tmDown = false;\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tmDown = true;\n\t\t\tmHandler.removeCallbacks(this);\n\t\t\tmHandler.postDelayed(this, KEYBOARD_REPEAT);\n\t\t\tmView.performClick();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean onTouch(View v, MotionEvent event) {\n\t\t\tif (BuildConfig.DEBUG) {\n\t\t\t\tLog.d(TAG, \"KeyRepeater.onTouch(\" + v.getId() + \", \" +\n\t\t\t\t\t\tevent.getAction() + \", \" +\n\t\t\t\t\t\tevent.getActionIndex() + \", \" +\n\t\t\t\t\t\tevent.getActionMasked() + \");\");\n\t\t\t}\n\t\t\tswitch (event.getAction()) {\n\t\t\tcase MotionEvent.ACTION_DOWN:\n\t\t\t\tmDown = false;\n\t\t\t\tmHandler.postDelayed(this, KEYBOARD_REPEAT_INITIAL);\n\t\t\t\tmView.setPressed(true);\n\t\t\t\treturn (true);\n\n\t\t\tcase MotionEvent.ACTION_CANCEL:\n\t\t\t\tmHandler.removeCallbacks(this);\n\t\t\t\tmView.setPressed(false);\n\t\t\t\treturn (true);\n\n\t\t\tcase MotionEvent.ACTION_UP:\n\t\t\t\tmHandler.removeCallbacks(this);\n\t\t\t\tmView.setPressed(false);\n\n\t\t\t\tif (!mDown) {\n\t\t\t\t\tmView.performClick();\n\t\t\t\t}\n\t\t\t\treturn (true);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic void onClick(View view) {\n\t\t\tonEmulatedKeyClicked(view);\n\t\t}\n\t}\n\n\tprivate void onEmulatedKeyClicked(View v) {\n\t\tTerminalView terminal = adapter.getCurrentTerminalView();\n\t\tif (terminal == null) return;\n\n\t\tif (BuildConfig.DEBUG) {\n\t\t\tLog.d(TAG, \"onEmulatedKeyClicked(\" + v.getId() + \")\");\n\t\t}\n\t\tTerminalKeyListener handler = terminal.bridge.getKeyHandler();\n\t\tboolean hideKeys = false;\n\n\t\tswitch (v.getId()) {\n\t\tcase R.id.button_ctrl:\n\t\t\thandler.metaPress(TerminalKeyListener.OUR_CTRL_ON, true);\n\t\t\thideKeys = true;\n\t\t\tbreak;\n\t\tcase R.id.button_esc:\n\t\t\thandler.sendEscape();\n\t\t\thideKeys = true;\n\t\t\tbreak;\n\t\tcase R.id.button_tab:\n\t\t\thandler.sendTab();\n\t\t\thideKeys = true;\n\t\t\tbreak;\n\n\t\tcase R.id.button_up:\n\t\t\thandler.sendPressedKey(vt320.KEY_UP);\n\t\t\tbreak;\n\t\tcase R.id.button_down:\n\t\t\thandler.sendPressedKey(vt320.KEY_DOWN);\n\t\t\tbreak;\n\t\tcase R.id.button_left:\n\t\t\thandler.sendPressedKey(vt320.KEY_LEFT);\n\t\t\tbreak;\n\t\tcase R.id.button_right:\n\t\t\thandler.sendPressedKey(vt320.KEY_RIGHT);\n\t\t\tbreak;\n\n\t\tcase R.id.button_home:\n\t\t\thandler.sendPressedKey(vt320.KEY_HOME);\n\t\t\tbreak;\n\t\tcase R.id.button_end:\n\t\t\thandler.sendPressedKey(vt320.KEY_END);\n\t\t\tbreak;\n\t\tcase R.id.button_pgup:\n\t\t\thandler.sendPressedKey(vt320.KEY_PAGE_UP);\n\t\t\tbreak;\n\t\tcase R.id.button_pgdn:\n\t\t\thandler.sendPressedKey(vt320.KEY_PAGE_DOWN);\n\t\t\tbreak;\n\n\t\tcase R.id.button_f1:\n\t\t\thandler.sendPressedKey(vt320.KEY_F1);\n\t\t\tbreak;\n\t\tcase R.id.button_f2:\n\t\t\thandler.sendPressedKey(vt320.KEY_F2);\n\t\t\tbreak;\n\t\tcase R.id.button_f3:\n\t\t\thandler.sendPressedKey(vt320.KEY_F3);\n\t\t\tbreak;\n\t\tcase R.id.button_f4:\n\t\t\thandler.sendPressedKey(vt320.KEY_F4);\n\t\t\tbreak;\n\t\tcase R.id.button_f5:\n\t\t\thandler.sendPressedKey(vt320.KEY_F5);\n\t\t\tbreak;\n\t\tcase R.id.button_f6:\n\t\t\thandler.sendPressedKey(vt320.KEY_F6);\n\t\t\tbreak;\n\t\tcase R.id.button_f7:\n\t\t\thandler.sendPressedKey(vt320.KEY_F7);\n\t\t\tbreak;\n\t\tcase R.id.button_f8:\n\t\t\thandler.sendPressedKey(vt320.KEY_F8);\n\t\t\tbreak;\n\t\tcase R.id.button_f9:\n\t\t\thandler.sendPressedKey(vt320.KEY_F9);\n\t\t\tbreak;\n\t\tcase R.id.button_f10:\n\t\t\thandler.sendPressedKey(vt320.KEY_F10);\n\t\t\tbreak;\n\t\tcase R.id.button_f11:\n\t\t\thandler.sendPressedKey(vt320.KEY_F11);\n\t\t\tbreak;\n\t\tcase R.id.button_f12:\n\t\t\thandler.sendPressedKey(vt320.KEY_F12);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (hideKeys)\n\t\t\thideEmulatedKeys();\n\t\telse\n\t\t\tautoHideEmulatedKeys();\n\n\t\tterminal.bridge.tryKeyVibrate();\n\t\thideActionBarIfRequested();\n\t}\n\n\tprivate void hideActionBarIfRequested() {\n\t\tif (titleBarHide && actionBar != null) {\n\t\t\tactionBar.hide();\n\t\t}\n\t}\n\n\t/**\n\t * @param bridge\n\t */\n\tprivate void closeBridge(final TerminalBridge bridge) {\n\t\tupdateEmptyVisible();\n\t\tupdatePromptVisible();\n\n\t\t// If we just closed the last bridge, go back to the previous activity.\n\t\tif (pager.getChildCount() == 0) {\n\t\t\tfinish();\n\t\t}\n\t}\n\n\tprotected View findCurrentView(int id) {\n\t\tView view = pager.findViewWithTag(adapter.getBridgeAtPosition(pager.getCurrentItem()));\n\t\tif (view == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn view.findViewById(id);\n\t}\n\n\tprotected PromptHelper getCurrentPromptHelper() {\n\t\tTerminalView view = adapter.getCurrentTerminalView();\n\t\tif (view == null) return null;\n\t\treturn view.bridge.promptHelper;\n\t}\n\n\tprotected void hideAllPrompts() {\n\t\tstringPromptGroup.setVisibility(View.GONE);\n\t\tbooleanPromptGroup.setVisibility(View.GONE);\n\t}\n\n\tprivate void showEmulatedKeys(boolean showActionBar) {\n\t\tkeyboardGroup.startAnimation(keyboard_fade_in);\n\t\tkeyboardGroup.setVisibility(View.VISIBLE);\n\t\tif (showActionBar) {\n\t\t\tactionBar.show();\n\t\t}\n\t\tautoHideEmulatedKeys();\n\t}\n\n\tprivate void autoHideEmulatedKeys() {\n\t\tif (keyboardGroupHider != null)\n\t\t\thandler.removeCallbacks(keyboardGroupHider);\n\t\tkeyboardGroupHider = new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tif (keyboardGroup.getVisibility() == View.GONE || inActionBarMenu)\n\t\t\t\t\treturn;\n\n\t\t\t\tkeyboardGroup.startAnimation(keyboard_fade_out);\n\t\t\t\tkeyboardGroup.setVisibility(View.GONE);\n\t\t\t\thideActionBarIfRequested();\n\t\t\t\tkeyboardGroupHider = null;\n\t\t\t}\n\t\t};\n\t\thandler.postDelayed(keyboardGroupHider, KEYBOARD_DISPLAY_TIME);\n\t}\n\n\tprivate void hideEmulatedKeys() {\n\t\tif (keyboardGroupHider != null)\n\t\t\thandler.removeCallbacks(keyboardGroupHider);\n\t\tkeyboardGroup.setVisibility(View.GONE);\n\t\thideActionBarIfRequested();\n\t}\n\n\t@Override\n\tpublic void onCreate(Bundle icicle) {\n\t\tsuper.onCreate(icicle);\n\n\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD) {\n\t\t\tStrictModeSetup.run();\n\t\t}\n\n\t\thardKeyboard = getResources().getConfiguration().keyboard ==\n\t\t\t\tConfiguration.KEYBOARD_QWERTY;\n\n\t\tclipboard = (ClipboardManager) getSystemService(CLIPBOARD_SERVICE);\n\t\tprefs = PreferenceManager.getDefaultSharedPreferences(this);\n\n\t\ttitleBarHide = prefs.getBoolean(PreferenceConstants.TITLEBARHIDE, false);\n\t\tif (titleBarHide) {\n\t\t\tsupportRequestWindowFeature(Window.FEATURE_ACTION_BAR_OVERLAY);\n\t\t}\n\n\t\tthis.setContentView(R.layout.act_console);\n\n\t\t// hide status bar if requested by user\n\t\tif (prefs.getBoolean(PreferenceConstants.FULLSCREEN, false)) {\n\t\t\tgetWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,\n\t\t\t\t\tWindowManager.LayoutParams.FLAG_FULLSCREEN);\n\t\t}\n\n\t\t// TODO find proper way to disable volume key beep if it exists.\n\t\tsetVolumeControlStream(AudioManager.STREAM_MUSIC);\n\n\t\t// handle requested console from incoming intent\n\t\tif (icicle == null) {\n\t\t\trequested = getIntent().getData();\n\t\t} else {\n\t\t\tString uri = icicle.getString(STATE_SELECTED_URI);\n\t\t\tif (uri != null) {\n\t\t\t\trequested = Uri.parse(uri);\n\t\t\t}\n\t\t}\n\n\t\tinflater = LayoutInflater.from(this);\n\n\t\ttoolbar = (Toolbar) findViewById(R.id.toolbar);\n\n\t\tpager = (ViewPager) findViewById(R.id.console_flip);\n\n\t\tpager.addOnPageChangeListener(\n\t\t\t\tnew ViewPager.SimpleOnPageChangeListener() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onPageSelected(int position) {\n\t\t\t\t\t\tsetTitle(adapter.getPageTitle(position));\n\t\t\t\t\t\tonTerminalChanged();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\tadapter = new TerminalPagerAdapter();\n\t\tpager.setAdapter(adapter);\n\n\t\tempty = (TextView) findViewById(android.R.id.empty);\n\n\t\tstringPromptGroup = (RelativeLayout) findViewById(R.id.console_password_group);\n\t\tstringPromptInstructions = (TextView) findViewById(R.id.console_password_instructions);\n\t\tstringPrompt = (EditText) findViewById(R.id.console_password);\n\t\tstringPrompt.setOnKeyListener(new OnKeyListener() {\n\t\t\tpublic boolean onKey(View v, int keyCode, KeyEvent event) {\n\t\t\t\tif (event.getAction() == KeyEvent.ACTION_UP) return false;\n\t\t\t\tif (keyCode != KeyEvent.KEYCODE_ENTER) return false;\n\n\t\t\t\t// pass collected password down to current terminal\n\t\t\t\tString value = stringPrompt.getText().toString();\n\n\t\t\t\tPromptHelper helper = getCurrentPromptHelper();\n\t\t\t\tif (helper == null) return false;\n\t\t\t\thelper.setResponse(value);\n\n\t\t\t\t// finally clear password for next user\n\t\t\t\tstringPrompt.setText(\"\");\n\t\t\t\tupdatePromptVisible();\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\tbooleanPromptGroup = (RelativeLayout) findViewById(R.id.console_boolean_group);\n\t\tbooleanPrompt = (TextView) findViewById(R.id.console_prompt);\n\n\t\tbooleanYes = (Button) findViewById(R.id.console_prompt_yes);\n\t\tbooleanYes.setOnClickListener(new OnClickListener() {\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tPromptHelper helper = getCurrentPromptHelper();\n\t\t\t\tif (helper == null) return;\n\t\t\t\thelper.setResponse(Boolean.TRUE);\n\t\t\t\tupdatePromptVisible();\n\t\t\t}\n\t\t});\n\n\t\tbooleanNo = (Button) findViewById(R.id.console_prompt_no);\n\t\tbooleanNo.setOnClickListener(new OnClickListener() {\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tPromptHelper helper = getCurrentPromptHelper();\n\t\t\t\tif (helper == null) return;\n\t\t\t\thelper.setResponse(Boolean.FALSE);\n\t\t\t\tupdatePromptVisible();\n\t\t\t}\n\t\t});\n\n\t\tfade_out_delayed = AnimationUtils.loadAnimation(this, R.anim.fade_out_delayed);\n\n\t\t// Preload animation for keyboard button\n\t\tkeyboard_fade_in = AnimationUtils.loadAnimation(this, R.anim.keyboard_fade_in);\n\t\tkeyboard_fade_out = AnimationUtils.loadAnimation(this, R.anim.keyboard_fade_out);\n\n\t\tinputManager = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);\n\n\t\tkeyboardGroup = (LinearLayout) findViewById(R.id.keyboard_group);\n\n\t\tmKeyboardButton = (ImageView) findViewById(R.id.button_keyboard);\n\t\tmKeyboardButton.setOnClickListener(new OnClickListener() {\n\t\t\tpublic void onClick(View view) {\n\t\t\t\tView terminal = adapter.getCurrentTerminalView();\n\t\t\t\tif (terminal == null)\n\t\t\t\t\treturn;\n\n\t\t\t\tinputManager.showSoftInput(terminal, InputMethodManager.SHOW_FORCED);\n\t\t\t\thideEmulatedKeys();\n\t\t\t}\n\t\t});\n\n\t\tfindViewById(R.id.button_ctrl).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_esc).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_tab).setOnClickListener(emulatedKeysListener);\n\n\t\tnew KeyRepeater(keyRepeatHandler, findViewById(R.id.button_up));\n\t\tnew KeyRepeater(keyRepeatHandler, findViewById(R.id.button_down));\n\t\tnew KeyRepeater(keyRepeatHandler, findViewById(R.id.button_left));\n\t\tnew KeyRepeater(keyRepeatHandler, findViewById(R.id.button_right));\n\n\t\tfindViewById(R.id.button_home).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_end).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_pgup).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_pgdn).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f1).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f2).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f3).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f4).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f5).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f6).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f7).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f8).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f9).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f10).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f11).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f12).setOnClickListener(emulatedKeysListener);\n\n\n\t\tactionBar = getSupportActionBar();\n\t\tif (actionBar != null) {\n\t\t\tactionBar.setDisplayHomeAsUpEnabled(true);\n\t\t\tif (titleBarHide) {\n\t\t\t\tactionBar.hide();\n\t\t\t}\n\t\t\tactionBar.addOnMenuVisibilityListener(new ActionBar.OnMenuVisibilityListener() {\n\t\t\t\tpublic void onMenuVisibilityChanged(boolean isVisible) {\n\t\t\t\t\tinActionBarMenu = isVisible;\n\t\t\t\t\tif (isVisible == false) {\n\t\t\t\t\t\thideEmulatedKeys();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tfinal HorizontalScrollView keyboardScroll = (HorizontalScrollView) findViewById(R.id.keyboard_hscroll);\n\t\tif (!hardKeyboard) {\n\t\t\t// Show virtual keyboard and scroll back and forth\n\t\t\tshowEmulatedKeys(false);\n\t\t\tkeyboardScroll.postDelayed(new Runnable() {\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\tfinal int xscroll = findViewById(R.id.button_f12).getRight();\n\t\t\t\t\tif (BuildConfig.DEBUG) {\n\t\t\t\t\t\tLog.d(TAG, \"smoothScrollBy(toEnd[\" + xscroll + \"])\");\n\t\t\t\t\t}\n\t\t\t\t\tkeyboardScroll.smoothScrollBy(xscroll, 0);\n\t\t\t\t\tkeyboardScroll.postDelayed(new Runnable() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\tif (BuildConfig.DEBUG) {\n\t\t\t\t\t\t\t\tLog.d(TAG, \"smoothScrollBy(toStart[\" + (-xscroll) + \"])\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tkeyboardScroll.smoothScrollBy(-xscroll, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, 500);\n\t\t\t\t}\n\t\t\t}, 500);\n\t\t}\n\n\t\t// Reset keyboard auto-hide timer when scrolling\n\t\tkeyboardScroll.setOnTouchListener(\n\t\t\t\tnew OnTouchListener() {\n\t\t\t\t\tpublic boolean onTouch(View v, MotionEvent event) {\n\t\t\t\t\t\tswitch (event.getAction()) {\n\t\t\t\t\t\tcase MotionEvent.ACTION_MOVE:\n\t\t\t\t\t\t\tautoHideEmulatedKeys();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase MotionEvent.ACTION_UP:\n\t\t\t\t\t\t\tv.performClick();\n\t\t\t\t\t\t\treturn (true);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn (false);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\ttabs = (TabLayout) findViewById(R.id.tabs);\n\t\tif (tabs != null)\n\t\t\tsetupTabLayoutWithViewPager();\n\n\t\tif (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB) {\n\t\t\tpager.setOnTouchListener(new OnTouchListener() {\n\t\t\t\tpublic boolean onTouch(View v, MotionEvent event) {\n\t\t\t\t\tTerminalBridge bridge = adapter.getCurrentTerminalView().bridge;\n\n\t\t\t\t\tboolean isCopyingInProgress =\n\t\t\t\t\t\t(copySource != null && copySource.isSelectingForCopy());\n\n\t\t\t\t\tif (!isCopyingInProgress && keyboardGroup.getVisibility() == View.GONE) {\n\t\t\t\t\t\tshowEmulatedKeys(true);\n\t\t\t\t\t}\n\n\t\t\t\t\t// when copying, highlight the area\n\t\t\t\t\tif (isCopyingInProgress) {\n\t\t\t\t\t\tSelectionArea area = copySource.getSelectionArea();\n\t\t\t\t\t\tint row = (int) Math.floor(event.getY() / bridge.charHeight);\n\t\t\t\t\t\tint col = (int) Math.floor(event.getX() / bridge.charWidth);\n\n\t\t\t\t\t\tswitch (event.getAction()) {\n\t\t\t\t\t\tcase MotionEvent.ACTION_DOWN:\n\t\t\t\t\t\t\t// recording starting area\n\t\t\t\t\t\t\tif (area.isSelectingOrigin()) {\n\t\t\t\t\t\t\t\tarea.setRow(row);\n\t\t\t\t\t\t\t\tarea.setColumn(col);\n\t\t\t\t\t\t\t\tlastTouchRow = row;\n\t\t\t\t\t\t\t\tlastTouchCol = col;\n\t\t\t\t\t\t\t\tcopySource.redraw();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\tcase MotionEvent.ACTION_MOVE:\n\t\t\t\t\t\t\t/* ignore when user hasn't moved since last time so\n\t\t\t\t\t\t\t * we can fine-tune with directional pad\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif (row == lastTouchRow && col == lastTouchCol)\n\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t// if the user moves, start the selection for other corner\n\t\t\t\t\t\t\tarea.finishSelectingOrigin();\n\n\t\t\t\t\t\t\t// update selected area\n\t\t\t\t\t\t\tarea.setRow(row);\n\t\t\t\t\t\t\tarea.setColumn(col);\n\t\t\t\t\t\t\tlastTouchRow = row;\n\t\t\t\t\t\t\tlastTouchCol = col;\n\t\t\t\t\t\t\tcopySource.redraw();\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\tcase MotionEvent.ACTION_UP:\n\t\t\t\t\t\t\t/* If they didn't move their finger, maybe they meant to\n\t\t\t\t\t\t\t * select the rest of the text with the directional pad.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif (area.getLeft() == area.getRight() &&\n\t\t\t\t\t\t\t\t\tarea.getTop() == area.getBottom()) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// copy selected area to clipboard\n\t\t\t\t\t\t\tString copiedText = area.copyFrom(copySource.buffer);\n\n\t\t\t\t\t\t\tclipboard.setText(copiedText);\n\t\t\t\t\t\t\tToast.makeText(ConsoleActivity.this, getString(R.string.console_copy_done, copiedText.length()), Toast.LENGTH_LONG).show();\n\t\t\t\t\t\t\t// fall through to clear state\n\n\t\t\t\t\t\tcase MotionEvent.ACTION_CANCEL:\n\t\t\t\t\t\t\t// make sure we clear any highlighted area\n\t\t\t\t\t\t\tarea.reset();\n\t\t\t\t\t\t\tcopySource.setSelectingForCopy(false);\n\t\t\t\t\t\t\tcopySource.redraw();\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Ties the {@link TabLayout} to the {@link ViewPager}.\n\t *\n\t * <p>This method will:\n\t * <ul>\n\t *     <li>Add a {@link ViewPager.OnPageChangeListener} that will forward events to\n\t *     this TabLayout.<\/li>\n\t *     <li>Populate the TabLayout's tabs from the ViewPager's {@link PagerAdapter}.<\/li>\n\t *     <li>Set our {@link TabLayout.OnTabSelectedListener} which will forward\n\t *     selected events to the ViewPager<\/li>\n\t * <\/ul>\n\t * <\/p>\n\t */\n\tpublic void setupTabLayoutWithViewPager() {\n\t\ttabs.setTabsFromPagerAdapter(adapter);\n\t\tpager.addOnPageChangeListener(new TabLayout.TabLayoutOnPageChangeListener(tabs));\n\t\ttabs.setOnTabSelectedListener(new TabLayout.ViewPagerOnTabSelectedListener(pager));\n\n\t\tif (adapter.getCount() > 0) {\n\t\t\tfinal int curItem = pager.getCurrentItem();\n\t\t\tif (tabs.getSelectedTabPosition() != curItem) {\n\t\t\t\ttabs.getTabAt(curItem).select();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t *\n\t */\n\tprivate void configureOrientation() {\n\t\tString rotateDefault;\n\t\tif (getResources().getConfiguration().keyboard == Configuration.KEYBOARD_NOKEYS)\n\t\t\trotateDefault = PreferenceConstants.ROTATION_PORTRAIT;\n\t\telse\n\t\t\trotateDefault = PreferenceConstants.ROTATION_LANDSCAPE;\n\n\t\tString rotate = prefs.getString(PreferenceConstants.ROTATION, rotateDefault);\n\t\tif (PreferenceConstants.ROTATION_DEFAULT.equals(rotate))\n\t\t\trotate = rotateDefault;\n\n\t\t// request a forced orientation if requested by user\n\t\tif (PreferenceConstants.ROTATION_LANDSCAPE.equals(rotate)) {\n\t\t\tsetRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);\n\t\t\tforcedOrientation = true;\n\t\t} else if (PreferenceConstants.ROTATION_PORTRAIT.equals(rotate)) {\n\t\t\tsetRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);\n\t\t\tforcedOrientation = true;\n\t\t} else {\n\t\t\tsetRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);\n\t\t\tforcedOrientation = false;\n\t\t}\n\t}\n\n\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu) {\n\t\tsuper.onCreateOptionsMenu(menu);\n\n\t\tTerminalView view = adapter.getCurrentTerminalView();\n\t\tfinal boolean activeTerminal = view != null;\n\t\tboolean sessionOpen = false;\n\t\tboolean disconnected = false;\n\t\tboolean canForwardPorts = false;\n\n\t\tif (activeTerminal) {\n\t\t\tTerminalBridge bridge = view.bridge;\n\t\t\tsessionOpen = bridge.isSessionOpen();\n\t\t\tdisconnected = bridge.isDisconnected();\n\t\t\tcanForwardPorts = bridge.canFowardPorts();\n\t\t}\n\n\t\tmenu.setQwertyMode(true);\n\n\t\tdisconnect = menu.add(R.string.list_host_disconnect);\n\t\tif (hardKeyboard)\n\t\t\tdisconnect.setAlphabeticShortcut('w');\n\t\tif (!sessionOpen && disconnected)\n\t\t\tdisconnect.setTitle(R.string.console_menu_close);\n\t\tdisconnect.setEnabled(activeTerminal);\n\t\tdisconnect.setIcon(android.R.drawable.ic_menu_close_clear_cancel);\n\t\tdisconnect.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t// disconnect or close the currently visible session\n\t\t\t\tTerminalView terminalView = adapter.getCurrentTerminalView();\n\t\t\t\tTerminalBridge bridge = terminalView.bridge;\n\n\t\t\t\tbridge.dispatchDisconnect(true);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\tif (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB) {\n\t\t\tcopy = menu.add(R.string.console_menu_copy);\n\t\t\tif (hardKeyboard)\n\t\t\t\tcopy.setAlphabeticShortcut('c');\n\t\t\tMenuItemCompat.setShowAsAction(copy, MenuItemCompat.SHOW_AS_ACTION_IF_ROOM);\n\t\t\tcopy.setIcon(R.drawable.ic_action_copy);\n\t\t\tcopy.setEnabled(activeTerminal);\n\t\t\tcopy.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\tstartCopyMode();\n\t\t\t\t\tToast.makeText(ConsoleActivity.this, getString(R.string.console_copy_start), Toast.LENGTH_LONG).show();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tpaste = menu.add(R.string.console_menu_paste);\n\t\tif (hardKeyboard)\n\t\t\tpaste.setAlphabeticShortcut('v');\n\t\tMenuItemCompat.setShowAsAction(paste, MenuItemCompat.SHOW_AS_ACTION_IF_ROOM);\n\t\tpaste.setIcon(R.drawable.ic_action_paste);\n\t\tpaste.setEnabled(clipboard.hasText() && sessionOpen);\n\t\tpaste.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tpasteIntoTerminal();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\tportForward = menu.add(R.string.console_menu_portforwards);\n\t\tif (hardKeyboard)\n\t\t\tportForward.setAlphabeticShortcut('f');\n\t\tportForward.setIcon(android.R.drawable.ic_menu_manage);\n\t\tportForward.setEnabled(sessionOpen && canForwardPorts);\n\t\tportForward.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tTerminalView terminalView = adapter.getCurrentTerminalView();\n\t\t\t\tTerminalBridge bridge = terminalView.bridge;\n\n\t\t\t\tIntent intent = new Intent(ConsoleActivity.this, PortForwardListActivity.class);\n\t\t\t\tintent.putExtra(Intent.EXTRA_TITLE, bridge.host.getId());\n\t\t\t\tConsoleActivity.this.startActivityForResult(intent, REQUEST_EDIT);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\turlscan = menu.add(R.string.console_menu_urlscan);\n\t\tif (hardKeyboard)\n\t\t\turlscan.setAlphabeticShortcut('u');\n\t\turlscan.setIcon(android.R.drawable.ic_menu_search);\n\t\turlscan.setEnabled(activeTerminal);\n\t\turlscan.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tfinal TerminalView terminalView = adapter.getCurrentTerminalView();\n\n\t\t\t\tList<String> urls = terminalView.bridge.scanForURLs();\n\n\t\t\t\tDialog urlDialog = new Dialog(ConsoleActivity.this);\n\t\t\t\turlDialog.setTitle(R.string.console_menu_urlscan);\n\n\t\t\t\tListView urlListView = new ListView(ConsoleActivity.this);\n\t\t\t\tURLItemListener urlListener = new URLItemListener(ConsoleActivity.this);\n\t\t\t\turlListView.setOnItemClickListener(urlListener);\n\n\t\t\t\turlListView.setAdapter(new ArrayAdapter<String>(ConsoleActivity.this, android.R.layout.simple_list_item_1, urls));\n\t\t\t\turlDialog.setContentView(urlListView);\n\t\t\t\turlDialog.show();\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\tresize = menu.add(R.string.console_menu_resize);\n\t\tif (hardKeyboard)\n\t\t\tresize.setAlphabeticShortcut('s');\n\t\tresize.setIcon(android.R.drawable.ic_menu_crop);\n\t\tresize.setEnabled(sessionOpen);\n\t\tresize.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tfinal TerminalView terminalView = adapter.getCurrentTerminalView();\n\n\t\t\t\tfinal View resizeView = inflater.inflate(R.layout.dia_resize, null, false);\n\t\t\t\tnew AlertDialog.Builder(ConsoleActivity.this)\n\t\t\t\t\t\t.setView(resizeView)\n\t\t\t\t\t\t.setPositiveButton(R.string.button_resize, new DialogInterface.OnClickListener() {\n\t\t\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\t\t\t\tint width, height;\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\twidth = Integer.parseInt(((EditText) resizeView\n\t\t\t\t\t\t\t\t\t\t\t.findViewById(R.id.width))\n\t\t\t\t\t\t\t\t\t\t\t.getText().toString());\n\t\t\t\t\t\t\t\t\theight = Integer.parseInt(((EditText) resizeView\n\t\t\t\t\t\t\t\t\t\t\t.findViewById(R.id.height))\n\t\t\t\t\t\t\t\t\t\t\t.getText().toString());\n\t\t\t\t\t\t\t\t} catch (NumberFormatException nfe) {\n\t\t\t\t\t\t\t\t\t// TODO change this to a real dialog where we can\n\t\t\t\t\t\t\t\t\t// make the input boxes turn red to indicate an error.\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tterminalView.forceSize(width, height);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}).setNegativeButton(android.R.string.cancel, null).create().show();\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean onPrepareOptionsMenu(Menu menu) {\n\t\tsuper.onPrepareOptionsMenu(menu);\n\n\t\tsetVolumeControlStream(AudioManager.STREAM_NOTIFICATION);\n\n\t\tfinal TerminalView view = adapter.getCurrentTerminalView();\n\t\tboolean activeTerminal = view != null;\n\t\tboolean sessionOpen = false;\n\t\tboolean disconnected = false;\n\t\tboolean canForwardPorts = false;\n\n\t\tif (activeTerminal) {\n\t\t\tTerminalBridge bridge = view.bridge;\n\t\t\tsessionOpen = bridge.isSessionOpen();\n\t\t\tdisconnected = bridge.isDisconnected();\n\t\t\tcanForwardPorts = bridge.canFowardPorts();\n\t\t}\n\n\t\tdisconnect.setEnabled(activeTerminal);\n\t\tif (sessionOpen || !disconnected)\n\t\t\tdisconnect.setTitle(R.string.list_host_disconnect);\n\t\telse\n\t\t\tdisconnect.setTitle(R.string.console_menu_close);\n\n\t\tif (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB) {\n\t\t\tcopy.setEnabled(activeTerminal);\n\t\t}\n\t\tpaste.setEnabled(clipboard.hasText() && sessionOpen);\n\t\tportForward.setEnabled(sessionOpen && canForwardPorts);\n\t\turlscan.setEnabled(activeTerminal);\n\t\tresize.setEnabled(sessionOpen);\n\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tswitch (item.getItemId()) {\n\t\tcase android.R.id.home:\n\t\t\tIntent intent = new Intent(this, HostListActivity.class);\n\t\t\tintent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n\t\t\tstartActivity(intent);\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn super.onOptionsItemSelected(item);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void onOptionsMenuClosed(Menu menu) {\n\t\tsuper.onOptionsMenuClosed(menu);\n\n\t\tsetVolumeControlStream(AudioManager.STREAM_MUSIC);\n\t}\n\n\t@Override\n\tpublic void onStart() {\n\t\tsuper.onStart();\n\n\t\t// connect with manager service to find all bridges\n\t\t// when connected it will insert all views\n\t\tbindService(new Intent(this, TerminalManager.class), connection, Context.BIND_AUTO_CREATE);\n\t}\n\n\t@Override\n\tpublic void onPause() {\n\t\tsuper.onPause();\n\t\tLog.d(TAG, \"onPause called\");\n\n\t\tif (forcedOrientation && bound != null) {\n\t\t\tbound.setResizeAllowed(false);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void onResume() {\n\t\tsuper.onResume();\n\t\tLog.d(TAG, \"onResume called\");\n\n\t\t// Make sure we don't let the screen fall asleep.\n\t\t// This also keeps the Wi-Fi chipset from disconnecting us.\n\t\tif (prefs.getBoolean(PreferenceConstants.KEEP_ALIVE, true)) {\n\t\t\tgetWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);\n\t\t} else {\n\t\t\tgetWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);\n\t\t}\n\n\t\tconfigureOrientation();\n\n\t\tif (forcedOrientation && bound != null) {\n\t\t\tbound.setResizeAllowed(true);\n\t\t}\n\t}\n\n\t/* (non-Javadoc)\n\t * @see android.app.Activity#onNewIntent(android.content.Intent)\n\t */\n\t@Override\n\tprotected void onNewIntent(Intent intent) {\n\t\tsuper.onNewIntent(intent);\n\n\t\tLog.d(TAG, \"onNewIntent called\");\n\n\t\trequested = intent.getData();\n\n\t\tif (requested == null) {\n\t\t\tLog.e(TAG, \"Got null intent data in onNewIntent()\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (bound == null) {\n\t\t\tLog.e(TAG, \"We're not bound in onNewIntent()\");\n\t\t\treturn;\n\t\t}\n\n\t\tTerminalBridge requestedBridge = bound.getConnectedBridge(requested.getFragment());\n\t\tint requestedIndex = 0;\n\n\t\tsynchronized (pager) {\n\t\t\tif (requestedBridge == null) {\n\t\t\t\t// If we didn't find the requested connection, try opening it\n\n\t\t\t\ttry {\n\t\t\t\t\tLog.d(TAG, String.format(\"We couldnt find an existing bridge with URI=%s (nickname=%s),\" +\n\t\t\t\t\t\t\t\"so creating one now\", requested.toString(), requested.getFragment()));\n\t\t\t\t\trequestedBridge = bound.openConnection(requested);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tLog.e(TAG, \"Problem while trying to create new requested bridge from URI\", e);\n\t\t\t\t\t// TODO: We should display an error dialog here.\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tadapter.notifyDataSetChanged();\n\t\t\t\trequestedIndex = adapter.getCount();\n\t\t\t} else {\n\t\t\t\tfinal int flipIndex = bound.getBridges().indexOf(requestedBridge);\n\t\t\t\tif (flipIndex > requestedIndex) {\n\t\t\t\t\trequestedIndex = flipIndex;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsetDisplayedTerminal(requestedIndex);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void onStop() {\n\t\tsuper.onStop();\n\n\t\tunbindService(connection);\n\t}\n\n\t@Override\n\tpublic void onSaveInstanceState(Bundle savedInstanceState) {\n\t\t// Maintain selected host if connected.\n\t\tif (adapter.getCurrentTerminalView() != null\n\t\t\t\t&& !adapter.getCurrentTerminalView().bridge.isDisconnected()) {\n\t\t\tUri uri = adapter.getCurrentTerminalView().bridge.host.getUri();\n\t\t\tsavedInstanceState.putString(STATE_SELECTED_URI, uri.toString());\n\t\t}\n\n\t\tsuper.onSaveInstanceState(savedInstanceState);\n\t}\n\n\t/**\n\t * Only intended for pre-Honeycomb devices.\n\t */\n\tprivate void startCopyMode() {\n\t\t// mark as copying and reset any previous bounds\n\t\tTerminalView terminalView = (TerminalView) adapter.getCurrentTerminalView();\n\t\tcopySource = terminalView.bridge;\n\n\t\tSelectionArea area = copySource.getSelectionArea();\n\t\tarea.reset();\n\t\tarea.setBounds(copySource.buffer.getColumns(), copySource.buffer.getRows());\n\n\t\tcopySource.setSelectingForCopy(true);\n\n\t\t// Make sure we show the initial selection\n\t\tcopySource.redraw();\n\t}\n\n\t/**\n\t * Save the currently shown {@link TerminalView} as the default. This is\n\t * saved back down into {@link TerminalManager} where we can read it again\n\t * later.\n\t */\n\tprivate void updateDefault() {\n\t\t// update the current default terminal\n\t\tTerminalView view = adapter.getCurrentTerminalView();\n\t\tif (view == null || bound == null) {\n\t\t\treturn;\n\t\t}\n\t\tbound.defaultBridge = view.bridge;\n\t}\n\n\tprotected void updateEmptyVisible() {\n\t\t// update visibility of empty status message\n\t\tempty.setVisibility((pager.getChildCount() == 0) ? View.VISIBLE : View.GONE);\n\t}\n\n\t/**\n\t * Show any prompts requested by the currently visible {@link TerminalView}.\n\t */\n\tprotected void updatePromptVisible() {\n\t\t// check if our currently-visible terminalbridge is requesting any prompt services\n\t\tTerminalView view = adapter.getCurrentTerminalView();\n\n\t\t// Hide all the prompts in case a prompt request was canceled\n\t\thideAllPrompts();\n\n\t\tif (view == null) {\n\t\t\t// we dont have an active view, so hide any prompts\n\t\t\treturn;\n\t\t}\n\n\t\tPromptHelper prompt = view.bridge.promptHelper;\n\t\tif (String.class.equals(prompt.promptRequested)) {\n\t\t\tstringPromptGroup.setVisibility(View.VISIBLE);\n\n\t\t\tString instructions = prompt.promptInstructions;\n\t\t\tif (instructions != null && instructions.length() > 0) {\n\t\t\t\tstringPromptInstructions.setVisibility(View.VISIBLE);\n\t\t\t\tstringPromptInstructions.setText(instructions);\n\t\t\t} else\n\t\t\t\tstringPromptInstructions.setVisibility(View.GONE);\n\t\t\tstringPrompt.setText(\"\");\n\t\t\tstringPrompt.setHint(prompt.promptHint);\n\t\t\tstringPrompt.requestFocus();\n\n\t\t} else if (Boolean.class.equals(prompt.promptRequested)) {\n\t\t\tbooleanPromptGroup.setVisibility(View.VISIBLE);\n\t\t\tbooleanPrompt.setText(prompt.promptHint);\n\t\t\tbooleanYes.requestFocus();\n\n\t\t} else {\n\t\t\thideAllPrompts();\n\t\t\tview.requestFocus();\n\t\t}\n\t}\n\n\tprivate class URLItemListener implements OnItemClickListener {\n\t\tprivate WeakReference<Context> contextRef;\n\n\t\tURLItemListener(Context context) {\n\t\t\tthis.contextRef = new WeakReference<Context>(context);\n\t\t}\n\n\t\tpublic void onItemClick(AdapterView<?> arg0, View view, int position, long id) {\n\t\t\tContext context = contextRef.get();\n\n\t\t\tif (context == null)\n\t\t\t\treturn;\n\n\t\t\ttry {\n\t\t\t\tTextView urlView = (TextView) view;\n\n\t\t\t\tString url = urlView.getText().toString();\n\t\t\t\tif (url.indexOf(\"://\") < 0)\n\t\t\t\t\turl = \"http://\" + url;\n\n\t\t\t\tIntent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));\n\t\t\t\tcontext.startActivity(intent);\n\t\t\t} catch (Exception e) {\n\t\t\t\tLog.e(TAG, \"couldn't open URL\", e);\n\t\t\t\t// We should probably tell the user that we couldn't find a handler...\n\t\t\t}\n\t\t}\n\n\t}\n\n\t@Override\n\tpublic void onConfigurationChanged(Configuration newConfig) {\n\t\tsuper.onConfigurationChanged(newConfig);\n\n\t\tLog.d(TAG, String.format(\"onConfigurationChanged; requestedOrientation=%d, newConfig.orientation=%d\", getRequestedOrientation(), newConfig.orientation));\n\t\tif (bound != null) {\n\t\t\tif (forcedOrientation &&\n\t\t\t\t\t(newConfig.orientation != Configuration.ORIENTATION_LANDSCAPE &&\n\t\t\t\t\t\t\tgetRequestedOrientation() == ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE) ||\n\t\t\t\t\t(newConfig.orientation != Configuration.ORIENTATION_PORTRAIT &&\n\t\t\t\t\t\t\tgetRequestedOrientation() == ActivityInfo.SCREEN_ORIENTATION_PORTRAIT))\n\t\t\t\tbound.setResizeAllowed(false);\n\t\t\telse\n\t\t\t\tbound.setResizeAllowed(true);\n\n\t\t\tbound.hardKeyboardHidden = (newConfig.hardKeyboardHidden == Configuration.HARDKEYBOARDHIDDEN_YES);\n\n\t\t\tmKeyboardButton.setVisibility(bound.hardKeyboardHidden ? View.VISIBLE : View.GONE);\n\t\t}\n\t}\n\n\t/**\n\t * Called whenever the displayed terminal is changed.\n\t */\n\tprivate void onTerminalChanged() {\n\t\tView overlay = findCurrentView(R.id.terminal_overlay);\n\t\tif (overlay != null)\n\t\t\toverlay.startAnimation(fade_out_delayed);\n\t\tupdateDefault();\n\t\tupdatePromptVisible();\n\t\tActivityCompat.invalidateOptionsMenu(ConsoleActivity.this);\n\t}\n\n\t/**\n\t * Displays the child in the ViewPager at the requestedIndex and updates the prompts.\n\t *\n\t * @param requestedIndex the index of the terminal view to display\n\t */\n\tprivate void setDisplayedTerminal(int requestedIndex) {\n\t\tpager.setCurrentItem(requestedIndex);\n\t\t// set activity title\n\t\tsetTitle(adapter.getPageTitle(requestedIndex));\n\t\tonTerminalChanged();\n\t}\n\n\tprivate void pasteIntoTerminal() {\n\t\t// force insert of clipboard text into current console\n\t\tTerminalView terminalView = adapter.getCurrentTerminalView();\n\t\tTerminalBridge bridge = terminalView.bridge;\n\n\t\t// pull string from clipboard and generate all events to force down\n\t\tString clip = clipboard.getText().toString();\n\t\tbridge.injectString(clip);\n\t}\n\n\tpublic class TerminalPagerAdapter extends PagerAdapter {\n\t\t@Override\n\t\tpublic int getCount() {\n\t\t\tif (bound != null) {\n\t\t\t\treturn bound.getBridges().size();\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Object instantiateItem(ViewGroup container, int position) {\n\t\t\tif (bound == null || bound.getBridges().size() <= position) {\n\t\t\t\tLog.w(TAG, \"Activity not bound when creating TerminalView.\");\n\t\t\t}\n\t\t\tTerminalBridge bridge = bound.getBridges().get(position);\n\t\t\tbridge.promptHelper.setHandler(promptHandler);\n\n\t\t\t// inflate each terminal view\n\t\t\tRelativeLayout view = (RelativeLayout) inflater.inflate(\n\t\t\t\t\tR.layout.item_terminal, container, false);\n\n\t\t\t// set the terminal overlay text\n\t\t\tTextView overlay = (TextView) view.findViewById(R.id.terminal_overlay);\n\t\t\toverlay.setText(bridge.host.getNickname());\n\n\t\t\t// and add our terminal view control, using index to place behind overlay\n\t\t\tfinal TerminalView terminal = new TerminalView(container.getContext(), bridge, pager);\n\t\t\tterminal.setId(R.id.terminal_view);\n\t\t\tview.addView(terminal, 0);\n\n\t\t\t// Tag the view with its bridge so it can be retrieved later.\n\t\t\tview.setTag(bridge);\n\n\t\t\tcontainer.addView(view);\n\t\t\toverlay.startAnimation(fade_out_delayed);\n\t\t\treturn view;\n\t\t}\n\n\t\t@Override\n\t\tpublic void destroyItem(ViewGroup container, int position, Object object) {\n\t\t\tfinal View view = (View) object;\n\n\t\t\tcontainer.removeView(view);\n\t\t}\n\n\t\t@Override\n\t\tpublic int getItemPosition(Object object) {\n\t\t\tif (bound == null) {\n\t\t\t\treturn POSITION_NONE;\n\t\t\t}\n\n\t\t\tView view = (View) object;\n\t\t\tTerminalView terminal = (TerminalView) view.findViewById(R.id.terminal_view);\n\t\t\tHostBean host = terminal.bridge.host;\n\n\t\t\tint itemIndex = POSITION_NONE;\n\t\t\tint i = 0;\n\t\t\tfor (TerminalBridge bridge : bound.getBridges()) {\n\t\t\t\tif (bridge.host.equals(host)) {\n\t\t\t\t\titemIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t\treturn itemIndex;\n\t\t}\n\n\t\tpublic TerminalBridge getBridgeAtPosition(int position) {\n\t\t\tif (bound == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tArrayList<TerminalBridge> bridges = bound.getBridges();\n\t\t\tif (position < 0 || position >= bridges.size()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn bridges.get(position);\n\t\t}\n\n\t\t@Override\n\t\tpublic void notifyDataSetChanged() {\n\t\t\tsuper.notifyDataSetChanged();\n\t\t\tif (tabs != null) {\n\t\t\t\ttoolbar.setVisibility(this.getCount() > 1 ? View.VISIBLE : View.GONE);\n\t\t\t\ttabs.setTabsFromPagerAdapter(this);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isViewFromObject(View view, Object object) {\n\t\t\treturn view == object;\n\t\t}\n\n\t\t@Override\n\t\tpublic CharSequence getPageTitle(int position) {\n\t\t\tTerminalBridge bridge = getBridgeAtPosition(position);\n\t\t\tif (bridge == null) {\n\t\t\t\treturn \"???\";\n\t\t\t}\n\t\t\treturn bridge.host.getNickname();\n\t\t}\n\n\t\tpublic TerminalView getCurrentTerminalView() {\n\t\t\tView currentView = pager.findViewWithTag(getBridgeAtPosition(pager.getCurrentItem()));\n\t\t\tif (currentView == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn (TerminalView) currentView.findViewById(R.id.terminal_view);\n\t\t}\n\t}\n}\n","lineNo":670}
{"Smelly Sample":"/*\n * ConnectBot: simple, powerful, open-source SSH client for Android\n * Copyright 2007 Kenny Root, Jeffrey Sharkey\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.connectbot;\n\nimport java.lang.ref.WeakReference;\nimport java.util.List;\n\nimport org.connectbot.bean.HostBean;\nimport org.connectbot.bean.PortForwardBean;\nimport org.connectbot.service.TerminalBridge;\nimport org.connectbot.service.TerminalManager;\nimport org.connectbot.util.HostDatabase;\n\nimport android.app.AlertDialog;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.ServiceConnection;\nimport android.content.res.Resources;\nimport android.database.SQLException;\nimport android.graphics.Paint;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Message;\nimport android.support.annotation.VisibleForTesting;\nimport android.support.design.widget.FloatingActionButton;\nimport android.support.v7.widget.LinearLayoutManager;\nimport android.support.v7.widget.RecyclerView;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.LayoutInflater;\nimport android.view.MenuItem;\nimport android.view.MenuItem.OnMenuItemClickListener;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.AdapterView;\nimport android.widget.AdapterView.OnItemSelectedListener;\nimport android.widget.EditText;\nimport android.widget.Spinner;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\n/**\n * List all portForwards for a particular host and provide a way for users to add more portForwards,\n * edit existing portForwards, and delete portForwards.\n *\n * @author Kenny Root\n */\npublic class PortForwardListActivity extends AppCompatListActivity {\n\tpublic final static String TAG = \"CB.PortForwardListAct\";\n\n\tprivate static final int LISTENER_CYCLE_TIME = 500;\n\n\tprotected HostDatabase hostdb;\n\n\tprivate List<PortForwardBean> portForwards;\n\n\tprivate ServiceConnection connection = null;\n\tprotected TerminalBridge hostBridge = null;\n\tprotected LayoutInflater inflater = null;\n\n\n\tprotected Handler updateHandler = new Handler(new WeakReference<>(this));\n\n\tprivate HostBean host;\n\n\t@Override\n\tpublic void onStart() {\n\t\tsuper.onStart();\n\n\t\tthis.bindService(new Intent(this, TerminalManager.class), connection, Context.BIND_AUTO_CREATE);\n\n\t\thostdb = HostDatabase.get(this);\n\t}\n\n\t@Override\n\tpublic void onStop() {\n\t\tsuper.onStop();\n\n\t\tthis.unbindService(connection);\n\n\t\thostdb = null;\n\t}\n\n\t@Override\n\tpublic void onCreate(Bundle icicle) {\n\t\tsuper.onCreate(icicle);\n\n\t\tlong hostId = this.getIntent().getLongExtra(Intent.EXTRA_TITLE, -1);\n\n\t\tsetContentView(R.layout.act_portforwardlist);\n\n\t\tmListView = (RecyclerView) findViewById(R.id.list);\n\t\tmListView.setHasFixedSize(true);\n\t\tmListView.setLayoutManager(new LinearLayoutManager(this));\n\t\tmListView.addItemDecoration(new ListItemDecoration(this));\n\n\t\tmEmptyView = findViewById(R.id.empty);\n\n\t\t// connect with hosts database and populate list\n\t\tthis.hostdb = HostDatabase.get(this);\n\t\thost = hostdb.findHostById(hostId);\n\n\t\t{\n\t\t\tfinal String nickname = host != null ? host.getNickname() : null;\n\t\t\tfinal Resources resources = getResources();\n\n\t\t\tif (nickname != null) {\n\t\t\t\tthis.setTitle(String.format(\"%s (%s)\",\n\t\t\t\t\t\tresources.getText(R.string.title_port_forwards_list),\n\t\t\t\t\t\tnickname));\n\t\t\t}\n\t\t}\n\n\t\tconnection = new ServiceConnection() {\n\t\t\tpublic void onServiceConnected(ComponentName className, IBinder service) {\n\t\t\t\tTerminalManager bound = ((TerminalManager.TerminalBinder) service).getService();\n\n\t\t\t\thostBridge = bound.getConnectedBridge(host);\n\t\t\t\tupdateHandler.sendEmptyMessage(-1);\n\t\t\t}\n\n\t\t\tpublic void onServiceDisconnected(ComponentName name) {\n\t\t\t\thostBridge = null;\n\t\t\t}\n\t\t};\n\n\t\tthis.updateList();\n\n\t\tthis.registerForContextMenu(mListView);\n\n\t\tthis.inflater = LayoutInflater.from(this);\n\n\t\tFloatingActionButton addPortForwardButton =\n\t\t\t\t(FloatingActionButton) findViewById(R.id.add_port_forward_button);\n\t\taddPortForwardButton.setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\t// build dialog to prompt user about updating\n\t\t\t\tfinal View portForwardView = View.inflate(PortForwardListActivity.this, R.layout.dia_portforward, null);\n\t\t\t\tfinal EditText destEdit = (EditText) portForwardView.findViewById(R.id.portforward_destination);\n\t\t\t\tfinal Spinner typeSpinner = (Spinner) portForwardView.findViewById(R.id.portforward_type);\n\n\t\t\t\ttypeSpinner.setOnItemSelectedListener(new OnItemSelectedListener() {\n\t\t\t\t\tpublic void onItemSelected(AdapterView<?> value, View view,\n\t\t\t\t\t\t\tint position, long id) {\n\t\t\t\t\t\tdestEdit.setEnabled(position != 2);\n\t\t\t\t\t}\n\t\t\t\t\tpublic void onNothingSelected(AdapterView<?> arg0) {\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tnew AlertDialog.Builder(PortForwardListActivity.this)\n\t\t\t\t\t\t.setView(portForwardView)\n\t\t\t\t\t\t.setPositiveButton(R.string.portforward_pos, new DialogInterface.OnClickListener() {\n\t\t\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tfinal EditText nicknameEdit = (EditText) portForwardView.findViewById(R.id.nickname);\n\t\t\t\t\t\t\t\t\tfinal EditText sourcePortEdit = (EditText) portForwardView.findViewById(R.id.portforward_source);\n\n\t\t\t\t\t\t\t\t\tString type = HostDatabase.PORTFORWARD_LOCAL;\n\t\t\t\t\t\t\t\t\tswitch (typeSpinner.getSelectedItemPosition()) {\n\t\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\t\ttype = HostDatabase.PORTFORWARD_LOCAL;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\t\ttype = HostDatabase.PORTFORWARD_REMOTE;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\t\ttype = HostDatabase.PORTFORWARD_DYNAMIC5;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tPortForwardBean portForward = new PortForwardBean(\n\t\t\t\t\t\t\t\t\t\t\thost != null ? host.getId() : -1,\n\t\t\t\t\t\t\t\t\t\t\tnicknameEdit.getText().toString(), type,\n\t\t\t\t\t\t\t\t\t\t\tsourcePortEdit.getText().toString(),\n\t\t\t\t\t\t\t\t\t\t\tdestEdit.getText().toString());\n\n\t\t\t\t\t\t\t\t\tif (hostBridge != null) {\n\t\t\t\t\t\t\t\t\t\thostBridge.addPortForward(portForward);\n\t\t\t\t\t\t\t\t\t\thostBridge.enablePortForward(portForward);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (host != null && !hostdb.savePortForward(portForward)) {\n\t\t\t\t\t\t\t\t\t\tthrow new SQLException(\"Could not save port forward\");\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tupdateHandler.sendEmptyMessage(-1);\n\t\t\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\t\t\tLog.e(TAG, \"Could not update port forward\", e);\n\t\t\t\t\t\t\t\t\t// TODO Show failure dialog.\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.setNegativeButton(R.string.delete_neg, null).create().show();\n\t\t\t}\n\n\t\t\tpublic void onNothingSelected(AdapterView<?> arg0) {}\n\t\t});\n\t}\n\n\tprotected void updateList() {\n\t\tif (hostBridge != null) {\n\t\t\tthis.portForwards = hostBridge.getPortForwards();\n\t\t} else {\n\t\t\tif (this.hostdb == null) return;\n\t\t\tthis.portForwards = this.hostdb.getPortForwardsForHost(host);\n\t\t}\n\n\t\tmAdapter = new PortForwardAdapter(this, portForwards);\n\t\tmListView.setAdapter(mAdapter);\n\t\tadjustViewVisibility();\n\t}\n\n\tprivate class PortForwardViewHolder extends ItemViewHolder {\n\t\tpublic final TextView nickname;\n\t\tpublic final TextView caption;\n\n\t\tpublic PortForwardBean portForward;\n\n\t\tpublic PortForwardViewHolder(View v) {\n\t\t\tsuper(v);\n\n\t\t\tnickname = (TextView) v.findViewById(android.R.id.text1);\n\t\t\tcaption = (TextView) v.findViewById(android.R.id.text2);\n\t\t}\n\n\t\t@Override\n\t\tpublic void onClick(View v) {\n\t\t\tif (hostBridge != null) {\n\t\t\t\tif (portForward.isEnabled())\n\t\t\t\t\thostBridge.disablePortForward(portForward);\n\t\t\t\telse {\n\t\t\t\t\tif (!hostBridge.enablePortForward(portForward))\n\t\t\t\t\t\tToast.makeText(PortForwardListActivity.this, getString(R.string.portforward_problem), Toast.LENGTH_LONG).show();\n\t\t\t\t}\n\n\t\t\t\tupdateHandler.sendEmptyMessage(-1);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void onCreateContextMenu(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo) {\n\t\t\t// Create menu to handle deleting and editing port forward\n\t\t\tAdapterView.AdapterContextMenuInfo info = (AdapterView.AdapterContextMenuInfo) menuInfo;\n\n\t\t\tmenu.setHeaderTitle(portForward.getNickname());\n\n\t\t\tMenuItem edit = menu.add(R.string.portforward_edit);\n\t\t\tedit.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\tfinal View editTunnelView = View.inflate(PortForwardListActivity.this, R.layout.dia_portforward, null);\n\n\t\t\t\t\tfinal Spinner typeSpinner = (Spinner) editTunnelView.findViewById(R.id.portforward_type);\n\t\t\t\t\tif (HostDatabase.PORTFORWARD_LOCAL.equals(portForward.getType()))\n\t\t\t\t\t\ttypeSpinner.setSelection(0);\n\t\t\t\t\telse if (HostDatabase.PORTFORWARD_REMOTE.equals(portForward.getType()))\n\t\t\t\t\t\ttypeSpinner.setSelection(1);\n\t\t\t\t\telse\n\t\t\t\t\t\ttypeSpinner.setSelection(2);\n\n\t\t\t\t\tfinal EditText nicknameEdit = (EditText) editTunnelView.findViewById(R.id.nickname);\n\t\t\t\t\tnicknameEdit.setText(portForward.getNickname());\n\n\t\t\t\t\tfinal EditText sourcePortEdit = (EditText) editTunnelView.findViewById(R.id.portforward_source);\n\t\t\t\t\tsourcePortEdit.setText(String.valueOf(portForward.getSourcePort()));\n\n\t\t\t\t\tfinal EditText destEdit = (EditText) editTunnelView.findViewById(R.id.portforward_destination);\n\t\t\t\t\tif (HostDatabase.PORTFORWARD_DYNAMIC5.equals(portForward.getType())) {\n\t\t\t\t\t\tdestEdit.setEnabled(false);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdestEdit.setText(String.format(\"%s:%d\", portForward.getDestAddr(), portForward.getDestPort()));\n\t\t\t\t\t}\n\n\t\t\t\t\ttypeSpinner.setOnItemSelectedListener(new OnItemSelectedListener() {\n\t\t\t\t\t\tpublic void onItemSelected(AdapterView<?> value, View view,\n\t\t\t\t\t\t\t\tint position, long id) {\n\t\t\t\t\t\t\tdestEdit.setEnabled(position != 2);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpublic void onNothingSelected(AdapterView<?> arg0) {\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tnew AlertDialog.Builder(PortForwardListActivity.this)\n\t\t\t\t\t\t\t.setView(editTunnelView)\n\t\t\t\t\t\t\t.setPositiveButton(R.string.button_change, new DialogInterface.OnClickListener() {\n\t\t\t\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tif (hostBridge != null)\n\t\t\t\t\t\t\t\t\t\t\thostBridge.disablePortForward(portForward);\n\n\t\t\t\t\t\t\t\t\t\tportForward.setNickname(nicknameEdit.getText().toString());\n\n\t\t\t\t\t\t\t\t\t\tswitch (typeSpinner.getSelectedItemPosition()) {\n\t\t\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\t\t\tportForward.setType(HostDatabase.PORTFORWARD_LOCAL);\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\t\t\tportForward.setType(HostDatabase.PORTFORWARD_REMOTE);\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\t\t\tportForward.setType(HostDatabase.PORTFORWARD_DYNAMIC5);\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tportForward.setSourcePort(Integer.parseInt(sourcePortEdit.getText().toString()));\n\t\t\t\t\t\t\t\t\t\tportForward.setDest(destEdit.getText().toString());\n\n\t\t\t\t\t\t\t\t\t\t// Use the new settings for the existing connection.\n\t\t\t\t\t\t\t\t\t\tif (hostBridge != null)\n\t\t\t\t\t\t\t\t\t\t\tupdateHandler.postDelayed(new Runnable() {\n\t\t\t\t\t\t\t\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\t\t\t\t\t\t\thostBridge.enablePortForward(portForward);\n\t\t\t\t\t\t\t\t\t\t\t\t\tupdateHandler.sendEmptyMessage(-1);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}, LISTENER_CYCLE_TIME);\n\n\n\t\t\t\t\t\t\t\t\t\tif (!hostdb.savePortForward(portForward)) {\n\t\t\t\t\t\t\t\t\t\t\tthrow new SQLException(\"Could not save port forward\");\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tupdateHandler.sendEmptyMessage(-1);\n\t\t\t\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\t\t\t\tLog.e(TAG, \"Could not update port forward\", e);\n\t\t\t\t\t\t\t\t\t\t// TODO Show failure dialog.\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t.setNegativeButton(android.R.string.cancel, null).create().show();\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tMenuItem delete = menu.add(R.string.portforward_delete);\n\t\t\tdelete.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\t// prompt user to make sure they really want this\n\t\t\t\t\tnew AlertDialog.Builder(PortForwardListActivity.this)\n\t\t\t\t\t\t\t.setMessage(getString(R.string.delete_message, portForward.getNickname()))\n\t\t\t\t\t\t\t.setPositiveButton(R.string.delete_pos, new DialogInterface.OnClickListener() {\n\t\t\t\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t// Delete the port forward from the host if needed.\n\t\t\t\t\t\t\t\t\t\tif (hostBridge != null)\n\t\t\t\t\t\t\t\t\t\t\thostBridge.removePortForward(portForward);\n\n\t\t\t\t\t\t\t\t\t\thostdb.deletePortForward(portForward);\n\t\t\t\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\t\t\t\tLog.e(TAG, \"Could not delete port forward\", e);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tupdateHandler.sendEmptyMessage(-1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t.setNegativeButton(R.string.delete_neg, null).create().show();\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t@VisibleForTesting\n\tprivate class PortForwardAdapter extends ItemAdapter {\n\t\tprivate final List<PortForwardBean> portForwards;\n\n\t\tpublic PortForwardAdapter(Context context, List<PortForwardBean> portForwards) {\n\t\t\tsuper(context);\n\t\t\tthis.portForwards = portForwards;\n\t\t}\n\n\t\t@Override\n\t\tpublic PortForwardViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n\t\t\tView v = LayoutInflater.from(parent.getContext())\n\t\t\t\t\t.inflate(R.layout.item_portforward, parent, false);\n\t\t\tPortForwardViewHolder vh = new PortForwardViewHolder(v);\n\t\t\treturn vh;\n\t\t}\n\n\t\t@Override\n\t\tpublic void onBindViewHolder(ItemViewHolder holder, int position) {\n\t\t\tPortForwardViewHolder portForwardHolder = (PortForwardViewHolder) holder;\n\t\t\tPortForwardBean portForward = portForwards.get(position);\n\n\t\t\tportForwardHolder.portForward = portForward;\n\t\t\tportForwardHolder.nickname.setText(portForward.getNickname());\n\t\t\tportForwardHolder.caption.setText(portForward.getDescription());\n\n\t\t\tif (hostBridge != null && !portForward.isEnabled()) {\n\t\t\t\tportForwardHolder.nickname.setPaintFlags(portForwardHolder.nickname.getPaintFlags() | Paint.STRIKE_THRU_TEXT_FLAG);\n\t\t\t\tportForwardHolder.caption.setPaintFlags(portForwardHolder.caption.getPaintFlags() | Paint.STRIKE_THRU_TEXT_FLAG);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic long getItemId(int position) {\n\t\t\treturn portForwards.get(position).getId();\n\t\t}\n\n\t\t@Override\n\t\tpublic int getItemCount() {\n\t\t\treturn portForwards.size();\n\t\t}\n\t}\n\n\tprivate static class Handler extends android.os.Handler {\n\n\t\tprivate WeakReference<PortForwardListActivity> mActivity;\n\n\t\tHandler(WeakReference<PortForwardListActivity> activity) {\n\t\t\tmActivity = activity;\n\t\t}\n\n\t\t@Override\n\t\tpublic void handleMessage(Message msg) {\n\t\t\tmActivity.get().updateList();\n\t\t}\n\t}\n}\n","Method after Refactoring":"/*\n * ConnectBot: simple, powerful, open-source SSH client for Android\n * Copyright 2007 Kenny Root, Jeffrey Sharkey\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.connectbot;\n\nimport java.lang.ref.WeakReference;\nimport java.util.List;\n\nimport org.connectbot.bean.HostBean;\nimport org.connectbot.bean.PortForwardBean;\nimport org.connectbot.service.TerminalBridge;\nimport org.connectbot.service.TerminalManager;\nimport org.connectbot.util.HostDatabase;\n\nimport android.app.AlertDialog;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.ServiceConnection;\nimport android.content.res.Resources;\nimport android.database.SQLException;\nimport android.graphics.Paint;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Message;\nimport android.support.annotation.VisibleForTesting;\nimport android.support.design.widget.FloatingActionButton;\nimport android.support.v7.widget.LinearLayoutManager;\nimport android.support.v7.widget.RecyclerView;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.LayoutInflater;\nimport android.view.MenuItem;\nimport android.view.MenuItem.OnMenuItemClickListener;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.AdapterView;\nimport android.widget.AdapterView.OnItemSelectedListener;\nimport android.widget.EditText;\nimport android.widget.Spinner;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\n/**\n * List all portForwards for a particular host and provide a way for users to add more portForwards,\n * edit existing portForwards, and delete portForwards.\n *\n * @author Kenny Root\n */\npublic class PortForwardListActivity extends AppCompatListActivity {\n\tpublic final static String TAG = \"CB.PortForwardListAct\";\n\n\tprivate static final int LISTENER_CYCLE_TIME = 500;\n\n\tprotected HostDatabase hostdb;\n\n\tprivate List<PortForwardBean> portForwards;\n\n\tprivate ServiceConnection connection = null;\n\tprotected TerminalBridge hostBridge = null;\n\tprotected LayoutInflater inflater = null;\n\n\n\tprotected Handler updateHandler = new Handler(new WeakReference<>(this));\n\n\tprivate HostBean host;\n\n\t@Override\n\tpublic void onStart() {\n\t\tsuper.onStart();\n\n\t\tthis.bindService(new Intent(this, TerminalManager.class), connection, Context.BIND_AUTO_CREATE);\n\n\t\thostdb = HostDatabase.get(this);\n\t}\n\n\t@Override\n\tpublic void onStop() {\n\t\tsuper.onStop();\n\n\t\tthis.unbindService(connection);\n\n\t\thostdb = null;\n\t}\n\n\t@Override\n\tpublic void onCreate(Bundle icicle) {\n\t\tsuper.onCreate(icicle);\n\n\t\tlong hostId = this.getIntent().getLongExtra(Intent.EXTRA_TITLE, -1);\n\n\t\tsetContentView(R.layout.act_portforwardlist);\n\n\t\tmListView = (RecyclerView) findViewById(R.id.list);\n\t\tmListView.setHasFixedSize(true);\n\t\tmListView.setLayoutManager(new LinearLayoutManager(this));\n\t\tmListView.addItemDecoration(new ListItemDecoration(this));\n\n\t\tmEmptyView = findViewById(R.id.empty);\n\n\t\t// connect with hosts database and populate list\n\t\tthis.hostdb = HostDatabase.get(this);\n\t\thost = hostdb.findHostById(hostId);\n\n\t\t{\n\t\t\tfinal String nickname = host != null ? host.getNickname() : null;\n\t\t\tfinal Resources resources = getResources();\n\n\t\t\tif (nickname != null) {\n\t\t\t\tthis.setTitle(String.format(\"%s (%s)\",\n\t\t\t\t\t\tresources.getText(R.string.title_port_forwards_list),\n\t\t\t\t\t\tnickname));\n\t\t\t}\n\t\t}\n\n\t\tconnection = new ServiceConnection() {\n\t\t\tpublic void onServiceConnected(ComponentName className, IBinder service) {\n\t\t\t\tTerminalManager bound = ((TerminalManager.TerminalBinder) service).getService();\n\n\t\t\t\thostBridge = bound.getConnectedBridge(host);\n\t\t\t\tupdateHandler.sendEmptyMessage(-1);\n\t\t\t}\n\n\t\t\tpublic void onServiceDisconnected(ComponentName name) {\n\t\t\t\thostBridge = null;\n\t\t\t}\n\t\t};\n\n\t\tthis.updateList();\n\n\t\tthis.registerForContextMenu(mListView);\n\n\t\tthis.inflater = LayoutInflater.from(this);\n\n\t\tFloatingActionButton addPortForwardButton =\n\t\t\t\t(FloatingActionButton) findViewById(R.id.add_port_forward_button);\n\t\taddPortForwardButton.setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\t// build dialog to prompt user about updating\n\t\t\t\tfinal View portForwardView = View.inflate(PortForwardListActivity.this, R.layout.dia_portforward, null);\n\t\t\t\tfinal EditText destEdit = (EditText) portForwardView.findViewById(R.id.portforward_destination);\n\t\t\t\tfinal Spinner typeSpinner = (Spinner) portForwardView.findViewById(R.id.portforward_type);\n\n\t\t\t\ttypeSpinner.setOnItemSelectedListener(new OnItemSelectedListener() {\n\t\t\t\t\tpublic void onItemSelected(AdapterView<?> value, View view,\n\t\t\t\t\t\t\tint position, long id) {\n\t\t\t\t\t\tdestEdit.setEnabled(position != 2);\n\t\t\t\t\t}\n\t\t\t\t\tpublic void onNothingSelected(AdapterView<?> arg0) {\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tnew AlertDialog.Builder(PortForwardListActivity.this)\n\t\t\t\t\t\t.setView(portForwardView)\n\t\t\t\t\t\t.setPositiveButton(R.string.portforward_pos, new DialogInterface.OnClickListener() {\n\t\t\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tfinal EditText nicknameEdit = (EditText) portForwardView.findViewById(R.id.nickname);\n\t\t\t\t\t\t\t\t\tfinal EditText sourcePortEdit = (EditText) portForwardView.findViewById(R.id.portforward_source);\n\n\t\t\t\t\t\t\t\t\tString type = HostDatabase.PORTFORWARD_LOCAL;\n\t\t\t\t\t\t\t\t\tswitch (typeSpinner.getSelectedItemPosition()) {\n\t\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\t\ttype = HostDatabase.PORTFORWARD_LOCAL;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\t\ttype = HostDatabase.PORTFORWARD_REMOTE;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\t\ttype = HostDatabase.PORTFORWARD_DYNAMIC5;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Why length(), not isEmpty(), is used: http://stackoverflow.com/q/10606725\n\t\t\t\t\t\t\t\t\tString sourcePort = sourcePortEdit.getText().toString();\n\t\t\t\t\t\t\t\t\tif (sourcePort.length() == 0) {\n\t\t\t\t\t\t\t\t\t\tsourcePort = sourcePortEdit.getHint().toString();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tString destination = destEdit.getText().toString();\n\t\t\t\t\t\t\t\t\tif (destination.length() == 0) {\n\t\t\t\t\t\t\t\t\t\tdestination = destEdit.getHint().toString();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tPortForwardBean portForward = new PortForwardBean(\n\t\t\t\t\t\t\t\t\t\t\thost != null ? host.getId() : -1,\n\t\t\t\t\t\t\t\t\t\t\tnicknameEdit.getText().toString(),\n\t\t\t\t\t\t\t\t\t\t\ttype,\n\t\t\t\t\t\t\t\t\t\t\tsourcePort,\n\t\t\t\t\t\t\t\t\t\t\tdestination);\n\n\t\t\t\t\t\t\t\t\tif (hostBridge != null) {\n\t\t\t\t\t\t\t\t\t\thostBridge.addPortForward(portForward);\n\t\t\t\t\t\t\t\t\t\thostBridge.enablePortForward(portForward);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (host != null && !hostdb.savePortForward(portForward)) {\n\t\t\t\t\t\t\t\t\t\tthrow new SQLException(\"Could not save port forward\");\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tupdateHandler.sendEmptyMessage(-1);\n\t\t\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\t\t\tLog.e(TAG, \"Could not update port forward\", e);\n\t\t\t\t\t\t\t\t\t// TODO Show failure dialog.\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.setNegativeButton(R.string.delete_neg, null).create().show();\n\t\t\t}\n\n\t\t\tpublic void onNothingSelected(AdapterView<?> arg0) {}\n\t\t});\n\t}\n\n\tprotected void updateList() {\n\t\tif (hostBridge != null) {\n\t\t\tthis.portForwards = hostBridge.getPortForwards();\n\t\t} else {\n\t\t\tif (this.hostdb == null) return;\n\t\t\tthis.portForwards = this.hostdb.getPortForwardsForHost(host);\n\t\t}\n\n\t\tmAdapter = new PortForwardAdapter(this, portForwards);\n\t\tmListView.setAdapter(mAdapter);\n\t\tadjustViewVisibility();\n\t}\n\n\tprivate class PortForwardViewHolder extends ItemViewHolder {\n\t\tpublic final TextView nickname;\n\t\tpublic final TextView caption;\n\n\t\tpublic PortForwardBean portForward;\n\n\t\tpublic PortForwardViewHolder(View v) {\n\t\t\tsuper(v);\n\n\t\t\tnickname = (TextView) v.findViewById(android.R.id.text1);\n\t\t\tcaption = (TextView) v.findViewById(android.R.id.text2);\n\t\t}\n\n\t\t@Override\n\t\tpublic void onClick(View v) {\n\t\t\tif (hostBridge != null) {\n\t\t\t\tif (portForward.isEnabled())\n\t\t\t\t\thostBridge.disablePortForward(portForward);\n\t\t\t\telse {\n\t\t\t\t\tif (!hostBridge.enablePortForward(portForward))\n\t\t\t\t\t\tToast.makeText(PortForwardListActivity.this, getString(R.string.portforward_problem), Toast.LENGTH_LONG).show();\n\t\t\t\t}\n\n\t\t\t\tupdateHandler.sendEmptyMessage(-1);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void onCreateContextMenu(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo) {\n\t\t\t// Create menu to handle deleting and editing port forward\n\t\t\tAdapterView.AdapterContextMenuInfo info = (AdapterView.AdapterContextMenuInfo) menuInfo;\n\n\t\t\tmenu.setHeaderTitle(portForward.getNickname());\n\n\t\t\tMenuItem edit = menu.add(R.string.portforward_edit);\n\t\t\tedit.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\tfinal View editTunnelView = View.inflate(PortForwardListActivity.this, R.layout.dia_portforward, null);\n\n\t\t\t\t\tfinal Spinner typeSpinner = (Spinner) editTunnelView.findViewById(R.id.portforward_type);\n\t\t\t\t\tif (HostDatabase.PORTFORWARD_LOCAL.equals(portForward.getType()))\n\t\t\t\t\t\ttypeSpinner.setSelection(0);\n\t\t\t\t\telse if (HostDatabase.PORTFORWARD_REMOTE.equals(portForward.getType()))\n\t\t\t\t\t\ttypeSpinner.setSelection(1);\n\t\t\t\t\telse\n\t\t\t\t\t\ttypeSpinner.setSelection(2);\n\n\t\t\t\t\tfinal EditText nicknameEdit = (EditText) editTunnelView.findViewById(R.id.nickname);\n\t\t\t\t\tnicknameEdit.setText(portForward.getNickname());\n\n\t\t\t\t\tfinal EditText sourcePortEdit = (EditText) editTunnelView.findViewById(R.id.portforward_source);\n\t\t\t\t\tsourcePortEdit.setText(String.valueOf(portForward.getSourcePort()));\n\n\t\t\t\t\tfinal EditText destEdit = (EditText) editTunnelView.findViewById(R.id.portforward_destination);\n\t\t\t\t\tif (HostDatabase.PORTFORWARD_DYNAMIC5.equals(portForward.getType())) {\n\t\t\t\t\t\tdestEdit.setEnabled(false);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdestEdit.setText(String.format(\"%s:%d\", portForward.getDestAddr(), portForward.getDestPort()));\n\t\t\t\t\t}\n\n\t\t\t\t\ttypeSpinner.setOnItemSelectedListener(new OnItemSelectedListener() {\n\t\t\t\t\t\tpublic void onItemSelected(AdapterView<?> value, View view,\n\t\t\t\t\t\t\t\tint position, long id) {\n\t\t\t\t\t\t\tdestEdit.setEnabled(position != 2);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpublic void onNothingSelected(AdapterView<?> arg0) {\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tnew AlertDialog.Builder(PortForwardListActivity.this)\n\t\t\t\t\t\t\t.setView(editTunnelView)\n\t\t\t\t\t\t\t.setPositiveButton(R.string.button_change, new DialogInterface.OnClickListener() {\n\t\t\t\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tif (hostBridge != null)\n\t\t\t\t\t\t\t\t\t\t\thostBridge.disablePortForward(portForward);\n\n\t\t\t\t\t\t\t\t\t\tportForward.setNickname(nicknameEdit.getText().toString());\n\n\t\t\t\t\t\t\t\t\t\tswitch (typeSpinner.getSelectedItemPosition()) {\n\t\t\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\t\t\tportForward.setType(HostDatabase.PORTFORWARD_LOCAL);\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\t\t\tportForward.setType(HostDatabase.PORTFORWARD_REMOTE);\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\t\t\tportForward.setType(HostDatabase.PORTFORWARD_DYNAMIC5);\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tportForward.setSourcePort(Integer.parseInt(sourcePortEdit.getText().toString()));\n\t\t\t\t\t\t\t\t\t\tportForward.setDest(destEdit.getText().toString());\n\n\t\t\t\t\t\t\t\t\t\t// Use the new settings for the existing connection.\n\t\t\t\t\t\t\t\t\t\tif (hostBridge != null)\n\t\t\t\t\t\t\t\t\t\t\tupdateHandler.postDelayed(new Runnable() {\n\t\t\t\t\t\t\t\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\t\t\t\t\t\t\thostBridge.enablePortForward(portForward);\n\t\t\t\t\t\t\t\t\t\t\t\t\tupdateHandler.sendEmptyMessage(-1);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}, LISTENER_CYCLE_TIME);\n\n\n\t\t\t\t\t\t\t\t\t\tif (!hostdb.savePortForward(portForward)) {\n\t\t\t\t\t\t\t\t\t\t\tthrow new SQLException(\"Could not save port forward\");\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tupdateHandler.sendEmptyMessage(-1);\n\t\t\t\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\t\t\t\tLog.e(TAG, \"Could not update port forward\", e);\n\t\t\t\t\t\t\t\t\t\t// TODO Show failure dialog.\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t.setNegativeButton(android.R.string.cancel, null).create().show();\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tMenuItem delete = menu.add(R.string.portforward_delete);\n\t\t\tdelete.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\t// prompt user to make sure they really want this\n\t\t\t\t\tnew AlertDialog.Builder(PortForwardListActivity.this)\n\t\t\t\t\t\t\t.setMessage(getString(R.string.delete_message, portForward.getNickname()))\n\t\t\t\t\t\t\t.setPositiveButton(R.string.delete_pos, new DialogInterface.OnClickListener() {\n\t\t\t\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t// Delete the port forward from the host if needed.\n\t\t\t\t\t\t\t\t\t\tif (hostBridge != null)\n\t\t\t\t\t\t\t\t\t\t\thostBridge.removePortForward(portForward);\n\n\t\t\t\t\t\t\t\t\t\thostdb.deletePortForward(portForward);\n\t\t\t\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\t\t\t\tLog.e(TAG, \"Could not delete port forward\", e);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tupdateHandler.sendEmptyMessage(-1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t.setNegativeButton(R.string.delete_neg, null).create().show();\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t@VisibleForTesting\n\tprivate class PortForwardAdapter extends ItemAdapter {\n\t\tprivate final List<PortForwardBean> portForwards;\n\n\t\tpublic PortForwardAdapter(Context context, List<PortForwardBean> portForwards) {\n\t\t\tsuper(context);\n\t\t\tthis.portForwards = portForwards;\n\t\t}\n\n\t\t@Override\n\t\tpublic PortForwardViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n\t\t\tView v = LayoutInflater.from(parent.getContext())\n\t\t\t\t\t.inflate(R.layout.item_portforward, parent, false);\n\t\t\tPortForwardViewHolder vh = new PortForwardViewHolder(v);\n\t\t\treturn vh;\n\t\t}\n\n\t\t@Override\n\t\tpublic void onBindViewHolder(ItemViewHolder holder, int position) {\n\t\t\tPortForwardViewHolder portForwardHolder = (PortForwardViewHolder) holder;\n\t\t\tPortForwardBean portForward = portForwards.get(position);\n\n\t\t\tportForwardHolder.portForward = portForward;\n\t\t\tportForwardHolder.nickname.setText(portForward.getNickname());\n\t\t\tportForwardHolder.caption.setText(portForward.getDescription());\n\n\t\t\tif (hostBridge != null && !portForward.isEnabled()) {\n\t\t\t\tportForwardHolder.nickname.setPaintFlags(portForwardHolder.nickname.getPaintFlags() | Paint.STRIKE_THRU_TEXT_FLAG);\n\t\t\t\tportForwardHolder.caption.setPaintFlags(portForwardHolder.caption.getPaintFlags() | Paint.STRIKE_THRU_TEXT_FLAG);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic long getItemId(int position) {\n\t\t\treturn portForwards.get(position).getId();\n\t\t}\n\n\t\t@Override\n\t\tpublic int getItemCount() {\n\t\t\treturn portForwards.size();\n\t\t}\n\t}\n\n\tprivate static class Handler extends android.os.Handler {\n\n\t\tprivate WeakReference<PortForwardListActivity> mActivity;\n\n\t\tHandler(WeakReference<PortForwardListActivity> activity) {\n\t\t\tmActivity = activity;\n\t\t}\n\n\t\t@Override\n\t\tpublic void handleMessage(Message msg) {\n\t\t\tmActivity.get().updateList();\n\t\t}\n\t}\n}\n","lineNo":192}
{"Smelly Sample":"/*\n * ConnectBot: simple, powerful, open-source SSH client for Android\n * Copyright 2007 Kenny Root, Jeffrey Sharkey\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.connectbot;\n\nimport java.lang.ref.WeakReference;\nimport java.util.List;\n\nimport org.connectbot.bean.HostBean;\nimport org.connectbot.bean.PortForwardBean;\nimport org.connectbot.service.TerminalBridge;\nimport org.connectbot.service.TerminalManager;\nimport org.connectbot.util.HostDatabase;\n\nimport android.app.AlertDialog;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.ServiceConnection;\nimport android.content.res.Resources;\nimport android.database.SQLException;\nimport android.graphics.Paint;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Message;\nimport android.support.annotation.VisibleForTesting;\nimport android.support.design.widget.FloatingActionButton;\nimport android.support.v7.widget.LinearLayoutManager;\nimport android.support.v7.widget.RecyclerView;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.LayoutInflater;\nimport android.view.MenuItem;\nimport android.view.MenuItem.OnMenuItemClickListener;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.AdapterView;\nimport android.widget.AdapterView.OnItemSelectedListener;\nimport android.widget.EditText;\nimport android.widget.Spinner;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\n/**\n * List all portForwards for a particular host and provide a way for users to add more portForwards,\n * edit existing portForwards, and delete portForwards.\n *\n * @author Kenny Root\n */\npublic class PortForwardListActivity extends AppCompatListActivity {\n\tpublic final static String TAG = \"CB.PortForwardListAct\";\n\n\tprivate static final int LISTENER_CYCLE_TIME = 500;\n\n\tprotected HostDatabase hostdb;\n\n\tprivate List<PortForwardBean> portForwards;\n\n\tprivate ServiceConnection connection = null;\n\tprotected TerminalBridge hostBridge = null;\n\tprotected LayoutInflater inflater = null;\n\n\n\tprotected Handler updateHandler = new Handler(new WeakReference<>(this));\n\n\tprivate HostBean host;\n\n\t@Override\n\tpublic void onStart() {\n\t\tsuper.onStart();\n\n\t\tthis.bindService(new Intent(this, TerminalManager.class), connection, Context.BIND_AUTO_CREATE);\n\n\t\thostdb = HostDatabase.get(this);\n\t}\n\n\t@Override\n\tpublic void onStop() {\n\t\tsuper.onStop();\n\n\t\tthis.unbindService(connection);\n\n\t\thostdb = null;\n\t}\n\n\t@Override\n\tpublic void onCreate(Bundle icicle) {\n\t\tsuper.onCreate(icicle);\n\n\t\tlong hostId = this.getIntent().getLongExtra(Intent.EXTRA_TITLE, -1);\n\n\t\tsetContentView(R.layout.act_portforwardlist);\n\n\t\tmListView = (RecyclerView) findViewById(R.id.list);\n\t\tmListView.setHasFixedSize(true);\n\t\tmListView.setLayoutManager(new LinearLayoutManager(this));\n\t\tmListView.addItemDecoration(new ListItemDecoration(this));\n\n\t\tmEmptyView = findViewById(R.id.empty);\n\n\t\t// connect with hosts database and populate list\n\t\tthis.hostdb = HostDatabase.get(this);\n\t\thost = hostdb.findHostById(hostId);\n\n\t\t{\n\t\t\tfinal String nickname = host != null ? host.getNickname() : null;\n\t\t\tfinal Resources resources = getResources();\n\n\t\t\tif (nickname != null) {\n\t\t\t\tthis.setTitle(String.format(\"%s (%s)\",\n\t\t\t\t\t\tresources.getText(R.string.title_port_forwards_list),\n\t\t\t\t\t\tnickname));\n\t\t\t}\n\t\t}\n\n\t\tconnection = new ServiceConnection() {\n\t\t\tpublic void onServiceConnected(ComponentName className, IBinder service) {\n\t\t\t\tTerminalManager bound = ((TerminalManager.TerminalBinder) service).getService();\n\n\t\t\t\thostBridge = bound.getConnectedBridge(host);\n\t\t\t\tupdateHandler.sendEmptyMessage(-1);\n\t\t\t}\n\n\t\t\tpublic void onServiceDisconnected(ComponentName name) {\n\t\t\t\thostBridge = null;\n\t\t\t}\n\t\t};\n\n\t\tthis.updateList();\n\n\t\tthis.registerForContextMenu(mListView);\n\n\t\tthis.inflater = LayoutInflater.from(this);\n\n\t\tFloatingActionButton addPortForwardButton =\n\t\t\t\t(FloatingActionButton) findViewById(R.id.add_port_forward_button);\n\t\taddPortForwardButton.setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\t// build dialog to prompt user about updating\n\t\t\t\tfinal View portForwardView = View.inflate(PortForwardListActivity.this, R.layout.dia_portforward, null);\n\t\t\t\tfinal EditText destEdit = (EditText) portForwardView.findViewById(R.id.portforward_destination);\n\t\t\t\tfinal Spinner typeSpinner = (Spinner) portForwardView.findViewById(R.id.portforward_type);\n\n\t\t\t\ttypeSpinner.setOnItemSelectedListener(new OnItemSelectedListener() {\n\t\t\t\t\tpublic void onItemSelected(AdapterView<?> value, View view,\n\t\t\t\t\t\t\tint position, long id) {\n\t\t\t\t\t\tdestEdit.setEnabled(position != 2);\n\t\t\t\t\t}\n\t\t\t\t\tpublic void onNothingSelected(AdapterView<?> arg0) {\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tnew AlertDialog.Builder(PortForwardListActivity.this)\n\t\t\t\t\t\t.setView(portForwardView)\n\t\t\t\t\t\t.setPositiveButton(R.string.portforward_pos, new DialogInterface.OnClickListener() {\n\t\t\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tfinal EditText nicknameEdit = (EditText) portForwardView.findViewById(R.id.nickname);\n\t\t\t\t\t\t\t\t\tfinal EditText sourcePortEdit = (EditText) portForwardView.findViewById(R.id.portforward_source);\n\n\t\t\t\t\t\t\t\t\tString type = HostDatabase.PORTFORWARD_LOCAL;\n\t\t\t\t\t\t\t\t\tswitch (typeSpinner.getSelectedItemPosition()) {\n\t\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\t\ttype = HostDatabase.PORTFORWARD_LOCAL;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\t\ttype = HostDatabase.PORTFORWARD_REMOTE;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\t\ttype = HostDatabase.PORTFORWARD_DYNAMIC5;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tPortForwardBean portForward = new PortForwardBean(\n\t\t\t\t\t\t\t\t\t\t\thost != null ? host.getId() : -1,\n\t\t\t\t\t\t\t\t\t\t\tnicknameEdit.getText().toString(), type,\n\t\t\t\t\t\t\t\t\t\t\tsourcePortEdit.getText().toString(),\n\t\t\t\t\t\t\t\t\t\t\tdestEdit.getText().toString());\n\n\t\t\t\t\t\t\t\t\tif (hostBridge != null) {\n\t\t\t\t\t\t\t\t\t\thostBridge.addPortForward(portForward);\n\t\t\t\t\t\t\t\t\t\thostBridge.enablePortForward(portForward);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (host != null && !hostdb.savePortForward(portForward)) {\n\t\t\t\t\t\t\t\t\t\tthrow new SQLException(\"Could not save port forward\");\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tupdateHandler.sendEmptyMessage(-1);\n\t\t\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\t\t\tLog.e(TAG, \"Could not update port forward\", e);\n\t\t\t\t\t\t\t\t\t// TODO Show failure dialog.\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.setNegativeButton(R.string.delete_neg, null).create().show();\n\t\t\t}\n\n\t\t\tpublic void onNothingSelected(AdapterView<?> arg0) {}\n\t\t});\n\t}\n\n\tprotected void updateList() {\n\t\tif (hostBridge != null) {\n\t\t\tthis.portForwards = hostBridge.getPortForwards();\n\t\t} else {\n\t\t\tif (this.hostdb == null) return;\n\t\t\tthis.portForwards = this.hostdb.getPortForwardsForHost(host);\n\t\t}\n\n\t\tmAdapter = new PortForwardAdapter(this, portForwards);\n\t\tmListView.setAdapter(mAdapter);\n\t\tadjustViewVisibility();\n\t}\n\n\tprivate class PortForwardViewHolder extends ItemViewHolder {\n\t\tpublic final TextView nickname;\n\t\tpublic final TextView caption;\n\n\t\tpublic PortForwardBean portForward;\n\n\t\tpublic PortForwardViewHolder(View v) {\n\t\t\tsuper(v);\n\n\t\t\tnickname = (TextView) v.findViewById(android.R.id.text1);\n\t\t\tcaption = (TextView) v.findViewById(android.R.id.text2);\n\t\t}\n\n\t\t@Override\n\t\tpublic void onClick(View v) {\n\t\t\tif (hostBridge != null) {\n\t\t\t\tif (portForward.isEnabled())\n\t\t\t\t\thostBridge.disablePortForward(portForward);\n\t\t\t\telse {\n\t\t\t\t\tif (!hostBridge.enablePortForward(portForward))\n\t\t\t\t\t\tToast.makeText(PortForwardListActivity.this, getString(R.string.portforward_problem), Toast.LENGTH_LONG).show();\n\t\t\t\t}\n\n\t\t\t\tupdateHandler.sendEmptyMessage(-1);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void onCreateContextMenu(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo) {\n\t\t\t// Create menu to handle deleting and editing port forward\n\t\t\tAdapterView.AdapterContextMenuInfo info = (AdapterView.AdapterContextMenuInfo) menuInfo;\n\n\t\t\tmenu.setHeaderTitle(portForward.getNickname());\n\n\t\t\tMenuItem edit = menu.add(R.string.portforward_edit);\n\t\t\tedit.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\tfinal View editTunnelView = View.inflate(PortForwardListActivity.this, R.layout.dia_portforward, null);\n\n\t\t\t\t\tfinal Spinner typeSpinner = (Spinner) editTunnelView.findViewById(R.id.portforward_type);\n\t\t\t\t\tif (HostDatabase.PORTFORWARD_LOCAL.equals(portForward.getType()))\n\t\t\t\t\t\ttypeSpinner.setSelection(0);\n\t\t\t\t\telse if (HostDatabase.PORTFORWARD_REMOTE.equals(portForward.getType()))\n\t\t\t\t\t\ttypeSpinner.setSelection(1);\n\t\t\t\t\telse\n\t\t\t\t\t\ttypeSpinner.setSelection(2);\n\n\t\t\t\t\tfinal EditText nicknameEdit = (EditText) editTunnelView.findViewById(R.id.nickname);\n\t\t\t\t\tnicknameEdit.setText(portForward.getNickname());\n\n\t\t\t\t\tfinal EditText sourcePortEdit = (EditText) editTunnelView.findViewById(R.id.portforward_source);\n\t\t\t\t\tsourcePortEdit.setText(String.valueOf(portForward.getSourcePort()));\n\n\t\t\t\t\tfinal EditText destEdit = (EditText) editTunnelView.findViewById(R.id.portforward_destination);\n\t\t\t\t\tif (HostDatabase.PORTFORWARD_DYNAMIC5.equals(portForward.getType())) {\n\t\t\t\t\t\tdestEdit.setEnabled(false);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdestEdit.setText(String.format(\"%s:%d\", portForward.getDestAddr(), portForward.getDestPort()));\n\t\t\t\t\t}\n\n\t\t\t\t\ttypeSpinner.setOnItemSelectedListener(new OnItemSelectedListener() {\n\t\t\t\t\t\tpublic void onItemSelected(AdapterView<?> value, View view,\n\t\t\t\t\t\t\t\tint position, long id) {\n\t\t\t\t\t\t\tdestEdit.setEnabled(position != 2);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpublic void onNothingSelected(AdapterView<?> arg0) {\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tnew AlertDialog.Builder(PortForwardListActivity.this)\n\t\t\t\t\t\t\t.setView(editTunnelView)\n\t\t\t\t\t\t\t.setPositiveButton(R.string.button_change, new DialogInterface.OnClickListener() {\n\t\t\t\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tif (hostBridge != null)\n\t\t\t\t\t\t\t\t\t\t\thostBridge.disablePortForward(portForward);\n\n\t\t\t\t\t\t\t\t\t\tportForward.setNickname(nicknameEdit.getText().toString());\n\n\t\t\t\t\t\t\t\t\t\tswitch (typeSpinner.getSelectedItemPosition()) {\n\t\t\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\t\t\tportForward.setType(HostDatabase.PORTFORWARD_LOCAL);\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\t\t\tportForward.setType(HostDatabase.PORTFORWARD_REMOTE);\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\t\t\tportForward.setType(HostDatabase.PORTFORWARD_DYNAMIC5);\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tportForward.setSourcePort(Integer.parseInt(sourcePortEdit.getText().toString()));\n\t\t\t\t\t\t\t\t\t\tportForward.setDest(destEdit.getText().toString());\n\n\t\t\t\t\t\t\t\t\t\t// Use the new settings for the existing connection.\n\t\t\t\t\t\t\t\t\t\tif (hostBridge != null)\n\t\t\t\t\t\t\t\t\t\t\tupdateHandler.postDelayed(new Runnable() {\n\t\t\t\t\t\t\t\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\t\t\t\t\t\t\thostBridge.enablePortForward(portForward);\n\t\t\t\t\t\t\t\t\t\t\t\t\tupdateHandler.sendEmptyMessage(-1);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}, LISTENER_CYCLE_TIME);\n\n\n\t\t\t\t\t\t\t\t\t\tif (!hostdb.savePortForward(portForward)) {\n\t\t\t\t\t\t\t\t\t\t\tthrow new SQLException(\"Could not save port forward\");\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tupdateHandler.sendEmptyMessage(-1);\n\t\t\t\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\t\t\t\tLog.e(TAG, \"Could not update port forward\", e);\n\t\t\t\t\t\t\t\t\t\t// TODO Show failure dialog.\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t.setNegativeButton(android.R.string.cancel, null).create().show();\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tMenuItem delete = menu.add(R.string.portforward_delete);\n\t\t\tdelete.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\t// prompt user to make sure they really want this\n\t\t\t\t\tnew AlertDialog.Builder(PortForwardListActivity.this)\n\t\t\t\t\t\t\t.setMessage(getString(R.string.delete_message, portForward.getNickname()))\n\t\t\t\t\t\t\t.setPositiveButton(R.string.delete_pos, new DialogInterface.OnClickListener() {\n\t\t\t\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t// Delete the port forward from the host if needed.\n\t\t\t\t\t\t\t\t\t\tif (hostBridge != null)\n\t\t\t\t\t\t\t\t\t\t\thostBridge.removePortForward(portForward);\n\n\t\t\t\t\t\t\t\t\t\thostdb.deletePortForward(portForward);\n\t\t\t\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\t\t\t\tLog.e(TAG, \"Could not delete port forward\", e);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tupdateHandler.sendEmptyMessage(-1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t.setNegativeButton(R.string.delete_neg, null).create().show();\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t@VisibleForTesting\n\tprivate class PortForwardAdapter extends ItemAdapter {\n\t\tprivate final List<PortForwardBean> portForwards;\n\n\t\tpublic PortForwardAdapter(Context context, List<PortForwardBean> portForwards) {\n\t\t\tsuper(context);\n\t\t\tthis.portForwards = portForwards;\n\t\t}\n\n\t\t@Override\n\t\tpublic PortForwardViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n\t\t\tView v = LayoutInflater.from(parent.getContext())\n\t\t\t\t\t.inflate(R.layout.item_portforward, parent, false);\n\t\t\tPortForwardViewHolder vh = new PortForwardViewHolder(v);\n\t\t\treturn vh;\n\t\t}\n\n\t\t@Override\n\t\tpublic void onBindViewHolder(ItemViewHolder holder, int position) {\n\t\t\tPortForwardViewHolder portForwardHolder = (PortForwardViewHolder) holder;\n\t\t\tPortForwardBean portForward = portForwards.get(position);\n\n\t\t\tportForwardHolder.portForward = portForward;\n\t\t\tportForwardHolder.nickname.setText(portForward.getNickname());\n\t\t\tportForwardHolder.caption.setText(portForward.getDescription());\n\n\t\t\tif (hostBridge != null && !portForward.isEnabled()) {\n\t\t\t\tportForwardHolder.nickname.setPaintFlags(portForwardHolder.nickname.getPaintFlags() | Paint.STRIKE_THRU_TEXT_FLAG);\n\t\t\t\tportForwardHolder.caption.setPaintFlags(portForwardHolder.caption.getPaintFlags() | Paint.STRIKE_THRU_TEXT_FLAG);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic long getItemId(int position) {\n\t\t\treturn portForwards.get(position).getId();\n\t\t}\n\n\t\t@Override\n\t\tpublic int getItemCount() {\n\t\t\treturn portForwards.size();\n\t\t}\n\t}\n\n\tprivate static class Handler extends android.os.Handler {\n\n\t\tprivate WeakReference<PortForwardListActivity> mActivity;\n\n\t\tHandler(WeakReference<PortForwardListActivity> activity) {\n\t\t\tmActivity = activity;\n\t\t}\n\n\t\t@Override\n\t\tpublic void handleMessage(Message msg) {\n\t\t\tmActivity.get().updateList();\n\t\t}\n\t}\n}\n","Method after Refactoring":"/*\n * ConnectBot: simple, powerful, open-source SSH client for Android\n * Copyright 2007 Kenny Root, Jeffrey Sharkey\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.connectbot;\n\nimport java.lang.ref.WeakReference;\nimport java.util.List;\n\nimport org.connectbot.bean.HostBean;\nimport org.connectbot.bean.PortForwardBean;\nimport org.connectbot.service.TerminalBridge;\nimport org.connectbot.service.TerminalManager;\nimport org.connectbot.util.HostDatabase;\n\nimport android.app.AlertDialog;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.ServiceConnection;\nimport android.content.res.Resources;\nimport android.database.SQLException;\nimport android.graphics.Paint;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Message;\nimport android.support.annotation.VisibleForTesting;\nimport android.support.design.widget.FloatingActionButton;\nimport android.support.v7.widget.LinearLayoutManager;\nimport android.support.v7.widget.RecyclerView;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.LayoutInflater;\nimport android.view.MenuItem;\nimport android.view.MenuItem.OnMenuItemClickListener;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.AdapterView;\nimport android.widget.AdapterView.OnItemSelectedListener;\nimport android.widget.EditText;\nimport android.widget.Spinner;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\n/**\n * List all portForwards for a particular host and provide a way for users to add more portForwards,\n * edit existing portForwards, and delete portForwards.\n *\n * @author Kenny Root\n */\npublic class PortForwardListActivity extends AppCompatListActivity {\n\tpublic final static String TAG = \"CB.PortForwardListAct\";\n\n\tprivate static final int LISTENER_CYCLE_TIME = 500;\n\n\tprotected HostDatabase hostdb;\n\n\tprivate List<PortForwardBean> portForwards;\n\n\tprivate ServiceConnection connection = null;\n\tprotected TerminalBridge hostBridge = null;\n\tprotected LayoutInflater inflater = null;\n\n\n\tprotected Handler updateHandler = new Handler(new WeakReference<>(this));\n\n\tprivate HostBean host;\n\n\t@Override\n\tpublic void onStart() {\n\t\tsuper.onStart();\n\n\t\tthis.bindService(new Intent(this, TerminalManager.class), connection, Context.BIND_AUTO_CREATE);\n\n\t\thostdb = HostDatabase.get(this);\n\t}\n\n\t@Override\n\tpublic void onStop() {\n\t\tsuper.onStop();\n\n\t\tthis.unbindService(connection);\n\n\t\thostdb = null;\n\t}\n\n\t@Override\n\tpublic void onCreate(Bundle icicle) {\n\t\tsuper.onCreate(icicle);\n\n\t\tlong hostId = this.getIntent().getLongExtra(Intent.EXTRA_TITLE, -1);\n\n\t\tsetContentView(R.layout.act_portforwardlist);\n\n\t\tmListView = (RecyclerView) findViewById(R.id.list);\n\t\tmListView.setHasFixedSize(true);\n\t\tmListView.setLayoutManager(new LinearLayoutManager(this));\n\t\tmListView.addItemDecoration(new ListItemDecoration(this));\n\n\t\tmEmptyView = findViewById(R.id.empty);\n\n\t\t// connect with hosts database and populate list\n\t\tthis.hostdb = HostDatabase.get(this);\n\t\thost = hostdb.findHostById(hostId);\n\n\t\t{\n\t\t\tfinal String nickname = host != null ? host.getNickname() : null;\n\t\t\tfinal Resources resources = getResources();\n\n\t\t\tif (nickname != null) {\n\t\t\t\tthis.setTitle(String.format(\"%s (%s)\",\n\t\t\t\t\t\tresources.getText(R.string.title_port_forwards_list),\n\t\t\t\t\t\tnickname));\n\t\t\t}\n\t\t}\n\n\t\tconnection = new ServiceConnection() {\n\t\t\tpublic void onServiceConnected(ComponentName className, IBinder service) {\n\t\t\t\tTerminalManager bound = ((TerminalManager.TerminalBinder) service).getService();\n\n\t\t\t\thostBridge = bound.getConnectedBridge(host);\n\t\t\t\tupdateHandler.sendEmptyMessage(-1);\n\t\t\t}\n\n\t\t\tpublic void onServiceDisconnected(ComponentName name) {\n\t\t\t\thostBridge = null;\n\t\t\t}\n\t\t};\n\n\t\tthis.updateList();\n\n\t\tthis.registerForContextMenu(mListView);\n\n\t\tthis.inflater = LayoutInflater.from(this);\n\n\t\tFloatingActionButton addPortForwardButton =\n\t\t\t\t(FloatingActionButton) findViewById(R.id.add_port_forward_button);\n\t\taddPortForwardButton.setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\t// build dialog to prompt user about updating\n\t\t\t\tfinal View portForwardView = View.inflate(PortForwardListActivity.this, R.layout.dia_portforward, null);\n\t\t\t\tfinal EditText destEdit = (EditText) portForwardView.findViewById(R.id.portforward_destination);\n\t\t\t\tfinal Spinner typeSpinner = (Spinner) portForwardView.findViewById(R.id.portforward_type);\n\n\t\t\t\ttypeSpinner.setOnItemSelectedListener(new OnItemSelectedListener() {\n\t\t\t\t\tpublic void onItemSelected(AdapterView<?> value, View view,\n\t\t\t\t\t\t\tint position, long id) {\n\t\t\t\t\t\tdestEdit.setEnabled(position != 2);\n\t\t\t\t\t}\n\t\t\t\t\tpublic void onNothingSelected(AdapterView<?> arg0) {\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tnew AlertDialog.Builder(PortForwardListActivity.this)\n\t\t\t\t\t\t.setView(portForwardView)\n\t\t\t\t\t\t.setPositiveButton(R.string.portforward_pos, new DialogInterface.OnClickListener() {\n\t\t\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tfinal EditText nicknameEdit = (EditText) portForwardView.findViewById(R.id.nickname);\n\t\t\t\t\t\t\t\t\tfinal EditText sourcePortEdit = (EditText) portForwardView.findViewById(R.id.portforward_source);\n\n\t\t\t\t\t\t\t\t\tString type = HostDatabase.PORTFORWARD_LOCAL;\n\t\t\t\t\t\t\t\t\tswitch (typeSpinner.getSelectedItemPosition()) {\n\t\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\t\ttype = HostDatabase.PORTFORWARD_LOCAL;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\t\ttype = HostDatabase.PORTFORWARD_REMOTE;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\t\ttype = HostDatabase.PORTFORWARD_DYNAMIC5;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Why length(), not isEmpty(), is used: http://stackoverflow.com/q/10606725\n\t\t\t\t\t\t\t\t\tString sourcePort = sourcePortEdit.getText().toString();\n\t\t\t\t\t\t\t\t\tif (sourcePort.length() == 0) {\n\t\t\t\t\t\t\t\t\t\tsourcePort = sourcePortEdit.getHint().toString();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tString destination = destEdit.getText().toString();\n\t\t\t\t\t\t\t\t\tif (destination.length() == 0) {\n\t\t\t\t\t\t\t\t\t\tdestination = destEdit.getHint().toString();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tPortForwardBean portForward = new PortForwardBean(\n\t\t\t\t\t\t\t\t\t\t\thost != null ? host.getId() : -1,\n\t\t\t\t\t\t\t\t\t\t\tnicknameEdit.getText().toString(),\n\t\t\t\t\t\t\t\t\t\t\ttype,\n\t\t\t\t\t\t\t\t\t\t\tsourcePort,\n\t\t\t\t\t\t\t\t\t\t\tdestination);\n\n\t\t\t\t\t\t\t\t\tif (hostBridge != null) {\n\t\t\t\t\t\t\t\t\t\thostBridge.addPortForward(portForward);\n\t\t\t\t\t\t\t\t\t\thostBridge.enablePortForward(portForward);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (host != null && !hostdb.savePortForward(portForward)) {\n\t\t\t\t\t\t\t\t\t\tthrow new SQLException(\"Could not save port forward\");\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tupdateHandler.sendEmptyMessage(-1);\n\t\t\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\t\t\tLog.e(TAG, \"Could not update port forward\", e);\n\t\t\t\t\t\t\t\t\t// TODO Show failure dialog.\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.setNegativeButton(R.string.delete_neg, null).create().show();\n\t\t\t}\n\n\t\t\tpublic void onNothingSelected(AdapterView<?> arg0) {}\n\t\t});\n\t}\n\n\tprotected void updateList() {\n\t\tif (hostBridge != null) {\n\t\t\tthis.portForwards = hostBridge.getPortForwards();\n\t\t} else {\n\t\t\tif (this.hostdb == null) return;\n\t\t\tthis.portForwards = this.hostdb.getPortForwardsForHost(host);\n\t\t}\n\n\t\tmAdapter = new PortForwardAdapter(this, portForwards);\n\t\tmListView.setAdapter(mAdapter);\n\t\tadjustViewVisibility();\n\t}\n\n\tprivate class PortForwardViewHolder extends ItemViewHolder {\n\t\tpublic final TextView nickname;\n\t\tpublic final TextView caption;\n\n\t\tpublic PortForwardBean portForward;\n\n\t\tpublic PortForwardViewHolder(View v) {\n\t\t\tsuper(v);\n\n\t\t\tnickname = (TextView) v.findViewById(android.R.id.text1);\n\t\t\tcaption = (TextView) v.findViewById(android.R.id.text2);\n\t\t}\n\n\t\t@Override\n\t\tpublic void onClick(View v) {\n\t\t\tif (hostBridge != null) {\n\t\t\t\tif (portForward.isEnabled())\n\t\t\t\t\thostBridge.disablePortForward(portForward);\n\t\t\t\telse {\n\t\t\t\t\tif (!hostBridge.enablePortForward(portForward))\n\t\t\t\t\t\tToast.makeText(PortForwardListActivity.this, getString(R.string.portforward_problem), Toast.LENGTH_LONG).show();\n\t\t\t\t}\n\n\t\t\t\tupdateHandler.sendEmptyMessage(-1);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void onCreateContextMenu(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo) {\n\t\t\t// Create menu to handle deleting and editing port forward\n\t\t\tAdapterView.AdapterContextMenuInfo info = (AdapterView.AdapterContextMenuInfo) menuInfo;\n\n\t\t\tmenu.setHeaderTitle(portForward.getNickname());\n\n\t\t\tMenuItem edit = menu.add(R.string.portforward_edit);\n\t\t\tedit.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\tfinal View editTunnelView = View.inflate(PortForwardListActivity.this, R.layout.dia_portforward, null);\n\n\t\t\t\t\tfinal Spinner typeSpinner = (Spinner) editTunnelView.findViewById(R.id.portforward_type);\n\t\t\t\t\tif (HostDatabase.PORTFORWARD_LOCAL.equals(portForward.getType()))\n\t\t\t\t\t\ttypeSpinner.setSelection(0);\n\t\t\t\t\telse if (HostDatabase.PORTFORWARD_REMOTE.equals(portForward.getType()))\n\t\t\t\t\t\ttypeSpinner.setSelection(1);\n\t\t\t\t\telse\n\t\t\t\t\t\ttypeSpinner.setSelection(2);\n\n\t\t\t\t\tfinal EditText nicknameEdit = (EditText) editTunnelView.findViewById(R.id.nickname);\n\t\t\t\t\tnicknameEdit.setText(portForward.getNickname());\n\n\t\t\t\t\tfinal EditText sourcePortEdit = (EditText) editTunnelView.findViewById(R.id.portforward_source);\n\t\t\t\t\tsourcePortEdit.setText(String.valueOf(portForward.getSourcePort()));\n\n\t\t\t\t\tfinal EditText destEdit = (EditText) editTunnelView.findViewById(R.id.portforward_destination);\n\t\t\t\t\tif (HostDatabase.PORTFORWARD_DYNAMIC5.equals(portForward.getType())) {\n\t\t\t\t\t\tdestEdit.setEnabled(false);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdestEdit.setText(String.format(\"%s:%d\", portForward.getDestAddr(), portForward.getDestPort()));\n\t\t\t\t\t}\n\n\t\t\t\t\ttypeSpinner.setOnItemSelectedListener(new OnItemSelectedListener() {\n\t\t\t\t\t\tpublic void onItemSelected(AdapterView<?> value, View view,\n\t\t\t\t\t\t\t\tint position, long id) {\n\t\t\t\t\t\t\tdestEdit.setEnabled(position != 2);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpublic void onNothingSelected(AdapterView<?> arg0) {\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tnew AlertDialog.Builder(PortForwardListActivity.this)\n\t\t\t\t\t\t\t.setView(editTunnelView)\n\t\t\t\t\t\t\t.setPositiveButton(R.string.button_change, new DialogInterface.OnClickListener() {\n\t\t\t\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tif (hostBridge != null)\n\t\t\t\t\t\t\t\t\t\t\thostBridge.disablePortForward(portForward);\n\n\t\t\t\t\t\t\t\t\t\tportForward.setNickname(nicknameEdit.getText().toString());\n\n\t\t\t\t\t\t\t\t\t\tswitch (typeSpinner.getSelectedItemPosition()) {\n\t\t\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\t\t\tportForward.setType(HostDatabase.PORTFORWARD_LOCAL);\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\t\t\tportForward.setType(HostDatabase.PORTFORWARD_REMOTE);\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\t\t\tportForward.setType(HostDatabase.PORTFORWARD_DYNAMIC5);\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tportForward.setSourcePort(Integer.parseInt(sourcePortEdit.getText().toString()));\n\t\t\t\t\t\t\t\t\t\tportForward.setDest(destEdit.getText().toString());\n\n\t\t\t\t\t\t\t\t\t\t// Use the new settings for the existing connection.\n\t\t\t\t\t\t\t\t\t\tif (hostBridge != null)\n\t\t\t\t\t\t\t\t\t\t\tupdateHandler.postDelayed(new Runnable() {\n\t\t\t\t\t\t\t\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\t\t\t\t\t\t\thostBridge.enablePortForward(portForward);\n\t\t\t\t\t\t\t\t\t\t\t\t\tupdateHandler.sendEmptyMessage(-1);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}, LISTENER_CYCLE_TIME);\n\n\n\t\t\t\t\t\t\t\t\t\tif (!hostdb.savePortForward(portForward)) {\n\t\t\t\t\t\t\t\t\t\t\tthrow new SQLException(\"Could not save port forward\");\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tupdateHandler.sendEmptyMessage(-1);\n\t\t\t\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\t\t\t\tLog.e(TAG, \"Could not update port forward\", e);\n\t\t\t\t\t\t\t\t\t\t// TODO Show failure dialog.\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t.setNegativeButton(android.R.string.cancel, null).create().show();\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tMenuItem delete = menu.add(R.string.portforward_delete);\n\t\t\tdelete.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\t// prompt user to make sure they really want this\n\t\t\t\t\tnew AlertDialog.Builder(PortForwardListActivity.this)\n\t\t\t\t\t\t\t.setMessage(getString(R.string.delete_message, portForward.getNickname()))\n\t\t\t\t\t\t\t.setPositiveButton(R.string.delete_pos, new DialogInterface.OnClickListener() {\n\t\t\t\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t// Delete the port forward from the host if needed.\n\t\t\t\t\t\t\t\t\t\tif (hostBridge != null)\n\t\t\t\t\t\t\t\t\t\t\thostBridge.removePortForward(portForward);\n\n\t\t\t\t\t\t\t\t\t\thostdb.deletePortForward(portForward);\n\t\t\t\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\t\t\t\tLog.e(TAG, \"Could not delete port forward\", e);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tupdateHandler.sendEmptyMessage(-1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t.setNegativeButton(R.string.delete_neg, null).create().show();\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t@VisibleForTesting\n\tprivate class PortForwardAdapter extends ItemAdapter {\n\t\tprivate final List<PortForwardBean> portForwards;\n\n\t\tpublic PortForwardAdapter(Context context, List<PortForwardBean> portForwards) {\n\t\t\tsuper(context);\n\t\t\tthis.portForwards = portForwards;\n\t\t}\n\n\t\t@Override\n\t\tpublic PortForwardViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n\t\t\tView v = LayoutInflater.from(parent.getContext())\n\t\t\t\t\t.inflate(R.layout.item_portforward, parent, false);\n\t\t\tPortForwardViewHolder vh = new PortForwardViewHolder(v);\n\t\t\treturn vh;\n\t\t}\n\n\t\t@Override\n\t\tpublic void onBindViewHolder(ItemViewHolder holder, int position) {\n\t\t\tPortForwardViewHolder portForwardHolder = (PortForwardViewHolder) holder;\n\t\t\tPortForwardBean portForward = portForwards.get(position);\n\n\t\t\tportForwardHolder.portForward = portForward;\n\t\t\tportForwardHolder.nickname.setText(portForward.getNickname());\n\t\t\tportForwardHolder.caption.setText(portForward.getDescription());\n\n\t\t\tif (hostBridge != null && !portForward.isEnabled()) {\n\t\t\t\tportForwardHolder.nickname.setPaintFlags(portForwardHolder.nickname.getPaintFlags() | Paint.STRIKE_THRU_TEXT_FLAG);\n\t\t\t\tportForwardHolder.caption.setPaintFlags(portForwardHolder.caption.getPaintFlags() | Paint.STRIKE_THRU_TEXT_FLAG);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic long getItemId(int position) {\n\t\t\treturn portForwards.get(position).getId();\n\t\t}\n\n\t\t@Override\n\t\tpublic int getItemCount() {\n\t\t\treturn portForwards.size();\n\t\t}\n\t}\n\n\tprivate static class Handler extends android.os.Handler {\n\n\t\tprivate WeakReference<PortForwardListActivity> mActivity;\n\n\t\tHandler(WeakReference<PortForwardListActivity> activity) {\n\t\t\tmActivity = activity;\n\t\t}\n\n\t\t@Override\n\t\tpublic void handleMessage(Message msg) {\n\t\t\tmActivity.get().updateList();\n\t\t}\n\t}\n}\n","lineNo":197}
{"Smelly Sample":"/*\n * ConnectBot: simple, powerful, open-source SSH client for Android\n * Copyright 2015 Kenny Root, Jeffrey Sharkey\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.connectbot;\n\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.res.TypedArray;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Parcelable;\nimport android.support.design.widget.TextInputLayout;\nimport android.support.v4.app.Fragment;\nimport android.text.Editable;\nimport android.text.TextWatcher;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.AdapterView;\nimport android.widget.ArrayAdapter;\nimport android.widget.EditText;\nimport android.widget.ImageButton;\nimport android.widget.SeekBar;\nimport android.widget.Spinner;\nimport android.widget.TextView;\n\nimport org.connectbot.bean.HostBean;\nimport org.connectbot.transport.SSH;\nimport org.connectbot.transport.Telnet;\nimport org.connectbot.transport.TransportFactory;\nimport org.connectbot.util.HostDatabase;\n\npublic class HostEditorFragment extends Fragment {\n\n\tprivate static final String ARG_EXISTING_HOST = \"existingHost\";\n\tprivate static final String ARG_IS_EXPANDED = \"isExpanded\";\n\tprivate static final String ARG_QUICKCONNECT_STRING = \"quickConnectString\";\n\n\tprivate static final int MINIMUM_FONT_SIZE = 8;\n\n\t// The host being edited.\n\tprivate HostBean mHost;\n\t\n\t// Whether the host is being created for the first time (as opposed to an existing one being\n\t// edited).\n\tprivate boolean mIsCreating;\n\n\t// The listener for changes to this host.\n\tprivate Listener mListener;\n\n\t// Whether the URI parts subsection is expanded.\n\tprivate boolean mIsUriEditorExpanded = false;\n\n\t// Whether a URI text edit is in progress. When the quick-connect field is being edited, changes\n\t// automatically propagate to the URI part fields; likewise, when the URI part fields are\n\t// edited, changes are propagated to the quick-connect field. This boolean safeguards against\n\t// infinite loops which can be caused by one field changing the other field, which changes the\n\t// first field, etc.\n\tprivate boolean mUriFieldEditInProgress = false;\n\n\t// Values for the colors displayed in the color Spinner. These are not necessarily the same as\n\t// the text in the Spinner because the text is localized while these values are not.\n\tprivate TypedArray mColorValues;\n\n\tprivate Spinner mTransportSpinner;\n\tprivate TextInputLayout mQuickConnectContainer;\n\tprivate EditText mQuickConnectField;\n\tprivate ImageButton mExpandCollapseButton;\n\tprivate View mUriPartsContainer;\n\tprivate View mUsernameContainer;\n\tprivate EditText mUsernameField;\n\tprivate View mHostnameContainer;\n\tprivate EditText mHostnameField;\n\tprivate View mPortContainer;\n\tprivate EditText mPortField;\n\tprivate EditText mNicknameField;\n\tprivate Spinner mColorSelector;\n\tprivate TextView mFontSizeText;\n\tprivate SeekBar mFontSizeSeekBar;\n\n\tpublic static HostEditorFragment newInstance(HostBean existingHost) {\n\t\tHostEditorFragment fragment = new HostEditorFragment();\n\t\tBundle args = new Bundle();\n\t\tif (existingHost != null) {\n\t\t\targs.putParcelable(ARG_EXISTING_HOST, existingHost.getValues());\n\t\t}\n\t\tfragment.setArguments(args);\n\t\treturn fragment;\n\t}\n\n\tpublic HostEditorFragment() {\n\t}\n\n\t@Override\n\tpublic void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\n\t\tBundle bundle = savedInstanceState == null ? getArguments() : savedInstanceState;\n\n\t\tParcelable existingHostParcelable = bundle.getParcelable(ARG_EXISTING_HOST);\n\t\tmIsCreating = existingHostParcelable == null;\n\t\tif (existingHostParcelable != null) {\n\t\t\tmHost = HostBean.fromContentValues((ContentValues) existingHostParcelable);\n\t\t} else {\n\t\t\tmHost = new HostBean();\n\t\t}\n\n\t\tmIsUriEditorExpanded = bundle.getBoolean(ARG_IS_EXPANDED);\n\t}\n\n\t@Override\n\tpublic View onCreateView(LayoutInflater inflater, ViewGroup container,\n\t\t\tBundle savedInstanceState) {\n\t\tView view = inflater.inflate(R.layout.fragment_host_editor, container, false);\n\n\t\tmTransportSpinner = (Spinner) view.findViewById(R.id.transport_selector);\n\t\tArrayAdapter<String> transportSelection = new ArrayAdapter<>(\n\t\t\t\tgetActivity(),\n\t\t\t\tandroid.R.layout.simple_spinner_item,\n\t\t\t\tTransportFactory.getTransportNames());\n\t\ttransportSelection.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);\n\t\tmTransportSpinner.setAdapter(transportSelection);\n\t\tmTransportSpinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {\n\t\t\t@Override\n\t\t\tpublic void onItemSelected(AdapterView<?> parent, View view, int position, long id) {\n\t\t\t\tString protocol = (String) mTransportSpinner.getSelectedItem();\n\t\t\t\tif (protocol == null) {\n\t\t\t\t\t// During initialization, protocol can be null before the list of dropdown items\n\t\t\t\t\t// has been generated. Return early in that case.\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tmHost.setProtocol(protocol);\n\t\t\t\tmHost.setPort(TransportFactory.getTransport(protocol).getDefaultPort());\n\n\t\t\t\tmQuickConnectContainer.setHint(\n\t\t\t\t\t\tTransportFactory.getFormatHint(protocol, getActivity()));\n\n\t\t\t\t// Different protocols have different field types, so show only the fields needed.\n\t\t\t\tif (SSH.getProtocolName().equals(protocol)) {\n\t\t\t\t\tmUsernameContainer.setVisibility(View.VISIBLE);\n\t\t\t\t\tmHostnameContainer.setVisibility(View.VISIBLE);\n\t\t\t\t\tmPortContainer.setVisibility(View.VISIBLE);\n\t\t\t\t\tmExpandCollapseButton.setVisibility(View.VISIBLE);\n\t\t\t\t} else if (Telnet.getProtocolName().equals(protocol)) {\n\t\t\t\t\tmUsernameContainer.setVisibility(View.GONE);\n\t\t\t\t\tmHostnameContainer.setVisibility(View.VISIBLE);\n\t\t\t\t\tmPortContainer.setVisibility(View.VISIBLE);\n\t\t\t\t\tmExpandCollapseButton.setVisibility(View.VISIBLE);\n\t\t\t\t} else {\n\t\t\t\t\t// Local protocol has only one field, so no need to show the URI parts\n\t\t\t\t\t// container.\n\t\t\t\t\tsetUriPartsContainerExpanded(false);\n\t\t\t\t\tmExpandCollapseButton.setVisibility(View.INVISIBLE);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void onNothingSelected(AdapterView<?> parent) {\n\t\t\t}\n\t\t});\n\n\t\tmQuickConnectContainer =\n\t\t\t\t(TextInputLayout) view.findViewById(R.id.quickconnect_field_container);\n\n\t\tmQuickConnectField = (EditText) view.findViewById(R.id.quickconnect_field);\n\t\tString oldQuickConnect = savedInstanceState == null ?\n\t\t\t\tnull : savedInstanceState.getString(ARG_QUICKCONNECT_STRING);\n\t\tmQuickConnectField.setText(oldQuickConnect == null ? mHost.toString() : oldQuickConnect);\n\t\tmQuickConnectField.addTextChangedListener(new TextWatcher() {\n\t\t\t@Override\n\t\t\tpublic void beforeTextChanged(CharSequence s, int start, int count, int after) {}\n\n\t\t\t@Override\n\t\t\tpublic void onTextChanged(CharSequence s, int start, int before, int count) {}\n\n\t\t\t@Override\n\t\t\tpublic void afterTextChanged(Editable s) {\n\t\t\t\tif (mTransportSpinner.getSelectedItem() == null) {\n\t\t\t\t\t// During initialization, protocol can be null before the list of dropdown items\n\t\t\t\t\t// has been generated. Return early in that case.\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (!mUriFieldEditInProgress) {\n\t\t\t\t\tapplyQuickConnectString(\n\t\t\t\t\t\t\ts.toString(), (String) mTransportSpinner.getSelectedItem());\n\n\t\t\t\t\tmUriFieldEditInProgress = true;\n\t\t\t\t\tmUsernameField.setText(mHost.getUsername());\n\t\t\t\t\tmHostnameField.setText(mHost.getHostname());\n\t\t\t\t\tmPortField.setText(Integer.toString(mHost.getPort()));\n\t\t\t\t\tmUriFieldEditInProgress = false;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tmExpandCollapseButton = (ImageButton) view.findViewById(R.id.expand_collapse_button);\n\t\tmExpandCollapseButton.setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tsetUriPartsContainerExpanded(!mIsUriEditorExpanded);\n\t\t\t}\n\t\t});\n\n\t\tmUriPartsContainer = view.findViewById(R.id.uri_parts_container);\n\n\t\tmUsernameContainer = view.findViewById(R.id.username_field_container);\n\t\tmUsernameField = (EditText) view.findViewById(R.id.username_edit_text);\n\t\tmUsernameField.setText(mHost.getUsername());\n\t\tmUsernameField.addTextChangedListener(new HostTextFieldWatcher(HostDatabase.FIELD_HOST_USERNAME));\n\n\t\tmHostnameContainer = view.findViewById(R.id.hostname_field_container);\n\t\tmHostnameField = (EditText) view.findViewById(R.id.hostname_edit_text);\n\t\tmHostnameField.setText(mHost.getHostname());\n\t\tmHostnameField.addTextChangedListener(new HostTextFieldWatcher(HostDatabase.FIELD_HOST_HOSTNAME));\n\n\t\tmPortContainer = view.findViewById(R.id.port_field_container);\n\t\tmPortField = (EditText) view.findViewById(R.id.port_edit_text);\n\t\tmPortField.setText(Integer.toString(mHost.getPort()));\n\t\tmPortField.addTextChangedListener(new HostTextFieldWatcher(HostDatabase.FIELD_HOST_PORT));\n\n\t\tmNicknameField = (EditText) view.findViewById(R.id.nickname_field);\n\t\tmNicknameField.setText(mHost.getNickname());\n\t\tmNicknameField.addTextChangedListener(\n\t\t\t\tnew HostTextFieldWatcher(HostDatabase.FIELD_HOST_NICKNAME));\n\n\t\tmColorSelector = (Spinner) view.findViewById(R.id.color_selector);\n\t\tif (mHost.getColor() != null) {\n\t\t\t// Unfortunately, TypedArray doesn't have an indexOf(String) function, so search through\n\t\t\t// the array for the saved color.\n\t\t\tfor (int i = 0; i < mColorValues.getIndexCount(); i++) {\n\t\t\t\tif (mHost.getColor().equals(mColorValues.getString(i))) {\n\t\t\t\t\tmColorSelector.setSelection(i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmColorSelector.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {\n\t\t\t@Override\n\t\t\tpublic void onItemSelected(AdapterView<?> parent, View view, int position, long id) {\n\t\t\t\tmHost.setColor(mColorValues.getString(position));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void onNothingSelected(AdapterView<?> parent) {\n\t\t\t}\n\t\t});\n\n\t\tmFontSizeText = (TextView) view.findViewById(R.id.font_size_text);\n\t\tmFontSizeSeekBar = (SeekBar) view.findViewById(R.id.font_size_bar);\n\t\tmFontSizeSeekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {\n\t\t\t@Override\n\t\t\tpublic void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {\n\t\t\t\tint fontSize = MINIMUM_FONT_SIZE + progress;\n\t\t\t\tmHost.setFontSize(fontSize);\n\t\t\t\tmFontSizeText.setText(Integer.toString(fontSize));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void onStartTrackingTouch(SeekBar seekBar) {\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void onStopTrackingTouch(SeekBar seekBar) {\n\t\t\t}\n\t\t});\n\t\tmFontSizeSeekBar.setProgress(mHost.getFontSize() - MINIMUM_FONT_SIZE);\n\n\t\tsetUriPartsContainerExpanded(mIsUriEditorExpanded);\n\n\t\treturn view;\n\t}\n\n\t@Override\n\tpublic void onAttach(Context context) {\n\t\tsuper.onAttach(context);\n\t\ttry {\n\t\t\tmListener = (Listener) context;\n\t\t} catch (ClassCastException e) {\n\t\t\tthrow new ClassCastException(context.toString() + \" must implement Listener\");\n\t\t}\n\n\t\t// Now that the fragment is attached to an Activity, fetch the array from the attached\n\t\t// Activity's resources.\n\t\tmColorValues = getResources().obtainTypedArray(R.array.list_color_values);\n\t}\n\n\t@Override\n\tpublic void onDetach() {\n\t\tsuper.onDetach();\n\t\tmListener = null;\n\t\tmColorValues.recycle();\n\t}\n\n\t@Override\n\tpublic void onSaveInstanceState(Bundle savedInstanceState) {\n\t\tsuper.onSaveInstanceState(savedInstanceState);\n\n\t\tsavedInstanceState.putParcelable(ARG_EXISTING_HOST, mHost.getValues());\n\t\tsavedInstanceState.putBoolean(ARG_IS_EXPANDED, mIsUriEditorExpanded);\n\t\tsavedInstanceState.putString(\n\t\t\t\tARG_QUICKCONNECT_STRING, mQuickConnectField.getText().toString());\n\t}\n\n\tprivate void setUriPartsContainerExpanded(boolean expanded) {\n\t\tmIsUriEditorExpanded = expanded;\n\n\t\tif (mIsUriEditorExpanded) {\n\t\t\tmExpandCollapseButton.setImageResource(R.drawable.ic_expand_less);\n\t\t\tmUriPartsContainer.setVisibility(View.VISIBLE);\n\t\t} else {\n\t\t\tmExpandCollapseButton.setImageResource(R.drawable.ic_expand_more);\n\t\t\tmUriPartsContainer.setVisibility(View.GONE);\n\t\t}\n\t}\n\n\t/**\n\t * Applies the quick-connect URI entered in the field by copying its URI parts to mHost's\n\t * fields.\n\t * @param quickConnectString The URI entered in the quick-connect field.\n\t * @param protocol The protocol for this connection.\n\t */\n\tprivate void applyQuickConnectString(String quickConnectString, String protocol) {\n\t\tif (quickConnectString == null || protocol == null)\n\t\t\treturn;\n\n\t\tUri uri = TransportFactory.getUri(protocol, quickConnectString);\n\t\tif (uri == null) {\n\t\t\t// If the URI was invalid, null out the associated fields.\n\t\t\tmHost.setProtocol(protocol);\n\t\t\tmHost.setUsername(null);\n\t\t\tmHost.setHostname(null);\n\t\t\tmHost.setNickname(null);\n\t\t\tmHost.setPort(TransportFactory.getTransport(protocol).getDefaultPort());\n\t\t\treturn;\n\t\t}\n\n\t\tHostBean host = TransportFactory.getTransport(protocol).createHost(uri);\n\t\tmHost.setProtocol(host.getProtocol());\n\t\tmHost.setUsername(host.getUsername());\n\t\tmHost.setHostname(host.getHostname());\n\t\tmHost.setNickname(host.getNickname());\n\t\tmHost.setPort(host.getPort());\n\t}\n\n\tpublic interface Listener {\n\t\tpublic void onHostUpdated(HostBean host);\n\t}\n\n\tprivate class HostTextFieldWatcher implements TextWatcher {\n\n\t\tprivate final String mFieldType;\n\n\t\tpublic HostTextFieldWatcher(String fieldType) {\n\t\t\tmFieldType = fieldType;\n\t\t}\n\n\t\t@Override\n\t\tpublic void beforeTextChanged(CharSequence s, int start, int count, int after) {}\n\n\t\t@Override\n\t\tpublic void onTextChanged(CharSequence s, int start, int before, int count) {}\n\n\t\t@Override\n\t\tpublic void afterTextChanged(Editable s) {\n\t\t\tString text = s.toString();\n\n\t\t\tif (HostDatabase.FIELD_HOST_USERNAME.equals(mFieldType)) {\n\t\t\t\tmHost.setUsername(text);\n\t\t\t} else if (HostDatabase.FIELD_HOST_HOSTNAME.equals(mFieldType)) {\n\t\t\t\tmHost.setHostname(text);\n\t\t\t} else if (HostDatabase.FIELD_HOST_PORT.equals(mFieldType)) {\n\t\t\t\ttry {\n\t\t\t\t\tmHost.setPort(Integer.parseInt(text));\n\t\t\t\t} catch (NumberFormatException e) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else if (HostDatabase.FIELD_HOST_NICKNAME.equals(mFieldType)) {\n\t\t\t\tmHost.setNickname(text);\n\t\t\t} else {\n\t\t\t\tthrow new RuntimeException(\"Invalid field type.\");\n\t\t\t}\n\n\t\t\tif (isUriRelatedField(mFieldType)) {\n\t\t\t\tmNicknameField.setText(mHost.toString());\n\t\t\t\tmHost.setNickname(mHost.toString());\n\n\t\t\t\tif (!mUriFieldEditInProgress) {\n\t\t\t\t\tmUriFieldEditInProgress = true;\n\t\t\t\t\tmQuickConnectField.setText(mHost.toString());\n\t\t\t\t\tmUriFieldEditInProgress = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean isUriRelatedField(String fieldType) {\n\t\t\treturn HostDatabase.FIELD_HOST_USERNAME.equals(fieldType) ||\n\t\t\t\t\tHostDatabase.FIELD_HOST_HOSTNAME.equals(fieldType) ||\n\t\t\t\t\tHostDatabase.FIELD_HOST_PORT.equals(fieldType);\n\t\t}\n\t}\n}\n","Method after Refactoring":"/*\n * ConnectBot: simple, powerful, open-source SSH client for Android\n * Copyright 2015 Kenny Root, Jeffrey Sharkey\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.connectbot;\n\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.res.TypedArray;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Parcelable;\nimport android.support.design.widget.TextInputLayout;\nimport android.support.v4.app.Fragment;\nimport android.support.v7.widget.AppCompatCheckBox;\nimport android.support.v7.widget.SwitchCompat;\nimport android.text.Editable;\nimport android.text.TextWatcher;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.AdapterView;\nimport android.widget.ArrayAdapter;\nimport android.widget.CompoundButton;\nimport android.widget.EditText;\nimport android.widget.ImageButton;\nimport android.widget.SeekBar;\nimport android.widget.Spinner;\nimport android.widget.Switch;\nimport android.widget.TextView;\n\nimport org.connectbot.bean.HostBean;\nimport org.connectbot.transport.SSH;\nimport org.connectbot.transport.Telnet;\nimport org.connectbot.transport.TransportFactory;\nimport org.connectbot.util.HostDatabase;\n\npublic class HostEditorFragment extends Fragment {\n\n\tprivate static final String ARG_EXISTING_HOST = \"existingHost\";\n\tprivate static final String ARG_IS_EXPANDED = \"isExpanded\";\n\tprivate static final String ARG_QUICKCONNECT_STRING = \"quickConnectString\";\n\n\tprivate static final int MINIMUM_FONT_SIZE = 8;\n\n\t// The host being edited.\n\tprivate HostBean mHost;\n\t\n\t// Whether the host is being created for the first time (as opposed to an existing one being\n\t// edited).\n\tprivate boolean mIsCreating;\n\n\t// The listener for changes to this host.\n\tprivate Listener mListener;\n\n\t// Whether the URI parts subsection is expanded.\n\tprivate boolean mIsUriEditorExpanded = false;\n\n\t// Whether a URI text edit is in progress. When the quick-connect field is being edited, changes\n\t// automatically propagate to the URI part fields; likewise, when the URI part fields are\n\t// edited, changes are propagated to the quick-connect field. This boolean safeguards against\n\t// infinite loops which can be caused by one field changing the other field, which changes the\n\t// first field, etc.\n\tprivate boolean mUriFieldEditInProgress = false;\n\n\t// Values for the colors displayed in the color Spinner. These are not necessarily the same as\n\t// the text in the Spinner because the text is localized while these values are not.\n\tprivate TypedArray mColorValues;\n\n\t// Likewise, but for SSH auth agent values.\n\tprivate TypedArray mSshAuthValues;\n\n\t// Likewise, but for DEL key values.\n\tprivate TypedArray mDelKeyValues;\n\n\tprivate Spinner mTransportSpinner;\n\tprivate TextInputLayout mQuickConnectContainer;\n\tprivate EditText mQuickConnectField;\n\tprivate ImageButton mExpandCollapseButton;\n\tprivate View mUriPartsContainer;\n\tprivate View mUsernameContainer;\n\tprivate EditText mUsernameField;\n\tprivate View mHostnameContainer;\n\tprivate EditText mHostnameField;\n\tprivate View mPortContainer;\n\tprivate EditText mPortField;\n\tprivate EditText mNicknameField;\n\tprivate Spinner mColorSelector;\n\tprivate TextView mFontSizeText;\n\tprivate SeekBar mFontSizeSeekBar;\n\tprivate Spinner mPubkeySpinner;\n\tprivate View mUseSshConfirmationContainer;\n\tprivate SwitchCompat mUseSshAuthSwitch;\n\tprivate AppCompatCheckBox mSshAuthConfirmationCheckbox;\n\tprivate SwitchCompat mCompressionSwitch;\n\tprivate SwitchCompat mStartShellSwitch;\n\tprivate SwitchCompat mStayConnectedSwitch;\n\tprivate SwitchCompat mCloseOnDisconnectSwitch;\n\tprivate EditText mPostLoginAutomationField;\n\tprivate Spinner mDelKeySpinner;\n\tprivate Spinner mEncodingSpinner;\n\n\tpublic static HostEditorFragment newInstance(HostBean existingHost) {\n\t\tHostEditorFragment fragment = new HostEditorFragment();\n\t\tBundle args = new Bundle();\n\t\tif (existingHost != null) {\n\t\t\targs.putParcelable(ARG_EXISTING_HOST, existingHost.getValues());\n\t\t}\n\t\tfragment.setArguments(args);\n\t\treturn fragment;\n\t}\n\n\tpublic HostEditorFragment() {\n\t}\n\n\t@Override\n\tpublic void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\n\t\tBundle bundle = savedInstanceState == null ? getArguments() : savedInstanceState;\n\n\t\tParcelable existingHostParcelable = bundle.getParcelable(ARG_EXISTING_HOST);\n\t\tmIsCreating = existingHostParcelable == null;\n\t\tif (existingHostParcelable != null) {\n\t\t\tmHost = HostBean.fromContentValues((ContentValues) existingHostParcelable);\n\t\t} else {\n\t\t\tmHost = new HostBean();\n\t\t}\n\n\t\tmIsUriEditorExpanded = bundle.getBoolean(ARG_IS_EXPANDED);\n\t}\n\n\t@Override\n\tpublic View onCreateView(LayoutInflater inflater, ViewGroup container,\n\t\t\tBundle savedInstanceState) {\n\t\tView view = inflater.inflate(R.layout.fragment_host_editor, container, false);\n\n\t\tmTransportSpinner = (Spinner) view.findViewById(R.id.transport_selector);\n\t\tString[] transportNames = TransportFactory.getTransportNames();\n\t\tArrayAdapter<String> transportSelection = new ArrayAdapter<>(\n\t\t\t\tgetActivity(), android.R.layout.simple_spinner_item, transportNames);\n\t\ttransportSelection.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);\n\t\tmTransportSpinner.setAdapter(transportSelection);\n\t\tfor (int i = 0; i < transportNames.length; i++) {\n\t\t\tif (transportNames.equals(mHost.getProtocol())) {\n\t\t\t\tmTransportSpinner.setSelection(i);\n\t\t\t}\n\t\t}\n\t\tmTransportSpinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {\n\t\t\t@Override\n\t\t\tpublic void onItemSelected(AdapterView<?> parent, View view, int position, long id) {\n\t\t\t\tString protocol = (String) mTransportSpinner.getSelectedItem();\n\t\t\t\tif (protocol == null) {\n\t\t\t\t\t// During initialization, protocol can be null before the list of dropdown items\n\t\t\t\t\t// has been generated. Return early in that case.\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tmHost.setProtocol(protocol);\n\t\t\t\tmHost.setPort(TransportFactory.getTransport(protocol).getDefaultPort());\n\n\t\t\t\tmQuickConnectContainer.setHint(\n\t\t\t\t\t\tTransportFactory.getFormatHint(protocol, getActivity()));\n\n\t\t\t\t// Different protocols have different field types, so show only the fields needed.\n\t\t\t\tif (SSH.getProtocolName().equals(protocol)) {\n\t\t\t\t\tmUsernameContainer.setVisibility(View.VISIBLE);\n\t\t\t\t\tmHostnameContainer.setVisibility(View.VISIBLE);\n\t\t\t\t\tmPortContainer.setVisibility(View.VISIBLE);\n\t\t\t\t\tmExpandCollapseButton.setVisibility(View.VISIBLE);\n\t\t\t\t} else if (Telnet.getProtocolName().equals(protocol)) {\n\t\t\t\t\tmUsernameContainer.setVisibility(View.GONE);\n\t\t\t\t\tmHostnameContainer.setVisibility(View.VISIBLE);\n\t\t\t\t\tmPortContainer.setVisibility(View.VISIBLE);\n\t\t\t\t\tmExpandCollapseButton.setVisibility(View.VISIBLE);\n\t\t\t\t} else {\n\t\t\t\t\t// Local protocol has only one field, so no need to show the URI parts\n\t\t\t\t\t// container.\n\t\t\t\t\tsetUriPartsContainerExpanded(false);\n\t\t\t\t\tmExpandCollapseButton.setVisibility(View.INVISIBLE);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void onNothingSelected(AdapterView<?> parent) {\n\t\t\t}\n\t\t});\n\n\t\tmQuickConnectContainer =\n\t\t\t\t(TextInputLayout) view.findViewById(R.id.quickconnect_field_container);\n\n\t\tmQuickConnectField = (EditText) view.findViewById(R.id.quickconnect_field);\n\t\tString oldQuickConnect = savedInstanceState == null ?\n\t\t\t\tnull : savedInstanceState.getString(ARG_QUICKCONNECT_STRING);\n\t\tmQuickConnectField.setText(oldQuickConnect == null ? mHost.toString() : oldQuickConnect);\n\t\tmQuickConnectField.addTextChangedListener(new TextWatcher() {\n\t\t\t@Override\n\t\t\tpublic void beforeTextChanged(CharSequence s, int start, int count, int after) {}\n\n\t\t\t@Override\n\t\t\tpublic void onTextChanged(CharSequence s, int start, int before, int count) {}\n\n\t\t\t@Override\n\t\t\tpublic void afterTextChanged(Editable s) {\n\t\t\t\tif (mTransportSpinner.getSelectedItem() == null) {\n\t\t\t\t\t// During initialization, protocol can be null before the list of dropdown items\n\t\t\t\t\t// has been generated. Return early in that case.\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (!mUriFieldEditInProgress) {\n\t\t\t\t\tapplyQuickConnectString(\n\t\t\t\t\t\t\ts.toString(), (String) mTransportSpinner.getSelectedItem());\n\n\t\t\t\t\tmUriFieldEditInProgress = true;\n\t\t\t\t\tmUsernameField.setText(mHost.getUsername());\n\t\t\t\t\tmHostnameField.setText(mHost.getHostname());\n\t\t\t\t\tmPortField.setText(Integer.toString(mHost.getPort()));\n\t\t\t\t\tmUriFieldEditInProgress = false;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tmExpandCollapseButton = (ImageButton) view.findViewById(R.id.expand_collapse_button);\n\t\tmExpandCollapseButton.setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tsetUriPartsContainerExpanded(!mIsUriEditorExpanded);\n\t\t\t}\n\t\t});\n\n\t\tmUriPartsContainer = view.findViewById(R.id.uri_parts_container);\n\n\t\tmUsernameContainer = view.findViewById(R.id.username_field_container);\n\t\tmUsernameField = (EditText) view.findViewById(R.id.username_edit_text);\n\t\tmUsernameField.setText(mHost.getUsername());\n\t\tmUsernameField.addTextChangedListener(new HostTextFieldWatcher(HostDatabase.FIELD_HOST_USERNAME));\n\n\t\tmHostnameContainer = view.findViewById(R.id.hostname_field_container);\n\t\tmHostnameField = (EditText) view.findViewById(R.id.hostname_edit_text);\n\t\tmHostnameField.setText(mHost.getHostname());\n\t\tmHostnameField.addTextChangedListener(new HostTextFieldWatcher(HostDatabase.FIELD_HOST_HOSTNAME));\n\n\t\tmPortContainer = view.findViewById(R.id.port_field_container);\n\t\tmPortField = (EditText) view.findViewById(R.id.port_edit_text);\n\t\tmPortField.setText(Integer.toString(mHost.getPort()));\n\t\tmPortField.addTextChangedListener(new HostTextFieldWatcher(HostDatabase.FIELD_HOST_PORT));\n\n\t\tmNicknameField = (EditText) view.findViewById(R.id.nickname_field);\n\t\tmNicknameField.setText(mHost.getNickname());\n\t\tmNicknameField.addTextChangedListener(\n\t\t\t\tnew HostTextFieldWatcher(HostDatabase.FIELD_HOST_NICKNAME));\n\n\t\tmColorSelector = (Spinner) view.findViewById(R.id.color_selector);\n\t\tfor (int i = 0; i < mColorValues.getIndexCount(); i++) {\n\t\t\tif (mHost.getColor().equals(mColorValues.getString(i))) {\n\t\t\t\tmColorSelector.setSelection(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmColorSelector.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {\n\t\t\t@Override\n\t\t\tpublic void onItemSelected(AdapterView<?> parent, View view, int position, long id) {\n\t\t\t\tmHost.setColor(mColorValues.getString(position));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void onNothingSelected(AdapterView<?> parent) {\n\t\t\t}\n\t\t});\n\n\t\tmFontSizeText = (TextView) view.findViewById(R.id.font_size_text);\n\t\tmFontSizeSeekBar = (SeekBar) view.findViewById(R.id.font_size_bar);\n\t\tmFontSizeSeekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {\n\t\t\t@Override\n\t\t\tpublic void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {\n\t\t\t\tint fontSize = MINIMUM_FONT_SIZE + progress;\n\t\t\t\tmHost.setFontSize(fontSize);\n\t\t\t\tmFontSizeText.setText(Integer.toString(fontSize));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void onStartTrackingTouch(SeekBar seekBar) {\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void onStopTrackingTouch(SeekBar seekBar) {\n\t\t\t}\n\t\t});\n\t\tmFontSizeSeekBar.setProgress(mHost.getFontSize() - MINIMUM_FONT_SIZE);\n\n\t\tmPubkeySpinner = (Spinner) view.findViewById(R.id.pubkey_spinner);\n\t\t// TODO: Set up spinner. This requires passing pubkey data into the fragment from the\n\t\t// activity and will be part of an upcoming PR.\n\n\t\tmUseSshConfirmationContainer = view.findViewById(R.id.ssh_confirmation_container);\n\t\tmUseSshAuthSwitch = (SwitchCompat) view.findViewById(R.id.use_ssh_auth_switch);\n\t\tmSshAuthConfirmationCheckbox =\n\t\t\t\t(AppCompatCheckBox) view.findViewById(R.id.ssh_auth_confirmation_checkbox);\n\t\tCompoundButton.OnCheckedChangeListener authSwitchListener = new CompoundButton.OnCheckedChangeListener() {\n\t\t\t@Override\n\t\t\tpublic void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {\n\t\t\t\tmUseSshConfirmationContainer.setVisibility(\n\t\t\t\t\t\tmUseSshAuthSwitch.isChecked() ? View.VISIBLE : View.GONE);\n\t\t\t\tif (mUseSshAuthSwitch.isChecked()) {\n\t\t\t\t\tmHost.setUseAuthAgent(\n\t\t\t\t\t\t\tmSshAuthConfirmationCheckbox.isChecked() ?\n\t\t\t\t\t\t\t\t\t/* require confirmation */ mSshAuthValues.getString(1) :\n\t\t\t\t\t\t\t\t\t/* don't require confirmation */ mSshAuthValues.getString(2));\n\t\t\t\t} else {\n\t\t\t\t\tmHost.setUseAuthAgent(/* don't use */ mSshAuthValues.getString(0));\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tmUseSshAuthSwitch.setOnCheckedChangeListener(authSwitchListener);\n\t\tmSshAuthConfirmationCheckbox.setOnCheckedChangeListener(authSwitchListener);\n\t\tif (mHost.getUseAuthAgent() == null ||\n\t\t\t\tmHost.getUseAuthAgent().equals(mSshAuthValues.getString(0))) {\n\t\t\tmUseSshAuthSwitch.setChecked(false);\n\t\t\tmSshAuthConfirmationCheckbox.setChecked(false);\n\t\t} else {\n\t\t\tmUseSshAuthSwitch.setChecked(true);\n\t\t\tmSshAuthConfirmationCheckbox.setChecked(\n\t\t\t\t\tmHost.getUseAuthAgent().equals(mSshAuthValues.getString(1)));\n\t\t}\n\n\t\tmCompressionSwitch = (SwitchCompat) view.findViewById(R.id.compression_switch);\n\t\tmCompressionSwitch.setChecked(mHost.getCompression());\n\t\tmCompressionSwitch.setOnCheckedChangeListener(\n\t\t\t\tnew HostSwitchWatcher(HostDatabase.FIELD_HOST_COMPRESSION));\n\n\t\tmStartShellSwitch = (SwitchCompat) view.findViewById(R.id.start_shell_switch);\n\t\tmStartShellSwitch.setChecked(mHost.getWantSession());\n\t\tmStartShellSwitch.setOnCheckedChangeListener(\n\t\t\t\tnew HostSwitchWatcher(HostDatabase.FIELD_HOST_WANTSESSION));\n\n\t\tmStayConnectedSwitch = (SwitchCompat) view.findViewById(R.id.stay_connected_switch);\n\t\tmStayConnectedSwitch.setChecked(mHost.getStayConnected());\n\t\tmStayConnectedSwitch.setOnCheckedChangeListener(\n\t\t\t\tnew HostSwitchWatcher(HostDatabase.FIELD_HOST_STAYCONNECTED));\n\n\t\tmCloseOnDisconnectSwitch = (SwitchCompat) view.findViewById(R.id.close_on_disconnect_switch);\n\t\tmCloseOnDisconnectSwitch.setChecked(mHost.getQuickDisconnect());\n\t\tmCloseOnDisconnectSwitch.setOnCheckedChangeListener(\n\t\t\t\tnew HostSwitchWatcher(HostDatabase.FIELD_HOST_QUICKDISCONNECT));\n\n\t\tmPostLoginAutomationField = (EditText) view.findViewById(R.id.post_login_automation_field);\n\t\tmPostLoginAutomationField.setText(mHost.getPostLogin());\n\t\tmPostLoginAutomationField.addTextChangedListener(\n\t\t\t\tnew HostTextFieldWatcher(HostDatabase.FIELD_HOST_POSTLOGIN));\n\n\t\tmDelKeySpinner = (Spinner) view.findViewById(R.id.del_key_spinner);\n\t\tfor (int i = 0; i < mDelKeyValues.getIndexCount(); i++) {\n\t\t\tif (mHost.getDelKey().equals(mDelKeyValues.getString(i))) {\n\t\t\t\tmDelKeySpinner.setSelection(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmDelKeySpinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {\n\t\t\t@Override\n\t\t\tpublic void onItemSelected(AdapterView<?> parent, View view, int position, long id) {\n\t\t\t\tmHost.setDelKey(mDelKeyValues.getString(position));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void onNothingSelected(AdapterView<?> parent) {\n\t\t\t}\n\t\t});\n\n\t\tmEncodingSpinner = (Spinner) view.findViewById(R.id.encoding_spinner);\n\t\t// TODO: Set up spinner. This requires passing pubkey data into the fragment from the\n\t\t// activity and will be part of an upcoming PR.\n\n\t\tsetUriPartsContainerExpanded(mIsUriEditorExpanded);\n\n\t\treturn view;\n\t}\n\n\t@Override\n\tpublic void onAttach(Context context) {\n\t\tsuper.onAttach(context);\n\t\ttry {\n\t\t\tmListener = (Listener) context;\n\t\t} catch (ClassCastException e) {\n\t\t\tthrow new ClassCastException(context.toString() + \" must implement Listener\");\n\t\t}\n\n\t\t// Now that the fragment is attached to an Activity, fetch the arrays from the attached\n\t\t// Activity's resources.\n\t\tmColorValues = getResources().obtainTypedArray(R.array.list_color_values);\n\t\tmSshAuthValues = getResources().obtainTypedArray(R.array.list_authagent_values);\n\t\tmDelKeyValues = getResources().obtainTypedArray(R.array.list_delkey_values);\n\t}\n\n\t@Override\n\tpublic void onDetach() {\n\t\tsuper.onDetach();\n\t\tmListener = null;\n\t\tmColorValues.recycle();\n\t\tmSshAuthValues.recycle();\n\t\tmDelKeyValues.recycle();\n\t}\n\n\t@Override\n\tpublic void onSaveInstanceState(Bundle savedInstanceState) {\n\t\tsuper.onSaveInstanceState(savedInstanceState);\n\n\t\tsavedInstanceState.putParcelable(ARG_EXISTING_HOST, mHost.getValues());\n\t\tsavedInstanceState.putBoolean(ARG_IS_EXPANDED, mIsUriEditorExpanded);\n\t\tsavedInstanceState.putString(\n\t\t\t\tARG_QUICKCONNECT_STRING, mQuickConnectField.getText().toString());\n\t}\n\n\tprivate void setUriPartsContainerExpanded(boolean expanded) {\n\t\tmIsUriEditorExpanded = expanded;\n\n\t\tif (mIsUriEditorExpanded) {\n\t\t\tmExpandCollapseButton.setImageResource(R.drawable.ic_expand_less);\n\t\t\tmUriPartsContainer.setVisibility(View.VISIBLE);\n\t\t} else {\n\t\t\tmExpandCollapseButton.setImageResource(R.drawable.ic_expand_more);\n\t\t\tmUriPartsContainer.setVisibility(View.GONE);\n\t\t}\n\t}\n\n\t/**\n\t * Applies the quick-connect URI entered in the field by copying its URI parts to mHost's\n\t * fields.\n\t * @param quickConnectString The URI entered in the quick-connect field.\n\t * @param protocol The protocol for this connection.\n\t */\n\tprivate void applyQuickConnectString(String quickConnectString, String protocol) {\n\t\tif (quickConnectString == null || protocol == null)\n\t\t\treturn;\n\n\t\tUri uri = TransportFactory.getUri(protocol, quickConnectString);\n\t\tif (uri == null) {\n\t\t\t// If the URI was invalid, null out the associated fields.\n\t\t\tmHost.setProtocol(protocol);\n\t\t\tmHost.setUsername(null);\n\t\t\tmHost.setHostname(null);\n\t\t\tmHost.setNickname(null);\n\t\t\tmHost.setPort(TransportFactory.getTransport(protocol).getDefaultPort());\n\t\t\treturn;\n\t\t}\n\n\t\tHostBean host = TransportFactory.getTransport(protocol).createHost(uri);\n\t\tmHost.setProtocol(host.getProtocol());\n\t\tmHost.setUsername(host.getUsername());\n\t\tmHost.setHostname(host.getHostname());\n\t\tmHost.setNickname(host.getNickname());\n\t\tmHost.setPort(host.getPort());\n\t}\n\n\tpublic interface Listener {\n\t\tpublic void onHostUpdated(HostBean host);\n\t}\n\n\tprivate class HostTextFieldWatcher implements TextWatcher {\n\n\t\tprivate final String mFieldType;\n\n\t\tpublic HostTextFieldWatcher(String fieldType) {\n\t\t\tmFieldType = fieldType;\n\t\t}\n\n\t\t@Override\n\t\tpublic void beforeTextChanged(CharSequence s, int start, int count, int after) {}\n\n\t\t@Override\n\t\tpublic void onTextChanged(CharSequence s, int start, int before, int count) {}\n\n\t\t@Override\n\t\tpublic void afterTextChanged(Editable s) {\n\t\t\tString text = s.toString();\n\n\t\t\tif (HostDatabase.FIELD_HOST_USERNAME.equals(mFieldType)) {\n\t\t\t\tmHost.setUsername(text);\n\t\t\t} else if (HostDatabase.FIELD_HOST_HOSTNAME.equals(mFieldType)) {\n\t\t\t\tmHost.setHostname(text);\n\t\t\t} else if (HostDatabase.FIELD_HOST_PORT.equals(mFieldType)) {\n\t\t\t\ttry {\n\t\t\t\t\tmHost.setPort(Integer.parseInt(text));\n\t\t\t\t} catch (NumberFormatException e) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else if (HostDatabase.FIELD_HOST_NICKNAME.equals(mFieldType)) {\n\t\t\t\tmHost.setNickname(text);\n\t\t\t} else if (HostDatabase.FIELD_HOST_POSTLOGIN.equals(mFieldType)) {\n\t\t\t\tmHost.setPostLogin(text);\n\t\t\t} else {\n\t\t\t\tthrow new RuntimeException(\"Invalid field type.\");\n\t\t\t}\n\n\t\t\tif (isUriRelatedField(mFieldType)) {\n\t\t\t\tmNicknameField.setText(mHost.toString());\n\t\t\t\tmHost.setNickname(mHost.toString());\n\n\t\t\t\tif (!mUriFieldEditInProgress) {\n\t\t\t\t\tmUriFieldEditInProgress = true;\n\t\t\t\t\tmQuickConnectField.setText(mHost.toString());\n\t\t\t\t\tmUriFieldEditInProgress = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean isUriRelatedField(String fieldType) {\n\t\t\treturn HostDatabase.FIELD_HOST_USERNAME.equals(fieldType) ||\n\t\t\t\t\tHostDatabase.FIELD_HOST_HOSTNAME.equals(fieldType) ||\n\t\t\t\t\tHostDatabase.FIELD_HOST_PORT.equals(fieldType);\n\t\t}\n\t}\n\n\tprivate class HostSwitchWatcher implements CompoundButton.OnCheckedChangeListener {\n\n\t\tprivate final String mFieldType;\n\n\t\tpublic HostSwitchWatcher(String fieldType) {\n\t\t\tmFieldType = fieldType;\n\t\t}\n\n\t\t@Override\n\t\tpublic void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {\n\t\t\tif (HostDatabase.FIELD_HOST_COMPRESSION.equals(mFieldType)) {\n\t\t\t\tmHost.setCompression(isChecked);\n\t\t\t} else if (HostDatabase.FIELD_HOST_WANTSESSION.equals(mFieldType)) {\n\t\t\t\tmHost.setWantSession(isChecked);\n\t\t\t} else if (HostDatabase.FIELD_HOST_STAYCONNECTED.equals(mFieldType)) {\n\t\t\t\tmHost.setStayConnected(isChecked);\n\t\t\t} else if (HostDatabase.FIELD_HOST_QUICKDISCONNECT.equals(mFieldType)) {\n\t\t\t\tmHost.setQuickDisconnect(isChecked);\n\t\t\t} else {\n\t\t\t\tthrow new RuntimeException(\"Invalid field type.\");\n\t\t\t}\n\t\t}\n\t}\n}\n","lineNo":152}
{"Smelly Sample":"package org.connectbot;\n\nimport org.connectbot.bean.HostBean;\nimport org.connectbot.util.HostDatabase;\nimport org.hamcrest.Description;\nimport org.hamcrest.Matcher;\nimport org.hamcrest.TypeSafeMatcher;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\n\nimport android.content.Intent;\nimport android.content.res.Resources;\nimport android.support.annotation.ColorInt;\nimport android.support.annotation.ColorRes;\nimport android.support.annotation.NonNull;\nimport android.support.annotation.StringRes;\nimport android.support.test.InstrumentationRegistry;\nimport android.support.test.espresso.intent.Intents;\nimport android.support.test.espresso.matcher.BoundedMatcher;\nimport android.support.test.rule.ActivityTestRule;\nimport android.support.test.runner.AndroidJUnit4;\nimport android.view.View;\nimport android.widget.ImageView;\nimport android.widget.TextView;\n\nimport static android.support.test.espresso.Espresso.onData;\nimport static android.support.test.espresso.Espresso.onView;\nimport static android.support.test.espresso.action.ViewActions.click;\nimport static android.support.test.espresso.action.ViewActions.closeSoftKeyboard;\nimport static android.support.test.espresso.action.ViewActions.longClick;\nimport static android.support.test.espresso.action.ViewActions.pressBack;\nimport static android.support.test.espresso.action.ViewActions.pressImeActionButton;\nimport static android.support.test.espresso.action.ViewActions.pressMenuKey;\nimport static android.support.test.espresso.action.ViewActions.typeText;\nimport static android.support.test.espresso.assertion.ViewAssertions.doesNotExist;\nimport static android.support.test.espresso.assertion.ViewAssertions.matches;\nimport static android.support.test.espresso.intent.Intents.intended;\nimport static android.support.test.espresso.intent.matcher.IntentMatchers.hasComponent;\nimport static android.support.test.espresso.matcher.ViewMatchers.hasDescendant;\nimport static android.support.test.espresso.matcher.ViewMatchers.isDisplayed;\nimport static android.support.test.espresso.matcher.ViewMatchers.withId;\nimport static android.support.test.espresso.matcher.ViewMatchers.withText;\nimport static org.connectbot.ConnectbotMatchers.hostConnected;\nimport static org.connectbot.ConnectbotMatchers.hostDisconnected;\nimport static org.connectbot.ConnectbotMatchers.withHostNickname;\nimport static org.connectbot.ConnectbotMatchers.withTextColor;\nimport static org.hamcrest.CoreMatchers.allOf;\nimport static org.hamcrest.CoreMatchers.instanceOf;\nimport static org.hamcrest.CoreMatchers.is;\n\n@RunWith(AndroidJUnit4.class)\npublic class StartupTest {\n\t@Rule\n\tpublic final ActivityTestRule<HostListActivity> mActivityRule = new ActivityTestRule<>(\n\t\t\tHostListActivity.class, false, false);\n\n\t@Before\n\tpublic void makeDatabasePristine() {\n\t\tHostDatabase.resetInMemoryInstance(InstrumentationRegistry.getTargetContext());\n\n\t\tmActivityRule.launchActivity(new Intent());\n\t}\n\n\t@Test\n\tpublic void localConnectionDisconnectFromHostList() {\n\t\tstartNewLocalConnection();\n\n\t\tonView(withId(R.id.console_flip)).perform(closeSoftKeyboard(), pressBack());\n\n\t\t// Make sure we're still connected.\n\t\tonData(withHostNickname(\"Local\")).inAdapterView(withId(android.R.id.list))\n\t\t\t\t.check(matches(hostConnected()))\n\t\t\t\t.perform(longClick());\n\n\t\t// Click on the disconnect context menu item.\n\t\tonView(withText(R.string.list_host_disconnect)).check(matches(isDisplayed())).perform(click());\n\n\t\t// Now make sure we're disconnected.\n\t\tonData(withHostNickname(\"Local\")).inAdapterView(withId(android.R.id.list))\n\t\t\t\t.check(matches(hostDisconnected()));\n\t}\n\n\t@Test\n\tpublic void localConnectionDisconnectConsoleActivity() {\n\t\tstartNewLocalConnection();\n\n\t\tonView(withId(R.id.console_flip)).perform(pressMenuKey());\n\n\t\t// Click on the disconnect context menu item.\n\t\tonView(withText(R.string.list_host_disconnect)).check(matches(isDisplayed())).perform(click());\n\n\t\t// Now make sure we're disconnected.\n\t\tonData(withHostNickname(\"Local\")).inAdapterView(withId(android.R.id.list))\n\t\t\t\t.check(matches(hostDisconnected()));\n\t}\n\n\t@Test\n\tpublic void localConnectionCanDelete() {\n\t\tstartNewLocalConnectionAndGoBack(\"Local\");\n\t\tonData(withHostNickname(\"Local\")).inAdapterView(withId(android.R.id.list))\n\t\t\t\t.perform(longClick());\n\t\tonView(withText(R.string.list_host_delete)).perform(click());\n\t\tonView(withText(R.string.delete_pos)).perform(click());\n\t}\n\n\t@Test\n\tpublic void localConnectionCanChangeToRed() throws Exception {\n\t\tstartNewLocalConnectionAndGoBack(\"Local1\");\n\t\tchangeColor(\"Local1\", R.color.red, R.string.color_red);\n\t}\n\n\t/**\n\t * Changes the color of {@code hostName} from the {@link HostListActivity} to the {@code color}\n\t * from {@code R.color.[color]} with identifying {@code stringForColor} from\n\t * {@code R.string.[colorname]}.\n\t */\n\tprivate void changeColor(String hostName, @ColorRes int color, @StringRes int stringForColor) {\n\t\t// Bring up the context menu.\n\t\tonData(withHostNickname(hostName)).inAdapterView(withId(android.R.id.list))\n\t\t\t\t.perform(longClick());\n\t\tonView(withText(R.string.list_host_edit)).perform(click());\n\n\t\t// Click on the color category and select the desired one.\n\t\tonView(withText(R.string.hostpref_color_title)).perform(click());\n\t\tonView(withText(stringForColor)).perform(click());\n\n\t\t// Go back to the host list.\n\t\tonView(withText(R.string.hostpref_color_title)).perform(pressBack());\n\n\t\tResources res = InstrumentationRegistry.getTargetContext().getResources();\n\t\tonData(withHostNickname(hostName)).inAdapterView(withId(android.R.id.list))\n\t\t\t\t.check(matches(hasDescendant(allOf(withId(android.R.id.text1),\n\t\t\t\t\t\twithTextColor(res.getColor(color))))));\n\t}\n\n\tprivate void startNewLocalConnectionAndGoBack(String name) {\n\t\tstartNewLocalConnection(name);\n\t\tonView(withId(R.id.console_flip)).perform(closeSoftKeyboard(), pressBack());\n\t\tonData(withHostNickname(name)).inAdapterView(withId(android.R.id.list))\n\t\t\t\t.check(matches(isDisplayed()));\n\t}\n\n\tprivate void startNewLocalConnection() {\n\t\tstartNewLocalConnection(\"Local\");\n\t}\n\n\tprivate void startNewLocalConnection(String name) {\n\t\tonView(withId(R.id.transport_selection)).perform(click());\n\t\tonData(allOf(is(instanceOf(String.class)), is(\"local\"))).perform(click());\n\t\tonView(withId(R.id.front_quickconnect)).perform(typeText(name));\n\n\t\tIntents.init();\n\t\ttry {\n\t\t\tonView(withId(R.id.front_quickconnect)).perform(pressImeActionButton());\n\t\t\tintended(hasComponent(ConsoleActivity.class.getName()));\n\t\t} finally {\n\t\t\tIntents.release();\n\t\t}\n\n\t\tonView(withId(R.id.console_flip)).check(matches(\n\t\t\t\thasDescendant(allOf(isDisplayed(), withId(R.id.terminal_view)))));\n\t}\n}\n","Method after Refactoring":"package org.connectbot;\n\nimport org.connectbot.util.HostDatabase;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\n\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.res.Resources;\nimport android.support.annotation.ColorRes;\nimport android.support.annotation.StringRes;\nimport android.support.test.InstrumentationRegistry;\nimport android.support.test.espresso.intent.Intents;\nimport android.support.test.rule.ActivityTestRule;\nimport android.support.test.runner.AndroidJUnit4;\n\nimport static android.support.test.espresso.Espresso.onData;\nimport static android.support.test.espresso.Espresso.onView;\nimport static android.support.test.espresso.action.ViewActions.click;\nimport static android.support.test.espresso.action.ViewActions.closeSoftKeyboard;\nimport static android.support.test.espresso.action.ViewActions.longClick;\nimport static android.support.test.espresso.action.ViewActions.pressBack;\nimport static android.support.test.espresso.action.ViewActions.pressImeActionButton;\nimport static android.support.test.espresso.action.ViewActions.pressMenuKey;\nimport static android.support.test.espresso.action.ViewActions.typeText;\nimport static android.support.test.espresso.assertion.ViewAssertions.matches;\nimport static android.support.test.espresso.intent.Intents.intended;\nimport static android.support.test.espresso.intent.matcher.IntentMatchers.hasComponent;\nimport static android.support.test.espresso.matcher.ViewMatchers.hasDescendant;\nimport static android.support.test.espresso.matcher.ViewMatchers.isDisplayed;\nimport static android.support.test.espresso.matcher.ViewMatchers.withId;\nimport static android.support.test.espresso.matcher.ViewMatchers.withText;\nimport static org.connectbot.ConnectbotMatchers.hostConnected;\nimport static org.connectbot.ConnectbotMatchers.hostDisconnected;\nimport static org.connectbot.ConnectbotMatchers.withHostNickname;\nimport static org.connectbot.ConnectbotMatchers.withTextColor;\nimport static org.hamcrest.CoreMatchers.allOf;\nimport static org.hamcrest.CoreMatchers.instanceOf;\nimport static org.hamcrest.CoreMatchers.is;\n\n@RunWith(AndroidJUnit4.class)\npublic class StartupTest {\n\t@Rule\n\tpublic final ActivityTestRule<HostListActivity> mActivityRule = new ActivityTestRule<>(\n\t\t\tHostListActivity.class, false, false);\n\n\t@Before\n\tpublic void makeDatabasePristine() {\n\t\tContext testContext = InstrumentationRegistry.getTargetContext();\n\t\tHostDatabase.resetInMemoryInstance(testContext);\n\n\t\tmActivityRule.launchActivity(new Intent());\n\t}\n\n\t@Test\n\tpublic void localConnectionDisconnectFromHostList() {\n\t\tstartNewLocalConnection();\n\n\t\tonView(withId(R.id.console_flip)).perform(closeSoftKeyboard(), pressBack());\n\n\t\t// Make sure we're still connected.\n\t\tonData(withHostNickname(\"Local\")).inAdapterView(withId(android.R.id.list))\n\t\t\t\t.check(matches(hostConnected()))\n\t\t\t\t.perform(longClick());\n\n\t\t// Click on the disconnect context menu item.\n\t\tonView(withText(R.string.list_host_disconnect)).check(matches(isDisplayed())).perform(click());\n\n\t\t// Now make sure we're disconnected.\n\t\tonData(withHostNickname(\"Local\")).inAdapterView(withId(android.R.id.list))\n\t\t\t\t.check(matches(hostDisconnected()));\n\t}\n\n\t@Test\n\tpublic void localConnectionDisconnectConsoleActivity() {\n\t\tstartNewLocalConnection();\n\n\t\tonView(withId(R.id.console_flip)).perform(pressMenuKey());\n\n\t\t// Click on the disconnect context menu item.\n\t\tonView(withText(R.string.list_host_disconnect)).check(matches(isDisplayed())).perform(click());\n\n\t\t// Now make sure we're disconnected.\n\t\tonData(withHostNickname(\"Local\")).inAdapterView(withId(android.R.id.list))\n\t\t\t\t.check(matches(hostDisconnected()));\n\t}\n\n\t@Test\n\tpublic void localConnectionCanDelete() {\n\t\tstartNewLocalConnectionAndGoBack(\"Local\");\n\t\tonData(withHostNickname(\"Local\")).inAdapterView(withId(android.R.id.list))\n\t\t\t\t.perform(longClick());\n\t\tonView(withText(R.string.list_host_delete)).perform(click());\n\t\tonView(withText(R.string.delete_pos)).perform(click());\n\t}\n\n\t@Test\n\tpublic void localConnectionCanChangeToRed() throws Exception {\n\t\tstartNewLocalConnectionAndGoBack(\"Local1\");\n\t\tchangeColor(\"Local1\", R.color.red, R.string.color_red);\n\t}\n\n\t/**\n\t * Changes the color of {@code hostName} from the {@link HostListActivity} to the {@code color}\n\t * from {@code R.color.[color]} with identifying {@code stringForColor} from\n\t * {@code R.string.[colorname]}.\n\t */\n\tprivate void changeColor(String hostName, @ColorRes int color, @StringRes int stringForColor) {\n\t\t// Bring up the context menu.\n\t\tonData(withHostNickname(hostName)).inAdapterView(withId(android.R.id.list))\n\t\t\t\t.perform(longClick());\n\t\tonView(withText(R.string.list_host_edit)).perform(click());\n\n\t\t// Click on the color category and select the desired one.\n\t\tonView(withText(R.string.hostpref_color_title)).perform(click());\n\t\tonView(withText(stringForColor)).perform(click());\n\n\t\t// Go back to the host list.\n\t\tonView(withText(R.string.hostpref_color_title)).perform(pressBack());\n\n\t\tResources res = InstrumentationRegistry.getTargetContext().getResources();\n\t\tonData(withHostNickname(hostName)).inAdapterView(withId(android.R.id.list))\n\t\t\t\t.check(matches(hasDescendant(allOf(withId(android.R.id.text1),\n\t\t\t\t\t\twithTextColor(res.getColor(color))))));\n\t}\n\n\tprivate void startNewLocalConnectionAndGoBack(String name) {\n\t\tstartNewLocalConnection(name);\n\t\tonView(withId(R.id.console_flip)).perform(closeSoftKeyboard(), pressBack());\n\t\tonData(withHostNickname(name)).inAdapterView(withId(android.R.id.list))\n\t\t\t\t.check(matches(isDisplayed()));\n\t}\n\n\tprivate void startNewLocalConnection() {\n\t\tstartNewLocalConnection(\"Local\");\n\t}\n\n\tprivate void startNewLocalConnection(String name) {\n\t\tonView(withId(R.id.transport_selection)).perform(click());\n\t\tonData(allOf(is(instanceOf(String.class)), is(\"local\"))).perform(click());\n\t\tonView(withId(R.id.front_quickconnect)).perform(typeText(name));\n\n\t\tIntents.init();\n\t\ttry {\n\t\t\tonView(withId(R.id.front_quickconnect)).perform(pressImeActionButton());\n\t\t\tintended(hasComponent(ConsoleActivity.class.getName()));\n\t\t} finally {\n\t\t\tIntents.release();\n\t\t}\n\n\t\tonView(withId(R.id.console_flip)).check(matches(\n\t\t\t\thasDescendant(allOf(isDisplayed(), withId(R.id.terminal_view)))));\n\t}\n}\n","lineNo":51}
{"Smelly Sample":"/*\n * ConnectBot: simple, powerful, open-source SSH client for Android\n * Copyright 2007 Kenny Root, Jeffrey Sharkey\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.connectbot;\n\nimport java.lang.ref.WeakReference;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.connectbot.bean.HostBean;\nimport org.connectbot.bean.SelectionArea;\nimport org.connectbot.service.BridgeDisconnectedListener;\nimport org.connectbot.service.PromptHelper;\nimport org.connectbot.service.TerminalBridge;\nimport org.connectbot.service.TerminalKeyListener;\nimport org.connectbot.service.TerminalManager;\nimport org.connectbot.util.PreferenceConstants;\n\nimport android.app.AlertDialog;\nimport android.app.Dialog;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.ServiceConnection;\nimport android.content.SharedPreferences;\nimport android.content.pm.ActivityInfo;\nimport android.content.res.Configuration;\nimport android.media.AudioManager;\nimport android.net.Uri;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Message;\nimport android.preference.PreferenceManager;\nimport android.support.annotation.Nullable;\nimport android.support.v4.app.ActivityCompat;\nimport android.support.design.widget.TabLayout;\nimport android.support.v4.view.MenuItemCompat;\nimport android.support.v4.view.MotionEventCompat;\nimport android.support.v4.view.PagerAdapter;\nimport android.support.v4.view.ViewPager;\nimport android.support.v7.app.ActionBar;\nimport android.support.v7.app.AppCompatActivity;\nimport android.support.v7.widget.Toolbar;\nimport android.text.ClipboardManager;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.GestureDetector;\nimport android.view.InputDevice;\nimport android.view.KeyEvent;\nimport android.view.LayoutInflater;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.MenuItem.OnMenuItemClickListener;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.view.View.OnClickListener;\nimport android.view.View.OnKeyListener;\nimport android.view.View.OnTouchListener;\nimport android.view.ViewConfiguration;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.WindowManager;\nimport android.view.animation.Animation;\nimport android.view.animation.AnimationUtils;\nimport android.view.inputmethod.InputMethodManager;\nimport android.widget.AdapterView;\nimport android.widget.AdapterView.OnItemClickListener;\nimport android.widget.ArrayAdapter;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.HorizontalScrollView;\nimport android.widget.ImageView;\nimport android.widget.LinearLayout;\nimport android.widget.ListView;\nimport android.widget.RelativeLayout;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport de.mud.terminal.vt320;\n\npublic class ConsoleActivity extends AppCompatActivity implements BridgeDisconnectedListener {\n\tpublic final static String TAG = \"CB.ConsoleActivity\";\n\n\tprotected static final int REQUEST_EDIT = 1;\n\n\tprivate static final int CLICK_TIME = 400;\n\tprivate static final float MAX_CLICK_DISTANCE = 25f;\n\tprivate static final int KEYBOARD_DISPLAY_TIME = 3000;\n\tprivate static final int KEYBOARD_REPEAT_INITIAL = 500;\n\tprivate static final int KEYBOARD_REPEAT = 100;\n\tprivate static final String STATE_SELECTED_URI = \"selectedUri\";\n\n\tprotected ViewPager pager = null;\n\tprotected TabLayout tabs = null;\n\tprotected Toolbar toolbar = null;\n\t@Nullable\n\tprotected TerminalManager bound = null;\n\tprotected TerminalPagerAdapter adapter = null;\n\tprotected LayoutInflater inflater = null;\n\n\tprivate SharedPreferences prefs = null;\n\n\t// determines whether or not menuitem accelerators are bound\n\t// otherwise they collide with an external keyboard's CTRL-char\n\tprivate boolean hardKeyboard = false;\n\n\tprotected Uri requested;\n\n\tprotected ClipboardManager clipboard;\n\tprivate RelativeLayout stringPromptGroup;\n\tprotected EditText stringPrompt;\n\tprivate TextView stringPromptInstructions;\n\n\tprivate RelativeLayout booleanPromptGroup;\n\tprivate TextView booleanPrompt;\n\tprivate Button booleanYes, booleanNo;\n\n\tprivate LinearLayout keyboardGroup;\n\tprivate Runnable keyboardGroupHider;\n\n\tprivate TextView empty;\n\n\tprivate Animation fade_out_delayed;\n\n\tprivate Animation keyboard_fade_in, keyboard_fade_out;\n\tprivate float lastX, lastY;\n\n\tprivate InputMethodManager inputManager;\n\n\tprivate MenuItem disconnect, copy, paste, portForward, resize, urlscan;\n\n\tprotected TerminalBridge copySource = null;\n\tprivate int lastTouchRow, lastTouchCol;\n\n\tprivate boolean forcedOrientation;\n\n\tprivate Handler handler = new Handler();\n\n\tprivate ImageView mKeyboardButton;\n\n\t@Nullable private ActionBar actionBar;\n\tprivate boolean inActionBarMenu = false;\n\tprivate boolean titleBarHide;\n\n\tprivate ServiceConnection connection = new ServiceConnection() {\n\t\tpublic void onServiceConnected(ComponentName className, IBinder service) {\n\t\t\tbound = ((TerminalManager.TerminalBinder) service).getService();\n\n\t\t\t// let manager know about our event handling services\n\t\t\tbound.disconnectListener = ConsoleActivity.this;\n\t\t\tbound.setResizeAllowed(true);\n\n\t\t\tfinal String requestedNickname = (requested != null) ? requested.getFragment() : null;\n\t\t\tint requestedIndex = 0;\n\n\t\t\tTerminalBridge requestedBridge = bound.getConnectedBridge(requestedNickname);\n\n\t\t\t// If we didn't find the requested connection, try opening it\n\t\t\tif (requestedNickname != null && requestedBridge == null) {\n\t\t\t\ttry {\n\t\t\t\t\tLog.d(TAG, String.format(\"We couldnt find an existing bridge with URI=%s (nickname=%s), so creating one now\", requested.toString(), requestedNickname));\n\t\t\t\t\trequestedBridge = bound.openConnection(requested);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tLog.e(TAG, \"Problem while trying to create new requested bridge from URI\", e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// create views for all bridges on this service\n\t\t\tadapter.notifyDataSetChanged();\n\t\t\trequestedIndex = bound.getBridges().indexOf(requestedBridge);\n\n\t\t\tsetDisplayedTerminal(requestedIndex == -1 ? 0 : requestedIndex);\n\t\t}\n\n\t\tpublic void onServiceDisconnected(ComponentName className) {\n\t\t\tadapter.notifyDataSetChanged();\n\t\t\tupdateEmptyVisible();\n\t\t\tbound = null;\n\t\t}\n\t};\n\n\tprotected Handler promptHandler = new Handler() {\n\t\t@Override\n\t\tpublic void handleMessage(Message msg) {\n\t\t\t// someone below us requested to display a prompt\n\t\t\tupdatePromptVisible();\n\t\t}\n\t};\n\n\tpublic void onDisconnected(TerminalBridge bridge) {\n\t\tsynchronized (adapter) {\n\t\t\tadapter.notifyDataSetChanged();\n\t\t\tLog.d(TAG, \"Someone sending HANDLE_DISCONNECT to parentHandler\");\n\n\t\t\tif (bridge.isAwaitingClose()) {\n\t\t\t\tcloseBridge(bridge);\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected OnClickListener emulatedKeysListener = new OnClickListener() {\n\t\t@Override\n\t\tpublic void onClick(View v) {\n\t\t\tonEmulatedKeyClicked(v);\n\t\t}\n\t};\n\n\tprotected Handler keyRepeatHandler = new Handler();\n\n\n\t/**\n\t * Handle repeatable virtual keys and touch events\n\t */\n\tpublic class KeyRepeater implements Runnable, OnTouchListener, OnClickListener {\n\t\tprivate View mView;\n\t\tprivate Handler mHandler;\n\t\tprivate boolean mDown;\n\n\t\tpublic KeyRepeater(Handler handler, View view) {\n\t\t\tmView = view;\n\t\t\tmHandler = handler;\n\t\t\tmView.setOnTouchListener(this);\n\t\t\tmView.setOnClickListener(this);\n\t\t\tmDown = false;\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tmDown = true;\n\t\t\tmHandler.removeCallbacks(this);\n\t\t\tmHandler.postDelayed(this, KEYBOARD_REPEAT);\n\t\t\tmView.performClick();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean onTouch(View v, MotionEvent event) {\n\t\t\tif (BuildConfig.DEBUG) {\n\t\t\t\tLog.d(TAG, \"KeyRepeater.onTouch(\" + v.getId() + \", \" +\n\t\t\t\t\t\tevent.getAction() + \", \" +\n\t\t\t\t\t\tevent.getActionIndex() + \", \" +\n\t\t\t\t\t\tevent.getActionMasked() + \");\");\n\t\t\t}\n\t\t\tswitch (event.getAction()) {\n\t\t\tcase MotionEvent.ACTION_DOWN:\n\t\t\t\tmDown = false;\n\t\t\t\tmHandler.postDelayed(this, KEYBOARD_REPEAT_INITIAL);\n\t\t\t\tmView.setPressed(true);\n\t\t\t\treturn (true);\n\n\t\t\tcase MotionEvent.ACTION_CANCEL:\n\t\t\t\tmHandler.removeCallbacks(this);\n\t\t\t\tmView.setPressed(false);\n\t\t\t\treturn (true);\n\n\t\t\tcase MotionEvent.ACTION_UP:\n\t\t\t\tmHandler.removeCallbacks(this);\n\t\t\t\tmView.setPressed(false);\n\n\t\t\t\tif (!mDown) {\n\t\t\t\t\tmView.performClick();\n\t\t\t\t}\n\t\t\t\treturn (true);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic void onClick(View view) {\n\t\t\tonEmulatedKeyClicked(view);\n\t\t}\n\t}\n\n\tprivate void onEmulatedKeyClicked(View v) {\n\t\tTerminalView terminal = adapter.getCurrentTerminalView();\n\t\tif (terminal == null) return;\n\n\t\tif (BuildConfig.DEBUG) {\n\t\t\tLog.d(TAG, \"onEmulatedKeyClicked(\" + v.getId() + \")\");\n\t\t}\n\t\tTerminalKeyListener handler = terminal.bridge.getKeyHandler();\n\t\tboolean hideKeys = false;\n\n\t\tswitch (v.getId()) {\n\t\tcase R.id.button_ctrl:\n\t\t\thandler.metaPress(TerminalKeyListener.OUR_CTRL_ON, true);\n\t\t\thideKeys = true;\n\t\t\tbreak;\n\t\tcase R.id.button_esc:\n\t\t\thandler.sendEscape();\n\t\t\thideKeys = true;\n\t\t\tbreak;\n\t\tcase R.id.button_tab:\n\t\t\thandler.sendTab();\n\t\t\thideKeys = true;\n\t\t\tbreak;\n\n\t\tcase R.id.button_up:\n\t\t\thandler.sendPressedKey(vt320.KEY_UP);\n\t\t\tbreak;\n\t\tcase R.id.button_down:\n\t\t\thandler.sendPressedKey(vt320.KEY_DOWN);\n\t\t\tbreak;\n\t\tcase R.id.button_left:\n\t\t\thandler.sendPressedKey(vt320.KEY_LEFT);\n\t\t\tbreak;\n\t\tcase R.id.button_right:\n\t\t\thandler.sendPressedKey(vt320.KEY_RIGHT);\n\t\t\tbreak;\n\n\t\tcase R.id.button_home:\n\t\t\thandler.sendPressedKey(vt320.KEY_HOME);\n\t\t\tbreak;\n\t\tcase R.id.button_end:\n\t\t\thandler.sendPressedKey(vt320.KEY_END);\n\t\t\tbreak;\n\t\tcase R.id.button_pgup:\n\t\t\thandler.sendPressedKey(vt320.KEY_PAGE_UP);\n\t\t\tbreak;\n\t\tcase R.id.button_pgdn:\n\t\t\thandler.sendPressedKey(vt320.KEY_PAGE_DOWN);\n\t\t\tbreak;\n\n\t\tcase R.id.button_f1:\n\t\t\thandler.sendPressedKey(vt320.KEY_F1);\n\t\t\tbreak;\n\t\tcase R.id.button_f2:\n\t\t\thandler.sendPressedKey(vt320.KEY_F2);\n\t\t\tbreak;\n\t\tcase R.id.button_f3:\n\t\t\thandler.sendPressedKey(vt320.KEY_F3);\n\t\t\tbreak;\n\t\tcase R.id.button_f4:\n\t\t\thandler.sendPressedKey(vt320.KEY_F4);\n\t\t\tbreak;\n\t\tcase R.id.button_f5:\n\t\t\thandler.sendPressedKey(vt320.KEY_F5);\n\t\t\tbreak;\n\t\tcase R.id.button_f6:\n\t\t\thandler.sendPressedKey(vt320.KEY_F6);\n\t\t\tbreak;\n\t\tcase R.id.button_f7:\n\t\t\thandler.sendPressedKey(vt320.KEY_F7);\n\t\t\tbreak;\n\t\tcase R.id.button_f8:\n\t\t\thandler.sendPressedKey(vt320.KEY_F8);\n\t\t\tbreak;\n\t\tcase R.id.button_f9:\n\t\t\thandler.sendPressedKey(vt320.KEY_F9);\n\t\t\tbreak;\n\t\tcase R.id.button_f10:\n\t\t\thandler.sendPressedKey(vt320.KEY_F10);\n\t\t\tbreak;\n\t\tcase R.id.button_f11:\n\t\t\thandler.sendPressedKey(vt320.KEY_F11);\n\t\t\tbreak;\n\t\tcase R.id.button_f12:\n\t\t\thandler.sendPressedKey(vt320.KEY_F12);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (hideKeys)\n\t\t\thideEmulatedKeys();\n\t\telse\n\t\t\tautoHideEmulatedKeys();\n\n\t\tterminal.bridge.tryKeyVibrate();\n\t\thideActionBarIfRequested();\n\t}\n\n\tprivate void hideActionBarIfRequested() {\n\t\tif (titleBarHide && actionBar != null) {\n\t\t\tactionBar.hide();\n\t\t}\n\t}\n\n\t/**\n\t * @param bridge\n\t */\n\tprivate void closeBridge(final TerminalBridge bridge) {\n\t\tupdateEmptyVisible();\n\t\tupdatePromptVisible();\n\n\t\t// If we just closed the last bridge, go back to the previous activity.\n\t\tif (pager.getChildCount() == 0) {\n\t\t\tfinish();\n\t\t}\n\t}\n\n\tprotected View findCurrentView(int id) {\n\t\tView view = pager.findViewWithTag(adapter.getBridgeAtPosition(pager.getCurrentItem()));\n\t\tif (view == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn view.findViewById(id);\n\t}\n\n\tprotected PromptHelper getCurrentPromptHelper() {\n\t\tTerminalView view = adapter.getCurrentTerminalView();\n\t\tif (view == null) return null;\n\t\treturn view.bridge.promptHelper;\n\t}\n\n\tprotected void hideAllPrompts() {\n\t\tstringPromptGroup.setVisibility(View.GONE);\n\t\tbooleanPromptGroup.setVisibility(View.GONE);\n\t}\n\n\tprivate void showEmulatedKeys(boolean showActionBar) {\n\t\tkeyboardGroup.startAnimation(keyboard_fade_in);\n\t\tkeyboardGroup.setVisibility(View.VISIBLE);\n\t\tif (showActionBar) {\n\t\t\tactionBar.show();\n\t\t}\n\t\tautoHideEmulatedKeys();\n\t}\n\n\tprivate void autoHideEmulatedKeys() {\n\t\tif (keyboardGroupHider != null)\n\t\t\thandler.removeCallbacks(keyboardGroupHider);\n\t\tkeyboardGroupHider = new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tif (keyboardGroup.getVisibility() == View.GONE || inActionBarMenu)\n\t\t\t\t\treturn;\n\n\t\t\t\tkeyboardGroup.startAnimation(keyboard_fade_out);\n\t\t\t\tkeyboardGroup.setVisibility(View.GONE);\n\t\t\t\thideActionBarIfRequested();\n\t\t\t\tkeyboardGroupHider = null;\n\t\t\t}\n\t\t};\n\t\thandler.postDelayed(keyboardGroupHider, KEYBOARD_DISPLAY_TIME);\n\t}\n\n\tprivate void hideEmulatedKeys() {\n\t\tif (keyboardGroupHider != null)\n\t\t\thandler.removeCallbacks(keyboardGroupHider);\n\t\tkeyboardGroup.setVisibility(View.GONE);\n\t\thideActionBarIfRequested();\n\t}\n\n\t@Override\n\tpublic void onCreate(Bundle icicle) {\n\t\tsuper.onCreate(icicle);\n\n\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD) {\n\t\t\tStrictModeSetup.run();\n\t\t}\n\n\t\thardKeyboard = getResources().getConfiguration().keyboard ==\n\t\t\t\tConfiguration.KEYBOARD_QWERTY;\n\n\t\tclipboard = (ClipboardManager) getSystemService(CLIPBOARD_SERVICE);\n\t\tprefs = PreferenceManager.getDefaultSharedPreferences(this);\n\n\t\ttitleBarHide = prefs.getBoolean(PreferenceConstants.TITLEBARHIDE, false);\n\t\tif (titleBarHide) {\n\t\t\tsupportRequestWindowFeature(Window.FEATURE_ACTION_BAR_OVERLAY);\n\t\t}\n\n\t\tthis.setContentView(R.layout.act_console);\n\n\t\t// hide status bar if requested by user\n\t\tif (prefs.getBoolean(PreferenceConstants.FULLSCREEN, false)) {\n\t\t\tgetWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,\n\t\t\t\t\tWindowManager.LayoutParams.FLAG_FULLSCREEN);\n\t\t}\n\n\t\t// TODO find proper way to disable volume key beep if it exists.\n\t\tsetVolumeControlStream(AudioManager.STREAM_MUSIC);\n\n\t\t// handle requested console from incoming intent\n\t\tif (icicle == null) {\n\t\t\trequested = getIntent().getData();\n\t\t} else {\n\t\t\trequested = Uri.parse(icicle.getString(STATE_SELECTED_URI));\n\t\t}\n\n\t\tinflater = LayoutInflater.from(this);\n\n\t\ttoolbar = (Toolbar) findViewById(R.id.toolbar);\n\t\tpager = (ViewPager) findViewById(R.id.console_flip);\n\t\tregisterForContextMenu(pager);\n\t\tpager.addOnPageChangeListener(\n\t\t\t\tnew ViewPager.SimpleOnPageChangeListener() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onPageSelected(int position) {\n\t\t\t\t\t\tsetTitle(adapter.getPageTitle(position));\n\t\t\t\t\t\tonTerminalChanged();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\tadapter = new TerminalPagerAdapter();\n\t\tpager.setAdapter(adapter);\n\n\t\tempty = (TextView) findViewById(android.R.id.empty);\n\n\t\tstringPromptGroup = (RelativeLayout) findViewById(R.id.console_password_group);\n\t\tstringPromptInstructions = (TextView) findViewById(R.id.console_password_instructions);\n\t\tstringPrompt = (EditText) findViewById(R.id.console_password);\n\t\tstringPrompt.setOnKeyListener(new OnKeyListener() {\n\t\t\tpublic boolean onKey(View v, int keyCode, KeyEvent event) {\n\t\t\t\tif (event.getAction() == KeyEvent.ACTION_UP) return false;\n\t\t\t\tif (keyCode != KeyEvent.KEYCODE_ENTER) return false;\n\n\t\t\t\t// pass collected password down to current terminal\n\t\t\t\tString value = stringPrompt.getText().toString();\n\n\t\t\t\tPromptHelper helper = getCurrentPromptHelper();\n\t\t\t\tif (helper == null) return false;\n\t\t\t\thelper.setResponse(value);\n\n\t\t\t\t// finally clear password for next user\n\t\t\t\tstringPrompt.setText(\"\");\n\t\t\t\tupdatePromptVisible();\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\tbooleanPromptGroup = (RelativeLayout) findViewById(R.id.console_boolean_group);\n\t\tbooleanPrompt = (TextView) findViewById(R.id.console_prompt);\n\n\t\tbooleanYes = (Button) findViewById(R.id.console_prompt_yes);\n\t\tbooleanYes.setOnClickListener(new OnClickListener() {\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tPromptHelper helper = getCurrentPromptHelper();\n\t\t\t\tif (helper == null) return;\n\t\t\t\thelper.setResponse(Boolean.TRUE);\n\t\t\t\tupdatePromptVisible();\n\t\t\t}\n\t\t});\n\n\t\tbooleanNo = (Button) findViewById(R.id.console_prompt_no);\n\t\tbooleanNo.setOnClickListener(new OnClickListener() {\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tPromptHelper helper = getCurrentPromptHelper();\n\t\t\t\tif (helper == null) return;\n\t\t\t\thelper.setResponse(Boolean.FALSE);\n\t\t\t\tupdatePromptVisible();\n\t\t\t}\n\t\t});\n\n\t\tfade_out_delayed = AnimationUtils.loadAnimation(this, R.anim.fade_out_delayed);\n\n\t\t// Preload animation for keyboard button\n\t\tkeyboard_fade_in = AnimationUtils.loadAnimation(this, R.anim.keyboard_fade_in);\n\t\tkeyboard_fade_out = AnimationUtils.loadAnimation(this, R.anim.keyboard_fade_out);\n\n\t\tinputManager = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);\n\n\t\tkeyboardGroup = (LinearLayout) findViewById(R.id.keyboard_group);\n\n\t\tmKeyboardButton = (ImageView) findViewById(R.id.button_keyboard);\n\t\tmKeyboardButton.setOnClickListener(new OnClickListener() {\n\t\t\tpublic void onClick(View view) {\n\t\t\t\tView terminal = adapter.getCurrentTerminalView();\n\t\t\t\tif (terminal == null)\n\t\t\t\t\treturn;\n\n\t\t\t\tinputManager.showSoftInput(terminal, InputMethodManager.SHOW_FORCED);\n\t\t\t\thideEmulatedKeys();\n\t\t\t}\n\t\t});\n\n\t\tfindViewById(R.id.button_ctrl).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_esc).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_tab).setOnClickListener(emulatedKeysListener);\n\n\t\tnew KeyRepeater(keyRepeatHandler, findViewById(R.id.button_up));\n\t\tnew KeyRepeater(keyRepeatHandler, findViewById(R.id.button_down));\n\t\tnew KeyRepeater(keyRepeatHandler, findViewById(R.id.button_left));\n\t\tnew KeyRepeater(keyRepeatHandler, findViewById(R.id.button_right));\n\n\t\tfindViewById(R.id.button_home).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_end).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_pgup).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_pgdn).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f1).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f2).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f3).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f4).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f5).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f6).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f7).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f8).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f9).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f10).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f11).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f12).setOnClickListener(emulatedKeysListener);\n\n\n\t\tactionBar = getSupportActionBar();\n\t\tif (actionBar != null) {\n\t\t\tactionBar.setDisplayHomeAsUpEnabled(true);\n\t\t\tif (titleBarHide) {\n\t\t\t\tactionBar.hide();\n\t\t\t}\n\t\t\tactionBar.addOnMenuVisibilityListener(new ActionBar.OnMenuVisibilityListener() {\n\t\t\t\tpublic void onMenuVisibilityChanged(boolean isVisible) {\n\t\t\t\t\tinActionBarMenu = isVisible;\n\t\t\t\t\tif (isVisible == false) {\n\t\t\t\t\t\thideEmulatedKeys();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tfinal HorizontalScrollView keyboardScroll = (HorizontalScrollView) findViewById(R.id.keyboard_hscroll);\n\t\tif (!hardKeyboard) {\n\t\t\t// Show virtual keyboard and scroll back and forth\n\t\t\tshowEmulatedKeys(false);\n\t\t\tkeyboardScroll.postDelayed(new Runnable() {\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\tfinal int xscroll = findViewById(R.id.button_f12).getRight();\n\t\t\t\t\tif (BuildConfig.DEBUG) {\n\t\t\t\t\t\tLog.d(TAG, \"smoothScrollBy(toEnd[\" + xscroll + \"])\");\n\t\t\t\t\t}\n\t\t\t\t\tkeyboardScroll.smoothScrollBy(xscroll, 0);\n\t\t\t\t\tkeyboardScroll.postDelayed(new Runnable() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\tif (BuildConfig.DEBUG) {\n\t\t\t\t\t\t\t\tLog.d(TAG, \"smoothScrollBy(toStart[\" + (-xscroll) + \"])\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tkeyboardScroll.smoothScrollBy(-xscroll, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, 500);\n\t\t\t\t}\n\t\t\t}, 500);\n\t\t}\n\n\t\t// Reset keyboard auto-hide timer when scrolling\n\t\tkeyboardScroll.setOnTouchListener(\n\t\t\t\tnew OnTouchListener() {\n\t\t\t\t\tpublic boolean onTouch(View v, MotionEvent event) {\n\t\t\t\t\t\tswitch (event.getAction()) {\n\t\t\t\t\t\tcase MotionEvent.ACTION_MOVE:\n\t\t\t\t\t\t\tautoHideEmulatedKeys();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase MotionEvent.ACTION_UP:\n\t\t\t\t\t\t\tv.performClick();\n\t\t\t\t\t\t\treturn (true);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn (false);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\ttabs = (TabLayout) findViewById(R.id.tabs);\n\t\tif (tabs != null)\n\t\t\tsetupTabLayoutWithViewPager();\n\n\t\t// detect fling gestures to switch between terminals\n\t\tfinal GestureDetector detect = new GestureDetector(this, new GestureDetector.SimpleOnGestureListener() {\n\t\t\tprivate float totalY = 0;\n\n\t\t\t@Override\n\t\t\tpublic void onLongPress(MotionEvent e) {\n\t\t\t\tsuper.onLongPress(e);\n\t\t\t\topenContextMenu(pager);\n\t\t\t}\n\n\n\t\t\t@Override\n\t\t\tpublic boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {\n\n\t\t\t\t// if copying, then ignore\n\t\t\t\tif (copySource != null && copySource.isSelectingForCopy())\n\t\t\t\t\treturn false;\n\n\t\t\t\tif (e1 == null || e2 == null)\n\t\t\t\t\treturn false;\n\n\t\t\t\t// if releasing then reset total scroll\n\t\t\t\tif (e2.getAction() == MotionEvent.ACTION_UP) {\n\t\t\t\t\ttotalY = 0;\n\t\t\t\t}\n\n\t\t\t\t// activate consider if within x tolerance\n\t\t\t\tint touchSlop = ViewConfiguration.get(ConsoleActivity.this).getScaledTouchSlop();\n\t\t\t\tif (Math.abs(e1.getX() - e2.getX()) < touchSlop * 4) {\n\n\t\t\t\t\tView view = adapter.getCurrentTerminalView();\n\t\t\t\t\tif (view == null) return false;\n\t\t\t\t\tTerminalView terminal = (TerminalView) view;\n\n\t\t\t\t\t// estimate how many rows we have scrolled through\n\t\t\t\t\t// accumulate distance that doesn't trigger immediate scroll\n\t\t\t\t\ttotalY += distanceY;\n\t\t\t\t\tfinal int moved = (int) (totalY / terminal.bridge.charHeight);\n\n\t\t\t\t\t// consume as scrollback only if towards right half of screen\n\t\t\t\t\tif (e2.getX() > view.getWidth() / 2) {\n\t\t\t\t\t\tif (moved != 0) {\n\t\t\t\t\t\t\tint base = terminal.bridge.buffer.getWindowBase();\n\t\t\t\t\t\t\tterminal.bridge.buffer.setWindowBase(base + moved);\n\t\t\t\t\t\t\ttotalY = 0;\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// otherwise consume as pgup/pgdown for every 5 lines\n\t\t\t\t\t\tif (moved > 5) {\n\t\t\t\t\t\t\t((vt320) terminal.bridge.buffer).keyPressed(vt320.KEY_PAGE_DOWN, ' ', 0);\n\t\t\t\t\t\t\tterminal.bridge.tryKeyVibrate();\n\t\t\t\t\t\t\ttotalY = 0;\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t} else if (moved < -5) {\n\t\t\t\t\t\t\t((vt320) terminal.bridge.buffer).keyPressed(vt320.KEY_PAGE_UP, ' ', 0);\n\t\t\t\t\t\t\tterminal.bridge.tryKeyVibrate();\n\t\t\t\t\t\t\ttotalY = 0;\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t}\n\n\n\t\t});\n\n\t\tpager.setLongClickable(true);\n\t\tpager.setOnTouchListener(new OnTouchListener() {\n\n\t\t\tpublic boolean onTouch(View v, MotionEvent event) {\n\n\t\t\t\t// Handle mouse-specific actions.\n\t\t\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH &&\n\t\t\t\t\t\tMotionEventCompat.getSource(event) == InputDevice.SOURCE_MOUSE &&\n\t\t\t\t\t\tevent.getAction() == MotionEvent.ACTION_DOWN) {\n\t\t\t\t\tswitch (event.getButtonState()) {\n\t\t\t\t\tcase MotionEvent.BUTTON_PRIMARY:\n\t\t\t\t\t\t// Automatically start copy mode if using a mouse.\n\t\t\t\t\t\tstartCopyMode();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase MotionEvent.BUTTON_SECONDARY:\n\t\t\t\t\t\topenContextMenu(pager);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tcase MotionEvent.BUTTON_TERTIARY:\n\t\t\t\t\t\t// Middle click pastes.\n\t\t\t\t\t\tpasteIntoTerminal();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// when copying, highlight the area\n\t\t\t\tif (copySource != null && copySource.isSelectingForCopy()) {\n\t\t\t\t\tint row = (int) Math.floor(event.getY() / copySource.charHeight);\n\t\t\t\t\tint col = (int) Math.floor(event.getX() / copySource.charWidth);\n\n\t\t\t\t\tSelectionArea area = copySource.getSelectionArea();\n\n\t\t\t\t\tswitch (event.getAction()) {\n\t\t\t\t\tcase MotionEvent.ACTION_DOWN:\n\t\t\t\t\t\t// recording starting area\n\t\t\t\t\t\tif (area.isSelectingOrigin()) {\n\t\t\t\t\t\t\tarea.setRow(row);\n\t\t\t\t\t\t\tarea.setColumn(col);\n\t\t\t\t\t\t\tlastTouchRow = row;\n\t\t\t\t\t\t\tlastTouchCol = col;\n\t\t\t\t\t\t\tcopySource.redraw();\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tcase MotionEvent.ACTION_MOVE:\n\t\t\t\t\t\t/* ignore when user hasn't moved since last time so\n\t\t\t\t\t\t * we can fine-tune with directional pad\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (row == lastTouchRow && col == lastTouchCol)\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t// if the user moves, start the selection for other corner\n\t\t\t\t\t\tarea.finishSelectingOrigin();\n\n\t\t\t\t\t\t// update selected area\n\t\t\t\t\t\tarea.setRow(row);\n\t\t\t\t\t\tarea.setColumn(col);\n\t\t\t\t\t\tlastTouchRow = row;\n\t\t\t\t\t\tlastTouchCol = col;\n\t\t\t\t\t\tcopySource.redraw();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tcase MotionEvent.ACTION_UP:\n\t\t\t\t\t\t/* If they didn't move their finger, maybe they meant to\n\t\t\t\t\t\t * select the rest of the text with the directional pad.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (area.getLeft() == area.getRight() &&\n\t\t\t\t\t\t\t\tarea.getTop() == area.getBottom()) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// copy selected area to clipboard\n\t\t\t\t\t\tString copiedText = area.copyFrom(copySource.buffer);\n\n\t\t\t\t\t\tclipboard.setText(copiedText);\n\t\t\t\t\t\tToast.makeText(ConsoleActivity.this, getString(R.string.console_copy_done, copiedText.length()), Toast.LENGTH_LONG).show();\n\t\t\t\t\t\t// fall through to clear state\n\n\t\t\t\t\tcase MotionEvent.ACTION_CANCEL:\n\t\t\t\t\t\t// make sure we clear any highlighted area\n\t\t\t\t\t\tarea.reset();\n\t\t\t\t\t\tcopySource.setSelectingForCopy(false);\n\t\t\t\t\t\tcopySource.redraw();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (event.getAction() == MotionEvent.ACTION_DOWN) {\n\t\t\t\t\tlastX = event.getX();\n\t\t\t\t\tlastY = event.getY();\n\t\t\t\t} else if (event.getAction() == MotionEvent.ACTION_UP\n\t\t\t\t\t\t&& keyboardGroup.getVisibility() == View.GONE\n\t\t\t\t\t\t&& event.getEventTime() - event.getDownTime() < CLICK_TIME\n\t\t\t\t\t\t&& Math.abs(event.getX() - lastX) < MAX_CLICK_DISTANCE\n\t\t\t\t\t\t&& Math.abs(event.getY() - lastY) < MAX_CLICK_DISTANCE) {\n\t\t\t\t\tshowEmulatedKeys(true);\n\t\t\t\t}\n\n\t\t\t\t// pass any touch events back to detector\n\t\t\t\treturn detect.onTouchEvent(event);\n\t\t\t}\n\n\t\t});\n\t}\n\n\t/**\n\t * Ties the {@link TabLayout} to the {@link ViewPager}.\n\t *\n\t * <p>This method will:\n\t * <ul>\n\t *     <li>Add a {@link ViewPager.OnPageChangeListener} that will forward events to\n\t *     this TabLayout.<\/li>\n\t *     <li>Populate the TabLayout's tabs from the ViewPager's {@link PagerAdapter}.<\/li>\n\t *     <li>Set our {@link TabLayout.OnTabSelectedListener} which will forward\n\t *     selected events to the ViewPager<\/li>\n\t * <\/ul>\n\t * <\/p>\n\t */\n\tpublic void setupTabLayoutWithViewPager() {\n\t\ttabs.setTabsFromPagerAdapter(adapter);\n\t\tpager.addOnPageChangeListener(new TabLayout.TabLayoutOnPageChangeListener(tabs));\n\t\ttabs.setOnTabSelectedListener(new TabLayout.ViewPagerOnTabSelectedListener(pager));\n\n\t\tif (adapter.getCount() > 0) {\n\t\t\tfinal int curItem = pager.getCurrentItem();\n\t\t\tif (tabs.getSelectedTabPosition() != curItem) {\n\t\t\t\ttabs.getTabAt(curItem).select();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t *\n\t */\n\tprivate void configureOrientation() {\n\t\tString rotateDefault;\n\t\tif (getResources().getConfiguration().keyboard == Configuration.KEYBOARD_NOKEYS)\n\t\t\trotateDefault = PreferenceConstants.ROTATION_PORTRAIT;\n\t\telse\n\t\t\trotateDefault = PreferenceConstants.ROTATION_LANDSCAPE;\n\n\t\tString rotate = prefs.getString(PreferenceConstants.ROTATION, rotateDefault);\n\t\tif (PreferenceConstants.ROTATION_DEFAULT.equals(rotate))\n\t\t\trotate = rotateDefault;\n\n\t\t// request a forced orientation if requested by user\n\t\tif (PreferenceConstants.ROTATION_LANDSCAPE.equals(rotate)) {\n\t\t\tsetRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);\n\t\t\tforcedOrientation = true;\n\t\t} else if (PreferenceConstants.ROTATION_PORTRAIT.equals(rotate)) {\n\t\t\tsetRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);\n\t\t\tforcedOrientation = true;\n\t\t} else {\n\t\t\tsetRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);\n\t\t\tforcedOrientation = false;\n\t\t}\n\t}\n\n\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu) {\n\t\tsuper.onCreateOptionsMenu(menu);\n\n\t\tTerminalView view = adapter.getCurrentTerminalView();\n\t\tfinal boolean activeTerminal = view != null;\n\t\tboolean sessionOpen = false;\n\t\tboolean disconnected = false;\n\t\tboolean canForwardPorts = false;\n\n\t\tif (activeTerminal) {\n\t\t\tTerminalBridge bridge = view.bridge;\n\t\t\tsessionOpen = bridge.isSessionOpen();\n\t\t\tdisconnected = bridge.isDisconnected();\n\t\t\tcanForwardPorts = bridge.canFowardPorts();\n\t\t}\n\n\t\tmenu.setQwertyMode(true);\n\n\t\tdisconnect = menu.add(R.string.list_host_disconnect);\n\t\tif (hardKeyboard)\n\t\t\tdisconnect.setAlphabeticShortcut('w');\n\t\tif (!sessionOpen && disconnected)\n\t\t\tdisconnect.setTitle(R.string.console_menu_close);\n\t\tdisconnect.setEnabled(activeTerminal);\n\t\tdisconnect.setIcon(android.R.drawable.ic_menu_close_clear_cancel);\n\t\tdisconnect.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t// disconnect or close the currently visible session\n\t\t\t\tTerminalView terminalView = adapter.getCurrentTerminalView();\n\t\t\t\tTerminalBridge bridge = terminalView.bridge;\n\n\t\t\t\tbridge.dispatchDisconnect(true);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\tcopy = menu.add(R.string.console_menu_copy);\n\t\tif (hardKeyboard)\n\t\t\tcopy.setAlphabeticShortcut('c');\n\t\tMenuItemCompat.setShowAsAction(copy, MenuItemCompat.SHOW_AS_ACTION_IF_ROOM);\n\t\tcopy.setIcon(R.drawable.ic_action_copy);\n\t\tcopy.setEnabled(activeTerminal);\n\t\tcopy.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tstartCopyMode();\n\t\t\t\tToast.makeText(ConsoleActivity.this, getString(R.string.console_copy_start), Toast.LENGTH_LONG).show();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\tpaste = menu.add(R.string.console_menu_paste);\n\t\tif (hardKeyboard)\n\t\t\tpaste.setAlphabeticShortcut('v');\n\t\tMenuItemCompat.setShowAsAction(paste, MenuItemCompat.SHOW_AS_ACTION_IF_ROOM);\n\t\tpaste.setIcon(R.drawable.ic_action_paste);\n\t\tpaste.setEnabled(clipboard.hasText() && sessionOpen);\n\t\tpaste.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tpasteIntoTerminal();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\tportForward = menu.add(R.string.console_menu_portforwards);\n\t\tif (hardKeyboard)\n\t\t\tportForward.setAlphabeticShortcut('f');\n\t\tportForward.setIcon(android.R.drawable.ic_menu_manage);\n\t\tportForward.setEnabled(sessionOpen && canForwardPorts);\n\t\tportForward.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tTerminalView terminalView = adapter.getCurrentTerminalView();\n\t\t\t\tTerminalBridge bridge = terminalView.bridge;\n\n\t\t\t\tIntent intent = new Intent(ConsoleActivity.this, PortForwardListActivity.class);\n\t\t\t\tintent.putExtra(Intent.EXTRA_TITLE, bridge.host.getId());\n\t\t\t\tConsoleActivity.this.startActivityForResult(intent, REQUEST_EDIT);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\turlscan = menu.add(R.string.console_menu_urlscan);\n\t\tif (hardKeyboard)\n\t\t\turlscan.setAlphabeticShortcut('u');\n\t\turlscan.setIcon(android.R.drawable.ic_menu_search);\n\t\turlscan.setEnabled(activeTerminal);\n\t\turlscan.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tfinal TerminalView terminalView = adapter.getCurrentTerminalView();\n\n\t\t\t\tList<String> urls = terminalView.bridge.scanForURLs();\n\n\t\t\t\tDialog urlDialog = new Dialog(ConsoleActivity.this);\n\t\t\t\turlDialog.setTitle(R.string.console_menu_urlscan);\n\n\t\t\t\tListView urlListView = new ListView(ConsoleActivity.this);\n\t\t\t\tURLItemListener urlListener = new URLItemListener(ConsoleActivity.this);\n\t\t\t\turlListView.setOnItemClickListener(urlListener);\n\n\t\t\t\turlListView.setAdapter(new ArrayAdapter<String>(ConsoleActivity.this, android.R.layout.simple_list_item_1, urls));\n\t\t\t\turlDialog.setContentView(urlListView);\n\t\t\t\turlDialog.show();\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\tresize = menu.add(R.string.console_menu_resize);\n\t\tif (hardKeyboard)\n\t\t\tresize.setAlphabeticShortcut('s');\n\t\tresize.setIcon(android.R.drawable.ic_menu_crop);\n\t\tresize.setEnabled(sessionOpen);\n\t\tresize.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tfinal TerminalView terminalView = adapter.getCurrentTerminalView();\n\n\t\t\t\tfinal View resizeView = inflater.inflate(R.layout.dia_resize, null, false);\n\t\t\t\tnew AlertDialog.Builder(ConsoleActivity.this)\n\t\t\t\t\t\t.setView(resizeView)\n\t\t\t\t\t\t.setPositiveButton(R.string.button_resize, new DialogInterface.OnClickListener() {\n\t\t\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\t\t\t\tint width, height;\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\twidth = Integer.parseInt(((EditText) resizeView\n\t\t\t\t\t\t\t\t\t\t\t.findViewById(R.id.width))\n\t\t\t\t\t\t\t\t\t\t\t.getText().toString());\n\t\t\t\t\t\t\t\t\theight = Integer.parseInt(((EditText) resizeView\n\t\t\t\t\t\t\t\t\t\t\t.findViewById(R.id.height))\n\t\t\t\t\t\t\t\t\t\t\t.getText().toString());\n\t\t\t\t\t\t\t\t} catch (NumberFormatException nfe) {\n\t\t\t\t\t\t\t\t\t// TODO change this to a real dialog where we can\n\t\t\t\t\t\t\t\t\t// make the input boxes turn red to indicate an error.\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tterminalView.forceSize(width, height);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}).setNegativeButton(android.R.string.cancel, null).create().show();\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean onPrepareOptionsMenu(Menu menu) {\n\t\tsuper.onPrepareOptionsMenu(menu);\n\n\t\tsetVolumeControlStream(AudioManager.STREAM_NOTIFICATION);\n\n\t\tfinal TerminalView view = adapter.getCurrentTerminalView();\n\t\tboolean activeTerminal = view != null;\n\t\tboolean sessionOpen = false;\n\t\tboolean disconnected = false;\n\t\tboolean canForwardPorts = false;\n\n\t\tif (activeTerminal) {\n\t\t\tTerminalBridge bridge = view.bridge;\n\t\t\tsessionOpen = bridge.isSessionOpen();\n\t\t\tdisconnected = bridge.isDisconnected();\n\t\t\tcanForwardPorts = bridge.canFowardPorts();\n\t\t}\n\n\t\tdisconnect.setEnabled(activeTerminal);\n\t\tif (sessionOpen || !disconnected)\n\t\t\tdisconnect.setTitle(R.string.list_host_disconnect);\n\t\telse\n\t\t\tdisconnect.setTitle(R.string.console_menu_close);\n\t\tcopy.setEnabled(activeTerminal);\n\t\tpaste.setEnabled(clipboard.hasText() && sessionOpen);\n\t\tportForward.setEnabled(sessionOpen && canForwardPorts);\n\t\turlscan.setEnabled(activeTerminal);\n\t\tresize.setEnabled(sessionOpen);\n\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tswitch (item.getItemId()) {\n\t\tcase android.R.id.home:\n\t\t\tIntent intent = new Intent(this, HostListActivity.class);\n\t\t\tintent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n\t\t\tstartActivity(intent);\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn super.onOptionsItemSelected(item);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void onOptionsMenuClosed(Menu menu) {\n\t\tsuper.onOptionsMenuClosed(menu);\n\n\t\tsetVolumeControlStream(AudioManager.STREAM_MUSIC);\n\t}\n\n\t@Override\n\tpublic void onCreateContextMenu(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo) {\n\t\tfinal TerminalView view = adapter.getCurrentTerminalView();\n\t\tboolean activeTerminal = view != null;\n\t\tboolean sessionOpen = false;\n\n\t\tif (activeTerminal) {\n\t\t\tTerminalBridge bridge = view.bridge;\n\t\t\tsessionOpen = bridge.isSessionOpen();\n\t\t}\n\n\t\tMenuItem paste = menu.add(R.string.console_menu_paste);\n\t\tif (hardKeyboard)\n\t\t\tpaste.setAlphabeticShortcut('v');\n\t\tpaste.setIcon(android.R.drawable.ic_menu_edit);\n\t\tpaste.setEnabled(clipboard.hasText() && sessionOpen);\n\t\tpaste.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tpasteIntoTerminal();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\n\t}\n\n\t@Override\n\tpublic void onStart() {\n\t\tsuper.onStart();\n\n\t\t// connect with manager service to find all bridges\n\t\t// when connected it will insert all views\n\t\tbindService(new Intent(this, TerminalManager.class), connection, Context.BIND_AUTO_CREATE);\n\t}\n\n\t@Override\n\tpublic void onPause() {\n\t\tsuper.onPause();\n\t\tLog.d(TAG, \"onPause called\");\n\n\t\tif (forcedOrientation && bound != null) {\n\t\t\tbound.setResizeAllowed(false);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void onResume() {\n\t\tsuper.onResume();\n\t\tLog.d(TAG, \"onResume called\");\n\n\t\t// Make sure we don't let the screen fall asleep.\n\t\t// This also keeps the Wi-Fi chipset from disconnecting us.\n\t\tif (prefs.getBoolean(PreferenceConstants.KEEP_ALIVE, true)) {\n\t\t\tgetWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);\n\t\t} else {\n\t\t\tgetWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);\n\t\t}\n\n\t\tconfigureOrientation();\n\n\t\tif (forcedOrientation && bound != null) {\n\t\t\tbound.setResizeAllowed(true);\n\t\t}\n\t}\n\n\t/* (non-Javadoc)\n\t * @see android.app.Activity#onNewIntent(android.content.Intent)\n\t */\n\t@Override\n\tprotected void onNewIntent(Intent intent) {\n\t\tsuper.onNewIntent(intent);\n\n\t\tLog.d(TAG, \"onNewIntent called\");\n\n\t\trequested = intent.getData();\n\n\t\tif (requested == null) {\n\t\t\tLog.e(TAG, \"Got null intent data in onNewIntent()\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (bound == null) {\n\t\t\tLog.e(TAG, \"We're not bound in onNewIntent()\");\n\t\t\treturn;\n\t\t}\n\n\t\tTerminalBridge requestedBridge = bound.getConnectedBridge(requested.getFragment());\n\t\tint requestedIndex = 0;\n\n\t\tsynchronized (pager) {\n\t\t\tif (requestedBridge == null) {\n\t\t\t\t// If we didn't find the requested connection, try opening it\n\n\t\t\t\ttry {\n\t\t\t\t\tLog.d(TAG, String.format(\"We couldnt find an existing bridge with URI=%s (nickname=%s),\" +\n\t\t\t\t\t\t\t\"so creating one now\", requested.toString(), requested.getFragment()));\n\t\t\t\t\trequestedBridge = bound.openConnection(requested);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tLog.e(TAG, \"Problem while trying to create new requested bridge from URI\", e);\n\t\t\t\t\t// TODO: We should display an error dialog here.\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tadapter.notifyDataSetChanged();\n\t\t\t\trequestedIndex = adapter.getCount();\n\t\t\t} else {\n\t\t\t\tfinal int flipIndex = bound.getBridges().indexOf(requestedBridge);\n\t\t\t\tif (flipIndex > requestedIndex) {\n\t\t\t\t\trequestedIndex = flipIndex;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsetDisplayedTerminal(requestedIndex);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void onStop() {\n\t\tsuper.onStop();\n\n\t\tunbindService(connection);\n\t}\n\n\t@Override\n\tpublic void onSaveInstanceState(Bundle savedInstanceState) {\n\t\t// Maintain selected host if connected.\n\t\tif (adapter.getCurrentTerminalView() != null\n\t\t\t\t&& !adapter.getCurrentTerminalView().bridge.isDisconnected()) {\n\t\t\tUri uri = adapter.getCurrentTerminalView().bridge.host.getUri();\n\t\t\tsavedInstanceState.putString(STATE_SELECTED_URI, uri.toString());\n\t\t}\n\n\t\tsuper.onSaveInstanceState(savedInstanceState);\n\t}\n\n\tprivate void startCopyMode() {\n\t\t// mark as copying and reset any previous bounds\n\t\tTerminalView terminalView = (TerminalView) adapter.getCurrentTerminalView();\n\t\tcopySource = terminalView.bridge;\n\n\t\tSelectionArea area = copySource.getSelectionArea();\n\t\tarea.reset();\n\t\tarea.setBounds(copySource.buffer.getColumns(), copySource.buffer.getRows());\n\n\t\tcopySource.setSelectingForCopy(true);\n\n\t\t// Make sure we show the initial selection\n\t\tcopySource.redraw();\n\t}\n\n\t/**\n\t * Save the currently shown {@link TerminalView} as the default. This is\n\t * saved back down into {@link TerminalManager} where we can read it again\n\t * later.\n\t */\n\tprivate void updateDefault() {\n\t\t// update the current default terminal\n\t\tTerminalView view = adapter.getCurrentTerminalView();\n\t\tif (view == null || bound == null) {\n\t\t\treturn;\n\t\t}\n\t\tbound.defaultBridge = view.bridge;\n\t}\n\n\tprotected void updateEmptyVisible() {\n\t\t// update visibility of empty status message\n\t\tempty.setVisibility((pager.getChildCount() == 0) ? View.VISIBLE : View.GONE);\n\t}\n\n\t/**\n\t * Show any prompts requested by the currently visible {@link TerminalView}.\n\t */\n\tprotected void updatePromptVisible() {\n\t\t// check if our currently-visible terminalbridge is requesting any prompt services\n\t\tTerminalView view = adapter.getCurrentTerminalView();\n\n\t\t// Hide all the prompts in case a prompt request was canceled\n\t\thideAllPrompts();\n\n\t\tif (view == null) {\n\t\t\t// we dont have an active view, so hide any prompts\n\t\t\treturn;\n\t\t}\n\n\t\tPromptHelper prompt = view.bridge.promptHelper;\n\t\tif (String.class.equals(prompt.promptRequested)) {\n\t\t\tstringPromptGroup.setVisibility(View.VISIBLE);\n\n\t\t\tString instructions = prompt.promptInstructions;\n\t\t\tif (instructions != null && instructions.length() > 0) {\n\t\t\t\tstringPromptInstructions.setVisibility(View.VISIBLE);\n\t\t\t\tstringPromptInstructions.setText(instructions);\n\t\t\t} else\n\t\t\t\tstringPromptInstructions.setVisibility(View.GONE);\n\t\t\tstringPrompt.setText(\"\");\n\t\t\tstringPrompt.setHint(prompt.promptHint);\n\t\t\tstringPrompt.requestFocus();\n\n\t\t} else if (Boolean.class.equals(prompt.promptRequested)) {\n\t\t\tbooleanPromptGroup.setVisibility(View.VISIBLE);\n\t\t\tbooleanPrompt.setText(prompt.promptHint);\n\t\t\tbooleanYes.requestFocus();\n\n\t\t} else {\n\t\t\thideAllPrompts();\n\t\t\tview.requestFocus();\n\t\t}\n\t}\n\n\tprivate class URLItemListener implements OnItemClickListener {\n\t\tprivate WeakReference<Context> contextRef;\n\n\t\tURLItemListener(Context context) {\n\t\t\tthis.contextRef = new WeakReference<Context>(context);\n\t\t}\n\n\t\tpublic void onItemClick(AdapterView<?> arg0, View view, int position, long id) {\n\t\t\tContext context = contextRef.get();\n\n\t\t\tif (context == null)\n\t\t\t\treturn;\n\n\t\t\ttry {\n\t\t\t\tTextView urlView = (TextView) view;\n\n\t\t\t\tString url = urlView.getText().toString();\n\t\t\t\tif (url.indexOf(\"://\") < 0)\n\t\t\t\t\turl = \"http://\" + url;\n\n\t\t\t\tIntent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));\n\t\t\t\tcontext.startActivity(intent);\n\t\t\t} catch (Exception e) {\n\t\t\t\tLog.e(TAG, \"couldn't open URL\", e);\n\t\t\t\t// We should probably tell the user that we couldn't find a handler...\n\t\t\t}\n\t\t}\n\n\t}\n\n\t@Override\n\tpublic void onConfigurationChanged(Configuration newConfig) {\n\t\tsuper.onConfigurationChanged(newConfig);\n\n\t\tLog.d(TAG, String.format(\"onConfigurationChanged; requestedOrientation=%d, newConfig.orientation=%d\", getRequestedOrientation(), newConfig.orientation));\n\t\tif (bound != null) {\n\t\t\tif (forcedOrientation &&\n\t\t\t\t\t(newConfig.orientation != Configuration.ORIENTATION_LANDSCAPE &&\n\t\t\t\t\t\t\tgetRequestedOrientation() == ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE) ||\n\t\t\t\t\t(newConfig.orientation != Configuration.ORIENTATION_PORTRAIT &&\n\t\t\t\t\t\t\tgetRequestedOrientation() == ActivityInfo.SCREEN_ORIENTATION_PORTRAIT))\n\t\t\t\tbound.setResizeAllowed(false);\n\t\t\telse\n\t\t\t\tbound.setResizeAllowed(true);\n\n\t\t\tbound.hardKeyboardHidden = (newConfig.hardKeyboardHidden == Configuration.HARDKEYBOARDHIDDEN_YES);\n\n\t\t\tmKeyboardButton.setVisibility(bound.hardKeyboardHidden ? View.VISIBLE : View.GONE);\n\t\t}\n\t}\n\n\t/**\n\t * Called whenever the displayed terminal is changed.\n\t */\n\tprivate void onTerminalChanged() {\n\t\tView overlay = findCurrentView(R.id.terminal_overlay);\n\t\tif (overlay != null)\n\t\t\toverlay.startAnimation(fade_out_delayed);\n\t\tupdateDefault();\n\t\tupdatePromptVisible();\n\t\tActivityCompat.invalidateOptionsMenu(ConsoleActivity.this);\n\t}\n\n\t/**\n\t * Displays the child in the ViewPager at the requestedIndex and updates the prompts.\n\t *\n\t * @param requestedIndex the index of the terminal view to display\n\t */\n\tprivate void setDisplayedTerminal(int requestedIndex) {\n\t\tpager.setCurrentItem(requestedIndex);\n\t\t// set activity title\n\t\tsetTitle(adapter.getPageTitle(requestedIndex));\n\t\tonTerminalChanged();\n\t}\n\n\tprivate void pasteIntoTerminal() {\n\t\t// force insert of clipboard text into current console\n\t\tTerminalView terminalView = adapter.getCurrentTerminalView();\n\t\tTerminalBridge bridge = terminalView.bridge;\n\n\t\t// pull string from clipboard and generate all events to force down\n\t\tString clip = clipboard.getText().toString();\n\t\tbridge.injectString(clip);\n\t}\n\n\tpublic class TerminalPagerAdapter extends PagerAdapter {\n\t\t@Override\n\t\tpublic int getCount() {\n\t\t\tif (bound != null) {\n\t\t\t\treturn bound.getBridges().size();\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Object instantiateItem(ViewGroup container, int position) {\n\t\t\tif (bound == null || bound.getBridges().size() <= position) {\n\t\t\t\tLog.w(TAG, \"Activity not bound when creating TerminalView.\");\n\t\t\t}\n\t\t\tTerminalBridge bridge = bound.getBridges().get(position);\n\t\t\tbridge.promptHelper.setHandler(promptHandler);\n\n\t\t\t// inflate each terminal view\n\t\t\tRelativeLayout view = (RelativeLayout) inflater.inflate(\n\t\t\t\t\tR.layout.item_terminal, container, false);\n\n\t\t\t// set the terminal overlay text\n\t\t\tTextView overlay = (TextView) view.findViewById(R.id.terminal_overlay);\n\t\t\toverlay.setText(bridge.host.getNickname());\n\n\t\t\t// and add our terminal view control, using index to place behind overlay\n\t\t\tfinal TerminalView terminal = new TerminalView(container.getContext(), bridge);\n\t\t\tterminal.setId(R.id.terminal_view);\n\t\t\tview.addView(terminal, 0);\n\n\t\t\t// Tag the view with its bridge so it can be retrieved later.\n\t\t\tview.setTag(bridge);\n\n\t\t\tcontainer.addView(view);\n\t\t\toverlay.startAnimation(fade_out_delayed);\n\t\t\treturn view;\n\t\t}\n\n\t\t@Override\n\t\tpublic void destroyItem(ViewGroup container, int position, Object object) {\n\t\t\tfinal View view = (View) object;\n\n\t\t\tcontainer.removeView(view);\n\t\t}\n\n\t\t@Override\n\t\tpublic int getItemPosition(Object object) {\n\t\t\tif (bound == null) {\n\t\t\t\treturn POSITION_NONE;\n\t\t\t}\n\n\t\t\tView view = (View) object;\n\t\t\tTerminalView terminal = (TerminalView) view.findViewById(R.id.terminal_view);\n\t\t\tHostBean host = terminal.bridge.host;\n\n\t\t\tint itemIndex = POSITION_NONE;\n\t\t\tint i = 0;\n\t\t\tfor (TerminalBridge bridge : bound.getBridges()) {\n\t\t\t\tif (bridge.host.equals(host)) {\n\t\t\t\t\titemIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t\treturn itemIndex;\n\t\t}\n\n\t\tpublic TerminalBridge getBridgeAtPosition(int position) {\n\t\t\tif (bound == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tArrayList<TerminalBridge> bridges = bound.getBridges();\n\t\t\tif (position < 0 || position >= bridges.size()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn bridges.get(position);\n\t\t}\n\n\t\t@Override\n\t\tpublic void notifyDataSetChanged() {\n\t\t\tsuper.notifyDataSetChanged();\n\t\t\tif (tabs != null) {\n\t\t\t\ttoolbar.setVisibility(this.getCount() > 1 ? View.VISIBLE : View.GONE);\n\t\t\t\ttabs.setTabsFromPagerAdapter(this);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isViewFromObject(View view, Object object) {\n\t\t\treturn view == object;\n\t\t}\n\n\t\t@Override\n\t\tpublic CharSequence getPageTitle(int position) {\n\t\t\tTerminalBridge bridge = getBridgeAtPosition(position);\n\t\t\tif (bridge == null) {\n\t\t\t\treturn \"???\";\n\t\t\t}\n\t\t\treturn bridge.host.getNickname();\n\t\t}\n\n\t\tpublic TerminalView getCurrentTerminalView() {\n\t\t\tView currentView = pager.findViewWithTag(getBridgeAtPosition(pager.getCurrentItem()));\n\t\t\tif (currentView == null) return null;\n\t\t\treturn (TerminalView) currentView.findViewById(R.id.terminal_view);\n\t\t}\n\t}\n}\n","Method after Refactoring":"/*\n * ConnectBot: simple, powerful, open-source SSH client for Android\n * Copyright 2007 Kenny Root, Jeffrey Sharkey\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.connectbot;\n\nimport java.lang.ref.WeakReference;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.connectbot.bean.HostBean;\nimport org.connectbot.bean.SelectionArea;\nimport org.connectbot.service.BridgeDisconnectedListener;\nimport org.connectbot.service.PromptHelper;\nimport org.connectbot.service.TerminalBridge;\nimport org.connectbot.service.TerminalKeyListener;\nimport org.connectbot.service.TerminalManager;\nimport org.connectbot.util.PreferenceConstants;\n\nimport android.app.AlertDialog;\nimport android.app.Dialog;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.ServiceConnection;\nimport android.content.SharedPreferences;\nimport android.content.pm.ActivityInfo;\nimport android.content.res.Configuration;\nimport android.media.AudioManager;\nimport android.net.Uri;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Message;\nimport android.preference.PreferenceManager;\nimport android.support.annotation.Nullable;\nimport android.support.v4.app.ActivityCompat;\nimport android.support.design.widget.TabLayout;\nimport android.support.v4.view.MenuItemCompat;\nimport android.support.v4.view.MotionEventCompat;\nimport android.support.v4.view.PagerAdapter;\nimport android.support.v4.view.ViewPager;\nimport android.support.v7.app.ActionBar;\nimport android.support.v7.app.AppCompatActivity;\nimport android.support.v7.widget.Toolbar;\nimport android.text.ClipboardManager;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.GestureDetector;\nimport android.view.InputDevice;\nimport android.view.KeyEvent;\nimport android.view.LayoutInflater;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.MenuItem.OnMenuItemClickListener;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.view.View.OnClickListener;\nimport android.view.View.OnKeyListener;\nimport android.view.View.OnTouchListener;\nimport android.view.ViewConfiguration;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.WindowManager;\nimport android.view.animation.Animation;\nimport android.view.animation.AnimationUtils;\nimport android.view.inputmethod.InputMethodManager;\nimport android.widget.AdapterView;\nimport android.widget.AdapterView.OnItemClickListener;\nimport android.widget.ArrayAdapter;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.HorizontalScrollView;\nimport android.widget.ImageView;\nimport android.widget.LinearLayout;\nimport android.widget.ListView;\nimport android.widget.RelativeLayout;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport de.mud.terminal.vt320;\n\npublic class ConsoleActivity extends AppCompatActivity implements BridgeDisconnectedListener {\n\tpublic final static String TAG = \"CB.ConsoleActivity\";\n\n\tprotected static final int REQUEST_EDIT = 1;\n\n\tprivate static final int CLICK_TIME = 400;\n\tprivate static final float MAX_CLICK_DISTANCE = 25f;\n\tprivate static final int KEYBOARD_DISPLAY_TIME = 3000;\n\tprivate static final int KEYBOARD_REPEAT_INITIAL = 500;\n\tprivate static final int KEYBOARD_REPEAT = 100;\n\tprivate static final String STATE_SELECTED_URI = \"selectedUri\";\n\n\tprotected ViewPager pager = null;\n\tprotected TabLayout tabs = null;\n\tprotected Toolbar toolbar = null;\n\t@Nullable\n\tprotected TerminalManager bound = null;\n\tprotected TerminalPagerAdapter adapter = null;\n\tprotected LayoutInflater inflater = null;\n\n\tprivate SharedPreferences prefs = null;\n\n\t// determines whether or not menuitem accelerators are bound\n\t// otherwise they collide with an external keyboard's CTRL-char\n\tprivate boolean hardKeyboard = false;\n\n\tprotected Uri requested;\n\n\tprotected ClipboardManager clipboard;\n\tprivate RelativeLayout stringPromptGroup;\n\tprotected EditText stringPrompt;\n\tprivate TextView stringPromptInstructions;\n\n\tprivate RelativeLayout booleanPromptGroup;\n\tprivate TextView booleanPrompt;\n\tprivate Button booleanYes, booleanNo;\n\n\tprivate LinearLayout keyboardGroup;\n\tprivate Runnable keyboardGroupHider;\n\n\tprivate TextView empty;\n\n\tprivate Animation fade_out_delayed;\n\n\tprivate Animation keyboard_fade_in, keyboard_fade_out;\n\tprivate float lastX, lastY;\n\n\tprivate InputMethodManager inputManager;\n\n\tprivate MenuItem disconnect, copy, paste, portForward, resize, urlscan;\n\n\tprotected TerminalBridge copySource = null;\n\tprivate int lastTouchRow, lastTouchCol;\n\n\tprivate boolean forcedOrientation;\n\n\tprivate Handler handler = new Handler();\n\n\tprivate ImageView mKeyboardButton;\n\n\t@Nullable private ActionBar actionBar;\n\tprivate boolean inActionBarMenu = false;\n\tprivate boolean titleBarHide;\n\n\tprivate ServiceConnection connection = new ServiceConnection() {\n\t\tpublic void onServiceConnected(ComponentName className, IBinder service) {\n\t\t\tbound = ((TerminalManager.TerminalBinder) service).getService();\n\n\t\t\t// let manager know about our event handling services\n\t\t\tbound.disconnectListener = ConsoleActivity.this;\n\t\t\tbound.setResizeAllowed(true);\n\n\t\t\tfinal String requestedNickname = (requested != null) ? requested.getFragment() : null;\n\t\t\tint requestedIndex = 0;\n\n\t\t\tTerminalBridge requestedBridge = bound.getConnectedBridge(requestedNickname);\n\n\t\t\t// If we didn't find the requested connection, try opening it\n\t\t\tif (requestedNickname != null && requestedBridge == null) {\n\t\t\t\ttry {\n\t\t\t\t\tLog.d(TAG, String.format(\"We couldnt find an existing bridge with URI=%s (nickname=%s), so creating one now\", requested.toString(), requestedNickname));\n\t\t\t\t\trequestedBridge = bound.openConnection(requested);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tLog.e(TAG, \"Problem while trying to create new requested bridge from URI\", e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// create views for all bridges on this service\n\t\t\tadapter.notifyDataSetChanged();\n\t\t\trequestedIndex = bound.getBridges().indexOf(requestedBridge);\n\n\t\t\tsetDisplayedTerminal(requestedIndex == -1 ? 0 : requestedIndex);\n\t\t}\n\n\t\tpublic void onServiceDisconnected(ComponentName className) {\n\t\t\tadapter.notifyDataSetChanged();\n\t\t\tupdateEmptyVisible();\n\t\t\tbound = null;\n\t\t}\n\t};\n\n\tprotected Handler promptHandler = new Handler() {\n\t\t@Override\n\t\tpublic void handleMessage(Message msg) {\n\t\t\t// someone below us requested to display a prompt\n\t\t\tupdatePromptVisible();\n\t\t}\n\t};\n\n\tpublic void onDisconnected(TerminalBridge bridge) {\n\t\tsynchronized (adapter) {\n\t\t\tadapter.notifyDataSetChanged();\n\t\t\tLog.d(TAG, \"Someone sending HANDLE_DISCONNECT to parentHandler\");\n\n\t\t\tif (bridge.isAwaitingClose()) {\n\t\t\t\tcloseBridge(bridge);\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected OnClickListener emulatedKeysListener = new OnClickListener() {\n\t\t@Override\n\t\tpublic void onClick(View v) {\n\t\t\tonEmulatedKeyClicked(v);\n\t\t}\n\t};\n\n\tprotected Handler keyRepeatHandler = new Handler();\n\n\n\t/**\n\t * Handle repeatable virtual keys and touch events\n\t */\n\tpublic class KeyRepeater implements Runnable, OnTouchListener, OnClickListener {\n\t\tprivate View mView;\n\t\tprivate Handler mHandler;\n\t\tprivate boolean mDown;\n\n\t\tpublic KeyRepeater(Handler handler, View view) {\n\t\t\tmView = view;\n\t\t\tmHandler = handler;\n\t\t\tmView.setOnTouchListener(this);\n\t\t\tmView.setOnClickListener(this);\n\t\t\tmDown = false;\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tmDown = true;\n\t\t\tmHandler.removeCallbacks(this);\n\t\t\tmHandler.postDelayed(this, KEYBOARD_REPEAT);\n\t\t\tmView.performClick();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean onTouch(View v, MotionEvent event) {\n\t\t\tif (BuildConfig.DEBUG) {\n\t\t\t\tLog.d(TAG, \"KeyRepeater.onTouch(\" + v.getId() + \", \" +\n\t\t\t\t\t\tevent.getAction() + \", \" +\n\t\t\t\t\t\tevent.getActionIndex() + \", \" +\n\t\t\t\t\t\tevent.getActionMasked() + \");\");\n\t\t\t}\n\t\t\tswitch (event.getAction()) {\n\t\t\tcase MotionEvent.ACTION_DOWN:\n\t\t\t\tmDown = false;\n\t\t\t\tmHandler.postDelayed(this, KEYBOARD_REPEAT_INITIAL);\n\t\t\t\tmView.setPressed(true);\n\t\t\t\treturn (true);\n\n\t\t\tcase MotionEvent.ACTION_CANCEL:\n\t\t\t\tmHandler.removeCallbacks(this);\n\t\t\t\tmView.setPressed(false);\n\t\t\t\treturn (true);\n\n\t\t\tcase MotionEvent.ACTION_UP:\n\t\t\t\tmHandler.removeCallbacks(this);\n\t\t\t\tmView.setPressed(false);\n\n\t\t\t\tif (!mDown) {\n\t\t\t\t\tmView.performClick();\n\t\t\t\t}\n\t\t\t\treturn (true);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic void onClick(View view) {\n\t\t\tonEmulatedKeyClicked(view);\n\t\t}\n\t}\n\n\tprivate void onEmulatedKeyClicked(View v) {\n\t\tTerminalView terminal = adapter.getCurrentTerminalView();\n\t\tif (terminal == null) return;\n\n\t\tif (BuildConfig.DEBUG) {\n\t\t\tLog.d(TAG, \"onEmulatedKeyClicked(\" + v.getId() + \")\");\n\t\t}\n\t\tTerminalKeyListener handler = terminal.bridge.getKeyHandler();\n\t\tboolean hideKeys = false;\n\n\t\tswitch (v.getId()) {\n\t\tcase R.id.button_ctrl:\n\t\t\thandler.metaPress(TerminalKeyListener.OUR_CTRL_ON, true);\n\t\t\thideKeys = true;\n\t\t\tbreak;\n\t\tcase R.id.button_esc:\n\t\t\thandler.sendEscape();\n\t\t\thideKeys = true;\n\t\t\tbreak;\n\t\tcase R.id.button_tab:\n\t\t\thandler.sendTab();\n\t\t\thideKeys = true;\n\t\t\tbreak;\n\n\t\tcase R.id.button_up:\n\t\t\thandler.sendPressedKey(vt320.KEY_UP);\n\t\t\tbreak;\n\t\tcase R.id.button_down:\n\t\t\thandler.sendPressedKey(vt320.KEY_DOWN);\n\t\t\tbreak;\n\t\tcase R.id.button_left:\n\t\t\thandler.sendPressedKey(vt320.KEY_LEFT);\n\t\t\tbreak;\n\t\tcase R.id.button_right:\n\t\t\thandler.sendPressedKey(vt320.KEY_RIGHT);\n\t\t\tbreak;\n\n\t\tcase R.id.button_home:\n\t\t\thandler.sendPressedKey(vt320.KEY_HOME);\n\t\t\tbreak;\n\t\tcase R.id.button_end:\n\t\t\thandler.sendPressedKey(vt320.KEY_END);\n\t\t\tbreak;\n\t\tcase R.id.button_pgup:\n\t\t\thandler.sendPressedKey(vt320.KEY_PAGE_UP);\n\t\t\tbreak;\n\t\tcase R.id.button_pgdn:\n\t\t\thandler.sendPressedKey(vt320.KEY_PAGE_DOWN);\n\t\t\tbreak;\n\n\t\tcase R.id.button_f1:\n\t\t\thandler.sendPressedKey(vt320.KEY_F1);\n\t\t\tbreak;\n\t\tcase R.id.button_f2:\n\t\t\thandler.sendPressedKey(vt320.KEY_F2);\n\t\t\tbreak;\n\t\tcase R.id.button_f3:\n\t\t\thandler.sendPressedKey(vt320.KEY_F3);\n\t\t\tbreak;\n\t\tcase R.id.button_f4:\n\t\t\thandler.sendPressedKey(vt320.KEY_F4);\n\t\t\tbreak;\n\t\tcase R.id.button_f5:\n\t\t\thandler.sendPressedKey(vt320.KEY_F5);\n\t\t\tbreak;\n\t\tcase R.id.button_f6:\n\t\t\thandler.sendPressedKey(vt320.KEY_F6);\n\t\t\tbreak;\n\t\tcase R.id.button_f7:\n\t\t\thandler.sendPressedKey(vt320.KEY_F7);\n\t\t\tbreak;\n\t\tcase R.id.button_f8:\n\t\t\thandler.sendPressedKey(vt320.KEY_F8);\n\t\t\tbreak;\n\t\tcase R.id.button_f9:\n\t\t\thandler.sendPressedKey(vt320.KEY_F9);\n\t\t\tbreak;\n\t\tcase R.id.button_f10:\n\t\t\thandler.sendPressedKey(vt320.KEY_F10);\n\t\t\tbreak;\n\t\tcase R.id.button_f11:\n\t\t\thandler.sendPressedKey(vt320.KEY_F11);\n\t\t\tbreak;\n\t\tcase R.id.button_f12:\n\t\t\thandler.sendPressedKey(vt320.KEY_F12);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (hideKeys)\n\t\t\thideEmulatedKeys();\n\t\telse\n\t\t\tautoHideEmulatedKeys();\n\n\t\tterminal.bridge.tryKeyVibrate();\n\t\thideActionBarIfRequested();\n\t}\n\n\tprivate void hideActionBarIfRequested() {\n\t\tif (titleBarHide && actionBar != null) {\n\t\t\tactionBar.hide();\n\t\t}\n\t}\n\n\t/**\n\t * @param bridge\n\t */\n\tprivate void closeBridge(final TerminalBridge bridge) {\n\t\tupdateEmptyVisible();\n\t\tupdatePromptVisible();\n\n\t\t// If we just closed the last bridge, go back to the previous activity.\n\t\tif (pager.getChildCount() == 0) {\n\t\t\tfinish();\n\t\t}\n\t}\n\n\tprotected View findCurrentView(int id) {\n\t\tView view = pager.findViewWithTag(adapter.getBridgeAtPosition(pager.getCurrentItem()));\n\t\tif (view == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn view.findViewById(id);\n\t}\n\n\tprotected PromptHelper getCurrentPromptHelper() {\n\t\tTerminalView view = adapter.getCurrentTerminalView();\n\t\tif (view == null) return null;\n\t\treturn view.bridge.promptHelper;\n\t}\n\n\tprotected void hideAllPrompts() {\n\t\tstringPromptGroup.setVisibility(View.GONE);\n\t\tbooleanPromptGroup.setVisibility(View.GONE);\n\t}\n\n\tprivate void showEmulatedKeys(boolean showActionBar) {\n\t\tkeyboardGroup.startAnimation(keyboard_fade_in);\n\t\tkeyboardGroup.setVisibility(View.VISIBLE);\n\t\tif (showActionBar) {\n\t\t\tactionBar.show();\n\t\t}\n\t\tautoHideEmulatedKeys();\n\t}\n\n\tprivate void autoHideEmulatedKeys() {\n\t\tif (keyboardGroupHider != null)\n\t\t\thandler.removeCallbacks(keyboardGroupHider);\n\t\tkeyboardGroupHider = new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tif (keyboardGroup.getVisibility() == View.GONE || inActionBarMenu)\n\t\t\t\t\treturn;\n\n\t\t\t\tkeyboardGroup.startAnimation(keyboard_fade_out);\n\t\t\t\tkeyboardGroup.setVisibility(View.GONE);\n\t\t\t\thideActionBarIfRequested();\n\t\t\t\tkeyboardGroupHider = null;\n\t\t\t}\n\t\t};\n\t\thandler.postDelayed(keyboardGroupHider, KEYBOARD_DISPLAY_TIME);\n\t}\n\n\tprivate void hideEmulatedKeys() {\n\t\tif (keyboardGroupHider != null)\n\t\t\thandler.removeCallbacks(keyboardGroupHider);\n\t\tkeyboardGroup.setVisibility(View.GONE);\n\t\thideActionBarIfRequested();\n\t}\n\n\t@Override\n\tpublic void onCreate(Bundle icicle) {\n\t\tsuper.onCreate(icicle);\n\n\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD) {\n\t\t\tStrictModeSetup.run();\n\t\t}\n\n\t\thardKeyboard = getResources().getConfiguration().keyboard ==\n\t\t\t\tConfiguration.KEYBOARD_QWERTY;\n\n\t\tclipboard = (ClipboardManager) getSystemService(CLIPBOARD_SERVICE);\n\t\tprefs = PreferenceManager.getDefaultSharedPreferences(this);\n\n\t\ttitleBarHide = prefs.getBoolean(PreferenceConstants.TITLEBARHIDE, false);\n\t\tif (titleBarHide) {\n\t\t\tsupportRequestWindowFeature(Window.FEATURE_ACTION_BAR_OVERLAY);\n\t\t}\n\n\t\tthis.setContentView(R.layout.act_console);\n\n\t\t// hide status bar if requested by user\n\t\tif (prefs.getBoolean(PreferenceConstants.FULLSCREEN, false)) {\n\t\t\tgetWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,\n\t\t\t\t\tWindowManager.LayoutParams.FLAG_FULLSCREEN);\n\t\t}\n\n\t\t// TODO find proper way to disable volume key beep if it exists.\n\t\tsetVolumeControlStream(AudioManager.STREAM_MUSIC);\n\n\t\t// handle requested console from incoming intent\n\t\tif (icicle == null) {\n\t\t\trequested = getIntent().getData();\n\t\t} else {\n\t\t\tString uri = icicle.getString(STATE_SELECTED_URI);\n\t\t\tif (uri != null) {\n\t\t\t\trequested = Uri.parse(uri);\n\t\t\t}\n\t\t}\n\n\t\tinflater = LayoutInflater.from(this);\n\n\t\ttoolbar = (Toolbar) findViewById(R.id.toolbar);\n\t\tpager = (ViewPager) findViewById(R.id.console_flip);\n\t\tregisterForContextMenu(pager);\n\t\tpager.addOnPageChangeListener(\n\t\t\t\tnew ViewPager.SimpleOnPageChangeListener() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onPageSelected(int position) {\n\t\t\t\t\t\tsetTitle(adapter.getPageTitle(position));\n\t\t\t\t\t\tonTerminalChanged();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\tadapter = new TerminalPagerAdapter();\n\t\tpager.setAdapter(adapter);\n\n\t\tempty = (TextView) findViewById(android.R.id.empty);\n\n\t\tstringPromptGroup = (RelativeLayout) findViewById(R.id.console_password_group);\n\t\tstringPromptInstructions = (TextView) findViewById(R.id.console_password_instructions);\n\t\tstringPrompt = (EditText) findViewById(R.id.console_password);\n\t\tstringPrompt.setOnKeyListener(new OnKeyListener() {\n\t\t\tpublic boolean onKey(View v, int keyCode, KeyEvent event) {\n\t\t\t\tif (event.getAction() == KeyEvent.ACTION_UP) return false;\n\t\t\t\tif (keyCode != KeyEvent.KEYCODE_ENTER) return false;\n\n\t\t\t\t// pass collected password down to current terminal\n\t\t\t\tString value = stringPrompt.getText().toString();\n\n\t\t\t\tPromptHelper helper = getCurrentPromptHelper();\n\t\t\t\tif (helper == null) return false;\n\t\t\t\thelper.setResponse(value);\n\n\t\t\t\t// finally clear password for next user\n\t\t\t\tstringPrompt.setText(\"\");\n\t\t\t\tupdatePromptVisible();\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\tbooleanPromptGroup = (RelativeLayout) findViewById(R.id.console_boolean_group);\n\t\tbooleanPrompt = (TextView) findViewById(R.id.console_prompt);\n\n\t\tbooleanYes = (Button) findViewById(R.id.console_prompt_yes);\n\t\tbooleanYes.setOnClickListener(new OnClickListener() {\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tPromptHelper helper = getCurrentPromptHelper();\n\t\t\t\tif (helper == null) return;\n\t\t\t\thelper.setResponse(Boolean.TRUE);\n\t\t\t\tupdatePromptVisible();\n\t\t\t}\n\t\t});\n\n\t\tbooleanNo = (Button) findViewById(R.id.console_prompt_no);\n\t\tbooleanNo.setOnClickListener(new OnClickListener() {\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tPromptHelper helper = getCurrentPromptHelper();\n\t\t\t\tif (helper == null) return;\n\t\t\t\thelper.setResponse(Boolean.FALSE);\n\t\t\t\tupdatePromptVisible();\n\t\t\t}\n\t\t});\n\n\t\tfade_out_delayed = AnimationUtils.loadAnimation(this, R.anim.fade_out_delayed);\n\n\t\t// Preload animation for keyboard button\n\t\tkeyboard_fade_in = AnimationUtils.loadAnimation(this, R.anim.keyboard_fade_in);\n\t\tkeyboard_fade_out = AnimationUtils.loadAnimation(this, R.anim.keyboard_fade_out);\n\n\t\tinputManager = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);\n\n\t\tkeyboardGroup = (LinearLayout) findViewById(R.id.keyboard_group);\n\n\t\tmKeyboardButton = (ImageView) findViewById(R.id.button_keyboard);\n\t\tmKeyboardButton.setOnClickListener(new OnClickListener() {\n\t\t\tpublic void onClick(View view) {\n\t\t\t\tView terminal = adapter.getCurrentTerminalView();\n\t\t\t\tif (terminal == null)\n\t\t\t\t\treturn;\n\n\t\t\t\tinputManager.showSoftInput(terminal, InputMethodManager.SHOW_FORCED);\n\t\t\t\thideEmulatedKeys();\n\t\t\t}\n\t\t});\n\n\t\tfindViewById(R.id.button_ctrl).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_esc).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_tab).setOnClickListener(emulatedKeysListener);\n\n\t\tnew KeyRepeater(keyRepeatHandler, findViewById(R.id.button_up));\n\t\tnew KeyRepeater(keyRepeatHandler, findViewById(R.id.button_down));\n\t\tnew KeyRepeater(keyRepeatHandler, findViewById(R.id.button_left));\n\t\tnew KeyRepeater(keyRepeatHandler, findViewById(R.id.button_right));\n\n\t\tfindViewById(R.id.button_home).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_end).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_pgup).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_pgdn).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f1).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f2).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f3).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f4).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f5).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f6).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f7).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f8).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f9).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f10).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f11).setOnClickListener(emulatedKeysListener);\n\t\tfindViewById(R.id.button_f12).setOnClickListener(emulatedKeysListener);\n\n\n\t\tactionBar = getSupportActionBar();\n\t\tif (actionBar != null) {\n\t\t\tactionBar.setDisplayHomeAsUpEnabled(true);\n\t\t\tif (titleBarHide) {\n\t\t\t\tactionBar.hide();\n\t\t\t}\n\t\t\tactionBar.addOnMenuVisibilityListener(new ActionBar.OnMenuVisibilityListener() {\n\t\t\t\tpublic void onMenuVisibilityChanged(boolean isVisible) {\n\t\t\t\t\tinActionBarMenu = isVisible;\n\t\t\t\t\tif (isVisible == false) {\n\t\t\t\t\t\thideEmulatedKeys();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tfinal HorizontalScrollView keyboardScroll = (HorizontalScrollView) findViewById(R.id.keyboard_hscroll);\n\t\tif (!hardKeyboard) {\n\t\t\t// Show virtual keyboard and scroll back and forth\n\t\t\tshowEmulatedKeys(false);\n\t\t\tkeyboardScroll.postDelayed(new Runnable() {\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\tfinal int xscroll = findViewById(R.id.button_f12).getRight();\n\t\t\t\t\tif (BuildConfig.DEBUG) {\n\t\t\t\t\t\tLog.d(TAG, \"smoothScrollBy(toEnd[\" + xscroll + \"])\");\n\t\t\t\t\t}\n\t\t\t\t\tkeyboardScroll.smoothScrollBy(xscroll, 0);\n\t\t\t\t\tkeyboardScroll.postDelayed(new Runnable() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\tif (BuildConfig.DEBUG) {\n\t\t\t\t\t\t\t\tLog.d(TAG, \"smoothScrollBy(toStart[\" + (-xscroll) + \"])\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tkeyboardScroll.smoothScrollBy(-xscroll, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, 500);\n\t\t\t\t}\n\t\t\t}, 500);\n\t\t}\n\n\t\t// Reset keyboard auto-hide timer when scrolling\n\t\tkeyboardScroll.setOnTouchListener(\n\t\t\t\tnew OnTouchListener() {\n\t\t\t\t\tpublic boolean onTouch(View v, MotionEvent event) {\n\t\t\t\t\t\tswitch (event.getAction()) {\n\t\t\t\t\t\tcase MotionEvent.ACTION_MOVE:\n\t\t\t\t\t\t\tautoHideEmulatedKeys();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase MotionEvent.ACTION_UP:\n\t\t\t\t\t\t\tv.performClick();\n\t\t\t\t\t\t\treturn (true);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn (false);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\ttabs = (TabLayout) findViewById(R.id.tabs);\n\t\tif (tabs != null)\n\t\t\tsetupTabLayoutWithViewPager();\n\n\t\t// detect fling gestures to switch between terminals\n\t\tfinal GestureDetector detect = new GestureDetector(this, new GestureDetector.SimpleOnGestureListener() {\n\t\t\tprivate float totalY = 0;\n\n\t\t\t@Override\n\t\t\tpublic void onLongPress(MotionEvent e) {\n\t\t\t\tsuper.onLongPress(e);\n\t\t\t\topenContextMenu(pager);\n\t\t\t}\n\n\n\t\t\t@Override\n\t\t\tpublic boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {\n\n\t\t\t\t// if copying, then ignore\n\t\t\t\tif (copySource != null && copySource.isSelectingForCopy())\n\t\t\t\t\treturn false;\n\n\t\t\t\tif (e1 == null || e2 == null)\n\t\t\t\t\treturn false;\n\n\t\t\t\t// if releasing then reset total scroll\n\t\t\t\tif (e2.getAction() == MotionEvent.ACTION_UP) {\n\t\t\t\t\ttotalY = 0;\n\t\t\t\t}\n\n\t\t\t\t// activate consider if within x tolerance\n\t\t\t\tint touchSlop = ViewConfiguration.get(ConsoleActivity.this).getScaledTouchSlop();\n\t\t\t\tif (Math.abs(e1.getX() - e2.getX()) < touchSlop * 4) {\n\n\t\t\t\t\tView view = adapter.getCurrentTerminalView();\n\t\t\t\t\tif (view == null) return false;\n\t\t\t\t\tTerminalView terminal = (TerminalView) view;\n\n\t\t\t\t\t// estimate how many rows we have scrolled through\n\t\t\t\t\t// accumulate distance that doesn't trigger immediate scroll\n\t\t\t\t\ttotalY += distanceY;\n\t\t\t\t\tfinal int moved = (int) (totalY / terminal.bridge.charHeight);\n\n\t\t\t\t\t// consume as scrollback only if towards right half of screen\n\t\t\t\t\tif (e2.getX() > view.getWidth() / 2) {\n\t\t\t\t\t\tif (moved != 0) {\n\t\t\t\t\t\t\tint base = terminal.bridge.buffer.getWindowBase();\n\t\t\t\t\t\t\tterminal.bridge.buffer.setWindowBase(base + moved);\n\t\t\t\t\t\t\ttotalY = 0;\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// otherwise consume as pgup/pgdown for every 5 lines\n\t\t\t\t\t\tif (moved > 5) {\n\t\t\t\t\t\t\t((vt320) terminal.bridge.buffer).keyPressed(vt320.KEY_PAGE_DOWN, ' ', 0);\n\t\t\t\t\t\t\tterminal.bridge.tryKeyVibrate();\n\t\t\t\t\t\t\ttotalY = 0;\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t} else if (moved < -5) {\n\t\t\t\t\t\t\t((vt320) terminal.bridge.buffer).keyPressed(vt320.KEY_PAGE_UP, ' ', 0);\n\t\t\t\t\t\t\tterminal.bridge.tryKeyVibrate();\n\t\t\t\t\t\t\ttotalY = 0;\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t}\n\n\n\t\t});\n\n\t\tpager.setLongClickable(true);\n\t\tpager.setOnTouchListener(new OnTouchListener() {\n\n\t\t\tpublic boolean onTouch(View v, MotionEvent event) {\n\n\t\t\t\t// Handle mouse-specific actions.\n\t\t\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH &&\n\t\t\t\t\t\tMotionEventCompat.getSource(event) == InputDevice.SOURCE_MOUSE &&\n\t\t\t\t\t\tevent.getAction() == MotionEvent.ACTION_DOWN) {\n\t\t\t\t\tswitch (event.getButtonState()) {\n\t\t\t\t\tcase MotionEvent.BUTTON_PRIMARY:\n\t\t\t\t\t\t// Automatically start copy mode if using a mouse.\n\t\t\t\t\t\tstartCopyMode();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase MotionEvent.BUTTON_SECONDARY:\n\t\t\t\t\t\topenContextMenu(pager);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tcase MotionEvent.BUTTON_TERTIARY:\n\t\t\t\t\t\t// Middle click pastes.\n\t\t\t\t\t\tpasteIntoTerminal();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// when copying, highlight the area\n\t\t\t\tif (copySource != null && copySource.isSelectingForCopy()) {\n\t\t\t\t\tint row = (int) Math.floor(event.getY() / copySource.charHeight);\n\t\t\t\t\tint col = (int) Math.floor(event.getX() / copySource.charWidth);\n\n\t\t\t\t\tSelectionArea area = copySource.getSelectionArea();\n\n\t\t\t\t\tswitch (event.getAction()) {\n\t\t\t\t\tcase MotionEvent.ACTION_DOWN:\n\t\t\t\t\t\t// recording starting area\n\t\t\t\t\t\tif (area.isSelectingOrigin()) {\n\t\t\t\t\t\t\tarea.setRow(row);\n\t\t\t\t\t\t\tarea.setColumn(col);\n\t\t\t\t\t\t\tlastTouchRow = row;\n\t\t\t\t\t\t\tlastTouchCol = col;\n\t\t\t\t\t\t\tcopySource.redraw();\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tcase MotionEvent.ACTION_MOVE:\n\t\t\t\t\t\t/* ignore when user hasn't moved since last time so\n\t\t\t\t\t\t * we can fine-tune with directional pad\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (row == lastTouchRow && col == lastTouchCol)\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t// if the user moves, start the selection for other corner\n\t\t\t\t\t\tarea.finishSelectingOrigin();\n\n\t\t\t\t\t\t// update selected area\n\t\t\t\t\t\tarea.setRow(row);\n\t\t\t\t\t\tarea.setColumn(col);\n\t\t\t\t\t\tlastTouchRow = row;\n\t\t\t\t\t\tlastTouchCol = col;\n\t\t\t\t\t\tcopySource.redraw();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tcase MotionEvent.ACTION_UP:\n\t\t\t\t\t\t/* If they didn't move their finger, maybe they meant to\n\t\t\t\t\t\t * select the rest of the text with the directional pad.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (area.getLeft() == area.getRight() &&\n\t\t\t\t\t\t\t\tarea.getTop() == area.getBottom()) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// copy selected area to clipboard\n\t\t\t\t\t\tString copiedText = area.copyFrom(copySource.buffer);\n\n\t\t\t\t\t\tclipboard.setText(copiedText);\n\t\t\t\t\t\tToast.makeText(ConsoleActivity.this, getString(R.string.console_copy_done, copiedText.length()), Toast.LENGTH_LONG).show();\n\t\t\t\t\t\t// fall through to clear state\n\n\t\t\t\t\tcase MotionEvent.ACTION_CANCEL:\n\t\t\t\t\t\t// make sure we clear any highlighted area\n\t\t\t\t\t\tarea.reset();\n\t\t\t\t\t\tcopySource.setSelectingForCopy(false);\n\t\t\t\t\t\tcopySource.redraw();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (event.getAction() == MotionEvent.ACTION_DOWN) {\n\t\t\t\t\tlastX = event.getX();\n\t\t\t\t\tlastY = event.getY();\n\t\t\t\t} else if (event.getAction() == MotionEvent.ACTION_UP\n\t\t\t\t\t\t&& keyboardGroup.getVisibility() == View.GONE\n\t\t\t\t\t\t&& event.getEventTime() - event.getDownTime() < CLICK_TIME\n\t\t\t\t\t\t&& Math.abs(event.getX() - lastX) < MAX_CLICK_DISTANCE\n\t\t\t\t\t\t&& Math.abs(event.getY() - lastY) < MAX_CLICK_DISTANCE) {\n\t\t\t\t\tshowEmulatedKeys(true);\n\t\t\t\t}\n\n\t\t\t\t// pass any touch events back to detector\n\t\t\t\treturn detect.onTouchEvent(event);\n\t\t\t}\n\n\t\t});\n\t}\n\n\t/**\n\t * Ties the {@link TabLayout} to the {@link ViewPager}.\n\t *\n\t * <p>This method will:\n\t * <ul>\n\t *     <li>Add a {@link ViewPager.OnPageChangeListener} that will forward events to\n\t *     this TabLayout.<\/li>\n\t *     <li>Populate the TabLayout's tabs from the ViewPager's {@link PagerAdapter}.<\/li>\n\t *     <li>Set our {@link TabLayout.OnTabSelectedListener} which will forward\n\t *     selected events to the ViewPager<\/li>\n\t * <\/ul>\n\t * <\/p>\n\t */\n\tpublic void setupTabLayoutWithViewPager() {\n\t\ttabs.setTabsFromPagerAdapter(adapter);\n\t\tpager.addOnPageChangeListener(new TabLayout.TabLayoutOnPageChangeListener(tabs));\n\t\ttabs.setOnTabSelectedListener(new TabLayout.ViewPagerOnTabSelectedListener(pager));\n\n\t\tif (adapter.getCount() > 0) {\n\t\t\tfinal int curItem = pager.getCurrentItem();\n\t\t\tif (tabs.getSelectedTabPosition() != curItem) {\n\t\t\t\ttabs.getTabAt(curItem).select();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t *\n\t */\n\tprivate void configureOrientation() {\n\t\tString rotateDefault;\n\t\tif (getResources().getConfiguration().keyboard == Configuration.KEYBOARD_NOKEYS)\n\t\t\trotateDefault = PreferenceConstants.ROTATION_PORTRAIT;\n\t\telse\n\t\t\trotateDefault = PreferenceConstants.ROTATION_LANDSCAPE;\n\n\t\tString rotate = prefs.getString(PreferenceConstants.ROTATION, rotateDefault);\n\t\tif (PreferenceConstants.ROTATION_DEFAULT.equals(rotate))\n\t\t\trotate = rotateDefault;\n\n\t\t// request a forced orientation if requested by user\n\t\tif (PreferenceConstants.ROTATION_LANDSCAPE.equals(rotate)) {\n\t\t\tsetRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);\n\t\t\tforcedOrientation = true;\n\t\t} else if (PreferenceConstants.ROTATION_PORTRAIT.equals(rotate)) {\n\t\t\tsetRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);\n\t\t\tforcedOrientation = true;\n\t\t} else {\n\t\t\tsetRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);\n\t\t\tforcedOrientation = false;\n\t\t}\n\t}\n\n\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu) {\n\t\tsuper.onCreateOptionsMenu(menu);\n\n\t\tTerminalView view = adapter.getCurrentTerminalView();\n\t\tfinal boolean activeTerminal = view != null;\n\t\tboolean sessionOpen = false;\n\t\tboolean disconnected = false;\n\t\tboolean canForwardPorts = false;\n\n\t\tif (activeTerminal) {\n\t\t\tTerminalBridge bridge = view.bridge;\n\t\t\tsessionOpen = bridge.isSessionOpen();\n\t\t\tdisconnected = bridge.isDisconnected();\n\t\t\tcanForwardPorts = bridge.canFowardPorts();\n\t\t}\n\n\t\tmenu.setQwertyMode(true);\n\n\t\tdisconnect = menu.add(R.string.list_host_disconnect);\n\t\tif (hardKeyboard)\n\t\t\tdisconnect.setAlphabeticShortcut('w');\n\t\tif (!sessionOpen && disconnected)\n\t\t\tdisconnect.setTitle(R.string.console_menu_close);\n\t\tdisconnect.setEnabled(activeTerminal);\n\t\tdisconnect.setIcon(android.R.drawable.ic_menu_close_clear_cancel);\n\t\tdisconnect.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t// disconnect or close the currently visible session\n\t\t\t\tTerminalView terminalView = adapter.getCurrentTerminalView();\n\t\t\t\tTerminalBridge bridge = terminalView.bridge;\n\n\t\t\t\tbridge.dispatchDisconnect(true);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\tcopy = menu.add(R.string.console_menu_copy);\n\t\tif (hardKeyboard)\n\t\t\tcopy.setAlphabeticShortcut('c');\n\t\tMenuItemCompat.setShowAsAction(copy, MenuItemCompat.SHOW_AS_ACTION_IF_ROOM);\n\t\tcopy.setIcon(R.drawable.ic_action_copy);\n\t\tcopy.setEnabled(activeTerminal);\n\t\tcopy.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tstartCopyMode();\n\t\t\t\tToast.makeText(ConsoleActivity.this, getString(R.string.console_copy_start), Toast.LENGTH_LONG).show();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\tpaste = menu.add(R.string.console_menu_paste);\n\t\tif (hardKeyboard)\n\t\t\tpaste.setAlphabeticShortcut('v');\n\t\tMenuItemCompat.setShowAsAction(paste, MenuItemCompat.SHOW_AS_ACTION_IF_ROOM);\n\t\tpaste.setIcon(R.drawable.ic_action_paste);\n\t\tpaste.setEnabled(clipboard.hasText() && sessionOpen);\n\t\tpaste.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tpasteIntoTerminal();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\tportForward = menu.add(R.string.console_menu_portforwards);\n\t\tif (hardKeyboard)\n\t\t\tportForward.setAlphabeticShortcut('f');\n\t\tportForward.setIcon(android.R.drawable.ic_menu_manage);\n\t\tportForward.setEnabled(sessionOpen && canForwardPorts);\n\t\tportForward.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tTerminalView terminalView = adapter.getCurrentTerminalView();\n\t\t\t\tTerminalBridge bridge = terminalView.bridge;\n\n\t\t\t\tIntent intent = new Intent(ConsoleActivity.this, PortForwardListActivity.class);\n\t\t\t\tintent.putExtra(Intent.EXTRA_TITLE, bridge.host.getId());\n\t\t\t\tConsoleActivity.this.startActivityForResult(intent, REQUEST_EDIT);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\turlscan = menu.add(R.string.console_menu_urlscan);\n\t\tif (hardKeyboard)\n\t\t\turlscan.setAlphabeticShortcut('u');\n\t\turlscan.setIcon(android.R.drawable.ic_menu_search);\n\t\turlscan.setEnabled(activeTerminal);\n\t\turlscan.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tfinal TerminalView terminalView = adapter.getCurrentTerminalView();\n\n\t\t\t\tList<String> urls = terminalView.bridge.scanForURLs();\n\n\t\t\t\tDialog urlDialog = new Dialog(ConsoleActivity.this);\n\t\t\t\turlDialog.setTitle(R.string.console_menu_urlscan);\n\n\t\t\t\tListView urlListView = new ListView(ConsoleActivity.this);\n\t\t\t\tURLItemListener urlListener = new URLItemListener(ConsoleActivity.this);\n\t\t\t\turlListView.setOnItemClickListener(urlListener);\n\n\t\t\t\turlListView.setAdapter(new ArrayAdapter<String>(ConsoleActivity.this, android.R.layout.simple_list_item_1, urls));\n\t\t\t\turlDialog.setContentView(urlListView);\n\t\t\t\turlDialog.show();\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\tresize = menu.add(R.string.console_menu_resize);\n\t\tif (hardKeyboard)\n\t\t\tresize.setAlphabeticShortcut('s');\n\t\tresize.setIcon(android.R.drawable.ic_menu_crop);\n\t\tresize.setEnabled(sessionOpen);\n\t\tresize.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tfinal TerminalView terminalView = adapter.getCurrentTerminalView();\n\n\t\t\t\tfinal View resizeView = inflater.inflate(R.layout.dia_resize, null, false);\n\t\t\t\tnew AlertDialog.Builder(ConsoleActivity.this)\n\t\t\t\t\t\t.setView(resizeView)\n\t\t\t\t\t\t.setPositiveButton(R.string.button_resize, new DialogInterface.OnClickListener() {\n\t\t\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\t\t\t\tint width, height;\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\twidth = Integer.parseInt(((EditText) resizeView\n\t\t\t\t\t\t\t\t\t\t\t.findViewById(R.id.width))\n\t\t\t\t\t\t\t\t\t\t\t.getText().toString());\n\t\t\t\t\t\t\t\t\theight = Integer.parseInt(((EditText) resizeView\n\t\t\t\t\t\t\t\t\t\t\t.findViewById(R.id.height))\n\t\t\t\t\t\t\t\t\t\t\t.getText().toString());\n\t\t\t\t\t\t\t\t} catch (NumberFormatException nfe) {\n\t\t\t\t\t\t\t\t\t// TODO change this to a real dialog where we can\n\t\t\t\t\t\t\t\t\t// make the input boxes turn red to indicate an error.\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tterminalView.forceSize(width, height);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}).setNegativeButton(android.R.string.cancel, null).create().show();\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean onPrepareOptionsMenu(Menu menu) {\n\t\tsuper.onPrepareOptionsMenu(menu);\n\n\t\tsetVolumeControlStream(AudioManager.STREAM_NOTIFICATION);\n\n\t\tfinal TerminalView view = adapter.getCurrentTerminalView();\n\t\tboolean activeTerminal = view != null;\n\t\tboolean sessionOpen = false;\n\t\tboolean disconnected = false;\n\t\tboolean canForwardPorts = false;\n\n\t\tif (activeTerminal) {\n\t\t\tTerminalBridge bridge = view.bridge;\n\t\t\tsessionOpen = bridge.isSessionOpen();\n\t\t\tdisconnected = bridge.isDisconnected();\n\t\t\tcanForwardPorts = bridge.canFowardPorts();\n\t\t}\n\n\t\tdisconnect.setEnabled(activeTerminal);\n\t\tif (sessionOpen || !disconnected)\n\t\t\tdisconnect.setTitle(R.string.list_host_disconnect);\n\t\telse\n\t\t\tdisconnect.setTitle(R.string.console_menu_close);\n\t\tcopy.setEnabled(activeTerminal);\n\t\tpaste.setEnabled(clipboard.hasText() && sessionOpen);\n\t\tportForward.setEnabled(sessionOpen && canForwardPorts);\n\t\turlscan.setEnabled(activeTerminal);\n\t\tresize.setEnabled(sessionOpen);\n\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tswitch (item.getItemId()) {\n\t\tcase android.R.id.home:\n\t\t\tIntent intent = new Intent(this, HostListActivity.class);\n\t\t\tintent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n\t\t\tstartActivity(intent);\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn super.onOptionsItemSelected(item);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void onOptionsMenuClosed(Menu menu) {\n\t\tsuper.onOptionsMenuClosed(menu);\n\n\t\tsetVolumeControlStream(AudioManager.STREAM_MUSIC);\n\t}\n\n\t@Override\n\tpublic void onCreateContextMenu(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo) {\n\t\tfinal TerminalView view = adapter.getCurrentTerminalView();\n\t\tboolean activeTerminal = view != null;\n\t\tboolean sessionOpen = false;\n\n\t\tif (activeTerminal) {\n\t\t\tTerminalBridge bridge = view.bridge;\n\t\t\tsessionOpen = bridge.isSessionOpen();\n\t\t}\n\n\t\tMenuItem paste = menu.add(R.string.console_menu_paste);\n\t\tif (hardKeyboard)\n\t\t\tpaste.setAlphabeticShortcut('v');\n\t\tpaste.setIcon(android.R.drawable.ic_menu_edit);\n\t\tpaste.setEnabled(clipboard.hasText() && sessionOpen);\n\t\tpaste.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tpasteIntoTerminal();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\n\t}\n\n\t@Override\n\tpublic void onStart() {\n\t\tsuper.onStart();\n\n\t\t// connect with manager service to find all bridges\n\t\t// when connected it will insert all views\n\t\tbindService(new Intent(this, TerminalManager.class), connection, Context.BIND_AUTO_CREATE);\n\t}\n\n\t@Override\n\tpublic void onPause() {\n\t\tsuper.onPause();\n\t\tLog.d(TAG, \"onPause called\");\n\n\t\tif (forcedOrientation && bound != null) {\n\t\t\tbound.setResizeAllowed(false);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void onResume() {\n\t\tsuper.onResume();\n\t\tLog.d(TAG, \"onResume called\");\n\n\t\t// Make sure we don't let the screen fall asleep.\n\t\t// This also keeps the Wi-Fi chipset from disconnecting us.\n\t\tif (prefs.getBoolean(PreferenceConstants.KEEP_ALIVE, true)) {\n\t\t\tgetWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);\n\t\t} else {\n\t\t\tgetWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);\n\t\t}\n\n\t\tconfigureOrientation();\n\n\t\tif (forcedOrientation && bound != null) {\n\t\t\tbound.setResizeAllowed(true);\n\t\t}\n\t}\n\n\t/* (non-Javadoc)\n\t * @see android.app.Activity#onNewIntent(android.content.Intent)\n\t */\n\t@Override\n\tprotected void onNewIntent(Intent intent) {\n\t\tsuper.onNewIntent(intent);\n\n\t\tLog.d(TAG, \"onNewIntent called\");\n\n\t\trequested = intent.getData();\n\n\t\tif (requested == null) {\n\t\t\tLog.e(TAG, \"Got null intent data in onNewIntent()\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (bound == null) {\n\t\t\tLog.e(TAG, \"We're not bound in onNewIntent()\");\n\t\t\treturn;\n\t\t}\n\n\t\tTerminalBridge requestedBridge = bound.getConnectedBridge(requested.getFragment());\n\t\tint requestedIndex = 0;\n\n\t\tsynchronized (pager) {\n\t\t\tif (requestedBridge == null) {\n\t\t\t\t// If we didn't find the requested connection, try opening it\n\n\t\t\t\ttry {\n\t\t\t\t\tLog.d(TAG, String.format(\"We couldnt find an existing bridge with URI=%s (nickname=%s),\" +\n\t\t\t\t\t\t\t\"so creating one now\", requested.toString(), requested.getFragment()));\n\t\t\t\t\trequestedBridge = bound.openConnection(requested);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tLog.e(TAG, \"Problem while trying to create new requested bridge from URI\", e);\n\t\t\t\t\t// TODO: We should display an error dialog here.\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tadapter.notifyDataSetChanged();\n\t\t\t\trequestedIndex = adapter.getCount();\n\t\t\t} else {\n\t\t\t\tfinal int flipIndex = bound.getBridges().indexOf(requestedBridge);\n\t\t\t\tif (flipIndex > requestedIndex) {\n\t\t\t\t\trequestedIndex = flipIndex;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsetDisplayedTerminal(requestedIndex);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void onStop() {\n\t\tsuper.onStop();\n\n\t\tunbindService(connection);\n\t}\n\n\t@Override\n\tpublic void onSaveInstanceState(Bundle savedInstanceState) {\n\t\t// Maintain selected host if connected.\n\t\tif (adapter.getCurrentTerminalView() != null\n\t\t\t\t&& !adapter.getCurrentTerminalView().bridge.isDisconnected()) {\n\t\t\tUri uri = adapter.getCurrentTerminalView().bridge.host.getUri();\n\t\t\tsavedInstanceState.putString(STATE_SELECTED_URI, uri.toString());\n\t\t}\n\n\t\tsuper.onSaveInstanceState(savedInstanceState);\n\t}\n\n\tprivate void startCopyMode() {\n\t\t// mark as copying and reset any previous bounds\n\t\tTerminalView terminalView = (TerminalView) adapter.getCurrentTerminalView();\n\t\tcopySource = terminalView.bridge;\n\n\t\tSelectionArea area = copySource.getSelectionArea();\n\t\tarea.reset();\n\t\tarea.setBounds(copySource.buffer.getColumns(), copySource.buffer.getRows());\n\n\t\tcopySource.setSelectingForCopy(true);\n\n\t\t// Make sure we show the initial selection\n\t\tcopySource.redraw();\n\t}\n\n\t/**\n\t * Save the currently shown {@link TerminalView} as the default. This is\n\t * saved back down into {@link TerminalManager} where we can read it again\n\t * later.\n\t */\n\tprivate void updateDefault() {\n\t\t// update the current default terminal\n\t\tTerminalView view = adapter.getCurrentTerminalView();\n\t\tif (view == null || bound == null) {\n\t\t\treturn;\n\t\t}\n\t\tbound.defaultBridge = view.bridge;\n\t}\n\n\tprotected void updateEmptyVisible() {\n\t\t// update visibility of empty status message\n\t\tempty.setVisibility((pager.getChildCount() == 0) ? View.VISIBLE : View.GONE);\n\t}\n\n\t/**\n\t * Show any prompts requested by the currently visible {@link TerminalView}.\n\t */\n\tprotected void updatePromptVisible() {\n\t\t// check if our currently-visible terminalbridge is requesting any prompt services\n\t\tTerminalView view = adapter.getCurrentTerminalView();\n\n\t\t// Hide all the prompts in case a prompt request was canceled\n\t\thideAllPrompts();\n\n\t\tif (view == null) {\n\t\t\t// we dont have an active view, so hide any prompts\n\t\t\treturn;\n\t\t}\n\n\t\tPromptHelper prompt = view.bridge.promptHelper;\n\t\tif (String.class.equals(prompt.promptRequested)) {\n\t\t\tstringPromptGroup.setVisibility(View.VISIBLE);\n\n\t\t\tString instructions = prompt.promptInstructions;\n\t\t\tif (instructions != null && instructions.length() > 0) {\n\t\t\t\tstringPromptInstructions.setVisibility(View.VISIBLE);\n\t\t\t\tstringPromptInstructions.setText(instructions);\n\t\t\t} else\n\t\t\t\tstringPromptInstructions.setVisibility(View.GONE);\n\t\t\tstringPrompt.setText(\"\");\n\t\t\tstringPrompt.setHint(prompt.promptHint);\n\t\t\tstringPrompt.requestFocus();\n\n\t\t} else if (Boolean.class.equals(prompt.promptRequested)) {\n\t\t\tbooleanPromptGroup.setVisibility(View.VISIBLE);\n\t\t\tbooleanPrompt.setText(prompt.promptHint);\n\t\t\tbooleanYes.requestFocus();\n\n\t\t} else {\n\t\t\thideAllPrompts();\n\t\t\tview.requestFocus();\n\t\t}\n\t}\n\n\tprivate class URLItemListener implements OnItemClickListener {\n\t\tprivate WeakReference<Context> contextRef;\n\n\t\tURLItemListener(Context context) {\n\t\t\tthis.contextRef = new WeakReference<Context>(context);\n\t\t}\n\n\t\tpublic void onItemClick(AdapterView<?> arg0, View view, int position, long id) {\n\t\t\tContext context = contextRef.get();\n\n\t\t\tif (context == null)\n\t\t\t\treturn;\n\n\t\t\ttry {\n\t\t\t\tTextView urlView = (TextView) view;\n\n\t\t\t\tString url = urlView.getText().toString();\n\t\t\t\tif (url.indexOf(\"://\") < 0)\n\t\t\t\t\turl = \"http://\" + url;\n\n\t\t\t\tIntent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));\n\t\t\t\tcontext.startActivity(intent);\n\t\t\t} catch (Exception e) {\n\t\t\t\tLog.e(TAG, \"couldn't open URL\", e);\n\t\t\t\t// We should probably tell the user that we couldn't find a handler...\n\t\t\t}\n\t\t}\n\n\t}\n\n\t@Override\n\tpublic void onConfigurationChanged(Configuration newConfig) {\n\t\tsuper.onConfigurationChanged(newConfig);\n\n\t\tLog.d(TAG, String.format(\"onConfigurationChanged; requestedOrientation=%d, newConfig.orientation=%d\", getRequestedOrientation(), newConfig.orientation));\n\t\tif (bound != null) {\n\t\t\tif (forcedOrientation &&\n\t\t\t\t\t(newConfig.orientation != Configuration.ORIENTATION_LANDSCAPE &&\n\t\t\t\t\t\t\tgetRequestedOrientation() == ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE) ||\n\t\t\t\t\t(newConfig.orientation != Configuration.ORIENTATION_PORTRAIT &&\n\t\t\t\t\t\t\tgetRequestedOrientation() == ActivityInfo.SCREEN_ORIENTATION_PORTRAIT))\n\t\t\t\tbound.setResizeAllowed(false);\n\t\t\telse\n\t\t\t\tbound.setResizeAllowed(true);\n\n\t\t\tbound.hardKeyboardHidden = (newConfig.hardKeyboardHidden == Configuration.HARDKEYBOARDHIDDEN_YES);\n\n\t\t\tmKeyboardButton.setVisibility(bound.hardKeyboardHidden ? View.VISIBLE : View.GONE);\n\t\t}\n\t}\n\n\t/**\n\t * Called whenever the displayed terminal is changed.\n\t */\n\tprivate void onTerminalChanged() {\n\t\tView overlay = findCurrentView(R.id.terminal_overlay);\n\t\tif (overlay != null)\n\t\t\toverlay.startAnimation(fade_out_delayed);\n\t\tupdateDefault();\n\t\tupdatePromptVisible();\n\t\tActivityCompat.invalidateOptionsMenu(ConsoleActivity.this);\n\t}\n\n\t/**\n\t * Displays the child in the ViewPager at the requestedIndex and updates the prompts.\n\t *\n\t * @param requestedIndex the index of the terminal view to display\n\t */\n\tprivate void setDisplayedTerminal(int requestedIndex) {\n\t\tpager.setCurrentItem(requestedIndex);\n\t\t// set activity title\n\t\tsetTitle(adapter.getPageTitle(requestedIndex));\n\t\tonTerminalChanged();\n\t}\n\n\tprivate void pasteIntoTerminal() {\n\t\t// force insert of clipboard text into current console\n\t\tTerminalView terminalView = adapter.getCurrentTerminalView();\n\t\tTerminalBridge bridge = terminalView.bridge;\n\n\t\t// pull string from clipboard and generate all events to force down\n\t\tString clip = clipboard.getText().toString();\n\t\tbridge.injectString(clip);\n\t}\n\n\tpublic class TerminalPagerAdapter extends PagerAdapter {\n\t\t@Override\n\t\tpublic int getCount() {\n\t\t\tif (bound != null) {\n\t\t\t\treturn bound.getBridges().size();\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Object instantiateItem(ViewGroup container, int position) {\n\t\t\tif (bound == null || bound.getBridges().size() <= position) {\n\t\t\t\tLog.w(TAG, \"Activity not bound when creating TerminalView.\");\n\t\t\t}\n\t\t\tTerminalBridge bridge = bound.getBridges().get(position);\n\t\t\tbridge.promptHelper.setHandler(promptHandler);\n\n\t\t\t// inflate each terminal view\n\t\t\tRelativeLayout view = (RelativeLayout) inflater.inflate(\n\t\t\t\t\tR.layout.item_terminal, container, false);\n\n\t\t\t// set the terminal overlay text\n\t\t\tTextView overlay = (TextView) view.findViewById(R.id.terminal_overlay);\n\t\t\toverlay.setText(bridge.host.getNickname());\n\n\t\t\t// and add our terminal view control, using index to place behind overlay\n\t\t\tfinal TerminalView terminal = new TerminalView(container.getContext(), bridge);\n\t\t\tterminal.setId(R.id.terminal_view);\n\t\t\tview.addView(terminal, 0);\n\n\t\t\t// Tag the view with its bridge so it can be retrieved later.\n\t\t\tview.setTag(bridge);\n\n\t\t\tcontainer.addView(view);\n\t\t\toverlay.startAnimation(fade_out_delayed);\n\t\t\treturn view;\n\t\t}\n\n\t\t@Override\n\t\tpublic void destroyItem(ViewGroup container, int position, Object object) {\n\t\t\tfinal View view = (View) object;\n\n\t\t\tcontainer.removeView(view);\n\t\t}\n\n\t\t@Override\n\t\tpublic int getItemPosition(Object object) {\n\t\t\tif (bound == null) {\n\t\t\t\treturn POSITION_NONE;\n\t\t\t}\n\n\t\t\tView view = (View) object;\n\t\t\tTerminalView terminal = (TerminalView) view.findViewById(R.id.terminal_view);\n\t\t\tHostBean host = terminal.bridge.host;\n\n\t\t\tint itemIndex = POSITION_NONE;\n\t\t\tint i = 0;\n\t\t\tfor (TerminalBridge bridge : bound.getBridges()) {\n\t\t\t\tif (bridge.host.equals(host)) {\n\t\t\t\t\titemIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t\treturn itemIndex;\n\t\t}\n\n\t\tpublic TerminalBridge getBridgeAtPosition(int position) {\n\t\t\tif (bound == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tArrayList<TerminalBridge> bridges = bound.getBridges();\n\t\t\tif (position < 0 || position >= bridges.size()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn bridges.get(position);\n\t\t}\n\n\t\t@Override\n\t\tpublic void notifyDataSetChanged() {\n\t\t\tsuper.notifyDataSetChanged();\n\t\t\tif (tabs != null) {\n\t\t\t\ttoolbar.setVisibility(this.getCount() > 1 ? View.VISIBLE : View.GONE);\n\t\t\t\ttabs.setTabsFromPagerAdapter(this);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isViewFromObject(View view, Object object) {\n\t\t\treturn view == object;\n\t\t}\n\n\t\t@Override\n\t\tpublic CharSequence getPageTitle(int position) {\n\t\t\tTerminalBridge bridge = getBridgeAtPosition(position);\n\t\t\tif (bridge == null) {\n\t\t\t\treturn \"???\";\n\t\t\t}\n\t\t\treturn bridge.host.getNickname();\n\t\t}\n\n\t\tpublic TerminalView getCurrentTerminalView() {\n\t\t\tView currentView = pager.findViewWithTag(getBridgeAtPosition(pager.getCurrentItem()));\n\t\t\tif (currentView == null) return null;\n\t\t\treturn (TerminalView) currentView.findViewById(R.id.terminal_view);\n\t\t}\n\t}\n}\n","lineNo":491}
{"Smelly Sample":"/*\n * ConnectBot: simple, powerful, open-source SSH client for Android\n * Copyright 2007 Kenny Root, Jeffrey Sharkey\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.connectbot;\n\nimport java.lang.ref.WeakReference;\nimport java.util.List;\n\nimport org.connectbot.bean.HostBean;\nimport org.connectbot.bean.SelectionArea;\nimport org.connectbot.service.PromptHelper;\nimport org.connectbot.service.TerminalBridge;\nimport org.connectbot.service.TerminalKeyListener;\nimport org.connectbot.service.TerminalManager;\nimport org.connectbot.util.PreferenceConstants;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.app.Dialog;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.ServiceConnection;\nimport android.content.SharedPreferences;\nimport android.content.pm.ActivityInfo;\nimport android.content.res.Configuration;\nimport android.media.AudioManager;\nimport android.net.Uri;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Message;\nimport android.preference.PreferenceManager;\nimport android.support.v4.app.ActivityCompat;\nimport android.support.v4.view.MotionEventCompat;\nimport android.support.v4.view.PagerAdapter;\nimport android.support.v4.view.ViewPager;\nimport android.text.ClipboardManager;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.GestureDetector;\nimport android.view.InputDevice;\nimport android.view.KeyEvent;\nimport android.view.LayoutInflater;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.MenuItem.OnMenuItemClickListener;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.view.View.OnClickListener;\nimport android.view.View.OnKeyListener;\nimport android.view.View.OnTouchListener;\nimport android.view.ViewConfiguration;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.WindowManager;\nimport android.view.animation.Animation;\nimport android.view.animation.AnimationUtils;\nimport android.view.inputmethod.InputMethodManager;\nimport android.widget.AdapterView;\nimport android.widget.AdapterView.OnItemClickListener;\nimport android.widget.ArrayAdapter;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.ImageView;\nimport android.widget.LinearLayout;\nimport android.widget.ListView;\nimport android.widget.RelativeLayout;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport de.mud.terminal.vt320;\n\npublic class ConsoleActivity extends Activity {\n\tpublic final static String TAG = \"CB.ConsoleActivity\";\n\n\tprotected static final int REQUEST_EDIT = 1;\n\n\tprivate static final int CLICK_TIME = 400;\n\tprivate static final float MAX_CLICK_DISTANCE = 25f;\n\tprivate static final int KEYBOARD_DISPLAY_TIME = 1500;\n\n\tprotected ViewPager pager = null;\n\tprotected TerminalManager bound = null;\n\tprotected TerminalPagerAdapter adapter = null;\n\tprotected LayoutInflater inflater = null;\n\n\tprivate SharedPreferences prefs = null;\n\n\t// determines whether or not menuitem accelerators are bound\n\t// otherwise they collide with an external keyboard's CTRL-char\n\tprivate boolean hardKeyboard = false;\n\n\tprotected Uri requested;\n\n\tprotected ClipboardManager clipboard;\n\tprivate RelativeLayout stringPromptGroup;\n\tprotected EditText stringPrompt;\n\tprivate TextView stringPromptInstructions;\n\n\tprivate RelativeLayout booleanPromptGroup;\n\tprivate TextView booleanPrompt;\n\tprivate Button booleanYes, booleanNo;\n\n\tprivate LinearLayout keyboardGroup;\n\tprivate Runnable keyboardGroupHider;\n\n\tprivate TextView empty;\n\n\tprivate Animation fade_out_delayed;\n\n\tprivate Animation keyboard_fade_in, keyboard_fade_out;\n\tprivate float lastX, lastY;\n\n\tprivate InputMethodManager inputManager;\n\n\tprivate MenuItem disconnect, copy, paste, portForward, resize, urlscan;\n\n\tprotected TerminalBridge copySource = null;\n\tprivate int lastTouchRow, lastTouchCol;\n\n\tprivate boolean forcedOrientation;\n\n\tprivate Handler handler = new Handler();\n\n\tprivate ImageView mKeyboardButton;\n\n\tprivate ActionBarWrapper actionBar;\n\tprivate boolean inActionBarMenu = false;\n\tprivate boolean titleBarHide;\n\n\tprivate ServiceConnection connection = new ServiceConnection() {\n\t\tpublic void onServiceConnected(ComponentName className, IBinder service) {\n\t\t\tbound = ((TerminalManager.TerminalBinder) service).getService();\n\n\t\t\t// let manager know about our event handling services\n\t\t\tbound.disconnectHandler = disconnectHandler;\n\t\t\tbound.setResizeAllowed(true);\n\n\t\t\tfinal String requestedNickname = (requested != null) ? requested.getFragment() : null;\n\t\t\tint requestedIndex = 0;\n\n\t\t\tTerminalBridge requestedBridge = bound.getConnectedBridge(requestedNickname);\n\n\t\t\t// If we didn't find the requested connection, try opening it\n\t\t\tif (requestedNickname != null && requestedBridge == null) {\n\t\t\t\ttry {\n\t\t\t\t\tLog.d(TAG, String.format(\"We couldnt find an existing bridge with URI=%s (nickname=%s), so creating one now\", requested.toString(), requestedNickname));\n\t\t\t\t\trequestedBridge = bound.openConnection(requested);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tLog.e(TAG, \"Problem while trying to create new requested bridge from URI\", e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// create views for all bridges on this service\n\t\t\tadapter.notifyDataSetChanged();\n\t\t\trequestedIndex = bound.getBridges().indexOf(requestedBridge);\n\n\t\t\tsetDisplayedTerminal(requestedIndex == -1 ? 0 : requestedIndex);\n\t\t}\n\n\t\tpublic void onServiceDisconnected(ComponentName className) {\n\t\t\tadapter.notifyDataSetChanged();\n\t\t\tupdateEmptyVisible();\n\t\t\tbound = null;\n\t\t}\n\t};\n\n\tprotected Handler promptHandler = new Handler() {\n\t\t@Override\n\t\tpublic void handleMessage(Message msg) {\n\t\t\t// someone below us requested to display a prompt\n\t\t\tupdatePromptVisible();\n\t\t}\n\t};\n\n\tprotected Handler disconnectHandler = new Handler() {\n\t\t@Override\n\t\tpublic void handleMessage(Message msg) {\n\t\t\tLog.d(TAG, \"Someone sending HANDLE_DISCONNECT to parentHandler\");\n\n\t\t\t// someone below us requested to display a password dialog\n\t\t\t// they are sending nickname and requested\n\t\t\tTerminalBridge bridge = (TerminalBridge) msg.obj;\n\n\t\t\tadapter.notifyDataSetChanged();\n\t\t\tif (bridge.isAwaitingClose()) {\n\t\t\t\tcloseBridge(bridge);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * @param bridge\n\t */\n\tprivate void closeBridge(final TerminalBridge bridge) {\n\t\tsynchronized (pager) {\n\t\t\tupdateEmptyVisible();\n\t\t\tupdatePromptVisible();\n\n\t\t\t// If we just closed the last bridge, go back to the previous activity.\n\t\t\tif (pager.getChildCount() == 0) {\n\t\t\t\tfinish();\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected View findCurrentView(int id) {\n\t\tTerminalView view = adapter.getCurrentTerminalView();\n\t\tif (view == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn view.findViewById(id);\n\t}\n\n\tprotected PromptHelper getCurrentPromptHelper() {\n\t\tTerminalView view = adapter.getCurrentTerminalView();\n\t\tif (view == null) return null;\n\t\treturn view.bridge.promptHelper;\n\t}\n\n\tprotected void hideAllPrompts() {\n\t\tstringPromptGroup.setVisibility(View.GONE);\n\t\tbooleanPromptGroup.setVisibility(View.GONE);\n\t}\n\n\tprivate void showEmulatedKeys() {\n\t\tkeyboardGroup.startAnimation(keyboard_fade_in);\n\t\tkeyboardGroup.setVisibility(View.VISIBLE);\n\t\tactionBar.show();\n\n\t\tif (keyboardGroupHider != null)\n\t\t\thandler.removeCallbacks(keyboardGroupHider);\n\t\tkeyboardGroupHider = new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tif (keyboardGroup.getVisibility() == View.GONE || inActionBarMenu)\n\t\t\t\t\treturn;\n\n\t\t\t\tkeyboardGroup.startAnimation(keyboard_fade_out);\n\t\t\t\tkeyboardGroup.setVisibility(View.GONE);\n\t\t\t\tif (titleBarHide) {\n\t\t\t\t\tactionBar.hide();\n\t\t\t\t}\n\t\t\t\tkeyboardGroupHider = null;\n\t\t\t}\n\t\t};\n\t\thandler.postDelayed(keyboardGroupHider, KEYBOARD_DISPLAY_TIME);\n\t}\n\n\tprivate void hideEmulatedKeys() {\n\t\tif (keyboardGroupHider != null)\n\t\t\thandler.removeCallbacks(keyboardGroupHider);\n\t\tkeyboardGroup.setVisibility(View.GONE);\n\t\tif (titleBarHide) {\n\t\t\tactionBar.hide();\n\t\t}\n\t}\n\n\t@Override\n\tpublic void onCreate(Bundle icicle) {\n\t\tsuper.onCreate(icicle);\n\n\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD) {\n\t\t\tStrictModeSetup.run();\n\t\t}\n\n\t\thardKeyboard = getResources().getConfiguration().keyboard ==\n\t\t\t\tConfiguration.KEYBOARD_QWERTY;\n\n\t\tclipboard = (ClipboardManager) getSystemService(CLIPBOARD_SERVICE);\n\t\tprefs = PreferenceManager.getDefaultSharedPreferences(this);\n\n\t\ttitleBarHide = prefs.getBoolean(PreferenceConstants.TITLEBARHIDE, false);\n\t\tif (titleBarHide) {\n\t\t\tgetWindow().requestFeature(Window.FEATURE_ACTION_BAR_OVERLAY);\n\t\t}\n\n\t\tthis.setContentView(R.layout.act_console);\n\n\t\t// hide status bar if requested by user\n\t\tif (prefs.getBoolean(PreferenceConstants.FULLSCREEN, false)) {\n\t\t\tgetWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,\n\t\t\t\t\tWindowManager.LayoutParams.FLAG_FULLSCREEN);\n\t\t}\n\n\t\t// TODO find proper way to disable volume key beep if it exists.\n\t\tsetVolumeControlStream(AudioManager.STREAM_MUSIC);\n\n\t\t// handle requested console from incoming intent\n\t\trequested = getIntent().getData();\n\n\t\tinflater = LayoutInflater.from(this);\n\n\t\tpager = (ViewPager) findViewById(R.id.console_flip);\n\t\tregisterForContextMenu(pager);\n\t\tpager.addOnPageChangeListener(\n\t\t\t\tnew ViewPager.SimpleOnPageChangeListener() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onPageSelected(int position) {\n\t\t\t\t\t\tonTerminalChanged();\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tempty = (TextView) findViewById(android.R.id.empty);\n\n\t\tstringPromptGroup = (RelativeLayout) findViewById(R.id.console_password_group);\n\t\tstringPromptInstructions = (TextView) findViewById(R.id.console_password_instructions);\n\t\tstringPrompt = (EditText) findViewById(R.id.console_password);\n\t\tstringPrompt.setOnKeyListener(new OnKeyListener() {\n\t\t\tpublic boolean onKey(View v, int keyCode, KeyEvent event) {\n\t\t\t\tif (event.getAction() == KeyEvent.ACTION_UP) return false;\n\t\t\t\tif (keyCode != KeyEvent.KEYCODE_ENTER) return false;\n\n\t\t\t\t// pass collected password down to current terminal\n\t\t\t\tString value = stringPrompt.getText().toString();\n\n\t\t\t\tPromptHelper helper = getCurrentPromptHelper();\n\t\t\t\tif (helper == null) return false;\n\t\t\t\thelper.setResponse(value);\n\n\t\t\t\t// finally clear password for next user\n\t\t\t\tstringPrompt.setText(\"\");\n\t\t\t\tupdatePromptVisible();\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\tbooleanPromptGroup = (RelativeLayout) findViewById(R.id.console_boolean_group);\n\t\tbooleanPrompt = (TextView) findViewById(R.id.console_prompt);\n\n\t\tbooleanYes = (Button) findViewById(R.id.console_prompt_yes);\n\t\tbooleanYes.setOnClickListener(new OnClickListener() {\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tPromptHelper helper = getCurrentPromptHelper();\n\t\t\t\tif (helper == null) return;\n\t\t\t\thelper.setResponse(Boolean.TRUE);\n\t\t\t\tupdatePromptVisible();\n\t\t\t}\n\t\t});\n\n\t\tbooleanNo = (Button) findViewById(R.id.console_prompt_no);\n\t\tbooleanNo.setOnClickListener(new OnClickListener() {\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tPromptHelper helper = getCurrentPromptHelper();\n\t\t\t\tif (helper == null) return;\n\t\t\t\thelper.setResponse(Boolean.FALSE);\n\t\t\t\tupdatePromptVisible();\n\t\t\t}\n\t\t});\n\n\t\tfade_out_delayed = AnimationUtils.loadAnimation(this, R.anim.fade_out_delayed);\n\n\t\t// Preload animation for keyboard button\n\t\tkeyboard_fade_in = AnimationUtils.loadAnimation(this, R.anim.keyboard_fade_in);\n\t\tkeyboard_fade_out = AnimationUtils.loadAnimation(this, R.anim.keyboard_fade_out);\n\n\t\tinputManager = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);\n\n\t\tkeyboardGroup = (LinearLayout) findViewById(R.id.keyboard_group);\n\n\t\tmKeyboardButton = (ImageView) findViewById(R.id.button_keyboard);\n\t\tmKeyboardButton.setOnClickListener(new OnClickListener() {\n\t\t\tpublic void onClick(View view) {\n\t\t\t\tView terminal = adapter.getCurrentTerminalView();\n\t\t\t\tif (terminal == null)\n\t\t\t\t\treturn;\n\n\t\t\t\tinputManager.showSoftInput(terminal, InputMethodManager.SHOW_FORCED);\n\t\t\t\thideEmulatedKeys();\n\t\t\t}\n\t\t});\n\n\t\tfinal Button ctrlButton = (Button) findViewById(R.id.button_ctrl);\n\t\tctrlButton.setOnClickListener(new OnClickListener() {\n\t\t\tpublic void onClick(View view) {\n\t\t\t\tTerminalView terminal = adapter.getCurrentTerminalView();\n\t\t\t\tif (terminal == null) return;\n\n\t\t\t\tTerminalKeyListener handler = terminal.bridge.getKeyHandler();\n\t\t\t\thandler.metaPress(TerminalKeyListener.OUR_CTRL_ON, true);\n\t\t\t\thideEmulatedKeys();\n\t\t\t}\n\t\t});\n\n\t\tfinal Button escButton = (Button) findViewById(R.id.button_esc);\n\t\tescButton.setOnClickListener(new OnClickListener() {\n\t\t\tpublic void onClick(View view) {\n\t\t\t\tTerminalView terminal = adapter.getCurrentTerminalView();\n\t\t\t\tif (terminal == null) return;\n\n\t\t\t\tTerminalKeyListener handler = terminal.bridge.getKeyHandler();\n\t\t\t\thandler.sendEscape();\n\t\t\t\thideEmulatedKeys();\n\t\t\t}\n\t\t});\n\n\t\tfinal Button tabButton = (Button) findViewById(R.id.button_tab);\n\t\ttabButton.setOnClickListener(new OnClickListener() {\n\t\t\tpublic void onClick(View view) {\n\t\t\t\tTerminalView terminal = adapter.getCurrentTerminalView();\n\t\t\t\tif (terminal == null) return;\n\n\t\t\t\tTerminalKeyListener handler = terminal.bridge.getKeyHandler();\n\t\t\t\thandler.sendTab();\n\t\t\t\thideEmulatedKeys();\n\t\t\t}\n\t\t});\n\t\tfinal Button upButton = (Button) findViewById(R.id.button_up);\n\t\tupButton.setOnClickListener(new OnClickListener() {\n\t\t\tpublic void onClick(View view) {\n\t\t\t\tView flip = findCurrentView(R.id.console_flip);\n\t\t\t\tif (flip == null) return;\n\t\t\t\tTerminalView terminal = (TerminalView) flip;\n\n\n\t\t\t\tTerminalKeyListener handler = terminal.bridge.getKeyHandler();\n\t\t\t\thandler.sendPressedKey(vt320.KEY_UP);\n\t\t\t}\n\t\t});\n\t\tfinal Button dnButton = (Button) findViewById(R.id.button_down);\n\t\tdnButton.setOnClickListener(new OnClickListener() {\n\t\t\tpublic void onClick(View view) {\n\t\t\t\tView flip = findCurrentView(R.id.console_flip);\n\t\t\t\tif (flip == null) return;\n\t\t\t\tTerminalView terminal = (TerminalView) flip;\n\n\t\t\t\tTerminalKeyListener handler = terminal.bridge.getKeyHandler();\n\t\t\t\thandler.sendPressedKey(vt320.KEY_DOWN);\n\t\t\t}\n\t\t});\n\t\tfinal Button leftButton = (Button) findViewById(R.id.button_left);\n\t\tleftButton.setOnClickListener(new OnClickListener() {\n\t\t\tpublic void onClick(View view) {\n\t\t\t\tView flip = findCurrentView(R.id.console_flip);\n\t\t\t\tif (flip == null) return;\n\t\t\t\tTerminalView terminal = (TerminalView) flip;\n\n\t\t\t\tTerminalKeyListener handler = terminal.bridge.getKeyHandler();\n\t\t\t\thandler.sendPressedKey(vt320.KEY_LEFT);\n\t\t\t}\n\t\t});\n\t\tfinal Button rightButton = (Button) findViewById(R.id.button_right);\n\t\trightButton.setOnClickListener(new OnClickListener() {\n\t\t\tpublic void onClick(View view) {\n\t\t\t\tView flip = findCurrentView(R.id.console_flip);\n\t\t\t\tif (flip == null) return;\n\t\t\t\tTerminalView terminal = (TerminalView) flip;\n\n\t\t\t\tTerminalKeyListener handler = terminal.bridge.getKeyHandler();\n\t\t\t\thandler.sendPressedKey(vt320.KEY_RIGHT);\n\t\t\t}\n\t\t});\n\n\t\tactionBar = ActionBarWrapper.getActionBar(this);\n\t\tactionBar.setDisplayHomeAsUpEnabled(true);\n\t\tif (titleBarHide) {\n\t\t\tactionBar.hide();\n\t\t}\n\t\tactionBar.addOnMenuVisibilityListener(new ActionBarWrapper.OnMenuVisibilityListener() {\n\t\t\tpublic void onMenuVisibilityChanged(boolean isVisible) {\n\t\t\t\tinActionBarMenu = isVisible;\n\t\t\t\tif (isVisible == false) {\n\t\t\t\t\thideEmulatedKeys();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t// detect fling gestures to switch between terminals\n\t\tfinal GestureDetector detect = new GestureDetector(this, new GestureDetector.SimpleOnGestureListener() {\n\t\t\tprivate float totalY = 0;\n\n\t\t\t@Override\n\t\t\tpublic void onLongPress(MotionEvent e) {\n\t\t\t\tsuper.onLongPress(e);\n\t\t\t\topenContextMenu(pager);\n\t\t\t}\n\n\n\t\t\t@Override\n\t\t\tpublic boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {\n\n\t\t\t\t// if copying, then ignore\n\t\t\t\tif (copySource != null && copySource.isSelectingForCopy())\n\t\t\t\t\treturn false;\n\n\t\t\t\tif (e1 == null || e2 == null)\n\t\t\t\t\treturn false;\n\n\t\t\t\t// if releasing then reset total scroll\n\t\t\t\tif (e2.getAction() == MotionEvent.ACTION_UP) {\n\t\t\t\t\ttotalY = 0;\n\t\t\t\t}\n\n\t\t\t\t// activate consider if within x tolerance\n\t\t\t\tint touchSlop = ViewConfiguration.get(ConsoleActivity.this).getScaledTouchSlop();\n\t\t\t\tif (Math.abs(e1.getX() - e2.getX()) < touchSlop * 4) {\n\n\t\t\t\t\tView view = adapter.getCurrentTerminalView();\n\t\t\t\t\tif (view == null) return false;\n\t\t\t\t\tTerminalView terminal = (TerminalView) view;\n\n\t\t\t\t\t// estimate how many rows we have scrolled through\n\t\t\t\t\t// accumulate distance that doesn't trigger immediate scroll\n\t\t\t\t\ttotalY += distanceY;\n\t\t\t\t\tfinal int moved = (int) (totalY / terminal.bridge.charHeight);\n\n\t\t\t\t\t// consume as scrollback only if towards right half of screen\n\t\t\t\t\tif (e2.getX() > view.getWidth() / 2) {\n\t\t\t\t\t\tif (moved != 0) {\n\t\t\t\t\t\t\tint base = terminal.bridge.buffer.getWindowBase();\n\t\t\t\t\t\t\tterminal.bridge.buffer.setWindowBase(base + moved);\n\t\t\t\t\t\t\ttotalY = 0;\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// otherwise consume as pgup/pgdown for every 5 lines\n\t\t\t\t\t\tif (moved > 5) {\n\t\t\t\t\t\t\t((vt320) terminal.bridge.buffer).keyPressed(vt320.KEY_PAGE_DOWN, ' ', 0);\n\t\t\t\t\t\t\tterminal.bridge.tryKeyVibrate();\n\t\t\t\t\t\t\ttotalY = 0;\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t} else if (moved < -5) {\n\t\t\t\t\t\t\t((vt320) terminal.bridge.buffer).keyPressed(vt320.KEY_PAGE_UP, ' ', 0);\n\t\t\t\t\t\t\tterminal.bridge.tryKeyVibrate();\n\t\t\t\t\t\t\ttotalY = 0;\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t}\n\n\n\t\t});\n\n\t\tpager.setLongClickable(true);\n\t\tpager.setOnTouchListener(new OnTouchListener() {\n\n\t\t\tpublic boolean onTouch(View v, MotionEvent event) {\n\n\t\t\t\t// Handle mouse-specific actions.\n\t\t\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH &&\n\t\t\t\t\t\tMotionEventCompat.getSource(event) == InputDevice.SOURCE_MOUSE &&\n\t\t\t\t\t\tevent.getAction() == MotionEvent.ACTION_DOWN) {\n\t\t\t\t\tswitch (event.getButtonState()) {\n\t\t\t\t\tcase MotionEvent.BUTTON_PRIMARY:\n\t\t\t\t\t\t// Automatically start copy mode if using a mouse.\n\t\t\t\t\t\tstartCopyMode();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase MotionEvent.BUTTON_SECONDARY:\n\t\t\t\t\t\topenContextMenu(pager);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tcase MotionEvent.BUTTON_TERTIARY:\n\t\t\t\t\t\t// Middle click pastes.\n\t\t\t\t\t\tpasteIntoTerminal();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// when copying, highlight the area\n\t\t\t\tif (copySource != null && copySource.isSelectingForCopy()) {\n\t\t\t\t\tint row = (int) Math.floor(event.getY() / copySource.charHeight);\n\t\t\t\t\tint col = (int) Math.floor(event.getX() / copySource.charWidth);\n\n\t\t\t\t\tSelectionArea area = copySource.getSelectionArea();\n\n\t\t\t\t\tswitch (event.getAction()) {\n\t\t\t\t\tcase MotionEvent.ACTION_DOWN:\n\t\t\t\t\t\t// recording starting area\n\t\t\t\t\t\tif (area.isSelectingOrigin()) {\n\t\t\t\t\t\t\tarea.setRow(row);\n\t\t\t\t\t\t\tarea.setColumn(col);\n\t\t\t\t\t\t\tlastTouchRow = row;\n\t\t\t\t\t\t\tlastTouchCol = col;\n\t\t\t\t\t\t\tcopySource.redraw();\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tcase MotionEvent.ACTION_MOVE:\n\t\t\t\t\t\t/* ignore when user hasn't moved since last time so\n\t\t\t\t\t\t * we can fine-tune with directional pad\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (row == lastTouchRow && col == lastTouchCol)\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t// if the user moves, start the selection for other corner\n\t\t\t\t\t\tarea.finishSelectingOrigin();\n\n\t\t\t\t\t\t// update selected area\n\t\t\t\t\t\tarea.setRow(row);\n\t\t\t\t\t\tarea.setColumn(col);\n\t\t\t\t\t\tlastTouchRow = row;\n\t\t\t\t\t\tlastTouchCol = col;\n\t\t\t\t\t\tcopySource.redraw();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tcase MotionEvent.ACTION_UP:\n\t\t\t\t\t\t/* If they didn't move their finger, maybe they meant to\n\t\t\t\t\t\t * select the rest of the text with the directional pad.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (area.getLeft() == area.getRight() &&\n\t\t\t\t\t\t\t\tarea.getTop() == area.getBottom()) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// copy selected area to clipboard\n\t\t\t\t\t\tString copiedText = area.copyFrom(copySource.buffer);\n\n\t\t\t\t\t\tclipboard.setText(copiedText);\n\t\t\t\t\t\tToast.makeText(ConsoleActivity.this, getString(R.string.console_copy_done, copiedText.length()), Toast.LENGTH_LONG).show();\n\t\t\t\t\t\t// fall through to clear state\n\n\t\t\t\t\tcase MotionEvent.ACTION_CANCEL:\n\t\t\t\t\t\t// make sure we clear any highlighted area\n\t\t\t\t\t\tarea.reset();\n\t\t\t\t\t\tcopySource.setSelectingForCopy(false);\n\t\t\t\t\t\tcopySource.redraw();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (event.getAction() == MotionEvent.ACTION_DOWN) {\n\t\t\t\t\tlastX = event.getX();\n\t\t\t\t\tlastY = event.getY();\n\t\t\t\t} else if (event.getAction() == MotionEvent.ACTION_UP\n\t\t\t\t\t\t&& keyboardGroup.getVisibility() == View.GONE\n\t\t\t\t\t\t&& event.getEventTime() - event.getDownTime() < CLICK_TIME\n\t\t\t\t\t\t&& Math.abs(event.getX() - lastX) < MAX_CLICK_DISTANCE\n\t\t\t\t\t\t&& Math.abs(event.getY() - lastY) < MAX_CLICK_DISTANCE) {\n\t\t\t\t\tshowEmulatedKeys();\n\t\t\t\t}\n\n\t\t\t\t// pass any touch events back to detector\n\t\t\t\treturn detect.onTouchEvent(event);\n\t\t\t}\n\n\t\t});\n\n\t\tadapter = new TerminalPagerAdapter();\n\t\tpager.setAdapter(adapter);\n\t}\n\n\t/**\n\t *\n\t */\n\tprivate void configureOrientation() {\n\t\tString rotateDefault;\n\t\tif (getResources().getConfiguration().keyboard == Configuration.KEYBOARD_NOKEYS)\n\t\t\trotateDefault = PreferenceConstants.ROTATION_PORTRAIT;\n\t\telse\n\t\t\trotateDefault = PreferenceConstants.ROTATION_LANDSCAPE;\n\n\t\tString rotate = prefs.getString(PreferenceConstants.ROTATION, rotateDefault);\n\t\tif (PreferenceConstants.ROTATION_DEFAULT.equals(rotate))\n\t\t\trotate = rotateDefault;\n\n\t\t// request a forced orientation if requested by user\n\t\tif (PreferenceConstants.ROTATION_LANDSCAPE.equals(rotate)) {\n\t\t\tsetRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);\n\t\t\tforcedOrientation = true;\n\t\t} else if (PreferenceConstants.ROTATION_PORTRAIT.equals(rotate)) {\n\t\t\tsetRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);\n\t\t\tforcedOrientation = true;\n\t\t} else {\n\t\t\tsetRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);\n\t\t\tforcedOrientation = false;\n\t\t}\n\t}\n\n\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu) {\n\t\tsuper.onCreateOptionsMenu(menu);\n\n\t\tTerminalView view = adapter.getCurrentTerminalView();\n\t\tfinal boolean activeTerminal = view != null;\n\t\tboolean sessionOpen = false;\n\t\tboolean disconnected = false;\n\t\tboolean canForwardPorts = false;\n\n\t\tif (activeTerminal) {\n\t\t\tTerminalBridge bridge = view.bridge;\n\t\t\tsessionOpen = bridge.isSessionOpen();\n\t\t\tdisconnected = bridge.isDisconnected();\n\t\t\tcanForwardPorts = bridge.canFowardPorts();\n\t\t}\n\n\t\tmenu.setQwertyMode(true);\n\n\t\tdisconnect = menu.add(R.string.list_host_disconnect);\n\t\tif (hardKeyboard)\n\t\t\tdisconnect.setAlphabeticShortcut('w');\n\t\tif (!sessionOpen && disconnected)\n\t\t\tdisconnect.setTitle(R.string.console_menu_close);\n\t\tdisconnect.setEnabled(activeTerminal);\n\t\tdisconnect.setIcon(android.R.drawable.ic_menu_close_clear_cancel);\n\t\tdisconnect.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t// disconnect or close the currently visible session\n\t\t\t\tTerminalView terminalView = adapter.getCurrentTerminalView();\n\t\t\t\tTerminalBridge bridge = terminalView.bridge;\n\n\t\t\t\tbridge.dispatchDisconnect(true);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\tcopy = menu.add(R.string.console_menu_copy);\n\t\tif (hardKeyboard)\n\t\t\tcopy.setAlphabeticShortcut('c');\n\t\tcopy.setIcon(android.R.drawable.ic_menu_set_as);\n\t\tcopy.setEnabled(activeTerminal);\n\t\tcopy.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tstartCopyMode();\n\t\t\t\tToast.makeText(ConsoleActivity.this, getString(R.string.console_copy_start), Toast.LENGTH_LONG).show();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\tpaste = menu.add(R.string.console_menu_paste);\n\t\tif (hardKeyboard)\n\t\t\tpaste.setAlphabeticShortcut('v');\n\t\tpaste.setIcon(android.R.drawable.ic_menu_edit);\n\t\tpaste.setEnabled(clipboard.hasText() && sessionOpen);\n\t\tpaste.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tpasteIntoTerminal();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\tportForward = menu.add(R.string.console_menu_portforwards);\n\t\tif (hardKeyboard)\n\t\t\tportForward.setAlphabeticShortcut('f');\n\t\tportForward.setIcon(android.R.drawable.ic_menu_manage);\n\t\tportForward.setEnabled(sessionOpen && canForwardPorts);\n\t\tportForward.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tTerminalView terminalView = adapter.getCurrentTerminalView();\n\t\t\t\tTerminalBridge bridge = terminalView.bridge;\n\n\t\t\t\tIntent intent = new Intent(ConsoleActivity.this, PortForwardListActivity.class);\n\t\t\t\tintent.putExtra(Intent.EXTRA_TITLE, bridge.host.getId());\n\t\t\t\tConsoleActivity.this.startActivityForResult(intent, REQUEST_EDIT);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\turlscan = menu.add(R.string.console_menu_urlscan);\n\t\tif (hardKeyboard)\n\t\t\turlscan.setAlphabeticShortcut('u');\n\t\turlscan.setIcon(android.R.drawable.ic_menu_search);\n\t\turlscan.setEnabled(activeTerminal);\n\t\turlscan.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tfinal TerminalView terminalView = adapter.getCurrentTerminalView();\n\n\t\t\t\tList<String> urls = terminalView.bridge.scanForURLs();\n\n\t\t\t\tDialog urlDialog = new Dialog(ConsoleActivity.this);\n\t\t\t\turlDialog.setTitle(R.string.console_menu_urlscan);\n\n\t\t\t\tListView urlListView = new ListView(ConsoleActivity.this);\n\t\t\t\tURLItemListener urlListener = new URLItemListener(ConsoleActivity.this);\n\t\t\t\turlListView.setOnItemClickListener(urlListener);\n\n\t\t\t\turlListView.setAdapter(new ArrayAdapter<String>(ConsoleActivity.this, android.R.layout.simple_list_item_1, urls));\n\t\t\t\turlDialog.setContentView(urlListView);\n\t\t\t\turlDialog.show();\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\tresize = menu.add(R.string.console_menu_resize);\n\t\tif (hardKeyboard)\n\t\t\tresize.setAlphabeticShortcut('s');\n\t\tresize.setIcon(android.R.drawable.ic_menu_crop);\n\t\tresize.setEnabled(sessionOpen);\n\t\tresize.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tfinal TerminalView terminalView = adapter.getCurrentTerminalView();\n\n\t\t\t\tfinal View resizeView = inflater.inflate(R.layout.dia_resize, null, false);\n\t\t\t\tnew AlertDialog.Builder(ConsoleActivity.this)\n\t\t\t\t\t.setView(resizeView)\n\t\t\t\t\t.setPositiveButton(R.string.button_resize, new DialogInterface.OnClickListener() {\n\t\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\t\t\tint width, height;\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\twidth = Integer.parseInt(((EditText) resizeView\n\t\t\t\t\t\t\t\t\t\t.findViewById(R.id.width))\n\t\t\t\t\t\t\t\t\t\t.getText().toString());\n\t\t\t\t\t\t\t\theight = Integer.parseInt(((EditText) resizeView\n\t\t\t\t\t\t\t\t\t\t.findViewById(R.id.height))\n\t\t\t\t\t\t\t\t\t\t.getText().toString());\n\t\t\t\t\t\t\t} catch (NumberFormatException nfe) {\n\t\t\t\t\t\t\t\t// TODO change this to a real dialog where we can\n\t\t\t\t\t\t\t\t// make the input boxes turn red to indicate an error.\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tterminalView.forceSize(width, height);\n\t\t\t\t\t\t}\n\t\t\t\t\t}).setNegativeButton(android.R.string.cancel, null).create().show();\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean onPrepareOptionsMenu(Menu menu) {\n\t\tsuper.onPrepareOptionsMenu(menu);\n\n\t\tsetVolumeControlStream(AudioManager.STREAM_NOTIFICATION);\n\n\t\tfinal TerminalView view = adapter.getCurrentTerminalView();\n\t\tboolean activeTerminal = view != null;\n\t\tboolean sessionOpen = false;\n\t\tboolean disconnected = false;\n\t\tboolean canForwardPorts = false;\n\n\t\tif (activeTerminal) {\n\t\t\tTerminalBridge bridge = view.bridge;\n\t\t\tsessionOpen = bridge.isSessionOpen();\n\t\t\tdisconnected = bridge.isDisconnected();\n\t\t\tcanForwardPorts = bridge.canFowardPorts();\n\t\t}\n\n\t\tdisconnect.setEnabled(activeTerminal);\n\t\tif (sessionOpen || !disconnected)\n\t\t\tdisconnect.setTitle(R.string.list_host_disconnect);\n\t\telse\n\t\t\tdisconnect.setTitle(R.string.console_menu_close);\n\t\tcopy.setEnabled(activeTerminal);\n\t\tpaste.setEnabled(clipboard.hasText() && sessionOpen);\n\t\tportForward.setEnabled(sessionOpen && canForwardPorts);\n\t\turlscan.setEnabled(activeTerminal);\n\t\tresize.setEnabled(sessionOpen);\n\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tswitch (item.getItemId()) {\n\t\t\tcase android.R.id.home:\n\t\t\t\tIntent intent = new Intent(this, HostListActivity.class);\n\t\t\t\tintent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n\t\t\t\tstartActivity(intent);\n\t\t\t\treturn true;\n\t\t\tdefault:\n\t\t\t\treturn super.onOptionsItemSelected(item);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void onOptionsMenuClosed(Menu menu) {\n\t\tsuper.onOptionsMenuClosed(menu);\n\n\t\tsetVolumeControlStream(AudioManager.STREAM_MUSIC);\n\t}\n\n\t@Override\n\tpublic void onCreateContextMenu(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo) {\n\t\tfinal TerminalView view = adapter.getCurrentTerminalView();\n\t\tboolean activeTerminal = view != null;\n\t\tboolean sessionOpen = false;\n\n\t\tif (activeTerminal) {\n\t\t\tTerminalBridge bridge = view.bridge;\n\t\t\tsessionOpen = bridge.isSessionOpen();\n\t\t}\n\n\t\tMenuItem paste = menu.add(R.string.console_menu_paste);\n\t\tif (hardKeyboard)\n\t\t\tpaste.setAlphabeticShortcut('v');\n\t\tpaste.setIcon(android.R.drawable.ic_menu_edit);\n\t\tpaste.setEnabled(clipboard.hasText() && sessionOpen);\n\t\tpaste.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tpasteIntoTerminal();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\n\t}\n\n\t@Override\n\tpublic void onStart() {\n\t\tsuper.onStart();\n\n\t\t// connect with manager service to find all bridges\n\t\t// when connected it will insert all views\n\t\tbindService(new Intent(this, TerminalManager.class), connection, Context.BIND_AUTO_CREATE);\n\t}\n\n\t@Override\n\tpublic void onPause() {\n\t\tsuper.onPause();\n\t\tLog.d(TAG, \"onPause called\");\n\n\t\tif (forcedOrientation && bound != null)\n\t\t\tbound.setResizeAllowed(false);\n\t}\n\n\t@Override\n\tpublic void onResume() {\n\t\tsuper.onResume();\n\t\tLog.d(TAG, \"onResume called\");\n\n\t\t// Make sure we don't let the screen fall asleep.\n\t\t// This also keeps the Wi-Fi chipset from disconnecting us.\n\t\tif (prefs.getBoolean(PreferenceConstants.KEEP_ALIVE, true)) {\n\t\t\tgetWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);\n\t\t} else {\n\t\t\tgetWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);\n\t\t}\n\n\t\tconfigureOrientation();\n\n\t\tif (forcedOrientation && bound != null)\n\t\t\tbound.setResizeAllowed(true);\n\t}\n\n\t/* (non-Javadoc)\n\t * @see android.app.Activity#onNewIntent(android.content.Intent)\n\t */\n\t@Override\n\tprotected void onNewIntent(Intent intent) {\n\t\tsuper.onNewIntent(intent);\n\n\t\tLog.d(TAG, \"onNewIntent called\");\n\n\t\trequested = intent.getData();\n\n\t\tif (requested == null) {\n\t\t\tLog.e(TAG, \"Got null intent data in onNewIntent()\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (bound == null) {\n\t\t\tLog.e(TAG, \"We're not bound in onNewIntent()\");\n\t\t\treturn;\n\t\t}\n\n\t\tTerminalBridge requestedBridge = bound.getConnectedBridge(requested.getFragment());\n\t\tint requestedIndex = 0;\n\n\t\tsynchronized (pager) {\n\t\t\tif (requestedBridge == null) {\n\t\t\t\t// If we didn't find the requested connection, try opening it\n\n\t\t\t\ttry {\n\t\t\t\t\tLog.d(TAG, String.format(\"We couldnt find an existing bridge with URI=%s (nickname=%s),\" +\n\t\t\t\t\t\t\t\"so creating one now\", requested.toString(), requested.getFragment()));\n\t\t\t\t\trequestedBridge = bound.openConnection(requested);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tLog.e(TAG, \"Problem while trying to create new requested bridge from URI\", e);\n\t\t\t\t\t// TODO: We should display an error dialog here.\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tadapter.notifyDataSetChanged();\n\t\t\t\trequestedIndex = adapter.getCount();\n\t\t\t} else {\n\t\t\t\tfinal int flipIndex = bound.getBridges().indexOf(requestedBridge);\n\t\t\t\tif (flipIndex > requestedIndex) {\n\t\t\t\t\trequestedIndex = flipIndex;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsetDisplayedTerminal(requestedIndex);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void onStop() {\n\t\tsuper.onStop();\n\n\t\tunbindService(connection);\n\t}\n\n\tprivate void startCopyMode() {\n\t\t// mark as copying and reset any previous bounds\n\t\tTerminalView terminalView = (TerminalView) adapter.getCurrentTerminalView();\n\t\tcopySource = terminalView.bridge;\n\n\t\tSelectionArea area = copySource.getSelectionArea();\n\t\tarea.reset();\n\t\tarea.setBounds(copySource.buffer.getColumns(), copySource.buffer.getRows());\n\n\t\tcopySource.setSelectingForCopy(true);\n\n\t\t// Make sure we show the initial selection\n\t\tcopySource.redraw();\n\t}\n\n\t/**\n\t * Save the currently shown {@link TerminalView} as the default. This is\n\t * saved back down into {@link TerminalManager} where we can read it again\n\t * later.\n\t */\n\tprivate void updateDefault() {\n\t\t// update the current default terminal\n\t\tTerminalView view = adapter.getCurrentTerminalView();\n\t\tif (view == null) return;\n\n\t\tif (bound == null) return;\n\t\tbound.defaultBridge = view.bridge;\n\t}\n\n\tprotected void updateEmptyVisible() {\n\t\t// update visibility of empty status message\n\t\tempty.setVisibility((pager.getChildCount() == 0) ? View.VISIBLE : View.GONE);\n\t}\n\n\t/**\n\t * Show any prompts requested by the currently visible {@link TerminalView}.\n\t */\n\tprotected void updatePromptVisible() {\n\t\t// check if our currently-visible terminalbridge is requesting any prompt services\n\t\tTerminalView view = adapter.getCurrentTerminalView();\n\n\t\t// Hide all the prompts in case a prompt request was canceled\n\t\thideAllPrompts();\n\n\t\tif (view == null) {\n\t\t\t// we dont have an active view, so hide any prompts\n\t\t\treturn;\n\t\t}\n\n\t\tPromptHelper prompt = view.bridge.promptHelper;\n\t\tif (String.class.equals(prompt.promptRequested)) {\n\t\t\tstringPromptGroup.setVisibility(View.VISIBLE);\n\n\t\t\tString instructions = prompt.promptInstructions;\n\t\t\tif (instructions != null && instructions.length() > 0) {\n\t\t\t\tstringPromptInstructions.setVisibility(View.VISIBLE);\n\t\t\t\tstringPromptInstructions.setText(instructions);\n\t\t\t} else\n\t\t\t\tstringPromptInstructions.setVisibility(View.GONE);\n\t\t\tstringPrompt.setText(\"\");\n\t\t\tstringPrompt.setHint(prompt.promptHint);\n\t\t\tstringPrompt.requestFocus();\n\n\t\t} else if (Boolean.class.equals(prompt.promptRequested)) {\n\t\t\tbooleanPromptGroup.setVisibility(View.VISIBLE);\n\t\t\tbooleanPrompt.setText(prompt.promptHint);\n\t\t\tbooleanYes.requestFocus();\n\n\t\t} else {\n\t\t\thideAllPrompts();\n\t\t\tview.requestFocus();\n\t\t}\n\t}\n\n\tprivate class URLItemListener implements OnItemClickListener {\n\t\tprivate WeakReference<Context> contextRef;\n\n\t\tURLItemListener(Context context) {\n\t\t\tthis.contextRef = new WeakReference<Context>(context);\n\t\t}\n\n\t\tpublic void onItemClick(AdapterView<?> arg0, View view, int position, long id) {\n\t\t\tContext context = contextRef.get();\n\n\t\t\tif (context == null)\n\t\t\t\treturn;\n\n\t\t\ttry {\n\t\t\t\tTextView urlView = (TextView) view;\n\n\t\t\t\tString url = urlView.getText().toString();\n\t\t\t\tif (url.indexOf(\"://\") < 0)\n\t\t\t\t\turl = \"http://\" + url;\n\n\t\t\t\tIntent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));\n\t\t\t\tcontext.startActivity(intent);\n\t\t\t} catch (Exception e) {\n\t\t\t\tLog.e(TAG, \"couldn't open URL\", e);\n\t\t\t\t// We should probably tell the user that we couldn't find a handler...\n\t\t\t}\n\t\t}\n\n\t}\n\n\t@Override\n\tpublic void onConfigurationChanged(Configuration newConfig) {\n\t\tsuper.onConfigurationChanged(newConfig);\n\n\t\tLog.d(TAG, String.format(\"onConfigurationChanged; requestedOrientation=%d, newConfig.orientation=%d\", getRequestedOrientation(), newConfig.orientation));\n\t\tif (bound != null) {\n\t\t\tif (forcedOrientation &&\n\t\t\t\t\t(newConfig.orientation != Configuration.ORIENTATION_LANDSCAPE &&\n\t\t\t\t\t\t\tgetRequestedOrientation() == ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE) ||\n\t\t\t\t\t(newConfig.orientation != Configuration.ORIENTATION_PORTRAIT &&\n\t\t\t\t\t\t\tgetRequestedOrientation() == ActivityInfo.SCREEN_ORIENTATION_PORTRAIT))\n\t\t\t\tbound.setResizeAllowed(false);\n\t\t\telse\n\t\t\t\tbound.setResizeAllowed(true);\n\n\t\t\tbound.hardKeyboardHidden = (newConfig.hardKeyboardHidden == Configuration.HARDKEYBOARDHIDDEN_YES);\n\n\t\t\tmKeyboardButton.setVisibility(bound.hardKeyboardHidden ? View.VISIBLE : View.GONE);\n\t\t}\n\t}\n\n\t/**\n\t * Called whenever the displayed terminal is changed.\n\t */\n\tprivate void onTerminalChanged() {\n\t\tView overlay = findCurrentView(R.id.terminal_overlay);\n\t\tif (overlay != null)\n\t\t\toverlay.startAnimation(fade_out_delayed);\n\t\tupdateDefault();\n\t\tupdatePromptVisible();\n\t\tActivityCompat.invalidateOptionsMenu(ConsoleActivity.this);\n\t}\n\n\t/**\n\t * Displays the child in the ViewPager at the requestedIndex and updates the prompts.\n\t *\n\t * @param requestedIndex the index of the terminal view to display\n\t */\n\tprivate void setDisplayedTerminal(int requestedIndex) {\n\t\tpager.setCurrentItem(requestedIndex);\n\t\tonTerminalChanged();\n\t}\n\n\tprivate void pasteIntoTerminal() {\n\t\t// force insert of clipboard text into current console\n\t\tTerminalView terminalView = adapter.getCurrentTerminalView();\n\t\tTerminalBridge bridge = terminalView.bridge;\n\n\t\t// pull string from clipboard and generate all events to force down\n\t\tString clip = clipboard.getText().toString();\n\t\tbridge.injectString(clip);\n\t}\n\n\tpublic class TerminalPagerAdapter extends PagerAdapter {\n\t\t@Override\n\t\tpublic int getCount() {\n\t\t\tif (bound != null) {\n\t\t\t\treturn bound.getBridges().size();\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Object instantiateItem(ViewGroup container, int position) {\n\t\t\tif (bound == null || bound.getBridges().size() <= position) {\n\t\t\t\tLog.w(TAG, \"Activity not bound when creating TerminalView.\");\n\t\t\t}\n\t\t\tTerminalBridge bridge = bound.getBridges().get(position);\n\t\t\tbridge.promptHelper.setHandler(promptHandler);\n\n\t\t\t// inflate each terminal view\n\t\t\tRelativeLayout view = (RelativeLayout) inflater.inflate(\n\t\t\t\t\tR.layout.item_terminal, container, false);\n\n\t\t\t// set the terminal overlay text\n\t\t\tTextView overlay = (TextView) view.findViewById(R.id.terminal_overlay);\n\t\t\toverlay.setText(bridge.host.getNickname());\n\n\t\t\t// and add our terminal view control, using index to place behind overlay\n\t\t\tfinal TerminalView terminal = new TerminalView(container.getContext(), bridge);\n\t\t\tterminal.setId(R.id.console_flip);\n\t\t\tview.addView(terminal, 0);\n\n\t\t\t// Tag the view with its bridge so it can be retrieved later.\n\t\t\tview.setTag(bridge);\n\n\t\t\tcontainer.addView(view);\n\t\t\toverlay.startAnimation(fade_out_delayed);\n\t\t\treturn view;\n\t\t}\n\n\t\t@Override\n\t\tpublic void destroyItem(ViewGroup container, int position, Object object) {\n\t\t\tfinal View view = (View) object;\n\n\t\t\tcontainer.removeView(view);\n\t\t}\n\n\t\t@Override\n\t\tpublic int getItemPosition(Object object) {\n\t\t\tfinal View view = (View) object;\n\t\t\tTerminalView terminal = (TerminalView) view.findViewById(R.id.console_flip);\n\t\t\tfinal HostBean host = terminal.bridge.host;\n\t\t\tint itemIndex = -1;\n\t\t\tint i = 0;\n\t\t\tfor (TerminalBridge bridge : bound.getBridges()) {\n\t\t\t\tif (bridge.host.equals(host)) {\n\t\t\t\t\titemIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif (itemIndex == -1) {\n\t\t\t\treturn POSITION_NONE;\n\t\t\t} else {\n\t\t\t\treturn itemIndex;\n\t\t\t}\n\t\t}\n\n\t\tpublic TerminalBridge getItemAtPosition(int position) {\n\t\t\treturn bound.getBridges().get(position);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isViewFromObject(View view, Object object) {\n\t\t\treturn view == object;\n\t\t}\n\n\t\t@Override\n\t\tpublic CharSequence getPageTitle(int position) {\n\t\t\treturn bound.getBridges().get(position).host.getNickname();\n\t\t}\n\n\t\tpublic TerminalView getCurrentTerminalView() {\n\t\t\tView currentView = pager.findViewWithTag(adapter.getItemAtPosition(pager.getCurrentItem()));\n\t\t\tif (currentView == null) return null;\n\t\t\treturn (TerminalView) currentView.findViewById(R.id.console_flip);\n\t\t}\n\t}\n}\n","Method after Refactoring":"/*\n * ConnectBot: simple, powerful, open-source SSH client for Android\n * Copyright 2007 Kenny Root, Jeffrey Sharkey\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.connectbot;\n\nimport java.lang.ref.WeakReference;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.connectbot.bean.HostBean;\nimport org.connectbot.bean.SelectionArea;\nimport org.connectbot.service.PromptHelper;\nimport org.connectbot.service.TerminalBridge;\nimport org.connectbot.service.TerminalKeyListener;\nimport org.connectbot.service.TerminalManager;\nimport org.connectbot.util.PreferenceConstants;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.app.Dialog;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.ServiceConnection;\nimport android.content.SharedPreferences;\nimport android.content.pm.ActivityInfo;\nimport android.content.res.Configuration;\nimport android.media.AudioManager;\nimport android.net.Uri;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Message;\nimport android.preference.PreferenceManager;\nimport android.support.v4.app.ActivityCompat;\nimport android.support.v4.view.MotionEventCompat;\nimport android.support.v4.view.PagerAdapter;\nimport android.support.v4.view.ViewPager;\nimport android.text.ClipboardManager;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.GestureDetector;\nimport android.view.InputDevice;\nimport android.view.KeyEvent;\nimport android.view.LayoutInflater;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.MenuItem.OnMenuItemClickListener;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.view.View.OnClickListener;\nimport android.view.View.OnKeyListener;\nimport android.view.View.OnTouchListener;\nimport android.view.ViewConfiguration;\nimport android.view.ViewGroup;\nimport android.view.Window;\nimport android.view.WindowManager;\nimport android.view.animation.Animation;\nimport android.view.animation.AnimationUtils;\nimport android.view.inputmethod.InputMethodManager;\nimport android.widget.AdapterView;\nimport android.widget.AdapterView.OnItemClickListener;\nimport android.widget.ArrayAdapter;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.ImageView;\nimport android.widget.LinearLayout;\nimport android.widget.ListView;\nimport android.widget.RelativeLayout;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport de.mud.terminal.vt320;\n\npublic class ConsoleActivity extends Activity {\n\tpublic final static String TAG = \"CB.ConsoleActivity\";\n\n\tprotected static final int REQUEST_EDIT = 1;\n\n\tprivate static final int CLICK_TIME = 400;\n\tprivate static final float MAX_CLICK_DISTANCE = 25f;\n\tprivate static final int KEYBOARD_DISPLAY_TIME = 1500;\n\n\tprotected ViewPager pager = null;\n\tprotected TerminalManager bound = null;\n\tprotected TerminalPagerAdapter adapter = null;\n\tprotected LayoutInflater inflater = null;\n\n\tprivate SharedPreferences prefs = null;\n\n\t// determines whether or not menuitem accelerators are bound\n\t// otherwise they collide with an external keyboard's CTRL-char\n\tprivate boolean hardKeyboard = false;\n\n\tprotected Uri requested;\n\n\tprotected ClipboardManager clipboard;\n\tprivate RelativeLayout stringPromptGroup;\n\tprotected EditText stringPrompt;\n\tprivate TextView stringPromptInstructions;\n\n\tprivate RelativeLayout booleanPromptGroup;\n\tprivate TextView booleanPrompt;\n\tprivate Button booleanYes, booleanNo;\n\n\tprivate LinearLayout keyboardGroup;\n\tprivate Runnable keyboardGroupHider;\n\n\tprivate TextView empty;\n\n\tprivate Animation fade_out_delayed;\n\n\tprivate Animation keyboard_fade_in, keyboard_fade_out;\n\tprivate float lastX, lastY;\n\n\tprivate InputMethodManager inputManager;\n\n\tprivate MenuItem disconnect, copy, paste, portForward, resize, urlscan;\n\n\tprotected TerminalBridge copySource = null;\n\tprivate int lastTouchRow, lastTouchCol;\n\n\tprivate boolean forcedOrientation;\n\n\tprivate Handler handler = new Handler();\n\n\tprivate ImageView mKeyboardButton;\n\n\tprivate ActionBarWrapper actionBar;\n\tprivate boolean inActionBarMenu = false;\n\tprivate boolean titleBarHide;\n\n\tprivate ServiceConnection connection = new ServiceConnection() {\n\t\tpublic void onServiceConnected(ComponentName className, IBinder service) {\n\t\t\tbound = ((TerminalManager.TerminalBinder) service).getService();\n\n\t\t\t// let manager know about our event handling services\n\t\t\tbound.disconnectHandler = disconnectHandler;\n\t\t\tbound.setResizeAllowed(true);\n\n\t\t\tfinal String requestedNickname = (requested != null) ? requested.getFragment() : null;\n\t\t\tint requestedIndex = 0;\n\n\t\t\tTerminalBridge requestedBridge = bound.getConnectedBridge(requestedNickname);\n\n\t\t\t// If we didn't find the requested connection, try opening it\n\t\t\tif (requestedNickname != null && requestedBridge == null) {\n\t\t\t\ttry {\n\t\t\t\t\tLog.d(TAG, String.format(\"We couldnt find an existing bridge with URI=%s (nickname=%s), so creating one now\", requested.toString(), requestedNickname));\n\t\t\t\t\trequestedBridge = bound.openConnection(requested);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tLog.e(TAG, \"Problem while trying to create new requested bridge from URI\", e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// create views for all bridges on this service\n\t\t\tadapter.notifyDataSetChanged();\n\t\t\trequestedIndex = bound.getBridges().indexOf(requestedBridge);\n\n\t\t\tsetDisplayedTerminal(requestedIndex == -1 ? 0 : requestedIndex);\n\t\t}\n\n\t\tpublic void onServiceDisconnected(ComponentName className) {\n\t\t\tadapter.notifyDataSetChanged();\n\t\t\tupdateEmptyVisible();\n\t\t\tbound = null;\n\t\t}\n\t};\n\n\tprotected Handler promptHandler = new Handler() {\n\t\t@Override\n\t\tpublic void handleMessage(Message msg) {\n\t\t\t// someone below us requested to display a prompt\n\t\t\tupdatePromptVisible();\n\t\t}\n\t};\n\n\tprotected Handler disconnectHandler = new Handler() {\n\t\t@Override\n\t\tpublic void handleMessage(Message msg) {\n\t\t\tLog.d(TAG, \"Someone sending HANDLE_DISCONNECT to parentHandler\");\n\n\t\t\t// someone below us requested to display a password dialog\n\t\t\t// they are sending nickname and requested\n\t\t\tTerminalBridge bridge = (TerminalBridge) msg.obj;\n\n\t\t\tadapter.notifyDataSetChanged();\n\t\t\tif (bridge.isAwaitingClose()) {\n\t\t\t\tcloseBridge(bridge);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * @param bridge\n\t */\n\tprivate void closeBridge(final TerminalBridge bridge) {\n\t\tsynchronized (pager) {\n\t\t\tupdateEmptyVisible();\n\t\t\tupdatePromptVisible();\n\n\t\t\t// If we just closed the last bridge, go back to the previous activity.\n\t\t\tif (pager.getChildCount() == 0) {\n\t\t\t\tfinish();\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected View findCurrentView(int id) {\n\t\tTerminalView view = adapter.getCurrentTerminalView();\n\t\tif (view == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn view.findViewById(id);\n\t}\n\n\tprotected PromptHelper getCurrentPromptHelper() {\n\t\tTerminalView view = adapter.getCurrentTerminalView();\n\t\tif (view == null) return null;\n\t\treturn view.bridge.promptHelper;\n\t}\n\n\tprotected void hideAllPrompts() {\n\t\tstringPromptGroup.setVisibility(View.GONE);\n\t\tbooleanPromptGroup.setVisibility(View.GONE);\n\t}\n\n\tprivate void showEmulatedKeys() {\n\t\tkeyboardGroup.startAnimation(keyboard_fade_in);\n\t\tkeyboardGroup.setVisibility(View.VISIBLE);\n\t\tactionBar.show();\n\n\t\tif (keyboardGroupHider != null)\n\t\t\thandler.removeCallbacks(keyboardGroupHider);\n\t\tkeyboardGroupHider = new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tif (keyboardGroup.getVisibility() == View.GONE || inActionBarMenu)\n\t\t\t\t\treturn;\n\n\t\t\t\tkeyboardGroup.startAnimation(keyboard_fade_out);\n\t\t\t\tkeyboardGroup.setVisibility(View.GONE);\n\t\t\t\tif (titleBarHide) {\n\t\t\t\t\tactionBar.hide();\n\t\t\t\t}\n\t\t\t\tkeyboardGroupHider = null;\n\t\t\t}\n\t\t};\n\t\thandler.postDelayed(keyboardGroupHider, KEYBOARD_DISPLAY_TIME);\n\t}\n\n\tprivate void hideEmulatedKeys() {\n\t\tif (keyboardGroupHider != null)\n\t\t\thandler.removeCallbacks(keyboardGroupHider);\n\t\tkeyboardGroup.setVisibility(View.GONE);\n\t\tif (titleBarHide) {\n\t\t\tactionBar.hide();\n\t\t}\n\t}\n\n\t@Override\n\tpublic void onCreate(Bundle icicle) {\n\t\tsuper.onCreate(icicle);\n\n\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD) {\n\t\t\tStrictModeSetup.run();\n\t\t}\n\n\t\thardKeyboard = getResources().getConfiguration().keyboard ==\n\t\t\t\tConfiguration.KEYBOARD_QWERTY;\n\n\t\tclipboard = (ClipboardManager) getSystemService(CLIPBOARD_SERVICE);\n\t\tprefs = PreferenceManager.getDefaultSharedPreferences(this);\n\n\t\ttitleBarHide = prefs.getBoolean(PreferenceConstants.TITLEBARHIDE, false);\n\t\tif (titleBarHide) {\n\t\t\tgetWindow().requestFeature(Window.FEATURE_ACTION_BAR_OVERLAY);\n\t\t}\n\n\t\tthis.setContentView(R.layout.act_console);\n\n\t\t// hide status bar if requested by user\n\t\tif (prefs.getBoolean(PreferenceConstants.FULLSCREEN, false)) {\n\t\t\tgetWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,\n\t\t\t\t\tWindowManager.LayoutParams.FLAG_FULLSCREEN);\n\t\t}\n\n\t\t// TODO find proper way to disable volume key beep if it exists.\n\t\tsetVolumeControlStream(AudioManager.STREAM_MUSIC);\n\n\t\t// handle requested console from incoming intent\n\t\trequested = getIntent().getData();\n\n\t\tinflater = LayoutInflater.from(this);\n\n\t\tpager = (ViewPager) findViewById(R.id.console_flip);\n\t\tregisterForContextMenu(pager);\n\t\tpager.addOnPageChangeListener(\n\t\t\t\tnew ViewPager.SimpleOnPageChangeListener() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onPageSelected(int position) {\n\t\t\t\t\t\tonTerminalChanged();\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tempty = (TextView) findViewById(android.R.id.empty);\n\n\t\tstringPromptGroup = (RelativeLayout) findViewById(R.id.console_password_group);\n\t\tstringPromptInstructions = (TextView) findViewById(R.id.console_password_instructions);\n\t\tstringPrompt = (EditText) findViewById(R.id.console_password);\n\t\tstringPrompt.setOnKeyListener(new OnKeyListener() {\n\t\t\tpublic boolean onKey(View v, int keyCode, KeyEvent event) {\n\t\t\t\tif (event.getAction() == KeyEvent.ACTION_UP) return false;\n\t\t\t\tif (keyCode != KeyEvent.KEYCODE_ENTER) return false;\n\n\t\t\t\t// pass collected password down to current terminal\n\t\t\t\tString value = stringPrompt.getText().toString();\n\n\t\t\t\tPromptHelper helper = getCurrentPromptHelper();\n\t\t\t\tif (helper == null) return false;\n\t\t\t\thelper.setResponse(value);\n\n\t\t\t\t// finally clear password for next user\n\t\t\t\tstringPrompt.setText(\"\");\n\t\t\t\tupdatePromptVisible();\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\tbooleanPromptGroup = (RelativeLayout) findViewById(R.id.console_boolean_group);\n\t\tbooleanPrompt = (TextView) findViewById(R.id.console_prompt);\n\n\t\tbooleanYes = (Button) findViewById(R.id.console_prompt_yes);\n\t\tbooleanYes.setOnClickListener(new OnClickListener() {\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tPromptHelper helper = getCurrentPromptHelper();\n\t\t\t\tif (helper == null) return;\n\t\t\t\thelper.setResponse(Boolean.TRUE);\n\t\t\t\tupdatePromptVisible();\n\t\t\t}\n\t\t});\n\n\t\tbooleanNo = (Button) findViewById(R.id.console_prompt_no);\n\t\tbooleanNo.setOnClickListener(new OnClickListener() {\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tPromptHelper helper = getCurrentPromptHelper();\n\t\t\t\tif (helper == null) return;\n\t\t\t\thelper.setResponse(Boolean.FALSE);\n\t\t\t\tupdatePromptVisible();\n\t\t\t}\n\t\t});\n\n\t\tfade_out_delayed = AnimationUtils.loadAnimation(this, R.anim.fade_out_delayed);\n\n\t\t// Preload animation for keyboard button\n\t\tkeyboard_fade_in = AnimationUtils.loadAnimation(this, R.anim.keyboard_fade_in);\n\t\tkeyboard_fade_out = AnimationUtils.loadAnimation(this, R.anim.keyboard_fade_out);\n\n\t\tinputManager = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);\n\n\t\tkeyboardGroup = (LinearLayout) findViewById(R.id.keyboard_group);\n\n\t\tmKeyboardButton = (ImageView) findViewById(R.id.button_keyboard);\n\t\tmKeyboardButton.setOnClickListener(new OnClickListener() {\n\t\t\tpublic void onClick(View view) {\n\t\t\t\tView terminal = adapter.getCurrentTerminalView();\n\t\t\t\tif (terminal == null)\n\t\t\t\t\treturn;\n\n\t\t\t\tinputManager.showSoftInput(terminal, InputMethodManager.SHOW_FORCED);\n\t\t\t\thideEmulatedKeys();\n\t\t\t}\n\t\t});\n\n\t\tfinal Button ctrlButton = (Button) findViewById(R.id.button_ctrl);\n\t\tctrlButton.setOnClickListener(new OnClickListener() {\n\t\t\tpublic void onClick(View view) {\n\t\t\t\tTerminalView terminal = adapter.getCurrentTerminalView();\n\t\t\t\tif (terminal == null) return;\n\n\t\t\t\tTerminalKeyListener handler = terminal.bridge.getKeyHandler();\n\t\t\t\thandler.metaPress(TerminalKeyListener.OUR_CTRL_ON, true);\n\t\t\t\thideEmulatedKeys();\n\t\t\t}\n\t\t});\n\n\t\tfinal Button escButton = (Button) findViewById(R.id.button_esc);\n\t\tescButton.setOnClickListener(new OnClickListener() {\n\t\t\tpublic void onClick(View view) {\n\t\t\t\tTerminalView terminal = adapter.getCurrentTerminalView();\n\t\t\t\tif (terminal == null) return;\n\n\t\t\t\tTerminalKeyListener handler = terminal.bridge.getKeyHandler();\n\t\t\t\thandler.sendEscape();\n\t\t\t\thideEmulatedKeys();\n\t\t\t}\n\t\t});\n\n\t\tfinal Button tabButton = (Button) findViewById(R.id.button_tab);\n\t\ttabButton.setOnClickListener(new OnClickListener() {\n\t\t\tpublic void onClick(View view) {\n\t\t\t\tTerminalView terminal = adapter.getCurrentTerminalView();\n\t\t\t\tif (terminal == null) return;\n\n\t\t\t\tTerminalKeyListener handler = terminal.bridge.getKeyHandler();\n\t\t\t\thandler.sendTab();\n\t\t\t\thideEmulatedKeys();\n\t\t\t}\n\t\t});\n\t\tfinal Button upButton = (Button) findViewById(R.id.button_up);\n\t\tupButton.setOnClickListener(new OnClickListener() {\n\t\t\tpublic void onClick(View view) {\n\t\t\t\tView flip = findCurrentView(R.id.console_flip);\n\t\t\t\tif (flip == null) return;\n\t\t\t\tTerminalView terminal = (TerminalView) flip;\n\n\n\t\t\t\tTerminalKeyListener handler = terminal.bridge.getKeyHandler();\n\t\t\t\thandler.sendPressedKey(vt320.KEY_UP);\n\t\t\t}\n\t\t});\n\t\tfinal Button dnButton = (Button) findViewById(R.id.button_down);\n\t\tdnButton.setOnClickListener(new OnClickListener() {\n\t\t\tpublic void onClick(View view) {\n\t\t\t\tView flip = findCurrentView(R.id.console_flip);\n\t\t\t\tif (flip == null) return;\n\t\t\t\tTerminalView terminal = (TerminalView) flip;\n\n\t\t\t\tTerminalKeyListener handler = terminal.bridge.getKeyHandler();\n\t\t\t\thandler.sendPressedKey(vt320.KEY_DOWN);\n\t\t\t}\n\t\t});\n\t\tfinal Button leftButton = (Button) findViewById(R.id.button_left);\n\t\tleftButton.setOnClickListener(new OnClickListener() {\n\t\t\tpublic void onClick(View view) {\n\t\t\t\tView flip = findCurrentView(R.id.console_flip);\n\t\t\t\tif (flip == null) return;\n\t\t\t\tTerminalView terminal = (TerminalView) flip;\n\n\t\t\t\tTerminalKeyListener handler = terminal.bridge.getKeyHandler();\n\t\t\t\thandler.sendPressedKey(vt320.KEY_LEFT);\n\t\t\t}\n\t\t});\n\t\tfinal Button rightButton = (Button) findViewById(R.id.button_right);\n\t\trightButton.setOnClickListener(new OnClickListener() {\n\t\t\tpublic void onClick(View view) {\n\t\t\t\tView flip = findCurrentView(R.id.console_flip);\n\t\t\t\tif (flip == null) return;\n\t\t\t\tTerminalView terminal = (TerminalView) flip;\n\n\t\t\t\tTerminalKeyListener handler = terminal.bridge.getKeyHandler();\n\t\t\t\thandler.sendPressedKey(vt320.KEY_RIGHT);\n\t\t\t}\n\t\t});\n\n\t\tactionBar = ActionBarWrapper.getActionBar(this);\n\t\tactionBar.setDisplayHomeAsUpEnabled(true);\n\t\tif (titleBarHide) {\n\t\t\tactionBar.hide();\n\t\t}\n\t\tactionBar.addOnMenuVisibilityListener(new ActionBarWrapper.OnMenuVisibilityListener() {\n\t\t\tpublic void onMenuVisibilityChanged(boolean isVisible) {\n\t\t\t\tinActionBarMenu = isVisible;\n\t\t\t\tif (isVisible == false) {\n\t\t\t\t\thideEmulatedKeys();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t// detect fling gestures to switch between terminals\n\t\tfinal GestureDetector detect = new GestureDetector(this, new GestureDetector.SimpleOnGestureListener() {\n\t\t\tprivate float totalY = 0;\n\n\t\t\t@Override\n\t\t\tpublic void onLongPress(MotionEvent e) {\n\t\t\t\tsuper.onLongPress(e);\n\t\t\t\topenContextMenu(pager);\n\t\t\t}\n\n\n\t\t\t@Override\n\t\t\tpublic boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {\n\n\t\t\t\t// if copying, then ignore\n\t\t\t\tif (copySource != null && copySource.isSelectingForCopy())\n\t\t\t\t\treturn false;\n\n\t\t\t\tif (e1 == null || e2 == null)\n\t\t\t\t\treturn false;\n\n\t\t\t\t// if releasing then reset total scroll\n\t\t\t\tif (e2.getAction() == MotionEvent.ACTION_UP) {\n\t\t\t\t\ttotalY = 0;\n\t\t\t\t}\n\n\t\t\t\t// activate consider if within x tolerance\n\t\t\t\tint touchSlop = ViewConfiguration.get(ConsoleActivity.this).getScaledTouchSlop();\n\t\t\t\tif (Math.abs(e1.getX() - e2.getX()) < touchSlop * 4) {\n\n\t\t\t\t\tView view = adapter.getCurrentTerminalView();\n\t\t\t\t\tif (view == null) return false;\n\t\t\t\t\tTerminalView terminal = (TerminalView) view;\n\n\t\t\t\t\t// estimate how many rows we have scrolled through\n\t\t\t\t\t// accumulate distance that doesn't trigger immediate scroll\n\t\t\t\t\ttotalY += distanceY;\n\t\t\t\t\tfinal int moved = (int) (totalY / terminal.bridge.charHeight);\n\n\t\t\t\t\t// consume as scrollback only if towards right half of screen\n\t\t\t\t\tif (e2.getX() > view.getWidth() / 2) {\n\t\t\t\t\t\tif (moved != 0) {\n\t\t\t\t\t\t\tint base = terminal.bridge.buffer.getWindowBase();\n\t\t\t\t\t\t\tterminal.bridge.buffer.setWindowBase(base + moved);\n\t\t\t\t\t\t\ttotalY = 0;\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// otherwise consume as pgup/pgdown for every 5 lines\n\t\t\t\t\t\tif (moved > 5) {\n\t\t\t\t\t\t\t((vt320) terminal.bridge.buffer).keyPressed(vt320.KEY_PAGE_DOWN, ' ', 0);\n\t\t\t\t\t\t\tterminal.bridge.tryKeyVibrate();\n\t\t\t\t\t\t\ttotalY = 0;\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t} else if (moved < -5) {\n\t\t\t\t\t\t\t((vt320) terminal.bridge.buffer).keyPressed(vt320.KEY_PAGE_UP, ' ', 0);\n\t\t\t\t\t\t\tterminal.bridge.tryKeyVibrate();\n\t\t\t\t\t\t\ttotalY = 0;\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t}\n\n\n\t\t});\n\n\t\tpager.setLongClickable(true);\n\t\tpager.setOnTouchListener(new OnTouchListener() {\n\n\t\t\tpublic boolean onTouch(View v, MotionEvent event) {\n\n\t\t\t\t// Handle mouse-specific actions.\n\t\t\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH &&\n\t\t\t\t\t\tMotionEventCompat.getSource(event) == InputDevice.SOURCE_MOUSE &&\n\t\t\t\t\t\tevent.getAction() == MotionEvent.ACTION_DOWN) {\n\t\t\t\t\tswitch (event.getButtonState()) {\n\t\t\t\t\tcase MotionEvent.BUTTON_PRIMARY:\n\t\t\t\t\t\t// Automatically start copy mode if using a mouse.\n\t\t\t\t\t\tstartCopyMode();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase MotionEvent.BUTTON_SECONDARY:\n\t\t\t\t\t\topenContextMenu(pager);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tcase MotionEvent.BUTTON_TERTIARY:\n\t\t\t\t\t\t// Middle click pastes.\n\t\t\t\t\t\tpasteIntoTerminal();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// when copying, highlight the area\n\t\t\t\tif (copySource != null && copySource.isSelectingForCopy()) {\n\t\t\t\t\tint row = (int) Math.floor(event.getY() / copySource.charHeight);\n\t\t\t\t\tint col = (int) Math.floor(event.getX() / copySource.charWidth);\n\n\t\t\t\t\tSelectionArea area = copySource.getSelectionArea();\n\n\t\t\t\t\tswitch (event.getAction()) {\n\t\t\t\t\tcase MotionEvent.ACTION_DOWN:\n\t\t\t\t\t\t// recording starting area\n\t\t\t\t\t\tif (area.isSelectingOrigin()) {\n\t\t\t\t\t\t\tarea.setRow(row);\n\t\t\t\t\t\t\tarea.setColumn(col);\n\t\t\t\t\t\t\tlastTouchRow = row;\n\t\t\t\t\t\t\tlastTouchCol = col;\n\t\t\t\t\t\t\tcopySource.redraw();\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tcase MotionEvent.ACTION_MOVE:\n\t\t\t\t\t\t/* ignore when user hasn't moved since last time so\n\t\t\t\t\t\t * we can fine-tune with directional pad\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (row == lastTouchRow && col == lastTouchCol)\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t// if the user moves, start the selection for other corner\n\t\t\t\t\t\tarea.finishSelectingOrigin();\n\n\t\t\t\t\t\t// update selected area\n\t\t\t\t\t\tarea.setRow(row);\n\t\t\t\t\t\tarea.setColumn(col);\n\t\t\t\t\t\tlastTouchRow = row;\n\t\t\t\t\t\tlastTouchCol = col;\n\t\t\t\t\t\tcopySource.redraw();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tcase MotionEvent.ACTION_UP:\n\t\t\t\t\t\t/* If they didn't move their finger, maybe they meant to\n\t\t\t\t\t\t * select the rest of the text with the directional pad.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (area.getLeft() == area.getRight() &&\n\t\t\t\t\t\t\t\tarea.getTop() == area.getBottom()) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// copy selected area to clipboard\n\t\t\t\t\t\tString copiedText = area.copyFrom(copySource.buffer);\n\n\t\t\t\t\t\tclipboard.setText(copiedText);\n\t\t\t\t\t\tToast.makeText(ConsoleActivity.this, getString(R.string.console_copy_done, copiedText.length()), Toast.LENGTH_LONG).show();\n\t\t\t\t\t\t// fall through to clear state\n\n\t\t\t\t\tcase MotionEvent.ACTION_CANCEL:\n\t\t\t\t\t\t// make sure we clear any highlighted area\n\t\t\t\t\t\tarea.reset();\n\t\t\t\t\t\tcopySource.setSelectingForCopy(false);\n\t\t\t\t\t\tcopySource.redraw();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (event.getAction() == MotionEvent.ACTION_DOWN) {\n\t\t\t\t\tlastX = event.getX();\n\t\t\t\t\tlastY = event.getY();\n\t\t\t\t} else if (event.getAction() == MotionEvent.ACTION_UP\n\t\t\t\t\t\t&& keyboardGroup.getVisibility() == View.GONE\n\t\t\t\t\t\t&& event.getEventTime() - event.getDownTime() < CLICK_TIME\n\t\t\t\t\t\t&& Math.abs(event.getX() - lastX) < MAX_CLICK_DISTANCE\n\t\t\t\t\t\t&& Math.abs(event.getY() - lastY) < MAX_CLICK_DISTANCE) {\n\t\t\t\t\tshowEmulatedKeys();\n\t\t\t\t}\n\n\t\t\t\t// pass any touch events back to detector\n\t\t\t\treturn detect.onTouchEvent(event);\n\t\t\t}\n\n\t\t});\n\n\t\tadapter = new TerminalPagerAdapter();\n\t\tpager.setAdapter(adapter);\n\t}\n\n\t/**\n\t *\n\t */\n\tprivate void configureOrientation() {\n\t\tString rotateDefault;\n\t\tif (getResources().getConfiguration().keyboard == Configuration.KEYBOARD_NOKEYS)\n\t\t\trotateDefault = PreferenceConstants.ROTATION_PORTRAIT;\n\t\telse\n\t\t\trotateDefault = PreferenceConstants.ROTATION_LANDSCAPE;\n\n\t\tString rotate = prefs.getString(PreferenceConstants.ROTATION, rotateDefault);\n\t\tif (PreferenceConstants.ROTATION_DEFAULT.equals(rotate))\n\t\t\trotate = rotateDefault;\n\n\t\t// request a forced orientation if requested by user\n\t\tif (PreferenceConstants.ROTATION_LANDSCAPE.equals(rotate)) {\n\t\t\tsetRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);\n\t\t\tforcedOrientation = true;\n\t\t} else if (PreferenceConstants.ROTATION_PORTRAIT.equals(rotate)) {\n\t\t\tsetRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);\n\t\t\tforcedOrientation = true;\n\t\t} else {\n\t\t\tsetRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);\n\t\t\tforcedOrientation = false;\n\t\t}\n\t}\n\n\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu) {\n\t\tsuper.onCreateOptionsMenu(menu);\n\n\t\tTerminalView view = adapter.getCurrentTerminalView();\n\t\tfinal boolean activeTerminal = view != null;\n\t\tboolean sessionOpen = false;\n\t\tboolean disconnected = false;\n\t\tboolean canForwardPorts = false;\n\n\t\tif (activeTerminal) {\n\t\t\tTerminalBridge bridge = view.bridge;\n\t\t\tsessionOpen = bridge.isSessionOpen();\n\t\t\tdisconnected = bridge.isDisconnected();\n\t\t\tcanForwardPorts = bridge.canFowardPorts();\n\t\t}\n\n\t\tmenu.setQwertyMode(true);\n\n\t\tdisconnect = menu.add(R.string.list_host_disconnect);\n\t\tif (hardKeyboard)\n\t\t\tdisconnect.setAlphabeticShortcut('w');\n\t\tif (!sessionOpen && disconnected)\n\t\t\tdisconnect.setTitle(R.string.console_menu_close);\n\t\tdisconnect.setEnabled(activeTerminal);\n\t\tdisconnect.setIcon(android.R.drawable.ic_menu_close_clear_cancel);\n\t\tdisconnect.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t// disconnect or close the currently visible session\n\t\t\t\tTerminalView terminalView = adapter.getCurrentTerminalView();\n\t\t\t\tTerminalBridge bridge = terminalView.bridge;\n\n\t\t\t\tbridge.dispatchDisconnect(true);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\tcopy = menu.add(R.string.console_menu_copy);\n\t\tif (hardKeyboard)\n\t\t\tcopy.setAlphabeticShortcut('c');\n\t\tcopy.setIcon(android.R.drawable.ic_menu_set_as);\n\t\tcopy.setEnabled(activeTerminal);\n\t\tcopy.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tstartCopyMode();\n\t\t\t\tToast.makeText(ConsoleActivity.this, getString(R.string.console_copy_start), Toast.LENGTH_LONG).show();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\tpaste = menu.add(R.string.console_menu_paste);\n\t\tif (hardKeyboard)\n\t\t\tpaste.setAlphabeticShortcut('v');\n\t\tpaste.setIcon(android.R.drawable.ic_menu_edit);\n\t\tpaste.setEnabled(clipboard.hasText() && sessionOpen);\n\t\tpaste.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tpasteIntoTerminal();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\tportForward = menu.add(R.string.console_menu_portforwards);\n\t\tif (hardKeyboard)\n\t\t\tportForward.setAlphabeticShortcut('f');\n\t\tportForward.setIcon(android.R.drawable.ic_menu_manage);\n\t\tportForward.setEnabled(sessionOpen && canForwardPorts);\n\t\tportForward.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tTerminalView terminalView = adapter.getCurrentTerminalView();\n\t\t\t\tTerminalBridge bridge = terminalView.bridge;\n\n\t\t\t\tIntent intent = new Intent(ConsoleActivity.this, PortForwardListActivity.class);\n\t\t\t\tintent.putExtra(Intent.EXTRA_TITLE, bridge.host.getId());\n\t\t\t\tConsoleActivity.this.startActivityForResult(intent, REQUEST_EDIT);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\turlscan = menu.add(R.string.console_menu_urlscan);\n\t\tif (hardKeyboard)\n\t\t\turlscan.setAlphabeticShortcut('u');\n\t\turlscan.setIcon(android.R.drawable.ic_menu_search);\n\t\turlscan.setEnabled(activeTerminal);\n\t\turlscan.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tfinal TerminalView terminalView = adapter.getCurrentTerminalView();\n\n\t\t\t\tList<String> urls = terminalView.bridge.scanForURLs();\n\n\t\t\t\tDialog urlDialog = new Dialog(ConsoleActivity.this);\n\t\t\t\turlDialog.setTitle(R.string.console_menu_urlscan);\n\n\t\t\t\tListView urlListView = new ListView(ConsoleActivity.this);\n\t\t\t\tURLItemListener urlListener = new URLItemListener(ConsoleActivity.this);\n\t\t\t\turlListView.setOnItemClickListener(urlListener);\n\n\t\t\t\turlListView.setAdapter(new ArrayAdapter<String>(ConsoleActivity.this, android.R.layout.simple_list_item_1, urls));\n\t\t\t\turlDialog.setContentView(urlListView);\n\t\t\t\turlDialog.show();\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\tresize = menu.add(R.string.console_menu_resize);\n\t\tif (hardKeyboard)\n\t\t\tresize.setAlphabeticShortcut('s');\n\t\tresize.setIcon(android.R.drawable.ic_menu_crop);\n\t\tresize.setEnabled(sessionOpen);\n\t\tresize.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tfinal TerminalView terminalView = adapter.getCurrentTerminalView();\n\n\t\t\t\tfinal View resizeView = inflater.inflate(R.layout.dia_resize, null, false);\n\t\t\t\tnew AlertDialog.Builder(ConsoleActivity.this)\n\t\t\t\t\t.setView(resizeView)\n\t\t\t\t\t.setPositiveButton(R.string.button_resize, new DialogInterface.OnClickListener() {\n\t\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\t\t\tint width, height;\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\twidth = Integer.parseInt(((EditText) resizeView\n\t\t\t\t\t\t\t\t\t\t.findViewById(R.id.width))\n\t\t\t\t\t\t\t\t\t\t.getText().toString());\n\t\t\t\t\t\t\t\theight = Integer.parseInt(((EditText) resizeView\n\t\t\t\t\t\t\t\t\t\t.findViewById(R.id.height))\n\t\t\t\t\t\t\t\t\t\t.getText().toString());\n\t\t\t\t\t\t\t} catch (NumberFormatException nfe) {\n\t\t\t\t\t\t\t\t// TODO change this to a real dialog where we can\n\t\t\t\t\t\t\t\t// make the input boxes turn red to indicate an error.\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tterminalView.forceSize(width, height);\n\t\t\t\t\t\t}\n\t\t\t\t\t}).setNegativeButton(android.R.string.cancel, null).create().show();\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean onPrepareOptionsMenu(Menu menu) {\n\t\tsuper.onPrepareOptionsMenu(menu);\n\n\t\tsetVolumeControlStream(AudioManager.STREAM_NOTIFICATION);\n\n\t\tfinal TerminalView view = adapter.getCurrentTerminalView();\n\t\tboolean activeTerminal = view != null;\n\t\tboolean sessionOpen = false;\n\t\tboolean disconnected = false;\n\t\tboolean canForwardPorts = false;\n\n\t\tif (activeTerminal) {\n\t\t\tTerminalBridge bridge = view.bridge;\n\t\t\tsessionOpen = bridge.isSessionOpen();\n\t\t\tdisconnected = bridge.isDisconnected();\n\t\t\tcanForwardPorts = bridge.canFowardPorts();\n\t\t}\n\n\t\tdisconnect.setEnabled(activeTerminal);\n\t\tif (sessionOpen || !disconnected)\n\t\t\tdisconnect.setTitle(R.string.list_host_disconnect);\n\t\telse\n\t\t\tdisconnect.setTitle(R.string.console_menu_close);\n\t\tcopy.setEnabled(activeTerminal);\n\t\tpaste.setEnabled(clipboard.hasText() && sessionOpen);\n\t\tportForward.setEnabled(sessionOpen && canForwardPorts);\n\t\turlscan.setEnabled(activeTerminal);\n\t\tresize.setEnabled(sessionOpen);\n\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tswitch (item.getItemId()) {\n\t\t\tcase android.R.id.home:\n\t\t\t\tIntent intent = new Intent(this, HostListActivity.class);\n\t\t\t\tintent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n\t\t\t\tstartActivity(intent);\n\t\t\t\treturn true;\n\t\t\tdefault:\n\t\t\t\treturn super.onOptionsItemSelected(item);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void onOptionsMenuClosed(Menu menu) {\n\t\tsuper.onOptionsMenuClosed(menu);\n\n\t\tsetVolumeControlStream(AudioManager.STREAM_MUSIC);\n\t}\n\n\t@Override\n\tpublic void onCreateContextMenu(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo) {\n\t\tfinal TerminalView view = adapter.getCurrentTerminalView();\n\t\tboolean activeTerminal = view != null;\n\t\tboolean sessionOpen = false;\n\n\t\tif (activeTerminal) {\n\t\t\tTerminalBridge bridge = view.bridge;\n\t\t\tsessionOpen = bridge.isSessionOpen();\n\t\t}\n\n\t\tMenuItem paste = menu.add(R.string.console_menu_paste);\n\t\tif (hardKeyboard)\n\t\t\tpaste.setAlphabeticShortcut('v');\n\t\tpaste.setIcon(android.R.drawable.ic_menu_edit);\n\t\tpaste.setEnabled(clipboard.hasText() && sessionOpen);\n\t\tpaste.setOnMenuItemClickListener(new OnMenuItemClickListener() {\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tpasteIntoTerminal();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\n\t}\n\n\t@Override\n\tpublic void onStart() {\n\t\tsuper.onStart();\n\n\t\t// connect with manager service to find all bridges\n\t\t// when connected it will insert all views\n\t\tbindService(new Intent(this, TerminalManager.class), connection, Context.BIND_AUTO_CREATE);\n\t}\n\n\t@Override\n\tpublic void onPause() {\n\t\tsuper.onPause();\n\t\tLog.d(TAG, \"onPause called\");\n\n\t\tif (forcedOrientation && bound != null)\n\t\t\tbound.setResizeAllowed(false);\n\t}\n\n\t@Override\n\tpublic void onResume() {\n\t\tsuper.onResume();\n\t\tLog.d(TAG, \"onResume called\");\n\n\t\t// Make sure we don't let the screen fall asleep.\n\t\t// This also keeps the Wi-Fi chipset from disconnecting us.\n\t\tif (prefs.getBoolean(PreferenceConstants.KEEP_ALIVE, true)) {\n\t\t\tgetWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);\n\t\t} else {\n\t\t\tgetWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);\n\t\t}\n\n\t\tconfigureOrientation();\n\n\t\tif (forcedOrientation && bound != null)\n\t\t\tbound.setResizeAllowed(true);\n\t}\n\n\t/* (non-Javadoc)\n\t * @see android.app.Activity#onNewIntent(android.content.Intent)\n\t */\n\t@Override\n\tprotected void onNewIntent(Intent intent) {\n\t\tsuper.onNewIntent(intent);\n\n\t\tLog.d(TAG, \"onNewIntent called\");\n\n\t\trequested = intent.getData();\n\n\t\tif (requested == null) {\n\t\t\tLog.e(TAG, \"Got null intent data in onNewIntent()\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (bound == null) {\n\t\t\tLog.e(TAG, \"We're not bound in onNewIntent()\");\n\t\t\treturn;\n\t\t}\n\n\t\tTerminalBridge requestedBridge = bound.getConnectedBridge(requested.getFragment());\n\t\tint requestedIndex = 0;\n\n\t\tsynchronized (pager) {\n\t\t\tif (requestedBridge == null) {\n\t\t\t\t// If we didn't find the requested connection, try opening it\n\n\t\t\t\ttry {\n\t\t\t\t\tLog.d(TAG, String.format(\"We couldnt find an existing bridge with URI=%s (nickname=%s),\" +\n\t\t\t\t\t\t\t\"so creating one now\", requested.toString(), requested.getFragment()));\n\t\t\t\t\trequestedBridge = bound.openConnection(requested);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tLog.e(TAG, \"Problem while trying to create new requested bridge from URI\", e);\n\t\t\t\t\t// TODO: We should display an error dialog here.\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tadapter.notifyDataSetChanged();\n\t\t\t\trequestedIndex = adapter.getCount();\n\t\t\t} else {\n\t\t\t\tfinal int flipIndex = bound.getBridges().indexOf(requestedBridge);\n\t\t\t\tif (flipIndex > requestedIndex) {\n\t\t\t\t\trequestedIndex = flipIndex;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsetDisplayedTerminal(requestedIndex);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void onStop() {\n\t\tsuper.onStop();\n\n\t\tunbindService(connection);\n\t}\n\n\tprivate void startCopyMode() {\n\t\t// mark as copying and reset any previous bounds\n\t\tTerminalView terminalView = (TerminalView) adapter.getCurrentTerminalView();\n\t\tcopySource = terminalView.bridge;\n\n\t\tSelectionArea area = copySource.getSelectionArea();\n\t\tarea.reset();\n\t\tarea.setBounds(copySource.buffer.getColumns(), copySource.buffer.getRows());\n\n\t\tcopySource.setSelectingForCopy(true);\n\n\t\t// Make sure we show the initial selection\n\t\tcopySource.redraw();\n\t}\n\n\t/**\n\t * Save the currently shown {@link TerminalView} as the default. This is\n\t * saved back down into {@link TerminalManager} where we can read it again\n\t * later.\n\t */\n\tprivate void updateDefault() {\n\t\t// update the current default terminal\n\t\tTerminalView view = adapter.getCurrentTerminalView();\n\t\tif (view == null) return;\n\n\t\tif (bound == null) return;\n\t\tbound.defaultBridge = view.bridge;\n\t}\n\n\tprotected void updateEmptyVisible() {\n\t\t// update visibility of empty status message\n\t\tempty.setVisibility((pager.getChildCount() == 0) ? View.VISIBLE : View.GONE);\n\t}\n\n\t/**\n\t * Show any prompts requested by the currently visible {@link TerminalView}.\n\t */\n\tprotected void updatePromptVisible() {\n\t\t// check if our currently-visible terminalbridge is requesting any prompt services\n\t\tTerminalView view = adapter.getCurrentTerminalView();\n\n\t\t// Hide all the prompts in case a prompt request was canceled\n\t\thideAllPrompts();\n\n\t\tif (view == null) {\n\t\t\t// we dont have an active view, so hide any prompts\n\t\t\treturn;\n\t\t}\n\n\t\tPromptHelper prompt = view.bridge.promptHelper;\n\t\tif (String.class.equals(prompt.promptRequested)) {\n\t\t\tstringPromptGroup.setVisibility(View.VISIBLE);\n\n\t\t\tString instructions = prompt.promptInstructions;\n\t\t\tif (instructions != null && instructions.length() > 0) {\n\t\t\t\tstringPromptInstructions.setVisibility(View.VISIBLE);\n\t\t\t\tstringPromptInstructions.setText(instructions);\n\t\t\t} else\n\t\t\t\tstringPromptInstructions.setVisibility(View.GONE);\n\t\t\tstringPrompt.setText(\"\");\n\t\t\tstringPrompt.setHint(prompt.promptHint);\n\t\t\tstringPrompt.requestFocus();\n\n\t\t} else if (Boolean.class.equals(prompt.promptRequested)) {\n\t\t\tbooleanPromptGroup.setVisibility(View.VISIBLE);\n\t\t\tbooleanPrompt.setText(prompt.promptHint);\n\t\t\tbooleanYes.requestFocus();\n\n\t\t} else {\n\t\t\thideAllPrompts();\n\t\t\tview.requestFocus();\n\t\t}\n\t}\n\n\tprivate class URLItemListener implements OnItemClickListener {\n\t\tprivate WeakReference<Context> contextRef;\n\n\t\tURLItemListener(Context context) {\n\t\t\tthis.contextRef = new WeakReference<Context>(context);\n\t\t}\n\n\t\tpublic void onItemClick(AdapterView<?> arg0, View view, int position, long id) {\n\t\t\tContext context = contextRef.get();\n\n\t\t\tif (context == null)\n\t\t\t\treturn;\n\n\t\t\ttry {\n\t\t\t\tTextView urlView = (TextView) view;\n\n\t\t\t\tString url = urlView.getText().toString();\n\t\t\t\tif (url.indexOf(\"://\") < 0)\n\t\t\t\t\turl = \"http://\" + url;\n\n\t\t\t\tIntent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));\n\t\t\t\tcontext.startActivity(intent);\n\t\t\t} catch (Exception e) {\n\t\t\t\tLog.e(TAG, \"couldn't open URL\", e);\n\t\t\t\t// We should probably tell the user that we couldn't find a handler...\n\t\t\t}\n\t\t}\n\n\t}\n\n\t@Override\n\tpublic void onConfigurationChanged(Configuration newConfig) {\n\t\tsuper.onConfigurationChanged(newConfig);\n\n\t\tLog.d(TAG, String.format(\"onConfigurationChanged; requestedOrientation=%d, newConfig.orientation=%d\", getRequestedOrientation(), newConfig.orientation));\n\t\tif (bound != null) {\n\t\t\tif (forcedOrientation &&\n\t\t\t\t\t(newConfig.orientation != Configuration.ORIENTATION_LANDSCAPE &&\n\t\t\t\t\t\t\tgetRequestedOrientation() == ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE) ||\n\t\t\t\t\t(newConfig.orientation != Configuration.ORIENTATION_PORTRAIT &&\n\t\t\t\t\t\t\tgetRequestedOrientation() == ActivityInfo.SCREEN_ORIENTATION_PORTRAIT))\n\t\t\t\tbound.setResizeAllowed(false);\n\t\t\telse\n\t\t\t\tbound.setResizeAllowed(true);\n\n\t\t\tbound.hardKeyboardHidden = (newConfig.hardKeyboardHidden == Configuration.HARDKEYBOARDHIDDEN_YES);\n\n\t\t\tmKeyboardButton.setVisibility(bound.hardKeyboardHidden ? View.VISIBLE : View.GONE);\n\t\t}\n\t}\n\n\t/**\n\t * Called whenever the displayed terminal is changed.\n\t */\n\tprivate void onTerminalChanged() {\n\t\tView overlay = findCurrentView(R.id.terminal_overlay);\n\t\tif (overlay != null)\n\t\t\toverlay.startAnimation(fade_out_delayed);\n\t\tupdateDefault();\n\t\tupdatePromptVisible();\n\t\tActivityCompat.invalidateOptionsMenu(ConsoleActivity.this);\n\t}\n\n\t/**\n\t * Displays the child in the ViewPager at the requestedIndex and updates the prompts.\n\t *\n\t * @param requestedIndex the index of the terminal view to display\n\t */\n\tprivate void setDisplayedTerminal(int requestedIndex) {\n\t\tpager.setCurrentItem(requestedIndex);\n\t\tonTerminalChanged();\n\t}\n\n\tprivate void pasteIntoTerminal() {\n\t\t// force insert of clipboard text into current console\n\t\tTerminalView terminalView = adapter.getCurrentTerminalView();\n\t\tTerminalBridge bridge = terminalView.bridge;\n\n\t\t// pull string from clipboard and generate all events to force down\n\t\tString clip = clipboard.getText().toString();\n\t\tbridge.injectString(clip);\n\t}\n\n\tpublic class TerminalPagerAdapter extends PagerAdapter {\n\t\t@Override\n\t\tpublic int getCount() {\n\t\t\tif (bound != null) {\n\t\t\t\treturn bound.getBridges().size();\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Object instantiateItem(ViewGroup container, int position) {\n\t\t\tif (bound == null || bound.getBridges().size() <= position) {\n\t\t\t\tLog.w(TAG, \"Activity not bound when creating TerminalView.\");\n\t\t\t}\n\t\t\tTerminalBridge bridge = bound.getBridges().get(position);\n\t\t\tbridge.promptHelper.setHandler(promptHandler);\n\n\t\t\t// inflate each terminal view\n\t\t\tRelativeLayout view = (RelativeLayout) inflater.inflate(\n\t\t\t\t\tR.layout.item_terminal, container, false);\n\n\t\t\t// set the terminal overlay text\n\t\t\tTextView overlay = (TextView) view.findViewById(R.id.terminal_overlay);\n\t\t\toverlay.setText(bridge.host.getNickname());\n\n\t\t\t// and add our terminal view control, using index to place behind overlay\n\t\t\tfinal TerminalView terminal = new TerminalView(container.getContext(), bridge);\n\t\t\tterminal.setId(R.id.console_flip);\n\t\t\tview.addView(terminal, 0);\n\n\t\t\t// Tag the view with its bridge so it can be retrieved later.\n\t\t\tview.setTag(bridge);\n\n\t\t\tcontainer.addView(view);\n\t\t\toverlay.startAnimation(fade_out_delayed);\n\t\t\treturn view;\n\t\t}\n\n\t\t@Override\n\t\tpublic void destroyItem(ViewGroup container, int position, Object object) {\n\t\t\tfinal View view = (View) object;\n\n\t\t\tcontainer.removeView(view);\n\t\t}\n\n\t\t@Override\n\t\tpublic int getItemPosition(Object object) {\n\t\t\tfinal View view = (View) object;\n\t\t\tTerminalView terminal = (TerminalView) view.findViewById(R.id.console_flip);\n\t\t\tfinal HostBean host = terminal.bridge.host;\n\t\t\tint itemIndex = -1;\n\t\t\tint i = 0;\n\t\t\tfor (TerminalBridge bridge : bound.getBridges()) {\n\t\t\t\tif (bridge.host.equals(host)) {\n\t\t\t\t\titemIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif (itemIndex == -1) {\n\t\t\t\treturn POSITION_NONE;\n\t\t\t} else {\n\t\t\t\treturn itemIndex;\n\t\t\t}\n\t\t}\n\n\t\tpublic TerminalBridge getItemAtPosition(int position) {\n\t\t\tArrayList<TerminalBridge> bridges = bound.getBridges();\n\t\t\tif (position < 0 || position >= bridges.size()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn bridges.get(position);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isViewFromObject(View view, Object object) {\n\t\t\treturn view == object;\n\t\t}\n\n\t\t@Override\n\t\tpublic CharSequence getPageTitle(int position) {\n\t\t\tTerminalBridge bridge = getItemAtPosition(position);\n\t\t\tif (bridge == null) {\n\t\t\t\treturn \"???\";\n\t\t\t}\n\t\t\treturn bridge.host.getNickname();\n\t\t}\n\n\t\tpublic TerminalView getCurrentTerminalView() {\n\t\t\tView currentView = pager.findViewWithTag(adapter.getItemAtPosition(pager.getCurrentItem()));\n\t\t\tif (currentView == null) return null;\n\t\t\treturn (TerminalView) currentView.findViewById(R.id.console_flip);\n\t\t}\n\t}\n}\n","lineNo":1232}
{"Smelly Sample":"/*\n * ConnectBot: simple, powerful, open-source SSH client for Android\n * Copyright 2007 Kenny Root, Jeffrey Sharkey\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.connectbot.transport;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.security.KeyPair;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.interfaces.DSAPrivateKey;\nimport java.security.interfaces.DSAPublicKey;\nimport java.security.interfaces.RSAPrivateKey;\nimport java.security.interfaces.RSAPublicKey;\nimport java.security.spec.InvalidKeySpecException;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.connectbot.R;\nimport org.connectbot.bean.HostBean;\nimport org.connectbot.bean.PortForwardBean;\nimport org.connectbot.bean.PubkeyBean;\nimport org.connectbot.service.TerminalBridge;\nimport org.connectbot.service.TerminalManager;\nimport org.connectbot.service.TerminalManager.KeyHolder;\nimport org.connectbot.util.HostDatabase;\nimport org.connectbot.util.PubkeyDatabase;\nimport org.connectbot.util.PubkeyUtils;\n\nimport android.content.Context;\nimport android.net.Uri;\nimport android.util.Log;\n\nimport com.trilead.ssh2.AuthAgentCallback;\nimport com.trilead.ssh2.ChannelCondition;\nimport com.trilead.ssh2.Connection;\nimport com.trilead.ssh2.ConnectionInfo;\nimport com.trilead.ssh2.ConnectionMonitor;\nimport com.trilead.ssh2.DynamicPortForwarder;\nimport com.trilead.ssh2.InteractiveCallback;\nimport com.trilead.ssh2.KnownHosts;\nimport com.trilead.ssh2.LocalPortForwarder;\nimport com.trilead.ssh2.ServerHostKeyVerifier;\nimport com.trilead.ssh2.Session;\nimport com.trilead.ssh2.crypto.PEMDecoder;\nimport com.trilead.ssh2.signature.DSASHA1Verify;\nimport com.trilead.ssh2.signature.RSASHA1Verify;\n\n/**\n * @author Kenny Root\n *\n */\npublic class SSH extends AbsTransport implements ConnectionMonitor, InteractiveCallback, AuthAgentCallback {\n\tpublic SSH() {\n\t\tsuper();\n\t}\n\n\t/**\n\t * @param host\n\t * @param bridge\n\t * @param manager\n\t */\n\tpublic SSH(HostBean host, TerminalBridge bridge, TerminalManager manager) {\n\t\tsuper(host, bridge, manager);\n\t}\n\n\tprivate static final String PROTOCOL = \"ssh\";\n\tprivate static final String TAG = \"ConnectBot.SSH\";\n\tprivate static final int DEFAULT_PORT = 22;\n\n\tprivate static final String AUTH_PUBLICKEY = \"publickey\",\n\t\tAUTH_PASSWORD = \"password\",\n\t\tAUTH_KEYBOARDINTERACTIVE = \"keyboard-interactive\";\n\n\tprivate final static int AUTH_TRIES = 20;\n\n\tstatic final Pattern hostmask;\n\tstatic {\n\t\thostmask = Pattern.compile(\"^(.+)@([0-9a-z.-]+)(:(\\\\d+))?$\", Pattern.CASE_INSENSITIVE);\n\t}\n\n\tprivate boolean compression = false;\n\tprivate volatile boolean authenticated = false;\n\tprivate volatile boolean connected = false;\n\tprivate volatile boolean sessionOpen = false;\n\n\tprivate boolean pubkeysExhausted = false;\n\tprivate boolean interactiveCanContinue = true;\n\n\tprivate Connection connection;\n\tprivate Session session;\n\tprivate ConnectionInfo connectionInfo;\n\n\tprivate OutputStream stdin;\n\tprivate InputStream stdout;\n\tprivate InputStream stderr;\n\n\tprivate static final int conditions = ChannelCondition.STDOUT_DATA\n\t\t| ChannelCondition.STDERR_DATA\n\t\t| ChannelCondition.CLOSED\n\t\t| ChannelCondition.EOF;\n\n\tprivate List<PortForwardBean> portForwards = new LinkedList<PortForwardBean>();\n\n\tprivate int columns;\n\tprivate int rows;\n\n\tprivate int width;\n\tprivate int height;\n\n\tprivate String useAuthAgent = HostDatabase.AUTHAGENT_NO;\n\tprivate String agentLockPassphrase;\n\n\tpublic class HostKeyVerifier implements ServerHostKeyVerifier {\n\t\tpublic boolean verifyServerHostKey(String hostname, int port,\n\t\t\t\tString serverHostKeyAlgorithm, byte[] serverHostKey) throws IOException {\n\n\t\t\t// read in all known hosts from hostdb\n\t\t\tKnownHosts hosts = manager.hostdb.getKnownHosts();\n\t\t\tBoolean result;\n\n\t\t\tString matchName = String.format(Locale.US, \"%s:%d\", hostname, port);\n\n\t\t\tString fingerprint = KnownHosts.createHexFingerprint(serverHostKeyAlgorithm, serverHostKey);\n\n\t\t\tString algorithmName;\n\t\t\tif (\"ssh-rsa\".equals(serverHostKeyAlgorithm))\n\t\t\t\talgorithmName = \"RSA\";\n\t\t\telse if (\"ssh-dss\".equals(serverHostKeyAlgorithm))\n\t\t\t\talgorithmName = \"DSA\";\n\t\t\telse if (serverHostKeyAlgorithm.startsWith(\"ecdsa-\"))\n\t\t\t    algorithmName = \"EC\";\n\t\t\telse\n\t\t\t\talgorithmName = serverHostKeyAlgorithm;\n\n\t\t\tswitch(hosts.verifyHostkey(matchName, serverHostKeyAlgorithm, serverHostKey)) {\n\t\t\tcase KnownHosts.HOSTKEY_IS_OK:\n\t\t\t\tbridge.outputLine(manager.res.getString(R.string.terminal_sucess, algorithmName, fingerprint));\n\t\t\t\treturn true;\n\n\t\t\tcase KnownHosts.HOSTKEY_IS_NEW:\n\t\t\t\t// prompt user\n\t\t\t\tbridge.outputLine(manager.res.getString(R.string.host_authenticity_warning, hostname));\n\t\t\t\tbridge.outputLine(manager.res.getString(R.string.host_fingerprint, algorithmName, fingerprint));\n\n\t\t\t\tresult = bridge.promptHelper.requestBooleanPrompt(null, manager.res.getString(R.string.prompt_continue_connecting));\n\t\t\t\tif(result == null) return false;\n\t\t\t\tif(result.booleanValue()) {\n\t\t\t\t\t// save this key in known database\n\t\t\t\t\tmanager.hostdb.saveKnownHost(hostname, port, serverHostKeyAlgorithm, serverHostKey);\n\t\t\t\t}\n\t\t\t\treturn result.booleanValue();\n\n\t\t\tcase KnownHosts.HOSTKEY_HAS_CHANGED:\n\t\t\t\tString header = String.format(\"@   %s   @\",\n\t\t\t\t\t\tmanager.res.getString(R.string.host_verification_failure_warning_header));\n\n\t\t\t\tchar[] atsigns = new char[header.length()];\n\t\t\t\tArrays.fill(atsigns, '@');\n\t\t\t\tString border = new String(atsigns);\n\n\t\t\t\tbridge.outputLine(border);\n\t\t\t\tbridge.outputLine(manager.res.getString(R.string.host_verification_failure_warning));\n\t\t\t\tbridge.outputLine(border);\n\n\t\t\t\tbridge.outputLine(String.format(manager.res.getString(R.string.host_fingerprint),\n\t\t\t\t\t\talgorithmName, fingerprint));\n\n\t\t\t\t// Users have no way to delete keys, so we'll prompt them for now.\n\t\t\t\tresult = bridge.promptHelper.requestBooleanPrompt(null, manager.res.getString(R.string.prompt_continue_connecting));\n\t\t\t\tif(result == null) return false;\n\t\t\t\tif(result.booleanValue()) {\n\t\t\t\t\t// save this key in known database\n\t\t\t\t\tmanager.hostdb.saveKnownHost(hostname, port, serverHostKeyAlgorithm, serverHostKey);\n\t\t\t\t}\n\t\t\t\treturn result.booleanValue();\n\n\t\t\t\tdefault:\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t}\n\n\tprivate void authenticate() {\n\t\ttry {\n\t\t\tif (connection.authenticateWithNone(host.getUsername())) {\n\t\t\t\tfinishConnection();\n\t\t\t\treturn;\n\t\t\t}\n\t\t} catch(Exception e) {\n\t\t\tLog.d(TAG, \"Host does not support 'none' authentication.\");\n\t\t}\n\n\t\tbridge.outputLine(manager.res.getString(R.string.terminal_auth));\n\n\t\ttry {\n\t\t\tlong pubkeyId = host.getPubkeyId();\n\n\t\t\tif (!pubkeysExhausted &&\n\t\t\t\t\tpubkeyId != HostDatabase.PUBKEYID_NEVER &&\n\t\t\t\t\tconnection.isAuthMethodAvailable(host.getUsername(), AUTH_PUBLICKEY)) {\n\n\t\t\t\t// if explicit pubkey defined for this host, then prompt for password as needed\n\t\t\t\t// otherwise just try all in-memory keys held in terminalmanager\n\n\t\t\t\tif (pubkeyId == HostDatabase.PUBKEYID_ANY) {\n\t\t\t\t\t// try each of the in-memory keys\n\t\t\t\t\tbridge.outputLine(manager.res\n\t\t\t\t\t\t\t.getString(R.string.terminal_auth_pubkey_any));\n\t\t\t\t\tfor (Entry<String, KeyHolder> entry : manager.loadedKeypairs.entrySet()) {\n\t\t\t\t\t\tif (entry.getValue().bean.isConfirmUse()\n\t\t\t\t\t\t\t\t&& !promptForPubkeyUse(entry.getKey()))\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tif (this.tryPublicKey(host.getUsername(), entry.getKey(),\n\t\t\t\t\t\t\t\tentry.getValue().pair)) {\n\t\t\t\t\t\t\tfinishConnection();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbridge.outputLine(manager.res.getString(R.string.terminal_auth_pubkey_specific));\n\t\t\t\t\t// use a specific key for this host, as requested\n\t\t\t\t\tPubkeyBean pubkey = manager.pubkeydb.findPubkeyById(pubkeyId);\n\n\t\t\t\t\tif (pubkey == null)\n\t\t\t\t\t\tbridge.outputLine(manager.res.getString(R.string.terminal_auth_pubkey_invalid));\n\t\t\t\t\telse\n\t\t\t\t\t\tif (tryPublicKey(pubkey))\n\t\t\t\t\t\t\tfinishConnection();\n\t\t\t\t}\n\n\t\t\t\tpubkeysExhausted = true;\n\t\t\t} else if (interactiveCanContinue &&\n\t\t\t\t\tconnection.isAuthMethodAvailable(host.getUsername(), AUTH_KEYBOARDINTERACTIVE)) {\n\t\t\t\t// this auth method will talk with us using InteractiveCallback interface\n\t\t\t\t// it blocks until authentication finishes\n\t\t\t\tbridge.outputLine(manager.res.getString(R.string.terminal_auth_ki));\n\t\t\t\tinteractiveCanContinue = false;\n\t\t\t\tif(connection.authenticateWithKeyboardInteractive(host.getUsername(), this)) {\n\t\t\t\t\tfinishConnection();\n\t\t\t\t} else {\n\t\t\t\t\tbridge.outputLine(manager.res.getString(R.string.terminal_auth_ki_fail));\n\t\t\t\t}\n\t\t\t} else if (connection.isAuthMethodAvailable(host.getUsername(), AUTH_PASSWORD)) {\n\t\t\t\tbridge.outputLine(manager.res.getString(R.string.terminal_auth_pass));\n\t\t\t\tString password = bridge.getPromptHelper().requestStringPrompt(null,\n\t\t\t\t\t\tmanager.res.getString(R.string.prompt_password));\n\t\t\t\tif (password != null\n\t\t\t\t\t\t&& connection.authenticateWithPassword(host.getUsername(), password)) {\n\t\t\t\t\tfinishConnection();\n\t\t\t\t} else {\n\t\t\t\t\tbridge.outputLine(manager.res.getString(R.string.terminal_auth_pass_fail));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbridge.outputLine(manager.res.getString(R.string.terminal_auth_fail));\n\t\t\t}\n\t\t} catch (IllegalStateException e) {\n\t\t\tLog.e(TAG, \"Connection went away while we were trying to authenticate\", e);\n\t\t\treturn;\n\t\t} catch(Exception e) {\n\t\t\tLog.e(TAG, \"Problem during handleAuthentication()\", e);\n\t\t}\n\t}\n\n\t/**\n\t * Attempt connection with database row pointed to by cursor.\n\t * @param cursor\n\t * @return true for successful authentication\n\t * @throws NoSuchAlgorithmException\n\t * @throws InvalidKeySpecException\n\t * @throws IOException\n\t */\n\tprivate boolean tryPublicKey(PubkeyBean pubkey) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException {\n\t\tKeyPair pair = null;\n\n\t\tif(manager.isKeyLoaded(pubkey.getNickname())) {\n\t\t\t// load this key from memory if its already there\n\t\t\tLog.d(TAG, String.format(\"Found unlocked key '%s' already in-memory\", pubkey.getNickname()));\n\n\t\t\tif (pubkey.isConfirmUse()) {\n\t\t\t\tif (!promptForPubkeyUse(pubkey.getNickname()))\n\t\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tpair = manager.getKey(pubkey.getNickname());\n\t\t} else {\n\t\t\t// otherwise load key from database and prompt for password as needed\n\t\t\tString password = null;\n\t\t\tif (pubkey.isEncrypted()) {\n\t\t\t\tpassword = bridge.getPromptHelper().requestStringPrompt(null,\n\t\t\t\t\t\tmanager.res.getString(R.string.prompt_pubkey_password, pubkey.getNickname()));\n\n\t\t\t\t// Something must have interrupted the prompt.\n\t\t\t\tif (password == null)\n\t\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif(PubkeyDatabase.KEY_TYPE_IMPORTED.equals(pubkey.getType())) {\n\t\t\t\t// load specific key using pem format\n\t\t\t\tpair = PEMDecoder.decode(new String(pubkey.getPrivateKey()).toCharArray(), password);\n\t\t\t} else {\n\t\t\t\t// load using internal generated format\n\t\t\t\tPrivateKey privKey;\n\t\t\t\ttry {\n\t\t\t\t\tprivKey = PubkeyUtils.decodePrivate(pubkey.getPrivateKey(),\n\t\t\t\t\t\t\tpubkey.getType(), password);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tString message = String.format(\"Bad password for key '%s'. Authentication failed.\", pubkey.getNickname());\n\t\t\t\t\tLog.e(TAG, message, e);\n\t\t\t\t\tbridge.outputLine(message);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tPublicKey pubKey = PubkeyUtils.decodePublic(pubkey.getPublicKey(), pubkey.getType());\n\n\t\t\t\t// convert key to trilead format\n\t\t\t\tpair = new KeyPair(pubKey, privKey);\n\t\t\t\tLog.d(TAG, \"Unlocked key \" + PubkeyUtils.formatKey(pubKey));\n\t\t\t}\n\n\t\t\tLog.d(TAG, String.format(\"Unlocked key '%s'\", pubkey.getNickname()));\n\n\t\t\t// save this key in memory\n\t\t\tmanager.addKey(pubkey, pair);\n\t\t}\n\n\t\treturn tryPublicKey(host.getUsername(), pubkey.getNickname(), pair);\n\t}\n\n\tprivate boolean tryPublicKey(String username, String keyNickname, KeyPair pair) throws IOException {\n\t\t//bridge.outputLine(String.format(\"Attempting 'publickey' with key '%s' [%s]...\", keyNickname, trileadKey.toString()));\n\t\tboolean success = connection.authenticateWithPublicKey(username, pair);\n\t\tif(!success)\n\t\t\tbridge.outputLine(manager.res.getString(R.string.terminal_auth_pubkey_fail, keyNickname));\n\t\treturn success;\n\t}\n\n\t/**\n\t * Internal method to request actual PTY terminal once we've finished\n\t * authentication. If called before authenticated, it will just fail.\n\t */\n\tprivate void finishConnection() {\n\t\tauthenticated = true;\n\n\t\tfor (PortForwardBean portForward : portForwards) {\n\t\t\ttry {\n\t\t\t\tenablePortForward(portForward);\n\t\t\t\tbridge.outputLine(manager.res.getString(R.string.terminal_enable_portfoward, portForward.getDescription()));\n\t\t\t} catch (Exception e) {\n\t\t\t\tLog.e(TAG, \"Error setting up port forward during connect\", e);\n\t\t\t}\n\t\t}\n\n\t\tif (!host.getWantSession()) {\n\t\t\tbridge.outputLine(manager.res.getString(R.string.terminal_no_session));\n\t\t\tbridge.onConnected();\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tsession = connection.openSession();\n\n\t\t\tif (!useAuthAgent.equals(HostDatabase.AUTHAGENT_NO))\n\t\t\t\tsession.requestAuthAgentForwarding(this);\n\n\t\t\tsession.requestPTY(getEmulation(), columns, rows, width, height, null);\n\t\t\tsession.startShell();\n\n\t\t\tstdin = session.getStdin();\n\t\t\tstdout = session.getStdout();\n\t\t\tstderr = session.getStderr();\n\n\t\t\tsessionOpen = true;\n\n\t\t\tbridge.onConnected();\n\t\t} catch (IOException e1) {\n\t\t\tLog.e(TAG, \"Problem while trying to create PTY in finishConnection()\", e1);\n\t\t}\n\n\t}\n\n\t@Override\n\tpublic void connect() {\n\t\tconnection = new Connection(host.getHostname(), host.getPort());\n\t\tconnection.addConnectionMonitor(this);\n\n\t\ttry {\n\t\t\tconnection.setCompression(compression);\n\t\t} catch (IOException e) {\n\t\t\tLog.e(TAG, \"Could not enable compression!\", e);\n\t\t}\n\n\t\ttry {\n\t\t\t/* Uncomment when debugging SSH protocol:\n\t\t\tDebugLogger logger = new DebugLogger() {\n\n\t\t\t\tpublic void log(int level, String className, String message) {\n\t\t\t\t\tLog.d(\"SSH\", message);\n\t\t\t\t}\n\n\t\t\t};\n\t\t\tLogger.enabled = true;\n\t\t\tLogger.logger = logger;\n\t\t\t*/\n\t\t\tconnectionInfo = connection.connect(new HostKeyVerifier());\n\t\t\tconnected = true;\n\n\t\t\tif (connectionInfo.clientToServerCryptoAlgorithm\n\t\t\t\t\t.equals(connectionInfo.serverToClientCryptoAlgorithm)\n\t\t\t\t\t&& connectionInfo.clientToServerMACAlgorithm\n\t\t\t\t\t\t\t.equals(connectionInfo.serverToClientMACAlgorithm)) {\n\t\t\t\tbridge.outputLine(manager.res.getString(R.string.terminal_using_algorithm,\n\t\t\t\t\t\tconnectionInfo.clientToServerCryptoAlgorithm,\n\t\t\t\t\t\tconnectionInfo.clientToServerMACAlgorithm));\n\t\t\t} else {\n\t\t\t\tbridge.outputLine(manager.res.getString(\n\t\t\t\t\t\tR.string.terminal_using_c2s_algorithm,\n\t\t\t\t\t\tconnectionInfo.clientToServerCryptoAlgorithm,\n\t\t\t\t\t\tconnectionInfo.clientToServerMACAlgorithm));\n\n\t\t\t\tbridge.outputLine(manager.res.getString(\n\t\t\t\t\t\tR.string.terminal_using_s2c_algorithm,\n\t\t\t\t\t\tconnectionInfo.serverToClientCryptoAlgorithm,\n\t\t\t\t\t\tconnectionInfo.serverToClientMACAlgorithm));\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tLog.e(TAG, \"Problem in SSH connection thread during authentication\", e);\n\n\t\t\t// Display the reason in the text.\n\t\t\tbridge.outputLine(e.getCause().getMessage());\n\n\t\t\tclose();\n\t\t\tonDisconnect();\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\t// enter a loop to keep trying until authentication\n\t\t\tint tries = 0;\n\t\t\twhile (connected && !connection.isAuthenticationComplete() && tries++ < AUTH_TRIES) {\n\t\t\t\tauthenticate();\n\n\t\t\t\t// sleep to make sure we dont kill system\n\t\t\t\tThread.sleep(1000);\n\t\t\t}\n\t\t} catch(Exception e) {\n\t\t\tLog.e(TAG, \"Problem in SSH connection thread during authentication\", e);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void close() {\n\t\tconnected = false;\n\n\t\tif (session != null) {\n\t\t\tsession.close();\n\t\t\tsession = null;\n\t\t}\n\n\t\tif (connection != null) {\n\t\t\tconnection.close();\n\t\t\tconnection = null;\n\t\t}\n\t}\n\n\tprivate void onDisconnect() {\n\t\tbridge.dispatchDisconnect(false);\n\t}\n\n\t@Override\n\tpublic void flush() throws IOException {\n\t\tif (stdin != null)\n\t\t\tstdin.flush();\n\t}\n\n\t@Override\n\tpublic int read(byte[] buffer, int start, int len) throws IOException {\n\t\tint bytesRead = 0;\n\n\t\tif (session == null)\n\t\t\treturn 0;\n\n\t\tint newConditions = session.waitForCondition(conditions, 0);\n\n\t\tif ((newConditions & ChannelCondition.STDOUT_DATA) != 0) {\n\t\t\tbytesRead = stdout.read(buffer, start, len);\n\t\t}\n\n\t\tif ((newConditions & ChannelCondition.STDERR_DATA) != 0) {\n\t\t\tbyte discard[] = new byte[256];\n\t\t\twhile (stderr.available() > 0) {\n\t\t\t\tstderr.read(discard);\n\t\t\t}\n\t\t}\n\n\t\tif ((newConditions & ChannelCondition.EOF) != 0) {\n\t\t\tclose();\n\t\t\tonDisconnect();\n\t\t\tthrow new IOException(\"Remote end closed connection\");\n\t\t}\n\n\t\treturn bytesRead;\n\t}\n\n\t@Override\n\tpublic void write(byte[] buffer) throws IOException {\n\t\tif (stdin != null)\n\t\t\tstdin.write(buffer);\n\t}\n\n\t@Override\n\tpublic void write(int c) throws IOException {\n\t\tif (stdin != null)\n\t\t\tstdin.write(c);\n\t}\n\n\t@Override\n\tpublic Map<String, String> getOptions() {\n\t\tMap<String, String> options = new HashMap<String, String>();\n\n\t\toptions.put(\"compression\", Boolean.toString(compression));\n\n\t\treturn options;\n\t}\n\n\t@Override\n\tpublic void setOptions(Map<String, String> options) {\n\t\tif (options.containsKey(\"compression\"))\n\t\t\tcompression = Boolean.parseBoolean(options.get(\"compression\"));\n\t}\n\n\tpublic static String getProtocolName() {\n\t\treturn PROTOCOL;\n\t}\n\n\t@Override\n\tpublic boolean isSessionOpen() {\n\t\treturn sessionOpen;\n\t}\n\n\t@Override\n\tpublic boolean isConnected() {\n\t\treturn connected;\n\t}\n\n\tpublic void connectionLost(Throwable reason) {\n\t\tonDisconnect();\n\t}\n\n\t@Override\n\tpublic boolean canForwardPorts() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic List<PortForwardBean> getPortForwards() {\n\t\treturn portForwards;\n\t}\n\n\t@Override\n\tpublic boolean addPortForward(PortForwardBean portForward) {\n\t\treturn portForwards.add(portForward);\n\t}\n\n\t@Override\n\tpublic boolean removePortForward(PortForwardBean portForward) {\n\t\t// Make sure we don't have a phantom forwarder.\n\t\tdisablePortForward(portForward);\n\n\t\treturn portForwards.remove(portForward);\n\t}\n\n\t@Override\n\tpublic boolean enablePortForward(PortForwardBean portForward) {\n\t\tif (!portForwards.contains(portForward)) {\n\t\t\tLog.e(TAG, \"Attempt to enable port forward not in list\");\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!authenticated)\n\t\t\treturn false;\n\n\t\tif (HostDatabase.PORTFORWARD_LOCAL.equals(portForward.getType())) {\n\t\t\tLocalPortForwarder lpf = null;\n\t\t\ttry {\n\t\t\t\tlpf = connection.createLocalPortForwarder(\n\t\t\t\t\t\tnew InetSocketAddress(InetAddress.getLocalHost(), portForward.getSourcePort()),\n\t\t\t\t\t\tportForward.getDestAddr(), portForward.getDestPort());\n\t\t\t} catch (Exception e) {\n\t\t\t\tLog.e(TAG, \"Could not create local port forward\", e);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (lpf == null) {\n\t\t\t\tLog.e(TAG, \"returned LocalPortForwarder object is null\");\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tportForward.setIdentifier(lpf);\n\t\t\tportForward.setEnabled(true);\n\t\t\treturn true;\n\t\t} else if (HostDatabase.PORTFORWARD_REMOTE.equals(portForward.getType())) {\n\t\t\ttry {\n\t\t\t\tconnection.requestRemotePortForwarding(\"\", portForward.getSourcePort(), portForward.getDestAddr(), portForward.getDestPort());\n\t\t\t} catch (Exception e) {\n\t\t\t\tLog.e(TAG, \"Could not create remote port forward\", e);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tportForward.setEnabled(true);\n\t\t\treturn true;\n\t\t} else if (HostDatabase.PORTFORWARD_DYNAMIC5.equals(portForward.getType())) {\n\t\t\tDynamicPortForwarder dpf = null;\n\n\t\t\ttry {\n\t\t\t\tdpf = connection.createDynamicPortForwarder(\n\t\t\t\t\t\tnew InetSocketAddress(InetAddress.getLocalHost(), portForward.getSourcePort()));\n\t\t\t} catch (Exception e) {\n\t\t\t\tLog.e(TAG, \"Could not create dynamic port forward\", e);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tportForward.setIdentifier(dpf);\n\t\t\tportForward.setEnabled(true);\n\t\t\treturn true;\n\t\t} else {\n\t\t\t// Unsupported type\n\t\t\tLog.e(TAG, String.format(\"attempt to forward unknown type %s\", portForward.getType()));\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean disablePortForward(PortForwardBean portForward) {\n\t\tif (!portForwards.contains(portForward)) {\n\t\t\tLog.e(TAG, \"Attempt to disable port forward not in list\");\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!authenticated)\n\t\t\treturn false;\n\n\t\tif (HostDatabase.PORTFORWARD_LOCAL.equals(portForward.getType())) {\n\t\t\tLocalPortForwarder lpf = null;\n\t\t\tlpf = (LocalPortForwarder)portForward.getIdentifier();\n\n\t\t\tif (!portForward.isEnabled() || lpf == null) {\n\t\t\t\tLog.d(TAG, String.format(\"Could not disable %s; it appears to be not enabled or have no handler\", portForward.getNickname()));\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tportForward.setEnabled(false);\n\n\t\t\ttry {\n\t\t\t\tlpf.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\tLog.e(TAG, \"Could not stop local port forwarder, setting enabled to false\", e);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t} else if (HostDatabase.PORTFORWARD_REMOTE.equals(portForward.getType())) {\n\t\t\tportForward.setEnabled(false);\n\n\t\t\ttry {\n\t\t\t\tconnection.cancelRemotePortForwarding(portForward.getSourcePort());\n\t\t\t} catch (IOException e) {\n\t\t\t\tLog.e(TAG, \"Could not stop remote port forwarding, setting enabled to false\", e);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t} else if (HostDatabase.PORTFORWARD_DYNAMIC5.equals(portForward.getType())) {\n\t\t\tDynamicPortForwarder dpf = null;\n\t\t\tdpf = (DynamicPortForwarder)portForward.getIdentifier();\n\n\t\t\tif (!portForward.isEnabled() || dpf == null) {\n\t\t\t\tLog.d(TAG, String.format(\"Could not disable %s; it appears to be not enabled or have no handler\", portForward.getNickname()));\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tportForward.setEnabled(false);\n\n\t\t\ttry {\n\t\t\t\tdpf.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\tLog.e(TAG, \"Could not stop dynamic port forwarder, setting enabled to false\", e);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t} else {\n\t\t\t// Unsupported type\n\t\t\tLog.e(TAG, String.format(\"attempt to forward unknown type %s\", portForward.getType()));\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t@Override\n\tpublic void setDimensions(int columns, int rows, int width, int height) {\n\t\tthis.columns = columns;\n\t\tthis.rows = rows;\n\n\t\tif (sessionOpen) {\n\t\t\ttry {\n\t\t\t\tsession.resizePTY(columns, rows, width, height);\n\t\t\t} catch (IOException e) {\n\t\t\t\tLog.e(TAG, \"Couldn't send resize PTY packet\", e);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic int getDefaultPort() {\n\t\treturn DEFAULT_PORT;\n\t}\n\n\t@Override\n\tpublic String getDefaultNickname(String username, String hostname, int port) {\n\t\tif (port == DEFAULT_PORT) {\n\t\t\treturn String.format(Locale.US, \"%s@%s\", username, hostname);\n\t\t} else {\n\t\t\treturn String.format(Locale.US, \"%s@%s:%d\", username, hostname, port);\n\t\t}\n\t}\n\n\tpublic static Uri getUri(String input) {\n\t\tMatcher matcher = hostmask.matcher(input);\n\n\t\tif (!matcher.matches())\n\t\t\treturn null;\n\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tsb.append(PROTOCOL)\n\t\t\t.append(\"://\")\n\t\t\t.append(Uri.encode(matcher.group(1)))\n\t\t\t.append('@')\n\t\t\t.append(matcher.group(2));\n\n\t\tString portString = matcher.group(4);\n\t\tint port = DEFAULT_PORT;\n\t\tif (portString != null) {\n\t\t\ttry {\n\t\t\t\tport = Integer.parseInt(portString);\n\t\t\t\tif (port < 1 || port > 65535) {\n\t\t\t\t\tport = DEFAULT_PORT;\n\t\t\t\t}\n\t\t\t} catch (NumberFormatException nfe) {\n\t\t\t\t// Keep the default port\n\t\t\t}\n\t\t}\n\n\t\tif (port != DEFAULT_PORT) {\n\t\t\tsb.append(':')\n\t\t\t\t.append(port);\n\t\t}\n\n\t\tsb.append(\"/#\")\n\t\t\t.append(Uri.encode(input));\n\n\t\tUri uri = Uri.parse(sb.toString());\n\n\t\treturn uri;\n\t}\n\n\t/**\n\t * Handle challenges from keyboard-interactive authentication mode.\n\t */\n\tpublic String[] replyToChallenge(String name, String instruction, int numPrompts, String[] prompt, boolean[] echo) {\n\t\tinteractiveCanContinue = true;\n\t\tString[] responses = new String[numPrompts];\n\t\tfor(int i = 0; i < numPrompts; i++) {\n\t\t\t// request response from user for each prompt\n\t\t\tresponses[i] = bridge.promptHelper.requestStringPrompt(instruction, prompt[i]);\n\t\t}\n\t\treturn responses;\n\t}\n\n\t@Override\n\tpublic HostBean createHost(Uri uri) {\n\t\tHostBean host = new HostBean();\n\n\t\thost.setProtocol(PROTOCOL);\n\n\t\thost.setHostname(uri.getHost());\n\n\t\tint port = uri.getPort();\n\t\tif (port < 0)\n\t\t\tport = DEFAULT_PORT;\n\t\thost.setPort(port);\n\n\t\thost.setUsername(uri.getUserInfo());\n\n\t\tString nickname = uri.getFragment();\n\t\tif (nickname == null || nickname.length() == 0) {\n\t\t\thost.setNickname(getDefaultNickname(host.getUsername(),\n\t\t\t\t\thost.getHostname(), host.getPort()));\n\t\t} else {\n\t\t\thost.setNickname(uri.getFragment());\n\t\t}\n\n\t\treturn host;\n\t}\n\n\t@Override\n\tpublic void getSelectionArgs(Uri uri, Map<String, String> selection) {\n\t\tselection.put(HostDatabase.FIELD_HOST_PROTOCOL, PROTOCOL);\n\t\tselection.put(HostDatabase.FIELD_HOST_NICKNAME, uri.getFragment());\n\t\tselection.put(HostDatabase.FIELD_HOST_HOSTNAME, uri.getHost());\n\n\t\tint port = uri.getPort();\n\t\tif (port < 0)\n\t\t\tport = DEFAULT_PORT;\n\t\tselection.put(HostDatabase.FIELD_HOST_PORT, Integer.toString(port));\n\t\tselection.put(HostDatabase.FIELD_HOST_USERNAME, uri.getUserInfo());\n\t}\n\n\t@Override\n\tpublic void setCompression(boolean compression) {\n\t\tthis.compression = compression;\n\t}\n\n\tpublic static String getFormatHint(Context context) {\n\t\treturn String.format(\"%s@%s:%s\",\n\t\t\t\tcontext.getString(R.string.format_username),\n\t\t\t\tcontext.getString(R.string.format_hostname),\n\t\t\t\tcontext.getString(R.string.format_port));\n\t}\n\n\t@Override\n\tpublic void setUseAuthAgent(String useAuthAgent) {\n\t\tthis.useAuthAgent = useAuthAgent;\n\t}\n\n\tpublic Map<String,byte[]> retrieveIdentities() {\n\t\tMap<String,byte[]> pubKeys = new HashMap<String,byte[]>(manager.loadedKeypairs.size());\n\n\t\tfor (Entry<String,KeyHolder> entry : manager.loadedKeypairs.entrySet()) {\n\t\t\tKeyPair pair = entry.getValue().pair;\n\n\t\t\ttry {\n\t\t\t\tPrivateKey privKey = pair.getPrivate();\n\t\t\t\tif (privKey instanceof RSAPrivateKey) {\n\t\t\t\t\tRSAPublicKey pubkey = (RSAPublicKey) pair.getPublic();\n\t\t\t\t\tpubKeys.put(entry.getKey(), RSASHA1Verify.encodeSSHRSAPublicKey(pubkey));\n\t\t\t\t} else if (privKey instanceof DSAPrivateKey) {\n\t\t\t\t\tDSAPublicKey pubkey = (DSAPublicKey) pair.getPublic();\n\t\t\t\t\tpubKeys.put(entry.getKey(), DSASHA1Verify.encodeSSHDSAPublicKey(pubkey));\n\t\t\t\t} else\n\t\t\t\t\tcontinue;\n\t\t\t} catch (IOException e) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\treturn pubKeys;\n\t}\n\n\tpublic KeyPair getKeyPair(byte[] publicKey) {\n\t\tString nickname = manager.getKeyNickname(publicKey);\n\n\t\tif (nickname == null)\n\t\t\treturn null;\n\n\t\tif (useAuthAgent.equals(HostDatabase.AUTHAGENT_NO)) {\n\t\t\tLog.e(TAG, \"\");\n\t\t\treturn null;\n\t\t} else if (useAuthAgent.equals(HostDatabase.AUTHAGENT_CONFIRM) ||\n\t\t\t\tmanager.loadedKeypairs.get(nickname).bean.isConfirmUse()) {\n\t\t\tif (!promptForPubkeyUse(nickname))\n\t\t\t\treturn null;\n\t\t}\n\t\treturn manager.getKey(nickname);\n\t}\n\n\tprivate boolean promptForPubkeyUse(String nickname) {\n\t\tBoolean result = bridge.promptHelper.requestBooleanPrompt(null,\n\t\t\t\tmanager.res.getString(R.string.prompt_allow_agent_to_use_key,\n\t\t\t\t\t\tnickname));\n\t\treturn result;\n\t}\n\n\tpublic boolean addIdentity(KeyPair pair, String comment, boolean confirmUse, int lifetime) {\n\t\tPubkeyBean pubkey = new PubkeyBean();\n//\t\tpubkey.setType(PubkeyDatabase.KEY_TYPE_IMPORTED);\n\t\tpubkey.setNickname(comment);\n\t\tpubkey.setConfirmUse(confirmUse);\n\t\tpubkey.setLifetime(lifetime);\n\t\tmanager.addKey(pubkey, pair);\n\t\treturn true;\n\t}\n\n\tpublic boolean removeAllIdentities() {\n\t\tmanager.loadedKeypairs.clear();\n\t\treturn true;\n\t}\n\n\tpublic boolean removeIdentity(byte[] publicKey) {\n\t\treturn manager.removeKey(publicKey);\n\t}\n\n\tpublic boolean isAgentLocked() {\n\t\treturn agentLockPassphrase != null;\n\t}\n\n\tpublic boolean requestAgentUnlock(String unlockPassphrase) {\n\t\tif (agentLockPassphrase == null)\n\t\t\treturn false;\n\n\t\tif (agentLockPassphrase.equals(unlockPassphrase))\n\t\t\tagentLockPassphrase = null;\n\n\t\treturn agentLockPassphrase == null;\n\t}\n\n\tpublic boolean setAgentLock(String lockPassphrase) {\n\t\tif (agentLockPassphrase != null)\n\t\t\treturn false;\n\n\t\tagentLockPassphrase = lockPassphrase;\n\t\treturn true;\n\t}\n\n\t/* (non-Javadoc)\n\t * @see org.connectbot.transport.AbsTransport#usesNetwork()\n\t */\n\t@Override\n\tpublic boolean usesNetwork() {\n\t\treturn true;\n\t}\n}\n","Method after Refactoring":"/*\n * ConnectBot: simple, powerful, open-source SSH client for Android\n * Copyright 2007 Kenny Root, Jeffrey Sharkey\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.connectbot.transport;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.security.KeyPair;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.interfaces.DSAPrivateKey;\nimport java.security.interfaces.DSAPublicKey;\nimport java.security.interfaces.RSAPrivateKey;\nimport java.security.interfaces.RSAPublicKey;\nimport java.security.spec.InvalidKeySpecException;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.connectbot.R;\nimport org.connectbot.bean.HostBean;\nimport org.connectbot.bean.PortForwardBean;\nimport org.connectbot.bean.PubkeyBean;\nimport org.connectbot.service.TerminalBridge;\nimport org.connectbot.service.TerminalManager;\nimport org.connectbot.service.TerminalManager.KeyHolder;\nimport org.connectbot.util.HostDatabase;\nimport org.connectbot.util.PubkeyDatabase;\nimport org.connectbot.util.PubkeyUtils;\n\nimport android.content.Context;\nimport android.net.Uri;\nimport android.util.Log;\n\nimport com.trilead.ssh2.AuthAgentCallback;\nimport com.trilead.ssh2.ChannelCondition;\nimport com.trilead.ssh2.Connection;\nimport com.trilead.ssh2.ConnectionInfo;\nimport com.trilead.ssh2.ConnectionMonitor;\nimport com.trilead.ssh2.DynamicPortForwarder;\nimport com.trilead.ssh2.InteractiveCallback;\nimport com.trilead.ssh2.KnownHosts;\nimport com.trilead.ssh2.LocalPortForwarder;\nimport com.trilead.ssh2.ServerHostKeyVerifier;\nimport com.trilead.ssh2.Session;\nimport com.trilead.ssh2.crypto.PEMDecoder;\nimport com.trilead.ssh2.signature.DSASHA1Verify;\nimport com.trilead.ssh2.signature.RSASHA1Verify;\n\n/**\n * @author Kenny Root\n *\n */\npublic class SSH extends AbsTransport implements ConnectionMonitor, InteractiveCallback, AuthAgentCallback {\n\tpublic SSH() {\n\t\tsuper();\n\t}\n\n\t/**\n\t * @param host\n\t * @param bridge\n\t * @param manager\n\t */\n\tpublic SSH(HostBean host, TerminalBridge bridge, TerminalManager manager) {\n\t\tsuper(host, bridge, manager);\n\t}\n\n\tprivate static final String PROTOCOL = \"ssh\";\n\tprivate static final String TAG = \"ConnectBot.SSH\";\n\tprivate static final int DEFAULT_PORT = 22;\n\n\tprivate static final String AUTH_PUBLICKEY = \"publickey\",\n\t\tAUTH_PASSWORD = \"password\",\n\t\tAUTH_KEYBOARDINTERACTIVE = \"keyboard-interactive\";\n\n\tprivate final static int AUTH_TRIES = 20;\n\n\tstatic final Pattern hostmask;\n\tstatic {\n\t\thostmask = Pattern.compile(\"^(.+)@([0-9a-z.-]+)(:(\\\\d+))?$\", Pattern.CASE_INSENSITIVE);\n\t}\n\n\tprivate boolean compression = false;\n\tprivate volatile boolean authenticated = false;\n\tprivate volatile boolean connected = false;\n\tprivate volatile boolean sessionOpen = false;\n\n\tprivate boolean pubkeysExhausted = false;\n\tprivate boolean interactiveCanContinue = true;\n\n\tprivate Connection connection;\n\tprivate Session session;\n\tprivate ConnectionInfo connectionInfo;\n\n\tprivate OutputStream stdin;\n\tprivate InputStream stdout;\n\tprivate InputStream stderr;\n\n\tprivate static final int conditions = ChannelCondition.STDOUT_DATA\n\t\t| ChannelCondition.STDERR_DATA\n\t\t| ChannelCondition.CLOSED\n\t\t| ChannelCondition.EOF;\n\n\tprivate List<PortForwardBean> portForwards = new LinkedList<PortForwardBean>();\n\n\tprivate int columns;\n\tprivate int rows;\n\n\tprivate int width;\n\tprivate int height;\n\n\tprivate String useAuthAgent = HostDatabase.AUTHAGENT_NO;\n\tprivate String agentLockPassphrase;\n\n\tpublic class HostKeyVerifier implements ServerHostKeyVerifier {\n\t\tpublic boolean verifyServerHostKey(String hostname, int port,\n\t\t\t\tString serverHostKeyAlgorithm, byte[] serverHostKey) throws IOException {\n\n\t\t\t// read in all known hosts from hostdb\n\t\t\tKnownHosts hosts = manager.hostdb.getKnownHosts();\n\t\t\tBoolean result;\n\n\t\t\tString matchName = String.format(Locale.US, \"%s:%d\", hostname, port);\n\n\t\t\tString fingerprint = KnownHosts.createHexFingerprint(serverHostKeyAlgorithm, serverHostKey);\n\n\t\t\tString algorithmName;\n\t\t\tif (\"ssh-rsa\".equals(serverHostKeyAlgorithm))\n\t\t\t\talgorithmName = \"RSA\";\n\t\t\telse if (\"ssh-dss\".equals(serverHostKeyAlgorithm))\n\t\t\t\talgorithmName = \"DSA\";\n\t\t\telse if (serverHostKeyAlgorithm.startsWith(\"ecdsa-\"))\n\t\t\t    algorithmName = \"EC\";\n\t\t\telse\n\t\t\t\talgorithmName = serverHostKeyAlgorithm;\n\n\t\t\tswitch(hosts.verifyHostkey(matchName, serverHostKeyAlgorithm, serverHostKey)) {\n\t\t\tcase KnownHosts.HOSTKEY_IS_OK:\n\t\t\t\tbridge.outputLine(manager.res.getString(R.string.terminal_sucess, algorithmName, fingerprint));\n\t\t\t\treturn true;\n\n\t\t\tcase KnownHosts.HOSTKEY_IS_NEW:\n\t\t\t\t// prompt user\n\t\t\t\tbridge.outputLine(manager.res.getString(R.string.host_authenticity_warning, hostname));\n\t\t\t\tbridge.outputLine(manager.res.getString(R.string.host_fingerprint, algorithmName, fingerprint));\n\n\t\t\t\tresult = bridge.promptHelper.requestBooleanPrompt(null, manager.res.getString(R.string.prompt_continue_connecting));\n\t\t\t\tif(result == null) return false;\n\t\t\t\tif(result.booleanValue()) {\n\t\t\t\t\t// save this key in known database\n\t\t\t\t\tmanager.hostdb.saveKnownHost(hostname, port, serverHostKeyAlgorithm, serverHostKey);\n\t\t\t\t}\n\t\t\t\treturn result.booleanValue();\n\n\t\t\tcase KnownHosts.HOSTKEY_HAS_CHANGED:\n\t\t\t\tString header = String.format(\"@   %s   @\",\n\t\t\t\t\t\tmanager.res.getString(R.string.host_verification_failure_warning_header));\n\n\t\t\t\tchar[] atsigns = new char[header.length()];\n\t\t\t\tArrays.fill(atsigns, '@');\n\t\t\t\tString border = new String(atsigns);\n\n\t\t\t\tbridge.outputLine(border);\n\t\t\t\tbridge.outputLine(manager.res.getString(R.string.host_verification_failure_warning));\n\t\t\t\tbridge.outputLine(border);\n\n\t\t\t\tbridge.outputLine(String.format(manager.res.getString(R.string.host_fingerprint),\n\t\t\t\t\t\talgorithmName, fingerprint));\n\n\t\t\t\t// Users have no way to delete keys, so we'll prompt them for now.\n\t\t\t\tresult = bridge.promptHelper.requestBooleanPrompt(null, manager.res.getString(R.string.prompt_continue_connecting));\n\t\t\t\tif(result == null) return false;\n\t\t\t\tif(result.booleanValue()) {\n\t\t\t\t\t// save this key in known database\n\t\t\t\t\tmanager.hostdb.saveKnownHost(hostname, port, serverHostKeyAlgorithm, serverHostKey);\n\t\t\t\t}\n\t\t\t\treturn result.booleanValue();\n\n\t\t\t\tdefault:\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t}\n\n\tprivate void authenticate() {\n\t\ttry {\n\t\t\tif (connection.authenticateWithNone(host.getUsername())) {\n\t\t\t\tfinishConnection();\n\t\t\t\treturn;\n\t\t\t}\n\t\t} catch(Exception e) {\n\t\t\tLog.d(TAG, \"Host does not support 'none' authentication.\");\n\t\t}\n\n\t\tbridge.outputLine(manager.res.getString(R.string.terminal_auth));\n\n\t\ttry {\n\t\t\tlong pubkeyId = host.getPubkeyId();\n\n\t\t\tif (!pubkeysExhausted &&\n\t\t\t\t\tpubkeyId != HostDatabase.PUBKEYID_NEVER &&\n\t\t\t\t\tconnection.isAuthMethodAvailable(host.getUsername(), AUTH_PUBLICKEY)) {\n\n\t\t\t\t// if explicit pubkey defined for this host, then prompt for password as needed\n\t\t\t\t// otherwise just try all in-memory keys held in terminalmanager\n\n\t\t\t\tif (pubkeyId == HostDatabase.PUBKEYID_ANY) {\n\t\t\t\t\t// try each of the in-memory keys\n\t\t\t\t\tbridge.outputLine(manager.res\n\t\t\t\t\t\t\t.getString(R.string.terminal_auth_pubkey_any));\n\t\t\t\t\tfor (Entry<String, KeyHolder> entry : manager.loadedKeypairs.entrySet()) {\n\t\t\t\t\t\tif (entry.getValue().bean.isConfirmUse()\n\t\t\t\t\t\t\t\t&& !promptForPubkeyUse(entry.getKey()))\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tif (this.tryPublicKey(host.getUsername(), entry.getKey(),\n\t\t\t\t\t\t\t\tentry.getValue().pair)) {\n\t\t\t\t\t\t\tfinishConnection();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbridge.outputLine(manager.res.getString(R.string.terminal_auth_pubkey_specific));\n\t\t\t\t\t// use a specific key for this host, as requested\n\t\t\t\t\tPubkeyBean pubkey = manager.pubkeydb.findPubkeyById(pubkeyId);\n\n\t\t\t\t\tif (pubkey == null)\n\t\t\t\t\t\tbridge.outputLine(manager.res.getString(R.string.terminal_auth_pubkey_invalid));\n\t\t\t\t\telse\n\t\t\t\t\t\tif (tryPublicKey(pubkey))\n\t\t\t\t\t\t\tfinishConnection();\n\t\t\t\t}\n\n\t\t\t\tpubkeysExhausted = true;\n\t\t\t} else if (interactiveCanContinue &&\n\t\t\t\t\tconnection.isAuthMethodAvailable(host.getUsername(), AUTH_KEYBOARDINTERACTIVE)) {\n\t\t\t\t// this auth method will talk with us using InteractiveCallback interface\n\t\t\t\t// it blocks until authentication finishes\n\t\t\t\tbridge.outputLine(manager.res.getString(R.string.terminal_auth_ki));\n\t\t\t\tinteractiveCanContinue = false;\n\t\t\t\tif(connection.authenticateWithKeyboardInteractive(host.getUsername(), this)) {\n\t\t\t\t\tfinishConnection();\n\t\t\t\t} else {\n\t\t\t\t\tbridge.outputLine(manager.res.getString(R.string.terminal_auth_ki_fail));\n\t\t\t\t}\n\t\t\t} else if (connection.isAuthMethodAvailable(host.getUsername(), AUTH_PASSWORD)) {\n\t\t\t\tbridge.outputLine(manager.res.getString(R.string.terminal_auth_pass));\n\t\t\t\tString password = bridge.getPromptHelper().requestStringPrompt(null,\n\t\t\t\t\t\tmanager.res.getString(R.string.prompt_password));\n\t\t\t\tif (password != null\n\t\t\t\t\t\t&& connection.authenticateWithPassword(host.getUsername(), password)) {\n\t\t\t\t\tfinishConnection();\n\t\t\t\t} else {\n\t\t\t\t\tbridge.outputLine(manager.res.getString(R.string.terminal_auth_pass_fail));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbridge.outputLine(manager.res.getString(R.string.terminal_auth_fail));\n\t\t\t}\n\t\t} catch (IllegalStateException e) {\n\t\t\tLog.e(TAG, \"Connection went away while we were trying to authenticate\", e);\n\t\t\treturn;\n\t\t} catch(Exception e) {\n\t\t\tLog.e(TAG, \"Problem during handleAuthentication()\", e);\n\t\t}\n\t}\n\n\t/**\n\t * Attempt connection with database row pointed to by cursor.\n\t * @param cursor\n\t * @return true for successful authentication\n\t * @throws NoSuchAlgorithmException\n\t * @throws InvalidKeySpecException\n\t * @throws IOException\n\t */\n\tprivate boolean tryPublicKey(PubkeyBean pubkey) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException {\n\t\tKeyPair pair = null;\n\n\t\tif(manager.isKeyLoaded(pubkey.getNickname())) {\n\t\t\t// load this key from memory if its already there\n\t\t\tLog.d(TAG, String.format(\"Found unlocked key '%s' already in-memory\", pubkey.getNickname()));\n\n\t\t\tif (pubkey.isConfirmUse()) {\n\t\t\t\tif (!promptForPubkeyUse(pubkey.getNickname()))\n\t\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tpair = manager.getKey(pubkey.getNickname());\n\t\t} else {\n\t\t\t// otherwise load key from database and prompt for password as needed\n\t\t\tString password = null;\n\t\t\tif (pubkey.isEncrypted()) {\n\t\t\t\tpassword = bridge.getPromptHelper().requestStringPrompt(null,\n\t\t\t\t\t\tmanager.res.getString(R.string.prompt_pubkey_password, pubkey.getNickname()));\n\n\t\t\t\t// Something must have interrupted the prompt.\n\t\t\t\tif (password == null)\n\t\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif(PubkeyDatabase.KEY_TYPE_IMPORTED.equals(pubkey.getType())) {\n\t\t\t\t// load specific key using pem format\n\t\t\t\tpair = PEMDecoder.decode(new String(pubkey.getPrivateKey()).toCharArray(), password);\n\t\t\t} else {\n\t\t\t\t// load using internal generated format\n\t\t\t\tPrivateKey privKey;\n\t\t\t\ttry {\n\t\t\t\t\tprivKey = PubkeyUtils.decodePrivate(pubkey.getPrivateKey(),\n\t\t\t\t\t\t\tpubkey.getType(), password);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tString message = String.format(\"Bad password for key '%s'. Authentication failed.\", pubkey.getNickname());\n\t\t\t\t\tLog.e(TAG, message, e);\n\t\t\t\t\tbridge.outputLine(message);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tPublicKey pubKey = PubkeyUtils.decodePublic(pubkey.getPublicKey(), pubkey.getType());\n\n\t\t\t\t// convert key to trilead format\n\t\t\t\tpair = new KeyPair(pubKey, privKey);\n\t\t\t\tLog.d(TAG, \"Unlocked key \" + PubkeyUtils.formatKey(pubKey));\n\t\t\t}\n\n\t\t\tLog.d(TAG, String.format(\"Unlocked key '%s'\", pubkey.getNickname()));\n\n\t\t\t// save this key in memory\n\t\t\tmanager.addKey(pubkey, pair);\n\t\t}\n\n\t\treturn tryPublicKey(host.getUsername(), pubkey.getNickname(), pair);\n\t}\n\n\tprivate boolean tryPublicKey(String username, String keyNickname, KeyPair pair) throws IOException {\n\t\t//bridge.outputLine(String.format(\"Attempting 'publickey' with key '%s' [%s]...\", keyNickname, trileadKey.toString()));\n\t\tboolean success = connection.authenticateWithPublicKey(username, pair);\n\t\tif(!success)\n\t\t\tbridge.outputLine(manager.res.getString(R.string.terminal_auth_pubkey_fail, keyNickname));\n\t\treturn success;\n\t}\n\n\t/**\n\t * Internal method to request actual PTY terminal once we've finished\n\t * authentication. If called before authenticated, it will just fail.\n\t */\n\tprivate void finishConnection() {\n\t\tauthenticated = true;\n\n\t\tfor (PortForwardBean portForward : portForwards) {\n\t\t\ttry {\n\t\t\t\tenablePortForward(portForward);\n\t\t\t\tbridge.outputLine(manager.res.getString(R.string.terminal_enable_portfoward, portForward.getDescription()));\n\t\t\t} catch (Exception e) {\n\t\t\t\tLog.e(TAG, \"Error setting up port forward during connect\", e);\n\t\t\t}\n\t\t}\n\n\t\tif (!host.getWantSession()) {\n\t\t\tbridge.outputLine(manager.res.getString(R.string.terminal_no_session));\n\t\t\tbridge.onConnected();\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tsession = connection.openSession();\n\n\t\t\tif (!useAuthAgent.equals(HostDatabase.AUTHAGENT_NO))\n\t\t\t\tsession.requestAuthAgentForwarding(this);\n\n\t\t\tsession.requestPTY(getEmulation(), columns, rows, width, height, null);\n\t\t\tsession.startShell();\n\n\t\t\tstdin = session.getStdin();\n\t\t\tstdout = session.getStdout();\n\t\t\tstderr = session.getStderr();\n\n\t\t\tsessionOpen = true;\n\n\t\t\tbridge.onConnected();\n\t\t} catch (IOException e1) {\n\t\t\tLog.e(TAG, \"Problem while trying to create PTY in finishConnection()\", e1);\n\t\t}\n\n\t}\n\n\t@Override\n\tpublic void connect() {\n\t\tconnection = new Connection(host.getHostname(), host.getPort());\n\t\tconnection.addConnectionMonitor(this);\n\n\t\ttry {\n\t\t\tconnection.setCompression(compression);\n\t\t} catch (IOException e) {\n\t\t\tLog.e(TAG, \"Could not enable compression!\", e);\n\t\t}\n\n\t\ttry {\n\t\t\t/* Uncomment when debugging SSH protocol:\n\t\t\tDebugLogger logger = new DebugLogger() {\n\n\t\t\t\tpublic void log(int level, String className, String message) {\n\t\t\t\t\tLog.d(\"SSH\", message);\n\t\t\t\t}\n\n\t\t\t};\n\t\t\tLogger.enabled = true;\n\t\t\tLogger.logger = logger;\n\t\t\t*/\n\t\t\tconnectionInfo = connection.connect(new HostKeyVerifier());\n\t\t\tconnected = true;\n\n\t\t\tif (connectionInfo.clientToServerCryptoAlgorithm\n\t\t\t\t\t.equals(connectionInfo.serverToClientCryptoAlgorithm)\n\t\t\t\t\t&& connectionInfo.clientToServerMACAlgorithm\n\t\t\t\t\t\t\t.equals(connectionInfo.serverToClientMACAlgorithm)) {\n\t\t\t\tbridge.outputLine(manager.res.getString(R.string.terminal_using_algorithm,\n\t\t\t\t\t\tconnectionInfo.clientToServerCryptoAlgorithm,\n\t\t\t\t\t\tconnectionInfo.clientToServerMACAlgorithm));\n\t\t\t} else {\n\t\t\t\tbridge.outputLine(manager.res.getString(\n\t\t\t\t\t\tR.string.terminal_using_c2s_algorithm,\n\t\t\t\t\t\tconnectionInfo.clientToServerCryptoAlgorithm,\n\t\t\t\t\t\tconnectionInfo.clientToServerMACAlgorithm));\n\n\t\t\t\tbridge.outputLine(manager.res.getString(\n\t\t\t\t\t\tR.string.terminal_using_s2c_algorithm,\n\t\t\t\t\t\tconnectionInfo.serverToClientCryptoAlgorithm,\n\t\t\t\t\t\tconnectionInfo.serverToClientMACAlgorithm));\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tLog.e(TAG, \"Problem in SSH connection thread during authentication\", e);\n\n\t\t\t// Display the reason in the text.\n\t\t\tThrowable t = e.getCause();\n\t\t\tdo {\n\t\t\t\tbridge.outputLine(t.getMessage());\n\t\t\t\tt = t.getCause();\n\t\t\t} while (t != null);\n\n\t\t\tclose();\n\t\t\tonDisconnect();\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\t// enter a loop to keep trying until authentication\n\t\t\tint tries = 0;\n\t\t\twhile (connected && !connection.isAuthenticationComplete() && tries++ < AUTH_TRIES) {\n\t\t\t\tauthenticate();\n\n\t\t\t\t// sleep to make sure we dont kill system\n\t\t\t\tThread.sleep(1000);\n\t\t\t}\n\t\t} catch(Exception e) {\n\t\t\tLog.e(TAG, \"Problem in SSH connection thread during authentication\", e);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void close() {\n\t\tconnected = false;\n\n\t\tif (session != null) {\n\t\t\tsession.close();\n\t\t\tsession = null;\n\t\t}\n\n\t\tif (connection != null) {\n\t\t\tconnection.close();\n\t\t\tconnection = null;\n\t\t}\n\t}\n\n\tprivate void onDisconnect() {\n\t\tbridge.dispatchDisconnect(false);\n\t}\n\n\t@Override\n\tpublic void flush() throws IOException {\n\t\tif (stdin != null)\n\t\t\tstdin.flush();\n\t}\n\n\t@Override\n\tpublic int read(byte[] buffer, int start, int len) throws IOException {\n\t\tint bytesRead = 0;\n\n\t\tif (session == null)\n\t\t\treturn 0;\n\n\t\tint newConditions = session.waitForCondition(conditions, 0);\n\n\t\tif ((newConditions & ChannelCondition.STDOUT_DATA) != 0) {\n\t\t\tbytesRead = stdout.read(buffer, start, len);\n\t\t}\n\n\t\tif ((newConditions & ChannelCondition.STDERR_DATA) != 0) {\n\t\t\tbyte discard[] = new byte[256];\n\t\t\twhile (stderr.available() > 0) {\n\t\t\t\tstderr.read(discard);\n\t\t\t}\n\t\t}\n\n\t\tif ((newConditions & ChannelCondition.EOF) != 0) {\n\t\t\tclose();\n\t\t\tonDisconnect();\n\t\t\tthrow new IOException(\"Remote end closed connection\");\n\t\t}\n\n\t\treturn bytesRead;\n\t}\n\n\t@Override\n\tpublic void write(byte[] buffer) throws IOException {\n\t\tif (stdin != null)\n\t\t\tstdin.write(buffer);\n\t}\n\n\t@Override\n\tpublic void write(int c) throws IOException {\n\t\tif (stdin != null)\n\t\t\tstdin.write(c);\n\t}\n\n\t@Override\n\tpublic Map<String, String> getOptions() {\n\t\tMap<String, String> options = new HashMap<String, String>();\n\n\t\toptions.put(\"compression\", Boolean.toString(compression));\n\n\t\treturn options;\n\t}\n\n\t@Override\n\tpublic void setOptions(Map<String, String> options) {\n\t\tif (options.containsKey(\"compression\"))\n\t\t\tcompression = Boolean.parseBoolean(options.get(\"compression\"));\n\t}\n\n\tpublic static String getProtocolName() {\n\t\treturn PROTOCOL;\n\t}\n\n\t@Override\n\tpublic boolean isSessionOpen() {\n\t\treturn sessionOpen;\n\t}\n\n\t@Override\n\tpublic boolean isConnected() {\n\t\treturn connected;\n\t}\n\n\tpublic void connectionLost(Throwable reason) {\n\t\tonDisconnect();\n\t}\n\n\t@Override\n\tpublic boolean canForwardPorts() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic List<PortForwardBean> getPortForwards() {\n\t\treturn portForwards;\n\t}\n\n\t@Override\n\tpublic boolean addPortForward(PortForwardBean portForward) {\n\t\treturn portForwards.add(portForward);\n\t}\n\n\t@Override\n\tpublic boolean removePortForward(PortForwardBean portForward) {\n\t\t// Make sure we don't have a phantom forwarder.\n\t\tdisablePortForward(portForward);\n\n\t\treturn portForwards.remove(portForward);\n\t}\n\n\t@Override\n\tpublic boolean enablePortForward(PortForwardBean portForward) {\n\t\tif (!portForwards.contains(portForward)) {\n\t\t\tLog.e(TAG, \"Attempt to enable port forward not in list\");\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!authenticated)\n\t\t\treturn false;\n\n\t\tif (HostDatabase.PORTFORWARD_LOCAL.equals(portForward.getType())) {\n\t\t\tLocalPortForwarder lpf = null;\n\t\t\ttry {\n\t\t\t\tlpf = connection.createLocalPortForwarder(\n\t\t\t\t\t\tnew InetSocketAddress(InetAddress.getLocalHost(), portForward.getSourcePort()),\n\t\t\t\t\t\tportForward.getDestAddr(), portForward.getDestPort());\n\t\t\t} catch (Exception e) {\n\t\t\t\tLog.e(TAG, \"Could not create local port forward\", e);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (lpf == null) {\n\t\t\t\tLog.e(TAG, \"returned LocalPortForwarder object is null\");\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tportForward.setIdentifier(lpf);\n\t\t\tportForward.setEnabled(true);\n\t\t\treturn true;\n\t\t} else if (HostDatabase.PORTFORWARD_REMOTE.equals(portForward.getType())) {\n\t\t\ttry {\n\t\t\t\tconnection.requestRemotePortForwarding(\"\", portForward.getSourcePort(), portForward.getDestAddr(), portForward.getDestPort());\n\t\t\t} catch (Exception e) {\n\t\t\t\tLog.e(TAG, \"Could not create remote port forward\", e);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tportForward.setEnabled(true);\n\t\t\treturn true;\n\t\t} else if (HostDatabase.PORTFORWARD_DYNAMIC5.equals(portForward.getType())) {\n\t\t\tDynamicPortForwarder dpf = null;\n\n\t\t\ttry {\n\t\t\t\tdpf = connection.createDynamicPortForwarder(\n\t\t\t\t\t\tnew InetSocketAddress(InetAddress.getLocalHost(), portForward.getSourcePort()));\n\t\t\t} catch (Exception e) {\n\t\t\t\tLog.e(TAG, \"Could not create dynamic port forward\", e);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tportForward.setIdentifier(dpf);\n\t\t\tportForward.setEnabled(true);\n\t\t\treturn true;\n\t\t} else {\n\t\t\t// Unsupported type\n\t\t\tLog.e(TAG, String.format(\"attempt to forward unknown type %s\", portForward.getType()));\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean disablePortForward(PortForwardBean portForward) {\n\t\tif (!portForwards.contains(portForward)) {\n\t\t\tLog.e(TAG, \"Attempt to disable port forward not in list\");\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!authenticated)\n\t\t\treturn false;\n\n\t\tif (HostDatabase.PORTFORWARD_LOCAL.equals(portForward.getType())) {\n\t\t\tLocalPortForwarder lpf = null;\n\t\t\tlpf = (LocalPortForwarder)portForward.getIdentifier();\n\n\t\t\tif (!portForward.isEnabled() || lpf == null) {\n\t\t\t\tLog.d(TAG, String.format(\"Could not disable %s; it appears to be not enabled or have no handler\", portForward.getNickname()));\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tportForward.setEnabled(false);\n\n\t\t\ttry {\n\t\t\t\tlpf.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\tLog.e(TAG, \"Could not stop local port forwarder, setting enabled to false\", e);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t} else if (HostDatabase.PORTFORWARD_REMOTE.equals(portForward.getType())) {\n\t\t\tportForward.setEnabled(false);\n\n\t\t\ttry {\n\t\t\t\tconnection.cancelRemotePortForwarding(portForward.getSourcePort());\n\t\t\t} catch (IOException e) {\n\t\t\t\tLog.e(TAG, \"Could not stop remote port forwarding, setting enabled to false\", e);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t} else if (HostDatabase.PORTFORWARD_DYNAMIC5.equals(portForward.getType())) {\n\t\t\tDynamicPortForwarder dpf = null;\n\t\t\tdpf = (DynamicPortForwarder)portForward.getIdentifier();\n\n\t\t\tif (!portForward.isEnabled() || dpf == null) {\n\t\t\t\tLog.d(TAG, String.format(\"Could not disable %s; it appears to be not enabled or have no handler\", portForward.getNickname()));\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tportForward.setEnabled(false);\n\n\t\t\ttry {\n\t\t\t\tdpf.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\tLog.e(TAG, \"Could not stop dynamic port forwarder, setting enabled to false\", e);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t} else {\n\t\t\t// Unsupported type\n\t\t\tLog.e(TAG, String.format(\"attempt to forward unknown type %s\", portForward.getType()));\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t@Override\n\tpublic void setDimensions(int columns, int rows, int width, int height) {\n\t\tthis.columns = columns;\n\t\tthis.rows = rows;\n\n\t\tif (sessionOpen) {\n\t\t\ttry {\n\t\t\t\tsession.resizePTY(columns, rows, width, height);\n\t\t\t} catch (IOException e) {\n\t\t\t\tLog.e(TAG, \"Couldn't send resize PTY packet\", e);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic int getDefaultPort() {\n\t\treturn DEFAULT_PORT;\n\t}\n\n\t@Override\n\tpublic String getDefaultNickname(String username, String hostname, int port) {\n\t\tif (port == DEFAULT_PORT) {\n\t\t\treturn String.format(Locale.US, \"%s@%s\", username, hostname);\n\t\t} else {\n\t\t\treturn String.format(Locale.US, \"%s@%s:%d\", username, hostname, port);\n\t\t}\n\t}\n\n\tpublic static Uri getUri(String input) {\n\t\tMatcher matcher = hostmask.matcher(input);\n\n\t\tif (!matcher.matches())\n\t\t\treturn null;\n\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tsb.append(PROTOCOL)\n\t\t\t.append(\"://\")\n\t\t\t.append(Uri.encode(matcher.group(1)))\n\t\t\t.append('@')\n\t\t\t.append(matcher.group(2));\n\n\t\tString portString = matcher.group(4);\n\t\tint port = DEFAULT_PORT;\n\t\tif (portString != null) {\n\t\t\ttry {\n\t\t\t\tport = Integer.parseInt(portString);\n\t\t\t\tif (port < 1 || port > 65535) {\n\t\t\t\t\tport = DEFAULT_PORT;\n\t\t\t\t}\n\t\t\t} catch (NumberFormatException nfe) {\n\t\t\t\t// Keep the default port\n\t\t\t}\n\t\t}\n\n\t\tif (port != DEFAULT_PORT) {\n\t\t\tsb.append(':')\n\t\t\t\t.append(port);\n\t\t}\n\n\t\tsb.append(\"/#\")\n\t\t\t.append(Uri.encode(input));\n\n\t\tUri uri = Uri.parse(sb.toString());\n\n\t\treturn uri;\n\t}\n\n\t/**\n\t * Handle challenges from keyboard-interactive authentication mode.\n\t */\n\tpublic String[] replyToChallenge(String name, String instruction, int numPrompts, String[] prompt, boolean[] echo) {\n\t\tinteractiveCanContinue = true;\n\t\tString[] responses = new String[numPrompts];\n\t\tfor(int i = 0; i < numPrompts; i++) {\n\t\t\t// request response from user for each prompt\n\t\t\tresponses[i] = bridge.promptHelper.requestStringPrompt(instruction, prompt[i]);\n\t\t}\n\t\treturn responses;\n\t}\n\n\t@Override\n\tpublic HostBean createHost(Uri uri) {\n\t\tHostBean host = new HostBean();\n\n\t\thost.setProtocol(PROTOCOL);\n\n\t\thost.setHostname(uri.getHost());\n\n\t\tint port = uri.getPort();\n\t\tif (port < 0)\n\t\t\tport = DEFAULT_PORT;\n\t\thost.setPort(port);\n\n\t\thost.setUsername(uri.getUserInfo());\n\n\t\tString nickname = uri.getFragment();\n\t\tif (nickname == null || nickname.length() == 0) {\n\t\t\thost.setNickname(getDefaultNickname(host.getUsername(),\n\t\t\t\t\thost.getHostname(), host.getPort()));\n\t\t} else {\n\t\t\thost.setNickname(uri.getFragment());\n\t\t}\n\n\t\treturn host;\n\t}\n\n\t@Override\n\tpublic void getSelectionArgs(Uri uri, Map<String, String> selection) {\n\t\tselection.put(HostDatabase.FIELD_HOST_PROTOCOL, PROTOCOL);\n\t\tselection.put(HostDatabase.FIELD_HOST_NICKNAME, uri.getFragment());\n\t\tselection.put(HostDatabase.FIELD_HOST_HOSTNAME, uri.getHost());\n\n\t\tint port = uri.getPort();\n\t\tif (port < 0)\n\t\t\tport = DEFAULT_PORT;\n\t\tselection.put(HostDatabase.FIELD_HOST_PORT, Integer.toString(port));\n\t\tselection.put(HostDatabase.FIELD_HOST_USERNAME, uri.getUserInfo());\n\t}\n\n\t@Override\n\tpublic void setCompression(boolean compression) {\n\t\tthis.compression = compression;\n\t}\n\n\tpublic static String getFormatHint(Context context) {\n\t\treturn String.format(\"%s@%s:%s\",\n\t\t\t\tcontext.getString(R.string.format_username),\n\t\t\t\tcontext.getString(R.string.format_hostname),\n\t\t\t\tcontext.getString(R.string.format_port));\n\t}\n\n\t@Override\n\tpublic void setUseAuthAgent(String useAuthAgent) {\n\t\tthis.useAuthAgent = useAuthAgent;\n\t}\n\n\tpublic Map<String,byte[]> retrieveIdentities() {\n\t\tMap<String,byte[]> pubKeys = new HashMap<String,byte[]>(manager.loadedKeypairs.size());\n\n\t\tfor (Entry<String,KeyHolder> entry : manager.loadedKeypairs.entrySet()) {\n\t\t\tKeyPair pair = entry.getValue().pair;\n\n\t\t\ttry {\n\t\t\t\tPrivateKey privKey = pair.getPrivate();\n\t\t\t\tif (privKey instanceof RSAPrivateKey) {\n\t\t\t\t\tRSAPublicKey pubkey = (RSAPublicKey) pair.getPublic();\n\t\t\t\t\tpubKeys.put(entry.getKey(), RSASHA1Verify.encodeSSHRSAPublicKey(pubkey));\n\t\t\t\t} else if (privKey instanceof DSAPrivateKey) {\n\t\t\t\t\tDSAPublicKey pubkey = (DSAPublicKey) pair.getPublic();\n\t\t\t\t\tpubKeys.put(entry.getKey(), DSASHA1Verify.encodeSSHDSAPublicKey(pubkey));\n\t\t\t\t} else\n\t\t\t\t\tcontinue;\n\t\t\t} catch (IOException e) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\treturn pubKeys;\n\t}\n\n\tpublic KeyPair getKeyPair(byte[] publicKey) {\n\t\tString nickname = manager.getKeyNickname(publicKey);\n\n\t\tif (nickname == null)\n\t\t\treturn null;\n\n\t\tif (useAuthAgent.equals(HostDatabase.AUTHAGENT_NO)) {\n\t\t\tLog.e(TAG, \"\");\n\t\t\treturn null;\n\t\t} else if (useAuthAgent.equals(HostDatabase.AUTHAGENT_CONFIRM) ||\n\t\t\t\tmanager.loadedKeypairs.get(nickname).bean.isConfirmUse()) {\n\t\t\tif (!promptForPubkeyUse(nickname))\n\t\t\t\treturn null;\n\t\t}\n\t\treturn manager.getKey(nickname);\n\t}\n\n\tprivate boolean promptForPubkeyUse(String nickname) {\n\t\tBoolean result = bridge.promptHelper.requestBooleanPrompt(null,\n\t\t\t\tmanager.res.getString(R.string.prompt_allow_agent_to_use_key,\n\t\t\t\t\t\tnickname));\n\t\treturn result;\n\t}\n\n\tpublic boolean addIdentity(KeyPair pair, String comment, boolean confirmUse, int lifetime) {\n\t\tPubkeyBean pubkey = new PubkeyBean();\n//\t\tpubkey.setType(PubkeyDatabase.KEY_TYPE_IMPORTED);\n\t\tpubkey.setNickname(comment);\n\t\tpubkey.setConfirmUse(confirmUse);\n\t\tpubkey.setLifetime(lifetime);\n\t\tmanager.addKey(pubkey, pair);\n\t\treturn true;\n\t}\n\n\tpublic boolean removeAllIdentities() {\n\t\tmanager.loadedKeypairs.clear();\n\t\treturn true;\n\t}\n\n\tpublic boolean removeIdentity(byte[] publicKey) {\n\t\treturn manager.removeKey(publicKey);\n\t}\n\n\tpublic boolean isAgentLocked() {\n\t\treturn agentLockPassphrase != null;\n\t}\n\n\tpublic boolean requestAgentUnlock(String unlockPassphrase) {\n\t\tif (agentLockPassphrase == null)\n\t\t\treturn false;\n\n\t\tif (agentLockPassphrase.equals(unlockPassphrase))\n\t\t\tagentLockPassphrase = null;\n\n\t\treturn agentLockPassphrase == null;\n\t}\n\n\tpublic boolean setAgentLock(String lockPassphrase) {\n\t\tif (agentLockPassphrase != null)\n\t\t\treturn false;\n\n\t\tagentLockPassphrase = lockPassphrase;\n\t\treturn true;\n\t}\n\n\t/* (non-Javadoc)\n\t * @see org.connectbot.transport.AbsTransport#usesNetwork()\n\t */\n\t@Override\n\tpublic boolean usesNetwork() {\n\t\treturn true;\n\t}\n}\n","lineNo":457}
{"Smelly Sample":"/*\n * ConnectBot: simple, powerful, open-source SSH client for Android\n * Copyright 2007 Kenny Root, Jeffrey Sharkey\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.connectbot.service;\n\nimport java.io.IOException;\nimport java.nio.charset.Charset;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.connectbot.R;\nimport org.connectbot.TerminalView;\nimport org.connectbot.bean.HostBean;\nimport org.connectbot.bean.PortForwardBean;\nimport org.connectbot.bean.SelectionArea;\nimport org.connectbot.transport.AbsTransport;\nimport org.connectbot.transport.TransportFactory;\nimport org.connectbot.util.HostDatabase;\n\nimport android.content.Context;\nimport android.graphics.Bitmap;\nimport android.graphics.Bitmap.Config;\nimport android.graphics.Canvas;\nimport android.graphics.Color;\nimport android.graphics.Paint;\nimport android.graphics.Paint.FontMetrics;\nimport android.graphics.Typeface;\nimport android.text.ClipboardManager;\nimport android.util.Log;\nimport de.mud.terminal.VDUBuffer;\nimport de.mud.terminal.VDUDisplay;\nimport de.mud.terminal.vt320;\n\n\n/**\n * Provides a bridge between a MUD terminal buffer and a possible TerminalView.\n * This separation allows us to keep the TerminalBridge running in a background\n * service. A TerminalView shares down a bitmap that we can use for rendering\n * when available.\n *\n * This class also provides SSH hostkey verification prompting, and password\n * prompting.\n */\n@SuppressWarnings(\"deprecation\") // for ClipboardManager\npublic class TerminalBridge implements VDUDisplay {\n\tpublic final static String TAG = \"ConnectBot.TerminalBridge\";\n\n\tpublic final static int DEFAULT_FONT_SIZE = 10;\n\tprivate final static int FONT_SIZE_STEP = 2;\n\n\tpublic Integer[] color;\n\n\tpublic int defaultFg = HostDatabase.DEFAULT_FG_COLOR;\n\tpublic int defaultBg = HostDatabase.DEFAULT_BG_COLOR;\n\n\tprotected final TerminalManager manager;\n\n\tpublic HostBean host;\n\n\t/* package */ AbsTransport transport;\n\n\tfinal Paint defaultPaint;\n\n\tprivate Relay relay;\n\n\tprivate final String emulation;\n\tprivate final int scrollback;\n\n\tpublic Bitmap bitmap = null;\n\tpublic VDUBuffer buffer = null;\n\n\tprivate TerminalView parent = null;\n\tprivate final Canvas canvas = new Canvas();\n\n\tprivate boolean disconnected = false;\n\tprivate boolean awaitingClose = false;\n\n\tprivate boolean forcedSize = false;\n\tprivate int columns;\n\tprivate int rows;\n\n\t/* package */ final TerminalKeyListener keyListener;\n\n\tprivate boolean selectingForCopy = false;\n\tprivate final SelectionArea selectionArea;\n\n\t// TODO add support for the new clipboard API\n\tprivate ClipboardManager clipboard;\n\n\tpublic int charWidth = -1;\n\tpublic int charHeight = -1;\n\tprivate int charTop = -1;\n\n\tprivate float fontSize = -1;\n\n\tprivate final List<FontSizeChangedListener> fontSizeChangedListeners;\n\n\tprivate final List<String> localOutput;\n\n\t/**\n\t * Flag indicating if we should perform a full-screen redraw during our next\n\t * rendering pass.\n\t */\n\tprivate boolean fullRedraw = false;\n\n\tpublic PromptHelper promptHelper;\n\n\tprotected BridgeDisconnectedListener disconnectListener = null;\n\n\t/**\n\t * Create a new terminal bridge suitable for unit testing.\n\t */\n\tpublic TerminalBridge() {\n\t\tbuffer = new vt320() {\n\t\t\t@Override\n\t\t\tpublic void write(byte[] b) {}\n\t\t\t@Override\n\t\t\tpublic void write(int b) {}\n\t\t\t@Override\n\t\t\tpublic void sendTelnetCommand(byte cmd) {}\n\t\t\t@Override\n\t\t\tpublic void setWindowSize(int c, int r) {}\n\t\t\t@Override\n\t\t\tpublic void debug(String s) {}\n\t\t};\n\n\t\temulation = null;\n\t\tmanager = null;\n\n\t\tdefaultPaint = new Paint();\n\n\t\tselectionArea = new SelectionArea();\n\t\tscrollback = 1;\n\n\t\tlocalOutput = new LinkedList<String>();\n\n\t\tfontSizeChangedListeners = new LinkedList<FontSizeChangedListener>();\n\n\t\ttransport = null;\n\n\t\tkeyListener = new TerminalKeyListener(manager, this, buffer, null);\n\t}\n\n\t/**\n\t * Create new terminal bridge with following parameters. We will immediately\n\t * launch thread to start SSH connection and handle any hostkey verification\n\t * and password authentication.\n\t */\n\tpublic TerminalBridge(final TerminalManager manager, final HostBean host) throws IOException {\n\t\tthis.manager = manager;\n\t\tthis.host = host;\n\n\t\temulation = manager.getEmulation();\n\t\tscrollback = manager.getScrollback();\n\n\t\t// create prompt helper to relay password and hostkey requests up to gui\n\t\tpromptHelper = new PromptHelper(this);\n\n\t\t// create our default paint\n\t\tdefaultPaint = new Paint();\n\t\tdefaultPaint.setAntiAlias(true);\n\t\tdefaultPaint.setTypeface(Typeface.MONOSPACE);\n\t\tdefaultPaint.setFakeBoldText(true); // more readable?\n\n\t\tlocalOutput = new LinkedList<String>();\n\n\t\tfontSizeChangedListeners = new LinkedList<FontSizeChangedListener>();\n\n\t\tint hostFontSize = host.getFontSize();\n\t\tif (hostFontSize <= 0)\n\t\t\thostFontSize = DEFAULT_FONT_SIZE;\n\t\tsetFontSize(hostFontSize);\n\n\t\t// create terminal buffer and handle outgoing data\n\t\t// this is probably status reply information\n\t\tbuffer = new vt320() {\n\t\t\t@Override\n\t\t\tpublic void debug(String s) {\n\t\t\t\tLog.d(TAG, s);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void write(byte[] b) {\n\t\t\t\ttry {\n\t\t\t\t\tif (b != null && transport != null)\n\t\t\t\t\t\ttransport.write(b);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tLog.e(TAG, \"Problem writing outgoing data in vt320() thread\", e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void write(int b) {\n\t\t\t\ttry {\n\t\t\t\t\tif (transport != null)\n\t\t\t\t\t\ttransport.write(b);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tLog.e(TAG, \"Problem writing outgoing data in vt320() thread\", e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// We don't use telnet sequences.\n\t\t\t@Override\n\t\t\tpublic void sendTelnetCommand(byte cmd) {\n\t\t\t}\n\n\t\t\t// We don't want remote to resize our window.\n\t\t\t@Override\n\t\t\tpublic void setWindowSize(int c, int r) {\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void beep() {\n\t\t\t\tif (parent.isShown())\n\t\t\t\t\tmanager.playBeep();\n\t\t\t\telse\n\t\t\t\t\tmanager.sendActivityNotification(host);\n\t\t\t}\n\t\t};\n\n\t\t// Don't keep any scrollback if a session is not being opened.\n\t\tif (host.getWantSession())\n\t\t\tbuffer.setBufferSize(scrollback);\n\t\telse\n\t\t\tbuffer.setBufferSize(0);\n\n\t\tresetColors();\n\t\tbuffer.setDisplay(this);\n\n\t\tselectionArea = new SelectionArea();\n\n\t\tkeyListener = new TerminalKeyListener(manager, this, buffer, host.getEncoding());\n\t}\n\n\tpublic PromptHelper getPromptHelper() {\n\t\treturn promptHelper;\n\t}\n\n\t/**\n\t * Spawn thread to open connection and start login process.\n\t */\n\tprotected void startConnection() {\n\t\ttransport = TransportFactory.getTransport(host.getProtocol());\n\t\ttransport.setBridge(this);\n\t\ttransport.setManager(manager);\n\t\ttransport.setHost(host);\n\n\t\t// TODO make this more abstract so we don't litter on AbsTransport\n\t\ttransport.setCompression(host.getCompression());\n\t\ttransport.setUseAuthAgent(host.getUseAuthAgent());\n\t\ttransport.setEmulation(emulation);\n\n\t\tif (transport.canForwardPorts()) {\n\t\t\tfor (PortForwardBean portForward : manager.hostdb.getPortForwardsForHost(host))\n\t\t\t\ttransport.addPortForward(portForward);\n\t\t}\n\n\t\toutputLine(manager.res.getString(R.string.terminal_connecting, host.getHostname(), host.getPort(), host.getProtocol()));\n\n\t\tThread connectionThread = new Thread(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\ttransport.connect();\n\t\t\t}\n\t\t});\n\t\tconnectionThread.setName(\"Connection\");\n\t\tconnectionThread.setDaemon(true);\n\t\tconnectionThread.start();\n\t}\n\n\t/**\n\t * Handle challenges from keyboard-interactive authentication mode.\n\t */\n\tpublic String[] replyToChallenge(String name, String instruction, int numPrompts, String[] prompt, boolean[] echo) {\n\t\tString[] responses = new String[numPrompts];\n\t\tfor(int i = 0; i < numPrompts; i++) {\n\t\t\t// request response from user for each prompt\n\t\t\tresponses[i] = promptHelper.requestStringPrompt(instruction, prompt[i]);\n\t\t}\n\t\treturn responses;\n\t}\n\n\t/**\n\t * @return charset in use by bridge\n\t */\n\tpublic Charset getCharset() {\n\t\treturn relay.getCharset();\n\t}\n\n\t/**\n\t * Sets the encoding used by the terminal. If the connection is live,\n\t * then the character set is changed for the next read.\n\t * @param encoding the canonical name of the character encoding\n\t */\n\tpublic void setCharset(String encoding) {\n\t\tif (relay != null)\n\t\t\trelay.setCharset(encoding);\n\t\tkeyListener.setCharset(encoding);\n\t}\n\n\t/**\n\t * Convenience method for writing a line into the underlying MUD buffer.\n\t * Should never be called once the session is established.\n\t */\n\tpublic final void outputLine(String line) {\n\t\tif (transport != null && transport.isSessionOpen())\n\t\t\tLog.e(TAG, \"Session established, cannot use outputLine!\", new IOException(\"outputLine call traceback\"));\n\n\t\tsynchronized (localOutput) {\n\t\t\tfinal String s = line + \"\\r\\n\";\n\n\t\t\tlocalOutput.add(s);\n\n\t\t\t((vt320) buffer).putString(s);\n\n\t\t\t// For accessibility\n\t\t\tfinal char[] charArray = s.toCharArray();\n\t\t\tpropagateConsoleText(charArray, charArray.length);\n\t\t}\n\t}\n\n\t/**\n\t * Inject a specific string into this terminal. Used for post-login strings\n\t * and pasting clipboard.\n\t */\n\tpublic void injectString(final String string) {\n\t\tif (string == null || string.length() == 0)\n\t\t\treturn;\n\n\t\tThread injectStringThread = new Thread(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\ttransport.write(string.getBytes(host.getEncoding()));\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tLog.e(TAG, \"Couldn't inject string to remote host: \", e);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tinjectStringThread.setName(\"InjectString\");\n\t\tinjectStringThread.start();\n\t}\n\n\t/**\n\t * Internal method to request actual PTY terminal once we've finished\n\t * authentication. If called before authenticated, it will just fail.\n\t */\n\tpublic void onConnected() {\n\t\tdisconnected = false;\n\n\t\t((vt320) buffer).reset();\n\n\t\t// We no longer need our local output.\n\t\tlocalOutput.clear();\n\n\t\t// previously tried vt100 and xterm for emulation modes\n\t\t// \"screen\" works the best for color and escape codes\n\t\t((vt320) buffer).setAnswerBack(emulation);\n\n\t\tif (HostDatabase.DELKEY_BACKSPACE.equals(host.getDelKey()))\n\t\t\t((vt320) buffer).setBackspace(vt320.DELETE_IS_BACKSPACE);\n\t\telse\n\t\t\t((vt320) buffer).setBackspace(vt320.DELETE_IS_DEL);\n\n\t\t// create thread to relay incoming connection data to buffer\n\t\trelay = new Relay(this, transport, (vt320) buffer, host.getEncoding());\n\t\tThread relayThread = new Thread(relay);\n\t\trelayThread.setDaemon(true);\n\t\trelayThread.setName(\"Relay\");\n\t\trelayThread.start();\n\n\t\t// force font-size to make sure we resizePTY as needed\n\t\tsetFontSize(fontSize);\n\n\t\t// finally send any post-login string, if requested\n\t\tinjectString(host.getPostLogin());\n\t}\n\n\t/**\n\t * @return whether a session is open or not\n\t */\n\tpublic boolean isSessionOpen() {\n\t\tif (transport != null)\n\t\t\treturn transport.isSessionOpen();\n\t\treturn false;\n\t}\n\n\tpublic void setOnDisconnectedListener(BridgeDisconnectedListener disconnectListener) {\n\t\tthis.disconnectListener = disconnectListener;\n\t}\n\n\t/**\n\t * Force disconnection of this terminal bridge.\n\t */\n\tpublic void dispatchDisconnect(boolean immediate) {\n\t\t// We don't need to do this multiple times.\n\t\tsynchronized (this) {\n\t\t\tif (disconnected && !immediate)\n\t\t\t\treturn;\n\n\t\t\tdisconnected = true;\n\t\t}\n\n\t\t// Cancel any pending prompts.\n\t\tpromptHelper.cancelPrompt();\n\n\t\t// disconnection request hangs if we havent really connected to a host yet\n\t\t// temporary fix is to just spawn disconnection into a thread\n\t\tThread disconnectThread = new Thread(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tif (transport != null && transport.isConnected())\n\t\t\t\t\ttransport.close();\n\t\t\t}\n\t\t});\n\t\tdisconnectThread.setName(\"Disconnect\");\n\t\tdisconnectThread.start();\n\n\t\tif (immediate || (host.getQuickDisconnect() && !host.getStayConnected())) {\n\t\t\tawaitingClose = true;\n\t\t\tif (disconnectListener != null)\n\t\t\t\tdisconnectListener.onDisconnected(TerminalBridge.this);\n\t\t} else {\n\t\t\t{\n\t\t\t\tfinal String line = manager.res.getString(R.string.alert_disconnect_msg);\n\t\t\t\t((vt320) buffer).putString(\"\\r\\n\" + line + \"\\r\\n\");\n\t\t\t}\n\t\t\tif (host.getStayConnected()) {\n\t\t\t\tmanager.requestReconnect(this);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tThread disconnectPromptThread = new Thread(new Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tBoolean result = promptHelper.requestBooleanPrompt(null,\n\t\t\t\t\t\t\tmanager.res.getString(R.string.prompt_host_disconnected));\n\t\t\t\t\tif (result == null || result.booleanValue()) {\n\t\t\t\t\t\tawaitingClose = true;\n\n\t\t\t\t\t\t// Tell the TerminalManager that we can be destroyed now.\n\t\t\t\t\t\tif (disconnectListener != null)\n\t\t\t\t\t\t\tdisconnectListener.onDisconnected(TerminalBridge.this);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\tdisconnectPromptThread.setName(\"DisconnectPrompt\");\n\t\t\tdisconnectPromptThread.setDaemon(true);\n\t\t\tdisconnectPromptThread.start();\n\t\t}\n\t}\n\n\tpublic void setSelectingForCopy(boolean selectingForCopy) {\n\t\tthis.selectingForCopy = selectingForCopy;\n\t}\n\n\tpublic boolean isSelectingForCopy() {\n\t\treturn selectingForCopy;\n\t}\n\n\tpublic SelectionArea getSelectionArea() {\n\t\treturn selectionArea;\n\t}\n\n\tpublic synchronized void tryKeyVibrate() {\n\t\tmanager.tryKeyVibrate();\n\t}\n\n\t/**\n\t * Request a different font size. Will make call to parentChanged() to make\n\t * sure we resize PTY if needed.\n\t */\n\t/* package */ final void setFontSize(float size) {\n\t\tif (size <= 0.0)\n\t\t\treturn;\n\n\t\tdefaultPaint.setTextSize(size);\n\t\tfontSize = size;\n\n\t\t// read new metrics to get exact pixel dimensions\n\t\tFontMetrics fm = defaultPaint.getFontMetrics();\n\t\tcharTop = (int)Math.ceil(fm.top);\n\n\t\tfloat[] widths = new float[1];\n\t\tdefaultPaint.getTextWidths(\"X\", widths);\n\t\tcharWidth = (int)Math.ceil(widths[0]);\n\t\tcharHeight = (int)Math.ceil(fm.descent - fm.top);\n\n\t\t// refresh any bitmap with new font size\n\t\tif(parent != null)\n\t\t\tparentChanged(parent);\n\n\t\tfor (FontSizeChangedListener ofscl : fontSizeChangedListeners)\n\t\t\tofscl.onFontSizeChanged(size);\n\n\t\thost.setFontSize((int) fontSize);\n\t\tmanager.hostdb.updateFontSize(host);\n\n\t\tforcedSize = false;\n\t}\n\n\t/**\n\t * Add an {@link FontSizeChangedListener} to the list of listeners for this\n\t * bridge.\n\t *\n\t * @param listener\n\t *            listener to add\n\t */\n\tpublic void addFontSizeChangedListener(FontSizeChangedListener listener) {\n\t\tfontSizeChangedListeners.add(listener);\n\t}\n\n\t/**\n\t * Remove an {@link FontSizeChangedListener} from the list of listeners for\n\t * this bridge.\n\t *\n\t * @param listener\n\t */\n\tpublic void removeFontSizeChangedListener(FontSizeChangedListener listener) {\n\t\tfontSizeChangedListeners.remove(listener);\n\t}\n\n\t/**\n\t * Something changed in our parent {@link TerminalView}, maybe it's a new\n\t * parent, or maybe it's an updated font size. We should recalculate\n\t * terminal size information and request a PTY resize.\n\t */\n\tpublic final synchronized void parentChanged(TerminalView parent) {\n\t\tif (manager != null && !manager.isResizeAllowed()) {\n\t\t\tLog.d(TAG, \"Resize is not allowed now\");\n\t\t\treturn;\n\t\t}\n\n\t\tthis.parent = parent;\n\t\tfinal int width = parent.getWidth();\n\t\tfinal int height = parent.getHeight();\n\n\t\t// Something has gone wrong with our layout; we're 0 width or height!\n\t\tif (width <= 0 || height <= 0)\n\t\t\treturn;\n\n\t\tclipboard = (ClipboardManager) parent.getContext().getSystemService(Context.CLIPBOARD_SERVICE);\n\t\tkeyListener.setClipboardManager(clipboard);\n\n\t\tif (!forcedSize) {\n\t\t\t// recalculate buffer size\n\t\t\tint newColumns, newRows;\n\n\t\t\tnewColumns = width / charWidth;\n\t\t\tnewRows = height / charHeight;\n\n\t\t\t// If nothing has changed in the terminal dimensions and not an intial\n\t\t\t// draw then don't blow away scroll regions and such.\n\t\t\tif (newColumns == columns && newRows == rows)\n\t\t\t\treturn;\n\n\t\t\tcolumns = newColumns;\n\t\t\trows = newRows;\n\t\t}\n\n\t\t// reallocate new bitmap if needed\n\t\tboolean newBitmap = (bitmap == null);\n\t\tif(bitmap != null)\n\t\t\tnewBitmap = (bitmap.getWidth() != width || bitmap.getHeight() != height);\n\n\t\tif (newBitmap) {\n\t\t\tdiscardBitmap();\n\t\t\tbitmap = Bitmap.createBitmap(width, height, Config.ARGB_8888);\n\t\t\tcanvas.setBitmap(bitmap);\n\t\t}\n\n\t\t// clear out any old buffer information\n\t\tdefaultPaint.setColor(Color.BLACK);\n\t\tcanvas.drawPaint(defaultPaint);\n\n\t\t// Stroke the border of the terminal if the size is being forced;\n\t\tif (forcedSize) {\n\t\t\tint borderX = (columns * charWidth) + 1;\n\t\t\tint borderY = (rows * charHeight) + 1;\n\n\t\t\tdefaultPaint.setColor(Color.GRAY);\n\t\t\tdefaultPaint.setStrokeWidth(0.0f);\n\t\t\tif (width >= borderX)\n\t\t\t\tcanvas.drawLine(borderX, 0, borderX, borderY + 1, defaultPaint);\n\t\t\tif (height >= borderY)\n\t\t\t\tcanvas.drawLine(0, borderY, borderX + 1, borderY, defaultPaint);\n\t\t}\n\n\t\ttry {\n\t\t\t// request a terminal pty resize\n\t\t\tsynchronized (buffer) {\n\t\t\t\tbuffer.setScreenSize(columns, rows, true);\n\t\t\t}\n\n\t\t\tif(transport != null)\n\t\t\t\ttransport.setDimensions(columns, rows, width, height);\n\t\t} catch(Exception e) {\n\t\t\tLog.e(TAG, \"Problem while trying to resize screen or PTY\", e);\n\t\t}\n\n\t\t// redraw local output if we don't have a sesson to receive our resize request\n\t\tif (transport == null) {\n\t\t\tsynchronized (localOutput) {\n\t\t\t\t((vt320) buffer).reset();\n\n\t\t\t\tfor (String line : localOutput)\n\t\t\t\t\t((vt320) buffer).putString(line);\n\t\t\t}\n\t\t}\n\n\t\t// force full redraw with new buffer size\n\t\tfullRedraw = true;\n\t\tredraw();\n\n\t\tparent.notifyUser(String.format(\"%d x %d\", columns, rows));\n\n\t\tLog.i(TAG, String.format(\"parentChanged() now width=%d, height=%d\", columns, rows));\n\t}\n\n\t/**\n\t * Somehow our parent {@link TerminalView} was destroyed. Now we don't need\n\t * to redraw anywhere, and we can recycle our internal bitmap.\n\t */\n\tpublic synchronized void parentDestroyed() {\n\t\tparent = null;\n\t\tdiscardBitmap();\n\t}\n\n\tprivate void discardBitmap() {\n\t\tif (bitmap != null)\n\t\t\tbitmap.recycle();\n\t\tbitmap = null;\n\t}\n\n\tpublic void setVDUBuffer(VDUBuffer buffer) {\n\t\tthis.buffer = buffer;\n\t}\n\n\tpublic VDUBuffer getVDUBuffer() {\n\t\treturn buffer;\n\t}\n\n\tpublic void propagateConsoleText(char[] rawText, int length) {\n\t\tif (parent != null) {\n\t\t\tparent.propagateConsoleText(rawText, length);\n\t\t}\n\t}\n\n\tpublic void onDraw() {\n\t\tint fg, bg;\n\t\tsynchronized (buffer) {\n\t\t\tboolean entireDirty = buffer.update[0] || fullRedraw;\n\t\t\tboolean isWideCharacter = false;\n\n\t\t\t// walk through all lines in the buffer\n\t\t\tfor(int l = 0; l < buffer.height; l++) {\n\n\t\t\t\t// check if this line is dirty and needs to be repainted\n\t\t\t\t// also check for entire-buffer dirty flags\n\t\t\t\tif (!entireDirty && !buffer.update[l + 1]) continue;\n\n\t\t\t\t// reset dirty flag for this line\n\t\t\t\tbuffer.update[l + 1] = false;\n\n\t\t\t\t// walk through all characters in this line\n\t\t\t\tfor (int c = 0; c < buffer.width; c++) {\n\t\t\t\t\tint addr = 0;\n\t\t\t\t\tint currAttr = buffer.charAttributes[buffer.windowBase + l][c];\n\n\t\t\t\t\t{\n\t\t\t\t\t\tint fgcolor = defaultFg;\n\n\t\t\t\t\t\t// check if foreground color attribute is set\n\t\t\t\t\t\tif ((currAttr & VDUBuffer.COLOR_FG) != 0)\n\t\t\t\t\t\t\tfgcolor = ((currAttr & VDUBuffer.COLOR_FG) >> VDUBuffer.COLOR_FG_SHIFT) - 1;\n\n\t\t\t\t\t\tif (fgcolor < 8 && (currAttr & VDUBuffer.BOLD) != 0)\n\t\t\t\t\t\t\tfg = color[fgcolor + 8];\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tfg = color[fgcolor];\n\t\t\t\t\t}\n\n\t\t\t\t\t// check if background color attribute is set\n\t\t\t\t\tif ((currAttr & VDUBuffer.COLOR_BG) != 0)\n\t\t\t\t\t\tbg = color[((currAttr & VDUBuffer.COLOR_BG) >> VDUBuffer.COLOR_BG_SHIFT) - 1];\n\t\t\t\t\telse\n\t\t\t\t\t\tbg = color[defaultBg];\n\n\t\t\t\t\t// support character inversion by swapping background and foreground color\n\t\t\t\t\tif ((currAttr & VDUBuffer.INVERT) != 0) {\n\t\t\t\t\t\tint swapc = bg;\n\t\t\t\t\t\tbg = fg;\n\t\t\t\t\t\tfg = swapc;\n\t\t\t\t\t}\n\n\t\t\t\t\t// set underlined attributes if requested\n\t\t\t\t\tdefaultPaint.setUnderlineText((currAttr & VDUBuffer.UNDERLINE) != 0);\n\n\t\t\t\t\tisWideCharacter = (currAttr & VDUBuffer.FULLWIDTH) != 0;\n\n\t\t\t\t\tif (isWideCharacter)\n\t\t\t\t\t\taddr++;\n\t\t\t\t\telse {\n\t\t\t\t\t\t// determine the amount of continuous characters with the same settings and print them all at once\n\t\t\t\t\t\twhile(c + addr < buffer.width\n\t\t\t\t\t\t\t\t&& buffer.charAttributes[buffer.windowBase + l][c + addr] == currAttr) {\n\t\t\t\t\t\t\taddr++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Save the current clip region\n\t\t\t\t\tcanvas.save(Canvas.CLIP_SAVE_FLAG);\n\n\t\t\t\t\t// clear this dirty area with background color\n\t\t\t\t\tdefaultPaint.setColor(bg);\n\t\t\t\t\tif (isWideCharacter) {\n\t\t\t\t\t\tcanvas.clipRect(c * charWidth,\n\t\t\t\t\t\t\t\tl * charHeight,\n\t\t\t\t\t\t\t\t(c + 2) * charWidth,\n\t\t\t\t\t\t\t\t(l + 1) * charHeight);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcanvas.clipRect(c * charWidth,\n\t\t\t\t\t\t\t\tl * charHeight,\n\t\t\t\t\t\t\t\t(c + addr) * charWidth,\n\t\t\t\t\t\t\t\t(l + 1) * charHeight);\n\t\t\t\t\t}\n\t\t\t\t\tcanvas.drawPaint(defaultPaint);\n\n\t\t\t\t\t// write the text string starting at 'c' for 'addr' number of characters\n\t\t\t\t\tdefaultPaint.setColor(fg);\n\t\t\t\t\tif((currAttr & VDUBuffer.INVISIBLE) == 0)\n\t\t\t\t\t\tcanvas.drawText(buffer.charArray[buffer.windowBase + l], c,\n\t\t\t\t\t\t\taddr, c * charWidth, (l * charHeight) - charTop,\n\t\t\t\t\t\t\tdefaultPaint);\n\n\t\t\t\t\t// Restore the previous clip region\n\t\t\t\t\tcanvas.restore();\n\n\t\t\t\t\t// advance to the next text block with different characteristics\n\t\t\t\t\tc += addr - 1;\n\t\t\t\t\tif (isWideCharacter)\n\t\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// reset entire-buffer flags\n\t\t\tbuffer.update[0] = false;\n\t\t}\n\t\tfullRedraw = false;\n\t}\n\n\tpublic void redraw() {\n\t\tif (parent != null)\n\t\t\tparent.postInvalidate();\n\t}\n\n\t// We don't have a scroll bar.\n\tpublic void updateScrollBar() {\n\t}\n\n\t/**\n\t * Resize terminal to fit [rows]x[cols] in screen of size [width]x[height]\n\t * @param rows\n\t * @param cols\n\t * @param width\n\t * @param height\n\t */\n\tpublic synchronized void resizeComputed(int cols, int rows, int width, int height) {\n\t\tfloat size = 8.0f;\n\t\tfloat step = 8.0f;\n\t\tfloat limit = 0.125f;\n\n\t\tint direction;\n\n\t\twhile ((direction = fontSizeCompare(size, cols, rows, width, height)) < 0)\n\t\t\tsize += step;\n\n\t\tif (direction == 0) {\n\t\t\tLog.d(\"fontsize\", String.format(\"Found match at %f\", size));\n\t\t\treturn;\n\t\t}\n\n\t\tstep /= 2.0f;\n\t\tsize -= step;\n\n\t\twhile ((direction = fontSizeCompare(size, cols, rows, width, height)) != 0\n\t\t\t\t&& step >= limit) {\n\t\t\tstep /= 2.0f;\n\t\t\tif (direction > 0) {\n\t\t\t\tsize -= step;\n\t\t\t} else {\n\t\t\t\tsize += step;\n\t\t\t}\n\t\t}\n\n\t\tif (direction > 0)\n\t\t\tsize -= step;\n\n\t\tthis.columns = cols;\n\t\tthis.rows = rows;\n\t\tsetFontSize(size);\n\t\tforcedSize = true;\n\t}\n\n\tprivate int fontSizeCompare(float size, int cols, int rows, int width, int height) {\n\t\t// read new metrics to get exact pixel dimensions\n\t\tdefaultPaint.setTextSize(size);\n\t\tFontMetrics fm = defaultPaint.getFontMetrics();\n\n\t\tfloat[] widths = new float[1];\n\t\tdefaultPaint.getTextWidths(\"X\", widths);\n\t\tint termWidth = (int)widths[0] * cols;\n\t\tint termHeight = (int)Math.ceil(fm.descent - fm.top) * rows;\n\n\t\tLog.d(\"fontsize\", String.format(\"font size %f resulted in %d x %d\", size, termWidth, termHeight));\n\n\t\t// Check to see if it fits in resolution specified.\n\t\tif (termWidth > width || termHeight > height)\n\t\t\treturn 1;\n\n\t\tif (termWidth == width || termHeight == height)\n\t\t\treturn 0;\n\n\t\treturn -1;\n\t}\n\n\t/**\n\t * @return whether underlying transport can forward ports\n\t */\n\tpublic boolean canFowardPorts() {\n\t\treturn transport.canForwardPorts();\n\t}\n\n\t/**\n\t * Adds the {@link PortForwardBean} to the list.\n\t * @param portForward the port forward bean to add\n\t * @return true on successful addition\n\t */\n\tpublic boolean addPortForward(PortForwardBean portForward) {\n\t\treturn transport.addPortForward(portForward);\n\t}\n\n\t/**\n\t * Removes the {@link PortForwardBean} from the list.\n\t * @param portForward the port forward bean to remove\n\t * @return true on successful removal\n\t */\n\tpublic boolean removePortForward(PortForwardBean portForward) {\n\t\treturn transport.removePortForward(portForward);\n\t}\n\n\t/**\n\t * @return the list of port forwards\n\t */\n\tpublic List<PortForwardBean> getPortForwards() {\n\t\treturn transport.getPortForwards();\n\t}\n\n\t/**\n\t * Enables a port forward member. After calling this method, the port forward should\n\t * be operational.\n\t * @param portForward member of our current port forwards list to enable\n\t * @return true on successful port forward setup\n\t */\n\tpublic boolean enablePortForward(PortForwardBean portForward) {\n\t\tif (!transport.isConnected()) {\n\t\t\tLog.i(TAG, \"Attempt to enable port forward while not connected\");\n\t\t\treturn false;\n\t\t}\n\n\t\treturn transport.enablePortForward(portForward);\n\t}\n\n\t/**\n\t * Disables a port forward member. After calling this method, the port forward should\n\t * be non-functioning.\n\t * @param portForward member of our current port forwards list to enable\n\t * @return true on successful port forward tear-down\n\t */\n\tpublic boolean disablePortForward(PortForwardBean portForward) {\n\t\tif (!transport.isConnected()) {\n\t\t\tLog.i(TAG, \"Attempt to disable port forward while not connected\");\n\t\t\treturn false;\n\t\t}\n\n\t\treturn transport.disablePortForward(portForward);\n\t}\n\n\t/**\n\t * @return whether the TerminalBridge should close\n\t */\n\tpublic boolean isAwaitingClose() {\n\t\treturn awaitingClose;\n\t}\n\n\t/**\n\t * @return whether this connection had started and subsequently disconnected\n\t */\n\tpublic boolean isDisconnected() {\n\t\treturn disconnected;\n\t}\n\n\t/* (non-Javadoc)\n\t * @see de.mud.terminal.VDUDisplay#setColor(byte, byte, byte, byte)\n\t */\n\tpublic void setColor(int index, int red, int green, int blue) {\n\t\t// Don't allow the system colors to be overwritten for now. May violate specs.\n\t\tif (index < color.length && index >= 16)\n\t\t\tcolor[index] = 0xff000000 | red << 16 | green << 8 | blue;\n\t}\n\n\tpublic final void resetColors() {\n\t\tint[] defaults = manager.hostdb.getDefaultColorsForScheme(HostDatabase.DEFAULT_COLOR_SCHEME);\n\t\tdefaultFg = defaults[0];\n\t\tdefaultBg = defaults[1];\n\n\t\tcolor = manager.hostdb.getColorsForScheme(HostDatabase.DEFAULT_COLOR_SCHEME);\n\t}\n\n\tprivate static Pattern urlPattern = null;\n\n\t/**\n\t * @return\n\t */\n\tpublic List<String> scanForURLs() {\n\t\tList<String> urls = new LinkedList<String>();\n\n\t\tif (urlPattern == null) {\n\t\t\t// based on http://www.ietf.org/rfc/rfc2396.txt\n\t\t\tString scheme = \"[A-Za-z][-+.0-9A-Za-z]*\";\n\t\t\tString unreserved = \"[-._~0-9A-Za-z]\";\n\t\t\tString pctEncoded = \"%[0-9A-Fa-f]{2}\";\n\t\t\tString subDelims = \"[!$&'()*+,;:=]\";\n\t\t\tString userinfo = \"(?:\" + unreserved + \"|\" + pctEncoded + \"|\" + subDelims + \"|:)*\";\n\t\t\tString h16 = \"[0-9A-Fa-f]{1,4}\";\n\t\t\tString decOctet = \"(?:[0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\";\n\t\t\tString ipv4address = decOctet + \"\\\\.\" + decOctet + \"\\\\.\" + decOctet + \"\\\\.\" + decOctet;\n\t\t\tString ls32 = \"(?:\" + h16 + \":\" + h16 + \"|\" + ipv4address + \")\";\n\t\t\tString ipv6address = \"(?:(?:\" + h16 + \"){6}\" + ls32 + \")\";\n\t\t\tString ipvfuture = \"v[0-9A-Fa-f]+.(?:\" + unreserved + \"|\" + subDelims + \"|:)+\";\n\t\t\tString ipLiteral = \"\\\\[(?:\" + ipv6address + \"|\" + ipvfuture + \")\\\\]\";\n\t\t\tString regName = \"(?:\" + unreserved + \"|\" + pctEncoded + \"|\" + subDelims + \")*\";\n\t\t\tString host = \"(?:\" + ipLiteral + \"|\" + ipv4address + \"|\" + regName + \")\";\n\t\t\tString port = \"[0-9]*\";\n\t\t\tString authority = \"(?:\" + userinfo + \"@)?\" + host + \"(?::\" + port + \")?\";\n\t\t\tString pchar = \"(?:\" + unreserved + \"|\" + pctEncoded + \"|\" + subDelims + \"|@)\";\n\t\t\tString segment = pchar + \"*\";\n\t\t\tString pathAbempty = \"(?:/\" + segment + \")*\";\n\t\t\tString segmentNz = pchar + \"+\";\n\t\t\tString pathAbsolute = \"/(?:\" + segmentNz + \"(?:/\" + segment + \")*)?\";\n\t\t\tString pathRootless = segmentNz + \"(?:/\" + segment + \")*\";\n\t\t\tString hierPart = \"(?://\" + authority + pathAbempty + \"|\" + pathAbsolute + \"|\" + pathRootless + \")\";\n\t\t\tString query = \"(?:\" + pchar + \"|/|\\\\?)*\";\n\t\t\tString fragment = \"(?:\" + pchar + \"|/|\\\\?)*\";\n\t\t\tString uriRegex = scheme + \":\" + hierPart + \"(?:\" + query + \")?(?:#\" + fragment + \")?\";\n\t\t\turlPattern = Pattern.compile(uriRegex);\n\t\t}\n\n\t\tchar[] visibleBuffer = new char[buffer.height * buffer.width];\n\t\tfor (int l = 0; l < buffer.height; l++)\n\t\t\tSystem.arraycopy(buffer.charArray[buffer.windowBase + l], 0,\n\t\t\t\t\tvisibleBuffer, l * buffer.width, buffer.width);\n\n\t\tMatcher urlMatcher = urlPattern.matcher(new String(visibleBuffer));\n\t\twhile (urlMatcher.find())\n\t\t\turls.add(urlMatcher.group());\n\n\t\treturn urls;\n\t}\n\n\t/**\n\t * @return\n\t */\n\tpublic boolean isUsingNetwork() {\n\t\treturn transport.usesNetwork();\n\t}\n\n\t/**\n\t * @return\n\t */\n\tpublic TerminalKeyListener getKeyHandler() {\n\t\treturn keyListener;\n\t}\n\n\t/**\n\t *\n\t */\n\tpublic void resetScrollPosition() {\n\t\t// if we're in scrollback, scroll to bottom of window on input\n\t\tif (buffer.windowBase != buffer.screenBase)\n\t\t\tbuffer.setWindowBase(buffer.screenBase);\n\t}\n\n\t/**\n\t *\n\t */\n\tpublic void increaseFontSize() {\n\t\tsetFontSize(fontSize + FONT_SIZE_STEP);\n\t}\n\n\t/**\n\t *\n\t */\n\tpublic void decreaseFontSize() {\n\t\tsetFontSize(fontSize - FONT_SIZE_STEP);\n\t}\n}\n","Method after Refactoring":"/*\n * ConnectBot: simple, powerful, open-source SSH client for Android\n * Copyright 2007 Kenny Root, Jeffrey Sharkey\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.connectbot.service;\n\nimport java.io.IOException;\nimport java.nio.charset.Charset;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.connectbot.R;\nimport org.connectbot.TerminalView;\nimport org.connectbot.bean.HostBean;\nimport org.connectbot.bean.PortForwardBean;\nimport org.connectbot.bean.SelectionArea;\nimport org.connectbot.transport.AbsTransport;\nimport org.connectbot.transport.TransportFactory;\nimport org.connectbot.util.HostDatabase;\n\nimport android.content.Context;\nimport android.graphics.Bitmap;\nimport android.graphics.Bitmap.Config;\nimport android.graphics.Canvas;\nimport android.graphics.Color;\nimport android.graphics.Paint;\nimport android.graphics.Paint.FontMetrics;\nimport android.graphics.Typeface;\nimport android.text.ClipboardManager;\nimport android.util.Log;\nimport de.mud.terminal.VDUBuffer;\nimport de.mud.terminal.VDUDisplay;\nimport de.mud.terminal.vt320;\n\n\n/**\n * Provides a bridge between a MUD terminal buffer and a possible TerminalView.\n * This separation allows us to keep the TerminalBridge running in a background\n * service. A TerminalView shares down a bitmap that we can use for rendering\n * when available.\n *\n * This class also provides SSH hostkey verification prompting, and password\n * prompting.\n */\n@SuppressWarnings(\"deprecation\") // for ClipboardManager\npublic class TerminalBridge implements VDUDisplay {\n\tpublic final static String TAG = \"ConnectBot.TerminalBridge\";\n\n\tpublic final static int DEFAULT_FONT_SIZE_DP = 10;\n\tprivate final static int FONT_SIZE_STEP = 2;\n\tprivate final float displayDensity;\n\n\tpublic Integer[] color;\n\n\tpublic int defaultFg = HostDatabase.DEFAULT_FG_COLOR;\n\tpublic int defaultBg = HostDatabase.DEFAULT_BG_COLOR;\n\n\tprotected final TerminalManager manager;\n\n\tpublic HostBean host;\n\n\t/* package */ AbsTransport transport;\n\n\tfinal Paint defaultPaint;\n\n\tprivate Relay relay;\n\n\tprivate final String emulation;\n\tprivate final int scrollback;\n\n\tpublic Bitmap bitmap = null;\n\tpublic VDUBuffer buffer = null;\n\n\tprivate TerminalView parent = null;\n\tprivate final Canvas canvas = new Canvas();\n\n\tprivate boolean disconnected = false;\n\tprivate boolean awaitingClose = false;\n\n\tprivate boolean forcedSize = false;\n\tprivate int columns;\n\tprivate int rows;\n\n\t/* package */ final TerminalKeyListener keyListener;\n\n\tprivate boolean selectingForCopy = false;\n\tprivate final SelectionArea selectionArea;\n\n\t// TODO add support for the new clipboard API\n\tprivate ClipboardManager clipboard;\n\n\tpublic int charWidth = -1;\n\tpublic int charHeight = -1;\n\tprivate int charTop = -1;\n\n\tprivate float fontSizeDp = -1;\n\n\tprivate final List<FontSizeChangedListener> fontSizeChangedListeners;\n\n\tprivate final List<String> localOutput;\n\n\t/**\n\t * Flag indicating if we should perform a full-screen redraw during our next\n\t * rendering pass.\n\t */\n\tprivate boolean fullRedraw = false;\n\n\tpublic PromptHelper promptHelper;\n\n\tprotected BridgeDisconnectedListener disconnectListener = null;\n\n\t/**\n\t * Create a new terminal bridge suitable for unit testing.\n\t */\n\tpublic TerminalBridge() {\n\t\tbuffer = new vt320() {\n\t\t\t@Override\n\t\t\tpublic void write(byte[] b) {}\n\t\t\t@Override\n\t\t\tpublic void write(int b) {}\n\t\t\t@Override\n\t\t\tpublic void sendTelnetCommand(byte cmd) {}\n\t\t\t@Override\n\t\t\tpublic void setWindowSize(int c, int r) {}\n\t\t\t@Override\n\t\t\tpublic void debug(String s) {}\n\t\t};\n\n\t\temulation = null;\n\t\tmanager = null;\n\n\t\tdisplayDensity = 1f;\n\n\t\tdefaultPaint = new Paint();\n\n\t\tselectionArea = new SelectionArea();\n\t\tscrollback = 1;\n\n\t\tlocalOutput = new LinkedList<String>();\n\n\t\tfontSizeChangedListeners = new LinkedList<FontSizeChangedListener>();\n\n\t\ttransport = null;\n\n\t\tkeyListener = new TerminalKeyListener(manager, this, buffer, null);\n\t}\n\n\t/**\n\t * Create new terminal bridge with following parameters. We will immediately\n\t * launch thread to start SSH connection and handle any hostkey verification\n\t * and password authentication.\n\t */\n\tpublic TerminalBridge(final TerminalManager manager, final HostBean host) throws IOException {\n\t\tthis.manager = manager;\n\t\tthis.host = host;\n\n\t\temulation = manager.getEmulation();\n\t\tscrollback = manager.getScrollback();\n\n\t\tthis.displayDensity = manager.getResources().getDisplayMetrics().density;\n\n\t\t// create prompt helper to relay password and hostkey requests up to gui\n\t\tpromptHelper = new PromptHelper(this);\n\n\t\t// create our default paint\n\t\tdefaultPaint = new Paint();\n\t\tdefaultPaint.setAntiAlias(true);\n\t\tdefaultPaint.setTypeface(Typeface.MONOSPACE);\n\t\tdefaultPaint.setFakeBoldText(true); // more readable?\n\n\t\tlocalOutput = new LinkedList<String>();\n\n\t\tfontSizeChangedListeners = new LinkedList<FontSizeChangedListener>();\n\n\t\tint hostFontSizeDp = host.getFontSize();\n\t\tif (hostFontSizeDp <= 0) {\n\t\t\thostFontSizeDp = DEFAULT_FONT_SIZE_DP;\n\t\t}\n\t\tsetFontSize(hostFontSizeDp);\n\n\t\t// create terminal buffer and handle outgoing data\n\t\t// this is probably status reply information\n\t\tbuffer = new vt320() {\n\t\t\t@Override\n\t\t\tpublic void debug(String s) {\n\t\t\t\tLog.d(TAG, s);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void write(byte[] b) {\n\t\t\t\ttry {\n\t\t\t\t\tif (b != null && transport != null)\n\t\t\t\t\t\ttransport.write(b);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tLog.e(TAG, \"Problem writing outgoing data in vt320() thread\", e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void write(int b) {\n\t\t\t\ttry {\n\t\t\t\t\tif (transport != null)\n\t\t\t\t\t\ttransport.write(b);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tLog.e(TAG, \"Problem writing outgoing data in vt320() thread\", e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// We don't use telnet sequences.\n\t\t\t@Override\n\t\t\tpublic void sendTelnetCommand(byte cmd) {\n\t\t\t}\n\n\t\t\t// We don't want remote to resize our window.\n\t\t\t@Override\n\t\t\tpublic void setWindowSize(int c, int r) {\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void beep() {\n\t\t\t\tif (parent.isShown())\n\t\t\t\t\tmanager.playBeep();\n\t\t\t\telse\n\t\t\t\t\tmanager.sendActivityNotification(host);\n\t\t\t}\n\t\t};\n\n\t\t// Don't keep any scrollback if a session is not being opened.\n\t\tif (host.getWantSession())\n\t\t\tbuffer.setBufferSize(scrollback);\n\t\telse\n\t\t\tbuffer.setBufferSize(0);\n\n\t\tresetColors();\n\t\tbuffer.setDisplay(this);\n\n\t\tselectionArea = new SelectionArea();\n\n\t\tkeyListener = new TerminalKeyListener(manager, this, buffer, host.getEncoding());\n\t}\n\n\tpublic PromptHelper getPromptHelper() {\n\t\treturn promptHelper;\n\t}\n\n\t/**\n\t * Spawn thread to open connection and start login process.\n\t */\n\tprotected void startConnection() {\n\t\ttransport = TransportFactory.getTransport(host.getProtocol());\n\t\ttransport.setBridge(this);\n\t\ttransport.setManager(manager);\n\t\ttransport.setHost(host);\n\n\t\t// TODO make this more abstract so we don't litter on AbsTransport\n\t\ttransport.setCompression(host.getCompression());\n\t\ttransport.setUseAuthAgent(host.getUseAuthAgent());\n\t\ttransport.setEmulation(emulation);\n\n\t\tif (transport.canForwardPorts()) {\n\t\t\tfor (PortForwardBean portForward : manager.hostdb.getPortForwardsForHost(host))\n\t\t\t\ttransport.addPortForward(portForward);\n\t\t}\n\n\t\toutputLine(manager.res.getString(R.string.terminal_connecting, host.getHostname(), host.getPort(), host.getProtocol()));\n\n\t\tThread connectionThread = new Thread(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\ttransport.connect();\n\t\t\t}\n\t\t});\n\t\tconnectionThread.setName(\"Connection\");\n\t\tconnectionThread.setDaemon(true);\n\t\tconnectionThread.start();\n\t}\n\n\t/**\n\t * Handle challenges from keyboard-interactive authentication mode.\n\t */\n\tpublic String[] replyToChallenge(String name, String instruction, int numPrompts, String[] prompt, boolean[] echo) {\n\t\tString[] responses = new String[numPrompts];\n\t\tfor(int i = 0; i < numPrompts; i++) {\n\t\t\t// request response from user for each prompt\n\t\t\tresponses[i] = promptHelper.requestStringPrompt(instruction, prompt[i]);\n\t\t}\n\t\treturn responses;\n\t}\n\n\t/**\n\t * @return charset in use by bridge\n\t */\n\tpublic Charset getCharset() {\n\t\treturn relay.getCharset();\n\t}\n\n\t/**\n\t * Sets the encoding used by the terminal. If the connection is live,\n\t * then the character set is changed for the next read.\n\t * @param encoding the canonical name of the character encoding\n\t */\n\tpublic void setCharset(String encoding) {\n\t\tif (relay != null)\n\t\t\trelay.setCharset(encoding);\n\t\tkeyListener.setCharset(encoding);\n\t}\n\n\t/**\n\t * Convenience method for writing a line into the underlying MUD buffer.\n\t * Should never be called once the session is established.\n\t */\n\tpublic final void outputLine(String line) {\n\t\tif (transport != null && transport.isSessionOpen())\n\t\t\tLog.e(TAG, \"Session established, cannot use outputLine!\", new IOException(\"outputLine call traceback\"));\n\n\t\tsynchronized (localOutput) {\n\t\t\tfinal String s = line + \"\\r\\n\";\n\n\t\t\tlocalOutput.add(s);\n\n\t\t\t((vt320) buffer).putString(s);\n\n\t\t\t// For accessibility\n\t\t\tfinal char[] charArray = s.toCharArray();\n\t\t\tpropagateConsoleText(charArray, charArray.length);\n\t\t}\n\t}\n\n\t/**\n\t * Inject a specific string into this terminal. Used for post-login strings\n\t * and pasting clipboard.\n\t */\n\tpublic void injectString(final String string) {\n\t\tif (string == null || string.length() == 0)\n\t\t\treturn;\n\n\t\tThread injectStringThread = new Thread(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\ttransport.write(string.getBytes(host.getEncoding()));\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tLog.e(TAG, \"Couldn't inject string to remote host: \", e);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tinjectStringThread.setName(\"InjectString\");\n\t\tinjectStringThread.start();\n\t}\n\n\t/**\n\t * Internal method to request actual PTY terminal once we've finished\n\t * authentication. If called before authenticated, it will just fail.\n\t */\n\tpublic void onConnected() {\n\t\tdisconnected = false;\n\n\t\t((vt320) buffer).reset();\n\n\t\t// We no longer need our local output.\n\t\tlocalOutput.clear();\n\n\t\t// previously tried vt100 and xterm for emulation modes\n\t\t// \"screen\" works the best for color and escape codes\n\t\t((vt320) buffer).setAnswerBack(emulation);\n\n\t\tif (HostDatabase.DELKEY_BACKSPACE.equals(host.getDelKey()))\n\t\t\t((vt320) buffer).setBackspace(vt320.DELETE_IS_BACKSPACE);\n\t\telse\n\t\t\t((vt320) buffer).setBackspace(vt320.DELETE_IS_DEL);\n\n\t\t// create thread to relay incoming connection data to buffer\n\t\trelay = new Relay(this, transport, (vt320) buffer, host.getEncoding());\n\t\tThread relayThread = new Thread(relay);\n\t\trelayThread.setDaemon(true);\n\t\trelayThread.setName(\"Relay\");\n\t\trelayThread.start();\n\n\t\t// force font-size to make sure we resizePTY as needed\n\t\tsetFontSize(fontSizeDp);\n\n\t\t// finally send any post-login string, if requested\n\t\tinjectString(host.getPostLogin());\n\t}\n\n\t/**\n\t * @return whether a session is open or not\n\t */\n\tpublic boolean isSessionOpen() {\n\t\tif (transport != null)\n\t\t\treturn transport.isSessionOpen();\n\t\treturn false;\n\t}\n\n\tpublic void setOnDisconnectedListener(BridgeDisconnectedListener disconnectListener) {\n\t\tthis.disconnectListener = disconnectListener;\n\t}\n\n\t/**\n\t * Force disconnection of this terminal bridge.\n\t */\n\tpublic void dispatchDisconnect(boolean immediate) {\n\t\t// We don't need to do this multiple times.\n\t\tsynchronized (this) {\n\t\t\tif (disconnected && !immediate)\n\t\t\t\treturn;\n\n\t\t\tdisconnected = true;\n\t\t}\n\n\t\t// Cancel any pending prompts.\n\t\tpromptHelper.cancelPrompt();\n\n\t\t// disconnection request hangs if we havent really connected to a host yet\n\t\t// temporary fix is to just spawn disconnection into a thread\n\t\tThread disconnectThread = new Thread(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tif (transport != null && transport.isConnected())\n\t\t\t\t\ttransport.close();\n\t\t\t}\n\t\t});\n\t\tdisconnectThread.setName(\"Disconnect\");\n\t\tdisconnectThread.start();\n\n\t\tif (immediate || (host.getQuickDisconnect() && !host.getStayConnected())) {\n\t\t\tawaitingClose = true;\n\t\t\tif (disconnectListener != null)\n\t\t\t\tdisconnectListener.onDisconnected(TerminalBridge.this);\n\t\t} else {\n\t\t\t{\n\t\t\t\tfinal String line = manager.res.getString(R.string.alert_disconnect_msg);\n\t\t\t\t((vt320) buffer).putString(\"\\r\\n\" + line + \"\\r\\n\");\n\t\t\t}\n\t\t\tif (host.getStayConnected()) {\n\t\t\t\tmanager.requestReconnect(this);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tThread disconnectPromptThread = new Thread(new Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tBoolean result = promptHelper.requestBooleanPrompt(null,\n\t\t\t\t\t\t\tmanager.res.getString(R.string.prompt_host_disconnected));\n\t\t\t\t\tif (result == null || result.booleanValue()) {\n\t\t\t\t\t\tawaitingClose = true;\n\n\t\t\t\t\t\t// Tell the TerminalManager that we can be destroyed now.\n\t\t\t\t\t\tif (disconnectListener != null)\n\t\t\t\t\t\t\tdisconnectListener.onDisconnected(TerminalBridge.this);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\tdisconnectPromptThread.setName(\"DisconnectPrompt\");\n\t\t\tdisconnectPromptThread.setDaemon(true);\n\t\t\tdisconnectPromptThread.start();\n\t\t}\n\t}\n\n\tpublic void setSelectingForCopy(boolean selectingForCopy) {\n\t\tthis.selectingForCopy = selectingForCopy;\n\t}\n\n\tpublic boolean isSelectingForCopy() {\n\t\treturn selectingForCopy;\n\t}\n\n\tpublic SelectionArea getSelectionArea() {\n\t\treturn selectionArea;\n\t}\n\n\tpublic synchronized void tryKeyVibrate() {\n\t\tmanager.tryKeyVibrate();\n\t}\n\n\t/**\n\t * Request a different font size. Will make call to parentChanged() to make\n\t * sure we resize PTY if needed.\n\t *\n\t * @param sizeDp Size of font in dp\n\t */\n\t/* package */ final void setFontSize(float sizeDp) {\n\t\tif (sizeDp <= 0.0) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal int fontSizePx = (int) (sizeDp * this.displayDensity + 0.5f);\n\n\t\tdefaultPaint.setTextSize(fontSizePx);\n\t\tfontSizeDp = sizeDp;\n\n\t\t// read new metrics to get exact pixel dimensions\n\t\tFontMetrics fm = defaultPaint.getFontMetrics();\n\t\tcharTop = (int)Math.ceil(fm.top);\n\n\t\tfloat[] widths = new float[1];\n\t\tdefaultPaint.getTextWidths(\"X\", widths);\n\t\tcharWidth = (int)Math.ceil(widths[0]);\n\t\tcharHeight = (int)Math.ceil(fm.descent - fm.top);\n\n\t\t// refresh any bitmap with new font size\n\t\tif (parent != null) {\n\t\t\tparentChanged(parent);\n\t\t}\n\n\t\tfor (FontSizeChangedListener ofscl : fontSizeChangedListeners) {\n\t\t\tofscl.onFontSizeChanged(sizeDp);\n\t\t}\n\n\t\thost.setFontSize((int) sizeDp);\n\t\tmanager.hostdb.updateFontSize(host);\n\n\t\tforcedSize = false;\n\t}\n\n\t/**\n\t * Add an {@link FontSizeChangedListener} to the list of listeners for this\n\t * bridge.\n\t *\n\t * @param listener\n\t *            listener to add\n\t */\n\tpublic void addFontSizeChangedListener(FontSizeChangedListener listener) {\n\t\tfontSizeChangedListeners.add(listener);\n\t}\n\n\t/**\n\t * Remove an {@link FontSizeChangedListener} from the list of listeners for\n\t * this bridge.\n\t *\n\t * @param listener\n\t */\n\tpublic void removeFontSizeChangedListener(FontSizeChangedListener listener) {\n\t\tfontSizeChangedListeners.remove(listener);\n\t}\n\n\t/**\n\t * Something changed in our parent {@link TerminalView}, maybe it's a new\n\t * parent, or maybe it's an updated font size. We should recalculate\n\t * terminal size information and request a PTY resize.\n\t */\n\tpublic final synchronized void parentChanged(TerminalView parent) {\n\t\tif (manager != null && !manager.isResizeAllowed()) {\n\t\t\tLog.d(TAG, \"Resize is not allowed now\");\n\t\t\treturn;\n\t\t}\n\n\t\tthis.parent = parent;\n\t\tfinal int width = parent.getWidth();\n\t\tfinal int height = parent.getHeight();\n\n\t\t// Something has gone wrong with our layout; we're 0 width or height!\n\t\tif (width <= 0 || height <= 0)\n\t\t\treturn;\n\n\t\tclipboard = (ClipboardManager) parent.getContext().getSystemService(Context.CLIPBOARD_SERVICE);\n\t\tkeyListener.setClipboardManager(clipboard);\n\n\t\tif (!forcedSize) {\n\t\t\t// recalculate buffer size\n\t\t\tint newColumns, newRows;\n\n\t\t\tnewColumns = width / charWidth;\n\t\t\tnewRows = height / charHeight;\n\n\t\t\t// If nothing has changed in the terminal dimensions and not an intial\n\t\t\t// draw then don't blow away scroll regions and such.\n\t\t\tif (newColumns == columns && newRows == rows)\n\t\t\t\treturn;\n\n\t\t\tcolumns = newColumns;\n\t\t\trows = newRows;\n\t\t}\n\n\t\t// reallocate new bitmap if needed\n\t\tboolean newBitmap = (bitmap == null);\n\t\tif(bitmap != null)\n\t\t\tnewBitmap = (bitmap.getWidth() != width || bitmap.getHeight() != height);\n\n\t\tif (newBitmap) {\n\t\t\tdiscardBitmap();\n\t\t\tbitmap = Bitmap.createBitmap(width, height, Config.ARGB_8888);\n\t\t\tcanvas.setBitmap(bitmap);\n\t\t}\n\n\t\t// clear out any old buffer information\n\t\tdefaultPaint.setColor(Color.BLACK);\n\t\tcanvas.drawPaint(defaultPaint);\n\n\t\t// Stroke the border of the terminal if the size is being forced;\n\t\tif (forcedSize) {\n\t\t\tint borderX = (columns * charWidth) + 1;\n\t\t\tint borderY = (rows * charHeight) + 1;\n\n\t\t\tdefaultPaint.setColor(Color.GRAY);\n\t\t\tdefaultPaint.setStrokeWidth(0.0f);\n\t\t\tif (width >= borderX)\n\t\t\t\tcanvas.drawLine(borderX, 0, borderX, borderY + 1, defaultPaint);\n\t\t\tif (height >= borderY)\n\t\t\t\tcanvas.drawLine(0, borderY, borderX + 1, borderY, defaultPaint);\n\t\t}\n\n\t\ttry {\n\t\t\t// request a terminal pty resize\n\t\t\tsynchronized (buffer) {\n\t\t\t\tbuffer.setScreenSize(columns, rows, true);\n\t\t\t}\n\n\t\t\tif(transport != null)\n\t\t\t\ttransport.setDimensions(columns, rows, width, height);\n\t\t} catch(Exception e) {\n\t\t\tLog.e(TAG, \"Problem while trying to resize screen or PTY\", e);\n\t\t}\n\n\t\t// redraw local output if we don't have a sesson to receive our resize request\n\t\tif (transport == null) {\n\t\t\tsynchronized (localOutput) {\n\t\t\t\t((vt320) buffer).reset();\n\n\t\t\t\tfor (String line : localOutput)\n\t\t\t\t\t((vt320) buffer).putString(line);\n\t\t\t}\n\t\t}\n\n\t\t// force full redraw with new buffer size\n\t\tfullRedraw = true;\n\t\tredraw();\n\n\t\tparent.notifyUser(String.format(\"%d x %d\", columns, rows));\n\n\t\tLog.i(TAG, String.format(\"parentChanged() now width=%d, height=%d\", columns, rows));\n\t}\n\n\t/**\n\t * Somehow our parent {@link TerminalView} was destroyed. Now we don't need\n\t * to redraw anywhere, and we can recycle our internal bitmap.\n\t */\n\tpublic synchronized void parentDestroyed() {\n\t\tparent = null;\n\t\tdiscardBitmap();\n\t}\n\n\tprivate void discardBitmap() {\n\t\tif (bitmap != null)\n\t\t\tbitmap.recycle();\n\t\tbitmap = null;\n\t}\n\n\tpublic void setVDUBuffer(VDUBuffer buffer) {\n\t\tthis.buffer = buffer;\n\t}\n\n\tpublic VDUBuffer getVDUBuffer() {\n\t\treturn buffer;\n\t}\n\n\tpublic void propagateConsoleText(char[] rawText, int length) {\n\t\tif (parent != null) {\n\t\t\tparent.propagateConsoleText(rawText, length);\n\t\t}\n\t}\n\n\tpublic void onDraw() {\n\t\tint fg, bg;\n\t\tsynchronized (buffer) {\n\t\t\tboolean entireDirty = buffer.update[0] || fullRedraw;\n\t\t\tboolean isWideCharacter = false;\n\n\t\t\t// walk through all lines in the buffer\n\t\t\tfor(int l = 0; l < buffer.height; l++) {\n\n\t\t\t\t// check if this line is dirty and needs to be repainted\n\t\t\t\t// also check for entire-buffer dirty flags\n\t\t\t\tif (!entireDirty && !buffer.update[l + 1]) continue;\n\n\t\t\t\t// reset dirty flag for this line\n\t\t\t\tbuffer.update[l + 1] = false;\n\n\t\t\t\t// walk through all characters in this line\n\t\t\t\tfor (int c = 0; c < buffer.width; c++) {\n\t\t\t\t\tint addr = 0;\n\t\t\t\t\tint currAttr = buffer.charAttributes[buffer.windowBase + l][c];\n\n\t\t\t\t\t{\n\t\t\t\t\t\tint fgcolor = defaultFg;\n\n\t\t\t\t\t\t// check if foreground color attribute is set\n\t\t\t\t\t\tif ((currAttr & VDUBuffer.COLOR_FG) != 0)\n\t\t\t\t\t\t\tfgcolor = ((currAttr & VDUBuffer.COLOR_FG) >> VDUBuffer.COLOR_FG_SHIFT) - 1;\n\n\t\t\t\t\t\tif (fgcolor < 8 && (currAttr & VDUBuffer.BOLD) != 0)\n\t\t\t\t\t\t\tfg = color[fgcolor + 8];\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tfg = color[fgcolor];\n\t\t\t\t\t}\n\n\t\t\t\t\t// check if background color attribute is set\n\t\t\t\t\tif ((currAttr & VDUBuffer.COLOR_BG) != 0)\n\t\t\t\t\t\tbg = color[((currAttr & VDUBuffer.COLOR_BG) >> VDUBuffer.COLOR_BG_SHIFT) - 1];\n\t\t\t\t\telse\n\t\t\t\t\t\tbg = color[defaultBg];\n\n\t\t\t\t\t// support character inversion by swapping background and foreground color\n\t\t\t\t\tif ((currAttr & VDUBuffer.INVERT) != 0) {\n\t\t\t\t\t\tint swapc = bg;\n\t\t\t\t\t\tbg = fg;\n\t\t\t\t\t\tfg = swapc;\n\t\t\t\t\t}\n\n\t\t\t\t\t// set underlined attributes if requested\n\t\t\t\t\tdefaultPaint.setUnderlineText((currAttr & VDUBuffer.UNDERLINE) != 0);\n\n\t\t\t\t\tisWideCharacter = (currAttr & VDUBuffer.FULLWIDTH) != 0;\n\n\t\t\t\t\tif (isWideCharacter)\n\t\t\t\t\t\taddr++;\n\t\t\t\t\telse {\n\t\t\t\t\t\t// determine the amount of continuous characters with the same settings and print them all at once\n\t\t\t\t\t\twhile(c + addr < buffer.width\n\t\t\t\t\t\t\t\t&& buffer.charAttributes[buffer.windowBase + l][c + addr] == currAttr) {\n\t\t\t\t\t\t\taddr++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Save the current clip region\n\t\t\t\t\tcanvas.save(Canvas.CLIP_SAVE_FLAG);\n\n\t\t\t\t\t// clear this dirty area with background color\n\t\t\t\t\tdefaultPaint.setColor(bg);\n\t\t\t\t\tif (isWideCharacter) {\n\t\t\t\t\t\tcanvas.clipRect(c * charWidth,\n\t\t\t\t\t\t\t\tl * charHeight,\n\t\t\t\t\t\t\t\t(c + 2) * charWidth,\n\t\t\t\t\t\t\t\t(l + 1) * charHeight);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcanvas.clipRect(c * charWidth,\n\t\t\t\t\t\t\t\tl * charHeight,\n\t\t\t\t\t\t\t\t(c + addr) * charWidth,\n\t\t\t\t\t\t\t\t(l + 1) * charHeight);\n\t\t\t\t\t}\n\t\t\t\t\tcanvas.drawPaint(defaultPaint);\n\n\t\t\t\t\t// write the text string starting at 'c' for 'addr' number of characters\n\t\t\t\t\tdefaultPaint.setColor(fg);\n\t\t\t\t\tif((currAttr & VDUBuffer.INVISIBLE) == 0)\n\t\t\t\t\t\tcanvas.drawText(buffer.charArray[buffer.windowBase + l], c,\n\t\t\t\t\t\t\taddr, c * charWidth, (l * charHeight) - charTop,\n\t\t\t\t\t\t\tdefaultPaint);\n\n\t\t\t\t\t// Restore the previous clip region\n\t\t\t\t\tcanvas.restore();\n\n\t\t\t\t\t// advance to the next text block with different characteristics\n\t\t\t\t\tc += addr - 1;\n\t\t\t\t\tif (isWideCharacter)\n\t\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// reset entire-buffer flags\n\t\t\tbuffer.update[0] = false;\n\t\t}\n\t\tfullRedraw = false;\n\t}\n\n\tpublic void redraw() {\n\t\tif (parent != null)\n\t\t\tparent.postInvalidate();\n\t}\n\n\t// We don't have a scroll bar.\n\tpublic void updateScrollBar() {\n\t}\n\n\t/**\n\t * Resize terminal to fit [rows]x[cols] in screen of size [width]x[height]\n\t *\n\t * @param rows desired number of text rows\n\t * @param cols desired numbor of text colums\n\t * @param width width of screen in pixels\n\t * @param height height of screen in pixels\n\t */\n\tpublic synchronized void resizeComputed(int cols, int rows, int width, int height) {\n\t\tfloat sizeDp = 8.0f;\n\t\tfloat step = 8.0f;\n\t\tfloat limit = 0.125f;\n\n\t\tint direction;\n\n\t\twhile ((direction = fontSizeCompare(sizeDp, cols, rows, width, height)) < 0)\n\t\t\tsizeDp += step;\n\n\t\tif (direction == 0) {\n\t\t\tLog.d(\"fontsize\", String.format(\"Found match at %f\", sizeDp));\n\t\t\treturn;\n\t\t}\n\n\t\tstep /= 2.0f;\n\t\tsizeDp -= step;\n\n\t\twhile ((direction = fontSizeCompare(sizeDp, cols, rows, width, height)) != 0\n\t\t\t\t&& step >= limit) {\n\t\t\tstep /= 2.0f;\n\t\t\tif (direction > 0) {\n\t\t\t\tsizeDp -= step;\n\t\t\t} else {\n\t\t\t\tsizeDp += step;\n\t\t\t}\n\t\t}\n\n\t\tif (direction > 0)\n\t\t\tsizeDp -= step;\n\n\t\tthis.columns = cols;\n\t\tthis.rows = rows;\n\t\tsetFontSize(sizeDp);\n\t\tforcedSize = true;\n\t}\n\n\tprivate int fontSizeCompare(float sizeDp, int cols, int rows, int width, int height) {\n\t\t// read new metrics to get exact pixel dimensions\n\t\tdefaultPaint.setTextSize((int) (sizeDp * this.displayDensity + 0.5f));\n\t\tFontMetrics fm = defaultPaint.getFontMetrics();\n\n\t\tfloat[] widths = new float[1];\n\t\tdefaultPaint.getTextWidths(\"X\", widths);\n\t\tint termWidth = (int)widths[0] * cols;\n\t\tint termHeight = (int)Math.ceil(fm.descent - fm.top) * rows;\n\n\t\tLog.d(\"fontsize\", String.format(\"font size %fdp resulted in %d x %d\", sizeDp, termWidth, termHeight));\n\n\t\t// Check to see if it fits in resolution specified.\n\t\tif (termWidth > width || termHeight > height)\n\t\t\treturn 1;\n\n\t\tif (termWidth == width || termHeight == height)\n\t\t\treturn 0;\n\n\t\treturn -1;\n\t}\n\n\t/**\n\t * @return whether underlying transport can forward ports\n\t */\n\tpublic boolean canFowardPorts() {\n\t\treturn transport.canForwardPorts();\n\t}\n\n\t/**\n\t * Adds the {@link PortForwardBean} to the list.\n\t * @param portForward the port forward bean to add\n\t * @return true on successful addition\n\t */\n\tpublic boolean addPortForward(PortForwardBean portForward) {\n\t\treturn transport.addPortForward(portForward);\n\t}\n\n\t/**\n\t * Removes the {@link PortForwardBean} from the list.\n\t * @param portForward the port forward bean to remove\n\t * @return true on successful removal\n\t */\n\tpublic boolean removePortForward(PortForwardBean portForward) {\n\t\treturn transport.removePortForward(portForward);\n\t}\n\n\t/**\n\t * @return the list of port forwards\n\t */\n\tpublic List<PortForwardBean> getPortForwards() {\n\t\treturn transport.getPortForwards();\n\t}\n\n\t/**\n\t * Enables a port forward member. After calling this method, the port forward should\n\t * be operational.\n\t * @param portForward member of our current port forwards list to enable\n\t * @return true on successful port forward setup\n\t */\n\tpublic boolean enablePortForward(PortForwardBean portForward) {\n\t\tif (!transport.isConnected()) {\n\t\t\tLog.i(TAG, \"Attempt to enable port forward while not connected\");\n\t\t\treturn false;\n\t\t}\n\n\t\treturn transport.enablePortForward(portForward);\n\t}\n\n\t/**\n\t * Disables a port forward member. After calling this method, the port forward should\n\t * be non-functioning.\n\t * @param portForward member of our current port forwards list to enable\n\t * @return true on successful port forward tear-down\n\t */\n\tpublic boolean disablePortForward(PortForwardBean portForward) {\n\t\tif (!transport.isConnected()) {\n\t\t\tLog.i(TAG, \"Attempt to disable port forward while not connected\");\n\t\t\treturn false;\n\t\t}\n\n\t\treturn transport.disablePortForward(portForward);\n\t}\n\n\t/**\n\t * @return whether the TerminalBridge should close\n\t */\n\tpublic boolean isAwaitingClose() {\n\t\treturn awaitingClose;\n\t}\n\n\t/**\n\t * @return whether this connection had started and subsequently disconnected\n\t */\n\tpublic boolean isDisconnected() {\n\t\treturn disconnected;\n\t}\n\n\t/* (non-Javadoc)\n\t * @see de.mud.terminal.VDUDisplay#setColor(byte, byte, byte, byte)\n\t */\n\tpublic void setColor(int index, int red, int green, int blue) {\n\t\t// Don't allow the system colors to be overwritten for now. May violate specs.\n\t\tif (index < color.length && index >= 16)\n\t\t\tcolor[index] = 0xff000000 | red << 16 | green << 8 | blue;\n\t}\n\n\tpublic final void resetColors() {\n\t\tint[] defaults = manager.hostdb.getDefaultColorsForScheme(HostDatabase.DEFAULT_COLOR_SCHEME);\n\t\tdefaultFg = defaults[0];\n\t\tdefaultBg = defaults[1];\n\n\t\tcolor = manager.hostdb.getColorsForScheme(HostDatabase.DEFAULT_COLOR_SCHEME);\n\t}\n\n\tprivate static Pattern urlPattern = null;\n\n\t/**\n\t * @return\n\t */\n\tpublic List<String> scanForURLs() {\n\t\tList<String> urls = new LinkedList<String>();\n\n\t\tif (urlPattern == null) {\n\t\t\t// based on http://www.ietf.org/rfc/rfc2396.txt\n\t\t\tString scheme = \"[A-Za-z][-+.0-9A-Za-z]*\";\n\t\t\tString unreserved = \"[-._~0-9A-Za-z]\";\n\t\t\tString pctEncoded = \"%[0-9A-Fa-f]{2}\";\n\t\t\tString subDelims = \"[!$&'()*+,;:=]\";\n\t\t\tString userinfo = \"(?:\" + unreserved + \"|\" + pctEncoded + \"|\" + subDelims + \"|:)*\";\n\t\t\tString h16 = \"[0-9A-Fa-f]{1,4}\";\n\t\t\tString decOctet = \"(?:[0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\";\n\t\t\tString ipv4address = decOctet + \"\\\\.\" + decOctet + \"\\\\.\" + decOctet + \"\\\\.\" + decOctet;\n\t\t\tString ls32 = \"(?:\" + h16 + \":\" + h16 + \"|\" + ipv4address + \")\";\n\t\t\tString ipv6address = \"(?:(?:\" + h16 + \"){6}\" + ls32 + \")\";\n\t\t\tString ipvfuture = \"v[0-9A-Fa-f]+.(?:\" + unreserved + \"|\" + subDelims + \"|:)+\";\n\t\t\tString ipLiteral = \"\\\\[(?:\" + ipv6address + \"|\" + ipvfuture + \")\\\\]\";\n\t\t\tString regName = \"(?:\" + unreserved + \"|\" + pctEncoded + \"|\" + subDelims + \")*\";\n\t\t\tString host = \"(?:\" + ipLiteral + \"|\" + ipv4address + \"|\" + regName + \")\";\n\t\t\tString port = \"[0-9]*\";\n\t\t\tString authority = \"(?:\" + userinfo + \"@)?\" + host + \"(?::\" + port + \")?\";\n\t\t\tString pchar = \"(?:\" + unreserved + \"|\" + pctEncoded + \"|\" + subDelims + \"|@)\";\n\t\t\tString segment = pchar + \"*\";\n\t\t\tString pathAbempty = \"(?:/\" + segment + \")*\";\n\t\t\tString segmentNz = pchar + \"+\";\n\t\t\tString pathAbsolute = \"/(?:\" + segmentNz + \"(?:/\" + segment + \")*)?\";\n\t\t\tString pathRootless = segmentNz + \"(?:/\" + segment + \")*\";\n\t\t\tString hierPart = \"(?://\" + authority + pathAbempty + \"|\" + pathAbsolute + \"|\" + pathRootless + \")\";\n\t\t\tString query = \"(?:\" + pchar + \"|/|\\\\?)*\";\n\t\t\tString fragment = \"(?:\" + pchar + \"|/|\\\\?)*\";\n\t\t\tString uriRegex = scheme + \":\" + hierPart + \"(?:\" + query + \")?(?:#\" + fragment + \")?\";\n\t\t\turlPattern = Pattern.compile(uriRegex);\n\t\t}\n\n\t\tchar[] visibleBuffer = new char[buffer.height * buffer.width];\n\t\tfor (int l = 0; l < buffer.height; l++)\n\t\t\tSystem.arraycopy(buffer.charArray[buffer.windowBase + l], 0,\n\t\t\t\t\tvisibleBuffer, l * buffer.width, buffer.width);\n\n\t\tMatcher urlMatcher = urlPattern.matcher(new String(visibleBuffer));\n\t\twhile (urlMatcher.find())\n\t\t\turls.add(urlMatcher.group());\n\n\t\treturn urls;\n\t}\n\n\t/**\n\t * @return\n\t */\n\tpublic boolean isUsingNetwork() {\n\t\treturn transport.usesNetwork();\n\t}\n\n\t/**\n\t * @return\n\t */\n\tpublic TerminalKeyListener getKeyHandler() {\n\t\treturn keyListener;\n\t}\n\n\t/**\n\t *\n\t */\n\tpublic void resetScrollPosition() {\n\t\t// if we're in scrollback, scroll to bottom of window on input\n\t\tif (buffer.windowBase != buffer.screenBase)\n\t\t\tbuffer.setWindowBase(buffer.screenBase);\n\t}\n\n\t/**\n\t * Convenience function to increase the font size by a given step.\n\t */\n\tpublic void increaseFontSize() {\n\t\tsetFontSize(fontSizeDp + FONT_SIZE_STEP);\n\t}\n\n\t/**\n\t * Convenience function to decrease the font size by a given step.\n\t */\n\tpublic void decreaseFontSize() {\n\t\tsetFontSize(fontSizeDp - FONT_SIZE_STEP);\n\t}\n}\n","lineNo":497}
{"Smelly Sample":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * 090408\n * Keith Wiley\n * kwiley@keithwiley.com\n * http://keithwiley.com\n *\n * UberColorPickerDialog v1.1\n *\n * This color picker was implemented as a (significant) extension of the\n * ColorPickerDialog class provided in the Android API Demos.  You are free\n * to drop it unchanged into your own projects or to modify it as you see\n * fit.  I would appreciate it if this comment block were let intact,\n * merely for credit's sake.\n *\n * Enjoy!\n */\n\npackage org.connectbot.util;\n\nimport android.app.Dialog;\nimport android.content.Context;\nimport android.graphics.Bitmap;\nimport android.graphics.Canvas;\nimport android.graphics.Color;\nimport android.graphics.ColorMatrix;\nimport android.graphics.ComposeShader;\nimport android.graphics.Paint;\nimport android.graphics.PorterDuff;\nimport android.graphics.PorterDuffXfermode;\nimport android.graphics.RadialGradient;\nimport android.graphics.Rect;\nimport android.graphics.RectF;\nimport android.graphics.Shader;\nimport android.graphics.SweepGradient;\nimport android.graphics.drawable.GradientDrawable;\nimport android.graphics.drawable.GradientDrawable.Orientation;\nimport android.os.Bundle;\nimport android.util.DisplayMetrics;\nimport android.view.MotionEvent;\nimport android.view.View;\n\n/**\n * UberColorPickerDialog is a seriously enhanced version of the UberColorPickerDialog\n * class provided in the Android API Demos.<p>\n *\n * NOTE (from Kenny Root): This is a VERY slimmed down version custom for ConnectBot.\n * Visit Keith's site for the full version at the URL listed in the author line.<p>\n *\n * @author Keith Wiley, kwiley@keithwiley.com, http://keithwiley.com\n */\npublic class UberColorPickerDialog extends Dialog {\n\tprivate final OnColorChangedListener mListener;\n\tprivate final int mInitialColor;\n\n\t/**\n\t * Callback to the creator of the dialog, informing the creator of a new color and notifying that the dialog is about to dismiss.\n\t */\n\tpublic interface OnColorChangedListener {\n\t\tvoid colorChanged(int color);\n\t}\n\n\t/**\n\t * Ctor\n\t * @param context\n\t * @param listener\n\t * @param initialColor\n\t * @param showTitle If true, a title is shown across the top of the dialog.  If false a toast is shown instead.\n\t */\n\tpublic UberColorPickerDialog(Context context,\n\t\t\t\t\t\t\tOnColorChangedListener listener,\n\t\t\t\t\t\t\tint initialColor) {\n\t\tsuper(context);\n\n\t\tmListener = listener;\n\t\tmInitialColor = initialColor;\n\t}\n\n\t/**\n\t * Activity entry point\n\t */\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tOnColorChangedListener l = new OnColorChangedListener() {\n\t\t\tpublic void colorChanged(int color) {\n\t\t\t\tmListener.colorChanged(color);\n\t\t\t\tdismiss();\n\t\t\t}\n\t\t};\n\n\t\tDisplayMetrics dm = new DisplayMetrics();\n\t\tgetWindow().getWindowManager().getDefaultDisplay().getMetrics(dm);\n\t\tint screenWidth = dm.widthPixels;\n\t\tint screenHeight = dm.heightPixels;\n\n\t\tsetTitle(\"Pick a color (try the trackball)\");\n\n\t\ttry {\n\t\t\tsetContentView(new ColorPickerView(getContext(), l, screenWidth, screenHeight, mInitialColor));\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t//There is currently only one kind of ctor exception, that where no methods are enabled.\n\t\t\tdismiss();\t//This doesn't work!  The dialog is still shown (its title at least, the layout is empty from the exception being thrown).  <sigh>\n\t\t}\n\t}\n\n\t/**\n\t * ColorPickerView is the meat of this color picker (as opposed to the enclosing class).\n\t * All the heavy lifting is done directly by this View subclass.\n\t * <P>\n\t * You can enable/disable whichever color chooser methods you want by modifying the ENABLED_METHODS switches.  They *should*\n\t * do all the work required to properly enable/disable methods without losing track of what goes with what and what maps to what.\n\t * <P>\n\t * If you add a new color chooser method, do a text search for \"NEW_METHOD_WORK_NEEDED_HERE\".  That tag indicates all\n\t * the locations in the code that will have to be amended in order to properly add a new color chooser method.\n\t * I highly recommend adding new methods to the end of the list.  If you want to try to reorder the list, you're on your own.\n\t */\n\tprivate static class ColorPickerView extends View {\n\t\tprivate static int SWATCH_WIDTH = 95;\n\t\tprivate static final int SWATCH_HEIGHT = 60;\n\n\t\tprivate static int PALETTE_POS_X = 0;\n\t\tprivate static int PALETTE_POS_Y = SWATCH_HEIGHT;\n\t\tprivate static final int PALETTE_DIM = SWATCH_WIDTH * 2;\n\t\tprivate static final int PALETTE_RADIUS = PALETTE_DIM / 2;\n\t\tprivate static final int PALETTE_CENTER_X = PALETTE_RADIUS;\n\t\tprivate static final int PALETTE_CENTER_Y = PALETTE_RADIUS;\n\n\t\tprivate static final int SLIDER_THICKNESS = 40;\n\n\t\tprivate static int VIEW_DIM_X = PALETTE_DIM;\n\t\tprivate static int VIEW_DIM_Y = SWATCH_HEIGHT;\n\n\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\tprivate static final int METHOD_HS_V_PALETTE = 0;\n\n\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\t//Add a new entry to the list for each controller in the new method\n\t\tprivate static final int TRACKED_NONE = -1;\t//No object on screen is currently being tracked\n\t\tprivate static final int TRACK_SWATCH_OLD = 10;\n\t\tprivate static final int TRACK_SWATCH_NEW = 11;\n\t\tprivate static final int TRACK_HS_PALETTE = 30;\n\t\tprivate static final int TRACK_VER_VALUE_SLIDER = 31;\n\n\t\tprivate static final int TEXT_SIZE = 12;\n\t\tprivate static int[] TEXT_HSV_POS = new int[2];\n\t\tprivate static int[] TEXT_RGB_POS = new int[2];\n\t\tprivate static int[] TEXT_YUV_POS = new int[2];\n\t\tprivate static int[] TEXT_HEX_POS = new int[2];\n\n\t\tprivate static final float PI = 3.141592653589793f;\n\n\t\tprivate int mMethod = METHOD_HS_V_PALETTE;\n\t\tprivate int mTracking = TRACKED_NONE;\t//What object on screen is currently being tracked for movement\n\n\t\t//Zillions of persistant Paint objecs for drawing the View\n\n\t\tprivate Paint mSwatchOld, mSwatchNew;\n\n\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\t//Add Paints to represent the palettes of the new method's UI controllers\n\t\tprivate Paint mOvalHueSat;\n\n\t\tprivate Bitmap mVerSliderBM;\n\t\tprivate Canvas mVerSliderCv;\n\n\t\tprivate Bitmap[] mHorSlidersBM = new Bitmap[3];\n\t\tprivate Canvas[] mHorSlidersCv = new Canvas[3];\n\n\t\tprivate Paint mValDimmer;\n\n\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\t//Add Paints to represent the icon for the new method\n\t\tprivate Paint mOvalHueSatSmall;\n\n\t\tprivate Paint mPosMarker;\n\t\tprivate Paint mText;\n\n\t\tprivate Rect mOldSwatchRect = new Rect();\n\t\tprivate Rect mNewSwatchRect = new Rect();\n\t\tprivate Rect mPaletteRect = new Rect();\n\t\tprivate Rect mVerSliderRect = new Rect();\n\n\t\tprivate int[] mSpectrumColorsRev;\n\t\tprivate int mOriginalColor = 0;\t//The color passed in at the beginning, which can be reverted to at any time by tapping the old swatch.\n\t\tprivate float[] mHSV = new float[3];\n\t\tprivate int[] mRGB = new int[3];\n\t\tprivate float[] mYUV = new float[3];\n\t\tprivate String mHexStr = \"\";\n\t\tprivate boolean mHSVenabled = true;\t//Only true if an HSV method is enabled\n\t\tprivate boolean mRGBenabled = true;\t//Only true if an RGB method is enabled\n\t\tprivate boolean mYUVenabled = true;\t//Only true if a YUV method is enabled\n\t\tprivate boolean mHexenabled = true;\t//Only true if an RGB method is enabled\n\t\tprivate int[] mCoord = new int[3];\t\t//For drawing slider/palette markers\n\t\tprivate int mFocusedControl = -1;\t//Which control receives trackball events.\n\t\tprivate OnColorChangedListener mListener;\n\n\t\t/**\n\t\t * Ctor.\n\t\t * @param c\n\t\t * @param l\n\t\t * @param width Used to determine orientation and adjust layout accordingly\n\t\t * @param height Used to determine orientation and adjust layout accordingly\n\t\t * @param color The initial color\n\t\t * @throws Exception\n\t\t */\n\t\tColorPickerView(Context c, OnColorChangedListener l, int width, int height, int color)\n\t\tthrows Exception {\n\t\t\tsuper(c);\n\n\t\t\t//We need to make the dialog focusable to retrieve trackball events.\n\t\t\tsetFocusable(true);\n\n\t\t\tmListener = l;\n\n\t\t\tmOriginalColor = color;\n\n\t\t\tColor.colorToHSV(color, mHSV);\n\n\t\t\tupdateAllFromHSV();\n\n\t\t\t//Setup the layout based on whether this is a portrait or landscape orientation.\n\t\t\tif (width <= height) {\t//Portrait layout\n\t\t\t\tSWATCH_WIDTH = (PALETTE_DIM + SLIDER_THICKNESS) / 2;\n\n\t\t\t\tPALETTE_POS_X = 0;\n\t\t\t\tPALETTE_POS_Y = TEXT_SIZE * 4 + SWATCH_HEIGHT;\n\n\t\t\t\t//Set more rects, lots of rects\n\t\t\t\tmOldSwatchRect.set(0, TEXT_SIZE * 4, SWATCH_WIDTH, TEXT_SIZE * 4 + SWATCH_HEIGHT);\n\t\t\t\tmNewSwatchRect.set(SWATCH_WIDTH, TEXT_SIZE * 4, SWATCH_WIDTH * 2, TEXT_SIZE * 4 + SWATCH_HEIGHT);\n\t\t\t\tmPaletteRect.set(0, PALETTE_POS_Y, PALETTE_DIM, PALETTE_POS_Y + PALETTE_DIM);\n\t\t\t\tmVerSliderRect.set(PALETTE_DIM, PALETTE_POS_Y, PALETTE_DIM + SLIDER_THICKNESS, PALETTE_POS_Y + PALETTE_DIM);\n\n\t\t\t\tTEXT_HSV_POS[0] = 3;\n\t\t\t\tTEXT_HSV_POS[1] = 0;\n\t\t\t\tTEXT_RGB_POS[0] = TEXT_HSV_POS[0] + 50;\n\t\t\t\tTEXT_RGB_POS[1] = TEXT_HSV_POS[1];\n\t\t\t\tTEXT_YUV_POS[0] = TEXT_HSV_POS[0] + 100;\n\t\t\t\tTEXT_YUV_POS[1] = TEXT_HSV_POS[1];\n\t\t\t\tTEXT_HEX_POS[0] = TEXT_HSV_POS[0] + 150;\n\t\t\t\tTEXT_HEX_POS[1] = TEXT_HSV_POS[1];\n\n\t\t\t\tVIEW_DIM_X = PALETTE_DIM + SLIDER_THICKNESS;\n\t\t\t\tVIEW_DIM_Y = SWATCH_HEIGHT + PALETTE_DIM + TEXT_SIZE * 4;\n\t\t\t}\n\t\t\telse {\t//Landscape layout\n\t\t\t\tSWATCH_WIDTH = 110;\n\n\t\t\t\tPALETTE_POS_X = SWATCH_WIDTH;\n\t\t\t\tPALETTE_POS_Y = 0;\n\n\t\t\t\t//Set more rects, lots of rects\n\t\t\t\tmOldSwatchRect.set(0, TEXT_SIZE * 7, SWATCH_WIDTH, TEXT_SIZE * 7 + SWATCH_HEIGHT);\n\t\t\t\tmNewSwatchRect.set(0, TEXT_SIZE * 7 + SWATCH_HEIGHT, SWATCH_WIDTH, TEXT_SIZE * 7 + SWATCH_HEIGHT * 2);\n\t\t\t\tmPaletteRect.set(SWATCH_WIDTH, PALETTE_POS_Y, SWATCH_WIDTH + PALETTE_DIM, PALETTE_POS_Y + PALETTE_DIM);\n\t\t\t\tmVerSliderRect.set(SWATCH_WIDTH + PALETTE_DIM, PALETTE_POS_Y, SWATCH_WIDTH + PALETTE_DIM + SLIDER_THICKNESS, PALETTE_POS_Y + PALETTE_DIM);\n\n\t\t\t\tTEXT_HSV_POS[0] = 3;\n\t\t\t\tTEXT_HSV_POS[1] = 0;\n\t\t\t\tTEXT_RGB_POS[0] = TEXT_HSV_POS[0];\n\t\t\t\tTEXT_RGB_POS[1] = (int)(TEXT_HSV_POS[1] + TEXT_SIZE * 3.5);\n\t\t\t\tTEXT_YUV_POS[0] = TEXT_HSV_POS[0] + 50;\n\t\t\t\tTEXT_YUV_POS[1] = (int)(TEXT_HSV_POS[1] + TEXT_SIZE * 3.5);\n\t\t\t\tTEXT_HEX_POS[0] = TEXT_HSV_POS[0] + 50;\n\t\t\t\tTEXT_HEX_POS[1] = TEXT_HSV_POS[1];\n\n\t\t\t\tVIEW_DIM_X = PALETTE_POS_X + PALETTE_DIM + SLIDER_THICKNESS;\n\t\t\t\tVIEW_DIM_Y = Math.max(mNewSwatchRect.bottom, PALETTE_DIM);\n\t\t\t}\n\n\t\t\t//Rainbows make everybody happy!\n\t\t\tmSpectrumColorsRev = new int[] {\n\t\t\t\t0xFFFF0000, 0xFFFF00FF, 0xFF0000FF, 0xFF00FFFF,\n\t\t\t\t0xFF00FF00, 0xFFFFFF00, 0xFFFF0000,\n\t\t\t};\n\n\t\t\t//Setup all the Paint and Shader objects.  There are lots of them!\n\n\t\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\t\t//Add Paints to represent the palettes of the new method's UI controllers\n\n\t\t\tmSwatchOld = new Paint(Paint.ANTI_ALIAS_FLAG);\n\t\t\tmSwatchOld.setStyle(Paint.Style.FILL);\n\t\t\tmSwatchOld.setColor(Color.HSVToColor(mHSV));\n\n\t\t\tmSwatchNew = new Paint(Paint.ANTI_ALIAS_FLAG);\n\t\t\tmSwatchNew.setStyle(Paint.Style.FILL);\n\t\t\tmSwatchNew.setColor(Color.HSVToColor(mHSV));\n\n\t\t\tShader shaderA = new SweepGradient(0, 0, mSpectrumColorsRev, null);\n\t\t\tShader shaderB = new RadialGradient(0, 0, PALETTE_CENTER_X, 0xFFFFFFFF, 0xFF000000, Shader.TileMode.CLAMP);\n\t\t\tShader shader = new ComposeShader(shaderA, shaderB, PorterDuff.Mode.SCREEN);\n\t\t\tmOvalHueSat = new Paint(Paint.ANTI_ALIAS_FLAG);\n\t\t\tmOvalHueSat.setShader(shader);\n\t\t\tmOvalHueSat.setStyle(Paint.Style.FILL);\n\t\t\tmOvalHueSat.setDither(true);\n\n\t\t\tmVerSliderBM = Bitmap.createBitmap(SLIDER_THICKNESS, PALETTE_DIM, Bitmap.Config.RGB_565);\n\t\t\tmVerSliderCv = new Canvas(mVerSliderBM);\n\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tmHorSlidersBM[i] = Bitmap.createBitmap(PALETTE_DIM, SLIDER_THICKNESS, Bitmap.Config.RGB_565);\n\t\t\t\tmHorSlidersCv[i] = new Canvas(mHorSlidersBM[i]);\n\t\t\t}\n\n\t\t\tmValDimmer = new Paint(Paint.ANTI_ALIAS_FLAG);\n\t\t\tmValDimmer.setStyle(Paint.Style.FILL);\n\t\t\tmValDimmer.setDither(true);\n\t\t\tmValDimmer.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.MULTIPLY));\n\n\t\t\t//Whew, we're done making the big Paints and Shaders for the swatches, palettes, and sliders.\n\t\t\t//Now we need to make the Paints and Shaders that will draw the little method icons in the method selector list.\n\n\t\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\t\t//Add Paints to represent the icon for the new method\n\n\t\t\tshaderA = new SweepGradient(0, 0, mSpectrumColorsRev, null);\n\t\t\tshaderB = new RadialGradient(0, 0, PALETTE_DIM / 2, 0xFFFFFFFF, 0xFF000000, Shader.TileMode.CLAMP);\n\t\t\tshader = new ComposeShader(shaderA, shaderB, PorterDuff.Mode.SCREEN);\n\t\t\tmOvalHueSatSmall = new Paint(Paint.ANTI_ALIAS_FLAG);\n\t\t\tmOvalHueSatSmall.setShader(shader);\n\t\t\tmOvalHueSatSmall.setStyle(Paint.Style.FILL);\n\n\t\t\t//Make a simple stroking Paint for drawing markers and borders and stuff like that.\n\t\t\tmPosMarker = new Paint(Paint.ANTI_ALIAS_FLAG);\n\t\t\tmPosMarker.setStyle(Paint.Style.STROKE);\n\t\t\tmPosMarker.setStrokeWidth(2);\n\n\t\t\t//Make a basic text Paint.\n\t\t\tmText = new Paint(Paint.ANTI_ALIAS_FLAG);\n\t\t\tmText.setTextSize(TEXT_SIZE);\n\t\t\tmText.setColor(Color.WHITE);\n\n\t\t\t//Kickstart\n\t\t\tinitUI();\n\t\t}\n\n\t\t/**\n\t\t * Draw the entire view (the entire dialog).\n\t\t */\n\t\t@Override\n\t\tprotected void onDraw(Canvas canvas) {\n\t\t\t//Draw the old and new swatches\n\t\t\tdrawSwatches(canvas);\n\n\t\t\t//Write the text\n\t\t\twriteColorParams(canvas);\n\n\t\t\t//Draw the palette and sliders (the UI)\n\t\t\tif (mMethod == METHOD_HS_V_PALETTE)\n\t\t\t\tdrawHSV1Palette(canvas);\n\t\t}\n\n\t\t/**\n\t\t * Draw the old and new swatches.\n\t\t * @param canvas\n\t\t */\n\t\tprivate void drawSwatches(Canvas canvas) {\n\t\t\tfloat[] hsv = new float[3];\n\n\t\t\tmText.setTextSize(16);\n\n\t\t\t//Draw the original swatch\n\t\t\tcanvas.drawRect(mOldSwatchRect, mSwatchOld);\n\t\t\tColor.colorToHSV(mOriginalColor, hsv);\n\t\t\t//if (UberColorPickerDialog.isGray(mColor))\t//Don't need this right here, but imp't to note\n\t\t\t//\thsv[1] = 0;\n\t\t\tif (hsv[2] > .5)\n\t\t\t\tmText.setColor(Color.BLACK);\n\t\t\tcanvas.drawText(\"Revert\", mOldSwatchRect.left + SWATCH_WIDTH / 2 - mText.measureText(\"Revert\") / 2, mOldSwatchRect.top + 16, mText);\n\t\t\tmText.setColor(Color.WHITE);\n\n\t\t\t//Draw the new swatch\n\t\t\tcanvas.drawRect(mNewSwatchRect, mSwatchNew);\n\t\t\tif (mHSV[2] > .5)\n\t\t\t\tmText.setColor(Color.BLACK);\n\t\t\tcanvas.drawText(\"Accept\", mNewSwatchRect.left + SWATCH_WIDTH / 2 - mText.measureText(\"Accept\") / 2, mNewSwatchRect.top + 16, mText);\n\t\t\tmText.setColor(Color.WHITE);\n\n\t\t\tmText.setTextSize(TEXT_SIZE);\n\t\t}\n\n\t\t/**\n\t\t * Write the color parametes (HSV, RGB, YUV, Hex, etc.).\n\t\t * @param canvas\n\t\t */\n\t\tprivate void writeColorParams(Canvas canvas) {\n\t\t\tif (mHSVenabled) {\n\t\t\t\tcanvas.drawText(\"H: \" + Integer.toString((int)(mHSV[0] / 360.0f * 255)), TEXT_HSV_POS[0], TEXT_HSV_POS[1] + TEXT_SIZE, mText);\n\t\t\t\tcanvas.drawText(\"S: \" + Integer.toString((int)(mHSV[1] * 255)), TEXT_HSV_POS[0], TEXT_HSV_POS[1] + TEXT_SIZE * 2, mText);\n\t\t\t\tcanvas.drawText(\"V: \" + Integer.toString((int)(mHSV[2] * 255)), TEXT_HSV_POS[0], TEXT_HSV_POS[1] + TEXT_SIZE * 3, mText);\n\t\t\t}\n\n\t\t\tif (mRGBenabled) {\n\t\t\t\tcanvas.drawText(\"R: \" + mRGB[0], TEXT_RGB_POS[0], TEXT_RGB_POS[1] + TEXT_SIZE, mText);\n\t\t\t\tcanvas.drawText(\"G: \" + mRGB[1], TEXT_RGB_POS[0], TEXT_RGB_POS[1] + TEXT_SIZE * 2, mText);\n\t\t\t\tcanvas.drawText(\"B: \" + mRGB[2], TEXT_RGB_POS[0], TEXT_RGB_POS[1] + TEXT_SIZE * 3, mText);\n\t\t\t}\n\n\t\t\tif (mYUVenabled) {\n\t\t\t\tcanvas.drawText(\"Y: \" + Integer.toString((int)(mYUV[0] * 255)), TEXT_YUV_POS[0], TEXT_YUV_POS[1] + TEXT_SIZE, mText);\n\t\t\t\tcanvas.drawText(\"U: \" + Integer.toString((int)((mYUV[1] + .5f) * 255)), TEXT_YUV_POS[0], TEXT_YUV_POS[1] + TEXT_SIZE * 2, mText);\n\t\t\t\tcanvas.drawText(\"V: \" + Integer.toString((int)((mYUV[2] + .5f) * 255)), TEXT_YUV_POS[0], TEXT_YUV_POS[1] + TEXT_SIZE * 3, mText);\n\t\t\t}\n\n\t\t\tif (mHexenabled)\n\t\t\t\tcanvas.drawText(\"#\" + mHexStr, TEXT_HEX_POS[0], TEXT_HEX_POS[1] + TEXT_SIZE, mText);\n\t\t}\n\n\t\t/**\n\t\t * Place a small circle on the 2D palette to indicate the current values.\n\t\t * @param canvas\n\t\t * @param markerPosX\n\t\t * @param markerPosY\n\t\t */\n\t\tprivate void mark2DPalette(Canvas canvas, int markerPosX, int markerPosY) {\n\t\t\tmPosMarker.setColor(Color.BLACK);\n\t\t\tcanvas.drawOval(new RectF(markerPosX - 5, markerPosY - 5, markerPosX + 5, markerPosY + 5), mPosMarker);\n\t\t\tmPosMarker.setColor(Color.WHITE);\n\t\t\tcanvas.drawOval(new RectF(markerPosX - 3, markerPosY - 3, markerPosX + 3, markerPosY + 3), mPosMarker);\n\t\t}\n\n\t\t/**\n\t\t * Draw a line across the slider to indicate its current value.\n\t\t * @param canvas\n\t\t * @param markerPos\n\t\t */\n\t\tprivate void markVerSlider(Canvas canvas, int markerPos) {\n\t\t\tmPosMarker.setColor(Color.BLACK);\n\t\t\tcanvas.drawRect(new Rect(0, markerPos - 2, SLIDER_THICKNESS, markerPos + 3), mPosMarker);\n\t\t\tmPosMarker.setColor(Color.WHITE);\n\t\t\tcanvas.drawRect(new Rect(0, markerPos, SLIDER_THICKNESS, markerPos + 1), mPosMarker);\n\t\t}\n\n\t\t/**\n\t\t * Frame the slider to indicate that it has trackball focus.\n\t\t * @param canvas\n\t\t */\n\t\tprivate void hilightFocusedVerSlider(Canvas canvas) {\n\t\t\tmPosMarker.setColor(Color.WHITE);\n\t\t\tcanvas.drawRect(new Rect(0, 0, SLIDER_THICKNESS, PALETTE_DIM), mPosMarker);\n\t\t\tmPosMarker.setColor(Color.BLACK);\n\t\t\tcanvas.drawRect(new Rect(2, 2, SLIDER_THICKNESS - 2, PALETTE_DIM - 2), mPosMarker);\n\t\t}\n\n\t\t/**\n\t\t * Frame the 2D palette to indicate that it has trackball focus.\n\t\t * @param canvas\n\t\t */\n\t\tprivate void hilightFocusedOvalPalette(Canvas canvas) {\n\t\t\tmPosMarker.setColor(Color.WHITE);\n\t\t\tcanvas.drawOval(new RectF(-PALETTE_RADIUS, -PALETTE_RADIUS, PALETTE_RADIUS, PALETTE_RADIUS), mPosMarker);\n\t\t\tmPosMarker.setColor(Color.BLACK);\n\t\t\tcanvas.drawOval(new RectF(-PALETTE_RADIUS + 2, -PALETTE_RADIUS + 2, PALETTE_RADIUS - 2, PALETTE_RADIUS - 2), mPosMarker);\n\t\t}\n\n\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\t//To add a new method, replicate the basic draw functions here.  Use the 2D palette or 1D sliders as templates for the new method.\n\t\t/**\n\t\t * Draw the UI for HSV with angular H and radial S combined in 2D and a 1D V slider.\n\t\t * @param canvas\n\t\t */\n\t\tprivate void drawHSV1Palette(Canvas canvas) {\n\t\t\tcanvas.save();\n\n\t\t\tcanvas.translate(PALETTE_POS_X, PALETTE_POS_Y);\n\n\t\t\t//Draw the 2D palette\n\t\t\tcanvas.translate(PALETTE_CENTER_X, PALETTE_CENTER_Y);\n\t\t\tcanvas.drawOval(new RectF(-PALETTE_RADIUS, -PALETTE_RADIUS, PALETTE_RADIUS, PALETTE_RADIUS), mOvalHueSat);\n\t\t\tcanvas.drawOval(new RectF(-PALETTE_RADIUS, -PALETTE_RADIUS, PALETTE_RADIUS, PALETTE_RADIUS), mValDimmer);\n\t\t\tif (mFocusedControl == 0)\n\t\t\t\thilightFocusedOvalPalette(canvas);\n\t\t\tmark2DPalette(canvas, mCoord[0], mCoord[1]);\n\t\t\tcanvas.translate(-PALETTE_CENTER_X, -PALETTE_CENTER_Y);\n\n\t\t\t//Draw the 1D slider\n\t\t\tcanvas.translate(PALETTE_DIM, 0);\n\t\t\tcanvas.drawBitmap(mVerSliderBM, 0, 0, null);\n\t\t\tif (mFocusedControl == 1)\n\t\t\t\thilightFocusedVerSlider(canvas);\n\t\t\tmarkVerSlider(canvas, mCoord[2]);\n\n\t\t\tcanvas.restore();\n\t\t}\n\n\t\t/**\n\t\t * Initialize the current color chooser's UI (set its color parameters and set its palette and slider values accordingly).\n\t\t */\n\t\tprivate void initUI() {\n\t\t\tinitHSV1Palette();\n\n\t\t\t//Focus on the first controller (arbitrary).\n\t\t\tmFocusedControl = 0;\n\t\t}\n\n\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\t//To add a new method, replicate and extend the last init function shown below\n\t\t/**\n\t\t * Initialize a color chooser.\n\t\t */\n\t\tprivate void initHSV1Palette() {\n\t\t\tsetOvalValDimmer();\n\t\t\tsetVerValSlider();\n\n\t\t\tfloat angle = 2*PI - mHSV[0] / (180 / 3.1415927f);\n\t\t\tfloat radius = mHSV[1] * PALETTE_RADIUS;\n\t\t\tmCoord[0] = (int)(Math.cos(angle) * radius);\n\t\t\tmCoord[1] = (int)(Math.sin(angle) * radius);\n\n\t\t\tmCoord[2] = PALETTE_DIM - (int)(mHSV[2] * PALETTE_DIM);\n\t\t}\n\n\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\t//To add a new method, replicate and extend the set functions below, one per UI controller in the new method\n\t\t/**\n\t\t * Adjust a Paint which, when painted, dims its underlying object to show the effects of varying value (brightness).\n\t\t */\n\t\tprivate void setOvalValDimmer() {\n\t\t\tfloat[] hsv = new float[3];\n\t\t\thsv[0] = mHSV[0];\n\t\t\thsv[1] = 0;\n\t\t\thsv[2] = mHSV[2];\n\t\t\tint gray = Color.HSVToColor(hsv);\n\t\t\tmValDimmer.setColor(gray);\n\t\t}\n\n\t\t/**\n\t\t * Create a linear gradient shader to show variations in value.\n\t\t */\n\t\tprivate void setVerValSlider() {\n\t\t\tfloat[] hsv = new float[3];\n\t\t\thsv[0] = mHSV[0];\n\t\t\thsv[1] = mHSV[1];\n\t\t\thsv[2] = 1;\n\t\t\tint col = Color.HSVToColor(hsv);\n\n\t\t\tint colors[] = new int[2];\n\t\t\tcolors[0] = col;\n\t\t\tcolors[1] = 0xFF000000;\n\t\t\tGradientDrawable gradDraw = new GradientDrawable(Orientation.TOP_BOTTOM, colors);\n\t\t\tgradDraw.setDither(true);\n\t\t\tgradDraw.setLevel(10000);\n\t\t\tgradDraw.setBounds(0, 0, SLIDER_THICKNESS, PALETTE_DIM);\n\t\t\tgradDraw.draw(mVerSliderCv);\n\t\t}\n\n\t\t/**\n\t\t * Report the correct tightly bounded dimensions of the view.\n\t\t */\n\t\t@Override\n\t\tprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n\t\t\tsetMeasuredDimension(VIEW_DIM_X, VIEW_DIM_Y);\n\t\t}\n\n\t\t/**\n\t\t * Wrap Math.round().  I'm not a Java expert.  Is this the only way to avoid writing \"(int)Math.round\" everywhere?\n\t\t * @param x\n\t\t * @return\n\t\t */\n\t\tprivate int round(double x) {\n\t\t\treturn (int)Math.round(x);\n\t\t}\n\n\t\t/**\n\t\t * Limit a value to the range [0,1].\n\t\t * @param n\n\t\t * @return\n\t\t */\n\t\tprivate float pinToUnit(float n) {\n\t\t\tif (n < 0) {\n\t\t\t\tn = 0;\n\t\t\t} else if (n > 1) {\n\t\t\t\tn = 1;\n\t\t\t}\n\t\t\treturn n;\n\t\t}\n\n\t\t/**\n\t\t * Limit a value to the range [0,max].\n\t\t * @param n\n\t\t * @param max\n\t\t * @return\n\t\t */\n\t\tprivate float pin(float n, float max) {\n\t\t\tif (n < 0) {\n\t\t\t\tn = 0;\n\t\t\t} else if (n > max) {\n\t\t\t\tn = max;\n\t\t\t}\n\t\t\treturn n;\n\t\t}\n\n\t\t/**\n\t\t * Limit a value to the range [min,max].\n\t\t * @param n\n\t\t * @param min\n\t\t * @param max\n\t\t * @return\n\t\t */\n\t\tprivate float pin(float n, float min, float max) {\n\t\t\tif (n < min) {\n\t\t\t\tn = min;\n\t\t\t} else if (n > max) {\n\t\t\t\tn = max;\n\t\t\t}\n\t\t\treturn n;\n\t\t}\n\n\t\t/**\n\t\t * No clue what this does (some sort of average/mean I presume).  It came with the original UberColorPickerDialog\n\t\t * in the API Demos and wasn't documented.  I don't feel like spending any time figuring it out, I haven't looked at it at all.\n\t\t * @param s\n\t\t * @param d\n\t\t * @param p\n\t\t * @return\n\t\t */\n\t\tprivate int ave(int s, int d, float p) {\n\t\t\treturn s + round(p * (d - s));\n\t\t}\n\n\t\t/**\n\t\t * Came with the original UberColorPickerDialog in the API Demos, wasn't documented.  I believe it takes an array of\n\t\t * colors and a value in the range [0,1] and interpolates a resulting color in a seemingly predictable manner.\n\t\t * I haven't looked at it at all.\n\t\t * @param colors\n\t\t * @param unit\n\t\t * @return\n\t\t */\n\t\tprivate int interpColor(int colors[], float unit) {\n\t\t\tif (unit <= 0) {\n\t\t\t\treturn colors[0];\n\t\t\t}\n\t\t\tif (unit >= 1) {\n\t\t\t\treturn colors[colors.length - 1];\n\t\t\t}\n\n\t\t\tfloat p = unit * (colors.length - 1);\n\t\t\tint i = (int)p;\n\t\t\tp -= i;\n\n\t\t\t// now p is just the fractional part [0...1) and i is the index\n\t\t\tint c0 = colors[i];\n\t\t\tint c1 = colors[i+1];\n\t\t\tint a = ave(Color.alpha(c0), Color.alpha(c1), p);\n\t\t\tint r = ave(Color.red(c0), Color.red(c1), p);\n\t\t\tint g = ave(Color.green(c0), Color.green(c1), p);\n\t\t\tint b = ave(Color.blue(c0), Color.blue(c1), p);\n\n\t\t\treturn Color.argb(a, r, g, b);\n\t\t}\n\n\t\t/**\n\t\t * A standard point-in-rect routine.\n\t\t * @param x\n\t\t * @param y\n\t\t * @param r\n\t\t * @return true if point x,y is in rect r\n\t\t */\n\t\tpublic boolean ptInRect(int x, int y, Rect r) {\n\t\t\treturn x > r.left && x < r.right && y > r.top && y < r.bottom;\n\t\t}\n\n\t\t/**\n\t\t * Process trackball events.  Used mainly for fine-tuned color adjustment, or alternatively to switch between slider controls.\n\t\t */\n\t\t@Override\n\t\tpublic boolean dispatchTrackballEvent(MotionEvent event) {\n\t\t\tfloat x = event.getX();\n\t\t\tfloat y = event.getY();\n\n\t\t\t//A longer event history implies faster trackball movement.\n\t\t\t//Use it to infer a larger jump and therefore faster palette/slider adjustment.\n\t\t\tint jump = event.getHistorySize() + 1;\n\n\t\t\tswitch (event.getAction()) {\n\t\t\t\tcase MotionEvent.ACTION_DOWN: {\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase MotionEvent.ACTION_MOVE: {\n\t\t\t\t\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\t\t\t\t\t//To add a new method, replicate and extend the appropriate entry in this list,\n\t\t\t\t\t\t//depending on whether you use 1D or 2D controllers\n\t\t\t\t\t\tswitch (mMethod) {\n\t\t\t\t\t\t\tcase METHOD_HS_V_PALETTE:\n\t\t\t\t\t\t\t\tif (mFocusedControl == 0) {\n\t\t\t\t\t\t\t\t\tchangeHSPalette(x, y, jump);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (mFocusedControl == 1) {\n\t\t\t\t\t\t\t\t\tif (y < 0)\n\t\t\t\t\t\t\t\t\t\tchangeSlider(mFocusedControl, true, jump);\n\t\t\t\t\t\t\t\t\telse if (y > 0)\n\t\t\t\t\t\t\t\t\t\tchangeSlider(mFocusedControl, false, jump);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase MotionEvent.ACTION_UP: {\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\t//To add a new method, replicate and extend the appropriate functions below,\n\t\t//one per UI controller in the new method\n\t\t/**\n\t\t * Effect a trackball change to a 2D palette.\n\t\t * @param x -1: negative x change, 0: no x change, +1: positive x change.\n\t\t * @param y -1: negative y change, 0, no y change, +1: positive y change.\n\t\t * @param jump the amount by which to change.\n\t\t */\n\t\tprivate void changeHSPalette(float x, float y, int jump) {\n\t\t\tint x2 = 0, y2 = 0;\n\t\t\tif (x < 0)\n\t\t\t\tx2 = -jump;\n\t\t\telse if (x > 0)\n\t\t\t\tx2 = jump;\n\t\t\tif (y < 0)\n\t\t\t\ty2 = -jump;\n\t\t\telse if (y > 0)\n\t\t\t\ty2 = jump;\n\n\t\t \tmCoord[0] += x2;\n\t\t \tmCoord[1] += y2;\n\n\t\t \tif (mCoord[0] < -PALETTE_RADIUS)\n\t\t \t\tmCoord[0] = -PALETTE_RADIUS;\n\t\t \telse if (mCoord[0] > PALETTE_RADIUS)\n\t\t \t\tmCoord[0] = PALETTE_RADIUS;\n\t\t \tif (mCoord[1] < -PALETTE_RADIUS)\n\t\t \t\tmCoord[1] = -PALETTE_RADIUS;\n\t\t \telse if (mCoord[1] > PALETTE_RADIUS)\n\t\t \t\tmCoord[1] = PALETTE_RADIUS;\n\n\t\t\tfloat radius = (float)java.lang.Math.sqrt(mCoord[0] * mCoord[0] + mCoord[1] * mCoord[1]);\n\t\t\tif (radius > PALETTE_RADIUS)\n\t\t\t\tradius = PALETTE_RADIUS;\n\n\t\t\tfloat angle = (float)java.lang.Math.atan2(mCoord[1], mCoord[0]);\n\t\t\t// need to turn angle [-PI ... PI] into unit [0....1]\n\t\t\tfloat unit = angle/(2*PI);\n\t\t\tif (unit < 0) {\n\t\t\t\tunit += 1;\n\t\t\t}\n\n\t\t\tmCoord[0] = round(Math.cos(angle) * radius);\n\t\t\tmCoord[1] = round(Math.sin(angle) * radius);\n\n\t\t\tint c = interpColor(mSpectrumColorsRev, unit);\n\t\t\tfloat[] hsv = new float[3];\n\t\t\tColor.colorToHSV(c, hsv);\n\t\t\tmHSV[0] = hsv[0];\n\t\t\tmHSV[1] = radius / PALETTE_RADIUS;\n\t\t\tupdateAllFromHSV();\n\t\t\tmSwatchNew.setColor(Color.HSVToColor(mHSV));\n\n\t\t\tsetVerValSlider();\n\n\t\t\tinvalidate();\n\t\t}\n\n\t\t/**\n\t\t * Effect a trackball change to a 1D slider.\n\t\t * @param slider id of the slider to be effected\n\t\t * @param increase true if the change is an increase, false if a decrease\n\t\t * @param jump the amount by which to change in units of the range [0,255]\n\t\t */\n\t\tprivate void changeSlider(int slider, boolean increase, int jump) {\n\t\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\t\t//It is only necessary to add an entry here for a new method if the new method uses a 1D slider.\n\t\t\t//Note, some sliders are horizontal and others are vertical.\n\t\t\t//They differ a bit, especially in a sign flip on the vertical axis.\n\t\t\tif (mMethod == METHOD_HS_V_PALETTE) {\n\t\t\t\t//slider *must* equal 1\n\n\t\t\t\tmHSV[2] += (increase ? jump : -jump) / 256.0f;\n\t\t\t\tmHSV[2] = pinToUnit(mHSV[2]);\n\t\t\t\tupdateAllFromHSV();\n\t\t\t\tmCoord[2] = PALETTE_DIM - (int)(mHSV[2] * PALETTE_DIM);\n\n\t\t\t\tmSwatchNew.setColor(Color.HSVToColor(mHSV));\n\n\t\t\t\tsetOvalValDimmer();\n\n\t\t\t\tinvalidate();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Keep all colorspace representations in sync.\n\t\t */\n\t\tprivate void updateRGBfromHSV() {\n\t\t\tint color = Color.HSVToColor(mHSV);\n\t\t\tmRGB[0] = Color.red(color);\n\t\t\tmRGB[1] = Color.green(color);\n\t\t\tmRGB[2] = Color.blue(color);\n\t\t}\n\n\t\t/**\n\t\t * Keep all colorspace representations in sync.\n\t\t */\n\t\tprivate void updateYUVfromRGB() {\n\t\t\tfloat r = mRGB[0] / 255.0f;\n\t\t\tfloat g = mRGB[1] / 255.0f;\n\t\t\tfloat b = mRGB[2] / 255.0f;\n\n\t\t\tColorMatrix cm = new ColorMatrix();\n\t\t\tcm.setRGB2YUV();\n\t\t\tfinal float[] a = cm.getArray();\n\n\t\t\tmYUV[0] = a[0] * r + a[1] * g + a[2] * b;\n\t\t\tmYUV[0] = pinToUnit(mYUV[0]);\n\t\t\tmYUV[1] = a[5] * r + a[6] * g + a[7] * b;\n\t\t\tmYUV[1] = pin(mYUV[1], -.5f, .5f);\n\t\t\tmYUV[2] = a[10] * r + a[11] * g + a[12] * b;\n\t\t\tmYUV[2] = pin(mYUV[2], -.5f, .5f);\n\t\t}\n\n\t\t/**\n\t\t * Keep all colorspace representations in sync.\n\t\t */\n\t\tprivate void updateHexFromHSV() {\n\t\t\t//For now, assume 100% opacity\n\t\t\tmHexStr = Integer.toHexString(Color.HSVToColor(mHSV)).toUpperCase();\n\t\t\tmHexStr = mHexStr.substring(2, mHexStr.length());\n\t\t}\n\n\t\t/**\n\t\t * Keep all colorspace representations in sync.\n\t\t */\n\t\tprivate void updateAllFromHSV() {\n\t\t\t//Update mRGB\n\t\t\tif (mRGBenabled || mYUVenabled)\n\t\t\t\tupdateRGBfromHSV();\n\n\t\t\t//Update mYUV\n\t\t\tif (mYUVenabled)\n\t\t\t\tupdateYUVfromRGB();\n\n\t\t\t//Update mHexStr\n\t\t\tif (mRGBenabled)\n\t\t\t\tupdateHexFromHSV();\n\t\t}\n\n\t\t/**\n\t\t * Process touch events: down, move, and up\n\t\t */\n\t\t@Override\n\t\tpublic boolean onTouchEvent(MotionEvent event) {\n\t\t\tfloat x = event.getX();\n\t\t\tfloat y = event.getY();\n\n\t\t\t//Generate coordinates which are palette=local with the origin at the upper left of the main 2D palette\n\t\t\tint y2 = (int)(pin(round(y - PALETTE_POS_Y), PALETTE_DIM));\n\n\t\t\t//Generate coordinates which are palette-local with the origin at the center of the main 2D palette\n\t\t\tfloat circlePinnedX = x - PALETTE_POS_X - PALETTE_CENTER_X;\n\t\t\tfloat circlePinnedY = y - PALETTE_POS_Y - PALETTE_CENTER_Y;\n\n\t\t\t//Is the event in a swatch?\n\t\t\tboolean inSwatchOld = ptInRect(round(x), round(y), mOldSwatchRect);\n\t\t\tboolean inSwatchNew = ptInRect(round(x), round(y), mNewSwatchRect);\n\n\t\t\t//Get the event's distance from the center of the main 2D palette\n\t\t\tfloat radius = (float)java.lang.Math.sqrt(circlePinnedX * circlePinnedX + circlePinnedY * circlePinnedY);\n\n\t\t\t//Is the event in a circle-pinned 2D palette?\n\t\t\tboolean inOvalPalette = radius <= PALETTE_RADIUS;\n\n\t\t\t//Pin the radius\n\t\t\tif (radius > PALETTE_RADIUS)\n\t\t\t\tradius = PALETTE_RADIUS;\n\n\t\t\t//Is the event in a vertical slider to the right of the main 2D palette\n\t\t\tboolean inVerSlider = ptInRect(round(x), round(y), mVerSliderRect);\n\n\t\t\tswitch (event.getAction()) {\n\t\t\t\tcase MotionEvent.ACTION_DOWN:\n\t\t\t\t\tmTracking = TRACKED_NONE;\n\n\t\t\t\t\tif (inSwatchOld)\n\t\t\t\t\t\tmTracking = TRACK_SWATCH_OLD;\n\t\t\t\t\telse if (inSwatchNew)\n\t\t\t\t\t\tmTracking = TRACK_SWATCH_NEW;\n\n\t\t\t\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\t\t\t\t//To add a new method, replicate and extend the last entry in this list\n\t\t\t\t\telse if (mMethod == METHOD_HS_V_PALETTE) {\n\t\t\t\t\t\tif (inOvalPalette) {\n\t\t\t\t\t\t\tmTracking = TRACK_HS_PALETTE;\n\t\t\t\t\t\t\tmFocusedControl = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (inVerSlider) {\n\t\t\t\t\t\t\tmTracking = TRACK_VER_VALUE_SLIDER;\n\t\t\t\t\t\t\tmFocusedControl = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tcase MotionEvent.ACTION_MOVE:\n\t\t\t\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\t\t\t\t//To add a new method, replicate and extend the entries in this list,\n\t\t\t\t\t//one per UI controller the new method requires.\n\t\t\t\t\tif (mTracking == TRACK_HS_PALETTE) {\n\t\t\t\t\t\tfloat angle = (float)java.lang.Math.atan2(circlePinnedY, circlePinnedX);\n\t\t\t\t\t\t// need to turn angle [-PI ... PI] into unit [0....1]\n\t\t\t\t\t\tfloat unit = angle/(2*PI);\n\t\t\t\t\t\tif (unit < 0) {\n\t\t\t\t\t\t\tunit += 1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmCoord[0] = round(Math.cos(angle) * radius);\n\t\t\t\t\t\tmCoord[1] = round(Math.sin(angle) * radius);\n\n\t\t\t\t\t\tint c = interpColor(mSpectrumColorsRev, unit);\n\t\t\t\t\t\tfloat[] hsv = new float[3];\n\t\t\t\t\t\tColor.colorToHSV(c, hsv);\n\t\t\t\t\t\tmHSV[0] = hsv[0];\n\t\t\t\t\t\tmHSV[1] = radius / PALETTE_RADIUS;\n\t\t\t\t\t\tupdateAllFromHSV();\n\t\t\t\t\t\tmSwatchNew.setColor(Color.HSVToColor(mHSV));\n\n\t\t\t\t\t\tsetVerValSlider();\n\n\t\t\t\t\t\tinvalidate();\n\t\t\t\t\t}\n\t\t\t\t\telse if (mTracking == TRACK_VER_VALUE_SLIDER) {\n\t\t\t\t\t\tif (mCoord[2] != y2) {\n\t\t\t\t\t\t\tmCoord[2] = y2;\n\t\t\t\t\t\t\tfloat value = 1.0f - (float)y2 / (float)PALETTE_DIM;\n\n\t\t\t\t\t\t\tmHSV[2] = value;\n\t\t\t\t\t\t\tupdateAllFromHSV();\n\t\t\t\t\t\t\tmSwatchNew.setColor(Color.HSVToColor(mHSV));\n\n\t\t\t\t\t\t\tsetOvalValDimmer();\n\n\t\t\t\t\t\t\tinvalidate();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase MotionEvent.ACTION_UP:\n\t\t\t\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\t\t\t\t//To add a new method, replicate and extend the last entry in this list.\n\t\t\t\t\tif (mTracking == TRACK_SWATCH_OLD && inSwatchOld) {\n\t\t\t\t\t\tColor.colorToHSV(mOriginalColor, mHSV);\n\t\t\t\t\t\tmSwatchNew.setColor(mOriginalColor);\n\t\t\t\t\t\tinitUI();\n\t\t\t\t\t\tinvalidate();\n\t\t\t\t\t}\n\t\t\t\t\telse if (mTracking == TRACK_SWATCH_NEW && inSwatchNew) {\n\t\t\t\t\t\tmListener.colorChanged(mSwatchNew.getColor());\n\t\t\t\t\t\tinvalidate();\n\t\t\t\t\t}\n\n\t\t\t\t\tmTracking= TRACKED_NONE;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t}\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * 090408\n * Keith Wiley\n * kwiley@keithwiley.com\n * http://keithwiley.com\n *\n * UberColorPickerDialog v1.1\n *\n * This color picker was implemented as a (significant) extension of the\n * ColorPickerDialog class provided in the Android API Demos.  You are free\n * to drop it unchanged into your own projects or to modify it as you see\n * fit.  I would appreciate it if this comment block were let intact,\n * merely for credit's sake.\n *\n * Enjoy!\n */\n\npackage org.connectbot.util;\n\nimport org.connectbot.R;\n\nimport android.app.Dialog;\nimport android.content.Context;\nimport android.graphics.Bitmap;\nimport android.graphics.Canvas;\nimport android.graphics.Color;\nimport android.graphics.ColorMatrix;\nimport android.graphics.ComposeShader;\nimport android.graphics.Paint;\nimport android.graphics.PorterDuff;\nimport android.graphics.PorterDuffXfermode;\nimport android.graphics.RadialGradient;\nimport android.graphics.Rect;\nimport android.graphics.RectF;\nimport android.graphics.Shader;\nimport android.graphics.SweepGradient;\nimport android.graphics.drawable.GradientDrawable;\nimport android.graphics.drawable.GradientDrawable.Orientation;\nimport android.os.Bundle;\nimport android.util.DisplayMetrics;\nimport android.view.MotionEvent;\nimport android.view.View;\n\n/**\n * UberColorPickerDialog is a seriously enhanced version of the UberColorPickerDialog\n * class provided in the Android API Demos.<p>\n *\n * NOTE (from Kenny Root): This is a VERY slimmed down version custom for ConnectBot.\n * Visit Keith's site for the full version at the URL listed in the author line.<p>\n *\n * @author Keith Wiley, kwiley@keithwiley.com, http://keithwiley.com\n */\npublic class UberColorPickerDialog extends Dialog {\n\tprivate final OnColorChangedListener mListener;\n\tprivate final int mInitialColor;\n\n\t/**\n\t * Callback to the creator of the dialog, informing the creator of a new color and notifying that the dialog is about to dismiss.\n\t */\n\tpublic interface OnColorChangedListener {\n\t\tvoid colorChanged(int color);\n\t}\n\n\t/**\n\t * Ctor\n\t * @param context\n\t * @param listener\n\t * @param initialColor\n\t */\n\tpublic UberColorPickerDialog(Context context,\n\t\t\t\t\t\t\tOnColorChangedListener listener,\n\t\t\t\t\t\t\tint initialColor) {\n\t\tsuper(context);\n\n\t\tmListener = listener;\n\t\tmInitialColor = initialColor;\n\t}\n\n\t/**\n\t * Activity entry point\n\t */\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tOnColorChangedListener l = new OnColorChangedListener() {\n\t\t\tpublic void colorChanged(int color) {\n\t\t\t\tmListener.colorChanged(color);\n\t\t\t\tdismiss();\n\t\t\t}\n\t\t};\n\n\t\tDisplayMetrics dm = new DisplayMetrics();\n\t\tgetWindow().getWindowManager().getDefaultDisplay().getMetrics(dm);\n\t\tint screenWidth = dm.widthPixels;\n\t\tint screenHeight = dm.heightPixels;\n\n\t\tsetTitle(getContext().getResources().getString(R.string.title_color_picker));\n\n\t\ttry {\n\t\t\tsetContentView(new ColorPickerView(getContext(), l, screenWidth, screenHeight, mInitialColor));\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t//There is currently only one kind of ctor exception, that where no methods are enabled.\n\t\t\tdismiss();\t//This doesn't work!  The dialog is still shown (its title at least, the layout is empty from the exception being thrown).  <sigh>\n\t\t}\n\t}\n\n\t/**\n\t * ColorPickerView is the meat of this color picker (as opposed to the enclosing class).\n\t * All the heavy lifting is done directly by this View subclass.\n\t * <P>\n\t * You can enable/disable whichever color chooser methods you want by modifying the ENABLED_METHODS switches.  They *should*\n\t * do all the work required to properly enable/disable methods without losing track of what goes with what and what maps to what.\n\t * <P>\n\t * If you add a new color chooser method, do a text search for \"NEW_METHOD_WORK_NEEDED_HERE\".  That tag indicates all\n\t * the locations in the code that will have to be amended in order to properly add a new color chooser method.\n\t * I highly recommend adding new methods to the end of the list.  If you want to try to reorder the list, you're on your own.\n\t */\n\tprivate static class ColorPickerView extends View {\n\t\tprivate static int SWATCH_WIDTH_PORTRAIT_DP = 95;\n\t\tprivate static int SWATCH_WIDTH_LANDSCAPE_DP = 110;\n\t\tprivate static final int SWATCH_HEIGHT_DP = 60;\n\n\t\tprivate static final int PALETTE_DIM_DP = SWATCH_WIDTH_PORTRAIT_DP * 2;\n\n\t\tprivate static final int SLIDER_THICKNESS_DP = 40;\n\n\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\tprivate static final int METHOD_HS_V_PALETTE = 0;\n\n\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\t//Add a new entry to the list for each controller in the new method\n\t\tprivate static final int TRACKED_NONE = -1;\t//No object on screen is currently being tracked\n\t\tprivate static final int TRACK_SWATCH_OLD = 10;\n\t\tprivate static final int TRACK_SWATCH_NEW = 11;\n\t\tprivate static final int TRACK_HS_PALETTE = 30;\n\t\tprivate static final int TRACK_VER_VALUE_SLIDER = 31;\n\n\t\tprivate static final int TEXT_SIZE_DP = 12;\n\t\tprivate static final int TEXT_SIZE_LABEL_DP = 12;\n\n\t\tprivate static final int BUTTON_TEXT_MARGIN_DP = 16;\n\n\t\tprivate static int[] TEXT_HSV_POS = new int[2];\n\t\tprivate static int[] TEXT_RGB_POS = new int[2];\n\t\tprivate static int[] TEXT_YUV_POS = new int[2];\n\t\tprivate static int[] TEXT_HEX_POS = new int[2];\n\n\t\tprivate static final float PI = 3.141592653589793f;\n\n\t\tprivate final int mSwatchWidthPx;\n\t\tprivate final int mTextSizePx;\n\t\tprivate final int mTextSizeLabelPx;\n\t\tprivate final int mPalettePosX;\n\t\tprivate final int mPalettePosY;\n\t\tprivate final int mPaletteDimPx;\n\t\tprivate final int mPaletteRadiusPx;\n\t\tprivate final int mSliderThicknessPx;\n\t\tprivate final int mViewDimXPx;\n\t\tprivate final int mViewDimYPx;\n\t\tprivate final int mPaletteCenterPx;\n\t\tprivate final int mButtonTextMarginPx;\n\n\t\tprivate int mMethod = METHOD_HS_V_PALETTE;\n\t\tprivate int mTracking = TRACKED_NONE;\t//What object on screen is currently being tracked for movement\n\n\t\t//Zillions of persistant Paint objecs for drawing the View\n\n\t\tprivate Paint mSwatchOld, mSwatchNew;\n\n\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\t//Add Paints to represent the palettes of the new method's UI controllers\n\t\tprivate Paint mOvalHueSat;\n\n\t\tprivate Bitmap mVerSliderBM;\n\t\tprivate Canvas mVerSliderCv;\n\n\t\tprivate Bitmap[] mHorSlidersBM = new Bitmap[3];\n\t\tprivate Canvas[] mHorSlidersCv = new Canvas[3];\n\n\t\tprivate Paint mValDimmer;\n\n\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\t//Add Paints to represent the icon for the new method\n\t\tprivate Paint mOvalHueSatSmall;\n\n\t\tprivate Paint mPosMarker;\n\t\tprivate Paint mText;\n\n\t\tprivate Rect mOldSwatchRect = new Rect();\n\t\tprivate Rect mNewSwatchRect = new Rect();\n\t\tprivate Rect mPaletteRect = new Rect();\n\t\tprivate Rect mVerSliderRect = new Rect();\n\n\t\tprivate int[] mSpectrumColorsRev;\n\t\tprivate int mOriginalColor = 0;\t//The color passed in at the beginning, which can be reverted to at any time by tapping the old swatch.\n\t\tprivate float[] mHSV = new float[3];\n\t\tprivate int[] mRGB = new int[3];\n\t\tprivate float[] mYUV = new float[3];\n\t\tprivate String mHexStr = \"\";\n\t\tprivate boolean mHSVenabled = true;\t//Only true if an HSV method is enabled\n\t\tprivate boolean mRGBenabled = true;\t//Only true if an RGB method is enabled\n\t\tprivate boolean mYUVenabled = true;\t//Only true if a YUV method is enabled\n\t\tprivate boolean mHexenabled = true;\t//Only true if an RGB method is enabled\n\t\tprivate int[] mCoord = new int[3];\t\t//For drawing slider/palette markers\n\t\tprivate int mFocusedControl = -1;\t//Which control receives trackball events.\n\t\tprivate OnColorChangedListener mListener;\n\n\t\t/**\n\t\t * Ctor.\n\t\t * @param c\n\t\t * @param l\n\t\t * @param width Used to determine orientation and adjust layout accordingly\n\t\t * @param height Used to determine orientation and adjust layout accordingly\n\t\t * @param color The initial color\n\t\t * @throws Exception\n\t\t */\n\t\tColorPickerView(Context c, OnColorChangedListener l, int width, int height, int color)\n\t\tthrows Exception {\n\t\t\tsuper(c);\n\n\t\t\tDisplayMetrics metrics = c.getResources().getDisplayMetrics();\n\t\t\tmTextSizePx = (int) (TEXT_SIZE_DP * metrics.density + 0.5f);\n\t\t\tmTextSizeLabelPx = (int) (TEXT_SIZE_LABEL_DP * metrics.density + 0.5f);\n\n\t\t\t//We need to make the dialog focusable to retrieve trackball events.\n\t\t\tsetFocusable(true);\n\n\t\t\tmListener = l;\n\n\t\t\tmOriginalColor = color;\n\n\t\t\tColor.colorToHSV(color, mHSV);\n\n\t\t\tupdateAllFromHSV();\n\n\t\t\tmPaletteDimPx = (int) (PALETTE_DIM_DP * metrics.density + 0.5f);\n\t\t\tmSliderThicknessPx = (int) (SLIDER_THICKNESS_DP * metrics.density + 0.5f);\n\t\t\tmButtonTextMarginPx = (int) (BUTTON_TEXT_MARGIN_DP * metrics.density + 0.5f);\n\n\t\t\t//Setup the layout based on whether this is a portrait or landscape orientation.\n\t\t\tif (width <= height) {        //Portrait layout\n\t\t\t\tmSwatchWidthPx = (int) (((PALETTE_DIM_DP + SLIDER_THICKNESS_DP) / 2) * metrics.density + 0.5f);\n\t\t\t\tfinal int swatchHeightPx = (int) (SWATCH_HEIGHT_DP * metrics.density + 0.5f);\n\n\t\t\t\tmPalettePosX = 0;\n\t\t\t\tmPalettePosY = mTextSizePx * 4 + swatchHeightPx;\n\n\t\t\t\t//Set more rects, lots of rects\n\t\t\t\tmOldSwatchRect.set(0, mTextSizePx * 4, mSwatchWidthPx, mTextSizePx * 4 + swatchHeightPx);\n\t\t\t\tmNewSwatchRect.set(mSwatchWidthPx, mTextSizePx * 4, mSwatchWidthPx * 2, mTextSizePx * 4 + swatchHeightPx);\n\t\t\t\tmPaletteRect.set(0, mPalettePosY, mPaletteDimPx, mPalettePosY + mPaletteDimPx);\n\t\t\t\tmVerSliderRect.set(mPaletteDimPx, mPalettePosY, mPaletteDimPx + mSliderThicknessPx, mPalettePosY + mPaletteDimPx);\n\n\t\t\t\tTEXT_HSV_POS[0] = (int) (3 * metrics.density + 0.5f);\n\t\t\t\tTEXT_HSV_POS[1] = 0;\n\t\t\t\tTEXT_RGB_POS[0] = TEXT_HSV_POS[0] + (int) (50 * metrics.density + 0.5f);\n\t\t\t\tTEXT_RGB_POS[1] = TEXT_HSV_POS[1];\n\t\t\t\tTEXT_YUV_POS[0] = TEXT_HSV_POS[0] + (int) (100 * metrics.density + 0.5f);\n\t\t\t\tTEXT_YUV_POS[1] = TEXT_HSV_POS[1];\n\t\t\t\tTEXT_HEX_POS[0] = TEXT_HSV_POS[0] + (int) (150 * metrics.density + 0.5f);\n\t\t\t\tTEXT_HEX_POS[1] = TEXT_HSV_POS[1];\n\n\t\t\t\tmViewDimXPx = mPaletteDimPx + mSliderThicknessPx;\n\t\t\t\tmViewDimYPx = swatchHeightPx + mPaletteDimPx + mTextSizePx * 4;\n\t\t\t} else {        //Landscape layout\n\t\t\t\tmSwatchWidthPx = (int) (SWATCH_WIDTH_LANDSCAPE_DP * metrics.density + 0.5f);\n\t\t\t\tfinal int swatchHeightPx = (int) (SWATCH_HEIGHT_DP * metrics.density + 0.5f);\n\n\t\t\t\tmPalettePosX = mSwatchWidthPx;\n\t\t\t\tmPalettePosY = 0;\n\n\t\t\t\t//Set more rects, lots of rects\n\t\t\t\tmOldSwatchRect.set(0, mTextSizePx * 7, mSwatchWidthPx, mTextSizePx * 7 + swatchHeightPx);\n\t\t\t\tmNewSwatchRect.set(0, mTextSizePx * 7 + mSliderThicknessPx, mSwatchWidthPx, mTextSizePx * 7 + swatchHeightPx * 2);\n\t\t\t\tmPaletteRect.set(mSwatchWidthPx, mPalettePosY, mSwatchWidthPx + mPaletteDimPx, mPalettePosY + mPaletteDimPx);\n\t\t\t\tmVerSliderRect.set(mSwatchWidthPx + mPaletteDimPx, mPalettePosY, mSwatchWidthPx + mPaletteDimPx + mSliderThicknessPx, mPalettePosY + mPaletteDimPx);\n\n\t\t\t\tTEXT_HSV_POS[0] = (int) (3 * metrics.density + 0.5f);\n\t\t\t\tTEXT_HSV_POS[1] = 0;\n\t\t\t\tTEXT_RGB_POS[0] = TEXT_HSV_POS[0];\n\t\t\t\tTEXT_RGB_POS[1] = (int) (TEXT_HSV_POS[1] + mTextSizePx * 3.5);\n\t\t\t\tTEXT_YUV_POS[0] = TEXT_HSV_POS[0] + (int) (50 * metrics.density + 0.5f);\n\t\t\t\tTEXT_YUV_POS[1] = (int) (TEXT_HSV_POS[1] + mTextSizePx * 3.5);\n\t\t\t\tTEXT_HEX_POS[0] = TEXT_HSV_POS[0] + (int) (50 * metrics.density + 0.5f);\n\t\t\t\tTEXT_HEX_POS[1] = TEXT_HSV_POS[1];\n\n\t\t\t\tmViewDimXPx = mPalettePosX + mPaletteDimPx + mSliderThicknessPx;\n\t\t\t\tmViewDimYPx = Math.max(mNewSwatchRect.bottom, mPaletteDimPx);\n\t\t\t}\n\n\t\t\tmPaletteCenterPx = mPaletteDimPx / 2;\n\t\t\tmPaletteRadiusPx = mPaletteDimPx / 2;\n\n\t\t\t//Rainbows make everybody happy!\n\t\t\tmSpectrumColorsRev = new int[] {\n\t\t\t\t0xFFFF0000, 0xFFFF00FF, 0xFF0000FF, 0xFF00FFFF,\n\t\t\t\t0xFF00FF00, 0xFFFFFF00, 0xFFFF0000,\n\t\t\t};\n\n\t\t\t//Setup all the Paint and Shader objects.  There are lots of them!\n\n\t\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\t\t//Add Paints to represent the palettes of the new method's UI controllers\n\n\t\t\tmSwatchOld = new Paint(Paint.ANTI_ALIAS_FLAG);\n\t\t\tmSwatchOld.setStyle(Paint.Style.FILL);\n\t\t\tmSwatchOld.setColor(Color.HSVToColor(mHSV));\n\n\t\t\tmSwatchNew = new Paint(Paint.ANTI_ALIAS_FLAG);\n\t\t\tmSwatchNew.setStyle(Paint.Style.FILL);\n\t\t\tmSwatchNew.setColor(Color.HSVToColor(mHSV));\n\n\t\t\tShader shaderA = new SweepGradient(0, 0, mSpectrumColorsRev, null);\n\t\t\tShader shaderB = new RadialGradient(0, 0, mPaletteCenterPx, 0xFFFFFFFF, 0xFF000000, Shader.TileMode.CLAMP);\n\t\t\tShader shader = new ComposeShader(shaderA, shaderB, PorterDuff.Mode.SCREEN);\n\t\t\tmOvalHueSat = new Paint(Paint.ANTI_ALIAS_FLAG);\n\t\t\tmOvalHueSat.setShader(shader);\n\t\t\tmOvalHueSat.setStyle(Paint.Style.FILL);\n\t\t\tmOvalHueSat.setDither(true);\n\n\t\t\tmVerSliderBM = Bitmap.createBitmap(mSliderThicknessPx, mPaletteDimPx, Bitmap.Config.RGB_565);\n\t\t\tmVerSliderCv = new Canvas(mVerSliderBM);\n\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tmHorSlidersBM[i] = Bitmap.createBitmap(mPaletteDimPx, mSliderThicknessPx, Bitmap.Config.RGB_565);\n\t\t\t\tmHorSlidersCv[i] = new Canvas(mHorSlidersBM[i]);\n\t\t\t}\n\n\t\t\tmValDimmer = new Paint(Paint.ANTI_ALIAS_FLAG);\n\t\t\tmValDimmer.setStyle(Paint.Style.FILL);\n\t\t\tmValDimmer.setDither(true);\n\t\t\tmValDimmer.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.MULTIPLY));\n\n\t\t\t//Whew, we're done making the big Paints and Shaders for the swatches, palettes, and sliders.\n\t\t\t//Now we need to make the Paints and Shaders that will draw the little method icons in the method selector list.\n\n\t\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\t\t//Add Paints to represent the icon for the new method\n\n\t\t\tshaderA = new SweepGradient(0, 0, mSpectrumColorsRev, null);\n\t\t\tshaderB = new RadialGradient(0, 0, mPaletteDimPx / 2, 0xFFFFFFFF, 0xFF000000, Shader.TileMode.CLAMP);\n\t\t\tshader = new ComposeShader(shaderA, shaderB, PorterDuff.Mode.SCREEN);\n\t\t\tmOvalHueSatSmall = new Paint(Paint.ANTI_ALIAS_FLAG);\n\t\t\tmOvalHueSatSmall.setShader(shader);\n\t\t\tmOvalHueSatSmall.setStyle(Paint.Style.FILL);\n\n\t\t\t//Make a simple stroking Paint for drawing markers and borders and stuff like that.\n\t\t\tmPosMarker = new Paint(Paint.ANTI_ALIAS_FLAG);\n\t\t\tmPosMarker.setStyle(Paint.Style.STROKE);\n\t\t\tmPosMarker.setStrokeWidth(2);\n\n\t\t\t//Make a basic text Paint.\n\t\t\tmText = new Paint(Paint.ANTI_ALIAS_FLAG);\n\t\t\tmText.setTextSize(mTextSizePx);\n\t\t\tmText.setColor(Color.WHITE);\n\n\t\t\t//Kickstart\n\t\t\tinitUI();\n\t\t}\n\n\t\t/**\n\t\t * Draw the entire view (the entire dialog).\n\t\t */\n\t\t@Override\n\t\tprotected void onDraw(Canvas canvas) {\n\t\t\t//Draw the old and new swatches\n\t\t\tdrawSwatches(canvas);\n\n\t\t\t//Write the text\n\t\t\twriteColorParams(canvas);\n\n\t\t\t//Draw the palette and sliders (the UI)\n\t\t\tif (mMethod == METHOD_HS_V_PALETTE)\n\t\t\t\tdrawHSV1Palette(canvas);\n\t\t}\n\n\t\t/**\n\t\t * Draw the old and new swatches.\n\t\t * @param canvas\n\t\t */\n\t\tprivate void drawSwatches(Canvas canvas) {\n\t\t\tfloat[] hsv = new float[3];\n\n\t\t\tmText.setTextSize(mTextSizePx);\n\n\t\t\t//Draw the original swatch\n\t\t\tcanvas.drawRect(mOldSwatchRect, mSwatchOld);\n\t\t\tColor.colorToHSV(mOriginalColor, hsv);\n\t\t\t//if (UberColorPickerDialog.isGray(mColor))\t//Don't need this right here, but imp't to note\n\t\t\t//\thsv[1] = 0;\n\t\t\tif (hsv[2] > .5)\n\t\t\t\tmText.setColor(Color.BLACK);\n\t\t\tcanvas.drawText(\"Revert\", mOldSwatchRect.left + mSwatchWidthPx / 2 - mText.measureText(\"Revert\") / 2, mOldSwatchRect.top + mButtonTextMarginPx, mText);\n\t\t\tmText.setColor(Color.WHITE);\n\n\t\t\t//Draw the new swatch\n\t\t\tcanvas.drawRect(mNewSwatchRect, mSwatchNew);\n\t\t\tif (mHSV[2] > .5)\n\t\t\t\tmText.setColor(Color.BLACK);\n\t\t\tcanvas.drawText(\"Accept\", mNewSwatchRect.left + mSwatchWidthPx / 2 - mText.measureText(\"Accept\") / 2, mNewSwatchRect.top + mButtonTextMarginPx, mText);\n\t\t\tmText.setColor(Color.WHITE);\n\n\t\t\tmText.setTextSize(mTextSizePx);\n\t\t}\n\n\t\t/**\n\t\t * Write the color parametes (HSV, RGB, YUV, Hex, etc.).\n\t\t * @param canvas\n\t\t */\n\t\tprivate void writeColorParams(Canvas canvas) {\n\t\t\tif (mHSVenabled) {\n\t\t\t\tcanvas.drawText(\"H: \" + Integer.toString((int) (mHSV[0] / 360.0f * 255)), TEXT_HSV_POS[0], TEXT_HSV_POS[1] + mTextSizePx, mText);\n\t\t\t\tcanvas.drawText(\"S: \" + Integer.toString((int) (mHSV[1] * 255)), TEXT_HSV_POS[0], TEXT_HSV_POS[1] + mTextSizePx * 2, mText);\n\t\t\t\tcanvas.drawText(\"V: \" + Integer.toString((int) (mHSV[2] * 255)), TEXT_HSV_POS[0], TEXT_HSV_POS[1] + mTextSizePx * 3, mText);\n\t\t\t}\n\n\t\t\tif (mRGBenabled) {\n\t\t\t\tcanvas.drawText(\"R: \" + mRGB[0], TEXT_RGB_POS[0], TEXT_RGB_POS[1] + mTextSizePx, mText);\n\t\t\t\tcanvas.drawText(\"G: \" + mRGB[1], TEXT_RGB_POS[0], TEXT_RGB_POS[1] + mTextSizePx * 2, mText);\n\t\t\t\tcanvas.drawText(\"B: \" + mRGB[2], TEXT_RGB_POS[0], TEXT_RGB_POS[1] + mTextSizePx * 3, mText);\n\t\t\t}\n\n\t\t\tif (mYUVenabled) {\n\t\t\t\tcanvas.drawText(\"Y: \" + Integer.toString((int) (mYUV[0] * 255)), TEXT_YUV_POS[0], TEXT_YUV_POS[1] + mTextSizePx, mText);\n\t\t\t\tcanvas.drawText(\"U: \" + Integer.toString((int) ((mYUV[1] + .5f) * 255)), TEXT_YUV_POS[0], TEXT_YUV_POS[1] + mTextSizePx * 2, mText);\n\t\t\t\tcanvas.drawText(\"V: \" + Integer.toString((int) ((mYUV[2] + .5f) * 255)), TEXT_YUV_POS[0], TEXT_YUV_POS[1] + mTextSizePx * 3, mText);\n\t\t\t}\n\n\t\t\tif (mHexenabled)\n\t\t\t\tcanvas.drawText(\"#\" + mHexStr, TEXT_HEX_POS[0], TEXT_HEX_POS[1] + mTextSizePx, mText);\n\t\t}\n\n\t\t/**\n\t\t * Place a small circle on the 2D palette to indicate the current values.\n\t\t * @param canvas\n\t\t * @param markerPosX\n\t\t * @param markerPosY\n\t\t */\n\t\tprivate void mark2DPalette(Canvas canvas, int markerPosX, int markerPosY) {\n\t\t\tmPosMarker.setColor(Color.BLACK);\n\t\t\tcanvas.drawOval(new RectF(markerPosX - 5, markerPosY - 5, markerPosX + 5, markerPosY + 5), mPosMarker);\n\t\t\tmPosMarker.setColor(Color.WHITE);\n\t\t\tcanvas.drawOval(new RectF(markerPosX - 3, markerPosY - 3, markerPosX + 3, markerPosY + 3), mPosMarker);\n\t\t}\n\n\t\t/**\n\t\t * Draw a line across the slider to indicate its current value.\n\t\t * @param canvas\n\t\t * @param markerPos\n\t\t */\n\t\tprivate void markVerSlider(Canvas canvas, int markerPos) {\n\t\t\tmPosMarker.setColor(Color.BLACK);\n\t\t\tcanvas.drawRect(new Rect(0, markerPos - 2, mSliderThicknessPx, markerPos + 3), mPosMarker);\n\t\t\tmPosMarker.setColor(Color.WHITE);\n\t\t\tcanvas.drawRect(new Rect(0, markerPos, mSliderThicknessPx, markerPos + 1), mPosMarker);\n\t\t}\n\n\t\t/**\n\t\t * Frame the slider to indicate that it has trackball focus.\n\t\t * @param canvas\n\t\t */\n\t\tprivate void hilightFocusedVerSlider(Canvas canvas) {\n\t\t\tmPosMarker.setColor(Color.WHITE);\n\t\t\tcanvas.drawRect(new Rect(0, 0, mSliderThicknessPx, mPaletteDimPx), mPosMarker);\n\t\t\tmPosMarker.setColor(Color.BLACK);\n\t\t\tcanvas.drawRect(new Rect(2, 2, mSliderThicknessPx - 2, mPaletteDimPx - 2), mPosMarker);\n\t\t}\n\n\t\t/**\n\t\t * Frame the 2D palette to indicate that it has trackball focus.\n\t\t * @param canvas\n\t\t */\n\t\tprivate void hilightFocusedOvalPalette(Canvas canvas) {\n\t\t\tmPosMarker.setColor(Color.WHITE);\n\t\t\tcanvas.drawOval(new RectF(-mPaletteRadiusPx, -mPaletteRadiusPx, mPaletteRadiusPx, mPaletteRadiusPx), mPosMarker);\n\t\t\tmPosMarker.setColor(Color.BLACK);\n\t\t\tcanvas.drawOval(new RectF(-mPaletteRadiusPx + 2, -mPaletteRadiusPx + 2, mPaletteRadiusPx - 2, mPaletteRadiusPx - 2), mPosMarker);\n\t\t}\n\n\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\t//To add a new method, replicate the basic draw functions here.  Use the 2D palette or 1D sliders as templates for the new method.\n\t\t/**\n\t\t * Draw the UI for HSV with angular H and radial S combined in 2D and a 1D V slider.\n\t\t * @param canvas\n\t\t */\n\t\tprivate void drawHSV1Palette(Canvas canvas) {\n\t\t\tcanvas.save();\n\n\t\t\tcanvas.translate(mPalettePosX, mPalettePosY);\n\n\t\t\t//Draw the 2D palette\n\t\t\tcanvas.translate(mPaletteCenterPx, mPaletteCenterPx);\n\t\t\tcanvas.drawOval(new RectF(-mPaletteRadiusPx, -mPaletteRadiusPx, mPaletteRadiusPx, mPaletteRadiusPx), mOvalHueSat);\n\t\t\tcanvas.drawOval(new RectF(-mPaletteRadiusPx, -mPaletteRadiusPx, mPaletteRadiusPx, mPaletteRadiusPx), mValDimmer);\n\t\t\tif (mFocusedControl == 0)\n\t\t\t\thilightFocusedOvalPalette(canvas);\n\t\t\tmark2DPalette(canvas, mCoord[0], mCoord[1]);\n\t\t\tcanvas.translate(-mPaletteCenterPx, -mPaletteCenterPx);\n\n\t\t\t//Draw the 1D slider\n\t\t\tcanvas.translate(mPaletteDimPx, 0);\n\t\t\tcanvas.drawBitmap(mVerSliderBM, 0, 0, null);\n\t\t\tif (mFocusedControl == 1)\n\t\t\t\thilightFocusedVerSlider(canvas);\n\t\t\tmarkVerSlider(canvas, mCoord[2]);\n\n\t\t\tcanvas.restore();\n\t\t}\n\n\t\t/**\n\t\t * Initialize the current color chooser's UI (set its color parameters and set its palette and slider values accordingly).\n\t\t */\n\t\tprivate void initUI() {\n\t\t\tinitHSV1Palette();\n\n\t\t\t//Focus on the first controller (arbitrary).\n\t\t\tmFocusedControl = 0;\n\t\t}\n\n\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\t//To add a new method, replicate and extend the last init function shown below\n\t\t/**\n\t\t * Initialize a color chooser.\n\t\t */\n\t\tprivate void initHSV1Palette() {\n\t\t\tsetOvalValDimmer();\n\t\t\tsetVerValSlider();\n\n\t\t\tfloat angle = 2 * PI - mHSV[0] / (180 / 3.1415927f);\n\t\t\tfloat radius = mHSV[1] * mPaletteRadiusPx;\n\t\t\tmCoord[0] = (int) (Math.cos(angle) * radius);\n\t\t\tmCoord[1] = (int) (Math.sin(angle) * radius);\n\n\t\t\tmCoord[2] = mPaletteDimPx - (int) (mHSV[2] * mPaletteDimPx);\n\t\t}\n\n\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\t//To add a new method, replicate and extend the set functions below, one per UI controller in the new method\n\t\t/**\n\t\t * Adjust a Paint which, when painted, dims its underlying object to show the effects of varying value (brightness).\n\t\t */\n\t\tprivate void setOvalValDimmer() {\n\t\t\tfloat[] hsv = new float[3];\n\t\t\thsv[0] = mHSV[0];\n\t\t\thsv[1] = 0;\n\t\t\thsv[2] = mHSV[2];\n\t\t\tint gray = Color.HSVToColor(hsv);\n\t\t\tmValDimmer.setColor(gray);\n\t\t}\n\n\t\t/**\n\t\t * Create a linear gradient shader to show variations in value.\n\t\t */\n\t\tprivate void setVerValSlider() {\n\t\t\tfloat[] hsv = new float[3];\n\t\t\thsv[0] = mHSV[0];\n\t\t\thsv[1] = mHSV[1];\n\t\t\thsv[2] = 1;\n\t\t\tint col = Color.HSVToColor(hsv);\n\n\t\t\tint colors[] = new int[2];\n\t\t\tcolors[0] = col;\n\t\t\tcolors[1] = 0xFF000000;\n\t\t\tGradientDrawable gradDraw = new GradientDrawable(Orientation.TOP_BOTTOM, colors);\n\t\t\tgradDraw.setDither(true);\n\t\t\tgradDraw.setLevel(10000);\n\t\t\tgradDraw.setBounds(0, 0, mSliderThicknessPx, mPaletteDimPx);\n\t\t\tgradDraw.draw(mVerSliderCv);\n\t\t}\n\n\t\t/**\n\t\t * Report the correct tightly bounded dimensions of the view.\n\t\t */\n\t\t@Override\n\t\tprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n\t\t\tsetMeasuredDimension(mViewDimXPx, mViewDimYPx);\n\t\t}\n\n\t\t/**\n\t\t * Wrap Math.round().  I'm not a Java expert.  Is this the only way to avoid writing \"(int)Math.round\" everywhere?\n\t\t * @param x\n\t\t * @return\n\t\t */\n\t\tprivate int round(double x) {\n\t\t\treturn (int)Math.round(x);\n\t\t}\n\n\t\t/**\n\t\t * Limit a value to the range [0,1].\n\t\t * @param n\n\t\t * @return\n\t\t */\n\t\tprivate float pinToUnit(float n) {\n\t\t\tif (n < 0) {\n\t\t\t\tn = 0;\n\t\t\t} else if (n > 1) {\n\t\t\t\tn = 1;\n\t\t\t}\n\t\t\treturn n;\n\t\t}\n\n\t\t/**\n\t\t * Limit a value to the range [0,max].\n\t\t * @param n\n\t\t * @param max\n\t\t * @return\n\t\t */\n\t\tprivate float pin(float n, float max) {\n\t\t\tif (n < 0) {\n\t\t\t\tn = 0;\n\t\t\t} else if (n > max) {\n\t\t\t\tn = max;\n\t\t\t}\n\t\t\treturn n;\n\t\t}\n\n\t\t/**\n\t\t * Limit a value to the range [min,max].\n\t\t * @param n\n\t\t * @param min\n\t\t * @param max\n\t\t * @return\n\t\t */\n\t\tprivate float pin(float n, float min, float max) {\n\t\t\tif (n < min) {\n\t\t\t\tn = min;\n\t\t\t} else if (n > max) {\n\t\t\t\tn = max;\n\t\t\t}\n\t\t\treturn n;\n\t\t}\n\n\t\t/**\n\t\t * No clue what this does (some sort of average/mean I presume).  It came with the original UberColorPickerDialog\n\t\t * in the API Demos and wasn't documented.  I don't feel like spending any time figuring it out, I haven't looked at it at all.\n\t\t * @param s\n\t\t * @param d\n\t\t * @param p\n\t\t * @return\n\t\t */\n\t\tprivate int ave(int s, int d, float p) {\n\t\t\treturn s + round(p * (d - s));\n\t\t}\n\n\t\t/**\n\t\t * Came with the original UberColorPickerDialog in the API Demos, wasn't documented.  I believe it takes an array of\n\t\t * colors and a value in the range [0,1] and interpolates a resulting color in a seemingly predictable manner.\n\t\t * I haven't looked at it at all.\n\t\t * @param colors\n\t\t * @param unit\n\t\t * @return\n\t\t */\n\t\tprivate int interpColor(int colors[], float unit) {\n\t\t\tif (unit <= 0) {\n\t\t\t\treturn colors[0];\n\t\t\t}\n\t\t\tif (unit >= 1) {\n\t\t\t\treturn colors[colors.length - 1];\n\t\t\t}\n\n\t\t\tfloat p = unit * (colors.length - 1);\n\t\t\tint i = (int)p;\n\t\t\tp -= i;\n\n\t\t\t// now p is just the fractional part [0...1) and i is the index\n\t\t\tint c0 = colors[i];\n\t\t\tint c1 = colors[i+1];\n\t\t\tint a = ave(Color.alpha(c0), Color.alpha(c1), p);\n\t\t\tint r = ave(Color.red(c0), Color.red(c1), p);\n\t\t\tint g = ave(Color.green(c0), Color.green(c1), p);\n\t\t\tint b = ave(Color.blue(c0), Color.blue(c1), p);\n\n\t\t\treturn Color.argb(a, r, g, b);\n\t\t}\n\n\t\t/**\n\t\t * A standard point-in-rect routine.\n\t\t * @param x\n\t\t * @param y\n\t\t * @param r\n\t\t * @return true if point x,y is in rect r\n\t\t */\n\t\tpublic boolean ptInRect(int x, int y, Rect r) {\n\t\t\treturn x > r.left && x < r.right && y > r.top && y < r.bottom;\n\t\t}\n\n\t\t/**\n\t\t * Process trackball events.  Used mainly for fine-tuned color adjustment, or alternatively to switch between slider controls.\n\t\t */\n\t\t@Override\n\t\tpublic boolean dispatchTrackballEvent(MotionEvent event) {\n\t\t\tfloat x = event.getX();\n\t\t\tfloat y = event.getY();\n\n\t\t\t//A longer event history implies faster trackball movement.\n\t\t\t//Use it to infer a larger jump and therefore faster palette/slider adjustment.\n\t\t\tint jump = event.getHistorySize() + 1;\n\n\t\t\tswitch (event.getAction()) {\n\t\t\t\tcase MotionEvent.ACTION_DOWN: {\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase MotionEvent.ACTION_MOVE: {\n\t\t\t\t\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\t\t\t\t\t//To add a new method, replicate and extend the appropriate entry in this list,\n\t\t\t\t\t\t//depending on whether you use 1D or 2D controllers\n\t\t\t\t\t\tswitch (mMethod) {\n\t\t\t\t\t\t\tcase METHOD_HS_V_PALETTE:\n\t\t\t\t\t\t\t\tif (mFocusedControl == 0) {\n\t\t\t\t\t\t\t\t\tchangeHSPalette(x, y, jump);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (mFocusedControl == 1) {\n\t\t\t\t\t\t\t\t\tif (y < 0)\n\t\t\t\t\t\t\t\t\t\tchangeSlider(mFocusedControl, true, jump);\n\t\t\t\t\t\t\t\t\telse if (y > 0)\n\t\t\t\t\t\t\t\t\t\tchangeSlider(mFocusedControl, false, jump);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase MotionEvent.ACTION_UP: {\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\t//To add a new method, replicate and extend the appropriate functions below,\n\t\t//one per UI controller in the new method\n\t\t/**\n\t\t * Effect a trackball change to a 2D palette.\n\t\t * @param x -1: negative x change, 0: no x change, +1: positive x change.\n\t\t * @param y -1: negative y change, 0, no y change, +1: positive y change.\n\t\t * @param jump the amount by which to change.\n\t\t */\n\t\tprivate void changeHSPalette(float x, float y, int jump) {\n\t\t\tint x2 = 0, y2 = 0;\n\t\t\tif (x < 0)\n\t\t\t\tx2 = -jump;\n\t\t\telse if (x > 0)\n\t\t\t\tx2 = jump;\n\t\t\tif (y < 0)\n\t\t\t\ty2 = -jump;\n\t\t\telse if (y > 0)\n\t\t\t\ty2 = jump;\n\n\t\t \tmCoord[0] += x2;\n\t\t \tmCoord[1] += y2;\n\n\t\t\tif (mCoord[0] < -mPaletteRadiusPx)\n\t\t\t\tmCoord[0] = -mPaletteRadiusPx;\n\t\t\telse if (mCoord[0] > mPaletteRadiusPx)\n\t\t\t\tmCoord[0] = mPaletteRadiusPx;\n\t\t\tif (mCoord[1] < -mPaletteRadiusPx)\n\t\t\t\tmCoord[1] = -mPaletteRadiusPx;\n\t\t\telse if (mCoord[1] > mPaletteRadiusPx)\n\t\t\t\tmCoord[1] = mPaletteRadiusPx;\n\n\t\t\tfloat radius = (float) java.lang.Math.sqrt(mCoord[0] * mCoord[0] + mCoord[1] * mCoord[1]);\n\t\t\tif (radius > mPaletteRadiusPx)\n\t\t\t\tradius = mPaletteRadiusPx;\n\n\t\t\tfloat angle = (float)java.lang.Math.atan2(mCoord[1], mCoord[0]);\n\t\t\t// need to turn angle [-PI ... PI] into unit [0....1]\n\t\t\tfloat unit = angle/(2*PI);\n\t\t\tif (unit < 0) {\n\t\t\t\tunit += 1;\n\t\t\t}\n\n\t\t\tmCoord[0] = round(Math.cos(angle) * radius);\n\t\t\tmCoord[1] = round(Math.sin(angle) * radius);\n\n\t\t\tint c = interpColor(mSpectrumColorsRev, unit);\n\t\t\tfloat[] hsv = new float[3];\n\t\t\tColor.colorToHSV(c, hsv);\n\t\t\tmHSV[0] = hsv[0];\n\t\t\tmHSV[1] = radius / mPaletteRadiusPx;\n\t\t\tupdateAllFromHSV();\n\t\t\tmSwatchNew.setColor(Color.HSVToColor(mHSV));\n\n\t\t\tsetVerValSlider();\n\n\t\t\tinvalidate();\n\t\t}\n\n\t\t/**\n\t\t * Effect a trackball change to a 1D slider.\n\t\t * @param slider id of the slider to be effected\n\t\t * @param increase true if the change is an increase, false if a decrease\n\t\t * @param jump the amount by which to change in units of the range [0,255]\n\t\t */\n\t\tprivate void changeSlider(int slider, boolean increase, int jump) {\n\t\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\t\t//It is only necessary to add an entry here for a new method if the new method uses a 1D slider.\n\t\t\t//Note, some sliders are horizontal and others are vertical.\n\t\t\t//They differ a bit, especially in a sign flip on the vertical axis.\n\t\t\tif (mMethod == METHOD_HS_V_PALETTE) {\n\t\t\t\t//slider *must* equal 1\n\n\t\t\t\tmHSV[2] += (increase ? jump : -jump) / 256.0f;\n\t\t\t\tmHSV[2] = pinToUnit(mHSV[2]);\n\t\t\t\tupdateAllFromHSV();\n\t\t\t\tmCoord[2] = mPaletteDimPx - (int) (mHSV[2] * mPaletteDimPx);\n\n\t\t\t\tmSwatchNew.setColor(Color.HSVToColor(mHSV));\n\n\t\t\t\tsetOvalValDimmer();\n\n\t\t\t\tinvalidate();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Keep all colorspace representations in sync.\n\t\t */\n\t\tprivate void updateRGBfromHSV() {\n\t\t\tint color = Color.HSVToColor(mHSV);\n\t\t\tmRGB[0] = Color.red(color);\n\t\t\tmRGB[1] = Color.green(color);\n\t\t\tmRGB[2] = Color.blue(color);\n\t\t}\n\n\t\t/**\n\t\t * Keep all colorspace representations in sync.\n\t\t */\n\t\tprivate void updateYUVfromRGB() {\n\t\t\tfloat r = mRGB[0] / 255.0f;\n\t\t\tfloat g = mRGB[1] / 255.0f;\n\t\t\tfloat b = mRGB[2] / 255.0f;\n\n\t\t\tColorMatrix cm = new ColorMatrix();\n\t\t\tcm.setRGB2YUV();\n\t\t\tfinal float[] a = cm.getArray();\n\n\t\t\tmYUV[0] = a[0] * r + a[1] * g + a[2] * b;\n\t\t\tmYUV[0] = pinToUnit(mYUV[0]);\n\t\t\tmYUV[1] = a[5] * r + a[6] * g + a[7] * b;\n\t\t\tmYUV[1] = pin(mYUV[1], -.5f, .5f);\n\t\t\tmYUV[2] = a[10] * r + a[11] * g + a[12] * b;\n\t\t\tmYUV[2] = pin(mYUV[2], -.5f, .5f);\n\t\t}\n\n\t\t/**\n\t\t * Keep all colorspace representations in sync.\n\t\t */\n\t\tprivate void updateHexFromHSV() {\n\t\t\t//For now, assume 100% opacity\n\t\t\tmHexStr = Integer.toHexString(Color.HSVToColor(mHSV)).toUpperCase();\n\t\t\tmHexStr = mHexStr.substring(2, mHexStr.length());\n\t\t}\n\n\t\t/**\n\t\t * Keep all colorspace representations in sync.\n\t\t */\n\t\tprivate void updateAllFromHSV() {\n\t\t\t//Update mRGB\n\t\t\tif (mRGBenabled || mYUVenabled)\n\t\t\t\tupdateRGBfromHSV();\n\n\t\t\t//Update mYUV\n\t\t\tif (mYUVenabled)\n\t\t\t\tupdateYUVfromRGB();\n\n\t\t\t//Update mHexStr\n\t\t\tif (mRGBenabled)\n\t\t\t\tupdateHexFromHSV();\n\t\t}\n\n\t\t/**\n\t\t * Process touch events: down, move, and up\n\t\t */\n\t\t@Override\n\t\tpublic boolean onTouchEvent(MotionEvent event) {\n\t\t\tfloat x = event.getX();\n\t\t\tfloat y = event.getY();\n\n\t\t\t//Generate coordinates which are palette=local with the origin at the upper left of the main 2D palette\n\t\t\tint y2 = (int) (pin(round(y - mPalettePosY), mPaletteDimPx));\n\n\t\t\t//Generate coordinates which are palette-local with the origin at the center of the main 2D palette\n\t\t\tfloat circlePinnedX = x - mPalettePosX - mPaletteCenterPx;\n\t\t\tfloat circlePinnedY = y - mPalettePosY - mPaletteCenterPx;\n\n\t\t\t//Is the event in a swatch?\n\t\t\tboolean inSwatchOld = ptInRect(round(x), round(y), mOldSwatchRect);\n\t\t\tboolean inSwatchNew = ptInRect(round(x), round(y), mNewSwatchRect);\n\n\t\t\t//Get the event's distance from the center of the main 2D palette\n\t\t\tfloat radius = (float)java.lang.Math.sqrt(circlePinnedX * circlePinnedX + circlePinnedY * circlePinnedY);\n\n\t\t\t//Is the event in a circle-pinned 2D palette?\n\t\t\tboolean inOvalPalette = radius <= mPaletteRadiusPx;\n\n\t\t\t//Pin the radius\n\t\t\tif (radius > mPaletteRadiusPx)\n\t\t\t\tradius = mPaletteRadiusPx;\n\n\t\t\t//Is the event in a vertical slider to the right of the main 2D palette\n\t\t\tboolean inVerSlider = ptInRect(round(x), round(y), mVerSliderRect);\n\n\t\t\tswitch (event.getAction()) {\n\t\t\t\tcase MotionEvent.ACTION_DOWN:\n\t\t\t\t\tmTracking = TRACKED_NONE;\n\n\t\t\t\t\tif (inSwatchOld)\n\t\t\t\t\t\tmTracking = TRACK_SWATCH_OLD;\n\t\t\t\t\telse if (inSwatchNew)\n\t\t\t\t\t\tmTracking = TRACK_SWATCH_NEW;\n\n\t\t\t\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\t\t\t\t//To add a new method, replicate and extend the last entry in this list\n\t\t\t\t\telse if (mMethod == METHOD_HS_V_PALETTE) {\n\t\t\t\t\t\tif (inOvalPalette) {\n\t\t\t\t\t\t\tmTracking = TRACK_HS_PALETTE;\n\t\t\t\t\t\t\tmFocusedControl = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (inVerSlider) {\n\t\t\t\t\t\t\tmTracking = TRACK_VER_VALUE_SLIDER;\n\t\t\t\t\t\t\tmFocusedControl = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tcase MotionEvent.ACTION_MOVE:\n\t\t\t\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\t\t\t\t//To add a new method, replicate and extend the entries in this list,\n\t\t\t\t\t//one per UI controller the new method requires.\n\t\t\t\t\tif (mTracking == TRACK_HS_PALETTE) {\n\t\t\t\t\t\tfloat angle = (float)java.lang.Math.atan2(circlePinnedY, circlePinnedX);\n\t\t\t\t\t\t// need to turn angle [-PI ... PI] into unit [0....1]\n\t\t\t\t\t\tfloat unit = angle/(2*PI);\n\t\t\t\t\t\tif (unit < 0) {\n\t\t\t\t\t\t\tunit += 1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmCoord[0] = round(Math.cos(angle) * radius);\n\t\t\t\t\t\tmCoord[1] = round(Math.sin(angle) * radius);\n\n\t\t\t\t\t\tint c = interpColor(mSpectrumColorsRev, unit);\n\t\t\t\t\t\tfloat[] hsv = new float[3];\n\t\t\t\t\t\tColor.colorToHSV(c, hsv);\n\t\t\t\t\t\tmHSV[0] = hsv[0];\n\t\t\t\t\t\tmHSV[1] = radius / mPaletteRadiusPx;\n\t\t\t\t\t\tupdateAllFromHSV();\n\t\t\t\t\t\tmSwatchNew.setColor(Color.HSVToColor(mHSV));\n\n\t\t\t\t\t\tsetVerValSlider();\n\n\t\t\t\t\t\tinvalidate();\n\t\t\t\t\t}\n\t\t\t\t\telse if (mTracking == TRACK_VER_VALUE_SLIDER) {\n\t\t\t\t\t\tif (mCoord[2] != y2) {\n\t\t\t\t\t\t\tmCoord[2] = y2;\n\t\t\t\t\t\t\tfloat value = 1.0f - (float) y2 / (float) mPaletteDimPx;\n\n\t\t\t\t\t\t\tmHSV[2] = value;\n\t\t\t\t\t\t\tupdateAllFromHSV();\n\t\t\t\t\t\t\tmSwatchNew.setColor(Color.HSVToColor(mHSV));\n\n\t\t\t\t\t\t\tsetOvalValDimmer();\n\n\t\t\t\t\t\t\tinvalidate();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase MotionEvent.ACTION_UP:\n\t\t\t\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\t\t\t\t//To add a new method, replicate and extend the last entry in this list.\n\t\t\t\t\tif (mTracking == TRACK_SWATCH_OLD && inSwatchOld) {\n\t\t\t\t\t\tColor.colorToHSV(mOriginalColor, mHSV);\n\t\t\t\t\t\tmSwatchNew.setColor(mOriginalColor);\n\t\t\t\t\t\tinitUI();\n\t\t\t\t\t\tinvalidate();\n\t\t\t\t\t}\n\t\t\t\t\telse if (mTracking == TRACK_SWATCH_NEW && inSwatchNew) {\n\t\t\t\t\t\tmListener.colorChanged(mSwatchNew.getColor());\n\t\t\t\t\t\tinvalidate();\n\t\t\t\t\t}\n\n\t\t\t\t\tmTracking= TRACKED_NONE;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t}\n}\n","lineNo":260}
{"Smelly Sample":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * 090408\n * Keith Wiley\n * kwiley@keithwiley.com\n * http://keithwiley.com\n *\n * UberColorPickerDialog v1.1\n *\n * This color picker was implemented as a (significant) extension of the\n * ColorPickerDialog class provided in the Android API Demos.  You are free\n * to drop it unchanged into your own projects or to modify it as you see\n * fit.  I would appreciate it if this comment block were let intact,\n * merely for credit's sake.\n *\n * Enjoy!\n */\n\npackage org.connectbot.util;\n\nimport android.app.Dialog;\nimport android.content.Context;\nimport android.graphics.Bitmap;\nimport android.graphics.Canvas;\nimport android.graphics.Color;\nimport android.graphics.ColorMatrix;\nimport android.graphics.ComposeShader;\nimport android.graphics.Paint;\nimport android.graphics.PorterDuff;\nimport android.graphics.PorterDuffXfermode;\nimport android.graphics.RadialGradient;\nimport android.graphics.Rect;\nimport android.graphics.RectF;\nimport android.graphics.Shader;\nimport android.graphics.SweepGradient;\nimport android.graphics.drawable.GradientDrawable;\nimport android.graphics.drawable.GradientDrawable.Orientation;\nimport android.os.Bundle;\nimport android.util.DisplayMetrics;\nimport android.view.MotionEvent;\nimport android.view.View;\n\n/**\n * UberColorPickerDialog is a seriously enhanced version of the UberColorPickerDialog\n * class provided in the Android API Demos.<p>\n *\n * NOTE (from Kenny Root): This is a VERY slimmed down version custom for ConnectBot.\n * Visit Keith's site for the full version at the URL listed in the author line.<p>\n *\n * @author Keith Wiley, kwiley@keithwiley.com, http://keithwiley.com\n */\npublic class UberColorPickerDialog extends Dialog {\n\tprivate final OnColorChangedListener mListener;\n\tprivate final int mInitialColor;\n\n\t/**\n\t * Callback to the creator of the dialog, informing the creator of a new color and notifying that the dialog is about to dismiss.\n\t */\n\tpublic interface OnColorChangedListener {\n\t\tvoid colorChanged(int color);\n\t}\n\n\t/**\n\t * Ctor\n\t * @param context\n\t * @param listener\n\t * @param initialColor\n\t * @param showTitle If true, a title is shown across the top of the dialog.  If false a toast is shown instead.\n\t */\n\tpublic UberColorPickerDialog(Context context,\n\t\t\t\t\t\t\tOnColorChangedListener listener,\n\t\t\t\t\t\t\tint initialColor) {\n\t\tsuper(context);\n\n\t\tmListener = listener;\n\t\tmInitialColor = initialColor;\n\t}\n\n\t/**\n\t * Activity entry point\n\t */\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tOnColorChangedListener l = new OnColorChangedListener() {\n\t\t\tpublic void colorChanged(int color) {\n\t\t\t\tmListener.colorChanged(color);\n\t\t\t\tdismiss();\n\t\t\t}\n\t\t};\n\n\t\tDisplayMetrics dm = new DisplayMetrics();\n\t\tgetWindow().getWindowManager().getDefaultDisplay().getMetrics(dm);\n\t\tint screenWidth = dm.widthPixels;\n\t\tint screenHeight = dm.heightPixels;\n\n\t\tsetTitle(\"Pick a color (try the trackball)\");\n\n\t\ttry {\n\t\t\tsetContentView(new ColorPickerView(getContext(), l, screenWidth, screenHeight, mInitialColor));\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t//There is currently only one kind of ctor exception, that where no methods are enabled.\n\t\t\tdismiss();\t//This doesn't work!  The dialog is still shown (its title at least, the layout is empty from the exception being thrown).  <sigh>\n\t\t}\n\t}\n\n\t/**\n\t * ColorPickerView is the meat of this color picker (as opposed to the enclosing class).\n\t * All the heavy lifting is done directly by this View subclass.\n\t * <P>\n\t * You can enable/disable whichever color chooser methods you want by modifying the ENABLED_METHODS switches.  They *should*\n\t * do all the work required to properly enable/disable methods without losing track of what goes with what and what maps to what.\n\t * <P>\n\t * If you add a new color chooser method, do a text search for \"NEW_METHOD_WORK_NEEDED_HERE\".  That tag indicates all\n\t * the locations in the code that will have to be amended in order to properly add a new color chooser method.\n\t * I highly recommend adding new methods to the end of the list.  If you want to try to reorder the list, you're on your own.\n\t */\n\tprivate static class ColorPickerView extends View {\n\t\tprivate static int SWATCH_WIDTH = 95;\n\t\tprivate static final int SWATCH_HEIGHT = 60;\n\n\t\tprivate static int PALETTE_POS_X = 0;\n\t\tprivate static int PALETTE_POS_Y = SWATCH_HEIGHT;\n\t\tprivate static final int PALETTE_DIM = SWATCH_WIDTH * 2;\n\t\tprivate static final int PALETTE_RADIUS = PALETTE_DIM / 2;\n\t\tprivate static final int PALETTE_CENTER_X = PALETTE_RADIUS;\n\t\tprivate static final int PALETTE_CENTER_Y = PALETTE_RADIUS;\n\n\t\tprivate static final int SLIDER_THICKNESS = 40;\n\n\t\tprivate static int VIEW_DIM_X = PALETTE_DIM;\n\t\tprivate static int VIEW_DIM_Y = SWATCH_HEIGHT;\n\n\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\tprivate static final int METHOD_HS_V_PALETTE = 0;\n\n\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\t//Add a new entry to the list for each controller in the new method\n\t\tprivate static final int TRACKED_NONE = -1;\t//No object on screen is currently being tracked\n\t\tprivate static final int TRACK_SWATCH_OLD = 10;\n\t\tprivate static final int TRACK_SWATCH_NEW = 11;\n\t\tprivate static final int TRACK_HS_PALETTE = 30;\n\t\tprivate static final int TRACK_VER_VALUE_SLIDER = 31;\n\n\t\tprivate static final int TEXT_SIZE = 12;\n\t\tprivate static int[] TEXT_HSV_POS = new int[2];\n\t\tprivate static int[] TEXT_RGB_POS = new int[2];\n\t\tprivate static int[] TEXT_YUV_POS = new int[2];\n\t\tprivate static int[] TEXT_HEX_POS = new int[2];\n\n\t\tprivate static final float PI = 3.141592653589793f;\n\n\t\tprivate int mMethod = METHOD_HS_V_PALETTE;\n\t\tprivate int mTracking = TRACKED_NONE;\t//What object on screen is currently being tracked for movement\n\n\t\t//Zillions of persistant Paint objecs for drawing the View\n\n\t\tprivate Paint mSwatchOld, mSwatchNew;\n\n\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\t//Add Paints to represent the palettes of the new method's UI controllers\n\t\tprivate Paint mOvalHueSat;\n\n\t\tprivate Bitmap mVerSliderBM;\n\t\tprivate Canvas mVerSliderCv;\n\n\t\tprivate Bitmap[] mHorSlidersBM = new Bitmap[3];\n\t\tprivate Canvas[] mHorSlidersCv = new Canvas[3];\n\n\t\tprivate Paint mValDimmer;\n\n\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\t//Add Paints to represent the icon for the new method\n\t\tprivate Paint mOvalHueSatSmall;\n\n\t\tprivate Paint mPosMarker;\n\t\tprivate Paint mText;\n\n\t\tprivate Rect mOldSwatchRect = new Rect();\n\t\tprivate Rect mNewSwatchRect = new Rect();\n\t\tprivate Rect mPaletteRect = new Rect();\n\t\tprivate Rect mVerSliderRect = new Rect();\n\n\t\tprivate int[] mSpectrumColorsRev;\n\t\tprivate int mOriginalColor = 0;\t//The color passed in at the beginning, which can be reverted to at any time by tapping the old swatch.\n\t\tprivate float[] mHSV = new float[3];\n\t\tprivate int[] mRGB = new int[3];\n\t\tprivate float[] mYUV = new float[3];\n\t\tprivate String mHexStr = \"\";\n\t\tprivate boolean mHSVenabled = true;\t//Only true if an HSV method is enabled\n\t\tprivate boolean mRGBenabled = true;\t//Only true if an RGB method is enabled\n\t\tprivate boolean mYUVenabled = true;\t//Only true if a YUV method is enabled\n\t\tprivate boolean mHexenabled = true;\t//Only true if an RGB method is enabled\n\t\tprivate int[] mCoord = new int[3];\t\t//For drawing slider/palette markers\n\t\tprivate int mFocusedControl = -1;\t//Which control receives trackball events.\n\t\tprivate OnColorChangedListener mListener;\n\n\t\t/**\n\t\t * Ctor.\n\t\t * @param c\n\t\t * @param l\n\t\t * @param width Used to determine orientation and adjust layout accordingly\n\t\t * @param height Used to determine orientation and adjust layout accordingly\n\t\t * @param color The initial color\n\t\t * @throws Exception\n\t\t */\n\t\tColorPickerView(Context c, OnColorChangedListener l, int width, int height, int color)\n\t\tthrows Exception {\n\t\t\tsuper(c);\n\n\t\t\t//We need to make the dialog focusable to retrieve trackball events.\n\t\t\tsetFocusable(true);\n\n\t\t\tmListener = l;\n\n\t\t\tmOriginalColor = color;\n\n\t\t\tColor.colorToHSV(color, mHSV);\n\n\t\t\tupdateAllFromHSV();\n\n\t\t\t//Setup the layout based on whether this is a portrait or landscape orientation.\n\t\t\tif (width <= height) {\t//Portrait layout\n\t\t\t\tSWATCH_WIDTH = (PALETTE_DIM + SLIDER_THICKNESS) / 2;\n\n\t\t\t\tPALETTE_POS_X = 0;\n\t\t\t\tPALETTE_POS_Y = TEXT_SIZE * 4 + SWATCH_HEIGHT;\n\n\t\t\t\t//Set more rects, lots of rects\n\t\t\t\tmOldSwatchRect.set(0, TEXT_SIZE * 4, SWATCH_WIDTH, TEXT_SIZE * 4 + SWATCH_HEIGHT);\n\t\t\t\tmNewSwatchRect.set(SWATCH_WIDTH, TEXT_SIZE * 4, SWATCH_WIDTH * 2, TEXT_SIZE * 4 + SWATCH_HEIGHT);\n\t\t\t\tmPaletteRect.set(0, PALETTE_POS_Y, PALETTE_DIM, PALETTE_POS_Y + PALETTE_DIM);\n\t\t\t\tmVerSliderRect.set(PALETTE_DIM, PALETTE_POS_Y, PALETTE_DIM + SLIDER_THICKNESS, PALETTE_POS_Y + PALETTE_DIM);\n\n\t\t\t\tTEXT_HSV_POS[0] = 3;\n\t\t\t\tTEXT_HSV_POS[1] = 0;\n\t\t\t\tTEXT_RGB_POS[0] = TEXT_HSV_POS[0] + 50;\n\t\t\t\tTEXT_RGB_POS[1] = TEXT_HSV_POS[1];\n\t\t\t\tTEXT_YUV_POS[0] = TEXT_HSV_POS[0] + 100;\n\t\t\t\tTEXT_YUV_POS[1] = TEXT_HSV_POS[1];\n\t\t\t\tTEXT_HEX_POS[0] = TEXT_HSV_POS[0] + 150;\n\t\t\t\tTEXT_HEX_POS[1] = TEXT_HSV_POS[1];\n\n\t\t\t\tVIEW_DIM_X = PALETTE_DIM + SLIDER_THICKNESS;\n\t\t\t\tVIEW_DIM_Y = SWATCH_HEIGHT + PALETTE_DIM + TEXT_SIZE * 4;\n\t\t\t}\n\t\t\telse {\t//Landscape layout\n\t\t\t\tSWATCH_WIDTH = 110;\n\n\t\t\t\tPALETTE_POS_X = SWATCH_WIDTH;\n\t\t\t\tPALETTE_POS_Y = 0;\n\n\t\t\t\t//Set more rects, lots of rects\n\t\t\t\tmOldSwatchRect.set(0, TEXT_SIZE * 7, SWATCH_WIDTH, TEXT_SIZE * 7 + SWATCH_HEIGHT);\n\t\t\t\tmNewSwatchRect.set(0, TEXT_SIZE * 7 + SWATCH_HEIGHT, SWATCH_WIDTH, TEXT_SIZE * 7 + SWATCH_HEIGHT * 2);\n\t\t\t\tmPaletteRect.set(SWATCH_WIDTH, PALETTE_POS_Y, SWATCH_WIDTH + PALETTE_DIM, PALETTE_POS_Y + PALETTE_DIM);\n\t\t\t\tmVerSliderRect.set(SWATCH_WIDTH + PALETTE_DIM, PALETTE_POS_Y, SWATCH_WIDTH + PALETTE_DIM + SLIDER_THICKNESS, PALETTE_POS_Y + PALETTE_DIM);\n\n\t\t\t\tTEXT_HSV_POS[0] = 3;\n\t\t\t\tTEXT_HSV_POS[1] = 0;\n\t\t\t\tTEXT_RGB_POS[0] = TEXT_HSV_POS[0];\n\t\t\t\tTEXT_RGB_POS[1] = (int)(TEXT_HSV_POS[1] + TEXT_SIZE * 3.5);\n\t\t\t\tTEXT_YUV_POS[0] = TEXT_HSV_POS[0] + 50;\n\t\t\t\tTEXT_YUV_POS[1] = (int)(TEXT_HSV_POS[1] + TEXT_SIZE * 3.5);\n\t\t\t\tTEXT_HEX_POS[0] = TEXT_HSV_POS[0] + 50;\n\t\t\t\tTEXT_HEX_POS[1] = TEXT_HSV_POS[1];\n\n\t\t\t\tVIEW_DIM_X = PALETTE_POS_X + PALETTE_DIM + SLIDER_THICKNESS;\n\t\t\t\tVIEW_DIM_Y = Math.max(mNewSwatchRect.bottom, PALETTE_DIM);\n\t\t\t}\n\n\t\t\t//Rainbows make everybody happy!\n\t\t\tmSpectrumColorsRev = new int[] {\n\t\t\t\t0xFFFF0000, 0xFFFF00FF, 0xFF0000FF, 0xFF00FFFF,\n\t\t\t\t0xFF00FF00, 0xFFFFFF00, 0xFFFF0000,\n\t\t\t};\n\n\t\t\t//Setup all the Paint and Shader objects.  There are lots of them!\n\n\t\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\t\t//Add Paints to represent the palettes of the new method's UI controllers\n\n\t\t\tmSwatchOld = new Paint(Paint.ANTI_ALIAS_FLAG);\n\t\t\tmSwatchOld.setStyle(Paint.Style.FILL);\n\t\t\tmSwatchOld.setColor(Color.HSVToColor(mHSV));\n\n\t\t\tmSwatchNew = new Paint(Paint.ANTI_ALIAS_FLAG);\n\t\t\tmSwatchNew.setStyle(Paint.Style.FILL);\n\t\t\tmSwatchNew.setColor(Color.HSVToColor(mHSV));\n\n\t\t\tShader shaderA = new SweepGradient(0, 0, mSpectrumColorsRev, null);\n\t\t\tShader shaderB = new RadialGradient(0, 0, PALETTE_CENTER_X, 0xFFFFFFFF, 0xFF000000, Shader.TileMode.CLAMP);\n\t\t\tShader shader = new ComposeShader(shaderA, shaderB, PorterDuff.Mode.SCREEN);\n\t\t\tmOvalHueSat = new Paint(Paint.ANTI_ALIAS_FLAG);\n\t\t\tmOvalHueSat.setShader(shader);\n\t\t\tmOvalHueSat.setStyle(Paint.Style.FILL);\n\t\t\tmOvalHueSat.setDither(true);\n\n\t\t\tmVerSliderBM = Bitmap.createBitmap(SLIDER_THICKNESS, PALETTE_DIM, Bitmap.Config.RGB_565);\n\t\t\tmVerSliderCv = new Canvas(mVerSliderBM);\n\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tmHorSlidersBM[i] = Bitmap.createBitmap(PALETTE_DIM, SLIDER_THICKNESS, Bitmap.Config.RGB_565);\n\t\t\t\tmHorSlidersCv[i] = new Canvas(mHorSlidersBM[i]);\n\t\t\t}\n\n\t\t\tmValDimmer = new Paint(Paint.ANTI_ALIAS_FLAG);\n\t\t\tmValDimmer.setStyle(Paint.Style.FILL);\n\t\t\tmValDimmer.setDither(true);\n\t\t\tmValDimmer.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.MULTIPLY));\n\n\t\t\t//Whew, we're done making the big Paints and Shaders for the swatches, palettes, and sliders.\n\t\t\t//Now we need to make the Paints and Shaders that will draw the little method icons in the method selector list.\n\n\t\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\t\t//Add Paints to represent the icon for the new method\n\n\t\t\tshaderA = new SweepGradient(0, 0, mSpectrumColorsRev, null);\n\t\t\tshaderB = new RadialGradient(0, 0, PALETTE_DIM / 2, 0xFFFFFFFF, 0xFF000000, Shader.TileMode.CLAMP);\n\t\t\tshader = new ComposeShader(shaderA, shaderB, PorterDuff.Mode.SCREEN);\n\t\t\tmOvalHueSatSmall = new Paint(Paint.ANTI_ALIAS_FLAG);\n\t\t\tmOvalHueSatSmall.setShader(shader);\n\t\t\tmOvalHueSatSmall.setStyle(Paint.Style.FILL);\n\n\t\t\t//Make a simple stroking Paint for drawing markers and borders and stuff like that.\n\t\t\tmPosMarker = new Paint(Paint.ANTI_ALIAS_FLAG);\n\t\t\tmPosMarker.setStyle(Paint.Style.STROKE);\n\t\t\tmPosMarker.setStrokeWidth(2);\n\n\t\t\t//Make a basic text Paint.\n\t\t\tmText = new Paint(Paint.ANTI_ALIAS_FLAG);\n\t\t\tmText.setTextSize(TEXT_SIZE);\n\t\t\tmText.setColor(Color.WHITE);\n\n\t\t\t//Kickstart\n\t\t\tinitUI();\n\t\t}\n\n\t\t/**\n\t\t * Draw the entire view (the entire dialog).\n\t\t */\n\t\t@Override\n\t\tprotected void onDraw(Canvas canvas) {\n\t\t\t//Draw the old and new swatches\n\t\t\tdrawSwatches(canvas);\n\n\t\t\t//Write the text\n\t\t\twriteColorParams(canvas);\n\n\t\t\t//Draw the palette and sliders (the UI)\n\t\t\tif (mMethod == METHOD_HS_V_PALETTE)\n\t\t\t\tdrawHSV1Palette(canvas);\n\t\t}\n\n\t\t/**\n\t\t * Draw the old and new swatches.\n\t\t * @param canvas\n\t\t */\n\t\tprivate void drawSwatches(Canvas canvas) {\n\t\t\tfloat[] hsv = new float[3];\n\n\t\t\tmText.setTextSize(16);\n\n\t\t\t//Draw the original swatch\n\t\t\tcanvas.drawRect(mOldSwatchRect, mSwatchOld);\n\t\t\tColor.colorToHSV(mOriginalColor, hsv);\n\t\t\t//if (UberColorPickerDialog.isGray(mColor))\t//Don't need this right here, but imp't to note\n\t\t\t//\thsv[1] = 0;\n\t\t\tif (hsv[2] > .5)\n\t\t\t\tmText.setColor(Color.BLACK);\n\t\t\tcanvas.drawText(\"Revert\", mOldSwatchRect.left + SWATCH_WIDTH / 2 - mText.measureText(\"Revert\") / 2, mOldSwatchRect.top + 16, mText);\n\t\t\tmText.setColor(Color.WHITE);\n\n\t\t\t//Draw the new swatch\n\t\t\tcanvas.drawRect(mNewSwatchRect, mSwatchNew);\n\t\t\tif (mHSV[2] > .5)\n\t\t\t\tmText.setColor(Color.BLACK);\n\t\t\tcanvas.drawText(\"Accept\", mNewSwatchRect.left + SWATCH_WIDTH / 2 - mText.measureText(\"Accept\") / 2, mNewSwatchRect.top + 16, mText);\n\t\t\tmText.setColor(Color.WHITE);\n\n\t\t\tmText.setTextSize(TEXT_SIZE);\n\t\t}\n\n\t\t/**\n\t\t * Write the color parametes (HSV, RGB, YUV, Hex, etc.).\n\t\t * @param canvas\n\t\t */\n\t\tprivate void writeColorParams(Canvas canvas) {\n\t\t\tif (mHSVenabled) {\n\t\t\t\tcanvas.drawText(\"H: \" + Integer.toString((int)(mHSV[0] / 360.0f * 255)), TEXT_HSV_POS[0], TEXT_HSV_POS[1] + TEXT_SIZE, mText);\n\t\t\t\tcanvas.drawText(\"S: \" + Integer.toString((int)(mHSV[1] * 255)), TEXT_HSV_POS[0], TEXT_HSV_POS[1] + TEXT_SIZE * 2, mText);\n\t\t\t\tcanvas.drawText(\"V: \" + Integer.toString((int)(mHSV[2] * 255)), TEXT_HSV_POS[0], TEXT_HSV_POS[1] + TEXT_SIZE * 3, mText);\n\t\t\t}\n\n\t\t\tif (mRGBenabled) {\n\t\t\t\tcanvas.drawText(\"R: \" + mRGB[0], TEXT_RGB_POS[0], TEXT_RGB_POS[1] + TEXT_SIZE, mText);\n\t\t\t\tcanvas.drawText(\"G: \" + mRGB[1], TEXT_RGB_POS[0], TEXT_RGB_POS[1] + TEXT_SIZE * 2, mText);\n\t\t\t\tcanvas.drawText(\"B: \" + mRGB[2], TEXT_RGB_POS[0], TEXT_RGB_POS[1] + TEXT_SIZE * 3, mText);\n\t\t\t}\n\n\t\t\tif (mYUVenabled) {\n\t\t\t\tcanvas.drawText(\"Y: \" + Integer.toString((int)(mYUV[0] * 255)), TEXT_YUV_POS[0], TEXT_YUV_POS[1] + TEXT_SIZE, mText);\n\t\t\t\tcanvas.drawText(\"U: \" + Integer.toString((int)((mYUV[1] + .5f) * 255)), TEXT_YUV_POS[0], TEXT_YUV_POS[1] + TEXT_SIZE * 2, mText);\n\t\t\t\tcanvas.drawText(\"V: \" + Integer.toString((int)((mYUV[2] + .5f) * 255)), TEXT_YUV_POS[0], TEXT_YUV_POS[1] + TEXT_SIZE * 3, mText);\n\t\t\t}\n\n\t\t\tif (mHexenabled)\n\t\t\t\tcanvas.drawText(\"#\" + mHexStr, TEXT_HEX_POS[0], TEXT_HEX_POS[1] + TEXT_SIZE, mText);\n\t\t}\n\n\t\t/**\n\t\t * Place a small circle on the 2D palette to indicate the current values.\n\t\t * @param canvas\n\t\t * @param markerPosX\n\t\t * @param markerPosY\n\t\t */\n\t\tprivate void mark2DPalette(Canvas canvas, int markerPosX, int markerPosY) {\n\t\t\tmPosMarker.setColor(Color.BLACK);\n\t\t\tcanvas.drawOval(new RectF(markerPosX - 5, markerPosY - 5, markerPosX + 5, markerPosY + 5), mPosMarker);\n\t\t\tmPosMarker.setColor(Color.WHITE);\n\t\t\tcanvas.drawOval(new RectF(markerPosX - 3, markerPosY - 3, markerPosX + 3, markerPosY + 3), mPosMarker);\n\t\t}\n\n\t\t/**\n\t\t * Draw a line across the slider to indicate its current value.\n\t\t * @param canvas\n\t\t * @param markerPos\n\t\t */\n\t\tprivate void markVerSlider(Canvas canvas, int markerPos) {\n\t\t\tmPosMarker.setColor(Color.BLACK);\n\t\t\tcanvas.drawRect(new Rect(0, markerPos - 2, SLIDER_THICKNESS, markerPos + 3), mPosMarker);\n\t\t\tmPosMarker.setColor(Color.WHITE);\n\t\t\tcanvas.drawRect(new Rect(0, markerPos, SLIDER_THICKNESS, markerPos + 1), mPosMarker);\n\t\t}\n\n\t\t/**\n\t\t * Frame the slider to indicate that it has trackball focus.\n\t\t * @param canvas\n\t\t */\n\t\tprivate void hilightFocusedVerSlider(Canvas canvas) {\n\t\t\tmPosMarker.setColor(Color.WHITE);\n\t\t\tcanvas.drawRect(new Rect(0, 0, SLIDER_THICKNESS, PALETTE_DIM), mPosMarker);\n\t\t\tmPosMarker.setColor(Color.BLACK);\n\t\t\tcanvas.drawRect(new Rect(2, 2, SLIDER_THICKNESS - 2, PALETTE_DIM - 2), mPosMarker);\n\t\t}\n\n\t\t/**\n\t\t * Frame the 2D palette to indicate that it has trackball focus.\n\t\t * @param canvas\n\t\t */\n\t\tprivate void hilightFocusedOvalPalette(Canvas canvas) {\n\t\t\tmPosMarker.setColor(Color.WHITE);\n\t\t\tcanvas.drawOval(new RectF(-PALETTE_RADIUS, -PALETTE_RADIUS, PALETTE_RADIUS, PALETTE_RADIUS), mPosMarker);\n\t\t\tmPosMarker.setColor(Color.BLACK);\n\t\t\tcanvas.drawOval(new RectF(-PALETTE_RADIUS + 2, -PALETTE_RADIUS + 2, PALETTE_RADIUS - 2, PALETTE_RADIUS - 2), mPosMarker);\n\t\t}\n\n\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\t//To add a new method, replicate the basic draw functions here.  Use the 2D palette or 1D sliders as templates for the new method.\n\t\t/**\n\t\t * Draw the UI for HSV with angular H and radial S combined in 2D and a 1D V slider.\n\t\t * @param canvas\n\t\t */\n\t\tprivate void drawHSV1Palette(Canvas canvas) {\n\t\t\tcanvas.save();\n\n\t\t\tcanvas.translate(PALETTE_POS_X, PALETTE_POS_Y);\n\n\t\t\t//Draw the 2D palette\n\t\t\tcanvas.translate(PALETTE_CENTER_X, PALETTE_CENTER_Y);\n\t\t\tcanvas.drawOval(new RectF(-PALETTE_RADIUS, -PALETTE_RADIUS, PALETTE_RADIUS, PALETTE_RADIUS), mOvalHueSat);\n\t\t\tcanvas.drawOval(new RectF(-PALETTE_RADIUS, -PALETTE_RADIUS, PALETTE_RADIUS, PALETTE_RADIUS), mValDimmer);\n\t\t\tif (mFocusedControl == 0)\n\t\t\t\thilightFocusedOvalPalette(canvas);\n\t\t\tmark2DPalette(canvas, mCoord[0], mCoord[1]);\n\t\t\tcanvas.translate(-PALETTE_CENTER_X, -PALETTE_CENTER_Y);\n\n\t\t\t//Draw the 1D slider\n\t\t\tcanvas.translate(PALETTE_DIM, 0);\n\t\t\tcanvas.drawBitmap(mVerSliderBM, 0, 0, null);\n\t\t\tif (mFocusedControl == 1)\n\t\t\t\thilightFocusedVerSlider(canvas);\n\t\t\tmarkVerSlider(canvas, mCoord[2]);\n\n\t\t\tcanvas.restore();\n\t\t}\n\n\t\t/**\n\t\t * Initialize the current color chooser's UI (set its color parameters and set its palette and slider values accordingly).\n\t\t */\n\t\tprivate void initUI() {\n\t\t\tinitHSV1Palette();\n\n\t\t\t//Focus on the first controller (arbitrary).\n\t\t\tmFocusedControl = 0;\n\t\t}\n\n\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\t//To add a new method, replicate and extend the last init function shown below\n\t\t/**\n\t\t * Initialize a color chooser.\n\t\t */\n\t\tprivate void initHSV1Palette() {\n\t\t\tsetOvalValDimmer();\n\t\t\tsetVerValSlider();\n\n\t\t\tfloat angle = 2*PI - mHSV[0] / (180 / 3.1415927f);\n\t\t\tfloat radius = mHSV[1] * PALETTE_RADIUS;\n\t\t\tmCoord[0] = (int)(Math.cos(angle) * radius);\n\t\t\tmCoord[1] = (int)(Math.sin(angle) * radius);\n\n\t\t\tmCoord[2] = PALETTE_DIM - (int)(mHSV[2] * PALETTE_DIM);\n\t\t}\n\n\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\t//To add a new method, replicate and extend the set functions below, one per UI controller in the new method\n\t\t/**\n\t\t * Adjust a Paint which, when painted, dims its underlying object to show the effects of varying value (brightness).\n\t\t */\n\t\tprivate void setOvalValDimmer() {\n\t\t\tfloat[] hsv = new float[3];\n\t\t\thsv[0] = mHSV[0];\n\t\t\thsv[1] = 0;\n\t\t\thsv[2] = mHSV[2];\n\t\t\tint gray = Color.HSVToColor(hsv);\n\t\t\tmValDimmer.setColor(gray);\n\t\t}\n\n\t\t/**\n\t\t * Create a linear gradient shader to show variations in value.\n\t\t */\n\t\tprivate void setVerValSlider() {\n\t\t\tfloat[] hsv = new float[3];\n\t\t\thsv[0] = mHSV[0];\n\t\t\thsv[1] = mHSV[1];\n\t\t\thsv[2] = 1;\n\t\t\tint col = Color.HSVToColor(hsv);\n\n\t\t\tint colors[] = new int[2];\n\t\t\tcolors[0] = col;\n\t\t\tcolors[1] = 0xFF000000;\n\t\t\tGradientDrawable gradDraw = new GradientDrawable(Orientation.TOP_BOTTOM, colors);\n\t\t\tgradDraw.setDither(true);\n\t\t\tgradDraw.setLevel(10000);\n\t\t\tgradDraw.setBounds(0, 0, SLIDER_THICKNESS, PALETTE_DIM);\n\t\t\tgradDraw.draw(mVerSliderCv);\n\t\t}\n\n\t\t/**\n\t\t * Report the correct tightly bounded dimensions of the view.\n\t\t */\n\t\t@Override\n\t\tprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n\t\t\tsetMeasuredDimension(VIEW_DIM_X, VIEW_DIM_Y);\n\t\t}\n\n\t\t/**\n\t\t * Wrap Math.round().  I'm not a Java expert.  Is this the only way to avoid writing \"(int)Math.round\" everywhere?\n\t\t * @param x\n\t\t * @return\n\t\t */\n\t\tprivate int round(double x) {\n\t\t\treturn (int)Math.round(x);\n\t\t}\n\n\t\t/**\n\t\t * Limit a value to the range [0,1].\n\t\t * @param n\n\t\t * @return\n\t\t */\n\t\tprivate float pinToUnit(float n) {\n\t\t\tif (n < 0) {\n\t\t\t\tn = 0;\n\t\t\t} else if (n > 1) {\n\t\t\t\tn = 1;\n\t\t\t}\n\t\t\treturn n;\n\t\t}\n\n\t\t/**\n\t\t * Limit a value to the range [0,max].\n\t\t * @param n\n\t\t * @param max\n\t\t * @return\n\t\t */\n\t\tprivate float pin(float n, float max) {\n\t\t\tif (n < 0) {\n\t\t\t\tn = 0;\n\t\t\t} else if (n > max) {\n\t\t\t\tn = max;\n\t\t\t}\n\t\t\treturn n;\n\t\t}\n\n\t\t/**\n\t\t * Limit a value to the range [min,max].\n\t\t * @param n\n\t\t * @param min\n\t\t * @param max\n\t\t * @return\n\t\t */\n\t\tprivate float pin(float n, float min, float max) {\n\t\t\tif (n < min) {\n\t\t\t\tn = min;\n\t\t\t} else if (n > max) {\n\t\t\t\tn = max;\n\t\t\t}\n\t\t\treturn n;\n\t\t}\n\n\t\t/**\n\t\t * No clue what this does (some sort of average/mean I presume).  It came with the original UberColorPickerDialog\n\t\t * in the API Demos and wasn't documented.  I don't feel like spending any time figuring it out, I haven't looked at it at all.\n\t\t * @param s\n\t\t * @param d\n\t\t * @param p\n\t\t * @return\n\t\t */\n\t\tprivate int ave(int s, int d, float p) {\n\t\t\treturn s + round(p * (d - s));\n\t\t}\n\n\t\t/**\n\t\t * Came with the original UberColorPickerDialog in the API Demos, wasn't documented.  I believe it takes an array of\n\t\t * colors and a value in the range [0,1] and interpolates a resulting color in a seemingly predictable manner.\n\t\t * I haven't looked at it at all.\n\t\t * @param colors\n\t\t * @param unit\n\t\t * @return\n\t\t */\n\t\tprivate int interpColor(int colors[], float unit) {\n\t\t\tif (unit <= 0) {\n\t\t\t\treturn colors[0];\n\t\t\t}\n\t\t\tif (unit >= 1) {\n\t\t\t\treturn colors[colors.length - 1];\n\t\t\t}\n\n\t\t\tfloat p = unit * (colors.length - 1);\n\t\t\tint i = (int)p;\n\t\t\tp -= i;\n\n\t\t\t// now p is just the fractional part [0...1) and i is the index\n\t\t\tint c0 = colors[i];\n\t\t\tint c1 = colors[i+1];\n\t\t\tint a = ave(Color.alpha(c0), Color.alpha(c1), p);\n\t\t\tint r = ave(Color.red(c0), Color.red(c1), p);\n\t\t\tint g = ave(Color.green(c0), Color.green(c1), p);\n\t\t\tint b = ave(Color.blue(c0), Color.blue(c1), p);\n\n\t\t\treturn Color.argb(a, r, g, b);\n\t\t}\n\n\t\t/**\n\t\t * A standard point-in-rect routine.\n\t\t * @param x\n\t\t * @param y\n\t\t * @param r\n\t\t * @return true if point x,y is in rect r\n\t\t */\n\t\tpublic boolean ptInRect(int x, int y, Rect r) {\n\t\t\treturn x > r.left && x < r.right && y > r.top && y < r.bottom;\n\t\t}\n\n\t\t/**\n\t\t * Process trackball events.  Used mainly for fine-tuned color adjustment, or alternatively to switch between slider controls.\n\t\t */\n\t\t@Override\n\t\tpublic boolean dispatchTrackballEvent(MotionEvent event) {\n\t\t\tfloat x = event.getX();\n\t\t\tfloat y = event.getY();\n\n\t\t\t//A longer event history implies faster trackball movement.\n\t\t\t//Use it to infer a larger jump and therefore faster palette/slider adjustment.\n\t\t\tint jump = event.getHistorySize() + 1;\n\n\t\t\tswitch (event.getAction()) {\n\t\t\t\tcase MotionEvent.ACTION_DOWN: {\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase MotionEvent.ACTION_MOVE: {\n\t\t\t\t\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\t\t\t\t\t//To add a new method, replicate and extend the appropriate entry in this list,\n\t\t\t\t\t\t//depending on whether you use 1D or 2D controllers\n\t\t\t\t\t\tswitch (mMethod) {\n\t\t\t\t\t\t\tcase METHOD_HS_V_PALETTE:\n\t\t\t\t\t\t\t\tif (mFocusedControl == 0) {\n\t\t\t\t\t\t\t\t\tchangeHSPalette(x, y, jump);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (mFocusedControl == 1) {\n\t\t\t\t\t\t\t\t\tif (y < 0)\n\t\t\t\t\t\t\t\t\t\tchangeSlider(mFocusedControl, true, jump);\n\t\t\t\t\t\t\t\t\telse if (y > 0)\n\t\t\t\t\t\t\t\t\t\tchangeSlider(mFocusedControl, false, jump);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase MotionEvent.ACTION_UP: {\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\t//To add a new method, replicate and extend the appropriate functions below,\n\t\t//one per UI controller in the new method\n\t\t/**\n\t\t * Effect a trackball change to a 2D palette.\n\t\t * @param x -1: negative x change, 0: no x change, +1: positive x change.\n\t\t * @param y -1: negative y change, 0, no y change, +1: positive y change.\n\t\t * @param jump the amount by which to change.\n\t\t */\n\t\tprivate void changeHSPalette(float x, float y, int jump) {\n\t\t\tint x2 = 0, y2 = 0;\n\t\t\tif (x < 0)\n\t\t\t\tx2 = -jump;\n\t\t\telse if (x > 0)\n\t\t\t\tx2 = jump;\n\t\t\tif (y < 0)\n\t\t\t\ty2 = -jump;\n\t\t\telse if (y > 0)\n\t\t\t\ty2 = jump;\n\n\t\t \tmCoord[0] += x2;\n\t\t \tmCoord[1] += y2;\n\n\t\t \tif (mCoord[0] < -PALETTE_RADIUS)\n\t\t \t\tmCoord[0] = -PALETTE_RADIUS;\n\t\t \telse if (mCoord[0] > PALETTE_RADIUS)\n\t\t \t\tmCoord[0] = PALETTE_RADIUS;\n\t\t \tif (mCoord[1] < -PALETTE_RADIUS)\n\t\t \t\tmCoord[1] = -PALETTE_RADIUS;\n\t\t \telse if (mCoord[1] > PALETTE_RADIUS)\n\t\t \t\tmCoord[1] = PALETTE_RADIUS;\n\n\t\t\tfloat radius = (float)java.lang.Math.sqrt(mCoord[0] * mCoord[0] + mCoord[1] * mCoord[1]);\n\t\t\tif (radius > PALETTE_RADIUS)\n\t\t\t\tradius = PALETTE_RADIUS;\n\n\t\t\tfloat angle = (float)java.lang.Math.atan2(mCoord[1], mCoord[0]);\n\t\t\t// need to turn angle [-PI ... PI] into unit [0....1]\n\t\t\tfloat unit = angle/(2*PI);\n\t\t\tif (unit < 0) {\n\t\t\t\tunit += 1;\n\t\t\t}\n\n\t\t\tmCoord[0] = round(Math.cos(angle) * radius);\n\t\t\tmCoord[1] = round(Math.sin(angle) * radius);\n\n\t\t\tint c = interpColor(mSpectrumColorsRev, unit);\n\t\t\tfloat[] hsv = new float[3];\n\t\t\tColor.colorToHSV(c, hsv);\n\t\t\tmHSV[0] = hsv[0];\n\t\t\tmHSV[1] = radius / PALETTE_RADIUS;\n\t\t\tupdateAllFromHSV();\n\t\t\tmSwatchNew.setColor(Color.HSVToColor(mHSV));\n\n\t\t\tsetVerValSlider();\n\n\t\t\tinvalidate();\n\t\t}\n\n\t\t/**\n\t\t * Effect a trackball change to a 1D slider.\n\t\t * @param slider id of the slider to be effected\n\t\t * @param increase true if the change is an increase, false if a decrease\n\t\t * @param jump the amount by which to change in units of the range [0,255]\n\t\t */\n\t\tprivate void changeSlider(int slider, boolean increase, int jump) {\n\t\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\t\t//It is only necessary to add an entry here for a new method if the new method uses a 1D slider.\n\t\t\t//Note, some sliders are horizontal and others are vertical.\n\t\t\t//They differ a bit, especially in a sign flip on the vertical axis.\n\t\t\tif (mMethod == METHOD_HS_V_PALETTE) {\n\t\t\t\t//slider *must* equal 1\n\n\t\t\t\tmHSV[2] += (increase ? jump : -jump) / 256.0f;\n\t\t\t\tmHSV[2] = pinToUnit(mHSV[2]);\n\t\t\t\tupdateAllFromHSV();\n\t\t\t\tmCoord[2] = PALETTE_DIM - (int)(mHSV[2] * PALETTE_DIM);\n\n\t\t\t\tmSwatchNew.setColor(Color.HSVToColor(mHSV));\n\n\t\t\t\tsetOvalValDimmer();\n\n\t\t\t\tinvalidate();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Keep all colorspace representations in sync.\n\t\t */\n\t\tprivate void updateRGBfromHSV() {\n\t\t\tint color = Color.HSVToColor(mHSV);\n\t\t\tmRGB[0] = Color.red(color);\n\t\t\tmRGB[1] = Color.green(color);\n\t\t\tmRGB[2] = Color.blue(color);\n\t\t}\n\n\t\t/**\n\t\t * Keep all colorspace representations in sync.\n\t\t */\n\t\tprivate void updateYUVfromRGB() {\n\t\t\tfloat r = mRGB[0] / 255.0f;\n\t\t\tfloat g = mRGB[1] / 255.0f;\n\t\t\tfloat b = mRGB[2] / 255.0f;\n\n\t\t\tColorMatrix cm = new ColorMatrix();\n\t\t\tcm.setRGB2YUV();\n\t\t\tfinal float[] a = cm.getArray();\n\n\t\t\tmYUV[0] = a[0] * r + a[1] * g + a[2] * b;\n\t\t\tmYUV[0] = pinToUnit(mYUV[0]);\n\t\t\tmYUV[1] = a[5] * r + a[6] * g + a[7] * b;\n\t\t\tmYUV[1] = pin(mYUV[1], -.5f, .5f);\n\t\t\tmYUV[2] = a[10] * r + a[11] * g + a[12] * b;\n\t\t\tmYUV[2] = pin(mYUV[2], -.5f, .5f);\n\t\t}\n\n\t\t/**\n\t\t * Keep all colorspace representations in sync.\n\t\t */\n\t\tprivate void updateHexFromHSV() {\n\t\t\t//For now, assume 100% opacity\n\t\t\tmHexStr = Integer.toHexString(Color.HSVToColor(mHSV)).toUpperCase();\n\t\t\tmHexStr = mHexStr.substring(2, mHexStr.length());\n\t\t}\n\n\t\t/**\n\t\t * Keep all colorspace representations in sync.\n\t\t */\n\t\tprivate void updateAllFromHSV() {\n\t\t\t//Update mRGB\n\t\t\tif (mRGBenabled || mYUVenabled)\n\t\t\t\tupdateRGBfromHSV();\n\n\t\t\t//Update mYUV\n\t\t\tif (mYUVenabled)\n\t\t\t\tupdateYUVfromRGB();\n\n\t\t\t//Update mHexStr\n\t\t\tif (mRGBenabled)\n\t\t\t\tupdateHexFromHSV();\n\t\t}\n\n\t\t/**\n\t\t * Process touch events: down, move, and up\n\t\t */\n\t\t@Override\n\t\tpublic boolean onTouchEvent(MotionEvent event) {\n\t\t\tfloat x = event.getX();\n\t\t\tfloat y = event.getY();\n\n\t\t\t//Generate coordinates which are palette=local with the origin at the upper left of the main 2D palette\n\t\t\tint y2 = (int)(pin(round(y - PALETTE_POS_Y), PALETTE_DIM));\n\n\t\t\t//Generate coordinates which are palette-local with the origin at the center of the main 2D palette\n\t\t\tfloat circlePinnedX = x - PALETTE_POS_X - PALETTE_CENTER_X;\n\t\t\tfloat circlePinnedY = y - PALETTE_POS_Y - PALETTE_CENTER_Y;\n\n\t\t\t//Is the event in a swatch?\n\t\t\tboolean inSwatchOld = ptInRect(round(x), round(y), mOldSwatchRect);\n\t\t\tboolean inSwatchNew = ptInRect(round(x), round(y), mNewSwatchRect);\n\n\t\t\t//Get the event's distance from the center of the main 2D palette\n\t\t\tfloat radius = (float)java.lang.Math.sqrt(circlePinnedX * circlePinnedX + circlePinnedY * circlePinnedY);\n\n\t\t\t//Is the event in a circle-pinned 2D palette?\n\t\t\tboolean inOvalPalette = radius <= PALETTE_RADIUS;\n\n\t\t\t//Pin the radius\n\t\t\tif (radius > PALETTE_RADIUS)\n\t\t\t\tradius = PALETTE_RADIUS;\n\n\t\t\t//Is the event in a vertical slider to the right of the main 2D palette\n\t\t\tboolean inVerSlider = ptInRect(round(x), round(y), mVerSliderRect);\n\n\t\t\tswitch (event.getAction()) {\n\t\t\t\tcase MotionEvent.ACTION_DOWN:\n\t\t\t\t\tmTracking = TRACKED_NONE;\n\n\t\t\t\t\tif (inSwatchOld)\n\t\t\t\t\t\tmTracking = TRACK_SWATCH_OLD;\n\t\t\t\t\telse if (inSwatchNew)\n\t\t\t\t\t\tmTracking = TRACK_SWATCH_NEW;\n\n\t\t\t\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\t\t\t\t//To add a new method, replicate and extend the last entry in this list\n\t\t\t\t\telse if (mMethod == METHOD_HS_V_PALETTE) {\n\t\t\t\t\t\tif (inOvalPalette) {\n\t\t\t\t\t\t\tmTracking = TRACK_HS_PALETTE;\n\t\t\t\t\t\t\tmFocusedControl = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (inVerSlider) {\n\t\t\t\t\t\t\tmTracking = TRACK_VER_VALUE_SLIDER;\n\t\t\t\t\t\t\tmFocusedControl = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tcase MotionEvent.ACTION_MOVE:\n\t\t\t\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\t\t\t\t//To add a new method, replicate and extend the entries in this list,\n\t\t\t\t\t//one per UI controller the new method requires.\n\t\t\t\t\tif (mTracking == TRACK_HS_PALETTE) {\n\t\t\t\t\t\tfloat angle = (float)java.lang.Math.atan2(circlePinnedY, circlePinnedX);\n\t\t\t\t\t\t// need to turn angle [-PI ... PI] into unit [0....1]\n\t\t\t\t\t\tfloat unit = angle/(2*PI);\n\t\t\t\t\t\tif (unit < 0) {\n\t\t\t\t\t\t\tunit += 1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmCoord[0] = round(Math.cos(angle) * radius);\n\t\t\t\t\t\tmCoord[1] = round(Math.sin(angle) * radius);\n\n\t\t\t\t\t\tint c = interpColor(mSpectrumColorsRev, unit);\n\t\t\t\t\t\tfloat[] hsv = new float[3];\n\t\t\t\t\t\tColor.colorToHSV(c, hsv);\n\t\t\t\t\t\tmHSV[0] = hsv[0];\n\t\t\t\t\t\tmHSV[1] = radius / PALETTE_RADIUS;\n\t\t\t\t\t\tupdateAllFromHSV();\n\t\t\t\t\t\tmSwatchNew.setColor(Color.HSVToColor(mHSV));\n\n\t\t\t\t\t\tsetVerValSlider();\n\n\t\t\t\t\t\tinvalidate();\n\t\t\t\t\t}\n\t\t\t\t\telse if (mTracking == TRACK_VER_VALUE_SLIDER) {\n\t\t\t\t\t\tif (mCoord[2] != y2) {\n\t\t\t\t\t\t\tmCoord[2] = y2;\n\t\t\t\t\t\t\tfloat value = 1.0f - (float)y2 / (float)PALETTE_DIM;\n\n\t\t\t\t\t\t\tmHSV[2] = value;\n\t\t\t\t\t\t\tupdateAllFromHSV();\n\t\t\t\t\t\t\tmSwatchNew.setColor(Color.HSVToColor(mHSV));\n\n\t\t\t\t\t\t\tsetOvalValDimmer();\n\n\t\t\t\t\t\t\tinvalidate();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase MotionEvent.ACTION_UP:\n\t\t\t\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\t\t\t\t//To add a new method, replicate and extend the last entry in this list.\n\t\t\t\t\tif (mTracking == TRACK_SWATCH_OLD && inSwatchOld) {\n\t\t\t\t\t\tColor.colorToHSV(mOriginalColor, mHSV);\n\t\t\t\t\t\tmSwatchNew.setColor(mOriginalColor);\n\t\t\t\t\t\tinitUI();\n\t\t\t\t\t\tinvalidate();\n\t\t\t\t\t}\n\t\t\t\t\telse if (mTracking == TRACK_SWATCH_NEW && inSwatchNew) {\n\t\t\t\t\t\tmListener.colorChanged(mSwatchNew.getColor());\n\t\t\t\t\t\tinvalidate();\n\t\t\t\t\t}\n\n\t\t\t\t\tmTracking= TRACKED_NONE;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t}\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * 090408\n * Keith Wiley\n * kwiley@keithwiley.com\n * http://keithwiley.com\n *\n * UberColorPickerDialog v1.1\n *\n * This color picker was implemented as a (significant) extension of the\n * ColorPickerDialog class provided in the Android API Demos.  You are free\n * to drop it unchanged into your own projects or to modify it as you see\n * fit.  I would appreciate it if this comment block were let intact,\n * merely for credit's sake.\n *\n * Enjoy!\n */\n\npackage org.connectbot.util;\n\nimport org.connectbot.R;\n\nimport android.app.Dialog;\nimport android.content.Context;\nimport android.graphics.Bitmap;\nimport android.graphics.Canvas;\nimport android.graphics.Color;\nimport android.graphics.ColorMatrix;\nimport android.graphics.ComposeShader;\nimport android.graphics.Paint;\nimport android.graphics.PorterDuff;\nimport android.graphics.PorterDuffXfermode;\nimport android.graphics.RadialGradient;\nimport android.graphics.Rect;\nimport android.graphics.RectF;\nimport android.graphics.Shader;\nimport android.graphics.SweepGradient;\nimport android.graphics.drawable.GradientDrawable;\nimport android.graphics.drawable.GradientDrawable.Orientation;\nimport android.os.Bundle;\nimport android.util.DisplayMetrics;\nimport android.view.MotionEvent;\nimport android.view.View;\n\n/**\n * UberColorPickerDialog is a seriously enhanced version of the UberColorPickerDialog\n * class provided in the Android API Demos.<p>\n *\n * NOTE (from Kenny Root): This is a VERY slimmed down version custom for ConnectBot.\n * Visit Keith's site for the full version at the URL listed in the author line.<p>\n *\n * @author Keith Wiley, kwiley@keithwiley.com, http://keithwiley.com\n */\npublic class UberColorPickerDialog extends Dialog {\n\tprivate final OnColorChangedListener mListener;\n\tprivate final int mInitialColor;\n\n\t/**\n\t * Callback to the creator of the dialog, informing the creator of a new color and notifying that the dialog is about to dismiss.\n\t */\n\tpublic interface OnColorChangedListener {\n\t\tvoid colorChanged(int color);\n\t}\n\n\t/**\n\t * Ctor\n\t * @param context\n\t * @param listener\n\t * @param initialColor\n\t */\n\tpublic UberColorPickerDialog(Context context,\n\t\t\t\t\t\t\tOnColorChangedListener listener,\n\t\t\t\t\t\t\tint initialColor) {\n\t\tsuper(context);\n\n\t\tmListener = listener;\n\t\tmInitialColor = initialColor;\n\t}\n\n\t/**\n\t * Activity entry point\n\t */\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tOnColorChangedListener l = new OnColorChangedListener() {\n\t\t\tpublic void colorChanged(int color) {\n\t\t\t\tmListener.colorChanged(color);\n\t\t\t\tdismiss();\n\t\t\t}\n\t\t};\n\n\t\tDisplayMetrics dm = new DisplayMetrics();\n\t\tgetWindow().getWindowManager().getDefaultDisplay().getMetrics(dm);\n\t\tint screenWidth = dm.widthPixels;\n\t\tint screenHeight = dm.heightPixels;\n\n\t\tsetTitle(getContext().getResources().getString(R.string.title_color_picker));\n\n\t\ttry {\n\t\t\tsetContentView(new ColorPickerView(getContext(), l, screenWidth, screenHeight, mInitialColor));\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t//There is currently only one kind of ctor exception, that where no methods are enabled.\n\t\t\tdismiss();\t//This doesn't work!  The dialog is still shown (its title at least, the layout is empty from the exception being thrown).  <sigh>\n\t\t}\n\t}\n\n\t/**\n\t * ColorPickerView is the meat of this color picker (as opposed to the enclosing class).\n\t * All the heavy lifting is done directly by this View subclass.\n\t * <P>\n\t * You can enable/disable whichever color chooser methods you want by modifying the ENABLED_METHODS switches.  They *should*\n\t * do all the work required to properly enable/disable methods without losing track of what goes with what and what maps to what.\n\t * <P>\n\t * If you add a new color chooser method, do a text search for \"NEW_METHOD_WORK_NEEDED_HERE\".  That tag indicates all\n\t * the locations in the code that will have to be amended in order to properly add a new color chooser method.\n\t * I highly recommend adding new methods to the end of the list.  If you want to try to reorder the list, you're on your own.\n\t */\n\tprivate static class ColorPickerView extends View {\n\t\tprivate static int SWATCH_WIDTH_PORTRAIT_DP = 95;\n\t\tprivate static int SWATCH_WIDTH_LANDSCAPE_DP = 110;\n\t\tprivate static final int SWATCH_HEIGHT_DP = 60;\n\n\t\tprivate static final int PALETTE_DIM_DP = SWATCH_WIDTH_PORTRAIT_DP * 2;\n\n\t\tprivate static final int SLIDER_THICKNESS_DP = 40;\n\n\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\tprivate static final int METHOD_HS_V_PALETTE = 0;\n\n\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\t//Add a new entry to the list for each controller in the new method\n\t\tprivate static final int TRACKED_NONE = -1;\t//No object on screen is currently being tracked\n\t\tprivate static final int TRACK_SWATCH_OLD = 10;\n\t\tprivate static final int TRACK_SWATCH_NEW = 11;\n\t\tprivate static final int TRACK_HS_PALETTE = 30;\n\t\tprivate static final int TRACK_VER_VALUE_SLIDER = 31;\n\n\t\tprivate static final int TEXT_SIZE_DP = 12;\n\t\tprivate static final int TEXT_SIZE_LABEL_DP = 12;\n\n\t\tprivate static final int BUTTON_TEXT_MARGIN_DP = 16;\n\n\t\tprivate static int[] TEXT_HSV_POS = new int[2];\n\t\tprivate static int[] TEXT_RGB_POS = new int[2];\n\t\tprivate static int[] TEXT_YUV_POS = new int[2];\n\t\tprivate static int[] TEXT_HEX_POS = new int[2];\n\n\t\tprivate static final float PI = 3.141592653589793f;\n\n\t\tprivate final int mSwatchWidthPx;\n\t\tprivate final int mTextSizePx;\n\t\tprivate final int mTextSizeLabelPx;\n\t\tprivate final int mPalettePosX;\n\t\tprivate final int mPalettePosY;\n\t\tprivate final int mPaletteDimPx;\n\t\tprivate final int mPaletteRadiusPx;\n\t\tprivate final int mSliderThicknessPx;\n\t\tprivate final int mViewDimXPx;\n\t\tprivate final int mViewDimYPx;\n\t\tprivate final int mPaletteCenterPx;\n\t\tprivate final int mButtonTextMarginPx;\n\n\t\tprivate int mMethod = METHOD_HS_V_PALETTE;\n\t\tprivate int mTracking = TRACKED_NONE;\t//What object on screen is currently being tracked for movement\n\n\t\t//Zillions of persistant Paint objecs for drawing the View\n\n\t\tprivate Paint mSwatchOld, mSwatchNew;\n\n\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\t//Add Paints to represent the palettes of the new method's UI controllers\n\t\tprivate Paint mOvalHueSat;\n\n\t\tprivate Bitmap mVerSliderBM;\n\t\tprivate Canvas mVerSliderCv;\n\n\t\tprivate Bitmap[] mHorSlidersBM = new Bitmap[3];\n\t\tprivate Canvas[] mHorSlidersCv = new Canvas[3];\n\n\t\tprivate Paint mValDimmer;\n\n\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\t//Add Paints to represent the icon for the new method\n\t\tprivate Paint mOvalHueSatSmall;\n\n\t\tprivate Paint mPosMarker;\n\t\tprivate Paint mText;\n\n\t\tprivate Rect mOldSwatchRect = new Rect();\n\t\tprivate Rect mNewSwatchRect = new Rect();\n\t\tprivate Rect mPaletteRect = new Rect();\n\t\tprivate Rect mVerSliderRect = new Rect();\n\n\t\tprivate int[] mSpectrumColorsRev;\n\t\tprivate int mOriginalColor = 0;\t//The color passed in at the beginning, which can be reverted to at any time by tapping the old swatch.\n\t\tprivate float[] mHSV = new float[3];\n\t\tprivate int[] mRGB = new int[3];\n\t\tprivate float[] mYUV = new float[3];\n\t\tprivate String mHexStr = \"\";\n\t\tprivate boolean mHSVenabled = true;\t//Only true if an HSV method is enabled\n\t\tprivate boolean mRGBenabled = true;\t//Only true if an RGB method is enabled\n\t\tprivate boolean mYUVenabled = true;\t//Only true if a YUV method is enabled\n\t\tprivate boolean mHexenabled = true;\t//Only true if an RGB method is enabled\n\t\tprivate int[] mCoord = new int[3];\t\t//For drawing slider/palette markers\n\t\tprivate int mFocusedControl = -1;\t//Which control receives trackball events.\n\t\tprivate OnColorChangedListener mListener;\n\n\t\t/**\n\t\t * Ctor.\n\t\t * @param c\n\t\t * @param l\n\t\t * @param width Used to determine orientation and adjust layout accordingly\n\t\t * @param height Used to determine orientation and adjust layout accordingly\n\t\t * @param color The initial color\n\t\t * @throws Exception\n\t\t */\n\t\tColorPickerView(Context c, OnColorChangedListener l, int width, int height, int color)\n\t\tthrows Exception {\n\t\t\tsuper(c);\n\n\t\t\tDisplayMetrics metrics = c.getResources().getDisplayMetrics();\n\t\t\tmTextSizePx = (int) (TEXT_SIZE_DP * metrics.density + 0.5f);\n\t\t\tmTextSizeLabelPx = (int) (TEXT_SIZE_LABEL_DP * metrics.density + 0.5f);\n\n\t\t\t//We need to make the dialog focusable to retrieve trackball events.\n\t\t\tsetFocusable(true);\n\n\t\t\tmListener = l;\n\n\t\t\tmOriginalColor = color;\n\n\t\t\tColor.colorToHSV(color, mHSV);\n\n\t\t\tupdateAllFromHSV();\n\n\t\t\tmPaletteDimPx = (int) (PALETTE_DIM_DP * metrics.density + 0.5f);\n\t\t\tmSliderThicknessPx = (int) (SLIDER_THICKNESS_DP * metrics.density + 0.5f);\n\t\t\tmButtonTextMarginPx = (int) (BUTTON_TEXT_MARGIN_DP * metrics.density + 0.5f);\n\n\t\t\t//Setup the layout based on whether this is a portrait or landscape orientation.\n\t\t\tif (width <= height) {        //Portrait layout\n\t\t\t\tmSwatchWidthPx = (int) (((PALETTE_DIM_DP + SLIDER_THICKNESS_DP) / 2) * metrics.density + 0.5f);\n\t\t\t\tfinal int swatchHeightPx = (int) (SWATCH_HEIGHT_DP * metrics.density + 0.5f);\n\n\t\t\t\tmPalettePosX = 0;\n\t\t\t\tmPalettePosY = mTextSizePx * 4 + swatchHeightPx;\n\n\t\t\t\t//Set more rects, lots of rects\n\t\t\t\tmOldSwatchRect.set(0, mTextSizePx * 4, mSwatchWidthPx, mTextSizePx * 4 + swatchHeightPx);\n\t\t\t\tmNewSwatchRect.set(mSwatchWidthPx, mTextSizePx * 4, mSwatchWidthPx * 2, mTextSizePx * 4 + swatchHeightPx);\n\t\t\t\tmPaletteRect.set(0, mPalettePosY, mPaletteDimPx, mPalettePosY + mPaletteDimPx);\n\t\t\t\tmVerSliderRect.set(mPaletteDimPx, mPalettePosY, mPaletteDimPx + mSliderThicknessPx, mPalettePosY + mPaletteDimPx);\n\n\t\t\t\tTEXT_HSV_POS[0] = (int) (3 * metrics.density + 0.5f);\n\t\t\t\tTEXT_HSV_POS[1] = 0;\n\t\t\t\tTEXT_RGB_POS[0] = TEXT_HSV_POS[0] + (int) (50 * metrics.density + 0.5f);\n\t\t\t\tTEXT_RGB_POS[1] = TEXT_HSV_POS[1];\n\t\t\t\tTEXT_YUV_POS[0] = TEXT_HSV_POS[0] + (int) (100 * metrics.density + 0.5f);\n\t\t\t\tTEXT_YUV_POS[1] = TEXT_HSV_POS[1];\n\t\t\t\tTEXT_HEX_POS[0] = TEXT_HSV_POS[0] + (int) (150 * metrics.density + 0.5f);\n\t\t\t\tTEXT_HEX_POS[1] = TEXT_HSV_POS[1];\n\n\t\t\t\tmViewDimXPx = mPaletteDimPx + mSliderThicknessPx;\n\t\t\t\tmViewDimYPx = swatchHeightPx + mPaletteDimPx + mTextSizePx * 4;\n\t\t\t} else {        //Landscape layout\n\t\t\t\tmSwatchWidthPx = (int) (SWATCH_WIDTH_LANDSCAPE_DP * metrics.density + 0.5f);\n\t\t\t\tfinal int swatchHeightPx = (int) (SWATCH_HEIGHT_DP * metrics.density + 0.5f);\n\n\t\t\t\tmPalettePosX = mSwatchWidthPx;\n\t\t\t\tmPalettePosY = 0;\n\n\t\t\t\t//Set more rects, lots of rects\n\t\t\t\tmOldSwatchRect.set(0, mTextSizePx * 7, mSwatchWidthPx, mTextSizePx * 7 + swatchHeightPx);\n\t\t\t\tmNewSwatchRect.set(0, mTextSizePx * 7 + mSliderThicknessPx, mSwatchWidthPx, mTextSizePx * 7 + swatchHeightPx * 2);\n\t\t\t\tmPaletteRect.set(mSwatchWidthPx, mPalettePosY, mSwatchWidthPx + mPaletteDimPx, mPalettePosY + mPaletteDimPx);\n\t\t\t\tmVerSliderRect.set(mSwatchWidthPx + mPaletteDimPx, mPalettePosY, mSwatchWidthPx + mPaletteDimPx + mSliderThicknessPx, mPalettePosY + mPaletteDimPx);\n\n\t\t\t\tTEXT_HSV_POS[0] = (int) (3 * metrics.density + 0.5f);\n\t\t\t\tTEXT_HSV_POS[1] = 0;\n\t\t\t\tTEXT_RGB_POS[0] = TEXT_HSV_POS[0];\n\t\t\t\tTEXT_RGB_POS[1] = (int) (TEXT_HSV_POS[1] + mTextSizePx * 3.5);\n\t\t\t\tTEXT_YUV_POS[0] = TEXT_HSV_POS[0] + (int) (50 * metrics.density + 0.5f);\n\t\t\t\tTEXT_YUV_POS[1] = (int) (TEXT_HSV_POS[1] + mTextSizePx * 3.5);\n\t\t\t\tTEXT_HEX_POS[0] = TEXT_HSV_POS[0] + (int) (50 * metrics.density + 0.5f);\n\t\t\t\tTEXT_HEX_POS[1] = TEXT_HSV_POS[1];\n\n\t\t\t\tmViewDimXPx = mPalettePosX + mPaletteDimPx + mSliderThicknessPx;\n\t\t\t\tmViewDimYPx = Math.max(mNewSwatchRect.bottom, mPaletteDimPx);\n\t\t\t}\n\n\t\t\tmPaletteCenterPx = mPaletteDimPx / 2;\n\t\t\tmPaletteRadiusPx = mPaletteDimPx / 2;\n\n\t\t\t//Rainbows make everybody happy!\n\t\t\tmSpectrumColorsRev = new int[] {\n\t\t\t\t0xFFFF0000, 0xFFFF00FF, 0xFF0000FF, 0xFF00FFFF,\n\t\t\t\t0xFF00FF00, 0xFFFFFF00, 0xFFFF0000,\n\t\t\t};\n\n\t\t\t//Setup all the Paint and Shader objects.  There are lots of them!\n\n\t\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\t\t//Add Paints to represent the palettes of the new method's UI controllers\n\n\t\t\tmSwatchOld = new Paint(Paint.ANTI_ALIAS_FLAG);\n\t\t\tmSwatchOld.setStyle(Paint.Style.FILL);\n\t\t\tmSwatchOld.setColor(Color.HSVToColor(mHSV));\n\n\t\t\tmSwatchNew = new Paint(Paint.ANTI_ALIAS_FLAG);\n\t\t\tmSwatchNew.setStyle(Paint.Style.FILL);\n\t\t\tmSwatchNew.setColor(Color.HSVToColor(mHSV));\n\n\t\t\tShader shaderA = new SweepGradient(0, 0, mSpectrumColorsRev, null);\n\t\t\tShader shaderB = new RadialGradient(0, 0, mPaletteCenterPx, 0xFFFFFFFF, 0xFF000000, Shader.TileMode.CLAMP);\n\t\t\tShader shader = new ComposeShader(shaderA, shaderB, PorterDuff.Mode.SCREEN);\n\t\t\tmOvalHueSat = new Paint(Paint.ANTI_ALIAS_FLAG);\n\t\t\tmOvalHueSat.setShader(shader);\n\t\t\tmOvalHueSat.setStyle(Paint.Style.FILL);\n\t\t\tmOvalHueSat.setDither(true);\n\n\t\t\tmVerSliderBM = Bitmap.createBitmap(mSliderThicknessPx, mPaletteDimPx, Bitmap.Config.RGB_565);\n\t\t\tmVerSliderCv = new Canvas(mVerSliderBM);\n\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tmHorSlidersBM[i] = Bitmap.createBitmap(mPaletteDimPx, mSliderThicknessPx, Bitmap.Config.RGB_565);\n\t\t\t\tmHorSlidersCv[i] = new Canvas(mHorSlidersBM[i]);\n\t\t\t}\n\n\t\t\tmValDimmer = new Paint(Paint.ANTI_ALIAS_FLAG);\n\t\t\tmValDimmer.setStyle(Paint.Style.FILL);\n\t\t\tmValDimmer.setDither(true);\n\t\t\tmValDimmer.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.MULTIPLY));\n\n\t\t\t//Whew, we're done making the big Paints and Shaders for the swatches, palettes, and sliders.\n\t\t\t//Now we need to make the Paints and Shaders that will draw the little method icons in the method selector list.\n\n\t\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\t\t//Add Paints to represent the icon for the new method\n\n\t\t\tshaderA = new SweepGradient(0, 0, mSpectrumColorsRev, null);\n\t\t\tshaderB = new RadialGradient(0, 0, mPaletteDimPx / 2, 0xFFFFFFFF, 0xFF000000, Shader.TileMode.CLAMP);\n\t\t\tshader = new ComposeShader(shaderA, shaderB, PorterDuff.Mode.SCREEN);\n\t\t\tmOvalHueSatSmall = new Paint(Paint.ANTI_ALIAS_FLAG);\n\t\t\tmOvalHueSatSmall.setShader(shader);\n\t\t\tmOvalHueSatSmall.setStyle(Paint.Style.FILL);\n\n\t\t\t//Make a simple stroking Paint for drawing markers and borders and stuff like that.\n\t\t\tmPosMarker = new Paint(Paint.ANTI_ALIAS_FLAG);\n\t\t\tmPosMarker.setStyle(Paint.Style.STROKE);\n\t\t\tmPosMarker.setStrokeWidth(2);\n\n\t\t\t//Make a basic text Paint.\n\t\t\tmText = new Paint(Paint.ANTI_ALIAS_FLAG);\n\t\t\tmText.setTextSize(mTextSizePx);\n\t\t\tmText.setColor(Color.WHITE);\n\n\t\t\t//Kickstart\n\t\t\tinitUI();\n\t\t}\n\n\t\t/**\n\t\t * Draw the entire view (the entire dialog).\n\t\t */\n\t\t@Override\n\t\tprotected void onDraw(Canvas canvas) {\n\t\t\t//Draw the old and new swatches\n\t\t\tdrawSwatches(canvas);\n\n\t\t\t//Write the text\n\t\t\twriteColorParams(canvas);\n\n\t\t\t//Draw the palette and sliders (the UI)\n\t\t\tif (mMethod == METHOD_HS_V_PALETTE)\n\t\t\t\tdrawHSV1Palette(canvas);\n\t\t}\n\n\t\t/**\n\t\t * Draw the old and new swatches.\n\t\t * @param canvas\n\t\t */\n\t\tprivate void drawSwatches(Canvas canvas) {\n\t\t\tfloat[] hsv = new float[3];\n\n\t\t\tmText.setTextSize(mTextSizePx);\n\n\t\t\t//Draw the original swatch\n\t\t\tcanvas.drawRect(mOldSwatchRect, mSwatchOld);\n\t\t\tColor.colorToHSV(mOriginalColor, hsv);\n\t\t\t//if (UberColorPickerDialog.isGray(mColor))\t//Don't need this right here, but imp't to note\n\t\t\t//\thsv[1] = 0;\n\t\t\tif (hsv[2] > .5)\n\t\t\t\tmText.setColor(Color.BLACK);\n\t\t\tcanvas.drawText(\"Revert\", mOldSwatchRect.left + mSwatchWidthPx / 2 - mText.measureText(\"Revert\") / 2, mOldSwatchRect.top + mButtonTextMarginPx, mText);\n\t\t\tmText.setColor(Color.WHITE);\n\n\t\t\t//Draw the new swatch\n\t\t\tcanvas.drawRect(mNewSwatchRect, mSwatchNew);\n\t\t\tif (mHSV[2] > .5)\n\t\t\t\tmText.setColor(Color.BLACK);\n\t\t\tcanvas.drawText(\"Accept\", mNewSwatchRect.left + mSwatchWidthPx / 2 - mText.measureText(\"Accept\") / 2, mNewSwatchRect.top + mButtonTextMarginPx, mText);\n\t\t\tmText.setColor(Color.WHITE);\n\n\t\t\tmText.setTextSize(mTextSizePx);\n\t\t}\n\n\t\t/**\n\t\t * Write the color parametes (HSV, RGB, YUV, Hex, etc.).\n\t\t * @param canvas\n\t\t */\n\t\tprivate void writeColorParams(Canvas canvas) {\n\t\t\tif (mHSVenabled) {\n\t\t\t\tcanvas.drawText(\"H: \" + Integer.toString((int) (mHSV[0] / 360.0f * 255)), TEXT_HSV_POS[0], TEXT_HSV_POS[1] + mTextSizePx, mText);\n\t\t\t\tcanvas.drawText(\"S: \" + Integer.toString((int) (mHSV[1] * 255)), TEXT_HSV_POS[0], TEXT_HSV_POS[1] + mTextSizePx * 2, mText);\n\t\t\t\tcanvas.drawText(\"V: \" + Integer.toString((int) (mHSV[2] * 255)), TEXT_HSV_POS[0], TEXT_HSV_POS[1] + mTextSizePx * 3, mText);\n\t\t\t}\n\n\t\t\tif (mRGBenabled) {\n\t\t\t\tcanvas.drawText(\"R: \" + mRGB[0], TEXT_RGB_POS[0], TEXT_RGB_POS[1] + mTextSizePx, mText);\n\t\t\t\tcanvas.drawText(\"G: \" + mRGB[1], TEXT_RGB_POS[0], TEXT_RGB_POS[1] + mTextSizePx * 2, mText);\n\t\t\t\tcanvas.drawText(\"B: \" + mRGB[2], TEXT_RGB_POS[0], TEXT_RGB_POS[1] + mTextSizePx * 3, mText);\n\t\t\t}\n\n\t\t\tif (mYUVenabled) {\n\t\t\t\tcanvas.drawText(\"Y: \" + Integer.toString((int) (mYUV[0] * 255)), TEXT_YUV_POS[0], TEXT_YUV_POS[1] + mTextSizePx, mText);\n\t\t\t\tcanvas.drawText(\"U: \" + Integer.toString((int) ((mYUV[1] + .5f) * 255)), TEXT_YUV_POS[0], TEXT_YUV_POS[1] + mTextSizePx * 2, mText);\n\t\t\t\tcanvas.drawText(\"V: \" + Integer.toString((int) ((mYUV[2] + .5f) * 255)), TEXT_YUV_POS[0], TEXT_YUV_POS[1] + mTextSizePx * 3, mText);\n\t\t\t}\n\n\t\t\tif (mHexenabled)\n\t\t\t\tcanvas.drawText(\"#\" + mHexStr, TEXT_HEX_POS[0], TEXT_HEX_POS[1] + mTextSizePx, mText);\n\t\t}\n\n\t\t/**\n\t\t * Place a small circle on the 2D palette to indicate the current values.\n\t\t * @param canvas\n\t\t * @param markerPosX\n\t\t * @param markerPosY\n\t\t */\n\t\tprivate void mark2DPalette(Canvas canvas, int markerPosX, int markerPosY) {\n\t\t\tmPosMarker.setColor(Color.BLACK);\n\t\t\tcanvas.drawOval(new RectF(markerPosX - 5, markerPosY - 5, markerPosX + 5, markerPosY + 5), mPosMarker);\n\t\t\tmPosMarker.setColor(Color.WHITE);\n\t\t\tcanvas.drawOval(new RectF(markerPosX - 3, markerPosY - 3, markerPosX + 3, markerPosY + 3), mPosMarker);\n\t\t}\n\n\t\t/**\n\t\t * Draw a line across the slider to indicate its current value.\n\t\t * @param canvas\n\t\t * @param markerPos\n\t\t */\n\t\tprivate void markVerSlider(Canvas canvas, int markerPos) {\n\t\t\tmPosMarker.setColor(Color.BLACK);\n\t\t\tcanvas.drawRect(new Rect(0, markerPos - 2, mSliderThicknessPx, markerPos + 3), mPosMarker);\n\t\t\tmPosMarker.setColor(Color.WHITE);\n\t\t\tcanvas.drawRect(new Rect(0, markerPos, mSliderThicknessPx, markerPos + 1), mPosMarker);\n\t\t}\n\n\t\t/**\n\t\t * Frame the slider to indicate that it has trackball focus.\n\t\t * @param canvas\n\t\t */\n\t\tprivate void hilightFocusedVerSlider(Canvas canvas) {\n\t\t\tmPosMarker.setColor(Color.WHITE);\n\t\t\tcanvas.drawRect(new Rect(0, 0, mSliderThicknessPx, mPaletteDimPx), mPosMarker);\n\t\t\tmPosMarker.setColor(Color.BLACK);\n\t\t\tcanvas.drawRect(new Rect(2, 2, mSliderThicknessPx - 2, mPaletteDimPx - 2), mPosMarker);\n\t\t}\n\n\t\t/**\n\t\t * Frame the 2D palette to indicate that it has trackball focus.\n\t\t * @param canvas\n\t\t */\n\t\tprivate void hilightFocusedOvalPalette(Canvas canvas) {\n\t\t\tmPosMarker.setColor(Color.WHITE);\n\t\t\tcanvas.drawOval(new RectF(-mPaletteRadiusPx, -mPaletteRadiusPx, mPaletteRadiusPx, mPaletteRadiusPx), mPosMarker);\n\t\t\tmPosMarker.setColor(Color.BLACK);\n\t\t\tcanvas.drawOval(new RectF(-mPaletteRadiusPx + 2, -mPaletteRadiusPx + 2, mPaletteRadiusPx - 2, mPaletteRadiusPx - 2), mPosMarker);\n\t\t}\n\n\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\t//To add a new method, replicate the basic draw functions here.  Use the 2D palette or 1D sliders as templates for the new method.\n\t\t/**\n\t\t * Draw the UI for HSV with angular H and radial S combined in 2D and a 1D V slider.\n\t\t * @param canvas\n\t\t */\n\t\tprivate void drawHSV1Palette(Canvas canvas) {\n\t\t\tcanvas.save();\n\n\t\t\tcanvas.translate(mPalettePosX, mPalettePosY);\n\n\t\t\t//Draw the 2D palette\n\t\t\tcanvas.translate(mPaletteCenterPx, mPaletteCenterPx);\n\t\t\tcanvas.drawOval(new RectF(-mPaletteRadiusPx, -mPaletteRadiusPx, mPaletteRadiusPx, mPaletteRadiusPx), mOvalHueSat);\n\t\t\tcanvas.drawOval(new RectF(-mPaletteRadiusPx, -mPaletteRadiusPx, mPaletteRadiusPx, mPaletteRadiusPx), mValDimmer);\n\t\t\tif (mFocusedControl == 0)\n\t\t\t\thilightFocusedOvalPalette(canvas);\n\t\t\tmark2DPalette(canvas, mCoord[0], mCoord[1]);\n\t\t\tcanvas.translate(-mPaletteCenterPx, -mPaletteCenterPx);\n\n\t\t\t//Draw the 1D slider\n\t\t\tcanvas.translate(mPaletteDimPx, 0);\n\t\t\tcanvas.drawBitmap(mVerSliderBM, 0, 0, null);\n\t\t\tif (mFocusedControl == 1)\n\t\t\t\thilightFocusedVerSlider(canvas);\n\t\t\tmarkVerSlider(canvas, mCoord[2]);\n\n\t\t\tcanvas.restore();\n\t\t}\n\n\t\t/**\n\t\t * Initialize the current color chooser's UI (set its color parameters and set its palette and slider values accordingly).\n\t\t */\n\t\tprivate void initUI() {\n\t\t\tinitHSV1Palette();\n\n\t\t\t//Focus on the first controller (arbitrary).\n\t\t\tmFocusedControl = 0;\n\t\t}\n\n\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\t//To add a new method, replicate and extend the last init function shown below\n\t\t/**\n\t\t * Initialize a color chooser.\n\t\t */\n\t\tprivate void initHSV1Palette() {\n\t\t\tsetOvalValDimmer();\n\t\t\tsetVerValSlider();\n\n\t\t\tfloat angle = 2 * PI - mHSV[0] / (180 / 3.1415927f);\n\t\t\tfloat radius = mHSV[1] * mPaletteRadiusPx;\n\t\t\tmCoord[0] = (int) (Math.cos(angle) * radius);\n\t\t\tmCoord[1] = (int) (Math.sin(angle) * radius);\n\n\t\t\tmCoord[2] = mPaletteDimPx - (int) (mHSV[2] * mPaletteDimPx);\n\t\t}\n\n\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\t//To add a new method, replicate and extend the set functions below, one per UI controller in the new method\n\t\t/**\n\t\t * Adjust a Paint which, when painted, dims its underlying object to show the effects of varying value (brightness).\n\t\t */\n\t\tprivate void setOvalValDimmer() {\n\t\t\tfloat[] hsv = new float[3];\n\t\t\thsv[0] = mHSV[0];\n\t\t\thsv[1] = 0;\n\t\t\thsv[2] = mHSV[2];\n\t\t\tint gray = Color.HSVToColor(hsv);\n\t\t\tmValDimmer.setColor(gray);\n\t\t}\n\n\t\t/**\n\t\t * Create a linear gradient shader to show variations in value.\n\t\t */\n\t\tprivate void setVerValSlider() {\n\t\t\tfloat[] hsv = new float[3];\n\t\t\thsv[0] = mHSV[0];\n\t\t\thsv[1] = mHSV[1];\n\t\t\thsv[2] = 1;\n\t\t\tint col = Color.HSVToColor(hsv);\n\n\t\t\tint colors[] = new int[2];\n\t\t\tcolors[0] = col;\n\t\t\tcolors[1] = 0xFF000000;\n\t\t\tGradientDrawable gradDraw = new GradientDrawable(Orientation.TOP_BOTTOM, colors);\n\t\t\tgradDraw.setDither(true);\n\t\t\tgradDraw.setLevel(10000);\n\t\t\tgradDraw.setBounds(0, 0, mSliderThicknessPx, mPaletteDimPx);\n\t\t\tgradDraw.draw(mVerSliderCv);\n\t\t}\n\n\t\t/**\n\t\t * Report the correct tightly bounded dimensions of the view.\n\t\t */\n\t\t@Override\n\t\tprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n\t\t\tsetMeasuredDimension(mViewDimXPx, mViewDimYPx);\n\t\t}\n\n\t\t/**\n\t\t * Wrap Math.round().  I'm not a Java expert.  Is this the only way to avoid writing \"(int)Math.round\" everywhere?\n\t\t * @param x\n\t\t * @return\n\t\t */\n\t\tprivate int round(double x) {\n\t\t\treturn (int)Math.round(x);\n\t\t}\n\n\t\t/**\n\t\t * Limit a value to the range [0,1].\n\t\t * @param n\n\t\t * @return\n\t\t */\n\t\tprivate float pinToUnit(float n) {\n\t\t\tif (n < 0) {\n\t\t\t\tn = 0;\n\t\t\t} else if (n > 1) {\n\t\t\t\tn = 1;\n\t\t\t}\n\t\t\treturn n;\n\t\t}\n\n\t\t/**\n\t\t * Limit a value to the range [0,max].\n\t\t * @param n\n\t\t * @param max\n\t\t * @return\n\t\t */\n\t\tprivate float pin(float n, float max) {\n\t\t\tif (n < 0) {\n\t\t\t\tn = 0;\n\t\t\t} else if (n > max) {\n\t\t\t\tn = max;\n\t\t\t}\n\t\t\treturn n;\n\t\t}\n\n\t\t/**\n\t\t * Limit a value to the range [min,max].\n\t\t * @param n\n\t\t * @param min\n\t\t * @param max\n\t\t * @return\n\t\t */\n\t\tprivate float pin(float n, float min, float max) {\n\t\t\tif (n < min) {\n\t\t\t\tn = min;\n\t\t\t} else if (n > max) {\n\t\t\t\tn = max;\n\t\t\t}\n\t\t\treturn n;\n\t\t}\n\n\t\t/**\n\t\t * No clue what this does (some sort of average/mean I presume).  It came with the original UberColorPickerDialog\n\t\t * in the API Demos and wasn't documented.  I don't feel like spending any time figuring it out, I haven't looked at it at all.\n\t\t * @param s\n\t\t * @param d\n\t\t * @param p\n\t\t * @return\n\t\t */\n\t\tprivate int ave(int s, int d, float p) {\n\t\t\treturn s + round(p * (d - s));\n\t\t}\n\n\t\t/**\n\t\t * Came with the original UberColorPickerDialog in the API Demos, wasn't documented.  I believe it takes an array of\n\t\t * colors and a value in the range [0,1] and interpolates a resulting color in a seemingly predictable manner.\n\t\t * I haven't looked at it at all.\n\t\t * @param colors\n\t\t * @param unit\n\t\t * @return\n\t\t */\n\t\tprivate int interpColor(int colors[], float unit) {\n\t\t\tif (unit <= 0) {\n\t\t\t\treturn colors[0];\n\t\t\t}\n\t\t\tif (unit >= 1) {\n\t\t\t\treturn colors[colors.length - 1];\n\t\t\t}\n\n\t\t\tfloat p = unit * (colors.length - 1);\n\t\t\tint i = (int)p;\n\t\t\tp -= i;\n\n\t\t\t// now p is just the fractional part [0...1) and i is the index\n\t\t\tint c0 = colors[i];\n\t\t\tint c1 = colors[i+1];\n\t\t\tint a = ave(Color.alpha(c0), Color.alpha(c1), p);\n\t\t\tint r = ave(Color.red(c0), Color.red(c1), p);\n\t\t\tint g = ave(Color.green(c0), Color.green(c1), p);\n\t\t\tint b = ave(Color.blue(c0), Color.blue(c1), p);\n\n\t\t\treturn Color.argb(a, r, g, b);\n\t\t}\n\n\t\t/**\n\t\t * A standard point-in-rect routine.\n\t\t * @param x\n\t\t * @param y\n\t\t * @param r\n\t\t * @return true if point x,y is in rect r\n\t\t */\n\t\tpublic boolean ptInRect(int x, int y, Rect r) {\n\t\t\treturn x > r.left && x < r.right && y > r.top && y < r.bottom;\n\t\t}\n\n\t\t/**\n\t\t * Process trackball events.  Used mainly for fine-tuned color adjustment, or alternatively to switch between slider controls.\n\t\t */\n\t\t@Override\n\t\tpublic boolean dispatchTrackballEvent(MotionEvent event) {\n\t\t\tfloat x = event.getX();\n\t\t\tfloat y = event.getY();\n\n\t\t\t//A longer event history implies faster trackball movement.\n\t\t\t//Use it to infer a larger jump and therefore faster palette/slider adjustment.\n\t\t\tint jump = event.getHistorySize() + 1;\n\n\t\t\tswitch (event.getAction()) {\n\t\t\t\tcase MotionEvent.ACTION_DOWN: {\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase MotionEvent.ACTION_MOVE: {\n\t\t\t\t\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\t\t\t\t\t//To add a new method, replicate and extend the appropriate entry in this list,\n\t\t\t\t\t\t//depending on whether you use 1D or 2D controllers\n\t\t\t\t\t\tswitch (mMethod) {\n\t\t\t\t\t\t\tcase METHOD_HS_V_PALETTE:\n\t\t\t\t\t\t\t\tif (mFocusedControl == 0) {\n\t\t\t\t\t\t\t\t\tchangeHSPalette(x, y, jump);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (mFocusedControl == 1) {\n\t\t\t\t\t\t\t\t\tif (y < 0)\n\t\t\t\t\t\t\t\t\t\tchangeSlider(mFocusedControl, true, jump);\n\t\t\t\t\t\t\t\t\telse if (y > 0)\n\t\t\t\t\t\t\t\t\t\tchangeSlider(mFocusedControl, false, jump);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase MotionEvent.ACTION_UP: {\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\t//To add a new method, replicate and extend the appropriate functions below,\n\t\t//one per UI controller in the new method\n\t\t/**\n\t\t * Effect a trackball change to a 2D palette.\n\t\t * @param x -1: negative x change, 0: no x change, +1: positive x change.\n\t\t * @param y -1: negative y change, 0, no y change, +1: positive y change.\n\t\t * @param jump the amount by which to change.\n\t\t */\n\t\tprivate void changeHSPalette(float x, float y, int jump) {\n\t\t\tint x2 = 0, y2 = 0;\n\t\t\tif (x < 0)\n\t\t\t\tx2 = -jump;\n\t\t\telse if (x > 0)\n\t\t\t\tx2 = jump;\n\t\t\tif (y < 0)\n\t\t\t\ty2 = -jump;\n\t\t\telse if (y > 0)\n\t\t\t\ty2 = jump;\n\n\t\t \tmCoord[0] += x2;\n\t\t \tmCoord[1] += y2;\n\n\t\t\tif (mCoord[0] < -mPaletteRadiusPx)\n\t\t\t\tmCoord[0] = -mPaletteRadiusPx;\n\t\t\telse if (mCoord[0] > mPaletteRadiusPx)\n\t\t\t\tmCoord[0] = mPaletteRadiusPx;\n\t\t\tif (mCoord[1] < -mPaletteRadiusPx)\n\t\t\t\tmCoord[1] = -mPaletteRadiusPx;\n\t\t\telse if (mCoord[1] > mPaletteRadiusPx)\n\t\t\t\tmCoord[1] = mPaletteRadiusPx;\n\n\t\t\tfloat radius = (float) java.lang.Math.sqrt(mCoord[0] * mCoord[0] + mCoord[1] * mCoord[1]);\n\t\t\tif (radius > mPaletteRadiusPx)\n\t\t\t\tradius = mPaletteRadiusPx;\n\n\t\t\tfloat angle = (float)java.lang.Math.atan2(mCoord[1], mCoord[0]);\n\t\t\t// need to turn angle [-PI ... PI] into unit [0....1]\n\t\t\tfloat unit = angle/(2*PI);\n\t\t\tif (unit < 0) {\n\t\t\t\tunit += 1;\n\t\t\t}\n\n\t\t\tmCoord[0] = round(Math.cos(angle) * radius);\n\t\t\tmCoord[1] = round(Math.sin(angle) * radius);\n\n\t\t\tint c = interpColor(mSpectrumColorsRev, unit);\n\t\t\tfloat[] hsv = new float[3];\n\t\t\tColor.colorToHSV(c, hsv);\n\t\t\tmHSV[0] = hsv[0];\n\t\t\tmHSV[1] = radius / mPaletteRadiusPx;\n\t\t\tupdateAllFromHSV();\n\t\t\tmSwatchNew.setColor(Color.HSVToColor(mHSV));\n\n\t\t\tsetVerValSlider();\n\n\t\t\tinvalidate();\n\t\t}\n\n\t\t/**\n\t\t * Effect a trackball change to a 1D slider.\n\t\t * @param slider id of the slider to be effected\n\t\t * @param increase true if the change is an increase, false if a decrease\n\t\t * @param jump the amount by which to change in units of the range [0,255]\n\t\t */\n\t\tprivate void changeSlider(int slider, boolean increase, int jump) {\n\t\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\t\t//It is only necessary to add an entry here for a new method if the new method uses a 1D slider.\n\t\t\t//Note, some sliders are horizontal and others are vertical.\n\t\t\t//They differ a bit, especially in a sign flip on the vertical axis.\n\t\t\tif (mMethod == METHOD_HS_V_PALETTE) {\n\t\t\t\t//slider *must* equal 1\n\n\t\t\t\tmHSV[2] += (increase ? jump : -jump) / 256.0f;\n\t\t\t\tmHSV[2] = pinToUnit(mHSV[2]);\n\t\t\t\tupdateAllFromHSV();\n\t\t\t\tmCoord[2] = mPaletteDimPx - (int) (mHSV[2] * mPaletteDimPx);\n\n\t\t\t\tmSwatchNew.setColor(Color.HSVToColor(mHSV));\n\n\t\t\t\tsetOvalValDimmer();\n\n\t\t\t\tinvalidate();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Keep all colorspace representations in sync.\n\t\t */\n\t\tprivate void updateRGBfromHSV() {\n\t\t\tint color = Color.HSVToColor(mHSV);\n\t\t\tmRGB[0] = Color.red(color);\n\t\t\tmRGB[1] = Color.green(color);\n\t\t\tmRGB[2] = Color.blue(color);\n\t\t}\n\n\t\t/**\n\t\t * Keep all colorspace representations in sync.\n\t\t */\n\t\tprivate void updateYUVfromRGB() {\n\t\t\tfloat r = mRGB[0] / 255.0f;\n\t\t\tfloat g = mRGB[1] / 255.0f;\n\t\t\tfloat b = mRGB[2] / 255.0f;\n\n\t\t\tColorMatrix cm = new ColorMatrix();\n\t\t\tcm.setRGB2YUV();\n\t\t\tfinal float[] a = cm.getArray();\n\n\t\t\tmYUV[0] = a[0] * r + a[1] * g + a[2] * b;\n\t\t\tmYUV[0] = pinToUnit(mYUV[0]);\n\t\t\tmYUV[1] = a[5] * r + a[6] * g + a[7] * b;\n\t\t\tmYUV[1] = pin(mYUV[1], -.5f, .5f);\n\t\t\tmYUV[2] = a[10] * r + a[11] * g + a[12] * b;\n\t\t\tmYUV[2] = pin(mYUV[2], -.5f, .5f);\n\t\t}\n\n\t\t/**\n\t\t * Keep all colorspace representations in sync.\n\t\t */\n\t\tprivate void updateHexFromHSV() {\n\t\t\t//For now, assume 100% opacity\n\t\t\tmHexStr = Integer.toHexString(Color.HSVToColor(mHSV)).toUpperCase();\n\t\t\tmHexStr = mHexStr.substring(2, mHexStr.length());\n\t\t}\n\n\t\t/**\n\t\t * Keep all colorspace representations in sync.\n\t\t */\n\t\tprivate void updateAllFromHSV() {\n\t\t\t//Update mRGB\n\t\t\tif (mRGBenabled || mYUVenabled)\n\t\t\t\tupdateRGBfromHSV();\n\n\t\t\t//Update mYUV\n\t\t\tif (mYUVenabled)\n\t\t\t\tupdateYUVfromRGB();\n\n\t\t\t//Update mHexStr\n\t\t\tif (mRGBenabled)\n\t\t\t\tupdateHexFromHSV();\n\t\t}\n\n\t\t/**\n\t\t * Process touch events: down, move, and up\n\t\t */\n\t\t@Override\n\t\tpublic boolean onTouchEvent(MotionEvent event) {\n\t\t\tfloat x = event.getX();\n\t\t\tfloat y = event.getY();\n\n\t\t\t//Generate coordinates which are palette=local with the origin at the upper left of the main 2D palette\n\t\t\tint y2 = (int) (pin(round(y - mPalettePosY), mPaletteDimPx));\n\n\t\t\t//Generate coordinates which are palette-local with the origin at the center of the main 2D palette\n\t\t\tfloat circlePinnedX = x - mPalettePosX - mPaletteCenterPx;\n\t\t\tfloat circlePinnedY = y - mPalettePosY - mPaletteCenterPx;\n\n\t\t\t//Is the event in a swatch?\n\t\t\tboolean inSwatchOld = ptInRect(round(x), round(y), mOldSwatchRect);\n\t\t\tboolean inSwatchNew = ptInRect(round(x), round(y), mNewSwatchRect);\n\n\t\t\t//Get the event's distance from the center of the main 2D palette\n\t\t\tfloat radius = (float)java.lang.Math.sqrt(circlePinnedX * circlePinnedX + circlePinnedY * circlePinnedY);\n\n\t\t\t//Is the event in a circle-pinned 2D palette?\n\t\t\tboolean inOvalPalette = radius <= mPaletteRadiusPx;\n\n\t\t\t//Pin the radius\n\t\t\tif (radius > mPaletteRadiusPx)\n\t\t\t\tradius = mPaletteRadiusPx;\n\n\t\t\t//Is the event in a vertical slider to the right of the main 2D palette\n\t\t\tboolean inVerSlider = ptInRect(round(x), round(y), mVerSliderRect);\n\n\t\t\tswitch (event.getAction()) {\n\t\t\t\tcase MotionEvent.ACTION_DOWN:\n\t\t\t\t\tmTracking = TRACKED_NONE;\n\n\t\t\t\t\tif (inSwatchOld)\n\t\t\t\t\t\tmTracking = TRACK_SWATCH_OLD;\n\t\t\t\t\telse if (inSwatchNew)\n\t\t\t\t\t\tmTracking = TRACK_SWATCH_NEW;\n\n\t\t\t\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\t\t\t\t//To add a new method, replicate and extend the last entry in this list\n\t\t\t\t\telse if (mMethod == METHOD_HS_V_PALETTE) {\n\t\t\t\t\t\tif (inOvalPalette) {\n\t\t\t\t\t\t\tmTracking = TRACK_HS_PALETTE;\n\t\t\t\t\t\t\tmFocusedControl = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (inVerSlider) {\n\t\t\t\t\t\t\tmTracking = TRACK_VER_VALUE_SLIDER;\n\t\t\t\t\t\t\tmFocusedControl = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tcase MotionEvent.ACTION_MOVE:\n\t\t\t\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\t\t\t\t//To add a new method, replicate and extend the entries in this list,\n\t\t\t\t\t//one per UI controller the new method requires.\n\t\t\t\t\tif (mTracking == TRACK_HS_PALETTE) {\n\t\t\t\t\t\tfloat angle = (float)java.lang.Math.atan2(circlePinnedY, circlePinnedX);\n\t\t\t\t\t\t// need to turn angle [-PI ... PI] into unit [0....1]\n\t\t\t\t\t\tfloat unit = angle/(2*PI);\n\t\t\t\t\t\tif (unit < 0) {\n\t\t\t\t\t\t\tunit += 1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmCoord[0] = round(Math.cos(angle) * radius);\n\t\t\t\t\t\tmCoord[1] = round(Math.sin(angle) * radius);\n\n\t\t\t\t\t\tint c = interpColor(mSpectrumColorsRev, unit);\n\t\t\t\t\t\tfloat[] hsv = new float[3];\n\t\t\t\t\t\tColor.colorToHSV(c, hsv);\n\t\t\t\t\t\tmHSV[0] = hsv[0];\n\t\t\t\t\t\tmHSV[1] = radius / mPaletteRadiusPx;\n\t\t\t\t\t\tupdateAllFromHSV();\n\t\t\t\t\t\tmSwatchNew.setColor(Color.HSVToColor(mHSV));\n\n\t\t\t\t\t\tsetVerValSlider();\n\n\t\t\t\t\t\tinvalidate();\n\t\t\t\t\t}\n\t\t\t\t\telse if (mTracking == TRACK_VER_VALUE_SLIDER) {\n\t\t\t\t\t\tif (mCoord[2] != y2) {\n\t\t\t\t\t\t\tmCoord[2] = y2;\n\t\t\t\t\t\t\tfloat value = 1.0f - (float) y2 / (float) mPaletteDimPx;\n\n\t\t\t\t\t\t\tmHSV[2] = value;\n\t\t\t\t\t\t\tupdateAllFromHSV();\n\t\t\t\t\t\t\tmSwatchNew.setColor(Color.HSVToColor(mHSV));\n\n\t\t\t\t\t\t\tsetOvalValDimmer();\n\n\t\t\t\t\t\t\tinvalidate();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase MotionEvent.ACTION_UP:\n\t\t\t\t\t//NEW_METHOD_WORK_NEEDED_HERE\n\t\t\t\t\t//To add a new method, replicate and extend the last entry in this list.\n\t\t\t\t\tif (mTracking == TRACK_SWATCH_OLD && inSwatchOld) {\n\t\t\t\t\t\tColor.colorToHSV(mOriginalColor, mHSV);\n\t\t\t\t\t\tmSwatchNew.setColor(mOriginalColor);\n\t\t\t\t\t\tinitUI();\n\t\t\t\t\t\tinvalidate();\n\t\t\t\t\t}\n\t\t\t\t\telse if (mTracking == TRACK_SWATCH_NEW && inSwatchNew) {\n\t\t\t\t\t\tmListener.colorChanged(mSwatchNew.getColor());\n\t\t\t\t\t\tinvalidate();\n\t\t\t\t\t}\n\n\t\t\t\t\tmTracking= TRACKED_NONE;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t}\n}\n","lineNo":284}
{"Smelly Sample":"/*\n * ConnectBot: simple, powerful, open-source SSH client for Android\n * Copyright 2007 Kenny Root, Jeffrey Sharkey\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.connectbot;\n\nimport org.connectbot.util.HelpTopicView;\n\nimport android.app.Activity;\nimport android.content.Context;\nimport android.os.Bundle;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.View.OnClickListener;\nimport android.widget.Button;\nimport android.widget.ViewFlipper;\n\n/**\n * Show a series of wizard-like steps to the user, which might include an EULA,\n * program credits, and helpful hints.\n *\n * @author jsharkey\n */\npublic class WizardActivity extends Activity {\n\tprotected ViewFlipper flipper = null;\n\tprivate Button next, prev;\n\n\t@Override\n\tpublic void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.act_wizard);\n\n\t\tthis.flipper = (ViewFlipper) findViewById(R.id.wizard_flipper);\n\n\t\t// inflate the layout for EULA step\n\t\tLayoutInflater inflater = LayoutInflater.from(this);\n\t\tthis.flipper.addView(inflater.inflate(R.layout.wiz_eula, this.flipper, false));\n\n\t\t// Add a view for each help topic we want the user to see.\n\t\tString[] topics = getResources().getStringArray(R.array.list_wizard_topics);\n\t\tfor (String topic : topics) {\n\t\t\tflipper.addView(new HelpTopicView(this).setTopic(topic));\n\t\t}\n\n\t\tnext = (Button)this.findViewById(R.id.action_next);\n\t\tnext.setOnClickListener(new OnClickListener() {\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tif(isLastDisplayed()) {\n\t\t\t\t\t// user walked past end of wizard, so return okay\n\t\t\t\t\tWizardActivity.this.setResult(Activity.RESULT_OK);\n\t\t\t\t\tWizardActivity.this.finish();\n\t\t\t\t} else {\n\t\t\t\t\t// show next step and update buttons\n\t\t\t\t\tflipper.showNext();\n\t\t\t\t\tupdateButtons();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tprev = (Button)this.findViewById(R.id.action_prev);\n\t\tprev.setOnClickListener(new OnClickListener() {\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tif(isFirstDisplayed()) {\n\t\t\t\t\t// user walked past beginning of wizard, so return that they cancelled\n\t\t\t\t\tWizardActivity.this.setResult(Activity.RESULT_CANCELED);\n\t\t\t\t\tWizardActivity.this.finish();\n\t\t\t\t} else {\n\t\t\t\t\t// show previous step and update buttons\n\t\t\t\t\tflipper.showPrevious();\n\t\t\t\t\tupdateButtons();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tthis.updateButtons();\n\t}\n\n\tprotected boolean isFirstDisplayed() {\n\t\treturn (flipper.getDisplayedChild() == 0);\n\t}\n\n\tprotected boolean isLastDisplayed() {\n\t\treturn (flipper.getDisplayedChild() == flipper.getChildCount() - 1);\n\t}\n\n\tprotected void updateButtons() {\n\t\tboolean eula = (flipper.getDisplayedChild() == 0);\n\n\t\tnext.setText(eula ? getString(R.string.wizard_agree) : getString(R.string.wizard_next));\n\t\tprev.setText(eula ? getString(R.string.delete_neg) : getString(R.string.wizard_back));\n\t}\n}\n","Method after Refactoring":"/*\n * ConnectBot: simple, powerful, open-source SSH client for Android\n * Copyright 2007 Kenny Root, Jeffrey Sharkey\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.connectbot;\n\nimport org.connectbot.util.HelpTopicView;\n\nimport android.app.Activity;\nimport android.content.Context;\nimport android.os.Bundle;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.View.OnClickListener;\nimport android.widget.Button;\nimport android.widget.TextView;\nimport android.widget.ViewFlipper;\n\n/**\n * Show a series of wizard-like steps to the user, which might include an EULA,\n * program credits, and helpful hints.\n *\n * @author jsharkey\n */\npublic class WizardActivity extends Activity {\n\tprotected ViewFlipper flipper = null;\n\tprivate Button next, prev;\n\n\t@Override\n\tpublic void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.act_wizard);\n\n\t\tflipper = (ViewFlipper) findViewById(R.id.wizard_flipper);\n\n\t\t// inflate the layout for EULA step\n\t\tLayoutInflater inflater = LayoutInflater.from(this);\n\n\t\tView eula = inflater.inflate(R.layout.wiz_eula, flipper, false);\n\t\tTextView versionString = (TextView) eula.findViewById(R.id.version);\n\t\tversionString.setText(BuildConfig.VERSION_NAME);\n\t\tflipper.addView(eula);\n\n\t\t// Add a view for each help topic we want the user to see.\n\t\tString[] topics = getResources().getStringArray(R.array.list_wizard_topics);\n\t\tfor (String topic : topics) {\n\t\t\tflipper.addView(new HelpTopicView(this).setTopic(topic));\n\t\t}\n\n\t\tnext = (Button)this.findViewById(R.id.action_next);\n\t\tnext.setOnClickListener(new OnClickListener() {\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tif(isLastDisplayed()) {\n\t\t\t\t\t// user walked past end of wizard, so return okay\n\t\t\t\t\tWizardActivity.this.setResult(Activity.RESULT_OK);\n\t\t\t\t\tWizardActivity.this.finish();\n\t\t\t\t} else {\n\t\t\t\t\t// show next step and update buttons\n\t\t\t\t\tflipper.showNext();\n\t\t\t\t\tupdateButtons();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tprev = (Button)this.findViewById(R.id.action_prev);\n\t\tprev.setOnClickListener(new OnClickListener() {\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tif(isFirstDisplayed()) {\n\t\t\t\t\t// user walked past beginning of wizard, so return that they cancelled\n\t\t\t\t\tWizardActivity.this.setResult(Activity.RESULT_CANCELED);\n\t\t\t\t\tWizardActivity.this.finish();\n\t\t\t\t} else {\n\t\t\t\t\t// show previous step and update buttons\n\t\t\t\t\tflipper.showPrevious();\n\t\t\t\t\tupdateButtons();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tthis.updateButtons();\n\t}\n\n\tprotected boolean isFirstDisplayed() {\n\t\treturn (flipper.getDisplayedChild() == 0);\n\t}\n\n\tprotected boolean isLastDisplayed() {\n\t\treturn (flipper.getDisplayedChild() == flipper.getChildCount() - 1);\n\t}\n\n\tprotected void updateButtons() {\n\t\tboolean eula = (flipper.getDisplayedChild() == 0);\n\n\t\tnext.setText(eula ? getString(R.string.wizard_agree) : getString(R.string.wizard_next));\n\t\tprev.setText(eula ? getString(R.string.delete_neg) : getString(R.string.wizard_back));\n\t}\n}\n","lineNo":52}
{"Smelly Sample":"/*\n * ConnectBot: simple, powerful, open-source SSH client for Android\n * Copyright 2010 Kenny Root, Jeffrey Sharkey\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.connectbot.service;\n\nimport java.io.IOException;\n\nimport org.connectbot.TerminalView;\nimport org.connectbot.bean.SelectionArea;\nimport org.connectbot.util.PreferenceConstants;\n\nimport android.content.SharedPreferences;\nimport android.content.SharedPreferences.OnSharedPreferenceChangeListener;\nimport android.content.res.Configuration;\nimport android.preference.PreferenceManager;\nimport android.text.ClipboardManager;\nimport android.util.Log;\nimport android.view.KeyCharacterMap;\nimport android.view.KeyEvent;\nimport android.view.View;\nimport android.view.View.OnKeyListener;\nimport de.mud.terminal.VDUBuffer;\nimport de.mud.terminal.vt320;\n\n/**\n * @author kenny\n *\n */\n@SuppressWarnings(\"deprecation\") // for ClipboardManager\npublic class TerminalKeyListener implements OnKeyListener, OnSharedPreferenceChangeListener {\n\tprivate static final String TAG = \"ConnectBot.OnKeyListener\";\n\n\tpublic final static int META_CTRL_ON = 0x01;\n\tpublic final static int META_CTRL_LOCK = 0x02;\n\tpublic final static int META_ALT_ON = 0x04;\n\tpublic final static int META_ALT_LOCK = 0x08;\n\tpublic final static int META_SHIFT_ON = 0x10;\n\tpublic final static int META_SHIFT_LOCK = 0x20;\n\tpublic final static int META_SLASH = 0x40;\n\tpublic final static int META_TAB = 0x80;\n\n\t// The bit mask of momentary and lock states for each\n\tpublic final static int META_CTRL_MASK = META_CTRL_ON | META_CTRL_LOCK;\n\tpublic final static int META_ALT_MASK = META_ALT_ON | META_ALT_LOCK;\n\tpublic final static int META_SHIFT_MASK = META_SHIFT_ON | META_SHIFT_LOCK;\n\n\t// backport constants from api level 11\n\tpublic final static int KEYCODE_ESCAPE = 111;\n\tpublic final static int HC_META_CTRL_ON = 4096;\n\n\t// All the transient key codes\n\tpublic final static int META_TRANSIENT = META_CTRL_ON | META_ALT_ON\n\t\t\t| META_SHIFT_ON;\n\n\tprivate final TerminalManager manager;\n\tprivate final TerminalBridge bridge;\n\tprivate final VDUBuffer buffer;\n\n\tprivate String keymode = null;\n\tprivate boolean hardKeyboard = false;\n\n\tprivate int metaState = 0;\n\n\tprivate int mDeadKey = 0;\n\n\t// TODO add support for the new API.\n\tprivate ClipboardManager clipboard = null;\n\n\tprivate boolean selectingForCopy = false;\n\tprivate final SelectionArea selectionArea;\n\n\tprivate String encoding;\n\n\tprivate final SharedPreferences prefs;\n\n\tpublic TerminalKeyListener(TerminalManager manager,\n\t\t\tTerminalBridge bridge,\n\t\t\tVDUBuffer buffer,\n\t\t\tString encoding) {\n\t\tthis.manager = manager;\n\t\tthis.bridge = bridge;\n\t\tthis.buffer = buffer;\n\t\tthis.encoding = encoding;\n\n\t\tselectionArea = new SelectionArea();\n\n\t\tprefs = PreferenceManager.getDefaultSharedPreferences(manager);\n\t\tprefs.registerOnSharedPreferenceChangeListener(this);\n\n\t\thardKeyboard = (manager.res.getConfiguration().keyboard\n\t\t\t\t== Configuration.KEYBOARD_QWERTY);\n\n\t\tupdateKeymode();\n\t}\n\n\t/**\n\t * Handle onKey() events coming down from a {@link TerminalView} above us.\n\t * Modify the keys to make more sense to a host then pass it to the transport.\n\t */\n\tpublic boolean onKey(View v, int keyCode, KeyEvent event) {\n\t\ttry {\n\t\t\tfinal boolean hardKeyboardHidden = manager.hardKeyboardHidden;\n\n\t\t\t// Ignore all key-up events except for the special keys\n\t\t\tif (event.getAction() == KeyEvent.ACTION_UP) {\n\t\t\t\t// There's nothing here for virtual keyboard users.\n\t\t\t\tif (!hardKeyboard || (hardKeyboard && hardKeyboardHidden))\n\t\t\t\t\treturn false;\n\n\t\t\t\t// skip keys if we aren't connected yet or have been disconnected\n\t\t\t\tif (bridge.isDisconnected() || bridge.transport == null)\n\t\t\t\t\treturn false;\n\n\t\t\t\tif (PreferenceConstants.KEYMODE_RIGHT.equals(keymode)) {\n\t\t\t\t\tif (keyCode == KeyEvent.KEYCODE_ALT_RIGHT\n\t\t\t\t\t\t\t&& (metaState & META_SLASH) != 0) {\n\t\t\t\t\t\tmetaState &= ~(META_SLASH | META_TRANSIENT);\n\t\t\t\t\t\tbridge.transport.write('/');\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t} else if (keyCode == KeyEvent.KEYCODE_SHIFT_RIGHT\n\t\t\t\t\t\t\t&& (metaState & META_TAB) != 0) {\n\t\t\t\t\t\tmetaState &= ~(META_TAB | META_TRANSIENT);\n\t\t\t\t\t\tbridge.transport.write(0x09);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else if (PreferenceConstants.KEYMODE_LEFT.equals(keymode)) {\n\t\t\t\t\tif (keyCode == KeyEvent.KEYCODE_ALT_LEFT\n\t\t\t\t\t\t\t&& (metaState & META_SLASH) != 0) {\n\t\t\t\t\t\tmetaState &= ~(META_SLASH | META_TRANSIENT);\n\t\t\t\t\t\tbridge.transport.write('/');\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t} else if (keyCode == KeyEvent.KEYCODE_SHIFT_LEFT\n\t\t\t\t\t\t\t&& (metaState & META_TAB) != 0) {\n\t\t\t\t\t\tmetaState &= ~(META_TAB | META_TRANSIENT);\n\t\t\t\t\t\tbridge.transport.write(0x09);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// check for terminal resizing keys\n\t\t\tif (keyCode == KeyEvent.KEYCODE_VOLUME_UP) {\n\t\t\t\tbridge.increaseFontSize();\n\t\t\t\treturn true;\n\t\t\t} else if(keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) {\n\t\t\t\tbridge.decreaseFontSize();\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// skip keys if we aren't connected yet or have been disconnected\n\t\t\tif (bridge.isDisconnected() || bridge.transport == null)\n\t\t\t\treturn false;\n\n\t\t\tbridge.resetScrollPosition();\n\n\t\t\tif (keyCode == KeyEvent.KEYCODE_UNKNOWN &&\n\t\t\t\t\tevent.getAction() == KeyEvent.ACTION_MULTIPLE) {\n\t\t\t\tbyte[] input = event.getCharacters().getBytes(encoding);\n\t\t\t\tbridge.transport.write(input);\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tint curMetaState = event.getMetaState();\n\t\t\tfinal int orgMetaState = curMetaState;\n\n\t\t\tif ((metaState & META_SHIFT_MASK) != 0) {\n\t\t\t\tcurMetaState |= KeyEvent.META_SHIFT_ON;\n\t\t\t}\n\n\t\t\tif ((metaState & META_ALT_MASK) != 0) {\n\t\t\t\tcurMetaState |= KeyEvent.META_ALT_ON;\n\t\t\t}\n\n\t\t\tint uchar = event.getUnicodeChar(curMetaState);\n\t\t\t// no hard keyboard?  ALT-k should pass through to below\n\t\t\tif ((orgMetaState & KeyEvent.META_ALT_ON) != 0 &&\n\t\t\t\t\t(!hardKeyboard || hardKeyboardHidden)) {\n\t\t\t\tuchar = 0;\n\t\t\t}\n\n\t\t\tif ((uchar & KeyCharacterMap.COMBINING_ACCENT) != 0) {\n\t\t\t\tmDeadKey = uchar & KeyCharacterMap.COMBINING_ACCENT_MASK;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (mDeadKey != 0) {\n\t\t\t\tuchar = KeyCharacterMap.getDeadChar(mDeadKey, keyCode);\n\t\t\t\tmDeadKey = 0;\n\t\t\t}\n\n\t\t\t// otherwise pass through to existing session\n\t\t\t// print normal keys\n\t\t\tif (uchar >= 0x20) {\n\t\t\t\tmetaState &= ~(META_SLASH | META_TAB);\n\n\t\t\t\t// Remove shift and alt modifiers\n\t\t\t\tfinal int lastMetaState = metaState;\n\t\t\t\tmetaState &= ~(META_SHIFT_ON | META_ALT_ON);\n\t\t\t\tif (metaState != lastMetaState) {\n\t\t\t\t\tbridge.redraw();\n\t\t\t\t}\n\n\t\t\t\tif ((metaState & META_CTRL_MASK) != 0) {\n\t\t\t\t\tmetaState &= ~META_CTRL_ON;\n\t\t\t\t\tbridge.redraw();\n\n\t\t\t\t\t// If there is no hard keyboard or there is a hard keyboard currently hidden,\n\t\t\t\t\t// CTRL-1 through CTRL-9 will send F1 through F9\n\t\t\t\t\tif ((!hardKeyboard || (hardKeyboard && hardKeyboardHidden))\n\t\t\t\t\t\t\t&& sendFunctionKey(keyCode))\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\tuchar = keyAsControl(uchar);\n\t\t\t\t}\n\n\t\t\t\t// handle pressing f-keys\n\t\t\t\tif ((hardKeyboard && !hardKeyboardHidden)\n\t\t\t\t\t\t&& (curMetaState & KeyEvent.META_SHIFT_ON) != 0\n\t\t\t\t\t\t&& sendFunctionKey(keyCode))\n\t\t\t\t\treturn true;\n\n\t\t\t\tif (uchar < 0x80)\n\t\t\t\t\tbridge.transport.write(uchar);\n\t\t\t\telse\n\t\t\t\t\t// TODO write encoding routine that doesn't allocate each time\n\t\t\t\t\tbridge.transport.write(new String(Character.toChars(uchar))\n\t\t\t\t\t\t\t.getBytes(encoding));\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// send ctrl and meta-keys as appropriate\n\t\t\tif (!hardKeyboard || hardKeyboardHidden) {\n\t\t\t\tint k = event.getUnicodeChar(0);\n\t\t\t\tint k0 = k;\n\t\t\t\tboolean sendCtrl = false;\n\t\t\t\tboolean sendMeta = false;\n\t\t\t\tif (k != 0) {\n\t\t\t\t\tif ((orgMetaState & HC_META_CTRL_ON) != 0) {\n\t\t\t\t\t\tk = keyAsControl(k);\n\t\t\t\t\t\tif (k != k0)\n\t\t\t\t\t\t\tsendCtrl = true;\n\t\t\t\t\t\t// send F1-F10 via CTRL-1 through CTRL-0\n\t\t\t\t\t\tif (!sendCtrl && sendFunctionKey(keyCode))\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t} else if ((orgMetaState & KeyEvent.META_ALT_ON) != 0) {\n\t\t\t\t\t\tsendMeta = true;\n\t\t\t\t\t\tsendEscape();\n\t\t\t\t\t}\n\t\t\t\t\tif (sendMeta || sendCtrl) {\n\t\t\t\t\t\tbridge.transport.write(k);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// try handling keymode shortcuts\n\t\t\tif (hardKeyboard && !hardKeyboardHidden &&\n\t\t\t\t\tevent.getRepeatCount() == 0) {\n\t\t\t\tif (PreferenceConstants.KEYMODE_RIGHT.equals(keymode)) {\n\t\t\t\t\tswitch (keyCode) {\n\t\t\t\t\tcase KeyEvent.KEYCODE_ALT_RIGHT:\n\t\t\t\t\t\tmetaState |= META_SLASH;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tcase KeyEvent.KEYCODE_SHIFT_RIGHT:\n\t\t\t\t\t\tmetaState |= META_TAB;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tcase KeyEvent.KEYCODE_SHIFT_LEFT:\n\t\t\t\t\t\tmetaPress(META_SHIFT_ON);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tcase KeyEvent.KEYCODE_ALT_LEFT:\n\t\t\t\t\t\tmetaPress(META_ALT_ON);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else if (PreferenceConstants.KEYMODE_LEFT.equals(keymode)) {\n\t\t\t\t\tswitch (keyCode) {\n\t\t\t\t\tcase KeyEvent.KEYCODE_ALT_LEFT:\n\t\t\t\t\t\tmetaState |= META_SLASH;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tcase KeyEvent.KEYCODE_SHIFT_LEFT:\n\t\t\t\t\t\tmetaState |= META_TAB;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tcase KeyEvent.KEYCODE_SHIFT_RIGHT:\n\t\t\t\t\t\tmetaPress(META_SHIFT_ON);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tcase KeyEvent.KEYCODE_ALT_RIGHT:\n\t\t\t\t\t\tmetaPress(META_ALT_ON);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tswitch (keyCode) {\n\t\t\t\t\tcase KeyEvent.KEYCODE_ALT_LEFT:\n\t\t\t\t\tcase KeyEvent.KEYCODE_ALT_RIGHT:\n\t\t\t\t\t\tmetaPress(META_ALT_ON);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tcase KeyEvent.KEYCODE_SHIFT_LEFT:\n\t\t\t\t\tcase KeyEvent.KEYCODE_SHIFT_RIGHT:\n\t\t\t\t\t\tmetaPress(META_SHIFT_ON);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// look for special chars\n\t\t\tswitch(keyCode) {\n\t\t\tcase KEYCODE_ESCAPE:\n\t\t\t\tsendEscape();\n\t\t\t\treturn true;\n\t\t\tcase KeyEvent.KEYCODE_TAB:\n\t\t\t\tbridge.transport.write(0x09);\n\t\t\t\treturn true;\n\t\t\tcase KeyEvent.KEYCODE_CAMERA:\n\n\t\t\t\t// check to see which shortcut the camera button triggers\n\t\t\t\tString camera = manager.prefs.getString(\n\t\t\t\t\t\tPreferenceConstants.CAMERA,\n\t\t\t\t\t\tPreferenceConstants.CAMERA_CTRLA_SPACE);\n\t\t\t\tif(PreferenceConstants.CAMERA_CTRLA_SPACE.equals(camera)) {\n\t\t\t\t\tbridge.transport.write(0x01);\n\t\t\t\t\tbridge.transport.write(' ');\n\t\t\t\t} else if(PreferenceConstants.CAMERA_CTRLA.equals(camera)) {\n\t\t\t\t\tbridge.transport.write(0x01);\n\t\t\t\t} else if(PreferenceConstants.CAMERA_ESC.equals(camera)) {\n\t\t\t\t\t((vt320)buffer).keyTyped(vt320.KEY_ESCAPE, ' ', 0);\n\t\t\t\t} else if(PreferenceConstants.CAMERA_ESC_A.equals(camera)) {\n\t\t\t\t\t((vt320)buffer).keyTyped(vt320.KEY_ESCAPE, ' ', 0);\n\t\t\t\t\tbridge.transport.write('a');\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase KeyEvent.KEYCODE_DEL:\n\t\t\t\t((vt320) buffer).keyPressed(vt320.KEY_BACK_SPACE, ' ',\n\t\t\t\t\t\tgetStateForBuffer());\n\t\t\t\tmetaState &= ~META_TRANSIENT;\n\t\t\t\treturn true;\n\t\t\tcase KeyEvent.KEYCODE_ENTER:\n\t\t\t\t((vt320)buffer).keyTyped(vt320.KEY_ENTER, ' ', 0);\n\t\t\t\tmetaState &= ~META_TRANSIENT;\n\t\t\t\treturn true;\n\n\t\t\tcase KeyEvent.KEYCODE_DPAD_LEFT:\n\t\t\t\tif (selectingForCopy) {\n\t\t\t\t\tselectionArea.decrementColumn();\n\t\t\t\t\tbridge.redraw();\n\t\t\t\t} else {\n\t\t\t\t\t((vt320) buffer).keyPressed(vt320.KEY_LEFT, ' ',\n\t\t\t\t\t\t\tgetStateForBuffer());\n\t\t\t\t\tmetaState &= ~META_TRANSIENT;\n\t\t\t\t\tbridge.tryKeyVibrate();\n\t\t\t\t}\n\t\t\t\treturn true;\n\n\t\t\tcase KeyEvent.KEYCODE_DPAD_UP:\n\t\t\t\tif (selectingForCopy) {\n\t\t\t\t\tselectionArea.decrementRow();\n\t\t\t\t\tbridge.redraw();\n\t\t\t\t} else {\n\t\t\t\t\t((vt320) buffer).keyPressed(vt320.KEY_UP, ' ',\n\t\t\t\t\t\t\tgetStateForBuffer());\n\t\t\t\t\tmetaState &= ~META_TRANSIENT;\n\t\t\t\t\tbridge.tryKeyVibrate();\n\t\t\t\t}\n\t\t\t\treturn true;\n\n\t\t\tcase KeyEvent.KEYCODE_DPAD_DOWN:\n\t\t\t\tif (selectingForCopy) {\n\t\t\t\t\tselectionArea.incrementRow();\n\t\t\t\t\tbridge.redraw();\n\t\t\t\t} else {\n\t\t\t\t\t((vt320) buffer).keyPressed(vt320.KEY_DOWN, ' ',\n\t\t\t\t\t\t\tgetStateForBuffer());\n\t\t\t\t\tmetaState &= ~META_TRANSIENT;\n\t\t\t\t\tbridge.tryKeyVibrate();\n\t\t\t\t}\n\t\t\t\treturn true;\n\n\t\t\tcase KeyEvent.KEYCODE_DPAD_RIGHT:\n\t\t\t\tif (selectingForCopy) {\n\t\t\t\t\tselectionArea.incrementColumn();\n\t\t\t\t\tbridge.redraw();\n\t\t\t\t} else {\n\t\t\t\t\t((vt320) buffer).keyPressed(vt320.KEY_RIGHT, ' ',\n\t\t\t\t\t\t\tgetStateForBuffer());\n\t\t\t\t\tmetaState &= ~META_TRANSIENT;\n\t\t\t\t\tbridge.tryKeyVibrate();\n\t\t\t\t}\n\t\t\t\treturn true;\n\n\t\t\tcase KeyEvent.KEYCODE_DPAD_CENTER:\n\t\t\t\tif (selectingForCopy) {\n\t\t\t\t\tif (selectionArea.isSelectingOrigin())\n\t\t\t\t\t\tselectionArea.finishSelectingOrigin();\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (clipboard != null) {\n\t\t\t\t\t\t\t// copy selected area to clipboard\n\t\t\t\t\t\t\tString copiedText = selectionArea.copyFrom(buffer);\n\n\t\t\t\t\t\t\tclipboard.setText(copiedText);\n\t\t\t\t\t\t\t// XXX STOPSHIP\n//\t\t\t\t\t\t\tmanager.notifyUser(manager.getString(\n//\t\t\t\t\t\t\t\t\tR.string.console_copy_done,\n//\t\t\t\t\t\t\t\t\tcopiedText.length()));\n\n\t\t\t\t\t\t\tselectingForCopy = false;\n\t\t\t\t\t\t\tselectionArea.reset();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif ((metaState & META_CTRL_ON) != 0) {\n\t\t\t\t\t\tsendEscape();\n\t\t\t\t\t\tmetaState &= ~META_CTRL_ON;\n\t\t\t\t\t} else\n\t\t\t\t\t\tmetaPress(META_CTRL_ON);\n\t\t\t\t}\n\n\t\t\t\tbridge.redraw();\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t} catch (IOException e) {\n\t\t\tLog.e(TAG, \"Problem while trying to handle an onKey() event\", e);\n\t\t\ttry {\n\t\t\t\tbridge.transport.flush();\n\t\t\t} catch (IOException ioe) {\n\t\t\t\tLog.d(TAG, \"Our transport was closed, dispatching disconnect event\");\n\t\t\t\tbridge.dispatchDisconnect(false);\n\t\t\t}\n\t\t} catch (NullPointerException npe) {\n\t\t\tLog.d(TAG, \"Input before connection established ignored.\");\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tpublic int keyAsControl(int key) {\n\t\t// Support CTRL-a through CTRL-z\n\t\tif (key >= 0x61 && key <= 0x7A)\n\t\t\tkey -= 0x60;\n\t\t// Support CTRL-A through CTRL-_\n\t\telse if (key >= 0x41 && key <= 0x5F)\n\t\t\tkey -= 0x40;\n\t\t// CTRL-space sends NULL\n\t\telse if (key == 0x20)\n\t\t\tkey = 0x00;\n\t\t// CTRL-? sends DEL\n\t\telse if (key == 0x3F)\n\t\t\tkey = 0x7F;\n\t\treturn key;\n\t}\n\n\tpublic void sendEscape() {\n\t\t((vt320)buffer).keyTyped(vt320.KEY_ESCAPE, ' ', 0);\n\t}\n\n\t/**\n\t * @param key\n\t * @return successful\n\t */\n\tprivate boolean sendFunctionKey(int keyCode) {\n\t\tswitch (keyCode) {\n\t\tcase KeyEvent.KEYCODE_1:\n\t\t\t((vt320) buffer).keyPressed(vt320.KEY_F1, ' ', 0);\n\t\t\treturn true;\n\t\tcase KeyEvent.KEYCODE_2:\n\t\t\t((vt320) buffer).keyPressed(vt320.KEY_F2, ' ', 0);\n\t\t\treturn true;\n\t\tcase KeyEvent.KEYCODE_3:\n\t\t\t((vt320) buffer).keyPressed(vt320.KEY_F3, ' ', 0);\n\t\t\treturn true;\n\t\tcase KeyEvent.KEYCODE_4:\n\t\t\t((vt320) buffer).keyPressed(vt320.KEY_F4, ' ', 0);\n\t\t\treturn true;\n\t\tcase KeyEvent.KEYCODE_5:\n\t\t\t((vt320) buffer).keyPressed(vt320.KEY_F5, ' ', 0);\n\t\t\treturn true;\n\t\tcase KeyEvent.KEYCODE_6:\n\t\t\t((vt320) buffer).keyPressed(vt320.KEY_F6, ' ', 0);\n\t\t\treturn true;\n\t\tcase KeyEvent.KEYCODE_7:\n\t\t\t((vt320) buffer).keyPressed(vt320.KEY_F7, ' ', 0);\n\t\t\treturn true;\n\t\tcase KeyEvent.KEYCODE_8:\n\t\t\t((vt320) buffer).keyPressed(vt320.KEY_F8, ' ', 0);\n\t\t\treturn true;\n\t\tcase KeyEvent.KEYCODE_9:\n\t\t\t((vt320) buffer).keyPressed(vt320.KEY_F9, ' ', 0);\n\t\t\treturn true;\n\t\tcase KeyEvent.KEYCODE_0:\n\t\t\t((vt320) buffer).keyPressed(vt320.KEY_F10, ' ', 0);\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Handle meta key presses where the key can be locked on.\n\t * <p>\n\t * 1st press: next key to have meta state<br />\n\t * 2nd press: meta state is locked on<br />\n\t * 3rd press: disable meta state\n\t *\n\t * @param code\n\t */\n\tpublic void metaPress(int code) {\n\t\tif ((metaState & (code << 1)) != 0) {\n\t\t\tmetaState &= ~(code << 1);\n\t\t} else if ((metaState & code) != 0) {\n\t\t\tmetaState &= ~code;\n\t\t\tmetaState |= code << 1;\n\t\t} else\n\t\t\tmetaState |= code;\n\t\tbridge.redraw();\n\t}\n\n\tpublic void setTerminalKeyMode(String keymode) {\n\t\tthis.keymode = keymode;\n\t}\n\n\tprivate int getStateForBuffer() {\n\t\tint bufferState = 0;\n\n\t\tif ((metaState & META_CTRL_MASK) != 0)\n\t\t\tbufferState |= vt320.KEY_CONTROL;\n\t\tif ((metaState & META_SHIFT_MASK) != 0)\n\t\t\tbufferState |= vt320.KEY_SHIFT;\n\t\tif ((metaState & META_ALT_MASK) != 0)\n\t\t\tbufferState |= vt320.KEY_ALT;\n\n\t\treturn bufferState;\n\t}\n\n\tpublic int getMetaState() {\n\t\treturn metaState;\n\t}\n\n\tpublic int getDeadKey() {\n\t\treturn mDeadKey;\n\t}\n\n\tpublic void setClipboardManager(ClipboardManager clipboard) {\n\t\tthis.clipboard = clipboard;\n\t}\n\n\tpublic void onSharedPreferenceChanged(SharedPreferences sharedPreferences,\n\t\t\tString key) {\n\t\tif (PreferenceConstants.KEYMODE.equals(key)) {\n\t\t\tupdateKeymode();\n\t\t}\n\t}\n\n\tprivate void updateKeymode() {\n\t\tkeymode = prefs.getString(PreferenceConstants.KEYMODE, PreferenceConstants.KEYMODE_RIGHT);\n\t}\n\n\tpublic void setCharset(String encoding) {\n\t\tthis.encoding = encoding;\n\t}\n}\n","Method after Refactoring":"/*\n * ConnectBot: simple, powerful, open-source SSH client for Android\n * Copyright 2010 Kenny Root, Jeffrey Sharkey\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.connectbot.service;\n\nimport java.io.IOException;\n\nimport org.connectbot.TerminalView;\nimport org.connectbot.bean.SelectionArea;\nimport org.connectbot.util.PreferenceConstants;\n\nimport android.content.SharedPreferences;\nimport android.content.SharedPreferences.OnSharedPreferenceChangeListener;\nimport android.content.res.Configuration;\nimport android.preference.PreferenceManager;\nimport android.text.ClipboardManager;\nimport android.util.Log;\nimport android.view.KeyCharacterMap;\nimport android.view.KeyEvent;\nimport android.view.View;\nimport android.view.View.OnKeyListener;\nimport de.mud.terminal.VDUBuffer;\nimport de.mud.terminal.vt320;\n\n/**\n * @author kenny\n *\n */\n@SuppressWarnings(\"deprecation\") // for ClipboardManager\npublic class TerminalKeyListener implements OnKeyListener, OnSharedPreferenceChangeListener {\n\tprivate static final String TAG = \"ConnectBot.OnKeyListener\";\n\n\t// Constants for our private tracking of modifier state\n\tpublic final static int OUR_CTRL_ON = 0x01;\n\tpublic final static int OUR_CTRL_LOCK = 0x02;\n\tpublic final static int OUR_ALT_ON = 0x04;\n\tpublic final static int OUR_ALT_LOCK = 0x08;\n\tpublic final static int OUR_SHIFT_ON = 0x10;\n\tpublic final static int OUR_SHIFT_LOCK = 0x20;\n\tprivate final static int OUR_SLASH = 0x40;\n\tprivate final static int OUR_TAB = 0x80;\n\n\t// All the transient key codes\n\tprivate final static int OUR_TRANSIENT = OUR_CTRL_ON | OUR_ALT_ON\n\t\t\t| OUR_SHIFT_ON | OUR_SLASH | OUR_TAB;\n\n\t// The bit mask of momentary and lock states for each\n\tprivate final static int OUR_CTRL_MASK = OUR_CTRL_ON | OUR_CTRL_LOCK;\n\tprivate final static int OUR_ALT_MASK = OUR_ALT_ON | OUR_ALT_LOCK;\n\tprivate final static int OUR_SHIFT_MASK = OUR_SHIFT_ON | OUR_SHIFT_LOCK;\n\n\t// backport constants from api level 11\n\tprivate final static int KEYCODE_ESCAPE = 111;\n\tprivate final static int HC_META_CTRL_ON = 4096;\n\tprivate final static int HC_META_ALT_MASK = KeyEvent.META_ALT_ON | KeyEvent.META_ALT_LEFT_ON\n\t\t\t| KeyEvent.META_ALT_RIGHT_ON;\n\n\tprivate final TerminalManager manager;\n\tprivate final TerminalBridge bridge;\n\tprivate final VDUBuffer buffer;\n\n\tprivate String keymode = null;\n\tprivate final boolean deviceHasHardKeyboard;\n\n\tprivate int ourMetaState = 0;\n\n\tprivate int mDeadKey = 0;\n\n\t// TODO add support for the new API.\n\tprivate ClipboardManager clipboard = null;\n\n\tprivate boolean selectingForCopy = false;\n\tprivate final SelectionArea selectionArea;\n\n\tprivate String encoding;\n\n\tprivate final SharedPreferences prefs;\n\n\tpublic TerminalKeyListener(TerminalManager manager,\n\t\t\tTerminalBridge bridge,\n\t\t\tVDUBuffer buffer,\n\t\t\tString encoding) {\n\t\tthis.manager = manager;\n\t\tthis.bridge = bridge;\n\t\tthis.buffer = buffer;\n\t\tthis.encoding = encoding;\n\n\t\tselectionArea = new SelectionArea();\n\n\t\tprefs = PreferenceManager.getDefaultSharedPreferences(manager);\n\t\tprefs.registerOnSharedPreferenceChangeListener(this);\n\n\t\tdeviceHasHardKeyboard = (manager.res.getConfiguration().keyboard\n\t\t\t\t== Configuration.KEYBOARD_QWERTY);\n\n\t\tupdateKeymode();\n\t}\n\n\t/**\n\t * Handle onKey() events coming down from a {@link TerminalView} above us.\n\t * Modify the keys to make more sense to a host then pass it to the transport.\n\t */\n\tpublic boolean onKey(View v, int keyCode, KeyEvent event) {\n\t\ttry {\n\t\t\t// skip keys if we aren't connected yet or have been disconnected\n\t\t\tif (bridge.isDisconnected() || bridge.transport == null)\n\t\t\t\treturn false;\n\n\t\t\tfinal boolean interpretAsHardKeyboard = deviceHasHardKeyboard &&\n\t\t\t\t\t!manager.hardKeyboardHidden;\n\t\t\tfinal boolean rightModifiersAreSlashAndTab = interpretAsHardKeyboard &&\n\t\t\t\t\tPreferenceConstants.KEYMODE_RIGHT.equals(keymode);\n\t\t\tfinal boolean leftModifiersAreSlashAndTab = interpretAsHardKeyboard &&\n\t\t\t\t\tPreferenceConstants.KEYMODE_LEFT.equals(keymode);\n\t\t\tfinal boolean volumeKeysChangeFontSize = true;\n\t\t\tfinal boolean shiftedNumbersAreFKeys = interpretAsHardKeyboard;\n\t\t\tfinal boolean controlNumbersAreFKeys = !interpretAsHardKeyboard;\n\n\t\t\t// Ignore all key-up events except for the special keys\n\t\t\tif (event.getAction() == KeyEvent.ACTION_UP) {\n\t\t\t\tif (rightModifiersAreSlashAndTab) {\n\t\t\t\t\tif (keyCode == KeyEvent.KEYCODE_ALT_RIGHT\n\t\t\t\t\t\t\t&& (ourMetaState & OUR_SLASH) != 0) {\n\t\t\t\t\t\tourMetaState &= ~OUR_TRANSIENT;\n\t\t\t\t\t\tbridge.transport.write('/');\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t} else if (keyCode == KeyEvent.KEYCODE_SHIFT_RIGHT\n\t\t\t\t\t\t\t&& (ourMetaState & OUR_TAB) != 0) {\n\t\t\t\t\t\tourMetaState &= ~OUR_TRANSIENT;\n\t\t\t\t\t\tbridge.transport.write(0x09);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else if (leftModifiersAreSlashAndTab) {\n\t\t\t\t\tif (keyCode == KeyEvent.KEYCODE_ALT_LEFT\n\t\t\t\t\t\t\t&& (ourMetaState & OUR_SLASH) != 0) {\n\t\t\t\t\t\tourMetaState &= ~OUR_TRANSIENT;\n\t\t\t\t\t\tbridge.transport.write('/');\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t} else if (keyCode == KeyEvent.KEYCODE_SHIFT_LEFT\n\t\t\t\t\t\t\t&& (ourMetaState & OUR_TAB) != 0) {\n\t\t\t\t\t\tourMetaState &= ~OUR_TRANSIENT;\n\t\t\t\t\t\tbridge.transport.write(0x09);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (volumeKeysChangeFontSize) {\n\t\t\t\tif (keyCode == KeyEvent.KEYCODE_VOLUME_UP) {\n\t\t\t\t\tbridge.increaseFontSize();\n\t\t\t\t\treturn true;\n\t\t\t\t} else if(keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) {\n\t\t\t\t\tbridge.decreaseFontSize();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbridge.resetScrollPosition();\n\n\t\t\t// Handle potentially multi-character IME input.\n\t\t\tif (keyCode == KeyEvent.KEYCODE_UNKNOWN &&\n\t\t\t\t\tevent.getAction() == KeyEvent.ACTION_MULTIPLE) {\n\t\t\t\tbyte[] input = event.getCharacters().getBytes(encoding);\n\t\t\t\tbridge.transport.write(input);\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t/// Handle alt and shift keys if they aren't repeating\n\t\t\tif (event.getRepeatCount() == 0) {\n\t\t\t\tif (rightModifiersAreSlashAndTab) {\n\t\t\t\t\tswitch (keyCode) {\n\t\t\t\t\tcase KeyEvent.KEYCODE_ALT_RIGHT:\n\t\t\t\t\t\tourMetaState |= OUR_SLASH;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tcase KeyEvent.KEYCODE_SHIFT_RIGHT:\n\t\t\t\t\t\tourMetaState |= OUR_TAB;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tcase KeyEvent.KEYCODE_SHIFT_LEFT:\n\t\t\t\t\t\tmetaPress(OUR_SHIFT_ON);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tcase KeyEvent.KEYCODE_ALT_LEFT:\n\t\t\t\t\t\tmetaPress(OUR_ALT_ON);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else if (leftModifiersAreSlashAndTab) {\n\t\t\t\t\tswitch (keyCode) {\n\t\t\t\t\tcase KeyEvent.KEYCODE_ALT_LEFT:\n\t\t\t\t\t\tourMetaState |= OUR_SLASH;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tcase KeyEvent.KEYCODE_SHIFT_LEFT:\n\t\t\t\t\t\tourMetaState |= OUR_TAB;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tcase KeyEvent.KEYCODE_SHIFT_RIGHT:\n\t\t\t\t\t\tmetaPress(OUR_SHIFT_ON);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tcase KeyEvent.KEYCODE_ALT_RIGHT:\n\t\t\t\t\t\tmetaPress(OUR_ALT_ON);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tswitch (keyCode) {\n\t\t\t\t\tcase KeyEvent.KEYCODE_ALT_LEFT:\n\t\t\t\t\tcase KeyEvent.KEYCODE_ALT_RIGHT:\n\t\t\t\t\t\tmetaPress(OUR_ALT_ON);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tcase KeyEvent.KEYCODE_SHIFT_LEFT:\n\t\t\t\t\tcase KeyEvent.KEYCODE_SHIFT_RIGHT:\n\t\t\t\t\t\tmetaPress(OUR_SHIFT_ON);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (keyCode == KeyEvent.KEYCODE_DPAD_CENTER) {\n\t\t\t\tif (selectingForCopy) {\n\t\t\t\t\tif (selectionArea.isSelectingOrigin())\n\t\t\t\t\t\tselectionArea.finishSelectingOrigin();\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (clipboard != null) {\n\t\t\t\t\t\t\t// copy selected area to clipboard\n\t\t\t\t\t\t\tString copiedText = selectionArea.copyFrom(buffer);\n\t\t\t\t\t\t\tclipboard.setText(copiedText);\n\t\t\t\t\t\t\t// XXX STOPSHIP\n//\t\t\t\t\t\t\tmanager.notifyUser(manager.getString(\n//\t\t\t\t\t\t\t\t\tR.string.console_copy_done,\n//\t\t\t\t\t\t\t\t\tcopiedText.length()));\n\t\t\t\t\t\t\tselectingForCopy = false;\n\t\t\t\t\t\t\tselectionArea.reset();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif ((ourMetaState & OUR_CTRL_ON) != 0) {\n\t\t\t\t\t\tsendEscape();\n\t\t\t\t\t\tourMetaState &= ~OUR_CTRL_ON;\n\t\t\t\t\t} else\n\t\t\t\t\t\tmetaPress(OUR_CTRL_ON);\n\t\t\t\t}\n\t\t\t\tbridge.redraw();\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tint derivedMetaState = event.getMetaState();\n\t\t\tif ((ourMetaState & OUR_SHIFT_MASK) != 0)\n\t\t\t\tderivedMetaState |= KeyEvent.META_SHIFT_ON;\n\t\t\tif ((ourMetaState & OUR_ALT_MASK) != 0)\n\t\t\t\tderivedMetaState |= KeyEvent.META_ALT_ON;\n\t\t\tif ((ourMetaState & OUR_CTRL_MASK) != 0)\n\t\t\t\tderivedMetaState |= HC_META_CTRL_ON;\n\n\t\t\tif ((ourMetaState & OUR_TRANSIENT) != 0) {\n\t\t\t\tourMetaState &= ~OUR_TRANSIENT;\n\t\t\t\tbridge.redraw();\n\t\t\t}\n\n\t\t\t// Test for modified numbers becoming function keys\n\t\t\tif (shiftedNumbersAreFKeys && (derivedMetaState & KeyEvent.META_SHIFT_ON) != 0) {\n\t\t\t\tif (sendFunctionKey(keyCode))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (controlNumbersAreFKeys && (derivedMetaState & HC_META_CTRL_ON) != 0) {\n\t\t\t\tif (sendFunctionKey(keyCode))\n\t\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// Ask the system to use the keymap to give us the unicode character for this key,\n\t\t\t// with our derived modifier state applied.\n\t\t\tint uchar = event.getUnicodeChar(derivedMetaState & ~HC_META_CTRL_ON);\n\t\t\tint ucharWithoutAlt = event.getUnicodeChar(\n\t\t\t        derivedMetaState & ~(HC_META_ALT_MASK | HC_META_CTRL_ON));\n\t\t\tif (uchar != ucharWithoutAlt) {\n\t\t\t\t// The alt key was used to modify the character returned; therefore, drop the alt\n\t\t\t\t// modifier from the state so we don't end up sending alt+key.\n\t\t\t\tderivedMetaState &= ~HC_META_ALT_MASK;\n\t\t\t}\n\n\t\t\t// Remove shift from the modifier state as it has already been used by getUnicodeChar.\n\t\t\tderivedMetaState &= ~KeyEvent.META_SHIFT_ON;\n\n\t\t\tif ((uchar & KeyCharacterMap.COMBINING_ACCENT) != 0) {\n\t\t\t\tmDeadKey = uchar & KeyCharacterMap.COMBINING_ACCENT_MASK;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (mDeadKey != 0) {\n\t\t\t\tuchar = KeyCharacterMap.getDeadChar(mDeadKey, keyCode);\n\t\t\t\tmDeadKey = 0;\n\t\t\t}\n\n\t\t\t// If we have a defined non-control character\n\t\t\tif (uchar >= 0x20) {\n\t\t\t\tif ((derivedMetaState & HC_META_CTRL_ON) != 0)\n\t\t\t\t\tuchar = keyAsControl(uchar);\n\t\t\t\tif ((derivedMetaState & KeyEvent.META_ALT_ON) != 0)\n\t\t\t\t\tsendEscape();\n\t\t\t\tif (uchar < 0x80)\n\t\t\t\t\tbridge.transport.write(uchar);\n\t\t\t\telse\n\t\t\t\t\t// TODO write encoding routine that doesn't allocate each time\n\t\t\t\t\tbridge.transport.write(new String(Character.toChars(uchar))\n\t\t\t\t\t\t\t.getBytes(encoding));\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// look for special chars\n\t\t\tswitch(keyCode) {\n\t\t\tcase KEYCODE_ESCAPE:\n\t\t\t\tsendEscape();\n\t\t\t\treturn true;\n\t\t\tcase KeyEvent.KEYCODE_TAB:\n\t\t\t\tbridge.transport.write(0x09);\n\t\t\t\treturn true;\n\t\t\tcase KeyEvent.KEYCODE_CAMERA:\n\n\t\t\t\t// check to see which shortcut the camera button triggers\n\t\t\t\tString camera = manager.prefs.getString(\n\t\t\t\t\t\tPreferenceConstants.CAMERA,\n\t\t\t\t\t\tPreferenceConstants.CAMERA_CTRLA_SPACE);\n\t\t\t\tif(PreferenceConstants.CAMERA_CTRLA_SPACE.equals(camera)) {\n\t\t\t\t\tbridge.transport.write(0x01);\n\t\t\t\t\tbridge.transport.write(' ');\n\t\t\t\t} else if(PreferenceConstants.CAMERA_CTRLA.equals(camera)) {\n\t\t\t\t\tbridge.transport.write(0x01);\n\t\t\t\t} else if(PreferenceConstants.CAMERA_ESC.equals(camera)) {\n\t\t\t\t\t((vt320)buffer).keyTyped(vt320.KEY_ESCAPE, ' ', 0);\n\t\t\t\t} else if(PreferenceConstants.CAMERA_ESC_A.equals(camera)) {\n\t\t\t\t\t((vt320)buffer).keyTyped(vt320.KEY_ESCAPE, ' ', 0);\n\t\t\t\t\tbridge.transport.write('a');\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase KeyEvent.KEYCODE_DEL:\n\t\t\t\t((vt320) buffer).keyPressed(vt320.KEY_BACK_SPACE, ' ',\n\t\t\t\t\t\tgetStateForBuffer());\n\t\t\t\treturn true;\n\t\t\tcase KeyEvent.KEYCODE_ENTER:\n\t\t\t\t((vt320)buffer).keyTyped(vt320.KEY_ENTER, ' ', 0);\n\t\t\t\treturn true;\n\n\t\t\tcase KeyEvent.KEYCODE_DPAD_LEFT:\n\t\t\t\tif (selectingForCopy) {\n\t\t\t\t\tselectionArea.decrementColumn();\n\t\t\t\t\tbridge.redraw();\n\t\t\t\t} else {\n\t\t\t\t\t((vt320) buffer).keyPressed(vt320.KEY_LEFT, ' ',\n\t\t\t\t\t\t\tgetStateForBuffer());\n\t\t\t\t\tbridge.tryKeyVibrate();\n\t\t\t\t}\n\t\t\t\treturn true;\n\n\t\t\tcase KeyEvent.KEYCODE_DPAD_UP:\n\t\t\t\tif (selectingForCopy) {\n\t\t\t\t\tselectionArea.decrementRow();\n\t\t\t\t\tbridge.redraw();\n\t\t\t\t} else {\n\t\t\t\t\t((vt320) buffer).keyPressed(vt320.KEY_UP, ' ',\n\t\t\t\t\t\t\tgetStateForBuffer());\n\t\t\t\t\tbridge.tryKeyVibrate();\n\t\t\t\t}\n\t\t\t\treturn true;\n\n\t\t\tcase KeyEvent.KEYCODE_DPAD_DOWN:\n\t\t\t\tif (selectingForCopy) {\n\t\t\t\t\tselectionArea.incrementRow();\n\t\t\t\t\tbridge.redraw();\n\t\t\t\t} else {\n\t\t\t\t\t((vt320) buffer).keyPressed(vt320.KEY_DOWN, ' ',\n\t\t\t\t\t\t\tgetStateForBuffer());\n\t\t\t\t\tbridge.tryKeyVibrate();\n\t\t\t\t}\n\t\t\t\treturn true;\n\n\t\t\tcase KeyEvent.KEYCODE_DPAD_RIGHT:\n\t\t\t\tif (selectingForCopy) {\n\t\t\t\t\tselectionArea.incrementColumn();\n\t\t\t\t\tbridge.redraw();\n\t\t\t\t} else {\n\t\t\t\t\t((vt320) buffer).keyPressed(vt320.KEY_RIGHT, ' ',\n\t\t\t\t\t\t\tgetStateForBuffer());\n\t\t\t\t\tbridge.tryKeyVibrate();\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t} catch (IOException e) {\n\t\t\tLog.e(TAG, \"Problem while trying to handle an onKey() event\", e);\n\t\t\ttry {\n\t\t\t\tbridge.transport.flush();\n\t\t\t} catch (IOException ioe) {\n\t\t\t\tLog.d(TAG, \"Our transport was closed, dispatching disconnect event\");\n\t\t\t\tbridge.dispatchDisconnect(false);\n\t\t\t}\n\t\t} catch (NullPointerException npe) {\n\t\t\tLog.d(TAG, \"Input before connection established ignored.\");\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tpublic int keyAsControl(int key) {\n\t\t// Support CTRL-a through CTRL-z\n\t\tif (key >= 0x61 && key <= 0x7A)\n\t\t\tkey -= 0x60;\n\t\t// Support CTRL-A through CTRL-_\n\t\telse if (key >= 0x41 && key <= 0x5F)\n\t\t\tkey -= 0x40;\n\t\t// CTRL-space sends NULL\n\t\telse if (key == 0x20)\n\t\t\tkey = 0x00;\n\t\t// CTRL-? sends DEL\n\t\telse if (key == 0x3F)\n\t\t\tkey = 0x7F;\n\t\treturn key;\n\t}\n\n\tpublic void sendEscape() {\n\t\t((vt320)buffer).keyTyped(vt320.KEY_ESCAPE, ' ', 0);\n\t}\n\n\t/**\n\t * @param key\n\t * @return successful\n\t */\n\tprivate boolean sendFunctionKey(int keyCode) {\n\t\tswitch (keyCode) {\n\t\tcase KeyEvent.KEYCODE_1:\n\t\t\t((vt320) buffer).keyPressed(vt320.KEY_F1, ' ', 0);\n\t\t\treturn true;\n\t\tcase KeyEvent.KEYCODE_2:\n\t\t\t((vt320) buffer).keyPressed(vt320.KEY_F2, ' ', 0);\n\t\t\treturn true;\n\t\tcase KeyEvent.KEYCODE_3:\n\t\t\t((vt320) buffer).keyPressed(vt320.KEY_F3, ' ', 0);\n\t\t\treturn true;\n\t\tcase KeyEvent.KEYCODE_4:\n\t\t\t((vt320) buffer).keyPressed(vt320.KEY_F4, ' ', 0);\n\t\t\treturn true;\n\t\tcase KeyEvent.KEYCODE_5:\n\t\t\t((vt320) buffer).keyPressed(vt320.KEY_F5, ' ', 0);\n\t\t\treturn true;\n\t\tcase KeyEvent.KEYCODE_6:\n\t\t\t((vt320) buffer).keyPressed(vt320.KEY_F6, ' ', 0);\n\t\t\treturn true;\n\t\tcase KeyEvent.KEYCODE_7:\n\t\t\t((vt320) buffer).keyPressed(vt320.KEY_F7, ' ', 0);\n\t\t\treturn true;\n\t\tcase KeyEvent.KEYCODE_8:\n\t\t\t((vt320) buffer).keyPressed(vt320.KEY_F8, ' ', 0);\n\t\t\treturn true;\n\t\tcase KeyEvent.KEYCODE_9:\n\t\t\t((vt320) buffer).keyPressed(vt320.KEY_F9, ' ', 0);\n\t\t\treturn true;\n\t\tcase KeyEvent.KEYCODE_0:\n\t\t\t((vt320) buffer).keyPressed(vt320.KEY_F10, ' ', 0);\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Handle meta key presses where the key can be locked on.\n\t * <p>\n\t * 1st press: next key to have meta state<br />\n\t * 2nd press: meta state is locked on<br />\n\t * 3rd press: disable meta state\n\t *\n\t * @param code\n\t */\n\tpublic void metaPress(int code) {\n\t\tif ((ourMetaState & (code << 1)) != 0) {\n\t\t\tourMetaState &= ~(code << 1);\n\t\t} else if ((ourMetaState & code) != 0) {\n\t\t\tourMetaState &= ~code;\n\t\t\tourMetaState |= code << 1;\n\t\t} else\n\t\t\tourMetaState |= code;\n\t\tbridge.redraw();\n\t}\n\n\tpublic void setTerminalKeyMode(String keymode) {\n\t\tthis.keymode = keymode;\n\t}\n\n\tprivate int getStateForBuffer() {\n\t\tint bufferState = 0;\n\n\t\tif ((ourMetaState & OUR_CTRL_MASK) != 0)\n\t\t\tbufferState |= vt320.KEY_CONTROL;\n\t\tif ((ourMetaState & OUR_SHIFT_MASK) != 0)\n\t\t\tbufferState |= vt320.KEY_SHIFT;\n\t\tif ((ourMetaState & OUR_ALT_MASK) != 0)\n\t\t\tbufferState |= vt320.KEY_ALT;\n\n\t\treturn bufferState;\n\t}\n\n\tpublic int getMetaState() {\n\t\treturn ourMetaState;\n\t}\n\n\tpublic int getDeadKey() {\n\t\treturn mDeadKey;\n\t}\n\n\tpublic void setClipboardManager(ClipboardManager clipboard) {\n\t\tthis.clipboard = clipboard;\n\t}\n\n\tpublic void onSharedPreferenceChanged(SharedPreferences sharedPreferences,\n\t\t\tString key) {\n\t\tif (PreferenceConstants.KEYMODE.equals(key)) {\n\t\t\tupdateKeymode();\n\t\t}\n\t}\n\n\tprivate void updateKeymode() {\n\t\tkeymode = prefs.getString(PreferenceConstants.KEYMODE, PreferenceConstants.KEYMODE_RIGHT);\n\t}\n\n\tpublic void setCharset(String encoding) {\n\t\tthis.encoding = encoding;\n\t}\n}\n","lineNo":126}
{"Smelly Sample":"/*\n * ConnectBot: simple, powerful, open-source SSH client for Android\n * Copyright 2010 Kenny Root, Jeffrey Sharkey\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.connectbot.service;\n\nimport java.io.IOException;\n\nimport org.connectbot.TerminalView;\nimport org.connectbot.bean.SelectionArea;\nimport org.connectbot.util.PreferenceConstants;\n\nimport android.content.SharedPreferences;\nimport android.content.SharedPreferences.OnSharedPreferenceChangeListener;\nimport android.content.res.Configuration;\nimport android.preference.PreferenceManager;\nimport android.text.ClipboardManager;\nimport android.util.Log;\nimport android.view.KeyCharacterMap;\nimport android.view.KeyEvent;\nimport android.view.View;\nimport android.view.View.OnKeyListener;\nimport de.mud.terminal.VDUBuffer;\nimport de.mud.terminal.vt320;\n\n/**\n * @author kenny\n *\n */\n@SuppressWarnings(\"deprecation\") // for ClipboardManager\npublic class TerminalKeyListener implements OnKeyListener, OnSharedPreferenceChangeListener {\n\tprivate static final String TAG = \"ConnectBot.OnKeyListener\";\n\n\tpublic final static int META_CTRL_ON = 0x01;\n\tpublic final static int META_CTRL_LOCK = 0x02;\n\tpublic final static int META_ALT_ON = 0x04;\n\tpublic final static int META_ALT_LOCK = 0x08;\n\tpublic final static int META_SHIFT_ON = 0x10;\n\tpublic final static int META_SHIFT_LOCK = 0x20;\n\tpublic final static int META_SLASH = 0x40;\n\tpublic final static int META_TAB = 0x80;\n\n\t// The bit mask of momentary and lock states for each\n\tpublic final static int META_CTRL_MASK = META_CTRL_ON | META_CTRL_LOCK;\n\tpublic final static int META_ALT_MASK = META_ALT_ON | META_ALT_LOCK;\n\tpublic final static int META_SHIFT_MASK = META_SHIFT_ON | META_SHIFT_LOCK;\n\n\t// backport constants from api level 11\n\tpublic final static int KEYCODE_ESCAPE = 111;\n\tpublic final static int HC_META_CTRL_ON = 4096;\n\n\t// All the transient key codes\n\tpublic final static int META_TRANSIENT = META_CTRL_ON | META_ALT_ON\n\t\t\t| META_SHIFT_ON;\n\n\tprivate final TerminalManager manager;\n\tprivate final TerminalBridge bridge;\n\tprivate final VDUBuffer buffer;\n\n\tprivate String keymode = null;\n\tprivate boolean hardKeyboard = false;\n\n\tprivate int metaState = 0;\n\n\tprivate int mDeadKey = 0;\n\n\t// TODO add support for the new API.\n\tprivate ClipboardManager clipboard = null;\n\n\tprivate boolean selectingForCopy = false;\n\tprivate final SelectionArea selectionArea;\n\n\tprivate String encoding;\n\n\tprivate final SharedPreferences prefs;\n\n\tpublic TerminalKeyListener(TerminalManager manager,\n\t\t\tTerminalBridge bridge,\n\t\t\tVDUBuffer buffer,\n\t\t\tString encoding) {\n\t\tthis.manager = manager;\n\t\tthis.bridge = bridge;\n\t\tthis.buffer = buffer;\n\t\tthis.encoding = encoding;\n\n\t\tselectionArea = new SelectionArea();\n\n\t\tprefs = PreferenceManager.getDefaultSharedPreferences(manager);\n\t\tprefs.registerOnSharedPreferenceChangeListener(this);\n\n\t\thardKeyboard = (manager.res.getConfiguration().keyboard\n\t\t\t\t== Configuration.KEYBOARD_QWERTY);\n\n\t\tupdateKeymode();\n\t}\n\n\t/**\n\t * Handle onKey() events coming down from a {@link TerminalView} above us.\n\t * Modify the keys to make more sense to a host then pass it to the transport.\n\t */\n\tpublic boolean onKey(View v, int keyCode, KeyEvent event) {\n\t\ttry {\n\t\t\tfinal boolean hardKeyboardHidden = manager.hardKeyboardHidden;\n\n\t\t\t// Ignore all key-up events except for the special keys\n\t\t\tif (event.getAction() == KeyEvent.ACTION_UP) {\n\t\t\t\t// There's nothing here for virtual keyboard users.\n\t\t\t\tif (!hardKeyboard || (hardKeyboard && hardKeyboardHidden))\n\t\t\t\t\treturn false;\n\n\t\t\t\t// skip keys if we aren't connected yet or have been disconnected\n\t\t\t\tif (bridge.isDisconnected() || bridge.transport == null)\n\t\t\t\t\treturn false;\n\n\t\t\t\tif (PreferenceConstants.KEYMODE_RIGHT.equals(keymode)) {\n\t\t\t\t\tif (keyCode == KeyEvent.KEYCODE_ALT_RIGHT\n\t\t\t\t\t\t\t&& (metaState & META_SLASH) != 0) {\n\t\t\t\t\t\tmetaState &= ~(META_SLASH | META_TRANSIENT);\n\t\t\t\t\t\tbridge.transport.write('/');\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t} else if (keyCode == KeyEvent.KEYCODE_SHIFT_RIGHT\n\t\t\t\t\t\t\t&& (metaState & META_TAB) != 0) {\n\t\t\t\t\t\tmetaState &= ~(META_TAB | META_TRANSIENT);\n\t\t\t\t\t\tbridge.transport.write(0x09);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else if (PreferenceConstants.KEYMODE_LEFT.equals(keymode)) {\n\t\t\t\t\tif (keyCode == KeyEvent.KEYCODE_ALT_LEFT\n\t\t\t\t\t\t\t&& (metaState & META_SLASH) != 0) {\n\t\t\t\t\t\tmetaState &= ~(META_SLASH | META_TRANSIENT);\n\t\t\t\t\t\tbridge.transport.write('/');\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t} else if (keyCode == KeyEvent.KEYCODE_SHIFT_LEFT\n\t\t\t\t\t\t\t&& (metaState & META_TAB) != 0) {\n\t\t\t\t\t\tmetaState &= ~(META_TAB | META_TRANSIENT);\n\t\t\t\t\t\tbridge.transport.write(0x09);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// check for terminal resizing keys\n\t\t\tif (keyCode == KeyEvent.KEYCODE_VOLUME_UP) {\n\t\t\t\tbridge.increaseFontSize();\n\t\t\t\treturn true;\n\t\t\t} else if(keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) {\n\t\t\t\tbridge.decreaseFontSize();\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// skip keys if we aren't connected yet or have been disconnected\n\t\t\tif (bridge.isDisconnected() || bridge.transport == null)\n\t\t\t\treturn false;\n\n\t\t\tbridge.resetScrollPosition();\n\n\t\t\tif (keyCode == KeyEvent.KEYCODE_UNKNOWN &&\n\t\t\t\t\tevent.getAction() == KeyEvent.ACTION_MULTIPLE) {\n\t\t\t\tbyte[] input = event.getCharacters().getBytes(encoding);\n\t\t\t\tbridge.transport.write(input);\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tint curMetaState = event.getMetaState();\n\t\t\tfinal int orgMetaState = curMetaState;\n\n\t\t\tif ((metaState & META_SHIFT_MASK) != 0) {\n\t\t\t\tcurMetaState |= KeyEvent.META_SHIFT_ON;\n\t\t\t}\n\n\t\t\tif ((metaState & META_ALT_MASK) != 0) {\n\t\t\t\tcurMetaState |= KeyEvent.META_ALT_ON;\n\t\t\t}\n\n\t\t\tint uchar = event.getUnicodeChar(curMetaState);\n\t\t\t// no hard keyboard?  ALT-k should pass through to below\n\t\t\tif ((orgMetaState & KeyEvent.META_ALT_ON) != 0 &&\n\t\t\t\t\t(!hardKeyboard || hardKeyboardHidden)) {\n\t\t\t\tuchar = 0;\n\t\t\t}\n\n\t\t\tif ((uchar & KeyCharacterMap.COMBINING_ACCENT) != 0) {\n\t\t\t\tmDeadKey = uchar & KeyCharacterMap.COMBINING_ACCENT_MASK;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (mDeadKey != 0) {\n\t\t\t\tuchar = KeyCharacterMap.getDeadChar(mDeadKey, keyCode);\n\t\t\t\tmDeadKey = 0;\n\t\t\t}\n\n\t\t\t// otherwise pass through to existing session\n\t\t\t// print normal keys\n\t\t\tif (uchar >= 0x20) {\n\t\t\t\tmetaState &= ~(META_SLASH | META_TAB);\n\n\t\t\t\t// Remove shift and alt modifiers\n\t\t\t\tfinal int lastMetaState = metaState;\n\t\t\t\tmetaState &= ~(META_SHIFT_ON | META_ALT_ON);\n\t\t\t\tif (metaState != lastMetaState) {\n\t\t\t\t\tbridge.redraw();\n\t\t\t\t}\n\n\t\t\t\tif ((metaState & META_CTRL_MASK) != 0) {\n\t\t\t\t\tmetaState &= ~META_CTRL_ON;\n\t\t\t\t\tbridge.redraw();\n\n\t\t\t\t\t// If there is no hard keyboard or there is a hard keyboard currently hidden,\n\t\t\t\t\t// CTRL-1 through CTRL-9 will send F1 through F9\n\t\t\t\t\tif ((!hardKeyboard || (hardKeyboard && hardKeyboardHidden))\n\t\t\t\t\t\t\t&& sendFunctionKey(keyCode))\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\tuchar = keyAsControl(uchar);\n\t\t\t\t}\n\n\t\t\t\t// handle pressing f-keys\n\t\t\t\tif ((hardKeyboard && !hardKeyboardHidden)\n\t\t\t\t\t\t&& (curMetaState & KeyEvent.META_SHIFT_ON) != 0\n\t\t\t\t\t\t&& sendFunctionKey(keyCode))\n\t\t\t\t\treturn true;\n\n\t\t\t\tif (uchar < 0x80)\n\t\t\t\t\tbridge.transport.write(uchar);\n\t\t\t\telse\n\t\t\t\t\t// TODO write encoding routine that doesn't allocate each time\n\t\t\t\t\tbridge.transport.write(new String(Character.toChars(uchar))\n\t\t\t\t\t\t\t.getBytes(encoding));\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// send ctrl and meta-keys as appropriate\n\t\t\tif (!hardKeyboard || hardKeyboardHidden) {\n\t\t\t\tint k = event.getUnicodeChar(0);\n\t\t\t\tint k0 = k;\n\t\t\t\tboolean sendCtrl = false;\n\t\t\t\tboolean sendMeta = false;\n\t\t\t\tif (k != 0) {\n\t\t\t\t\tif ((orgMetaState & HC_META_CTRL_ON) != 0) {\n\t\t\t\t\t\tk = keyAsControl(k);\n\t\t\t\t\t\tif (k != k0)\n\t\t\t\t\t\t\tsendCtrl = true;\n\t\t\t\t\t\t// send F1-F10 via CTRL-1 through CTRL-0\n\t\t\t\t\t\tif (!sendCtrl && sendFunctionKey(keyCode))\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t} else if ((orgMetaState & KeyEvent.META_ALT_ON) != 0) {\n\t\t\t\t\t\tsendMeta = true;\n\t\t\t\t\t\tsendEscape();\n\t\t\t\t\t}\n\t\t\t\t\tif (sendMeta || sendCtrl) {\n\t\t\t\t\t\tbridge.transport.write(k);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// try handling keymode shortcuts\n\t\t\tif (hardKeyboard && !hardKeyboardHidden &&\n\t\t\t\t\tevent.getRepeatCount() == 0) {\n\t\t\t\tif (PreferenceConstants.KEYMODE_RIGHT.equals(keymode)) {\n\t\t\t\t\tswitch (keyCode) {\n\t\t\t\t\tcase KeyEvent.KEYCODE_ALT_RIGHT:\n\t\t\t\t\t\tmetaState |= META_SLASH;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tcase KeyEvent.KEYCODE_SHIFT_RIGHT:\n\t\t\t\t\t\tmetaState |= META_TAB;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tcase KeyEvent.KEYCODE_SHIFT_LEFT:\n\t\t\t\t\t\tmetaPress(META_SHIFT_ON);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tcase KeyEvent.KEYCODE_ALT_LEFT:\n\t\t\t\t\t\tmetaPress(META_ALT_ON);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else if (PreferenceConstants.KEYMODE_LEFT.equals(keymode)) {\n\t\t\t\t\tswitch (keyCode) {\n\t\t\t\t\tcase KeyEvent.KEYCODE_ALT_LEFT:\n\t\t\t\t\t\tmetaState |= META_SLASH;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tcase KeyEvent.KEYCODE_SHIFT_LEFT:\n\t\t\t\t\t\tmetaState |= META_TAB;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tcase KeyEvent.KEYCODE_SHIFT_RIGHT:\n\t\t\t\t\t\tmetaPress(META_SHIFT_ON);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tcase KeyEvent.KEYCODE_ALT_RIGHT:\n\t\t\t\t\t\tmetaPress(META_ALT_ON);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tswitch (keyCode) {\n\t\t\t\t\tcase KeyEvent.KEYCODE_ALT_LEFT:\n\t\t\t\t\tcase KeyEvent.KEYCODE_ALT_RIGHT:\n\t\t\t\t\t\tmetaPress(META_ALT_ON);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tcase KeyEvent.KEYCODE_SHIFT_LEFT:\n\t\t\t\t\tcase KeyEvent.KEYCODE_SHIFT_RIGHT:\n\t\t\t\t\t\tmetaPress(META_SHIFT_ON);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// look for special chars\n\t\t\tswitch(keyCode) {\n\t\t\tcase KEYCODE_ESCAPE:\n\t\t\t\tsendEscape();\n\t\t\t\treturn true;\n\t\t\tcase KeyEvent.KEYCODE_TAB:\n\t\t\t\tbridge.transport.write(0x09);\n\t\t\t\treturn true;\n\t\t\tcase KeyEvent.KEYCODE_CAMERA:\n\n\t\t\t\t// check to see which shortcut the camera button triggers\n\t\t\t\tString camera = manager.prefs.getString(\n\t\t\t\t\t\tPreferenceConstants.CAMERA,\n\t\t\t\t\t\tPreferenceConstants.CAMERA_CTRLA_SPACE);\n\t\t\t\tif(PreferenceConstants.CAMERA_CTRLA_SPACE.equals(camera)) {\n\t\t\t\t\tbridge.transport.write(0x01);\n\t\t\t\t\tbridge.transport.write(' ');\n\t\t\t\t} else if(PreferenceConstants.CAMERA_CTRLA.equals(camera)) {\n\t\t\t\t\tbridge.transport.write(0x01);\n\t\t\t\t} else if(PreferenceConstants.CAMERA_ESC.equals(camera)) {\n\t\t\t\t\t((vt320)buffer).keyTyped(vt320.KEY_ESCAPE, ' ', 0);\n\t\t\t\t} else if(PreferenceConstants.CAMERA_ESC_A.equals(camera)) {\n\t\t\t\t\t((vt320)buffer).keyTyped(vt320.KEY_ESCAPE, ' ', 0);\n\t\t\t\t\tbridge.transport.write('a');\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase KeyEvent.KEYCODE_DEL:\n\t\t\t\t((vt320) buffer).keyPressed(vt320.KEY_BACK_SPACE, ' ',\n\t\t\t\t\t\tgetStateForBuffer());\n\t\t\t\tmetaState &= ~META_TRANSIENT;\n\t\t\t\treturn true;\n\t\t\tcase KeyEvent.KEYCODE_ENTER:\n\t\t\t\t((vt320)buffer).keyTyped(vt320.KEY_ENTER, ' ', 0);\n\t\t\t\tmetaState &= ~META_TRANSIENT;\n\t\t\t\treturn true;\n\n\t\t\tcase KeyEvent.KEYCODE_DPAD_LEFT:\n\t\t\t\tif (selectingForCopy) {\n\t\t\t\t\tselectionArea.decrementColumn();\n\t\t\t\t\tbridge.redraw();\n\t\t\t\t} else {\n\t\t\t\t\t((vt320) buffer).keyPressed(vt320.KEY_LEFT, ' ',\n\t\t\t\t\t\t\tgetStateForBuffer());\n\t\t\t\t\tmetaState &= ~META_TRANSIENT;\n\t\t\t\t\tbridge.tryKeyVibrate();\n\t\t\t\t}\n\t\t\t\treturn true;\n\n\t\t\tcase KeyEvent.KEYCODE_DPAD_UP:\n\t\t\t\tif (selectingForCopy) {\n\t\t\t\t\tselectionArea.decrementRow();\n\t\t\t\t\tbridge.redraw();\n\t\t\t\t} else {\n\t\t\t\t\t((vt320) buffer).keyPressed(vt320.KEY_UP, ' ',\n\t\t\t\t\t\t\tgetStateForBuffer());\n\t\t\t\t\tmetaState &= ~META_TRANSIENT;\n\t\t\t\t\tbridge.tryKeyVibrate();\n\t\t\t\t}\n\t\t\t\treturn true;\n\n\t\t\tcase KeyEvent.KEYCODE_DPAD_DOWN:\n\t\t\t\tif (selectingForCopy) {\n\t\t\t\t\tselectionArea.incrementRow();\n\t\t\t\t\tbridge.redraw();\n\t\t\t\t} else {\n\t\t\t\t\t((vt320) buffer).keyPressed(vt320.KEY_DOWN, ' ',\n\t\t\t\t\t\t\tgetStateForBuffer());\n\t\t\t\t\tmetaState &= ~META_TRANSIENT;\n\t\t\t\t\tbridge.tryKeyVibrate();\n\t\t\t\t}\n\t\t\t\treturn true;\n\n\t\t\tcase KeyEvent.KEYCODE_DPAD_RIGHT:\n\t\t\t\tif (selectingForCopy) {\n\t\t\t\t\tselectionArea.incrementColumn();\n\t\t\t\t\tbridge.redraw();\n\t\t\t\t} else {\n\t\t\t\t\t((vt320) buffer).keyPressed(vt320.KEY_RIGHT, ' ',\n\t\t\t\t\t\t\tgetStateForBuffer());\n\t\t\t\t\tmetaState &= ~META_TRANSIENT;\n\t\t\t\t\tbridge.tryKeyVibrate();\n\t\t\t\t}\n\t\t\t\treturn true;\n\n\t\t\tcase KeyEvent.KEYCODE_DPAD_CENTER:\n\t\t\t\tif (selectingForCopy) {\n\t\t\t\t\tif (selectionArea.isSelectingOrigin())\n\t\t\t\t\t\tselectionArea.finishSelectingOrigin();\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (clipboard != null) {\n\t\t\t\t\t\t\t// copy selected area to clipboard\n\t\t\t\t\t\t\tString copiedText = selectionArea.copyFrom(buffer);\n\n\t\t\t\t\t\t\tclipboard.setText(copiedText);\n\t\t\t\t\t\t\t// XXX STOPSHIP\n//\t\t\t\t\t\t\tmanager.notifyUser(manager.getString(\n//\t\t\t\t\t\t\t\t\tR.string.console_copy_done,\n//\t\t\t\t\t\t\t\t\tcopiedText.length()));\n\n\t\t\t\t\t\t\tselectingForCopy = false;\n\t\t\t\t\t\t\tselectionArea.reset();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif ((metaState & META_CTRL_ON) != 0) {\n\t\t\t\t\t\tsendEscape();\n\t\t\t\t\t\tmetaState &= ~META_CTRL_ON;\n\t\t\t\t\t} else\n\t\t\t\t\t\tmetaPress(META_CTRL_ON);\n\t\t\t\t}\n\n\t\t\t\tbridge.redraw();\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t} catch (IOException e) {\n\t\t\tLog.e(TAG, \"Problem while trying to handle an onKey() event\", e);\n\t\t\ttry {\n\t\t\t\tbridge.transport.flush();\n\t\t\t} catch (IOException ioe) {\n\t\t\t\tLog.d(TAG, \"Our transport was closed, dispatching disconnect event\");\n\t\t\t\tbridge.dispatchDisconnect(false);\n\t\t\t}\n\t\t} catch (NullPointerException npe) {\n\t\t\tLog.d(TAG, \"Input before connection established ignored.\");\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tpublic int keyAsControl(int key) {\n\t\t// Support CTRL-a through CTRL-z\n\t\tif (key >= 0x61 && key <= 0x7A)\n\t\t\tkey -= 0x60;\n\t\t// Support CTRL-A through CTRL-_\n\t\telse if (key >= 0x41 && key <= 0x5F)\n\t\t\tkey -= 0x40;\n\t\t// CTRL-space sends NULL\n\t\telse if (key == 0x20)\n\t\t\tkey = 0x00;\n\t\t// CTRL-? sends DEL\n\t\telse if (key == 0x3F)\n\t\t\tkey = 0x7F;\n\t\treturn key;\n\t}\n\n\tpublic void sendEscape() {\n\t\t((vt320)buffer).keyTyped(vt320.KEY_ESCAPE, ' ', 0);\n\t}\n\n\t/**\n\t * @param key\n\t * @return successful\n\t */\n\tprivate boolean sendFunctionKey(int keyCode) {\n\t\tswitch (keyCode) {\n\t\tcase KeyEvent.KEYCODE_1:\n\t\t\t((vt320) buffer).keyPressed(vt320.KEY_F1, ' ', 0);\n\t\t\treturn true;\n\t\tcase KeyEvent.KEYCODE_2:\n\t\t\t((vt320) buffer).keyPressed(vt320.KEY_F2, ' ', 0);\n\t\t\treturn true;\n\t\tcase KeyEvent.KEYCODE_3:\n\t\t\t((vt320) buffer).keyPressed(vt320.KEY_F3, ' ', 0);\n\t\t\treturn true;\n\t\tcase KeyEvent.KEYCODE_4:\n\t\t\t((vt320) buffer).keyPressed(vt320.KEY_F4, ' ', 0);\n\t\t\treturn true;\n\t\tcase KeyEvent.KEYCODE_5:\n\t\t\t((vt320) buffer).keyPressed(vt320.KEY_F5, ' ', 0);\n\t\t\treturn true;\n\t\tcase KeyEvent.KEYCODE_6:\n\t\t\t((vt320) buffer).keyPressed(vt320.KEY_F6, ' ', 0);\n\t\t\treturn true;\n\t\tcase KeyEvent.KEYCODE_7:\n\t\t\t((vt320) buffer).keyPressed(vt320.KEY_F7, ' ', 0);\n\t\t\treturn true;\n\t\tcase KeyEvent.KEYCODE_8:\n\t\t\t((vt320) buffer).keyPressed(vt320.KEY_F8, ' ', 0);\n\t\t\treturn true;\n\t\tcase KeyEvent.KEYCODE_9:\n\t\t\t((vt320) buffer).keyPressed(vt320.KEY_F9, ' ', 0);\n\t\t\treturn true;\n\t\tcase KeyEvent.KEYCODE_0:\n\t\t\t((vt320) buffer).keyPressed(vt320.KEY_F10, ' ', 0);\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Handle meta key presses where the key can be locked on.\n\t * <p>\n\t * 1st press: next key to have meta state<br />\n\t * 2nd press: meta state is locked on<br />\n\t * 3rd press: disable meta state\n\t *\n\t * @param code\n\t */\n\tpublic void metaPress(int code) {\n\t\tif ((metaState & (code << 1)) != 0) {\n\t\t\tmetaState &= ~(code << 1);\n\t\t} else if ((metaState & code) != 0) {\n\t\t\tmetaState &= ~code;\n\t\t\tmetaState |= code << 1;\n\t\t} else\n\t\t\tmetaState |= code;\n\t\tbridge.redraw();\n\t}\n\n\tpublic void setTerminalKeyMode(String keymode) {\n\t\tthis.keymode = keymode;\n\t}\n\n\tprivate int getStateForBuffer() {\n\t\tint bufferState = 0;\n\n\t\tif ((metaState & META_CTRL_MASK) != 0)\n\t\t\tbufferState |= vt320.KEY_CONTROL;\n\t\tif ((metaState & META_SHIFT_MASK) != 0)\n\t\t\tbufferState |= vt320.KEY_SHIFT;\n\t\tif ((metaState & META_ALT_MASK) != 0)\n\t\t\tbufferState |= vt320.KEY_ALT;\n\n\t\treturn bufferState;\n\t}\n\n\tpublic int getMetaState() {\n\t\treturn metaState;\n\t}\n\n\tpublic int getDeadKey() {\n\t\treturn mDeadKey;\n\t}\n\n\tpublic void setClipboardManager(ClipboardManager clipboard) {\n\t\tthis.clipboard = clipboard;\n\t}\n\n\tpublic void onSharedPreferenceChanged(SharedPreferences sharedPreferences,\n\t\t\tString key) {\n\t\tif (PreferenceConstants.KEYMODE.equals(key)) {\n\t\t\tupdateKeymode();\n\t\t}\n\t}\n\n\tprivate void updateKeymode() {\n\t\tkeymode = prefs.getString(PreferenceConstants.KEYMODE, PreferenceConstants.KEYMODE_RIGHT);\n\t}\n\n\tpublic void setCharset(String encoding) {\n\t\tthis.encoding = encoding;\n\t}\n}\n","Method after Refactoring":"/*\n * ConnectBot: simple, powerful, open-source SSH client for Android\n * Copyright 2010 Kenny Root, Jeffrey Sharkey\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.connectbot.service;\n\nimport java.io.IOException;\n\nimport org.connectbot.TerminalView;\nimport org.connectbot.bean.SelectionArea;\nimport org.connectbot.util.PreferenceConstants;\n\nimport android.content.SharedPreferences;\nimport android.content.SharedPreferences.OnSharedPreferenceChangeListener;\nimport android.content.res.Configuration;\nimport android.preference.PreferenceManager;\nimport android.text.ClipboardManager;\nimport android.util.Log;\nimport android.view.KeyCharacterMap;\nimport android.view.KeyEvent;\nimport android.view.View;\nimport android.view.View.OnKeyListener;\nimport de.mud.terminal.VDUBuffer;\nimport de.mud.terminal.vt320;\n\n/**\n * @author kenny\n *\n */\n@SuppressWarnings(\"deprecation\") // for ClipboardManager\npublic class TerminalKeyListener implements OnKeyListener, OnSharedPreferenceChangeListener {\n\tprivate static final String TAG = \"ConnectBot.OnKeyListener\";\n\n\t// Constants for our private tracking of modifier state\n\tpublic final static int OUR_CTRL_ON = 0x01;\n\tpublic final static int OUR_CTRL_LOCK = 0x02;\n\tpublic final static int OUR_ALT_ON = 0x04;\n\tpublic final static int OUR_ALT_LOCK = 0x08;\n\tpublic final static int OUR_SHIFT_ON = 0x10;\n\tpublic final static int OUR_SHIFT_LOCK = 0x20;\n\tprivate final static int OUR_SLASH = 0x40;\n\tprivate final static int OUR_TAB = 0x80;\n\n\t// All the transient key codes\n\tprivate final static int OUR_TRANSIENT = OUR_CTRL_ON | OUR_ALT_ON\n\t\t\t| OUR_SHIFT_ON | OUR_SLASH | OUR_TAB;\n\n\t// The bit mask of momentary and lock states for each\n\tprivate final static int OUR_CTRL_MASK = OUR_CTRL_ON | OUR_CTRL_LOCK;\n\tprivate final static int OUR_ALT_MASK = OUR_ALT_ON | OUR_ALT_LOCK;\n\tprivate final static int OUR_SHIFT_MASK = OUR_SHIFT_ON | OUR_SHIFT_LOCK;\n\n\t// backport constants from api level 11\n\tprivate final static int KEYCODE_ESCAPE = 111;\n\tprivate final static int HC_META_CTRL_ON = 4096;\n\tprivate final static int HC_META_ALT_MASK = KeyEvent.META_ALT_ON | KeyEvent.META_ALT_LEFT_ON\n\t\t\t| KeyEvent.META_ALT_RIGHT_ON;\n\n\tprivate final TerminalManager manager;\n\tprivate final TerminalBridge bridge;\n\tprivate final VDUBuffer buffer;\n\n\tprivate String keymode = null;\n\tprivate final boolean deviceHasHardKeyboard;\n\n\tprivate int ourMetaState = 0;\n\n\tprivate int mDeadKey = 0;\n\n\t// TODO add support for the new API.\n\tprivate ClipboardManager clipboard = null;\n\n\tprivate boolean selectingForCopy = false;\n\tprivate final SelectionArea selectionArea;\n\n\tprivate String encoding;\n\n\tprivate final SharedPreferences prefs;\n\n\tpublic TerminalKeyListener(TerminalManager manager,\n\t\t\tTerminalBridge bridge,\n\t\t\tVDUBuffer buffer,\n\t\t\tString encoding) {\n\t\tthis.manager = manager;\n\t\tthis.bridge = bridge;\n\t\tthis.buffer = buffer;\n\t\tthis.encoding = encoding;\n\n\t\tselectionArea = new SelectionArea();\n\n\t\tprefs = PreferenceManager.getDefaultSharedPreferences(manager);\n\t\tprefs.registerOnSharedPreferenceChangeListener(this);\n\n\t\tdeviceHasHardKeyboard = (manager.res.getConfiguration().keyboard\n\t\t\t\t== Configuration.KEYBOARD_QWERTY);\n\n\t\tupdateKeymode();\n\t}\n\n\t/**\n\t * Handle onKey() events coming down from a {@link TerminalView} above us.\n\t * Modify the keys to make more sense to a host then pass it to the transport.\n\t */\n\tpublic boolean onKey(View v, int keyCode, KeyEvent event) {\n\t\ttry {\n\t\t\t// skip keys if we aren't connected yet or have been disconnected\n\t\t\tif (bridge.isDisconnected() || bridge.transport == null)\n\t\t\t\treturn false;\n\n\t\t\tfinal boolean interpretAsHardKeyboard = deviceHasHardKeyboard &&\n\t\t\t\t\t!manager.hardKeyboardHidden;\n\t\t\tfinal boolean rightModifiersAreSlashAndTab = interpretAsHardKeyboard &&\n\t\t\t\t\tPreferenceConstants.KEYMODE_RIGHT.equals(keymode);\n\t\t\tfinal boolean leftModifiersAreSlashAndTab = interpretAsHardKeyboard &&\n\t\t\t\t\tPreferenceConstants.KEYMODE_LEFT.equals(keymode);\n\t\t\tfinal boolean volumeKeysChangeFontSize = true;\n\t\t\tfinal boolean shiftedNumbersAreFKeys = interpretAsHardKeyboard;\n\t\t\tfinal boolean controlNumbersAreFKeys = !interpretAsHardKeyboard;\n\n\t\t\t// Ignore all key-up events except for the special keys\n\t\t\tif (event.getAction() == KeyEvent.ACTION_UP) {\n\t\t\t\tif (rightModifiersAreSlashAndTab) {\n\t\t\t\t\tif (keyCode == KeyEvent.KEYCODE_ALT_RIGHT\n\t\t\t\t\t\t\t&& (ourMetaState & OUR_SLASH) != 0) {\n\t\t\t\t\t\tourMetaState &= ~OUR_TRANSIENT;\n\t\t\t\t\t\tbridge.transport.write('/');\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t} else if (keyCode == KeyEvent.KEYCODE_SHIFT_RIGHT\n\t\t\t\t\t\t\t&& (ourMetaState & OUR_TAB) != 0) {\n\t\t\t\t\t\tourMetaState &= ~OUR_TRANSIENT;\n\t\t\t\t\t\tbridge.transport.write(0x09);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else if (leftModifiersAreSlashAndTab) {\n\t\t\t\t\tif (keyCode == KeyEvent.KEYCODE_ALT_LEFT\n\t\t\t\t\t\t\t&& (ourMetaState & OUR_SLASH) != 0) {\n\t\t\t\t\t\tourMetaState &= ~OUR_TRANSIENT;\n\t\t\t\t\t\tbridge.transport.write('/');\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t} else if (keyCode == KeyEvent.KEYCODE_SHIFT_LEFT\n\t\t\t\t\t\t\t&& (ourMetaState & OUR_TAB) != 0) {\n\t\t\t\t\t\tourMetaState &= ~OUR_TRANSIENT;\n\t\t\t\t\t\tbridge.transport.write(0x09);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (volumeKeysChangeFontSize) {\n\t\t\t\tif (keyCode == KeyEvent.KEYCODE_VOLUME_UP) {\n\t\t\t\t\tbridge.increaseFontSize();\n\t\t\t\t\treturn true;\n\t\t\t\t} else if(keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) {\n\t\t\t\t\tbridge.decreaseFontSize();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbridge.resetScrollPosition();\n\n\t\t\t// Handle potentially multi-character IME input.\n\t\t\tif (keyCode == KeyEvent.KEYCODE_UNKNOWN &&\n\t\t\t\t\tevent.getAction() == KeyEvent.ACTION_MULTIPLE) {\n\t\t\t\tbyte[] input = event.getCharacters().getBytes(encoding);\n\t\t\t\tbridge.transport.write(input);\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t/// Handle alt and shift keys if they aren't repeating\n\t\t\tif (event.getRepeatCount() == 0) {\n\t\t\t\tif (rightModifiersAreSlashAndTab) {\n\t\t\t\t\tswitch (keyCode) {\n\t\t\t\t\tcase KeyEvent.KEYCODE_ALT_RIGHT:\n\t\t\t\t\t\tourMetaState |= OUR_SLASH;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tcase KeyEvent.KEYCODE_SHIFT_RIGHT:\n\t\t\t\t\t\tourMetaState |= OUR_TAB;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tcase KeyEvent.KEYCODE_SHIFT_LEFT:\n\t\t\t\t\t\tmetaPress(OUR_SHIFT_ON);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tcase KeyEvent.KEYCODE_ALT_LEFT:\n\t\t\t\t\t\tmetaPress(OUR_ALT_ON);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else if (leftModifiersAreSlashAndTab) {\n\t\t\t\t\tswitch (keyCode) {\n\t\t\t\t\tcase KeyEvent.KEYCODE_ALT_LEFT:\n\t\t\t\t\t\tourMetaState |= OUR_SLASH;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tcase KeyEvent.KEYCODE_SHIFT_LEFT:\n\t\t\t\t\t\tourMetaState |= OUR_TAB;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tcase KeyEvent.KEYCODE_SHIFT_RIGHT:\n\t\t\t\t\t\tmetaPress(OUR_SHIFT_ON);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tcase KeyEvent.KEYCODE_ALT_RIGHT:\n\t\t\t\t\t\tmetaPress(OUR_ALT_ON);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tswitch (keyCode) {\n\t\t\t\t\tcase KeyEvent.KEYCODE_ALT_LEFT:\n\t\t\t\t\tcase KeyEvent.KEYCODE_ALT_RIGHT:\n\t\t\t\t\t\tmetaPress(OUR_ALT_ON);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tcase KeyEvent.KEYCODE_SHIFT_LEFT:\n\t\t\t\t\tcase KeyEvent.KEYCODE_SHIFT_RIGHT:\n\t\t\t\t\t\tmetaPress(OUR_SHIFT_ON);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (keyCode == KeyEvent.KEYCODE_DPAD_CENTER) {\n\t\t\t\tif (selectingForCopy) {\n\t\t\t\t\tif (selectionArea.isSelectingOrigin())\n\t\t\t\t\t\tselectionArea.finishSelectingOrigin();\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (clipboard != null) {\n\t\t\t\t\t\t\t// copy selected area to clipboard\n\t\t\t\t\t\t\tString copiedText = selectionArea.copyFrom(buffer);\n\t\t\t\t\t\t\tclipboard.setText(copiedText);\n\t\t\t\t\t\t\t// XXX STOPSHIP\n//\t\t\t\t\t\t\tmanager.notifyUser(manager.getString(\n//\t\t\t\t\t\t\t\t\tR.string.console_copy_done,\n//\t\t\t\t\t\t\t\t\tcopiedText.length()));\n\t\t\t\t\t\t\tselectingForCopy = false;\n\t\t\t\t\t\t\tselectionArea.reset();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif ((ourMetaState & OUR_CTRL_ON) != 0) {\n\t\t\t\t\t\tsendEscape();\n\t\t\t\t\t\tourMetaState &= ~OUR_CTRL_ON;\n\t\t\t\t\t} else\n\t\t\t\t\t\tmetaPress(OUR_CTRL_ON);\n\t\t\t\t}\n\t\t\t\tbridge.redraw();\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tint derivedMetaState = event.getMetaState();\n\t\t\tif ((ourMetaState & OUR_SHIFT_MASK) != 0)\n\t\t\t\tderivedMetaState |= KeyEvent.META_SHIFT_ON;\n\t\t\tif ((ourMetaState & OUR_ALT_MASK) != 0)\n\t\t\t\tderivedMetaState |= KeyEvent.META_ALT_ON;\n\t\t\tif ((ourMetaState & OUR_CTRL_MASK) != 0)\n\t\t\t\tderivedMetaState |= HC_META_CTRL_ON;\n\n\t\t\tif ((ourMetaState & OUR_TRANSIENT) != 0) {\n\t\t\t\tourMetaState &= ~OUR_TRANSIENT;\n\t\t\t\tbridge.redraw();\n\t\t\t}\n\n\t\t\t// Test for modified numbers becoming function keys\n\t\t\tif (shiftedNumbersAreFKeys && (derivedMetaState & KeyEvent.META_SHIFT_ON) != 0) {\n\t\t\t\tif (sendFunctionKey(keyCode))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (controlNumbersAreFKeys && (derivedMetaState & HC_META_CTRL_ON) != 0) {\n\t\t\t\tif (sendFunctionKey(keyCode))\n\t\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// Ask the system to use the keymap to give us the unicode character for this key,\n\t\t\t// with our derived modifier state applied.\n\t\t\tint uchar = event.getUnicodeChar(derivedMetaState & ~HC_META_CTRL_ON);\n\t\t\tint ucharWithoutAlt = event.getUnicodeChar(\n\t\t\t        derivedMetaState & ~(HC_META_ALT_MASK | HC_META_CTRL_ON));\n\t\t\tif (uchar != ucharWithoutAlt) {\n\t\t\t\t// The alt key was used to modify the character returned; therefore, drop the alt\n\t\t\t\t// modifier from the state so we don't end up sending alt+key.\n\t\t\t\tderivedMetaState &= ~HC_META_ALT_MASK;\n\t\t\t}\n\n\t\t\t// Remove shift from the modifier state as it has already been used by getUnicodeChar.\n\t\t\tderivedMetaState &= ~KeyEvent.META_SHIFT_ON;\n\n\t\t\tif ((uchar & KeyCharacterMap.COMBINING_ACCENT) != 0) {\n\t\t\t\tmDeadKey = uchar & KeyCharacterMap.COMBINING_ACCENT_MASK;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (mDeadKey != 0) {\n\t\t\t\tuchar = KeyCharacterMap.getDeadChar(mDeadKey, keyCode);\n\t\t\t\tmDeadKey = 0;\n\t\t\t}\n\n\t\t\t// If we have a defined non-control character\n\t\t\tif (uchar >= 0x20) {\n\t\t\t\tif ((derivedMetaState & HC_META_CTRL_ON) != 0)\n\t\t\t\t\tuchar = keyAsControl(uchar);\n\t\t\t\tif ((derivedMetaState & KeyEvent.META_ALT_ON) != 0)\n\t\t\t\t\tsendEscape();\n\t\t\t\tif (uchar < 0x80)\n\t\t\t\t\tbridge.transport.write(uchar);\n\t\t\t\telse\n\t\t\t\t\t// TODO write encoding routine that doesn't allocate each time\n\t\t\t\t\tbridge.transport.write(new String(Character.toChars(uchar))\n\t\t\t\t\t\t\t.getBytes(encoding));\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// look for special chars\n\t\t\tswitch(keyCode) {\n\t\t\tcase KEYCODE_ESCAPE:\n\t\t\t\tsendEscape();\n\t\t\t\treturn true;\n\t\t\tcase KeyEvent.KEYCODE_TAB:\n\t\t\t\tbridge.transport.write(0x09);\n\t\t\t\treturn true;\n\t\t\tcase KeyEvent.KEYCODE_CAMERA:\n\n\t\t\t\t// check to see which shortcut the camera button triggers\n\t\t\t\tString camera = manager.prefs.getString(\n\t\t\t\t\t\tPreferenceConstants.CAMERA,\n\t\t\t\t\t\tPreferenceConstants.CAMERA_CTRLA_SPACE);\n\t\t\t\tif(PreferenceConstants.CAMERA_CTRLA_SPACE.equals(camera)) {\n\t\t\t\t\tbridge.transport.write(0x01);\n\t\t\t\t\tbridge.transport.write(' ');\n\t\t\t\t} else if(PreferenceConstants.CAMERA_CTRLA.equals(camera)) {\n\t\t\t\t\tbridge.transport.write(0x01);\n\t\t\t\t} else if(PreferenceConstants.CAMERA_ESC.equals(camera)) {\n\t\t\t\t\t((vt320)buffer).keyTyped(vt320.KEY_ESCAPE, ' ', 0);\n\t\t\t\t} else if(PreferenceConstants.CAMERA_ESC_A.equals(camera)) {\n\t\t\t\t\t((vt320)buffer).keyTyped(vt320.KEY_ESCAPE, ' ', 0);\n\t\t\t\t\tbridge.transport.write('a');\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase KeyEvent.KEYCODE_DEL:\n\t\t\t\t((vt320) buffer).keyPressed(vt320.KEY_BACK_SPACE, ' ',\n\t\t\t\t\t\tgetStateForBuffer());\n\t\t\t\treturn true;\n\t\t\tcase KeyEvent.KEYCODE_ENTER:\n\t\t\t\t((vt320)buffer).keyTyped(vt320.KEY_ENTER, ' ', 0);\n\t\t\t\treturn true;\n\n\t\t\tcase KeyEvent.KEYCODE_DPAD_LEFT:\n\t\t\t\tif (selectingForCopy) {\n\t\t\t\t\tselectionArea.decrementColumn();\n\t\t\t\t\tbridge.redraw();\n\t\t\t\t} else {\n\t\t\t\t\t((vt320) buffer).keyPressed(vt320.KEY_LEFT, ' ',\n\t\t\t\t\t\t\tgetStateForBuffer());\n\t\t\t\t\tbridge.tryKeyVibrate();\n\t\t\t\t}\n\t\t\t\treturn true;\n\n\t\t\tcase KeyEvent.KEYCODE_DPAD_UP:\n\t\t\t\tif (selectingForCopy) {\n\t\t\t\t\tselectionArea.decrementRow();\n\t\t\t\t\tbridge.redraw();\n\t\t\t\t} else {\n\t\t\t\t\t((vt320) buffer).keyPressed(vt320.KEY_UP, ' ',\n\t\t\t\t\t\t\tgetStateForBuffer());\n\t\t\t\t\tbridge.tryKeyVibrate();\n\t\t\t\t}\n\t\t\t\treturn true;\n\n\t\t\tcase KeyEvent.KEYCODE_DPAD_DOWN:\n\t\t\t\tif (selectingForCopy) {\n\t\t\t\t\tselectionArea.incrementRow();\n\t\t\t\t\tbridge.redraw();\n\t\t\t\t} else {\n\t\t\t\t\t((vt320) buffer).keyPressed(vt320.KEY_DOWN, ' ',\n\t\t\t\t\t\t\tgetStateForBuffer());\n\t\t\t\t\tbridge.tryKeyVibrate();\n\t\t\t\t}\n\t\t\t\treturn true;\n\n\t\t\tcase KeyEvent.KEYCODE_DPAD_RIGHT:\n\t\t\t\tif (selectingForCopy) {\n\t\t\t\t\tselectionArea.incrementColumn();\n\t\t\t\t\tbridge.redraw();\n\t\t\t\t} else {\n\t\t\t\t\t((vt320) buffer).keyPressed(vt320.KEY_RIGHT, ' ',\n\t\t\t\t\t\t\tgetStateForBuffer());\n\t\t\t\t\tbridge.tryKeyVibrate();\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t} catch (IOException e) {\n\t\t\tLog.e(TAG, \"Problem while trying to handle an onKey() event\", e);\n\t\t\ttry {\n\t\t\t\tbridge.transport.flush();\n\t\t\t} catch (IOException ioe) {\n\t\t\t\tLog.d(TAG, \"Our transport was closed, dispatching disconnect event\");\n\t\t\t\tbridge.dispatchDisconnect(false);\n\t\t\t}\n\t\t} catch (NullPointerException npe) {\n\t\t\tLog.d(TAG, \"Input before connection established ignored.\");\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tpublic int keyAsControl(int key) {\n\t\t// Support CTRL-a through CTRL-z\n\t\tif (key >= 0x61 && key <= 0x7A)\n\t\t\tkey -= 0x60;\n\t\t// Support CTRL-A through CTRL-_\n\t\telse if (key >= 0x41 && key <= 0x5F)\n\t\t\tkey -= 0x40;\n\t\t// CTRL-space sends NULL\n\t\telse if (key == 0x20)\n\t\t\tkey = 0x00;\n\t\t// CTRL-? sends DEL\n\t\telse if (key == 0x3F)\n\t\t\tkey = 0x7F;\n\t\treturn key;\n\t}\n\n\tpublic void sendEscape() {\n\t\t((vt320)buffer).keyTyped(vt320.KEY_ESCAPE, ' ', 0);\n\t}\n\n\t/**\n\t * @param key\n\t * @return successful\n\t */\n\tprivate boolean sendFunctionKey(int keyCode) {\n\t\tswitch (keyCode) {\n\t\tcase KeyEvent.KEYCODE_1:\n\t\t\t((vt320) buffer).keyPressed(vt320.KEY_F1, ' ', 0);\n\t\t\treturn true;\n\t\tcase KeyEvent.KEYCODE_2:\n\t\t\t((vt320) buffer).keyPressed(vt320.KEY_F2, ' ', 0);\n\t\t\treturn true;\n\t\tcase KeyEvent.KEYCODE_3:\n\t\t\t((vt320) buffer).keyPressed(vt320.KEY_F3, ' ', 0);\n\t\t\treturn true;\n\t\tcase KeyEvent.KEYCODE_4:\n\t\t\t((vt320) buffer).keyPressed(vt320.KEY_F4, ' ', 0);\n\t\t\treturn true;\n\t\tcase KeyEvent.KEYCODE_5:\n\t\t\t((vt320) buffer).keyPressed(vt320.KEY_F5, ' ', 0);\n\t\t\treturn true;\n\t\tcase KeyEvent.KEYCODE_6:\n\t\t\t((vt320) buffer).keyPressed(vt320.KEY_F6, ' ', 0);\n\t\t\treturn true;\n\t\tcase KeyEvent.KEYCODE_7:\n\t\t\t((vt320) buffer).keyPressed(vt320.KEY_F7, ' ', 0);\n\t\t\treturn true;\n\t\tcase KeyEvent.KEYCODE_8:\n\t\t\t((vt320) buffer).keyPressed(vt320.KEY_F8, ' ', 0);\n\t\t\treturn true;\n\t\tcase KeyEvent.KEYCODE_9:\n\t\t\t((vt320) buffer).keyPressed(vt320.KEY_F9, ' ', 0);\n\t\t\treturn true;\n\t\tcase KeyEvent.KEYCODE_0:\n\t\t\t((vt320) buffer).keyPressed(vt320.KEY_F10, ' ', 0);\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Handle meta key presses where the key can be locked on.\n\t * <p>\n\t * 1st press: next key to have meta state<br />\n\t * 2nd press: meta state is locked on<br />\n\t * 3rd press: disable meta state\n\t *\n\t * @param code\n\t */\n\tpublic void metaPress(int code) {\n\t\tif ((ourMetaState & (code << 1)) != 0) {\n\t\t\tourMetaState &= ~(code << 1);\n\t\t} else if ((ourMetaState & code) != 0) {\n\t\t\tourMetaState &= ~code;\n\t\t\tourMetaState |= code << 1;\n\t\t} else\n\t\t\tourMetaState |= code;\n\t\tbridge.redraw();\n\t}\n\n\tpublic void setTerminalKeyMode(String keymode) {\n\t\tthis.keymode = keymode;\n\t}\n\n\tprivate int getStateForBuffer() {\n\t\tint bufferState = 0;\n\n\t\tif ((ourMetaState & OUR_CTRL_MASK) != 0)\n\t\t\tbufferState |= vt320.KEY_CONTROL;\n\t\tif ((ourMetaState & OUR_SHIFT_MASK) != 0)\n\t\t\tbufferState |= vt320.KEY_SHIFT;\n\t\tif ((ourMetaState & OUR_ALT_MASK) != 0)\n\t\t\tbufferState |= vt320.KEY_ALT;\n\n\t\treturn bufferState;\n\t}\n\n\tpublic int getMetaState() {\n\t\treturn ourMetaState;\n\t}\n\n\tpublic int getDeadKey() {\n\t\treturn mDeadKey;\n\t}\n\n\tpublic void setClipboardManager(ClipboardManager clipboard) {\n\t\tthis.clipboard = clipboard;\n\t}\n\n\tpublic void onSharedPreferenceChanged(SharedPreferences sharedPreferences,\n\t\t\tString key) {\n\t\tif (PreferenceConstants.KEYMODE.equals(key)) {\n\t\t\tupdateKeymode();\n\t\t}\n\t}\n\n\tprivate void updateKeymode() {\n\t\tkeymode = prefs.getString(PreferenceConstants.KEYMODE, PreferenceConstants.KEYMODE_RIGHT);\n\t}\n\n\tpublic void setCharset(String encoding) {\n\t\tthis.encoding = encoding;\n\t}\n}\n","lineNo":124}
{"Smelly Sample":"/*\n * ConnectBot: simple, powerful, open-source SSH client for Android\n * Copyright 2007 Kenny Root, Jeffrey Sharkey\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *\t http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.connectbot.util;\n\nimport java.io.IOException;\nimport java.math.BigInteger;\nimport java.security.AlgorithmParameters;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.Key;\nimport java.security.KeyFactory;\nimport java.security.KeyPair;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.SecureRandom;\nimport java.security.interfaces.DSAParams;\nimport java.security.interfaces.DSAPrivateKey;\nimport java.security.interfaces.DSAPublicKey;\nimport java.security.interfaces.ECPrivateKey;\nimport java.security.interfaces.ECPublicKey;\nimport java.security.interfaces.RSAPrivateCrtKey;\nimport java.security.interfaces.RSAPublicKey;\nimport java.security.spec.DSAPublicKeySpec;\nimport java.security.spec.ECParameterSpec;\nimport java.security.spec.ECPoint;\nimport java.security.spec.ECPublicKeySpec;\nimport java.security.spec.InvalidKeySpecException;\nimport java.security.spec.InvalidParameterSpecException;\nimport java.security.spec.KeySpec;\nimport java.security.spec.PKCS8EncodedKeySpec;\nimport java.security.spec.RSAPublicKeySpec;\nimport java.security.spec.X509EncodedKeySpec;\nimport java.util.Arrays;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.EncryptedPrivateKeyInfo;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.PBEKeySpec;\nimport javax.crypto.spec.PBEParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport org.keyczar.jce.EcCore;\n\nimport android.util.Log;\n\nimport com.trilead.ssh2.crypto.Base64;\nimport com.trilead.ssh2.crypto.SimpleDERReader;\nimport com.trilead.ssh2.signature.DSASHA1Verify;\nimport com.trilead.ssh2.signature.ECDSASHA2Verify;\nimport com.trilead.ssh2.signature.RSASHA1Verify;\n\npublic class PubkeyUtils {\n\tprivate static final String TAG = \"PubkeyUtils\";\n\n\tpublic static final String PKCS8_START = \"-----BEGIN PRIVATE KEY-----\";\n\tpublic static final String PKCS8_END = \"-----END PRIVATE KEY-----\";\n\n\t// Size in bytes of salt to use.\n\tprivate static final int SALT_SIZE = 8;\n\n\t// Number of iterations for password hashing. PKCS#5 recommends 1000\n\tprivate static final int ITERATIONS = 1000;\n\n\tpublic static String formatKey(Key key){\n\t\tString algo = key.getAlgorithm();\n\t\tString fmt = key.getFormat();\n\t\tbyte[] encoded = key.getEncoded();\n\t\treturn \"Key[algorithm=\" + algo + \", format=\" + fmt +\n\t\t\t\", bytes=\" + encoded.length + \"]\";\n\t}\n\n\tpublic static byte[] sha256(byte[] data) throws NoSuchAlgorithmException {\n\t\treturn MessageDigest.getInstance(\"SHA-256\").digest(data);\n\t}\n\n\tpublic static byte[] cipher(int mode, byte[] data, byte[] secret) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException {\n\t\tSecretKeySpec secretKeySpec = new SecretKeySpec(sha256(secret), \"AES\");\n\t\tCipher c = Cipher.getInstance(\"AES\");\n\t\tc.init(mode, secretKeySpec);\n\t\treturn c.doFinal(data);\n\t}\n\n\tpublic static byte[] encrypt(byte[] cleartext, String secret) throws Exception {\n\t\tbyte[] salt = new byte[SALT_SIZE];\n\n\t\tbyte[] ciphertext = Encryptor.encrypt(salt, ITERATIONS, secret, cleartext);\n\n\t\tbyte[] complete = new byte[salt.length + ciphertext.length];\n\n\t\tSystem.arraycopy(salt, 0, complete, 0, salt.length);\n\t\tSystem.arraycopy(ciphertext, 0, complete, salt.length, ciphertext.length);\n\n\t\tArrays.fill(salt, (byte) 0x00);\n\t\tArrays.fill(ciphertext, (byte) 0x00);\n\n\t\treturn complete;\n\t}\n\n\tpublic static byte[] decrypt(byte[] complete, String secret) throws Exception {\n\t\ttry {\n\t\t\tbyte[] salt = new byte[SALT_SIZE];\n\t\t\tbyte[] ciphertext = new byte[complete.length - salt.length];\n\n\t\t\tSystem.arraycopy(complete, 0, salt, 0, salt.length);\n\t\t\tSystem.arraycopy(complete, salt.length, ciphertext, 0, ciphertext.length);\n\n\t\t\treturn Encryptor.decrypt(salt, ITERATIONS, secret, ciphertext);\n\t\t} catch (Exception e) {\n\t\t\tLog.d(\"decrypt\", \"Could not decrypt with new method\", e);\n\t\t\t// We might be using the old encryption method.\n\t\t\treturn cipher(Cipher.DECRYPT_MODE, complete, secret.getBytes());\n\t\t}\n\t}\n\n\tpublic static byte[] getEncodedPublic(PublicKey pk) {\n\t\treturn new X509EncodedKeySpec(pk.getEncoded()).getEncoded();\n\t}\n\n\tpublic static byte[] getEncodedPrivate(PrivateKey pk) {\n\t\treturn new PKCS8EncodedKeySpec(pk.getEncoded()).getEncoded();\n\t}\n\n\tpublic static byte[] getEncodedPrivate(PrivateKey pk, String secret) throws Exception {\n\t\tif (secret.length() > 0)\n\t\t\treturn encrypt(getEncodedPrivate(pk), secret);\n\t\telse\n\t\t\treturn getEncodedPrivate(pk);\n\t}\n\n\tpublic static PrivateKey decodePrivate(byte[] encoded, String keyType) throws NoSuchAlgorithmException, InvalidKeySpecException {\n\t\tPKCS8EncodedKeySpec privKeySpec = new PKCS8EncodedKeySpec(encoded);\n\t\tKeyFactory kf = KeyFactory.getInstance(keyType);\n\t\treturn kf.generatePrivate(privKeySpec);\n\t}\n\n\tpublic static PrivateKey decodePrivate(byte[] encoded, String keyType, String secret) throws Exception {\n\t\tif (secret != null && secret.length() > 0)\n\t\t\treturn decodePrivate(decrypt(encoded, secret), keyType);\n\t\telse\n\t\t\treturn decodePrivate(encoded, keyType);\n\t}\n\n\tpublic static PublicKey decodePublic(byte[] encoded, String keyType) throws NoSuchAlgorithmException, InvalidKeySpecException {\n\t\tX509EncodedKeySpec pubKeySpec = new X509EncodedKeySpec(encoded);\n\t\tKeyFactory kf = KeyFactory.getInstance(keyType);\n\t\treturn kf.generatePublic(pubKeySpec);\n\t}\n\n\tpublic static KeyPair recoverKeyPair(byte[] encoded) throws NoSuchAlgorithmException, InvalidKeySpecException {\n\t\tKeySpec privKeySpec = new PKCS8EncodedKeySpec(encoded);\n\t\tKeySpec pubKeySpec;\n\n\t\tPrivateKey priv;\n\t\tPublicKey pub;\n\t\tKeyFactory kf;\n\n\t\tSimpleDERReader reader = new SimpleDERReader(encoded);\n\t\tfinal String oid;\n\t\ttry {\n\t\t\tif (!reader.readInt().equals(BigInteger.ZERO)) {\n\t\t\t\tthrow new InvalidKeySpecException(\"Not PKCS#8 encoded\");\n\t\t\t}\n\n\t\t\toid = reader.readOid();\n\t\t} catch (IOException e) {\n\t\t\tLog.w(TAG, \"Could not read OID\");\n\t\t\tthrow new InvalidKeySpecException(e);\n\t\t}\n\n\t\tkf = KeyFactory.getInstance(oid);\n\t\tLog.d(TAG, \"here's the algo: \" + kf.getAlgorithm());\n\n\t\ttry {\n\t\t\tkf = KeyFactory.getInstance(PubkeyDatabase.KEY_TYPE_RSA);\n\t\t\tpriv = kf.generatePrivate(privKeySpec);\n\n\t\t\tpubKeySpec = new RSAPublicKeySpec(((RSAPrivateCrtKey) priv)\n\t\t\t\t\t.getModulus(), ((RSAPrivateCrtKey) priv)\n\t\t\t\t\t.getPublicExponent());\n\n\t\t\tpub = kf.generatePublic(pubKeySpec);\n\t\t} catch (ClassCastException e) {\n\t\t\ttry {\n\t\t\t\tkf = KeyFactory.getInstance(PubkeyDatabase.KEY_TYPE_DSA);\n\t\t\t\tpriv = kf.generatePrivate(privKeySpec);\n\n\t\t\t\tDSAParams params = ((DSAPrivateKey) priv).getParams();\n\n\t\t\t\t// Calculate public key Y\n\t\t\t\tBigInteger y = params.getG().modPow(((DSAPrivateKey) priv).getX(),\n\t\t\t\t\t\tparams.getP());\n\n\t\t\t\tpubKeySpec = new DSAPublicKeySpec(y, params.getP(), params.getQ(),\n\t\t\t\t\t\tparams.getG());\n\n\t\t\t\tpub = kf.generatePublic(pubKeySpec);\n\t\t\t} catch (ClassCastException e2) {\n\t\t\t\tkf = KeyFactory.getInstance(PubkeyDatabase.KEY_TYPE_EC);\n\t\t\t\tpriv = kf.generatePrivate(privKeySpec);\n\n\t\t\t\tECParameterSpec params = ((ECPrivateKey) priv).getParams();\n\n\t\t\t\t// Calculate public key Y\n\t\t\t\tECPoint generator = params.getGenerator();\n\t\t\t\tBigInteger[] wCoords = EcCore.multiplyPoint(new BigInteger[] {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgenerator.getAffineX(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgenerator.getAffineY() },\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t((ECPrivateKey) priv).getS(), params);\n\t\t\t\tECPoint w = new ECPoint(wCoords[0], wCoords[1]);\n\n\t\t\t\tpubKeySpec = new ECPublicKeySpec(w, params);\n\n\t\t\t\tpub = kf.generatePublic(pubKeySpec);\n\t\t\t}\n\t\t}\n\n\t\treturn new KeyPair(pub, priv);\n\t}\n\n\t/*\n\t * OpenSSH compatibility methods\n\t */\n\n\tpublic static String convertToOpenSSHFormat(PublicKey pk, String origNickname) throws IOException, InvalidKeyException {\n\t\tString nickname = origNickname;\n\t\tif (nickname == null)\n\t\t\tnickname = \"connectbot@android\";\n\n\t\tif (pk instanceof RSAPublicKey) {\n\t\t\tString data = \"ssh-rsa \";\n\t\t\tdata += String.valueOf(Base64.encode(RSASHA1Verify.encodeSSHRSAPublicKey((RSAPublicKey) pk)));\n\t\t\treturn data + \" \" + nickname;\n\t\t} else if (pk instanceof DSAPublicKey) {\n\t\t\tString data = \"ssh-dss \";\n\t\t\tdata += String.valueOf(Base64.encode(DSASHA1Verify.encodeSSHDSAPublicKey((DSAPublicKey) pk)));\n\t\t\treturn data + \" \" + nickname;\n\t\t} else if (pk instanceof ECPublicKey) {\n\t\t\tECPublicKey ecPub = (ECPublicKey) pk;\n\t\t\tString keyType = ECDSASHA2Verify.getCurveName(ecPub.getParams().getCurve().getField().getFieldSize());\n\t\t\tString keyData = String.valueOf(Base64.encode(ECDSASHA2Verify.encodeSSHECDSAPublicKey(ecPub)));\n\t\t\treturn ECDSASHA2Verify.ECDSA_SHA2_PREFIX + keyType + \" \" + keyData + \" \" + nickname;\n\t\t}\n\n\t\tthrow new InvalidKeyException(\"Unknown key type\");\n\t}\n\n\t/*\n\t * OpenSSH compatibility methods\n\t */\n\n\t/**\n\t * @param trileadKey\n\t * @return OpenSSH-encoded pubkey\n\t */\n\tpublic static byte[] extractOpenSSHPublic(KeyPair pair) {\n\t\ttry {\n\t\t\tPublicKey pubKey = pair.getPublic();\n\t\t\tif (pubKey instanceof RSAPublicKey) {\n\t\t\t\treturn RSASHA1Verify.encodeSSHRSAPublicKey((RSAPublicKey) pair.getPublic());\n\t\t\t} else if (pubKey instanceof DSAPublicKey) {\n\t\t\t\treturn DSASHA1Verify.encodeSSHDSAPublicKey((DSAPublicKey) pair.getPublic());\n\t\t\t} else if (pubKey instanceof ECPublicKey) {\n\t\t\t\treturn ECDSASHA2Verify.encodeSSHECDSAPublicKey((ECPublicKey) pair.getPublic());\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic static String exportPEM(PrivateKey key, String secret) throws NoSuchAlgorithmException, InvalidParameterSpecException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, InvalidKeySpecException, IllegalBlockSizeException, IOException {\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tbyte[] data = key.getEncoded();\n\n\t\tsb.append(PKCS8_START);\n\t\tsb.append('\\n');\n\n\t\tif (secret != null) {\n\t\t\tbyte[] salt = new byte[8];\n\t\t\tSecureRandom random = new SecureRandom();\n\t\t\trandom.nextBytes(salt);\n\n\t\t\tPBEParameterSpec defParams = new PBEParameterSpec(salt, 1);\n\t\t\tAlgorithmParameters params = AlgorithmParameters.getInstance(key.getAlgorithm());\n\n\t\t\tparams.init(defParams);\n\n\t\t\tPBEKeySpec pbeSpec = new PBEKeySpec(secret.toCharArray());\n\n\t\t\tSecretKeyFactory keyFact = SecretKeyFactory.getInstance(key.getAlgorithm());\n\t\t\tCipher cipher = Cipher.getInstance(key.getAlgorithm());\n\t\t\tcipher.init(Cipher.WRAP_MODE, keyFact.generateSecret(pbeSpec), params);\n\n\t\t\tbyte[] wrappedKey = cipher.wrap(key);\n\n\t\t\tEncryptedPrivateKeyInfo pinfo = new EncryptedPrivateKeyInfo(params, wrappedKey);\n\n\t\t\tdata = pinfo.getEncoded();\n\n\t\t\tsb.append(\"Proc-Type: 4,ENCRYPTED\\n\");\n\t\t\tsb.append(\"DEK-Info: DES-EDE3-CBC,\");\n\t\t\tsb.append(encodeHex(salt));\n\t\t\tsb.append(\"\\n\\n\");\n\t\t}\n\n\t\tint i = sb.length();\n\t\tsb.append(Base64.encode(data));\n\t\tfor (i += 63; i < sb.length(); i += 64) {\n\t\t\tsb.insert(i, \"\\n\");\n\t\t}\n\n\t\tsb.append('\\n');\n\t\tsb.append(PKCS8_END);\n\t\tsb.append('\\n');\n\n\t\treturn sb.toString();\n\t}\n\n\tprivate static final char[] HEX_DIGITS = { '0', '1', '2', '3', '4', '5', '6',\n\t\t\t'7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n\tprotected static String encodeHex(byte[] bytes) {\n\t\tfinal char[] hex = new char[bytes.length * 2];\n\n\t\tint i = 0;\n\t\tfor (byte b : bytes) {\n\t\t\thex[i++] = HEX_DIGITS[(b >> 4) & 0x0f];\n\t\t\thex[i++] = HEX_DIGITS[b & 0x0f];\n\t\t}\n\n\t\treturn String.valueOf(hex);\n\t}\n}\n","Method after Refactoring":"/*\n * ConnectBot: simple, powerful, open-source SSH client for Android\n * Copyright 2007 Kenny Root, Jeffrey Sharkey\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *\t http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.connectbot.util;\n\nimport java.io.IOException;\nimport java.math.BigInteger;\nimport java.security.AlgorithmParameters;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.Key;\nimport java.security.KeyFactory;\nimport java.security.KeyPair;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.SecureRandom;\nimport java.security.interfaces.DSAParams;\nimport java.security.interfaces.DSAPrivateKey;\nimport java.security.interfaces.DSAPublicKey;\nimport java.security.interfaces.ECPrivateKey;\nimport java.security.interfaces.ECPublicKey;\nimport java.security.interfaces.RSAPrivateCrtKey;\nimport java.security.interfaces.RSAPublicKey;\nimport java.security.spec.DSAPublicKeySpec;\nimport java.security.spec.ECParameterSpec;\nimport java.security.spec.ECPoint;\nimport java.security.spec.ECPublicKeySpec;\nimport java.security.spec.InvalidKeySpecException;\nimport java.security.spec.InvalidParameterSpecException;\nimport java.security.spec.KeySpec;\nimport java.security.spec.PKCS8EncodedKeySpec;\nimport java.security.spec.RSAPublicKeySpec;\nimport java.security.spec.X509EncodedKeySpec;\nimport java.util.Arrays;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.EncryptedPrivateKeyInfo;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.PBEKeySpec;\nimport javax.crypto.spec.PBEParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport org.keyczar.jce.EcCore;\n\nimport android.util.Log;\n\nimport com.trilead.ssh2.crypto.Base64;\nimport com.trilead.ssh2.crypto.SimpleDERReader;\nimport com.trilead.ssh2.signature.DSASHA1Verify;\nimport com.trilead.ssh2.signature.ECDSASHA2Verify;\nimport com.trilead.ssh2.signature.RSASHA1Verify;\n\npublic class PubkeyUtils {\n\tprivate static final String TAG = \"PubkeyUtils\";\n\n\tpublic static final String PKCS8_START = \"-----BEGIN PRIVATE KEY-----\";\n\tpublic static final String PKCS8_END = \"-----END PRIVATE KEY-----\";\n\n\t// Size in bytes of salt to use.\n\tprivate static final int SALT_SIZE = 8;\n\n\t// Number of iterations for password hashing. PKCS#5 recommends 1000\n\tprivate static final int ITERATIONS = 1000;\n\n\tpublic static String formatKey(Key key){\n\t\tString algo = key.getAlgorithm();\n\t\tString fmt = key.getFormat();\n\t\tbyte[] encoded = key.getEncoded();\n\t\treturn \"Key[algorithm=\" + algo + \", format=\" + fmt +\n\t\t\t\", bytes=\" + encoded.length + \"]\";\n\t}\n\n\tpublic static byte[] sha256(byte[] data) throws NoSuchAlgorithmException {\n\t\treturn MessageDigest.getInstance(\"SHA-256\").digest(data);\n\t}\n\n\tpublic static byte[] cipher(int mode, byte[] data, byte[] secret) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException {\n\t\tSecretKeySpec secretKeySpec = new SecretKeySpec(sha256(secret), \"AES\");\n\t\tCipher c = Cipher.getInstance(\"AES\");\n\t\tc.init(mode, secretKeySpec);\n\t\treturn c.doFinal(data);\n\t}\n\n\tpublic static byte[] encrypt(byte[] cleartext, String secret) throws Exception {\n\t\tbyte[] salt = new byte[SALT_SIZE];\n\n\t\tbyte[] ciphertext = Encryptor.encrypt(salt, ITERATIONS, secret, cleartext);\n\n\t\tbyte[] complete = new byte[salt.length + ciphertext.length];\n\n\t\tSystem.arraycopy(salt, 0, complete, 0, salt.length);\n\t\tSystem.arraycopy(ciphertext, 0, complete, salt.length, ciphertext.length);\n\n\t\tArrays.fill(salt, (byte) 0x00);\n\t\tArrays.fill(ciphertext, (byte) 0x00);\n\n\t\treturn complete;\n\t}\n\n\tpublic static byte[] decrypt(byte[] complete, String secret) throws Exception {\n\t\ttry {\n\t\t\tbyte[] salt = new byte[SALT_SIZE];\n\t\t\tbyte[] ciphertext = new byte[complete.length - salt.length];\n\n\t\t\tSystem.arraycopy(complete, 0, salt, 0, salt.length);\n\t\t\tSystem.arraycopy(complete, salt.length, ciphertext, 0, ciphertext.length);\n\n\t\t\treturn Encryptor.decrypt(salt, ITERATIONS, secret, ciphertext);\n\t\t} catch (Exception e) {\n\t\t\tLog.d(\"decrypt\", \"Could not decrypt with new method\", e);\n\t\t\t// We might be using the old encryption method.\n\t\t\treturn cipher(Cipher.DECRYPT_MODE, complete, secret.getBytes());\n\t\t}\n\t}\n\n\tpublic static byte[] getEncodedPublic(PublicKey pk) {\n\t\treturn new X509EncodedKeySpec(pk.getEncoded()).getEncoded();\n\t}\n\n\tpublic static byte[] getEncodedPrivate(PrivateKey pk) {\n\t\treturn new PKCS8EncodedKeySpec(pk.getEncoded()).getEncoded();\n\t}\n\n\tpublic static byte[] getEncodedPrivate(PrivateKey pk, String secret) throws Exception {\n\t\tif (secret.length() > 0)\n\t\t\treturn encrypt(getEncodedPrivate(pk), secret);\n\t\telse\n\t\t\treturn getEncodedPrivate(pk);\n\t}\n\n\tpublic static PrivateKey decodePrivate(byte[] encoded, String keyType) throws NoSuchAlgorithmException, InvalidKeySpecException {\n\t\tPKCS8EncodedKeySpec privKeySpec = new PKCS8EncodedKeySpec(encoded);\n\t\tKeyFactory kf = KeyFactory.getInstance(keyType);\n\t\treturn kf.generatePrivate(privKeySpec);\n\t}\n\n\tpublic static PrivateKey decodePrivate(byte[] encoded, String keyType, String secret) throws Exception {\n\t\tif (secret != null && secret.length() > 0)\n\t\t\treturn decodePrivate(decrypt(encoded, secret), keyType);\n\t\telse\n\t\t\treturn decodePrivate(encoded, keyType);\n\t}\n\n\tpublic static PublicKey decodePublic(byte[] encoded, String keyType) throws NoSuchAlgorithmException, InvalidKeySpecException {\n\t\tX509EncodedKeySpec pubKeySpec = new X509EncodedKeySpec(encoded);\n\t\tKeyFactory kf = KeyFactory.getInstance(keyType);\n\t\treturn kf.generatePublic(pubKeySpec);\n\t}\n\n\tpublic static KeyPair recoverKeyPair(byte[] encoded) throws NoSuchAlgorithmException, InvalidKeySpecException {\n\t\tKeySpec privKeySpec = new PKCS8EncodedKeySpec(encoded);\n\t\tKeySpec pubKeySpec;\n\n\t\tPrivateKey priv;\n\t\tPublicKey pub;\n\t\tKeyFactory kf;\n\n\t\tfinal String oid;\n\t\ttry {\n\t\t\tSimpleDERReader reader = new SimpleDERReader(encoded);\n\t\t\treader.resetInput(reader.readSequenceAsByteArray());\n\t\t\treader.readInt();\n\t\t\treader.resetInput(reader.readSequenceAsByteArray());\n\t\t\toid = reader.readOid();\n\n\t\t\tkf = KeyFactory.getInstance(oid);\n\t\t\tpriv = kf.generatePrivate(privKeySpec);\n\t\t} catch (IOException e) {\n\t\t\tLog.w(TAG, \"Could not read OID\", e);\n\t\t\tthrow new InvalidKeySpecException(\"Could not read key\", e);\n\t\t}\n\n\t\tif (priv instanceof RSAPrivateCrtKey) {\n\t\t\tRSAPrivateCrtKey rsaPriv = (RSAPrivateCrtKey) priv;\n\t\t\tpubKeySpec = new RSAPublicKeySpec(rsaPriv.getModulus(), rsaPriv.getPublicExponent());\n\n\t\t\tpub = kf.generatePublic(pubKeySpec);\n\t\t} else if (priv instanceof DSAPrivateKey) {\n\t\t\tDSAPrivateKey dsaPriv = (DSAPrivateKey) priv;\n\t\t\tDSAParams params = dsaPriv.getParams();\n\n\t\t\t// Calculate public key Y\n\t\t\tBigInteger y = params.getG().modPow(dsaPriv.getX(), params.getP());\n\n\t\t\tpubKeySpec = new DSAPublicKeySpec(y, params.getP(), params.getQ(), params.getG());\n\n\t\t\tpub = kf.generatePublic(pubKeySpec);\n\t\t} else if (priv instanceof ECPrivateKey) {\n\t\t\tECPrivateKey ecPriv = (ECPrivateKey) priv;\n\t\t\tECParameterSpec params = ecPriv.getParams();\n\n\t\t\t// Calculate public key Y\n\t\t\tECPoint generator = params.getGenerator();\n\t\t\tBigInteger[] wCoords = EcCore.multiplyPoint(new BigInteger[] {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgenerator.getAffineX(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgenerator.getAffineY() },\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tecPriv.getS(), params);\n\t\t\tECPoint w = new ECPoint(wCoords[0], wCoords[1]);\n\n\t\t\tpubKeySpec = new ECPublicKeySpec(w, params);\n\n\t\t\tpub = kf.generatePublic(pubKeySpec);\n\t\t} else {\n\t\t\tthrow new NoSuchAlgorithmException(\"Unknown OID: \" + oid);\n\t\t}\n\n\t\treturn new KeyPair(pub, priv);\n\t}\n\n\t/*\n\t * OpenSSH compatibility methods\n\t */\n\n\tpublic static String convertToOpenSSHFormat(PublicKey pk, String origNickname) throws IOException, InvalidKeyException {\n\t\tString nickname = origNickname;\n\t\tif (nickname == null)\n\t\t\tnickname = \"connectbot@android\";\n\n\t\tif (pk instanceof RSAPublicKey) {\n\t\t\tString data = \"ssh-rsa \";\n\t\t\tdata += String.valueOf(Base64.encode(RSASHA1Verify.encodeSSHRSAPublicKey((RSAPublicKey) pk)));\n\t\t\treturn data + \" \" + nickname;\n\t\t} else if (pk instanceof DSAPublicKey) {\n\t\t\tString data = \"ssh-dss \";\n\t\t\tdata += String.valueOf(Base64.encode(DSASHA1Verify.encodeSSHDSAPublicKey((DSAPublicKey) pk)));\n\t\t\treturn data + \" \" + nickname;\n\t\t} else if (pk instanceof ECPublicKey) {\n\t\t\tECPublicKey ecPub = (ECPublicKey) pk;\n\t\t\tString keyType = ECDSASHA2Verify.getCurveName(ecPub.getParams().getCurve().getField().getFieldSize());\n\t\t\tString keyData = String.valueOf(Base64.encode(ECDSASHA2Verify.encodeSSHECDSAPublicKey(ecPub)));\n\t\t\treturn ECDSASHA2Verify.ECDSA_SHA2_PREFIX + keyType + \" \" + keyData + \" \" + nickname;\n\t\t}\n\n\t\tthrow new InvalidKeyException(\"Unknown key type\");\n\t}\n\n\t/*\n\t * OpenSSH compatibility methods\n\t */\n\n\t/**\n\t * @param trileadKey\n\t * @return OpenSSH-encoded pubkey\n\t */\n\tpublic static byte[] extractOpenSSHPublic(KeyPair pair) {\n\t\ttry {\n\t\t\tPublicKey pubKey = pair.getPublic();\n\t\t\tif (pubKey instanceof RSAPublicKey) {\n\t\t\t\treturn RSASHA1Verify.encodeSSHRSAPublicKey((RSAPublicKey) pair.getPublic());\n\t\t\t} else if (pubKey instanceof DSAPublicKey) {\n\t\t\t\treturn DSASHA1Verify.encodeSSHDSAPublicKey((DSAPublicKey) pair.getPublic());\n\t\t\t} else if (pubKey instanceof ECPublicKey) {\n\t\t\t\treturn ECDSASHA2Verify.encodeSSHECDSAPublicKey((ECPublicKey) pair.getPublic());\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic static String exportPEM(PrivateKey key, String secret) throws NoSuchAlgorithmException, InvalidParameterSpecException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, InvalidKeySpecException, IllegalBlockSizeException, IOException {\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tbyte[] data = key.getEncoded();\n\n\t\tsb.append(PKCS8_START);\n\t\tsb.append('\\n');\n\n\t\tif (secret != null) {\n\t\t\tbyte[] salt = new byte[8];\n\t\t\tSecureRandom random = new SecureRandom();\n\t\t\trandom.nextBytes(salt);\n\n\t\t\tPBEParameterSpec defParams = new PBEParameterSpec(salt, 1);\n\t\t\tAlgorithmParameters params = AlgorithmParameters.getInstance(key.getAlgorithm());\n\n\t\t\tparams.init(defParams);\n\n\t\t\tPBEKeySpec pbeSpec = new PBEKeySpec(secret.toCharArray());\n\n\t\t\tSecretKeyFactory keyFact = SecretKeyFactory.getInstance(key.getAlgorithm());\n\t\t\tCipher cipher = Cipher.getInstance(key.getAlgorithm());\n\t\t\tcipher.init(Cipher.WRAP_MODE, keyFact.generateSecret(pbeSpec), params);\n\n\t\t\tbyte[] wrappedKey = cipher.wrap(key);\n\n\t\t\tEncryptedPrivateKeyInfo pinfo = new EncryptedPrivateKeyInfo(params, wrappedKey);\n\n\t\t\tdata = pinfo.getEncoded();\n\n\t\t\tsb.append(\"Proc-Type: 4,ENCRYPTED\\n\");\n\t\t\tsb.append(\"DEK-Info: DES-EDE3-CBC,\");\n\t\t\tsb.append(encodeHex(salt));\n\t\t\tsb.append(\"\\n\\n\");\n\t\t}\n\n\t\tint i = sb.length();\n\t\tsb.append(Base64.encode(data));\n\t\tfor (i += 63; i < sb.length(); i += 64) {\n\t\t\tsb.insert(i, \"\\n\");\n\t\t}\n\n\t\tsb.append('\\n');\n\t\tsb.append(PKCS8_END);\n\t\tsb.append('\\n');\n\n\t\treturn sb.toString();\n\t}\n\n\tprivate static final char[] HEX_DIGITS = { '0', '1', '2', '3', '4', '5', '6',\n\t\t\t'7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n\tprotected static String encodeHex(byte[] bytes) {\n\t\tfinal char[] hex = new char[bytes.length * 2];\n\n\t\tint i = 0;\n\t\tfor (byte b : bytes) {\n\t\t\thex[i++] = HEX_DIGITS[(b >> 4) & 0x0f];\n\t\t\thex[i++] = HEX_DIGITS[b & 0x0f];\n\t\t}\n\n\t\treturn String.valueOf(hex);\n\t}\n}\n","lineNo":198}
{"Smelly Sample":"/*\n * ConnectBot: simple, powerful, open-source SSH client for Android\n * Copyright 2007 Kenny Root, Jeffrey Sharkey\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *\t http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.connectbot.util;\n\nimport java.io.IOException;\nimport java.math.BigInteger;\nimport java.security.AlgorithmParameters;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.Key;\nimport java.security.KeyFactory;\nimport java.security.KeyPair;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.SecureRandom;\nimport java.security.interfaces.DSAParams;\nimport java.security.interfaces.DSAPrivateKey;\nimport java.security.interfaces.DSAPublicKey;\nimport java.security.interfaces.ECPrivateKey;\nimport java.security.interfaces.ECPublicKey;\nimport java.security.interfaces.RSAPrivateCrtKey;\nimport java.security.interfaces.RSAPublicKey;\nimport java.security.spec.DSAPublicKeySpec;\nimport java.security.spec.ECParameterSpec;\nimport java.security.spec.ECPoint;\nimport java.security.spec.ECPublicKeySpec;\nimport java.security.spec.InvalidKeySpecException;\nimport java.security.spec.InvalidParameterSpecException;\nimport java.security.spec.KeySpec;\nimport java.security.spec.PKCS8EncodedKeySpec;\nimport java.security.spec.RSAPublicKeySpec;\nimport java.security.spec.X509EncodedKeySpec;\nimport java.util.Arrays;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.EncryptedPrivateKeyInfo;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.PBEKeySpec;\nimport javax.crypto.spec.PBEParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport org.keyczar.jce.EcCore;\n\nimport android.util.Log;\n\nimport com.trilead.ssh2.crypto.Base64;\nimport com.trilead.ssh2.crypto.SimpleDERReader;\nimport com.trilead.ssh2.signature.DSASHA1Verify;\nimport com.trilead.ssh2.signature.ECDSASHA2Verify;\nimport com.trilead.ssh2.signature.RSASHA1Verify;\n\npublic class PubkeyUtils {\n\tprivate static final String TAG = \"PubkeyUtils\";\n\n\tpublic static final String PKCS8_START = \"-----BEGIN PRIVATE KEY-----\";\n\tpublic static final String PKCS8_END = \"-----END PRIVATE KEY-----\";\n\n\t// Size in bytes of salt to use.\n\tprivate static final int SALT_SIZE = 8;\n\n\t// Number of iterations for password hashing. PKCS#5 recommends 1000\n\tprivate static final int ITERATIONS = 1000;\n\n\tpublic static String formatKey(Key key){\n\t\tString algo = key.getAlgorithm();\n\t\tString fmt = key.getFormat();\n\t\tbyte[] encoded = key.getEncoded();\n\t\treturn \"Key[algorithm=\" + algo + \", format=\" + fmt +\n\t\t\t\", bytes=\" + encoded.length + \"]\";\n\t}\n\n\tpublic static byte[] sha256(byte[] data) throws NoSuchAlgorithmException {\n\t\treturn MessageDigest.getInstance(\"SHA-256\").digest(data);\n\t}\n\n\tpublic static byte[] cipher(int mode, byte[] data, byte[] secret) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException {\n\t\tSecretKeySpec secretKeySpec = new SecretKeySpec(sha256(secret), \"AES\");\n\t\tCipher c = Cipher.getInstance(\"AES\");\n\t\tc.init(mode, secretKeySpec);\n\t\treturn c.doFinal(data);\n\t}\n\n\tpublic static byte[] encrypt(byte[] cleartext, String secret) throws Exception {\n\t\tbyte[] salt = new byte[SALT_SIZE];\n\n\t\tbyte[] ciphertext = Encryptor.encrypt(salt, ITERATIONS, secret, cleartext);\n\n\t\tbyte[] complete = new byte[salt.length + ciphertext.length];\n\n\t\tSystem.arraycopy(salt, 0, complete, 0, salt.length);\n\t\tSystem.arraycopy(ciphertext, 0, complete, salt.length, ciphertext.length);\n\n\t\tArrays.fill(salt, (byte) 0x00);\n\t\tArrays.fill(ciphertext, (byte) 0x00);\n\n\t\treturn complete;\n\t}\n\n\tpublic static byte[] decrypt(byte[] complete, String secret) throws Exception {\n\t\ttry {\n\t\t\tbyte[] salt = new byte[SALT_SIZE];\n\t\t\tbyte[] ciphertext = new byte[complete.length - salt.length];\n\n\t\t\tSystem.arraycopy(complete, 0, salt, 0, salt.length);\n\t\t\tSystem.arraycopy(complete, salt.length, ciphertext, 0, ciphertext.length);\n\n\t\t\treturn Encryptor.decrypt(salt, ITERATIONS, secret, ciphertext);\n\t\t} catch (Exception e) {\n\t\t\tLog.d(\"decrypt\", \"Could not decrypt with new method\", e);\n\t\t\t// We might be using the old encryption method.\n\t\t\treturn cipher(Cipher.DECRYPT_MODE, complete, secret.getBytes());\n\t\t}\n\t}\n\n\tpublic static byte[] getEncodedPublic(PublicKey pk) {\n\t\treturn new X509EncodedKeySpec(pk.getEncoded()).getEncoded();\n\t}\n\n\tpublic static byte[] getEncodedPrivate(PrivateKey pk) {\n\t\treturn new PKCS8EncodedKeySpec(pk.getEncoded()).getEncoded();\n\t}\n\n\tpublic static byte[] getEncodedPrivate(PrivateKey pk, String secret) throws Exception {\n\t\tif (secret.length() > 0)\n\t\t\treturn encrypt(getEncodedPrivate(pk), secret);\n\t\telse\n\t\t\treturn getEncodedPrivate(pk);\n\t}\n\n\tpublic static PrivateKey decodePrivate(byte[] encoded, String keyType) throws NoSuchAlgorithmException, InvalidKeySpecException {\n\t\tPKCS8EncodedKeySpec privKeySpec = new PKCS8EncodedKeySpec(encoded);\n\t\tKeyFactory kf = KeyFactory.getInstance(keyType);\n\t\treturn kf.generatePrivate(privKeySpec);\n\t}\n\n\tpublic static PrivateKey decodePrivate(byte[] encoded, String keyType, String secret) throws Exception {\n\t\tif (secret != null && secret.length() > 0)\n\t\t\treturn decodePrivate(decrypt(encoded, secret), keyType);\n\t\telse\n\t\t\treturn decodePrivate(encoded, keyType);\n\t}\n\n\tpublic static PublicKey decodePublic(byte[] encoded, String keyType) throws NoSuchAlgorithmException, InvalidKeySpecException {\n\t\tX509EncodedKeySpec pubKeySpec = new X509EncodedKeySpec(encoded);\n\t\tKeyFactory kf = KeyFactory.getInstance(keyType);\n\t\treturn kf.generatePublic(pubKeySpec);\n\t}\n\n\tpublic static KeyPair recoverKeyPair(byte[] encoded) throws NoSuchAlgorithmException, InvalidKeySpecException {\n\t\tKeySpec privKeySpec = new PKCS8EncodedKeySpec(encoded);\n\t\tKeySpec pubKeySpec;\n\n\t\tPrivateKey priv;\n\t\tPublicKey pub;\n\t\tKeyFactory kf;\n\n\t\tSimpleDERReader reader = new SimpleDERReader(encoded);\n\t\tfinal String oid;\n\t\ttry {\n\t\t\tif (!reader.readInt().equals(BigInteger.ZERO)) {\n\t\t\t\tthrow new InvalidKeySpecException(\"Not PKCS#8 encoded\");\n\t\t\t}\n\n\t\t\toid = reader.readOid();\n\t\t} catch (IOException e) {\n\t\t\tLog.w(TAG, \"Could not read OID\");\n\t\t\tthrow new InvalidKeySpecException(e);\n\t\t}\n\n\t\tkf = KeyFactory.getInstance(oid);\n\t\tLog.d(TAG, \"here's the algo: \" + kf.getAlgorithm());\n\n\t\ttry {\n\t\t\tkf = KeyFactory.getInstance(PubkeyDatabase.KEY_TYPE_RSA);\n\t\t\tpriv = kf.generatePrivate(privKeySpec);\n\n\t\t\tpubKeySpec = new RSAPublicKeySpec(((RSAPrivateCrtKey) priv)\n\t\t\t\t\t.getModulus(), ((RSAPrivateCrtKey) priv)\n\t\t\t\t\t.getPublicExponent());\n\n\t\t\tpub = kf.generatePublic(pubKeySpec);\n\t\t} catch (ClassCastException e) {\n\t\t\ttry {\n\t\t\t\tkf = KeyFactory.getInstance(PubkeyDatabase.KEY_TYPE_DSA);\n\t\t\t\tpriv = kf.generatePrivate(privKeySpec);\n\n\t\t\t\tDSAParams params = ((DSAPrivateKey) priv).getParams();\n\n\t\t\t\t// Calculate public key Y\n\t\t\t\tBigInteger y = params.getG().modPow(((DSAPrivateKey) priv).getX(),\n\t\t\t\t\t\tparams.getP());\n\n\t\t\t\tpubKeySpec = new DSAPublicKeySpec(y, params.getP(), params.getQ(),\n\t\t\t\t\t\tparams.getG());\n\n\t\t\t\tpub = kf.generatePublic(pubKeySpec);\n\t\t\t} catch (ClassCastException e2) {\n\t\t\t\tkf = KeyFactory.getInstance(PubkeyDatabase.KEY_TYPE_EC);\n\t\t\t\tpriv = kf.generatePrivate(privKeySpec);\n\n\t\t\t\tECParameterSpec params = ((ECPrivateKey) priv).getParams();\n\n\t\t\t\t// Calculate public key Y\n\t\t\t\tECPoint generator = params.getGenerator();\n\t\t\t\tBigInteger[] wCoords = EcCore.multiplyPoint(new BigInteger[] {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgenerator.getAffineX(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgenerator.getAffineY() },\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t((ECPrivateKey) priv).getS(), params);\n\t\t\t\tECPoint w = new ECPoint(wCoords[0], wCoords[1]);\n\n\t\t\t\tpubKeySpec = new ECPublicKeySpec(w, params);\n\n\t\t\t\tpub = kf.generatePublic(pubKeySpec);\n\t\t\t}\n\t\t}\n\n\t\treturn new KeyPair(pub, priv);\n\t}\n\n\t/*\n\t * OpenSSH compatibility methods\n\t */\n\n\tpublic static String convertToOpenSSHFormat(PublicKey pk, String origNickname) throws IOException, InvalidKeyException {\n\t\tString nickname = origNickname;\n\t\tif (nickname == null)\n\t\t\tnickname = \"connectbot@android\";\n\n\t\tif (pk instanceof RSAPublicKey) {\n\t\t\tString data = \"ssh-rsa \";\n\t\t\tdata += String.valueOf(Base64.encode(RSASHA1Verify.encodeSSHRSAPublicKey((RSAPublicKey) pk)));\n\t\t\treturn data + \" \" + nickname;\n\t\t} else if (pk instanceof DSAPublicKey) {\n\t\t\tString data = \"ssh-dss \";\n\t\t\tdata += String.valueOf(Base64.encode(DSASHA1Verify.encodeSSHDSAPublicKey((DSAPublicKey) pk)));\n\t\t\treturn data + \" \" + nickname;\n\t\t} else if (pk instanceof ECPublicKey) {\n\t\t\tECPublicKey ecPub = (ECPublicKey) pk;\n\t\t\tString keyType = ECDSASHA2Verify.getCurveName(ecPub.getParams().getCurve().getField().getFieldSize());\n\t\t\tString keyData = String.valueOf(Base64.encode(ECDSASHA2Verify.encodeSSHECDSAPublicKey(ecPub)));\n\t\t\treturn ECDSASHA2Verify.ECDSA_SHA2_PREFIX + keyType + \" \" + keyData + \" \" + nickname;\n\t\t}\n\n\t\tthrow new InvalidKeyException(\"Unknown key type\");\n\t}\n\n\t/*\n\t * OpenSSH compatibility methods\n\t */\n\n\t/**\n\t * @param trileadKey\n\t * @return OpenSSH-encoded pubkey\n\t */\n\tpublic static byte[] extractOpenSSHPublic(KeyPair pair) {\n\t\ttry {\n\t\t\tPublicKey pubKey = pair.getPublic();\n\t\t\tif (pubKey instanceof RSAPublicKey) {\n\t\t\t\treturn RSASHA1Verify.encodeSSHRSAPublicKey((RSAPublicKey) pair.getPublic());\n\t\t\t} else if (pubKey instanceof DSAPublicKey) {\n\t\t\t\treturn DSASHA1Verify.encodeSSHDSAPublicKey((DSAPublicKey) pair.getPublic());\n\t\t\t} else if (pubKey instanceof ECPublicKey) {\n\t\t\t\treturn ECDSASHA2Verify.encodeSSHECDSAPublicKey((ECPublicKey) pair.getPublic());\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic static String exportPEM(PrivateKey key, String secret) throws NoSuchAlgorithmException, InvalidParameterSpecException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, InvalidKeySpecException, IllegalBlockSizeException, IOException {\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tbyte[] data = key.getEncoded();\n\n\t\tsb.append(PKCS8_START);\n\t\tsb.append('\\n');\n\n\t\tif (secret != null) {\n\t\t\tbyte[] salt = new byte[8];\n\t\t\tSecureRandom random = new SecureRandom();\n\t\t\trandom.nextBytes(salt);\n\n\t\t\tPBEParameterSpec defParams = new PBEParameterSpec(salt, 1);\n\t\t\tAlgorithmParameters params = AlgorithmParameters.getInstance(key.getAlgorithm());\n\n\t\t\tparams.init(defParams);\n\n\t\t\tPBEKeySpec pbeSpec = new PBEKeySpec(secret.toCharArray());\n\n\t\t\tSecretKeyFactory keyFact = SecretKeyFactory.getInstance(key.getAlgorithm());\n\t\t\tCipher cipher = Cipher.getInstance(key.getAlgorithm());\n\t\t\tcipher.init(Cipher.WRAP_MODE, keyFact.generateSecret(pbeSpec), params);\n\n\t\t\tbyte[] wrappedKey = cipher.wrap(key);\n\n\t\t\tEncryptedPrivateKeyInfo pinfo = new EncryptedPrivateKeyInfo(params, wrappedKey);\n\n\t\t\tdata = pinfo.getEncoded();\n\n\t\t\tsb.append(\"Proc-Type: 4,ENCRYPTED\\n\");\n\t\t\tsb.append(\"DEK-Info: DES-EDE3-CBC,\");\n\t\t\tsb.append(encodeHex(salt));\n\t\t\tsb.append(\"\\n\\n\");\n\t\t}\n\n\t\tint i = sb.length();\n\t\tsb.append(Base64.encode(data));\n\t\tfor (i += 63; i < sb.length(); i += 64) {\n\t\t\tsb.insert(i, \"\\n\");\n\t\t}\n\n\t\tsb.append('\\n');\n\t\tsb.append(PKCS8_END);\n\t\tsb.append('\\n');\n\n\t\treturn sb.toString();\n\t}\n\n\tprivate static final char[] HEX_DIGITS = { '0', '1', '2', '3', '4', '5', '6',\n\t\t\t'7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n\tprotected static String encodeHex(byte[] bytes) {\n\t\tfinal char[] hex = new char[bytes.length * 2];\n\n\t\tint i = 0;\n\t\tfor (byte b : bytes) {\n\t\t\thex[i++] = HEX_DIGITS[(b >> 4) & 0x0f];\n\t\t\thex[i++] = HEX_DIGITS[b & 0x0f];\n\t\t}\n\n\t\treturn String.valueOf(hex);\n\t}\n}\n","Method after Refactoring":"/*\n * ConnectBot: simple, powerful, open-source SSH client for Android\n * Copyright 2007 Kenny Root, Jeffrey Sharkey\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *\t http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.connectbot.util;\n\nimport java.io.IOException;\nimport java.math.BigInteger;\nimport java.security.AlgorithmParameters;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.Key;\nimport java.security.KeyFactory;\nimport java.security.KeyPair;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.SecureRandom;\nimport java.security.interfaces.DSAParams;\nimport java.security.interfaces.DSAPrivateKey;\nimport java.security.interfaces.DSAPublicKey;\nimport java.security.interfaces.ECPrivateKey;\nimport java.security.interfaces.ECPublicKey;\nimport java.security.interfaces.RSAPrivateCrtKey;\nimport java.security.interfaces.RSAPublicKey;\nimport java.security.spec.DSAPublicKeySpec;\nimport java.security.spec.ECParameterSpec;\nimport java.security.spec.ECPoint;\nimport java.security.spec.ECPublicKeySpec;\nimport java.security.spec.InvalidKeySpecException;\nimport java.security.spec.InvalidParameterSpecException;\nimport java.security.spec.KeySpec;\nimport java.security.spec.PKCS8EncodedKeySpec;\nimport java.security.spec.RSAPublicKeySpec;\nimport java.security.spec.X509EncodedKeySpec;\nimport java.util.Arrays;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.EncryptedPrivateKeyInfo;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.PBEKeySpec;\nimport javax.crypto.spec.PBEParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport org.keyczar.jce.EcCore;\n\nimport android.util.Log;\n\nimport com.trilead.ssh2.crypto.Base64;\nimport com.trilead.ssh2.crypto.SimpleDERReader;\nimport com.trilead.ssh2.signature.DSASHA1Verify;\nimport com.trilead.ssh2.signature.ECDSASHA2Verify;\nimport com.trilead.ssh2.signature.RSASHA1Verify;\n\npublic class PubkeyUtils {\n\tprivate static final String TAG = \"PubkeyUtils\";\n\n\tpublic static final String PKCS8_START = \"-----BEGIN PRIVATE KEY-----\";\n\tpublic static final String PKCS8_END = \"-----END PRIVATE KEY-----\";\n\n\t// Size in bytes of salt to use.\n\tprivate static final int SALT_SIZE = 8;\n\n\t// Number of iterations for password hashing. PKCS#5 recommends 1000\n\tprivate static final int ITERATIONS = 1000;\n\n\tpublic static String formatKey(Key key){\n\t\tString algo = key.getAlgorithm();\n\t\tString fmt = key.getFormat();\n\t\tbyte[] encoded = key.getEncoded();\n\t\treturn \"Key[algorithm=\" + algo + \", format=\" + fmt +\n\t\t\t\", bytes=\" + encoded.length + \"]\";\n\t}\n\n\tpublic static byte[] sha256(byte[] data) throws NoSuchAlgorithmException {\n\t\treturn MessageDigest.getInstance(\"SHA-256\").digest(data);\n\t}\n\n\tpublic static byte[] cipher(int mode, byte[] data, byte[] secret) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException {\n\t\tSecretKeySpec secretKeySpec = new SecretKeySpec(sha256(secret), \"AES\");\n\t\tCipher c = Cipher.getInstance(\"AES\");\n\t\tc.init(mode, secretKeySpec);\n\t\treturn c.doFinal(data);\n\t}\n\n\tpublic static byte[] encrypt(byte[] cleartext, String secret) throws Exception {\n\t\tbyte[] salt = new byte[SALT_SIZE];\n\n\t\tbyte[] ciphertext = Encryptor.encrypt(salt, ITERATIONS, secret, cleartext);\n\n\t\tbyte[] complete = new byte[salt.length + ciphertext.length];\n\n\t\tSystem.arraycopy(salt, 0, complete, 0, salt.length);\n\t\tSystem.arraycopy(ciphertext, 0, complete, salt.length, ciphertext.length);\n\n\t\tArrays.fill(salt, (byte) 0x00);\n\t\tArrays.fill(ciphertext, (byte) 0x00);\n\n\t\treturn complete;\n\t}\n\n\tpublic static byte[] decrypt(byte[] complete, String secret) throws Exception {\n\t\ttry {\n\t\t\tbyte[] salt = new byte[SALT_SIZE];\n\t\t\tbyte[] ciphertext = new byte[complete.length - salt.length];\n\n\t\t\tSystem.arraycopy(complete, 0, salt, 0, salt.length);\n\t\t\tSystem.arraycopy(complete, salt.length, ciphertext, 0, ciphertext.length);\n\n\t\t\treturn Encryptor.decrypt(salt, ITERATIONS, secret, ciphertext);\n\t\t} catch (Exception e) {\n\t\t\tLog.d(\"decrypt\", \"Could not decrypt with new method\", e);\n\t\t\t// We might be using the old encryption method.\n\t\t\treturn cipher(Cipher.DECRYPT_MODE, complete, secret.getBytes());\n\t\t}\n\t}\n\n\tpublic static byte[] getEncodedPublic(PublicKey pk) {\n\t\treturn new X509EncodedKeySpec(pk.getEncoded()).getEncoded();\n\t}\n\n\tpublic static byte[] getEncodedPrivate(PrivateKey pk) {\n\t\treturn new PKCS8EncodedKeySpec(pk.getEncoded()).getEncoded();\n\t}\n\n\tpublic static byte[] getEncodedPrivate(PrivateKey pk, String secret) throws Exception {\n\t\tif (secret.length() > 0)\n\t\t\treturn encrypt(getEncodedPrivate(pk), secret);\n\t\telse\n\t\t\treturn getEncodedPrivate(pk);\n\t}\n\n\tpublic static PrivateKey decodePrivate(byte[] encoded, String keyType) throws NoSuchAlgorithmException, InvalidKeySpecException {\n\t\tPKCS8EncodedKeySpec privKeySpec = new PKCS8EncodedKeySpec(encoded);\n\t\tKeyFactory kf = KeyFactory.getInstance(keyType);\n\t\treturn kf.generatePrivate(privKeySpec);\n\t}\n\n\tpublic static PrivateKey decodePrivate(byte[] encoded, String keyType, String secret) throws Exception {\n\t\tif (secret != null && secret.length() > 0)\n\t\t\treturn decodePrivate(decrypt(encoded, secret), keyType);\n\t\telse\n\t\t\treturn decodePrivate(encoded, keyType);\n\t}\n\n\tpublic static PublicKey decodePublic(byte[] encoded, String keyType) throws NoSuchAlgorithmException, InvalidKeySpecException {\n\t\tX509EncodedKeySpec pubKeySpec = new X509EncodedKeySpec(encoded);\n\t\tKeyFactory kf = KeyFactory.getInstance(keyType);\n\t\treturn kf.generatePublic(pubKeySpec);\n\t}\n\n\tpublic static KeyPair recoverKeyPair(byte[] encoded) throws NoSuchAlgorithmException, InvalidKeySpecException {\n\t\tKeySpec privKeySpec = new PKCS8EncodedKeySpec(encoded);\n\t\tKeySpec pubKeySpec;\n\n\t\tPrivateKey priv;\n\t\tPublicKey pub;\n\t\tKeyFactory kf;\n\n\t\tfinal String oid;\n\t\ttry {\n\t\t\tSimpleDERReader reader = new SimpleDERReader(encoded);\n\t\t\treader.resetInput(reader.readSequenceAsByteArray());\n\t\t\treader.readInt();\n\t\t\treader.resetInput(reader.readSequenceAsByteArray());\n\t\t\toid = reader.readOid();\n\n\t\t\tkf = KeyFactory.getInstance(oid);\n\t\t\tpriv = kf.generatePrivate(privKeySpec);\n\t\t} catch (IOException e) {\n\t\t\tLog.w(TAG, \"Could not read OID\", e);\n\t\t\tthrow new InvalidKeySpecException(\"Could not read key\", e);\n\t\t}\n\n\t\tif (priv instanceof RSAPrivateCrtKey) {\n\t\t\tRSAPrivateCrtKey rsaPriv = (RSAPrivateCrtKey) priv;\n\t\t\tpubKeySpec = new RSAPublicKeySpec(rsaPriv.getModulus(), rsaPriv.getPublicExponent());\n\n\t\t\tpub = kf.generatePublic(pubKeySpec);\n\t\t} else if (priv instanceof DSAPrivateKey) {\n\t\t\tDSAPrivateKey dsaPriv = (DSAPrivateKey) priv;\n\t\t\tDSAParams params = dsaPriv.getParams();\n\n\t\t\t// Calculate public key Y\n\t\t\tBigInteger y = params.getG().modPow(dsaPriv.getX(), params.getP());\n\n\t\t\tpubKeySpec = new DSAPublicKeySpec(y, params.getP(), params.getQ(), params.getG());\n\n\t\t\tpub = kf.generatePublic(pubKeySpec);\n\t\t} else if (priv instanceof ECPrivateKey) {\n\t\t\tECPrivateKey ecPriv = (ECPrivateKey) priv;\n\t\t\tECParameterSpec params = ecPriv.getParams();\n\n\t\t\t// Calculate public key Y\n\t\t\tECPoint generator = params.getGenerator();\n\t\t\tBigInteger[] wCoords = EcCore.multiplyPoint(new BigInteger[] {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgenerator.getAffineX(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgenerator.getAffineY() },\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tecPriv.getS(), params);\n\t\t\tECPoint w = new ECPoint(wCoords[0], wCoords[1]);\n\n\t\t\tpubKeySpec = new ECPublicKeySpec(w, params);\n\n\t\t\tpub = kf.generatePublic(pubKeySpec);\n\t\t} else {\n\t\t\tthrow new NoSuchAlgorithmException(\"Unknown OID: \" + oid);\n\t\t}\n\n\t\treturn new KeyPair(pub, priv);\n\t}\n\n\t/*\n\t * OpenSSH compatibility methods\n\t */\n\n\tpublic static String convertToOpenSSHFormat(PublicKey pk, String origNickname) throws IOException, InvalidKeyException {\n\t\tString nickname = origNickname;\n\t\tif (nickname == null)\n\t\t\tnickname = \"connectbot@android\";\n\n\t\tif (pk instanceof RSAPublicKey) {\n\t\t\tString data = \"ssh-rsa \";\n\t\t\tdata += String.valueOf(Base64.encode(RSASHA1Verify.encodeSSHRSAPublicKey((RSAPublicKey) pk)));\n\t\t\treturn data + \" \" + nickname;\n\t\t} else if (pk instanceof DSAPublicKey) {\n\t\t\tString data = \"ssh-dss \";\n\t\t\tdata += String.valueOf(Base64.encode(DSASHA1Verify.encodeSSHDSAPublicKey((DSAPublicKey) pk)));\n\t\t\treturn data + \" \" + nickname;\n\t\t} else if (pk instanceof ECPublicKey) {\n\t\t\tECPublicKey ecPub = (ECPublicKey) pk;\n\t\t\tString keyType = ECDSASHA2Verify.getCurveName(ecPub.getParams().getCurve().getField().getFieldSize());\n\t\t\tString keyData = String.valueOf(Base64.encode(ECDSASHA2Verify.encodeSSHECDSAPublicKey(ecPub)));\n\t\t\treturn ECDSASHA2Verify.ECDSA_SHA2_PREFIX + keyType + \" \" + keyData + \" \" + nickname;\n\t\t}\n\n\t\tthrow new InvalidKeyException(\"Unknown key type\");\n\t}\n\n\t/*\n\t * OpenSSH compatibility methods\n\t */\n\n\t/**\n\t * @param trileadKey\n\t * @return OpenSSH-encoded pubkey\n\t */\n\tpublic static byte[] extractOpenSSHPublic(KeyPair pair) {\n\t\ttry {\n\t\t\tPublicKey pubKey = pair.getPublic();\n\t\t\tif (pubKey instanceof RSAPublicKey) {\n\t\t\t\treturn RSASHA1Verify.encodeSSHRSAPublicKey((RSAPublicKey) pair.getPublic());\n\t\t\t} else if (pubKey instanceof DSAPublicKey) {\n\t\t\t\treturn DSASHA1Verify.encodeSSHDSAPublicKey((DSAPublicKey) pair.getPublic());\n\t\t\t} else if (pubKey instanceof ECPublicKey) {\n\t\t\t\treturn ECDSASHA2Verify.encodeSSHECDSAPublicKey((ECPublicKey) pair.getPublic());\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic static String exportPEM(PrivateKey key, String secret) throws NoSuchAlgorithmException, InvalidParameterSpecException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, InvalidKeySpecException, IllegalBlockSizeException, IOException {\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tbyte[] data = key.getEncoded();\n\n\t\tsb.append(PKCS8_START);\n\t\tsb.append('\\n');\n\n\t\tif (secret != null) {\n\t\t\tbyte[] salt = new byte[8];\n\t\t\tSecureRandom random = new SecureRandom();\n\t\t\trandom.nextBytes(salt);\n\n\t\t\tPBEParameterSpec defParams = new PBEParameterSpec(salt, 1);\n\t\t\tAlgorithmParameters params = AlgorithmParameters.getInstance(key.getAlgorithm());\n\n\t\t\tparams.init(defParams);\n\n\t\t\tPBEKeySpec pbeSpec = new PBEKeySpec(secret.toCharArray());\n\n\t\t\tSecretKeyFactory keyFact = SecretKeyFactory.getInstance(key.getAlgorithm());\n\t\t\tCipher cipher = Cipher.getInstance(key.getAlgorithm());\n\t\t\tcipher.init(Cipher.WRAP_MODE, keyFact.generateSecret(pbeSpec), params);\n\n\t\t\tbyte[] wrappedKey = cipher.wrap(key);\n\n\t\t\tEncryptedPrivateKeyInfo pinfo = new EncryptedPrivateKeyInfo(params, wrappedKey);\n\n\t\t\tdata = pinfo.getEncoded();\n\n\t\t\tsb.append(\"Proc-Type: 4,ENCRYPTED\\n\");\n\t\t\tsb.append(\"DEK-Info: DES-EDE3-CBC,\");\n\t\t\tsb.append(encodeHex(salt));\n\t\t\tsb.append(\"\\n\\n\");\n\t\t}\n\n\t\tint i = sb.length();\n\t\tsb.append(Base64.encode(data));\n\t\tfor (i += 63; i < sb.length(); i += 64) {\n\t\t\tsb.insert(i, \"\\n\");\n\t\t}\n\n\t\tsb.append('\\n');\n\t\tsb.append(PKCS8_END);\n\t\tsb.append('\\n');\n\n\t\treturn sb.toString();\n\t}\n\n\tprivate static final char[] HEX_DIGITS = { '0', '1', '2', '3', '4', '5', '6',\n\t\t\t'7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n\tprotected static String encodeHex(byte[] bytes) {\n\t\tfinal char[] hex = new char[bytes.length * 2];\n\n\t\tint i = 0;\n\t\tfor (byte b : bytes) {\n\t\t\thex[i++] = HEX_DIGITS[(b >> 4) & 0x0f];\n\t\t\thex[i++] = HEX_DIGITS[b & 0x0f];\n\t\t}\n\n\t\treturn String.valueOf(hex);\n\t}\n}\n","lineNo":208}
{"Smelly Sample":"/**\n *\n */\npackage com.trilead.ssh2.signature;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.math.BigInteger;\nimport java.security.InvalidKeyException;\nimport java.security.KeyFactory;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.Signature;\nimport java.security.SignatureException;\nimport java.security.interfaces.ECPrivateKey;\nimport java.security.interfaces.ECPublicKey;\nimport java.security.spec.ECFieldFp;\nimport java.security.spec.ECParameterSpec;\nimport java.security.spec.ECPoint;\nimport java.security.spec.ECPublicKeySpec;\nimport java.security.spec.EllipticCurve;\nimport java.security.spec.InvalidKeySpecException;\nimport java.security.spec.KeySpec;\nimport java.util.Map;\nimport java.util.TreeMap;\n\nimport com.trilead.ssh2.log.Logger;\nimport com.trilead.ssh2.packets.TypesReader;\nimport com.trilead.ssh2.packets.TypesWriter;\n\n/**\n * @author Kenny Root\n *\n */\npublic class ECDSASHA2Verify {\n\tprivate static final Logger log = Logger.getLogger(ECDSASHA2Verify.class);\n\n\tpublic static final String ECDSA_SHA2_PREFIX = \"ecdsa-sha2-\";\n\n\tprivate static final String NISTP256 = \"nistp256\";\n\tprivate static final String NISTP384 = \"nistp384\";\n\tprivate static final String NISTP521 = \"nistp521\";\n\n\tprivate static final Map<String, ECParameterSpec> CURVES = new TreeMap<String, ECParameterSpec>();\n\tstatic {\n\t\tCURVES.put(NISTP256, EllipticCurves.nistp256);\n\t\tCURVES.put(NISTP384, EllipticCurves.nistp384);\n\t\tCURVES.put(NISTP521, EllipticCurves.nistp521);\n\t}\n\n\tprivate static final Map<Integer, String> CURVE_SIZES = new TreeMap<Integer, String>();\n\tstatic {\n\t\tCURVE_SIZES.put(256, NISTP256);\n\t\tCURVE_SIZES.put(384, NISTP384);\n\t\tCURVE_SIZES.put(521, NISTP521);\n\t}\n\n\tpublic static ECPublicKey decodeSSHECDSAPublicKey(byte[] key) throws IOException\n\t{\n\t\tTypesReader tr = new TypesReader(key);\n\n\t\tString key_format = tr.readString();\n\n\t\tif (key_format.startsWith(ECDSA_SHA2_PREFIX) == false)\n\t\t\tthrow new IllegalArgumentException(\"This is not an ECDSA public key\");\n\n\t\tString curveName = tr.readString();\n\t\tbyte[] groupBytes = tr.readByteString();\n\n\t\tif (tr.remain() != 0)\n\t\t\tthrow new IOException(\"Padding in ECDSA public key!\");\n\n\t\tif (key_format.equals(ECDSA_SHA2_PREFIX + curveName) == false) {\n\t\t\tthrow new IOException(\"Key format is inconsistent with curve name: \" + key_format\n\t\t\t\t\t+ \" != \" + curveName);\n\t\t}\n\n\t\tECParameterSpec params = CURVES.get(curveName);\n\t\tif (params == null) {\n\t\t\tthrow new IOException(\"Curve is not supported: \" + curveName);\n\t\t}\n\n\t\tECPoint group = ECDSASHA2Verify.decodeECPoint(groupBytes, params.getCurve());\n\t\tif (group == null) {\n\t\t\tthrow new IOException(\"Invalid ECDSA group\");\n\t\t}\n\n\t\tKeySpec keySpec = new ECPublicKeySpec(group, params);\n\n\t\ttry {\n\t\t\tKeyFactory kf = KeyFactory.getInstance(\"EC\");\n\t\t\treturn (ECPublicKey) kf.generatePublic(keySpec);\n\t\t} catch (NoSuchAlgorithmException nsae) {\n\t\t\tIOException ioe = new IOException(\"No RSA KeyFactory available\");\n\t\t\tioe.initCause(nsae);\n\t\t\tthrow ioe;\n\t\t} catch (InvalidKeySpecException ikse) {\n\t\t\tIOException ioe = new IOException(\"No RSA KeyFactory available\");\n\t\t\tioe.initCause(ikse);\n\t\t\tthrow ioe;\n\t\t}\n\t}\n\n\tpublic static byte[] encodeSSHECDSAPublicKey(ECPublicKey key) throws IOException {\n\t\tTypesWriter tw = new TypesWriter();\n\n\t\tString curveName = getCurveName(key.getParams());\n\n\t\tString keyFormat = ECDSA_SHA2_PREFIX + curveName;\n\n\t\ttw.writeString(keyFormat);\n\n\t\ttw.writeString(curveName);\n\n\t\ttw.writeBytes(encodeECPoint(key.getW(), key.getParams().getCurve()));\n\n\t\treturn tw.getBytes();\n\t}\n\n\tprivate static String getCurveName(ECParameterSpec params) throws IOException {\n\t\tint fieldSize = getCurveSize(params);\n\t\tString curveName = CURVE_SIZES.get(fieldSize);\n\t\tif (curveName == null) {\n\t\t\tthrow new IOException(\"Unsupported curve field size: \" + fieldSize);\n\t\t}\n\t\treturn curveName;\n\t}\n\n\tprivate static int getCurveSize(ECParameterSpec params) {\n\t\treturn params.getCurve().getField().getFieldSize();\n\t}\n\n\tpublic static byte[] decodeSSHECDSASignature(byte[] sig) throws IOException {\n\t\tbyte[] rsArray = null;\n\n\t\tTypesReader tr = new TypesReader(sig);\n\n\t\tString sig_format = tr.readString();\n\t\tif (sig_format.startsWith(ECDSA_SHA2_PREFIX) == false)\n\t\t\tthrow new IOException(\"Peer sent wrong signature format\");\n\n\t\tString curveName = sig_format.substring(ECDSA_SHA2_PREFIX.length());\n\t\tif (CURVES.containsKey(curveName) == false) {\n\t\t\tthrow new IOException(\"Unsupported curve: \" + curveName);\n\t\t}\n\n\t\trsArray = tr.readByteString();\n\n\t\tif (tr.remain() != 0)\n\t\t\tthrow new IOException(\"Padding in ECDSA signature!\");\n\n\t\tbyte[] rArray;\n\t\tbyte[] sArray;\n\t\t{\n\t\t\tTypesReader rsReader = new TypesReader(rsArray);\n\t\t\trArray = rsReader.readMPINT().toByteArray();\n\t\t\tsArray = rsReader.readMPINT().toByteArray();\n\t\t}\n\n\t\tint first = rArray.length;\n\t\tint second = sArray.length;\n\n\t\t/* We can't have the high bit set, so add an extra zero at the beginning if so. */\n\t\tif ((rArray[0] & 0x80) != 0) {\n\t\t\tfirst++;\n\t\t}\n\t\tif ((sArray[0] & 0x80) != 0) {\n\t\t\tsecond++;\n\t\t}\n\n\t\t/* Calculate total output length */\n\t\tByteArrayOutputStream os = new ByteArrayOutputStream(6 + first + second);\n\n\t\t/* ASN.1 SEQUENCE tag */\n\t\tos.write(0x30);\n\n\t\t/* Size of SEQUENCE */\n\t\twriteLength(4 + first + second, os);\n\n\t\t/* ASN.1 INTEGER tag */\n\t\tos.write(0x02);\n\n\t\t/* \"r\" INTEGER length */\n\t\twriteLength(first, os);\n\n\t\t/* Copy in the \"r\" INTEGER */\n\t\tif (first != rArray.length) {\n\t\t\tos.write(0x00);\n\t\t}\n\t\tos.write(rArray);\n\n\t\t/* ASN.1 INTEGER tag */\n\t\tos.write(0x02);\n\n\t\t/* \"s\" INTEGER length */\n\t\twriteLength(second, os);\n\n\t\t/* Copy in the \"s\" INTEGER */\n\t\tif (second != sArray.length) {\n\t\t\tos.write(0x00);\n\t\t}\n\t\tos.write(sArray);\n\n\t\treturn os.toByteArray();\n\t}\n\n\tprivate static final void writeLength(int length, OutputStream os) throws IOException {\n\t\tif (length <= 0x7F) {\n\t\t\tos.write(length);\n\t\t\treturn;\n\t\t}\n\n\t\tint numOctets = 0;\n\t\tint lenCopy = length;\n\t\twhile (lenCopy != 0) {\n\t\t\tlenCopy >>>= 8;\n\t\t\tnumOctets++;\n\t\t}\n\n\t\tos.write(0x80 | numOctets);\n\n\t\tfor (int i = (numOctets - 1) * 8; i >= 0; i -= 8) {\n\t\t\tos.write((byte) (length >> i));\n\t\t}\n\t}\n\n\tpublic static byte[] encodeSSHECDSASignature(byte[] sig, ECParameterSpec params) throws IOException\n\t{\n\t\tTypesWriter tw = new TypesWriter();\n\n\t\tString curveName = getCurveName(params);\n\t\ttw.writeString(ECDSA_SHA2_PREFIX + curveName);\n\n\t\tif ((sig[0] != 0x30) || (sig[1] != sig.length - 2) || (sig[2] != 0x02)) {\n\t\t\tthrow new IOException(\"Invalid signature format\");\n\t\t}\n\n\t\tint rLength = sig[3];\n\t\tif ((rLength + 6 > sig.length) || (sig[4 + rLength] != 0x02)) {\n\t\t\tthrow new IOException(\"Invalid signature format\");\n\t\t}\n\n\t\tint sLength = sig[5 + rLength];\n\t\tif (6 + rLength + sLength > sig.length) {\n\t\t\tthrow new IOException(\"Invalid signature format\");\n\t\t}\n\n\t\tbyte[] rArray = new byte[rLength];\n\t\tbyte[] sArray = new byte[sLength];\n\n\t\tSystem.arraycopy(sig, 4, rArray, 0, rLength);\n\t\tSystem.arraycopy(sig, 6 + rLength, sArray, 0, sLength);\n\n\t\tBigInteger r = new BigInteger(rArray);\n\t\tBigInteger s = new BigInteger(sArray);\n\n\t\t// Write the <r,s> to its own types writer.\n\t\tTypesWriter rsWriter = new TypesWriter();\n\t\trsWriter.writeMPInt(r);\n\t\trsWriter.writeMPInt(s);\n\t\ttw.writeBytes(rsWriter.getBytes());\n\n\t\treturn tw.getBytes();\n\t}\n\n\tpublic static byte[] generateSignature(byte[] message, ECPrivateKey pk) throws IOException\n\t{\n\t\tfinal String algo = getSignatureAlgorithmForParams(pk.getParams());\n\n\t\ttry {\n\t\t\tSignature s = Signature.getInstance(algo);\n\t\t\ts.initSign(pk);\n\t\t\ts.update(message);\n\t\t\treturn s.sign();\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\tIOException ex = new IOException();\n\t\t\tex.initCause(e);\n\t\t\tthrow ex;\n\t\t} catch (InvalidKeyException e) {\n\t\t\tIOException ex = new IOException();\n\t\t\tex.initCause(e);\n\t\t\tthrow ex;\n\t\t} catch (SignatureException e) {\n\t\t\tIOException ex = new IOException();\n\t\t\tex.initCause(e);\n\t\t\tthrow ex;\n\t\t}\n\t}\n\n\tpublic static boolean verifySignature(byte[] message, byte[] ds, ECPublicKey dpk) throws IOException\n\t{\n\t\tfinal String algo = getSignatureAlgorithmForParams(dpk.getParams());\n\n\t\ttry {\n\t\t\tSignature s = Signature.getInstance(algo);\n\t\t\ts.initVerify(dpk);\n\t\t\ts.update(message);\n\t\t\treturn s.verify(ds);\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\tIOException ex = new IOException(\"No such algorithm\");\n\t\t\tex.initCause(e);\n\t\t\tthrow ex;\n\t\t} catch (InvalidKeyException e) {\n\t\t\tIOException ex = new IOException(\"No such algorithm\");\n\t\t\tex.initCause(e);\n\t\t\tthrow ex;\n\t\t} catch (SignatureException e) {\n\t\t\tIOException ex = new IOException();\n\t\t\tex.initCause(e);\n\t\t\tthrow ex;\n\t\t}\n\t}\n\n\tprivate static String getSignatureAlgorithmForParams(ECParameterSpec params) {\n\t\tint size = getCurveSize(params);\n\t\tif (size <= 256) {\n\t\t\treturn \"SHA256withECDSA\";\n\t\t} else if (size <= 384) {\n\t\t\treturn \"SHA384withECDSA\";\n\t\t} else {\n\t\t\treturn \"SHA512withECDSA\";\n\t\t}\n\t}\n\n\tpublic static String getDigestAlgorithmForParams(ECParameterSpec params) {\n\t\tint size = getCurveSize(params);\n\t\tif (size <= 256) {\n\t\t\treturn \"SHA256\";\n\t\t} else if (size <= 384) {\n\t\t\treturn \"SHA384\";\n\t\t} else {\n\t\t\treturn \"SHA512\";\n\t\t}\n\t}\n\n\t/**\n\t * Decode an OctetString to EllipticCurvePoint according to SECG 2.3.4\n\t */\n\tpublic static ECPoint decodeECPoint(byte[] M, EllipticCurve curve) {\n\t\tif (M.length == 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// M has len 2 ceil(log_2(q)/8) + 1 ?\n\t\tint elementSize = (curve.getField().getFieldSize() + 7) / 8;\n\t\tif (M.length != 2 * elementSize + 1) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// step 3.2\n\t\tif (M[0] != 0x04) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Step 3.3\n\t\tbyte[] xp = new byte[elementSize];\n\t\tSystem.arraycopy(M, 1, xp, 0, elementSize);\n\n\t\t// Step 3.4\n\t\tbyte[] yp = new byte[elementSize];\n\t\tSystem.arraycopy(M, 1 + elementSize, yp, 0, elementSize);\n\n\t\tECPoint P = new ECPoint(new BigInteger(1, xp), new BigInteger(1, yp));\n\n\t\t// TODO check point 3.5\n\n\t\t// Step 3.6\n\t\treturn P;\n\t}\n\n\t/**\n\t * Encode EllipticCurvePoint to an OctetString\n\t */\n\tpublic static byte[] encodeECPoint(ECPoint group, EllipticCurve curve)\n\t{\n\t\t// M has len 2 ceil(log_2(q)/8) + 1 ?\n\t\tint elementSize = (curve.getField().getFieldSize() + 7) / 8;\n\t\tbyte[] M = new byte[2 * elementSize + 1];\n\n\t\t// Uncompressed format\n\t\tM[0] = 0x04;\n\n\t\t{\n\t\t\tbyte[] affineX = removeLeadingZeroes(group.getAffineX().toByteArray());\n\t\t\tSystem.arraycopy(affineX, 0, M, 1 + elementSize - affineX.length, affineX.length);\n\t\t}\n\n\t\t{\n\t\t\tbyte[] affineY = removeLeadingZeroes(group.getAffineY().toByteArray());\n\t\t\tSystem.arraycopy(affineY, 0, M, 1 + elementSize + elementSize - affineY.length,\n\t\t\t\t\t\t\t affineY.length);\n\t\t}\n\n\t\treturn M;\n\t}\n\n\tprivate static byte[] removeLeadingZeroes(byte[] input) {\n\t\tif (input[0] != 0x00) {\n\t\t\treturn input;\n\t\t}\n\n\t\tint pos = 1;\n\t\twhile (pos < input.length - 1 && input[pos] == 0x00) {\n\t\t\tpos++;\n\t\t}\n\n\t\tbyte[] output = new byte[input.length - pos];\n\t\tSystem.arraycopy(input, pos, output, 0, output.length);\n\t\treturn output;\n\t}\n\n\tpublic static class EllipticCurves {\n\t\tpublic static ECParameterSpec nistp256 = new ECParameterSpec(\n\t\t\t\tnew EllipticCurve(\n\t\t\t\t\t\tnew ECFieldFp(new BigInteger(\"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\", 16)),\n\t\t\t\t\t\tnew BigInteger(\"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\", 16),\n\t\t\t\t\t\tnew BigInteger(\"5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b\", 16)),\n\t\t\t\tnew ECPoint(new BigInteger(\"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\", 16),\n\t\t\t\t\t\t\tnew BigInteger(\"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\", 16)),\n\t\t\t\tnew BigInteger(\"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551\", 16),\n\t\t\t\t1);\n\n\t\tpublic static ECParameterSpec nistp384 = new ECParameterSpec(\n\t\t\t\tnew EllipticCurve(\n\t\t\t\t\t\tnew ECFieldFp(new BigInteger(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\", 16)),\n\t\t\t\t\t\tnew BigInteger(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\", 16),\n\t\t\t\t\t\tnew BigInteger(\"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\", 16)),\n\t\t\t\tnew ECPoint(new BigInteger(\"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B9859F741E082542A385502F25DBF55296C3A545E3872760AB7\", 16),\n\t\t\t\t\t\t\tnew BigInteger(\"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A147CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\", 16)),\n\t\t\t\tnew BigInteger(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\", 16),\n\t\t\t\t1);\n\n\t\tpublic static ECParameterSpec nistp521 = new ECParameterSpec(\n\t\t\t\tnew EllipticCurve(\n\t\t\t\t\t\tnew ECFieldFp(new BigInteger(\"01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\", 16)),\n\t\t\t\t\t\tnew BigInteger(\"01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC\", 16),\n\t\t\t\t\t\tnew BigInteger(\"0051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573DF883D2C34F1EF451FD46B503F00\", 16)),\n\t\t\t\tnew ECPoint(new BigInteger(\"00C6858E06B70404E9CD9E3ECB662395B4429C648139053FB521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B3C1856A429BF97E7E31C2E5BD66\", 16),\n\t\t\t\t\t\t\tnew BigInteger(\"011839296A789A3BC0045C8A5FB42C7D1BD998F54449579B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C7086A272C24088BE94769FD16650\", 16)),\n\t\t\t\tnew BigInteger(\"01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5C9B8899C47AEBB6FB71E91386409\", 16),\n\t\t\t\t1);\n\t}\n}\n","Method after Refactoring":"/**\n *\n */\npackage com.trilead.ssh2.signature;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.math.BigInteger;\nimport java.security.InvalidKeyException;\nimport java.security.KeyFactory;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.Signature;\nimport java.security.SignatureException;\nimport java.security.interfaces.ECPrivateKey;\nimport java.security.interfaces.ECPublicKey;\nimport java.security.spec.ECFieldFp;\nimport java.security.spec.ECParameterSpec;\nimport java.security.spec.ECPoint;\nimport java.security.spec.ECPublicKeySpec;\nimport java.security.spec.EllipticCurve;\nimport java.security.spec.InvalidKeySpecException;\nimport java.security.spec.KeySpec;\nimport java.util.Map;\nimport java.util.TreeMap;\n\nimport com.trilead.ssh2.log.Logger;\nimport com.trilead.ssh2.packets.TypesReader;\nimport com.trilead.ssh2.packets.TypesWriter;\n\n/**\n * @author Kenny Root\n *\n */\npublic class ECDSASHA2Verify {\n\tprivate static final Logger log = Logger.getLogger(ECDSASHA2Verify.class);\n\n\tpublic static final String ECDSA_SHA2_PREFIX = \"ecdsa-sha2-\";\n\n\tprivate static final String NISTP256 = \"nistp256\";\n\tprivate static final String NISTP384 = \"nistp384\";\n\tprivate static final String NISTP521 = \"nistp521\";\n\n\tprivate static final Map<String, ECParameterSpec> CURVES = new TreeMap<String, ECParameterSpec>();\n\tstatic {\n\t\tCURVES.put(NISTP256, EllipticCurves.nistp256);\n\t\tCURVES.put(NISTP384, EllipticCurves.nistp384);\n\t\tCURVES.put(NISTP521, EllipticCurves.nistp521);\n\t}\n\n\tprivate static final Map<Integer, String> CURVE_SIZES = new TreeMap<Integer, String>();\n\tstatic {\n\t\tCURVE_SIZES.put(256, NISTP256);\n\t\tCURVE_SIZES.put(384, NISTP384);\n\t\tCURVE_SIZES.put(521, NISTP521);\n\t}\n\n\tpublic static int[] getCurveSizes() {\n\t\tint[] keys = new int[CURVE_SIZES.size()];\n\t\tint i = 0;\n\t\tfor (Integer n : CURVE_SIZES.keySet().toArray(new Integer[keys.length])) {\n\t\t\tkeys[i++] = n;\n\t\t}\n\t\treturn keys;\n\t}\n\n\tpublic static ECParameterSpec getCurveForSize(int size) {\n\t\tfinal String name = CURVE_SIZES.get(size);\n\t\tif (name == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn CURVES.get(name);\n\t}\n\n\tpublic static ECPublicKey decodeSSHECDSAPublicKey(byte[] key) throws IOException\n\t{\n\t\tTypesReader tr = new TypesReader(key);\n\n\t\tString key_format = tr.readString();\n\n\t\tif (key_format.startsWith(ECDSA_SHA2_PREFIX) == false)\n\t\t\tthrow new IllegalArgumentException(\"This is not an ECDSA public key\");\n\n\t\tString curveName = tr.readString();\n\t\tbyte[] groupBytes = tr.readByteString();\n\n\t\tif (tr.remain() != 0)\n\t\t\tthrow new IOException(\"Padding in ECDSA public key!\");\n\n\t\tif (key_format.equals(ECDSA_SHA2_PREFIX + curveName) == false) {\n\t\t\tthrow new IOException(\"Key format is inconsistent with curve name: \" + key_format\n\t\t\t\t\t+ \" != \" + curveName);\n\t\t}\n\n\t\tECParameterSpec params = CURVES.get(curveName);\n\t\tif (params == null) {\n\t\t\tthrow new IOException(\"Curve is not supported: \" + curveName);\n\t\t}\n\n\t\tECPoint group = ECDSASHA2Verify.decodeECPoint(groupBytes, params.getCurve());\n\t\tif (group == null) {\n\t\t\tthrow new IOException(\"Invalid ECDSA group\");\n\t\t}\n\n\t\tKeySpec keySpec = new ECPublicKeySpec(group, params);\n\n\t\ttry {\n\t\t\tKeyFactory kf = KeyFactory.getInstance(\"EC\");\n\t\t\treturn (ECPublicKey) kf.generatePublic(keySpec);\n\t\t} catch (NoSuchAlgorithmException nsae) {\n\t\t\tIOException ioe = new IOException(\"No RSA KeyFactory available\");\n\t\t\tioe.initCause(nsae);\n\t\t\tthrow ioe;\n\t\t} catch (InvalidKeySpecException ikse) {\n\t\t\tIOException ioe = new IOException(\"No RSA KeyFactory available\");\n\t\t\tioe.initCause(ikse);\n\t\t\tthrow ioe;\n\t\t}\n\t}\n\n\tpublic static byte[] encodeSSHECDSAPublicKey(ECPublicKey key) throws IOException {\n\t\tTypesWriter tw = new TypesWriter();\n\n\t\tString curveName = getCurveName(key.getParams());\n\n\t\tString keyFormat = ECDSA_SHA2_PREFIX + curveName;\n\n\t\ttw.writeString(keyFormat);\n\n\t\ttw.writeString(curveName);\n\n\t\tbyte[] encoded = encodeECPoint(key.getW(), key.getParams().getCurve());\n\t\ttw.writeString(encoded, 0, encoded.length);\n\n\t\treturn tw.getBytes();\n\t}\n\n\tpublic static String getCurveName(ECParameterSpec params) throws IOException {\n\t\tint fieldSize = getCurveSize(params);\n\t\tfinal String curveName = getCurveName(fieldSize);\n\t\tif (curveName == null) {\n\t\t\tthrow new IOException(\"invalid curve size \" + fieldSize);\n\t\t}\n\t\treturn curveName;\n\t}\n\n\tpublic static String getCurveName(int fieldSize) {\n\t\tString curveName = CURVE_SIZES.get(fieldSize);\n\t\tif (curveName == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn curveName;\n\t}\n\n\tpublic static int getCurveSize(ECParameterSpec params) {\n\t\treturn params.getCurve().getField().getFieldSize();\n\t}\n\n\tpublic static byte[] decodeSSHECDSASignature(byte[] sig) throws IOException {\n\t\tbyte[] rsArray = null;\n\n\t\tTypesReader tr = new TypesReader(sig);\n\n\t\tString sig_format = tr.readString();\n\t\tif (sig_format.startsWith(ECDSA_SHA2_PREFIX) == false)\n\t\t\tthrow new IOException(\"Peer sent wrong signature format\");\n\n\t\tString curveName = sig_format.substring(ECDSA_SHA2_PREFIX.length());\n\t\tif (CURVES.containsKey(curveName) == false) {\n\t\t\tthrow new IOException(\"Unsupported curve: \" + curveName);\n\t\t}\n\n\t\trsArray = tr.readByteString();\n\n\t\tif (tr.remain() != 0)\n\t\t\tthrow new IOException(\"Padding in ECDSA signature!\");\n\n\t\tbyte[] rArray;\n\t\tbyte[] sArray;\n\t\t{\n\t\t\tTypesReader rsReader = new TypesReader(rsArray);\n\t\t\trArray = rsReader.readMPINT().toByteArray();\n\t\t\tsArray = rsReader.readMPINT().toByteArray();\n\t\t}\n\n\t\tint first = rArray.length;\n\t\tint second = sArray.length;\n\n\t\t/* We can't have the high bit set, so add an extra zero at the beginning if so. */\n\t\tif ((rArray[0] & 0x80) != 0) {\n\t\t\tfirst++;\n\t\t}\n\t\tif ((sArray[0] & 0x80) != 0) {\n\t\t\tsecond++;\n\t\t}\n\n\t\t/* Calculate total output length */\n\t\tByteArrayOutputStream os = new ByteArrayOutputStream(6 + first + second);\n\n\t\t/* ASN.1 SEQUENCE tag */\n\t\tos.write(0x30);\n\n\t\t/* Size of SEQUENCE */\n\t\twriteLength(4 + first + second, os);\n\n\t\t/* ASN.1 INTEGER tag */\n\t\tos.write(0x02);\n\n\t\t/* \"r\" INTEGER length */\n\t\twriteLength(first, os);\n\n\t\t/* Copy in the \"r\" INTEGER */\n\t\tif (first != rArray.length) {\n\t\t\tos.write(0x00);\n\t\t}\n\t\tos.write(rArray);\n\n\t\t/* ASN.1 INTEGER tag */\n\t\tos.write(0x02);\n\n\t\t/* \"s\" INTEGER length */\n\t\twriteLength(second, os);\n\n\t\t/* Copy in the \"s\" INTEGER */\n\t\tif (second != sArray.length) {\n\t\t\tos.write(0x00);\n\t\t}\n\t\tos.write(sArray);\n\n\t\treturn os.toByteArray();\n\t}\n\n\tprivate static final void writeLength(int length, OutputStream os) throws IOException {\n\t\tif (length <= 0x7F) {\n\t\t\tos.write(length);\n\t\t\treturn;\n\t\t}\n\n\t\tint numOctets = 0;\n\t\tint lenCopy = length;\n\t\twhile (lenCopy != 0) {\n\t\t\tlenCopy >>>= 8;\n\t\t\tnumOctets++;\n\t\t}\n\n\t\tos.write(0x80 | numOctets);\n\n\t\tfor (int i = (numOctets - 1) * 8; i >= 0; i -= 8) {\n\t\t\tos.write((byte) (length >> i));\n\t\t}\n\t}\n\n\tpublic static byte[] encodeSSHECDSASignature(byte[] sig, ECParameterSpec params) throws IOException\n\t{\n\t\tTypesWriter tw = new TypesWriter();\n\n\t\tString curveName = getCurveName(params);\n\t\ttw.writeString(ECDSA_SHA2_PREFIX + curveName);\n\n\t\tif ((sig[0] != 0x30) || (sig[1] != sig.length - 2) || (sig[2] != 0x02)) {\n\t\t\tthrow new IOException(\"Invalid signature format\");\n\t\t}\n\n\t\tint rLength = sig[3];\n\t\tif ((rLength + 6 > sig.length) || (sig[4 + rLength] != 0x02)) {\n\t\t\tthrow new IOException(\"Invalid signature format\");\n\t\t}\n\n\t\tint sLength = sig[5 + rLength];\n\t\tif (6 + rLength + sLength > sig.length) {\n\t\t\tthrow new IOException(\"Invalid signature format\");\n\t\t}\n\n\t\tbyte[] rArray = new byte[rLength];\n\t\tbyte[] sArray = new byte[sLength];\n\n\t\tSystem.arraycopy(sig, 4, rArray, 0, rLength);\n\t\tSystem.arraycopy(sig, 6 + rLength, sArray, 0, sLength);\n\n\t\tBigInteger r = new BigInteger(rArray);\n\t\tBigInteger s = new BigInteger(sArray);\n\n\t\t// Write the <r,s> to its own types writer.\n\t\tTypesWriter rsWriter = new TypesWriter();\n\t\trsWriter.writeMPInt(r);\n\t\trsWriter.writeMPInt(s);\n\t\tbyte[] encoded = rsWriter.getBytes();\n\t\ttw.writeString(encoded, 0, encoded.length);\n\n\t\treturn tw.getBytes();\n\t}\n\n\tpublic static byte[] generateSignature(byte[] message, ECPrivateKey pk) throws IOException\n\t{\n\t\tfinal String algo = getSignatureAlgorithmForParams(pk.getParams());\n\n\t\ttry {\n\t\t\tSignature s = Signature.getInstance(algo);\n\t\t\ts.initSign(pk);\n\t\t\ts.update(message);\n\t\t\treturn s.sign();\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\tIOException ex = new IOException();\n\t\t\tex.initCause(e);\n\t\t\tthrow ex;\n\t\t} catch (InvalidKeyException e) {\n\t\t\tIOException ex = new IOException();\n\t\t\tex.initCause(e);\n\t\t\tthrow ex;\n\t\t} catch (SignatureException e) {\n\t\t\tIOException ex = new IOException();\n\t\t\tex.initCause(e);\n\t\t\tthrow ex;\n\t\t}\n\t}\n\n\tpublic static boolean verifySignature(byte[] message, byte[] ds, ECPublicKey dpk) throws IOException\n\t{\n\t\tfinal String algo = getSignatureAlgorithmForParams(dpk.getParams());\n\n\t\ttry {\n\t\t\tSignature s = Signature.getInstance(algo);\n\t\t\ts.initVerify(dpk);\n\t\t\ts.update(message);\n\t\t\treturn s.verify(ds);\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\tIOException ex = new IOException(\"No such algorithm\");\n\t\t\tex.initCause(e);\n\t\t\tthrow ex;\n\t\t} catch (InvalidKeyException e) {\n\t\t\tIOException ex = new IOException(\"No such algorithm\");\n\t\t\tex.initCause(e);\n\t\t\tthrow ex;\n\t\t} catch (SignatureException e) {\n\t\t\tIOException ex = new IOException();\n\t\t\tex.initCause(e);\n\t\t\tthrow ex;\n\t\t}\n\t}\n\n\tprivate static String getSignatureAlgorithmForParams(ECParameterSpec params) {\n\t\tint size = getCurveSize(params);\n\t\tif (size <= 256) {\n\t\t\treturn \"SHA256withECDSA\";\n\t\t} else if (size <= 384) {\n\t\t\treturn \"SHA384withECDSA\";\n\t\t} else {\n\t\t\treturn \"SHA512withECDSA\";\n\t\t}\n\t}\n\n\tpublic static String getDigestAlgorithmForParams(ECParameterSpec params) {\n\t\tint size = getCurveSize(params);\n\t\tif (size <= 256) {\n\t\t\treturn \"SHA256\";\n\t\t} else if (size <= 384) {\n\t\t\treturn \"SHA384\";\n\t\t} else {\n\t\t\treturn \"SHA512\";\n\t\t}\n\t}\n\n\t/**\n\t * Decode an OctetString to EllipticCurvePoint according to SECG 2.3.4\n\t */\n\tpublic static ECPoint decodeECPoint(byte[] M, EllipticCurve curve) {\n\t\tif (M.length == 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// M has len 2 ceil(log_2(q)/8) + 1 ?\n\t\tint elementSize = (curve.getField().getFieldSize() + 7) / 8;\n\t\tif (M.length != 2 * elementSize + 1) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// step 3.2\n\t\tif (M[0] != 0x04) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Step 3.3\n\t\tbyte[] xp = new byte[elementSize];\n\t\tSystem.arraycopy(M, 1, xp, 0, elementSize);\n\n\t\t// Step 3.4\n\t\tbyte[] yp = new byte[elementSize];\n\t\tSystem.arraycopy(M, 1 + elementSize, yp, 0, elementSize);\n\n\t\tECPoint P = new ECPoint(new BigInteger(1, xp), new BigInteger(1, yp));\n\n\t\t// TODO check point 3.5\n\n\t\t// Step 3.6\n\t\treturn P;\n\t}\n\n\t/**\n\t * Encode EllipticCurvePoint to an OctetString\n\t */\n\tpublic static byte[] encodeECPoint(ECPoint group, EllipticCurve curve)\n\t{\n\t\t// M has len 2 ceil(log_2(q)/8) + 1 ?\n\t\tint elementSize = (curve.getField().getFieldSize() + 7) / 8;\n\t\tbyte[] M = new byte[2 * elementSize + 1];\n\n\t\t// Uncompressed format\n\t\tM[0] = 0x04;\n\n\t\t{\n\t\t\tbyte[] affineX = removeLeadingZeroes(group.getAffineX().toByteArray());\n\t\t\tSystem.arraycopy(affineX, 0, M, 1 + elementSize - affineX.length, affineX.length);\n\t\t}\n\n\t\t{\n\t\t\tbyte[] affineY = removeLeadingZeroes(group.getAffineY().toByteArray());\n\t\t\tSystem.arraycopy(affineY, 0, M, 1 + elementSize + elementSize - affineY.length,\n\t\t\t\t\t\t\t affineY.length);\n\t\t}\n\n\t\treturn M;\n\t}\n\n\tprivate static byte[] removeLeadingZeroes(byte[] input) {\n\t\tif (input[0] != 0x00) {\n\t\t\treturn input;\n\t\t}\n\n\t\tint pos = 1;\n\t\twhile (pos < input.length - 1 && input[pos] == 0x00) {\n\t\t\tpos++;\n\t\t}\n\n\t\tbyte[] output = new byte[input.length - pos];\n\t\tSystem.arraycopy(input, pos, output, 0, output.length);\n\t\treturn output;\n\t}\n\n\tpublic static class EllipticCurves {\n\t\tpublic static ECParameterSpec nistp256 = new ECParameterSpec(\n\t\t\t\tnew EllipticCurve(\n\t\t\t\t\t\tnew ECFieldFp(new BigInteger(\"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\", 16)),\n\t\t\t\t\t\tnew BigInteger(\"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\", 16),\n\t\t\t\t\t\tnew BigInteger(\"5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b\", 16)),\n\t\t\t\tnew ECPoint(new BigInteger(\"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\", 16),\n\t\t\t\t\t\t\tnew BigInteger(\"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\", 16)),\n\t\t\t\tnew BigInteger(\"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551\", 16),\n\t\t\t\t1);\n\n\t\tpublic static ECParameterSpec nistp384 = new ECParameterSpec(\n\t\t\t\tnew EllipticCurve(\n\t\t\t\t\t\tnew ECFieldFp(new BigInteger(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\", 16)),\n\t\t\t\t\t\tnew BigInteger(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\", 16),\n\t\t\t\t\t\tnew BigInteger(\"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\", 16)),\n\t\t\t\tnew ECPoint(new BigInteger(\"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B9859F741E082542A385502F25DBF55296C3A545E3872760AB7\", 16),\n\t\t\t\t\t\t\tnew BigInteger(\"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A147CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\", 16)),\n\t\t\t\tnew BigInteger(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\", 16),\n\t\t\t\t1);\n\n\t\tpublic static ECParameterSpec nistp521 = new ECParameterSpec(\n\t\t\t\tnew EllipticCurve(\n\t\t\t\t\t\tnew ECFieldFp(new BigInteger(\"01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\", 16)),\n\t\t\t\t\t\tnew BigInteger(\"01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC\", 16),\n\t\t\t\t\t\tnew BigInteger(\"0051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573DF883D2C34F1EF451FD46B503F00\", 16)),\n\t\t\t\tnew ECPoint(new BigInteger(\"00C6858E06B70404E9CD9E3ECB662395B4429C648139053FB521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B3C1856A429BF97E7E31C2E5BD66\", 16),\n\t\t\t\t\t\t\tnew BigInteger(\"011839296A789A3BC0045C8A5FB42C7D1BD998F54449579B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C7086A272C24088BE94769FD16650\", 16)),\n\t\t\t\tnew BigInteger(\"01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5C9B8899C47AEBB6FB71E91386409\", 16),\n\t\t\t\t1);\n\t}\n}\n","lineNo":132}
{"Smelly Sample":"/**\n *\n */\npackage com.trilead.ssh2.signature;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.math.BigInteger;\nimport java.security.InvalidKeyException;\nimport java.security.KeyFactory;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.Signature;\nimport java.security.SignatureException;\nimport java.security.interfaces.ECPrivateKey;\nimport java.security.interfaces.ECPublicKey;\nimport java.security.spec.ECFieldFp;\nimport java.security.spec.ECParameterSpec;\nimport java.security.spec.ECPoint;\nimport java.security.spec.ECPublicKeySpec;\nimport java.security.spec.EllipticCurve;\nimport java.security.spec.InvalidKeySpecException;\nimport java.security.spec.KeySpec;\nimport java.util.Map;\nimport java.util.TreeMap;\n\nimport com.trilead.ssh2.log.Logger;\nimport com.trilead.ssh2.packets.TypesReader;\nimport com.trilead.ssh2.packets.TypesWriter;\n\n/**\n * @author Kenny Root\n *\n */\npublic class ECDSASHA2Verify {\n\tprivate static final Logger log = Logger.getLogger(ECDSASHA2Verify.class);\n\n\tpublic static final String ECDSA_SHA2_PREFIX = \"ecdsa-sha2-\";\n\n\tprivate static final String NISTP256 = \"nistp256\";\n\tprivate static final String NISTP384 = \"nistp384\";\n\tprivate static final String NISTP521 = \"nistp521\";\n\n\tprivate static final Map<String, ECParameterSpec> CURVES = new TreeMap<String, ECParameterSpec>();\n\tstatic {\n\t\tCURVES.put(NISTP256, EllipticCurves.nistp256);\n\t\tCURVES.put(NISTP384, EllipticCurves.nistp384);\n\t\tCURVES.put(NISTP521, EllipticCurves.nistp521);\n\t}\n\n\tprivate static final Map<Integer, String> CURVE_SIZES = new TreeMap<Integer, String>();\n\tstatic {\n\t\tCURVE_SIZES.put(256, NISTP256);\n\t\tCURVE_SIZES.put(384, NISTP384);\n\t\tCURVE_SIZES.put(521, NISTP521);\n\t}\n\n\tpublic static ECPublicKey decodeSSHECDSAPublicKey(byte[] key) throws IOException\n\t{\n\t\tTypesReader tr = new TypesReader(key);\n\n\t\tString key_format = tr.readString();\n\n\t\tif (key_format.startsWith(ECDSA_SHA2_PREFIX) == false)\n\t\t\tthrow new IllegalArgumentException(\"This is not an ECDSA public key\");\n\n\t\tString curveName = tr.readString();\n\t\tbyte[] groupBytes = tr.readByteString();\n\n\t\tif (tr.remain() != 0)\n\t\t\tthrow new IOException(\"Padding in ECDSA public key!\");\n\n\t\tif (key_format.equals(ECDSA_SHA2_PREFIX + curveName) == false) {\n\t\t\tthrow new IOException(\"Key format is inconsistent with curve name: \" + key_format\n\t\t\t\t\t+ \" != \" + curveName);\n\t\t}\n\n\t\tECParameterSpec params = CURVES.get(curveName);\n\t\tif (params == null) {\n\t\t\tthrow new IOException(\"Curve is not supported: \" + curveName);\n\t\t}\n\n\t\tECPoint group = ECDSASHA2Verify.decodeECPoint(groupBytes, params.getCurve());\n\t\tif (group == null) {\n\t\t\tthrow new IOException(\"Invalid ECDSA group\");\n\t\t}\n\n\t\tKeySpec keySpec = new ECPublicKeySpec(group, params);\n\n\t\ttry {\n\t\t\tKeyFactory kf = KeyFactory.getInstance(\"EC\");\n\t\t\treturn (ECPublicKey) kf.generatePublic(keySpec);\n\t\t} catch (NoSuchAlgorithmException nsae) {\n\t\t\tIOException ioe = new IOException(\"No RSA KeyFactory available\");\n\t\t\tioe.initCause(nsae);\n\t\t\tthrow ioe;\n\t\t} catch (InvalidKeySpecException ikse) {\n\t\t\tIOException ioe = new IOException(\"No RSA KeyFactory available\");\n\t\t\tioe.initCause(ikse);\n\t\t\tthrow ioe;\n\t\t}\n\t}\n\n\tpublic static byte[] encodeSSHECDSAPublicKey(ECPublicKey key) throws IOException {\n\t\tTypesWriter tw = new TypesWriter();\n\n\t\tString curveName = getCurveName(key.getParams());\n\n\t\tString keyFormat = ECDSA_SHA2_PREFIX + curveName;\n\n\t\ttw.writeString(keyFormat);\n\n\t\ttw.writeString(curveName);\n\n\t\ttw.writeBytes(encodeECPoint(key.getW(), key.getParams().getCurve()));\n\n\t\treturn tw.getBytes();\n\t}\n\n\tprivate static String getCurveName(ECParameterSpec params) throws IOException {\n\t\tint fieldSize = getCurveSize(params);\n\t\tString curveName = CURVE_SIZES.get(fieldSize);\n\t\tif (curveName == null) {\n\t\t\tthrow new IOException(\"Unsupported curve field size: \" + fieldSize);\n\t\t}\n\t\treturn curveName;\n\t}\n\n\tprivate static int getCurveSize(ECParameterSpec params) {\n\t\treturn params.getCurve().getField().getFieldSize();\n\t}\n\n\tpublic static byte[] decodeSSHECDSASignature(byte[] sig) throws IOException {\n\t\tbyte[] rsArray = null;\n\n\t\tTypesReader tr = new TypesReader(sig);\n\n\t\tString sig_format = tr.readString();\n\t\tif (sig_format.startsWith(ECDSA_SHA2_PREFIX) == false)\n\t\t\tthrow new IOException(\"Peer sent wrong signature format\");\n\n\t\tString curveName = sig_format.substring(ECDSA_SHA2_PREFIX.length());\n\t\tif (CURVES.containsKey(curveName) == false) {\n\t\t\tthrow new IOException(\"Unsupported curve: \" + curveName);\n\t\t}\n\n\t\trsArray = tr.readByteString();\n\n\t\tif (tr.remain() != 0)\n\t\t\tthrow new IOException(\"Padding in ECDSA signature!\");\n\n\t\tbyte[] rArray;\n\t\tbyte[] sArray;\n\t\t{\n\t\t\tTypesReader rsReader = new TypesReader(rsArray);\n\t\t\trArray = rsReader.readMPINT().toByteArray();\n\t\t\tsArray = rsReader.readMPINT().toByteArray();\n\t\t}\n\n\t\tint first = rArray.length;\n\t\tint second = sArray.length;\n\n\t\t/* We can't have the high bit set, so add an extra zero at the beginning if so. */\n\t\tif ((rArray[0] & 0x80) != 0) {\n\t\t\tfirst++;\n\t\t}\n\t\tif ((sArray[0] & 0x80) != 0) {\n\t\t\tsecond++;\n\t\t}\n\n\t\t/* Calculate total output length */\n\t\tByteArrayOutputStream os = new ByteArrayOutputStream(6 + first + second);\n\n\t\t/* ASN.1 SEQUENCE tag */\n\t\tos.write(0x30);\n\n\t\t/* Size of SEQUENCE */\n\t\twriteLength(4 + first + second, os);\n\n\t\t/* ASN.1 INTEGER tag */\n\t\tos.write(0x02);\n\n\t\t/* \"r\" INTEGER length */\n\t\twriteLength(first, os);\n\n\t\t/* Copy in the \"r\" INTEGER */\n\t\tif (first != rArray.length) {\n\t\t\tos.write(0x00);\n\t\t}\n\t\tos.write(rArray);\n\n\t\t/* ASN.1 INTEGER tag */\n\t\tos.write(0x02);\n\n\t\t/* \"s\" INTEGER length */\n\t\twriteLength(second, os);\n\n\t\t/* Copy in the \"s\" INTEGER */\n\t\tif (second != sArray.length) {\n\t\t\tos.write(0x00);\n\t\t}\n\t\tos.write(sArray);\n\n\t\treturn os.toByteArray();\n\t}\n\n\tprivate static final void writeLength(int length, OutputStream os) throws IOException {\n\t\tif (length <= 0x7F) {\n\t\t\tos.write(length);\n\t\t\treturn;\n\t\t}\n\n\t\tint numOctets = 0;\n\t\tint lenCopy = length;\n\t\twhile (lenCopy != 0) {\n\t\t\tlenCopy >>>= 8;\n\t\t\tnumOctets++;\n\t\t}\n\n\t\tos.write(0x80 | numOctets);\n\n\t\tfor (int i = (numOctets - 1) * 8; i >= 0; i -= 8) {\n\t\t\tos.write((byte) (length >> i));\n\t\t}\n\t}\n\n\tpublic static byte[] encodeSSHECDSASignature(byte[] sig, ECParameterSpec params) throws IOException\n\t{\n\t\tTypesWriter tw = new TypesWriter();\n\n\t\tString curveName = getCurveName(params);\n\t\ttw.writeString(ECDSA_SHA2_PREFIX + curveName);\n\n\t\tif ((sig[0] != 0x30) || (sig[1] != sig.length - 2) || (sig[2] != 0x02)) {\n\t\t\tthrow new IOException(\"Invalid signature format\");\n\t\t}\n\n\t\tint rLength = sig[3];\n\t\tif ((rLength + 6 > sig.length) || (sig[4 + rLength] != 0x02)) {\n\t\t\tthrow new IOException(\"Invalid signature format\");\n\t\t}\n\n\t\tint sLength = sig[5 + rLength];\n\t\tif (6 + rLength + sLength > sig.length) {\n\t\t\tthrow new IOException(\"Invalid signature format\");\n\t\t}\n\n\t\tbyte[] rArray = new byte[rLength];\n\t\tbyte[] sArray = new byte[sLength];\n\n\t\tSystem.arraycopy(sig, 4, rArray, 0, rLength);\n\t\tSystem.arraycopy(sig, 6 + rLength, sArray, 0, sLength);\n\n\t\tBigInteger r = new BigInteger(rArray);\n\t\tBigInteger s = new BigInteger(sArray);\n\n\t\t// Write the <r,s> to its own types writer.\n\t\tTypesWriter rsWriter = new TypesWriter();\n\t\trsWriter.writeMPInt(r);\n\t\trsWriter.writeMPInt(s);\n\t\ttw.writeBytes(rsWriter.getBytes());\n\n\t\treturn tw.getBytes();\n\t}\n\n\tpublic static byte[] generateSignature(byte[] message, ECPrivateKey pk) throws IOException\n\t{\n\t\tfinal String algo = getSignatureAlgorithmForParams(pk.getParams());\n\n\t\ttry {\n\t\t\tSignature s = Signature.getInstance(algo);\n\t\t\ts.initSign(pk);\n\t\t\ts.update(message);\n\t\t\treturn s.sign();\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\tIOException ex = new IOException();\n\t\t\tex.initCause(e);\n\t\t\tthrow ex;\n\t\t} catch (InvalidKeyException e) {\n\t\t\tIOException ex = new IOException();\n\t\t\tex.initCause(e);\n\t\t\tthrow ex;\n\t\t} catch (SignatureException e) {\n\t\t\tIOException ex = new IOException();\n\t\t\tex.initCause(e);\n\t\t\tthrow ex;\n\t\t}\n\t}\n\n\tpublic static boolean verifySignature(byte[] message, byte[] ds, ECPublicKey dpk) throws IOException\n\t{\n\t\tfinal String algo = getSignatureAlgorithmForParams(dpk.getParams());\n\n\t\ttry {\n\t\t\tSignature s = Signature.getInstance(algo);\n\t\t\ts.initVerify(dpk);\n\t\t\ts.update(message);\n\t\t\treturn s.verify(ds);\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\tIOException ex = new IOException(\"No such algorithm\");\n\t\t\tex.initCause(e);\n\t\t\tthrow ex;\n\t\t} catch (InvalidKeyException e) {\n\t\t\tIOException ex = new IOException(\"No such algorithm\");\n\t\t\tex.initCause(e);\n\t\t\tthrow ex;\n\t\t} catch (SignatureException e) {\n\t\t\tIOException ex = new IOException();\n\t\t\tex.initCause(e);\n\t\t\tthrow ex;\n\t\t}\n\t}\n\n\tprivate static String getSignatureAlgorithmForParams(ECParameterSpec params) {\n\t\tint size = getCurveSize(params);\n\t\tif (size <= 256) {\n\t\t\treturn \"SHA256withECDSA\";\n\t\t} else if (size <= 384) {\n\t\t\treturn \"SHA384withECDSA\";\n\t\t} else {\n\t\t\treturn \"SHA512withECDSA\";\n\t\t}\n\t}\n\n\tpublic static String getDigestAlgorithmForParams(ECParameterSpec params) {\n\t\tint size = getCurveSize(params);\n\t\tif (size <= 256) {\n\t\t\treturn \"SHA256\";\n\t\t} else if (size <= 384) {\n\t\t\treturn \"SHA384\";\n\t\t} else {\n\t\t\treturn \"SHA512\";\n\t\t}\n\t}\n\n\t/**\n\t * Decode an OctetString to EllipticCurvePoint according to SECG 2.3.4\n\t */\n\tpublic static ECPoint decodeECPoint(byte[] M, EllipticCurve curve) {\n\t\tif (M.length == 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// M has len 2 ceil(log_2(q)/8) + 1 ?\n\t\tint elementSize = (curve.getField().getFieldSize() + 7) / 8;\n\t\tif (M.length != 2 * elementSize + 1) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// step 3.2\n\t\tif (M[0] != 0x04) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Step 3.3\n\t\tbyte[] xp = new byte[elementSize];\n\t\tSystem.arraycopy(M, 1, xp, 0, elementSize);\n\n\t\t// Step 3.4\n\t\tbyte[] yp = new byte[elementSize];\n\t\tSystem.arraycopy(M, 1 + elementSize, yp, 0, elementSize);\n\n\t\tECPoint P = new ECPoint(new BigInteger(1, xp), new BigInteger(1, yp));\n\n\t\t// TODO check point 3.5\n\n\t\t// Step 3.6\n\t\treturn P;\n\t}\n\n\t/**\n\t * Encode EllipticCurvePoint to an OctetString\n\t */\n\tpublic static byte[] encodeECPoint(ECPoint group, EllipticCurve curve)\n\t{\n\t\t// M has len 2 ceil(log_2(q)/8) + 1 ?\n\t\tint elementSize = (curve.getField().getFieldSize() + 7) / 8;\n\t\tbyte[] M = new byte[2 * elementSize + 1];\n\n\t\t// Uncompressed format\n\t\tM[0] = 0x04;\n\n\t\t{\n\t\t\tbyte[] affineX = removeLeadingZeroes(group.getAffineX().toByteArray());\n\t\t\tSystem.arraycopy(affineX, 0, M, 1 + elementSize - affineX.length, affineX.length);\n\t\t}\n\n\t\t{\n\t\t\tbyte[] affineY = removeLeadingZeroes(group.getAffineY().toByteArray());\n\t\t\tSystem.arraycopy(affineY, 0, M, 1 + elementSize + elementSize - affineY.length,\n\t\t\t\t\t\t\t affineY.length);\n\t\t}\n\n\t\treturn M;\n\t}\n\n\tprivate static byte[] removeLeadingZeroes(byte[] input) {\n\t\tif (input[0] != 0x00) {\n\t\t\treturn input;\n\t\t}\n\n\t\tint pos = 1;\n\t\twhile (pos < input.length - 1 && input[pos] == 0x00) {\n\t\t\tpos++;\n\t\t}\n\n\t\tbyte[] output = new byte[input.length - pos];\n\t\tSystem.arraycopy(input, pos, output, 0, output.length);\n\t\treturn output;\n\t}\n\n\tpublic static class EllipticCurves {\n\t\tpublic static ECParameterSpec nistp256 = new ECParameterSpec(\n\t\t\t\tnew EllipticCurve(\n\t\t\t\t\t\tnew ECFieldFp(new BigInteger(\"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\", 16)),\n\t\t\t\t\t\tnew BigInteger(\"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\", 16),\n\t\t\t\t\t\tnew BigInteger(\"5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b\", 16)),\n\t\t\t\tnew ECPoint(new BigInteger(\"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\", 16),\n\t\t\t\t\t\t\tnew BigInteger(\"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\", 16)),\n\t\t\t\tnew BigInteger(\"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551\", 16),\n\t\t\t\t1);\n\n\t\tpublic static ECParameterSpec nistp384 = new ECParameterSpec(\n\t\t\t\tnew EllipticCurve(\n\t\t\t\t\t\tnew ECFieldFp(new BigInteger(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\", 16)),\n\t\t\t\t\t\tnew BigInteger(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\", 16),\n\t\t\t\t\t\tnew BigInteger(\"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\", 16)),\n\t\t\t\tnew ECPoint(new BigInteger(\"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B9859F741E082542A385502F25DBF55296C3A545E3872760AB7\", 16),\n\t\t\t\t\t\t\tnew BigInteger(\"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A147CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\", 16)),\n\t\t\t\tnew BigInteger(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\", 16),\n\t\t\t\t1);\n\n\t\tpublic static ECParameterSpec nistp521 = new ECParameterSpec(\n\t\t\t\tnew EllipticCurve(\n\t\t\t\t\t\tnew ECFieldFp(new BigInteger(\"01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\", 16)),\n\t\t\t\t\t\tnew BigInteger(\"01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC\", 16),\n\t\t\t\t\t\tnew BigInteger(\"0051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573DF883D2C34F1EF451FD46B503F00\", 16)),\n\t\t\t\tnew ECPoint(new BigInteger(\"00C6858E06B70404E9CD9E3ECB662395B4429C648139053FB521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B3C1856A429BF97E7E31C2E5BD66\", 16),\n\t\t\t\t\t\t\tnew BigInteger(\"011839296A789A3BC0045C8A5FB42C7D1BD998F54449579B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C7086A272C24088BE94769FD16650\", 16)),\n\t\t\t\tnew BigInteger(\"01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5C9B8899C47AEBB6FB71E91386409\", 16),\n\t\t\t\t1);\n\t}\n}\n","Method after Refactoring":"/**\n *\n */\npackage com.trilead.ssh2.signature;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.math.BigInteger;\nimport java.security.InvalidKeyException;\nimport java.security.KeyFactory;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.Signature;\nimport java.security.SignatureException;\nimport java.security.interfaces.ECPrivateKey;\nimport java.security.interfaces.ECPublicKey;\nimport java.security.spec.ECFieldFp;\nimport java.security.spec.ECParameterSpec;\nimport java.security.spec.ECPoint;\nimport java.security.spec.ECPublicKeySpec;\nimport java.security.spec.EllipticCurve;\nimport java.security.spec.InvalidKeySpecException;\nimport java.security.spec.KeySpec;\nimport java.util.Map;\nimport java.util.TreeMap;\n\nimport com.trilead.ssh2.log.Logger;\nimport com.trilead.ssh2.packets.TypesReader;\nimport com.trilead.ssh2.packets.TypesWriter;\n\n/**\n * @author Kenny Root\n *\n */\npublic class ECDSASHA2Verify {\n\tprivate static final Logger log = Logger.getLogger(ECDSASHA2Verify.class);\n\n\tpublic static final String ECDSA_SHA2_PREFIX = \"ecdsa-sha2-\";\n\n\tprivate static final String NISTP256 = \"nistp256\";\n\tprivate static final String NISTP384 = \"nistp384\";\n\tprivate static final String NISTP521 = \"nistp521\";\n\n\tprivate static final Map<String, ECParameterSpec> CURVES = new TreeMap<String, ECParameterSpec>();\n\tstatic {\n\t\tCURVES.put(NISTP256, EllipticCurves.nistp256);\n\t\tCURVES.put(NISTP384, EllipticCurves.nistp384);\n\t\tCURVES.put(NISTP521, EllipticCurves.nistp521);\n\t}\n\n\tprivate static final Map<Integer, String> CURVE_SIZES = new TreeMap<Integer, String>();\n\tstatic {\n\t\tCURVE_SIZES.put(256, NISTP256);\n\t\tCURVE_SIZES.put(384, NISTP384);\n\t\tCURVE_SIZES.put(521, NISTP521);\n\t}\n\n\tpublic static int[] getCurveSizes() {\n\t\tint[] keys = new int[CURVE_SIZES.size()];\n\t\tint i = 0;\n\t\tfor (Integer n : CURVE_SIZES.keySet().toArray(new Integer[keys.length])) {\n\t\t\tkeys[i++] = n;\n\t\t}\n\t\treturn keys;\n\t}\n\n\tpublic static ECParameterSpec getCurveForSize(int size) {\n\t\tfinal String name = CURVE_SIZES.get(size);\n\t\tif (name == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn CURVES.get(name);\n\t}\n\n\tpublic static ECPublicKey decodeSSHECDSAPublicKey(byte[] key) throws IOException\n\t{\n\t\tTypesReader tr = new TypesReader(key);\n\n\t\tString key_format = tr.readString();\n\n\t\tif (key_format.startsWith(ECDSA_SHA2_PREFIX) == false)\n\t\t\tthrow new IllegalArgumentException(\"This is not an ECDSA public key\");\n\n\t\tString curveName = tr.readString();\n\t\tbyte[] groupBytes = tr.readByteString();\n\n\t\tif (tr.remain() != 0)\n\t\t\tthrow new IOException(\"Padding in ECDSA public key!\");\n\n\t\tif (key_format.equals(ECDSA_SHA2_PREFIX + curveName) == false) {\n\t\t\tthrow new IOException(\"Key format is inconsistent with curve name: \" + key_format\n\t\t\t\t\t+ \" != \" + curveName);\n\t\t}\n\n\t\tECParameterSpec params = CURVES.get(curveName);\n\t\tif (params == null) {\n\t\t\tthrow new IOException(\"Curve is not supported: \" + curveName);\n\t\t}\n\n\t\tECPoint group = ECDSASHA2Verify.decodeECPoint(groupBytes, params.getCurve());\n\t\tif (group == null) {\n\t\t\tthrow new IOException(\"Invalid ECDSA group\");\n\t\t}\n\n\t\tKeySpec keySpec = new ECPublicKeySpec(group, params);\n\n\t\ttry {\n\t\t\tKeyFactory kf = KeyFactory.getInstance(\"EC\");\n\t\t\treturn (ECPublicKey) kf.generatePublic(keySpec);\n\t\t} catch (NoSuchAlgorithmException nsae) {\n\t\t\tIOException ioe = new IOException(\"No RSA KeyFactory available\");\n\t\t\tioe.initCause(nsae);\n\t\t\tthrow ioe;\n\t\t} catch (InvalidKeySpecException ikse) {\n\t\t\tIOException ioe = new IOException(\"No RSA KeyFactory available\");\n\t\t\tioe.initCause(ikse);\n\t\t\tthrow ioe;\n\t\t}\n\t}\n\n\tpublic static byte[] encodeSSHECDSAPublicKey(ECPublicKey key) throws IOException {\n\t\tTypesWriter tw = new TypesWriter();\n\n\t\tString curveName = getCurveName(key.getParams());\n\n\t\tString keyFormat = ECDSA_SHA2_PREFIX + curveName;\n\n\t\ttw.writeString(keyFormat);\n\n\t\ttw.writeString(curveName);\n\n\t\tbyte[] encoded = encodeECPoint(key.getW(), key.getParams().getCurve());\n\t\ttw.writeString(encoded, 0, encoded.length);\n\n\t\treturn tw.getBytes();\n\t}\n\n\tpublic static String getCurveName(ECParameterSpec params) throws IOException {\n\t\tint fieldSize = getCurveSize(params);\n\t\tfinal String curveName = getCurveName(fieldSize);\n\t\tif (curveName == null) {\n\t\t\tthrow new IOException(\"invalid curve size \" + fieldSize);\n\t\t}\n\t\treturn curveName;\n\t}\n\n\tpublic static String getCurveName(int fieldSize) {\n\t\tString curveName = CURVE_SIZES.get(fieldSize);\n\t\tif (curveName == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn curveName;\n\t}\n\n\tpublic static int getCurveSize(ECParameterSpec params) {\n\t\treturn params.getCurve().getField().getFieldSize();\n\t}\n\n\tpublic static byte[] decodeSSHECDSASignature(byte[] sig) throws IOException {\n\t\tbyte[] rsArray = null;\n\n\t\tTypesReader tr = new TypesReader(sig);\n\n\t\tString sig_format = tr.readString();\n\t\tif (sig_format.startsWith(ECDSA_SHA2_PREFIX) == false)\n\t\t\tthrow new IOException(\"Peer sent wrong signature format\");\n\n\t\tString curveName = sig_format.substring(ECDSA_SHA2_PREFIX.length());\n\t\tif (CURVES.containsKey(curveName) == false) {\n\t\t\tthrow new IOException(\"Unsupported curve: \" + curveName);\n\t\t}\n\n\t\trsArray = tr.readByteString();\n\n\t\tif (tr.remain() != 0)\n\t\t\tthrow new IOException(\"Padding in ECDSA signature!\");\n\n\t\tbyte[] rArray;\n\t\tbyte[] sArray;\n\t\t{\n\t\t\tTypesReader rsReader = new TypesReader(rsArray);\n\t\t\trArray = rsReader.readMPINT().toByteArray();\n\t\t\tsArray = rsReader.readMPINT().toByteArray();\n\t\t}\n\n\t\tint first = rArray.length;\n\t\tint second = sArray.length;\n\n\t\t/* We can't have the high bit set, so add an extra zero at the beginning if so. */\n\t\tif ((rArray[0] & 0x80) != 0) {\n\t\t\tfirst++;\n\t\t}\n\t\tif ((sArray[0] & 0x80) != 0) {\n\t\t\tsecond++;\n\t\t}\n\n\t\t/* Calculate total output length */\n\t\tByteArrayOutputStream os = new ByteArrayOutputStream(6 + first + second);\n\n\t\t/* ASN.1 SEQUENCE tag */\n\t\tos.write(0x30);\n\n\t\t/* Size of SEQUENCE */\n\t\twriteLength(4 + first + second, os);\n\n\t\t/* ASN.1 INTEGER tag */\n\t\tos.write(0x02);\n\n\t\t/* \"r\" INTEGER length */\n\t\twriteLength(first, os);\n\n\t\t/* Copy in the \"r\" INTEGER */\n\t\tif (first != rArray.length) {\n\t\t\tos.write(0x00);\n\t\t}\n\t\tos.write(rArray);\n\n\t\t/* ASN.1 INTEGER tag */\n\t\tos.write(0x02);\n\n\t\t/* \"s\" INTEGER length */\n\t\twriteLength(second, os);\n\n\t\t/* Copy in the \"s\" INTEGER */\n\t\tif (second != sArray.length) {\n\t\t\tos.write(0x00);\n\t\t}\n\t\tos.write(sArray);\n\n\t\treturn os.toByteArray();\n\t}\n\n\tprivate static final void writeLength(int length, OutputStream os) throws IOException {\n\t\tif (length <= 0x7F) {\n\t\t\tos.write(length);\n\t\t\treturn;\n\t\t}\n\n\t\tint numOctets = 0;\n\t\tint lenCopy = length;\n\t\twhile (lenCopy != 0) {\n\t\t\tlenCopy >>>= 8;\n\t\t\tnumOctets++;\n\t\t}\n\n\t\tos.write(0x80 | numOctets);\n\n\t\tfor (int i = (numOctets - 1) * 8; i >= 0; i -= 8) {\n\t\t\tos.write((byte) (length >> i));\n\t\t}\n\t}\n\n\tpublic static byte[] encodeSSHECDSASignature(byte[] sig, ECParameterSpec params) throws IOException\n\t{\n\t\tTypesWriter tw = new TypesWriter();\n\n\t\tString curveName = getCurveName(params);\n\t\ttw.writeString(ECDSA_SHA2_PREFIX + curveName);\n\n\t\tif ((sig[0] != 0x30) || (sig[1] != sig.length - 2) || (sig[2] != 0x02)) {\n\t\t\tthrow new IOException(\"Invalid signature format\");\n\t\t}\n\n\t\tint rLength = sig[3];\n\t\tif ((rLength + 6 > sig.length) || (sig[4 + rLength] != 0x02)) {\n\t\t\tthrow new IOException(\"Invalid signature format\");\n\t\t}\n\n\t\tint sLength = sig[5 + rLength];\n\t\tif (6 + rLength + sLength > sig.length) {\n\t\t\tthrow new IOException(\"Invalid signature format\");\n\t\t}\n\n\t\tbyte[] rArray = new byte[rLength];\n\t\tbyte[] sArray = new byte[sLength];\n\n\t\tSystem.arraycopy(sig, 4, rArray, 0, rLength);\n\t\tSystem.arraycopy(sig, 6 + rLength, sArray, 0, sLength);\n\n\t\tBigInteger r = new BigInteger(rArray);\n\t\tBigInteger s = new BigInteger(sArray);\n\n\t\t// Write the <r,s> to its own types writer.\n\t\tTypesWriter rsWriter = new TypesWriter();\n\t\trsWriter.writeMPInt(r);\n\t\trsWriter.writeMPInt(s);\n\t\tbyte[] encoded = rsWriter.getBytes();\n\t\ttw.writeString(encoded, 0, encoded.length);\n\n\t\treturn tw.getBytes();\n\t}\n\n\tpublic static byte[] generateSignature(byte[] message, ECPrivateKey pk) throws IOException\n\t{\n\t\tfinal String algo = getSignatureAlgorithmForParams(pk.getParams());\n\n\t\ttry {\n\t\t\tSignature s = Signature.getInstance(algo);\n\t\t\ts.initSign(pk);\n\t\t\ts.update(message);\n\t\t\treturn s.sign();\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\tIOException ex = new IOException();\n\t\t\tex.initCause(e);\n\t\t\tthrow ex;\n\t\t} catch (InvalidKeyException e) {\n\t\t\tIOException ex = new IOException();\n\t\t\tex.initCause(e);\n\t\t\tthrow ex;\n\t\t} catch (SignatureException e) {\n\t\t\tIOException ex = new IOException();\n\t\t\tex.initCause(e);\n\t\t\tthrow ex;\n\t\t}\n\t}\n\n\tpublic static boolean verifySignature(byte[] message, byte[] ds, ECPublicKey dpk) throws IOException\n\t{\n\t\tfinal String algo = getSignatureAlgorithmForParams(dpk.getParams());\n\n\t\ttry {\n\t\t\tSignature s = Signature.getInstance(algo);\n\t\t\ts.initVerify(dpk);\n\t\t\ts.update(message);\n\t\t\treturn s.verify(ds);\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\tIOException ex = new IOException(\"No such algorithm\");\n\t\t\tex.initCause(e);\n\t\t\tthrow ex;\n\t\t} catch (InvalidKeyException e) {\n\t\t\tIOException ex = new IOException(\"No such algorithm\");\n\t\t\tex.initCause(e);\n\t\t\tthrow ex;\n\t\t} catch (SignatureException e) {\n\t\t\tIOException ex = new IOException();\n\t\t\tex.initCause(e);\n\t\t\tthrow ex;\n\t\t}\n\t}\n\n\tprivate static String getSignatureAlgorithmForParams(ECParameterSpec params) {\n\t\tint size = getCurveSize(params);\n\t\tif (size <= 256) {\n\t\t\treturn \"SHA256withECDSA\";\n\t\t} else if (size <= 384) {\n\t\t\treturn \"SHA384withECDSA\";\n\t\t} else {\n\t\t\treturn \"SHA512withECDSA\";\n\t\t}\n\t}\n\n\tpublic static String getDigestAlgorithmForParams(ECParameterSpec params) {\n\t\tint size = getCurveSize(params);\n\t\tif (size <= 256) {\n\t\t\treturn \"SHA256\";\n\t\t} else if (size <= 384) {\n\t\t\treturn \"SHA384\";\n\t\t} else {\n\t\t\treturn \"SHA512\";\n\t\t}\n\t}\n\n\t/**\n\t * Decode an OctetString to EllipticCurvePoint according to SECG 2.3.4\n\t */\n\tpublic static ECPoint decodeECPoint(byte[] M, EllipticCurve curve) {\n\t\tif (M.length == 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// M has len 2 ceil(log_2(q)/8) + 1 ?\n\t\tint elementSize = (curve.getField().getFieldSize() + 7) / 8;\n\t\tif (M.length != 2 * elementSize + 1) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// step 3.2\n\t\tif (M[0] != 0x04) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Step 3.3\n\t\tbyte[] xp = new byte[elementSize];\n\t\tSystem.arraycopy(M, 1, xp, 0, elementSize);\n\n\t\t// Step 3.4\n\t\tbyte[] yp = new byte[elementSize];\n\t\tSystem.arraycopy(M, 1 + elementSize, yp, 0, elementSize);\n\n\t\tECPoint P = new ECPoint(new BigInteger(1, xp), new BigInteger(1, yp));\n\n\t\t// TODO check point 3.5\n\n\t\t// Step 3.6\n\t\treturn P;\n\t}\n\n\t/**\n\t * Encode EllipticCurvePoint to an OctetString\n\t */\n\tpublic static byte[] encodeECPoint(ECPoint group, EllipticCurve curve)\n\t{\n\t\t// M has len 2 ceil(log_2(q)/8) + 1 ?\n\t\tint elementSize = (curve.getField().getFieldSize() + 7) / 8;\n\t\tbyte[] M = new byte[2 * elementSize + 1];\n\n\t\t// Uncompressed format\n\t\tM[0] = 0x04;\n\n\t\t{\n\t\t\tbyte[] affineX = removeLeadingZeroes(group.getAffineX().toByteArray());\n\t\t\tSystem.arraycopy(affineX, 0, M, 1 + elementSize - affineX.length, affineX.length);\n\t\t}\n\n\t\t{\n\t\t\tbyte[] affineY = removeLeadingZeroes(group.getAffineY().toByteArray());\n\t\t\tSystem.arraycopy(affineY, 0, M, 1 + elementSize + elementSize - affineY.length,\n\t\t\t\t\t\t\t affineY.length);\n\t\t}\n\n\t\treturn M;\n\t}\n\n\tprivate static byte[] removeLeadingZeroes(byte[] input) {\n\t\tif (input[0] != 0x00) {\n\t\t\treturn input;\n\t\t}\n\n\t\tint pos = 1;\n\t\twhile (pos < input.length - 1 && input[pos] == 0x00) {\n\t\t\tpos++;\n\t\t}\n\n\t\tbyte[] output = new byte[input.length - pos];\n\t\tSystem.arraycopy(input, pos, output, 0, output.length);\n\t\treturn output;\n\t}\n\n\tpublic static class EllipticCurves {\n\t\tpublic static ECParameterSpec nistp256 = new ECParameterSpec(\n\t\t\t\tnew EllipticCurve(\n\t\t\t\t\t\tnew ECFieldFp(new BigInteger(\"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\", 16)),\n\t\t\t\t\t\tnew BigInteger(\"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\", 16),\n\t\t\t\t\t\tnew BigInteger(\"5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b\", 16)),\n\t\t\t\tnew ECPoint(new BigInteger(\"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\", 16),\n\t\t\t\t\t\t\tnew BigInteger(\"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\", 16)),\n\t\t\t\tnew BigInteger(\"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551\", 16),\n\t\t\t\t1);\n\n\t\tpublic static ECParameterSpec nistp384 = new ECParameterSpec(\n\t\t\t\tnew EllipticCurve(\n\t\t\t\t\t\tnew ECFieldFp(new BigInteger(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\", 16)),\n\t\t\t\t\t\tnew BigInteger(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\", 16),\n\t\t\t\t\t\tnew BigInteger(\"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\", 16)),\n\t\t\t\tnew ECPoint(new BigInteger(\"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B9859F741E082542A385502F25DBF55296C3A545E3872760AB7\", 16),\n\t\t\t\t\t\t\tnew BigInteger(\"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A147CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\", 16)),\n\t\t\t\tnew BigInteger(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\", 16),\n\t\t\t\t1);\n\n\t\tpublic static ECParameterSpec nistp521 = new ECParameterSpec(\n\t\t\t\tnew EllipticCurve(\n\t\t\t\t\t\tnew ECFieldFp(new BigInteger(\"01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\", 16)),\n\t\t\t\t\t\tnew BigInteger(\"01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC\", 16),\n\t\t\t\t\t\tnew BigInteger(\"0051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573DF883D2C34F1EF451FD46B503F00\", 16)),\n\t\t\t\tnew ECPoint(new BigInteger(\"00C6858E06B70404E9CD9E3ECB662395B4429C648139053FB521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B3C1856A429BF97E7E31C2E5BD66\", 16),\n\t\t\t\t\t\t\tnew BigInteger(\"011839296A789A3BC0045C8A5FB42C7D1BD998F54449579B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C7086A272C24088BE94769FD16650\", 16)),\n\t\t\t\tnew BigInteger(\"01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5C9B8899C47AEBB6FB71E91386409\", 16),\n\t\t\t\t1);\n\t}\n}\n","lineNo":287}
