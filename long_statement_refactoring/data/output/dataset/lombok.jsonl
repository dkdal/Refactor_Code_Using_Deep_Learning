{"Smelly Sample":"package lombok.eclipse.dependencies;\n\nimport java.io.BufferedInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\nimport javax.xml.bind.JAXBContext;\nimport javax.xml.bind.JAXBException;\n\npublic class UpdateSite {\n\tprivate static final String OS_NAME = System.getProperty(\"os.name\").toLowerCase();\n\tprivate static final String OSGI_OS = OS_NAME.contains(\"windows\") ? \"windows\" : OS_NAME.contains(\"mac\") ? \"mac\" : \"linux\";\n\tprivate static final String OS_ARCH = System.getProperty(\"os.arch\");\n\tprivate static final String OSGI_ARCH = OS_ARCH.equals(\"aarch64\") ? \"aarch64\" : \"x86_64\";\n\t\n\tprivate JAXBContext jaxbContext;\n\tprivate Repository repository;\n\tprivate Map<String, List<Unit>> providesIndex;\n\tprivate String resolvedUrl;\n\t\n\tpublic UpdateSite() throws JAXBException {\n\t\tjaxbContext = JAXBContext.newInstance(Repository.class);\n\t\tprovidesIndex = new HashMap<>();\n\t}\n\t\n\tpublic void read(String url) throws Exception {\n\t\tString currentUrl = url;\n\t\ttry {\n\t\t\twhile (true) {\n\t\t\t\tString child = resolveNextChild(currentUrl);\n\t\t\t\tif (child.startsWith(\"https://\")) {\n\t\t\t\t\tcurrentUrl = child;\n\t\t\t\t} else {\n\t\t\t\t\tcurrentUrl += child;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (FileNotFoundException e) {\n\t\t\t// Found the real repository\n\t\t}\n\t\t\n\t\tresolvedUrl = currentUrl;\n\t\t\n\t\ttry (InputStream inputStream = readJarOrXml(resolvedUrl, \"content\")) {\n\t\t\trepository = (Repository) jaxbContext.createUnmarshaller().unmarshal(inputStream);\n\t\t\t\n\t\t\t// Build index\n\t\t\tfor (Unit unit : repository.units) {\n\t\t\t\tfor (Provided provides : unit.provides) {\n\t\t\t\t\tprovidesIndex.computeIfAbsent(provides.namespace + \":\" + provides.name, k -> new ArrayList<>()).add(unit);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t;\n\t}\n\t\n\tpublic Set<String> resolveWithoutDependencies(List<String> dependencies) {\n\t\treturn resolve(dependencies, false);\n\t}\n\t\n\tpublic Set<String> resolveWithDependencies(List<String> dependencies) {\n\t\treturn resolve(dependencies, true);\n\t}\n\t\n\tprivate Set<String> resolve(List<String> dependencies, boolean withDependencies) {\n\t\tQueue<String> toResolve = new UniqueQueue<>();\n\t\tfor (String dependency : dependencies) {\n\t\t\ttoResolve.add(dependency);\n\t\t}\n\t\tSet<Unit> resolved = new HashSet<>();\n\t\twhile (!toResolve.isEmpty()) {\n\t\t\tString next = toResolve.poll();\n\t\t\t\n\t\t\tList<Unit> providedUnits = providesIndex.get(next);\n\t\t\t// Skip unknown\n\t\t\tif (providedUnits == null) {\n\t\t\t\tSystem.out.println(\"Skipping unknown unit \" + next);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// Skip ambiguous (we could use version ranges to solve that...)\n\t\t\tif (providedUnits.size() > 1) {\n\t\t\t\tboolean alreadyResolved = providedUnits.stream().anyMatch(resolved::contains);\n\t\t\t\tif (!alreadyResolved) {\n\t\t\t\t\tSystem.out.println(\"Ambiguous resolution for \" + next + \": \" + providedUnits.toString());\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tUnit unit = providedUnits.get(0);\n\t\t\tresolved.add(unit);\n\t\t\t\n\t\t\tif (withDependencies && unit.requires != null) {\n\t\t\t\tfor (Required required : unit.requires) {\n\t\t\t\t\tif (required.optional) continue;\n\t\t\t\t\tif (!matchesFilter(required.filter)) continue;\n\t\t\t\t\t\n\t\t\t\t\ttoResolve.add(required.namespace + \":\" + required.name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn resolved.stream().map(u -> u.toString() + \".jar\").collect(Collectors.toSet());\n\t}\n\t\n\t// Dummy implementation\n\tprivate boolean matchesFilter(String filter) {\n\t\tif (filter == null) {\n\t\t\treturn true;\n\t\t}\n\t\tif (filter.contains(\"osgi.arch=\") && !filter.contains(\"osgi.arch=\" + OSGI_ARCH)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (filter.contains(\"osgi.os=\") && !filter.contains(\"osgi.os=\" + OSGI_OS)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate String resolveNextChild(String currentUrl) throws MalformedURLException, IOException, JAXBException {\n\t\ttry (InputStream inputStream = readJarOrXml(currentUrl, \"compositeContent\")) {\n\t\t\tRepository repository = (Repository) jaxbContext.createUnmarshaller().unmarshal(inputStream);\n\t\t\tChild lastChild = repository.children.get(repository.children.size() - 1);\n\t\t\treturn lastChild.location;\n\t\t}\n\t}\n\t\n\tprivate InputStream readJarOrXml(String url, String name) throws MalformedURLException, IOException {\n\t\ttry {\n\t\t\treturn getStreamForUrl(url + \"/\" + name + \".xml\");\n\t\t} catch (FileNotFoundException e) {\n\t\t\tSystem.out.println(\"Not found, trying jar\");\n\t\t}\n\t\tZipInputStream zipInputStream = new ZipInputStream(getStreamForUrl(url + \"/\" + name + \".jar\"));\n\t\tZipEntry entry;\n\t\twhile ((entry = zipInputStream.getNextEntry()) != null) {\n\t\t\tif (entry.getName().equals(name + \".xml\")) {\n\t\t\t\treturn zipInputStream;\n\t\t\t}\n\t\t}\n\t\tthrow new FileNotFoundException();\n\t}\n\t\n\tprivate static InputStream getStreamForUrl(String url) throws IOException, MalformedURLException {\n\t\tSystem.out.println(\"Reading \" + url);\n\t\tHttpURLConnection connection = (HttpURLConnection) new URL(url).openConnection();\n\t\tconnection.setRequestProperty(\"User-Agent\", \"lombok\");\n\t\tconnection.setRequestProperty(\"Accept\", \"*/*\");\n\t\tInputStream in = new BufferedInputStream(connection.getInputStream());\n\t\treturn in;\n\t}\n\n\tpublic String getResolvedUrl() {\n\t\treturn resolvedUrl;\n\t}\n}\n","Method after Refactoring":"package lombok.eclipse.dependencies;\n\nimport java.io.BufferedInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\nimport javax.xml.bind.JAXBContext;\nimport javax.xml.bind.JAXBException;\n\npublic class UpdateSite {\n\tprivate static final String OS_NAME = System.getProperty(\"os.name\").toLowerCase();\n\tprivate static final String OSGI_OS = OS_NAME.contains(\"windows\") ? \"windows\" : OS_NAME.contains(\"mac\") ? \"mac\" : \"linux\";\n\tprivate static final String OS_ARCH = System.getProperty(\"os.arch\");\n\tprivate static final String OSGI_ARCH = OS_ARCH.equals(\"aarch64\") ? \"aarch64\" : \"x86_64\";\n\t\n\tprivate JAXBContext jaxbContext;\n\tprivate Repository repository;\n\tprivate Map<String, List<Unit>> providesIndex;\n\tprivate String resolvedUrl;\n\t\n\tpublic UpdateSite() throws JAXBException {\n\t\tjaxbContext = JAXBContext.newInstance(Repository.class);\n\t\tprovidesIndex = new HashMap<>();\n\t}\n\t\n\tpublic void read(String url) throws Exception {\n\t\tString currentUrl = url;\n\t\ttry {\n\t\t\twhile (true) {\n\t\t\t\tString child = resolveNextChild(currentUrl);\n\t\t\t\tif (child.startsWith(\"https://\")) {\n\t\t\t\t\tcurrentUrl = child;\n\t\t\t\t} else {\n\t\t\t\t\tcurrentUrl += child;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (FileNotFoundException e) {\n\t\t\t// Found the real repository\n\t\t}\n\t\t\n\t\tresolvedUrl = currentUrl;\n\t\t\n\t\ttry (InputStream inputStream = readJarOrXml(resolvedUrl, \"content\")) {\n\t\t\trepository = (Repository) jaxbContext.createUnmarshaller().unmarshal(inputStream);\n\t\t\t\n\t\t\t// Build index\n\t\t\tfor (Unit unit : repository.units) {\n\t\t\t\tfor (Provided provides : unit.provides) {\n\t\t\t\t\tprovidesIndex.computeIfAbsent(provides.namespace + \":\" + provides.name, k -> new ArrayList<>()).add(unit);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t;\n\t}\n\t\n\tpublic Set<String> resolveWithoutDependencies(List<String> dependencies) {\n\t\treturn resolve(dependencies, false);\n\t}\n\t\n\tpublic Set<String> resolveWithDependencies(List<String> dependencies) {\n\t\treturn resolve(dependencies, true);\n\t}\n\t\n\tprivate Set<String> resolve(List<String> dependencies, boolean withDependencies) {\n\t\tQueue<String> toResolve = new UniqueQueue<>();\n\t\tfor (String dependency : dependencies) {\n\t\t\ttoResolve.add(dependency);\n\t\t}\n\t\tSet<Unit> resolved = new HashSet<>();\n\t\twhile (!toResolve.isEmpty()) {\n\t\t\tString next = toResolve.poll();\n\t\t\t\n\t\t\tList<Unit> providedUnits = providesIndex.get(next);\n\t\t\t// Skip unknown\n\t\t\tif (providedUnits == null) {\n\t\t\t\tSystem.out.println(\"Skipping unknown unit \" + next);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// Remove a.jre.javase dependency\n\t\t\tList<Unit> filteredProvidedUnits = providedUnits.stream()\n\t\t\t\t.filter(u -> !u.id.equals(\"a.jre.javase\")) // Remove\n\t\t\t\t.collect(Collectors.toList());\n\t\t\t\n\t\t\tif (filteredProvidedUnits.size() == 0) {\n\t\t\t\t// This is a JDK only dependency, skip\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t// Skip ambiguous (we could use version ranges to solve that...)\n\t\t\tif (filteredProvidedUnits.size() > 1) {\n\t\t\t\tboolean alreadyResolved = filteredProvidedUnits.stream().anyMatch(resolved::contains);\n\t\t\t\tif (!alreadyResolved) {\n\t\t\t\t\tSystem.out.println(\"Ambiguous resolution for \" + next + \": \" + filteredProvidedUnits.toString());\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tUnit unit = filteredProvidedUnits.get(0);\n\t\t\tresolved.add(unit);\n\t\t\t\n\t\t\tif (withDependencies && unit.requires != null) {\n\t\t\t\tfor (Required required : unit.requires) {\n\t\t\t\t\tif (required.optional) continue;\n\t\t\t\t\tif (!matchesFilter(required.filter)) continue;\n\t\t\t\t\t\n\t\t\t\t\ttoResolve.add(required.namespace + \":\" + required.name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn resolved.stream().map(u -> u.toString() + \".jar\").collect(Collectors.toSet());\n\t}\n\t\n\t// Dummy implementation\n\tprivate boolean matchesFilter(String filter) {\n\t\tif (filter == null) {\n\t\t\treturn true;\n\t\t}\n\t\tif (filter.contains(\"osgi.arch=\") && !filter.contains(\"osgi.arch=\" + OSGI_ARCH)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (filter.contains(\"osgi.os=\") && !filter.contains(\"osgi.os=\" + OSGI_OS)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate String resolveNextChild(String currentUrl) throws MalformedURLException, IOException, JAXBException {\n\t\ttry (InputStream inputStream = readJarOrXml(currentUrl, \"compositeContent\")) {\n\t\t\tRepository repository = (Repository) jaxbContext.createUnmarshaller().unmarshal(inputStream);\n\t\t\tChild lastChild = repository.children.get(repository.children.size() - 1);\n\t\t\treturn lastChild.location;\n\t\t}\n\t}\n\t\n\tprivate InputStream readJarOrXml(String url, String name) throws MalformedURLException, IOException {\n\t\ttry {\n\t\t\treturn getStreamForUrl(url + \"/\" + name + \".xml\");\n\t\t} catch (FileNotFoundException e) {\n\t\t\tSystem.out.println(\"Not found, trying jar\");\n\t\t}\n\t\tZipInputStream zipInputStream = new ZipInputStream(getStreamForUrl(url + \"/\" + name + \".jar\"));\n\t\tZipEntry entry;\n\t\twhile ((entry = zipInputStream.getNextEntry()) != null) {\n\t\t\tif (entry.getName().equals(name + \".xml\")) {\n\t\t\t\treturn zipInputStream;\n\t\t\t}\n\t\t}\n\t\tthrow new FileNotFoundException();\n\t}\n\t\n\tprivate static InputStream getStreamForUrl(String url) throws IOException, MalformedURLException {\n\t\tSystem.out.println(\"Reading \" + url);\n\t\tHttpURLConnection connection = (HttpURLConnection) new URL(url).openConnection();\n\t\tconnection.setRequestProperty(\"User-Agent\", \"lombok\");\n\t\tconnection.setRequestProperty(\"Accept\", \"*/*\");\n\t\tInputStream in = new BufferedInputStream(connection.getInputStream());\n\t\treturn in;\n\t}\n\n\tpublic String getResolvedUrl() {\n\t\treturn resolvedUrl;\n\t}\n}\n","lineNo":94}
{"Smelly Sample":"/*\n * Copyright (C) 2010-2021 The Project Lombok Authors.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage lombok.launch;\n\nimport static lombok.eclipse.EcjAugments.ASTNode_generatedBy;\nimport static lombok.eclipse.Eclipse.*;\n\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.security.CodeSource;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Stack;\n\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.jdt.core.IAnnotatable;\nimport org.eclipse.jdt.core.IAnnotation;\nimport org.eclipse.jdt.core.IField;\nimport org.eclipse.jdt.core.IJavaElement;\nimport org.eclipse.jdt.core.IMethod;\nimport org.eclipse.jdt.core.IType;\nimport org.eclipse.jdt.core.JavaModelException;\nimport org.eclipse.jdt.core.dom.AST;\nimport org.eclipse.jdt.core.dom.ASTNode;\nimport org.eclipse.jdt.core.dom.MethodDeclaration;\nimport org.eclipse.jdt.core.dom.Name;\nimport org.eclipse.jdt.core.dom.ReturnStatement;\nimport org.eclipse.jdt.core.dom.SimpleName;\nimport org.eclipse.jdt.core.dom.SingleVariableDeclaration;\nimport org.eclipse.jdt.core.dom.Type;\nimport org.eclipse.jdt.core.search.SearchMatch;\nimport org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.Annotation;\nimport org.eclipse.jdt.internal.compiler.ast.Expression;\nimport org.eclipse.jdt.internal.compiler.ast.FieldDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.LocalDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;\nimport org.eclipse.jdt.internal.compiler.lookup.BlockScope;\nimport org.eclipse.jdt.internal.compiler.lookup.TypeBinding;\nimport org.eclipse.jdt.internal.core.SourceField;\nimport org.eclipse.jdt.internal.core.dom.rewrite.NodeRewriteEvent;\nimport org.eclipse.jdt.internal.core.dom.rewrite.RewriteEvent;\nimport org.eclipse.jdt.internal.core.dom.rewrite.TokenScanner;\nimport org.eclipse.jdt.internal.corext.refactoring.SearchResultGroup;\nimport org.eclipse.jdt.internal.corext.refactoring.code.CallContext;\nimport org.eclipse.jdt.internal.corext.refactoring.code.SourceProvider;\nimport org.eclipse.jdt.internal.corext.refactoring.structure.MemberVisibilityAdjustor.IncomingMemberVisibilityAdjustment;\n\nimport lombok.permit.Permit;\n\n/** These contain a mix of the following:\n * <ul>\n * <li> 'dependency free' method wrappers that cross the shadowloader barrier.\n * <li> methods that directly patch, <em>but<\/em>, these should ALWAYS be transplanted.\n * <\/ul>\n * \n * <strong>This class lives on the outside of the shadowloader barrier, and as a consequence, cannot access any other lombok code except other\n * code in the {@code lombok.launch} package!<\/strong>.\n * <p>\n * This class is package private with lots of public inner static classes. This hides all of them from IDE autocomplete dialogs and such but at the JVM\n * level the inner static class are just plain public, which is important, because calls to the contents of these inner static classes are injected into\n * various eclipse classes verbatim, and if they weren't public, the verifier wouldn't accept it.\n */\nfinal class PatchFixesHider {\n\t\n\t/** These utility methods are only used 'internally', but because of transplant methods, the class (and its methods) still have to be public! */\n\tpublic static final class Util {\n\t\tprivate static ClassLoader shadowLoader;\n\t\t\n\t\tpublic static ClassLoader getShadowLoader() {\n\t\t\tif (shadowLoader == null) {\n\t\t\t\ttry {\n\t\t\t\t\tClass.forName(\"lombok.core.LombokNode\");\n\t\t\t\t\t// If we get here, then lombok is already available.\n\t\t\t\t\tshadowLoader = Util.class.getClassLoader();\n\t\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\t\t// If we get here, it isn't, and we should use the shadowloader.\n\t\t\t\t\tshadowLoader = Main.getShadowClassLoader();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn shadowLoader;\n\t\t}\n\t\t\n\t\tpublic static Class<?> shadowLoadClass(String name) {\n\t\t\ttry {\n\t\t\t\treturn Class.forName(name, true, getShadowLoader());\n\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\tthrow sneakyThrow(e);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static Method findMethod(Class<?> type, String name, Class<?>... parameterTypes) {\n\t\t\ttry {\n\t\t\t\treturn type.getDeclaredMethod(name, parameterTypes);\n\t\t\t} catch (NoSuchMethodException e) {\n\t\t\t\tthrow sneakyThrow(e);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static Method findMethod(Class<?> type, String name, String... parameterTypes) {\n\t\t\tfor (Method m : type.getDeclaredMethods()) {\n\t\t\t\tif (name.equals(m.getName()) && sameTypes(m.getParameterTypes(), parameterTypes)) {\n\t\t\t\t\treturn m;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow sneakyThrow(new NoSuchMethodException(type.getName() + \"::\" + name));\n\t\t}\n\t\t\n\t\tpublic static Method findMethodAnyArgs(Class<?> type, String name) {\n\t\t\tfor (Method m : type.getDeclaredMethods()) if (name.equals(m.getName())) return m;\n\t\t\tthrow sneakyThrow(new NoSuchMethodException(type.getName() + \"::\" + name));\n\t\t}\n\t\t\n\t\tpublic static Object invokeMethod(Method method, Object... args) {\n\t\t\ttry {\n\t\t\t\treturn method.invoke(null, args);\n\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\tthrow sneakyThrow(e);\n\t\t\t} catch (InvocationTargetException e) {\n\t\t\t\tthrow sneakyThrow(e.getCause());\n\t\t\t}\n\t\t}\n\t\t\n\t\tprivate static RuntimeException sneakyThrow(Throwable t) {\n\t\t\tif (t == null) throw new NullPointerException(\"t\");\n\t\t\tUtil.<RuntimeException>sneakyThrow0(t);\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tprivate static <T extends Throwable> void sneakyThrow0(Throwable t) throws T {\n\t\t\tthrow (T)t;\n\t\t}\n\t\t\n\t\tprivate static boolean sameTypes(Class<?>[] types, String[] typeNames) {\n\t\t\tif (types.length != typeNames.length) return false;\n\t\t\tfor (int i = 0; i < types.length; i++) {\n\t\t\t\tif (!types[i].getName().equals(typeNames[i])) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\t/** Contains patch fixes that are dependent on lombok internals. */\n\tpublic static final class LombokDeps {\n\t\tpublic static final Method ADD_LOMBOK_NOTES;\n\t\tpublic static final Method POST_COMPILER_BYTES_STRING;\n\t\tpublic static final Method POST_COMPILER_OUTPUTSTREAM;\n\t\tpublic static final Method POST_COMPILER_BUFFEREDOUTPUTSTREAM_STRING_STRING;\n\t\t\n\t\tstatic {\n\t\t\tClass<?> shadowed = Util.shadowLoadClass(\"lombok.eclipse.agent.PatchFixesShadowLoaded\");\n\t\t\tADD_LOMBOK_NOTES = Util.findMethod(shadowed, \"addLombokNotesToEclipseAboutDialog\", String.class, String.class);\n\t\t\tPOST_COMPILER_BYTES_STRING = Util.findMethod(shadowed, \"runPostCompiler\", byte[].class, String.class);\n\t\t\tPOST_COMPILER_OUTPUTSTREAM = Util.findMethod(shadowed, \"runPostCompiler\", OutputStream.class);\n\t\t\tPOST_COMPILER_BUFFEREDOUTPUTSTREAM_STRING_STRING = Util.findMethod(shadowed, \"runPostCompiler\", BufferedOutputStream.class, String.class, String.class);\n\t\t}\n\t\t\n\t\tpublic static String addLombokNotesToEclipseAboutDialog(String origReturnValue, String key) {\n\t\t\ttry {\n\t\t\t\treturn (String) Util.invokeMethod(LombokDeps.ADD_LOMBOK_NOTES, origReturnValue, key);\n\t\t\t} catch (Throwable t) {\n\t\t\t\treturn origReturnValue;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static byte[] runPostCompiler(byte[] bytes, String fileName) {\n\t\t\treturn (byte[]) Util.invokeMethod(LombokDeps.POST_COMPILER_BYTES_STRING, bytes, fileName);\n\t\t}\n\t\t\n\t\tpublic static OutputStream runPostCompiler(OutputStream out) throws IOException {\n\t\t\treturn (OutputStream) Util.invokeMethod(LombokDeps.POST_COMPILER_OUTPUTSTREAM, out);\n\t\t}\n\t\t\n\t\tpublic static BufferedOutputStream runPostCompiler(BufferedOutputStream out, String path, String name) throws IOException {\n\t\t\treturn (BufferedOutputStream) Util.invokeMethod(LombokDeps.POST_COMPILER_BUFFEREDOUTPUTSTREAM_STRING_STRING, out, path, name);\n\t\t}\n\t}\n\t\n\tpublic static final class Transform {\n\t\tprivate static Method TRANSFORM;\n\t\tprivate static Method TRANSFORM_SWAPPED;\n\t\t\n\t\tprivate static synchronized void init(ClassLoader prepend) {\n\t\t\tif (TRANSFORM != null) return;\n\t\t\t\n\t\t\tprependClassLoader(prepend);\n\t\t\tif (!prepend.toString().contains(\"org.eclipse.jdt.core:\")) {\n\t\t\t\tClassLoader jdtCoreClassLoader = findJdtCoreClassLoader(prepend);\n\t\t\t\tprependClassLoader(jdtCoreClassLoader);\n\t\t\t}\n\t\t\tClass<?> shadowed = Util.shadowLoadClass(\"lombok.eclipse.TransformEclipseAST\");\n\t\t\tTRANSFORM = Util.findMethodAnyArgs(shadowed, \"transform\");\n\t\t\tTRANSFORM_SWAPPED = Util.findMethodAnyArgs(shadowed, \"transform_swapped\");\n\t\t}\n\t\t\n\t\tprivate static void prependClassLoader(ClassLoader classLoader) {\n\t\t\tMain.prependClassLoader(classLoader);\n\t\t\ttry {\n\t\t\t\tClassLoader currentClassLoader = Transform.class.getClassLoader();\n\t\t\t\t\n\t\t\t\tMethod prependParentMethod = Permit.getMethod(currentClassLoader.getClass(), \"prependParent\", ClassLoader.class);\n\t\t\t\tPermit.invoke(prependParentMethod, currentClassLoader, classLoader);\n\t\t\t} catch (Throwable t) {\n\t\t\t\t// Ignore\n\t\t\t}\n\t\t}\n\t\t\n\t\tprivate static ClassLoader findJdtCoreClassLoader(ClassLoader classLoader) {\n\t\t\ttry {\n\t\t\t\tMethod getBundleMethod = Permit.getMethod(classLoader.getClass(), \"getBundle\");\n\t\t\t\tObject bundle = Permit.invoke(getBundleMethod, classLoader);\n\t\t\t\t\n\t\t\t\tMethod getBundleContextMethod = Permit.getMethod(bundle.getClass(), \"getBundleContext\");\n\t\t\t\tObject bundleContext = Permit.invoke(getBundleContextMethod, bundle);\n\t\t\t\t\n\t\t\t\tMethod getBundlesMethod = Permit.getMethod(bundleContext.getClass(), \"getBundles\");\n\t\t\t\tObject[] bundles = (Object[]) Permit.invoke(getBundlesMethod, bundleContext);\n\t\t\t\t\n\t\t\t\tfor (Object searchBundle : bundles) {\n\t\t\t\t\tif (searchBundle.toString().startsWith(\"org.eclipse.jdt.core_\")) {\n\t\t\t\t\t\tMethod getModuleClassLoaderMethod = Permit.getMethod(searchBundle.getClass(), \"getModuleClassLoader\", boolean.class);\n\t\t\t\t\t\treturn (ClassLoader) Permit.invoke(getModuleClassLoaderMethod, searchBundle, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (Throwable t) {\n\t\t\t\t// Ignore\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tpublic static void transform(Object parser, Object ast) throws IOException {\n\t\t\tinit(parser.getClass().getClassLoader());\n\t\t\tUtil.invokeMethod(TRANSFORM, parser, ast);\n\t\t}\n\t\t\n\t\tpublic static void transform_swapped(Object ast, Object parser) throws IOException {\n\t\t\tinit(parser.getClass().getClassLoader());\n\t\t\tUtil.invokeMethod(TRANSFORM_SWAPPED, ast, parser);\n\t\t}\n\t}\n\t\n\t/** Contains patch code to support {@code @Delegate} */\n\tpublic static final class Delegate {\n\t\tprivate static final Method HANDLE_DELEGATE_FOR_TYPE;\n\t\tprivate static final Method ADD_GENERATED_DELEGATE_METHODS;\n\t\t\n\t\tstatic {\n\t\t\tClass<?> shadowed = Util.shadowLoadClass(\"lombok.eclipse.agent.PatchDelegatePortal\");\n\t\t\tHANDLE_DELEGATE_FOR_TYPE = Util.findMethod(shadowed, \"handleDelegateForType\", Object.class);\n\t\t\tADD_GENERATED_DELEGATE_METHODS = Util.findMethod(shadowed, \"addGeneratedDelegateMethods\", Object.class, Object.class);\n\t\t}\n\t\t\n\t\tpublic static boolean handleDelegateForType(Object classScope) {\n\t\t\treturn (Boolean) Util.invokeMethod(HANDLE_DELEGATE_FOR_TYPE, classScope);\n\t\t}\n\t\t\n\t\tpublic static Object[] addGeneratedDelegateMethods(Object returnValue, Object javaElement) {\n\t\t\treturn (Object[]) Util.invokeMethod(ADD_GENERATED_DELEGATE_METHODS, returnValue, javaElement);\n\t\t}\n\t}\n\t\n\t/** Contains patch code to support {@code val} (eclipse specific) */\n\tpublic static final class ValPortal {\n\t\tprivate static final Method COPY_INITIALIZATION_OF_FOR_EACH_ITERABLE;\n\t\tprivate static final Method COPY_INITIALIZATION_OF_LOCAL_DECLARATION;\n\t\tprivate static final Method ADD_FINAL_AND_VAL_ANNOTATION_TO_VARIABLE_DECLARATION_STATEMENT;\n\t\tprivate static final Method ADD_FINAL_AND_VAL_ANNOTATION_TO_SINGLE_VARIABLE_DECLARATION;\n\t\t\n\t\tstatic {\n\t\t\tClass<?> shadowed = Util.shadowLoadClass(\"lombok.eclipse.agent.PatchValEclipsePortal\");\n\t\t\tCOPY_INITIALIZATION_OF_FOR_EACH_ITERABLE = Util.findMethod(shadowed, \"copyInitializationOfForEachIterable\", Object.class);\n\t\t\tCOPY_INITIALIZATION_OF_LOCAL_DECLARATION = Util.findMethod(shadowed, \"copyInitializationOfLocalDeclaration\", Object.class);\n\t\t\tADD_FINAL_AND_VAL_ANNOTATION_TO_VARIABLE_DECLARATION_STATEMENT = Util.findMethod(shadowed, \"addFinalAndValAnnotationToVariableDeclarationStatement\", Object.class, Object.class, Object.class);\n\t\t\tADD_FINAL_AND_VAL_ANNOTATION_TO_SINGLE_VARIABLE_DECLARATION = Util.findMethod(shadowed, \"addFinalAndValAnnotationToSingleVariableDeclaration\", Object.class, Object.class, Object.class);\n\t\t}\n\n\t\tpublic static void copyInitializationOfForEachIterable(Object parser) {\n\t\t\tUtil.invokeMethod(COPY_INITIALIZATION_OF_FOR_EACH_ITERABLE, parser);\n\t\t}\n\t\t\n\t\tpublic static void copyInitializationOfLocalDeclaration(Object parser) {\n\t\t\tUtil.invokeMethod(COPY_INITIALIZATION_OF_LOCAL_DECLARATION, parser);\n\t\t}\n\t\t\n\t\tpublic static void addFinalAndValAnnotationToVariableDeclarationStatement(Object converter, Object out, Object in) {\n\t\t\tUtil.invokeMethod(ADD_FINAL_AND_VAL_ANNOTATION_TO_VARIABLE_DECLARATION_STATEMENT, converter, out, in);\n\t\t}\n\t\t\n\t\tpublic static void addFinalAndValAnnotationToSingleVariableDeclaration(Object converter, Object out, Object in) {\n\t\t\tUtil.invokeMethod(ADD_FINAL_AND_VAL_ANNOTATION_TO_SINGLE_VARIABLE_DECLARATION, converter, out, in);\n\t\t}\n\t}\n\t\n\t/** Contains patch code to support {@code val} (eclipse and ecj) */\n\tpublic static final class Val {\n\t\tprivate static final String BLOCK_SCOPE_SIG = \"org.eclipse.jdt.internal.compiler.lookup.BlockScope\";\n\t\tprivate static final String LOCAL_DECLARATION_SIG = \"org.eclipse.jdt.internal.compiler.ast.LocalDeclaration\";\n\t\tprivate static final String FOREACH_STATEMENT_SIG = \"org.eclipse.jdt.internal.compiler.ast.ForeachStatement\";\n\t\t\n\t\tprivate static final Method HANDLE_VAL_FOR_LOCAL_DECLARATION;\n\t\tprivate static final Method HANDLE_VAL_FOR_FOR_EACH;\n\t\t\n\t\tstatic {\n\t\t\tClass<?> shadowed = Util.shadowLoadClass(\"lombok.eclipse.agent.PatchVal\");\n\t\t\tHANDLE_VAL_FOR_LOCAL_DECLARATION = Util.findMethod(shadowed, \"handleValForLocalDeclaration\", LOCAL_DECLARATION_SIG, BLOCK_SCOPE_SIG);\n\t\t\tHANDLE_VAL_FOR_FOR_EACH = Util.findMethod(shadowed, \"handleValForForEach\", FOREACH_STATEMENT_SIG, BLOCK_SCOPE_SIG);\n\t\t}\n\t\t\n\t\tpublic static boolean handleValForLocalDeclaration(Object local, Object scope) {\n\t\t\treturn (Boolean) Util.invokeMethod(HANDLE_VAL_FOR_LOCAL_DECLARATION, local, scope);\n\t\t}\n\t\t\n\t\tpublic static boolean handleValForForEach(Object forEach, Object scope) {\n\t\t\treturn (Boolean) Util.invokeMethod(HANDLE_VAL_FOR_FOR_EACH, forEach, scope);\n\t\t}\n\t\t\n\t\t/** \n\t\t * Patches local declaration to not call .resolveType() on the initializer expression if we've already done so (calling it twice causes weird errors) \n\t\t * This and the next method must be transplanted so that the return type is loaded in the correct class loader\n\t\t */\n\t\tpublic static TypeBinding skipResolveInitializerIfAlreadyCalled(Expression expr, BlockScope scope) {\n\t\t\tif (expr.resolvedType != null) return expr.resolvedType;\n\t\t\ttry {\n\t\t\t\treturn expr.resolveType(scope);\n\t\t\t} catch (NullPointerException e) {\n\t\t\t\treturn null;\n\t\t\t} catch (ArrayIndexOutOfBoundsException e) {\n\t\t\t\t// This will occur internally due to for example 'val x = mth(\"X\");', where mth takes 2 arguments.\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static TypeBinding skipResolveInitializerIfAlreadyCalled2(Expression expr, BlockScope scope, LocalDeclaration decl) {\n\t\t\tif (decl != null && LocalDeclaration.class.equals(decl.getClass()) && expr.resolvedType != null) return expr.resolvedType;\n\t\t\ttry {\n\t\t\t\treturn expr.resolveType(scope);\n\t\t\t} catch (NullPointerException e) {\n\t\t\t\treturn null;\n\t\t\t} catch (ArrayIndexOutOfBoundsException e) {\n\t\t\t\t// This will occur internally due to for example 'val x = mth(\"X\");', where mth takes 2 arguments.\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/** Contains patch code to support {@code @ExtensionMethod} */\n\tpublic static final class ExtensionMethod {\n\t\tprivate static final String MESSAGE_SEND_SIG = \"org.eclipse.jdt.internal.compiler.ast.MessageSend\";\n\t\tprivate static final String TYPE_BINDING_SIG = \"org.eclipse.jdt.internal.compiler.lookup.TypeBinding\";\n\t\tprivate static final String SCOPE_SIG = \"org.eclipse.jdt.internal.compiler.lookup.Scope\";\n\t\tprivate static final String BLOCK_SCOPE_SIG = \"org.eclipse.jdt.internal.compiler.lookup.BlockScope\";\n\t\tprivate static final String TYPE_BINDINGS_SIG = \"[Lorg.eclipse.jdt.internal.compiler.lookup.TypeBinding;\";\n\t\tprivate static final String PROBLEM_REPORTER_SIG = \"org.eclipse.jdt.internal.compiler.problem.ProblemReporter\";\n\t\tprivate static final String METHOD_BINDING_SIG = \"org.eclipse.jdt.internal.compiler.lookup.MethodBinding\";\n\t\tprivate static final String AST_NODE_SIG = \"org.eclipse.jdt.internal.compiler.ast.ASTNode\";\n\t\t\n\t\tprivate static final Method RESOLVE_TYPE;\n\t\tprivate static final Method ERROR_NO_METHOD_FOR;\n\t\tprivate static final Method INVALID_METHOD, INVALID_METHOD2;\n\t\tprivate static final Method NON_STATIC_ACCESS_TO_STATIC_METHOD;\n\t\tprivate static final Method MODIFY_METHOD_PATTERN;\n\t\t\n\t\tstatic {\n\t\t\tClass<?> shadowed = Util.shadowLoadClass(\"lombok.eclipse.agent.PatchExtensionMethod\");\n\t\t\tRESOLVE_TYPE = Util.findMethod(shadowed, \"resolveType\", TYPE_BINDING_SIG, MESSAGE_SEND_SIG, BLOCK_SCOPE_SIG);\n\t\t\tERROR_NO_METHOD_FOR = Util.findMethod(shadowed, \"errorNoMethodFor\", PROBLEM_REPORTER_SIG, MESSAGE_SEND_SIG, TYPE_BINDING_SIG, TYPE_BINDINGS_SIG);\n\t\t\tINVALID_METHOD = Util.findMethod(shadowed, \"invalidMethod\", PROBLEM_REPORTER_SIG, MESSAGE_SEND_SIG, METHOD_BINDING_SIG);\n\t\t\tINVALID_METHOD2 = Util.findMethod(shadowed, \"invalidMethod\", PROBLEM_REPORTER_SIG, MESSAGE_SEND_SIG, METHOD_BINDING_SIG, SCOPE_SIG);\n\t\t\tNON_STATIC_ACCESS_TO_STATIC_METHOD = Util.findMethod(shadowed, \"nonStaticAccessToStaticMethod\", PROBLEM_REPORTER_SIG, AST_NODE_SIG, METHOD_BINDING_SIG, MESSAGE_SEND_SIG);\n\t\t\tMODIFY_METHOD_PATTERN = Util.findMethod(shadowed, \"modifyMethodPattern\", Object.class);\n\t\t}\n\t\t\n\t\tpublic static Object resolveType(Object resolvedType, Object methodCall, Object scope) {\n\t\t\treturn Util.invokeMethod(RESOLVE_TYPE, resolvedType, methodCall, scope);\n\t\t}\n\t\t\n\t\tpublic static void errorNoMethodFor(Object problemReporter, Object messageSend, Object recType, Object params) {\n\t\t\tUtil.invokeMethod(ERROR_NO_METHOD_FOR, problemReporter, messageSend, recType, params);\n\t\t}\n\t\t\n\t\tpublic static void invalidMethod(Object problemReporter, Object messageSend, Object method) {\n\t\t\tUtil.invokeMethod(INVALID_METHOD, problemReporter, messageSend, method);\n\t\t}\n\t\t\n\t\tpublic static void invalidMethod(Object problemReporter, Object messageSend, Object method, Object scope) {\n\t\t\tUtil.invokeMethod(INVALID_METHOD2, problemReporter, messageSend, method, scope);\n\t\t}\n\t\t\n\t\tpublic static void nonStaticAccessToStaticMethod(Object problemReporter, Object location, Object method, Object messageSend) {\n\t\t\tUtil.invokeMethod(NON_STATIC_ACCESS_TO_STATIC_METHOD, problemReporter, location, method, messageSend);\n\t\t}\n\t\t\n\t\tpublic static Object modifyMethodPattern(Object original) {\n\t\t\treturn Util.invokeMethod(MODIFY_METHOD_PATTERN, original);\n\t\t}\n\t}\n\t\n\t/** Contains patch code to support Javadoc for generated methods */\n\tpublic static final class Javadoc {\n\t\tprivate static final Method GET_HTML;\n\t\tprivate static final Method PRINT_METHOD;\n\t\t\n\t\tstatic {\n\t\t\tClass<?> shadowed = Util.shadowLoadClass(\"lombok.eclipse.agent.PatchJavadoc\");\n\t\t\tGET_HTML = Util.findMethod(shadowed, \"getHTMLContentFromSource\", String.class, Object.class);\n\t\t\tPRINT_METHOD = Util.findMethod(shadowed, \"printMethod\", AbstractMethodDeclaration.class, Integer.class, StringBuffer.class, TypeDeclaration.class);\n\t\t}\n\t\t\n\t\tpublic static String getHTMLContentFromSource(String original, IJavaElement member) {\n\t\t\treturn (String) Util.invokeMethod(GET_HTML, original, member);\n\t\t}\n\t\t\n\t\tpublic static StringBuffer printMethod(AbstractMethodDeclaration methodDeclaration, int tab, StringBuffer output, TypeDeclaration type) {\n\t\t\treturn (StringBuffer) Util.invokeMethod(PRINT_METHOD, methodDeclaration, tab, output, type);\n\t\t}\n\t}\n\t\n\t/**\n\t * Contains a mix of methods: ecj only, ecj+eclipse, and eclipse only. As a consequence, _EVERY_ method from here used for ecj MUST be\n\t * transplanted, as ecj itself cannot load this class (signatures refer to things that don't exist in ecj-only mode).\n\t * <p>\n\t * Because of usage of transplant(), a bunch of these contain direct code and don't try to cross the shadowloader barrier.\n\t */\n\tpublic static final class PatchFixes {\n\t\tpublic static boolean isGenerated(org.eclipse.jdt.core.dom.ASTNode node) {\n\t\t\tboolean result = false;\n\t\t\ttry {\n\t\t\t\tresult = ((Boolean)node.getClass().getField(\"$isGenerated\").get(node)).booleanValue();\n\t\t\t\tif (!result && node.getParent() != null && node.getParent() instanceof org.eclipse.jdt.core.dom.QualifiedName) {\n\t\t\t\t\tresult = isGenerated(node.getParent());\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\t// better to assume it isn't generated\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic static boolean isGenerated(org.eclipse.jdt.internal.compiler.ast.ASTNode node) {\n\t\t\tboolean result = false;\n\t\t\ttry {\n\t\t\t\tresult = node.getClass().getField(\"$generatedBy\").get(node) != null;\n\t\t\t} catch (Exception e) {\n\t\t\t\t// better to assume it isn't generated\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic static boolean isGenerated(org.eclipse.jdt.core.IMember member) {\n\t\t\tboolean result = false;\n\t\t\ttry {\n\t\t\t\tresult = member.getNameRange().getLength() <= 0 || member.getNameRange().equals(member.getSourceRange());\n\t\t\t} catch (JavaModelException e) {\n\t\t\t\t// better to assume it isn't generated\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\t\n\t\tpublic static boolean isBlockedVisitorAndGenerated(org.eclipse.jdt.core.dom.ASTNode node, org.eclipse.jdt.core.dom.ASTVisitor visitor) {\n\t\t\tif (visitor == null) return false;\n\t\t\t\n\t\t\tString className = visitor.getClass().getName();\n\t\t\tif (!(className.startsWith(\"org.eclipse.jdt.internal.corext.fix\") || className.startsWith(\"org.eclipse.jdt.internal.ui.fix\") || className.startsWith(\"org.eclipse.jdt.ls.core.internal.semantictokens.SemanticTokensVisitor\"))) return false;\n\t\t\tif (className.equals(\"org.eclipse.jdt.internal.corext.fix.VariableDeclarationFixCore$WrittenNamesFinder\")) return false;\n\t\t\t\n\t\t\treturn isGenerated(node);\n\t\t}\n\t\t\n\t\tpublic static boolean isListRewriteOnGeneratedNode(org.eclipse.jdt.core.dom.rewrite.ListRewrite rewrite) {\n\t\t\treturn isGenerated(rewrite.getParent());\n\t\t}\n\t\t\n\t\tpublic static boolean returnFalse(java.lang.Object object) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tpublic static boolean returnTrue(java.lang.Object object) {\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\t@java.lang.SuppressWarnings({\"unchecked\", \"rawtypes\"}) public static java.util.List removeGeneratedNodes(java.util.List list) {\n\t\t\ttry {\n\t\t\t\tjava.util.List realNodes = new java.util.ArrayList(list.size());\n\t\t\t\tfor (java.lang.Object node : list) {\n\t\t\t\t\tif(!isGenerated(((org.eclipse.jdt.core.dom.ASTNode)node))) {\n\t\t\t\t\t\trealNodes.add(node);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn realNodes;\n\t\t\t} catch (Exception e) {\n\t\t\t}\n\t\t\treturn list;\n\t\t}\n\t\t\n\t\tpublic static java.lang.String getRealMethodDeclarationSource(java.lang.String original, Object processor, org.eclipse.jdt.core.dom.MethodDeclaration declaration) throws Exception {\n\t\t\tif (!isGenerated(declaration)) return original;\n\t\t\t\n\t\t\tList<org.eclipse.jdt.core.dom.Annotation> annotations = new ArrayList<org.eclipse.jdt.core.dom.Annotation>();\n\t\t\tfor (Object modifier : declaration.modifiers()) {\n\t\t\t\tif (modifier instanceof org.eclipse.jdt.core.dom.Annotation) {\n\t\t\t\t\torg.eclipse.jdt.core.dom.Annotation annotation = (org.eclipse.jdt.core.dom.Annotation)modifier;\n\t\t\t\t\tString qualifiedAnnotationName = annotation.resolveTypeBinding().getQualifiedName();\n\t\t\t\t\tif (!\"java.lang.Override\".equals(qualifiedAnnotationName) && !\"java.lang.SuppressWarnings\".equals(qualifiedAnnotationName)) annotations.add(annotation);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tStringBuilder signature = new StringBuilder();\n\t\t\taddAnnotations(annotations, signature);\n\t\t\t\n\t\t\ttry {\n\t\t\t\tif ((Boolean)processor.getClass().getDeclaredField(\"fPublic\").get(processor)) signature.append(\"public \");\n\t\t\t\tif ((Boolean)processor.getClass().getDeclaredField(\"fAbstract\").get(processor)) signature.append(\"abstract \");\n\t\t\t} catch (Throwable t) { }\n\t\t\t\n\t\t\tsignature\n\t\t\t\t.append(declaration.getReturnType2().toString())\n\t\t\t\t.append(\" \").append(declaration.getName().getFullyQualifiedName())\n\t\t\t\t.append(\"(\");\n\t\t\t\n\t\t\tboolean first = true;\n\t\t\tfor (Object parameter : declaration.parameters()) {\n\t\t\t\tif (!first) signature.append(\", \");\n\t\t\t\tfirst = false;\n\t\t\t\t// We should also add the annotations of the parameters\n\t\t\t\tsignature.append(parameter);\n\t\t\t}\n\t\t\t\n\t\t\tsignature.append(\");\");\n\t\t\treturn signature.toString();\n\t\t}\n\t\t\n\t\t// part of getRealMethodDeclarationSource(...)\n\t\tpublic static void addAnnotations(List<org.eclipse.jdt.core.dom.Annotation> annotations, StringBuilder signature) {\n\t\t\t/*\n\t\t\t * We SHOULD be able to handle the following cases:\n\t\t\t * @Override\n\t\t\t * @Override()\n\t\t\t * @SuppressWarnings(\"all\")\n\t\t\t * @SuppressWarnings({\"all\", \"unused\"})\n\t\t\t * @SuppressWarnings(value = \"all\")\n\t\t\t * @SuppressWarnings(value = {\"all\", \"unused\"})\n\t\t\t * @EqualsAndHashCode(callSuper=true, of=\"id\")\n\t\t\t * \n\t\t\t * Currently, we only seem to correctly support:\n\t\t\t * @Override\n\t\t\t * @Override() N.B. We lose the parentheses here, since there are no values. No big deal.\n\t\t\t * @SuppressWarnings(\"all\")\n\t\t\t */\n\t\t\tfor (org.eclipse.jdt.core.dom.Annotation annotation : annotations) {\n\t\t\t\tList<String> values = new ArrayList<String>();\n\t\t\t\tif (annotation.isSingleMemberAnnotation()) {\n\t\t\t\t\torg.eclipse.jdt.core.dom.SingleMemberAnnotation smAnn = (org.eclipse.jdt.core.dom.SingleMemberAnnotation) annotation;\n\t\t\t\t\tvalues.add(smAnn.getValue().toString());\n\t\t\t\t} else if (annotation.isNormalAnnotation()) {\n\t\t\t\t\torg.eclipse.jdt.core.dom.NormalAnnotation normalAnn = (org.eclipse.jdt.core.dom.NormalAnnotation) annotation;\n\t\t\t\t\tfor (Object value : normalAnn.values()) values.add(value.toString());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tsignature.append(\"@\").append(annotation.getTypeName().getFullyQualifiedName());\n\t\t\t\tif (!values.isEmpty()) {\n\t\t\t\t\tsignature.append(\"(\");\n\t\t\t\t\tboolean first = true;\n\t\t\t\t\tfor (String string : values) {\n\t\t\t\t\t\tif (!first) signature.append(\", \");\n\t\t\t\t\t\tfirst = false;\n\t\t\t\t\t\tsignature.append('\"').append(string).append('\"');\n\t\t\t\t\t}\n\t\t\t\t\tsignature.append(\")\");\n\t\t\t\t}\n\t\t\t\tsignature.append(\" \");\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static org.eclipse.jdt.core.dom.MethodDeclaration getRealMethodDeclarationNode(org.eclipse.jdt.core.dom.MethodDeclaration original, org.eclipse.jdt.core.IMethod sourceMethod, org.eclipse.jdt.core.dom.CompilationUnit cuUnit) throws JavaModelException {\n\t\t\tif (!isGenerated(original)) return original;\n\t\t\t\n\t\t\tIType declaringType = sourceMethod.getDeclaringType();\n\t\t\tStack<IType> typeStack = new Stack<IType>();\n\t\t\twhile (declaringType != null) {\n\t\t\t\ttypeStack.push(declaringType);\n\t\t\t\tdeclaringType = declaringType.getDeclaringType();\n\t\t\t}\n\t\t\t\n\t\t\tIType rootType = typeStack.pop();\n\t\t\torg.eclipse.jdt.core.dom.AbstractTypeDeclaration typeDeclaration = findTypeDeclaration(rootType, cuUnit.types());\n\t\t\twhile (!typeStack.isEmpty() && typeDeclaration != null) {\n\t\t\t\ttypeDeclaration = findTypeDeclaration(typeStack.pop(), typeDeclaration.bodyDeclarations());\n\t\t\t}\n\t\t\t\n\t\t\tString targetMethodName = sourceMethod.getElementName();\n\t\t\tList<String> targetMethodParameterTypes = new ArrayList<String>();\n\t\t\tfor (String parameterType : sourceMethod.getParameterTypes()) {\n\t\t\t\ttargetMethodParameterTypes.add(org.eclipse.jdt.core.Signature.toString(parameterType));\n\t\t\t}\n\t\t\t\n\t\t\tif (typeStack.isEmpty() && typeDeclaration != null) {\n\t\t\t\tfor (Object declaration : typeDeclaration.bodyDeclarations()) {\n\t\t\t\t\tif (declaration instanceof org.eclipse.jdt.core.dom.MethodDeclaration) {\n\t\t\t\t\t\torg.eclipse.jdt.core.dom.MethodDeclaration methodDeclaration = (org.eclipse.jdt.core.dom.MethodDeclaration) declaration;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (!methodDeclaration.getName().toString().equals(targetMethodName)) continue;\n\t\t\t\t\t\tif (methodDeclaration.parameters().size() != targetMethodParameterTypes.size()) continue;\n\t\t\t\t\t\tif (!isGenerated(methodDeclaration)) continue;\n\t\t\t\t\t\t\n\t\t\t\t\t\tboolean parameterTypesEquals = true;\n\t\t\t\t\t\tfor (int i = 0; i < methodDeclaration.parameters().size(); i++) {\n\t\t\t\t\t\t\tSingleVariableDeclaration variableDeclaration = (SingleVariableDeclaration) methodDeclaration.parameters().get(i);\n\t\t\t\t\t\t\tif (!variableDeclaration.getType().toString().equals(targetMethodParameterTypes.get(i))) {\n\t\t\t\t\t\t\t\tparameterTypesEquals = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (parameterTypesEquals) {\n\t\t\t\t\t\t\treturn methodDeclaration;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn original;\n\t\t}\n\t\t\n\t\t// part of getRealMethodDeclarationNode\n\t\tpublic static org.eclipse.jdt.core.dom.AbstractTypeDeclaration findTypeDeclaration(IType searchType, List<?> nodes) {\n\t\t\tfor (Object object : nodes) {\n\t\t\t\tif (object instanceof org.eclipse.jdt.core.dom.AbstractTypeDeclaration) {\n\t\t\t\t\torg.eclipse.jdt.core.dom.AbstractTypeDeclaration typeDeclaration = (org.eclipse.jdt.core.dom.AbstractTypeDeclaration) object;\n\t\t\t\t\tif (typeDeclaration.getName().toString().equals(searchType.getElementName()))\n\t\t\t\t\t\treturn typeDeclaration;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tpublic static int getSourceEndFixed(int sourceEnd, org.eclipse.jdt.internal.compiler.ast.ASTNode node) throws Exception {\n\t\t\tif (sourceEnd == -1) {\n\t\t\t\torg.eclipse.jdt.internal.compiler.ast.ASTNode object = (org.eclipse.jdt.internal.compiler.ast.ASTNode)node.getClass().getField(\"$generatedBy\").get(node);\n\t\t\t\tif (object != null) {\n\t\t\t\t\treturn object.sourceEnd;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn sourceEnd;\n\t\t}\n\t\t\n\t\tpublic static int fixRetrieveStartingCatchPosition(int original, int start) {\n\t\t\treturn original == -1 ? start : original;\n\t\t}\n\t\t\n\t\tpublic static int fixRetrieveIdentifierEndPosition(int original, int start, int end) {\n\t\t\tif (original == -1) return end;\n\t\t\tif (original < start) return end;\n\t\t\treturn original;\n\t\t}\n\t\t\n\t\tpublic static int fixRetrieveEllipsisStartPosition(int original, int end) {\n\t\t\treturn original == -1 ? end : original;\n\t\t}\n\t\t\n\t\tpublic static int fixRetrieveStartBlockPosition(int original, int start) {\n\t\t\treturn original == -1 ? start : original;\n\t\t}\n\t\t\n\t\tpublic static int fixRetrieveRightBraceOrSemiColonPosition(int original, int end) {\n//\t\t\tif (original == -1) {\n//\t\t\t\tThread.dumpStack();\n//\t\t\t}\n\t\t\t return original == -1 ? end : original;\n\t\t}\n\t\t\n\t\tpublic static int fixRetrieveRightBraceOrSemiColonPosition(int retVal, AbstractMethodDeclaration amd) {\n\t\t\tif (retVal != -1 || amd == null) return retVal;\n\t\t\tboolean isGenerated = ASTNode_generatedBy.get(amd) != null;\n\t\t\tif (isGenerated) return amd.declarationSourceEnd;\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tpublic static int fixRetrieveRightBraceOrSemiColonPosition(int retVal, FieldDeclaration fd) {\n\t\t\tif (retVal != -1 || fd == null) return retVal;\n\t\t\tboolean isGenerated = ASTNode_generatedBy.get(fd) != null;\n\t\t\tif (isGenerated) return fd.declarationSourceEnd;\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tpublic static int fixRetrieveProperRightBracketPosition(int retVal, Type type) {\n\t\t\tif (retVal != -1 || type == null) return retVal;\n\t\t\tif (isGenerated(type)) return type.getStartPosition() + type.getLength() - 1;\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tpublic static final int ALREADY_PROCESSED_FLAG = 0x800000;  //Bit 24\n\t\t\n\t\tpublic static boolean checkBit24(Object node) throws Exception {\n\t\t\tint bits = (Integer)(node.getClass().getField(\"bits\").get(node));\n\t\t\treturn (bits & ALREADY_PROCESSED_FLAG) != 0;\n\t\t}\n\t\t\n\t\tpublic static boolean skipRewritingGeneratedNodes(org.eclipse.jdt.core.dom.ASTNode node) throws Exception {\n\t\t\treturn ((Boolean) node.getClass().getField(\"$isGenerated\").get(node)).booleanValue();\n\t\t}\n\t\t\n\t\tpublic static void setIsGeneratedFlag(org.eclipse.jdt.core.dom.ASTNode domNode,\n\t\t\t\torg.eclipse.jdt.internal.compiler.ast.ASTNode internalNode) throws Exception {\n\t\t\t\n\t\t\tif (internalNode == null || domNode == null) return;\n\t\t\tboolean isGenerated = ASTNode_generatedBy.get(internalNode) != null;\n\t\t\tif (isGenerated) domNode.getClass().getField(\"$isGenerated\").set(domNode, true);\n\t\t}\n\t\t\n\t\tpublic static void setIsGeneratedFlagForName(org.eclipse.jdt.core.dom.Name name, Object internalNode) throws Exception {\n\t\t\tif (internalNode instanceof org.eclipse.jdt.internal.compiler.ast.ASTNode) {\n\t\t\t\tboolean isGenerated = ASTNode_generatedBy.get((org.eclipse.jdt.internal.compiler.ast.ASTNode) internalNode) != null;\n\t\t\t\tif (isGenerated) name.getClass().getField(\"$isGenerated\").set(name, true);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static RewriteEvent[] listRewriteHandleGeneratedMethods(RewriteEvent parent) {\n\t\t\tRewriteEvent[] children = parent.getChildren();\n\t\t\tList<RewriteEvent> newChildren = new ArrayList<RewriteEvent>();\n\t\t\tList<RewriteEvent> modifiedChildren = new ArrayList<RewriteEvent>();\n\t\t\tfor (int i = 0; i < children.length; i++) {\n\t\t\t\tRewriteEvent child = children[i];\n\t\t\t\tboolean isGenerated = isGenerated((org.eclipse.jdt.core.dom.ASTNode) child.getOriginalValue());\n\t\t\t\tif (isGenerated) {\n\t\t\t\t\tboolean isReplacedOrRemoved = child.getChangeKind() == RewriteEvent.REPLACED || child.getChangeKind() == RewriteEvent.REMOVED;\n\t\t\t\t\tboolean convertingFromMethod = child.getOriginalValue() instanceof org.eclipse.jdt.core.dom.MethodDeclaration;\n\t\t\t\t\tif (isReplacedOrRemoved && convertingFromMethod && child.getNewValue() != null) {\n\t\t\t\t\t\tmodifiedChildren.add(new NodeRewriteEvent(null, child.getNewValue()));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnewChildren.add(child);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Since Eclipse doesn't honor the \"insert at specified location\" for already existing members,\n\t\t\t// we'll just add them last\n\t\t\tnewChildren.addAll(modifiedChildren);\n\t\t\treturn newChildren.toArray(new RewriteEvent[0]);\n\t\t}\n\t\t\n\t\tpublic static int getTokenEndOffsetFixed(TokenScanner scanner, int token, int startOffset, Object domNode) throws CoreException {\n\t\t\tboolean isGenerated = false;\n\t\t\ttry {\n\t\t\t\tisGenerated = (Boolean) domNode.getClass().getField(\"$isGenerated\").get(domNode);\n\t\t\t} catch (Exception e) {\n\t\t\t\t// If this fails, better to break some refactor scripts than to crash eclipse.\n\t\t\t}\n\t\t\tif (isGenerated) return -1;\n\t\t\treturn scanner.getTokenEndOffset(token, startOffset);\n\t\t}\n\t\t\n\t\tpublic static IMethod[] removeGeneratedMethods(IMethod[] methods) throws Exception {\n\t\t\tList<IMethod> result = new ArrayList<IMethod>();\n\t\t\tfor (IMethod m : methods) {\n\t\t\t\tif (!isGenerated(m)) result.add(m);\n\t\t\t}\n\t\t\treturn result.size() == methods.length ? methods : result.toArray(new IMethod[0]);\n\t\t}\n\t\t\n\t\tpublic static SearchMatch[] removeGenerated(SearchMatch[] returnValue) {\n\t\t\tList<SearchMatch> result = new ArrayList<SearchMatch>();\n\t\t\tfor (int j = 0; j < returnValue.length; j++) {\n\t\t\t\tSearchMatch searchResult = returnValue[j];\n\t\t\t\tif (searchResult.getElement() instanceof IField) {\n\t\t\t\t\tIField field = (IField) searchResult.getElement();\n\t\t\t\t\t\n\t\t\t\t\t// can not check for value=lombok because annotation is\n\t\t\t\t\t// not fully resolved\n\t\t\t\t\tIAnnotation annotation = field.getAnnotation(\"Generated\");\n\t\t\t\t\tif (annotation != null) {\n\t\t\t\t\t\t// Method generated at field location, skip\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tresult.add(searchResult);\n\t\t\t}\n\t\t\treturn result.toArray(new SearchMatch[0]);\n\t\t}\n\t\t\n\t\tpublic static SearchResultGroup[] createFakeSearchResult(SearchResultGroup[] returnValue,\n\t\t\t\tObject/*\n\t\t\t\t\t\t * org.eclipse.jdt.internal.corext.refactoring.rename.\n\t\t\t\t\t\t * RenameFieldProcessor\n\t\t\t\t\t\t */ processor) throws Exception {\n\t\t\tif (returnValue == null || returnValue.length == 0) {\n\t\t\t\t// if no matches were found, check if Data annotation is present on the class\n\t\t\t\tField declaredField = processor.getClass().getDeclaredField(\"fField\");\n\t\t\t\tif (declaredField != null) {\n\t\t\t\t\tdeclaredField.setAccessible(true);\n\t\t\t\t\tSourceField fField = (SourceField) declaredField.get(processor);\n\t\t\t\t\tIAnnotation dataAnnotation = fField.getDeclaringType().getAnnotation(\"Data\");\n\t\t\t\t\tif (dataAnnotation != null) {\n\t\t\t\t\t\t// add fake item, to make refactoring checks pass\n\t\t\t\t\t\treturn new SearchResultGroup[] {new SearchResultGroup(null, new SearchMatch[1])};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn returnValue;\n\t\t}\n\t\t\n\t\tpublic static SimpleName[] removeGeneratedSimpleNames(SimpleName[] in) throws Exception {\n\t\t\tField f = SimpleName.class.getField(\"$isGenerated\");\n\t\t\t\n\t\t\tint count = 0;\n\t\t\tfor (int i = 0; i < in.length; i++) {\n\t\t\t\tif (in[i] == null || !((Boolean)f.get(in[i])).booleanValue()) count++;\n\t\t\t}\n\t\t\tif (count == in.length) return in;\n\t\t\tSimpleName[] newSimpleNames = new SimpleName[count];\n\t\t\tcount = 0;\n\t\t\tfor (int i = 0; i < in.length; i++) {\n\t\t\t\tif (in[i] == null || !((Boolean)f.get(in[i])).booleanValue()) newSimpleNames[count++] = in[i];\n\t\t\t}\n\t\t\treturn newSimpleNames;\n\t\t}\n\t\t\n\t\tpublic static Name[] removeGeneratedNames(Name[] in) throws Exception {\n\t\t\tField f = Name.class.getField(\"$isGenerated\");\n\t\t\t\n\t\t\tint count = 0;\n\t\t\tfor (int i = 0; i < in.length; i++) {\n\t\t\t\tif (in[i] == null || !((Boolean)f.get(in[i])).booleanValue()) count++;\n\t\t\t}\n\t\t\tif (count == in.length) return in;\n\t\t\tName[] newNames = new Name[count];\n\t\t\tcount = 0;\n\t\t\tfor (int i = 0; i < in.length; i++) {\n\t\t\t\tif (in[i] == null || !((Boolean)f.get(in[i])).booleanValue()) newNames[count++] = in[i];\n\t\t\t}\n\t\t\treturn newNames;\n\t\t}\n\t\t\n\t\tpublic static Annotation[] convertAnnotations(Annotation[] out, IAnnotatable annotatable) {\n\t\t\tIAnnotation[] in;\n\t\t\t\n\t\t\ttry {\n\t\t\t\tin = annotatable.getAnnotations();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn out;\n\t\t\t}\n\t\t\t\n\t\t\tif (out == null) return null;\n\t\t\tint toWrite = 0;\n\t\t\t\n\t\t\tfor (int idx = 0; idx < out.length; idx++) {\n\t\t\t\tString oName = new String(out[idx].type.getLastToken());\n\t\t\t\tboolean found = false;\n\t\t\t\tfor (IAnnotation i : in) {\n\t\t\t\t\tString name = i.getElementName();\n\t\t\t\t\tint li = name.lastIndexOf('.');\n\t\t\t\t\tif (li > -1) name = name.substring(li + 1);\n\t\t\t\t\tif (name.equals(oName)) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) out[idx] = null;\n\t\t\t\telse toWrite++;\n\t\t\t}\n\t\t\t\n\t\t\tAnnotation[] replace = out;\n\t\t\tif (toWrite < out.length) {\n\t\t\t\treplace = new Annotation[toWrite];\n\t\t\t\tint idx = 0;\n\t\t\t\tfor (int i = 0; i < out.length; i++) {\n\t\t\t\t\tif (out[i] == null) continue;\n\t\t\t\t\treplace[idx++] = out[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn replace;\n\t\t}\n\t\t\n\t\tpublic static String getRealNodeSource(String original, org.eclipse.jdt.internal.compiler.ast.ASTNode node) {\n\t\t\tif (!isGenerated(node)) return original;\n\t\t\t\n\t\t\treturn node.toString();\n\t\t}\n\t\t\n\t\tpublic static java.lang.String getRealNodeSource(java.lang.String original, org.eclipse.jdt.core.dom.ASTNode node) throws Exception {\n\t\t\tif (!isGenerated(node)) return original;\n\t\t\t\n\t\t\treturn node.toString();\n\t\t}\n\t\t\n\t\tpublic static boolean skipRewriteVisibility(IncomingMemberVisibilityAdjustment adjustment) {\n\t\t\treturn isGenerated(adjustment.getMember());\n\t\t}\n\t\t\n\t\tpublic static String[] getRealCodeBlocks(String[] blocks, SourceProvider sourceProvider, CallContext callContext) {\n\t\t\tMethodDeclaration methodDeclaration = sourceProvider.getDeclaration();\n\t\t\tif (!isGenerated(methodDeclaration)) {\n\t\t\t\treturn blocks;\n\t\t\t}\n\t\t\t\n\t\t\ttry {\n\t\t\t\t// Replace parameter references with actual argument\n\t\t\t\tAST ast = methodDeclaration.getAST();\n\t\t\t\tfor (Object param : methodDeclaration.parameters()) {\n\t\t\t\t\tObject data = ((SingleVariableDeclaration)param).getProperty(\"org.eclipse.jdt.internal.corext.refactoring.code.ParameterData\");\n\t\t\t\t\tList<SimpleName> names = Permit.get(Permit.permissiveGetField(data.getClass(), \"fReferences\"), data);\n\t\t\t\t\t\n\t\t\t\t\tfor (SimpleName simpleName : names) {\n\t\t\t\t\t\tASTNode copy = ASTNode.copySubtree(ast, callContext.arguments[0]);\n\t\t\t\t\t\tsimpleName.getParent().setStructuralProperty(simpleName.getLocationInParent(), copy);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Convert AST to source\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tfor (Object statement : methodDeclaration.getBody().statements()) {\n\t\t\t\t\tif (callContext.callMode != ASTNode.RETURN_STATEMENT && statement instanceof ReturnStatement) {\n\t\t\t\t\t\tReturnStatement returnStatement = (ReturnStatement) statement;\n\t\t\t\t\t\tsb.append(returnStatement.getExpression());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsb.append(statement);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn new String[] {sb.toString().trim()};\n\t\t\t} catch (Throwable e) {\n\t\t\t\treturn blocks;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static class Tests {\n\t\tpublic static Object getBundle(Object original, Class<?> c) {\n\t\t\tif (original != null) {\n\t\t\t\treturn original;\n\t\t\t}\n\t\t\t\n\t\t\tCodeSource codeSource = c.getProtectionDomain().getCodeSource();\n\t\t\tif (codeSource == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t\n\t\t\tString jar = codeSource.getLocation().getFile();\n\t\t\tString bundleName = jar.substring(jar.lastIndexOf(\"/\") + 1, jar.indexOf(\"_\"));\n\t\t\t\n\t\t\torg.osgi.framework.Bundle[] bundles = org.eclipse.core.runtime.adaptor.EclipseStarter.getSystemBundleContext().getBundles();\n\t\t\tfor (org.osgi.framework.Bundle bundle : bundles) {\n\t\t\t\tif (bundleName.equals(bundle.getSymbolicName())) {\n\t\t\t\t\treturn bundle;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tpublic static boolean isImplicitCanonicalConstructor(AbstractMethodDeclaration method, Object parameter) {\n\t\t\treturn (method.bits & IsCanonicalConstructor) != 0 && (method.bits & IsImplicit) != 0;\n\t\t}\n\t\t\n\t\tpublic static StringBuffer returnStringBuffer(Object p1, StringBuffer buffer) {\n\t\t\treturn buffer;\n\t\t}\n\t}\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2010-2021 The Project Lombok Authors.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage lombok.launch;\n\nimport static lombok.eclipse.EcjAugments.ASTNode_generatedBy;\nimport static lombok.eclipse.Eclipse.*;\n\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.security.CodeSource;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Stack;\n\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.jdt.core.IAnnotatable;\nimport org.eclipse.jdt.core.IAnnotation;\nimport org.eclipse.jdt.core.IField;\nimport org.eclipse.jdt.core.IJavaElement;\nimport org.eclipse.jdt.core.IMethod;\nimport org.eclipse.jdt.core.IType;\nimport org.eclipse.jdt.core.JavaModelException;\nimport org.eclipse.jdt.core.dom.AST;\nimport org.eclipse.jdt.core.dom.ASTNode;\nimport org.eclipse.jdt.core.dom.MethodDeclaration;\nimport org.eclipse.jdt.core.dom.Name;\nimport org.eclipse.jdt.core.dom.ReturnStatement;\nimport org.eclipse.jdt.core.dom.SimpleName;\nimport org.eclipse.jdt.core.dom.SingleVariableDeclaration;\nimport org.eclipse.jdt.core.dom.Type;\nimport org.eclipse.jdt.core.search.SearchMatch;\nimport org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.Annotation;\nimport org.eclipse.jdt.internal.compiler.ast.Expression;\nimport org.eclipse.jdt.internal.compiler.ast.FieldDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.LocalDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;\nimport org.eclipse.jdt.internal.compiler.lookup.BlockScope;\nimport org.eclipse.jdt.internal.compiler.lookup.TypeBinding;\nimport org.eclipse.jdt.internal.core.SourceField;\nimport org.eclipse.jdt.internal.core.dom.rewrite.NodeRewriteEvent;\nimport org.eclipse.jdt.internal.core.dom.rewrite.RewriteEvent;\nimport org.eclipse.jdt.internal.core.dom.rewrite.TokenScanner;\nimport org.eclipse.jdt.internal.corext.refactoring.SearchResultGroup;\nimport org.eclipse.jdt.internal.corext.refactoring.code.CallContext;\nimport org.eclipse.jdt.internal.corext.refactoring.code.SourceProvider;\nimport org.eclipse.jdt.internal.corext.refactoring.structure.MemberVisibilityAdjustor.IncomingMemberVisibilityAdjustment;\n\nimport lombok.permit.Permit;\n\n/** These contain a mix of the following:\n * <ul>\n * <li> 'dependency free' method wrappers that cross the shadowloader barrier.\n * <li> methods that directly patch, <em>but<\/em>, these should ALWAYS be transplanted.\n * <\/ul>\n * \n * <strong>This class lives on the outside of the shadowloader barrier, and as a consequence, cannot access any other lombok code except other\n * code in the {@code lombok.launch} package!<\/strong>.\n * <p>\n * This class is package private with lots of public inner static classes. This hides all of them from IDE autocomplete dialogs and such but at the JVM\n * level the inner static class are just plain public, which is important, because calls to the contents of these inner static classes are injected into\n * various eclipse classes verbatim, and if they weren't public, the verifier wouldn't accept it.\n */\nfinal class PatchFixesHider {\n\t\n\t/** These utility methods are only used 'internally', but because of transplant methods, the class (and its methods) still have to be public! */\n\tpublic static final class Util {\n\t\tprivate static ClassLoader shadowLoader;\n\t\t\n\t\tpublic static ClassLoader getShadowLoader() {\n\t\t\tif (shadowLoader == null) {\n\t\t\t\ttry {\n\t\t\t\t\tClass.forName(\"lombok.core.LombokNode\");\n\t\t\t\t\t// If we get here, then lombok is already available.\n\t\t\t\t\tshadowLoader = Util.class.getClassLoader();\n\t\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\t\t// If we get here, it isn't, and we should use the shadowloader.\n\t\t\t\t\tshadowLoader = Main.getShadowClassLoader();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn shadowLoader;\n\t\t}\n\t\t\n\t\tpublic static Class<?> shadowLoadClass(String name) {\n\t\t\ttry {\n\t\t\t\treturn Class.forName(name, true, getShadowLoader());\n\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\tthrow sneakyThrow(e);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static Method findMethod(Class<?> type, String name, Class<?>... parameterTypes) {\n\t\t\ttry {\n\t\t\t\treturn type.getDeclaredMethod(name, parameterTypes);\n\t\t\t} catch (NoSuchMethodException e) {\n\t\t\t\tthrow sneakyThrow(e);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static Method findMethod(Class<?> type, String name, String... parameterTypes) {\n\t\t\tfor (Method m : type.getDeclaredMethods()) {\n\t\t\t\tif (name.equals(m.getName()) && sameTypes(m.getParameterTypes(), parameterTypes)) {\n\t\t\t\t\treturn m;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow sneakyThrow(new NoSuchMethodException(type.getName() + \"::\" + name));\n\t\t}\n\t\t\n\t\tpublic static Method findMethodAnyArgs(Class<?> type, String name) {\n\t\t\tfor (Method m : type.getDeclaredMethods()) if (name.equals(m.getName())) return m;\n\t\t\tthrow sneakyThrow(new NoSuchMethodException(type.getName() + \"::\" + name));\n\t\t}\n\t\t\n\t\tpublic static Object invokeMethod(Method method, Object... args) {\n\t\t\ttry {\n\t\t\t\treturn method.invoke(null, args);\n\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\tthrow sneakyThrow(e);\n\t\t\t} catch (InvocationTargetException e) {\n\t\t\t\tthrow sneakyThrow(e.getCause());\n\t\t\t}\n\t\t}\n\t\t\n\t\tprivate static RuntimeException sneakyThrow(Throwable t) {\n\t\t\tif (t == null) throw new NullPointerException(\"t\");\n\t\t\tUtil.<RuntimeException>sneakyThrow0(t);\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tprivate static <T extends Throwable> void sneakyThrow0(Throwable t) throws T {\n\t\t\tthrow (T)t;\n\t\t}\n\t\t\n\t\tprivate static boolean sameTypes(Class<?>[] types, String[] typeNames) {\n\t\t\tif (types.length != typeNames.length) return false;\n\t\t\tfor (int i = 0; i < types.length; i++) {\n\t\t\t\tif (!types[i].getName().equals(typeNames[i])) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\t/** Contains patch fixes that are dependent on lombok internals. */\n\tpublic static final class LombokDeps {\n\t\tpublic static final Method ADD_LOMBOK_NOTES;\n\t\tpublic static final Method POST_COMPILER_BYTES_STRING;\n\t\tpublic static final Method POST_COMPILER_OUTPUTSTREAM;\n\t\tpublic static final Method POST_COMPILER_BUFFEREDOUTPUTSTREAM_STRING_STRING;\n\t\t\n\t\tstatic {\n\t\t\tClass<?> shadowed = Util.shadowLoadClass(\"lombok.eclipse.agent.PatchFixesShadowLoaded\");\n\t\t\tADD_LOMBOK_NOTES = Util.findMethod(shadowed, \"addLombokNotesToEclipseAboutDialog\", String.class, String.class);\n\t\t\tPOST_COMPILER_BYTES_STRING = Util.findMethod(shadowed, \"runPostCompiler\", byte[].class, String.class);\n\t\t\tPOST_COMPILER_OUTPUTSTREAM = Util.findMethod(shadowed, \"runPostCompiler\", OutputStream.class);\n\t\t\tPOST_COMPILER_BUFFEREDOUTPUTSTREAM_STRING_STRING = Util.findMethod(shadowed, \"runPostCompiler\", BufferedOutputStream.class, String.class, String.class);\n\t\t}\n\t\t\n\t\tpublic static String addLombokNotesToEclipseAboutDialog(String origReturnValue, String key) {\n\t\t\ttry {\n\t\t\t\treturn (String) Util.invokeMethod(LombokDeps.ADD_LOMBOK_NOTES, origReturnValue, key);\n\t\t\t} catch (Throwable t) {\n\t\t\t\treturn origReturnValue;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static byte[] runPostCompiler(byte[] bytes, String fileName) {\n\t\t\treturn (byte[]) Util.invokeMethod(LombokDeps.POST_COMPILER_BYTES_STRING, bytes, fileName);\n\t\t}\n\t\t\n\t\tpublic static OutputStream runPostCompiler(OutputStream out) throws IOException {\n\t\t\treturn (OutputStream) Util.invokeMethod(LombokDeps.POST_COMPILER_OUTPUTSTREAM, out);\n\t\t}\n\t\t\n\t\tpublic static BufferedOutputStream runPostCompiler(BufferedOutputStream out, String path, String name) throws IOException {\n\t\t\treturn (BufferedOutputStream) Util.invokeMethod(LombokDeps.POST_COMPILER_BUFFEREDOUTPUTSTREAM_STRING_STRING, out, path, name);\n\t\t}\n\t}\n\t\n\tpublic static final class Transform {\n\t\tprivate static Method TRANSFORM;\n\t\tprivate static Method TRANSFORM_SWAPPED;\n\t\t\n\t\tprivate static synchronized void init(ClassLoader prepend) {\n\t\t\tif (TRANSFORM != null) return;\n\t\t\t\n\t\t\tprependClassLoader(prepend);\n\t\t\tif (!prepend.toString().contains(\"org.eclipse.jdt.core:\")) {\n\t\t\t\tClassLoader jdtCoreClassLoader = findJdtCoreClassLoader(prepend);\n\t\t\t\tprependClassLoader(jdtCoreClassLoader);\n\t\t\t}\n\t\t\tClass<?> shadowed = Util.shadowLoadClass(\"lombok.eclipse.TransformEclipseAST\");\n\t\t\tTRANSFORM = Util.findMethodAnyArgs(shadowed, \"transform\");\n\t\t\tTRANSFORM_SWAPPED = Util.findMethodAnyArgs(shadowed, \"transform_swapped\");\n\t\t}\n\t\t\n\t\tprivate static void prependClassLoader(ClassLoader classLoader) {\n\t\t\tMain.prependClassLoader(classLoader);\n\t\t\ttry {\n\t\t\t\tClassLoader currentClassLoader = Transform.class.getClassLoader();\n\t\t\t\t\n\t\t\t\tMethod prependParentMethod = Permit.getMethod(currentClassLoader.getClass(), \"prependParent\", ClassLoader.class);\n\t\t\t\tPermit.invoke(prependParentMethod, currentClassLoader, classLoader);\n\t\t\t} catch (Throwable t) {\n\t\t\t\t// Ignore\n\t\t\t}\n\t\t}\n\t\t\n\t\tprivate static ClassLoader findJdtCoreClassLoader(ClassLoader classLoader) {\n\t\t\ttry {\n\t\t\t\tMethod getBundleMethod = Permit.getMethod(classLoader.getClass(), \"getBundle\");\n\t\t\t\tObject bundle = Permit.invoke(getBundleMethod, classLoader);\n\t\t\t\t\n\t\t\t\tMethod getBundleContextMethod = Permit.getMethod(bundle.getClass(), \"getBundleContext\");\n\t\t\t\tObject bundleContext = Permit.invoke(getBundleContextMethod, bundle);\n\t\t\t\t\n\t\t\t\tMethod getBundlesMethod = Permit.getMethod(bundleContext.getClass(), \"getBundles\");\n\t\t\t\tObject[] bundles = (Object[]) Permit.invoke(getBundlesMethod, bundleContext);\n\t\t\t\t\n\t\t\t\tfor (Object searchBundle : bundles) {\n\t\t\t\t\tif (searchBundle.toString().startsWith(\"org.eclipse.jdt.core_\")) {\n\t\t\t\t\t\tMethod getModuleClassLoaderMethod = Permit.getMethod(searchBundle.getClass(), \"getModuleClassLoader\", boolean.class);\n\t\t\t\t\t\treturn (ClassLoader) Permit.invoke(getModuleClassLoaderMethod, searchBundle, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (Throwable t) {\n\t\t\t\t// Ignore\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tpublic static void transform(Object parser, Object ast) throws IOException {\n\t\t\tinit(parser.getClass().getClassLoader());\n\t\t\tUtil.invokeMethod(TRANSFORM, parser, ast);\n\t\t}\n\t\t\n\t\tpublic static void transform_swapped(Object ast, Object parser) throws IOException {\n\t\t\tinit(parser.getClass().getClassLoader());\n\t\t\tUtil.invokeMethod(TRANSFORM_SWAPPED, ast, parser);\n\t\t}\n\t}\n\t\n\t/** Contains patch code to support {@code @Delegate} */\n\tpublic static final class Delegate {\n\t\tprivate static final Method HANDLE_DELEGATE_FOR_TYPE;\n\t\tprivate static final Method ADD_GENERATED_DELEGATE_METHODS;\n\t\t\n\t\tstatic {\n\t\t\tClass<?> shadowed = Util.shadowLoadClass(\"lombok.eclipse.agent.PatchDelegatePortal\");\n\t\t\tHANDLE_DELEGATE_FOR_TYPE = Util.findMethod(shadowed, \"handleDelegateForType\", Object.class);\n\t\t\tADD_GENERATED_DELEGATE_METHODS = Util.findMethod(shadowed, \"addGeneratedDelegateMethods\", Object.class, Object.class);\n\t\t}\n\t\t\n\t\tpublic static boolean handleDelegateForType(Object classScope) {\n\t\t\treturn (Boolean) Util.invokeMethod(HANDLE_DELEGATE_FOR_TYPE, classScope);\n\t\t}\n\t\t\n\t\tpublic static Object[] addGeneratedDelegateMethods(Object returnValue, Object javaElement) {\n\t\t\treturn (Object[]) Util.invokeMethod(ADD_GENERATED_DELEGATE_METHODS, returnValue, javaElement);\n\t\t}\n\t}\n\t\n\t/** Contains patch code to support {@code val} (eclipse specific) */\n\tpublic static final class ValPortal {\n\t\tprivate static final Method COPY_INITIALIZATION_OF_FOR_EACH_ITERABLE;\n\t\tprivate static final Method COPY_INITIALIZATION_OF_LOCAL_DECLARATION;\n\t\tprivate static final Method ADD_FINAL_AND_VAL_ANNOTATION_TO_VARIABLE_DECLARATION_STATEMENT;\n\t\tprivate static final Method ADD_FINAL_AND_VAL_ANNOTATION_TO_SINGLE_VARIABLE_DECLARATION;\n\t\t\n\t\tstatic {\n\t\t\tClass<?> shadowed = Util.shadowLoadClass(\"lombok.eclipse.agent.PatchValEclipsePortal\");\n\t\t\tCOPY_INITIALIZATION_OF_FOR_EACH_ITERABLE = Util.findMethod(shadowed, \"copyInitializationOfForEachIterable\", Object.class);\n\t\t\tCOPY_INITIALIZATION_OF_LOCAL_DECLARATION = Util.findMethod(shadowed, \"copyInitializationOfLocalDeclaration\", Object.class);\n\t\t\tADD_FINAL_AND_VAL_ANNOTATION_TO_VARIABLE_DECLARATION_STATEMENT = Util.findMethod(shadowed, \"addFinalAndValAnnotationToVariableDeclarationStatement\", Object.class, Object.class, Object.class);\n\t\t\tADD_FINAL_AND_VAL_ANNOTATION_TO_SINGLE_VARIABLE_DECLARATION = Util.findMethod(shadowed, \"addFinalAndValAnnotationToSingleVariableDeclaration\", Object.class, Object.class, Object.class);\n\t\t}\n\n\t\tpublic static void copyInitializationOfForEachIterable(Object parser) {\n\t\t\tUtil.invokeMethod(COPY_INITIALIZATION_OF_FOR_EACH_ITERABLE, parser);\n\t\t}\n\t\t\n\t\tpublic static void copyInitializationOfLocalDeclaration(Object parser) {\n\t\t\tUtil.invokeMethod(COPY_INITIALIZATION_OF_LOCAL_DECLARATION, parser);\n\t\t}\n\t\t\n\t\tpublic static void addFinalAndValAnnotationToVariableDeclarationStatement(Object converter, Object out, Object in) {\n\t\t\tUtil.invokeMethod(ADD_FINAL_AND_VAL_ANNOTATION_TO_VARIABLE_DECLARATION_STATEMENT, converter, out, in);\n\t\t}\n\t\t\n\t\tpublic static void addFinalAndValAnnotationToSingleVariableDeclaration(Object converter, Object out, Object in) {\n\t\t\tUtil.invokeMethod(ADD_FINAL_AND_VAL_ANNOTATION_TO_SINGLE_VARIABLE_DECLARATION, converter, out, in);\n\t\t}\n\t}\n\t\n\t/** Contains patch code to support {@code val} (eclipse and ecj) */\n\tpublic static final class Val {\n\t\tprivate static final String BLOCK_SCOPE_SIG = \"org.eclipse.jdt.internal.compiler.lookup.BlockScope\";\n\t\tprivate static final String LOCAL_DECLARATION_SIG = \"org.eclipse.jdt.internal.compiler.ast.LocalDeclaration\";\n\t\tprivate static final String FOREACH_STATEMENT_SIG = \"org.eclipse.jdt.internal.compiler.ast.ForeachStatement\";\n\t\t\n\t\tprivate static final Method HANDLE_VAL_FOR_LOCAL_DECLARATION;\n\t\tprivate static final Method HANDLE_VAL_FOR_FOR_EACH;\n\t\t\n\t\tstatic {\n\t\t\tClass<?> shadowed = Util.shadowLoadClass(\"lombok.eclipse.agent.PatchVal\");\n\t\t\tHANDLE_VAL_FOR_LOCAL_DECLARATION = Util.findMethod(shadowed, \"handleValForLocalDeclaration\", LOCAL_DECLARATION_SIG, BLOCK_SCOPE_SIG);\n\t\t\tHANDLE_VAL_FOR_FOR_EACH = Util.findMethod(shadowed, \"handleValForForEach\", FOREACH_STATEMENT_SIG, BLOCK_SCOPE_SIG);\n\t\t}\n\t\t\n\t\tpublic static boolean handleValForLocalDeclaration(Object local, Object scope) {\n\t\t\treturn (Boolean) Util.invokeMethod(HANDLE_VAL_FOR_LOCAL_DECLARATION, local, scope);\n\t\t}\n\t\t\n\t\tpublic static boolean handleValForForEach(Object forEach, Object scope) {\n\t\t\treturn (Boolean) Util.invokeMethod(HANDLE_VAL_FOR_FOR_EACH, forEach, scope);\n\t\t}\n\t\t\n\t\t/** \n\t\t * Patches local declaration to not call .resolveType() on the initializer expression if we've already done so (calling it twice causes weird errors) \n\t\t * This and the next method must be transplanted so that the return type is loaded in the correct class loader\n\t\t */\n\t\tpublic static TypeBinding skipResolveInitializerIfAlreadyCalled(Expression expr, BlockScope scope) {\n\t\t\tif (expr.resolvedType != null) return expr.resolvedType;\n\t\t\ttry {\n\t\t\t\treturn expr.resolveType(scope);\n\t\t\t} catch (NullPointerException e) {\n\t\t\t\treturn null;\n\t\t\t} catch (ArrayIndexOutOfBoundsException e) {\n\t\t\t\t// This will occur internally due to for example 'val x = mth(\"X\");', where mth takes 2 arguments.\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static TypeBinding skipResolveInitializerIfAlreadyCalled2(Expression expr, BlockScope scope, LocalDeclaration decl) {\n\t\t\tif (decl != null && LocalDeclaration.class.equals(decl.getClass()) && expr.resolvedType != null) return expr.resolvedType;\n\t\t\ttry {\n\t\t\t\treturn expr.resolveType(scope);\n\t\t\t} catch (NullPointerException e) {\n\t\t\t\treturn null;\n\t\t\t} catch (ArrayIndexOutOfBoundsException e) {\n\t\t\t\t// This will occur internally due to for example 'val x = mth(\"X\");', where mth takes 2 arguments.\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/** Contains patch code to support {@code @ExtensionMethod} */\n\tpublic static final class ExtensionMethod {\n\t\tprivate static final String MESSAGE_SEND_SIG = \"org.eclipse.jdt.internal.compiler.ast.MessageSend\";\n\t\tprivate static final String TYPE_BINDING_SIG = \"org.eclipse.jdt.internal.compiler.lookup.TypeBinding\";\n\t\tprivate static final String SCOPE_SIG = \"org.eclipse.jdt.internal.compiler.lookup.Scope\";\n\t\tprivate static final String BLOCK_SCOPE_SIG = \"org.eclipse.jdt.internal.compiler.lookup.BlockScope\";\n\t\tprivate static final String TYPE_BINDINGS_SIG = \"[Lorg.eclipse.jdt.internal.compiler.lookup.TypeBinding;\";\n\t\tprivate static final String PROBLEM_REPORTER_SIG = \"org.eclipse.jdt.internal.compiler.problem.ProblemReporter\";\n\t\tprivate static final String METHOD_BINDING_SIG = \"org.eclipse.jdt.internal.compiler.lookup.MethodBinding\";\n\t\tprivate static final String AST_NODE_SIG = \"org.eclipse.jdt.internal.compiler.ast.ASTNode\";\n\t\t\n\t\tprivate static final Method RESOLVE_TYPE;\n\t\tprivate static final Method ERROR_NO_METHOD_FOR;\n\t\tprivate static final Method INVALID_METHOD, INVALID_METHOD2;\n\t\tprivate static final Method NON_STATIC_ACCESS_TO_STATIC_METHOD;\n\t\tprivate static final Method MODIFY_METHOD_PATTERN;\n\t\t\n\t\tstatic {\n\t\t\tClass<?> shadowed = Util.shadowLoadClass(\"lombok.eclipse.agent.PatchExtensionMethod\");\n\t\t\tRESOLVE_TYPE = Util.findMethod(shadowed, \"resolveType\", TYPE_BINDING_SIG, MESSAGE_SEND_SIG, BLOCK_SCOPE_SIG);\n\t\t\tERROR_NO_METHOD_FOR = Util.findMethod(shadowed, \"errorNoMethodFor\", PROBLEM_REPORTER_SIG, MESSAGE_SEND_SIG, TYPE_BINDING_SIG, TYPE_BINDINGS_SIG);\n\t\t\tINVALID_METHOD = Util.findMethod(shadowed, \"invalidMethod\", PROBLEM_REPORTER_SIG, MESSAGE_SEND_SIG, METHOD_BINDING_SIG);\n\t\t\tINVALID_METHOD2 = Util.findMethod(shadowed, \"invalidMethod\", PROBLEM_REPORTER_SIG, MESSAGE_SEND_SIG, METHOD_BINDING_SIG, SCOPE_SIG);\n\t\t\tNON_STATIC_ACCESS_TO_STATIC_METHOD = Util.findMethod(shadowed, \"nonStaticAccessToStaticMethod\", PROBLEM_REPORTER_SIG, AST_NODE_SIG, METHOD_BINDING_SIG, MESSAGE_SEND_SIG);\n\t\t\tMODIFY_METHOD_PATTERN = Util.findMethod(shadowed, \"modifyMethodPattern\", Object.class);\n\t\t}\n\t\t\n\t\tpublic static Object resolveType(Object resolvedType, Object methodCall, Object scope) {\n\t\t\treturn Util.invokeMethod(RESOLVE_TYPE, resolvedType, methodCall, scope);\n\t\t}\n\t\t\n\t\tpublic static void errorNoMethodFor(Object problemReporter, Object messageSend, Object recType, Object params) {\n\t\t\tUtil.invokeMethod(ERROR_NO_METHOD_FOR, problemReporter, messageSend, recType, params);\n\t\t}\n\t\t\n\t\tpublic static void invalidMethod(Object problemReporter, Object messageSend, Object method) {\n\t\t\tUtil.invokeMethod(INVALID_METHOD, problemReporter, messageSend, method);\n\t\t}\n\t\t\n\t\tpublic static void invalidMethod(Object problemReporter, Object messageSend, Object method, Object scope) {\n\t\t\tUtil.invokeMethod(INVALID_METHOD2, problemReporter, messageSend, method, scope);\n\t\t}\n\t\t\n\t\tpublic static void nonStaticAccessToStaticMethod(Object problemReporter, Object location, Object method, Object messageSend) {\n\t\t\tUtil.invokeMethod(NON_STATIC_ACCESS_TO_STATIC_METHOD, problemReporter, location, method, messageSend);\n\t\t}\n\t\t\n\t\tpublic static Object modifyMethodPattern(Object original) {\n\t\t\treturn Util.invokeMethod(MODIFY_METHOD_PATTERN, original);\n\t\t}\n\t}\n\t\n\t/** Contains patch code to support Javadoc for generated methods */\n\tpublic static final class Javadoc {\n\t\tprivate static final Method GET_HTML;\n\t\tprivate static final Method PRINT_METHOD;\n\t\t\n\t\tstatic {\n\t\t\tClass<?> shadowed = Util.shadowLoadClass(\"lombok.eclipse.agent.PatchJavadoc\");\n\t\t\tGET_HTML = Util.findMethod(shadowed, \"getHTMLContentFromSource\", String.class, Object.class);\n\t\t\tPRINT_METHOD = Util.findMethod(shadowed, \"printMethod\", AbstractMethodDeclaration.class, Integer.class, StringBuffer.class, TypeDeclaration.class);\n\t\t}\n\t\t\n\t\tpublic static String getHTMLContentFromSource(String original, IJavaElement member) {\n\t\t\treturn (String) Util.invokeMethod(GET_HTML, original, member);\n\t\t}\n\t\t\n\t\tpublic static StringBuffer printMethod(AbstractMethodDeclaration methodDeclaration, int tab, StringBuffer output, TypeDeclaration type) {\n\t\t\treturn (StringBuffer) Util.invokeMethod(PRINT_METHOD, methodDeclaration, tab, output, type);\n\t\t}\n\t}\n\t\n\t/**\n\t * Contains a mix of methods: ecj only, ecj+eclipse, and eclipse only. As a consequence, _EVERY_ method from here used for ecj MUST be\n\t * transplanted, as ecj itself cannot load this class (signatures refer to things that don't exist in ecj-only mode).\n\t * <p>\n\t * Because of usage of transplant(), a bunch of these contain direct code and don't try to cross the shadowloader barrier.\n\t */\n\tpublic static final class PatchFixes {\n\t\tpublic static boolean isGenerated(org.eclipse.jdt.core.dom.ASTNode node) {\n\t\t\tboolean result = false;\n\t\t\ttry {\n\t\t\t\tresult = ((Boolean)node.getClass().getField(\"$isGenerated\").get(node)).booleanValue();\n\t\t\t\tif (!result && node.getParent() != null && node.getParent() instanceof org.eclipse.jdt.core.dom.QualifiedName) {\n\t\t\t\t\tresult = isGenerated(node.getParent());\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\t// better to assume it isn't generated\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic static boolean isGenerated(org.eclipse.jdt.internal.compiler.ast.ASTNode node) {\n\t\t\tboolean result = false;\n\t\t\ttry {\n\t\t\t\tresult = node.getClass().getField(\"$generatedBy\").get(node) != null;\n\t\t\t} catch (Exception e) {\n\t\t\t\t// better to assume it isn't generated\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic static boolean isGenerated(org.eclipse.jdt.core.IMember member) {\n\t\t\tboolean result = false;\n\t\t\ttry {\n\t\t\t\tresult = member.getNameRange().getLength() <= 0 || member.getNameRange().equals(member.getSourceRange());\n\t\t\t} catch (JavaModelException e) {\n\t\t\t\t// better to assume it isn't generated\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\t\n\t\tpublic static boolean isBlockedVisitorAndGenerated(org.eclipse.jdt.core.dom.ASTNode node, org.eclipse.jdt.core.dom.ASTVisitor visitor) {\n\t\t\tif (visitor == null) return false;\n\t\t\t\n\t\t\tString className = visitor.getClass().getName();\n\t\t\tif (!(className.startsWith(\"org.eclipse.jdt.internal.corext.fix\") || className.startsWith(\"org.eclipse.jdt.internal.ui.fix\") || className.startsWith(\"org.eclipse.jdt.ls.core.internal.semantictokens.SemanticTokensVisitor\"))) return false;\n\t\t\tif (className.equals(\"org.eclipse.jdt.internal.corext.fix.VariableDeclarationFixCore$WrittenNamesFinder\")) return false;\n\t\t\t\n\t\t\treturn isGenerated(node);\n\t\t}\n\t\t\n\t\tpublic static boolean isListRewriteOnGeneratedNode(org.eclipse.jdt.core.dom.rewrite.ListRewrite rewrite) {\n\t\t\treturn isGenerated(rewrite.getParent());\n\t\t}\n\t\t\n\t\tpublic static boolean returnFalse(java.lang.Object object) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tpublic static boolean returnTrue(java.lang.Object object) {\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\t@java.lang.SuppressWarnings({\"unchecked\", \"rawtypes\"}) public static java.util.List removeGeneratedNodes(java.util.List list) {\n\t\t\ttry {\n\t\t\t\tjava.util.List realNodes = new java.util.ArrayList(list.size());\n\t\t\t\tfor (java.lang.Object node : list) {\n\t\t\t\t\tif(!isGenerated(((org.eclipse.jdt.core.dom.ASTNode)node))) {\n\t\t\t\t\t\trealNodes.add(node);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn realNodes;\n\t\t\t} catch (Exception e) {\n\t\t\t}\n\t\t\treturn list;\n\t\t}\n\t\t\n\t\tpublic static java.lang.String getRealMethodDeclarationSource(java.lang.String original, Object processor, org.eclipse.jdt.core.dom.MethodDeclaration declaration) throws Exception {\n\t\t\tif (!isGenerated(declaration)) return original;\n\t\t\t\n\t\t\tList<org.eclipse.jdt.core.dom.Annotation> annotations = new ArrayList<org.eclipse.jdt.core.dom.Annotation>();\n\t\t\tfor (Object modifier : declaration.modifiers()) {\n\t\t\t\tif (modifier instanceof org.eclipse.jdt.core.dom.Annotation) {\n\t\t\t\t\torg.eclipse.jdt.core.dom.Annotation annotation = (org.eclipse.jdt.core.dom.Annotation)modifier;\n\t\t\t\t\tString qualifiedAnnotationName = annotation.resolveTypeBinding().getQualifiedName();\n\t\t\t\t\tif (!\"java.lang.Override\".equals(qualifiedAnnotationName) && !\"java.lang.SuppressWarnings\".equals(qualifiedAnnotationName)) annotations.add(annotation);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tStringBuilder signature = new StringBuilder();\n\t\t\taddAnnotations(annotations, signature);\n\t\t\t\n\t\t\ttry {\n\t\t\t\tif ((Boolean)processor.getClass().getDeclaredField(\"fPublic\").get(processor)) signature.append(\"public \");\n\t\t\t\tif ((Boolean)processor.getClass().getDeclaredField(\"fAbstract\").get(processor)) signature.append(\"abstract \");\n\t\t\t} catch (Throwable t) { }\n\t\t\t\n\t\t\tsignature\n\t\t\t\t.append(declaration.getReturnType2().toString())\n\t\t\t\t.append(\" \").append(declaration.getName().getFullyQualifiedName())\n\t\t\t\t.append(\"(\");\n\t\t\t\n\t\t\tboolean first = true;\n\t\t\tfor (Object parameter : declaration.parameters()) {\n\t\t\t\tif (!first) signature.append(\", \");\n\t\t\t\tfirst = false;\n\t\t\t\t// We should also add the annotations of the parameters\n\t\t\t\tsignature.append(parameter);\n\t\t\t}\n\t\t\t\n\t\t\tsignature.append(\");\");\n\t\t\treturn signature.toString();\n\t\t}\n\t\t\n\t\t// part of getRealMethodDeclarationSource(...)\n\t\tpublic static void addAnnotations(List<org.eclipse.jdt.core.dom.Annotation> annotations, StringBuilder signature) {\n\t\t\t/*\n\t\t\t * We SHOULD be able to handle the following cases:\n\t\t\t * @Override\n\t\t\t * @Override()\n\t\t\t * @SuppressWarnings(\"all\")\n\t\t\t * @SuppressWarnings({\"all\", \"unused\"})\n\t\t\t * @SuppressWarnings(value = \"all\")\n\t\t\t * @SuppressWarnings(value = {\"all\", \"unused\"})\n\t\t\t * @EqualsAndHashCode(callSuper=true, of=\"id\")\n\t\t\t * \n\t\t\t * Currently, we only seem to correctly support:\n\t\t\t * @Override\n\t\t\t * @Override() N.B. We lose the parentheses here, since there are no values. No big deal.\n\t\t\t * @SuppressWarnings(\"all\")\n\t\t\t */\n\t\t\tfor (org.eclipse.jdt.core.dom.Annotation annotation : annotations) {\n\t\t\t\tList<String> values = new ArrayList<String>();\n\t\t\t\tif (annotation.isSingleMemberAnnotation()) {\n\t\t\t\t\torg.eclipse.jdt.core.dom.SingleMemberAnnotation smAnn = (org.eclipse.jdt.core.dom.SingleMemberAnnotation) annotation;\n\t\t\t\t\tvalues.add(smAnn.getValue().toString());\n\t\t\t\t} else if (annotation.isNormalAnnotation()) {\n\t\t\t\t\torg.eclipse.jdt.core.dom.NormalAnnotation normalAnn = (org.eclipse.jdt.core.dom.NormalAnnotation) annotation;\n\t\t\t\t\tfor (Object value : normalAnn.values()) values.add(value.toString());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tsignature.append(\"@\").append(annotation.getTypeName().getFullyQualifiedName());\n\t\t\t\tif (!values.isEmpty()) {\n\t\t\t\t\tsignature.append(\"(\");\n\t\t\t\t\tboolean first = true;\n\t\t\t\t\tfor (String string : values) {\n\t\t\t\t\t\tif (!first) signature.append(\", \");\n\t\t\t\t\t\tfirst = false;\n\t\t\t\t\t\tsignature.append('\"').append(string).append('\"');\n\t\t\t\t\t}\n\t\t\t\t\tsignature.append(\")\");\n\t\t\t\t}\n\t\t\t\tsignature.append(\" \");\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static org.eclipse.jdt.core.dom.MethodDeclaration getRealMethodDeclarationNode(org.eclipse.jdt.core.dom.MethodDeclaration original, org.eclipse.jdt.core.IMethod sourceMethod, org.eclipse.jdt.core.dom.CompilationUnit cuUnit) throws JavaModelException {\n\t\t\tif (!isGenerated(original)) return original;\n\t\t\t\n\t\t\tIType declaringType = sourceMethod.getDeclaringType();\n\t\t\tStack<IType> typeStack = new Stack<IType>();\n\t\t\twhile (declaringType != null) {\n\t\t\t\ttypeStack.push(declaringType);\n\t\t\t\tdeclaringType = declaringType.getDeclaringType();\n\t\t\t}\n\t\t\t\n\t\t\tIType rootType = typeStack.pop();\n\t\t\torg.eclipse.jdt.core.dom.AbstractTypeDeclaration typeDeclaration = findTypeDeclaration(rootType, cuUnit.types());\n\t\t\twhile (!typeStack.isEmpty() && typeDeclaration != null) {\n\t\t\t\ttypeDeclaration = findTypeDeclaration(typeStack.pop(), typeDeclaration.bodyDeclarations());\n\t\t\t}\n\t\t\t\n\t\t\tString targetMethodName = sourceMethod.getElementName();\n\t\t\tList<String> targetMethodParameterTypes = new ArrayList<String>();\n\t\t\tfor (String parameterType : sourceMethod.getParameterTypes()) {\n\t\t\t\ttargetMethodParameterTypes.add(org.eclipse.jdt.core.Signature.toString(parameterType));\n\t\t\t}\n\t\t\t\n\t\t\tif (typeStack.isEmpty() && typeDeclaration != null) {\n\t\t\t\tfor (Object declaration : typeDeclaration.bodyDeclarations()) {\n\t\t\t\t\tif (declaration instanceof org.eclipse.jdt.core.dom.MethodDeclaration) {\n\t\t\t\t\t\torg.eclipse.jdt.core.dom.MethodDeclaration methodDeclaration = (org.eclipse.jdt.core.dom.MethodDeclaration) declaration;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (!methodDeclaration.getName().toString().equals(targetMethodName)) continue;\n\t\t\t\t\t\tif (methodDeclaration.parameters().size() != targetMethodParameterTypes.size()) continue;\n\t\t\t\t\t\tif (!isGenerated(methodDeclaration)) continue;\n\t\t\t\t\t\t\n\t\t\t\t\t\tboolean parameterTypesEquals = true;\n\t\t\t\t\t\tfor (int i = 0; i < methodDeclaration.parameters().size(); i++) {\n\t\t\t\t\t\t\tSingleVariableDeclaration variableDeclaration = (SingleVariableDeclaration) methodDeclaration.parameters().get(i);\n\t\t\t\t\t\t\tif (!variableDeclaration.getType().toString().equals(targetMethodParameterTypes.get(i))) {\n\t\t\t\t\t\t\t\tparameterTypesEquals = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (parameterTypesEquals) {\n\t\t\t\t\t\t\treturn methodDeclaration;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn original;\n\t\t}\n\t\t\n\t\t// part of getRealMethodDeclarationNode\n\t\tpublic static org.eclipse.jdt.core.dom.AbstractTypeDeclaration findTypeDeclaration(IType searchType, List<?> nodes) {\n\t\t\tfor (Object object : nodes) {\n\t\t\t\tif (object instanceof org.eclipse.jdt.core.dom.AbstractTypeDeclaration) {\n\t\t\t\t\torg.eclipse.jdt.core.dom.AbstractTypeDeclaration typeDeclaration = (org.eclipse.jdt.core.dom.AbstractTypeDeclaration) object;\n\t\t\t\t\tif (typeDeclaration.getName().toString().equals(searchType.getElementName()))\n\t\t\t\t\t\treturn typeDeclaration;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tpublic static int getSourceEndFixed(int sourceEnd, org.eclipse.jdt.internal.compiler.ast.ASTNode node) throws Exception {\n\t\t\tif (sourceEnd == -1) {\n\t\t\t\torg.eclipse.jdt.internal.compiler.ast.ASTNode object = (org.eclipse.jdt.internal.compiler.ast.ASTNode)node.getClass().getField(\"$generatedBy\").get(node);\n\t\t\t\tif (object != null) {\n\t\t\t\t\treturn object.sourceEnd;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn sourceEnd;\n\t\t}\n\t\t\n\t\tpublic static int fixRetrieveStartingCatchPosition(int original, int start) {\n\t\t\treturn original == -1 ? start : original;\n\t\t}\n\t\t\n\t\tpublic static int fixRetrieveIdentifierEndPosition(int original, int start, int end) {\n\t\t\tif (original == -1) return end;\n\t\t\tif (original < start) return end;\n\t\t\treturn original;\n\t\t}\n\t\t\n\t\tpublic static int fixRetrieveEllipsisStartPosition(int original, int end) {\n\t\t\treturn original == -1 ? end : original;\n\t\t}\n\t\t\n\t\tpublic static int fixRetrieveStartBlockPosition(int original, int start) {\n\t\t\treturn original == -1 ? start : original;\n\t\t}\n\t\t\n\t\tpublic static int fixRetrieveRightBraceOrSemiColonPosition(int original, int end) {\n//\t\t\tif (original == -1) {\n//\t\t\t\tThread.dumpStack();\n//\t\t\t}\n\t\t\t return original == -1 ? end : original;\n\t\t}\n\t\t\n\t\tpublic static int fixRetrieveRightBraceOrSemiColonPosition(int retVal, AbstractMethodDeclaration amd) {\n\t\t\tif (retVal != -1 || amd == null) return retVal;\n\t\t\tboolean isGenerated = ASTNode_generatedBy.get(amd) != null;\n\t\t\tif (isGenerated) return amd.declarationSourceEnd;\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tpublic static int fixRetrieveRightBraceOrSemiColonPosition(int retVal, FieldDeclaration fd) {\n\t\t\tif (retVal != -1 || fd == null) return retVal;\n\t\t\tboolean isGenerated = ASTNode_generatedBy.get(fd) != null;\n\t\t\tif (isGenerated) return fd.declarationSourceEnd;\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tpublic static int fixRetrieveProperRightBracketPosition(int retVal, Type type) {\n\t\t\tif (retVal != -1 || type == null) return retVal;\n\t\t\tif (isGenerated(type)) return type.getStartPosition() + type.getLength() - 1;\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tpublic static final int ALREADY_PROCESSED_FLAG = 0x800000;  //Bit 24\n\t\t\n\t\tpublic static boolean checkBit24(Object node) throws Exception {\n\t\t\tint bits = (Integer)(node.getClass().getField(\"bits\").get(node));\n\t\t\treturn (bits & ALREADY_PROCESSED_FLAG) != 0;\n\t\t}\n\t\t\n\t\tpublic static boolean skipRewritingGeneratedNodes(org.eclipse.jdt.core.dom.ASTNode node) throws Exception {\n\t\t\treturn ((Boolean) node.getClass().getField(\"$isGenerated\").get(node)).booleanValue();\n\t\t}\n\t\t\n\t\tpublic static void setIsGeneratedFlag(org.eclipse.jdt.core.dom.ASTNode domNode,\n\t\t\t\torg.eclipse.jdt.internal.compiler.ast.ASTNode internalNode) throws Exception {\n\t\t\t\n\t\t\tif (internalNode == null || domNode == null) return;\n\t\t\tboolean isGenerated = ASTNode_generatedBy.get(internalNode) != null;\n\t\t\tif (isGenerated) domNode.getClass().getField(\"$isGenerated\").set(domNode, true);\n\t\t}\n\t\t\n\t\tpublic static void setIsGeneratedFlagForName(org.eclipse.jdt.core.dom.Name name, Object internalNode) throws Exception {\n\t\t\tif (internalNode instanceof org.eclipse.jdt.internal.compiler.ast.ASTNode) {\n\t\t\t\tboolean isGenerated = ASTNode_generatedBy.get((org.eclipse.jdt.internal.compiler.ast.ASTNode) internalNode) != null;\n\t\t\t\tif (isGenerated) name.getClass().getField(\"$isGenerated\").set(name, true);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static RewriteEvent[] listRewriteHandleGeneratedMethods(RewriteEvent parent) {\n\t\t\tRewriteEvent[] children = parent.getChildren();\n\t\t\tList<RewriteEvent> newChildren = new ArrayList<RewriteEvent>();\n\t\t\tList<RewriteEvent> modifiedChildren = new ArrayList<RewriteEvent>();\n\t\t\tfor (int i = 0; i < children.length; i++) {\n\t\t\t\tRewriteEvent child = children[i];\n\t\t\t\tboolean isGenerated = isGenerated((org.eclipse.jdt.core.dom.ASTNode) child.getOriginalValue());\n\t\t\t\tif (isGenerated) {\n\t\t\t\t\tboolean isReplacedOrRemoved = child.getChangeKind() == RewriteEvent.REPLACED || child.getChangeKind() == RewriteEvent.REMOVED;\n\t\t\t\t\tboolean convertingFromMethod = child.getOriginalValue() instanceof org.eclipse.jdt.core.dom.MethodDeclaration;\n\t\t\t\t\tif (isReplacedOrRemoved && convertingFromMethod && child.getNewValue() != null) {\n\t\t\t\t\t\tmodifiedChildren.add(new NodeRewriteEvent(null, child.getNewValue()));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnewChildren.add(child);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Since Eclipse doesn't honor the \"insert at specified location\" for already existing members,\n\t\t\t// we'll just add them last\n\t\t\tnewChildren.addAll(modifiedChildren);\n\t\t\treturn newChildren.toArray(new RewriteEvent[0]);\n\t\t}\n\t\t\n\t\tpublic static int getTokenEndOffsetFixed(TokenScanner scanner, int token, int startOffset, Object domNode) throws CoreException {\n\t\t\tboolean isGenerated = false;\n\t\t\ttry {\n\t\t\t\tisGenerated = (Boolean) domNode.getClass().getField(\"$isGenerated\").get(domNode);\n\t\t\t} catch (Exception e) {\n\t\t\t\t// If this fails, better to break some refactor scripts than to crash eclipse.\n\t\t\t}\n\t\t\tif (isGenerated) return -1;\n\t\t\treturn scanner.getTokenEndOffset(token, startOffset);\n\t\t}\n\t\t\n\t\tpublic static IMethod[] removeGeneratedMethods(IMethod[] methods) throws Exception {\n\t\t\tList<IMethod> result = new ArrayList<IMethod>();\n\t\t\tfor (IMethod m : methods) {\n\t\t\t\tif (!isGenerated(m)) result.add(m);\n\t\t\t}\n\t\t\treturn result.size() == methods.length ? methods : result.toArray(new IMethod[0]);\n\t\t}\n\t\t\n\t\tpublic static SearchMatch[] removeGenerated(SearchMatch[] returnValue) {\n\t\t\tList<SearchMatch> result = new ArrayList<SearchMatch>();\n\t\t\tfor (int j = 0; j < returnValue.length; j++) {\n\t\t\t\tSearchMatch searchResult = returnValue[j];\n\t\t\t\tif (searchResult.getElement() instanceof IField) {\n\t\t\t\t\tIField field = (IField) searchResult.getElement();\n\t\t\t\t\t\n\t\t\t\t\t// can not check for value=lombok because annotation is\n\t\t\t\t\t// not fully resolved\n\t\t\t\t\tIAnnotation annotation = field.getAnnotation(\"Generated\");\n\t\t\t\t\tif (annotation != null) {\n\t\t\t\t\t\t// Method generated at field location, skip\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tresult.add(searchResult);\n\t\t\t}\n\t\t\treturn result.toArray(new SearchMatch[0]);\n\t\t}\n\t\t\n\t\tpublic static SearchResultGroup[] createFakeSearchResult(SearchResultGroup[] returnValue,\n\t\t\t\tObject/*\n\t\t\t\t\t\t * org.eclipse.jdt.internal.corext.refactoring.rename.\n\t\t\t\t\t\t * RenameFieldProcessor\n\t\t\t\t\t\t */ processor) throws Exception {\n\t\t\tif (returnValue == null || returnValue.length == 0) {\n\t\t\t\t// if no matches were found, check if Data annotation is present on the class\n\t\t\t\tField declaredField = processor.getClass().getDeclaredField(\"fField\");\n\t\t\t\tif (declaredField != null) {\n\t\t\t\t\tdeclaredField.setAccessible(true);\n\t\t\t\t\tSourceField fField = (SourceField) declaredField.get(processor);\n\t\t\t\t\tIAnnotation dataAnnotation = fField.getDeclaringType().getAnnotation(\"Data\");\n\t\t\t\t\tif (dataAnnotation != null) {\n\t\t\t\t\t\t// add fake item, to make refactoring checks pass\n\t\t\t\t\t\treturn new SearchResultGroup[] {new SearchResultGroup(null, new SearchMatch[1])};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn returnValue;\n\t\t}\n\t\t\n\t\tpublic static SimpleName[] removeGeneratedSimpleNames(SimpleName[] in) throws Exception {\n\t\t\tField f = SimpleName.class.getField(\"$isGenerated\");\n\t\t\t\n\t\t\tint count = 0;\n\t\t\tfor (int i = 0; i < in.length; i++) {\n\t\t\t\tif (in[i] == null || !((Boolean)f.get(in[i])).booleanValue()) count++;\n\t\t\t}\n\t\t\tif (count == in.length) return in;\n\t\t\tSimpleName[] newSimpleNames = new SimpleName[count];\n\t\t\tcount = 0;\n\t\t\tfor (int i = 0; i < in.length; i++) {\n\t\t\t\tif (in[i] == null || !((Boolean)f.get(in[i])).booleanValue()) newSimpleNames[count++] = in[i];\n\t\t\t}\n\t\t\treturn newSimpleNames;\n\t\t}\n\t\t\n\t\tpublic static Name[] removeGeneratedNames(Name[] in) throws Exception {\n\t\t\tField f = Name.class.getField(\"$isGenerated\");\n\t\t\t\n\t\t\tint count = 0;\n\t\t\tfor (int i = 0; i < in.length; i++) {\n\t\t\t\tif (in[i] == null || !((Boolean)f.get(in[i])).booleanValue()) count++;\n\t\t\t}\n\t\t\tif (count == in.length) return in;\n\t\t\tName[] newNames = new Name[count];\n\t\t\tcount = 0;\n\t\t\tfor (int i = 0; i < in.length; i++) {\n\t\t\t\tif (in[i] == null || !((Boolean)f.get(in[i])).booleanValue()) newNames[count++] = in[i];\n\t\t\t}\n\t\t\treturn newNames;\n\t\t}\n\t\t\n\t\tpublic static Annotation[] convertAnnotations(Annotation[] out, IAnnotatable annotatable) {\n\t\t\tIAnnotation[] in;\n\t\t\t\n\t\t\ttry {\n\t\t\t\tin = annotatable.getAnnotations();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn out;\n\t\t\t}\n\t\t\t\n\t\t\tif (out == null) return null;\n\t\t\tint toWrite = 0;\n\t\t\t\n\t\t\tfor (int idx = 0; idx < out.length; idx++) {\n\t\t\t\tString oName = new String(out[idx].type.getLastToken());\n\t\t\t\tboolean found = false;\n\t\t\t\tfor (IAnnotation i : in) {\n\t\t\t\t\tString name = i.getElementName();\n\t\t\t\t\tint li = name.lastIndexOf('.');\n\t\t\t\t\tif (li > -1) name = name.substring(li + 1);\n\t\t\t\t\tif (name.equals(oName)) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) out[idx] = null;\n\t\t\t\telse toWrite++;\n\t\t\t}\n\t\t\t\n\t\t\tAnnotation[] replace = out;\n\t\t\tif (toWrite < out.length) {\n\t\t\t\treplace = new Annotation[toWrite];\n\t\t\t\tint idx = 0;\n\t\t\t\tfor (int i = 0; i < out.length; i++) {\n\t\t\t\t\tif (out[i] == null) continue;\n\t\t\t\t\treplace[idx++] = out[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn replace;\n\t\t}\n\t\t\n\t\tpublic static String getRealNodeSource(String original, org.eclipse.jdt.internal.compiler.ast.ASTNode node) {\n\t\t\tif (!isGenerated(node)) return original;\n\t\t\t\n\t\t\treturn node.toString();\n\t\t}\n\t\t\n\t\tpublic static java.lang.String getRealNodeSource(java.lang.String original, org.eclipse.jdt.core.dom.ASTNode node) throws Exception {\n\t\t\tif (!isGenerated(node)) return original;\n\t\t\t\n\t\t\treturn node.toString();\n\t\t}\n\t\t\n\t\tpublic static boolean skipRewriteVisibility(IncomingMemberVisibilityAdjustment adjustment) {\n\t\t\treturn isGenerated(adjustment.getMember());\n\t\t}\n\t\t\n\t\tpublic static String[] getRealCodeBlocks(String[] blocks, SourceProvider sourceProvider, CallContext callContext) {\n\t\t\tMethodDeclaration methodDeclaration = sourceProvider.getDeclaration();\n\t\t\tif (!isGenerated(methodDeclaration)) {\n\t\t\t\treturn blocks;\n\t\t\t}\n\t\t\t\n\t\t\ttry {\n\t\t\t\t// Replace parameter references with actual argument\n\t\t\t\tAST ast = methodDeclaration.getAST();\n\t\t\t\tList<?> parameters = methodDeclaration.parameters();\n\t\t\t\tfor (int i = 0; i < parameters.size(); i++) {\n\t\t\t\t\tSingleVariableDeclaration param = (SingleVariableDeclaration) parameters.get(i);\n\t\t\t\t\tObject data = param.getProperty(\"org.eclipse.jdt.internal.corext.refactoring.code.ParameterData\");\n\t\t\t\t\tList<SimpleName> names = Permit.get(Permit.permissiveGetField(data.getClass(), \"fReferences\"), data);\n\t\t\t\t\t\n\t\t\t\t\tfor (SimpleName simpleName : names) {\n\t\t\t\t\t\tASTNode copy = ASTNode.copySubtree(ast, callContext.arguments[i]);\n\t\t\t\t\t\tsimpleName.getParent().setStructuralProperty(simpleName.getLocationInParent(), copy);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Convert AST to source\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tfor (Object statement : methodDeclaration.getBody().statements()) {\n\t\t\t\t\tif (callContext.callMode != ASTNode.RETURN_STATEMENT && statement instanceof ReturnStatement) {\n\t\t\t\t\t\tReturnStatement returnStatement = (ReturnStatement) statement;\n\t\t\t\t\t\tsb.append(returnStatement.getExpression());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsb.append(statement);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn new String[] {sb.toString().trim()};\n\t\t\t} catch (Throwable e) {\n\t\t\t\treturn blocks;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static class Tests {\n\t\tpublic static Object getBundle(Object original, Class<?> c) {\n\t\t\tif (original != null) {\n\t\t\t\treturn original;\n\t\t\t}\n\t\t\t\n\t\t\tCodeSource codeSource = c.getProtectionDomain().getCodeSource();\n\t\t\tif (codeSource == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t\n\t\t\tString jar = codeSource.getLocation().getFile();\n\t\t\tString bundleName = jar.substring(jar.lastIndexOf(\"/\") + 1, jar.indexOf(\"_\"));\n\t\t\t\n\t\t\torg.osgi.framework.Bundle[] bundles = org.eclipse.core.runtime.adaptor.EclipseStarter.getSystemBundleContext().getBundles();\n\t\t\tfor (org.osgi.framework.Bundle bundle : bundles) {\n\t\t\t\tif (bundleName.equals(bundle.getSymbolicName())) {\n\t\t\t\t\treturn bundle;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tpublic static boolean isImplicitCanonicalConstructor(AbstractMethodDeclaration method, Object parameter) {\n\t\t\treturn (method.bits & IsCanonicalConstructor) != 0 && (method.bits & IsImplicit) != 0;\n\t\t}\n\t\t\n\t\tpublic static StringBuffer returnStringBuffer(Object p1, StringBuffer buffer) {\n\t\t\treturn buffer;\n\t\t}\n\t}\n}\n","lineNo":921}
{"Smelly Sample":"/*\n * Copyright (C) 2013-2021 The Project Lombok Authors.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage lombok.javac.handlers;\n\nimport static lombok.core.handlers.HandlerUtil.*;\nimport static lombok.javac.Javac.*;\nimport static lombok.javac.JavacTreeMaker.TypeTag.typeTag;\nimport static lombok.javac.handlers.JavacHandlerUtil.*;\n\nimport java.util.ArrayList;\n\nimport javax.lang.model.element.Modifier;\n\nimport com.sun.tools.javac.code.Flags;\nimport com.sun.tools.javac.tree.JCTree;\nimport com.sun.tools.javac.tree.JCTree.JCAnnotation;\nimport com.sun.tools.javac.tree.JCTree.JCArrayTypeTree;\nimport com.sun.tools.javac.tree.JCTree.JCBlock;\nimport com.sun.tools.javac.tree.JCTree.JCClassDecl;\nimport com.sun.tools.javac.tree.JCTree.JCCompilationUnit;\nimport com.sun.tools.javac.tree.JCTree.JCExpression;\nimport com.sun.tools.javac.tree.JCTree.JCFieldAccess;\nimport com.sun.tools.javac.tree.JCTree.JCIdent;\nimport com.sun.tools.javac.tree.JCTree.JCIf;\nimport com.sun.tools.javac.tree.JCTree.JCLiteral;\nimport com.sun.tools.javac.tree.JCTree.JCMethodDecl;\nimport com.sun.tools.javac.tree.JCTree.JCMethodInvocation;\nimport com.sun.tools.javac.tree.JCTree.JCModifiers;\nimport com.sun.tools.javac.tree.JCTree.JCNewArray;\nimport com.sun.tools.javac.tree.JCTree.JCNewClass;\nimport com.sun.tools.javac.tree.JCTree.JCPrimitiveTypeTree;\nimport com.sun.tools.javac.tree.JCTree.JCReturn;\nimport com.sun.tools.javac.tree.JCTree.JCStatement;\nimport com.sun.tools.javac.tree.JCTree.JCTypeApply;\nimport com.sun.tools.javac.tree.JCTree.JCTypeParameter;\nimport com.sun.tools.javac.tree.JCTree.JCVariableDecl;\nimport com.sun.tools.javac.util.Context;\nimport com.sun.tools.javac.util.List;\nimport com.sun.tools.javac.util.ListBuffer;\nimport com.sun.tools.javac.util.Name;\n\nimport lombok.AccessLevel;\nimport lombok.Builder;\nimport lombok.Builder.ObtainVia;\nimport lombok.ConfigurationKeys;\nimport lombok.Singular;\nimport lombok.ToString;\nimport lombok.core.AST.Kind;\nimport lombok.core.AnnotationValues;\nimport lombok.core.HandlerPriority;\nimport lombok.core.configuration.CheckerFrameworkVersion;\nimport lombok.core.handlers.HandlerUtil;\nimport lombok.core.handlers.HandlerUtil.FieldAccess;\nimport lombok.core.handlers.InclusionExclusionUtils.Included;\nimport lombok.experimental.NonFinal;\nimport lombok.javac.Javac;\nimport lombok.javac.JavacAnnotationHandler;\nimport lombok.javac.JavacNode;\nimport lombok.javac.JavacTreeMaker;\nimport lombok.javac.handlers.HandleConstructor.SkipIfConstructorExists;\nimport lombok.javac.handlers.JavacHandlerUtil.CopyJavadoc;\nimport lombok.javac.handlers.JavacHandlerUtil.MemberExistsResult;\nimport lombok.javac.handlers.JavacSingularsRecipes.JavacSingularizer;\nimport lombok.javac.handlers.JavacSingularsRecipes.SingularData;\nimport lombok.spi.Provides;\n\n@Provides\n@HandlerPriority(-1024) //-2^10; to ensure we've picked up @FieldDefault's changes (-2048) but @Value hasn't removed itself yet (-512), so that we can error on presence of it on the builder classes.\npublic class HandleBuilder extends JavacAnnotationHandler<Builder> {\n\tprivate HandleConstructor handleConstructor = new HandleConstructor();\n\t\n\tstatic final String CLEAN_FIELD_NAME = \"$lombokUnclean\";\n\tstatic final String CLEAN_METHOD_NAME = \"$lombokClean\";\n\tstatic final String TO_BUILDER_METHOD_NAME = \"toBuilder\";\n\tstatic final String DEFAULT_PREFIX = \"$default$\";\n\tstatic final String SET_PREFIX = \"$set\";\n\tstatic final String VALUE_PREFIX = \"$value\";\n\tstatic final String BUILDER_TEMP_VAR = \"builder\";\n\tstatic final String TO_BUILDER_NOT_SUPPORTED = \"@Builder(toBuilder=true) is only supported if you return your own type.\";\n\t\n\tprivate static final boolean toBoolean(Object expr, boolean defaultValue) {\n\t\tif (expr == null) return defaultValue;\n\t\tif (expr instanceof JCLiteral) return ((Integer) ((JCLiteral) expr).value) != 0;\n\t\treturn ((Boolean) expr).booleanValue();\n\t}\n\t\n\tstatic class BuilderJob {\n\t\tCheckerFrameworkVersion checkerFramework;\n\t\tJavacNode parentType;\n\t\tString builderMethodName, buildMethodName;\n\t\tboolean isStatic;\n\t\tList<JCTypeParameter> typeParams;\n\t\tList<JCTypeParameter> builderTypeParams;\n\t\tJavacNode sourceNode;\n\t\tjava.util.List<BuilderFieldData> builderFields;\n\t\tAccessLevel accessInners, accessOuters;\n\t\tboolean oldFluent, oldChain, toBuilder;\n\t\t\n\t\tJavacNode builderType;\n\t\tString builderClassName;\n\t\t\n\t\tvoid init(AnnotationValues<Builder> annValues, Builder ann, JavacNode node) {\n\t\t\taccessOuters = ann.access();\n\t\t\tif (accessOuters == null) accessOuters = AccessLevel.PUBLIC;\n\t\t\tif (accessOuters == AccessLevel.NONE) {\n\t\t\t\tsourceNode.addError(\"AccessLevel.NONE is not valid here\");\n\t\t\t\taccessOuters = AccessLevel.PUBLIC;\n\t\t\t}\n\t\t\taccessInners = accessOuters == AccessLevel.PROTECTED ? AccessLevel.PUBLIC : accessOuters;\n\t\t\t\n\t\t\toldFluent = toBoolean(annValues.getActualExpression(\"fluent\"), true);\n\t\t\toldChain = toBoolean(annValues.getActualExpression(\"chain\"), true);\n\t\t\t\n\t\t\tbuilderMethodName = ann.builderMethodName();\n\t\t\tbuildMethodName = ann.buildMethodName();\n\t\t\tbuilderClassName = getBuilderClassNameTemplate(node, ann.builderClassName());\n\t\t\ttoBuilder = ann.toBuilder();\n\t\t\t\n\t\t\tif (builderMethodName == null) builderMethodName = \"builder\";\n\t\t\tif (buildMethodName == null) buildMethodName = \"build\";\n\t\t\tif (builderClassName == null) builderClassName = \"\";\n\t\t}\n\t\t\n\t\tstatic String getBuilderClassNameTemplate(JavacNode node, String override) {\n\t\t\tif (override != null && !override.isEmpty()) return override;\n\t\t\toverride = node.getAst().readConfiguration(ConfigurationKeys.BUILDER_CLASS_NAME);\n\t\t\tif (override != null && !override.isEmpty()) return override;\n\t\t\treturn \"*Builder\";\n\t\t}\n\t\t\n\t\tString replaceBuilderClassName(Name name) {\n\t\t\treturn replaceBuilderClassName(name.toString(), builderClassName);\n\t\t}\n\t\t\n\t\tString replaceBuilderClassName(String name, String template) {\n\t\t\tif (template.indexOf('*') == -1) return template;\n\t\t\treturn template.replace(\"*\", name);\n\t\t}\n\t\t\n\t\tJCExpression createBuilderParentTypeReference() {\n\t\t\treturn namePlusTypeParamsToTypeReference(parentType.getTreeMaker(), parentType, typeParams);\n\t\t}\n\t\t\n\t\tName getBuilderClassName() {\n\t\t\treturn parentType.toName(builderClassName);\n\t\t}\n\t\t\n\t\tList<JCTypeParameter> copyTypeParams() {\n\t\t\treturn JavacHandlerUtil.copyTypeParams(sourceNode, typeParams);\n\t\t}\n\t\t\n\t\tName toName(String name) {\n\t\t\treturn parentType.toName(name);\n\t\t}\n\t\t\n\t\tContext getContext() {\n\t\t\treturn parentType.getContext();\n\t\t}\n\t\t\n\t\tJavacTreeMaker getTreeMaker() {\n\t\t\treturn parentType.getTreeMaker();\n\t\t}\n\t}\n\t\n\tstatic class BuilderFieldData {\n\t\tList<JCAnnotation> annotations;\n\t\tJCExpression type;\n\t\tName rawName;\n\t\tName name;\n\t\tName builderFieldName;\n\t\tName nameOfDefaultProvider;\n\t\tName nameOfSetFlag;\n\t\tSingularData singularData;\n\t\tObtainVia obtainVia;\n\t\tJavacNode obtainViaNode;\n\t\tJavacNode originalFieldNode;\n\t\t\n\t\tjava.util.List<JavacNode> createdFields = new ArrayList<JavacNode>();\n\t}\n\t\n\t@Override public void handle(AnnotationValues<Builder> annotation, JCAnnotation ast, JavacNode annotationNode) {\n\t\tfinal String BUILDER_NODE_NOT_SUPPORTED_ERR = \"@Builder is only supported on classes, records, constructors, and methods.\";\n\t\t\n\t\thandleFlagUsage(annotationNode, ConfigurationKeys.BUILDER_FLAG_USAGE, \"@Builder\");\n\t\tBuilderJob job = new BuilderJob();\n\t\tjob.sourceNode = annotationNode;\n\t\tjob.checkerFramework = getCheckerFrameworkVersion(annotationNode);\n\t\tjob.isStatic = true;\n\t\t\n\t\tBuilder annInstance = annotation.getInstance();\n\t\tjob.init(annotation, annInstance, annotationNode);\n\t\tjava.util.List<Name> typeArgsForToBuilder = null;\n\t\t\n\t\tboolean generateBuilderMethod;\n\t\tif (job.builderMethodName.isEmpty()) {\n\t\t\tgenerateBuilderMethod = false;\n\t\t} else if (!checkName(\"builderMethodName\", job.builderMethodName, annotationNode)) {\n\t\t\treturn;\n\t\t} else {\n\t\t\tgenerateBuilderMethod = true;\n\t\t}\n\t\t\n\t\tif (!checkName(\"buildMethodName\", job.buildMethodName, annotationNode)) return;\n\t\t\n\t\t// Do not delete the Builder annotation yet, we need it for @Jacksonized.\n\t\t\n\t\tJavacNode parent = annotationNode.up();\n\t\t\n\t\tjob.builderFields = new ArrayList<BuilderFieldData>();\n\t\tJCExpression buildMethodReturnType;\n\t\tjob.typeParams = List.nil();\n\t\tList<JCExpression> buildMethodThrownExceptions;\n\t\tName nameOfBuilderMethod;\n\t\t\n\t\tJavacNode fillParametersFrom = parent.get() instanceof JCMethodDecl ? parent : null;\n\t\tboolean addCleaning = false;\n\t\t\n\t\tArrayList<JavacNode> nonFinalNonDefaultedFields = null;\n\t\t\n\t\tif (!isStaticAllowed(upToTypeNode(parent))) {\n\t\t\tannotationNode.addError(\"@Builder is not supported on non-static nested classes.\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (parent.get() instanceof JCClassDecl) {\n\t\t\tif (!isClass(parent) && !isRecord(parent)) {\n\t\t\t\tannotationNode.addError(BUILDER_NODE_NOT_SUPPORTED_ERR);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tjob.parentType = parent;\n\t\t\tJCClassDecl td = (JCClassDecl) parent.get();\n\t\t\t\n\t\t\tListBuffer<JavacNode> allFields = new ListBuffer<JavacNode>();\n\t\t\tboolean valuePresent = (hasAnnotation(lombok.Value.class, parent) || hasAnnotation(\"lombok.experimental.Value\", parent));\n\t\t\tfor (JavacNode fieldNode : HandleConstructor.findAllFields(parent, true)) {\n\t\t\t\tJCVariableDecl fd = (JCVariableDecl) fieldNode.get();\n\t\t\t\tJavacNode isDefault = findAnnotation(Builder.Default.class, fieldNode, false);\n\t\t\t\tboolean isFinal = (fd.mods.flags & Flags.FINAL) != 0 || (valuePresent && !hasAnnotation(NonFinal.class, fieldNode));\n\t\t\t\t\n\t\t\t\tBuilderFieldData bfd = new BuilderFieldData();\n\t\t\t\tbfd.rawName = fd.name;\n\t\t\t\tbfd.name = removePrefixFromField(fieldNode);\n\t\t\t\tbfd.builderFieldName = bfd.name;\n\t\t\t\tbfd.annotations = findCopyableAnnotations(fieldNode);\n\t\t\t\tbfd.type = fd.vartype;\n\t\t\t\tbfd.singularData = getSingularData(fieldNode, annInstance.setterPrefix());\n\t\t\t\tbfd.originalFieldNode = fieldNode;\n\t\t\t\t\n\t\t\t\tif (bfd.singularData != null && isDefault != null) {\n\t\t\t\t\tisDefault.addError(\"@Builder.Default and @Singular cannot be mixed.\");\n\t\t\t\t\tfindAnnotation(Builder.Default.class, fieldNode, true);\n\t\t\t\t\tisDefault = null;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (fd.init == null && isDefault != null) {\n\t\t\t\t\tisDefault.addWarning(\"@Builder.Default requires an initializing expression (' = something;').\");\n\t\t\t\t\tfindAnnotation(Builder.Default.class, fieldNode, true);\n\t\t\t\t\tisDefault = null;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (fd.init != null && isDefault == null) {\n\t\t\t\t\tif (isFinal) continue;\n\t\t\t\t\tif (nonFinalNonDefaultedFields == null) nonFinalNonDefaultedFields = new ArrayList<JavacNode>();\n\t\t\t\t\tnonFinalNonDefaultedFields.add(fieldNode);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (isDefault != null) {\n\t\t\t\t\tbfd.nameOfDefaultProvider = parent.toName(DEFAULT_PREFIX + bfd.name);\n\t\t\t\t\tbfd.nameOfSetFlag = parent.toName(bfd.name + SET_PREFIX);\n\t\t\t\t\tbfd.builderFieldName = parent.toName(bfd.name + VALUE_PREFIX);\n\t\t\t\t\tJCMethodDecl md = generateDefaultProvider(bfd.nameOfDefaultProvider, fieldNode, td.typarams, job);\n\t\t\t\t\tif (md != null) injectMethod(parent, md);\n\t\t\t\t}\n\t\t\t\taddObtainVia(bfd, fieldNode);\n\t\t\t\tjob.builderFields.add(bfd);\n\t\t\t\tallFields.append(fieldNode);\n\t\t\t}\n\t\t\t\n\t\t\tif (!isRecord(parent)) {\n\t\t\t\t// Records ship with a canonical constructor that acts as @AllArgsConstructor - just use that one.\n\t\t\t\t\n\t\t\t\thandleConstructor.generateConstructor(parent, AccessLevel.PACKAGE, List.<JCAnnotation>nil(), allFields.toList(), false, null, SkipIfConstructorExists.I_AM_BUILDER, annotationNode);\n\t\t\t}\n\t\t\t\n\t\t\tbuildMethodReturnType = namePlusTypeParamsToTypeReference(parent.getTreeMaker(), parent, td.typarams);\n\t\t\tjob.typeParams = job.builderTypeParams = td.typarams;\n\t\t\tbuildMethodThrownExceptions = List.nil();\n\t\t\tnameOfBuilderMethod = null;\n\t\t\tjob.builderClassName = job.replaceBuilderClassName(td.name);\n\t\t\tif (!checkName(\"builderClassName\", job.builderClassName, annotationNode)) return;\n\t\t} else if (fillParametersFrom != null && fillParametersFrom.getName().toString().equals(\"<init>\")) {\n\t\t\tJCMethodDecl jmd = (JCMethodDecl) fillParametersFrom.get();\n\t\t\tif (!jmd.typarams.isEmpty()) {\n\t\t\t\tannotationNode.addError(\"@Builder is not supported on constructors with constructor type parameters.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tjob.parentType = parent.up();\n\t\t\tJCClassDecl td = (JCClassDecl) job.parentType.get();\n\t\t\tjob.typeParams = job.builderTypeParams = td.typarams;\n\t\t\tbuildMethodReturnType = job.createBuilderParentTypeReference();\n\t\t\tbuildMethodThrownExceptions = jmd.thrown;\n\t\t\tnameOfBuilderMethod = null;\n\t\t\tjob.builderClassName = job.replaceBuilderClassName(td.name);\n\t\t\tif (!checkName(\"builderClassName\", job.builderClassName, annotationNode)) return;\n\t\t} else if (fillParametersFrom != null) {\n\t\t\tjob.parentType = parent.up();\n\t\t\tJCClassDecl td = (JCClassDecl) job.parentType.get();\n\t\t\tJCMethodDecl jmd = (JCMethodDecl) fillParametersFrom.get();\n\t\t\tjob.isStatic = (jmd.mods.flags & Flags.STATIC) != 0;\n\t\t\t\n\t\t\tJCExpression fullReturnType = jmd.restype;\n\t\t\tbuildMethodReturnType = fullReturnType;\n\t\t\tjob.typeParams = job.builderTypeParams = jmd.typarams;\n\t\t\tbuildMethodThrownExceptions = jmd.thrown;\n\t\t\tnameOfBuilderMethod = jmd.name;\n\t\t\tif (buildMethodReturnType instanceof JCTypeApply) {\n\t\t\t\tbuildMethodReturnType = cloneType(job.getTreeMaker(), buildMethodReturnType, annotationNode);\n\t\t\t}\n\t\t\tif (job.builderClassName.indexOf('*') > -1) {\n\t\t\t\tString replStr = returnTypeToBuilderClassName(annotationNode, td, buildMethodReturnType, job.typeParams);\n\t\t\t\tif (replStr == null) return; // shuold not happen\n\t\t\t\tjob.builderClassName = job.builderClassName.replace(\"*\", replStr);\n\t\t\t}\n\t\t\tif (job.toBuilder) {\n\t\t\t\tif (fullReturnType instanceof JCArrayTypeTree) {\n\t\t\t\t\tannotationNode.addError(TO_BUILDER_NOT_SUPPORTED);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tName simpleName;\n\t\t\t\tString pkg;\n\t\t\t\tList<JCExpression> tpOnRet = List.nil();\n\t\t\t\t\n\t\t\t\tif (fullReturnType instanceof JCTypeApply) {\n\t\t\t\t\ttpOnRet = ((JCTypeApply) fullReturnType).arguments;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tJCExpression namingType = fullReturnType;\n\t\t\t\tif (buildMethodReturnType instanceof JCTypeApply) namingType = ((JCTypeApply) buildMethodReturnType).clazz;\n\t\t\t\t\n\t\t\t\tif (namingType instanceof JCIdent) {\n\t\t\t\t\tsimpleName = ((JCIdent) namingType).name;\n\t\t\t\t\tpkg = null;\n\t\t\t\t} else if (namingType instanceof JCFieldAccess) {\n\t\t\t\t\tJCFieldAccess jcfa = (JCFieldAccess) namingType;\n\t\t\t\t\tsimpleName = jcfa.name;\n\t\t\t\t\tpkg = unpack(jcfa.selected);\n\t\t\t\t\tif (pkg.startsWith(\"ERR:\")) {\n\t\t\t\t\t\tString err = pkg.substring(4, pkg.indexOf(\"__ERR__\"));\n\t\t\t\t\t\tannotationNode.addError(err);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tannotationNode.addError(\"Expected a (parameterized) type here instead of a \" + namingType.getClass().getName());\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (pkg != null && !parent.getPackageDeclaration().equals(pkg)) {\n\t\t\t\t\tannotationNode.addError(TO_BUILDER_NOT_SUPPORTED);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!job.parentType.getName().contentEquals(simpleName)) {\n\t\t\t\t\tannotationNode.addError(TO_BUILDER_NOT_SUPPORTED);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tList<JCTypeParameter> tpOnMethod = jmd.typarams;\n\t\t\t\tList<JCTypeParameter> tpOnType = ((JCClassDecl) job.parentType.get()).typarams;\n\t\t\t\ttypeArgsForToBuilder = new ArrayList<Name>();\n\t\t\t\t\n\t\t\t\tfor (JCTypeParameter tp : tpOnMethod) {\n\t\t\t\t\tint pos = -1;\n\t\t\t\t\tint idx = -1;\n\t\t\t\t\tfor (JCExpression tOnRet : tpOnRet) {\n\t\t\t\t\t\tidx++;\n\t\t\t\t\t\tif (!(tOnRet instanceof JCIdent)) continue;\n\t\t\t\t\t\tif (((JCIdent) tOnRet).name != tp.name) continue;\n\t\t\t\t\t\tpos = idx;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (pos == -1 || tpOnType.size() <= pos) {\n\t\t\t\t\t\tannotationNode.addError(\"@Builder(toBuilder=true) requires that each type parameter on the static method is part of the typeargs of the return value. Type parameter \" + tp.name + \" is not part of the return type.\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\ttypeArgsForToBuilder.add(tpOnType.get(pos).name);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tannotationNode.addError(BUILDER_NODE_NOT_SUPPORTED_ERR);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (fillParametersFrom != null) {\n\t\t\tfor (JavacNode param : fillParametersFrom.down()) {\n\t\t\t\tif (param.getKind() != Kind.ARGUMENT) continue;\n\t\t\t\tBuilderFieldData bfd = new BuilderFieldData();\n\t\t\t\t\n\t\t\t\tJCVariableDecl raw = (JCVariableDecl) param.get();\n\t\t\t\tbfd.name = raw.name;\n\t\t\t\tbfd.builderFieldName = bfd.name;\n\t\t\t\tbfd.rawName = raw.name;\n\t\t\t\tbfd.annotations = findCopyableAnnotations(param);\n\t\t\t\tbfd.type = raw.vartype;\n\t\t\t\tbfd.singularData = getSingularData(param, annInstance.setterPrefix());\n\t\t\t\tbfd.originalFieldNode = param;\n\t\t\t\taddObtainVia(bfd, param);\n\t\t\t\tjob.builderFields.add(bfd);\n\t\t\t}\n\t\t}\n\t\t\n\t\tjob.builderType = findInnerClass(job.parentType, job.builderClassName);\n\t\tif (job.builderType == null) {\n\t\t\tjob.builderType = makeBuilderClass(job);\n\t\t\trecursiveSetGeneratedBy(job.builderType.get(), annotationNode);\n\t\t} else {\n\t\t\tJCClassDecl builderTypeDeclaration = (JCClassDecl) job.builderType.get();\n\t\t\tif (job.isStatic && !builderTypeDeclaration.getModifiers().getFlags().contains(Modifier.STATIC)) {\n\t\t\t\tannotationNode.addError(\"Existing Builder must be a static inner class.\");\n\t\t\t\treturn;\n\t\t\t} else if (!job.isStatic && builderTypeDeclaration.getModifiers().getFlags().contains(Modifier.STATIC)) {\n\t\t\t\tannotationNode.addError(\"Existing Builder must be a non-static inner class.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsanityCheckForMethodGeneratingAnnotationsOnBuilderClass(job.builderType, annotationNode);\n\t\t\t/* generate errors for @Singular BFDs that have one already defined node. */ {\n\t\t\t\tfor (BuilderFieldData bfd : job.builderFields) {\n\t\t\t\t\tSingularData sd = bfd.singularData;\n\t\t\t\t\tif (sd == null) continue;\n\t\t\t\t\tJavacSingularizer singularizer = sd.getSingularizer();\n\t\t\t\t\tif (singularizer == null) continue;\n\t\t\t\t\tif (singularizer.checkForAlreadyExistingNodesAndGenerateError(job.builderType, sd)) {\n\t\t\t\t\t\tbfd.singularData = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (BuilderFieldData bfd : job.builderFields) {\n\t\t\tif (bfd.singularData != null && bfd.singularData.getSingularizer() != null) {\n\t\t\t\tif (bfd.singularData.getSingularizer().requiresCleaning()) {\n\t\t\t\t\taddCleaning = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (bfd.obtainVia != null) {\n\t\t\t\tif (bfd.obtainVia.field().isEmpty() == bfd.obtainVia.method().isEmpty()) {\n\t\t\t\t\tbfd.obtainViaNode.addError(\"The syntax is either @ObtainVia(field = \\\"fieldName\\\") or @ObtainVia(method = \\\"methodName\\\").\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (bfd.obtainVia.method().isEmpty() && bfd.obtainVia.isStatic()) {\n\t\t\t\t\tbfd.obtainViaNode.addError(\"@ObtainVia(isStatic = true) is not valid unless 'method' has been set.\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tgenerateBuilderFields(job);\n\t\tif (addCleaning) {\n\t\t\tJavacTreeMaker maker = job.getTreeMaker();\n\t\t\tJCVariableDecl uncleanField = maker.VarDef(maker.Modifiers(Flags.PRIVATE), job.builderType.toName(CLEAN_FIELD_NAME), maker.TypeIdent(CTC_BOOLEAN), null);\n\t\t\tinjectFieldAndMarkGenerated(job.builderType, uncleanField);\n\t\t\trecursiveSetGeneratedBy(uncleanField, annotationNode);\n\t\t}\n\t\t\n\t\tif (constructorExists(job.builderType) == MemberExistsResult.NOT_EXISTS) {\n\t\t\tJCMethodDecl cd = HandleConstructor.createConstructor(AccessLevel.PACKAGE, List.<JCAnnotation>nil(), job.builderType, List.<JavacNode>nil(), false, annotationNode);\n\t\t\tif (cd != null) injectMethod(job.builderType, cd);\n\t\t}\n\t\t\n\t\tfor (BuilderFieldData bfd : job.builderFields) {\n\t\t\tmakePrefixedSetterMethodsForBuilder(job, bfd, annInstance.setterPrefix());\n\t\t}\n\t\t\n\t\t{\n\t\t\tMemberExistsResult methodExists = methodExists(job.buildMethodName, job.builderType, -1);\n\t\t\tif (methodExists == MemberExistsResult.EXISTS_BY_LOMBOK) methodExists = methodExists(job.buildMethodName, job.builderType, 0);\n\t\t\tif (methodExists == MemberExistsResult.NOT_EXISTS) {\n\t\t\t\tJCMethodDecl md = generateBuildMethod(job, nameOfBuilderMethod, buildMethodReturnType, buildMethodThrownExceptions, addCleaning);\n\t\t\t\tif (md != null) {\n\t\t\t\t\trecursiveSetGeneratedBy(md, annotationNode);\n\t\t\t\t\tinjectMethod(job.builderType, md);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (methodExists(\"toString\", job.builderType, 0) == MemberExistsResult.NOT_EXISTS) {\n\t\t\tjava.util.List<Included<JavacNode, ToString.Include>> fieldNodes = new ArrayList<Included<JavacNode, ToString.Include>>();\n\t\t\tfor (BuilderFieldData bfd : job.builderFields) {\n\t\t\t\tfor (JavacNode f : bfd.createdFields) {\n\t\t\t\t\tfieldNodes.add(new Included<JavacNode, ToString.Include>(f, null, true, false));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tJCMethodDecl md = HandleToString.createToString(job.builderType, fieldNodes, true, false, FieldAccess.ALWAYS_FIELD, job.sourceNode);\n\t\t\tif (md != null) injectMethod(job.builderType, md);\n\t\t}\n\t\t\n\t\tif (addCleaning) injectMethod(job.builderType, generateCleanMethod(job));\n\t\t\n\t\tif (generateBuilderMethod && methodExists(job.builderMethodName, job.parentType, -1) != MemberExistsResult.NOT_EXISTS) generateBuilderMethod = false;\n\t\tif (generateBuilderMethod) {\n\t\t\tJCMethodDecl md = generateBuilderMethod(job);\n\t\t\trecursiveSetGeneratedBy(md, annotationNode);\n\t\t\tif (md != null) injectMethod(job.parentType, md);\n\t\t}\n\t\t\n\t\tif (job.toBuilder) {\n\t\t\tswitch (methodExists(TO_BUILDER_METHOD_NAME, job.parentType, 0)) {\n\t\t\tcase EXISTS_BY_USER:\n\t\t\t\tannotationNode.addWarning(\"Not generating toBuilder() as it already exists.\");\n\t\t\t\treturn;\n\t\t\tcase NOT_EXISTS:\n\t\t\t\tList<JCTypeParameter> tps = job.typeParams;\n\t\t\t\tif (typeArgsForToBuilder != null) {\n\t\t\t\t\tListBuffer<JCTypeParameter> lb = new ListBuffer<JCTypeParameter>();\n\t\t\t\t\tJavacTreeMaker maker = job.getTreeMaker();\n\t\t\t\t\tfor (Name n : typeArgsForToBuilder) {\n\t\t\t\t\t\tlb.append(maker.TypeParameter(n, List.<JCExpression>nil()));\n\t\t\t\t\t}\n\t\t\t\t\ttps = lb.toList();\n\t\t\t\t}\n\t\t\t\tJCMethodDecl md = generateToBuilderMethod(job, tps, annInstance.setterPrefix());\n\t\t\t\tif (md != null) {\n\t\t\t\t\trecursiveSetGeneratedBy(md, annotationNode);\n\t\t\t\t\tinjectMethod(job.parentType, md);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (nonFinalNonDefaultedFields != null && generateBuilderMethod) {\n\t\t\tfor (JavacNode fieldNode : nonFinalNonDefaultedFields) {\n\t\t\t\tfieldNode.addWarning(\"@Builder will ignore the initializing expression entirely. If you want the initializing expression to serve as default, add @Builder.Default. If it is not supposed to be settable during building, make the field final.\");\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic String returnTypeToBuilderClassName(JavacNode annotationNode, JCClassDecl td, JCExpression returnType, List<JCTypeParameter> typeParams) {\n\t\tString replStr = null;\n\t\tif (returnType instanceof JCFieldAccess) {\n\t\t\treplStr = ((JCFieldAccess) returnType).name.toString();\n\t\t} else if (returnType instanceof JCIdent) {\n\t\t\tName n = ((JCIdent) returnType).name;\n\t\t\t\n\t\t\tfor (JCTypeParameter tp : typeParams) {\n\t\t\t\tif (tp.name.equals(n)) {\n\t\t\t\t\tannotationNode.addError(\"@Builder requires specifying 'builderClassName' if used on methods with a type parameter as return type.\");\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\treplStr = n.toString();\n\t\t} else if (returnType instanceof JCPrimitiveTypeTree) {\n\t\t\treplStr = returnType.toString();\n\t\t\tif (Character.isLowerCase(replStr.charAt(0))) {\n\t\t\t\treplStr = Character.toTitleCase(replStr.charAt(0)) + replStr.substring(1);\n\t\t\t}\n\t\t} else if (returnType instanceof JCTypeApply) {\n\t\t\tJCExpression clazz = ((JCTypeApply) returnType).clazz;\n\t\t\tif (clazz instanceof JCFieldAccess) {\n\t\t\t\treplStr = ((JCFieldAccess) clazz).name.toString();\n\t\t\t} else if (clazz instanceof JCIdent) {\n\t\t\t\treplStr = ((JCIdent) clazz).name.toString();\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (replStr == null || replStr.isEmpty()) {\n\t\t\t// This shouldn't happen.\n\t\t\tSystem.err.println(\"Lombok bug ID#20140614-1651: javac HandleBuilder: return type to name conversion failed: \" + returnType.getClass());\n\t\t\treplStr = td.name.toString();\n\t\t}\n\t\treturn replStr;\n\t}\n\t\n\tprivate static String unpack(JCExpression expr) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tunpack(sb, expr);\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static void unpack(StringBuilder sb, JCExpression expr) {\n\t\tif (expr instanceof JCIdent) {\n\t\t\tsb.append(((JCIdent) expr).name.toString());\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (expr instanceof JCFieldAccess) {\n\t\t\tJCFieldAccess jcfa = (JCFieldAccess) expr;\n\t\t\tunpack(sb, jcfa.selected);\n\t\t\tsb.append(\".\").append(jcfa.name.toString());\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (expr instanceof JCTypeApply) {\n\t\t\tsb.setLength(0);\n\t\t\tsb.append(\"ERR:\");\n\t\t\tsb.append(\"@Builder(toBuilder=true) is not supported if returning a type with generics applied to an intermediate.\");\n\t\t\tsb.append(\"__ERR__\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tsb.setLength(0);\n\t\tsb.append(\"ERR:\");\n\t\tsb.append(\"Expected a type of some sort, not a \" + expr.getClass().getName());\n\t\tsb.append(\"__ERR__\");\n\t}\n\t\n\tprivate JCMethodDecl generateToBuilderMethod(BuilderJob job, List<JCTypeParameter> typeParameters, String prefix) {\n\t\t// return new ThingieBuilder<A, B>().setA(this.a).setB(this.b);\n\t\tJavacTreeMaker maker = job.getTreeMaker();\n\t\t\n\t\tJCExpression call = maker.NewClass(null, List.<JCExpression>nil(), namePlusTypeParamsToTypeReference(maker, job.parentType, job.toName(job.builderClassName), !job.isStatic, job.builderTypeParams), List.<JCExpression>nil(), null);\n\t\tJCExpression invoke = call;\n\t\tListBuffer<JCStatement> preStatements = null;\n\t\tListBuffer<JCStatement> statements = new ListBuffer<JCStatement>();\n\t\t\n\t\tfor (BuilderFieldData bfd : job.builderFields) {\n\t\t\tString setterPrefix = !prefix.isEmpty() ? prefix : job.oldFluent ? \"\" : \"set\";\n\t\t\tString prefixedSetterName = bfd.name.toString();\n\t\t\tif (!setterPrefix.isEmpty()) prefixedSetterName = HandlerUtil.buildAccessorName(job.sourceNode, setterPrefix, prefixedSetterName);\n\t\t\t\n\t\t\tName setterName = job.toName(prefixedSetterName);\n\t\t\tJCExpression[] tgt = new JCExpression[bfd.singularData == null ? 1 : 2];\n\t\t\tif (bfd.obtainVia == null || !bfd.obtainVia.field().isEmpty()) {\n\t\t\t\tfor (int i = 0; i < tgt.length; i++) {\n\t\t\t\t\ttgt[i] = maker.Select(maker.Ident(job.toName(\"this\")), bfd.obtainVia == null ? bfd.rawName : job.toName(bfd.obtainVia.field()));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tString name = bfd.obtainVia.method();\n\t\t\t\tJCMethodInvocation inv;\n\t\t\t\tif (bfd.obtainVia.isStatic()) {\n\t\t\t\t\tJCExpression c = maker.Select(maker.Ident(job.toName(job.parentType.getName())), job.toName(name));\n\t\t\t\t\tinv = maker.Apply(typeParameterNames(maker, typeParameters), c, List.<JCExpression>of(maker.Ident(job.toName(\"this\"))));\n\t\t\t\t} else {\n\t\t\t\t\tJCExpression c = maker.Select(maker.Ident(job.toName(\"this\")), job.toName(name));\n\t\t\t\t\tinv = maker.Apply(List.<JCExpression>nil(), c, List.<JCExpression>nil());\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < tgt.length; i++) tgt[i] = maker.Ident(bfd.name);\n\t\t\t\t\n\t\t\t\t// javac appears to cache the type of JCMethodInvocation expressions based on position, meaning, if you have 2 ObtainVia-based method invokes on different types, you get bizarre type mismatch errors.\n\t\t\t\t// going via a local variable declaration solves the problem.\n\t\t\t\tJCExpression varType = JavacHandlerUtil.cloneType(maker, bfd.type, job.sourceNode);\n\t\t\t\tif (preStatements == null) preStatements = new ListBuffer<JCStatement>();\n\t\t\t\tpreStatements.append(maker.VarDef(maker.Modifiers(Flags.FINAL), bfd.name, varType, inv));\n\t\t\t}\n\t\t\t\n\t\t\tJCExpression arg;\n\t\t\tif (bfd.singularData == null) {\n\t\t\t\targ = tgt[0];\n\t\t\t\tinvoke = maker.Apply(List.<JCExpression>nil(), maker.Select(invoke, setterName), List.of(arg));\n\t\t\t} else {\n\t\t\t\tJCExpression isNotNull = maker.Binary(CTC_NOT_EQUAL, tgt[0], maker.Literal(CTC_BOT, null));\n\t\t\t\tJCExpression invokeBuilder = maker.Apply(List.<JCExpression>nil(), maker.Select(maker.Ident(job.toName(BUILDER_TEMP_VAR)), setterName), List.<JCExpression>of(tgt[1]));\n\t\t\t\tstatements.append(maker.If(isNotNull, maker.Exec(invokeBuilder), null));\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (!statements.isEmpty()) {\n\t\t\tJCExpression tempVarType = namePlusTypeParamsToTypeReference(maker, job.parentType, job.getBuilderClassName(), !job.isStatic, typeParameters);\n\t\t\tstatements.prepend(maker.VarDef(maker.Modifiers(Flags.FINAL), job.toName(BUILDER_TEMP_VAR), tempVarType, invoke));\n\t\t\tstatements.append(maker.Return(maker.Ident(job.toName(BUILDER_TEMP_VAR))));\n\t\t} else {\n\t\t\tstatements.append(maker.Return(invoke));\n\t\t}\n\t\t\n\t\tif (preStatements != null) {\n\t\t\tpreStatements.appendList(statements);\n\t\t\tstatements = preStatements;\n\t\t}\n\t\tJCBlock body = maker.Block(0, statements.toList());\n\t\tList<JCAnnotation> annsOnParamType = List.nil();\n\t\tif (job.checkerFramework.generateUnique()) annsOnParamType = List.of(maker.Annotation(genTypeRef(job.parentType, CheckerFrameworkVersion.NAME__UNIQUE), List.<JCExpression>nil()));\n\t\tJCMethodDecl methodDef = maker.MethodDef(maker.Modifiers(toJavacModifier(job.accessOuters)), job.toName(TO_BUILDER_METHOD_NAME), namePlusTypeParamsToTypeReference(maker, job.parentType, job.getBuilderClassName(), !job.isStatic, typeParameters, annsOnParamType), List.<JCTypeParameter>nil(), List.<JCVariableDecl>nil(), List.<JCExpression>nil(), body, null);\n\t\tcreateRelevantNonNullAnnotation(job.parentType, methodDef);\n\t\treturn methodDef;\n\t}\n\t\n\tprivate JCMethodDecl generateCleanMethod(BuilderJob job) {\n\t\tJavacTreeMaker maker = job.getTreeMaker();\n\t\tListBuffer<JCStatement> statements = new ListBuffer<JCStatement>();\n\t\t\n\t\tfor (BuilderFieldData bfd : job.builderFields) {\n\t\t\tif (bfd.singularData != null && bfd.singularData.getSingularizer() != null) {\n\t\t\t\tbfd.singularData.getSingularizer().appendCleaningCode(bfd.singularData, job.builderType, job.sourceNode, statements);\n\t\t\t}\n\t\t}\n\t\t\n\t\tstatements.append(maker.Exec(maker.Assign(maker.Select(maker.Ident(job.toName(\"this\")), job.toName(CLEAN_FIELD_NAME)), maker.Literal(CTC_BOOLEAN, 0))));\n\t\tJCBlock body = maker.Block(0, statements.toList());\n\t\tJCMethodDecl method = maker.MethodDef(maker.Modifiers(toJavacModifier(AccessLevel.PRIVATE)), job.toName(CLEAN_METHOD_NAME), maker.Type(Javac.createVoidType(job.builderType.getSymbolTable(), CTC_VOID)), List.<JCTypeParameter>nil(), List.<JCVariableDecl>nil(), List.<JCExpression>nil(), body, null);\n\t\trecursiveSetGeneratedBy(method, job.sourceNode);\n\t\treturn method;\n\t}\n\t\n\tstatic JCVariableDecl generateReceiver(BuilderJob job) {\n\t\tif (!job.checkerFramework.generateCalledMethods()) return null;\n\t\t\n\t\tArrayList<String> mandatories = new ArrayList<String>();\n\t\tfor (BuilderFieldData bfd : job.builderFields) {\n\t\t\tif (bfd.singularData == null && bfd.nameOfSetFlag == null) mandatories.add(bfd.name.toString());\n\t\t}\n\t\t\n\t\tJCExpression arg;\n\t\tJavacTreeMaker maker = job.getTreeMaker();\n\t\tif (mandatories.size() == 0) return null;\n\t\tif (mandatories.size() == 1) arg = maker.Literal(mandatories.get(0));\n\t\telse {\n\t\t\tList<JCExpression> elems = List.nil();\n\t\t\tfor (int i = mandatories.size() - 1; i >= 0; i--) elems = elems.prepend(maker.Literal(mandatories.get(i)));\n\t\t\targ = maker.NewArray(null, List.<JCExpression>nil(), elems);\n\t\t}\n\t\tJCAnnotation recvAnno = maker.Annotation(genTypeRef(job.builderType, CheckerFrameworkVersion.NAME__CALLED), List.of(arg));\n\t\tJCClassDecl builderTypeNode = (JCClassDecl) job.builderType.get();\n\t\tJCVariableDecl recv = maker.VarDef(maker.Modifiers(Flags.PARAMETER, List.<JCAnnotation>nil()), job.toName(\"this\"), namePlusTypeParamsToTypeReference(maker, job.builderType, builderTypeNode.typarams, List.<JCAnnotation>of(recvAnno)), null);\n\t\treturn recv;\n\t}\n\t\n\tprivate JCMethodDecl generateBuildMethod(BuilderJob job, Name staticName, JCExpression returnType, List<JCExpression> thrownExceptions, boolean addCleaning) {\n\t\tJavacTreeMaker maker = job.getTreeMaker();\n\t\t\n\t\tJCExpression call;\n\t\tListBuffer<JCStatement> statements = new ListBuffer<JCStatement>();\n\t\t\n\t\tif (addCleaning) {\n\t\t\tJCExpression notClean = maker.Unary(CTC_NOT, maker.Select(maker.Ident(job.toName(\"this\")), job.toName(CLEAN_FIELD_NAME)));\n\t\t\tJCStatement invokeClean = maker.Exec(maker.Apply(List.<JCExpression>nil(), maker.Ident(job.toName(CLEAN_METHOD_NAME)), List.<JCExpression>nil()));\n\t\t\tJCIf ifUnclean = maker.If(notClean, invokeClean, null);\n\t\t\tstatements.append(ifUnclean);\n\t\t}\n\t\t\n\t\tfor (BuilderFieldData bfd : job.builderFields) {\n\t\t\tif (bfd.singularData != null && bfd.singularData.getSingularizer() != null) {\n\t\t\t\tbfd.singularData.getSingularizer().appendBuildCode(bfd.singularData, job.builderType, job.sourceNode, statements, bfd.builderFieldName, \"this\");\n\t\t\t}\n\t\t}\n\t\t\n\t\tListBuffer<JCExpression> args = new ListBuffer<JCExpression>();\n\t\tName thisName = job.toName(\"this\");\n\t\tfor (BuilderFieldData bfd : job.builderFields) {\n\t\t\tif (bfd.nameOfSetFlag != null) {\n\t\t\t\tstatements.append(maker.VarDef(maker.Modifiers(0L), bfd.builderFieldName, cloneType(maker, bfd.type, job.sourceNode), maker.Select(maker.Ident(thisName), bfd.builderFieldName)));\n\t\t\t\tstatements.append(maker.If(maker.Unary(CTC_NOT, maker.Select(maker.Ident(thisName), bfd.nameOfSetFlag)), maker.Exec(maker.Assign(maker.Ident(bfd.builderFieldName), maker.Apply(typeParameterNames(maker, ((JCClassDecl) job.parentType.get()).typarams), maker.Select(maker.Ident(((JCClassDecl) job.parentType.get()).name), bfd.nameOfDefaultProvider), List.<JCExpression>nil()))), null));\n\t\t\t}\n\t\t\tif (bfd.nameOfSetFlag != null || (bfd.singularData != null && bfd.singularData.getSingularizer().shadowedDuringBuild())) {\n\t\t\t\targs.append(maker.Ident(bfd.builderFieldName));\n\t\t\t} else {\n\t\t\t\targs.append(maker.Select(maker.Ident(thisName), bfd.builderFieldName));\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (addCleaning) {\n\t\t\tstatements.append(maker.Exec(maker.Assign(maker.Select(maker.Ident(job.toName(\"this\")), job.toName(CLEAN_FIELD_NAME)), maker.Literal(CTC_BOOLEAN, 1))));\n\t\t}\n\t\t\n\t\tif (staticName == null) {\n\t\t\tcall = maker.NewClass(null, List.<JCExpression>nil(), returnType, args.toList(), null);\n\t\t\tstatements.append(maker.Return(call));\n\t\t} else {\n\t\t\tListBuffer<JCExpression> typeParams = new ListBuffer<JCExpression>();\n\t\t\tfor (JCTypeParameter tp : ((JCClassDecl) job.builderType.get()).typarams) {\n\t\t\t\ttypeParams.append(maker.Ident(tp.name));\n\t\t\t}\n\t\t\tJCExpression callee = maker.Ident(((JCClassDecl) job.parentType.get()).name);\n\t\t\tif (!job.isStatic) callee = maker.Select(callee, job.toName(\"this\"));\n\t\t\tJCExpression fn = maker.Select(callee, staticName);\n\t\t\tcall = maker.Apply(typeParams.toList(), fn, args.toList());\n\t\t\tif (returnType instanceof JCPrimitiveTypeTree && CTC_VOID.equals(typeTag(returnType))) {\n\t\t\t\tstatements.append(maker.Exec(call));\n\t\t\t} else {\n\t\t\t\tstatements.append(maker.Return(call));\n\t\t\t}\n\t\t}\n\t\t\n\t\tJCBlock body = maker.Block(0, statements.toList());\n\t\t\n\t\tList<JCAnnotation> annsOnMethod = job.checkerFramework.generateSideEffectFree() ? List.of(maker.Annotation(genTypeRef(job.builderType, CheckerFrameworkVersion.NAME__SIDE_EFFECT_FREE), List.<JCExpression>nil())) : List.<JCAnnotation>nil();\n\t\tJCVariableDecl recv = generateReceiver(job);\n\t\tJCMethodDecl methodDef;\n\t\tif (recv != null && maker.hasMethodDefWithRecvParam()) {\n\t\t\tmethodDef = maker.MethodDefWithRecvParam(maker.Modifiers(toJavacModifier(job.accessInners), annsOnMethod), job.toName(job.buildMethodName), returnType, List.<JCTypeParameter>nil(), recv, List.<JCVariableDecl>nil(), thrownExceptions, body, null);\n\t\t} else {\n\t\t\tmethodDef = maker.MethodDef(maker.Modifiers(toJavacModifier(job.accessInners), annsOnMethod), job.toName(job.buildMethodName), returnType, List.<JCTypeParameter>nil(), List.<JCVariableDecl>nil(), thrownExceptions, body, null);\n\t\t}\n\t\tif (staticName == null) createRelevantNonNullAnnotation(job.builderType, methodDef);\n\t\treturn methodDef;\n\t}\n\t\n\tpublic static JCMethodDecl generateDefaultProvider(Name methodName, JavacNode fieldNode, List<JCTypeParameter> params, BuilderJob job) {\n\t\tJavacTreeMaker maker = fieldNode.getTreeMaker();\n\t\tJCVariableDecl field = (JCVariableDecl) fieldNode.get();\n\t\t\n\t\t// Lombok tries to keep the position of the original initializer. First we save the expression ...\n\t\tJCExpression init = field.init;\n\t\tfield.init = null;\n\t\t\n\t\t// ... then we generate an empty return statement ...\n\t\tJCReturn statement = maker.Return(null);\n\t\tJCBlock body = maker.Block(0, List.<JCStatement>of(statement));\n\t\tint modifiers = Flags.PRIVATE | Flags.STATIC;\n\t\tJCMethodDecl defaultProvider = maker.MethodDef(maker.Modifiers(modifiers), methodName, cloneType(maker, field.vartype, fieldNode), copyTypeParams(fieldNode, params), List.<JCVariableDecl>nil(), List.<JCExpression>nil(), body, null);\n\t\t// ... then we convert short array initializers from `{1,2}` to `new int[]{1,2}` ...\n\t\tif (init instanceof JCNewArray && field.vartype instanceof JCArrayTypeTree) {\n\t\t\tJCNewArray arrayInitializer = (JCNewArray) init;\n\t\t\tJCArrayTypeTree fieldType = (JCArrayTypeTree) field.vartype;\n\t\t\tif (arrayInitializer.elemtype == null) {\n\t\t\t\tarrayInitializer.elemtype = cloneType(maker, fieldType.elemtype, fieldNode);\n\t\t\t}\n\t\t}\n\t\t// ... then we set positions for everything else ...\n\t\trecursiveSetGeneratedBy(defaultProvider, job.sourceNode);\n\t\t// ... and finally add back the original expression\n\t\tstatement.expr = init;\n\t\treturn defaultProvider;\n\t}\n\t\n\tpublic JCMethodDecl generateBuilderMethod(BuilderJob job) {\n\t\t//String builderClassName, JavacNode source, JavacNode type, List<JCTypeParameter> typeParams, AccessLevel access) {\n\t\t//builderClassName, annotationNode, tdParent, typeParams, accessForOuters);\n\t\t\n\t\tJavacTreeMaker maker = job.getTreeMaker();\n\t\t\n\t\tJCExpression call;\n\t\tif (job.isStatic) {\n\t\t\tcall = maker.NewClass(null, List.<JCExpression>nil(), namePlusTypeParamsToTypeReference(maker, job.parentType, job.toName(job.builderClassName), false, job.typeParams), List.<JCExpression>nil(), null);\n\t\t} else {\n\t\t\tcall = maker.NewClass(null, List.<JCExpression>nil(), namePlusTypeParamsToTypeReference(maker, null, job.toName(job.builderClassName), false, job.typeParams), List.<JCExpression>nil(), null);\n\t\t\t((JCNewClass) call).encl = maker.Ident(job.toName(\"this\"));\n\t\t\t\n\t\t}\n\t\tJCStatement statement = maker.Return(call);\n\t\t\n\t\tJCBlock body = maker.Block(0, List.<JCStatement>of(statement));\n\t\tint modifiers = toJavacModifier(job.accessOuters);\n\t\tif (job.isStatic) modifiers |= Flags.STATIC;\n\t\tList<JCAnnotation> annsOnMethod = List.nil();\n\t\tif (job.checkerFramework.generateSideEffectFree()) annsOnMethod = List.of(maker.Annotation(genTypeRef(job.parentType, CheckerFrameworkVersion.NAME__SIDE_EFFECT_FREE), List.<JCExpression>nil()));\n\t\tList<JCAnnotation> annsOnParamType = List.nil();\n\t\tif (job.checkerFramework.generateUnique()) annsOnParamType = List.of(maker.Annotation(genTypeRef(job.parentType, CheckerFrameworkVersion.NAME__UNIQUE), List.<JCExpression>nil()));\n\t\t\n\t\tJCExpression returnType = namePlusTypeParamsToTypeReference(maker, job.parentType, job.getBuilderClassName(), !job.isStatic, job.builderTypeParams, annsOnParamType);\n\t\tJCMethodDecl methodDef = maker.MethodDef(maker.Modifiers(modifiers, annsOnMethod), job.toName(job.builderMethodName), returnType, job.copyTypeParams(), List.<JCVariableDecl>nil(), List.<JCExpression>nil(), body, null);\n\t\tcreateRelevantNonNullAnnotation(job.parentType, methodDef);\n\t\treturn methodDef;\n\t}\n\t\n\tpublic void generateBuilderFields(BuilderJob job) {\n\t\tint len = job.builderFields.size();\n\t\tjava.util.List<JavacNode> existing = new ArrayList<JavacNode>();\n\t\tfor (JavacNode child : job.builderType.down()) {\n\t\t\tif (child.getKind() == Kind.FIELD) existing.add(child);\n\t\t}\n\t\t\n\t\tjava.util.List<JCVariableDecl> generated = new ArrayList<JCVariableDecl>();\n\t\t\n\t\tfor (int i = len - 1; i >= 0; i--) {\n\t\t\tBuilderFieldData bfd = job.builderFields.get(i);\n\t\t\tif (bfd.singularData != null && bfd.singularData.getSingularizer() != null) {\n\t\t\t\tjava.util.List<JavacNode> generateSingularFields = bfd.singularData.getSingularizer().generateFields(bfd.singularData, job.builderType, job.sourceNode);\n\t\t\t\tfor (JavacNode field : generateSingularFields) {\n\t\t\t\t\tgenerated.add((JCVariableDecl) field.get());\n\t\t\t\t}\n\t\t\t\tbfd.createdFields.addAll(generateSingularFields);\n\t\t\t} else {\n\t\t\t\tJavacNode field = null, setFlag = null;\n\t\t\t\tfor (JavacNode exists : existing) {\n\t\t\t\t\tName n = ((JCVariableDecl) exists.get()).name;\n\t\t\t\t\tif (n.equals(bfd.builderFieldName)) field = exists;\n\t\t\t\t\tif (n.equals(bfd.nameOfSetFlag)) setFlag = exists;\n\t\t\t\t}\n\t\t\t\tJavacTreeMaker maker = job.getTreeMaker();\n\t\t\t\tif (field == null) {\n\t\t\t\t\tJCModifiers mods = maker.Modifiers(Flags.PRIVATE);\n\t\t\t\t\tJCVariableDecl newField = maker.VarDef(mods, bfd.builderFieldName, cloneType(maker, bfd.type, job.sourceNode), null);\n\t\t\t\t\tfield = injectFieldAndMarkGenerated(job.builderType, newField);\n\t\t\t\t\tgenerated.add(newField);\n\t\t\t\t}\n\t\t\t\tif (setFlag == null && bfd.nameOfSetFlag != null) {\n\t\t\t\t\tJCModifiers mods = maker.Modifiers(Flags.PRIVATE);\n\t\t\t\t\tJCVariableDecl newField = maker.VarDef(mods, bfd.nameOfSetFlag, maker.TypeIdent(CTC_BOOLEAN), null);\n\t\t\t\t\tinjectFieldAndMarkGenerated(job.builderType, newField);\n\t\t\t\t\tgenerated.add(newField);\n\t\t\t\t}\n\t\t\t\tbfd.createdFields.add(field);\n\t\t\t}\n\t\t}\n\t\tfor (JCVariableDecl gen : generated) recursiveSetGeneratedBy(gen, job.sourceNode);\n\t}\n\t\n\tpublic void makePrefixedSetterMethodsForBuilder(BuilderJob job, BuilderFieldData bfd, String prefix) {\n\t\tboolean deprecate = isFieldDeprecated(bfd.originalFieldNode);\n\t\tif (bfd.singularData == null || bfd.singularData.getSingularizer() == null) {\n\t\t\tmakePrefixedSetterMethodForBuilder(job, bfd, deprecate, prefix);\n\t\t} else {\n\t\t\tbfd.singularData.getSingularizer().generateMethods(job, bfd.singularData, deprecate);\n\t\t}\n\t}\n\t\n\tprivate void makePrefixedSetterMethodForBuilder(BuilderJob job, BuilderFieldData bfd, boolean deprecate, String prefix) {\n\t\tJavacNode fieldNode = bfd.createdFields.get(0);\n\t\tString setterPrefix = !prefix.isEmpty() ? prefix : job.oldFluent ? \"\" : \"set\";\n\t\tString setterName = HandlerUtil.buildAccessorName(job.sourceNode, setterPrefix, bfd.name.toString());\n\t\tName setterName_ = job.builderType.toName(setterName);\n\t\t\n\t\tfor (JavacNode child : job.builderType.down()) {\n\t\t\tif (child.getKind() != Kind.METHOD) continue;\n\t\t\tJCMethodDecl methodDecl = (JCMethodDecl) child.get();\n\t\t\tName existingName = methodDecl.name;\n\t\t\tif (existingName.equals(setterName_) && !isTolerate(fieldNode, methodDecl)) return;\n\t\t}\n\t\t\n\t\tJavacTreeMaker maker = fieldNode.getTreeMaker();\n\t\t\n\t\tList<JCAnnotation> methodAnns = JavacHandlerUtil.findCopyableToSetterAnnotations(bfd.originalFieldNode);\n\t\tJCMethodDecl newMethod = HandleSetter.createSetter(toJavacModifier(job.accessInners), deprecate, fieldNode, maker, setterName, bfd.name, bfd.nameOfSetFlag, job.oldChain, job.sourceNode, methodAnns, bfd.annotations);\n\t\trecursiveSetGeneratedBy(newMethod, job.sourceNode);\n\t\tif (job.sourceNode.up().getKind() == Kind.METHOD) {\n\t\t\tcopyJavadocFromParam(bfd.originalFieldNode.up(), newMethod, bfd.name.toString());\n\t\t} else {\n\t\t\tcopyJavadoc(bfd.originalFieldNode, newMethod, CopyJavadoc.SETTER, true);\n\t\t}\n\t\t\n\t\tinjectMethod(job.builderType, newMethod);\n\t}\n\t\n\tprivate void copyJavadocFromParam(JavacNode from, JCMethodDecl to, String param) {\n\t\ttry {\n\t\t\tJCCompilationUnit cu = ((JCCompilationUnit) from.top().get());\n\t\t\tString methodComment = Javac.getDocComment(cu, from.get());\n\t\t\tString newJavadoc = addReturnsThisIfNeeded(getParamJavadoc(methodComment, param));\n\t\t\tJavac.setDocComment(cu, to, newJavadoc);\n\t\t} catch (Exception ignore) {}\n\t}\t\n\t\n\tpublic JavacNode makeBuilderClass(BuilderJob job) {\n\t\t//boolean isStatic, JavacNode source, JavacNode tdParent, String builderClassName, List<JCTypeParameter> typeParams, JCAnnotation ast, AccessLevel access) {\n\t\t//isStatic, annotationNode, tdParent, builderClassName, typeParams, ast, accessForOuters\n\t\tJavacTreeMaker maker = job.getTreeMaker();\n\t\tint modifiers = toJavacModifier(job.accessOuters);\n\t\tif (job.isStatic) modifiers |= Flags.STATIC;\n\t\tJCModifiers mods = maker.Modifiers(modifiers);\n\t\tJCClassDecl builder = maker.ClassDef(mods, job.getBuilderClassName(), job.copyTypeParams(), null, List.<JCExpression>nil(), List.<JCTree>nil());\n\t\trecursiveSetGeneratedBy(builder, job.sourceNode);\n\t\treturn injectType(job.parentType, builder);\n\t}\n\t\n\tprivate void addObtainVia(BuilderFieldData bfd, JavacNode node) {\n\t\tfor (JavacNode child : node.down()) {\n\t\t\tif (!annotationTypeMatches(ObtainVia.class, child)) continue;\n\t\t\tAnnotationValues<ObtainVia> ann = createAnnotation(ObtainVia.class, child);\n\t\t\tbfd.obtainVia = ann.getInstance();\n\t\t\tbfd.obtainViaNode = child;\n\t\t\tdeleteAnnotationIfNeccessary(child, ObtainVia.class);\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\t/**\n\t * Returns the explicitly requested singular annotation on this node (field\n\t * or parameter), or null if there's no {@code @Singular} annotation on it.\n\t * \n\t * @param node The node (field or method param) to inspect for its name and potential {@code @Singular} annotation.\n\t * @param setterPrefix Explicitly requested setter prefix.\n\t */\n\tprivate SingularData getSingularData(JavacNode node, String setterPrefix) {\n\t\tfor (JavacNode child : node.down()) {\n\t\t\tif (!annotationTypeMatches(Singular.class, child)) continue;\n\t\t\tName pluralName = node.getKind() == Kind.FIELD ? removePrefixFromField(node) : ((JCVariableDecl) node.get()).name;\n\t\t\tAnnotationValues<Singular> ann = createAnnotation(Singular.class, child);\n\t\t\tSingular singularInstance = ann.getInstance();\n\t\t\tdeleteAnnotationIfNeccessary(child, Singular.class);\n\t\t\tString explicitSingular = singularInstance.value();\n\t\t\tif (explicitSingular.isEmpty()) {\n\t\t\t\tif (Boolean.FALSE.equals(node.getAst().readConfiguration(ConfigurationKeys.SINGULAR_AUTO))) {\n\t\t\t\t\tnode.addError(\"The singular must be specified explicitly (e.g. @Singular(\\\"task\\\")) because auto singularization is disabled.\");\n\t\t\t\t\texplicitSingular = pluralName.toString();\n\t\t\t\t} else {\n\t\t\t\t\texplicitSingular = autoSingularize(pluralName.toString());\n\t\t\t\t\tif (explicitSingular == null) {\n\t\t\t\t\t\tnode.addError(\"Can't singularize this name; please specify the singular explicitly (i.e. @Singular(\\\"sheep\\\"))\");\n\t\t\t\t\t\texplicitSingular = pluralName.toString();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tName singularName = node.toName(explicitSingular);\n\t\t\t\n\t\t\tJCExpression type = null;\n\t\t\tif (node.get() instanceof JCVariableDecl) {\n\t\t\t\ttype = ((JCVariableDecl) node.get()).vartype;\n\t\t\t}\n\t\t\t\n\t\t\tString name = null;\n\t\t\tList<JCExpression> typeArgs = List.nil();\n\t\t\tif (type instanceof JCTypeApply) {\n\t\t\t\ttypeArgs = ((JCTypeApply) type).arguments;\n\t\t\t\ttype = ((JCTypeApply) type).clazz;\n\t\t\t}\n\t\t\t\n\t\t\tname = type.toString();\n\t\t\t\n\t\t\tString targetFqn = JavacSingularsRecipes.get().toQualified(name);\n\t\t\tJavacSingularizer singularizer = JavacSingularsRecipes.get().getSingularizer(targetFqn, node);\n\t\t\tif (singularizer == null) {\n\t\t\t\tnode.addError(\"Lombok does not know how to create the singular-form builder methods for type '\" + name + \"'; they won't be generated.\");\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t\n\t\t\treturn new SingularData(child, singularName, pluralName, typeArgs, targetFqn, singularizer, singularInstance.ignoreNullCollections(), setterPrefix);\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2013-2021 The Project Lombok Authors.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage lombok.javac.handlers;\n\nimport static lombok.core.handlers.HandlerUtil.*;\nimport static lombok.javac.Javac.*;\nimport static lombok.javac.JavacTreeMaker.TypeTag.typeTag;\nimport static lombok.javac.handlers.JavacHandlerUtil.*;\n\nimport java.util.ArrayList;\n\nimport javax.lang.model.element.Modifier;\n\nimport com.sun.tools.javac.code.Flags;\nimport com.sun.tools.javac.tree.JCTree;\nimport com.sun.tools.javac.tree.JCTree.JCAnnotation;\nimport com.sun.tools.javac.tree.JCTree.JCArrayTypeTree;\nimport com.sun.tools.javac.tree.JCTree.JCBlock;\nimport com.sun.tools.javac.tree.JCTree.JCClassDecl;\nimport com.sun.tools.javac.tree.JCTree.JCCompilationUnit;\nimport com.sun.tools.javac.tree.JCTree.JCExpression;\nimport com.sun.tools.javac.tree.JCTree.JCFieldAccess;\nimport com.sun.tools.javac.tree.JCTree.JCIdent;\nimport com.sun.tools.javac.tree.JCTree.JCIf;\nimport com.sun.tools.javac.tree.JCTree.JCLiteral;\nimport com.sun.tools.javac.tree.JCTree.JCMethodDecl;\nimport com.sun.tools.javac.tree.JCTree.JCMethodInvocation;\nimport com.sun.tools.javac.tree.JCTree.JCModifiers;\nimport com.sun.tools.javac.tree.JCTree.JCNewArray;\nimport com.sun.tools.javac.tree.JCTree.JCNewClass;\nimport com.sun.tools.javac.tree.JCTree.JCPrimitiveTypeTree;\nimport com.sun.tools.javac.tree.JCTree.JCReturn;\nimport com.sun.tools.javac.tree.JCTree.JCStatement;\nimport com.sun.tools.javac.tree.JCTree.JCTypeApply;\nimport com.sun.tools.javac.tree.JCTree.JCTypeParameter;\nimport com.sun.tools.javac.tree.JCTree.JCVariableDecl;\nimport com.sun.tools.javac.util.Context;\nimport com.sun.tools.javac.util.List;\nimport com.sun.tools.javac.util.ListBuffer;\nimport com.sun.tools.javac.util.Name;\n\nimport lombok.AccessLevel;\nimport lombok.Builder;\nimport lombok.Builder.ObtainVia;\nimport lombok.ConfigurationKeys;\nimport lombok.Singular;\nimport lombok.ToString;\nimport lombok.core.AST.Kind;\nimport lombok.core.AnnotationValues;\nimport lombok.core.HandlerPriority;\nimport lombok.core.configuration.CheckerFrameworkVersion;\nimport lombok.core.handlers.HandlerUtil;\nimport lombok.core.handlers.HandlerUtil.FieldAccess;\nimport lombok.core.handlers.InclusionExclusionUtils.Included;\nimport lombok.experimental.NonFinal;\nimport lombok.javac.Javac;\nimport lombok.javac.JavacAnnotationHandler;\nimport lombok.javac.JavacNode;\nimport lombok.javac.JavacTreeMaker;\nimport lombok.javac.handlers.HandleConstructor.SkipIfConstructorExists;\nimport lombok.javac.handlers.JavacHandlerUtil.CopyJavadoc;\nimport lombok.javac.handlers.JavacHandlerUtil.MemberExistsResult;\nimport lombok.javac.handlers.JavacSingularsRecipes.JavacSingularizer;\nimport lombok.javac.handlers.JavacSingularsRecipes.SingularData;\nimport lombok.spi.Provides;\n\n@Provides\n@HandlerPriority(-1024) //-2^10; to ensure we've picked up @FieldDefault's changes (-2048) but @Value hasn't removed itself yet (-512), so that we can error on presence of it on the builder classes.\npublic class HandleBuilder extends JavacAnnotationHandler<Builder> {\n\tprivate HandleConstructor handleConstructor = new HandleConstructor();\n\t\n\tstatic final String CLEAN_FIELD_NAME = \"$lombokUnclean\";\n\tstatic final String CLEAN_METHOD_NAME = \"$lombokClean\";\n\tstatic final String TO_BUILDER_METHOD_NAME = \"toBuilder\";\n\tstatic final String DEFAULT_PREFIX = \"$default$\";\n\tstatic final String SET_PREFIX = \"$set\";\n\tstatic final String VALUE_PREFIX = \"$value\";\n\tstatic final String BUILDER_TEMP_VAR = \"builder\";\n\tstatic final String TO_BUILDER_NOT_SUPPORTED = \"@Builder(toBuilder=true) is only supported if you return your own type.\";\n\t\n\tprivate static final boolean toBoolean(Object expr, boolean defaultValue) {\n\t\tif (expr == null) return defaultValue;\n\t\tif (expr instanceof JCLiteral) return ((Integer) ((JCLiteral) expr).value) != 0;\n\t\treturn ((Boolean) expr).booleanValue();\n\t}\n\t\n\tstatic class BuilderJob {\n\t\tCheckerFrameworkVersion checkerFramework;\n\t\tJavacNode parentType;\n\t\tString builderMethodName, buildMethodName;\n\t\tboolean isStatic;\n\t\tList<JCTypeParameter> typeParams;\n\t\tList<JCTypeParameter> builderTypeParams;\n\t\tJavacNode sourceNode;\n\t\tjava.util.List<BuilderFieldData> builderFields;\n\t\tAccessLevel accessInners, accessOuters;\n\t\tboolean oldFluent, oldChain, toBuilder;\n\t\t\n\t\tJavacNode builderType;\n\t\tString builderClassName;\n\t\t\n\t\tvoid init(AnnotationValues<Builder> annValues, Builder ann, JavacNode node) {\n\t\t\taccessOuters = ann.access();\n\t\t\tif (accessOuters == null) accessOuters = AccessLevel.PUBLIC;\n\t\t\tif (accessOuters == AccessLevel.NONE) {\n\t\t\t\tsourceNode.addError(\"AccessLevel.NONE is not valid here\");\n\t\t\t\taccessOuters = AccessLevel.PUBLIC;\n\t\t\t}\n\t\t\taccessInners = accessOuters == AccessLevel.PROTECTED ? AccessLevel.PUBLIC : accessOuters;\n\t\t\t\n\t\t\toldFluent = toBoolean(annValues.getActualExpression(\"fluent\"), true);\n\t\t\toldChain = toBoolean(annValues.getActualExpression(\"chain\"), true);\n\t\t\t\n\t\t\tbuilderMethodName = ann.builderMethodName();\n\t\t\tbuildMethodName = ann.buildMethodName();\n\t\t\tbuilderClassName = getBuilderClassNameTemplate(node, ann.builderClassName());\n\t\t\ttoBuilder = ann.toBuilder();\n\t\t\t\n\t\t\tif (builderMethodName == null) builderMethodName = \"builder\";\n\t\t\tif (buildMethodName == null) buildMethodName = \"build\";\n\t\t\tif (builderClassName == null) builderClassName = \"\";\n\t\t}\n\t\t\n\t\tstatic String getBuilderClassNameTemplate(JavacNode node, String override) {\n\t\t\tif (override != null && !override.isEmpty()) return override;\n\t\t\toverride = node.getAst().readConfiguration(ConfigurationKeys.BUILDER_CLASS_NAME);\n\t\t\tif (override != null && !override.isEmpty()) return override;\n\t\t\treturn \"*Builder\";\n\t\t}\n\t\t\n\t\tString replaceBuilderClassName(Name name) {\n\t\t\treturn replaceBuilderClassName(name.toString(), builderClassName);\n\t\t}\n\t\t\n\t\tString replaceBuilderClassName(String name, String template) {\n\t\t\tif (template.indexOf('*') == -1) return template;\n\t\t\treturn template.replace(\"*\", name);\n\t\t}\n\t\t\n\t\tJCExpression createBuilderParentTypeReference() {\n\t\t\treturn namePlusTypeParamsToTypeReference(parentType.getTreeMaker(), parentType, typeParams);\n\t\t}\n\t\t\n\t\tName getBuilderClassName() {\n\t\t\treturn parentType.toName(builderClassName);\n\t\t}\n\t\t\n\t\tList<JCTypeParameter> copyTypeParams() {\n\t\t\treturn JavacHandlerUtil.copyTypeParams(sourceNode, typeParams);\n\t\t}\n\t\t\n\t\tName toName(String name) {\n\t\t\treturn parentType.toName(name);\n\t\t}\n\t\t\n\t\tContext getContext() {\n\t\t\treturn parentType.getContext();\n\t\t}\n\t\t\n\t\tJavacTreeMaker getTreeMaker() {\n\t\t\treturn parentType.getTreeMaker();\n\t\t}\n\t}\n\t\n\tstatic class BuilderFieldData {\n\t\tList<JCAnnotation> annotations;\n\t\tJCExpression type;\n\t\tName rawName;\n\t\tName name;\n\t\tName builderFieldName;\n\t\tName nameOfDefaultProvider;\n\t\tName nameOfSetFlag;\n\t\tSingularData singularData;\n\t\tObtainVia obtainVia;\n\t\tJavacNode obtainViaNode;\n\t\tJavacNode originalFieldNode;\n\t\t\n\t\tjava.util.List<JavacNode> createdFields = new ArrayList<JavacNode>();\n\t}\n\t\n\t@Override public void handle(AnnotationValues<Builder> annotation, JCAnnotation ast, JavacNode annotationNode) {\n\t\tfinal String BUILDER_NODE_NOT_SUPPORTED_ERR = \"@Builder is only supported on classes, records, constructors, and methods.\";\n\t\t\n\t\thandleFlagUsage(annotationNode, ConfigurationKeys.BUILDER_FLAG_USAGE, \"@Builder\");\n\t\tBuilderJob job = new BuilderJob();\n\t\tjob.sourceNode = annotationNode;\n\t\tjob.checkerFramework = getCheckerFrameworkVersion(annotationNode);\n\t\tjob.isStatic = true;\n\t\t\n\t\tBuilder annInstance = annotation.getInstance();\n\t\tjob.init(annotation, annInstance, annotationNode);\n\t\tjava.util.List<Name> typeArgsForToBuilder = null;\n\t\t\n\t\tboolean generateBuilderMethod;\n\t\tif (job.builderMethodName.isEmpty()) {\n\t\t\tgenerateBuilderMethod = false;\n\t\t} else if (!checkName(\"builderMethodName\", job.builderMethodName, annotationNode)) {\n\t\t\treturn;\n\t\t} else {\n\t\t\tgenerateBuilderMethod = true;\n\t\t}\n\t\t\n\t\tif (!checkName(\"buildMethodName\", job.buildMethodName, annotationNode)) return;\n\t\t\n\t\t// Do not delete the Builder annotation yet, we need it for @Jacksonized.\n\t\t\n\t\tJavacNode parent = annotationNode.up();\n\t\t\n\t\tjob.builderFields = new ArrayList<BuilderFieldData>();\n\t\tJCExpression buildMethodReturnType;\n\t\tjob.typeParams = List.nil();\n\t\tList<JCExpression> buildMethodThrownExceptions;\n\t\tName nameOfBuilderMethod;\n\t\t\n\t\tJavacNode fillParametersFrom = parent.get() instanceof JCMethodDecl ? parent : null;\n\t\tboolean addCleaning = false;\n\t\t\n\t\tArrayList<JavacNode> nonFinalNonDefaultedFields = null;\n\t\t\n\t\tif (!isStaticAllowed(upToTypeNode(parent))) {\n\t\t\tannotationNode.addError(\"@Builder is not supported on non-static nested classes.\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (parent.get() instanceof JCClassDecl) {\n\t\t\tif (!isClass(parent) && !isRecord(parent)) {\n\t\t\t\tannotationNode.addError(BUILDER_NODE_NOT_SUPPORTED_ERR);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tjob.parentType = parent;\n\t\t\tJCClassDecl td = (JCClassDecl) parent.get();\n\t\t\t\n\t\t\tListBuffer<JavacNode> allFields = new ListBuffer<JavacNode>();\n\t\t\tboolean valuePresent = (hasAnnotation(lombok.Value.class, parent) || hasAnnotation(\"lombok.experimental.Value\", parent));\n\t\t\tfor (JavacNode fieldNode : HandleConstructor.findAllFields(parent, true)) {\n\t\t\t\tJCVariableDecl fd = (JCVariableDecl) fieldNode.get();\n\t\t\t\tJavacNode isDefault = findAnnotation(Builder.Default.class, fieldNode, false);\n\t\t\t\tboolean isFinal = (fd.mods.flags & Flags.FINAL) != 0 || (valuePresent && !hasAnnotation(NonFinal.class, fieldNode));\n\t\t\t\t\n\t\t\t\tBuilderFieldData bfd = new BuilderFieldData();\n\t\t\t\tbfd.rawName = fd.name;\n\t\t\t\tbfd.name = removePrefixFromField(fieldNode);\n\t\t\t\tbfd.builderFieldName = bfd.name;\n\t\t\t\tbfd.annotations = findCopyableAnnotations(fieldNode);\n\t\t\t\tbfd.type = fd.vartype;\n\t\t\t\tbfd.singularData = getSingularData(fieldNode, annInstance.setterPrefix());\n\t\t\t\tbfd.originalFieldNode = fieldNode;\n\t\t\t\t\n\t\t\t\tif (bfd.singularData != null && isDefault != null) {\n\t\t\t\t\tisDefault.addError(\"@Builder.Default and @Singular cannot be mixed.\");\n\t\t\t\t\tfindAnnotation(Builder.Default.class, fieldNode, true);\n\t\t\t\t\tisDefault = null;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (fd.init == null && isDefault != null) {\n\t\t\t\t\tisDefault.addWarning(\"@Builder.Default requires an initializing expression (' = something;').\");\n\t\t\t\t\tfindAnnotation(Builder.Default.class, fieldNode, true);\n\t\t\t\t\tisDefault = null;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (fd.init != null && isDefault == null) {\n\t\t\t\t\tif (isFinal) continue;\n\t\t\t\t\tif (nonFinalNonDefaultedFields == null) nonFinalNonDefaultedFields = new ArrayList<JavacNode>();\n\t\t\t\t\tnonFinalNonDefaultedFields.add(fieldNode);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (isDefault != null) {\n\t\t\t\t\tbfd.nameOfDefaultProvider = parent.toName(DEFAULT_PREFIX + bfd.name);\n\t\t\t\t\tbfd.nameOfSetFlag = parent.toName(bfd.name + SET_PREFIX);\n\t\t\t\t\tbfd.builderFieldName = parent.toName(bfd.name + VALUE_PREFIX);\n\t\t\t\t\tJCMethodDecl md = generateDefaultProvider(bfd.nameOfDefaultProvider, fieldNode, td.typarams, job);\n\t\t\t\t\tif (md != null) injectMethod(parent, md);\n\t\t\t\t}\n\t\t\t\taddObtainVia(bfd, fieldNode);\n\t\t\t\tjob.builderFields.add(bfd);\n\t\t\t\tallFields.append(fieldNode);\n\t\t\t}\n\t\t\t\n\t\t\tif (!isRecord(parent)) {\n\t\t\t\t// Records ship with a canonical constructor that acts as @AllArgsConstructor - just use that one.\n\t\t\t\t\n\t\t\t\thandleConstructor.generateConstructor(parent, AccessLevel.PACKAGE, List.<JCAnnotation>nil(), allFields.toList(), false, null, SkipIfConstructorExists.I_AM_BUILDER, annotationNode);\n\t\t\t}\n\t\t\t\n\t\t\tbuildMethodReturnType = namePlusTypeParamsToTypeReference(parent.getTreeMaker(), parent, td.typarams);\n\t\t\tjob.typeParams = job.builderTypeParams = td.typarams;\n\t\t\tbuildMethodThrownExceptions = List.nil();\n\t\t\tnameOfBuilderMethod = null;\n\t\t\tjob.builderClassName = job.replaceBuilderClassName(td.name);\n\t\t\tif (!checkName(\"builderClassName\", job.builderClassName, annotationNode)) return;\n\t\t} else if (fillParametersFrom != null && fillParametersFrom.getName().toString().equals(\"<init>\")) {\n\t\t\tJCMethodDecl jmd = (JCMethodDecl) fillParametersFrom.get();\n\t\t\tif (!jmd.typarams.isEmpty()) {\n\t\t\t\tannotationNode.addError(\"@Builder is not supported on constructors with constructor type parameters.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tjob.parentType = parent.up();\n\t\t\tJCClassDecl td = (JCClassDecl) job.parentType.get();\n\t\t\tjob.typeParams = job.builderTypeParams = td.typarams;\n\t\t\tbuildMethodReturnType = job.createBuilderParentTypeReference();\n\t\t\tbuildMethodThrownExceptions = jmd.thrown;\n\t\t\tnameOfBuilderMethod = null;\n\t\t\tjob.builderClassName = job.replaceBuilderClassName(td.name);\n\t\t\tif (!checkName(\"builderClassName\", job.builderClassName, annotationNode)) return;\n\t\t} else if (fillParametersFrom != null) {\n\t\t\tjob.parentType = parent.up();\n\t\t\tJCClassDecl td = (JCClassDecl) job.parentType.get();\n\t\t\tJCMethodDecl jmd = (JCMethodDecl) fillParametersFrom.get();\n\t\t\tjob.isStatic = (jmd.mods.flags & Flags.STATIC) != 0;\n\t\t\t\n\t\t\tJCExpression fullReturnType = jmd.restype;\n\t\t\tbuildMethodReturnType = fullReturnType;\n\t\t\tjob.typeParams = job.builderTypeParams = jmd.typarams;\n\t\t\tbuildMethodThrownExceptions = jmd.thrown;\n\t\t\tnameOfBuilderMethod = jmd.name;\n\t\t\tif (buildMethodReturnType instanceof JCTypeApply) {\n\t\t\t\tbuildMethodReturnType = cloneType(job.getTreeMaker(), buildMethodReturnType, annotationNode);\n\t\t\t}\n\t\t\tif (job.builderClassName.indexOf('*') > -1) {\n\t\t\t\tString replStr = returnTypeToBuilderClassName(annotationNode, td, buildMethodReturnType, job.typeParams);\n\t\t\t\tif (replStr == null) return; // shuold not happen\n\t\t\t\tjob.builderClassName = job.builderClassName.replace(\"*\", replStr);\n\t\t\t}\n\t\t\tif (job.toBuilder) {\n\t\t\t\tif (fullReturnType instanceof JCArrayTypeTree) {\n\t\t\t\t\tannotationNode.addError(TO_BUILDER_NOT_SUPPORTED);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tName simpleName;\n\t\t\t\tString pkg;\n\t\t\t\tList<JCExpression> tpOnRet = List.nil();\n\t\t\t\t\n\t\t\t\tif (fullReturnType instanceof JCTypeApply) {\n\t\t\t\t\ttpOnRet = ((JCTypeApply) fullReturnType).arguments;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tJCExpression namingType = fullReturnType;\n\t\t\t\tif (buildMethodReturnType instanceof JCTypeApply) namingType = ((JCTypeApply) buildMethodReturnType).clazz;\n\t\t\t\t\n\t\t\t\tif (namingType instanceof JCIdent) {\n\t\t\t\t\tsimpleName = ((JCIdent) namingType).name;\n\t\t\t\t\tpkg = null;\n\t\t\t\t} else if (namingType instanceof JCFieldAccess) {\n\t\t\t\t\tJCFieldAccess jcfa = (JCFieldAccess) namingType;\n\t\t\t\t\tsimpleName = jcfa.name;\n\t\t\t\t\tpkg = unpack(jcfa.selected);\n\t\t\t\t\tif (pkg.startsWith(\"ERR:\")) {\n\t\t\t\t\t\tString err = pkg.substring(4, pkg.indexOf(\"__ERR__\"));\n\t\t\t\t\t\tannotationNode.addError(err);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tannotationNode.addError(\"Expected a (parameterized) type here instead of a \" + namingType.getClass().getName());\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (pkg != null && !parent.getPackageDeclaration().equals(pkg)) {\n\t\t\t\t\tannotationNode.addError(TO_BUILDER_NOT_SUPPORTED);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!job.parentType.getName().contentEquals(simpleName)) {\n\t\t\t\t\tannotationNode.addError(TO_BUILDER_NOT_SUPPORTED);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tList<JCTypeParameter> tpOnMethod = jmd.typarams;\n\t\t\t\tList<JCTypeParameter> tpOnType = ((JCClassDecl) job.parentType.get()).typarams;\n\t\t\t\ttypeArgsForToBuilder = new ArrayList<Name>();\n\t\t\t\t\n\t\t\t\tfor (JCTypeParameter tp : tpOnMethod) {\n\t\t\t\t\tint pos = -1;\n\t\t\t\t\tint idx = -1;\n\t\t\t\t\tfor (JCExpression tOnRet : tpOnRet) {\n\t\t\t\t\t\tidx++;\n\t\t\t\t\t\tif (!(tOnRet instanceof JCIdent)) continue;\n\t\t\t\t\t\tif (((JCIdent) tOnRet).name != tp.name) continue;\n\t\t\t\t\t\tpos = idx;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (pos == -1 || tpOnType.size() <= pos) {\n\t\t\t\t\t\tannotationNode.addError(\"@Builder(toBuilder=true) requires that each type parameter on the static method is part of the typeargs of the return value. Type parameter \" + tp.name + \" is not part of the return type.\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\ttypeArgsForToBuilder.add(tpOnType.get(pos).name);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tannotationNode.addError(BUILDER_NODE_NOT_SUPPORTED_ERR);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (fillParametersFrom != null) {\n\t\t\tfor (JavacNode param : fillParametersFrom.down()) {\n\t\t\t\tif (param.getKind() != Kind.ARGUMENT) continue;\n\t\t\t\tBuilderFieldData bfd = new BuilderFieldData();\n\t\t\t\t\n\t\t\t\tJCVariableDecl raw = (JCVariableDecl) param.get();\n\t\t\t\tbfd.name = raw.name;\n\t\t\t\tbfd.builderFieldName = bfd.name;\n\t\t\t\tbfd.rawName = raw.name;\n\t\t\t\tbfd.annotations = findCopyableAnnotations(param);\n\t\t\t\tbfd.type = raw.vartype;\n\t\t\t\tbfd.singularData = getSingularData(param, annInstance.setterPrefix());\n\t\t\t\tbfd.originalFieldNode = param;\n\t\t\t\taddObtainVia(bfd, param);\n\t\t\t\tjob.builderFields.add(bfd);\n\t\t\t}\n\t\t}\n\t\t\n\t\tjob.builderType = findInnerClass(job.parentType, job.builderClassName);\n\t\tif (job.builderType == null) {\n\t\t\tjob.builderType = makeBuilderClass(job);\n\t\t\trecursiveSetGeneratedBy(job.builderType.get(), annotationNode);\n\t\t} else {\n\t\t\tJCClassDecl builderTypeDeclaration = (JCClassDecl) job.builderType.get();\n\t\t\tif (job.isStatic && !builderTypeDeclaration.getModifiers().getFlags().contains(Modifier.STATIC)) {\n\t\t\t\tannotationNode.addError(\"Existing Builder must be a static inner class.\");\n\t\t\t\treturn;\n\t\t\t} else if (!job.isStatic && builderTypeDeclaration.getModifiers().getFlags().contains(Modifier.STATIC)) {\n\t\t\t\tannotationNode.addError(\"Existing Builder must be a non-static inner class.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsanityCheckForMethodGeneratingAnnotationsOnBuilderClass(job.builderType, annotationNode);\n\t\t\t/* generate errors for @Singular BFDs that have one already defined node. */ {\n\t\t\t\tfor (BuilderFieldData bfd : job.builderFields) {\n\t\t\t\t\tSingularData sd = bfd.singularData;\n\t\t\t\t\tif (sd == null) continue;\n\t\t\t\t\tJavacSingularizer singularizer = sd.getSingularizer();\n\t\t\t\t\tif (singularizer == null) continue;\n\t\t\t\t\tif (singularizer.checkForAlreadyExistingNodesAndGenerateError(job.builderType, sd)) {\n\t\t\t\t\t\tbfd.singularData = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (BuilderFieldData bfd : job.builderFields) {\n\t\t\tif (bfd.singularData != null && bfd.singularData.getSingularizer() != null) {\n\t\t\t\tif (bfd.singularData.getSingularizer().requiresCleaning()) {\n\t\t\t\t\taddCleaning = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (bfd.obtainVia != null) {\n\t\t\t\tif (bfd.obtainVia.field().isEmpty() == bfd.obtainVia.method().isEmpty()) {\n\t\t\t\t\tbfd.obtainViaNode.addError(\"The syntax is either @ObtainVia(field = \\\"fieldName\\\") or @ObtainVia(method = \\\"methodName\\\").\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (bfd.obtainVia.method().isEmpty() && bfd.obtainVia.isStatic()) {\n\t\t\t\t\tbfd.obtainViaNode.addError(\"@ObtainVia(isStatic = true) is not valid unless 'method' has been set.\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tgenerateBuilderFields(job);\n\t\tif (addCleaning) {\n\t\t\tJavacTreeMaker maker = job.getTreeMaker();\n\t\t\tJCVariableDecl uncleanField = maker.VarDef(maker.Modifiers(Flags.PRIVATE), job.builderType.toName(CLEAN_FIELD_NAME), maker.TypeIdent(CTC_BOOLEAN), null);\n\t\t\tinjectFieldAndMarkGenerated(job.builderType, uncleanField);\n\t\t\trecursiveSetGeneratedBy(uncleanField, annotationNode);\n\t\t}\n\t\t\n\t\tif (constructorExists(job.builderType) == MemberExistsResult.NOT_EXISTS) {\n\t\t\tJCMethodDecl cd = HandleConstructor.createConstructor(AccessLevel.PACKAGE, List.<JCAnnotation>nil(), job.builderType, List.<JavacNode>nil(), false, annotationNode);\n\t\t\tif (cd != null) injectMethod(job.builderType, cd);\n\t\t}\n\t\t\n\t\tfor (BuilderFieldData bfd : job.builderFields) {\n\t\t\tmakePrefixedSetterMethodsForBuilder(job, bfd, annInstance.setterPrefix());\n\t\t}\n\t\t\n\t\t{\n\t\t\tMemberExistsResult methodExists = methodExists(job.buildMethodName, job.builderType, -1);\n\t\t\tif (methodExists == MemberExistsResult.EXISTS_BY_LOMBOK) methodExists = methodExists(job.buildMethodName, job.builderType, 0);\n\t\t\tif (methodExists == MemberExistsResult.NOT_EXISTS) {\n\t\t\t\tJCMethodDecl md = generateBuildMethod(job, nameOfBuilderMethod, buildMethodReturnType, buildMethodThrownExceptions, addCleaning);\n\t\t\t\tif (md != null) {\n\t\t\t\t\trecursiveSetGeneratedBy(md, annotationNode);\n\t\t\t\t\tinjectMethod(job.builderType, md);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (methodExists(\"toString\", job.builderType, 0) == MemberExistsResult.NOT_EXISTS) {\n\t\t\tjava.util.List<Included<JavacNode, ToString.Include>> fieldNodes = new ArrayList<Included<JavacNode, ToString.Include>>();\n\t\t\tfor (BuilderFieldData bfd : job.builderFields) {\n\t\t\t\tfor (JavacNode f : bfd.createdFields) {\n\t\t\t\t\tfieldNodes.add(new Included<JavacNode, ToString.Include>(f, null, true, false));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tJCMethodDecl md = HandleToString.createToString(job.builderType, fieldNodes, true, false, FieldAccess.ALWAYS_FIELD, job.sourceNode);\n\t\t\tif (md != null) injectMethod(job.builderType, md);\n\t\t}\n\t\t\n\t\tif (addCleaning) injectMethod(job.builderType, generateCleanMethod(job));\n\t\t\n\t\tif (generateBuilderMethod && methodExists(job.builderMethodName, job.parentType, -1) != MemberExistsResult.NOT_EXISTS) generateBuilderMethod = false;\n\t\tif (generateBuilderMethod) {\n\t\t\tJCMethodDecl md = generateBuilderMethod(job);\n\t\t\trecursiveSetGeneratedBy(md, annotationNode);\n\t\t\tif (md != null) injectMethod(job.parentType, md);\n\t\t}\n\t\t\n\t\tif (job.toBuilder) {\n\t\t\tswitch (methodExists(TO_BUILDER_METHOD_NAME, job.parentType, 0)) {\n\t\t\tcase EXISTS_BY_USER:\n\t\t\t\tannotationNode.addWarning(\"Not generating toBuilder() as it already exists.\");\n\t\t\t\treturn;\n\t\t\tcase NOT_EXISTS:\n\t\t\t\tList<JCTypeParameter> tps = job.typeParams;\n\t\t\t\tif (typeArgsForToBuilder != null) {\n\t\t\t\t\tListBuffer<JCTypeParameter> lb = new ListBuffer<JCTypeParameter>();\n\t\t\t\t\tJavacTreeMaker maker = job.getTreeMaker();\n\t\t\t\t\tfor (Name n : typeArgsForToBuilder) {\n\t\t\t\t\t\tlb.append(maker.TypeParameter(n, List.<JCExpression>nil()));\n\t\t\t\t\t}\n\t\t\t\t\ttps = lb.toList();\n\t\t\t\t}\n\t\t\t\tJCMethodDecl md = generateToBuilderMethod(job, tps, annInstance.setterPrefix());\n\t\t\t\tif (md != null) {\n\t\t\t\t\trecursiveSetGeneratedBy(md, annotationNode);\n\t\t\t\t\tinjectMethod(job.parentType, md);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (nonFinalNonDefaultedFields != null && generateBuilderMethod) {\n\t\t\tfor (JavacNode fieldNode : nonFinalNonDefaultedFields) {\n\t\t\t\tfieldNode.addWarning(\"@Builder will ignore the initializing expression entirely. If you want the initializing expression to serve as default, add @Builder.Default. If it is not supposed to be settable during building, make the field final.\");\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic String returnTypeToBuilderClassName(JavacNode annotationNode, JCClassDecl td, JCExpression returnType, List<JCTypeParameter> typeParams) {\n\t\tString replStr = null;\n\t\tif (returnType instanceof JCFieldAccess) {\n\t\t\treplStr = ((JCFieldAccess) returnType).name.toString();\n\t\t} else if (returnType instanceof JCIdent) {\n\t\t\tName n = ((JCIdent) returnType).name;\n\t\t\t\n\t\t\tfor (JCTypeParameter tp : typeParams) {\n\t\t\t\tif (tp.name.equals(n)) {\n\t\t\t\t\tannotationNode.addError(\"@Builder requires specifying 'builderClassName' if used on methods with a type parameter as return type.\");\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\treplStr = n.toString();\n\t\t} else if (returnType instanceof JCPrimitiveTypeTree) {\n\t\t\treplStr = returnType.toString();\n\t\t\tif (Character.isLowerCase(replStr.charAt(0))) {\n\t\t\t\treplStr = Character.toTitleCase(replStr.charAt(0)) + replStr.substring(1);\n\t\t\t}\n\t\t} else if (returnType instanceof JCTypeApply) {\n\t\t\tJCExpression clazz = ((JCTypeApply) returnType).clazz;\n\t\t\tif (clazz instanceof JCFieldAccess) {\n\t\t\t\treplStr = ((JCFieldAccess) clazz).name.toString();\n\t\t\t} else if (clazz instanceof JCIdent) {\n\t\t\t\treplStr = ((JCIdent) clazz).name.toString();\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (replStr == null || replStr.isEmpty()) {\n\t\t\t// This shouldn't happen.\n\t\t\tSystem.err.println(\"Lombok bug ID#20140614-1651: javac HandleBuilder: return type to name conversion failed: \" + returnType.getClass());\n\t\t\treplStr = td.name.toString();\n\t\t}\n\t\treturn replStr;\n\t}\n\t\n\tprivate static String unpack(JCExpression expr) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tunpack(sb, expr);\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static void unpack(StringBuilder sb, JCExpression expr) {\n\t\tif (expr instanceof JCIdent) {\n\t\t\tsb.append(((JCIdent) expr).name.toString());\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (expr instanceof JCFieldAccess) {\n\t\t\tJCFieldAccess jcfa = (JCFieldAccess) expr;\n\t\t\tunpack(sb, jcfa.selected);\n\t\t\tsb.append(\".\").append(jcfa.name.toString());\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (expr instanceof JCTypeApply) {\n\t\t\tsb.setLength(0);\n\t\t\tsb.append(\"ERR:\");\n\t\t\tsb.append(\"@Builder(toBuilder=true) is not supported if returning a type with generics applied to an intermediate.\");\n\t\t\tsb.append(\"__ERR__\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tsb.setLength(0);\n\t\tsb.append(\"ERR:\");\n\t\tsb.append(\"Expected a type of some sort, not a \" + expr.getClass().getName());\n\t\tsb.append(\"__ERR__\");\n\t}\n\t\n\tprivate JCMethodDecl generateToBuilderMethod(BuilderJob job, List<JCTypeParameter> typeParameters, String prefix) {\n\t\t// return new ThingieBuilder<A, B>().setA(this.a).setB(this.b);\n\t\tJavacTreeMaker maker = job.getTreeMaker();\n\t\t\n\t\tJCExpression call = maker.NewClass(null, List.<JCExpression>nil(), namePlusTypeParamsToTypeReference(maker, job.parentType, job.toName(job.builderClassName), !job.isStatic, job.builderTypeParams), List.<JCExpression>nil(), null);\n\t\tJCExpression invoke = call;\n\t\tListBuffer<JCStatement> preStatements = null;\n\t\tListBuffer<JCStatement> statements = new ListBuffer<JCStatement>();\n\t\t\n\t\tfor (BuilderFieldData bfd : job.builderFields) {\n\t\t\tString setterPrefix = !prefix.isEmpty() ? prefix : job.oldFluent ? \"\" : \"set\";\n\t\t\tString prefixedSetterName = bfd.name.toString();\n\t\t\tif (!setterPrefix.isEmpty()) prefixedSetterName = HandlerUtil.buildAccessorName(job.sourceNode, setterPrefix, prefixedSetterName);\n\t\t\t\n\t\t\tName setterName = job.toName(prefixedSetterName);\n\t\t\tJCExpression[] tgt = new JCExpression[bfd.singularData == null ? 1 : 2];\n\t\t\tif (bfd.obtainVia == null || !bfd.obtainVia.field().isEmpty()) {\n\t\t\t\tfor (int i = 0; i < tgt.length; i++) {\n\t\t\t\t\ttgt[i] = maker.Select(maker.Ident(job.toName(\"this\")), bfd.obtainVia == null ? bfd.rawName : job.toName(bfd.obtainVia.field()));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tString name = bfd.obtainVia.method();\n\t\t\t\tJCMethodInvocation inv;\n\t\t\t\tif (bfd.obtainVia.isStatic()) {\n\t\t\t\t\tJCExpression c = maker.Select(maker.Ident(job.toName(job.parentType.getName())), job.toName(name));\n\t\t\t\t\tinv = maker.Apply(typeParameterNames(maker, typeParameters), c, List.<JCExpression>of(maker.Ident(job.toName(\"this\"))));\n\t\t\t\t} else {\n\t\t\t\t\tJCExpression c = maker.Select(maker.Ident(job.toName(\"this\")), job.toName(name));\n\t\t\t\t\tinv = maker.Apply(List.<JCExpression>nil(), c, List.<JCExpression>nil());\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < tgt.length; i++) tgt[i] = maker.Ident(bfd.name);\n\t\t\t\t\n\t\t\t\t// javac appears to cache the type of JCMethodInvocation expressions based on position, meaning, if you have 2 ObtainVia-based method invokes on different types, you get bizarre type mismatch errors.\n\t\t\t\t// going via a local variable declaration solves the problem.\n\t\t\t\tJCExpression varType = JavacHandlerUtil.cloneType(maker, bfd.type, job.sourceNode);\n\t\t\t\tif (preStatements == null) preStatements = new ListBuffer<JCStatement>();\n\t\t\t\tpreStatements.append(maker.VarDef(maker.Modifiers(Flags.FINAL), bfd.name, varType, inv));\n\t\t\t}\n\t\t\t\n\t\t\tJCExpression arg;\n\t\t\tif (bfd.singularData == null) {\n\t\t\t\targ = tgt[0];\n\t\t\t\tinvoke = maker.Apply(List.<JCExpression>nil(), maker.Select(invoke, setterName), List.of(arg));\n\t\t\t} else {\n\t\t\t\tJCExpression isNotNull = maker.Binary(CTC_NOT_EQUAL, tgt[0], maker.Literal(CTC_BOT, null));\n\t\t\t\tJCExpression invokeBuilder = maker.Apply(List.<JCExpression>nil(), maker.Select(maker.Ident(job.toName(BUILDER_TEMP_VAR)), setterName), List.<JCExpression>of(tgt[1]));\n\t\t\t\tstatements.append(maker.If(isNotNull, maker.Exec(invokeBuilder), null));\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (!statements.isEmpty()) {\n\t\t\tJCExpression tempVarType = namePlusTypeParamsToTypeReference(maker, job.parentType, job.getBuilderClassName(), !job.isStatic, typeParameters);\n\t\t\tstatements.prepend(maker.VarDef(maker.Modifiers(Flags.FINAL), job.toName(BUILDER_TEMP_VAR), tempVarType, invoke));\n\t\t\tstatements.append(maker.Return(maker.Ident(job.toName(BUILDER_TEMP_VAR))));\n\t\t} else {\n\t\t\tstatements.append(maker.Return(invoke));\n\t\t}\n\t\t\n\t\tif (preStatements != null) {\n\t\t\tpreStatements.appendList(statements);\n\t\t\tstatements = preStatements;\n\t\t}\n\t\tJCBlock body = maker.Block(0, statements.toList());\n\t\tList<JCAnnotation> annsOnParamType = List.nil();\n\t\tif (job.checkerFramework.generateUnique()) annsOnParamType = List.of(maker.Annotation(genTypeRef(job.parentType, CheckerFrameworkVersion.NAME__UNIQUE), List.<JCExpression>nil()));\n\t\tJCMethodDecl methodDef = maker.MethodDef(maker.Modifiers(toJavacModifier(job.accessOuters)), job.toName(TO_BUILDER_METHOD_NAME), namePlusTypeParamsToTypeReference(maker, job.parentType, job.getBuilderClassName(), !job.isStatic, typeParameters, annsOnParamType), List.<JCTypeParameter>nil(), List.<JCVariableDecl>nil(), List.<JCExpression>nil(), body, null);\n\t\tcreateRelevantNonNullAnnotation(job.parentType, methodDef);\n\t\treturn methodDef;\n\t}\n\t\n\tprivate JCMethodDecl generateCleanMethod(BuilderJob job) {\n\t\tJavacTreeMaker maker = job.getTreeMaker();\n\t\tListBuffer<JCStatement> statements = new ListBuffer<JCStatement>();\n\t\t\n\t\tfor (BuilderFieldData bfd : job.builderFields) {\n\t\t\tif (bfd.singularData != null && bfd.singularData.getSingularizer() != null) {\n\t\t\t\tbfd.singularData.getSingularizer().appendCleaningCode(bfd.singularData, job.builderType, job.sourceNode, statements);\n\t\t\t}\n\t\t}\n\t\t\n\t\tstatements.append(maker.Exec(maker.Assign(maker.Select(maker.Ident(job.toName(\"this\")), job.toName(CLEAN_FIELD_NAME)), maker.Literal(CTC_BOOLEAN, 0))));\n\t\tJCBlock body = maker.Block(0, statements.toList());\n\t\tJCMethodDecl method = maker.MethodDef(maker.Modifiers(toJavacModifier(AccessLevel.PRIVATE)), job.toName(CLEAN_METHOD_NAME), maker.Type(Javac.createVoidType(job.builderType.getSymbolTable(), CTC_VOID)), List.<JCTypeParameter>nil(), List.<JCVariableDecl>nil(), List.<JCExpression>nil(), body, null);\n\t\trecursiveSetGeneratedBy(method, job.sourceNode);\n\t\treturn method;\n\t}\n\t\n\tstatic JCVariableDecl generateReceiver(BuilderJob job) {\n\t\tif (!job.checkerFramework.generateCalledMethods()) return null;\n\t\t\n\t\tArrayList<String> mandatories = new ArrayList<String>();\n\t\tfor (BuilderFieldData bfd : job.builderFields) {\n\t\t\tif (bfd.singularData == null && bfd.nameOfSetFlag == null) mandatories.add(bfd.name.toString());\n\t\t}\n\t\t\n\t\tJCExpression arg;\n\t\tJavacTreeMaker maker = job.getTreeMaker();\n\t\tif (mandatories.size() == 0) return null;\n\t\tif (mandatories.size() == 1) arg = maker.Literal(mandatories.get(0));\n\t\telse {\n\t\t\tList<JCExpression> elems = List.nil();\n\t\t\tfor (int i = mandatories.size() - 1; i >= 0; i--) elems = elems.prepend(maker.Literal(mandatories.get(i)));\n\t\t\targ = maker.NewArray(null, List.<JCExpression>nil(), elems);\n\t\t}\n\t\tJCAnnotation recvAnno = maker.Annotation(genTypeRef(job.builderType, CheckerFrameworkVersion.NAME__CALLED), List.of(arg));\n\t\tJCClassDecl builderTypeNode = (JCClassDecl) job.builderType.get();\n\t\tJCVariableDecl recv = maker.VarDef(maker.Modifiers(Flags.PARAMETER, List.<JCAnnotation>nil()), job.toName(\"this\"), namePlusTypeParamsToTypeReference(maker, job.builderType, builderTypeNode.typarams, List.<JCAnnotation>of(recvAnno)), null);\n\t\treturn recv;\n\t}\n\t\n\tprivate JCMethodDecl generateBuildMethod(BuilderJob job, Name staticName, JCExpression returnType, List<JCExpression> thrownExceptions, boolean addCleaning) {\n\t\tJavacTreeMaker maker = job.getTreeMaker();\n\t\t\n\t\tJCExpression call;\n\t\tListBuffer<JCStatement> statements = new ListBuffer<JCStatement>();\n\t\t\n\t\tif (addCleaning) {\n\t\t\tJCExpression notClean = maker.Unary(CTC_NOT, maker.Select(maker.Ident(job.toName(\"this\")), job.toName(CLEAN_FIELD_NAME)));\n\t\t\tJCStatement invokeClean = maker.Exec(maker.Apply(List.<JCExpression>nil(), maker.Ident(job.toName(CLEAN_METHOD_NAME)), List.<JCExpression>nil()));\n\t\t\tJCIf ifUnclean = maker.If(notClean, invokeClean, null);\n\t\t\tstatements.append(ifUnclean);\n\t\t}\n\t\t\n\t\tfor (BuilderFieldData bfd : job.builderFields) {\n\t\t\tif (bfd.singularData != null && bfd.singularData.getSingularizer() != null) {\n\t\t\t\tbfd.singularData.getSingularizer().appendBuildCode(bfd.singularData, job.builderType, job.sourceNode, statements, bfd.builderFieldName, \"this\");\n\t\t\t}\n\t\t}\n\t\t\n\t\tListBuffer<JCExpression> args = new ListBuffer<JCExpression>();\n\t\tName thisName = job.toName(\"this\");\n\t\tfor (BuilderFieldData bfd : job.builderFields) {\n\t\t\tif (bfd.nameOfSetFlag != null) {\n\t\t\t\tstatements.append(maker.VarDef(maker.Modifiers(0L), bfd.builderFieldName, cloneType(maker, bfd.type, job.sourceNode), maker.Select(maker.Ident(thisName), bfd.builderFieldName)));\n\t\t\t\tstatements.append(maker.If(maker.Unary(CTC_NOT, maker.Select(maker.Ident(thisName), bfd.nameOfSetFlag)), maker.Exec(maker.Assign(maker.Ident(bfd.builderFieldName), maker.Apply(typeParameterNames(maker, ((JCClassDecl) job.parentType.get()).typarams), maker.Select(maker.Ident(((JCClassDecl) job.parentType.get()).name), bfd.nameOfDefaultProvider), List.<JCExpression>nil()))), null));\n\t\t\t}\n\t\t\tif (bfd.nameOfSetFlag != null || (bfd.singularData != null && bfd.singularData.getSingularizer().shadowedDuringBuild())) {\n\t\t\t\targs.append(maker.Ident(bfd.builderFieldName));\n\t\t\t} else {\n\t\t\t\targs.append(maker.Select(maker.Ident(thisName), bfd.builderFieldName));\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (addCleaning) {\n\t\t\tstatements.append(maker.Exec(maker.Assign(maker.Select(maker.Ident(job.toName(\"this\")), job.toName(CLEAN_FIELD_NAME)), maker.Literal(CTC_BOOLEAN, 1))));\n\t\t}\n\t\t\n\t\tif (staticName == null) {\n\t\t\tcall = maker.NewClass(null, List.<JCExpression>nil(), returnType, args.toList(), null);\n\t\t\tstatements.append(maker.Return(call));\n\t\t} else {\n\t\t\tListBuffer<JCExpression> typeParams = new ListBuffer<JCExpression>();\n\t\t\tfor (JCTypeParameter tp : ((JCClassDecl) job.builderType.get()).typarams) {\n\t\t\t\ttypeParams.append(maker.Ident(tp.name));\n\t\t\t}\n\t\t\tJCExpression callee = maker.Ident(((JCClassDecl) job.parentType.get()).name);\n\t\t\tif (!job.isStatic) callee = maker.Select(callee, job.toName(\"this\"));\n\t\t\tJCExpression fn = maker.Select(callee, staticName);\n\t\t\tcall = maker.Apply(typeParams.toList(), fn, args.toList());\n\t\t\tif (returnType instanceof JCPrimitiveTypeTree && CTC_VOID.equals(typeTag(returnType))) {\n\t\t\t\tstatements.append(maker.Exec(call));\n\t\t\t} else {\n\t\t\t\tstatements.append(maker.Return(call));\n\t\t\t}\n\t\t}\n\t\t\n\t\tJCBlock body = maker.Block(0, statements.toList());\n\t\t\n\t\tList<JCAnnotation> annsOnMethod = job.checkerFramework.generateSideEffectFree() ? List.of(maker.Annotation(genTypeRef(job.builderType, CheckerFrameworkVersion.NAME__SIDE_EFFECT_FREE), List.<JCExpression>nil())) : List.<JCAnnotation>nil();\n\t\tJCVariableDecl recv = generateReceiver(job);\n\t\tJCMethodDecl methodDef;\n\t\tJCExpression returnTypeCopy = cloneType(maker, returnType, job.sourceNode);\n\t\tif (recv != null && maker.hasMethodDefWithRecvParam()) {\n\t\t\tmethodDef = maker.MethodDefWithRecvParam(maker.Modifiers(toJavacModifier(job.accessInners), annsOnMethod), job.toName(job.buildMethodName), returnTypeCopy, List.<JCTypeParameter>nil(), recv, List.<JCVariableDecl>nil(), thrownExceptions, body, null);\n\t\t} else {\n\t\t\tmethodDef = maker.MethodDef(maker.Modifiers(toJavacModifier(job.accessInners), annsOnMethod), job.toName(job.buildMethodName), returnTypeCopy, List.<JCTypeParameter>nil(), List.<JCVariableDecl>nil(), thrownExceptions, body, null);\n\t\t}\n\t\tif (staticName == null) createRelevantNonNullAnnotation(job.builderType, methodDef);\n\t\treturn methodDef;\n\t}\n\t\n\tpublic static JCMethodDecl generateDefaultProvider(Name methodName, JavacNode fieldNode, List<JCTypeParameter> params, BuilderJob job) {\n\t\tJavacTreeMaker maker = fieldNode.getTreeMaker();\n\t\tJCVariableDecl field = (JCVariableDecl) fieldNode.get();\n\t\t\n\t\t// Lombok tries to keep the position of the original initializer. First we save the expression ...\n\t\tJCExpression init = field.init;\n\t\tfield.init = null;\n\t\t\n\t\t// ... then we generate an empty return statement ...\n\t\tJCReturn statement = maker.Return(null);\n\t\tJCBlock body = maker.Block(0, List.<JCStatement>of(statement));\n\t\tint modifiers = Flags.PRIVATE | Flags.STATIC;\n\t\tJCMethodDecl defaultProvider = maker.MethodDef(maker.Modifiers(modifiers), methodName, cloneType(maker, field.vartype, fieldNode), copyTypeParams(fieldNode, params), List.<JCVariableDecl>nil(), List.<JCExpression>nil(), body, null);\n\t\t// ... then we convert short array initializers from `{1,2}` to `new int[]{1,2}` ...\n\t\tif (init instanceof JCNewArray && field.vartype instanceof JCArrayTypeTree) {\n\t\t\tJCNewArray arrayInitializer = (JCNewArray) init;\n\t\t\tJCArrayTypeTree fieldType = (JCArrayTypeTree) field.vartype;\n\t\t\tif (arrayInitializer.elemtype == null) {\n\t\t\t\tarrayInitializer.elemtype = cloneType(maker, fieldType.elemtype, fieldNode);\n\t\t\t}\n\t\t}\n\t\t// ... then we set positions for everything else ...\n\t\trecursiveSetGeneratedBy(defaultProvider, job.sourceNode);\n\t\t// ... and finally add back the original expression\n\t\tstatement.expr = init;\n\t\treturn defaultProvider;\n\t}\n\t\n\tpublic JCMethodDecl generateBuilderMethod(BuilderJob job) {\n\t\t//String builderClassName, JavacNode source, JavacNode type, List<JCTypeParameter> typeParams, AccessLevel access) {\n\t\t//builderClassName, annotationNode, tdParent, typeParams, accessForOuters);\n\t\t\n\t\tJavacTreeMaker maker = job.getTreeMaker();\n\t\t\n\t\tJCExpression call;\n\t\tif (job.isStatic) {\n\t\t\tcall = maker.NewClass(null, List.<JCExpression>nil(), namePlusTypeParamsToTypeReference(maker, job.parentType, job.toName(job.builderClassName), false, job.typeParams), List.<JCExpression>nil(), null);\n\t\t} else {\n\t\t\tcall = maker.NewClass(null, List.<JCExpression>nil(), namePlusTypeParamsToTypeReference(maker, null, job.toName(job.builderClassName), false, job.typeParams), List.<JCExpression>nil(), null);\n\t\t\t((JCNewClass) call).encl = maker.Ident(job.toName(\"this\"));\n\t\t\t\n\t\t}\n\t\tJCStatement statement = maker.Return(call);\n\t\t\n\t\tJCBlock body = maker.Block(0, List.<JCStatement>of(statement));\n\t\tint modifiers = toJavacModifier(job.accessOuters);\n\t\tif (job.isStatic) modifiers |= Flags.STATIC;\n\t\tList<JCAnnotation> annsOnMethod = List.nil();\n\t\tif (job.checkerFramework.generateSideEffectFree()) annsOnMethod = List.of(maker.Annotation(genTypeRef(job.parentType, CheckerFrameworkVersion.NAME__SIDE_EFFECT_FREE), List.<JCExpression>nil()));\n\t\tList<JCAnnotation> annsOnParamType = List.nil();\n\t\tif (job.checkerFramework.generateUnique()) annsOnParamType = List.of(maker.Annotation(genTypeRef(job.parentType, CheckerFrameworkVersion.NAME__UNIQUE), List.<JCExpression>nil()));\n\t\t\n\t\tJCExpression returnType = namePlusTypeParamsToTypeReference(maker, job.parentType, job.getBuilderClassName(), !job.isStatic, job.builderTypeParams, annsOnParamType);\n\t\tJCMethodDecl methodDef = maker.MethodDef(maker.Modifiers(modifiers, annsOnMethod), job.toName(job.builderMethodName), returnType, job.copyTypeParams(), List.<JCVariableDecl>nil(), List.<JCExpression>nil(), body, null);\n\t\tcreateRelevantNonNullAnnotation(job.parentType, methodDef);\n\t\treturn methodDef;\n\t}\n\t\n\tpublic void generateBuilderFields(BuilderJob job) {\n\t\tint len = job.builderFields.size();\n\t\tjava.util.List<JavacNode> existing = new ArrayList<JavacNode>();\n\t\tfor (JavacNode child : job.builderType.down()) {\n\t\t\tif (child.getKind() == Kind.FIELD) existing.add(child);\n\t\t}\n\t\t\n\t\tjava.util.List<JCVariableDecl> generated = new ArrayList<JCVariableDecl>();\n\t\t\n\t\tfor (int i = len - 1; i >= 0; i--) {\n\t\t\tBuilderFieldData bfd = job.builderFields.get(i);\n\t\t\tif (bfd.singularData != null && bfd.singularData.getSingularizer() != null) {\n\t\t\t\tjava.util.List<JavacNode> generateSingularFields = bfd.singularData.getSingularizer().generateFields(bfd.singularData, job.builderType, job.sourceNode);\n\t\t\t\tfor (JavacNode field : generateSingularFields) {\n\t\t\t\t\tgenerated.add((JCVariableDecl) field.get());\n\t\t\t\t}\n\t\t\t\tbfd.createdFields.addAll(generateSingularFields);\n\t\t\t} else {\n\t\t\t\tJavacNode field = null, setFlag = null;\n\t\t\t\tfor (JavacNode exists : existing) {\n\t\t\t\t\tName n = ((JCVariableDecl) exists.get()).name;\n\t\t\t\t\tif (n.equals(bfd.builderFieldName)) field = exists;\n\t\t\t\t\tif (n.equals(bfd.nameOfSetFlag)) setFlag = exists;\n\t\t\t\t}\n\t\t\t\tJavacTreeMaker maker = job.getTreeMaker();\n\t\t\t\tif (field == null) {\n\t\t\t\t\tJCModifiers mods = maker.Modifiers(Flags.PRIVATE);\n\t\t\t\t\tJCVariableDecl newField = maker.VarDef(mods, bfd.builderFieldName, cloneType(maker, bfd.type, job.sourceNode), null);\n\t\t\t\t\tfield = injectFieldAndMarkGenerated(job.builderType, newField);\n\t\t\t\t\tgenerated.add(newField);\n\t\t\t\t}\n\t\t\t\tif (setFlag == null && bfd.nameOfSetFlag != null) {\n\t\t\t\t\tJCModifiers mods = maker.Modifiers(Flags.PRIVATE);\n\t\t\t\t\tJCVariableDecl newField = maker.VarDef(mods, bfd.nameOfSetFlag, maker.TypeIdent(CTC_BOOLEAN), null);\n\t\t\t\t\tinjectFieldAndMarkGenerated(job.builderType, newField);\n\t\t\t\t\tgenerated.add(newField);\n\t\t\t\t}\n\t\t\t\tbfd.createdFields.add(field);\n\t\t\t}\n\t\t}\n\t\tfor (JCVariableDecl gen : generated) recursiveSetGeneratedBy(gen, job.sourceNode);\n\t}\n\t\n\tpublic void makePrefixedSetterMethodsForBuilder(BuilderJob job, BuilderFieldData bfd, String prefix) {\n\t\tboolean deprecate = isFieldDeprecated(bfd.originalFieldNode);\n\t\tif (bfd.singularData == null || bfd.singularData.getSingularizer() == null) {\n\t\t\tmakePrefixedSetterMethodForBuilder(job, bfd, deprecate, prefix);\n\t\t} else {\n\t\t\tbfd.singularData.getSingularizer().generateMethods(job, bfd.singularData, deprecate);\n\t\t}\n\t}\n\t\n\tprivate void makePrefixedSetterMethodForBuilder(BuilderJob job, BuilderFieldData bfd, boolean deprecate, String prefix) {\n\t\tJavacNode fieldNode = bfd.createdFields.get(0);\n\t\tString setterPrefix = !prefix.isEmpty() ? prefix : job.oldFluent ? \"\" : \"set\";\n\t\tString setterName = HandlerUtil.buildAccessorName(job.sourceNode, setterPrefix, bfd.name.toString());\n\t\tName setterName_ = job.builderType.toName(setterName);\n\t\t\n\t\tfor (JavacNode child : job.builderType.down()) {\n\t\t\tif (child.getKind() != Kind.METHOD) continue;\n\t\t\tJCMethodDecl methodDecl = (JCMethodDecl) child.get();\n\t\t\tName existingName = methodDecl.name;\n\t\t\tif (existingName.equals(setterName_) && !isTolerate(fieldNode, methodDecl)) return;\n\t\t}\n\t\t\n\t\tJavacTreeMaker maker = fieldNode.getTreeMaker();\n\t\t\n\t\tList<JCAnnotation> methodAnns = JavacHandlerUtil.findCopyableToSetterAnnotations(bfd.originalFieldNode);\n\t\tJCMethodDecl newMethod = HandleSetter.createSetter(toJavacModifier(job.accessInners), deprecate, fieldNode, maker, setterName, bfd.name, bfd.nameOfSetFlag, job.oldChain, job.sourceNode, methodAnns, bfd.annotations);\n\t\trecursiveSetGeneratedBy(newMethod, job.sourceNode);\n\t\tif (job.sourceNode.up().getKind() == Kind.METHOD) {\n\t\t\tcopyJavadocFromParam(bfd.originalFieldNode.up(), newMethod, bfd.name.toString());\n\t\t} else {\n\t\t\tcopyJavadoc(bfd.originalFieldNode, newMethod, CopyJavadoc.SETTER, true);\n\t\t}\n\t\t\n\t\tinjectMethod(job.builderType, newMethod);\n\t}\n\t\n\tprivate void copyJavadocFromParam(JavacNode from, JCMethodDecl to, String param) {\n\t\ttry {\n\t\t\tJCCompilationUnit cu = ((JCCompilationUnit) from.top().get());\n\t\t\tString methodComment = Javac.getDocComment(cu, from.get());\n\t\t\tString newJavadoc = addReturnsThisIfNeeded(getParamJavadoc(methodComment, param));\n\t\t\tJavac.setDocComment(cu, to, newJavadoc);\n\t\t} catch (Exception ignore) {}\n\t}\t\n\t\n\tpublic JavacNode makeBuilderClass(BuilderJob job) {\n\t\t//boolean isStatic, JavacNode source, JavacNode tdParent, String builderClassName, List<JCTypeParameter> typeParams, JCAnnotation ast, AccessLevel access) {\n\t\t//isStatic, annotationNode, tdParent, builderClassName, typeParams, ast, accessForOuters\n\t\tJavacTreeMaker maker = job.getTreeMaker();\n\t\tint modifiers = toJavacModifier(job.accessOuters);\n\t\tif (job.isStatic) modifiers |= Flags.STATIC;\n\t\tJCModifiers mods = maker.Modifiers(modifiers);\n\t\tJCClassDecl builder = maker.ClassDef(mods, job.getBuilderClassName(), job.copyTypeParams(), null, List.<JCExpression>nil(), List.<JCTree>nil());\n\t\trecursiveSetGeneratedBy(builder, job.sourceNode);\n\t\treturn injectType(job.parentType, builder);\n\t}\n\t\n\tprivate void addObtainVia(BuilderFieldData bfd, JavacNode node) {\n\t\tfor (JavacNode child : node.down()) {\n\t\t\tif (!annotationTypeMatches(ObtainVia.class, child)) continue;\n\t\t\tAnnotationValues<ObtainVia> ann = createAnnotation(ObtainVia.class, child);\n\t\t\tbfd.obtainVia = ann.getInstance();\n\t\t\tbfd.obtainViaNode = child;\n\t\t\tdeleteAnnotationIfNeccessary(child, ObtainVia.class);\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\t/**\n\t * Returns the explicitly requested singular annotation on this node (field\n\t * or parameter), or null if there's no {@code @Singular} annotation on it.\n\t * \n\t * @param node The node (field or method param) to inspect for its name and potential {@code @Singular} annotation.\n\t * @param setterPrefix Explicitly requested setter prefix.\n\t */\n\tprivate SingularData getSingularData(JavacNode node, String setterPrefix) {\n\t\tfor (JavacNode child : node.down()) {\n\t\t\tif (!annotationTypeMatches(Singular.class, child)) continue;\n\t\t\tName pluralName = node.getKind() == Kind.FIELD ? removePrefixFromField(node) : ((JCVariableDecl) node.get()).name;\n\t\t\tAnnotationValues<Singular> ann = createAnnotation(Singular.class, child);\n\t\t\tSingular singularInstance = ann.getInstance();\n\t\t\tdeleteAnnotationIfNeccessary(child, Singular.class);\n\t\t\tString explicitSingular = singularInstance.value();\n\t\t\tif (explicitSingular.isEmpty()) {\n\t\t\t\tif (Boolean.FALSE.equals(node.getAst().readConfiguration(ConfigurationKeys.SINGULAR_AUTO))) {\n\t\t\t\t\tnode.addError(\"The singular must be specified explicitly (e.g. @Singular(\\\"task\\\")) because auto singularization is disabled.\");\n\t\t\t\t\texplicitSingular = pluralName.toString();\n\t\t\t\t} else {\n\t\t\t\t\texplicitSingular = autoSingularize(pluralName.toString());\n\t\t\t\t\tif (explicitSingular == null) {\n\t\t\t\t\t\tnode.addError(\"Can't singularize this name; please specify the singular explicitly (i.e. @Singular(\\\"sheep\\\"))\");\n\t\t\t\t\t\texplicitSingular = pluralName.toString();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tName singularName = node.toName(explicitSingular);\n\t\t\t\n\t\t\tJCExpression type = null;\n\t\t\tif (node.get() instanceof JCVariableDecl) {\n\t\t\t\ttype = ((JCVariableDecl) node.get()).vartype;\n\t\t\t}\n\t\t\t\n\t\t\tString name = null;\n\t\t\tList<JCExpression> typeArgs = List.nil();\n\t\t\tif (type instanceof JCTypeApply) {\n\t\t\t\ttypeArgs = ((JCTypeApply) type).arguments;\n\t\t\t\ttype = ((JCTypeApply) type).clazz;\n\t\t\t}\n\t\t\t\n\t\t\tname = type.toString();\n\t\t\t\n\t\t\tString targetFqn = JavacSingularsRecipes.get().toQualified(name);\n\t\t\tJavacSingularizer singularizer = JavacSingularsRecipes.get().getSingularizer(targetFqn, node);\n\t\t\tif (singularizer == null) {\n\t\t\t\tnode.addError(\"Lombok does not know how to create the singular-form builder methods for type '\" + name + \"'; they won't be generated.\");\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t\n\t\t\treturn new SingularData(child, singularName, pluralName, typeArgs, targetFqn, singularizer, singularInstance.ignoreNullCollections(), setterPrefix);\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n}\n","lineNo":799}
{"Smelly Sample":"/*\n * Copyright (C) 2009-2021 The Project Lombok Authors.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage lombok.javac.handlers;\n\nimport static lombok.core.handlers.HandlerUtil.handleFlagUsage;\nimport static lombok.javac.Javac.*;\nimport static lombok.javac.handlers.JavacHandlerUtil.*;\n\nimport java.lang.reflect.Field;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\n\nimport com.sun.tools.javac.code.BoundKind;\nimport com.sun.tools.javac.code.Flags;\nimport com.sun.tools.javac.tree.JCTree.JCAnnotation;\nimport com.sun.tools.javac.tree.JCTree.JCArrayTypeTree;\nimport com.sun.tools.javac.tree.JCTree.JCBinary;\nimport com.sun.tools.javac.tree.JCTree.JCBlock;\nimport com.sun.tools.javac.tree.JCTree.JCClassDecl;\nimport com.sun.tools.javac.tree.JCTree.JCExpression;\nimport com.sun.tools.javac.tree.JCTree.JCExpressionStatement;\nimport com.sun.tools.javac.tree.JCTree.JCFieldAccess;\nimport com.sun.tools.javac.tree.JCTree.JCIdent;\nimport com.sun.tools.javac.tree.JCTree.JCMethodDecl;\nimport com.sun.tools.javac.tree.JCTree.JCMethodInvocation;\nimport com.sun.tools.javac.tree.JCTree.JCModifiers;\nimport com.sun.tools.javac.tree.JCTree.JCPrimitiveTypeTree;\nimport com.sun.tools.javac.tree.JCTree.JCStatement;\nimport com.sun.tools.javac.tree.JCTree.JCTypeParameter;\nimport com.sun.tools.javac.tree.JCTree.JCUnary;\nimport com.sun.tools.javac.tree.JCTree.JCVariableDecl;\nimport com.sun.tools.javac.util.List;\nimport com.sun.tools.javac.util.ListBuffer;\nimport com.sun.tools.javac.util.Name;\n\nimport lombok.ConfigurationKeys;\nimport lombok.EqualsAndHashCode;\nimport lombok.EqualsAndHashCode.CacheStrategy;\nimport lombok.core.AST.Kind;\nimport lombok.core.AnnotationValues;\nimport lombok.core.configuration.CallSuperType;\nimport lombok.core.configuration.CheckerFrameworkVersion;\nimport lombok.core.handlers.HandlerUtil;\nimport lombok.core.handlers.HandlerUtil.FieldAccess;\nimport lombok.core.handlers.InclusionExclusionUtils;\nimport lombok.core.handlers.InclusionExclusionUtils.Included;\nimport lombok.javac.JavacAnnotationHandler;\nimport lombok.javac.JavacNode;\nimport lombok.javac.JavacTreeMaker;\nimport lombok.javac.handlers.JavacHandlerUtil.MemberExistsResult;\nimport lombok.spi.Provides;\n\n/**\n * Handles the {@code lombok.EqualsAndHashCode} annotation for javac.\n */\n@Provides\npublic class HandleEqualsAndHashCode extends JavacAnnotationHandler<EqualsAndHashCode> {\n\tprivate static final String RESULT_NAME = \"result\";\n\tprivate static final String PRIME_NAME = \"PRIME\";\n\tprivate static final String HASH_CODE_CACHE_NAME = \"$hashCodeCache\";\n\t\n\t@Override public void handle(AnnotationValues<EqualsAndHashCode> annotation, JCAnnotation ast, JavacNode annotationNode) {\n\t\thandleFlagUsage(annotationNode, ConfigurationKeys.EQUALS_AND_HASH_CODE_FLAG_USAGE, \"@EqualsAndHashCode\");\n\t\t\n\t\tdeleteAnnotationIfNeccessary(annotationNode, EqualsAndHashCode.class);\n\t\tdeleteImportFromCompilationUnit(annotationNode, CacheStrategy.class.getName());\n\t\tEqualsAndHashCode ann = annotation.getInstance();\n\t\tjava.util.List<Included<JavacNode, EqualsAndHashCode.Include>> members = InclusionExclusionUtils.handleEqualsAndHashCodeMarking(annotationNode.up(), annotation, annotationNode);\n\t\tJavacNode typeNode = annotationNode.up();\n\t\tList<JCAnnotation> onParam = unboxAndRemoveAnnotationParameter(ast, \"onParam\", \"@EqualsAndHashCode(onParam\", annotationNode);\n\t\t\n\t\tBoolean callSuper = ann.callSuper();\n\t\tif (!annotation.isExplicit(\"callSuper\")) callSuper = null;\n\t\t\n\t\tBoolean doNotUseGettersConfiguration = annotationNode.getAst().readConfiguration(ConfigurationKeys.EQUALS_AND_HASH_CODE_DO_NOT_USE_GETTERS);\n\t\tboolean doNotUseGetters = annotation.isExplicit(\"doNotUseGetters\") || doNotUseGettersConfiguration == null ? ann.doNotUseGetters() : doNotUseGettersConfiguration;\n\t\tFieldAccess fieldAccess = doNotUseGetters ? FieldAccess.PREFER_FIELD : FieldAccess.GETTER;\n\t\t\n\t\tboolean cacheHashCode = ann.cacheStrategy() == CacheStrategy.LAZY;\n\t\t\n\t\tgenerateMethods(typeNode, annotationNode, members, callSuper, true, cacheHashCode, fieldAccess, onParam);\n\t}\n\t\n\tpublic void generateEqualsAndHashCodeForType(JavacNode typeNode, JavacNode source) {\n\t\tif (hasAnnotation(EqualsAndHashCode.class, typeNode)) {\n\t\t\t//The annotation will make it happen, so we can skip it.\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tBoolean doNotUseGettersConfiguration = typeNode.getAst().readConfiguration(ConfigurationKeys.EQUALS_AND_HASH_CODE_DO_NOT_USE_GETTERS);\n\t\tFieldAccess access = doNotUseGettersConfiguration == null || !doNotUseGettersConfiguration ? FieldAccess.GETTER : FieldAccess.PREFER_FIELD;\n\t\t\n\t\tjava.util.List<Included<JavacNode, EqualsAndHashCode.Include>> members = InclusionExclusionUtils.handleEqualsAndHashCodeMarking(typeNode, null, null);\n\t\t\n\t\tgenerateMethods(typeNode, source, members, null, false, false, access, List.<JCAnnotation>nil());\n\t}\n\t\n\tpublic void generateMethods(JavacNode typeNode, JavacNode source, java.util.List<Included<JavacNode, EqualsAndHashCode.Include>> members,\n\t\tBoolean callSuper, boolean whineIfExists, boolean cacheHashCode, FieldAccess fieldAccess, List<JCAnnotation> onParam) {\n\t\t\n\t\tif (!isClass(typeNode)) {\n\t\t\tsource.addError(\"@EqualsAndHashCode is only supported on a class.\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tboolean implicitCallSuper = callSuper == null;\n\t\tif (callSuper == null) {\n\t\t\ttry {\n\t\t\t\tcallSuper = ((Boolean) EqualsAndHashCode.class.getMethod(\"callSuper\").getDefaultValue()).booleanValue();\n\t\t\t} catch (Exception ignore) {\n\t\t\t\tthrow new InternalError(\"Lombok bug - this cannot happen - can't find callSuper field in EqualsAndHashCode annotation.\");\n\t\t\t}\n\t\t}\n\t\t\n\t\tboolean isDirectDescendantOfObject = isDirectDescendantOfObject(typeNode);\n\t\t\n\t\tboolean isFinal = (((JCClassDecl) typeNode.get()).mods.flags & Flags.FINAL) != 0;\n\t\tboolean needsCanEqual = !isFinal || !isDirectDescendantOfObject;\n\t\tMemberExistsResult equalsExists = methodExists(\"equals\", typeNode, 1);\n\t\tMemberExistsResult hashCodeExists = methodExists(\"hashCode\", typeNode, 0);\n\t\tMemberExistsResult canEqualExists = methodExists(\"canEqual\", typeNode, 1);\n\t\tswitch (Collections.max(Arrays.asList(equalsExists, hashCodeExists))) {\n\t\tcase EXISTS_BY_LOMBOK:\n\t\t\treturn;\n\t\tcase EXISTS_BY_USER:\n\t\t\tif (whineIfExists) {\n\t\t\t\tString msg = \"Not generating equals and hashCode: A method with one of those names already exists. (Either both or none of these methods will be generated).\";\n\t\t\t\tsource.addWarning(msg);\n\t\t\t} else if (equalsExists == MemberExistsResult.NOT_EXISTS || hashCodeExists == MemberExistsResult.NOT_EXISTS) {\n\t\t\t\t// This means equals OR hashCode exists and not both.\n\t\t\t\t// Even though we should suppress the message about not generating these, this is such a weird and surprising situation we should ALWAYS generate a warning.\n\t\t\t\t// The user code couldn't possibly (barring really weird subclassing shenanigans) be in a shippable state anyway; the implementations of these 2 methods are\n\t\t\t\t// all inter-related and should be written by the same entity.\n\t\t\t\tString msg = String.format(\"Not generating %s: One of equals or hashCode exists. \" +\n\t\t\t\t\t\"You should either write both of these or none of these (in the latter case, lombok generates them).\",\n\t\t\t\t\tequalsExists == MemberExistsResult.NOT_EXISTS ? \"equals\" : \"hashCode\");\n\t\t\t\tsource.addWarning(msg);\n\t\t\t}\n\t\t\treturn;\n\t\tcase NOT_EXISTS:\n\t\tdefault:\n\t\t\t//fallthrough\n\t\t}\n\t\t\n\t\tif (isDirectDescendantOfObject && callSuper) {\n\t\t\tsource.addError(\"Generating equals/hashCode with a supercall to java.lang.Object is pointless.\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (implicitCallSuper && !isDirectDescendantOfObject) {\n\t\t\tCallSuperType cst = typeNode.getAst().readConfiguration(ConfigurationKeys.EQUALS_AND_HASH_CODE_CALL_SUPER);\n\t\t\tif (cst == null) cst = CallSuperType.WARN;\n\t\t\t\n\t\t\tswitch (cst) {\n\t\t\tdefault:\n\t\t\tcase WARN:\n\t\t\t\tsource.addWarning(\"Generating equals/hashCode implementation but without a call to superclass, even though this class does not extend java.lang.Object. If this is intentional, add '@EqualsAndHashCode(callSuper=false)' to your type.\");\n\t\t\t\tcallSuper = false;\n\t\t\t\tbreak;\n\t\t\tcase SKIP:\n\t\t\t\tcallSuper = false;\n\t\t\t\tbreak;\n\t\t\tcase CALL:\n\t\t\t\tcallSuper = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tJCMethodDecl equalsMethod = createEquals(typeNode, members, callSuper, fieldAccess, needsCanEqual, source, onParam);\n\t\t\n\t\tinjectMethod(typeNode, equalsMethod);\n\t\t\n\t\tif (needsCanEqual && canEqualExists == MemberExistsResult.NOT_EXISTS) {\n\t\t\tJCMethodDecl canEqualMethod = createCanEqual(typeNode, source, onParam);\n\t\t\tinjectMethod(typeNode, canEqualMethod);\n\t\t}\n\t\t\n\t\tif (cacheHashCode){\n\t\t\tif (fieldExists(HASH_CODE_CACHE_NAME, typeNode) != MemberExistsResult.NOT_EXISTS) {\n\t\t\t\tString msg = String.format(\"Not caching the result of hashCode: A field named %s already exists.\", HASH_CODE_CACHE_NAME);\n\t\t\t\tsource.addWarning(msg);\n\t\t\t\tcacheHashCode = false;\n\t\t\t} else {\n\t\t\t\tcreateHashCodeCacheField(typeNode, source);\n\t\t\t}\n\t\t}\n\t\t\n\t\tJCMethodDecl hashCodeMethod = createHashCode(typeNode, members, callSuper, cacheHashCode, fieldAccess, source);\n\t\tinjectMethod(typeNode, hashCodeMethod);\n\t}\n\n\tprivate void createHashCodeCacheField(JavacNode typeNode, JavacNode source) {\n\t\tJavacTreeMaker maker = typeNode.getTreeMaker();\n\t\tJCModifiers mods = maker.Modifiers(Flags.PRIVATE | Flags.TRANSIENT);\n\t\tJCVariableDecl hashCodeCacheField = maker.VarDef(mods, typeNode.toName(HASH_CODE_CACHE_NAME), maker.TypeIdent(CTC_INT), null);\n\t\tinjectFieldAndMarkGenerated(typeNode, hashCodeCacheField);\n\t\trecursiveSetGeneratedBy(hashCodeCacheField, source);\n\t}\n\t\n\tpublic JCMethodDecl createHashCode(JavacNode typeNode, java.util.List<Included<JavacNode, EqualsAndHashCode.Include>> members, boolean callSuper, boolean cacheHashCode, FieldAccess fieldAccess, JavacNode source) {\n\t\tJavacTreeMaker maker = typeNode.getTreeMaker();\n\t\t\n\t\tJCAnnotation overrideAnnotation = maker.Annotation(genJavaLangTypeRef(typeNode, \"Override\"), List.<JCExpression>nil());\n\t\tList<JCAnnotation> annsOnMethod = List.of(overrideAnnotation);\n\t\tCheckerFrameworkVersion checkerFramework = getCheckerFrameworkVersion(typeNode);\n\t\tif (cacheHashCode && checkerFramework.generatePure()) {\n\t\t\tannsOnMethod = annsOnMethod.prepend(maker.Annotation(genTypeRef(typeNode, CheckerFrameworkVersion.NAME__PURE), List.<JCExpression>nil()));\n\t\t} else if (checkerFramework.generateSideEffectFree()) { \n\t\t\tannsOnMethod = annsOnMethod.prepend(maker.Annotation(genTypeRef(typeNode, CheckerFrameworkVersion.NAME__SIDE_EFFECT_FREE), List.<JCExpression>nil()));\n\t\t}\n\t\tJCModifiers mods = maker.Modifiers(Flags.PUBLIC, annsOnMethod);\n\t\tJCExpression returnType = maker.TypeIdent(CTC_INT);\n\t\tListBuffer<JCStatement> statements = new ListBuffer<JCStatement>();\n\t\t\n\t\tName primeName = typeNode.toName(PRIME_NAME);\n\t\tName resultName = typeNode.toName(RESULT_NAME);\n\t\tlong finalFlag = JavacHandlerUtil.addFinalIfNeeded(0L, typeNode.getContext());\n\t\t\n\t\tboolean isEmpty = members.isEmpty();\n\t\t\n\t\t/* if (this.$hashCodeCache != 0) return this.$hashCodeCache; */ {\n\t\t\tif (cacheHashCode) {\n\t\t\t\tJCIdent receiver = maker.Ident(typeNode.toName(\"this\"));\n\t\t\t\tJCFieldAccess cacheHashCodeFieldAccess = maker.Select(receiver, typeNode.toName(HASH_CODE_CACHE_NAME));\n\t\t\t\tJCExpression cacheNotZero = maker.Binary(CTC_NOT_EQUAL, cacheHashCodeFieldAccess, maker.Literal(CTC_INT, 0));\n\t\t\t\tstatements.append(maker.If(cacheNotZero, maker.Return(cacheHashCodeFieldAccess), null));\n\t\t\t}\n\t\t}\n\t\t\n\t\t/* final int PRIME = X; */ {\n\t\t\tif (!isEmpty) {\n\t\t\t\tstatements.append(maker.VarDef(maker.Modifiers(finalFlag), primeName, maker.TypeIdent(CTC_INT), maker.Literal(HandlerUtil.primeForHashcode())));\n\t\t\t}\n\t\t}\n\t\t\n\t\t/* int result = ... */ {\n\t\t\tfinal JCExpression init;\n\t\t\tif (callSuper) {\n\t\t\t\t/* ... super.hashCode(); */\n\t\t\t\tinit = maker.Apply(List.<JCExpression>nil(),\n\t\t\t\t\tmaker.Select(maker.Ident(typeNode.toName(\"super\")), typeNode.toName(\"hashCode\")),\n\t\t\t\t\tList.<JCExpression>nil());\n\t\t\t} else {\n\t\t\t\t/* ... 1; */\n\t\t\t\tinit = maker.Literal(1);\n\t\t\t}\n\t\t\tstatements.append(maker.VarDef(maker.Modifiers(isEmpty && !cacheHashCode ? finalFlag : 0L), resultName, maker.TypeIdent(CTC_INT), init));\n\t\t}\n\t\t\n\t\tfor (Included<JavacNode, EqualsAndHashCode.Include> member : members) {\n\t\t\tJavacNode memberNode = member.getNode();\n\t\t\tJCExpression fType = unnotate(getFieldType(memberNode, fieldAccess));\n\t\t\tboolean isMethod = memberNode.getKind() == Kind.METHOD;\n\t\t\t\n\t\t\tJCExpression fieldAccessor = isMethod ? createMethodAccessor(maker, memberNode) : createFieldAccessor(maker, memberNode, fieldAccess);\n\t\t\tif (fType instanceof JCPrimitiveTypeTree) {\n\t\t\t\tswitch (((JCPrimitiveTypeTree) fType).getPrimitiveTypeKind()) {\n\t\t\t\tcase BOOLEAN:\n\t\t\t\t\t/* this.fieldName ? X : Y */\n\t\t\t\t\tstatements.append(createResultCalculation(typeNode, maker.Parens(maker.Conditional(fieldAccessor, \n\t\t\t\t\t\tmaker.Literal(HandlerUtil.primeForTrue()), maker.Literal(HandlerUtil.primeForFalse())))));\n\t\t\t\t\tbreak;\n\t\t\t\tcase LONG: {\n\t\t\t\t\t\tName dollarFieldName = memberNode.toName((isMethod ? \"$$\" : \"$\") + memberNode.getName());\n\t\t\t\t\t\tstatements.append(maker.VarDef(maker.Modifiers(finalFlag), dollarFieldName, maker.TypeIdent(CTC_LONG), fieldAccessor));\n\t\t\t\t\t\tstatements.append(createResultCalculation(typeNode, longToIntForHashCode(maker, maker.Ident(dollarFieldName), maker.Ident(dollarFieldName))));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase FLOAT:\n\t\t\t\t\t/* Float.floatToIntBits(this.fieldName) */\n\t\t\t\t\tstatements.append(createResultCalculation(typeNode, maker.Apply(\n\t\t\t\t\t\tList.<JCExpression>nil(),\n\t\t\t\t\t\tgenJavaLangTypeRef(typeNode, \"Float\", \"floatToIntBits\"),\n\t\t\t\t\t\tList.of(fieldAccessor))));\n\t\t\t\t\tbreak;\n\t\t\t\tcase DOUBLE: {\n\t\t\t\t\t\t/* longToIntForHashCode(Double.doubleToLongBits(this.fieldName)) */\n\t\t\t\t\tName dollarFieldName = memberNode.toName((isMethod ? \"$$\" : \"$\") + memberNode.getName());\n\t\t\t\t\t\tJCExpression init = maker.Apply(\n\t\t\t\t\t\t\tList.<JCExpression>nil(),\n\t\t\t\t\t\t\tgenJavaLangTypeRef(typeNode, \"Double\", \"doubleToLongBits\"),\n\t\t\t\t\t\t\tList.of(fieldAccessor));\n\t\t\t\t\t\tstatements.append(maker.VarDef(maker.Modifiers(finalFlag), dollarFieldName, maker.TypeIdent(CTC_LONG), init));\n\t\t\t\t\t\tstatements.append(createResultCalculation(typeNode, longToIntForHashCode(maker, maker.Ident(dollarFieldName), maker.Ident(dollarFieldName))));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\tcase BYTE:\n\t\t\t\tcase SHORT:\n\t\t\t\tcase INT:\n\t\t\t\tcase CHAR:\n\t\t\t\t\t/* just the field */\n\t\t\t\t\tstatements.append(createResultCalculation(typeNode, fieldAccessor));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (fType instanceof JCArrayTypeTree) {\n\t\t\t\tJCArrayTypeTree array = (JCArrayTypeTree) fType;\n\t\t\t\t/* java.util.Arrays.deepHashCode(this.fieldName) //use just hashCode() for primitive arrays. */\n\t\t\t\tboolean multiDim = unnotate(array.elemtype) instanceof JCArrayTypeTree;\n\t\t\t\tboolean primitiveArray = unnotate(array.elemtype) instanceof JCPrimitiveTypeTree;\n\t\t\t\tboolean useDeepHC = multiDim || !primitiveArray;\n\t\t\t\t\n\t\t\t\tJCExpression hcMethod = chainDots(typeNode, \"java\", \"util\", \"Arrays\", useDeepHC ? \"deepHashCode\" : \"hashCode\");\n\t\t\t\tstatements.append(createResultCalculation(typeNode, maker.Apply(List.<JCExpression>nil(), hcMethod, List.of(fieldAccessor))));\n\t\t\t} else /* objects */ {\n\t\t\t\t/* final java.lang.Object $fieldName = this.fieldName; */\n\t\t\t\t/* ($fieldName == null ? NULL_PRIME : $fieldName.hashCode()) */\n\t\t\t\t\n\t\t\t\tName dollarFieldName = memberNode.toName((isMethod ? \"$$\" : \"$\") + memberNode.getName());\n\t\t\t\tstatements.append(maker.VarDef(maker.Modifiers(finalFlag), dollarFieldName, genJavaLangTypeRef(typeNode, \"Object\"), fieldAccessor));\n\t\t\t\t\n\t\t\t\tJCExpression hcCall = maker.Apply(List.<JCExpression>nil(), maker.Select(maker.Ident(dollarFieldName), typeNode.toName(\"hashCode\")),\n\t\t\t\t\tList.<JCExpression>nil());\n\t\t\t\tJCExpression thisEqualsNull = maker.Binary(CTC_EQUAL, maker.Ident(dollarFieldName), maker.Literal(CTC_BOT, null));\n\t\t\t\tstatements.append(createResultCalculation(typeNode, maker.Parens(maker.Conditional(thisEqualsNull, maker.Literal(HandlerUtil.primeForNull()), hcCall))));\n\t\t\t}\n\t\t}\n\t\t\n\t\t/* \n\t\t * if (result == 0) result = Integer.MIN_VALUE;\n\t\t * this.$hashCodeCache = result;\n\t\t * \n\t\t */ {\n\t\t\tif (cacheHashCode) {\n\t\t\t\tstatements.append(maker.If(maker.Binary(CTC_EQUAL, maker.Ident(resultName), maker.Literal(CTC_INT, 0)), \n\t\t\t\t\tmaker.Exec(maker.Assign(maker.Ident(resultName), genJavaLangTypeRef(typeNode, \"Integer\", \"MIN_VALUE\"))), null));\n\t\t\t\t\n\t\t\t\tJCFieldAccess cacheHashCodeFieldAccess = maker.Select(maker.Ident(typeNode.toName(\"this\")), typeNode.toName(HASH_CODE_CACHE_NAME));\n\t\t\t\tstatements.append(maker.Exec(maker.Assign(cacheHashCodeFieldAccess, maker.Ident(resultName))));\n\t\t\t}\n\t\t}\n\t\t\n\t\t/* return result; */ {\n\t\t\tstatements.append(maker.Return(maker.Ident(resultName)));\n\t\t}\n\t\t\n\t\tJCBlock body = maker.Block(0, statements.toList());\n\t\treturn recursiveSetGeneratedBy(maker.MethodDef(mods, typeNode.toName(\"hashCode\"), returnType,\n\t\t\tList.<JCTypeParameter>nil(), List.<JCVariableDecl>nil(), List.<JCExpression>nil(), body, null), source);\n\t}\n\n\tpublic JCExpressionStatement createResultCalculation(JavacNode typeNode, JCExpression expr) {\n\t\t/* result = result * PRIME + expr; */\n\t\tJavacTreeMaker maker = typeNode.getTreeMaker();\n\t\tName resultName = typeNode.toName(RESULT_NAME);\n\t\tJCExpression mult = maker.Binary(CTC_MUL, maker.Ident(resultName), maker.Ident(typeNode.toName(PRIME_NAME)));\n\t\tJCExpression add = maker.Binary(CTC_PLUS, mult, expr);\n\t\treturn maker.Exec(maker.Assign(maker.Ident(resultName), add));\n\t}\n\t\n\t/** The 2 references must be clones of each other. */\n\tpublic JCExpression longToIntForHashCode(JavacTreeMaker maker, JCExpression ref1, JCExpression ref2) {\n\t\t/* (int) (ref >>> 32 ^ ref) */\n\t\tJCExpression shift = maker.Binary(CTC_UNSIGNED_SHIFT_RIGHT, ref1, maker.Literal(32));\n\t\tJCExpression xorBits = maker.Binary(CTC_BITXOR, shift, ref2);\n\t\treturn maker.TypeCast(maker.TypeIdent(CTC_INT), maker.Parens(xorBits));\n\t}\n\t\n\tpublic JCExpression createTypeReference(JavacNode type, boolean addWildcards) {\n\t\tjava.util.List<String> list = new ArrayList<String>();\n\t\tjava.util.List<Integer> genericsCount = addWildcards ? new ArrayList<Integer>() : null;\n\t\t\n\t\tlist.add(type.getName());\n\t\tif (addWildcards) genericsCount.add(((JCClassDecl) type.get()).typarams.size());\n\t\tboolean staticContext = (((JCClassDecl) type.get()).getModifiers().flags & Flags.STATIC) != 0;\n\t\tJavacNode tNode = type.up();\n\t\t\n\t\twhile (tNode != null && tNode.getKind() == Kind.TYPE && !tNode.getName().isEmpty()) {\n\t\t\tlist.add(tNode.getName());\n\t\t\tif (addWildcards) genericsCount.add(staticContext ? 0 : ((JCClassDecl) tNode.get()).typarams.size());\n\t\t\tif (!staticContext) staticContext = (((JCClassDecl) tNode.get()).getModifiers().flags & Flags.STATIC) != 0;\n\t\t\ttNode = tNode.up();\n\t\t}\n\t\tCollections.reverse(list);\n\t\tif (addWildcards) Collections.reverse(genericsCount);\n\t\t\n\t\tJavacTreeMaker maker = type.getTreeMaker();\n\t\t\n\t\tJCExpression chain = maker.Ident(type.toName(list.get(0)));\n\t\tif (addWildcards) chain = wildcardify(maker, chain, genericsCount.get(0));\n\t\t\n\t\tfor (int i = 1; i < list.size(); i++) {\n\t\t\tchain = maker.Select(chain, type.toName(list.get(i)));\n\t\t\tif (addWildcards) chain = wildcardify(maker, chain, genericsCount.get(i));\n\t\t}\n\t\t\n\t\treturn chain;\n\t}\n\t\n\tprivate JCExpression wildcardify(JavacTreeMaker maker, JCExpression expr, int count) {\n\t\tif (count == 0) return expr;\n\t\t\n\t\tListBuffer<JCExpression> wildcards = new ListBuffer<JCExpression>();\n\t\tfor (int i = 0 ; i < count ; i++) {\n\t\t\twildcards.append(maker.Wildcard(maker.TypeBoundKind(BoundKind.UNBOUND), null));\n\t\t}\n\t\t\n\t\treturn maker.TypeApply(expr, wildcards.toList());\n\t}\n\t\n\tpublic JCMethodDecl createEquals(JavacNode typeNode, java.util.List<Included<JavacNode, EqualsAndHashCode.Include>> members, boolean callSuper, FieldAccess fieldAccess, boolean needsCanEqual, JavacNode source, List<JCAnnotation> onParam) {\n\t\tJavacTreeMaker maker = typeNode.getTreeMaker();\n\t\t\n\t\tName oName = typeNode.toName(\"o\");\n\t\tName otherName = typeNode.toName(\"other\");\n\t\tName thisName = typeNode.toName(\"this\");\n\t\t\n\t\tList<JCAnnotation> annsOnParamOnMethod = List.nil();\n\t\t\n\t\tJCAnnotation overrideAnnotation = maker.Annotation(genJavaLangTypeRef(typeNode, \"Override\"), List.<JCExpression>nil());\n\t\tList<JCAnnotation> annsOnMethod = List.of(overrideAnnotation);\n\t\tCheckerFrameworkVersion checkerFramework = getCheckerFrameworkVersion(typeNode);\n\t\tif (checkerFramework.generateSideEffectFree()) {\n\t\t\tannsOnMethod = annsOnMethod.prepend(maker.Annotation(genTypeRef(typeNode, CheckerFrameworkVersion.NAME__SIDE_EFFECT_FREE), List.<JCExpression>nil()));\n\t\t}\n\t\tJCModifiers mods = maker.Modifiers(Flags.PUBLIC, annsOnMethod);\n\t\tJCExpression objectType;\n\t\tif (annsOnParamOnMethod.isEmpty()) {\n\t\t\tobjectType = genJavaLangTypeRef(typeNode, \"Object\");\n\t\t} else {\n\t\t\tobjectType = chainDots(typeNode, \"java\", \"lang\", \"Object\");\n\t\t\tobjectType = maker.AnnotatedType(annsOnParamOnMethod, objectType);\n\t\t}\n\t\t\n\t\tJCExpression returnType = maker.TypeIdent(CTC_BOOLEAN);\n\t\t\n\t\tlong finalFlag = JavacHandlerUtil.addFinalIfNeeded(0L, typeNode.getContext());\n\t\t\n\t\tListBuffer<JCStatement> statements = new ListBuffer<JCStatement>();\n\t\tJCVariableDecl param = maker.VarDef(maker.Modifiers(finalFlag | Flags.PARAMETER, onParam), oName, objectType, null);\n\t\tJavacHandlerUtil.createRelevantNullableAnnotation(typeNode, param);\n\t\t\n\t\tfinal List<JCVariableDecl> params = List.of(param);\n\t\t\n\t\t/* if (o == this) return true; */ {\n\t\t\tstatements.append(maker.If(maker.Binary(CTC_EQUAL, maker.Ident(oName),\n\t\t\t\tmaker.Ident(thisName)), returnBool(maker, true), null));\n\t\t}\n\t\t\n\t\t/* if (!(o instanceof Outer.Inner.MyType)) return false; */ {\n\t\t\t \n\t\t\tJCUnary notInstanceOf = maker.Unary(CTC_NOT, maker.Parens(maker.TypeTest(maker.Ident(oName), createTypeReference(typeNode, false))));\n\t\t\tstatements.append(maker.If(notInstanceOf, returnBool(maker, false), null));\n\t\t}\n\t\t\n\t\t/* Outer.Inner.MyType<?> other = (Outer.Inner.MyType<?>) o; */ {\n\t\t\tif (!members.isEmpty() || needsCanEqual) {\n\t\t\t\tfinal JCExpression selfType1 = createTypeReference(typeNode, true), selfType2 = createTypeReference(typeNode, true);\n\t\t\t\t\n\t\t\t\tstatements.append(\n\t\t\t\t\tmaker.VarDef(maker.Modifiers(finalFlag), otherName, selfType1, maker.TypeCast(selfType2, maker.Ident(oName))));\n\t\t\t}\n\t\t}\n\t\t\n\t\t/* if (!other.canEqual((java.lang.Object) this)) return false; */ {\n\t\t\tif (needsCanEqual) {\n\t\t\t\tList<JCExpression> exprNil = List.nil();\n\t\t\t\tJCExpression thisRef = maker.Ident(thisName);\n\t\t\t\tJCExpression castThisRef = maker.TypeCast(genJavaLangTypeRef(typeNode, \"Object\"), thisRef);\n\t\t\t\tJCExpression equalityCheck = maker.Apply(exprNil, \n\t\t\t\t\tmaker.Select(maker.Ident(otherName), typeNode.toName(\"canEqual\")),\n\t\t\t\t\tList.of(castThisRef));\n\t\t\t\tstatements.append(maker.If(maker.Unary(CTC_NOT, equalityCheck), returnBool(maker, false), null));\n\t\t\t}\n\t\t}\n\t\t\n\t\t/* if (!super.equals(o)) return false; */\n\t\tif (callSuper) {\n\t\t\tJCMethodInvocation callToSuper = maker.Apply(List.<JCExpression>nil(),\n\t\t\t\tmaker.Select(maker.Ident(typeNode.toName(\"super\")), typeNode.toName(\"equals\")),\n\t\t\t\tList.<JCExpression>of(maker.Ident(oName)));\n\t\t\tJCUnary superNotEqual = maker.Unary(CTC_NOT, callToSuper);\n\t\t\tstatements.append(maker.If(superNotEqual, returnBool(maker, false), null));\n\t\t}\n\t\t\n\t\tfor (Included<JavacNode, EqualsAndHashCode.Include> member : members) {\n\t\t\tJavacNode memberNode = member.getNode();\n\t\t\tboolean isMethod = memberNode.getKind() == Kind.METHOD;\n\t\t\t\n\t\t\tJCExpression fType = unnotate(getFieldType(memberNode, fieldAccess));\n\t\t\tJCExpression thisFieldAccessor = isMethod ? createMethodAccessor(maker, memberNode) : createFieldAccessor(maker, memberNode, fieldAccess);\n\t\t\tJCExpression otherFieldAccessor = isMethod ? createMethodAccessor(maker, memberNode, maker.Ident(otherName)) : createFieldAccessor(maker, memberNode, fieldAccess, maker.Ident(otherName));\n\t\t\tif (fType instanceof JCPrimitiveTypeTree) {\n\t\t\t\tswitch (((JCPrimitiveTypeTree)fType).getPrimitiveTypeKind()) {\n\t\t\t\tcase FLOAT:\n\t\t\t\t\t/* if (Float.compare(this.fieldName, other.fieldName) != 0) return false; */\n\t\t\t\t\tstatements.append(generateCompareFloatOrDouble(thisFieldAccessor, otherFieldAccessor, maker, typeNode, false));\n\t\t\t\t\tbreak;\n\t\t\t\tcase DOUBLE:\n\t\t\t\t\t/* if (Double.compare(this.fieldName, other.fieldName) != 0) return false; */\n\t\t\t\t\tstatements.append(generateCompareFloatOrDouble(thisFieldAccessor, otherFieldAccessor, maker, typeNode, true));\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t/* if (this.fieldName != other.fieldName) return false; */\n\t\t\t\t\tstatements.append(\n\t\t\t\t\t\t\tmaker.If(maker.Binary(CTC_NOT_EQUAL, thisFieldAccessor, otherFieldAccessor), returnBool(maker, false), null));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (fType instanceof JCArrayTypeTree) {\n\t\t\t\tJCArrayTypeTree array = (JCArrayTypeTree) fType;\n\t\t\t\t/* if (!java.util.Arrays.deepEquals(this.fieldName, other.fieldName)) return false; //use equals for primitive arrays. */\n\t\t\t\tboolean multiDim = unnotate(array.elemtype) instanceof JCArrayTypeTree;\n\t\t\t\tboolean primitiveArray = unnotate(array.elemtype) instanceof JCPrimitiveTypeTree;\n\t\t\t\tboolean useDeepEquals = multiDim || !primitiveArray;\n\t\t\t\t\n\t\t\t\tJCExpression eqMethod = chainDots(typeNode, \"java\", \"util\", \"Arrays\", useDeepEquals ? \"deepEquals\" : \"equals\");\n\t\t\t\tList<JCExpression> args = List.of(thisFieldAccessor, otherFieldAccessor);\n\t\t\t\tstatements.append(maker.If(maker.Unary(CTC_NOT,\n\t\t\t\t\tmaker.Apply(List.<JCExpression>nil(), eqMethod, args)), returnBool(maker, false), null));\n\t\t\t} else /* objects */ {\n\t\t\t\t/* final java.lang.Object this$fieldName = this.fieldName; */\n\t\t\t\t/* final java.lang.Object other$fieldName = other.fieldName; */\n\t\t\t\t/* if (this$fieldName == null ? other$fieldName != null : !this$fieldName.equals(other$fieldName)) return false; */\n\t\t\t\tName thisDollarFieldName = memberNode.toName(\"this\" + (isMethod ? \"$$\" : \"$\") + memberNode.getName());\n\t\t\t\tName otherDollarFieldName = memberNode.toName(\"other\" + (isMethod ? \"$$\" : \"$\") + memberNode.getName());\n\t\t\t\t\n\t\t\t\tstatements.append(maker.VarDef(maker.Modifiers(finalFlag), thisDollarFieldName, genJavaLangTypeRef(typeNode, \"Object\"), thisFieldAccessor));\n\t\t\t\tstatements.append(maker.VarDef(maker.Modifiers(finalFlag), otherDollarFieldName, genJavaLangTypeRef(typeNode, \"Object\"), otherFieldAccessor));\n\n\t\t\t\tJCExpression thisEqualsNull = maker.Binary(CTC_EQUAL, maker.Ident(thisDollarFieldName), maker.Literal(CTC_BOT, null));\n\t\t\t\tJCExpression otherNotEqualsNull = maker.Binary(CTC_NOT_EQUAL, maker.Ident(otherDollarFieldName), maker.Literal(CTC_BOT, null));\n\t\t\t\tJCExpression thisEqualsThat = maker.Apply(List.<JCExpression>nil(),\n\t\t\t\t\tmaker.Select(maker.Ident(thisDollarFieldName), typeNode.toName(\"equals\")),\n\t\t\t\t\tList.<JCExpression>of(maker.Ident(otherDollarFieldName)));\n\t\t\t\tJCExpression fieldsAreNotEqual = maker.Conditional(thisEqualsNull, otherNotEqualsNull, maker.Unary(CTC_NOT, thisEqualsThat));\n\t\t\t\tstatements.append(maker.If(fieldsAreNotEqual, returnBool(maker, false), null));\n\t\t\t}\n\t\t}\n\t\t\n\t\t/* return true; */ {\n\t\t\tstatements.append(returnBool(maker, true));\n\t\t}\n\t\t\n\t\tJCBlock body = maker.Block(0, statements.toList());\n\t\treturn recursiveSetGeneratedBy(maker.MethodDef(mods, typeNode.toName(\"equals\"), returnType, List.<JCTypeParameter>nil(), params, List.<JCExpression>nil(), body, null), source);\n\t}\n\n\tpublic JCMethodDecl createCanEqual(JavacNode typeNode, JavacNode source, List<JCAnnotation> onParam) {\n\t\t/* protected boolean canEqual(final java.lang.Object other) {\n\t\t *     return other instanceof Outer.Inner.MyType;\n\t\t * }\n\t\t */\n\t\tJavacTreeMaker maker = typeNode.getTreeMaker();\n\t\t\n\t\tList<JCAnnotation> annsOnMethod = List.nil();\n\t\tCheckerFrameworkVersion checkerFramework = getCheckerFrameworkVersion(typeNode);\n\t\tif (checkerFramework.generatePure()) {\n\t\t\tannsOnMethod = annsOnMethod.prepend(maker.Annotation(genTypeRef(typeNode, CheckerFrameworkVersion.NAME__PURE), List.<JCExpression>nil()));\n\t\t}\n\t\tJCModifiers mods = maker.Modifiers(Flags.PROTECTED, annsOnMethod);\n\t\tJCExpression returnType = maker.TypeIdent(CTC_BOOLEAN);\n\t\tName canEqualName = typeNode.toName(\"canEqual\");\n\t\tJCExpression objectType = genJavaLangTypeRef(typeNode, \"Object\");\n\t\tName otherName = typeNode.toName(\"other\");\n\t\tlong flags = JavacHandlerUtil.addFinalIfNeeded(Flags.PARAMETER, typeNode.getContext());\n\t\tJCVariableDecl param = maker.VarDef(maker.Modifiers(flags, onParam), otherName, objectType, null);\n\t\tcreateRelevantNullableAnnotation(typeNode, param);\n\t\tList<JCVariableDecl> params = List.of(param);\n\t\t\n\t\tJCBlock body = maker.Block(0, List.<JCStatement>of(\n\t\t\tmaker.Return(maker.TypeTest(maker.Ident(otherName), createTypeReference(typeNode, false)))));\n\t\t\n\t\treturn recursiveSetGeneratedBy(maker.MethodDef(mods, canEqualName, returnType, List.<JCTypeParameter>nil(), params, List.<JCExpression>nil(), body, null), source);\n\t}\n\t\n\tpublic JCStatement generateCompareFloatOrDouble(JCExpression thisDotField, JCExpression otherDotField,\n\t\tJavacTreeMaker maker, JavacNode node, boolean isDouble) {\n\t\t\n\t\t/* if (Float.compare(fieldName, other.fieldName) != 0) return false; */\n\t\tJCExpression clazz = genJavaLangTypeRef(node, isDouble ? \"Double\" : \"Float\");\n\t\tList<JCExpression> args = List.of(thisDotField, otherDotField);\n\t\tJCBinary compareCallEquals0 = maker.Binary(CTC_NOT_EQUAL, maker.Apply(\n\t\t\tList.<JCExpression>nil(), maker.Select(clazz, node.toName(\"compare\")), args), maker.Literal(0));\n\t\treturn maker.If(compareCallEquals0, returnBool(maker, false), null);\n\t}\n\t\n\tpublic JCStatement returnBool(JavacTreeMaker maker, boolean bool) {\n\t\treturn maker.Return(maker.Literal(CTC_BOOLEAN, bool ? 1 : 0));\n\t}\n\t\n\tprivate boolean jcAnnotatedTypeInit;\n\tprivate Class<?> jcAnnotatedTypeClass = null;\n\tprivate Field jcAnnotatedTypeUnderlyingTypeField = null;\n\t\n\tprivate JCExpression unnotate(JCExpression type) {\n\t\tif (!isJcAnnotatedType(type)) return type;\n\t\tif (jcAnnotatedTypeUnderlyingTypeField == null) return type;\n\t\ttry {\n\t\t\treturn (JCExpression) jcAnnotatedTypeUnderlyingTypeField.get(type);\n\t\t} catch (Exception ignore) {}\n\t\treturn type;\n\t}\n\t\n\tprivate boolean isJcAnnotatedType(JCExpression o) {\n\t\tif (o == null) return false;\n\t\tif (!jcAnnotatedTypeInit) {\n\t\t\ttry {\n\t\t\t\tjcAnnotatedTypeClass = Class.forName(\"com.sun.tools.javac.tree.JCTree$JCAnnotatedType\", false, o.getClass().getClassLoader());\n\t\t\t\tjcAnnotatedTypeUnderlyingTypeField = jcAnnotatedTypeClass.getDeclaredField(\"underlyingType\");\n\t\t\t}\n\t\t\tcatch (Exception ignore) {}\n\t\t\tjcAnnotatedTypeInit = true;\n\t\t}\n\t\treturn jcAnnotatedTypeClass == o.getClass();\n\t}\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2009-2021 The Project Lombok Authors.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage lombok.javac.handlers;\n\nimport static lombok.core.handlers.HandlerUtil.handleFlagUsage;\nimport static lombok.javac.Javac.*;\nimport static lombok.javac.handlers.JavacHandlerUtil.*;\n\nimport java.lang.reflect.Field;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\n\nimport com.sun.tools.javac.code.BoundKind;\nimport com.sun.tools.javac.code.Flags;\nimport com.sun.tools.javac.tree.JCTree.JCAnnotation;\nimport com.sun.tools.javac.tree.JCTree.JCArrayTypeTree;\nimport com.sun.tools.javac.tree.JCTree.JCBinary;\nimport com.sun.tools.javac.tree.JCTree.JCBlock;\nimport com.sun.tools.javac.tree.JCTree.JCClassDecl;\nimport com.sun.tools.javac.tree.JCTree.JCExpression;\nimport com.sun.tools.javac.tree.JCTree.JCExpressionStatement;\nimport com.sun.tools.javac.tree.JCTree.JCFieldAccess;\nimport com.sun.tools.javac.tree.JCTree.JCIdent;\nimport com.sun.tools.javac.tree.JCTree.JCMethodDecl;\nimport com.sun.tools.javac.tree.JCTree.JCMethodInvocation;\nimport com.sun.tools.javac.tree.JCTree.JCModifiers;\nimport com.sun.tools.javac.tree.JCTree.JCPrimitiveTypeTree;\nimport com.sun.tools.javac.tree.JCTree.JCStatement;\nimport com.sun.tools.javac.tree.JCTree.JCTypeParameter;\nimport com.sun.tools.javac.tree.JCTree.JCUnary;\nimport com.sun.tools.javac.tree.JCTree.JCVariableDecl;\nimport com.sun.tools.javac.util.List;\nimport com.sun.tools.javac.util.ListBuffer;\nimport com.sun.tools.javac.util.Name;\n\nimport lombok.ConfigurationKeys;\nimport lombok.EqualsAndHashCode;\nimport lombok.EqualsAndHashCode.CacheStrategy;\nimport lombok.core.AST.Kind;\nimport lombok.core.AnnotationValues;\nimport lombok.core.configuration.CallSuperType;\nimport lombok.core.configuration.CheckerFrameworkVersion;\nimport lombok.core.handlers.HandlerUtil;\nimport lombok.core.handlers.HandlerUtil.FieldAccess;\nimport lombok.core.handlers.InclusionExclusionUtils;\nimport lombok.core.handlers.InclusionExclusionUtils.Included;\nimport lombok.javac.JavacAnnotationHandler;\nimport lombok.javac.JavacNode;\nimport lombok.javac.JavacTreeMaker;\nimport lombok.javac.handlers.JavacHandlerUtil.MemberExistsResult;\nimport lombok.spi.Provides;\n\n/**\n * Handles the {@code lombok.EqualsAndHashCode} annotation for javac.\n */\n@Provides\npublic class HandleEqualsAndHashCode extends JavacAnnotationHandler<EqualsAndHashCode> {\n\tprivate static final String RESULT_NAME = \"result\";\n\tprivate static final String PRIME_NAME = \"PRIME\";\n\tprivate static final String HASH_CODE_CACHE_NAME = \"$hashCodeCache\";\n\t\n\t@Override public void handle(AnnotationValues<EqualsAndHashCode> annotation, JCAnnotation ast, JavacNode annotationNode) {\n\t\thandleFlagUsage(annotationNode, ConfigurationKeys.EQUALS_AND_HASH_CODE_FLAG_USAGE, \"@EqualsAndHashCode\");\n\t\t\n\t\tdeleteAnnotationIfNeccessary(annotationNode, EqualsAndHashCode.class);\n\t\tdeleteImportFromCompilationUnit(annotationNode, CacheStrategy.class.getName());\n\t\tEqualsAndHashCode ann = annotation.getInstance();\n\t\tjava.util.List<Included<JavacNode, EqualsAndHashCode.Include>> members = InclusionExclusionUtils.handleEqualsAndHashCodeMarking(annotationNode.up(), annotation, annotationNode);\n\t\tJavacNode typeNode = annotationNode.up();\n\t\tList<JCAnnotation> onParam = unboxAndRemoveAnnotationParameter(ast, \"onParam\", \"@EqualsAndHashCode(onParam\", annotationNode);\n\t\t\n\t\tBoolean callSuper = ann.callSuper();\n\t\tif (!annotation.isExplicit(\"callSuper\")) callSuper = null;\n\t\t\n\t\tBoolean doNotUseGettersConfiguration = annotationNode.getAst().readConfiguration(ConfigurationKeys.EQUALS_AND_HASH_CODE_DO_NOT_USE_GETTERS);\n\t\tboolean doNotUseGetters = annotation.isExplicit(\"doNotUseGetters\") || doNotUseGettersConfiguration == null ? ann.doNotUseGetters() : doNotUseGettersConfiguration;\n\t\tFieldAccess fieldAccess = doNotUseGetters ? FieldAccess.PREFER_FIELD : FieldAccess.GETTER;\n\t\t\n\t\tboolean cacheHashCode = ann.cacheStrategy() == CacheStrategy.LAZY;\n\t\t\n\t\tgenerateMethods(typeNode, annotationNode, members, callSuper, true, cacheHashCode, fieldAccess, onParam);\n\t}\n\t\n\tpublic void generateEqualsAndHashCodeForType(JavacNode typeNode, JavacNode source) {\n\t\tif (hasAnnotation(EqualsAndHashCode.class, typeNode)) {\n\t\t\t//The annotation will make it happen, so we can skip it.\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tBoolean doNotUseGettersConfiguration = typeNode.getAst().readConfiguration(ConfigurationKeys.EQUALS_AND_HASH_CODE_DO_NOT_USE_GETTERS);\n\t\tFieldAccess access = doNotUseGettersConfiguration == null || !doNotUseGettersConfiguration ? FieldAccess.GETTER : FieldAccess.PREFER_FIELD;\n\t\t\n\t\tjava.util.List<Included<JavacNode, EqualsAndHashCode.Include>> members = InclusionExclusionUtils.handleEqualsAndHashCodeMarking(typeNode, null, null);\n\t\t\n\t\tgenerateMethods(typeNode, source, members, null, false, false, access, List.<JCAnnotation>nil());\n\t}\n\t\n\tpublic void generateMethods(JavacNode typeNode, JavacNode source, java.util.List<Included<JavacNode, EqualsAndHashCode.Include>> members,\n\t\tBoolean callSuper, boolean whineIfExists, boolean cacheHashCode, FieldAccess fieldAccess, List<JCAnnotation> onParam) {\n\t\t\n\t\tif (!isClass(typeNode)) {\n\t\t\tsource.addError(\"@EqualsAndHashCode is only supported on a class.\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tboolean implicitCallSuper = callSuper == null;\n\t\tif (callSuper == null) {\n\t\t\ttry {\n\t\t\t\tcallSuper = ((Boolean) EqualsAndHashCode.class.getMethod(\"callSuper\").getDefaultValue()).booleanValue();\n\t\t\t} catch (Exception ignore) {\n\t\t\t\tthrow new InternalError(\"Lombok bug - this cannot happen - can't find callSuper field in EqualsAndHashCode annotation.\");\n\t\t\t}\n\t\t}\n\t\t\n\t\tboolean isDirectDescendantOfObject = isDirectDescendantOfObject(typeNode);\n\t\t\n\t\tboolean isFinal = (((JCClassDecl) typeNode.get()).mods.flags & Flags.FINAL) != 0;\n\t\tboolean needsCanEqual = !isFinal || !isDirectDescendantOfObject;\n\t\tMemberExistsResult equalsExists = methodExists(\"equals\", typeNode, 1);\n\t\tMemberExistsResult hashCodeExists = methodExists(\"hashCode\", typeNode, 0);\n\t\tMemberExistsResult canEqualExists = methodExists(\"canEqual\", typeNode, 1);\n\t\tswitch (Collections.max(Arrays.asList(equalsExists, hashCodeExists))) {\n\t\tcase EXISTS_BY_LOMBOK:\n\t\t\treturn;\n\t\tcase EXISTS_BY_USER:\n\t\t\tif (whineIfExists) {\n\t\t\t\tString msg = \"Not generating equals and hashCode: A method with one of those names already exists. (Either both or none of these methods will be generated).\";\n\t\t\t\tsource.addWarning(msg);\n\t\t\t} else if (equalsExists == MemberExistsResult.NOT_EXISTS || hashCodeExists == MemberExistsResult.NOT_EXISTS) {\n\t\t\t\t// This means equals OR hashCode exists and not both.\n\t\t\t\t// Even though we should suppress the message about not generating these, this is such a weird and surprising situation we should ALWAYS generate a warning.\n\t\t\t\t// The user code couldn't possibly (barring really weird subclassing shenanigans) be in a shippable state anyway; the implementations of these 2 methods are\n\t\t\t\t// all inter-related and should be written by the same entity.\n\t\t\t\tString msg = String.format(\"Not generating %s: One of equals or hashCode exists. \" +\n\t\t\t\t\t\"You should either write both of these or none of these (in the latter case, lombok generates them).\",\n\t\t\t\t\tequalsExists == MemberExistsResult.NOT_EXISTS ? \"equals\" : \"hashCode\");\n\t\t\t\tsource.addWarning(msg);\n\t\t\t}\n\t\t\treturn;\n\t\tcase NOT_EXISTS:\n\t\tdefault:\n\t\t\t//fallthrough\n\t\t}\n\t\t\n\t\tif (isDirectDescendantOfObject && callSuper) {\n\t\t\tsource.addError(\"Generating equals/hashCode with a supercall to java.lang.Object is pointless.\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (implicitCallSuper && !isDirectDescendantOfObject) {\n\t\t\tCallSuperType cst = typeNode.getAst().readConfiguration(ConfigurationKeys.EQUALS_AND_HASH_CODE_CALL_SUPER);\n\t\t\tif (cst == null) cst = CallSuperType.WARN;\n\t\t\t\n\t\t\tswitch (cst) {\n\t\t\tdefault:\n\t\t\tcase WARN:\n\t\t\t\tsource.addWarning(\"Generating equals/hashCode implementation but without a call to superclass, even though this class does not extend java.lang.Object. If this is intentional, add '@EqualsAndHashCode(callSuper=false)' to your type.\");\n\t\t\t\tcallSuper = false;\n\t\t\t\tbreak;\n\t\t\tcase SKIP:\n\t\t\t\tcallSuper = false;\n\t\t\t\tbreak;\n\t\t\tcase CALL:\n\t\t\t\tcallSuper = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tJCMethodDecl equalsMethod = createEquals(typeNode, members, callSuper, fieldAccess, needsCanEqual, source, onParam);\n\t\t\n\t\tinjectMethod(typeNode, equalsMethod);\n\t\t\n\t\tif (needsCanEqual && canEqualExists == MemberExistsResult.NOT_EXISTS) {\n\t\t\tJCMethodDecl canEqualMethod = createCanEqual(typeNode, source, copyAnnotations(onParam));\n\t\t\tinjectMethod(typeNode, canEqualMethod);\n\t\t}\n\t\t\n\t\tif (cacheHashCode){\n\t\t\tif (fieldExists(HASH_CODE_CACHE_NAME, typeNode) != MemberExistsResult.NOT_EXISTS) {\n\t\t\t\tString msg = String.format(\"Not caching the result of hashCode: A field named %s already exists.\", HASH_CODE_CACHE_NAME);\n\t\t\t\tsource.addWarning(msg);\n\t\t\t\tcacheHashCode = false;\n\t\t\t} else {\n\t\t\t\tcreateHashCodeCacheField(typeNode, source);\n\t\t\t}\n\t\t}\n\t\t\n\t\tJCMethodDecl hashCodeMethod = createHashCode(typeNode, members, callSuper, cacheHashCode, fieldAccess, source);\n\t\tinjectMethod(typeNode, hashCodeMethod);\n\t}\n\n\tprivate void createHashCodeCacheField(JavacNode typeNode, JavacNode source) {\n\t\tJavacTreeMaker maker = typeNode.getTreeMaker();\n\t\tJCModifiers mods = maker.Modifiers(Flags.PRIVATE | Flags.TRANSIENT);\n\t\tJCVariableDecl hashCodeCacheField = maker.VarDef(mods, typeNode.toName(HASH_CODE_CACHE_NAME), maker.TypeIdent(CTC_INT), null);\n\t\tinjectFieldAndMarkGenerated(typeNode, hashCodeCacheField);\n\t\trecursiveSetGeneratedBy(hashCodeCacheField, source);\n\t}\n\t\n\tpublic JCMethodDecl createHashCode(JavacNode typeNode, java.util.List<Included<JavacNode, EqualsAndHashCode.Include>> members, boolean callSuper, boolean cacheHashCode, FieldAccess fieldAccess, JavacNode source) {\n\t\tJavacTreeMaker maker = typeNode.getTreeMaker();\n\t\t\n\t\tJCAnnotation overrideAnnotation = maker.Annotation(genJavaLangTypeRef(typeNode, \"Override\"), List.<JCExpression>nil());\n\t\tList<JCAnnotation> annsOnMethod = List.of(overrideAnnotation);\n\t\tCheckerFrameworkVersion checkerFramework = getCheckerFrameworkVersion(typeNode);\n\t\tif (cacheHashCode && checkerFramework.generatePure()) {\n\t\t\tannsOnMethod = annsOnMethod.prepend(maker.Annotation(genTypeRef(typeNode, CheckerFrameworkVersion.NAME__PURE), List.<JCExpression>nil()));\n\t\t} else if (checkerFramework.generateSideEffectFree()) { \n\t\t\tannsOnMethod = annsOnMethod.prepend(maker.Annotation(genTypeRef(typeNode, CheckerFrameworkVersion.NAME__SIDE_EFFECT_FREE), List.<JCExpression>nil()));\n\t\t}\n\t\tJCModifiers mods = maker.Modifiers(Flags.PUBLIC, annsOnMethod);\n\t\tJCExpression returnType = maker.TypeIdent(CTC_INT);\n\t\tListBuffer<JCStatement> statements = new ListBuffer<JCStatement>();\n\t\t\n\t\tName primeName = typeNode.toName(PRIME_NAME);\n\t\tName resultName = typeNode.toName(RESULT_NAME);\n\t\tlong finalFlag = JavacHandlerUtil.addFinalIfNeeded(0L, typeNode.getContext());\n\t\t\n\t\tboolean isEmpty = members.isEmpty();\n\t\t\n\t\t/* if (this.$hashCodeCache != 0) return this.$hashCodeCache; */ {\n\t\t\tif (cacheHashCode) {\n\t\t\t\tJCFieldAccess hashCodeCacheFieldAccess = createHashCodeCacheFieldAccess(typeNode, maker);\n\t\t\t\tJCExpression cacheNotZero = maker.Binary(CTC_NOT_EQUAL, hashCodeCacheFieldAccess, maker.Literal(CTC_INT, 0));\n\t\t\t\thashCodeCacheFieldAccess = createHashCodeCacheFieldAccess(typeNode, maker);\n\t\t\t\tstatements.append(maker.If(cacheNotZero, maker.Return(hashCodeCacheFieldAccess), null));\n\t\t\t}\n\t\t}\n\t\t\n\t\t/* final int PRIME = X; */ {\n\t\t\tif (!isEmpty) {\n\t\t\t\tstatements.append(maker.VarDef(maker.Modifiers(finalFlag), primeName, maker.TypeIdent(CTC_INT), maker.Literal(HandlerUtil.primeForHashcode())));\n\t\t\t}\n\t\t}\n\t\t\n\t\t/* int result = ... */ {\n\t\t\tfinal JCExpression init;\n\t\t\tif (callSuper) {\n\t\t\t\t/* ... super.hashCode(); */\n\t\t\t\tinit = maker.Apply(List.<JCExpression>nil(),\n\t\t\t\t\tmaker.Select(maker.Ident(typeNode.toName(\"super\")), typeNode.toName(\"hashCode\")),\n\t\t\t\t\tList.<JCExpression>nil());\n\t\t\t} else {\n\t\t\t\t/* ... 1; */\n\t\t\t\tinit = maker.Literal(1);\n\t\t\t}\n\t\t\tstatements.append(maker.VarDef(maker.Modifiers(isEmpty && !cacheHashCode ? finalFlag : 0L), resultName, maker.TypeIdent(CTC_INT), init));\n\t\t}\n\t\t\n\t\tfor (Included<JavacNode, EqualsAndHashCode.Include> member : members) {\n\t\t\tJavacNode memberNode = member.getNode();\n\t\t\tJCExpression fType = unnotate(getFieldType(memberNode, fieldAccess));\n\t\t\tboolean isMethod = memberNode.getKind() == Kind.METHOD;\n\t\t\t\n\t\t\tJCExpression fieldAccessor = isMethod ? createMethodAccessor(maker, memberNode) : createFieldAccessor(maker, memberNode, fieldAccess);\n\t\t\tif (fType instanceof JCPrimitiveTypeTree) {\n\t\t\t\tswitch (((JCPrimitiveTypeTree) fType).getPrimitiveTypeKind()) {\n\t\t\t\tcase BOOLEAN:\n\t\t\t\t\t/* this.fieldName ? X : Y */\n\t\t\t\t\tstatements.append(createResultCalculation(typeNode, maker.Parens(maker.Conditional(fieldAccessor, \n\t\t\t\t\t\tmaker.Literal(HandlerUtil.primeForTrue()), maker.Literal(HandlerUtil.primeForFalse())))));\n\t\t\t\t\tbreak;\n\t\t\t\tcase LONG: {\n\t\t\t\t\t\tName dollarFieldName = memberNode.toName((isMethod ? \"$$\" : \"$\") + memberNode.getName());\n\t\t\t\t\t\tstatements.append(maker.VarDef(maker.Modifiers(finalFlag), dollarFieldName, maker.TypeIdent(CTC_LONG), fieldAccessor));\n\t\t\t\t\t\tstatements.append(createResultCalculation(typeNode, longToIntForHashCode(maker, maker.Ident(dollarFieldName), maker.Ident(dollarFieldName))));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase FLOAT:\n\t\t\t\t\t/* Float.floatToIntBits(this.fieldName) */\n\t\t\t\t\tstatements.append(createResultCalculation(typeNode, maker.Apply(\n\t\t\t\t\t\tList.<JCExpression>nil(),\n\t\t\t\t\t\tgenJavaLangTypeRef(typeNode, \"Float\", \"floatToIntBits\"),\n\t\t\t\t\t\tList.of(fieldAccessor))));\n\t\t\t\t\tbreak;\n\t\t\t\tcase DOUBLE: {\n\t\t\t\t\t\t/* longToIntForHashCode(Double.doubleToLongBits(this.fieldName)) */\n\t\t\t\t\tName dollarFieldName = memberNode.toName((isMethod ? \"$$\" : \"$\") + memberNode.getName());\n\t\t\t\t\t\tJCExpression init = maker.Apply(\n\t\t\t\t\t\t\tList.<JCExpression>nil(),\n\t\t\t\t\t\t\tgenJavaLangTypeRef(typeNode, \"Double\", \"doubleToLongBits\"),\n\t\t\t\t\t\t\tList.of(fieldAccessor));\n\t\t\t\t\t\tstatements.append(maker.VarDef(maker.Modifiers(finalFlag), dollarFieldName, maker.TypeIdent(CTC_LONG), init));\n\t\t\t\t\t\tstatements.append(createResultCalculation(typeNode, longToIntForHashCode(maker, maker.Ident(dollarFieldName), maker.Ident(dollarFieldName))));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\tcase BYTE:\n\t\t\t\tcase SHORT:\n\t\t\t\tcase INT:\n\t\t\t\tcase CHAR:\n\t\t\t\t\t/* just the field */\n\t\t\t\t\tstatements.append(createResultCalculation(typeNode, fieldAccessor));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (fType instanceof JCArrayTypeTree) {\n\t\t\t\tJCArrayTypeTree array = (JCArrayTypeTree) fType;\n\t\t\t\t/* java.util.Arrays.deepHashCode(this.fieldName) //use just hashCode() for primitive arrays. */\n\t\t\t\tboolean multiDim = unnotate(array.elemtype) instanceof JCArrayTypeTree;\n\t\t\t\tboolean primitiveArray = unnotate(array.elemtype) instanceof JCPrimitiveTypeTree;\n\t\t\t\tboolean useDeepHC = multiDim || !primitiveArray;\n\t\t\t\t\n\t\t\t\tJCExpression hcMethod = chainDots(typeNode, \"java\", \"util\", \"Arrays\", useDeepHC ? \"deepHashCode\" : \"hashCode\");\n\t\t\t\tstatements.append(createResultCalculation(typeNode, maker.Apply(List.<JCExpression>nil(), hcMethod, List.of(fieldAccessor))));\n\t\t\t} else /* objects */ {\n\t\t\t\t/* final java.lang.Object $fieldName = this.fieldName; */\n\t\t\t\t/* ($fieldName == null ? NULL_PRIME : $fieldName.hashCode()) */\n\t\t\t\t\n\t\t\t\tName dollarFieldName = memberNode.toName((isMethod ? \"$$\" : \"$\") + memberNode.getName());\n\t\t\t\tstatements.append(maker.VarDef(maker.Modifiers(finalFlag), dollarFieldName, genJavaLangTypeRef(typeNode, \"Object\"), fieldAccessor));\n\t\t\t\t\n\t\t\t\tJCExpression hcCall = maker.Apply(List.<JCExpression>nil(), maker.Select(maker.Ident(dollarFieldName), typeNode.toName(\"hashCode\")),\n\t\t\t\t\tList.<JCExpression>nil());\n\t\t\t\tJCExpression thisEqualsNull = maker.Binary(CTC_EQUAL, maker.Ident(dollarFieldName), maker.Literal(CTC_BOT, null));\n\t\t\t\tstatements.append(createResultCalculation(typeNode, maker.Parens(maker.Conditional(thisEqualsNull, maker.Literal(HandlerUtil.primeForNull()), hcCall))));\n\t\t\t}\n\t\t}\n\t\t\n\t\t/* \n\t\t * if (result == 0) result = Integer.MIN_VALUE;\n\t\t * this.$hashCodeCache = result;\n\t\t * \n\t\t */ {\n\t\t\tif (cacheHashCode) {\n\t\t\t\tstatements.append(maker.If(maker.Binary(CTC_EQUAL, maker.Ident(resultName), maker.Literal(CTC_INT, 0)), \n\t\t\t\t\tmaker.Exec(maker.Assign(maker.Ident(resultName), genJavaLangTypeRef(typeNode, \"Integer\", \"MIN_VALUE\"))), null));\n\t\t\t\t\n\t\t\t\tJCFieldAccess cacheHashCodeFieldAccess = createHashCodeCacheFieldAccess(typeNode, maker);\n\t\t\t\tstatements.append(maker.Exec(maker.Assign(cacheHashCodeFieldAccess, maker.Ident(resultName))));\n\t\t\t}\n\t\t}\n\t\t\n\t\t/* return result; */ {\n\t\t\tstatements.append(maker.Return(maker.Ident(resultName)));\n\t\t}\n\t\t\n\t\tJCBlock body = maker.Block(0, statements.toList());\n\t\treturn recursiveSetGeneratedBy(maker.MethodDef(mods, typeNode.toName(\"hashCode\"), returnType,\n\t\t\tList.<JCTypeParameter>nil(), List.<JCVariableDecl>nil(), List.<JCExpression>nil(), body, null), source);\n\t}\n\n\tprivate JCFieldAccess createHashCodeCacheFieldAccess(JavacNode typeNode, JavacTreeMaker maker) {\n\t\tJCIdent receiver = maker.Ident(typeNode.toName(\"this\"));\n\t\tJCFieldAccess cacheHashCodeFieldAccess = maker.Select(receiver, typeNode.toName(HASH_CODE_CACHE_NAME));\n\t\treturn cacheHashCodeFieldAccess;\n\t}\n\n\tpublic JCExpressionStatement createResultCalculation(JavacNode typeNode, JCExpression expr) {\n\t\t/* result = result * PRIME + expr; */\n\t\tJavacTreeMaker maker = typeNode.getTreeMaker();\n\t\tName resultName = typeNode.toName(RESULT_NAME);\n\t\tJCExpression mult = maker.Binary(CTC_MUL, maker.Ident(resultName), maker.Ident(typeNode.toName(PRIME_NAME)));\n\t\tJCExpression add = maker.Binary(CTC_PLUS, mult, expr);\n\t\treturn maker.Exec(maker.Assign(maker.Ident(resultName), add));\n\t}\n\t\n\t/** The 2 references must be clones of each other. */\n\tpublic JCExpression longToIntForHashCode(JavacTreeMaker maker, JCExpression ref1, JCExpression ref2) {\n\t\t/* (int) (ref >>> 32 ^ ref) */\n\t\tJCExpression shift = maker.Binary(CTC_UNSIGNED_SHIFT_RIGHT, ref1, maker.Literal(32));\n\t\tJCExpression xorBits = maker.Binary(CTC_BITXOR, shift, ref2);\n\t\treturn maker.TypeCast(maker.TypeIdent(CTC_INT), maker.Parens(xorBits));\n\t}\n\t\n\tpublic JCExpression createTypeReference(JavacNode type, boolean addWildcards) {\n\t\tjava.util.List<String> list = new ArrayList<String>();\n\t\tjava.util.List<Integer> genericsCount = addWildcards ? new ArrayList<Integer>() : null;\n\t\t\n\t\tlist.add(type.getName());\n\t\tif (addWildcards) genericsCount.add(((JCClassDecl) type.get()).typarams.size());\n\t\tboolean staticContext = (((JCClassDecl) type.get()).getModifiers().flags & Flags.STATIC) != 0;\n\t\tJavacNode tNode = type.up();\n\t\t\n\t\twhile (tNode != null && tNode.getKind() == Kind.TYPE && !tNode.getName().isEmpty()) {\n\t\t\tlist.add(tNode.getName());\n\t\t\tif (addWildcards) genericsCount.add(staticContext ? 0 : ((JCClassDecl) tNode.get()).typarams.size());\n\t\t\tif (!staticContext) staticContext = (((JCClassDecl) tNode.get()).getModifiers().flags & Flags.STATIC) != 0;\n\t\t\ttNode = tNode.up();\n\t\t}\n\t\tCollections.reverse(list);\n\t\tif (addWildcards) Collections.reverse(genericsCount);\n\t\t\n\t\tJavacTreeMaker maker = type.getTreeMaker();\n\t\t\n\t\tJCExpression chain = maker.Ident(type.toName(list.get(0)));\n\t\tif (addWildcards) chain = wildcardify(maker, chain, genericsCount.get(0));\n\t\t\n\t\tfor (int i = 1; i < list.size(); i++) {\n\t\t\tchain = maker.Select(chain, type.toName(list.get(i)));\n\t\t\tif (addWildcards) chain = wildcardify(maker, chain, genericsCount.get(i));\n\t\t}\n\t\t\n\t\treturn chain;\n\t}\n\t\n\tprivate JCExpression wildcardify(JavacTreeMaker maker, JCExpression expr, int count) {\n\t\tif (count == 0) return expr;\n\t\t\n\t\tListBuffer<JCExpression> wildcards = new ListBuffer<JCExpression>();\n\t\tfor (int i = 0 ; i < count ; i++) {\n\t\t\twildcards.append(maker.Wildcard(maker.TypeBoundKind(BoundKind.UNBOUND), null));\n\t\t}\n\t\t\n\t\treturn maker.TypeApply(expr, wildcards.toList());\n\t}\n\t\n\tpublic JCMethodDecl createEquals(JavacNode typeNode, java.util.List<Included<JavacNode, EqualsAndHashCode.Include>> members, boolean callSuper, FieldAccess fieldAccess, boolean needsCanEqual, JavacNode source, List<JCAnnotation> onParam) {\n\t\tJavacTreeMaker maker = typeNode.getTreeMaker();\n\t\t\n\t\tName oName = typeNode.toName(\"o\");\n\t\tName otherName = typeNode.toName(\"other\");\n\t\tName thisName = typeNode.toName(\"this\");\n\t\t\n\t\tList<JCAnnotation> annsOnParamOnMethod = List.nil();\n\t\t\n\t\tJCAnnotation overrideAnnotation = maker.Annotation(genJavaLangTypeRef(typeNode, \"Override\"), List.<JCExpression>nil());\n\t\tList<JCAnnotation> annsOnMethod = List.of(overrideAnnotation);\n\t\tCheckerFrameworkVersion checkerFramework = getCheckerFrameworkVersion(typeNode);\n\t\tif (checkerFramework.generateSideEffectFree()) {\n\t\t\tannsOnMethod = annsOnMethod.prepend(maker.Annotation(genTypeRef(typeNode, CheckerFrameworkVersion.NAME__SIDE_EFFECT_FREE), List.<JCExpression>nil()));\n\t\t}\n\t\tJCModifiers mods = maker.Modifiers(Flags.PUBLIC, annsOnMethod);\n\t\tJCExpression objectType;\n\t\tif (annsOnParamOnMethod.isEmpty()) {\n\t\t\tobjectType = genJavaLangTypeRef(typeNode, \"Object\");\n\t\t} else {\n\t\t\tobjectType = chainDots(typeNode, \"java\", \"lang\", \"Object\");\n\t\t\tobjectType = maker.AnnotatedType(annsOnParamOnMethod, objectType);\n\t\t}\n\t\t\n\t\tJCExpression returnType = maker.TypeIdent(CTC_BOOLEAN);\n\t\t\n\t\tlong finalFlag = JavacHandlerUtil.addFinalIfNeeded(0L, typeNode.getContext());\n\t\t\n\t\tListBuffer<JCStatement> statements = new ListBuffer<JCStatement>();\n\t\tJCVariableDecl param = maker.VarDef(maker.Modifiers(finalFlag | Flags.PARAMETER, onParam), oName, objectType, null);\n\t\tJavacHandlerUtil.createRelevantNullableAnnotation(typeNode, param);\n\t\t\n\t\tfinal List<JCVariableDecl> params = List.of(param);\n\t\t\n\t\t/* if (o == this) return true; */ {\n\t\t\tstatements.append(maker.If(maker.Binary(CTC_EQUAL, maker.Ident(oName),\n\t\t\t\tmaker.Ident(thisName)), returnBool(maker, true), null));\n\t\t}\n\t\t\n\t\t/* if (!(o instanceof Outer.Inner.MyType)) return false; */ {\n\t\t\t \n\t\t\tJCUnary notInstanceOf = maker.Unary(CTC_NOT, maker.Parens(maker.TypeTest(maker.Ident(oName), createTypeReference(typeNode, false))));\n\t\t\tstatements.append(maker.If(notInstanceOf, returnBool(maker, false), null));\n\t\t}\n\t\t\n\t\t/* Outer.Inner.MyType<?> other = (Outer.Inner.MyType<?>) o; */ {\n\t\t\tif (!members.isEmpty() || needsCanEqual) {\n\t\t\t\tfinal JCExpression selfType1 = createTypeReference(typeNode, true), selfType2 = createTypeReference(typeNode, true);\n\t\t\t\t\n\t\t\t\tstatements.append(\n\t\t\t\t\tmaker.VarDef(maker.Modifiers(finalFlag), otherName, selfType1, maker.TypeCast(selfType2, maker.Ident(oName))));\n\t\t\t}\n\t\t}\n\t\t\n\t\t/* if (!other.canEqual((java.lang.Object) this)) return false; */ {\n\t\t\tif (needsCanEqual) {\n\t\t\t\tList<JCExpression> exprNil = List.nil();\n\t\t\t\tJCExpression thisRef = maker.Ident(thisName);\n\t\t\t\tJCExpression castThisRef = maker.TypeCast(genJavaLangTypeRef(typeNode, \"Object\"), thisRef);\n\t\t\t\tJCExpression equalityCheck = maker.Apply(exprNil, \n\t\t\t\t\tmaker.Select(maker.Ident(otherName), typeNode.toName(\"canEqual\")),\n\t\t\t\t\tList.of(castThisRef));\n\t\t\t\tstatements.append(maker.If(maker.Unary(CTC_NOT, equalityCheck), returnBool(maker, false), null));\n\t\t\t}\n\t\t}\n\t\t\n\t\t/* if (!super.equals(o)) return false; */\n\t\tif (callSuper) {\n\t\t\tJCMethodInvocation callToSuper = maker.Apply(List.<JCExpression>nil(),\n\t\t\t\tmaker.Select(maker.Ident(typeNode.toName(\"super\")), typeNode.toName(\"equals\")),\n\t\t\t\tList.<JCExpression>of(maker.Ident(oName)));\n\t\t\tJCUnary superNotEqual = maker.Unary(CTC_NOT, callToSuper);\n\t\t\tstatements.append(maker.If(superNotEqual, returnBool(maker, false), null));\n\t\t}\n\t\t\n\t\tfor (Included<JavacNode, EqualsAndHashCode.Include> member : members) {\n\t\t\tJavacNode memberNode = member.getNode();\n\t\t\tboolean isMethod = memberNode.getKind() == Kind.METHOD;\n\t\t\t\n\t\t\tJCExpression fType = unnotate(getFieldType(memberNode, fieldAccess));\n\t\t\tJCExpression thisFieldAccessor = isMethod ? createMethodAccessor(maker, memberNode) : createFieldAccessor(maker, memberNode, fieldAccess);\n\t\t\tJCExpression otherFieldAccessor = isMethod ? createMethodAccessor(maker, memberNode, maker.Ident(otherName)) : createFieldAccessor(maker, memberNode, fieldAccess, maker.Ident(otherName));\n\t\t\tif (fType instanceof JCPrimitiveTypeTree) {\n\t\t\t\tswitch (((JCPrimitiveTypeTree)fType).getPrimitiveTypeKind()) {\n\t\t\t\tcase FLOAT:\n\t\t\t\t\t/* if (Float.compare(this.fieldName, other.fieldName) != 0) return false; */\n\t\t\t\t\tstatements.append(generateCompareFloatOrDouble(thisFieldAccessor, otherFieldAccessor, maker, typeNode, false));\n\t\t\t\t\tbreak;\n\t\t\t\tcase DOUBLE:\n\t\t\t\t\t/* if (Double.compare(this.fieldName, other.fieldName) != 0) return false; */\n\t\t\t\t\tstatements.append(generateCompareFloatOrDouble(thisFieldAccessor, otherFieldAccessor, maker, typeNode, true));\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t/* if (this.fieldName != other.fieldName) return false; */\n\t\t\t\t\tstatements.append(\n\t\t\t\t\t\t\tmaker.If(maker.Binary(CTC_NOT_EQUAL, thisFieldAccessor, otherFieldAccessor), returnBool(maker, false), null));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (fType instanceof JCArrayTypeTree) {\n\t\t\t\tJCArrayTypeTree array = (JCArrayTypeTree) fType;\n\t\t\t\t/* if (!java.util.Arrays.deepEquals(this.fieldName, other.fieldName)) return false; //use equals for primitive arrays. */\n\t\t\t\tboolean multiDim = unnotate(array.elemtype) instanceof JCArrayTypeTree;\n\t\t\t\tboolean primitiveArray = unnotate(array.elemtype) instanceof JCPrimitiveTypeTree;\n\t\t\t\tboolean useDeepEquals = multiDim || !primitiveArray;\n\t\t\t\t\n\t\t\t\tJCExpression eqMethod = chainDots(typeNode, \"java\", \"util\", \"Arrays\", useDeepEquals ? \"deepEquals\" : \"equals\");\n\t\t\t\tList<JCExpression> args = List.of(thisFieldAccessor, otherFieldAccessor);\n\t\t\t\tstatements.append(maker.If(maker.Unary(CTC_NOT,\n\t\t\t\t\tmaker.Apply(List.<JCExpression>nil(), eqMethod, args)), returnBool(maker, false), null));\n\t\t\t} else /* objects */ {\n\t\t\t\t/* final java.lang.Object this$fieldName = this.fieldName; */\n\t\t\t\t/* final java.lang.Object other$fieldName = other.fieldName; */\n\t\t\t\t/* if (this$fieldName == null ? other$fieldName != null : !this$fieldName.equals(other$fieldName)) return false; */\n\t\t\t\tName thisDollarFieldName = memberNode.toName(\"this\" + (isMethod ? \"$$\" : \"$\") + memberNode.getName());\n\t\t\t\tName otherDollarFieldName = memberNode.toName(\"other\" + (isMethod ? \"$$\" : \"$\") + memberNode.getName());\n\t\t\t\t\n\t\t\t\tstatements.append(maker.VarDef(maker.Modifiers(finalFlag), thisDollarFieldName, genJavaLangTypeRef(typeNode, \"Object\"), thisFieldAccessor));\n\t\t\t\tstatements.append(maker.VarDef(maker.Modifiers(finalFlag), otherDollarFieldName, genJavaLangTypeRef(typeNode, \"Object\"), otherFieldAccessor));\n\n\t\t\t\tJCExpression thisEqualsNull = maker.Binary(CTC_EQUAL, maker.Ident(thisDollarFieldName), maker.Literal(CTC_BOT, null));\n\t\t\t\tJCExpression otherNotEqualsNull = maker.Binary(CTC_NOT_EQUAL, maker.Ident(otherDollarFieldName), maker.Literal(CTC_BOT, null));\n\t\t\t\tJCExpression thisEqualsThat = maker.Apply(List.<JCExpression>nil(),\n\t\t\t\t\tmaker.Select(maker.Ident(thisDollarFieldName), typeNode.toName(\"equals\")),\n\t\t\t\t\tList.<JCExpression>of(maker.Ident(otherDollarFieldName)));\n\t\t\t\tJCExpression fieldsAreNotEqual = maker.Conditional(thisEqualsNull, otherNotEqualsNull, maker.Unary(CTC_NOT, thisEqualsThat));\n\t\t\t\tstatements.append(maker.If(fieldsAreNotEqual, returnBool(maker, false), null));\n\t\t\t}\n\t\t}\n\t\t\n\t\t/* return true; */ {\n\t\t\tstatements.append(returnBool(maker, true));\n\t\t}\n\t\t\n\t\tJCBlock body = maker.Block(0, statements.toList());\n\t\treturn recursiveSetGeneratedBy(maker.MethodDef(mods, typeNode.toName(\"equals\"), returnType, List.<JCTypeParameter>nil(), params, List.<JCExpression>nil(), body, null), source);\n\t}\n\n\tpublic JCMethodDecl createCanEqual(JavacNode typeNode, JavacNode source, List<JCAnnotation> onParam) {\n\t\t/* protected boolean canEqual(final java.lang.Object other) {\n\t\t *     return other instanceof Outer.Inner.MyType;\n\t\t * }\n\t\t */\n\t\tJavacTreeMaker maker = typeNode.getTreeMaker();\n\t\t\n\t\tList<JCAnnotation> annsOnMethod = List.nil();\n\t\tCheckerFrameworkVersion checkerFramework = getCheckerFrameworkVersion(typeNode);\n\t\tif (checkerFramework.generatePure()) {\n\t\t\tannsOnMethod = annsOnMethod.prepend(maker.Annotation(genTypeRef(typeNode, CheckerFrameworkVersion.NAME__PURE), List.<JCExpression>nil()));\n\t\t}\n\t\tJCModifiers mods = maker.Modifiers(Flags.PROTECTED, annsOnMethod);\n\t\tJCExpression returnType = maker.TypeIdent(CTC_BOOLEAN);\n\t\tName canEqualName = typeNode.toName(\"canEqual\");\n\t\tJCExpression objectType = genJavaLangTypeRef(typeNode, \"Object\");\n\t\tName otherName = typeNode.toName(\"other\");\n\t\tlong flags = JavacHandlerUtil.addFinalIfNeeded(Flags.PARAMETER, typeNode.getContext());\n\t\tJCVariableDecl param = maker.VarDef(maker.Modifiers(flags, onParam), otherName, objectType, null);\n\t\tcreateRelevantNullableAnnotation(typeNode, param);\n\t\tList<JCVariableDecl> params = List.of(param);\n\t\t\n\t\tJCBlock body = maker.Block(0, List.<JCStatement>of(\n\t\t\tmaker.Return(maker.TypeTest(maker.Ident(otherName), createTypeReference(typeNode, false)))));\n\t\t\n\t\treturn recursiveSetGeneratedBy(maker.MethodDef(mods, canEqualName, returnType, List.<JCTypeParameter>nil(), params, List.<JCExpression>nil(), body, null), source);\n\t}\n\t\n\tpublic JCStatement generateCompareFloatOrDouble(JCExpression thisDotField, JCExpression otherDotField,\n\t\tJavacTreeMaker maker, JavacNode node, boolean isDouble) {\n\t\t\n\t\t/* if (Float.compare(fieldName, other.fieldName) != 0) return false; */\n\t\tJCExpression clazz = genJavaLangTypeRef(node, isDouble ? \"Double\" : \"Float\");\n\t\tList<JCExpression> args = List.of(thisDotField, otherDotField);\n\t\tJCBinary compareCallEquals0 = maker.Binary(CTC_NOT_EQUAL, maker.Apply(\n\t\t\tList.<JCExpression>nil(), maker.Select(clazz, node.toName(\"compare\")), args), maker.Literal(0));\n\t\treturn maker.If(compareCallEquals0, returnBool(maker, false), null);\n\t}\n\t\n\tpublic JCStatement returnBool(JavacTreeMaker maker, boolean bool) {\n\t\treturn maker.Return(maker.Literal(CTC_BOOLEAN, bool ? 1 : 0));\n\t}\n\t\n\tprivate boolean jcAnnotatedTypeInit;\n\tprivate Class<?> jcAnnotatedTypeClass = null;\n\tprivate Field jcAnnotatedTypeUnderlyingTypeField = null;\n\t\n\tprivate JCExpression unnotate(JCExpression type) {\n\t\tif (!isJcAnnotatedType(type)) return type;\n\t\tif (jcAnnotatedTypeUnderlyingTypeField == null) return type;\n\t\ttry {\n\t\t\treturn (JCExpression) jcAnnotatedTypeUnderlyingTypeField.get(type);\n\t\t} catch (Exception ignore) {}\n\t\treturn type;\n\t}\n\t\n\tprivate boolean isJcAnnotatedType(JCExpression o) {\n\t\tif (o == null) return false;\n\t\tif (!jcAnnotatedTypeInit) {\n\t\t\ttry {\n\t\t\t\tjcAnnotatedTypeClass = Class.forName(\"com.sun.tools.javac.tree.JCTree$JCAnnotatedType\", false, o.getClass().getClassLoader());\n\t\t\t\tjcAnnotatedTypeUnderlyingTypeField = jcAnnotatedTypeClass.getDeclaredField(\"underlyingType\");\n\t\t\t}\n\t\t\tcatch (Exception ignore) {}\n\t\t\tjcAnnotatedTypeInit = true;\n\t\t}\n\t\treturn jcAnnotatedTypeClass == o.getClass();\n\t}\n}\n","lineNo":363}
{"Smelly Sample":"/*\n * Copyright (C) 2013-2021 The Project Lombok Authors.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage lombok.eclipse.handlers;\n\nimport static lombok.core.handlers.HandlerUtil.handleFlagUsage;\nimport static lombok.eclipse.Eclipse.*;\nimport static lombok.eclipse.handlers.EclipseHandlerUtil.*;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.eclipse.jdt.internal.compiler.ast.ASTNode;\nimport org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.AbstractVariableDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.Annotation;\nimport org.eclipse.jdt.internal.compiler.ast.Argument;\nimport org.eclipse.jdt.internal.compiler.ast.AssertStatement;\nimport org.eclipse.jdt.internal.compiler.ast.Assignment;\nimport org.eclipse.jdt.internal.compiler.ast.Block;\nimport org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.EqualExpression;\nimport org.eclipse.jdt.internal.compiler.ast.ExplicitConstructorCall;\nimport org.eclipse.jdt.internal.compiler.ast.Expression;\nimport org.eclipse.jdt.internal.compiler.ast.FieldDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.FieldReference;\nimport org.eclipse.jdt.internal.compiler.ast.IfStatement;\nimport org.eclipse.jdt.internal.compiler.ast.MessageSend;\nimport org.eclipse.jdt.internal.compiler.ast.NullLiteral;\nimport org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference;\nimport org.eclipse.jdt.internal.compiler.ast.SingleNameReference;\nimport org.eclipse.jdt.internal.compiler.ast.SingleTypeReference;\nimport org.eclipse.jdt.internal.compiler.ast.Statement;\nimport org.eclipse.jdt.internal.compiler.ast.SynchronizedStatement;\nimport org.eclipse.jdt.internal.compiler.ast.ThisReference;\nimport org.eclipse.jdt.internal.compiler.ast.ThrowStatement;\nimport org.eclipse.jdt.internal.compiler.ast.TryStatement;\nimport org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.TypeReference;\nimport org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;\n\nimport lombok.ConfigurationKeys;\nimport lombok.NonNull;\nimport lombok.core.AST.Kind;\nimport lombok.core.AnnotationValues;\nimport lombok.core.HandlerPriority;\nimport lombok.eclipse.EcjAugments;\nimport lombok.eclipse.EclipseAST;\nimport lombok.eclipse.EclipseAnnotationHandler;\nimport lombok.eclipse.EclipseNode;\nimport lombok.spi.Provides;\n\n@Provides\n@HandlerPriority(value = 512) // 2^9; onParameter=@__(@NonNull) has to run first.\npublic class HandleNonNull extends EclipseAnnotationHandler<NonNull> {\n\tprivate static final char[] REQUIRE_NON_NULL = \"requireNonNull\".toCharArray();\n\tprivate static final char[] CHECK_NOT_NULL = \"checkNotNull\".toCharArray();\n\t\n\tpublic static final HandleNonNull INSTANCE = new HandleNonNull();\n\t\n\tpublic void fix(EclipseNode method) {\n\t\tfor (EclipseNode m : method.down()) {\n\t\t\tif (m.getKind() != Kind.ARGUMENT) continue;\n\t\t\tfor (EclipseNode c : m.down()) {\n\t\t\t\tif (c.getKind() == Kind.ANNOTATION) {\n\t\t\t\t\tif (annotationTypeMatches(NonNull.class, c)) {\n\t\t\t\t\t\thandle0((Annotation) c.get(), c, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate List<FieldDeclaration> getRecordComponents(EclipseNode typeNode) {\n\t\tList<FieldDeclaration> list = new ArrayList<FieldDeclaration>();\n\t\t\n\t\tfor (EclipseNode child : typeNode.down()) {\n\t\t\tif (child.getKind() == Kind.FIELD) {\n\t\t\t\tFieldDeclaration fd = (FieldDeclaration) child.get();\n\t\t\t\tif ((fd.modifiers & AccRecord) != 0) list.add(fd);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn list;\n\t}\n\t\n\tprivate EclipseNode addCompactConstructorIfNeeded(EclipseNode typeNode, EclipseNode annotationNode) {\n\t\t// explicit Compact Constructor has bits set: Bit32, IsCanonicalConstructor (10).\n\t\t// implicit Compact Constructor has bits set: Bit32, IsCanonicalConstructor (10), and IsImplicit (11).\n\t\t// explicit constructor with long-form shows up as a normal constructor (Bit32 set, that's all), but the\n\t\t//   implicit CC is then also present and will presumably be stripped out in some later phase.\n\t\t\n\t\tEclipseNode toRemove = null;\n\t\tEclipseNode existingCompactConstructor = null;\n\t\tList<FieldDeclaration> recordComponents = null;\n\t\tfor (EclipseNode child : typeNode.down()) {\n\t\t\tif (!(child.get() instanceof ConstructorDeclaration)) continue;\n\t\t\tConstructorDeclaration cd = (ConstructorDeclaration) child.get();\n\t\t\tif ((cd.bits & IsCanonicalConstructor) != 0) {\n\t\t\t\tif ((cd.bits & IsImplicit) != 0) {\n\t\t\t\t\ttoRemove = child;\n\t\t\t\t} else {\n\t\t\t\t\texistingCompactConstructor = child;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// If this constructor has exact matching types vs. the record components,\n\t\t\t\t// this is the canonical constructor in long form and we should not generate one.\n\t\t\t\t\n\t\t\t\tif (recordComponents == null) recordComponents = getRecordComponents(typeNode);\n\t\t\t\tint argLength = cd.arguments == null ? 0 : cd.arguments.length;\n\t\t\t\tint compLength = recordComponents.size();\n\t\t\t\tboolean isCanonical = argLength == compLength;\n\t\t\t\tif (isCanonical) top: for (int i = 0; i < argLength; i++) {\n\t\t\t\t\tTypeReference a = recordComponents.get(i).type;\n\t\t\t\t\tTypeReference b = cd.arguments[i] == null ? null : cd.arguments[i].type;\n\t\t\t\t\t// technically this won't match e.g. `java.lang.String` to just `String`;\n\t\t\t\t\t// to use this feature you'll need to use the same way to write it, which seems\n\t\t\t\t\t// like a fair requirement.\n\t\t\t\t\tchar[][] ta = getRawTypeName(a);\n\t\t\t\t\tchar[][] tb = getRawTypeName(b);\n\t\t\t\t\tif (ta == null || tb == null || ta.length != tb.length) {\n\t\t\t\t\t\tisCanonical = false;\n\t\t\t\t\t\tbreak top;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int j = 0; j < ta.length; j++) {\n\t\t\t\t\t\tif (!Arrays.equals(ta[j], tb[j])) {\n\t\t\t\t\t\t\tisCanonical = false;\n\t\t\t\t\t\t\tbreak top;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (isCanonical) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (existingCompactConstructor != null) return existingCompactConstructor;\n\t\tint posToInsert = -1;\n\t\tTypeDeclaration td = (TypeDeclaration) typeNode.get();\n\t\tif (toRemove != null) {\n\t\t\tint idxToRemove = -1;\n\t\t\tfor (int i = 0; i < td.methods.length; i++) {\n\t\t\t\tif (td.methods[i] == toRemove.get()) idxToRemove = i;\n\t\t\t}\n\t\t\tif (idxToRemove != -1) {\n\t\t\t\tSystem.arraycopy(td.methods, idxToRemove + 1, td.methods, idxToRemove, td.methods.length - idxToRemove - 1);\n\t\t\t\tposToInsert = td.methods.length - 1;\n\t\t\t\ttypeNode.removeChild(toRemove);\n\t\t\t}\n\t\t}\n\t\tif (posToInsert == -1) {\n\t\t\tAbstractMethodDeclaration[] na = new AbstractMethodDeclaration[td.methods.length + 1];\n\t\t\tposToInsert = td.methods.length;\n\t\t\tSystem.arraycopy(td.methods, 0, na, 0, posToInsert);\n\t\t\ttd.methods = na;\n\t\t}\n\t\t\n\t\tConstructorDeclaration cd = new ConstructorDeclaration(((CompilationUnitDeclaration) typeNode.top().get()).compilationResult);\n\t\tcd.modifiers = ClassFileConstants.AccPublic;\n\t\tcd.bits = ASTNode.Bit32 | ECLIPSE_DO_NOT_TOUCH_FLAG | IsCanonicalConstructor;\n\t\tcd.selector = td.name;\n\t\tcd.constructorCall = new ExplicitConstructorCall(ExplicitConstructorCall.ImplicitSuper);\n\t\tif (recordComponents == null) recordComponents = getRecordComponents(typeNode);\n\t\tcd.arguments = new Argument[recordComponents.size()];\n\t\tcd.statements = new Statement[recordComponents.size()];\n\t\tcd.bits = IsCanonicalConstructor;\n\t\t\n\t\tfor (int i = 0; i < cd.arguments.length; i++) {\n\t\t\tFieldDeclaration cmp = recordComponents.get(i);\n\t\t\tcd.arguments[i] = new Argument(cmp.name, cmp.sourceStart, cmp.type, 0);\n\t\t\tcd.arguments[i].bits = ASTNode.IsArgument | ASTNode.IgnoreRawTypeCheck | ASTNode.IsReachable;\n\t\t\tFieldReference lhs = new FieldReference(cmp.name, 0);\n\t\t\tlhs.receiver = new ThisReference(0, 0);\n\t\t\tSingleNameReference rhs = new SingleNameReference(cmp.name, 0);\n\t\t\tcd.statements[i] = new Assignment(lhs, rhs, cmp.sourceEnd);\n\t\t}\n\t\t\n\t\tsetGeneratedBy(cd, annotationNode.get());\n\t\tfor (int i = 0; i < cd.arguments.length; i++) {\n\t\t\tFieldDeclaration cmp = recordComponents.get(i);\n\t\t\tcd.arguments[i].sourceStart = cmp.sourceStart;\n\t\t\tcd.arguments[i].sourceEnd = cmp.sourceStart;\n\t\t\tcd.arguments[i].declarationSourceEnd = cmp.sourceStart;\n\t\t\tcd.arguments[i].declarationEnd = cmp.sourceStart;\n\t\t}\n\t\t\n\t\ttd.methods[posToInsert] = cd;\n\t\tcd.annotations = addSuppressWarningsAll(typeNode, cd, cd.annotations);\n\t\tcd.annotations = addGenerated(typeNode, cd, cd.annotations);\n\t\treturn typeNode.add(cd, Kind.METHOD);\n\t}\n\t\n\tprivate static char[][] getRawTypeName(TypeReference a) {\n\t\tif (a instanceof QualifiedTypeReference) return ((QualifiedTypeReference) a).tokens;\n\t\tif (a instanceof SingleTypeReference) return new char[][] {((SingleTypeReference) a).token};\n\t\treturn null;\n\t}\n\t\n\t@Override public void handle(AnnotationValues<NonNull> annotation, Annotation ast, EclipseNode annotationNode) {\n\t\t// Generating new methods is only possible during diet parse but modifying existing methods requires a full parse.\n\t\t// As we need both for @NonNull we reset the handled flag during diet parse.\n\t\t\n\t\tif (!annotationNode.isCompleteParse()) {\n\t\t\tif (annotationNode.up().getKind() == Kind.FIELD) {\n\t\t\t\t//Check if this is a record and we need to generate the compact form constructor.\n\t\t\t\tEclipseNode typeNode = annotationNode.up().up();\n\t\t\t\tif (typeNode.getKind() == Kind.TYPE) {\n\t\t\t\t\tif (isRecord(typeNode)) {\n\t\t\t\t\t\taddCompactConstructorIfNeeded(typeNode, annotationNode);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tEcjAugments.ASTNode_handled.clear(ast);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\thandle0(ast, annotationNode, false);\n\t}\n\t\n\tprivate EclipseNode findCompactConstructor(EclipseNode typeNode) {\n\t\tfor (EclipseNode child : typeNode.down()) {\n\t\t\tif (!(child.get() instanceof ConstructorDeclaration)) continue;\n\t\t\tConstructorDeclaration cd = (ConstructorDeclaration) child.get();\n\t\t\tif ((cd.bits & IsCanonicalConstructor) != 0 && (cd.bits & IsImplicit) == 0) return child;\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\t\n\tprivate void handle0(Annotation ast, EclipseNode annotationNode, boolean force) {\n\t\thandleFlagUsage(annotationNode, ConfigurationKeys.NON_NULL_FLAG_USAGE, \"@NonNull\");\n\t\t\n\t\tif (annotationNode.up().getKind() == Kind.FIELD) {\n\t\t\t// This is meaningless unless the field is used to generate a method (@Setter, @RequiredArgsConstructor, etc),\n\t\t\t// but in that case those handlers will take care of it. However, we DO check if the annotation is applied to\n\t\t\t// a primitive, because those handlers trigger on any annotation named @NonNull and we only want the warning\n\t\t\t// behaviour on _OUR_ 'lombok.NonNull'.\n\t\t\tEclipseNode fieldNode = annotationNode.up();\n\t\t\tEclipseNode typeNode = fieldNode.up();\n\t\t\t\n\t\t\ttry {\n\t\t\t\tif (isPrimitive(((AbstractVariableDeclaration) annotationNode.up().get()).type)) {\n\t\t\t\t\tannotationNode.addWarning(\"@NonNull is meaningless on a primitive.\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} catch (Exception ignore) {}\n\t\t\t\n\t\t\tif (isRecord(typeNode)) {\n\t\t\t\t// well, these kinda double as parameters (of the compact constructor), so we do some work here.\n\t\t\t\t// NB:Tthe diet parse run already added an explicit compact constructor if we need to take any actions.\n\t\t\t\tEclipseNode compactConstructor = findCompactConstructor(typeNode);\n\t\t\t\t\n\t\t\t\tif (compactConstructor != null) {\n\t\t\t\t\taddNullCheckIfNeeded((AbstractMethodDeclaration) compactConstructor.get(), (AbstractVariableDeclaration) fieldNode.get(), annotationNode);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tArgument param;\n\t\tEclipseNode paramNode;\n\t\tAbstractMethodDeclaration declaration;\n\t\t\n\t\tswitch (annotationNode.up().getKind()) {\n\t\tcase ARGUMENT:\n\t\t\tparamNode = annotationNode.up();\n\t\t\tbreak;\n\t\tcase TYPE_USE:\n\t\t\tEclipseNode typeNode = annotationNode.directUp();\n\t\t\tboolean ok = false;\n\t\t\tASTNode astNode = typeNode.get();\n\t\t\tif (astNode instanceof TypeReference) {\n\t\t\t\tAnnotation[] anns = EclipseAST.getTopLevelTypeReferenceAnnotations((TypeReference) astNode);\n\t\t\t\tif (anns == null) return;\n\t\t\t\tfor (Annotation ann : anns) if (ast == ann) ok = true;\n\t\t\t}\n\t\t\tif (!ok) return;\n\t\t\tparamNode = typeNode.directUp();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t\t}\n\t\t\n\t\ttry {\n\t\t\tparam = (Argument) paramNode.get();\n\t\t\tdeclaration = (AbstractMethodDeclaration) paramNode.up().get();\n\t\t} catch (Exception e) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (!force && isGenerated(declaration)) return;\n\t\t\n\t\tif (declaration.isAbstract()) {\n\t\t\t// This used to be a warning, but as @NonNull also has a documentary purpose, better to not warn about this. Since 1.16.7\n\t\t\treturn;\n\t\t}\n\t\t\n\t\taddNullCheckIfNeeded(declaration, param, annotationNode);\n\t\tparamNode.up().rebuild();\n\t}\n\t\n\tprivate void addNullCheckIfNeeded(AbstractMethodDeclaration declaration, AbstractVariableDeclaration param, EclipseNode annotationNode) {\n\t\t// Possibly, if 'declaration instanceof ConstructorDeclaration', fetch declaration.constructorCall, search it for any references to our parameter,\n\t\t// and if they exist, create a new method in the class: 'private static <T> T lombok$nullCheck(T expr, String msg) {if (expr == null) throw NPE; return expr;}' and\n\t\t// wrap all references to it in the super/this to a call to this method.\n\t\t\n\t\tStatement nullCheck = generateNullCheck(param, annotationNode, null);\n\t\t\n\t\tif (nullCheck == null) {\n\t\t\t// @NonNull applied to a primitive. Kinda pointless. Let's generate a warning.\n\t\t\tannotationNode.addWarning(\"@NonNull is meaningless on a primitive.\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (declaration.statements == null) {\n\t\t\tdeclaration.statements = new Statement[] {nullCheck};\n\t\t} else {\n\t\t\tchar[] expectedName = param.name;\n\t\t\t/* Abort if the null check is already there, delving into try and synchronized statements */ {\n\t\t\t\tStatement[] stats = declaration.statements;\n\t\t\t\tint idx = 0;\n\t\t\t\twhile (stats != null && stats.length > idx) {\n\t\t\t\t\tStatement stat = stats[idx++];\n\t\t\t\t\tif (stat instanceof TryStatement) {\n\t\t\t\t\t\tstats = ((TryStatement) stat).tryBlock.statements;\n\t\t\t\t\t\tidx = 0;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (stat instanceof SynchronizedStatement) {\n\t\t\t\t\t\tstats = ((SynchronizedStatement) stat).block.statements;\n\t\t\t\t\t\tidx = 0;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tchar[] varNameOfNullCheck = returnVarNameIfNullCheck(stat);\n\t\t\t\t\tif (varNameOfNullCheck == null) break;\n\t\t\t\t\tif (Arrays.equals(varNameOfNullCheck, expectedName)) return;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tStatement[] newStatements = new Statement[declaration.statements.length + 1];\n\t\t\tint skipOver = 0;\n\t\t\tfor (Statement stat : declaration.statements) {\n\t\t\t\tif (isGenerated(stat) && isNullCheck(stat)) skipOver++;\n\t\t\t\telse break;\n\t\t\t}\n\t\t\tSystem.arraycopy(declaration.statements, 0, newStatements, 0, skipOver);\n\t\t\tSystem.arraycopy(declaration.statements, skipOver, newStatements, skipOver + 1, declaration.statements.length - skipOver);\n\t\t\tnewStatements[skipOver] = nullCheck;\n\t\t\tdeclaration.statements = newStatements;\n\t\t}\n\t}\n\t\n\tpublic boolean isNullCheck(Statement stat) {\n\t\treturn returnVarNameIfNullCheck(stat) != null;\n\t}\n\t\n\tpublic char[] returnVarNameIfNullCheck(Statement stat) {\n\t\tboolean isIf = stat instanceof IfStatement;\n\t\tboolean isExpression = stat instanceof Expression;\n\t\tif (!isIf && !(stat instanceof AssertStatement) && !isExpression) return null;\n\t\t\n\t\tif (isExpression) {\n\t\t\t/* Check if the statements contains a call to checkNotNull or requireNonNull */\n\t\t\tExpression expression = (Expression) stat;\n\t\t\tif (expression instanceof Assignment) expression = ((Assignment) expression).expression;\n\t\t\tif (!(expression instanceof MessageSend)) return null;\n\t\t\t\n\t\t\tMessageSend invocation = (MessageSend) expression;\n\t\t\tif (!Arrays.equals(invocation.selector, CHECK_NOT_NULL) && !Arrays.equals(invocation.selector, REQUIRE_NON_NULL)) return null;\n\t\t\tif (invocation.arguments == null || invocation.arguments.length == 0) return null;\n\t\t\tExpression firstArgument = invocation.arguments[0];\n\t\t\tif (!(firstArgument instanceof SingleNameReference)) return null;\n\t\t\treturn ((SingleNameReference) firstArgument).token;\n\t\t}\n\t\t\n\t\tif (isIf) {\n\t\t\t/* Check that the if's statement is a throw statement, possibly in a block. */\n\t\t\tStatement then = ((IfStatement) stat).thenStatement;\n\t\t\tif (then instanceof Block) {\n\t\t\t\tStatement[] blockStatements = ((Block) then).statements;\n\t\t\t\tif (blockStatements == null || blockStatements.length == 0) return null;\n\t\t\t\tthen = blockStatements[0];\n\t\t\t}\n\t\t\t\n\t\t\tif (!(then instanceof ThrowStatement)) return null;\n\t\t}\n\t\t\n\t\t/* Check that the if's conditional is like 'x == null'. Return from this method (don't generate\n\t\t   a nullcheck) if 'x' is equal to our own variable's name: There's already a nullcheck here. */ {\n\t\t\tExpression cond = isIf ? ((IfStatement) stat).condition : ((AssertStatement) stat).assertExpression;\n\t\t\tif (!(cond instanceof EqualExpression)) return null;\n\t\t\tEqualExpression bin = (EqualExpression) cond;\n\t\t\tString op = bin.operatorToString();\n\t\t\tif (isIf) {\n\t\t\t\tif (!\"==\".equals(op)) return null;\n\t\t\t} else {\n\t\t\t\tif (!\"!=\".equals(op)) return null;\n\t\t\t}\n\t\t\tif (!(bin.left instanceof SingleNameReference)) return null;\n\t\t\tif (!(bin.right instanceof NullLiteral)) return null;\n\t\t\treturn ((SingleNameReference) bin.left).token;\n\t\t}\n\t}\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2013-2021 The Project Lombok Authors.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage lombok.eclipse.handlers;\n\nimport static lombok.core.handlers.HandlerUtil.handleFlagUsage;\nimport static lombok.eclipse.Eclipse.*;\nimport static lombok.eclipse.handlers.EclipseHandlerUtil.*;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.eclipse.jdt.internal.compiler.ast.ASTNode;\nimport org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.AbstractVariableDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.Annotation;\nimport org.eclipse.jdt.internal.compiler.ast.Argument;\nimport org.eclipse.jdt.internal.compiler.ast.AssertStatement;\nimport org.eclipse.jdt.internal.compiler.ast.Assignment;\nimport org.eclipse.jdt.internal.compiler.ast.Block;\nimport org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.EqualExpression;\nimport org.eclipse.jdt.internal.compiler.ast.ExplicitConstructorCall;\nimport org.eclipse.jdt.internal.compiler.ast.Expression;\nimport org.eclipse.jdt.internal.compiler.ast.FieldDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.FieldReference;\nimport org.eclipse.jdt.internal.compiler.ast.IfStatement;\nimport org.eclipse.jdt.internal.compiler.ast.MessageSend;\nimport org.eclipse.jdt.internal.compiler.ast.NullLiteral;\nimport org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference;\nimport org.eclipse.jdt.internal.compiler.ast.SingleNameReference;\nimport org.eclipse.jdt.internal.compiler.ast.SingleTypeReference;\nimport org.eclipse.jdt.internal.compiler.ast.Statement;\nimport org.eclipse.jdt.internal.compiler.ast.SynchronizedStatement;\nimport org.eclipse.jdt.internal.compiler.ast.ThisReference;\nimport org.eclipse.jdt.internal.compiler.ast.ThrowStatement;\nimport org.eclipse.jdt.internal.compiler.ast.TryStatement;\nimport org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.TypeReference;\nimport org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;\n\nimport lombok.ConfigurationKeys;\nimport lombok.NonNull;\nimport lombok.core.AST.Kind;\nimport lombok.core.AnnotationValues;\nimport lombok.core.HandlerPriority;\nimport lombok.eclipse.EcjAugments;\nimport lombok.eclipse.EclipseAnnotationHandler;\nimport lombok.eclipse.EclipseNode;\nimport lombok.spi.Provides;\n\n@Provides\n@HandlerPriority(value = 512) // 2^9; onParameter=@__(@NonNull) has to run first.\npublic class HandleNonNull extends EclipseAnnotationHandler<NonNull> {\n\tprivate static final char[] REQUIRE_NON_NULL = \"requireNonNull\".toCharArray();\n\tprivate static final char[] CHECK_NOT_NULL = \"checkNotNull\".toCharArray();\n\t\n\tpublic static final HandleNonNull INSTANCE = new HandleNonNull();\n\t\n\tpublic void fix(EclipseNode method) {\n\t\tfor (EclipseNode m : method.down()) {\n\t\t\tif (m.getKind() != Kind.ARGUMENT) continue;\n\t\t\tfor (EclipseNode c : m.down()) {\n\t\t\t\tif (c.getKind() == Kind.ANNOTATION) {\n\t\t\t\t\tif (annotationTypeMatches(NonNull.class, c)) {\n\t\t\t\t\t\thandle0((Annotation) c.get(), c, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate List<FieldDeclaration> getRecordComponents(EclipseNode typeNode) {\n\t\tList<FieldDeclaration> list = new ArrayList<FieldDeclaration>();\n\t\t\n\t\tfor (EclipseNode child : typeNode.down()) {\n\t\t\tif (child.getKind() == Kind.FIELD) {\n\t\t\t\tFieldDeclaration fd = (FieldDeclaration) child.get();\n\t\t\t\tif ((fd.modifiers & AccRecord) != 0) list.add(fd);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn list;\n\t}\n\t\n\tprivate EclipseNode addCompactConstructorIfNeeded(EclipseNode typeNode, EclipseNode annotationNode) {\n\t\t// explicit Compact Constructor has bits set: Bit32, IsCanonicalConstructor (10).\n\t\t// implicit Compact Constructor has bits set: Bit32, IsCanonicalConstructor (10), and IsImplicit (11).\n\t\t// explicit constructor with long-form shows up as a normal constructor (Bit32 set, that's all), but the\n\t\t//   implicit CC is then also present and will presumably be stripped out in some later phase.\n\t\t\n\t\tEclipseNode toRemove = null;\n\t\tEclipseNode existingCompactConstructor = null;\n\t\tList<FieldDeclaration> recordComponents = null;\n\t\tfor (EclipseNode child : typeNode.down()) {\n\t\t\tif (!(child.get() instanceof ConstructorDeclaration)) continue;\n\t\t\tConstructorDeclaration cd = (ConstructorDeclaration) child.get();\n\t\t\tif ((cd.bits & IsCanonicalConstructor) != 0) {\n\t\t\t\tif ((cd.bits & IsImplicit) != 0) {\n\t\t\t\t\ttoRemove = child;\n\t\t\t\t} else {\n\t\t\t\t\texistingCompactConstructor = child;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// If this constructor has exact matching types vs. the record components,\n\t\t\t\t// this is the canonical constructor in long form and we should not generate one.\n\t\t\t\t\n\t\t\t\tif (recordComponents == null) recordComponents = getRecordComponents(typeNode);\n\t\t\t\tint argLength = cd.arguments == null ? 0 : cd.arguments.length;\n\t\t\t\tint compLength = recordComponents.size();\n\t\t\t\tboolean isCanonical = argLength == compLength;\n\t\t\t\tif (isCanonical) top: for (int i = 0; i < argLength; i++) {\n\t\t\t\t\tTypeReference a = recordComponents.get(i).type;\n\t\t\t\t\tTypeReference b = cd.arguments[i] == null ? null : cd.arguments[i].type;\n\t\t\t\t\t// technically this won't match e.g. `java.lang.String` to just `String`;\n\t\t\t\t\t// to use this feature you'll need to use the same way to write it, which seems\n\t\t\t\t\t// like a fair requirement.\n\t\t\t\t\tchar[][] ta = getRawTypeName(a);\n\t\t\t\t\tchar[][] tb = getRawTypeName(b);\n\t\t\t\t\tif (ta == null || tb == null || ta.length != tb.length) {\n\t\t\t\t\t\tisCanonical = false;\n\t\t\t\t\t\tbreak top;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int j = 0; j < ta.length; j++) {\n\t\t\t\t\t\tif (!Arrays.equals(ta[j], tb[j])) {\n\t\t\t\t\t\t\tisCanonical = false;\n\t\t\t\t\t\t\tbreak top;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (isCanonical) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (existingCompactConstructor != null) return existingCompactConstructor;\n\t\tint posToInsert = -1;\n\t\tTypeDeclaration td = (TypeDeclaration) typeNode.get();\n\t\tif (toRemove != null) {\n\t\t\tint idxToRemove = -1;\n\t\t\tfor (int i = 0; i < td.methods.length; i++) {\n\t\t\t\tif (td.methods[i] == toRemove.get()) idxToRemove = i;\n\t\t\t}\n\t\t\tif (idxToRemove != -1) {\n\t\t\t\tSystem.arraycopy(td.methods, idxToRemove + 1, td.methods, idxToRemove, td.methods.length - idxToRemove - 1);\n\t\t\t\tposToInsert = td.methods.length - 1;\n\t\t\t\ttypeNode.removeChild(toRemove);\n\t\t\t}\n\t\t}\n\t\tif (posToInsert == -1) {\n\t\t\tAbstractMethodDeclaration[] na = new AbstractMethodDeclaration[td.methods.length + 1];\n\t\t\tposToInsert = td.methods.length;\n\t\t\tSystem.arraycopy(td.methods, 0, na, 0, posToInsert);\n\t\t\ttd.methods = na;\n\t\t}\n\t\t\n\t\tConstructorDeclaration cd = new ConstructorDeclaration(((CompilationUnitDeclaration) typeNode.top().get()).compilationResult);\n\t\tcd.modifiers = ClassFileConstants.AccPublic;\n\t\tcd.bits = ASTNode.Bit32 | ECLIPSE_DO_NOT_TOUCH_FLAG | IsCanonicalConstructor;\n\t\tcd.selector = td.name;\n\t\tcd.constructorCall = new ExplicitConstructorCall(ExplicitConstructorCall.ImplicitSuper);\n\t\tif (recordComponents == null) recordComponents = getRecordComponents(typeNode);\n\t\tcd.arguments = new Argument[recordComponents.size()];\n\t\tcd.statements = new Statement[recordComponents.size()];\n\t\tcd.bits = IsCanonicalConstructor;\n\t\t\n\t\tfor (int i = 0; i < cd.arguments.length; i++) {\n\t\t\tFieldDeclaration cmp = recordComponents.get(i);\n\t\t\tcd.arguments[i] = new Argument(cmp.name, cmp.sourceStart, cmp.type, 0);\n\t\t\tcd.arguments[i].bits = ASTNode.IsArgument | ASTNode.IgnoreRawTypeCheck | ASTNode.IsReachable;\n\t\t\tFieldReference lhs = new FieldReference(cmp.name, 0);\n\t\t\tlhs.receiver = new ThisReference(0, 0);\n\t\t\tSingleNameReference rhs = new SingleNameReference(cmp.name, 0);\n\t\t\tcd.statements[i] = new Assignment(lhs, rhs, cmp.sourceEnd);\n\t\t}\n\t\t\n\t\tsetGeneratedBy(cd, annotationNode.get());\n\t\tfor (int i = 0; i < cd.arguments.length; i++) {\n\t\t\tFieldDeclaration cmp = recordComponents.get(i);\n\t\t\tcd.arguments[i].sourceStart = cmp.sourceStart;\n\t\t\tcd.arguments[i].sourceEnd = cmp.sourceStart;\n\t\t\tcd.arguments[i].declarationSourceEnd = cmp.sourceStart;\n\t\t\tcd.arguments[i].declarationEnd = cmp.sourceStart;\n\t\t}\n\t\t\n\t\ttd.methods[posToInsert] = cd;\n\t\tcd.annotations = addSuppressWarningsAll(typeNode, cd, cd.annotations);\n\t\tcd.annotations = addGenerated(typeNode, cd, cd.annotations);\n\t\treturn typeNode.add(cd, Kind.METHOD);\n\t}\n\t\n\tprivate static char[][] getRawTypeName(TypeReference a) {\n\t\tif (a instanceof QualifiedTypeReference) return ((QualifiedTypeReference) a).tokens;\n\t\tif (a instanceof SingleTypeReference) return new char[][] {((SingleTypeReference) a).token};\n\t\treturn null;\n\t}\n\t\n\t@Override public void handle(AnnotationValues<NonNull> annotation, Annotation ast, EclipseNode annotationNode) {\n\t\t// Generating new methods is only possible during diet parse but modifying existing methods requires a full parse.\n\t\t// As we need both for @NonNull we reset the handled flag during diet parse.\n\t\t\n\t\tif (!annotationNode.isCompleteParse()) {\n\t\t\tfinal EclipseNode node;\n\t\t\tif (annotationNode.up().getKind() == Kind.TYPE_USE) {\n\t\t\t\tnode = annotationNode.directUp().directUp();\n\t\t\t} else {\n\t\t\t\tnode = annotationNode.up();\n\t\t\t}\n\t\t\t\n\t\t\tif (node.getKind() == Kind.FIELD) {\n\t\t\t\t//Check if this is a record and we need to generate the compact form constructor.\n\t\t\t\tEclipseNode typeNode = node.up();\n\t\t\t\tif (typeNode.getKind() == Kind.TYPE) {\n\t\t\t\t\tif (isRecord(typeNode)) {\n\t\t\t\t\t\taddCompactConstructorIfNeeded(typeNode, annotationNode);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tEcjAugments.ASTNode_handled.clear(ast);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\thandle0(ast, annotationNode, false);\n\t}\n\t\n\tprivate EclipseNode findCompactConstructor(EclipseNode typeNode) {\n\t\tfor (EclipseNode child : typeNode.down()) {\n\t\t\tif (!(child.get() instanceof ConstructorDeclaration)) continue;\n\t\t\tConstructorDeclaration cd = (ConstructorDeclaration) child.get();\n\t\t\tif ((cd.bits & IsCanonicalConstructor) != 0 && (cd.bits & IsImplicit) == 0) return child;\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\t\n\tprivate void handle0(Annotation ast, EclipseNode annotationNode, boolean force) {\n\t\thandleFlagUsage(annotationNode, ConfigurationKeys.NON_NULL_FLAG_USAGE, \"@NonNull\");\n\t\t\n\t\tfinal EclipseNode node;\n\t\tif (annotationNode.up().getKind() == Kind.TYPE_USE) {\n\t\t\tnode = annotationNode.directUp().directUp();\n\t\t} else {\n\t\t\tnode = annotationNode.up();\n\t\t}\n\t\t\n\t\tif (node.getKind() == Kind.FIELD) {\n\t\t\t// This is meaningless unless the field is used to generate a method (@Setter, @RequiredArgsConstructor, etc),\n\t\t\t// but in that case those handlers will take care of it. However, we DO check if the annotation is applied to\n\t\t\t// a primitive, because those handlers trigger on any annotation named @NonNull and we only want the warning\n\t\t\t// behaviour on _OUR_ 'lombok.NonNull'.\n\t\t\tEclipseNode fieldNode = node;\n\t\t\tEclipseNode typeNode = fieldNode.up();\n\t\t\t\n\t\t\ttry {\n\t\t\t\tif (isPrimitive(((AbstractVariableDeclaration) node.get()).type)) {\n\t\t\t\t\tannotationNode.addWarning(\"@NonNull is meaningless on a primitive.\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} catch (Exception ignore) {}\n\t\t\t\n\t\t\tif (isRecord(typeNode)) {\n\t\t\t\t// well, these kinda double as parameters (of the compact constructor), so we do some work here.\n\t\t\t\t// NB:Tthe diet parse run already added an explicit compact constructor if we need to take any actions.\n\t\t\t\tEclipseNode compactConstructor = findCompactConstructor(typeNode);\n\t\t\t\t\n\t\t\t\tif (compactConstructor != null) {\n\t\t\t\t\taddNullCheckIfNeeded((AbstractMethodDeclaration) compactConstructor.get(), (AbstractVariableDeclaration) fieldNode.get(), annotationNode);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (node.getKind() != Kind.ARGUMENT) return;\n\t\t\n\t\tArgument param;\n\t\tAbstractMethodDeclaration declaration;\n\t\t\n\t\ttry {\n\t\t\tparam = (Argument) node.get();\n\t\t\tdeclaration = (AbstractMethodDeclaration) node.up().get();\n\t\t} catch (Exception e) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (!force && isGenerated(declaration)) return;\n\t\t\n\t\tif (declaration.isAbstract()) {\n\t\t\t// This used to be a warning, but as @NonNull also has a documentary purpose, better to not warn about this. Since 1.16.7\n\t\t\treturn;\n\t\t}\n\t\t\n\t\taddNullCheckIfNeeded(declaration, param, annotationNode);\n\t\tnode.up().rebuild();\n\t}\n\t\n\tprivate void addNullCheckIfNeeded(AbstractMethodDeclaration declaration, AbstractVariableDeclaration param, EclipseNode annotationNode) {\n\t\t// Possibly, if 'declaration instanceof ConstructorDeclaration', fetch declaration.constructorCall, search it for any references to our parameter,\n\t\t// and if they exist, create a new method in the class: 'private static <T> T lombok$nullCheck(T expr, String msg) {if (expr == null) throw NPE; return expr;}' and\n\t\t// wrap all references to it in the super/this to a call to this method.\n\t\t\n\t\tStatement nullCheck = generateNullCheck(param, annotationNode, null);\n\t\t\n\t\tif (nullCheck == null) {\n\t\t\t// @NonNull applied to a primitive. Kinda pointless. Let's generate a warning.\n\t\t\tannotationNode.addWarning(\"@NonNull is meaningless on a primitive.\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (declaration.statements == null) {\n\t\t\tdeclaration.statements = new Statement[] {nullCheck};\n\t\t} else {\n\t\t\tchar[] expectedName = param.name;\n\t\t\t/* Abort if the null check is already there, delving into try and synchronized statements */ {\n\t\t\t\tStatement[] stats = declaration.statements;\n\t\t\t\tint idx = 0;\n\t\t\t\twhile (stats != null && stats.length > idx) {\n\t\t\t\t\tStatement stat = stats[idx++];\n\t\t\t\t\tif (stat instanceof TryStatement) {\n\t\t\t\t\t\tstats = ((TryStatement) stat).tryBlock.statements;\n\t\t\t\t\t\tidx = 0;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (stat instanceof SynchronizedStatement) {\n\t\t\t\t\t\tstats = ((SynchronizedStatement) stat).block.statements;\n\t\t\t\t\t\tidx = 0;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tchar[] varNameOfNullCheck = returnVarNameIfNullCheck(stat);\n\t\t\t\t\tif (varNameOfNullCheck == null) break;\n\t\t\t\t\tif (Arrays.equals(varNameOfNullCheck, expectedName)) return;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tStatement[] newStatements = new Statement[declaration.statements.length + 1];\n\t\t\tint skipOver = 0;\n\t\t\tfor (Statement stat : declaration.statements) {\n\t\t\t\tif (isGenerated(stat) && isNullCheck(stat)) skipOver++;\n\t\t\t\telse break;\n\t\t\t}\n\t\t\tSystem.arraycopy(declaration.statements, 0, newStatements, 0, skipOver);\n\t\t\tSystem.arraycopy(declaration.statements, skipOver, newStatements, skipOver + 1, declaration.statements.length - skipOver);\n\t\t\tnewStatements[skipOver] = nullCheck;\n\t\t\tdeclaration.statements = newStatements;\n\t\t}\n\t}\n\t\n\tpublic boolean isNullCheck(Statement stat) {\n\t\treturn returnVarNameIfNullCheck(stat) != null;\n\t}\n\t\n\tpublic char[] returnVarNameIfNullCheck(Statement stat) {\n\t\tboolean isIf = stat instanceof IfStatement;\n\t\tboolean isExpression = stat instanceof Expression;\n\t\tif (!isIf && !(stat instanceof AssertStatement) && !isExpression) return null;\n\t\t\n\t\tif (isExpression) {\n\t\t\t/* Check if the statements contains a call to checkNotNull or requireNonNull */\n\t\t\tExpression expression = (Expression) stat;\n\t\t\tif (expression instanceof Assignment) expression = ((Assignment) expression).expression;\n\t\t\tif (!(expression instanceof MessageSend)) return null;\n\t\t\t\n\t\t\tMessageSend invocation = (MessageSend) expression;\n\t\t\tif (!Arrays.equals(invocation.selector, CHECK_NOT_NULL) && !Arrays.equals(invocation.selector, REQUIRE_NON_NULL)) return null;\n\t\t\tif (invocation.arguments == null || invocation.arguments.length == 0) return null;\n\t\t\tExpression firstArgument = invocation.arguments[0];\n\t\t\tif (!(firstArgument instanceof SingleNameReference)) return null;\n\t\t\treturn ((SingleNameReference) firstArgument).token;\n\t\t}\n\t\t\n\t\tif (isIf) {\n\t\t\t/* Check that the if's statement is a throw statement, possibly in a block. */\n\t\t\tStatement then = ((IfStatement) stat).thenStatement;\n\t\t\tif (then instanceof Block) {\n\t\t\t\tStatement[] blockStatements = ((Block) then).statements;\n\t\t\t\tif (blockStatements == null || blockStatements.length == 0) return null;\n\t\t\t\tthen = blockStatements[0];\n\t\t\t}\n\t\t\t\n\t\t\tif (!(then instanceof ThrowStatement)) return null;\n\t\t}\n\t\t\n\t\t/* Check that the if's conditional is like 'x == null'. Return from this method (don't generate\n\t\t   a nullcheck) if 'x' is equal to our own variable's name: There's already a nullcheck here. */ {\n\t\t\tExpression cond = isIf ? ((IfStatement) stat).condition : ((AssertStatement) stat).assertExpression;\n\t\t\tif (!(cond instanceof EqualExpression)) return null;\n\t\t\tEqualExpression bin = (EqualExpression) cond;\n\t\t\tString op = bin.operatorToString();\n\t\t\tif (isIf) {\n\t\t\t\tif (!\"==\".equals(op)) return null;\n\t\t\t} else {\n\t\t\t\tif (!\"!=\".equals(op)) return null;\n\t\t\t}\n\t\t\tif (!(bin.left instanceof SingleNameReference)) return null;\n\t\t\tif (!(bin.right instanceof NullLiteral)) return null;\n\t\t\treturn ((SingleNameReference) bin.left).token;\n\t\t}\n\t}\n}\n","lineNo":223}
{"Smelly Sample":"/*\n * Copyright (C) 2009-2019 The Project Lombok Authors.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage lombok.javac;\n\nimport java.util.List;\nimport java.util.SortedSet;\n\nimport javax.annotation.processing.Messager;\n\nimport com.sun.source.util.Trees;\nimport com.sun.tools.javac.tree.JCTree;\nimport com.sun.tools.javac.tree.JCTree.JCAnnotation;\nimport com.sun.tools.javac.tree.JCTree.JCClassDecl;\nimport com.sun.tools.javac.tree.JCTree.JCCompilationUnit;\nimport com.sun.tools.javac.tree.JCTree.JCMethodDecl;\nimport com.sun.tools.javac.tree.JCTree.JCVariableDecl;\nimport com.sun.tools.javac.util.Context;\n\nimport lombok.ConfigurationKeys;\nimport lombok.core.CleanupRegistry;\nimport lombok.core.LombokConfiguration;\n\npublic class JavacTransformer {\n\tprivate final HandlerLibrary handlers;\n\tprivate final Messager messager;\n\t\n\tpublic JavacTransformer(Messager messager, Trees trees) {\n\t\tthis.messager = messager;\n\t\tthis.handlers = HandlerLibrary.load(messager, trees);\n\t}\n\t\n\tpublic SortedSet<Long> getPriorities() {\n\t\treturn handlers.getPriorities();\n\t}\n\t\n\tpublic SortedSet<Long> getPrioritiesRequiringResolutionReset() {\n\t\treturn handlers.getPrioritiesRequiringResolutionReset();\n\t}\n\t\n\tpublic void transform(long priority, Context context, List<JCCompilationUnit> compilationUnits, CleanupRegistry cleanup) {\n\t\tfor (JCCompilationUnit unit : compilationUnits) {\n\t\t\tif (!Boolean.TRUE.equals(LombokConfiguration.read(ConfigurationKeys.LOMBOK_DISABLE, JavacAST.getAbsoluteFileLocation(unit)))) {\n\t\t\t\tJavacAST ast = new JavacAST(messager, context, unit, cleanup);\n\t\t\t\tast.traverse(new AnnotationVisitor(priority));\n\t\t\t\thandlers.callASTVisitors(ast, priority);\n\t\t\t\tif (ast.isChanged()) LombokOptions.markChanged(context, (JCCompilationUnit) ast.top().get());\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate class AnnotationVisitor extends JavacASTAdapter {\n\t\tprivate final long priority;\n\t\t\n\t\tAnnotationVisitor(long priority) {\n\t\t\tthis.priority = priority;\n\t\t}\n\t\t\n\t\t@Override public void visitAnnotationOnType(JCClassDecl type, JavacNode annotationNode, JCAnnotation annotation) {\n\t\t\tJCCompilationUnit top = (JCCompilationUnit) annotationNode.top().get();\n\t\t\thandlers.handleAnnotation(top, annotationNode, annotation, priority);\n\t\t}\n\t\t\n\t\t@Override public void visitAnnotationOnField(JCVariableDecl field, JavacNode annotationNode, JCAnnotation annotation) {\n\t\t\tJCCompilationUnit top = (JCCompilationUnit) annotationNode.top().get();\n\t\t\thandlers.handleAnnotation(top, annotationNode, annotation, priority);\n\t\t}\n\t\t\n\t\t@Override public void visitAnnotationOnMethod(JCMethodDecl method, JavacNode annotationNode, JCAnnotation annotation) {\n\t\t\tJCCompilationUnit top = (JCCompilationUnit) annotationNode.top().get();\n\t\t\thandlers.handleAnnotation(top, annotationNode, annotation, priority);\n\t\t}\n\t\t\n\t\t@Override public void visitAnnotationOnMethodArgument(JCVariableDecl argument, JCMethodDecl method, JavacNode annotationNode, JCAnnotation annotation) {\n\t\t\tJCCompilationUnit top = (JCCompilationUnit) annotationNode.top().get();\n\t\t\thandlers.handleAnnotation(top, annotationNode, annotation, priority);\n\t\t}\n\t\t\n\t\t@Override public void visitAnnotationOnLocal(JCVariableDecl local, JavacNode annotationNode, JCAnnotation annotation) {\n\t\t\tJCCompilationUnit top = (JCCompilationUnit) annotationNode.top().get();\n\t\t\thandlers.handleAnnotation(top, annotationNode, annotation, priority);\n\t\t}\n\t\t\n\t\t@Override public void visitAnnotationOnTypeUse(JCTree typeUse, JavacNode annotationNode, JCAnnotation annotation) {\n\t\t\tJCCompilationUnit top = (JCCompilationUnit) annotationNode.top().get();\n\t\t\thandlers.handleAnnotation(top, annotationNode, annotation, priority);\n\t\t}\n\t}\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2009-2019 The Project Lombok Authors.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage lombok.javac;\n\nimport java.util.List;\nimport java.util.SortedSet;\n\nimport javax.annotation.processing.Messager;\n\nimport com.sun.source.util.Trees;\nimport com.sun.tools.javac.tree.JCTree;\nimport com.sun.tools.javac.tree.JCTree.JCAnnotation;\nimport com.sun.tools.javac.tree.JCTree.JCClassDecl;\nimport com.sun.tools.javac.tree.JCTree.JCCompilationUnit;\nimport com.sun.tools.javac.tree.JCTree.JCMethodDecl;\nimport com.sun.tools.javac.tree.JCTree.JCVariableDecl;\nimport com.sun.tools.javac.util.Context;\n\nimport lombok.ConfigurationKeys;\nimport lombok.core.CleanupRegistry;\nimport lombok.core.LombokConfiguration;\n\npublic class JavacTransformer {\n\tprivate final HandlerLibrary handlers;\n\tprivate final Messager messager;\n\t\n\tpublic JavacTransformer(Messager messager, Trees trees) {\n\t\tthis.messager = messager;\n\t\tthis.handlers = HandlerLibrary.load(messager, trees);\n\t}\n\t\n\tpublic SortedSet<Long> getPriorities() {\n\t\treturn handlers.getPriorities();\n\t}\n\t\n\tpublic SortedSet<Long> getPrioritiesRequiringResolutionReset() {\n\t\treturn handlers.getPrioritiesRequiringResolutionReset();\n\t}\n\t\n\tpublic void transform(long priority, Context context, List<JCCompilationUnit> compilationUnits, CleanupRegistry cleanup) {\n\t\tif (compilationUnits.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\t\tJavacAST.ErrorLog errorLog = JavacAST.ErrorLog.create(messager, context);\n\t\tfor (JCCompilationUnit unit : compilationUnits) {\n\t\t\tif (!Boolean.TRUE.equals(LombokConfiguration.read(ConfigurationKeys.LOMBOK_DISABLE, JavacAST.getAbsoluteFileLocation(unit)))) {\n\t\t\t\tJavacAST ast = new JavacAST(errorLog, context, unit, cleanup);\n\t\t\t\tast.traverse(new AnnotationVisitor(priority));\n\t\t\t\thandlers.callASTVisitors(ast, priority);\n\t\t\t\tif (ast.isChanged()) LombokOptions.markChanged(context, (JCCompilationUnit) ast.top().get());\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate class AnnotationVisitor extends JavacASTAdapter {\n\t\tprivate final long priority;\n\t\t\n\t\tAnnotationVisitor(long priority) {\n\t\t\tthis.priority = priority;\n\t\t}\n\t\t\n\t\t@Override public void visitAnnotationOnType(JCClassDecl type, JavacNode annotationNode, JCAnnotation annotation) {\n\t\t\tJCCompilationUnit top = (JCCompilationUnit) annotationNode.top().get();\n\t\t\thandlers.handleAnnotation(top, annotationNode, annotation, priority);\n\t\t}\n\t\t\n\t\t@Override public void visitAnnotationOnField(JCVariableDecl field, JavacNode annotationNode, JCAnnotation annotation) {\n\t\t\tJCCompilationUnit top = (JCCompilationUnit) annotationNode.top().get();\n\t\t\thandlers.handleAnnotation(top, annotationNode, annotation, priority);\n\t\t}\n\t\t\n\t\t@Override public void visitAnnotationOnMethod(JCMethodDecl method, JavacNode annotationNode, JCAnnotation annotation) {\n\t\t\tJCCompilationUnit top = (JCCompilationUnit) annotationNode.top().get();\n\t\t\thandlers.handleAnnotation(top, annotationNode, annotation, priority);\n\t\t}\n\t\t\n\t\t@Override public void visitAnnotationOnMethodArgument(JCVariableDecl argument, JCMethodDecl method, JavacNode annotationNode, JCAnnotation annotation) {\n\t\t\tJCCompilationUnit top = (JCCompilationUnit) annotationNode.top().get();\n\t\t\thandlers.handleAnnotation(top, annotationNode, annotation, priority);\n\t\t}\n\t\t\n\t\t@Override public void visitAnnotationOnLocal(JCVariableDecl local, JavacNode annotationNode, JCAnnotation annotation) {\n\t\t\tJCCompilationUnit top = (JCCompilationUnit) annotationNode.top().get();\n\t\t\thandlers.handleAnnotation(top, annotationNode, annotation, priority);\n\t\t}\n\t\t\n\t\t@Override public void visitAnnotationOnTypeUse(JCTree typeUse, JavacNode annotationNode, JCAnnotation annotation) {\n\t\t\tJCCompilationUnit top = (JCCompilationUnit) annotationNode.top().get();\n\t\t\thandlers.handleAnnotation(top, annotationNode, annotation, priority);\n\t\t}\n\t}\n}\n","lineNo":63}
{"Smelly Sample":"/*\n * Copyright (C) 2009-2022 The Project Lombok Authors.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage lombok.javac.handlers;\n\nimport static com.sun.tools.javac.code.Flags.GENERATEDCONSTR;\nimport static lombok.core.handlers.HandlerUtil.*;\nimport static lombok.javac.Javac.*;\nimport static lombok.javac.JavacAugments.JCTree_generatedNode;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.regex.Pattern;\n\nimport com.sun.tools.javac.code.Attribute;\nimport com.sun.tools.javac.code.BoundKind;\nimport com.sun.tools.javac.code.Flags;\nimport com.sun.tools.javac.code.Scope;\nimport com.sun.tools.javac.code.Symbol;\nimport com.sun.tools.javac.code.Symbol.ClassSymbol;\nimport com.sun.tools.javac.code.Symbol.TypeSymbol;\nimport com.sun.tools.javac.code.Type;\nimport com.sun.tools.javac.comp.Annotate;\nimport com.sun.tools.javac.comp.AttrContext;\nimport com.sun.tools.javac.comp.Enter;\nimport com.sun.tools.javac.comp.Env;\nimport com.sun.tools.javac.comp.MemberEnter;\nimport com.sun.tools.javac.tree.JCTree;\nimport com.sun.tools.javac.tree.JCTree.JCAnnotation;\nimport com.sun.tools.javac.tree.JCTree.JCArrayTypeTree;\nimport com.sun.tools.javac.tree.JCTree.JCAssign;\nimport com.sun.tools.javac.tree.JCTree.JCBlock;\nimport com.sun.tools.javac.tree.JCTree.JCClassDecl;\nimport com.sun.tools.javac.tree.JCTree.JCCompilationUnit;\nimport com.sun.tools.javac.tree.JCTree.JCExpression;\nimport com.sun.tools.javac.tree.JCTree.JCExpressionStatement;\nimport com.sun.tools.javac.tree.JCTree.JCFieldAccess;\nimport com.sun.tools.javac.tree.JCTree.JCIdent;\nimport com.sun.tools.javac.tree.JCTree.JCImport;\nimport com.sun.tools.javac.tree.JCTree.JCLiteral;\nimport com.sun.tools.javac.tree.JCTree.JCMethodDecl;\nimport com.sun.tools.javac.tree.JCTree.JCMethodInvocation;\nimport com.sun.tools.javac.tree.JCTree.JCModifiers;\nimport com.sun.tools.javac.tree.JCTree.JCNewArray;\nimport com.sun.tools.javac.tree.JCTree.JCPrimitiveTypeTree;\nimport com.sun.tools.javac.tree.JCTree.JCStatement;\nimport com.sun.tools.javac.tree.JCTree.JCTypeApply;\nimport com.sun.tools.javac.tree.JCTree.JCTypeParameter;\nimport com.sun.tools.javac.tree.JCTree.JCVariableDecl;\nimport com.sun.tools.javac.tree.JCTree.JCWildcard;\nimport com.sun.tools.javac.tree.JCTree.TypeBoundKind;\nimport com.sun.tools.javac.tree.TreeMaker;\nimport com.sun.tools.javac.tree.TreeScanner;\nimport com.sun.tools.javac.util.Context;\nimport com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\nimport com.sun.tools.javac.util.List;\nimport com.sun.tools.javac.util.ListBuffer;\nimport com.sun.tools.javac.util.Name;\nimport com.sun.tools.javac.util.Options;\n\nimport lombok.AccessLevel;\nimport lombok.ConfigurationKeys;\nimport lombok.Data;\nimport lombok.Getter;\nimport lombok.core.AST.Kind;\nimport lombok.core.AnnotationValues;\nimport lombok.core.AnnotationValues.AnnotationValue;\nimport lombok.core.CleanupTask;\nimport lombok.core.LombokImmutableList;\nimport lombok.core.TypeResolver;\nimport lombok.core.configuration.CheckerFrameworkVersion;\nimport lombok.core.configuration.NullAnnotationLibrary;\nimport lombok.core.configuration.NullCheckExceptionType;\nimport lombok.core.configuration.TypeName;\nimport lombok.core.handlers.HandlerUtil;\nimport lombok.core.handlers.HandlerUtil.FieldAccess;\nimport lombok.delombok.LombokOptionsFactory;\nimport lombok.experimental.Accessors;\nimport lombok.experimental.Tolerate;\nimport lombok.javac.Javac;\nimport lombok.javac.JavacAugments;\nimport lombok.javac.JavacNode;\nimport lombok.javac.JavacTreeMaker;\nimport lombok.javac.JavacTreeMaker.TypeTag;\nimport lombok.permit.Permit;\n\n/**\n * Container for static utility methods useful to handlers written for javac.\n */\npublic class JavacHandlerUtil {\n\tprivate JavacHandlerUtil() {\n\t\t//Prevent instantiation\n\t}\n\t\n\tprivate static class MarkingScanner extends TreeScanner {\n\t\tprivate final JavacNode source;\n\t\t\n\t\tMarkingScanner(JavacNode source) {\n\t\t\tthis.source = source;\n\t\t}\n\t\t\n\t\t@Override public void scan(JCTree tree) {\n\t\t\tif (tree == null) return;\n\t\t\tsetGeneratedBy(tree, source);\n\t\t\tsuper.scan(tree);\n\t\t}\n\t}\n\t\n\t/**\n\t * Contributed by Jan Lahoda; many lombok transformations should not be run (or a lite version should be run) when the netbeans editor\n\t * is running javac on the open source file to find inline errors and such. As class files are compiled separately this does not affect\n\t * actual runtime behaviour or file output of the netbeans IDE.\n\t */\n\tpublic static boolean inNetbeansEditor(JavacNode node) {\n\t\treturn inNetbeansEditor(node.getContext());\n\t}\n\t\n\tpublic static boolean inNetbeansEditor(Context context) {\n\t\tOptions options = Options.instance(context);\n\t\treturn (options.keySet().contains(\"ide\") && !options.keySet().contains(\"backgroundCompilation\"));\n\t}\n\t\n\tpublic static boolean inNetbeansCompileOnSave(Context context) {\n\t\tOptions options = Options.instance(context);\n\t\treturn (options.keySet().contains(\"ide\") && options.keySet().contains(\"backgroundCompilation\"));\n\t}\n\t\n\tpublic static JCTree getGeneratedBy(JCTree node) {\n\t\treturn JCTree_generatedNode.get(node);\n\t}\n\t\n\tpublic static boolean isGenerated(JCTree node) {\n\t\treturn getGeneratedBy(node) != null;\n\t}\n\t\n\tpublic static <T extends JCTree> T recursiveSetGeneratedBy(T node, JavacNode source) {\n\t\tif (node == null) return null;\n\t\tsetGeneratedBy(node, source);\n\t\tnode.accept(new MarkingScanner(source));\n\t\treturn node;\n\t}\n\t\n\tpublic static <T extends JCTree> T setGeneratedBy(T node, JavacNode sourceNode) {\n\t\tif (node == null) return null;\n\t\tif (sourceNode == null) {\n\t\t\tJCTree_generatedNode.clear(node);\n\t\t\treturn node;\n\t\t}\n\t\tJCTree_generatedNode.set(node, sourceNode.get());\n\t\t\n\t\tif (!inNetbeansEditor(sourceNode.getContext()) || isParameter(node)) {\n\t\t\tnode.pos = sourceNode.getStartPos();\n\t\t\tstoreEnd(node, sourceNode.getEndPosition(), (JCCompilationUnit) sourceNode.top().get());\n\t\t}\n\t\treturn node;\n\t}\n\n\tpublic static boolean isParameter(JCTree node) {\n\t\treturn node instanceof JCVariableDecl && (((JCVariableDecl) node).mods.flags & Flags.PARAMETER) != 0;\n\t}\n\t\n\tpublic static boolean hasAnnotation(String type, JavacNode node) {\n\t\treturn hasAnnotation(type, node, false);\n\t}\n\t\n\tpublic static boolean hasAnnotation(Class<? extends Annotation> type, JavacNode node) {\n\t\treturn hasAnnotation(type, node, false);\n\t}\n\t\n\tpublic static boolean hasAnnotationAndDeleteIfNeccessary(Class<? extends Annotation> type, JavacNode node) {\n\t\treturn hasAnnotation(type, node, true);\n\t}\n\t\n\tprivate static boolean hasAnnotation(Class<? extends Annotation> type, JavacNode node, boolean delete) {\n\t\tif (node == null) return false;\n\t\tif (type == null) return false;\n\t\tswitch (node.getKind()) {\n\t\tcase ARGUMENT:\n\t\tcase FIELD:\n\t\tcase LOCAL:\n\t\tcase TYPE:\n\t\tcase METHOD:\n\t\t\tfor (JavacNode child : node.down()) {\n\t\t\t\tif (annotationTypeMatches(type, child)) {\n\t\t\t\t\tif (delete) deleteAnnotationIfNeccessary(child, type);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// intentional fallthrough\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tprivate static boolean hasAnnotation(String type, JavacNode node, boolean delete) {\n\t\tif (node == null) return false;\n\t\tif (type == null) return false;\n\t\tswitch (node.getKind()) {\n\t\tcase ARGUMENT:\n\t\tcase FIELD:\n\t\tcase LOCAL:\n\t\tcase TYPE:\n\t\tcase METHOD:\n\t\t\tfor (JavacNode child : node.down()) {\n\t\t\t\tif (annotationTypeMatches(type, child)) {\n\t\t\t\t\tif (delete) deleteAnnotationIfNeccessary(child, type);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// intentional fallthrough\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tpublic static JavacNode findInnerClass(JavacNode parent, String name) {\n\t\tfor (JavacNode child : parent.down()) {\n\t\t\tif (child.getKind() != Kind.TYPE) continue;\n\t\t\tJCClassDecl td = (JCClassDecl) child.get();\n\t\t\tif (td.name.contentEquals(name)) return child;\n\t\t}\n\t\treturn null;\n\t}\n\t\n\tpublic static JavacNode findAnnotation(Class<? extends Annotation> type, JavacNode node) {\n\t\treturn findAnnotation(type, node, false);\n\t}\n\t\n\tpublic static JavacNode findAnnotation(Class<? extends Annotation> type, JavacNode node, boolean delete) {\n\t\tif (node == null) return null;\n\t\tif (type == null) return null;\n\t\tswitch (node.getKind()) {\n\t\tcase ARGUMENT:\n\t\tcase FIELD:\n\t\tcase LOCAL:\n\t\tcase TYPE:\n\t\tcase METHOD:\n\t\t\tfor (JavacNode child : node.down()) {\n\t\t\t\tif (annotationTypeMatches(type, child)) {\n\t\t\t\t\tif (delete) deleteAnnotationIfNeccessary(child, type);\n\t\t\t\t\treturn child;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// intentional fallthrough\n\t\tdefault:\n\t\t\treturn null;\n\t\t}\n\t}\n\t\n\t/**\n\t * Checks if the Annotation AST Node provided is likely to be an instance of the provided annotation type.\n\t * \n\t * @param type An actual annotation type, such as {@code lombok.Getter.class}.\n\t * @param node A Lombok AST node representing an annotation in source code.\n\t */\n\tpublic static boolean annotationTypeMatches(Class<? extends Annotation> type, JavacNode node) {\n\t\tif (node.getKind() != Kind.ANNOTATION) return false;\n\t\treturn typeMatches(type, node, ((JCAnnotation) node.get()).annotationType);\n\t}\n\t\n\t/**\n\t * Checks if the Annotation AST Node provided is likely to be an instance of the provided annotation type.\n\t * \n\t * @param type An actual annotation type, such as {@code lombok.Getter.class}.\n\t * @param node A Lombok AST node representing an annotation in source code.\n\t */\n\tpublic static boolean annotationTypeMatches(String type, JavacNode node) {\n\t\tif (node.getKind() != Kind.ANNOTATION) return false;\n\t\treturn typeMatches(type, node, ((JCAnnotation) node.get()).annotationType);\n\t}\n\t\n\t/**\n\t * Checks if the given TypeReference node is likely to be a reference to the provided class.\n\t * \n\t * @param type An actual type. This method checks if {@code typeNode} is likely to be a reference to this type.\n\t * @param node A Lombok AST node. Any node in the appropriate compilation unit will do (used to get access to import statements).\n\t * @param typeNode A type reference to check.\n\t */\n\tpublic static boolean typeMatches(Class<?> type, JavacNode node, JCTree typeNode) {\n\t\treturn typeMatches(type.getName(), node, typeNode);\n\t}\n\t\n\t/**\n\t * Checks if the given TypeReference node is likely to be a reference to the provided class.\n\t * \n\t * @param type An actual type. This method checks if {@code typeNode} is likely to be a reference to this type.\n\t * @param node A Lombok AST node. Any node in the appropriate compilation unit will do (used to get access to import statements).\n\t * @param typeNode A type reference to check.\n\t */\n\tpublic static boolean typeMatches(String type, JavacNode node, JCTree typeNode) {\n\t\tString typeName = typeNode == null ? null : typeNode.toString();\n\t\tif (typeName == null || typeName.length() == 0) return false;\n\t\tint lastIndexA = typeName.lastIndexOf('.') + 1;\n\t\tint lastIndexB = Math.max(type.lastIndexOf('.'), type.lastIndexOf('$')) + 1;\n\t\tint len = typeName.length() - lastIndexA;\n\t\tif (len != type.length() - lastIndexB) return false;\n\t\tfor (int i = 0; i < len; i++) if (typeName.charAt(i + lastIndexA) != type.charAt(i + lastIndexB)) return false;\n\t\tTypeResolver resolver = node.getImportListAsTypeResolver();\n\t\treturn resolver.typeMatches(node, type, typeName);\n\t}\n\t\n\t/**\n\t * Returns if a field is marked deprecated, either by {@code @Deprecated} or in javadoc\n\t * @param field the field to check\n\t * @return {@code true} if a field is marked deprecated, either by {@code @Deprecated} or in javadoc, otherwise {@code false}\n\t */\n\tpublic static boolean isFieldDeprecated(JavacNode field) {\n\t\tif (!(field.get() instanceof JCVariableDecl)) return false;\n\t\tJCVariableDecl fieldNode = (JCVariableDecl) field.get();\n\t\tif ((fieldNode.mods.flags & Flags.DEPRECATED) != 0) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (JavacNode child : field.down()) {\n\t\t\tif (annotationTypeMatches(Deprecated.class, child)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic static CheckerFrameworkVersion getCheckerFrameworkVersion(JavacNode node) {\n\t\tCheckerFrameworkVersion cfv = node.getAst().readConfiguration(ConfigurationKeys.CHECKER_FRAMEWORK);\n\t\treturn cfv == null ? CheckerFrameworkVersion.NONE : cfv;\n\t}\n\t\n\t/**\n\t * Returns if a node is marked deprecated (as picked up on by the parser).\n\t * @param node the node to check (type, method, or field decl).\n\t */\n\tpublic static boolean nodeHasDeprecatedFlag(JCTree node) {\n\t\tif (node instanceof JCVariableDecl) return (((JCVariableDecl) node).mods.flags & Flags.DEPRECATED) != 0;\n\t\tif (node instanceof JCMethodDecl) return (((JCMethodDecl) node).mods.flags & Flags.DEPRECATED) != 0;\n\t\tif (node instanceof JCClassDecl) return (((JCClassDecl) node).mods.flags & Flags.DEPRECATED) != 0;\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Creates an instance of {@code AnnotationValues} for the provided AST Node.\n\t * \n\t * @param type An annotation class type, such as {@code lombok.Getter.class}.\n\t * @param node A Lombok AST node representing an annotation in source code.\n\t */\n\tpublic static <A extends Annotation> AnnotationValues<A> createAnnotation(Class<A> type, final JavacNode node) {\n\t\treturn createAnnotation(type, (JCAnnotation) node.get(), node);\n\t}\n\t\n\t/**\n\t * Creates an instance of {@code AnnotationValues} for the provided AST Node\n\t * and Annotation expression.\n\t *\n\t * @param type An annotation class type, such as {@code lombok.Getter.class}.\n\t * @param anno the annotation expression\n\t * @param node A Lombok AST node representing an annotation in source code.\n\t */\n\tpublic static <A extends Annotation> AnnotationValues<A> createAnnotation(Class<A> type, JCAnnotation anno, final JavacNode node) {\n\t\tMap<String, AnnotationValue> values = new HashMap<String, AnnotationValue>();\n\t\tList<JCExpression> arguments = anno.getArguments();\n\t\t\n\t\tfor (JCExpression arg : arguments) {\n\t\t\tString mName;\n\t\t\tJCExpression rhs;\n\t\t\tjava.util.List<String> raws = new ArrayList<String>();\n\t\t\tjava.util.List<Object> guesses = new ArrayList<Object>();\n\t\t\tjava.util.List<Object> expressions = new ArrayList<Object>();\n\t\t\tfinal java.util.List<DiagnosticPosition> positions = new ArrayList<DiagnosticPosition>();\n\t\t\t\n\t\t\tif (arg instanceof JCAssign) {\n\t\t\t\tJCAssign assign = (JCAssign) arg;\n\t\t\t\tmName = assign.lhs.toString();\n\t\t\t\trhs = assign.rhs;\n\t\t\t} else {\n\t\t\t\trhs = arg;\n\t\t\t\tmName = \"value\";\n\t\t\t}\n\t\t\t\n\t\t\tif (rhs instanceof JCNewArray) {\n\t\t\t\tList<JCExpression> elems = ((JCNewArray) rhs).elems;\n\t\t\t\tfor (JCExpression inner : elems) {\n\t\t\t\t\traws.add(inner.toString());\n\t\t\t\t\texpressions.add(inner);\n\t\t\t\t\tif (inner instanceof JCAnnotation) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\t\t\t\tClass<A> innerClass = (Class<A>) Class.forName(inner.type.toString());\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tguesses.add(createAnnotation(innerClass, (JCAnnotation) inner, node));\n\t\t\t\t\t\t} catch (ClassNotFoundException ex) {\n\t\t\t\t\t\t\tguesses.add(calculateGuess(inner));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tguesses.add(calculateGuess(inner));\n\t\t\t\t\t}\n\t\t\t\t\tpositions.add(inner.pos());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\traws.add(rhs.toString());\n\t\t\t\texpressions.add(rhs);\n\t\t\t\tif (rhs instanceof JCAnnotation) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\t\t\tClass<A> innerClass = (Class<A>) Class.forName(rhs.type.toString());\n\t\t\t\t\t\t\n\t\t\t\t\t\tguesses.add(createAnnotation(innerClass, (JCAnnotation) rhs, node));\n\t\t\t\t\t} catch (ClassNotFoundException ex) {\n\t\t\t\t\t\tguesses.add(calculateGuess(rhs));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tguesses.add(calculateGuess(rhs));\n\t\t\t\t}\n\t\t\t\tpositions.add(rhs.pos());\n\t\t\t}\n\t\t\t\n\t\t\tvalues.put(mName, new AnnotationValue(node, raws, expressions, guesses, true) {\n\t\t\t\t@Override public void setError(String message, int valueIdx) {\n\t\t\t\t\tif (valueIdx < 0) node.addError(message);\n\t\t\t\t\telse node.addError(message, positions.get(valueIdx));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t@Override public void setWarning(String message, int valueIdx) {\n\t\t\t\t\tif (valueIdx < 0) node.addWarning(message);\n\t\t\t\t\telse node.addWarning(message, positions.get(valueIdx));\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\t\n\t\tfor (Method m : type.getDeclaredMethods()) {\n\t\t\tif (!Modifier.isPublic(m.getModifiers())) continue;\n\t\t\tString name = m.getName();\n\t\t\tif (!values.containsKey(name)) {\n\t\t\t\tvalues.put(name, new AnnotationValue(node, new ArrayList<String>(), new ArrayList<Object>(), new ArrayList<Object>(), false) {\n\t\t\t\t\t@Override public void setError(String message, int valueIdx) {\n\t\t\t\t\t\tnode.addError(message);\n\t\t\t\t\t}\n\t\t\t\t\t@Override public void setWarning(String message, int valueIdx) {\n\t\t\t\t\t\tnode.addWarning(message);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn new AnnotationValues<A>(type, values, node);\n\t}\n\t\n\t/**\n\t * Removes the annotation from javac's AST (it remains in lombok's AST),\n\t * then removes any import statement that imports this exact annotation (not star imports).\n\t * Only does this if the DeleteLombokAnnotations class is in the context.\n\t */\n\tpublic static void deleteAnnotationIfNeccessary(JavacNode annotation, String annotationType) {\n\t\tdeleteAnnotationIfNeccessary0(annotation, annotationType);\n\t}\n\t\n\t/**\n\t * Removes the annotation from javac's AST (it remains in lombok's AST),\n\t * then removes any import statement that imports this exact annotation (not star imports).\n\t * Only does this if the DeleteLombokAnnotations class is in the context.\n\t */\n\tpublic static void deleteAnnotationIfNeccessary(JavacNode annotation, Class<? extends Annotation> annotationType) {\n\t\tdeleteAnnotationIfNeccessary0(annotation, annotationType.getName());\n\t}\n\t\n\t/**\n\t * Removes the annotation from javac's AST (it remains in lombok's AST),\n\t * then removes any import statement that imports this exact annotation (not star imports).\n\t * Only does this if the DeleteLombokAnnotations class is in the context.\n\t */\n\tpublic static void deleteAnnotationIfNeccessary(JavacNode annotation, Class<? extends Annotation> annotationType1, Class<? extends Annotation> annotationType2) {\n\t\tdeleteAnnotationIfNeccessary0(annotation, annotationType1.getName(), annotationType2.getName());\n\t}\n\t\n\t/**\n\t * Removes the annotation from javac's AST (it remains in lombok's AST),\n\t * then removes any import statement that imports this exact annotation (not star imports).\n\t * Only does this if the DeleteLombokAnnotations class is in the context.\n\t */\n\tpublic static void deleteAnnotationIfNeccessary(JavacNode annotation, Class<? extends Annotation> annotationType1, String annotationType2) {\n\t\tdeleteAnnotationIfNeccessary0(annotation, annotationType1.getName(), annotationType2);\n\t}\n\t\n\tprivate static void deleteAnnotationIfNeccessary0(JavacNode annotation, String... annotationTypes) {\n\t\tif (inNetbeansEditor(annotation)) return;\n\t\tif (!annotation.shouldDeleteLombokAnnotations()) return;\n\t\tJavacNode parentNode = annotation.directUp();\n\t\tswitch (parentNode.getKind()) {\n\t\tcase FIELD:\n\t\tcase ARGUMENT:\n\t\tcase LOCAL:\n\t\t\tJCVariableDecl variable = (JCVariableDecl) parentNode.get();\n\t\t\tvariable.mods.annotations = filterList(variable.mods.annotations, annotation.get());\n\t\t\tbreak;\n\t\tcase METHOD:\n\t\t\tJCMethodDecl method = (JCMethodDecl) parentNode.get();\n\t\t\tmethod.mods.annotations = filterList(method.mods.annotations, annotation.get());\n\t\t\tbreak;\n\t\tcase TYPE:\n\t\t\ttry {\n\t\t\t\tJCClassDecl type = (JCClassDecl) parentNode.get();\n\t\t\t\ttype.mods.annotations = filterList(type.mods.annotations, annotation.get());\n\t\t\t} catch (ClassCastException e) {\n\t\t\t\t//something rather odd has been annotated. Better to just break only delombok instead of everything.\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t//This really shouldn't happen, but if it does, better just break delombok instead of breaking everything.\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tparentNode.getAst().setChanged();\n\t\tfor (String annotationType : annotationTypes) {\n\t\t\tdeleteImportFromCompilationUnit(annotation, annotationType);\n\t\t}\n\t}\n\t\n\tpublic static void deleteImportFromCompilationUnit(JavacNode node, String name) {\n\t\tif (inNetbeansEditor(node)) return;\n\t\tif (!node.shouldDeleteLombokAnnotations()) return;\n\t\t\n\t\tJCCompilationUnit unit = (JCCompilationUnit) node.top().get();\n\t\t\n\t\tfor (JCTree def : unit.defs) {\n\t\t\tif (!(def instanceof JCImport)) continue;\n\t\t\tJCImport imp0rt = (JCImport) def;\n\t\t\tif (imp0rt.staticImport) continue;\n\t\t\tif (!imp0rt.qualid.toString().equals(name)) continue;\n\t\t\tJavacAugments.JCImport_deletable.set(imp0rt, true);\n\t\t}\n\t}\n\t\n\tprivate static List<JCAnnotation> filterList(List<JCAnnotation> annotations, JCTree jcTree) {\n\t\tListBuffer<JCAnnotation> newAnnotations = new ListBuffer<JCAnnotation>();\n\t\tfor (JCAnnotation ann : annotations) {\n\t\t\tif (jcTree != ann) newAnnotations.append(ann);\n\t\t}\n\t\treturn newAnnotations.toList();\n\t}\n\t\n\t/** Serves as return value for the methods that check for the existence of fields and methods. */\n\tpublic enum MemberExistsResult {\n\t\tNOT_EXISTS, EXISTS_BY_LOMBOK, EXISTS_BY_USER;\n\t}\n\t\n\t/**\n\t * Translates the given field into all possible getter names.\n\t * Convenient wrapper around {@link HandlerUtil#toAllGetterNames(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static java.util.List<String> toAllGetterNames(JavacNode field) {\n\t\treturn HandlerUtil.toAllGetterNames(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * Translates the given field into all possible getter names.\n\t * Convenient wrapper around {@link HandlerUtil#toAllGetterNames(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static java.util.List<String> toAllGetterNames(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\treturn HandlerUtil.toAllGetterNames(field.getAst(), accessors, field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * @return the likely getter name for the stated field. (e.g. private boolean foo; to isFoo).\n\t * \n\t * Convenient wrapper around {@link HandlerUtil#toGetterName(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static String toGetterName(JavacNode field) {\n\t\treturn HandlerUtil.toGetterName(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * @return the likely getter name for the stated field. (e.g. private boolean foo; to isFoo).\n\t * \n\t * Convenient wrapper around {@link HandlerUtil#toGetterName(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static String toGetterName(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\treturn HandlerUtil.toGetterName(field.getAst(), accessors, field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * Translates the given field into all possible setter names.\n\t * Convenient wrapper around {@link HandlerUtil#toAllSetterNames(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static java.util.List<String> toAllSetterNames(JavacNode field) {\n\t\treturn HandlerUtil.toAllSetterNames(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * Translates the given field into all possible setter names.\n\t * Convenient wrapper around {@link HandlerUtil#toAllSetterNames(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static java.util.List<String> toAllSetterNames(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\treturn HandlerUtil.toAllSetterNames(field.getAst(), accessors, field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * @return the likely setter name for the stated field. (e.g. private boolean foo; to setFoo).\n\t * \n\t * Convenient wrapper around {@link HandlerUtil#toSetterName(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static String toSetterName(JavacNode field) {\n\t\treturn HandlerUtil.toSetterName(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * @return the likely setter name for the stated field. (e.g. private boolean foo; to setFoo).\n\t * \n\t * Convenient wrapper around {@link HandlerUtil#toSetterName(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static String toSetterName(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\treturn HandlerUtil.toSetterName(field.getAst(), accessors, field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * Translates the given field into all possible with names.\n\t * Convenient wrapper around {@link HandlerUtil#toAllWithNames(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static java.util.List<String> toAllWithNames(JavacNode field) {\n\t\treturn HandlerUtil.toAllWithNames(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * Translates the given field into all possible with names.\n\t * Convenient wrapper around {@link HandlerUtil#toAllWithNames(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static java.util.List<String> toAllWithNames(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\treturn HandlerUtil.toAllWithNames(field.getAst(), accessors, field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * Translates the given field into all possible withBy names.\n\t * Convenient wrapper around {@link HandlerUtil#toAllWithByNames(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static java.util.List<String> toAllWithByNames(JavacNode field) {\n\t\treturn HandlerUtil.toAllWithByNames(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * Translates the given field into all possible withBy names.\n\t * Convenient wrapper around {@link HandlerUtil#toAllWithByNames(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static java.util.List<String> toAllWithByNames(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\treturn HandlerUtil.toAllWithByNames(field.getAst(), accessors, field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * @return the likely with name for the stated field. (e.g. private boolean foo; to withFoo).\n\t * \n\t * Convenient wrapper around {@link HandlerUtil#toWithName(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static String toWithName(JavacNode field) {\n\t\treturn HandlerUtil.toWithName(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * @return the likely with name for the stated field. (e.g. private boolean foo; to withFoo).\n\t * \n\t * Convenient wrapper around {@link HandlerUtil#toWithName(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static String toWithName(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\treturn HandlerUtil.toWithName(field.getAst(), accessors, field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * @return the likely withBy name for the stated field. (e.g. private boolean foo; to withFooBy).\n\t * \n\t * Convenient wrapper around {@link HandlerUtil#toWithByName(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static String toWithByName(JavacNode field) {\n\t\treturn HandlerUtil.toWithByName(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * @return the likely withBy name for the stated field. (e.g. private boolean foo; to withFooBy).\n\t * \n\t * Convenient wrapper around {@link HandlerUtil#toWithByName(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static String toWithByName(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\treturn HandlerUtil.toWithByName(field.getAst(), accessors, field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * When generating a setter, the setter either returns void (beanspec) or Self (fluent).\n\t * This method scans for the {@code Accessors} annotation to figure that out.\n\t */\n\tpublic static boolean shouldReturnThis(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\tif ((((JCVariableDecl) field.get()).mods.flags & Flags.STATIC) != 0) return false;\n\t\t\n\t\treturn HandlerUtil.shouldReturnThis0(accessors, field.getAst());\n\t}\n\t\n\t/**\n\t * When generating a setter/getter/wither, should it be made final?\n\t */\n\tpublic static boolean shouldMakeFinal(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\tif ((((JCVariableDecl) field.get()).mods.flags & Flags.STATIC) != 0) return false;\n\t\t\n\t\treturn HandlerUtil.shouldMakeFinal0(accessors, field.getAst());\n\t}\n\t\n\tpublic static JCExpression cloneSelfType(JavacNode childOfType) {\n\t\tJavacNode typeNode = childOfType;\n\t\tJavacTreeMaker maker = childOfType.getTreeMaker();\n\t\twhile (typeNode != null && typeNode.getKind() != Kind.TYPE) typeNode = typeNode.up();\n\t\treturn JavacHandlerUtil.namePlusTypeParamsToTypeReference(maker, typeNode, ((JCClassDecl) typeNode.get()).typarams);\n\t}\n\t\n\tpublic static boolean isBoolean(JavacNode field) {\n\t\tJCExpression varType = ((JCVariableDecl) field.get()).vartype;\n\t\treturn isBoolean(varType);\n\t}\n\t\n\tpublic static boolean isBoolean(JCExpression varType) {\n\t\treturn varType != null && varType.toString().equals(\"boolean\");\n\t}\n\t\n\tpublic static Name removePrefixFromField(JavacNode field) {\n\t\tjava.util.List<String> prefixes = null;\n\t\tfor (JavacNode node : field.down()) {\n\t\t\tif (annotationTypeMatches(Accessors.class, node)) {\n\t\t\t\tAnnotationValues<Accessors> ann = createAnnotation(Accessors.class, node);\n\t\t\t\tif (ann.isExplicit(\"prefix\")) prefixes = Arrays.asList(ann.getInstance().prefix());\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (prefixes == null) {\n\t\t\tJavacNode current = field.up();\n\t\t\touter:\n\t\t\twhile (current != null) {\n\t\t\t\tfor (JavacNode node : current.down()) {\n\t\t\t\t\tif (annotationTypeMatches(Accessors.class, node)) {\n\t\t\t\t\t\tAnnotationValues<Accessors> ann = createAnnotation(Accessors.class, node);\n\t\t\t\t\t\tif (ann.isExplicit(\"prefix\")) prefixes = Arrays.asList(ann.getInstance().prefix());\n\t\t\t\t\t\tbreak outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcurrent = current.up();\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (prefixes == null) prefixes = field.getAst().readConfiguration(ConfigurationKeys.ACCESSORS_PREFIX);\n\t\t\n\t\tif (!prefixes.isEmpty()) {\n\t\t\tCharSequence newName = removePrefix(field.getName(), prefixes);\n\t\t\tif (newName != null) return field.toName(newName.toString());\n\t\t}\n\t\t\n\t\treturn ((JCVariableDecl) field.get()).name;\n\t}\n\t\n\tpublic static AnnotationValues<Accessors> getAccessorsForField(JavacNode field) {\n\t\tAnnotationValues<Accessors> values = null;\n\t\t\n\t\tfor (JavacNode node : field.down()) {\n\t\t\tif (annotationTypeMatches(Accessors.class, node)) {\n\t\t\t\tvalues = createAnnotation(Accessors.class, node);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tJavacNode current = field.up();\n\t\twhile (current != null) {\n\t\t\tfor (JavacNode node : current.down()) {\n\t\t\t\tif (annotationTypeMatches(Accessors.class, node)) {\n\t\t\t\t\tAnnotationValues<Accessors> onType = createAnnotation(Accessors.class, node);\n\t\t\t\t\tvalues = values == null ? onType : values.integrate(onType);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurrent = current.up();\n\t\t}\n\t\t\n\t\treturn values == null ? AnnotationValues.of(Accessors.class, field) : values;\n\t}\n\t\n\t/**\n\t * Checks if there is a field with the provided name.\n\t * \n\t * @param fieldName the field name to check for.\n\t * @param node Any node that represents the Type (JCClassDecl) to look in, or any child node thereof.\n\t */\n\tpublic static MemberExistsResult fieldExists(String fieldName, JavacNode node) {\n\t\tnode = upToTypeNode(node);\n\t\t\n\t\tif (node != null && node.get() instanceof JCClassDecl) {\n\t\t\tfor (JCTree def : ((JCClassDecl)node.get()).defs) {\n\t\t\t\tif (def instanceof JCVariableDecl) {\n\t\t\t\t\tif (((JCVariableDecl)def).name.contentEquals(fieldName)) {\n\t\t\t\t\t\treturn getGeneratedBy(def) == null ? MemberExistsResult.EXISTS_BY_USER : MemberExistsResult.EXISTS_BY_LOMBOK;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn MemberExistsResult.NOT_EXISTS;\n\t}\n\t\n\tpublic static MemberExistsResult methodExists(String methodName, JavacNode node, int params) {\n\t\treturn methodExists(methodName, node, true, params);\n\t}\n\t\n\t/**\n\t * Checks if there is a method with the provided name. In case of multiple methods (overloading), only\n\t * the first method decides if EXISTS_BY_USER or EXISTS_BY_LOMBOK is returned.\n\t * \n\t * @param methodName the method name to check for.\n\t * @param node Any node that represents the Type (JCClassDecl) to look in, or any child node thereof.\n\t * @param caseSensitive If the search should be case sensitive.\n\t * @param params The number of parameters the method should have; varargs count as 0-*. Set to -1 to find any method with the appropriate name regardless of parameter count.\n\t */\n\tpublic static MemberExistsResult methodExists(String methodName, JavacNode node, boolean caseSensitive, int params) {\n\t\tnode = upToTypeNode(node);\n\t\t\n\t\tif (node != null && node.get() instanceof JCClassDecl) {\n\t\t\ttop: for (JCTree def : ((JCClassDecl)node.get()).defs) {\n\t\t\t\tif (def instanceof JCMethodDecl) {\n\t\t\t\t\tJCMethodDecl md = (JCMethodDecl) def;\n\t\t\t\t\tString name = md.name.toString();\n\t\t\t\t\tboolean matches = caseSensitive ? name.equals(methodName) : name.equalsIgnoreCase(methodName);\n\t\t\t\t\tif (matches) {\n\t\t\t\t\t\tif (params > -1) {\n\t\t\t\t\t\t\tList<JCVariableDecl> ps = md.params;\n\t\t\t\t\t\t\tint minArgs = 0;\n\t\t\t\t\t\t\tint maxArgs = 0;\n\t\t\t\t\t\t\tif (ps != null && ps.length() > 0) {\n\t\t\t\t\t\t\t\tminArgs = ps.length();\n\t\t\t\t\t\t\t\tif ((ps.last().mods.flags & Flags.VARARGS) != 0) {\n\t\t\t\t\t\t\t\t\tmaxArgs = Integer.MAX_VALUE;\n\t\t\t\t\t\t\t\t\tminArgs--;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tmaxArgs = minArgs;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (params < minArgs || params > maxArgs) continue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (isTolerate(node, md)) continue top;\n\t\t\t\t\t\t\n\t\t\t\t\t\treturn getGeneratedBy(def) == null ? MemberExistsResult.EXISTS_BY_USER : MemberExistsResult.EXISTS_BY_LOMBOK;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn MemberExistsResult.NOT_EXISTS;\n\t}\n\t\n\tpublic static boolean isTolerate(JavacNode node, JCTree.JCMethodDecl md) {\n\t\tList<JCAnnotation> annotations = md.getModifiers().getAnnotations();\n\t\tif (annotations != null) for (JCTree.JCAnnotation anno : annotations) {\n\t\t\tif (typeMatches(Tolerate.class, node, anno.getAnnotationType())) return true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Checks if there is a (non-default) constructor. In case of multiple constructors (overloading), only\n\t * the first constructor decides if EXISTS_BY_USER or EXISTS_BY_LOMBOK is returned.\n\t * \n\t * @param node Any node that represents the Type (JCClassDecl) to look in, or any child node thereof.\n\t */\n\tpublic static MemberExistsResult constructorExists(JavacNode node) {\n\t\tnode = upToTypeNode(node);\n\t\t\n\t\tif (node != null && node.get() instanceof JCClassDecl) {\n\t\t\tfor (JCTree def : ((JCClassDecl) node.get()).defs) {\n\t\t\t\tif (def instanceof JCMethodDecl) {\n\t\t\t\t\tJCMethodDecl md = (JCMethodDecl) def;\n\t\t\t\t\tif (md.name.contentEquals(\"<init>\")) {\n\t\t\t\t\t\tif ((md.mods.flags & Flags.GENERATEDCONSTR) != 0) continue;\n\t\t\t\t\t\tif (isTolerate(node, md)) continue;\n\t\t\t\t\t\treturn getGeneratedBy(def) == null ? MemberExistsResult.EXISTS_BY_USER : MemberExistsResult.EXISTS_BY_LOMBOK;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn MemberExistsResult.NOT_EXISTS;\n\t}\n\t\n\tpublic static boolean isConstructorCall(final JCStatement statement) {\n\t\tif (!(statement instanceof JCExpressionStatement)) return false;\n\t\tJCExpression expr = ((JCExpressionStatement) statement).expr;\n\t\tif (!(expr instanceof JCMethodInvocation)) return false;\n\t\tJCExpression invocation = ((JCMethodInvocation) expr).meth;\n\t\tString name;\n\t\tif (invocation instanceof JCFieldAccess) {\n\t\t\tname = ((JCFieldAccess) invocation).name.toString();\n\t\t} else if (invocation instanceof JCIdent) {\n\t\t\tname = ((JCIdent) invocation).name.toString();\n\t\t} else {\n\t\t\tname = \"\";\n\t\t}\n\t\t\n\t\treturn \"super\".equals(name) || \"this\".equals(name);\n\t}\n\t\n\t/**\n\t * Turns an {@code AccessLevel} instance into the flag bit used by javac.\n\t */\n\tpublic static int toJavacModifier(AccessLevel accessLevel) {\n\t\tswitch (accessLevel) {\n\t\tcase MODULE:\n\t\tcase PACKAGE:\n\t\t\treturn 0;\n\t\tdefault:\n\t\tcase PUBLIC:\n\t\t\treturn Flags.PUBLIC;\n\t\tcase NONE:\n\t\tcase PRIVATE:\n\t\t\treturn Flags.PRIVATE;\n\t\tcase PROTECTED:\n\t\t\treturn Flags.PROTECTED;\n\t\t}\n\t}\n\t\n\tprivate static class GetterMethod {\n\t\tprivate final Name name;\n\t\tprivate final JCExpression type;\n\t\t\n\t\tGetterMethod(Name name, JCExpression type) {\n\t\t\tthis.name = name;\n\t\t\tthis.type = type;\n\t\t}\n\t}\n\t\n\tprivate static GetterMethod findGetter(JavacNode field) {\n\t\tJCVariableDecl decl = (JCVariableDecl)field.get();\n\t\tJavacNode typeNode = field.up();\n\t\tfor (String potentialGetterName : toAllGetterNames(field)) {\n\t\t\tfor (JavacNode potentialGetter : typeNode.down()) {\n\t\t\t\tif (potentialGetter.getKind() != Kind.METHOD) continue;\n\t\t\t\tJCMethodDecl method = (JCMethodDecl) potentialGetter.get();\n\t\t\t\tif (!method.name.toString().equalsIgnoreCase(potentialGetterName)) continue;\n\t\t\t\t/** static getX() methods don't count. */\n\t\t\t\tif ((method.mods.flags & Flags.STATIC) != 0) continue;\n\t\t\t\t/** Nor do getters with a non-empty parameter list. */\n\t\t\t\tif (method.params != null && method.params.size() > 0) continue;\n\t\t\t\treturn new GetterMethod(method.name, method.restype);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Check if the field has a @Getter annotation.\n\t\t\n\t\tboolean hasGetterAnnotation = false;\n\t\t\n\t\tfor (JavacNode child : field.down()) {\n\t\t\tif (child.getKind() == Kind.ANNOTATION && annotationTypeMatches(Getter.class, child)) {\n\t\t\t\tAnnotationValues<Getter> ann = createAnnotation(Getter.class, child);\n\t\t\t\tif (ann.getInstance().value() == AccessLevel.NONE) return null;   //Definitely WONT have a getter.\n\t\t\t\thasGetterAnnotation = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Check if the class has a @Getter annotation.\n\t\t\n\t\tif (!hasGetterAnnotation && HandleGetter.fieldQualifiesForGetterGeneration(field)) {\n\t\t\t//Check if the class has @Getter or @Data annotation.\n\t\t\t\n\t\t\tJavacNode containingType = field.up();\n\t\t\tif (containingType != null) for (JavacNode child : containingType.down()) {\n\t\t\t\tif (child.getKind() == Kind.ANNOTATION && annotationTypeMatches(Data.class, child)) hasGetterAnnotation = true;\n\t\t\t\tif (child.getKind() == Kind.ANNOTATION && annotationTypeMatches(Getter.class, child)) {\n\t\t\t\t\tAnnotationValues<Getter> ann = createAnnotation(Getter.class, child);\n\t\t\t\t\tif (ann.getInstance().value() == AccessLevel.NONE) return null;   //Definitely WONT have a getter.\n\t\t\t\t\thasGetterAnnotation = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (hasGetterAnnotation) {\n\t\t\tString getterName = toGetterName(field);\n\t\t\tif (getterName == null) return null;\n\t\t\treturn new GetterMethod(field.toName(getterName), decl.vartype);\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\t\n\tstatic boolean lookForGetter(JavacNode field, FieldAccess fieldAccess) {\n\t\tif (fieldAccess == FieldAccess.GETTER) return true;\n\t\tif (fieldAccess == FieldAccess.ALWAYS_FIELD) return false;\n\t\t\n\t\t// If @Getter(lazy = true) is used, then using it is mandatory.\n\t\tfor (JavacNode child : field.down()) {\n\t\t\tif (child.getKind() != Kind.ANNOTATION) continue;\n\t\t\tif (annotationTypeMatches(Getter.class, child)) {\n\t\t\t\tAnnotationValues<Getter> ann = createAnnotation(Getter.class, child);\n\t\t\t\tif (ann.getInstance().lazy()) return true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Returns the type of the field, unless a getter exists for this field, in which case the return type of the getter is returned.\n\t * \n\t * @see #createFieldAccessor(TreeMaker, JavacNode, FieldAccess)\n\t */\n\tstatic JCExpression getFieldType(JavacNode field, FieldAccess fieldAccess) {\n\t\tif (field.getKind() == Kind.METHOD) return ((JCMethodDecl) field.get()).restype;\n\t\t\n\t\tboolean lookForGetter = lookForGetter(field, fieldAccess);\n\t\t\n\t\tGetterMethod getter = lookForGetter ? findGetter(field) : null;\n\t\t\n\t\tif (getter == null) {\n\t\t\treturn ((JCVariableDecl) field.get()).vartype;\n\t\t}\n\t\t\n\t\treturn getter.type;\n\t}\n\t\n\t/**\n\t * Creates an expression that reads the field. Will either be {@code this.field} or {@code this.getField()} depending on whether or not there's a getter.\n\t */\n\tstatic JCExpression createFieldAccessor(JavacTreeMaker maker, JavacNode field, FieldAccess fieldAccess) {\n\t\treturn createFieldAccessor(maker, field, fieldAccess, null);\n\t}\n\t\n\tstatic JCExpression createFieldAccessor(JavacTreeMaker maker, JavacNode field, FieldAccess fieldAccess, JCExpression receiver) {\n\t\tboolean lookForGetter = lookForGetter(field, fieldAccess);\n\t\t\n\t\tGetterMethod getter = lookForGetter ? findGetter(field) : null;\n\t\tJCVariableDecl fieldDecl = (JCVariableDecl) field.get();\n\t\t\n\t\tif (getter == null) {\n\t\t\tif (receiver == null) {\n\t\t\t\tif ((fieldDecl.mods.flags & Flags.STATIC) == 0) {\n\t\t\t\t\treceiver = maker.Ident(field.toName(\"this\"));\n\t\t\t\t} else {\n\t\t\t\t\tJavacNode containerNode = field.up();\n\t\t\t\t\tif (containerNode != null && containerNode.get() instanceof JCClassDecl) {\n\t\t\t\t\t\tJCClassDecl container = (JCClassDecl) field.up().get();\n\t\t\t\t\t\treceiver = maker.Ident(container.name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn receiver == null ? maker.Ident(fieldDecl.name) : maker.Select(receiver, fieldDecl.name);\n\t\t}\n\t\t\n\t\tif (receiver == null) receiver = maker.Ident(field.toName(\"this\"));\n\t\tJCMethodInvocation call = maker.Apply(List.<JCExpression>nil(),\n\t\t\tmaker.Select(receiver, getter.name), List.<JCExpression>nil());\n\t\treturn call;\n\t}\n\t\n\tstatic JCExpression createMethodAccessor(JavacTreeMaker maker, JavacNode method) {\n\t\treturn createMethodAccessor(maker, method, null);\n\t}\n\t\n\tstatic JCExpression createMethodAccessor(JavacTreeMaker maker, JavacNode method, JCExpression receiver) {\n\t\tJCMethodDecl methodDecl = (JCMethodDecl) method.get();\n\t\t\n\t\tif (receiver == null && (methodDecl.mods.flags & Flags.STATIC) == 0) {\n\t\t\treceiver = maker.Ident(method.toName(\"this\"));\n\t\t} else if (receiver == null) {\n\t\t\tJavacNode containerNode = method.up();\n\t\t\tif (containerNode != null && containerNode.get() instanceof JCClassDecl) {\n\t\t\t\tJCClassDecl container = (JCClassDecl) method.up().get();\n\t\t\t\treceiver = maker.Ident(container.name);\n\t\t\t}\n\t\t}\n\t\t\n\t\tJCMethodInvocation call = maker.Apply(List.<JCExpression>nil(),\n\t\t\treceiver == null ? maker.Ident(methodDecl.name) : maker.Select(receiver, methodDecl.name), List.<JCExpression>nil());\n\t\treturn call;\n\t}\n\t\n\t/**\n\t * Adds the given new field declaration to the provided type AST Node.\n\t * The field carries the &#64;{@link SuppressWarnings}(\"all\") annotation.\n\t * Also takes care of updating the JavacAST.\n\t */\n\tpublic static JavacNode injectFieldAndMarkGenerated(JavacNode typeNode, JCVariableDecl field) {\n\t\treturn injectField(typeNode, field, true);\n\t}\n\t\n\t/**\n\t * Adds the given new field declaration to the provided type AST Node.\n\t * \n\t * Also takes care of updating the JavacAST.\n\t */\n\tpublic static JavacNode injectField(JavacNode typeNode, JCVariableDecl field) {\n\t\treturn injectField(typeNode, field, false);\n\t}\n\t\n\tpublic static JavacNode injectField(JavacNode typeNode, JCVariableDecl field, boolean addGenerated) {\n\t\treturn injectField(typeNode, field, addGenerated, false);\n\t}\n\t\n\tpublic static JavacNode injectField(JavacNode typeNode, JCVariableDecl field, boolean addGenerated, boolean specialEnumHandling) {\n\t\tJCClassDecl type = (JCClassDecl) typeNode.get();\n\t\t\n\t\tif (addGenerated) {\n\t\t\taddSuppressWarningsAll(field.mods, typeNode, typeNode.getNodeFor(getGeneratedBy(field)), typeNode.getContext());\n\t\t\taddGenerated(field.mods, typeNode, typeNode.getNodeFor(getGeneratedBy(field)), typeNode.getContext());\n\t\t}\n\t\t\n\t\tList<JCTree> insertAfter = null;\n\t\tList<JCTree> insertBefore = type.defs;\n\t\twhile (true) {\n\t\t\tboolean skip = false;\n\t\t\tif (insertBefore.head instanceof JCVariableDecl) {\n\t\t\t\tJCVariableDecl f = (JCVariableDecl) insertBefore.head;\n\t\t\t\tif ((!specialEnumHandling && isEnumConstant(f)) || isGenerated(f)) skip = true;\n\t\t\t} else if (insertBefore.head instanceof JCMethodDecl) {\n\t\t\t\tif ((((JCMethodDecl) insertBefore.head).mods.flags & GENERATEDCONSTR) != 0) skip = true;\n\t\t\t}\n\t\t\tif (skip) {\n\t\t\t\tinsertAfter = insertBefore;\n\t\t\t\tinsertBefore = insertBefore.tail;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tList<JCTree> fieldEntry = List.<JCTree>of(field);\n\t\tfieldEntry.tail = insertBefore;\n\t\tif (insertAfter == null) {\n\t\t\ttype.defs = fieldEntry;\n\t\t} else {\n\t\t\tinsertAfter.tail = fieldEntry;\n\t\t}\n\t\t\n\t\tEnterReflect.memberEnter(field, typeNode);\n\t\t\n\t\treturn typeNode.add(field, Kind.FIELD);\n\t}\n\t\n\tpublic static boolean isEnumConstant(final JCVariableDecl field) {\n\t\treturn (field.mods.flags & Flags.ENUM) != 0;\n\t}\n\t\n\tstatic class JCAnnotatedTypeReflect {\n\t\tprivate static Class<?> TYPE;\n\t\tprivate static Constructor<?> CONSTRUCTOR;\n\t\tprivate static Field ANNOTATIONS, UNDERLYING_TYPE;\n\t\t\n\t\tprivate static void initByLoader(ClassLoader classLoader) {\n\t\t\tif (TYPE != null) return;\n\t\t\tClass<?> c;\n\t\t\ttry {\n\t\t\t\tc = classLoader.loadClass(\"com.sun.tools.javac.tree.JCTree$JCAnnotatedType\");\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tinit(c);\n\t\t}\n\t\t\n\t\tprivate static void init(Class<?> in) {\n\t\t\tif (TYPE != null) return;\n\t\t\tif (!in.getName().equals(\"com.sun.tools.javac.tree.JCTree$JCAnnotatedType\")) return;\n\t\t\ttry {\n\t\t\t\tCONSTRUCTOR = Permit.getConstructor(in, List.class, JCExpression.class);\n\t\t\t\tANNOTATIONS = Permit.getField(in, \"annotations\");\n\t\t\t\tUNDERLYING_TYPE = Permit.getField(in, \"underlyingType\");\n\t\t\t\tTYPE = in;\n\t\t\t} catch (Exception ignore) {}\n\t\t}\n\t\t\n\t\tstatic boolean is(JCTree obj) {\n\t\t\tif (obj == null) return false;\n\t\t\tinit(obj.getClass());\n\t\t\treturn obj.getClass() == TYPE;\n\t\t}\n\t\t\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tstatic List<JCAnnotation> getAnnotations(JCTree obj) {\n\t\t\tinit(obj.getClass());\n\t\t\ttry {\n\t\t\t\treturn (List<JCAnnotation>) ANNOTATIONS.get(obj);\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn List.nil();\n\t\t\t}\n\t\t}\n\t\t\n\t\tstatic void setAnnotations(JCTree obj, List<JCAnnotation> anns) {\n\t\t\tinit(obj.getClass());\n\t\t\ttry {\n\t\t\t\tANNOTATIONS.set(obj, anns);\n\t\t\t} catch (Exception e) {}\n\t\t}\n\t\t\n\t\tstatic JCExpression getUnderlyingType(JCTree obj) {\n\t\t\tinit(obj.getClass());\n\t\t\ttry {\n\t\t\t\treturn (JCExpression) UNDERLYING_TYPE.get(obj);\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\t\n\t\tstatic JCExpression create(List<JCAnnotation> annotations, JCExpression underlyingType) {\n\t\t\tinitByLoader(underlyingType.getClass().getClassLoader());\n\t\t\ttry {\n\t\t\t\treturn (JCExpression) CONSTRUCTOR.newInstance(annotations, underlyingType);\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn underlyingType;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic class JCAnnotationReflect {\n\t\tprivate static final Field ATTRIBUTE;\n\n\t\tstatic {\n\t\t\tATTRIBUTE = Permit.permissiveGetField(JCAnnotation.class, \"attribute\");\n\t\t}\n\n\t\tstatic Attribute.Compound getAttribute(JCAnnotation jcAnnotation) {\n\t\t\tif (ATTRIBUTE != null) {\n\t\t\t\ttry {\n\t\t\t\t\treturn (Attribute.Compound) ATTRIBUTE.get(jcAnnotation);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t// Ignore\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tstatic void setAttribute(JCAnnotation jcAnnotation, Attribute.Compound attribute) {\n\t\t\tif (ATTRIBUTE != null) {\n\t\t\t\ttry {\n\t\t\t\t\tPermit.set(ATTRIBUTE, jcAnnotation, attribute);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t// Ignore\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// jdk9 support, types have changed, names stay the same\n\tstatic class ClassSymbolMembersField {\n\t\tprivate static final Field membersField;\n\t\tprivate static final Method removeMethod;\n\t\tprivate static final Method enterMethod;\n\t\t\n\t\tstatic {\n\t\t\tField f = null;\n\t\t\tMethod r = null;\n\t\t\tMethod e = null;\n\t\t\ttry {\n\t\t\t\tf = Permit.getField(ClassSymbol.class, \"members_field\");\n\t\t\t\tr = Permit.getMethod(f.getType(), \"remove\", Symbol.class);\n\t\t\t\te = Permit.getMethod(f.getType(), \"enter\", Symbol.class);\n\t\t\t} catch (Exception ex) {}\n\t\t\tmembersField = f;\n\t\t\tremoveMethod = r;\n\t\t\tenterMethod = e;\n\t\t}\n\t\t\n\t\tstatic void remove(ClassSymbol from, Symbol toRemove) {\n\t\t\tif (from == null) return;\n\t\t\ttry {\n\t\t\t\tScope scope = (Scope) membersField.get(from);\n\t\t\t\tif (scope == null) return;\n\t\t\t\tPermit.invoke(removeMethod, scope, toRemove);\n\t\t\t} catch (Exception e) {}\n\t\t}\n\t\t\n\t\tstatic void enter(ClassSymbol from, Symbol toEnter) {\n\t\t\tif (from == null) return;\n\t\t\ttry {\n\t\t\t\tScope scope = (Scope) membersField.get(from);\n\t\t\t\tif (scope == null) return;\n\t\t\t\tPermit.invoke(enterMethod, scope, toEnter);\n\t\t\t} catch (Exception e) {}\n\t\t}\n\t}\n\t\n\t/**\n\t * Adds the given new method declaration to the provided type AST Node.\n\t * Can also inject constructors.\n\t * \n\t * Also takes care of updating the JavacAST.\n\t */\n\tpublic static void injectMethod(JavacNode typeNode, JCMethodDecl method) {\n\t\tJCClassDecl type = (JCClassDecl) typeNode.get();\n\t\t\n\t\tif (method.getName().contentEquals(\"<init>\")) {\n\t\t\t//Scan for default constructor, and remove it.\n\t\t\tint idx = 0;\n\t\t\tfor (JCTree def : type.defs) {\n\t\t\t\tif (def instanceof JCMethodDecl) {\n\t\t\t\t\tif ((((JCMethodDecl) def).mods.flags & Flags.GENERATEDCONSTR) != 0) {\n\t\t\t\t\t\tJavacNode tossMe = typeNode.getNodeFor(def);\n\t\t\t\t\t\tif (tossMe != null) tossMe.up().removeChild(tossMe);\n\t\t\t\t\t\ttype.defs = addAllButOne(type.defs, idx);\n\t\t\t\t\t\tClassSymbolMembersField.remove(type.sym, ((JCMethodDecl) def).sym);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tidx++;\n\t\t\t}\n\t\t}\n\t\t\n\t\taddSuppressWarningsAll(method.mods, typeNode, typeNode.getNodeFor(getGeneratedBy(method)), typeNode.getContext());\n\t\taddGenerated(method.mods, typeNode, typeNode.getNodeFor(getGeneratedBy(method)), typeNode.getContext());\n\t\ttype.defs = type.defs.append(method);\n\t\t\n\t\tEnterReflect.memberEnter(method, typeNode);\n\t\t\n\t\ttypeNode.add(method, Kind.METHOD);\n\t}\n\n\t/**\n\t * Adds an inner type (class, interface, enum) to the given type. Cannot inject top-level types.\n\t * \n\t * @param typeNode parent type to inject new type into\n\t * @param type New type (class, interface, etc) to inject.\n\t * @return \n\t */\n\tpublic static JavacNode injectType(JavacNode typeNode, final JCClassDecl type) {\n\t\tJCClassDecl typeDecl = (JCClassDecl) typeNode.get();\n\t\taddSuppressWarningsAll(type.mods, typeNode, typeNode.getNodeFor(getGeneratedBy(type)), typeNode.getContext());\n\t\taddGenerated(type.mods, typeNode, typeNode.getNodeFor(getGeneratedBy(type)), typeNode.getContext());\n\t\ttypeDecl.defs = typeDecl.defs.append(type);\n\t\t\n\t\tEnterReflect.classEnter(type, typeNode);\n\t\t\n\t\treturn typeNode.add(type, Kind.TYPE);\n\t}\n\t\n\tstatic class EnterReflect {\n\t\tprivate static final Method classEnter;\n\t\tprivate static final Method memberEnter;\n\t\tprivate static final Method blockAnnotations;\n\t\tprivate static final Method unblockAnnotations;\n\t\t\n\t\tstatic {\n\t\t\tclassEnter = Permit.permissiveGetMethod(Enter.class, \"classEnter\", JCTree.class, Env.class);\n\t\t\tmemberEnter = Permit.permissiveGetMethod(MemberEnter.class, \"memberEnter\", JCTree.class, Env.class);\n\t\t\t\n\t\t\tMethod block = Permit.permissiveGetMethod(Annotate.class, \"blockAnnotations\");\n\t\t\tif (block == null) block = Permit.permissiveGetMethod(Annotate.class, \"enterStart\");\n\t\t\tblockAnnotations = block;\n\t\t\t\n\t\t\tMethod unblock = Permit.permissiveGetMethod(Annotate.class, \"unblockAnnotations\");\n\t\t\tif (unblock == null) unblock = Permit.permissiveGetMethod(Annotate.class, \"enterDone\");\n\t\t\tunblockAnnotations = unblock;\n\t\t}\n\t\t\n\t\tstatic Type classEnter(JCTree tree, JavacNode parent) {\n\t\t\tEnter enter = Enter.instance(parent.getContext());\n\t\t\tEnv<AttrContext> classEnv = enter.getEnv((TypeSymbol) parent.getElement());\n\t\t\tif (classEnv == null) return null;\n\t\t\tType type = (Type) Permit.invokeSneaky(classEnter, enter, tree, classEnv);\n\t\t\tif (type == null) return null;\n\t\t\ttype.complete();\n\t\t\treturn type;\n\t\t}\n\t\t\n\t\tstatic void memberEnter(JCTree tree, JavacNode parent) {\n\t\t\tContext context = parent.getContext();\n\t\t\tMemberEnter me = MemberEnter.instance(context);\n\t\t\tAnnotate annotate = Annotate.instance(context);\n\t\t\tEnter enter = Enter.instance(context);\n\t\t\t\n\t\t\tEnv<AttrContext> classEnv = enter.getEnv((TypeSymbol) parent.getElement());\n\t\t\tif (classEnv == null) return;\n\t\t\t\n\t\t\tPermit.invokeSneaky(blockAnnotations, annotate);\n\t\t\tPermit.invokeSneaky(memberEnter, me, tree, classEnv);\n\t\t\tPermit.invokeSneaky(unblockAnnotations, annotate);\n\t\t}\n\t}\n\t\n\tpublic static long addFinalIfNeeded(long flags, Context context) {\n\t\tboolean addFinal = LombokOptionsFactory.getDelombokOptions(context).getFormatPreferences().generateFinalParams();\n\t\t\n\t\tif (addFinal) flags |= Flags.FINAL;\n\t\treturn flags;\n\t}\n\t\n\tpublic static JCExpression genTypeRef(JavacNode node, String complexName) {\n\t\tString[] parts = complexName.split(\"\\\\.\");\n\t\tif (parts.length > 2 && parts[0].equals(\"java\") && parts[1].equals(\"lang\")) {\n\t\t\tString[] subParts = new String[parts.length - 2];\n\t\t\tSystem.arraycopy(parts, 2, subParts, 0, subParts.length);\n\t\t\treturn genJavaLangTypeRef(node, subParts);\n\t\t}\n\t\t\n\t\treturn chainDots(node, parts);\n\t}\n\t\n\tpublic static JCExpression genJavaLangTypeRef(JavacNode node, String... simpleNames) {\n\t\tif (LombokOptionsFactory.getDelombokOptions(node.getContext()).getFormatPreferences().javaLangAsFqn()) {\n\t\t\treturn chainDots(node, \"java\", \"lang\", simpleNames);\n\t\t} else {\n\t\t\treturn chainDots(node, null, null, simpleNames);\n\t\t}\n\t}\n\t\n\tpublic static JCExpression genJavaLangTypeRef(JavacNode node, int pos, String... simpleNames) {\n\t\tif (LombokOptionsFactory.getDelombokOptions(node.getContext()).getFormatPreferences().javaLangAsFqn()) {\n\t\t\treturn chainDots(node, pos, \"java\", \"lang\", simpleNames);\n\t\t} else {\n\t\t\treturn chainDots(node, pos, null, null, simpleNames);\n\t\t}\n\t}\n\t\n\tpublic static void addSuppressWarningsAll(JCModifiers mods, JavacNode node, JavacNode source, Context context) {\n\t\tif (!LombokOptionsFactory.getDelombokOptions(context).getFormatPreferences().generateSuppressWarnings()) return;\n\t\t\n\t\tboolean addJLSuppress = !Boolean.FALSE.equals(node.getAst().readConfiguration(ConfigurationKeys.ADD_SUPPRESSWARNINGS_ANNOTATIONS));\n\t\t\n\t\tif (addJLSuppress) {\n\t\t\tfor (JCAnnotation ann : mods.annotations) {\n\t\t\t\tJCTree type = ann.getAnnotationType();\n\t\t\t\tName n = null;\n\t\t\t\tif (type instanceof JCIdent) n = ((JCIdent) type).name;\n\t\t\t\telse if (type instanceof JCFieldAccess) n = ((JCFieldAccess) type).name;\n\t\t\t\tif (n != null && n.contentEquals(\"SuppressWarnings\")) {\n\t\t\t\t\taddJLSuppress = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (addJLSuppress) addAnnotation(mods, node, source, \"java.lang.SuppressWarnings\", node.getTreeMaker().Literal(\"all\"));\n\t\t\n\t\tif (Boolean.TRUE.equals(node.getAst().readConfiguration(ConfigurationKeys.ADD_FINDBUGS_SUPPRESSWARNINGS_ANNOTATIONS))) {\n\t\t\tJavacTreeMaker maker = node.getTreeMaker();\n\t\t\tJCExpression arg = maker.Assign(maker.Ident(node.toName(\"justification\")), maker.Literal(\"generated code\"));\n\t\t\taddAnnotation(mods, node, source, \"edu.umd.cs.findbugs.annotations.SuppressFBWarnings\", arg);\n\t\t}\n\t}\n\t\n\tpublic static void addGenerated(JCModifiers mods, JavacNode node, JavacNode source, Context context) {\n\t\tif (!LombokOptionsFactory.getDelombokOptions(context).getFormatPreferences().generateGenerated()) return;\n\t\t\n\t\tif (HandlerUtil.shouldAddGenerated(node)) {\n\t\t\taddAnnotation(mods, node, source, \"javax.annotation.Generated\", node.getTreeMaker().Literal(\"lombok\"));\n\t\t}\n\t\tif (Boolean.TRUE.equals(node.getAst().readConfiguration(ConfigurationKeys.ADD_LOMBOK_GENERATED_ANNOTATIONS))) {\n\t\t\taddAnnotation(mods, node, source, \"lombok.Generated\", null);\n\t\t}\n\t}\n\t\n\tpublic static void addAnnotation(JCModifiers mods, JavacNode node, JavacNode source, String annotationTypeFqn, JCExpression arg) {\n\t\tboolean isJavaLangBased;\n\t\tString simpleName; {\n\t\t\tint idx = annotationTypeFqn.lastIndexOf('.');\n\t\t\tsimpleName = idx == -1 ? annotationTypeFqn : annotationTypeFqn.substring(idx + 1);\n\t\t\t\n\t\t\tisJavaLangBased = idx == 9 && annotationTypeFqn.regionMatches(0, \"java.lang.\", 0, 10);\n\t\t}\n\t\t\n\t\tfor (JCAnnotation ann : mods.annotations) {\n\t\t\tJCTree annType = ann.getAnnotationType();\n\t\t\tif (annType instanceof JCIdent) {\n\t\t\t\tName lastPart = ((JCIdent) annType).name;\n\t\t\t\tif (lastPart.contentEquals(simpleName)) return;\n\t\t\t}\n\t\t\t\n\t\t\tif (annType instanceof JCFieldAccess) {\n\t\t\t\tif (annType.toString().equals(annotationTypeFqn)) return;\n\t\t\t}\n\t\t}\n\t\t\n\t\tJavacTreeMaker maker = node.getTreeMaker();\n\t\tJCExpression annType = isJavaLangBased ? genJavaLangTypeRef(node, simpleName) : chainDotsString(node, annotationTypeFqn);\n\t\tList<JCExpression> argList = arg != null ? List.of(arg) : List.<JCExpression>nil();\n\t\tJCAnnotation annotation = recursiveSetGeneratedBy(maker.Annotation(annType, argList), source);\n\t\tmods.annotations = mods.annotations.append(annotation);\n\t}\n\t\n\tstatic JCExpression addCheckerFrameworkReturnsReceiver(JCExpression returnType, JavacTreeMaker maker, JavacNode typeNode, CheckerFrameworkVersion cfv) {\n\t\tif (cfv.generateReturnsReceiver()) {\n\t\t\tJCAnnotation rrAnnotation = maker.Annotation(genTypeRef(typeNode, CheckerFrameworkVersion.NAME__RETURNS_RECEIVER), List.<JCExpression>nil());\n\t\t\treturnType = maker.AnnotatedType(List.of(rrAnnotation), returnType);\n\t\t}\n\t\treturn returnType;\n\t}\n\t\n\tprivate static List<JCTree> addAllButOne(List<JCTree> defs, int idx) {\n\t\tListBuffer<JCTree> out = new ListBuffer<JCTree>();\n\t\tint i = 0;\n\t\tfor (JCTree def : defs) {\n\t\t\tif (i++ != idx) out.append(def);\n\t\t}\n\t\treturn out.toList();\n\t}\n\t\n\t/**\n\t * In javac, dotted access of any kind, from {@code java.lang.String} to {@code var.methodName}\n\t * is represented by a fold-left of {@code Select} nodes with the leftmost string represented by\n\t * a {@code Ident} node. This method generates such an expression.\n\t * <p>\n\t * The position of the generated node(s) will be unpositioned (-1).\n\t * \n\t * For example, maker.Select(maker.Select(maker.Ident(NAME[java]), NAME[lang]), NAME[String]).\n\t * \n\t * @see com.sun.tools.javac.tree.JCTree.JCIdent\n\t * @see com.sun.tools.javac.tree.JCTree.JCFieldAccess\n\t */\n\tpublic static JCExpression chainDots(JavacNode node, String elem1, String elem2, String... elems) {\n\t\treturn chainDots(node, -1, elem1, elem2, elems);\n\t}\n\t\n\tpublic static JCExpression chainDots(JavacNode node, String[] elems) {\n\t\treturn chainDots(node, -1, null, null, elems);\n\t}\n\t\n\tpublic static JCExpression chainDots(JavacNode node, LombokImmutableList<String> elems) {\n\t\tassert elems != null;\n\t\t\n\t\tJavacTreeMaker maker = node.getTreeMaker();\n\t\tJCExpression e = null;\n\t\tfor (String elem : elems) {\n\t\t\tif (e == null) e = maker.Ident(node.toName(elem));\n\t\t\telse e = maker.Select(e, node.toName(elem));\n\t\t}\n\t\treturn e;\n\t}\n\t\n\t/**\n\t * In javac, dotted access of any kind, from {@code java.lang.String} to {@code var.methodName}\n\t * is represented by a fold-left of {@code Select} nodes with the leftmost string represented by\n\t * a {@code Ident} node. This method generates such an expression.\n\t * <p>\n\t * The position of the generated node(s) will be equal to the {@code pos} parameter.\n\t *\n\t * For example, maker.Select(maker.Select(maker.Ident(NAME[java]), NAME[lang]), NAME[String]).\n\t * \n\t * @see com.sun.tools.javac.tree.JCTree.JCIdent\n\t * @see com.sun.tools.javac.tree.JCTree.JCFieldAccess\n\t */\n\tpublic static JCExpression chainDots(JavacNode node, int pos, String elem1, String elem2, String... elems) {\n\t\tassert elems != null;\n\t\t\n\t\tJavacTreeMaker maker = node.getTreeMaker();\n\t\tif (pos != -1) maker = maker.at(pos);\n\t\tJCExpression e = null;\n\t\tif (elem1 != null) e = maker.Ident(node.toName(elem1));\n\t\tif (elem2 != null) e = e == null ? maker.Ident(node.toName(elem2)) : maker.Select(e, node.toName(elem2));\n\t\tfor (int i = 0 ; i < elems.length ; i++) {\n\t\t\te = e == null ? maker.Ident(node.toName(elems[i])) : maker.Select(e, node.toName(elems[i]));\n\t\t}\n\t\t\n\t\tassert e != null;\n\t\t\n\t\treturn e;\n\t}\n\t\n\t/**\n\t * In javac, dotted access of any kind, from {@code java.lang.String} to {@code var.methodName}\n\t * is represented by a fold-left of {@code Select} nodes with the leftmost string represented by\n\t * a {@code Ident} node. This method generates such an expression.\n\t * \n\t * For example, maker.Select(maker.Select(maker.Ident(NAME[java]), NAME[lang]), NAME[String]).\n\t * \n\t * @see com.sun.tools.javac.tree.JCTree.JCIdent\n\t * @see com.sun.tools.javac.tree.JCTree.JCFieldAccess\n\t */\n\tpublic static JCExpression chainDotsString(JavacNode node, String elems) {\n\t\treturn chainDots(node, null, null, elems.split(\"\\\\.\"));\n\t}\n\t\n\t/**\n\t * Searches the given field node for annotations and returns each one that matches the provided regular expression pattern.\n\t * \n\t * Only the simple name is checked - the package and any containing class are ignored.\n\t */\n\tpublic static List<JCAnnotation> findAnnotations(JavacNode fieldNode, Pattern namePattern) {\n\t\tListBuffer<JCAnnotation> result = new ListBuffer<JCAnnotation>();\n\t\tfor (JavacNode child : fieldNode.down()) {\n\t\t\tif (child.getKind() == Kind.ANNOTATION) {\n\t\t\t\tJCAnnotation annotation = (JCAnnotation) child.get();\n\t\t\t\tString name = annotation.annotationType.toString();\n\t\t\t\tint idx = name.lastIndexOf(\".\");\n\t\t\t\tString suspect = idx == -1 ? name : name.substring(idx + 1);\n\t\t\t\tif (namePattern.matcher(suspect).matches()) {\n\t\t\t\t\tresult.append(annotation);\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\t\treturn result.toList();\n\t}\n\t\n\tpublic static String scanForNearestAnnotation(JavacNode node, String... anns) {\n\t\twhile (node != null) {\n\t\t\tfor (JavacNode ann : node.down()) {\n\t\t\t\tif (ann.getKind() != Kind.ANNOTATION) continue;\n\t\t\t\tJCAnnotation a = (JCAnnotation) ann.get();\n\t\t\t\tfor (String annToFind : anns) if (typeMatches(annToFind, node, a.annotationType)) return annToFind;\n\t\t\t}\n\t\t\tnode = node.up();\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\t\n\tpublic static boolean hasNonNullAnnotations(JavacNode node) {\n\t\tfor (JavacNode child : node.down()) {\n\t\t\tif (child.getKind() == Kind.ANNOTATION) {\n\t\t\t\tJCAnnotation annotation = (JCAnnotation) child.get();\n\t\t\t\tfor (String nn : NONNULL_ANNOTATIONS) if (typeMatches(nn, node, annotation.annotationType)) return true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tpublic static boolean hasNonNullAnnotations(JavacNode node, List<JCAnnotation> anns) {\n\t\tif (anns == null) return false;\n\t\tfor (JCAnnotation ann : anns) {\n\t\t\tfor (String nn : NONNULL_ANNOTATIONS) if (typeMatches(nn, node, ann)) return true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Searches the given field node for annotations and returns each one that is 'copyable' (either via configuration or from the base list).\n\t */\n\tpublic static List<JCAnnotation> findCopyableAnnotations(JavacNode node) {\n\t\tJCAnnotation anno = null;\n\t\tString annoName = null;\n\t\tfor (JavacNode child : node.down()) {\n\t\t\tif (child.getKind() == Kind.ANNOTATION) {\n\t\t\t\tif (anno != null) {\n\t\t\t\t\tannoName = \"\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tJCAnnotation annotation = (JCAnnotation) child.get();\n\t\t\t\tannoName = annotation.annotationType.toString();\n\t\t\t\tanno = annotation;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (annoName == null) return List.nil();\n\t\t\n\t\tjava.util.List<TypeName> configuredCopyable = node.getAst().readConfiguration(ConfigurationKeys.COPYABLE_ANNOTATIONS);\n\t\t\n\t\tif (!annoName.isEmpty()) {\n\t\t\tfor (TypeName cn : configuredCopyable) if (cn != null && typeMatches(cn.toString(), node, anno.annotationType)) return List.of(anno);\n\t\t\tfor (String bn : BASE_COPYABLE_ANNOTATIONS) if (typeMatches(bn, node, anno.annotationType)) return List.of(anno);\n\t\t}\n\t\t\n\t\tListBuffer<JCAnnotation> result = new ListBuffer<JCAnnotation>();\n\t\tfor (JavacNode child : node.down()) {\n\t\t\tif (child.getKind() == Kind.ANNOTATION) {\n\t\t\t\tJCAnnotation annotation = (JCAnnotation) child.get();\n\t\t\t\tboolean match = false;\n\t\t\t\tfor (TypeName cn : configuredCopyable) if (cn != null && typeMatches(cn.toString(), node, annotation.annotationType)) {\n\t\t\t\t\tresult.append(annotation);\n\t\t\t\t\tmatch = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!match) for (String bn : BASE_COPYABLE_ANNOTATIONS) if (typeMatches(bn, node, annotation.annotationType)) {\n\t\t\t\t\tresult.append(annotation);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result.toList();\n\t}\n\t\n\t/**\n\t * Searches the given field node for annotations that are specifically intentioned to be copied to the setter.\n\t */\n\tpublic static List<JCAnnotation> findCopyableToSetterAnnotations(JavacNode node) {\n\t\treturn findAnnotationsInList(node, COPY_TO_SETTER_ANNOTATIONS);\n\t}\n\n\t/**\n\t * Searches the given field node for annotations that are specifically intentioned to be copied to the builder's singular method.\n\t */\n\tpublic static List<JCAnnotation> findCopyableToBuilderSingularSetterAnnotations(JavacNode node) {\n\t\treturn findAnnotationsInList(node, COPY_TO_BUILDER_SINGULAR_SETTER_ANNOTATIONS);\n\t}\n\t\n\t/**\n\t * Searches the given field node for annotations that are in the given list, and returns those.\n\t */\n\tprivate static List<JCAnnotation> findAnnotationsInList(JavacNode node, java.util.List<String> annotationsToFind) {\n\t\tJCAnnotation anno = null;\n\t\tString annoName = null;\n\t\tfor (JavacNode child : node.down()) {\n\t\t\tif (child.getKind() == Kind.ANNOTATION) {\n\t\t\t\tif (anno != null) {\n\t\t\t\t\tannoName = \"\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tJCAnnotation annotation = (JCAnnotation) child.get();\n\t\t\t\tannoName = annotation.annotationType.toString();\n\t\t\t\tanno = annotation;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (annoName == null) return List.nil();\n\t\t\n\t\tif (!annoName.isEmpty()) {\n\t\t\tfor (String bn : annotationsToFind) if (typeMatches(bn, node, anno.annotationType)) return List.of(anno);\n\t\t}\n\t\t\n\t\tListBuffer<JCAnnotation> result = new ListBuffer<JCAnnotation>();\n\t\tfor (JavacNode child : node.down()) {\n\t\t\tif (child.getKind() == Kind.ANNOTATION) {\n\t\t\t\tJCAnnotation annotation = (JCAnnotation) child.get();\n\t\t\t\tboolean match = false;\n\t\t\t\tif (!match) for (String bn : annotationsToFind) if (typeMatches(bn, node, annotation.annotationType)) {\n\t\t\t\t\tresult.append(annotation);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result.toList();\n\t}\n\t\n\t/**\n\t * Generates a new statement that checks if the given variable is null, and if so, throws a configured exception with the\n\t * variable name as message.\n\t */\n\tpublic static JCStatement generateNullCheck(JavacTreeMaker maker, JavacNode variable, JavacNode source) {\n\t\treturn generateNullCheck(maker, (JCVariableDecl) variable.get(), source);\n\t}\n\t\n\t/**\n\t * Generates a new statement that checks if the given local is null, and if so, throws a configured exception with the\n\t * local variable name as message. \n\t */\n\tpublic static JCStatement generateNullCheck(JavacTreeMaker maker, JCExpression typeNode, Name varName, JavacNode source, String customMessage) {\n\t\tNullCheckExceptionType exceptionType = source.getAst().readConfiguration(ConfigurationKeys.NON_NULL_EXCEPTION_TYPE);\n\t\tif (exceptionType == null) exceptionType = NullCheckExceptionType.NULL_POINTER_EXCEPTION;\n\t\t\n\t\tif (typeNode != null && isPrimitive(typeNode)) return null;\n\t\tJCLiteral message = maker.Literal(exceptionType.toExceptionMessage(varName.toString(), customMessage));\n\t\t\n\t\tLombokImmutableList<String> method = exceptionType.getMethod();\n\t\tif (method != null) {\n\t\t\treturn maker.Exec(maker.Apply(List.<JCExpression>nil(), chainDots(source, method), List.of(maker.Ident(varName), message)));\n\t\t}\n\t\t\n\t\tif (exceptionType == NullCheckExceptionType.ASSERTION) {\n\t\t\treturn maker.Assert(maker.Binary(CTC_NOT_EQUAL, maker.Ident(varName), maker.Literal(CTC_BOT, null)), message);\n\t\t}\n\t\t\n\t\tJCExpression exType = genTypeRef(source, exceptionType.getExceptionType());\n\t\tJCExpression exception = maker.NewClass(null, List.<JCExpression>nil(), exType, List.<JCExpression>of(message), null);\n\t\tJCStatement throwStatement = maker.Throw(exception);\n\t\tJCBlock throwBlock = maker.Block(0, List.of(throwStatement));\n\t\treturn maker.If(maker.Binary(CTC_EQUAL, maker.Ident(varName), maker.Literal(CTC_BOT, null)), throwBlock, null);\n\t}\n\t\n\t/**\n\t * Generates a new statement that checks if the given variable is null, and if so, throws a configured exception with the\n\t * variable name as message. \n\t * \n\t * This is a special case method reserved for use when the provided declaration differs from the\n\t * variable's declaration, i.e. in a constructor or setter where the local parameter is named the same but with the prefix\n\t * stripped as a result of @Accessors.prefix.\n\t */\n\tpublic static JCStatement generateNullCheck(JavacTreeMaker maker, JCVariableDecl varDecl, JavacNode source) {\n\t\treturn generateNullCheck(maker, varDecl.vartype, varDecl.name, source, null);\n\t}\n\t\n\t/**\n\t * Given a list of field names and a node referring to a type, finds each name in the list that does not match a field within the type.\n\t */\n\tpublic static List<Integer> createListOfNonExistentFields(List<String> list, JavacNode type, boolean excludeStandard, boolean excludeTransient) {\n\t\tboolean[] matched = new boolean[list.size()];\n\t\t\n\t\tfor (JavacNode child : type.down()) {\n\t\t\tif (list.isEmpty()) break;\n\t\t\tif (child.getKind() != Kind.FIELD) continue;\n\t\t\tJCVariableDecl field = (JCVariableDecl)child.get();\n\t\t\tif (excludeStandard) {\n\t\t\t\tif ((field.mods.flags & Flags.STATIC) != 0) continue;\n\t\t\t\tif (field.name.toString().startsWith(\"$\")) continue;\n\t\t\t}\n\t\t\tif (excludeTransient && (field.mods.flags & Flags.TRANSIENT) != 0) continue;\n\t\t\t\n\t\t\tint idx = list.indexOf(child.getName());\n\t\t\tif (idx > -1) matched[idx] = true;\n\t\t}\n\t\t\n\t\tListBuffer<Integer> problematic = new ListBuffer<Integer>();\n\t\tfor (int i = 0 ; i < list.size() ; i++) {\n\t\t\tif (!matched[i]) problematic.append(i);\n\t\t}\n\t\t\n\t\treturn problematic.toList();\n\t}\n\t\n\tstatic List<JCAnnotation> unboxAndRemoveAnnotationParameter(JCAnnotation ast, String parameterName, String errorName, JavacNode annotationNode) {\n\t\tListBuffer<JCExpression> params = new ListBuffer<JCExpression>();\n\t\tListBuffer<JCAnnotation> result = new ListBuffer<JCAnnotation>();\n\t\t\n\t\touter:\n\t\tfor (JCExpression param : ast.args) {\n\t\t\tboolean allowRaw;\n\t\t\tString nameOfParam = \"value\";\n\t\t\tJCExpression valueOfParam = null;\n\t\t\tif (param instanceof JCAssign) {\n\t\t\t\tJCAssign assign = (JCAssign) param;\n\t\t\t\tif (assign.lhs instanceof JCIdent) {\n\t\t\t\t\tJCIdent ident = (JCIdent) assign.lhs;\n\t\t\t\t\tnameOfParam = ident.name.toString();\n\t\t\t\t}\n\t\t\t\tvalueOfParam = assign.rhs;\n\t\t\t}\n\t\t\t\n\t\t\t/* strip trailing underscores */ {\n\t\t\t\tint lastIdx;\n\t\t\t\tfor (lastIdx = nameOfParam.length() ; lastIdx > 0; lastIdx--) {\n\t\t\t\t\tif (nameOfParam.charAt(lastIdx - 1) != '_') break;\n\t\t\t\t}\n\t\t\t\tallowRaw = lastIdx < nameOfParam.length();\n\t\t\t\tnameOfParam = nameOfParam.substring(0, lastIdx);\n\t\t\t}\n\t\t\t\n\t\t\tif (!parameterName.equals(nameOfParam)) {\n\t\t\t\tparams.append(param);\n\t\t\t\tcontinue outer;\n\t\t\t}\n\t\t\t\n\t\t\tint endPos = Javac.getEndPosition(param.pos(), (JCCompilationUnit) annotationNode.top().get());\n\t\t\tannotationNode.getAst().removeFromDeferredDiagnostics(param.pos, endPos);\n\t\t\t\n\t\t\tif (valueOfParam instanceof JCAnnotation) {\n\t\t\t\tString dummyAnnotationName = ((JCAnnotation) valueOfParam).annotationType.toString();\n\t\t\t\tdummyAnnotationName = dummyAnnotationName.replace(\"_\", \"\").replace(\"$\", \"\").replace(\"x\", \"\").replace(\"X\", \"\");\n\t\t\t\tif (dummyAnnotationName.length() > 0) {\n\t\t\t\t\tif (allowRaw) {\n\t\t\t\t\t\tresult.append((JCAnnotation) valueOfParam);\n\t\t\t\t\t} else {\n\t\t\t\t\t\taddError(errorName, annotationNode);\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (JCExpression expr : ((JCAnnotation) valueOfParam).args) {\n\t\t\t\t\t\tif (expr instanceof JCAssign && ((JCAssign) expr).lhs instanceof JCIdent) {\n\t\t\t\t\t\t\tJCIdent id = (JCIdent) ((JCAssign) expr).lhs;\n\t\t\t\t\t\t\tif (\"value\".equals(id.name.toString())) {\n\t\t\t\t\t\t\t\texpr = ((JCAssign) expr).rhs;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\taddError(errorName, annotationNode);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (expr instanceof JCAnnotation) {\n\t\t\t\t\t\t\tresult.append((JCAnnotation) expr);\n\t\t\t\t\t\t} else if (expr instanceof JCNewArray) {\n\t\t\t\t\t\t\tfor (JCExpression expr2 : ((JCNewArray) expr).elems) {\n\t\t\t\t\t\t\t\tif (expr2 instanceof JCAnnotation) {\n\t\t\t\t\t\t\t\t\tresult.append((JCAnnotation) expr2);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\taddError(errorName, annotationNode);\n\t\t\t\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\taddError(errorName, annotationNode);\n\t\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (valueOfParam instanceof JCNewArray) {\n\t\t\t\tJCNewArray arr = (JCNewArray) valueOfParam;\n\t\t\t\tif (arr.elems.isEmpty()) {\n\t\t\t\t\t// Just remove it, this is always fine.\n\t\t\t\t} else if (allowRaw) {\n\t\t\t\t\tfor (JCExpression jce : arr.elems) {\n\t\t\t\t\t\tif (jce instanceof JCAnnotation) result.append((JCAnnotation) jce);\n\t\t\t\t\t\telse addError(errorName, annotationNode);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\taddError(errorName, annotationNode);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\taddError(errorName, annotationNode);\n\t\t\t}\n\t\t}\n\t\tfor (JCAnnotation annotation : result) {\n\t\t\tclearTypes(annotation);\n\t\t}\n\t\tast.args = params.toList();\n\t\treturn result.toList();\n\t}\n\t\n\t/**\n\t * Removes all type information from the provided tree.\n\t */\n\tprivate static void clearTypes(JCTree tree) {\n\t\ttree.accept(new TreeScanner() {\n\t\t\t@Override public void scan(JCTree tree) {\n\t\t\t\tif (tree == null) return;\n\t\t\t\ttree.type = null;\n\t\t\t\tsuper.scan(tree);\n\t\t\t}\n\t\t\t@Override public void visitClassDef(JCClassDecl tree) {\n\t\t\t\ttree.sym = null;\n\t\t\t\tsuper.visitClassDef(tree);\n\t\t\t}\n\t\t\t@Override public void visitMethodDef(JCMethodDecl tree) {\n\t\t\t\ttree.sym = null;\n\t\t\t\tsuper.visitMethodDef(tree);\n\t\t\t}\n\t\t\t@Override public void visitVarDef(JCVariableDecl tree) {\n\t\t\t\ttree.sym = null;\n\t\t\t\tsuper.visitVarDef(tree);\n\t\t\t}\n\t\t\t@Override public void visitSelect(JCFieldAccess tree) {\n\t\t\t\ttree.sym = null;\n\t\t\t\tsuper.visitSelect(tree);\n\t\t\t}\n\t\t\t@Override public void visitIdent(JCIdent tree) {\n\t\t\t\ttree.sym = null;\n\t\t\t\tsuper.visitIdent(tree);\n\t\t\t}\n\t\t\t@Override public void visitAnnotation(JCAnnotation tree) {\n\t\t\t\tJCAnnotationReflect.setAttribute(tree, null);\n\t\t\t\tsuper.visitAnnotation(tree);\n\t\t\t}\n\t\t});\n\t}\n\t\n\tprivate static void addError(String errorName, JavacNode node) {\n\t\tif (node.getLatestJavaSpecSupported() < 8) {\n\t\t\tnode.addError(\"The correct format up to JDK7 is \" + errorName + \"=@__({@SomeAnnotation, @SomeOtherAnnotation}))\");\n\t\t} else {\n\t\t\tnode.addError(\"The correct format for JDK8+ is \" + errorName + \"_={@SomeAnnotation, @SomeOtherAnnotation})\");\n\t\t}\n\t}\n\t\n\tpublic static List<JCTypeParameter> copyTypeParams(JavacNode source, List<JCTypeParameter> params) {\n\t\tif (params == null || params.isEmpty()) return params;\n\t\tListBuffer<JCTypeParameter> out = new ListBuffer<JCTypeParameter>();\n\t\tJavacTreeMaker maker = source.getTreeMaker();\n\t\tfor (JCTypeParameter tp : params) {\n\t\t\tList<JCExpression> bounds = tp.bounds;\n\t\t\tif (bounds != null && !bounds.isEmpty()) {\n\t\t\t\tListBuffer<JCExpression> boundsCopy = new ListBuffer<JCExpression>();\n\t\t\t\tfor (JCExpression expr : tp.bounds) {\n\t\t\t\t\tboundsCopy.append(cloneType(maker, expr, source));\n\t\t\t\t}\n\t\t\t\tbounds = boundsCopy.toList();\n\t\t\t}\n\t\t\tout.append(maker.TypeParameter(tp.name, bounds));\n\t\t}\n\t\treturn out.toList();\n\t}\n\t\n\tpublic static List<JCAnnotation> getTypeUseAnnotations(JCExpression from) {\n\t\tif (!JCAnnotatedTypeReflect.is(from)) return List.nil();\n\t\treturn JCAnnotatedTypeReflect.getAnnotations(from);\n\t}\n\t\n\tpublic static JCExpression removeTypeUseAnnotations(JCExpression from) {\n\t\tif (!JCAnnotatedTypeReflect.is(from)) return from;\n\t\treturn JCAnnotatedTypeReflect.getUnderlyingType(from);\n\t}\n\t\n\tpublic static JCExpression namePlusTypeParamsToTypeReference(JavacTreeMaker maker, JavacNode type, List<JCTypeParameter> params) {\n\t\tJCClassDecl td = (JCClassDecl) type.get();\n\t\tboolean instance = (td.mods.flags & Flags.STATIC) == 0;\n\t\treturn namePlusTypeParamsToTypeReference(maker, type.up(), td.name, instance, params, List.<JCAnnotation>nil());\n\t}\n\t\n\tpublic static JCExpression namePlusTypeParamsToTypeReference(JavacTreeMaker maker, JavacNode type, List<JCTypeParameter> params, List<JCAnnotation> annotations) {\n\t\tJCClassDecl td = (JCClassDecl) type.get();\n\t\tboolean instance = (td.mods.flags & Flags.STATIC) == 0;\n\t\treturn namePlusTypeParamsToTypeReference(maker, type.up(), td.name, instance, params, annotations);\n\t}\n\t\n\tpublic static JCExpression namePlusTypeParamsToTypeReference(JavacTreeMaker maker, JavacNode parentType, Name typeName, boolean instance, List<JCTypeParameter> params) {\n\t\treturn namePlusTypeParamsToTypeReference(maker, parentType, typeName, instance, params, List.<JCAnnotation>nil());\n\t}\n\t\n\tpublic static JCExpression namePlusTypeParamsToTypeReference(JavacTreeMaker maker, JavacNode parentType, Name typeName, boolean instance, List<JCTypeParameter> params, List<JCAnnotation> annotations) {\n\t\tJCExpression r = null;\n\t\tif (parentType != null && parentType.getKind() == Kind.TYPE && !parentType.getName().isEmpty()) {\n\t\t\tJCClassDecl td = (JCClassDecl) parentType.get();\n\t\t\tboolean outerInstance = instance && ((td.mods.flags & Flags.STATIC) == 0);\n\t\t\tList<JCTypeParameter> outerParams = instance ? td.typarams : List.<JCTypeParameter>nil();\n\t\t\tr = namePlusTypeParamsToTypeReference(maker, parentType.up(), td.name, outerInstance, outerParams, List.<JCAnnotation>nil());\n\t\t}\n\t\t\n\t\tr = r == null ? maker.Ident(typeName) : maker.Select(r, typeName);\n\t\tif (!annotations.isEmpty()) r = JCAnnotatedTypeReflect.create(annotations, r);\n\t\tif (!params.isEmpty()) r = maker.TypeApply(r, typeParameterNames(maker, params));\n\t\treturn r;\n\t}\n\t\n\tpublic static List<JCExpression> typeParameterNames(JavacTreeMaker maker, List<JCTypeParameter> params) {\n\t\tListBuffer<JCExpression> typeArgs = new ListBuffer<JCExpression>();\n\t\tfor (JCTypeParameter param : params) {\n\t\t\ttypeArgs.append(maker.Ident(param.name));\n\t\t}\n\t\treturn typeArgs.toList();\n\t}\n\t\n\tpublic static void sanityCheckForMethodGeneratingAnnotationsOnBuilderClass(JavacNode typeNode, JavacNode errorNode) {\n\t\tList<String> disallowed = List.nil();\n\t\tfor (JavacNode child : typeNode.down()) {\n\t\t\tfor (String annType : INVALID_ON_BUILDERS) {\n\t\t\t\tif (annotationTypeMatches(annType, child)) {\n\t\t\t\t\tint lastIndex = annType.lastIndexOf('.');\n\t\t\t\t\tdisallowed = disallowed.append(lastIndex == -1 ? annType : annType.substring(lastIndex + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint size = disallowed.size();\n\t\tif (size == 0) return;\n\t\tif (size == 1) {\n\t\t\terrorNode.addError(\"@\" + disallowed.head + \" is not allowed on builder classes.\");\n\t\t\treturn;\n\t\t}\n\t\tStringBuilder out = new StringBuilder();\n\t\tfor (String a : disallowed) out.append(\"@\").append(a).append(\", \");\n\t\tout.setLength(out.length() - 2);\n\t\terrorNode.addError(out.append(\" are not allowed on builder classes.\").toString());\n\t}\n\t\n\tstatic List<JCAnnotation> copyAnnotations(List<? extends JCExpression> in) {\n\t\tListBuffer<JCAnnotation> out = new ListBuffer<JCAnnotation>();\n\t\tfor (JCExpression expr : in) {\n\t\t\tif (!(expr instanceof JCAnnotation)) continue;\n\t\t\tout.append((JCAnnotation) expr.clone());\n\t\t}\n\t\treturn out.toList();\n\t}\n\t\n\tstatic List<JCAnnotation> mergeAnnotations(List<JCAnnotation> a, List<JCAnnotation> b) {\n\t\tif (a == null || a.isEmpty()) return b;\n\t\tif (b == null || b.isEmpty()) return a;\n\t\tListBuffer<JCAnnotation> out = new ListBuffer<JCAnnotation>();\n\t\tfor (JCAnnotation ann : a) out.append(ann);\n\t\tfor (JCAnnotation ann : b) out.append(ann);\n\t\treturn out.toList();\n\t}\n\t\n\t/**\n\t * Returns {@code true} if the provided node is an actual class and not some other type declaration (so, not an annotation definition, interface, enum, or record).\n\t */\n\tpublic static boolean isClass(JavacNode typeNode) {\n\t\treturn isClassAndDoesNotHaveFlags(typeNode, Flags.INTERFACE | Flags.ENUM | Flags.ANNOTATION | RECORD);\n\t}\n\t\n\t/**\n\t * Returns {@code true} if the provided node is an actual class or enum and not some other type declaration (so, not an annotation definition, interface, or record).\n\t */\n\tpublic static boolean isClassOrEnum(JavacNode typeNode) {\n\t\treturn isClassAndDoesNotHaveFlags(typeNode, Flags.INTERFACE | Flags.ANNOTATION | RECORD);\n\t}\n\t\n\tpublic static boolean isClassOrEnumOrInterface(JavacNode typeNode) {\n\t\treturn isClassAndDoesNotHaveFlags(typeNode, Flags.ANNOTATION | RECORD);\n\t}\n\t\n\t/**\n\t * Returns {@code true} if the provided node is an actual class, an enum or a record and not some other type declaration (so, not an annotation definition or interface).\n\t */\n\tpublic static boolean isClassEnumOrRecord(JavacNode typeNode) {\n\t\treturn isClassAndDoesNotHaveFlags(typeNode, Flags.INTERFACE | Flags.ANNOTATION);\n\t}\n\t\n\t/**\n\t * Returns {@code true} if the provided node is a record declaration (so, not an annotation definition, interface, enum, or plain class).\n\t */\n\tpublic static boolean isRecord(JavacNode typeNode) {\n\t\treturn typeNode.getKind() == Kind.TYPE && (((JCClassDecl) typeNode.get()).mods.flags & RECORD) != 0;\n\t}\n\t\n\tpublic static boolean isClassAndDoesNotHaveFlags(JavacNode typeNode, long flags) {\n\t\tJCClassDecl typeDecl = null;\n\t\tif (typeNode.get() instanceof JCClassDecl) typeDecl = (JCClassDecl) typeNode.get();\n\t\telse return false;\n\t\t\n\t\tlong typeDeclflags = typeDecl == null ? 0 : typeDecl.mods.flags;\n\t\treturn (typeDeclflags & flags) == 0;\n\t}\n\t\n\t/**\n\t * Returns {@code true} if the provided node supports static methods and types (top level or static class)\n\t */\n\tpublic static boolean isStaticAllowed(JavacNode typeNode) {\n\t\treturn typeNode.isStatic() || typeNode.up() == null || typeNode.up().getKind() == Kind.COMPILATION_UNIT || isRecord(typeNode);\n\t}\n\t\n\tpublic static JavacNode upToTypeNode(JavacNode node) {\n\t\tif (node == null) throw new NullPointerException(\"node\");\n\t\twhile ((node != null) && !(node.get() instanceof JCClassDecl)) node = node.up();\n\t\t\n\t\treturn node;\n\t}\n\t\n\tpublic static List<JCExpression> cloneTypes(JavacTreeMaker maker, List<JCExpression> in, JavacNode source) {\n\t\tif (in.isEmpty()) return List.nil();\n\t\tif (in.size() == 1) return List.of(cloneType(maker, in.get(0), source));\n\t\tListBuffer<JCExpression> lb = new ListBuffer<JCExpression>();\n\t\tfor (JCExpression expr : in) lb.append(cloneType(maker, expr, source));\n\t\treturn lb.toList();\n\t}\n\t\n\t/**\n\t * Creates a full clone of a given javac AST type node. Every part is cloned (every identifier, every select, every wildcard, every type apply, every type_use annotation).\n\t * \n\t * If there's any node in the tree that we don't know how to clone, that part isn't cloned. However, we wouldn't know what could possibly show up that we\n\t * can't currently clone; that's just a safeguard.\n\t * \n\t * This should be used if the type looks the same in the code, but resolves differently. For example, a static method that has some generics in it named after\n\t * the class's own parameter, but as its a static method, the static method's notion of {@code T} is different from the class notion of {@code T}. If you're duplicating\n\t * a type used in the class context, you need to use this method.\n\t */\n\tpublic static JCExpression cloneType(JavacTreeMaker maker, JCExpression in, JavacNode source) {\n\t\tJCExpression out = cloneType0(maker, in);\n\t\tif (out != null) recursiveSetGeneratedBy(out, source);\n\t\treturn out;\n\t}\n\t\n\tprivate static JCExpression cloneType0(JavacTreeMaker maker, JCTree in) {\n\t\tif (in == null) return null;\n\t\t\n\t\tif (in instanceof JCPrimitiveTypeTree) {\n\t\t\treturn maker.TypeIdent(TypeTag.typeTag(in));\n\t\t}\n\t\t\n\t\tif (in instanceof JCIdent) {\n\t\t\treturn maker.Ident(((JCIdent) in).name);\n\t\t}\n\t\t\n\t\tif (in instanceof JCFieldAccess) {\n\t\t\tJCFieldAccess fa = (JCFieldAccess) in;\n\t\t\treturn maker.Select(cloneType0(maker, fa.selected), fa.name);\n\t\t}\n\t\t\n\t\tif (in instanceof JCArrayTypeTree) {\n\t\t\tJCArrayTypeTree att = (JCArrayTypeTree) in;\n\t\t\treturn maker.TypeArray(cloneType0(maker, att.elemtype));\n\t\t}\n\t\t\n\t\tif (in instanceof JCTypeApply) {\n\t\t\tJCTypeApply ta = (JCTypeApply) in;\n\t\t\tListBuffer<JCExpression> lb = new ListBuffer<JCExpression>();\n\t\t\tfor (JCExpression typeArg : ta.arguments) {\n\t\t\t\tlb.append(cloneType0(maker, typeArg));\n\t\t\t}\n\t\t\treturn maker.TypeApply(cloneType0(maker, ta.clazz), lb.toList());\n\t\t}\n\t\t\n\t\tif (in instanceof JCWildcard) {\n\t\t\tJCWildcard w = (JCWildcard) in;\n\t\t\tJCExpression newInner = cloneType0(maker, w.inner);\n\t\t\tTypeBoundKind newKind;\n\t\t\tswitch (w.getKind()) {\n\t\t\tcase SUPER_WILDCARD:\n\t\t\t\tnewKind = maker.TypeBoundKind(BoundKind.SUPER);\n\t\t\t\tbreak;\n\t\t\tcase EXTENDS_WILDCARD:\n\t\t\t\tnewKind = maker.TypeBoundKind(BoundKind.EXTENDS);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\tcase UNBOUNDED_WILDCARD:\n\t\t\t\tnewKind = maker.TypeBoundKind(BoundKind.UNBOUND);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn maker.Wildcard(newKind, newInner);\n\t\t}\n\t\t\n\t\tif (JCAnnotatedTypeReflect.is(in)) {\n\t\t\tJCExpression underlyingType = cloneType0(maker, JCAnnotatedTypeReflect.getUnderlyingType(in));\n\t\t\tList<JCAnnotation> anns = copyAnnotations(JCAnnotatedTypeReflect.getAnnotations(in));\n\t\t\treturn JCAnnotatedTypeReflect.create(anns, underlyingType);\n\t\t}\n\t\t\n\t\t// This is somewhat unsafe, but it's better than outright throwing an exception here. Returning null will just cause an exception down the pipeline.\n\t\treturn (JCExpression) in;\n\t}\n\t\n\tpublic static enum CopyJavadoc {\n\t\tVERBATIM {\n\t\t\t@Override public String apply(final JCCompilationUnit cu, final JavacNode node) {\n\t\t\t\treturn Javac.getDocComment(cu, node.get());\n\t\t\t}\n\t\t},\n\t\tGETTER {\n\t\t\t@Override public String apply(final JCCompilationUnit cu, final JavacNode node) {\n\t\t\t\tfinal JCTree n = node.get();\n\t\t\t\tString javadoc = Javac.getDocComment(cu, n);\n\t\t\t\t// step 1: Check if there is a 'GETTER' section. If yes, that becomes the new method's javadoc.\n\t\t\t\tString out = getJavadocSection(javadoc, \"GETTER\");\n\t\t\t\tfinal boolean sectionBased = out != null;\n\t\t\t\tif (!sectionBased) {\n\t\t\t\t\tout = stripLinesWithTagFromJavadoc(stripSectionsFromJavadoc(javadoc), JavadocTag.PARAM);\n\t\t\t\t}\n\t\t\t\tnode.getAst().cleanupTask(\"javadocfilter-getter\", n, new CleanupTask() {\n\t\t\t\t\t@Override public void cleanup() {\n\t\t\t\t\t\tString javadoc = Javac.getDocComment(cu, n);\n\t\t\t\t\t\tif (javadoc == null || javadoc.isEmpty()) return;\n\t\t\t\t\t\tjavadoc = stripSectionsFromJavadoc(javadoc);\n\t\t\t\t\t\tif (!sectionBased) {\n\t\t\t\t\t\t\tjavadoc = stripLinesWithTagFromJavadoc(stripSectionsFromJavadoc(javadoc), JavadocTag.RETURN);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tJavac.setDocComment(cu, n, javadoc);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn out;\n\t\t\t}\n\t\t},\n\t\tSETTER {\n\t\t\t@Override public String apply(final JCCompilationUnit cu, final JavacNode node) {\n\t\t\t\treturn applySetter(cu, node, \"SETTER\");\n\t\t\t}\n\t\t},\n\t\tWITH {\n\t\t\t@Override public String apply(final JCCompilationUnit cu, final JavacNode node) {\n\t\t\t\treturn addReturnsUpdatedSelfIfNeeded(applySetter(cu, node, \"WITH|WITHER\"));\n\t\t\t}\n\t\t},\n\t\tWITH_BY {\n\t\t\t@Override public String apply(final JCCompilationUnit cu, final JavacNode node) {\n\t\t\t\treturn applySetter(cu, node, \"WITHBY|WITH_BY\");\n\t\t\t}\n\t\t};\n\t\t\n\t\tpublic abstract String apply(final JCCompilationUnit cu, final JavacNode node);\n\t\t\n\t\tprivate static String applySetter(final JCCompilationUnit cu, JavacNode node, String sectionName) {\n\t\t\tfinal JCTree n = node.get();\n\t\t\tString javadoc = Javac.getDocComment(cu, n);\n\t\t\t// step 1: Check if there is a 'SETTER' section. If yes, that becomes the new method's javadoc.\n\t\t\tString out = getJavadocSection(javadoc, sectionName);\n\t\t\tfinal boolean sectionBased = out != null;\n\t\t\tif (!sectionBased) {\n\t\t\t\tout = stripLinesWithTagFromJavadoc(stripSectionsFromJavadoc(javadoc), JavadocTag.RETURN);\n\t\t\t}\n\t\t\tnode.getAst().cleanupTask(\"javadocfilter-setter\", n, new CleanupTask() {\n\t\t\t\t@Override public void cleanup() {\n\t\t\t\t\tString javadoc = Javac.getDocComment(cu, n);\n\t\t\t\t\tif (javadoc == null || javadoc.isEmpty()) return;\n\t\t\t\t\tjavadoc = stripSectionsFromJavadoc(javadoc);\n\t\t\t\t\tif (!sectionBased) {\n\t\t\t\t\t\tjavadoc = stripLinesWithTagFromJavadoc(stripSectionsFromJavadoc(javadoc), JavadocTag.PARAM);\n\t\t\t\t\t}\n\t\t\t\t\tJavac.setDocComment(cu, n, javadoc);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn shouldReturnThis(node, JavacHandlerUtil.getAccessorsForField(node)) ? addReturnsThisIfNeeded(out) : out;\n\t\t}\n\t}\n\t\n\tpublic static void copyJavadoc(JavacNode from, JCTree to, CopyJavadoc copyMode) {\n\t\tcopyJavadoc(from, to, copyMode, false);\n\t}\n\t\n\t/**\n\t * Copies javadoc on one node to the other.\n\t * \n\t * in 'GETTER' copyMode, first a 'GETTER' segment is searched for. If it exists, that will become the javadoc for the 'to' node, and this section is\n\t * stripped out of the 'from' node. If no 'GETTER' segment is found, then the entire javadoc is taken minus any {@code @param} lines and other sections.\n\t * any {@code @return} lines are stripped from 'from'.\n\t * \n\t * in 'SETTER' mode, stripping works similarly to 'GETTER' mode, except {@code param} are copied and stripped from the original and {@code @return} are skipped.\n\t */\n\tpublic static void copyJavadoc(JavacNode from, JCTree to, CopyJavadoc copyMode, boolean forceAddReturn) {\n\t\tif (copyMode == null) copyMode = CopyJavadoc.VERBATIM;\n\t\ttry {\n\t\t\tJCCompilationUnit cu = ((JCCompilationUnit) from.top().get());\n\t\t\tString newJavadoc = copyMode.apply(cu, from);\n\t\t\tif (forceAddReturn) {\n\t\t\t\tnewJavadoc = addReturnsThisIfNeeded(newJavadoc);\n\t\t\t}\n\t\t\tJavac.setDocComment(cu, to, newJavadoc);\n\t\t} catch (Exception ignore) {}\n\t}\n\t\n\tpublic static boolean isDirectDescendantOfObject(JavacNode typeNode) {\n\t\tif (!(typeNode.get() instanceof JCClassDecl)) throw new IllegalArgumentException(\"not a type node\");\n\t\tJCTree extending = Javac.getExtendsClause((JCClassDecl) typeNode.get());\n\t\tif (extending == null) return true;\n\t\tString p = extending.toString();\n\t\treturn p.equals(\"Object\") || p.equals(\"java.lang.Object\");\n\t}\n\t\n\tpublic static void createRelevantNullableAnnotation(JavacNode typeNode, JCMethodDecl mth) {\n\t\tNullAnnotationLibrary lib = typeNode.getAst().readConfiguration(ConfigurationKeys.ADD_NULL_ANNOTATIONS);\n\t\tif (lib == null) return;\n\t\tapplyAnnotationToMethodDecl(typeNode, mth, lib.getNullableAnnotation(), lib.isTypeUse());\n\t}\n\t\n\tpublic static void createRelevantNonNullAnnotation(JavacNode typeNode, JCMethodDecl mth) {\n\t\tNullAnnotationLibrary lib = typeNode.getAst().readConfiguration(ConfigurationKeys.ADD_NULL_ANNOTATIONS);\n\t\tif (lib == null) return;\n\t\tapplyAnnotationToMethodDecl(typeNode, mth, lib.getNonNullAnnotation(), lib.isTypeUse());\n\t}\n\t\n\tpublic static void createRelevantNonNullAnnotation(JavacNode typeNode, JCVariableDecl arg) {\n\t\tNullAnnotationLibrary lib = typeNode.getAst().readConfiguration(ConfigurationKeys.ADD_NULL_ANNOTATIONS);\n\t\tif (lib == null) return;\n\t\t\n\t\tapplyAnnotationToVarDecl(typeNode, arg, lib.getNonNullAnnotation(), lib.isTypeUse());\n\t}\n\t\n\tpublic static void createRelevantNullableAnnotation(JavacNode typeNode, JCVariableDecl arg) {\n\t\tNullAnnotationLibrary lib = typeNode.getAst().readConfiguration(ConfigurationKeys.ADD_NULL_ANNOTATIONS);\n\t\tif (lib == null) return;\n\t\t\n\t\tapplyAnnotationToVarDecl(typeNode, arg, lib.getNullableAnnotation(), lib.isTypeUse());\n\t}\n\t\n\tprivate static void applyAnnotationToMethodDecl(JavacNode typeNode, JCMethodDecl mth, String annType, boolean typeUse) {\n\t\tif (annType == null) return;\n\t\tJavacTreeMaker maker = typeNode.getTreeMaker();\n\t\t\n\t\tJCAnnotation m = maker.Annotation(genTypeRef(typeNode, annType), List.<JCExpression>nil());\n\t\tif (typeUse) {\n\t\t\tJCExpression resType = mth.restype;\n\t\t\tif (resType instanceof JCTypeApply) {\n\t\t\t\tJCTypeApply ta = (JCTypeApply) resType;\n\t\t\t\tif (ta.clazz instanceof JCFieldAccess) {\n\t\t\t\t\tmth.restype = maker.TypeApply(maker.AnnotatedType(List.of(m), ta.clazz), ta.arguments);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tresType = ta.clazz;\n\t\t\t}\n\t\t\t\n\t\t\tif (resType instanceof JCFieldAccess || resType instanceof JCArrayTypeTree) {\n\t\t\t\tmth.restype = maker.AnnotatedType(List.of(m), resType);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif (JCAnnotatedTypeReflect.is(resType)) {\n\t\t\t\tList<JCAnnotation> annotations = JCAnnotatedTypeReflect.getAnnotations(resType);\n\t\t\t\tJCAnnotatedTypeReflect.setAnnotations(resType, annotations.prepend(m));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif (resType instanceof JCPrimitiveTypeTree || resType instanceof JCIdent) {\n\t\t\t\tmth.mods.annotations = mth.mods.annotations == null ? List.of(m) : mth.mods.annotations.prepend(m);\n\t\t\t}\n\t\t} else {\n\t\t\tmth.mods.annotations = mth.mods.annotations == null ? List.of(m) : mth.mods.annotations.prepend(m);\n\t\t}\n\t}\n\t\n\tprivate static void applyAnnotationToVarDecl(JavacNode typeNode, JCVariableDecl arg, String annType, boolean typeUse) {\n\t\tif (annType == null) return;\n\t\tJavacTreeMaker maker = typeNode.getTreeMaker();\n\t\t\n\t\tJCAnnotation m = maker.Annotation(genTypeRef(typeNode, annType), List.<JCExpression>nil());\n\t\tif (typeUse) {\n\t\t\tJCExpression varType = arg.vartype;\n\t\t\tJCTypeApply ta = null;\n\t\t\tif (varType instanceof JCTypeApply) {\n\t\t\t\tta = (JCTypeApply) varType;\n\t\t\t\tvarType = ta.clazz;\n\t\t\t}\n\t\t\t\n\t\t\tif (varType instanceof JCFieldAccess || varType instanceof JCArrayTypeTree) {\n\t\t\t\tvarType = maker.AnnotatedType(List.of(m), varType);\n\t\t\t\tif (ta != null) ta.clazz = varType;\n\t\t\t\telse arg.vartype = varType;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif (JCAnnotatedTypeReflect.is(varType)) {\n\t\t\t\tList<JCAnnotation> annotations = JCAnnotatedTypeReflect.getAnnotations(varType);\n\t\t\t\tJCAnnotatedTypeReflect.setAnnotations(varType, annotations.prepend(m));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif (varType instanceof JCPrimitiveTypeTree || varType instanceof JCIdent) {\n\t\t\t\targ.mods.annotations = arg.mods.annotations == null ? List.of(m) : arg.mods.annotations.prepend(m);\n\t\t\t}\n\t\t} else {\n\t\t\targ.mods.annotations = arg.mods.annotations == null ? List.of(m) : arg.mods.annotations.prepend(m);\n\t\t}\n\t}\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2009-2022 The Project Lombok Authors.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage lombok.javac.handlers;\n\nimport static com.sun.tools.javac.code.Flags.GENERATEDCONSTR;\nimport static lombok.core.handlers.HandlerUtil.*;\nimport static lombok.javac.Javac.*;\nimport static lombok.javac.JavacAugments.JCTree_generatedNode;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.regex.Pattern;\n\nimport com.sun.tools.javac.code.Attribute;\nimport com.sun.tools.javac.code.BoundKind;\nimport com.sun.tools.javac.code.Flags;\nimport com.sun.tools.javac.code.Scope;\nimport com.sun.tools.javac.code.Symbol;\nimport com.sun.tools.javac.code.Symbol.ClassSymbol;\nimport com.sun.tools.javac.code.Symbol.TypeSymbol;\nimport com.sun.tools.javac.code.Type;\nimport com.sun.tools.javac.comp.Annotate;\nimport com.sun.tools.javac.comp.AttrContext;\nimport com.sun.tools.javac.comp.Enter;\nimport com.sun.tools.javac.comp.Env;\nimport com.sun.tools.javac.comp.MemberEnter;\nimport com.sun.tools.javac.tree.JCTree;\nimport com.sun.tools.javac.tree.JCTree.JCAnnotation;\nimport com.sun.tools.javac.tree.JCTree.JCArrayTypeTree;\nimport com.sun.tools.javac.tree.JCTree.JCAssign;\nimport com.sun.tools.javac.tree.JCTree.JCBlock;\nimport com.sun.tools.javac.tree.JCTree.JCClassDecl;\nimport com.sun.tools.javac.tree.JCTree.JCCompilationUnit;\nimport com.sun.tools.javac.tree.JCTree.JCExpression;\nimport com.sun.tools.javac.tree.JCTree.JCExpressionStatement;\nimport com.sun.tools.javac.tree.JCTree.JCFieldAccess;\nimport com.sun.tools.javac.tree.JCTree.JCIdent;\nimport com.sun.tools.javac.tree.JCTree.JCImport;\nimport com.sun.tools.javac.tree.JCTree.JCLiteral;\nimport com.sun.tools.javac.tree.JCTree.JCMethodDecl;\nimport com.sun.tools.javac.tree.JCTree.JCMethodInvocation;\nimport com.sun.tools.javac.tree.JCTree.JCModifiers;\nimport com.sun.tools.javac.tree.JCTree.JCNewArray;\nimport com.sun.tools.javac.tree.JCTree.JCPrimitiveTypeTree;\nimport com.sun.tools.javac.tree.JCTree.JCStatement;\nimport com.sun.tools.javac.tree.JCTree.JCTypeApply;\nimport com.sun.tools.javac.tree.JCTree.JCTypeParameter;\nimport com.sun.tools.javac.tree.JCTree.JCVariableDecl;\nimport com.sun.tools.javac.tree.JCTree.JCWildcard;\nimport com.sun.tools.javac.tree.JCTree.TypeBoundKind;\nimport com.sun.tools.javac.tree.TreeMaker;\nimport com.sun.tools.javac.tree.TreeScanner;\nimport com.sun.tools.javac.util.Context;\nimport com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\nimport com.sun.tools.javac.util.List;\nimport com.sun.tools.javac.util.ListBuffer;\nimport com.sun.tools.javac.util.Name;\nimport com.sun.tools.javac.util.Options;\n\nimport lombok.AccessLevel;\nimport lombok.ConfigurationKeys;\nimport lombok.Data;\nimport lombok.Getter;\nimport lombok.core.AST.Kind;\nimport lombok.core.AnnotationValues;\nimport lombok.core.AnnotationValues.AnnotationValue;\nimport lombok.core.CleanupTask;\nimport lombok.core.LombokImmutableList;\nimport lombok.core.TypeResolver;\nimport lombok.core.configuration.CheckerFrameworkVersion;\nimport lombok.core.configuration.NullAnnotationLibrary;\nimport lombok.core.configuration.NullCheckExceptionType;\nimport lombok.core.configuration.TypeName;\nimport lombok.core.handlers.HandlerUtil;\nimport lombok.core.handlers.HandlerUtil.FieldAccess;\nimport lombok.delombok.LombokOptionsFactory;\nimport lombok.experimental.Accessors;\nimport lombok.experimental.Tolerate;\nimport lombok.javac.Javac;\nimport lombok.javac.JavacAugments;\nimport lombok.javac.JavacNode;\nimport lombok.javac.JavacTreeMaker;\nimport lombok.javac.JavacTreeMaker.TypeTag;\nimport lombok.permit.Permit;\n\n/**\n * Container for static utility methods useful to handlers written for javac.\n */\npublic class JavacHandlerUtil {\n\tprivate JavacHandlerUtil() {\n\t\t//Prevent instantiation\n\t}\n\t\n\tprivate static class MarkingScanner extends TreeScanner {\n\t\tprivate final JavacNode source;\n\t\t\n\t\tMarkingScanner(JavacNode source) {\n\t\t\tthis.source = source;\n\t\t}\n\t\t\n\t\t@Override public void scan(JCTree tree) {\n\t\t\tif (tree == null) return;\n\t\t\tsetGeneratedBy(tree, source);\n\t\t\tsuper.scan(tree);\n\t\t}\n\t}\n\t\n\t/**\n\t * Contributed by Jan Lahoda; many lombok transformations should not be run (or a lite version should be run) when the netbeans editor\n\t * is running javac on the open source file to find inline errors and such. As class files are compiled separately this does not affect\n\t * actual runtime behaviour or file output of the netbeans IDE.\n\t */\n\tpublic static boolean inNetbeansEditor(JavacNode node) {\n\t\treturn inNetbeansEditor(node.getContext());\n\t}\n\t\n\tpublic static boolean inNetbeansEditor(Context context) {\n\t\tOptions options = Options.instance(context);\n\t\treturn (options.keySet().contains(\"ide\") && !options.keySet().contains(\"backgroundCompilation\"));\n\t}\n\t\n\tpublic static boolean inNetbeansCompileOnSave(Context context) {\n\t\tOptions options = Options.instance(context);\n\t\treturn (options.keySet().contains(\"ide\") && options.keySet().contains(\"backgroundCompilation\"));\n\t}\n\t\n\tpublic static JCTree getGeneratedBy(JCTree node) {\n\t\treturn JCTree_generatedNode.get(node);\n\t}\n\t\n\tpublic static boolean isGenerated(JCTree node) {\n\t\treturn getGeneratedBy(node) != null;\n\t}\n\t\n\tpublic static <T extends JCTree> T recursiveSetGeneratedBy(T node, JavacNode source) {\n\t\tif (node == null) return null;\n\t\tsetGeneratedBy(node, source);\n\t\tnode.accept(new MarkingScanner(source));\n\t\treturn node;\n\t}\n\t\n\tpublic static <T extends JCTree> T setGeneratedBy(T node, JavacNode sourceNode) {\n\t\tif (node == null) return null;\n\t\tif (sourceNode == null) {\n\t\t\tJCTree_generatedNode.clear(node);\n\t\t\treturn node;\n\t\t}\n\t\tJCTree_generatedNode.set(node, sourceNode.get());\n\t\t\n\t\tif (!inNetbeansEditor(sourceNode.getContext()) || isParameter(node)) {\n\t\t\tnode.pos = sourceNode.getStartPos();\n\t\t\tstoreEnd(node, sourceNode.getEndPosition(), (JCCompilationUnit) sourceNode.top().get());\n\t\t}\n\t\treturn node;\n\t}\n\n\tpublic static boolean isParameter(JCTree node) {\n\t\treturn node instanceof JCVariableDecl && (((JCVariableDecl) node).mods.flags & Flags.PARAMETER) != 0;\n\t}\n\t\n\tpublic static boolean hasAnnotation(String type, JavacNode node) {\n\t\treturn hasAnnotation(type, node, false);\n\t}\n\t\n\tpublic static boolean hasAnnotation(Class<? extends Annotation> type, JavacNode node) {\n\t\treturn hasAnnotation(type, node, false);\n\t}\n\t\n\tpublic static boolean hasAnnotationAndDeleteIfNeccessary(Class<? extends Annotation> type, JavacNode node) {\n\t\treturn hasAnnotation(type, node, true);\n\t}\n\t\n\tprivate static boolean hasAnnotation(Class<? extends Annotation> type, JavacNode node, boolean delete) {\n\t\tif (node == null) return false;\n\t\tif (type == null) return false;\n\t\tswitch (node.getKind()) {\n\t\tcase ARGUMENT:\n\t\tcase FIELD:\n\t\tcase LOCAL:\n\t\tcase TYPE:\n\t\tcase METHOD:\n\t\t\tfor (JavacNode child : node.down()) {\n\t\t\t\tif (annotationTypeMatches(type, child)) {\n\t\t\t\t\tif (delete) deleteAnnotationIfNeccessary(child, type);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// intentional fallthrough\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tprivate static boolean hasAnnotation(String type, JavacNode node, boolean delete) {\n\t\tif (node == null) return false;\n\t\tif (type == null) return false;\n\t\tswitch (node.getKind()) {\n\t\tcase ARGUMENT:\n\t\tcase FIELD:\n\t\tcase LOCAL:\n\t\tcase TYPE:\n\t\tcase METHOD:\n\t\t\tfor (JavacNode child : node.down()) {\n\t\t\t\tif (annotationTypeMatches(type, child)) {\n\t\t\t\t\tif (delete) deleteAnnotationIfNeccessary(child, type);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// intentional fallthrough\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tpublic static JavacNode findInnerClass(JavacNode parent, String name) {\n\t\tfor (JavacNode child : parent.down()) {\n\t\t\tif (child.getKind() != Kind.TYPE) continue;\n\t\t\tJCClassDecl td = (JCClassDecl) child.get();\n\t\t\tif (td.name.contentEquals(name)) return child;\n\t\t}\n\t\treturn null;\n\t}\n\t\n\tpublic static JavacNode findAnnotation(Class<? extends Annotation> type, JavacNode node) {\n\t\treturn findAnnotation(type, node, false);\n\t}\n\t\n\tpublic static JavacNode findAnnotation(Class<? extends Annotation> type, JavacNode node, boolean delete) {\n\t\tif (node == null) return null;\n\t\tif (type == null) return null;\n\t\tswitch (node.getKind()) {\n\t\tcase ARGUMENT:\n\t\tcase FIELD:\n\t\tcase LOCAL:\n\t\tcase TYPE:\n\t\tcase METHOD:\n\t\t\tfor (JavacNode child : node.down()) {\n\t\t\t\tif (annotationTypeMatches(type, child)) {\n\t\t\t\t\tif (delete) deleteAnnotationIfNeccessary(child, type);\n\t\t\t\t\treturn child;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// intentional fallthrough\n\t\tdefault:\n\t\t\treturn null;\n\t\t}\n\t}\n\t\n\t/**\n\t * Checks if the Annotation AST Node provided is likely to be an instance of the provided annotation type.\n\t * \n\t * @param type An actual annotation type, such as {@code lombok.Getter.class}.\n\t * @param node A Lombok AST node representing an annotation in source code.\n\t */\n\tpublic static boolean annotationTypeMatches(Class<? extends Annotation> type, JavacNode node) {\n\t\tif (node.getKind() != Kind.ANNOTATION) return false;\n\t\treturn typeMatches(type, node, ((JCAnnotation) node.get()).annotationType);\n\t}\n\t\n\t/**\n\t * Checks if the Annotation AST Node provided is likely to be an instance of the provided annotation type.\n\t * \n\t * @param type An actual annotation type, such as {@code lombok.Getter.class}.\n\t * @param node A Lombok AST node representing an annotation in source code.\n\t */\n\tpublic static boolean annotationTypeMatches(String type, JavacNode node) {\n\t\tif (node.getKind() != Kind.ANNOTATION) return false;\n\t\treturn typeMatches(type, node, ((JCAnnotation) node.get()).annotationType);\n\t}\n\t\n\t/**\n\t * Checks if the given TypeReference node is likely to be a reference to the provided class.\n\t * \n\t * @param type An actual type. This method checks if {@code typeNode} is likely to be a reference to this type.\n\t * @param node A Lombok AST node. Any node in the appropriate compilation unit will do (used to get access to import statements).\n\t * @param typeNode A type reference to check.\n\t */\n\tpublic static boolean typeMatches(Class<?> type, JavacNode node, JCTree typeNode) {\n\t\treturn typeMatches(type.getName(), node, typeNode);\n\t}\n\t\n\t/**\n\t * Checks if the given TypeReference node is likely to be a reference to the provided class.\n\t * \n\t * @param type An actual type. This method checks if {@code typeNode} is likely to be a reference to this type.\n\t * @param node A Lombok AST node. Any node in the appropriate compilation unit will do (used to get access to import statements).\n\t * @param typeNode A type reference to check.\n\t */\n\tpublic static boolean typeMatches(String type, JavacNode node, JCTree typeNode) {\n\t\tString typeName = getTypeName(typeNode);\n\t\treturn typeMatches(type, node, typeName);\n\t}\n\n\tprivate static boolean typeMatches(String type, JavacNode node, String typeName) {\n\t\tif (typeName == null || typeName.length() == 0) return false;\n\t\tint lastIndexA = typeName.lastIndexOf('.') + 1;\n\t\tint lastIndexB = Math.max(type.lastIndexOf('.'), type.lastIndexOf('$')) + 1;\n\t\tint len = typeName.length() - lastIndexA;\n\t\tif (len != type.length() - lastIndexB) return false;\n\t\tfor (int i = 0; i < len; i++) if (typeName.charAt(i + lastIndexA) != type.charAt(i + lastIndexB)) return false;\n\t\tTypeResolver resolver = node.getImportListAsTypeResolver();\n\t\treturn resolver.typeMatches(node, type, typeName);\n\t}\n\n\tprivate static String getTypeName(JCTree typeNode) {\n\t\treturn typeNode == null ? null : typeNode.toString();\n\t}\n\n\t/**\n\t * Returns if a field is marked deprecated, either by {@code @Deprecated} or in javadoc\n\t * @param field the field to check\n\t * @return {@code true} if a field is marked deprecated, either by {@code @Deprecated} or in javadoc, otherwise {@code false}\n\t */\n\tpublic static boolean isFieldDeprecated(JavacNode field) {\n\t\tif (!(field.get() instanceof JCVariableDecl)) return false;\n\t\tJCVariableDecl fieldNode = (JCVariableDecl) field.get();\n\t\tif ((fieldNode.mods.flags & Flags.DEPRECATED) != 0) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (JavacNode child : field.down()) {\n\t\t\tif (annotationTypeMatches(Deprecated.class, child)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic static CheckerFrameworkVersion getCheckerFrameworkVersion(JavacNode node) {\n\t\tCheckerFrameworkVersion cfv = node.getAst().readConfiguration(ConfigurationKeys.CHECKER_FRAMEWORK);\n\t\treturn cfv == null ? CheckerFrameworkVersion.NONE : cfv;\n\t}\n\t\n\t/**\n\t * Returns if a node is marked deprecated (as picked up on by the parser).\n\t * @param node the node to check (type, method, or field decl).\n\t */\n\tpublic static boolean nodeHasDeprecatedFlag(JCTree node) {\n\t\tif (node instanceof JCVariableDecl) return (((JCVariableDecl) node).mods.flags & Flags.DEPRECATED) != 0;\n\t\tif (node instanceof JCMethodDecl) return (((JCMethodDecl) node).mods.flags & Flags.DEPRECATED) != 0;\n\t\tif (node instanceof JCClassDecl) return (((JCClassDecl) node).mods.flags & Flags.DEPRECATED) != 0;\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Creates an instance of {@code AnnotationValues} for the provided AST Node.\n\t * \n\t * @param type An annotation class type, such as {@code lombok.Getter.class}.\n\t * @param node A Lombok AST node representing an annotation in source code.\n\t */\n\tpublic static <A extends Annotation> AnnotationValues<A> createAnnotation(Class<A> type, final JavacNode node) {\n\t\treturn createAnnotation(type, (JCAnnotation) node.get(), node);\n\t}\n\t\n\t/**\n\t * Creates an instance of {@code AnnotationValues} for the provided AST Node\n\t * and Annotation expression.\n\t *\n\t * @param type An annotation class type, such as {@code lombok.Getter.class}.\n\t * @param anno the annotation expression\n\t * @param node A Lombok AST node representing an annotation in source code.\n\t */\n\tpublic static <A extends Annotation> AnnotationValues<A> createAnnotation(Class<A> type, JCAnnotation anno, final JavacNode node) {\n\t\tMap<String, AnnotationValue> values = new HashMap<String, AnnotationValue>();\n\t\tList<JCExpression> arguments = anno.getArguments();\n\t\t\n\t\tfor (JCExpression arg : arguments) {\n\t\t\tString mName;\n\t\t\tJCExpression rhs;\n\t\t\tjava.util.List<String> raws = new ArrayList<String>();\n\t\t\tjava.util.List<Object> guesses = new ArrayList<Object>();\n\t\t\tjava.util.List<Object> expressions = new ArrayList<Object>();\n\t\t\tfinal java.util.List<DiagnosticPosition> positions = new ArrayList<DiagnosticPosition>();\n\t\t\t\n\t\t\tif (arg instanceof JCAssign) {\n\t\t\t\tJCAssign assign = (JCAssign) arg;\n\t\t\t\tmName = assign.lhs.toString();\n\t\t\t\trhs = assign.rhs;\n\t\t\t} else {\n\t\t\t\trhs = arg;\n\t\t\t\tmName = \"value\";\n\t\t\t}\n\t\t\t\n\t\t\tif (rhs instanceof JCNewArray) {\n\t\t\t\tList<JCExpression> elems = ((JCNewArray) rhs).elems;\n\t\t\t\tfor (JCExpression inner : elems) {\n\t\t\t\t\traws.add(inner.toString());\n\t\t\t\t\texpressions.add(inner);\n\t\t\t\t\tif (inner instanceof JCAnnotation) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\t\t\t\tClass<A> innerClass = (Class<A>) Class.forName(inner.type.toString());\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tguesses.add(createAnnotation(innerClass, (JCAnnotation) inner, node));\n\t\t\t\t\t\t} catch (ClassNotFoundException ex) {\n\t\t\t\t\t\t\tguesses.add(calculateGuess(inner));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tguesses.add(calculateGuess(inner));\n\t\t\t\t\t}\n\t\t\t\t\tpositions.add(inner.pos());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\traws.add(rhs.toString());\n\t\t\t\texpressions.add(rhs);\n\t\t\t\tif (rhs instanceof JCAnnotation) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\t\t\tClass<A> innerClass = (Class<A>) Class.forName(rhs.type.toString());\n\t\t\t\t\t\t\n\t\t\t\t\t\tguesses.add(createAnnotation(innerClass, (JCAnnotation) rhs, node));\n\t\t\t\t\t} catch (ClassNotFoundException ex) {\n\t\t\t\t\t\tguesses.add(calculateGuess(rhs));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tguesses.add(calculateGuess(rhs));\n\t\t\t\t}\n\t\t\t\tpositions.add(rhs.pos());\n\t\t\t}\n\t\t\t\n\t\t\tvalues.put(mName, new AnnotationValue(node, raws, expressions, guesses, true) {\n\t\t\t\t@Override public void setError(String message, int valueIdx) {\n\t\t\t\t\tif (valueIdx < 0) node.addError(message);\n\t\t\t\t\telse node.addError(message, positions.get(valueIdx));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t@Override public void setWarning(String message, int valueIdx) {\n\t\t\t\t\tif (valueIdx < 0) node.addWarning(message);\n\t\t\t\t\telse node.addWarning(message, positions.get(valueIdx));\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\t\n\t\tfor (Method m : type.getDeclaredMethods()) {\n\t\t\tif (!Modifier.isPublic(m.getModifiers())) continue;\n\t\t\tString name = m.getName();\n\t\t\tif (!values.containsKey(name)) {\n\t\t\t\tvalues.put(name, new AnnotationValue(node, new ArrayList<String>(), new ArrayList<Object>(), new ArrayList<Object>(), false) {\n\t\t\t\t\t@Override public void setError(String message, int valueIdx) {\n\t\t\t\t\t\tnode.addError(message);\n\t\t\t\t\t}\n\t\t\t\t\t@Override public void setWarning(String message, int valueIdx) {\n\t\t\t\t\t\tnode.addWarning(message);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn new AnnotationValues<A>(type, values, node);\n\t}\n\t\n\t/**\n\t * Removes the annotation from javac's AST (it remains in lombok's AST),\n\t * then removes any import statement that imports this exact annotation (not star imports).\n\t * Only does this if the DeleteLombokAnnotations class is in the context.\n\t */\n\tpublic static void deleteAnnotationIfNeccessary(JavacNode annotation, String annotationType) {\n\t\tdeleteAnnotationIfNeccessary0(annotation, annotationType);\n\t}\n\t\n\t/**\n\t * Removes the annotation from javac's AST (it remains in lombok's AST),\n\t * then removes any import statement that imports this exact annotation (not star imports).\n\t * Only does this if the DeleteLombokAnnotations class is in the context.\n\t */\n\tpublic static void deleteAnnotationIfNeccessary(JavacNode annotation, Class<? extends Annotation> annotationType) {\n\t\tdeleteAnnotationIfNeccessary0(annotation, annotationType.getName());\n\t}\n\t\n\t/**\n\t * Removes the annotation from javac's AST (it remains in lombok's AST),\n\t * then removes any import statement that imports this exact annotation (not star imports).\n\t * Only does this if the DeleteLombokAnnotations class is in the context.\n\t */\n\tpublic static void deleteAnnotationIfNeccessary(JavacNode annotation, Class<? extends Annotation> annotationType1, Class<? extends Annotation> annotationType2) {\n\t\tdeleteAnnotationIfNeccessary0(annotation, annotationType1.getName(), annotationType2.getName());\n\t}\n\t\n\t/**\n\t * Removes the annotation from javac's AST (it remains in lombok's AST),\n\t * then removes any import statement that imports this exact annotation (not star imports).\n\t * Only does this if the DeleteLombokAnnotations class is in the context.\n\t */\n\tpublic static void deleteAnnotationIfNeccessary(JavacNode annotation, Class<? extends Annotation> annotationType1, String annotationType2) {\n\t\tdeleteAnnotationIfNeccessary0(annotation, annotationType1.getName(), annotationType2);\n\t}\n\t\n\tprivate static void deleteAnnotationIfNeccessary0(JavacNode annotation, String... annotationTypes) {\n\t\tif (inNetbeansEditor(annotation)) return;\n\t\tif (!annotation.shouldDeleteLombokAnnotations()) return;\n\t\tJavacNode parentNode = annotation.directUp();\n\t\tswitch (parentNode.getKind()) {\n\t\tcase FIELD:\n\t\tcase ARGUMENT:\n\t\tcase LOCAL:\n\t\t\tJCVariableDecl variable = (JCVariableDecl) parentNode.get();\n\t\t\tvariable.mods.annotations = filterList(variable.mods.annotations, annotation.get());\n\t\t\tbreak;\n\t\tcase METHOD:\n\t\t\tJCMethodDecl method = (JCMethodDecl) parentNode.get();\n\t\t\tmethod.mods.annotations = filterList(method.mods.annotations, annotation.get());\n\t\t\tbreak;\n\t\tcase TYPE:\n\t\t\ttry {\n\t\t\t\tJCClassDecl type = (JCClassDecl) parentNode.get();\n\t\t\t\ttype.mods.annotations = filterList(type.mods.annotations, annotation.get());\n\t\t\t} catch (ClassCastException e) {\n\t\t\t\t//something rather odd has been annotated. Better to just break only delombok instead of everything.\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t//This really shouldn't happen, but if it does, better just break delombok instead of breaking everything.\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tparentNode.getAst().setChanged();\n\t\tfor (String annotationType : annotationTypes) {\n\t\t\tdeleteImportFromCompilationUnit(annotation, annotationType);\n\t\t}\n\t}\n\t\n\tpublic static void deleteImportFromCompilationUnit(JavacNode node, String name) {\n\t\tif (inNetbeansEditor(node)) return;\n\t\tif (!node.shouldDeleteLombokAnnotations()) return;\n\t\t\n\t\tJCCompilationUnit unit = (JCCompilationUnit) node.top().get();\n\t\t\n\t\tfor (JCTree def : unit.defs) {\n\t\t\tif (!(def instanceof JCImport)) continue;\n\t\t\tJCImport imp0rt = (JCImport) def;\n\t\t\tif (imp0rt.staticImport) continue;\n\t\t\tif (!imp0rt.qualid.toString().equals(name)) continue;\n\t\t\tJavacAugments.JCImport_deletable.set(imp0rt, true);\n\t\t}\n\t}\n\t\n\tprivate static List<JCAnnotation> filterList(List<JCAnnotation> annotations, JCTree jcTree) {\n\t\tListBuffer<JCAnnotation> newAnnotations = new ListBuffer<JCAnnotation>();\n\t\tfor (JCAnnotation ann : annotations) {\n\t\t\tif (jcTree != ann) newAnnotations.append(ann);\n\t\t}\n\t\treturn newAnnotations.toList();\n\t}\n\t\n\t/** Serves as return value for the methods that check for the existence of fields and methods. */\n\tpublic enum MemberExistsResult {\n\t\tNOT_EXISTS, EXISTS_BY_LOMBOK, EXISTS_BY_USER;\n\t}\n\t\n\t/**\n\t * Translates the given field into all possible getter names.\n\t * Convenient wrapper around {@link HandlerUtil#toAllGetterNames(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static java.util.List<String> toAllGetterNames(JavacNode field) {\n\t\treturn HandlerUtil.toAllGetterNames(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * Translates the given field into all possible getter names.\n\t * Convenient wrapper around {@link HandlerUtil#toAllGetterNames(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static java.util.List<String> toAllGetterNames(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\treturn HandlerUtil.toAllGetterNames(field.getAst(), accessors, field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * @return the likely getter name for the stated field. (e.g. private boolean foo; to isFoo).\n\t * \n\t * Convenient wrapper around {@link HandlerUtil#toGetterName(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static String toGetterName(JavacNode field) {\n\t\treturn HandlerUtil.toGetterName(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * @return the likely getter name for the stated field. (e.g. private boolean foo; to isFoo).\n\t * \n\t * Convenient wrapper around {@link HandlerUtil#toGetterName(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static String toGetterName(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\treturn HandlerUtil.toGetterName(field.getAst(), accessors, field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * Translates the given field into all possible setter names.\n\t * Convenient wrapper around {@link HandlerUtil#toAllSetterNames(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static java.util.List<String> toAllSetterNames(JavacNode field) {\n\t\treturn HandlerUtil.toAllSetterNames(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * Translates the given field into all possible setter names.\n\t * Convenient wrapper around {@link HandlerUtil#toAllSetterNames(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static java.util.List<String> toAllSetterNames(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\treturn HandlerUtil.toAllSetterNames(field.getAst(), accessors, field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * @return the likely setter name for the stated field. (e.g. private boolean foo; to setFoo).\n\t * \n\t * Convenient wrapper around {@link HandlerUtil#toSetterName(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static String toSetterName(JavacNode field) {\n\t\treturn HandlerUtil.toSetterName(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * @return the likely setter name for the stated field. (e.g. private boolean foo; to setFoo).\n\t * \n\t * Convenient wrapper around {@link HandlerUtil#toSetterName(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static String toSetterName(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\treturn HandlerUtil.toSetterName(field.getAst(), accessors, field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * Translates the given field into all possible with names.\n\t * Convenient wrapper around {@link HandlerUtil#toAllWithNames(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static java.util.List<String> toAllWithNames(JavacNode field) {\n\t\treturn HandlerUtil.toAllWithNames(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * Translates the given field into all possible with names.\n\t * Convenient wrapper around {@link HandlerUtil#toAllWithNames(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static java.util.List<String> toAllWithNames(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\treturn HandlerUtil.toAllWithNames(field.getAst(), accessors, field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * Translates the given field into all possible withBy names.\n\t * Convenient wrapper around {@link HandlerUtil#toAllWithByNames(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static java.util.List<String> toAllWithByNames(JavacNode field) {\n\t\treturn HandlerUtil.toAllWithByNames(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * Translates the given field into all possible withBy names.\n\t * Convenient wrapper around {@link HandlerUtil#toAllWithByNames(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static java.util.List<String> toAllWithByNames(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\treturn HandlerUtil.toAllWithByNames(field.getAst(), accessors, field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * @return the likely with name for the stated field. (e.g. private boolean foo; to withFoo).\n\t * \n\t * Convenient wrapper around {@link HandlerUtil#toWithName(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static String toWithName(JavacNode field) {\n\t\treturn HandlerUtil.toWithName(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * @return the likely with name for the stated field. (e.g. private boolean foo; to withFoo).\n\t * \n\t * Convenient wrapper around {@link HandlerUtil#toWithName(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static String toWithName(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\treturn HandlerUtil.toWithName(field.getAst(), accessors, field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * @return the likely withBy name for the stated field. (e.g. private boolean foo; to withFooBy).\n\t * \n\t * Convenient wrapper around {@link HandlerUtil#toWithByName(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static String toWithByName(JavacNode field) {\n\t\treturn HandlerUtil.toWithByName(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * @return the likely withBy name for the stated field. (e.g. private boolean foo; to withFooBy).\n\t * \n\t * Convenient wrapper around {@link HandlerUtil#toWithByName(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static String toWithByName(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\treturn HandlerUtil.toWithByName(field.getAst(), accessors, field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * When generating a setter, the setter either returns void (beanspec) or Self (fluent).\n\t * This method scans for the {@code Accessors} annotation to figure that out.\n\t */\n\tpublic static boolean shouldReturnThis(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\tif ((((JCVariableDecl) field.get()).mods.flags & Flags.STATIC) != 0) return false;\n\t\t\n\t\treturn HandlerUtil.shouldReturnThis0(accessors, field.getAst());\n\t}\n\t\n\t/**\n\t * When generating a setter/getter/wither, should it be made final?\n\t */\n\tpublic static boolean shouldMakeFinal(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\tif ((((JCVariableDecl) field.get()).mods.flags & Flags.STATIC) != 0) return false;\n\t\t\n\t\treturn HandlerUtil.shouldMakeFinal0(accessors, field.getAst());\n\t}\n\t\n\tpublic static JCExpression cloneSelfType(JavacNode childOfType) {\n\t\tJavacNode typeNode = childOfType;\n\t\tJavacTreeMaker maker = childOfType.getTreeMaker();\n\t\twhile (typeNode != null && typeNode.getKind() != Kind.TYPE) typeNode = typeNode.up();\n\t\treturn JavacHandlerUtil.namePlusTypeParamsToTypeReference(maker, typeNode, ((JCClassDecl) typeNode.get()).typarams);\n\t}\n\t\n\tpublic static boolean isBoolean(JavacNode field) {\n\t\tJCExpression varType = ((JCVariableDecl) field.get()).vartype;\n\t\treturn isBoolean(varType);\n\t}\n\t\n\tpublic static boolean isBoolean(JCExpression varType) {\n\t\treturn varType != null && varType.toString().equals(\"boolean\");\n\t}\n\t\n\tpublic static Name removePrefixFromField(JavacNode field) {\n\t\tjava.util.List<String> prefixes = null;\n\t\tfor (JavacNode node : field.down()) {\n\t\t\tif (annotationTypeMatches(Accessors.class, node)) {\n\t\t\t\tAnnotationValues<Accessors> ann = createAnnotation(Accessors.class, node);\n\t\t\t\tif (ann.isExplicit(\"prefix\")) prefixes = Arrays.asList(ann.getInstance().prefix());\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (prefixes == null) {\n\t\t\tJavacNode current = field.up();\n\t\t\touter:\n\t\t\twhile (current != null) {\n\t\t\t\tfor (JavacNode node : current.down()) {\n\t\t\t\t\tif (annotationTypeMatches(Accessors.class, node)) {\n\t\t\t\t\t\tAnnotationValues<Accessors> ann = createAnnotation(Accessors.class, node);\n\t\t\t\t\t\tif (ann.isExplicit(\"prefix\")) prefixes = Arrays.asList(ann.getInstance().prefix());\n\t\t\t\t\t\tbreak outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcurrent = current.up();\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (prefixes == null) prefixes = field.getAst().readConfiguration(ConfigurationKeys.ACCESSORS_PREFIX);\n\t\t\n\t\tif (!prefixes.isEmpty()) {\n\t\t\tCharSequence newName = removePrefix(field.getName(), prefixes);\n\t\t\tif (newName != null) return field.toName(newName.toString());\n\t\t}\n\t\t\n\t\treturn ((JCVariableDecl) field.get()).name;\n\t}\n\t\n\tpublic static AnnotationValues<Accessors> getAccessorsForField(JavacNode field) {\n\t\tAnnotationValues<Accessors> values = null;\n\t\t\n\t\tfor (JavacNode node : field.down()) {\n\t\t\tif (annotationTypeMatches(Accessors.class, node)) {\n\t\t\t\tvalues = createAnnotation(Accessors.class, node);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tJavacNode current = field.up();\n\t\twhile (current != null) {\n\t\t\tfor (JavacNode node : current.down()) {\n\t\t\t\tif (annotationTypeMatches(Accessors.class, node)) {\n\t\t\t\t\tAnnotationValues<Accessors> onType = createAnnotation(Accessors.class, node);\n\t\t\t\t\tvalues = values == null ? onType : values.integrate(onType);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurrent = current.up();\n\t\t}\n\t\t\n\t\treturn values == null ? AnnotationValues.of(Accessors.class, field) : values;\n\t}\n\t\n\t/**\n\t * Checks if there is a field with the provided name.\n\t * \n\t * @param fieldName the field name to check for.\n\t * @param node Any node that represents the Type (JCClassDecl) to look in, or any child node thereof.\n\t */\n\tpublic static MemberExistsResult fieldExists(String fieldName, JavacNode node) {\n\t\tnode = upToTypeNode(node);\n\t\t\n\t\tif (node != null && node.get() instanceof JCClassDecl) {\n\t\t\tfor (JCTree def : ((JCClassDecl)node.get()).defs) {\n\t\t\t\tif (def instanceof JCVariableDecl) {\n\t\t\t\t\tif (((JCVariableDecl)def).name.contentEquals(fieldName)) {\n\t\t\t\t\t\treturn getGeneratedBy(def) == null ? MemberExistsResult.EXISTS_BY_USER : MemberExistsResult.EXISTS_BY_LOMBOK;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn MemberExistsResult.NOT_EXISTS;\n\t}\n\t\n\tpublic static MemberExistsResult methodExists(String methodName, JavacNode node, int params) {\n\t\treturn methodExists(methodName, node, true, params);\n\t}\n\t\n\t/**\n\t * Checks if there is a method with the provided name. In case of multiple methods (overloading), only\n\t * the first method decides if EXISTS_BY_USER or EXISTS_BY_LOMBOK is returned.\n\t * \n\t * @param methodName the method name to check for.\n\t * @param node Any node that represents the Type (JCClassDecl) to look in, or any child node thereof.\n\t * @param caseSensitive If the search should be case sensitive.\n\t * @param params The number of parameters the method should have; varargs count as 0-*. Set to -1 to find any method with the appropriate name regardless of parameter count.\n\t */\n\tpublic static MemberExistsResult methodExists(String methodName, JavacNode node, boolean caseSensitive, int params) {\n\t\tnode = upToTypeNode(node);\n\t\t\n\t\tif (node != null && node.get() instanceof JCClassDecl) {\n\t\t\ttop: for (JCTree def : ((JCClassDecl)node.get()).defs) {\n\t\t\t\tif (def instanceof JCMethodDecl) {\n\t\t\t\t\tJCMethodDecl md = (JCMethodDecl) def;\n\t\t\t\t\tString name = md.name.toString();\n\t\t\t\t\tboolean matches = caseSensitive ? name.equals(methodName) : name.equalsIgnoreCase(methodName);\n\t\t\t\t\tif (matches) {\n\t\t\t\t\t\tif (params > -1) {\n\t\t\t\t\t\t\tList<JCVariableDecl> ps = md.params;\n\t\t\t\t\t\t\tint minArgs = 0;\n\t\t\t\t\t\t\tint maxArgs = 0;\n\t\t\t\t\t\t\tif (ps != null && ps.length() > 0) {\n\t\t\t\t\t\t\t\tminArgs = ps.length();\n\t\t\t\t\t\t\t\tif ((ps.last().mods.flags & Flags.VARARGS) != 0) {\n\t\t\t\t\t\t\t\t\tmaxArgs = Integer.MAX_VALUE;\n\t\t\t\t\t\t\t\t\tminArgs--;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tmaxArgs = minArgs;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (params < minArgs || params > maxArgs) continue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (isTolerate(node, md)) continue top;\n\t\t\t\t\t\t\n\t\t\t\t\t\treturn getGeneratedBy(def) == null ? MemberExistsResult.EXISTS_BY_USER : MemberExistsResult.EXISTS_BY_LOMBOK;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn MemberExistsResult.NOT_EXISTS;\n\t}\n\t\n\tpublic static boolean isTolerate(JavacNode node, JCTree.JCMethodDecl md) {\n\t\tList<JCAnnotation> annotations = md.getModifiers().getAnnotations();\n\t\tif (annotations != null) for (JCTree.JCAnnotation anno : annotations) {\n\t\t\tif (typeMatches(Tolerate.class, node, anno.getAnnotationType())) return true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Checks if there is a (non-default) constructor. In case of multiple constructors (overloading), only\n\t * the first constructor decides if EXISTS_BY_USER or EXISTS_BY_LOMBOK is returned.\n\t * \n\t * @param node Any node that represents the Type (JCClassDecl) to look in, or any child node thereof.\n\t */\n\tpublic static MemberExistsResult constructorExists(JavacNode node) {\n\t\tnode = upToTypeNode(node);\n\t\t\n\t\tif (node != null && node.get() instanceof JCClassDecl) {\n\t\t\tfor (JCTree def : ((JCClassDecl) node.get()).defs) {\n\t\t\t\tif (def instanceof JCMethodDecl) {\n\t\t\t\t\tJCMethodDecl md = (JCMethodDecl) def;\n\t\t\t\t\tif (md.name.contentEquals(\"<init>\")) {\n\t\t\t\t\t\tif ((md.mods.flags & Flags.GENERATEDCONSTR) != 0) continue;\n\t\t\t\t\t\tif (isTolerate(node, md)) continue;\n\t\t\t\t\t\treturn getGeneratedBy(def) == null ? MemberExistsResult.EXISTS_BY_USER : MemberExistsResult.EXISTS_BY_LOMBOK;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn MemberExistsResult.NOT_EXISTS;\n\t}\n\t\n\tpublic static boolean isConstructorCall(final JCStatement statement) {\n\t\tif (!(statement instanceof JCExpressionStatement)) return false;\n\t\tJCExpression expr = ((JCExpressionStatement) statement).expr;\n\t\tif (!(expr instanceof JCMethodInvocation)) return false;\n\t\tJCExpression invocation = ((JCMethodInvocation) expr).meth;\n\t\tString name;\n\t\tif (invocation instanceof JCFieldAccess) {\n\t\t\tname = ((JCFieldAccess) invocation).name.toString();\n\t\t} else if (invocation instanceof JCIdent) {\n\t\t\tname = ((JCIdent) invocation).name.toString();\n\t\t} else {\n\t\t\tname = \"\";\n\t\t}\n\t\t\n\t\treturn \"super\".equals(name) || \"this\".equals(name);\n\t}\n\t\n\t/**\n\t * Turns an {@code AccessLevel} instance into the flag bit used by javac.\n\t */\n\tpublic static int toJavacModifier(AccessLevel accessLevel) {\n\t\tswitch (accessLevel) {\n\t\tcase MODULE:\n\t\tcase PACKAGE:\n\t\t\treturn 0;\n\t\tdefault:\n\t\tcase PUBLIC:\n\t\t\treturn Flags.PUBLIC;\n\t\tcase NONE:\n\t\tcase PRIVATE:\n\t\t\treturn Flags.PRIVATE;\n\t\tcase PROTECTED:\n\t\t\treturn Flags.PROTECTED;\n\t\t}\n\t}\n\t\n\tprivate static class GetterMethod {\n\t\tprivate final Name name;\n\t\tprivate final JCExpression type;\n\t\t\n\t\tGetterMethod(Name name, JCExpression type) {\n\t\t\tthis.name = name;\n\t\t\tthis.type = type;\n\t\t}\n\t}\n\t\n\tprivate static GetterMethod findGetter(JavacNode field) {\n\t\tJCVariableDecl decl = (JCVariableDecl)field.get();\n\t\tJavacNode typeNode = field.up();\n\t\tfor (String potentialGetterName : toAllGetterNames(field)) {\n\t\t\tfor (JavacNode potentialGetter : typeNode.down()) {\n\t\t\t\tif (potentialGetter.getKind() != Kind.METHOD) continue;\n\t\t\t\tJCMethodDecl method = (JCMethodDecl) potentialGetter.get();\n\t\t\t\tif (!method.name.toString().equalsIgnoreCase(potentialGetterName)) continue;\n\t\t\t\t/** static getX() methods don't count. */\n\t\t\t\tif ((method.mods.flags & Flags.STATIC) != 0) continue;\n\t\t\t\t/** Nor do getters with a non-empty parameter list. */\n\t\t\t\tif (method.params != null && method.params.size() > 0) continue;\n\t\t\t\treturn new GetterMethod(method.name, method.restype);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Check if the field has a @Getter annotation.\n\t\t\n\t\tboolean hasGetterAnnotation = false;\n\t\t\n\t\tfor (JavacNode child : field.down()) {\n\t\t\tif (child.getKind() == Kind.ANNOTATION && annotationTypeMatches(Getter.class, child)) {\n\t\t\t\tAnnotationValues<Getter> ann = createAnnotation(Getter.class, child);\n\t\t\t\tif (ann.getInstance().value() == AccessLevel.NONE) return null;   //Definitely WONT have a getter.\n\t\t\t\thasGetterAnnotation = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Check if the class has a @Getter annotation.\n\t\t\n\t\tif (!hasGetterAnnotation && HandleGetter.fieldQualifiesForGetterGeneration(field)) {\n\t\t\t//Check if the class has @Getter or @Data annotation.\n\t\t\t\n\t\t\tJavacNode containingType = field.up();\n\t\t\tif (containingType != null) for (JavacNode child : containingType.down()) {\n\t\t\t\tif (child.getKind() == Kind.ANNOTATION && annotationTypeMatches(Data.class, child)) hasGetterAnnotation = true;\n\t\t\t\tif (child.getKind() == Kind.ANNOTATION && annotationTypeMatches(Getter.class, child)) {\n\t\t\t\t\tAnnotationValues<Getter> ann = createAnnotation(Getter.class, child);\n\t\t\t\t\tif (ann.getInstance().value() == AccessLevel.NONE) return null;   //Definitely WONT have a getter.\n\t\t\t\t\thasGetterAnnotation = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (hasGetterAnnotation) {\n\t\t\tString getterName = toGetterName(field);\n\t\t\tif (getterName == null) return null;\n\t\t\treturn new GetterMethod(field.toName(getterName), decl.vartype);\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\t\n\tstatic boolean lookForGetter(JavacNode field, FieldAccess fieldAccess) {\n\t\tif (fieldAccess == FieldAccess.GETTER) return true;\n\t\tif (fieldAccess == FieldAccess.ALWAYS_FIELD) return false;\n\t\t\n\t\t// If @Getter(lazy = true) is used, then using it is mandatory.\n\t\tfor (JavacNode child : field.down()) {\n\t\t\tif (child.getKind() != Kind.ANNOTATION) continue;\n\t\t\tif (annotationTypeMatches(Getter.class, child)) {\n\t\t\t\tAnnotationValues<Getter> ann = createAnnotation(Getter.class, child);\n\t\t\t\tif (ann.getInstance().lazy()) return true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Returns the type of the field, unless a getter exists for this field, in which case the return type of the getter is returned.\n\t * \n\t * @see #createFieldAccessor(TreeMaker, JavacNode, FieldAccess)\n\t */\n\tstatic JCExpression getFieldType(JavacNode field, FieldAccess fieldAccess) {\n\t\tif (field.getKind() == Kind.METHOD) return ((JCMethodDecl) field.get()).restype;\n\t\t\n\t\tboolean lookForGetter = lookForGetter(field, fieldAccess);\n\t\t\n\t\tGetterMethod getter = lookForGetter ? findGetter(field) : null;\n\t\t\n\t\tif (getter == null) {\n\t\t\treturn ((JCVariableDecl) field.get()).vartype;\n\t\t}\n\t\t\n\t\treturn getter.type;\n\t}\n\t\n\t/**\n\t * Creates an expression that reads the field. Will either be {@code this.field} or {@code this.getField()} depending on whether or not there's a getter.\n\t */\n\tstatic JCExpression createFieldAccessor(JavacTreeMaker maker, JavacNode field, FieldAccess fieldAccess) {\n\t\treturn createFieldAccessor(maker, field, fieldAccess, null);\n\t}\n\t\n\tstatic JCExpression createFieldAccessor(JavacTreeMaker maker, JavacNode field, FieldAccess fieldAccess, JCExpression receiver) {\n\t\tboolean lookForGetter = lookForGetter(field, fieldAccess);\n\t\t\n\t\tGetterMethod getter = lookForGetter ? findGetter(field) : null;\n\t\tJCVariableDecl fieldDecl = (JCVariableDecl) field.get();\n\t\t\n\t\tif (getter == null) {\n\t\t\tif (receiver == null) {\n\t\t\t\tif ((fieldDecl.mods.flags & Flags.STATIC) == 0) {\n\t\t\t\t\treceiver = maker.Ident(field.toName(\"this\"));\n\t\t\t\t} else {\n\t\t\t\t\tJavacNode containerNode = field.up();\n\t\t\t\t\tif (containerNode != null && containerNode.get() instanceof JCClassDecl) {\n\t\t\t\t\t\tJCClassDecl container = (JCClassDecl) field.up().get();\n\t\t\t\t\t\treceiver = maker.Ident(container.name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn receiver == null ? maker.Ident(fieldDecl.name) : maker.Select(receiver, fieldDecl.name);\n\t\t}\n\t\t\n\t\tif (receiver == null) receiver = maker.Ident(field.toName(\"this\"));\n\t\tJCMethodInvocation call = maker.Apply(List.<JCExpression>nil(),\n\t\t\tmaker.Select(receiver, getter.name), List.<JCExpression>nil());\n\t\treturn call;\n\t}\n\t\n\tstatic JCExpression createMethodAccessor(JavacTreeMaker maker, JavacNode method) {\n\t\treturn createMethodAccessor(maker, method, null);\n\t}\n\t\n\tstatic JCExpression createMethodAccessor(JavacTreeMaker maker, JavacNode method, JCExpression receiver) {\n\t\tJCMethodDecl methodDecl = (JCMethodDecl) method.get();\n\t\t\n\t\tif (receiver == null && (methodDecl.mods.flags & Flags.STATIC) == 0) {\n\t\t\treceiver = maker.Ident(method.toName(\"this\"));\n\t\t} else if (receiver == null) {\n\t\t\tJavacNode containerNode = method.up();\n\t\t\tif (containerNode != null && containerNode.get() instanceof JCClassDecl) {\n\t\t\t\tJCClassDecl container = (JCClassDecl) method.up().get();\n\t\t\t\treceiver = maker.Ident(container.name);\n\t\t\t}\n\t\t}\n\t\t\n\t\tJCMethodInvocation call = maker.Apply(List.<JCExpression>nil(),\n\t\t\treceiver == null ? maker.Ident(methodDecl.name) : maker.Select(receiver, methodDecl.name), List.<JCExpression>nil());\n\t\treturn call;\n\t}\n\t\n\t/**\n\t * Adds the given new field declaration to the provided type AST Node.\n\t * The field carries the &#64;{@link SuppressWarnings}(\"all\") annotation.\n\t * Also takes care of updating the JavacAST.\n\t */\n\tpublic static JavacNode injectFieldAndMarkGenerated(JavacNode typeNode, JCVariableDecl field) {\n\t\treturn injectField(typeNode, field, true);\n\t}\n\t\n\t/**\n\t * Adds the given new field declaration to the provided type AST Node.\n\t * \n\t * Also takes care of updating the JavacAST.\n\t */\n\tpublic static JavacNode injectField(JavacNode typeNode, JCVariableDecl field) {\n\t\treturn injectField(typeNode, field, false);\n\t}\n\t\n\tpublic static JavacNode injectField(JavacNode typeNode, JCVariableDecl field, boolean addGenerated) {\n\t\treturn injectField(typeNode, field, addGenerated, false);\n\t}\n\t\n\tpublic static JavacNode injectField(JavacNode typeNode, JCVariableDecl field, boolean addGenerated, boolean specialEnumHandling) {\n\t\tJCClassDecl type = (JCClassDecl) typeNode.get();\n\t\t\n\t\tif (addGenerated) {\n\t\t\taddSuppressWarningsAll(field.mods, typeNode, typeNode.getNodeFor(getGeneratedBy(field)), typeNode.getContext());\n\t\t\taddGenerated(field.mods, typeNode, typeNode.getNodeFor(getGeneratedBy(field)), typeNode.getContext());\n\t\t}\n\t\t\n\t\tList<JCTree> insertAfter = null;\n\t\tList<JCTree> insertBefore = type.defs;\n\t\twhile (true) {\n\t\t\tboolean skip = false;\n\t\t\tif (insertBefore.head instanceof JCVariableDecl) {\n\t\t\t\tJCVariableDecl f = (JCVariableDecl) insertBefore.head;\n\t\t\t\tif ((!specialEnumHandling && isEnumConstant(f)) || isGenerated(f)) skip = true;\n\t\t\t} else if (insertBefore.head instanceof JCMethodDecl) {\n\t\t\t\tif ((((JCMethodDecl) insertBefore.head).mods.flags & GENERATEDCONSTR) != 0) skip = true;\n\t\t\t}\n\t\t\tif (skip) {\n\t\t\t\tinsertAfter = insertBefore;\n\t\t\t\tinsertBefore = insertBefore.tail;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tList<JCTree> fieldEntry = List.<JCTree>of(field);\n\t\tfieldEntry.tail = insertBefore;\n\t\tif (insertAfter == null) {\n\t\t\ttype.defs = fieldEntry;\n\t\t} else {\n\t\t\tinsertAfter.tail = fieldEntry;\n\t\t}\n\t\t\n\t\tEnterReflect.memberEnter(field, typeNode);\n\t\t\n\t\treturn typeNode.add(field, Kind.FIELD);\n\t}\n\t\n\tpublic static boolean isEnumConstant(final JCVariableDecl field) {\n\t\treturn (field.mods.flags & Flags.ENUM) != 0;\n\t}\n\t\n\tstatic class JCAnnotatedTypeReflect {\n\t\tprivate static Class<?> TYPE;\n\t\tprivate static Constructor<?> CONSTRUCTOR;\n\t\tprivate static Field ANNOTATIONS, UNDERLYING_TYPE;\n\t\t\n\t\tprivate static void initByLoader(ClassLoader classLoader) {\n\t\t\tif (TYPE != null) return;\n\t\t\tClass<?> c;\n\t\t\ttry {\n\t\t\t\tc = classLoader.loadClass(\"com.sun.tools.javac.tree.JCTree$JCAnnotatedType\");\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tinit(c);\n\t\t}\n\t\t\n\t\tprivate static void init(Class<?> in) {\n\t\t\tif (TYPE != null) return;\n\t\t\tif (!in.getName().equals(\"com.sun.tools.javac.tree.JCTree$JCAnnotatedType\")) return;\n\t\t\ttry {\n\t\t\t\tCONSTRUCTOR = Permit.getConstructor(in, List.class, JCExpression.class);\n\t\t\t\tANNOTATIONS = Permit.getField(in, \"annotations\");\n\t\t\t\tUNDERLYING_TYPE = Permit.getField(in, \"underlyingType\");\n\t\t\t\tTYPE = in;\n\t\t\t} catch (Exception ignore) {}\n\t\t}\n\t\t\n\t\tstatic boolean is(JCTree obj) {\n\t\t\tif (obj == null) return false;\n\t\t\tinit(obj.getClass());\n\t\t\treturn obj.getClass() == TYPE;\n\t\t}\n\t\t\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tstatic List<JCAnnotation> getAnnotations(JCTree obj) {\n\t\t\tinit(obj.getClass());\n\t\t\ttry {\n\t\t\t\treturn (List<JCAnnotation>) ANNOTATIONS.get(obj);\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn List.nil();\n\t\t\t}\n\t\t}\n\t\t\n\t\tstatic void setAnnotations(JCTree obj, List<JCAnnotation> anns) {\n\t\t\tinit(obj.getClass());\n\t\t\ttry {\n\t\t\t\tANNOTATIONS.set(obj, anns);\n\t\t\t} catch (Exception e) {}\n\t\t}\n\t\t\n\t\tstatic JCExpression getUnderlyingType(JCTree obj) {\n\t\t\tinit(obj.getClass());\n\t\t\ttry {\n\t\t\t\treturn (JCExpression) UNDERLYING_TYPE.get(obj);\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\t\n\t\tstatic JCExpression create(List<JCAnnotation> annotations, JCExpression underlyingType) {\n\t\t\tinitByLoader(underlyingType.getClass().getClassLoader());\n\t\t\ttry {\n\t\t\t\treturn (JCExpression) CONSTRUCTOR.newInstance(annotations, underlyingType);\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn underlyingType;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic class JCAnnotationReflect {\n\t\tprivate static final Field ATTRIBUTE;\n\n\t\tstatic {\n\t\t\tATTRIBUTE = Permit.permissiveGetField(JCAnnotation.class, \"attribute\");\n\t\t}\n\n\t\tstatic Attribute.Compound getAttribute(JCAnnotation jcAnnotation) {\n\t\t\tif (ATTRIBUTE != null) {\n\t\t\t\ttry {\n\t\t\t\t\treturn (Attribute.Compound) ATTRIBUTE.get(jcAnnotation);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t// Ignore\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tstatic void setAttribute(JCAnnotation jcAnnotation, Attribute.Compound attribute) {\n\t\t\tif (ATTRIBUTE != null) {\n\t\t\t\ttry {\n\t\t\t\t\tPermit.set(ATTRIBUTE, jcAnnotation, attribute);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t// Ignore\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// jdk9 support, types have changed, names stay the same\n\tstatic class ClassSymbolMembersField {\n\t\tprivate static final Field membersField;\n\t\tprivate static final Method removeMethod;\n\t\tprivate static final Method enterMethod;\n\t\t\n\t\tstatic {\n\t\t\tField f = null;\n\t\t\tMethod r = null;\n\t\t\tMethod e = null;\n\t\t\ttry {\n\t\t\t\tf = Permit.getField(ClassSymbol.class, \"members_field\");\n\t\t\t\tr = Permit.getMethod(f.getType(), \"remove\", Symbol.class);\n\t\t\t\te = Permit.getMethod(f.getType(), \"enter\", Symbol.class);\n\t\t\t} catch (Exception ex) {}\n\t\t\tmembersField = f;\n\t\t\tremoveMethod = r;\n\t\t\tenterMethod = e;\n\t\t}\n\t\t\n\t\tstatic void remove(ClassSymbol from, Symbol toRemove) {\n\t\t\tif (from == null) return;\n\t\t\ttry {\n\t\t\t\tScope scope = (Scope) membersField.get(from);\n\t\t\t\tif (scope == null) return;\n\t\t\t\tPermit.invoke(removeMethod, scope, toRemove);\n\t\t\t} catch (Exception e) {}\n\t\t}\n\t\t\n\t\tstatic void enter(ClassSymbol from, Symbol toEnter) {\n\t\t\tif (from == null) return;\n\t\t\ttry {\n\t\t\t\tScope scope = (Scope) membersField.get(from);\n\t\t\t\tif (scope == null) return;\n\t\t\t\tPermit.invoke(enterMethod, scope, toEnter);\n\t\t\t} catch (Exception e) {}\n\t\t}\n\t}\n\t\n\t/**\n\t * Adds the given new method declaration to the provided type AST Node.\n\t * Can also inject constructors.\n\t * \n\t * Also takes care of updating the JavacAST.\n\t */\n\tpublic static void injectMethod(JavacNode typeNode, JCMethodDecl method) {\n\t\tJCClassDecl type = (JCClassDecl) typeNode.get();\n\t\t\n\t\tif (method.getName().contentEquals(\"<init>\")) {\n\t\t\t//Scan for default constructor, and remove it.\n\t\t\tint idx = 0;\n\t\t\tfor (JCTree def : type.defs) {\n\t\t\t\tif (def instanceof JCMethodDecl) {\n\t\t\t\t\tif ((((JCMethodDecl) def).mods.flags & Flags.GENERATEDCONSTR) != 0) {\n\t\t\t\t\t\tJavacNode tossMe = typeNode.getNodeFor(def);\n\t\t\t\t\t\tif (tossMe != null) tossMe.up().removeChild(tossMe);\n\t\t\t\t\t\ttype.defs = addAllButOne(type.defs, idx);\n\t\t\t\t\t\tClassSymbolMembersField.remove(type.sym, ((JCMethodDecl) def).sym);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tidx++;\n\t\t\t}\n\t\t}\n\t\t\n\t\taddSuppressWarningsAll(method.mods, typeNode, typeNode.getNodeFor(getGeneratedBy(method)), typeNode.getContext());\n\t\taddGenerated(method.mods, typeNode, typeNode.getNodeFor(getGeneratedBy(method)), typeNode.getContext());\n\t\ttype.defs = type.defs.append(method);\n\t\t\n\t\tEnterReflect.memberEnter(method, typeNode);\n\t\t\n\t\ttypeNode.add(method, Kind.METHOD);\n\t}\n\n\t/**\n\t * Adds an inner type (class, interface, enum) to the given type. Cannot inject top-level types.\n\t * \n\t * @param typeNode parent type to inject new type into\n\t * @param type New type (class, interface, etc) to inject.\n\t * @return \n\t */\n\tpublic static JavacNode injectType(JavacNode typeNode, final JCClassDecl type) {\n\t\tJCClassDecl typeDecl = (JCClassDecl) typeNode.get();\n\t\taddSuppressWarningsAll(type.mods, typeNode, typeNode.getNodeFor(getGeneratedBy(type)), typeNode.getContext());\n\t\taddGenerated(type.mods, typeNode, typeNode.getNodeFor(getGeneratedBy(type)), typeNode.getContext());\n\t\ttypeDecl.defs = typeDecl.defs.append(type);\n\t\t\n\t\tEnterReflect.classEnter(type, typeNode);\n\t\t\n\t\treturn typeNode.add(type, Kind.TYPE);\n\t}\n\t\n\tstatic class EnterReflect {\n\t\tprivate static final Method classEnter;\n\t\tprivate static final Method memberEnter;\n\t\tprivate static final Method blockAnnotations;\n\t\tprivate static final Method unblockAnnotations;\n\t\t\n\t\tstatic {\n\t\t\tclassEnter = Permit.permissiveGetMethod(Enter.class, \"classEnter\", JCTree.class, Env.class);\n\t\t\tmemberEnter = Permit.permissiveGetMethod(MemberEnter.class, \"memberEnter\", JCTree.class, Env.class);\n\t\t\t\n\t\t\tMethod block = Permit.permissiveGetMethod(Annotate.class, \"blockAnnotations\");\n\t\t\tif (block == null) block = Permit.permissiveGetMethod(Annotate.class, \"enterStart\");\n\t\t\tblockAnnotations = block;\n\t\t\t\n\t\t\tMethod unblock = Permit.permissiveGetMethod(Annotate.class, \"unblockAnnotations\");\n\t\t\tif (unblock == null) unblock = Permit.permissiveGetMethod(Annotate.class, \"enterDone\");\n\t\t\tunblockAnnotations = unblock;\n\t\t}\n\t\t\n\t\tstatic Type classEnter(JCTree tree, JavacNode parent) {\n\t\t\tEnter enter = Enter.instance(parent.getContext());\n\t\t\tEnv<AttrContext> classEnv = enter.getEnv((TypeSymbol) parent.getElement());\n\t\t\tif (classEnv == null) return null;\n\t\t\tType type = (Type) Permit.invokeSneaky(classEnter, enter, tree, classEnv);\n\t\t\tif (type == null) return null;\n\t\t\ttype.complete();\n\t\t\treturn type;\n\t\t}\n\t\t\n\t\tstatic void memberEnter(JCTree tree, JavacNode parent) {\n\t\t\tContext context = parent.getContext();\n\t\t\tMemberEnter me = MemberEnter.instance(context);\n\t\t\tAnnotate annotate = Annotate.instance(context);\n\t\t\tEnter enter = Enter.instance(context);\n\t\t\t\n\t\t\tEnv<AttrContext> classEnv = enter.getEnv((TypeSymbol) parent.getElement());\n\t\t\tif (classEnv == null) return;\n\t\t\t\n\t\t\tPermit.invokeSneaky(blockAnnotations, annotate);\n\t\t\tPermit.invokeSneaky(memberEnter, me, tree, classEnv);\n\t\t\tPermit.invokeSneaky(unblockAnnotations, annotate);\n\t\t}\n\t}\n\t\n\tpublic static long addFinalIfNeeded(long flags, Context context) {\n\t\tboolean addFinal = LombokOptionsFactory.getDelombokOptions(context).getFormatPreferences().generateFinalParams();\n\t\t\n\t\tif (addFinal) flags |= Flags.FINAL;\n\t\treturn flags;\n\t}\n\t\n\tpublic static JCExpression genTypeRef(JavacNode node, String complexName) {\n\t\tString[] parts = complexName.split(\"\\\\.\");\n\t\tif (parts.length > 2 && parts[0].equals(\"java\") && parts[1].equals(\"lang\")) {\n\t\t\tString[] subParts = new String[parts.length - 2];\n\t\t\tSystem.arraycopy(parts, 2, subParts, 0, subParts.length);\n\t\t\treturn genJavaLangTypeRef(node, subParts);\n\t\t}\n\t\t\n\t\treturn chainDots(node, parts);\n\t}\n\t\n\tpublic static JCExpression genJavaLangTypeRef(JavacNode node, String... simpleNames) {\n\t\tif (LombokOptionsFactory.getDelombokOptions(node.getContext()).getFormatPreferences().javaLangAsFqn()) {\n\t\t\treturn chainDots(node, \"java\", \"lang\", simpleNames);\n\t\t} else {\n\t\t\treturn chainDots(node, null, null, simpleNames);\n\t\t}\n\t}\n\t\n\tpublic static JCExpression genJavaLangTypeRef(JavacNode node, int pos, String... simpleNames) {\n\t\tif (LombokOptionsFactory.getDelombokOptions(node.getContext()).getFormatPreferences().javaLangAsFqn()) {\n\t\t\treturn chainDots(node, pos, \"java\", \"lang\", simpleNames);\n\t\t} else {\n\t\t\treturn chainDots(node, pos, null, null, simpleNames);\n\t\t}\n\t}\n\t\n\tpublic static void addSuppressWarningsAll(JCModifiers mods, JavacNode node, JavacNode source, Context context) {\n\t\tif (!LombokOptionsFactory.getDelombokOptions(context).getFormatPreferences().generateSuppressWarnings()) return;\n\t\t\n\t\tboolean addJLSuppress = !Boolean.FALSE.equals(node.getAst().readConfiguration(ConfigurationKeys.ADD_SUPPRESSWARNINGS_ANNOTATIONS));\n\t\t\n\t\tif (addJLSuppress) {\n\t\t\tfor (JCAnnotation ann : mods.annotations) {\n\t\t\t\tJCTree type = ann.getAnnotationType();\n\t\t\t\tName n = null;\n\t\t\t\tif (type instanceof JCIdent) n = ((JCIdent) type).name;\n\t\t\t\telse if (type instanceof JCFieldAccess) n = ((JCFieldAccess) type).name;\n\t\t\t\tif (n != null && n.contentEquals(\"SuppressWarnings\")) {\n\t\t\t\t\taddJLSuppress = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (addJLSuppress) addAnnotation(mods, node, source, \"java.lang.SuppressWarnings\", node.getTreeMaker().Literal(\"all\"));\n\t\t\n\t\tif (Boolean.TRUE.equals(node.getAst().readConfiguration(ConfigurationKeys.ADD_FINDBUGS_SUPPRESSWARNINGS_ANNOTATIONS))) {\n\t\t\tJavacTreeMaker maker = node.getTreeMaker();\n\t\t\tJCExpression arg = maker.Assign(maker.Ident(node.toName(\"justification\")), maker.Literal(\"generated code\"));\n\t\t\taddAnnotation(mods, node, source, \"edu.umd.cs.findbugs.annotations.SuppressFBWarnings\", arg);\n\t\t}\n\t}\n\t\n\tpublic static void addGenerated(JCModifiers mods, JavacNode node, JavacNode source, Context context) {\n\t\tif (!LombokOptionsFactory.getDelombokOptions(context).getFormatPreferences().generateGenerated()) return;\n\t\t\n\t\tif (HandlerUtil.shouldAddGenerated(node)) {\n\t\t\taddAnnotation(mods, node, source, \"javax.annotation.Generated\", node.getTreeMaker().Literal(\"lombok\"));\n\t\t}\n\t\tif (Boolean.TRUE.equals(node.getAst().readConfiguration(ConfigurationKeys.ADD_LOMBOK_GENERATED_ANNOTATIONS))) {\n\t\t\taddAnnotation(mods, node, source, \"lombok.Generated\", null);\n\t\t}\n\t}\n\t\n\tpublic static void addAnnotation(JCModifiers mods, JavacNode node, JavacNode source, String annotationTypeFqn, JCExpression arg) {\n\t\tboolean isJavaLangBased;\n\t\tString simpleName; {\n\t\t\tint idx = annotationTypeFqn.lastIndexOf('.');\n\t\t\tsimpleName = idx == -1 ? annotationTypeFqn : annotationTypeFqn.substring(idx + 1);\n\t\t\t\n\t\t\tisJavaLangBased = idx == 9 && annotationTypeFqn.regionMatches(0, \"java.lang.\", 0, 10);\n\t\t}\n\t\t\n\t\tfor (JCAnnotation ann : mods.annotations) {\n\t\t\tJCTree annType = ann.getAnnotationType();\n\t\t\tif (annType instanceof JCIdent) {\n\t\t\t\tName lastPart = ((JCIdent) annType).name;\n\t\t\t\tif (lastPart.contentEquals(simpleName)) return;\n\t\t\t}\n\t\t\t\n\t\t\tif (annType instanceof JCFieldAccess) {\n\t\t\t\tif (annType.toString().equals(annotationTypeFqn)) return;\n\t\t\t}\n\t\t}\n\t\t\n\t\tJavacTreeMaker maker = node.getTreeMaker();\n\t\tJCExpression annType = isJavaLangBased ? genJavaLangTypeRef(node, simpleName) : chainDotsString(node, annotationTypeFqn);\n\t\tList<JCExpression> argList = arg != null ? List.of(arg) : List.<JCExpression>nil();\n\t\tJCAnnotation annotation = recursiveSetGeneratedBy(maker.Annotation(annType, argList), source);\n\t\tmods.annotations = mods.annotations.append(annotation);\n\t}\n\t\n\tstatic JCExpression addCheckerFrameworkReturnsReceiver(JCExpression returnType, JavacTreeMaker maker, JavacNode typeNode, CheckerFrameworkVersion cfv) {\n\t\tif (cfv.generateReturnsReceiver()) {\n\t\t\tJCAnnotation rrAnnotation = maker.Annotation(genTypeRef(typeNode, CheckerFrameworkVersion.NAME__RETURNS_RECEIVER), List.<JCExpression>nil());\n\t\t\treturnType = maker.AnnotatedType(List.of(rrAnnotation), returnType);\n\t\t}\n\t\treturn returnType;\n\t}\n\t\n\tprivate static List<JCTree> addAllButOne(List<JCTree> defs, int idx) {\n\t\tListBuffer<JCTree> out = new ListBuffer<JCTree>();\n\t\tint i = 0;\n\t\tfor (JCTree def : defs) {\n\t\t\tif (i++ != idx) out.append(def);\n\t\t}\n\t\treturn out.toList();\n\t}\n\t\n\t/**\n\t * In javac, dotted access of any kind, from {@code java.lang.String} to {@code var.methodName}\n\t * is represented by a fold-left of {@code Select} nodes with the leftmost string represented by\n\t * a {@code Ident} node. This method generates such an expression.\n\t * <p>\n\t * The position of the generated node(s) will be unpositioned (-1).\n\t * \n\t * For example, maker.Select(maker.Select(maker.Ident(NAME[java]), NAME[lang]), NAME[String]).\n\t * \n\t * @see com.sun.tools.javac.tree.JCTree.JCIdent\n\t * @see com.sun.tools.javac.tree.JCTree.JCFieldAccess\n\t */\n\tpublic static JCExpression chainDots(JavacNode node, String elem1, String elem2, String... elems) {\n\t\treturn chainDots(node, -1, elem1, elem2, elems);\n\t}\n\t\n\tpublic static JCExpression chainDots(JavacNode node, String[] elems) {\n\t\treturn chainDots(node, -1, null, null, elems);\n\t}\n\t\n\tpublic static JCExpression chainDots(JavacNode node, LombokImmutableList<String> elems) {\n\t\tassert elems != null;\n\t\t\n\t\tJavacTreeMaker maker = node.getTreeMaker();\n\t\tJCExpression e = null;\n\t\tfor (String elem : elems) {\n\t\t\tif (e == null) e = maker.Ident(node.toName(elem));\n\t\t\telse e = maker.Select(e, node.toName(elem));\n\t\t}\n\t\treturn e;\n\t}\n\t\n\t/**\n\t * In javac, dotted access of any kind, from {@code java.lang.String} to {@code var.methodName}\n\t * is represented by a fold-left of {@code Select} nodes with the leftmost string represented by\n\t * a {@code Ident} node. This method generates such an expression.\n\t * <p>\n\t * The position of the generated node(s) will be equal to the {@code pos} parameter.\n\t *\n\t * For example, maker.Select(maker.Select(maker.Ident(NAME[java]), NAME[lang]), NAME[String]).\n\t * \n\t * @see com.sun.tools.javac.tree.JCTree.JCIdent\n\t * @see com.sun.tools.javac.tree.JCTree.JCFieldAccess\n\t */\n\tpublic static JCExpression chainDots(JavacNode node, int pos, String elem1, String elem2, String... elems) {\n\t\tassert elems != null;\n\t\t\n\t\tJavacTreeMaker maker = node.getTreeMaker();\n\t\tif (pos != -1) maker = maker.at(pos);\n\t\tJCExpression e = null;\n\t\tif (elem1 != null) e = maker.Ident(node.toName(elem1));\n\t\tif (elem2 != null) e = e == null ? maker.Ident(node.toName(elem2)) : maker.Select(e, node.toName(elem2));\n\t\tfor (int i = 0 ; i < elems.length ; i++) {\n\t\t\te = e == null ? maker.Ident(node.toName(elems[i])) : maker.Select(e, node.toName(elems[i]));\n\t\t}\n\t\t\n\t\tassert e != null;\n\t\t\n\t\treturn e;\n\t}\n\t\n\t/**\n\t * In javac, dotted access of any kind, from {@code java.lang.String} to {@code var.methodName}\n\t * is represented by a fold-left of {@code Select} nodes with the leftmost string represented by\n\t * a {@code Ident} node. This method generates such an expression.\n\t * \n\t * For example, maker.Select(maker.Select(maker.Ident(NAME[java]), NAME[lang]), NAME[String]).\n\t * \n\t * @see com.sun.tools.javac.tree.JCTree.JCIdent\n\t * @see com.sun.tools.javac.tree.JCTree.JCFieldAccess\n\t */\n\tpublic static JCExpression chainDotsString(JavacNode node, String elems) {\n\t\treturn chainDots(node, null, null, elems.split(\"\\\\.\"));\n\t}\n\t\n\t/**\n\t * Searches the given field node for annotations and returns each one that matches the provided regular expression pattern.\n\t * \n\t * Only the simple name is checked - the package and any containing class are ignored.\n\t */\n\tpublic static List<JCAnnotation> findAnnotations(JavacNode fieldNode, Pattern namePattern) {\n\t\tListBuffer<JCAnnotation> result = new ListBuffer<JCAnnotation>();\n\t\tfor (JavacNode child : fieldNode.down()) {\n\t\t\tif (child.getKind() == Kind.ANNOTATION) {\n\t\t\t\tJCAnnotation annotation = (JCAnnotation) child.get();\n\t\t\t\tString name = annotation.annotationType.toString();\n\t\t\t\tint idx = name.lastIndexOf(\".\");\n\t\t\t\tString suspect = idx == -1 ? name : name.substring(idx + 1);\n\t\t\t\tif (namePattern.matcher(suspect).matches()) {\n\t\t\t\t\tresult.append(annotation);\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\t\treturn result.toList();\n\t}\n\t\n\tpublic static String scanForNearestAnnotation(JavacNode node, String... anns) {\n\t\twhile (node != null) {\n\t\t\tfor (JavacNode ann : node.down()) {\n\t\t\t\tif (ann.getKind() != Kind.ANNOTATION) continue;\n\t\t\t\tJCAnnotation a = (JCAnnotation) ann.get();\n\t\t\t\tfor (String annToFind : anns) if (typeMatches(annToFind, node, a.annotationType)) return annToFind;\n\t\t\t}\n\t\t\tnode = node.up();\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\t\n\tpublic static boolean hasNonNullAnnotations(JavacNode node) {\n\t\tfor (JavacNode child : node.down()) {\n\t\t\tif (child.getKind() == Kind.ANNOTATION) {\n\t\t\t\tJCAnnotation annotation = (JCAnnotation) child.get();\n\t\t\t\tString annotationTypeName = getTypeName(annotation.annotationType);\n\t\t\t\tfor (String nn : NONNULL_ANNOTATIONS) if (typeMatches(nn, node, annotationTypeName)) return true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tpublic static boolean hasNonNullAnnotations(JavacNode node, List<JCAnnotation> anns) {\n\t\tif (anns == null) return false;\n\t\tfor (JCAnnotation ann : anns) {\n\t\t\tString annotationTypeName = getTypeName(ann.annotationType);\n\t\t\tfor (String nn : NONNULL_ANNOTATIONS) if (typeMatches(nn, node, annotationTypeName)) return true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Searches the given field node for annotations and returns each one that is 'copyable' (either via configuration or from the base list).\n\t */\n\tpublic static List<JCAnnotation> findCopyableAnnotations(JavacNode node) {\n\t\tJCAnnotation anno = null;\n\t\tString annoName = null;\n\t\tfor (JavacNode child : node.down()) {\n\t\t\tif (child.getKind() == Kind.ANNOTATION) {\n\t\t\t\tif (anno != null) {\n\t\t\t\t\tannoName = \"\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tJCAnnotation annotation = (JCAnnotation) child.get();\n\t\t\t\tannoName = annotation.annotationType.toString();\n\t\t\t\tanno = annotation;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (annoName == null) return List.nil();\n\t\t\n\t\tjava.util.List<TypeName> configuredCopyable = node.getAst().readConfiguration(ConfigurationKeys.COPYABLE_ANNOTATIONS);\n\t\t\n\t\tif (!annoName.isEmpty()) {\n\t\t\tfor (TypeName cn : configuredCopyable) if (cn != null && typeMatches(cn.toString(), node, annoName)) return List.of(anno);\n\t\t\tfor (String bn : BASE_COPYABLE_ANNOTATIONS) if (typeMatches(bn, node, annoName)) return List.of(anno);\n\t\t}\n\n\t\tListBuffer<JCAnnotation> result = new ListBuffer<JCAnnotation>();\n\t\tfor (JavacNode child : node.down()) {\n\t\t\tif (child.getKind() == Kind.ANNOTATION) {\n\t\t\t\tJCAnnotation annotation = (JCAnnotation) child.get();\n\t\t\t\tString annotationTypeName = getTypeName(annotation.annotationType);\n\t\t\t\tboolean match = false;\n\t\t\t\tfor (TypeName cn : configuredCopyable) if (cn != null && typeMatches(cn.toString(), node, annotationTypeName)) {\n\t\t\t\t\tresult.append(annotation);\n\t\t\t\t\tmatch = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!match) for (String bn : BASE_COPYABLE_ANNOTATIONS) if (typeMatches(bn, node, annotationTypeName)) {\n\t\t\t\t\tresult.append(annotation);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result.toList();\n\t}\n\t\n\t/**\n\t * Searches the given field node for annotations that are specifically intentioned to be copied to the setter.\n\t */\n\tpublic static List<JCAnnotation> findCopyableToSetterAnnotations(JavacNode node) {\n\t\treturn findAnnotationsInList(node, COPY_TO_SETTER_ANNOTATIONS);\n\t}\n\n\t/**\n\t * Searches the given field node for annotations that are specifically intentioned to be copied to the builder's singular method.\n\t */\n\tpublic static List<JCAnnotation> findCopyableToBuilderSingularSetterAnnotations(JavacNode node) {\n\t\treturn findAnnotationsInList(node, COPY_TO_BUILDER_SINGULAR_SETTER_ANNOTATIONS);\n\t}\n\t\n\t/**\n\t * Searches the given field node for annotations that are in the given list, and returns those.\n\t */\n\tprivate static List<JCAnnotation> findAnnotationsInList(JavacNode node, java.util.List<String> annotationsToFind) {\n\t\tJCAnnotation anno = null;\n\t\tString annoName = null;\n\t\tfor (JavacNode child : node.down()) {\n\t\t\tif (child.getKind() == Kind.ANNOTATION) {\n\t\t\t\tif (anno != null) {\n\t\t\t\t\tannoName = \"\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tJCAnnotation annotation = (JCAnnotation) child.get();\n\t\t\t\tannoName = annotation.annotationType.toString();\n\t\t\t\tanno = annotation;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (annoName == null) return List.nil();\n\t\t\n\t\tif (!annoName.isEmpty()) {\n\t\t\tfor (String bn : annotationsToFind) if (typeMatches(bn, node, annoName)) return List.of(anno);\n\t\t}\n\t\t\n\t\tListBuffer<JCAnnotation> result = new ListBuffer<JCAnnotation>();\n\t\tfor (JavacNode child : node.down()) {\n\t\t\tif (child.getKind() == Kind.ANNOTATION) {\n\t\t\t\tJCAnnotation annotation = (JCAnnotation) child.get();\n\t\t\t\tString annotationTypeName = getTypeName(annotation.annotationType);\n\t\t\t\tboolean match = false;\n\t\t\t\tif (!match) for (String bn : annotationsToFind) if (typeMatches(bn, node, annotationTypeName)) {\n\t\t\t\t\tresult.append(annotation);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result.toList();\n\t}\n\t\n\t/**\n\t * Generates a new statement that checks if the given variable is null, and if so, throws a configured exception with the\n\t * variable name as message.\n\t */\n\tpublic static JCStatement generateNullCheck(JavacTreeMaker maker, JavacNode variable, JavacNode source) {\n\t\treturn generateNullCheck(maker, (JCVariableDecl) variable.get(), source);\n\t}\n\t\n\t/**\n\t * Generates a new statement that checks if the given local is null, and if so, throws a configured exception with the\n\t * local variable name as message. \n\t */\n\tpublic static JCStatement generateNullCheck(JavacTreeMaker maker, JCExpression typeNode, Name varName, JavacNode source, String customMessage) {\n\t\tNullCheckExceptionType exceptionType = source.getAst().readConfiguration(ConfigurationKeys.NON_NULL_EXCEPTION_TYPE);\n\t\tif (exceptionType == null) exceptionType = NullCheckExceptionType.NULL_POINTER_EXCEPTION;\n\t\t\n\t\tif (typeNode != null && isPrimitive(typeNode)) return null;\n\t\tJCLiteral message = maker.Literal(exceptionType.toExceptionMessage(varName.toString(), customMessage));\n\t\t\n\t\tLombokImmutableList<String> method = exceptionType.getMethod();\n\t\tif (method != null) {\n\t\t\treturn maker.Exec(maker.Apply(List.<JCExpression>nil(), chainDots(source, method), List.of(maker.Ident(varName), message)));\n\t\t}\n\t\t\n\t\tif (exceptionType == NullCheckExceptionType.ASSERTION) {\n\t\t\treturn maker.Assert(maker.Binary(CTC_NOT_EQUAL, maker.Ident(varName), maker.Literal(CTC_BOT, null)), message);\n\t\t}\n\t\t\n\t\tJCExpression exType = genTypeRef(source, exceptionType.getExceptionType());\n\t\tJCExpression exception = maker.NewClass(null, List.<JCExpression>nil(), exType, List.<JCExpression>of(message), null);\n\t\tJCStatement throwStatement = maker.Throw(exception);\n\t\tJCBlock throwBlock = maker.Block(0, List.of(throwStatement));\n\t\treturn maker.If(maker.Binary(CTC_EQUAL, maker.Ident(varName), maker.Literal(CTC_BOT, null)), throwBlock, null);\n\t}\n\t\n\t/**\n\t * Generates a new statement that checks if the given variable is null, and if so, throws a configured exception with the\n\t * variable name as message. \n\t * \n\t * This is a special case method reserved for use when the provided declaration differs from the\n\t * variable's declaration, i.e. in a constructor or setter where the local parameter is named the same but with the prefix\n\t * stripped as a result of @Accessors.prefix.\n\t */\n\tpublic static JCStatement generateNullCheck(JavacTreeMaker maker, JCVariableDecl varDecl, JavacNode source) {\n\t\treturn generateNullCheck(maker, varDecl.vartype, varDecl.name, source, null);\n\t}\n\t\n\t/**\n\t * Given a list of field names and a node referring to a type, finds each name in the list that does not match a field within the type.\n\t */\n\tpublic static List<Integer> createListOfNonExistentFields(List<String> list, JavacNode type, boolean excludeStandard, boolean excludeTransient) {\n\t\tboolean[] matched = new boolean[list.size()];\n\t\t\n\t\tfor (JavacNode child : type.down()) {\n\t\t\tif (list.isEmpty()) break;\n\t\t\tif (child.getKind() != Kind.FIELD) continue;\n\t\t\tJCVariableDecl field = (JCVariableDecl)child.get();\n\t\t\tif (excludeStandard) {\n\t\t\t\tif ((field.mods.flags & Flags.STATIC) != 0) continue;\n\t\t\t\tif (field.name.toString().startsWith(\"$\")) continue;\n\t\t\t}\n\t\t\tif (excludeTransient && (field.mods.flags & Flags.TRANSIENT) != 0) continue;\n\t\t\t\n\t\t\tint idx = list.indexOf(child.getName());\n\t\t\tif (idx > -1) matched[idx] = true;\n\t\t}\n\t\t\n\t\tListBuffer<Integer> problematic = new ListBuffer<Integer>();\n\t\tfor (int i = 0 ; i < list.size() ; i++) {\n\t\t\tif (!matched[i]) problematic.append(i);\n\t\t}\n\t\t\n\t\treturn problematic.toList();\n\t}\n\t\n\tstatic List<JCAnnotation> unboxAndRemoveAnnotationParameter(JCAnnotation ast, String parameterName, String errorName, JavacNode annotationNode) {\n\t\tListBuffer<JCExpression> params = new ListBuffer<JCExpression>();\n\t\tListBuffer<JCAnnotation> result = new ListBuffer<JCAnnotation>();\n\t\t\n\t\touter:\n\t\tfor (JCExpression param : ast.args) {\n\t\t\tboolean allowRaw;\n\t\t\tString nameOfParam = \"value\";\n\t\t\tJCExpression valueOfParam = null;\n\t\t\tif (param instanceof JCAssign) {\n\t\t\t\tJCAssign assign = (JCAssign) param;\n\t\t\t\tif (assign.lhs instanceof JCIdent) {\n\t\t\t\t\tJCIdent ident = (JCIdent) assign.lhs;\n\t\t\t\t\tnameOfParam = ident.name.toString();\n\t\t\t\t}\n\t\t\t\tvalueOfParam = assign.rhs;\n\t\t\t}\n\t\t\t\n\t\t\t/* strip trailing underscores */ {\n\t\t\t\tint lastIdx;\n\t\t\t\tfor (lastIdx = nameOfParam.length() ; lastIdx > 0; lastIdx--) {\n\t\t\t\t\tif (nameOfParam.charAt(lastIdx - 1) != '_') break;\n\t\t\t\t}\n\t\t\t\tallowRaw = lastIdx < nameOfParam.length();\n\t\t\t\tnameOfParam = nameOfParam.substring(0, lastIdx);\n\t\t\t}\n\t\t\t\n\t\t\tif (!parameterName.equals(nameOfParam)) {\n\t\t\t\tparams.append(param);\n\t\t\t\tcontinue outer;\n\t\t\t}\n\t\t\t\n\t\t\tint endPos = Javac.getEndPosition(param.pos(), (JCCompilationUnit) annotationNode.top().get());\n\t\t\tannotationNode.getAst().removeFromDeferredDiagnostics(param.pos, endPos);\n\t\t\t\n\t\t\tif (valueOfParam instanceof JCAnnotation) {\n\t\t\t\tString dummyAnnotationName = ((JCAnnotation) valueOfParam).annotationType.toString();\n\t\t\t\tdummyAnnotationName = dummyAnnotationName.replace(\"_\", \"\").replace(\"$\", \"\").replace(\"x\", \"\").replace(\"X\", \"\");\n\t\t\t\tif (dummyAnnotationName.length() > 0) {\n\t\t\t\t\tif (allowRaw) {\n\t\t\t\t\t\tresult.append((JCAnnotation) valueOfParam);\n\t\t\t\t\t} else {\n\t\t\t\t\t\taddError(errorName, annotationNode);\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (JCExpression expr : ((JCAnnotation) valueOfParam).args) {\n\t\t\t\t\t\tif (expr instanceof JCAssign && ((JCAssign) expr).lhs instanceof JCIdent) {\n\t\t\t\t\t\t\tJCIdent id = (JCIdent) ((JCAssign) expr).lhs;\n\t\t\t\t\t\t\tif (\"value\".equals(id.name.toString())) {\n\t\t\t\t\t\t\t\texpr = ((JCAssign) expr).rhs;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\taddError(errorName, annotationNode);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (expr instanceof JCAnnotation) {\n\t\t\t\t\t\t\tresult.append((JCAnnotation) expr);\n\t\t\t\t\t\t} else if (expr instanceof JCNewArray) {\n\t\t\t\t\t\t\tfor (JCExpression expr2 : ((JCNewArray) expr).elems) {\n\t\t\t\t\t\t\t\tif (expr2 instanceof JCAnnotation) {\n\t\t\t\t\t\t\t\t\tresult.append((JCAnnotation) expr2);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\taddError(errorName, annotationNode);\n\t\t\t\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\taddError(errorName, annotationNode);\n\t\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (valueOfParam instanceof JCNewArray) {\n\t\t\t\tJCNewArray arr = (JCNewArray) valueOfParam;\n\t\t\t\tif (arr.elems.isEmpty()) {\n\t\t\t\t\t// Just remove it, this is always fine.\n\t\t\t\t} else if (allowRaw) {\n\t\t\t\t\tfor (JCExpression jce : arr.elems) {\n\t\t\t\t\t\tif (jce instanceof JCAnnotation) result.append((JCAnnotation) jce);\n\t\t\t\t\t\telse addError(errorName, annotationNode);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\taddError(errorName, annotationNode);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\taddError(errorName, annotationNode);\n\t\t\t}\n\t\t}\n\t\tfor (JCAnnotation annotation : result) {\n\t\t\tclearTypes(annotation);\n\t\t}\n\t\tast.args = params.toList();\n\t\treturn result.toList();\n\t}\n\t\n\t/**\n\t * Removes all type information from the provided tree.\n\t */\n\tprivate static void clearTypes(JCTree tree) {\n\t\ttree.accept(new TreeScanner() {\n\t\t\t@Override public void scan(JCTree tree) {\n\t\t\t\tif (tree == null) return;\n\t\t\t\ttree.type = null;\n\t\t\t\tsuper.scan(tree);\n\t\t\t}\n\t\t\t@Override public void visitClassDef(JCClassDecl tree) {\n\t\t\t\ttree.sym = null;\n\t\t\t\tsuper.visitClassDef(tree);\n\t\t\t}\n\t\t\t@Override public void visitMethodDef(JCMethodDecl tree) {\n\t\t\t\ttree.sym = null;\n\t\t\t\tsuper.visitMethodDef(tree);\n\t\t\t}\n\t\t\t@Override public void visitVarDef(JCVariableDecl tree) {\n\t\t\t\ttree.sym = null;\n\t\t\t\tsuper.visitVarDef(tree);\n\t\t\t}\n\t\t\t@Override public void visitSelect(JCFieldAccess tree) {\n\t\t\t\ttree.sym = null;\n\t\t\t\tsuper.visitSelect(tree);\n\t\t\t}\n\t\t\t@Override public void visitIdent(JCIdent tree) {\n\t\t\t\ttree.sym = null;\n\t\t\t\tsuper.visitIdent(tree);\n\t\t\t}\n\t\t\t@Override public void visitAnnotation(JCAnnotation tree) {\n\t\t\t\tJCAnnotationReflect.setAttribute(tree, null);\n\t\t\t\tsuper.visitAnnotation(tree);\n\t\t\t}\n\t\t});\n\t}\n\t\n\tprivate static void addError(String errorName, JavacNode node) {\n\t\tif (node.getLatestJavaSpecSupported() < 8) {\n\t\t\tnode.addError(\"The correct format up to JDK7 is \" + errorName + \"=@__({@SomeAnnotation, @SomeOtherAnnotation}))\");\n\t\t} else {\n\t\t\tnode.addError(\"The correct format for JDK8+ is \" + errorName + \"_={@SomeAnnotation, @SomeOtherAnnotation})\");\n\t\t}\n\t}\n\t\n\tpublic static List<JCTypeParameter> copyTypeParams(JavacNode source, List<JCTypeParameter> params) {\n\t\tif (params == null || params.isEmpty()) return params;\n\t\tListBuffer<JCTypeParameter> out = new ListBuffer<JCTypeParameter>();\n\t\tJavacTreeMaker maker = source.getTreeMaker();\n\t\tfor (JCTypeParameter tp : params) {\n\t\t\tList<JCExpression> bounds = tp.bounds;\n\t\t\tif (bounds != null && !bounds.isEmpty()) {\n\t\t\t\tListBuffer<JCExpression> boundsCopy = new ListBuffer<JCExpression>();\n\t\t\t\tfor (JCExpression expr : tp.bounds) {\n\t\t\t\t\tboundsCopy.append(cloneType(maker, expr, source));\n\t\t\t\t}\n\t\t\t\tbounds = boundsCopy.toList();\n\t\t\t}\n\t\t\tout.append(maker.TypeParameter(tp.name, bounds));\n\t\t}\n\t\treturn out.toList();\n\t}\n\t\n\tpublic static List<JCAnnotation> getTypeUseAnnotations(JCExpression from) {\n\t\tif (!JCAnnotatedTypeReflect.is(from)) return List.nil();\n\t\treturn JCAnnotatedTypeReflect.getAnnotations(from);\n\t}\n\t\n\tpublic static JCExpression removeTypeUseAnnotations(JCExpression from) {\n\t\tif (!JCAnnotatedTypeReflect.is(from)) return from;\n\t\treturn JCAnnotatedTypeReflect.getUnderlyingType(from);\n\t}\n\t\n\tpublic static JCExpression namePlusTypeParamsToTypeReference(JavacTreeMaker maker, JavacNode type, List<JCTypeParameter> params) {\n\t\tJCClassDecl td = (JCClassDecl) type.get();\n\t\tboolean instance = (td.mods.flags & Flags.STATIC) == 0;\n\t\treturn namePlusTypeParamsToTypeReference(maker, type.up(), td.name, instance, params, List.<JCAnnotation>nil());\n\t}\n\t\n\tpublic static JCExpression namePlusTypeParamsToTypeReference(JavacTreeMaker maker, JavacNode type, List<JCTypeParameter> params, List<JCAnnotation> annotations) {\n\t\tJCClassDecl td = (JCClassDecl) type.get();\n\t\tboolean instance = (td.mods.flags & Flags.STATIC) == 0;\n\t\treturn namePlusTypeParamsToTypeReference(maker, type.up(), td.name, instance, params, annotations);\n\t}\n\t\n\tpublic static JCExpression namePlusTypeParamsToTypeReference(JavacTreeMaker maker, JavacNode parentType, Name typeName, boolean instance, List<JCTypeParameter> params) {\n\t\treturn namePlusTypeParamsToTypeReference(maker, parentType, typeName, instance, params, List.<JCAnnotation>nil());\n\t}\n\t\n\tpublic static JCExpression namePlusTypeParamsToTypeReference(JavacTreeMaker maker, JavacNode parentType, Name typeName, boolean instance, List<JCTypeParameter> params, List<JCAnnotation> annotations) {\n\t\tJCExpression r = null;\n\t\tif (parentType != null && parentType.getKind() == Kind.TYPE && !parentType.getName().isEmpty()) {\n\t\t\tJCClassDecl td = (JCClassDecl) parentType.get();\n\t\t\tboolean outerInstance = instance && ((td.mods.flags & Flags.STATIC) == 0);\n\t\t\tList<JCTypeParameter> outerParams = instance ? td.typarams : List.<JCTypeParameter>nil();\n\t\t\tr = namePlusTypeParamsToTypeReference(maker, parentType.up(), td.name, outerInstance, outerParams, List.<JCAnnotation>nil());\n\t\t}\n\t\t\n\t\tr = r == null ? maker.Ident(typeName) : maker.Select(r, typeName);\n\t\tif (!annotations.isEmpty()) r = JCAnnotatedTypeReflect.create(annotations, r);\n\t\tif (!params.isEmpty()) r = maker.TypeApply(r, typeParameterNames(maker, params));\n\t\treturn r;\n\t}\n\t\n\tpublic static List<JCExpression> typeParameterNames(JavacTreeMaker maker, List<JCTypeParameter> params) {\n\t\tListBuffer<JCExpression> typeArgs = new ListBuffer<JCExpression>();\n\t\tfor (JCTypeParameter param : params) {\n\t\t\ttypeArgs.append(maker.Ident(param.name));\n\t\t}\n\t\treturn typeArgs.toList();\n\t}\n\t\n\tpublic static void sanityCheckForMethodGeneratingAnnotationsOnBuilderClass(JavacNode typeNode, JavacNode errorNode) {\n\t\tList<String> disallowed = List.nil();\n\t\tfor (JavacNode child : typeNode.down()) {\n\t\t\tfor (String annType : INVALID_ON_BUILDERS) {\n\t\t\t\tif (annotationTypeMatches(annType, child)) {\n\t\t\t\t\tint lastIndex = annType.lastIndexOf('.');\n\t\t\t\t\tdisallowed = disallowed.append(lastIndex == -1 ? annType : annType.substring(lastIndex + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint size = disallowed.size();\n\t\tif (size == 0) return;\n\t\tif (size == 1) {\n\t\t\terrorNode.addError(\"@\" + disallowed.head + \" is not allowed on builder classes.\");\n\t\t\treturn;\n\t\t}\n\t\tStringBuilder out = new StringBuilder();\n\t\tfor (String a : disallowed) out.append(\"@\").append(a).append(\", \");\n\t\tout.setLength(out.length() - 2);\n\t\terrorNode.addError(out.append(\" are not allowed on builder classes.\").toString());\n\t}\n\t\n\tstatic List<JCAnnotation> copyAnnotations(List<? extends JCExpression> in) {\n\t\tListBuffer<JCAnnotation> out = new ListBuffer<JCAnnotation>();\n\t\tfor (JCExpression expr : in) {\n\t\t\tif (!(expr instanceof JCAnnotation)) continue;\n\t\t\tout.append((JCAnnotation) expr.clone());\n\t\t}\n\t\treturn out.toList();\n\t}\n\t\n\tstatic List<JCAnnotation> mergeAnnotations(List<JCAnnotation> a, List<JCAnnotation> b) {\n\t\tif (a == null || a.isEmpty()) return b;\n\t\tif (b == null || b.isEmpty()) return a;\n\t\tListBuffer<JCAnnotation> out = new ListBuffer<JCAnnotation>();\n\t\tfor (JCAnnotation ann : a) out.append(ann);\n\t\tfor (JCAnnotation ann : b) out.append(ann);\n\t\treturn out.toList();\n\t}\n\t\n\t/**\n\t * Returns {@code true} if the provided node is an actual class and not some other type declaration (so, not an annotation definition, interface, enum, or record).\n\t */\n\tpublic static boolean isClass(JavacNode typeNode) {\n\t\treturn isClassAndDoesNotHaveFlags(typeNode, Flags.INTERFACE | Flags.ENUM | Flags.ANNOTATION | RECORD);\n\t}\n\t\n\t/**\n\t * Returns {@code true} if the provided node is an actual class or enum and not some other type declaration (so, not an annotation definition, interface, or record).\n\t */\n\tpublic static boolean isClassOrEnum(JavacNode typeNode) {\n\t\treturn isClassAndDoesNotHaveFlags(typeNode, Flags.INTERFACE | Flags.ANNOTATION | RECORD);\n\t}\n\t\n\tpublic static boolean isClassOrEnumOrInterface(JavacNode typeNode) {\n\t\treturn isClassAndDoesNotHaveFlags(typeNode, Flags.ANNOTATION | RECORD);\n\t}\n\t\n\t/**\n\t * Returns {@code true} if the provided node is an actual class, an enum or a record and not some other type declaration (so, not an annotation definition or interface).\n\t */\n\tpublic static boolean isClassEnumOrRecord(JavacNode typeNode) {\n\t\treturn isClassAndDoesNotHaveFlags(typeNode, Flags.INTERFACE | Flags.ANNOTATION);\n\t}\n\t\n\t/**\n\t * Returns {@code true} if the provided node is a record declaration (so, not an annotation definition, interface, enum, or plain class).\n\t */\n\tpublic static boolean isRecord(JavacNode typeNode) {\n\t\treturn typeNode.getKind() == Kind.TYPE && (((JCClassDecl) typeNode.get()).mods.flags & RECORD) != 0;\n\t}\n\t\n\tpublic static boolean isClassAndDoesNotHaveFlags(JavacNode typeNode, long flags) {\n\t\tJCClassDecl typeDecl = null;\n\t\tif (typeNode.get() instanceof JCClassDecl) typeDecl = (JCClassDecl) typeNode.get();\n\t\telse return false;\n\t\t\n\t\tlong typeDeclflags = typeDecl == null ? 0 : typeDecl.mods.flags;\n\t\treturn (typeDeclflags & flags) == 0;\n\t}\n\t\n\t/**\n\t * Returns {@code true} if the provided node supports static methods and types (top level or static class)\n\t */\n\tpublic static boolean isStaticAllowed(JavacNode typeNode) {\n\t\treturn typeNode.isStatic() || typeNode.up() == null || typeNode.up().getKind() == Kind.COMPILATION_UNIT || isRecord(typeNode);\n\t}\n\t\n\tpublic static JavacNode upToTypeNode(JavacNode node) {\n\t\tif (node == null) throw new NullPointerException(\"node\");\n\t\twhile ((node != null) && !(node.get() instanceof JCClassDecl)) node = node.up();\n\t\t\n\t\treturn node;\n\t}\n\t\n\tpublic static List<JCExpression> cloneTypes(JavacTreeMaker maker, List<JCExpression> in, JavacNode source) {\n\t\tif (in.isEmpty()) return List.nil();\n\t\tif (in.size() == 1) return List.of(cloneType(maker, in.get(0), source));\n\t\tListBuffer<JCExpression> lb = new ListBuffer<JCExpression>();\n\t\tfor (JCExpression expr : in) lb.append(cloneType(maker, expr, source));\n\t\treturn lb.toList();\n\t}\n\t\n\t/**\n\t * Creates a full clone of a given javac AST type node. Every part is cloned (every identifier, every select, every wildcard, every type apply, every type_use annotation).\n\t * \n\t * If there's any node in the tree that we don't know how to clone, that part isn't cloned. However, we wouldn't know what could possibly show up that we\n\t * can't currently clone; that's just a safeguard.\n\t * \n\t * This should be used if the type looks the same in the code, but resolves differently. For example, a static method that has some generics in it named after\n\t * the class's own parameter, but as its a static method, the static method's notion of {@code T} is different from the class notion of {@code T}. If you're duplicating\n\t * a type used in the class context, you need to use this method.\n\t */\n\tpublic static JCExpression cloneType(JavacTreeMaker maker, JCExpression in, JavacNode source) {\n\t\tJCExpression out = cloneType0(maker, in);\n\t\tif (out != null) recursiveSetGeneratedBy(out, source);\n\t\treturn out;\n\t}\n\t\n\tprivate static JCExpression cloneType0(JavacTreeMaker maker, JCTree in) {\n\t\tif (in == null) return null;\n\t\t\n\t\tif (in instanceof JCPrimitiveTypeTree) {\n\t\t\treturn maker.TypeIdent(TypeTag.typeTag(in));\n\t\t}\n\t\t\n\t\tif (in instanceof JCIdent) {\n\t\t\treturn maker.Ident(((JCIdent) in).name);\n\t\t}\n\t\t\n\t\tif (in instanceof JCFieldAccess) {\n\t\t\tJCFieldAccess fa = (JCFieldAccess) in;\n\t\t\treturn maker.Select(cloneType0(maker, fa.selected), fa.name);\n\t\t}\n\t\t\n\t\tif (in instanceof JCArrayTypeTree) {\n\t\t\tJCArrayTypeTree att = (JCArrayTypeTree) in;\n\t\t\treturn maker.TypeArray(cloneType0(maker, att.elemtype));\n\t\t}\n\t\t\n\t\tif (in instanceof JCTypeApply) {\n\t\t\tJCTypeApply ta = (JCTypeApply) in;\n\t\t\tListBuffer<JCExpression> lb = new ListBuffer<JCExpression>();\n\t\t\tfor (JCExpression typeArg : ta.arguments) {\n\t\t\t\tlb.append(cloneType0(maker, typeArg));\n\t\t\t}\n\t\t\treturn maker.TypeApply(cloneType0(maker, ta.clazz), lb.toList());\n\t\t}\n\t\t\n\t\tif (in instanceof JCWildcard) {\n\t\t\tJCWildcard w = (JCWildcard) in;\n\t\t\tJCExpression newInner = cloneType0(maker, w.inner);\n\t\t\tTypeBoundKind newKind;\n\t\t\tswitch (w.getKind()) {\n\t\t\tcase SUPER_WILDCARD:\n\t\t\t\tnewKind = maker.TypeBoundKind(BoundKind.SUPER);\n\t\t\t\tbreak;\n\t\t\tcase EXTENDS_WILDCARD:\n\t\t\t\tnewKind = maker.TypeBoundKind(BoundKind.EXTENDS);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\tcase UNBOUNDED_WILDCARD:\n\t\t\t\tnewKind = maker.TypeBoundKind(BoundKind.UNBOUND);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn maker.Wildcard(newKind, newInner);\n\t\t}\n\t\t\n\t\tif (JCAnnotatedTypeReflect.is(in)) {\n\t\t\tJCExpression underlyingType = cloneType0(maker, JCAnnotatedTypeReflect.getUnderlyingType(in));\n\t\t\tList<JCAnnotation> anns = copyAnnotations(JCAnnotatedTypeReflect.getAnnotations(in));\n\t\t\treturn JCAnnotatedTypeReflect.create(anns, underlyingType);\n\t\t}\n\t\t\n\t\t// This is somewhat unsafe, but it's better than outright throwing an exception here. Returning null will just cause an exception down the pipeline.\n\t\treturn (JCExpression) in;\n\t}\n\t\n\tpublic static enum CopyJavadoc {\n\t\tVERBATIM {\n\t\t\t@Override public String apply(final JCCompilationUnit cu, final JavacNode node) {\n\t\t\t\treturn Javac.getDocComment(cu, node.get());\n\t\t\t}\n\t\t},\n\t\tGETTER {\n\t\t\t@Override public String apply(final JCCompilationUnit cu, final JavacNode node) {\n\t\t\t\tfinal JCTree n = node.get();\n\t\t\t\tString javadoc = Javac.getDocComment(cu, n);\n\t\t\t\t// step 1: Check if there is a 'GETTER' section. If yes, that becomes the new method's javadoc.\n\t\t\t\tString out = getJavadocSection(javadoc, \"GETTER\");\n\t\t\t\tfinal boolean sectionBased = out != null;\n\t\t\t\tif (!sectionBased) {\n\t\t\t\t\tout = stripLinesWithTagFromJavadoc(stripSectionsFromJavadoc(javadoc), JavadocTag.PARAM);\n\t\t\t\t}\n\t\t\t\tnode.getAst().cleanupTask(\"javadocfilter-getter\", n, new CleanupTask() {\n\t\t\t\t\t@Override public void cleanup() {\n\t\t\t\t\t\tString javadoc = Javac.getDocComment(cu, n);\n\t\t\t\t\t\tif (javadoc == null || javadoc.isEmpty()) return;\n\t\t\t\t\t\tjavadoc = stripSectionsFromJavadoc(javadoc);\n\t\t\t\t\t\tif (!sectionBased) {\n\t\t\t\t\t\t\tjavadoc = stripLinesWithTagFromJavadoc(stripSectionsFromJavadoc(javadoc), JavadocTag.RETURN);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tJavac.setDocComment(cu, n, javadoc);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn out;\n\t\t\t}\n\t\t},\n\t\tSETTER {\n\t\t\t@Override public String apply(final JCCompilationUnit cu, final JavacNode node) {\n\t\t\t\treturn applySetter(cu, node, \"SETTER\");\n\t\t\t}\n\t\t},\n\t\tWITH {\n\t\t\t@Override public String apply(final JCCompilationUnit cu, final JavacNode node) {\n\t\t\t\treturn addReturnsUpdatedSelfIfNeeded(applySetter(cu, node, \"WITH|WITHER\"));\n\t\t\t}\n\t\t},\n\t\tWITH_BY {\n\t\t\t@Override public String apply(final JCCompilationUnit cu, final JavacNode node) {\n\t\t\t\treturn applySetter(cu, node, \"WITHBY|WITH_BY\");\n\t\t\t}\n\t\t};\n\t\t\n\t\tpublic abstract String apply(final JCCompilationUnit cu, final JavacNode node);\n\t\t\n\t\tprivate static String applySetter(final JCCompilationUnit cu, JavacNode node, String sectionName) {\n\t\t\tfinal JCTree n = node.get();\n\t\t\tString javadoc = Javac.getDocComment(cu, n);\n\t\t\t// step 1: Check if there is a 'SETTER' section. If yes, that becomes the new method's javadoc.\n\t\t\tString out = getJavadocSection(javadoc, sectionName);\n\t\t\tfinal boolean sectionBased = out != null;\n\t\t\tif (!sectionBased) {\n\t\t\t\tout = stripLinesWithTagFromJavadoc(stripSectionsFromJavadoc(javadoc), JavadocTag.RETURN);\n\t\t\t}\n\t\t\tnode.getAst().cleanupTask(\"javadocfilter-setter\", n, new CleanupTask() {\n\t\t\t\t@Override public void cleanup() {\n\t\t\t\t\tString javadoc = Javac.getDocComment(cu, n);\n\t\t\t\t\tif (javadoc == null || javadoc.isEmpty()) return;\n\t\t\t\t\tjavadoc = stripSectionsFromJavadoc(javadoc);\n\t\t\t\t\tif (!sectionBased) {\n\t\t\t\t\t\tjavadoc = stripLinesWithTagFromJavadoc(stripSectionsFromJavadoc(javadoc), JavadocTag.PARAM);\n\t\t\t\t\t}\n\t\t\t\t\tJavac.setDocComment(cu, n, javadoc);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn shouldReturnThis(node, JavacHandlerUtil.getAccessorsForField(node)) ? addReturnsThisIfNeeded(out) : out;\n\t\t}\n\t}\n\t\n\tpublic static void copyJavadoc(JavacNode from, JCTree to, CopyJavadoc copyMode) {\n\t\tcopyJavadoc(from, to, copyMode, false);\n\t}\n\t\n\t/**\n\t * Copies javadoc on one node to the other.\n\t * \n\t * in 'GETTER' copyMode, first a 'GETTER' segment is searched for. If it exists, that will become the javadoc for the 'to' node, and this section is\n\t * stripped out of the 'from' node. If no 'GETTER' segment is found, then the entire javadoc is taken minus any {@code @param} lines and other sections.\n\t * any {@code @return} lines are stripped from 'from'.\n\t * \n\t * in 'SETTER' mode, stripping works similarly to 'GETTER' mode, except {@code param} are copied and stripped from the original and {@code @return} are skipped.\n\t */\n\tpublic static void copyJavadoc(JavacNode from, JCTree to, CopyJavadoc copyMode, boolean forceAddReturn) {\n\t\tif (copyMode == null) copyMode = CopyJavadoc.VERBATIM;\n\t\ttry {\n\t\t\tJCCompilationUnit cu = ((JCCompilationUnit) from.top().get());\n\t\t\tString newJavadoc = copyMode.apply(cu, from);\n\t\t\tif (forceAddReturn) {\n\t\t\t\tnewJavadoc = addReturnsThisIfNeeded(newJavadoc);\n\t\t\t}\n\t\t\tJavac.setDocComment(cu, to, newJavadoc);\n\t\t} catch (Exception ignore) {}\n\t}\n\t\n\tpublic static boolean isDirectDescendantOfObject(JavacNode typeNode) {\n\t\tif (!(typeNode.get() instanceof JCClassDecl)) throw new IllegalArgumentException(\"not a type node\");\n\t\tJCTree extending = Javac.getExtendsClause((JCClassDecl) typeNode.get());\n\t\tif (extending == null) return true;\n\t\tString p = extending.toString();\n\t\treturn p.equals(\"Object\") || p.equals(\"java.lang.Object\");\n\t}\n\t\n\tpublic static void createRelevantNullableAnnotation(JavacNode typeNode, JCMethodDecl mth) {\n\t\tNullAnnotationLibrary lib = typeNode.getAst().readConfiguration(ConfigurationKeys.ADD_NULL_ANNOTATIONS);\n\t\tif (lib == null) return;\n\t\tapplyAnnotationToMethodDecl(typeNode, mth, lib.getNullableAnnotation(), lib.isTypeUse());\n\t}\n\t\n\tpublic static void createRelevantNonNullAnnotation(JavacNode typeNode, JCMethodDecl mth) {\n\t\tNullAnnotationLibrary lib = typeNode.getAst().readConfiguration(ConfigurationKeys.ADD_NULL_ANNOTATIONS);\n\t\tif (lib == null) return;\n\t\tapplyAnnotationToMethodDecl(typeNode, mth, lib.getNonNullAnnotation(), lib.isTypeUse());\n\t}\n\t\n\tpublic static void createRelevantNonNullAnnotation(JavacNode typeNode, JCVariableDecl arg) {\n\t\tNullAnnotationLibrary lib = typeNode.getAst().readConfiguration(ConfigurationKeys.ADD_NULL_ANNOTATIONS);\n\t\tif (lib == null) return;\n\t\t\n\t\tapplyAnnotationToVarDecl(typeNode, arg, lib.getNonNullAnnotation(), lib.isTypeUse());\n\t}\n\t\n\tpublic static void createRelevantNullableAnnotation(JavacNode typeNode, JCVariableDecl arg) {\n\t\tNullAnnotationLibrary lib = typeNode.getAst().readConfiguration(ConfigurationKeys.ADD_NULL_ANNOTATIONS);\n\t\tif (lib == null) return;\n\t\t\n\t\tapplyAnnotationToVarDecl(typeNode, arg, lib.getNullableAnnotation(), lib.isTypeUse());\n\t}\n\t\n\tprivate static void applyAnnotationToMethodDecl(JavacNode typeNode, JCMethodDecl mth, String annType, boolean typeUse) {\n\t\tif (annType == null) return;\n\t\tJavacTreeMaker maker = typeNode.getTreeMaker();\n\t\t\n\t\tJCAnnotation m = maker.Annotation(genTypeRef(typeNode, annType), List.<JCExpression>nil());\n\t\tif (typeUse) {\n\t\t\tJCExpression resType = mth.restype;\n\t\t\tif (resType instanceof JCTypeApply) {\n\t\t\t\tJCTypeApply ta = (JCTypeApply) resType;\n\t\t\t\tif (ta.clazz instanceof JCFieldAccess) {\n\t\t\t\t\tmth.restype = maker.TypeApply(maker.AnnotatedType(List.of(m), ta.clazz), ta.arguments);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tresType = ta.clazz;\n\t\t\t}\n\t\t\t\n\t\t\tif (resType instanceof JCFieldAccess || resType instanceof JCArrayTypeTree) {\n\t\t\t\tmth.restype = maker.AnnotatedType(List.of(m), resType);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif (JCAnnotatedTypeReflect.is(resType)) {\n\t\t\t\tList<JCAnnotation> annotations = JCAnnotatedTypeReflect.getAnnotations(resType);\n\t\t\t\tJCAnnotatedTypeReflect.setAnnotations(resType, annotations.prepend(m));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif (resType instanceof JCPrimitiveTypeTree || resType instanceof JCIdent) {\n\t\t\t\tmth.mods.annotations = mth.mods.annotations == null ? List.of(m) : mth.mods.annotations.prepend(m);\n\t\t\t}\n\t\t} else {\n\t\t\tmth.mods.annotations = mth.mods.annotations == null ? List.of(m) : mth.mods.annotations.prepend(m);\n\t\t}\n\t}\n\t\n\tprivate static void applyAnnotationToVarDecl(JavacNode typeNode, JCVariableDecl arg, String annType, boolean typeUse) {\n\t\tif (annType == null) return;\n\t\tJavacTreeMaker maker = typeNode.getTreeMaker();\n\t\t\n\t\tJCAnnotation m = maker.Annotation(genTypeRef(typeNode, annType), List.<JCExpression>nil());\n\t\tif (typeUse) {\n\t\t\tJCExpression varType = arg.vartype;\n\t\t\tJCTypeApply ta = null;\n\t\t\tif (varType instanceof JCTypeApply) {\n\t\t\t\tta = (JCTypeApply) varType;\n\t\t\t\tvarType = ta.clazz;\n\t\t\t}\n\t\t\t\n\t\t\tif (varType instanceof JCFieldAccess || varType instanceof JCArrayTypeTree) {\n\t\t\t\tvarType = maker.AnnotatedType(List.of(m), varType);\n\t\t\t\tif (ta != null) ta.clazz = varType;\n\t\t\t\telse arg.vartype = varType;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif (JCAnnotatedTypeReflect.is(varType)) {\n\t\t\t\tList<JCAnnotation> annotations = JCAnnotatedTypeReflect.getAnnotations(varType);\n\t\t\t\tJCAnnotatedTypeReflect.setAnnotations(varType, annotations.prepend(m));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif (varType instanceof JCPrimitiveTypeTree || varType instanceof JCIdent) {\n\t\t\t\targ.mods.annotations = arg.mods.annotations == null ? List.of(m) : arg.mods.annotations.prepend(m);\n\t\t\t}\n\t\t} else {\n\t\t\targ.mods.annotations = arg.mods.annotations == null ? List.of(m) : arg.mods.annotations.prepend(m);\n\t\t}\n\t}\n}\n","lineNo":1628}
{"Smelly Sample":"/*\n * Copyright (C) 2009-2022 The Project Lombok Authors.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage lombok.javac.handlers;\n\nimport static com.sun.tools.javac.code.Flags.GENERATEDCONSTR;\nimport static lombok.core.handlers.HandlerUtil.*;\nimport static lombok.javac.Javac.*;\nimport static lombok.javac.JavacAugments.JCTree_generatedNode;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.regex.Pattern;\n\nimport com.sun.tools.javac.code.Attribute;\nimport com.sun.tools.javac.code.BoundKind;\nimport com.sun.tools.javac.code.Flags;\nimport com.sun.tools.javac.code.Scope;\nimport com.sun.tools.javac.code.Symbol;\nimport com.sun.tools.javac.code.Symbol.ClassSymbol;\nimport com.sun.tools.javac.code.Symbol.TypeSymbol;\nimport com.sun.tools.javac.code.Type;\nimport com.sun.tools.javac.comp.Annotate;\nimport com.sun.tools.javac.comp.AttrContext;\nimport com.sun.tools.javac.comp.Enter;\nimport com.sun.tools.javac.comp.Env;\nimport com.sun.tools.javac.comp.MemberEnter;\nimport com.sun.tools.javac.tree.JCTree;\nimport com.sun.tools.javac.tree.JCTree.JCAnnotation;\nimport com.sun.tools.javac.tree.JCTree.JCArrayTypeTree;\nimport com.sun.tools.javac.tree.JCTree.JCAssign;\nimport com.sun.tools.javac.tree.JCTree.JCBlock;\nimport com.sun.tools.javac.tree.JCTree.JCClassDecl;\nimport com.sun.tools.javac.tree.JCTree.JCCompilationUnit;\nimport com.sun.tools.javac.tree.JCTree.JCExpression;\nimport com.sun.tools.javac.tree.JCTree.JCExpressionStatement;\nimport com.sun.tools.javac.tree.JCTree.JCFieldAccess;\nimport com.sun.tools.javac.tree.JCTree.JCIdent;\nimport com.sun.tools.javac.tree.JCTree.JCImport;\nimport com.sun.tools.javac.tree.JCTree.JCLiteral;\nimport com.sun.tools.javac.tree.JCTree.JCMethodDecl;\nimport com.sun.tools.javac.tree.JCTree.JCMethodInvocation;\nimport com.sun.tools.javac.tree.JCTree.JCModifiers;\nimport com.sun.tools.javac.tree.JCTree.JCNewArray;\nimport com.sun.tools.javac.tree.JCTree.JCPrimitiveTypeTree;\nimport com.sun.tools.javac.tree.JCTree.JCStatement;\nimport com.sun.tools.javac.tree.JCTree.JCTypeApply;\nimport com.sun.tools.javac.tree.JCTree.JCTypeParameter;\nimport com.sun.tools.javac.tree.JCTree.JCVariableDecl;\nimport com.sun.tools.javac.tree.JCTree.JCWildcard;\nimport com.sun.tools.javac.tree.JCTree.TypeBoundKind;\nimport com.sun.tools.javac.tree.TreeMaker;\nimport com.sun.tools.javac.tree.TreeScanner;\nimport com.sun.tools.javac.util.Context;\nimport com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\nimport com.sun.tools.javac.util.List;\nimport com.sun.tools.javac.util.ListBuffer;\nimport com.sun.tools.javac.util.Name;\nimport com.sun.tools.javac.util.Options;\n\nimport lombok.AccessLevel;\nimport lombok.ConfigurationKeys;\nimport lombok.Data;\nimport lombok.Getter;\nimport lombok.core.AST.Kind;\nimport lombok.core.AnnotationValues;\nimport lombok.core.AnnotationValues.AnnotationValue;\nimport lombok.core.CleanupTask;\nimport lombok.core.LombokImmutableList;\nimport lombok.core.TypeResolver;\nimport lombok.core.configuration.CheckerFrameworkVersion;\nimport lombok.core.configuration.NullAnnotationLibrary;\nimport lombok.core.configuration.NullCheckExceptionType;\nimport lombok.core.configuration.TypeName;\nimport lombok.core.handlers.HandlerUtil;\nimport lombok.core.handlers.HandlerUtil.FieldAccess;\nimport lombok.delombok.LombokOptionsFactory;\nimport lombok.experimental.Accessors;\nimport lombok.experimental.Tolerate;\nimport lombok.javac.Javac;\nimport lombok.javac.JavacAugments;\nimport lombok.javac.JavacNode;\nimport lombok.javac.JavacTreeMaker;\nimport lombok.javac.JavacTreeMaker.TypeTag;\nimport lombok.permit.Permit;\n\n/**\n * Container for static utility methods useful to handlers written for javac.\n */\npublic class JavacHandlerUtil {\n\tprivate JavacHandlerUtil() {\n\t\t//Prevent instantiation\n\t}\n\t\n\tprivate static class MarkingScanner extends TreeScanner {\n\t\tprivate final JavacNode source;\n\t\t\n\t\tMarkingScanner(JavacNode source) {\n\t\t\tthis.source = source;\n\t\t}\n\t\t\n\t\t@Override public void scan(JCTree tree) {\n\t\t\tif (tree == null) return;\n\t\t\tsetGeneratedBy(tree, source);\n\t\t\tsuper.scan(tree);\n\t\t}\n\t}\n\t\n\t/**\n\t * Contributed by Jan Lahoda; many lombok transformations should not be run (or a lite version should be run) when the netbeans editor\n\t * is running javac on the open source file to find inline errors and such. As class files are compiled separately this does not affect\n\t * actual runtime behaviour or file output of the netbeans IDE.\n\t */\n\tpublic static boolean inNetbeansEditor(JavacNode node) {\n\t\treturn inNetbeansEditor(node.getContext());\n\t}\n\t\n\tpublic static boolean inNetbeansEditor(Context context) {\n\t\tOptions options = Options.instance(context);\n\t\treturn (options.keySet().contains(\"ide\") && !options.keySet().contains(\"backgroundCompilation\"));\n\t}\n\t\n\tpublic static boolean inNetbeansCompileOnSave(Context context) {\n\t\tOptions options = Options.instance(context);\n\t\treturn (options.keySet().contains(\"ide\") && options.keySet().contains(\"backgroundCompilation\"));\n\t}\n\t\n\tpublic static JCTree getGeneratedBy(JCTree node) {\n\t\treturn JCTree_generatedNode.get(node);\n\t}\n\t\n\tpublic static boolean isGenerated(JCTree node) {\n\t\treturn getGeneratedBy(node) != null;\n\t}\n\t\n\tpublic static <T extends JCTree> T recursiveSetGeneratedBy(T node, JavacNode source) {\n\t\tif (node == null) return null;\n\t\tsetGeneratedBy(node, source);\n\t\tnode.accept(new MarkingScanner(source));\n\t\treturn node;\n\t}\n\t\n\tpublic static <T extends JCTree> T setGeneratedBy(T node, JavacNode sourceNode) {\n\t\tif (node == null) return null;\n\t\tif (sourceNode == null) {\n\t\t\tJCTree_generatedNode.clear(node);\n\t\t\treturn node;\n\t\t}\n\t\tJCTree_generatedNode.set(node, sourceNode.get());\n\t\t\n\t\tif (!inNetbeansEditor(sourceNode.getContext()) || isParameter(node)) {\n\t\t\tnode.pos = sourceNode.getStartPos();\n\t\t\tstoreEnd(node, sourceNode.getEndPosition(), (JCCompilationUnit) sourceNode.top().get());\n\t\t}\n\t\treturn node;\n\t}\n\n\tpublic static boolean isParameter(JCTree node) {\n\t\treturn node instanceof JCVariableDecl && (((JCVariableDecl) node).mods.flags & Flags.PARAMETER) != 0;\n\t}\n\t\n\tpublic static boolean hasAnnotation(String type, JavacNode node) {\n\t\treturn hasAnnotation(type, node, false);\n\t}\n\t\n\tpublic static boolean hasAnnotation(Class<? extends Annotation> type, JavacNode node) {\n\t\treturn hasAnnotation(type, node, false);\n\t}\n\t\n\tpublic static boolean hasAnnotationAndDeleteIfNeccessary(Class<? extends Annotation> type, JavacNode node) {\n\t\treturn hasAnnotation(type, node, true);\n\t}\n\t\n\tprivate static boolean hasAnnotation(Class<? extends Annotation> type, JavacNode node, boolean delete) {\n\t\tif (node == null) return false;\n\t\tif (type == null) return false;\n\t\tswitch (node.getKind()) {\n\t\tcase ARGUMENT:\n\t\tcase FIELD:\n\t\tcase LOCAL:\n\t\tcase TYPE:\n\t\tcase METHOD:\n\t\t\tfor (JavacNode child : node.down()) {\n\t\t\t\tif (annotationTypeMatches(type, child)) {\n\t\t\t\t\tif (delete) deleteAnnotationIfNeccessary(child, type);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// intentional fallthrough\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tprivate static boolean hasAnnotation(String type, JavacNode node, boolean delete) {\n\t\tif (node == null) return false;\n\t\tif (type == null) return false;\n\t\tswitch (node.getKind()) {\n\t\tcase ARGUMENT:\n\t\tcase FIELD:\n\t\tcase LOCAL:\n\t\tcase TYPE:\n\t\tcase METHOD:\n\t\t\tfor (JavacNode child : node.down()) {\n\t\t\t\tif (annotationTypeMatches(type, child)) {\n\t\t\t\t\tif (delete) deleteAnnotationIfNeccessary(child, type);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// intentional fallthrough\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tpublic static JavacNode findInnerClass(JavacNode parent, String name) {\n\t\tfor (JavacNode child : parent.down()) {\n\t\t\tif (child.getKind() != Kind.TYPE) continue;\n\t\t\tJCClassDecl td = (JCClassDecl) child.get();\n\t\t\tif (td.name.contentEquals(name)) return child;\n\t\t}\n\t\treturn null;\n\t}\n\t\n\tpublic static JavacNode findAnnotation(Class<? extends Annotation> type, JavacNode node) {\n\t\treturn findAnnotation(type, node, false);\n\t}\n\t\n\tpublic static JavacNode findAnnotation(Class<? extends Annotation> type, JavacNode node, boolean delete) {\n\t\tif (node == null) return null;\n\t\tif (type == null) return null;\n\t\tswitch (node.getKind()) {\n\t\tcase ARGUMENT:\n\t\tcase FIELD:\n\t\tcase LOCAL:\n\t\tcase TYPE:\n\t\tcase METHOD:\n\t\t\tfor (JavacNode child : node.down()) {\n\t\t\t\tif (annotationTypeMatches(type, child)) {\n\t\t\t\t\tif (delete) deleteAnnotationIfNeccessary(child, type);\n\t\t\t\t\treturn child;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// intentional fallthrough\n\t\tdefault:\n\t\t\treturn null;\n\t\t}\n\t}\n\t\n\t/**\n\t * Checks if the Annotation AST Node provided is likely to be an instance of the provided annotation type.\n\t * \n\t * @param type An actual annotation type, such as {@code lombok.Getter.class}.\n\t * @param node A Lombok AST node representing an annotation in source code.\n\t */\n\tpublic static boolean annotationTypeMatches(Class<? extends Annotation> type, JavacNode node) {\n\t\tif (node.getKind() != Kind.ANNOTATION) return false;\n\t\treturn typeMatches(type, node, ((JCAnnotation) node.get()).annotationType);\n\t}\n\t\n\t/**\n\t * Checks if the Annotation AST Node provided is likely to be an instance of the provided annotation type.\n\t * \n\t * @param type An actual annotation type, such as {@code lombok.Getter.class}.\n\t * @param node A Lombok AST node representing an annotation in source code.\n\t */\n\tpublic static boolean annotationTypeMatches(String type, JavacNode node) {\n\t\tif (node.getKind() != Kind.ANNOTATION) return false;\n\t\treturn typeMatches(type, node, ((JCAnnotation) node.get()).annotationType);\n\t}\n\t\n\t/**\n\t * Checks if the given TypeReference node is likely to be a reference to the provided class.\n\t * \n\t * @param type An actual type. This method checks if {@code typeNode} is likely to be a reference to this type.\n\t * @param node A Lombok AST node. Any node in the appropriate compilation unit will do (used to get access to import statements).\n\t * @param typeNode A type reference to check.\n\t */\n\tpublic static boolean typeMatches(Class<?> type, JavacNode node, JCTree typeNode) {\n\t\treturn typeMatches(type.getName(), node, typeNode);\n\t}\n\t\n\t/**\n\t * Checks if the given TypeReference node is likely to be a reference to the provided class.\n\t * \n\t * @param type An actual type. This method checks if {@code typeNode} is likely to be a reference to this type.\n\t * @param node A Lombok AST node. Any node in the appropriate compilation unit will do (used to get access to import statements).\n\t * @param typeNode A type reference to check.\n\t */\n\tpublic static boolean typeMatches(String type, JavacNode node, JCTree typeNode) {\n\t\tString typeName = typeNode == null ? null : typeNode.toString();\n\t\tif (typeName == null || typeName.length() == 0) return false;\n\t\tint lastIndexA = typeName.lastIndexOf('.') + 1;\n\t\tint lastIndexB = Math.max(type.lastIndexOf('.'), type.lastIndexOf('$')) + 1;\n\t\tint len = typeName.length() - lastIndexA;\n\t\tif (len != type.length() - lastIndexB) return false;\n\t\tfor (int i = 0; i < len; i++) if (typeName.charAt(i + lastIndexA) != type.charAt(i + lastIndexB)) return false;\n\t\tTypeResolver resolver = node.getImportListAsTypeResolver();\n\t\treturn resolver.typeMatches(node, type, typeName);\n\t}\n\t\n\t/**\n\t * Returns if a field is marked deprecated, either by {@code @Deprecated} or in javadoc\n\t * @param field the field to check\n\t * @return {@code true} if a field is marked deprecated, either by {@code @Deprecated} or in javadoc, otherwise {@code false}\n\t */\n\tpublic static boolean isFieldDeprecated(JavacNode field) {\n\t\tif (!(field.get() instanceof JCVariableDecl)) return false;\n\t\tJCVariableDecl fieldNode = (JCVariableDecl) field.get();\n\t\tif ((fieldNode.mods.flags & Flags.DEPRECATED) != 0) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (JavacNode child : field.down()) {\n\t\t\tif (annotationTypeMatches(Deprecated.class, child)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic static CheckerFrameworkVersion getCheckerFrameworkVersion(JavacNode node) {\n\t\tCheckerFrameworkVersion cfv = node.getAst().readConfiguration(ConfigurationKeys.CHECKER_FRAMEWORK);\n\t\treturn cfv == null ? CheckerFrameworkVersion.NONE : cfv;\n\t}\n\t\n\t/**\n\t * Returns if a node is marked deprecated (as picked up on by the parser).\n\t * @param node the node to check (type, method, or field decl).\n\t */\n\tpublic static boolean nodeHasDeprecatedFlag(JCTree node) {\n\t\tif (node instanceof JCVariableDecl) return (((JCVariableDecl) node).mods.flags & Flags.DEPRECATED) != 0;\n\t\tif (node instanceof JCMethodDecl) return (((JCMethodDecl) node).mods.flags & Flags.DEPRECATED) != 0;\n\t\tif (node instanceof JCClassDecl) return (((JCClassDecl) node).mods.flags & Flags.DEPRECATED) != 0;\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Creates an instance of {@code AnnotationValues} for the provided AST Node.\n\t * \n\t * @param type An annotation class type, such as {@code lombok.Getter.class}.\n\t * @param node A Lombok AST node representing an annotation in source code.\n\t */\n\tpublic static <A extends Annotation> AnnotationValues<A> createAnnotation(Class<A> type, final JavacNode node) {\n\t\treturn createAnnotation(type, (JCAnnotation) node.get(), node);\n\t}\n\t\n\t/**\n\t * Creates an instance of {@code AnnotationValues} for the provided AST Node\n\t * and Annotation expression.\n\t *\n\t * @param type An annotation class type, such as {@code lombok.Getter.class}.\n\t * @param anno the annotation expression\n\t * @param node A Lombok AST node representing an annotation in source code.\n\t */\n\tpublic static <A extends Annotation> AnnotationValues<A> createAnnotation(Class<A> type, JCAnnotation anno, final JavacNode node) {\n\t\tMap<String, AnnotationValue> values = new HashMap<String, AnnotationValue>();\n\t\tList<JCExpression> arguments = anno.getArguments();\n\t\t\n\t\tfor (JCExpression arg : arguments) {\n\t\t\tString mName;\n\t\t\tJCExpression rhs;\n\t\t\tjava.util.List<String> raws = new ArrayList<String>();\n\t\t\tjava.util.List<Object> guesses = new ArrayList<Object>();\n\t\t\tjava.util.List<Object> expressions = new ArrayList<Object>();\n\t\t\tfinal java.util.List<DiagnosticPosition> positions = new ArrayList<DiagnosticPosition>();\n\t\t\t\n\t\t\tif (arg instanceof JCAssign) {\n\t\t\t\tJCAssign assign = (JCAssign) arg;\n\t\t\t\tmName = assign.lhs.toString();\n\t\t\t\trhs = assign.rhs;\n\t\t\t} else {\n\t\t\t\trhs = arg;\n\t\t\t\tmName = \"value\";\n\t\t\t}\n\t\t\t\n\t\t\tif (rhs instanceof JCNewArray) {\n\t\t\t\tList<JCExpression> elems = ((JCNewArray) rhs).elems;\n\t\t\t\tfor (JCExpression inner : elems) {\n\t\t\t\t\traws.add(inner.toString());\n\t\t\t\t\texpressions.add(inner);\n\t\t\t\t\tif (inner instanceof JCAnnotation) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\t\t\t\tClass<A> innerClass = (Class<A>) Class.forName(inner.type.toString());\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tguesses.add(createAnnotation(innerClass, (JCAnnotation) inner, node));\n\t\t\t\t\t\t} catch (ClassNotFoundException ex) {\n\t\t\t\t\t\t\tguesses.add(calculateGuess(inner));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tguesses.add(calculateGuess(inner));\n\t\t\t\t\t}\n\t\t\t\t\tpositions.add(inner.pos());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\traws.add(rhs.toString());\n\t\t\t\texpressions.add(rhs);\n\t\t\t\tif (rhs instanceof JCAnnotation) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\t\t\tClass<A> innerClass = (Class<A>) Class.forName(rhs.type.toString());\n\t\t\t\t\t\t\n\t\t\t\t\t\tguesses.add(createAnnotation(innerClass, (JCAnnotation) rhs, node));\n\t\t\t\t\t} catch (ClassNotFoundException ex) {\n\t\t\t\t\t\tguesses.add(calculateGuess(rhs));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tguesses.add(calculateGuess(rhs));\n\t\t\t\t}\n\t\t\t\tpositions.add(rhs.pos());\n\t\t\t}\n\t\t\t\n\t\t\tvalues.put(mName, new AnnotationValue(node, raws, expressions, guesses, true) {\n\t\t\t\t@Override public void setError(String message, int valueIdx) {\n\t\t\t\t\tif (valueIdx < 0) node.addError(message);\n\t\t\t\t\telse node.addError(message, positions.get(valueIdx));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t@Override public void setWarning(String message, int valueIdx) {\n\t\t\t\t\tif (valueIdx < 0) node.addWarning(message);\n\t\t\t\t\telse node.addWarning(message, positions.get(valueIdx));\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\t\n\t\tfor (Method m : type.getDeclaredMethods()) {\n\t\t\tif (!Modifier.isPublic(m.getModifiers())) continue;\n\t\t\tString name = m.getName();\n\t\t\tif (!values.containsKey(name)) {\n\t\t\t\tvalues.put(name, new AnnotationValue(node, new ArrayList<String>(), new ArrayList<Object>(), new ArrayList<Object>(), false) {\n\t\t\t\t\t@Override public void setError(String message, int valueIdx) {\n\t\t\t\t\t\tnode.addError(message);\n\t\t\t\t\t}\n\t\t\t\t\t@Override public void setWarning(String message, int valueIdx) {\n\t\t\t\t\t\tnode.addWarning(message);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn new AnnotationValues<A>(type, values, node);\n\t}\n\t\n\t/**\n\t * Removes the annotation from javac's AST (it remains in lombok's AST),\n\t * then removes any import statement that imports this exact annotation (not star imports).\n\t * Only does this if the DeleteLombokAnnotations class is in the context.\n\t */\n\tpublic static void deleteAnnotationIfNeccessary(JavacNode annotation, String annotationType) {\n\t\tdeleteAnnotationIfNeccessary0(annotation, annotationType);\n\t}\n\t\n\t/**\n\t * Removes the annotation from javac's AST (it remains in lombok's AST),\n\t * then removes any import statement that imports this exact annotation (not star imports).\n\t * Only does this if the DeleteLombokAnnotations class is in the context.\n\t */\n\tpublic static void deleteAnnotationIfNeccessary(JavacNode annotation, Class<? extends Annotation> annotationType) {\n\t\tdeleteAnnotationIfNeccessary0(annotation, annotationType.getName());\n\t}\n\t\n\t/**\n\t * Removes the annotation from javac's AST (it remains in lombok's AST),\n\t * then removes any import statement that imports this exact annotation (not star imports).\n\t * Only does this if the DeleteLombokAnnotations class is in the context.\n\t */\n\tpublic static void deleteAnnotationIfNeccessary(JavacNode annotation, Class<? extends Annotation> annotationType1, Class<? extends Annotation> annotationType2) {\n\t\tdeleteAnnotationIfNeccessary0(annotation, annotationType1.getName(), annotationType2.getName());\n\t}\n\t\n\t/**\n\t * Removes the annotation from javac's AST (it remains in lombok's AST),\n\t * then removes any import statement that imports this exact annotation (not star imports).\n\t * Only does this if the DeleteLombokAnnotations class is in the context.\n\t */\n\tpublic static void deleteAnnotationIfNeccessary(JavacNode annotation, Class<? extends Annotation> annotationType1, String annotationType2) {\n\t\tdeleteAnnotationIfNeccessary0(annotation, annotationType1.getName(), annotationType2);\n\t}\n\t\n\tprivate static void deleteAnnotationIfNeccessary0(JavacNode annotation, String... annotationTypes) {\n\t\tif (inNetbeansEditor(annotation)) return;\n\t\tif (!annotation.shouldDeleteLombokAnnotations()) return;\n\t\tJavacNode parentNode = annotation.directUp();\n\t\tswitch (parentNode.getKind()) {\n\t\tcase FIELD:\n\t\tcase ARGUMENT:\n\t\tcase LOCAL:\n\t\t\tJCVariableDecl variable = (JCVariableDecl) parentNode.get();\n\t\t\tvariable.mods.annotations = filterList(variable.mods.annotations, annotation.get());\n\t\t\tbreak;\n\t\tcase METHOD:\n\t\t\tJCMethodDecl method = (JCMethodDecl) parentNode.get();\n\t\t\tmethod.mods.annotations = filterList(method.mods.annotations, annotation.get());\n\t\t\tbreak;\n\t\tcase TYPE:\n\t\t\ttry {\n\t\t\t\tJCClassDecl type = (JCClassDecl) parentNode.get();\n\t\t\t\ttype.mods.annotations = filterList(type.mods.annotations, annotation.get());\n\t\t\t} catch (ClassCastException e) {\n\t\t\t\t//something rather odd has been annotated. Better to just break only delombok instead of everything.\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t//This really shouldn't happen, but if it does, better just break delombok instead of breaking everything.\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tparentNode.getAst().setChanged();\n\t\tfor (String annotationType : annotationTypes) {\n\t\t\tdeleteImportFromCompilationUnit(annotation, annotationType);\n\t\t}\n\t}\n\t\n\tpublic static void deleteImportFromCompilationUnit(JavacNode node, String name) {\n\t\tif (inNetbeansEditor(node)) return;\n\t\tif (!node.shouldDeleteLombokAnnotations()) return;\n\t\t\n\t\tJCCompilationUnit unit = (JCCompilationUnit) node.top().get();\n\t\t\n\t\tfor (JCTree def : unit.defs) {\n\t\t\tif (!(def instanceof JCImport)) continue;\n\t\t\tJCImport imp0rt = (JCImport) def;\n\t\t\tif (imp0rt.staticImport) continue;\n\t\t\tif (!imp0rt.qualid.toString().equals(name)) continue;\n\t\t\tJavacAugments.JCImport_deletable.set(imp0rt, true);\n\t\t}\n\t}\n\t\n\tprivate static List<JCAnnotation> filterList(List<JCAnnotation> annotations, JCTree jcTree) {\n\t\tListBuffer<JCAnnotation> newAnnotations = new ListBuffer<JCAnnotation>();\n\t\tfor (JCAnnotation ann : annotations) {\n\t\t\tif (jcTree != ann) newAnnotations.append(ann);\n\t\t}\n\t\treturn newAnnotations.toList();\n\t}\n\t\n\t/** Serves as return value for the methods that check for the existence of fields and methods. */\n\tpublic enum MemberExistsResult {\n\t\tNOT_EXISTS, EXISTS_BY_LOMBOK, EXISTS_BY_USER;\n\t}\n\t\n\t/**\n\t * Translates the given field into all possible getter names.\n\t * Convenient wrapper around {@link HandlerUtil#toAllGetterNames(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static java.util.List<String> toAllGetterNames(JavacNode field) {\n\t\treturn HandlerUtil.toAllGetterNames(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * Translates the given field into all possible getter names.\n\t * Convenient wrapper around {@link HandlerUtil#toAllGetterNames(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static java.util.List<String> toAllGetterNames(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\treturn HandlerUtil.toAllGetterNames(field.getAst(), accessors, field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * @return the likely getter name for the stated field. (e.g. private boolean foo; to isFoo).\n\t * \n\t * Convenient wrapper around {@link HandlerUtil#toGetterName(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static String toGetterName(JavacNode field) {\n\t\treturn HandlerUtil.toGetterName(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * @return the likely getter name for the stated field. (e.g. private boolean foo; to isFoo).\n\t * \n\t * Convenient wrapper around {@link HandlerUtil#toGetterName(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static String toGetterName(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\treturn HandlerUtil.toGetterName(field.getAst(), accessors, field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * Translates the given field into all possible setter names.\n\t * Convenient wrapper around {@link HandlerUtil#toAllSetterNames(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static java.util.List<String> toAllSetterNames(JavacNode field) {\n\t\treturn HandlerUtil.toAllSetterNames(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * Translates the given field into all possible setter names.\n\t * Convenient wrapper around {@link HandlerUtil#toAllSetterNames(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static java.util.List<String> toAllSetterNames(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\treturn HandlerUtil.toAllSetterNames(field.getAst(), accessors, field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * @return the likely setter name for the stated field. (e.g. private boolean foo; to setFoo).\n\t * \n\t * Convenient wrapper around {@link HandlerUtil#toSetterName(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static String toSetterName(JavacNode field) {\n\t\treturn HandlerUtil.toSetterName(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * @return the likely setter name for the stated field. (e.g. private boolean foo; to setFoo).\n\t * \n\t * Convenient wrapper around {@link HandlerUtil#toSetterName(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static String toSetterName(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\treturn HandlerUtil.toSetterName(field.getAst(), accessors, field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * Translates the given field into all possible with names.\n\t * Convenient wrapper around {@link HandlerUtil#toAllWithNames(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static java.util.List<String> toAllWithNames(JavacNode field) {\n\t\treturn HandlerUtil.toAllWithNames(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * Translates the given field into all possible with names.\n\t * Convenient wrapper around {@link HandlerUtil#toAllWithNames(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static java.util.List<String> toAllWithNames(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\treturn HandlerUtil.toAllWithNames(field.getAst(), accessors, field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * Translates the given field into all possible withBy names.\n\t * Convenient wrapper around {@link HandlerUtil#toAllWithByNames(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static java.util.List<String> toAllWithByNames(JavacNode field) {\n\t\treturn HandlerUtil.toAllWithByNames(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * Translates the given field into all possible withBy names.\n\t * Convenient wrapper around {@link HandlerUtil#toAllWithByNames(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static java.util.List<String> toAllWithByNames(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\treturn HandlerUtil.toAllWithByNames(field.getAst(), accessors, field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * @return the likely with name for the stated field. (e.g. private boolean foo; to withFoo).\n\t * \n\t * Convenient wrapper around {@link HandlerUtil#toWithName(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static String toWithName(JavacNode field) {\n\t\treturn HandlerUtil.toWithName(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * @return the likely with name for the stated field. (e.g. private boolean foo; to withFoo).\n\t * \n\t * Convenient wrapper around {@link HandlerUtil#toWithName(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static String toWithName(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\treturn HandlerUtil.toWithName(field.getAst(), accessors, field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * @return the likely withBy name for the stated field. (e.g. private boolean foo; to withFooBy).\n\t * \n\t * Convenient wrapper around {@link HandlerUtil#toWithByName(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static String toWithByName(JavacNode field) {\n\t\treturn HandlerUtil.toWithByName(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * @return the likely withBy name for the stated field. (e.g. private boolean foo; to withFooBy).\n\t * \n\t * Convenient wrapper around {@link HandlerUtil#toWithByName(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static String toWithByName(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\treturn HandlerUtil.toWithByName(field.getAst(), accessors, field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * When generating a setter, the setter either returns void (beanspec) or Self (fluent).\n\t * This method scans for the {@code Accessors} annotation to figure that out.\n\t */\n\tpublic static boolean shouldReturnThis(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\tif ((((JCVariableDecl) field.get()).mods.flags & Flags.STATIC) != 0) return false;\n\t\t\n\t\treturn HandlerUtil.shouldReturnThis0(accessors, field.getAst());\n\t}\n\t\n\t/**\n\t * When generating a setter/getter/wither, should it be made final?\n\t */\n\tpublic static boolean shouldMakeFinal(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\tif ((((JCVariableDecl) field.get()).mods.flags & Flags.STATIC) != 0) return false;\n\t\t\n\t\treturn HandlerUtil.shouldMakeFinal0(accessors, field.getAst());\n\t}\n\t\n\tpublic static JCExpression cloneSelfType(JavacNode childOfType) {\n\t\tJavacNode typeNode = childOfType;\n\t\tJavacTreeMaker maker = childOfType.getTreeMaker();\n\t\twhile (typeNode != null && typeNode.getKind() != Kind.TYPE) typeNode = typeNode.up();\n\t\treturn JavacHandlerUtil.namePlusTypeParamsToTypeReference(maker, typeNode, ((JCClassDecl) typeNode.get()).typarams);\n\t}\n\t\n\tpublic static boolean isBoolean(JavacNode field) {\n\t\tJCExpression varType = ((JCVariableDecl) field.get()).vartype;\n\t\treturn isBoolean(varType);\n\t}\n\t\n\tpublic static boolean isBoolean(JCExpression varType) {\n\t\treturn varType != null && varType.toString().equals(\"boolean\");\n\t}\n\t\n\tpublic static Name removePrefixFromField(JavacNode field) {\n\t\tjava.util.List<String> prefixes = null;\n\t\tfor (JavacNode node : field.down()) {\n\t\t\tif (annotationTypeMatches(Accessors.class, node)) {\n\t\t\t\tAnnotationValues<Accessors> ann = createAnnotation(Accessors.class, node);\n\t\t\t\tif (ann.isExplicit(\"prefix\")) prefixes = Arrays.asList(ann.getInstance().prefix());\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (prefixes == null) {\n\t\t\tJavacNode current = field.up();\n\t\t\touter:\n\t\t\twhile (current != null) {\n\t\t\t\tfor (JavacNode node : current.down()) {\n\t\t\t\t\tif (annotationTypeMatches(Accessors.class, node)) {\n\t\t\t\t\t\tAnnotationValues<Accessors> ann = createAnnotation(Accessors.class, node);\n\t\t\t\t\t\tif (ann.isExplicit(\"prefix\")) prefixes = Arrays.asList(ann.getInstance().prefix());\n\t\t\t\t\t\tbreak outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcurrent = current.up();\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (prefixes == null) prefixes = field.getAst().readConfiguration(ConfigurationKeys.ACCESSORS_PREFIX);\n\t\t\n\t\tif (!prefixes.isEmpty()) {\n\t\t\tCharSequence newName = removePrefix(field.getName(), prefixes);\n\t\t\tif (newName != null) return field.toName(newName.toString());\n\t\t}\n\t\t\n\t\treturn ((JCVariableDecl) field.get()).name;\n\t}\n\t\n\tpublic static AnnotationValues<Accessors> getAccessorsForField(JavacNode field) {\n\t\tAnnotationValues<Accessors> values = null;\n\t\t\n\t\tfor (JavacNode node : field.down()) {\n\t\t\tif (annotationTypeMatches(Accessors.class, node)) {\n\t\t\t\tvalues = createAnnotation(Accessors.class, node);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tJavacNode current = field.up();\n\t\twhile (current != null) {\n\t\t\tfor (JavacNode node : current.down()) {\n\t\t\t\tif (annotationTypeMatches(Accessors.class, node)) {\n\t\t\t\t\tAnnotationValues<Accessors> onType = createAnnotation(Accessors.class, node);\n\t\t\t\t\tvalues = values == null ? onType : values.integrate(onType);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurrent = current.up();\n\t\t}\n\t\t\n\t\treturn values == null ? AnnotationValues.of(Accessors.class, field) : values;\n\t}\n\t\n\t/**\n\t * Checks if there is a field with the provided name.\n\t * \n\t * @param fieldName the field name to check for.\n\t * @param node Any node that represents the Type (JCClassDecl) to look in, or any child node thereof.\n\t */\n\tpublic static MemberExistsResult fieldExists(String fieldName, JavacNode node) {\n\t\tnode = upToTypeNode(node);\n\t\t\n\t\tif (node != null && node.get() instanceof JCClassDecl) {\n\t\t\tfor (JCTree def : ((JCClassDecl)node.get()).defs) {\n\t\t\t\tif (def instanceof JCVariableDecl) {\n\t\t\t\t\tif (((JCVariableDecl)def).name.contentEquals(fieldName)) {\n\t\t\t\t\t\treturn getGeneratedBy(def) == null ? MemberExistsResult.EXISTS_BY_USER : MemberExistsResult.EXISTS_BY_LOMBOK;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn MemberExistsResult.NOT_EXISTS;\n\t}\n\t\n\tpublic static MemberExistsResult methodExists(String methodName, JavacNode node, int params) {\n\t\treturn methodExists(methodName, node, true, params);\n\t}\n\t\n\t/**\n\t * Checks if there is a method with the provided name. In case of multiple methods (overloading), only\n\t * the first method decides if EXISTS_BY_USER or EXISTS_BY_LOMBOK is returned.\n\t * \n\t * @param methodName the method name to check for.\n\t * @param node Any node that represents the Type (JCClassDecl) to look in, or any child node thereof.\n\t * @param caseSensitive If the search should be case sensitive.\n\t * @param params The number of parameters the method should have; varargs count as 0-*. Set to -1 to find any method with the appropriate name regardless of parameter count.\n\t */\n\tpublic static MemberExistsResult methodExists(String methodName, JavacNode node, boolean caseSensitive, int params) {\n\t\tnode = upToTypeNode(node);\n\t\t\n\t\tif (node != null && node.get() instanceof JCClassDecl) {\n\t\t\ttop: for (JCTree def : ((JCClassDecl)node.get()).defs) {\n\t\t\t\tif (def instanceof JCMethodDecl) {\n\t\t\t\t\tJCMethodDecl md = (JCMethodDecl) def;\n\t\t\t\t\tString name = md.name.toString();\n\t\t\t\t\tboolean matches = caseSensitive ? name.equals(methodName) : name.equalsIgnoreCase(methodName);\n\t\t\t\t\tif (matches) {\n\t\t\t\t\t\tif (params > -1) {\n\t\t\t\t\t\t\tList<JCVariableDecl> ps = md.params;\n\t\t\t\t\t\t\tint minArgs = 0;\n\t\t\t\t\t\t\tint maxArgs = 0;\n\t\t\t\t\t\t\tif (ps != null && ps.length() > 0) {\n\t\t\t\t\t\t\t\tminArgs = ps.length();\n\t\t\t\t\t\t\t\tif ((ps.last().mods.flags & Flags.VARARGS) != 0) {\n\t\t\t\t\t\t\t\t\tmaxArgs = Integer.MAX_VALUE;\n\t\t\t\t\t\t\t\t\tminArgs--;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tmaxArgs = minArgs;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (params < minArgs || params > maxArgs) continue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (isTolerate(node, md)) continue top;\n\t\t\t\t\t\t\n\t\t\t\t\t\treturn getGeneratedBy(def) == null ? MemberExistsResult.EXISTS_BY_USER : MemberExistsResult.EXISTS_BY_LOMBOK;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn MemberExistsResult.NOT_EXISTS;\n\t}\n\t\n\tpublic static boolean isTolerate(JavacNode node, JCTree.JCMethodDecl md) {\n\t\tList<JCAnnotation> annotations = md.getModifiers().getAnnotations();\n\t\tif (annotations != null) for (JCTree.JCAnnotation anno : annotations) {\n\t\t\tif (typeMatches(Tolerate.class, node, anno.getAnnotationType())) return true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Checks if there is a (non-default) constructor. In case of multiple constructors (overloading), only\n\t * the first constructor decides if EXISTS_BY_USER or EXISTS_BY_LOMBOK is returned.\n\t * \n\t * @param node Any node that represents the Type (JCClassDecl) to look in, or any child node thereof.\n\t */\n\tpublic static MemberExistsResult constructorExists(JavacNode node) {\n\t\tnode = upToTypeNode(node);\n\t\t\n\t\tif (node != null && node.get() instanceof JCClassDecl) {\n\t\t\tfor (JCTree def : ((JCClassDecl) node.get()).defs) {\n\t\t\t\tif (def instanceof JCMethodDecl) {\n\t\t\t\t\tJCMethodDecl md = (JCMethodDecl) def;\n\t\t\t\t\tif (md.name.contentEquals(\"<init>\")) {\n\t\t\t\t\t\tif ((md.mods.flags & Flags.GENERATEDCONSTR) != 0) continue;\n\t\t\t\t\t\tif (isTolerate(node, md)) continue;\n\t\t\t\t\t\treturn getGeneratedBy(def) == null ? MemberExistsResult.EXISTS_BY_USER : MemberExistsResult.EXISTS_BY_LOMBOK;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn MemberExistsResult.NOT_EXISTS;\n\t}\n\t\n\tpublic static boolean isConstructorCall(final JCStatement statement) {\n\t\tif (!(statement instanceof JCExpressionStatement)) return false;\n\t\tJCExpression expr = ((JCExpressionStatement) statement).expr;\n\t\tif (!(expr instanceof JCMethodInvocation)) return false;\n\t\tJCExpression invocation = ((JCMethodInvocation) expr).meth;\n\t\tString name;\n\t\tif (invocation instanceof JCFieldAccess) {\n\t\t\tname = ((JCFieldAccess) invocation).name.toString();\n\t\t} else if (invocation instanceof JCIdent) {\n\t\t\tname = ((JCIdent) invocation).name.toString();\n\t\t} else {\n\t\t\tname = \"\";\n\t\t}\n\t\t\n\t\treturn \"super\".equals(name) || \"this\".equals(name);\n\t}\n\t\n\t/**\n\t * Turns an {@code AccessLevel} instance into the flag bit used by javac.\n\t */\n\tpublic static int toJavacModifier(AccessLevel accessLevel) {\n\t\tswitch (accessLevel) {\n\t\tcase MODULE:\n\t\tcase PACKAGE:\n\t\t\treturn 0;\n\t\tdefault:\n\t\tcase PUBLIC:\n\t\t\treturn Flags.PUBLIC;\n\t\tcase NONE:\n\t\tcase PRIVATE:\n\t\t\treturn Flags.PRIVATE;\n\t\tcase PROTECTED:\n\t\t\treturn Flags.PROTECTED;\n\t\t}\n\t}\n\t\n\tprivate static class GetterMethod {\n\t\tprivate final Name name;\n\t\tprivate final JCExpression type;\n\t\t\n\t\tGetterMethod(Name name, JCExpression type) {\n\t\t\tthis.name = name;\n\t\t\tthis.type = type;\n\t\t}\n\t}\n\t\n\tprivate static GetterMethod findGetter(JavacNode field) {\n\t\tJCVariableDecl decl = (JCVariableDecl)field.get();\n\t\tJavacNode typeNode = field.up();\n\t\tfor (String potentialGetterName : toAllGetterNames(field)) {\n\t\t\tfor (JavacNode potentialGetter : typeNode.down()) {\n\t\t\t\tif (potentialGetter.getKind() != Kind.METHOD) continue;\n\t\t\t\tJCMethodDecl method = (JCMethodDecl) potentialGetter.get();\n\t\t\t\tif (!method.name.toString().equalsIgnoreCase(potentialGetterName)) continue;\n\t\t\t\t/** static getX() methods don't count. */\n\t\t\t\tif ((method.mods.flags & Flags.STATIC) != 0) continue;\n\t\t\t\t/** Nor do getters with a non-empty parameter list. */\n\t\t\t\tif (method.params != null && method.params.size() > 0) continue;\n\t\t\t\treturn new GetterMethod(method.name, method.restype);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Check if the field has a @Getter annotation.\n\t\t\n\t\tboolean hasGetterAnnotation = false;\n\t\t\n\t\tfor (JavacNode child : field.down()) {\n\t\t\tif (child.getKind() == Kind.ANNOTATION && annotationTypeMatches(Getter.class, child)) {\n\t\t\t\tAnnotationValues<Getter> ann = createAnnotation(Getter.class, child);\n\t\t\t\tif (ann.getInstance().value() == AccessLevel.NONE) return null;   //Definitely WONT have a getter.\n\t\t\t\thasGetterAnnotation = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Check if the class has a @Getter annotation.\n\t\t\n\t\tif (!hasGetterAnnotation && HandleGetter.fieldQualifiesForGetterGeneration(field)) {\n\t\t\t//Check if the class has @Getter or @Data annotation.\n\t\t\t\n\t\t\tJavacNode containingType = field.up();\n\t\t\tif (containingType != null) for (JavacNode child : containingType.down()) {\n\t\t\t\tif (child.getKind() == Kind.ANNOTATION && annotationTypeMatches(Data.class, child)) hasGetterAnnotation = true;\n\t\t\t\tif (child.getKind() == Kind.ANNOTATION && annotationTypeMatches(Getter.class, child)) {\n\t\t\t\t\tAnnotationValues<Getter> ann = createAnnotation(Getter.class, child);\n\t\t\t\t\tif (ann.getInstance().value() == AccessLevel.NONE) return null;   //Definitely WONT have a getter.\n\t\t\t\t\thasGetterAnnotation = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (hasGetterAnnotation) {\n\t\t\tString getterName = toGetterName(field);\n\t\t\tif (getterName == null) return null;\n\t\t\treturn new GetterMethod(field.toName(getterName), decl.vartype);\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\t\n\tstatic boolean lookForGetter(JavacNode field, FieldAccess fieldAccess) {\n\t\tif (fieldAccess == FieldAccess.GETTER) return true;\n\t\tif (fieldAccess == FieldAccess.ALWAYS_FIELD) return false;\n\t\t\n\t\t// If @Getter(lazy = true) is used, then using it is mandatory.\n\t\tfor (JavacNode child : field.down()) {\n\t\t\tif (child.getKind() != Kind.ANNOTATION) continue;\n\t\t\tif (annotationTypeMatches(Getter.class, child)) {\n\t\t\t\tAnnotationValues<Getter> ann = createAnnotation(Getter.class, child);\n\t\t\t\tif (ann.getInstance().lazy()) return true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Returns the type of the field, unless a getter exists for this field, in which case the return type of the getter is returned.\n\t * \n\t * @see #createFieldAccessor(TreeMaker, JavacNode, FieldAccess)\n\t */\n\tstatic JCExpression getFieldType(JavacNode field, FieldAccess fieldAccess) {\n\t\tif (field.getKind() == Kind.METHOD) return ((JCMethodDecl) field.get()).restype;\n\t\t\n\t\tboolean lookForGetter = lookForGetter(field, fieldAccess);\n\t\t\n\t\tGetterMethod getter = lookForGetter ? findGetter(field) : null;\n\t\t\n\t\tif (getter == null) {\n\t\t\treturn ((JCVariableDecl) field.get()).vartype;\n\t\t}\n\t\t\n\t\treturn getter.type;\n\t}\n\t\n\t/**\n\t * Creates an expression that reads the field. Will either be {@code this.field} or {@code this.getField()} depending on whether or not there's a getter.\n\t */\n\tstatic JCExpression createFieldAccessor(JavacTreeMaker maker, JavacNode field, FieldAccess fieldAccess) {\n\t\treturn createFieldAccessor(maker, field, fieldAccess, null);\n\t}\n\t\n\tstatic JCExpression createFieldAccessor(JavacTreeMaker maker, JavacNode field, FieldAccess fieldAccess, JCExpression receiver) {\n\t\tboolean lookForGetter = lookForGetter(field, fieldAccess);\n\t\t\n\t\tGetterMethod getter = lookForGetter ? findGetter(field) : null;\n\t\tJCVariableDecl fieldDecl = (JCVariableDecl) field.get();\n\t\t\n\t\tif (getter == null) {\n\t\t\tif (receiver == null) {\n\t\t\t\tif ((fieldDecl.mods.flags & Flags.STATIC) == 0) {\n\t\t\t\t\treceiver = maker.Ident(field.toName(\"this\"));\n\t\t\t\t} else {\n\t\t\t\t\tJavacNode containerNode = field.up();\n\t\t\t\t\tif (containerNode != null && containerNode.get() instanceof JCClassDecl) {\n\t\t\t\t\t\tJCClassDecl container = (JCClassDecl) field.up().get();\n\t\t\t\t\t\treceiver = maker.Ident(container.name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn receiver == null ? maker.Ident(fieldDecl.name) : maker.Select(receiver, fieldDecl.name);\n\t\t}\n\t\t\n\t\tif (receiver == null) receiver = maker.Ident(field.toName(\"this\"));\n\t\tJCMethodInvocation call = maker.Apply(List.<JCExpression>nil(),\n\t\t\tmaker.Select(receiver, getter.name), List.<JCExpression>nil());\n\t\treturn call;\n\t}\n\t\n\tstatic JCExpression createMethodAccessor(JavacTreeMaker maker, JavacNode method) {\n\t\treturn createMethodAccessor(maker, method, null);\n\t}\n\t\n\tstatic JCExpression createMethodAccessor(JavacTreeMaker maker, JavacNode method, JCExpression receiver) {\n\t\tJCMethodDecl methodDecl = (JCMethodDecl) method.get();\n\t\t\n\t\tif (receiver == null && (methodDecl.mods.flags & Flags.STATIC) == 0) {\n\t\t\treceiver = maker.Ident(method.toName(\"this\"));\n\t\t} else if (receiver == null) {\n\t\t\tJavacNode containerNode = method.up();\n\t\t\tif (containerNode != null && containerNode.get() instanceof JCClassDecl) {\n\t\t\t\tJCClassDecl container = (JCClassDecl) method.up().get();\n\t\t\t\treceiver = maker.Ident(container.name);\n\t\t\t}\n\t\t}\n\t\t\n\t\tJCMethodInvocation call = maker.Apply(List.<JCExpression>nil(),\n\t\t\treceiver == null ? maker.Ident(methodDecl.name) : maker.Select(receiver, methodDecl.name), List.<JCExpression>nil());\n\t\treturn call;\n\t}\n\t\n\t/**\n\t * Adds the given new field declaration to the provided type AST Node.\n\t * The field carries the &#64;{@link SuppressWarnings}(\"all\") annotation.\n\t * Also takes care of updating the JavacAST.\n\t */\n\tpublic static JavacNode injectFieldAndMarkGenerated(JavacNode typeNode, JCVariableDecl field) {\n\t\treturn injectField(typeNode, field, true);\n\t}\n\t\n\t/**\n\t * Adds the given new field declaration to the provided type AST Node.\n\t * \n\t * Also takes care of updating the JavacAST.\n\t */\n\tpublic static JavacNode injectField(JavacNode typeNode, JCVariableDecl field) {\n\t\treturn injectField(typeNode, field, false);\n\t}\n\t\n\tpublic static JavacNode injectField(JavacNode typeNode, JCVariableDecl field, boolean addGenerated) {\n\t\treturn injectField(typeNode, field, addGenerated, false);\n\t}\n\t\n\tpublic static JavacNode injectField(JavacNode typeNode, JCVariableDecl field, boolean addGenerated, boolean specialEnumHandling) {\n\t\tJCClassDecl type = (JCClassDecl) typeNode.get();\n\t\t\n\t\tif (addGenerated) {\n\t\t\taddSuppressWarningsAll(field.mods, typeNode, typeNode.getNodeFor(getGeneratedBy(field)), typeNode.getContext());\n\t\t\taddGenerated(field.mods, typeNode, typeNode.getNodeFor(getGeneratedBy(field)), typeNode.getContext());\n\t\t}\n\t\t\n\t\tList<JCTree> insertAfter = null;\n\t\tList<JCTree> insertBefore = type.defs;\n\t\twhile (true) {\n\t\t\tboolean skip = false;\n\t\t\tif (insertBefore.head instanceof JCVariableDecl) {\n\t\t\t\tJCVariableDecl f = (JCVariableDecl) insertBefore.head;\n\t\t\t\tif ((!specialEnumHandling && isEnumConstant(f)) || isGenerated(f)) skip = true;\n\t\t\t} else if (insertBefore.head instanceof JCMethodDecl) {\n\t\t\t\tif ((((JCMethodDecl) insertBefore.head).mods.flags & GENERATEDCONSTR) != 0) skip = true;\n\t\t\t}\n\t\t\tif (skip) {\n\t\t\t\tinsertAfter = insertBefore;\n\t\t\t\tinsertBefore = insertBefore.tail;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tList<JCTree> fieldEntry = List.<JCTree>of(field);\n\t\tfieldEntry.tail = insertBefore;\n\t\tif (insertAfter == null) {\n\t\t\ttype.defs = fieldEntry;\n\t\t} else {\n\t\t\tinsertAfter.tail = fieldEntry;\n\t\t}\n\t\t\n\t\tEnterReflect.memberEnter(field, typeNode);\n\t\t\n\t\treturn typeNode.add(field, Kind.FIELD);\n\t}\n\t\n\tpublic static boolean isEnumConstant(final JCVariableDecl field) {\n\t\treturn (field.mods.flags & Flags.ENUM) != 0;\n\t}\n\t\n\tstatic class JCAnnotatedTypeReflect {\n\t\tprivate static Class<?> TYPE;\n\t\tprivate static Constructor<?> CONSTRUCTOR;\n\t\tprivate static Field ANNOTATIONS, UNDERLYING_TYPE;\n\t\t\n\t\tprivate static void initByLoader(ClassLoader classLoader) {\n\t\t\tif (TYPE != null) return;\n\t\t\tClass<?> c;\n\t\t\ttry {\n\t\t\t\tc = classLoader.loadClass(\"com.sun.tools.javac.tree.JCTree$JCAnnotatedType\");\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tinit(c);\n\t\t}\n\t\t\n\t\tprivate static void init(Class<?> in) {\n\t\t\tif (TYPE != null) return;\n\t\t\tif (!in.getName().equals(\"com.sun.tools.javac.tree.JCTree$JCAnnotatedType\")) return;\n\t\t\ttry {\n\t\t\t\tCONSTRUCTOR = Permit.getConstructor(in, List.class, JCExpression.class);\n\t\t\t\tANNOTATIONS = Permit.getField(in, \"annotations\");\n\t\t\t\tUNDERLYING_TYPE = Permit.getField(in, \"underlyingType\");\n\t\t\t\tTYPE = in;\n\t\t\t} catch (Exception ignore) {}\n\t\t}\n\t\t\n\t\tstatic boolean is(JCTree obj) {\n\t\t\tif (obj == null) return false;\n\t\t\tinit(obj.getClass());\n\t\t\treturn obj.getClass() == TYPE;\n\t\t}\n\t\t\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tstatic List<JCAnnotation> getAnnotations(JCTree obj) {\n\t\t\tinit(obj.getClass());\n\t\t\ttry {\n\t\t\t\treturn (List<JCAnnotation>) ANNOTATIONS.get(obj);\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn List.nil();\n\t\t\t}\n\t\t}\n\t\t\n\t\tstatic void setAnnotations(JCTree obj, List<JCAnnotation> anns) {\n\t\t\tinit(obj.getClass());\n\t\t\ttry {\n\t\t\t\tANNOTATIONS.set(obj, anns);\n\t\t\t} catch (Exception e) {}\n\t\t}\n\t\t\n\t\tstatic JCExpression getUnderlyingType(JCTree obj) {\n\t\t\tinit(obj.getClass());\n\t\t\ttry {\n\t\t\t\treturn (JCExpression) UNDERLYING_TYPE.get(obj);\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\t\n\t\tstatic JCExpression create(List<JCAnnotation> annotations, JCExpression underlyingType) {\n\t\t\tinitByLoader(underlyingType.getClass().getClassLoader());\n\t\t\ttry {\n\t\t\t\treturn (JCExpression) CONSTRUCTOR.newInstance(annotations, underlyingType);\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn underlyingType;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic class JCAnnotationReflect {\n\t\tprivate static final Field ATTRIBUTE;\n\n\t\tstatic {\n\t\t\tATTRIBUTE = Permit.permissiveGetField(JCAnnotation.class, \"attribute\");\n\t\t}\n\n\t\tstatic Attribute.Compound getAttribute(JCAnnotation jcAnnotation) {\n\t\t\tif (ATTRIBUTE != null) {\n\t\t\t\ttry {\n\t\t\t\t\treturn (Attribute.Compound) ATTRIBUTE.get(jcAnnotation);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t// Ignore\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tstatic void setAttribute(JCAnnotation jcAnnotation, Attribute.Compound attribute) {\n\t\t\tif (ATTRIBUTE != null) {\n\t\t\t\ttry {\n\t\t\t\t\tPermit.set(ATTRIBUTE, jcAnnotation, attribute);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t// Ignore\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// jdk9 support, types have changed, names stay the same\n\tstatic class ClassSymbolMembersField {\n\t\tprivate static final Field membersField;\n\t\tprivate static final Method removeMethod;\n\t\tprivate static final Method enterMethod;\n\t\t\n\t\tstatic {\n\t\t\tField f = null;\n\t\t\tMethod r = null;\n\t\t\tMethod e = null;\n\t\t\ttry {\n\t\t\t\tf = Permit.getField(ClassSymbol.class, \"members_field\");\n\t\t\t\tr = Permit.getMethod(f.getType(), \"remove\", Symbol.class);\n\t\t\t\te = Permit.getMethod(f.getType(), \"enter\", Symbol.class);\n\t\t\t} catch (Exception ex) {}\n\t\t\tmembersField = f;\n\t\t\tremoveMethod = r;\n\t\t\tenterMethod = e;\n\t\t}\n\t\t\n\t\tstatic void remove(ClassSymbol from, Symbol toRemove) {\n\t\t\tif (from == null) return;\n\t\t\ttry {\n\t\t\t\tScope scope = (Scope) membersField.get(from);\n\t\t\t\tif (scope == null) return;\n\t\t\t\tPermit.invoke(removeMethod, scope, toRemove);\n\t\t\t} catch (Exception e) {}\n\t\t}\n\t\t\n\t\tstatic void enter(ClassSymbol from, Symbol toEnter) {\n\t\t\tif (from == null) return;\n\t\t\ttry {\n\t\t\t\tScope scope = (Scope) membersField.get(from);\n\t\t\t\tif (scope == null) return;\n\t\t\t\tPermit.invoke(enterMethod, scope, toEnter);\n\t\t\t} catch (Exception e) {}\n\t\t}\n\t}\n\t\n\t/**\n\t * Adds the given new method declaration to the provided type AST Node.\n\t * Can also inject constructors.\n\t * \n\t * Also takes care of updating the JavacAST.\n\t */\n\tpublic static void injectMethod(JavacNode typeNode, JCMethodDecl method) {\n\t\tJCClassDecl type = (JCClassDecl) typeNode.get();\n\t\t\n\t\tif (method.getName().contentEquals(\"<init>\")) {\n\t\t\t//Scan for default constructor, and remove it.\n\t\t\tint idx = 0;\n\t\t\tfor (JCTree def : type.defs) {\n\t\t\t\tif (def instanceof JCMethodDecl) {\n\t\t\t\t\tif ((((JCMethodDecl) def).mods.flags & Flags.GENERATEDCONSTR) != 0) {\n\t\t\t\t\t\tJavacNode tossMe = typeNode.getNodeFor(def);\n\t\t\t\t\t\tif (tossMe != null) tossMe.up().removeChild(tossMe);\n\t\t\t\t\t\ttype.defs = addAllButOne(type.defs, idx);\n\t\t\t\t\t\tClassSymbolMembersField.remove(type.sym, ((JCMethodDecl) def).sym);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tidx++;\n\t\t\t}\n\t\t}\n\t\t\n\t\taddSuppressWarningsAll(method.mods, typeNode, typeNode.getNodeFor(getGeneratedBy(method)), typeNode.getContext());\n\t\taddGenerated(method.mods, typeNode, typeNode.getNodeFor(getGeneratedBy(method)), typeNode.getContext());\n\t\ttype.defs = type.defs.append(method);\n\t\t\n\t\tEnterReflect.memberEnter(method, typeNode);\n\t\t\n\t\ttypeNode.add(method, Kind.METHOD);\n\t}\n\n\t/**\n\t * Adds an inner type (class, interface, enum) to the given type. Cannot inject top-level types.\n\t * \n\t * @param typeNode parent type to inject new type into\n\t * @param type New type (class, interface, etc) to inject.\n\t * @return \n\t */\n\tpublic static JavacNode injectType(JavacNode typeNode, final JCClassDecl type) {\n\t\tJCClassDecl typeDecl = (JCClassDecl) typeNode.get();\n\t\taddSuppressWarningsAll(type.mods, typeNode, typeNode.getNodeFor(getGeneratedBy(type)), typeNode.getContext());\n\t\taddGenerated(type.mods, typeNode, typeNode.getNodeFor(getGeneratedBy(type)), typeNode.getContext());\n\t\ttypeDecl.defs = typeDecl.defs.append(type);\n\t\t\n\t\tEnterReflect.classEnter(type, typeNode);\n\t\t\n\t\treturn typeNode.add(type, Kind.TYPE);\n\t}\n\t\n\tstatic class EnterReflect {\n\t\tprivate static final Method classEnter;\n\t\tprivate static final Method memberEnter;\n\t\tprivate static final Method blockAnnotations;\n\t\tprivate static final Method unblockAnnotations;\n\t\t\n\t\tstatic {\n\t\t\tclassEnter = Permit.permissiveGetMethod(Enter.class, \"classEnter\", JCTree.class, Env.class);\n\t\t\tmemberEnter = Permit.permissiveGetMethod(MemberEnter.class, \"memberEnter\", JCTree.class, Env.class);\n\t\t\t\n\t\t\tMethod block = Permit.permissiveGetMethod(Annotate.class, \"blockAnnotations\");\n\t\t\tif (block == null) block = Permit.permissiveGetMethod(Annotate.class, \"enterStart\");\n\t\t\tblockAnnotations = block;\n\t\t\t\n\t\t\tMethod unblock = Permit.permissiveGetMethod(Annotate.class, \"unblockAnnotations\");\n\t\t\tif (unblock == null) unblock = Permit.permissiveGetMethod(Annotate.class, \"enterDone\");\n\t\t\tunblockAnnotations = unblock;\n\t\t}\n\t\t\n\t\tstatic Type classEnter(JCTree tree, JavacNode parent) {\n\t\t\tEnter enter = Enter.instance(parent.getContext());\n\t\t\tEnv<AttrContext> classEnv = enter.getEnv((TypeSymbol) parent.getElement());\n\t\t\tif (classEnv == null) return null;\n\t\t\tType type = (Type) Permit.invokeSneaky(classEnter, enter, tree, classEnv);\n\t\t\tif (type == null) return null;\n\t\t\ttype.complete();\n\t\t\treturn type;\n\t\t}\n\t\t\n\t\tstatic void memberEnter(JCTree tree, JavacNode parent) {\n\t\t\tContext context = parent.getContext();\n\t\t\tMemberEnter me = MemberEnter.instance(context);\n\t\t\tAnnotate annotate = Annotate.instance(context);\n\t\t\tEnter enter = Enter.instance(context);\n\t\t\t\n\t\t\tEnv<AttrContext> classEnv = enter.getEnv((TypeSymbol) parent.getElement());\n\t\t\tif (classEnv == null) return;\n\t\t\t\n\t\t\tPermit.invokeSneaky(blockAnnotations, annotate);\n\t\t\tPermit.invokeSneaky(memberEnter, me, tree, classEnv);\n\t\t\tPermit.invokeSneaky(unblockAnnotations, annotate);\n\t\t}\n\t}\n\t\n\tpublic static long addFinalIfNeeded(long flags, Context context) {\n\t\tboolean addFinal = LombokOptionsFactory.getDelombokOptions(context).getFormatPreferences().generateFinalParams();\n\t\t\n\t\tif (addFinal) flags |= Flags.FINAL;\n\t\treturn flags;\n\t}\n\t\n\tpublic static JCExpression genTypeRef(JavacNode node, String complexName) {\n\t\tString[] parts = complexName.split(\"\\\\.\");\n\t\tif (parts.length > 2 && parts[0].equals(\"java\") && parts[1].equals(\"lang\")) {\n\t\t\tString[] subParts = new String[parts.length - 2];\n\t\t\tSystem.arraycopy(parts, 2, subParts, 0, subParts.length);\n\t\t\treturn genJavaLangTypeRef(node, subParts);\n\t\t}\n\t\t\n\t\treturn chainDots(node, parts);\n\t}\n\t\n\tpublic static JCExpression genJavaLangTypeRef(JavacNode node, String... simpleNames) {\n\t\tif (LombokOptionsFactory.getDelombokOptions(node.getContext()).getFormatPreferences().javaLangAsFqn()) {\n\t\t\treturn chainDots(node, \"java\", \"lang\", simpleNames);\n\t\t} else {\n\t\t\treturn chainDots(node, null, null, simpleNames);\n\t\t}\n\t}\n\t\n\tpublic static JCExpression genJavaLangTypeRef(JavacNode node, int pos, String... simpleNames) {\n\t\tif (LombokOptionsFactory.getDelombokOptions(node.getContext()).getFormatPreferences().javaLangAsFqn()) {\n\t\t\treturn chainDots(node, pos, \"java\", \"lang\", simpleNames);\n\t\t} else {\n\t\t\treturn chainDots(node, pos, null, null, simpleNames);\n\t\t}\n\t}\n\t\n\tpublic static void addSuppressWarningsAll(JCModifiers mods, JavacNode node, JavacNode source, Context context) {\n\t\tif (!LombokOptionsFactory.getDelombokOptions(context).getFormatPreferences().generateSuppressWarnings()) return;\n\t\t\n\t\tboolean addJLSuppress = !Boolean.FALSE.equals(node.getAst().readConfiguration(ConfigurationKeys.ADD_SUPPRESSWARNINGS_ANNOTATIONS));\n\t\t\n\t\tif (addJLSuppress) {\n\t\t\tfor (JCAnnotation ann : mods.annotations) {\n\t\t\t\tJCTree type = ann.getAnnotationType();\n\t\t\t\tName n = null;\n\t\t\t\tif (type instanceof JCIdent) n = ((JCIdent) type).name;\n\t\t\t\telse if (type instanceof JCFieldAccess) n = ((JCFieldAccess) type).name;\n\t\t\t\tif (n != null && n.contentEquals(\"SuppressWarnings\")) {\n\t\t\t\t\taddJLSuppress = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (addJLSuppress) addAnnotation(mods, node, source, \"java.lang.SuppressWarnings\", node.getTreeMaker().Literal(\"all\"));\n\t\t\n\t\tif (Boolean.TRUE.equals(node.getAst().readConfiguration(ConfigurationKeys.ADD_FINDBUGS_SUPPRESSWARNINGS_ANNOTATIONS))) {\n\t\t\tJavacTreeMaker maker = node.getTreeMaker();\n\t\t\tJCExpression arg = maker.Assign(maker.Ident(node.toName(\"justification\")), maker.Literal(\"generated code\"));\n\t\t\taddAnnotation(mods, node, source, \"edu.umd.cs.findbugs.annotations.SuppressFBWarnings\", arg);\n\t\t}\n\t}\n\t\n\tpublic static void addGenerated(JCModifiers mods, JavacNode node, JavacNode source, Context context) {\n\t\tif (!LombokOptionsFactory.getDelombokOptions(context).getFormatPreferences().generateGenerated()) return;\n\t\t\n\t\tif (HandlerUtil.shouldAddGenerated(node)) {\n\t\t\taddAnnotation(mods, node, source, \"javax.annotation.Generated\", node.getTreeMaker().Literal(\"lombok\"));\n\t\t}\n\t\tif (Boolean.TRUE.equals(node.getAst().readConfiguration(ConfigurationKeys.ADD_LOMBOK_GENERATED_ANNOTATIONS))) {\n\t\t\taddAnnotation(mods, node, source, \"lombok.Generated\", null);\n\t\t}\n\t}\n\t\n\tpublic static void addAnnotation(JCModifiers mods, JavacNode node, JavacNode source, String annotationTypeFqn, JCExpression arg) {\n\t\tboolean isJavaLangBased;\n\t\tString simpleName; {\n\t\t\tint idx = annotationTypeFqn.lastIndexOf('.');\n\t\t\tsimpleName = idx == -1 ? annotationTypeFqn : annotationTypeFqn.substring(idx + 1);\n\t\t\t\n\t\t\tisJavaLangBased = idx == 9 && annotationTypeFqn.regionMatches(0, \"java.lang.\", 0, 10);\n\t\t}\n\t\t\n\t\tfor (JCAnnotation ann : mods.annotations) {\n\t\t\tJCTree annType = ann.getAnnotationType();\n\t\t\tif (annType instanceof JCIdent) {\n\t\t\t\tName lastPart = ((JCIdent) annType).name;\n\t\t\t\tif (lastPart.contentEquals(simpleName)) return;\n\t\t\t}\n\t\t\t\n\t\t\tif (annType instanceof JCFieldAccess) {\n\t\t\t\tif (annType.toString().equals(annotationTypeFqn)) return;\n\t\t\t}\n\t\t}\n\t\t\n\t\tJavacTreeMaker maker = node.getTreeMaker();\n\t\tJCExpression annType = isJavaLangBased ? genJavaLangTypeRef(node, simpleName) : chainDotsString(node, annotationTypeFqn);\n\t\tList<JCExpression> argList = arg != null ? List.of(arg) : List.<JCExpression>nil();\n\t\tJCAnnotation annotation = recursiveSetGeneratedBy(maker.Annotation(annType, argList), source);\n\t\tmods.annotations = mods.annotations.append(annotation);\n\t}\n\t\n\tstatic JCExpression addCheckerFrameworkReturnsReceiver(JCExpression returnType, JavacTreeMaker maker, JavacNode typeNode, CheckerFrameworkVersion cfv) {\n\t\tif (cfv.generateReturnsReceiver()) {\n\t\t\tJCAnnotation rrAnnotation = maker.Annotation(genTypeRef(typeNode, CheckerFrameworkVersion.NAME__RETURNS_RECEIVER), List.<JCExpression>nil());\n\t\t\treturnType = maker.AnnotatedType(List.of(rrAnnotation), returnType);\n\t\t}\n\t\treturn returnType;\n\t}\n\t\n\tprivate static List<JCTree> addAllButOne(List<JCTree> defs, int idx) {\n\t\tListBuffer<JCTree> out = new ListBuffer<JCTree>();\n\t\tint i = 0;\n\t\tfor (JCTree def : defs) {\n\t\t\tif (i++ != idx) out.append(def);\n\t\t}\n\t\treturn out.toList();\n\t}\n\t\n\t/**\n\t * In javac, dotted access of any kind, from {@code java.lang.String} to {@code var.methodName}\n\t * is represented by a fold-left of {@code Select} nodes with the leftmost string represented by\n\t * a {@code Ident} node. This method generates such an expression.\n\t * <p>\n\t * The position of the generated node(s) will be unpositioned (-1).\n\t * \n\t * For example, maker.Select(maker.Select(maker.Ident(NAME[java]), NAME[lang]), NAME[String]).\n\t * \n\t * @see com.sun.tools.javac.tree.JCTree.JCIdent\n\t * @see com.sun.tools.javac.tree.JCTree.JCFieldAccess\n\t */\n\tpublic static JCExpression chainDots(JavacNode node, String elem1, String elem2, String... elems) {\n\t\treturn chainDots(node, -1, elem1, elem2, elems);\n\t}\n\t\n\tpublic static JCExpression chainDots(JavacNode node, String[] elems) {\n\t\treturn chainDots(node, -1, null, null, elems);\n\t}\n\t\n\tpublic static JCExpression chainDots(JavacNode node, LombokImmutableList<String> elems) {\n\t\tassert elems != null;\n\t\t\n\t\tJavacTreeMaker maker = node.getTreeMaker();\n\t\tJCExpression e = null;\n\t\tfor (String elem : elems) {\n\t\t\tif (e == null) e = maker.Ident(node.toName(elem));\n\t\t\telse e = maker.Select(e, node.toName(elem));\n\t\t}\n\t\treturn e;\n\t}\n\t\n\t/**\n\t * In javac, dotted access of any kind, from {@code java.lang.String} to {@code var.methodName}\n\t * is represented by a fold-left of {@code Select} nodes with the leftmost string represented by\n\t * a {@code Ident} node. This method generates such an expression.\n\t * <p>\n\t * The position of the generated node(s) will be equal to the {@code pos} parameter.\n\t *\n\t * For example, maker.Select(maker.Select(maker.Ident(NAME[java]), NAME[lang]), NAME[String]).\n\t * \n\t * @see com.sun.tools.javac.tree.JCTree.JCIdent\n\t * @see com.sun.tools.javac.tree.JCTree.JCFieldAccess\n\t */\n\tpublic static JCExpression chainDots(JavacNode node, int pos, String elem1, String elem2, String... elems) {\n\t\tassert elems != null;\n\t\t\n\t\tJavacTreeMaker maker = node.getTreeMaker();\n\t\tif (pos != -1) maker = maker.at(pos);\n\t\tJCExpression e = null;\n\t\tif (elem1 != null) e = maker.Ident(node.toName(elem1));\n\t\tif (elem2 != null) e = e == null ? maker.Ident(node.toName(elem2)) : maker.Select(e, node.toName(elem2));\n\t\tfor (int i = 0 ; i < elems.length ; i++) {\n\t\t\te = e == null ? maker.Ident(node.toName(elems[i])) : maker.Select(e, node.toName(elems[i]));\n\t\t}\n\t\t\n\t\tassert e != null;\n\t\t\n\t\treturn e;\n\t}\n\t\n\t/**\n\t * In javac, dotted access of any kind, from {@code java.lang.String} to {@code var.methodName}\n\t * is represented by a fold-left of {@code Select} nodes with the leftmost string represented by\n\t * a {@code Ident} node. This method generates such an expression.\n\t * \n\t * For example, maker.Select(maker.Select(maker.Ident(NAME[java]), NAME[lang]), NAME[String]).\n\t * \n\t * @see com.sun.tools.javac.tree.JCTree.JCIdent\n\t * @see com.sun.tools.javac.tree.JCTree.JCFieldAccess\n\t */\n\tpublic static JCExpression chainDotsString(JavacNode node, String elems) {\n\t\treturn chainDots(node, null, null, elems.split(\"\\\\.\"));\n\t}\n\t\n\t/**\n\t * Searches the given field node for annotations and returns each one that matches the provided regular expression pattern.\n\t * \n\t * Only the simple name is checked - the package and any containing class are ignored.\n\t */\n\tpublic static List<JCAnnotation> findAnnotations(JavacNode fieldNode, Pattern namePattern) {\n\t\tListBuffer<JCAnnotation> result = new ListBuffer<JCAnnotation>();\n\t\tfor (JavacNode child : fieldNode.down()) {\n\t\t\tif (child.getKind() == Kind.ANNOTATION) {\n\t\t\t\tJCAnnotation annotation = (JCAnnotation) child.get();\n\t\t\t\tString name = annotation.annotationType.toString();\n\t\t\t\tint idx = name.lastIndexOf(\".\");\n\t\t\t\tString suspect = idx == -1 ? name : name.substring(idx + 1);\n\t\t\t\tif (namePattern.matcher(suspect).matches()) {\n\t\t\t\t\tresult.append(annotation);\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\t\treturn result.toList();\n\t}\n\t\n\tpublic static String scanForNearestAnnotation(JavacNode node, String... anns) {\n\t\twhile (node != null) {\n\t\t\tfor (JavacNode ann : node.down()) {\n\t\t\t\tif (ann.getKind() != Kind.ANNOTATION) continue;\n\t\t\t\tJCAnnotation a = (JCAnnotation) ann.get();\n\t\t\t\tfor (String annToFind : anns) if (typeMatches(annToFind, node, a.annotationType)) return annToFind;\n\t\t\t}\n\t\t\tnode = node.up();\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\t\n\tpublic static boolean hasNonNullAnnotations(JavacNode node) {\n\t\tfor (JavacNode child : node.down()) {\n\t\t\tif (child.getKind() == Kind.ANNOTATION) {\n\t\t\t\tJCAnnotation annotation = (JCAnnotation) child.get();\n\t\t\t\tfor (String nn : NONNULL_ANNOTATIONS) if (typeMatches(nn, node, annotation.annotationType)) return true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tpublic static boolean hasNonNullAnnotations(JavacNode node, List<JCAnnotation> anns) {\n\t\tif (anns == null) return false;\n\t\tfor (JCAnnotation ann : anns) {\n\t\t\tfor (String nn : NONNULL_ANNOTATIONS) if (typeMatches(nn, node, ann)) return true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Searches the given field node for annotations and returns each one that is 'copyable' (either via configuration or from the base list).\n\t */\n\tpublic static List<JCAnnotation> findCopyableAnnotations(JavacNode node) {\n\t\tJCAnnotation anno = null;\n\t\tString annoName = null;\n\t\tfor (JavacNode child : node.down()) {\n\t\t\tif (child.getKind() == Kind.ANNOTATION) {\n\t\t\t\tif (anno != null) {\n\t\t\t\t\tannoName = \"\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tJCAnnotation annotation = (JCAnnotation) child.get();\n\t\t\t\tannoName = annotation.annotationType.toString();\n\t\t\t\tanno = annotation;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (annoName == null) return List.nil();\n\t\t\n\t\tjava.util.List<TypeName> configuredCopyable = node.getAst().readConfiguration(ConfigurationKeys.COPYABLE_ANNOTATIONS);\n\t\t\n\t\tif (!annoName.isEmpty()) {\n\t\t\tfor (TypeName cn : configuredCopyable) if (cn != null && typeMatches(cn.toString(), node, anno.annotationType)) return List.of(anno);\n\t\t\tfor (String bn : BASE_COPYABLE_ANNOTATIONS) if (typeMatches(bn, node, anno.annotationType)) return List.of(anno);\n\t\t}\n\t\t\n\t\tListBuffer<JCAnnotation> result = new ListBuffer<JCAnnotation>();\n\t\tfor (JavacNode child : node.down()) {\n\t\t\tif (child.getKind() == Kind.ANNOTATION) {\n\t\t\t\tJCAnnotation annotation = (JCAnnotation) child.get();\n\t\t\t\tboolean match = false;\n\t\t\t\tfor (TypeName cn : configuredCopyable) if (cn != null && typeMatches(cn.toString(), node, annotation.annotationType)) {\n\t\t\t\t\tresult.append(annotation);\n\t\t\t\t\tmatch = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!match) for (String bn : BASE_COPYABLE_ANNOTATIONS) if (typeMatches(bn, node, annotation.annotationType)) {\n\t\t\t\t\tresult.append(annotation);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result.toList();\n\t}\n\t\n\t/**\n\t * Searches the given field node for annotations that are specifically intentioned to be copied to the setter.\n\t */\n\tpublic static List<JCAnnotation> findCopyableToSetterAnnotations(JavacNode node) {\n\t\treturn findAnnotationsInList(node, COPY_TO_SETTER_ANNOTATIONS);\n\t}\n\n\t/**\n\t * Searches the given field node for annotations that are specifically intentioned to be copied to the builder's singular method.\n\t */\n\tpublic static List<JCAnnotation> findCopyableToBuilderSingularSetterAnnotations(JavacNode node) {\n\t\treturn findAnnotationsInList(node, COPY_TO_BUILDER_SINGULAR_SETTER_ANNOTATIONS);\n\t}\n\t\n\t/**\n\t * Searches the given field node for annotations that are in the given list, and returns those.\n\t */\n\tprivate static List<JCAnnotation> findAnnotationsInList(JavacNode node, java.util.List<String> annotationsToFind) {\n\t\tJCAnnotation anno = null;\n\t\tString annoName = null;\n\t\tfor (JavacNode child : node.down()) {\n\t\t\tif (child.getKind() == Kind.ANNOTATION) {\n\t\t\t\tif (anno != null) {\n\t\t\t\t\tannoName = \"\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tJCAnnotation annotation = (JCAnnotation) child.get();\n\t\t\t\tannoName = annotation.annotationType.toString();\n\t\t\t\tanno = annotation;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (annoName == null) return List.nil();\n\t\t\n\t\tif (!annoName.isEmpty()) {\n\t\t\tfor (String bn : annotationsToFind) if (typeMatches(bn, node, anno.annotationType)) return List.of(anno);\n\t\t}\n\t\t\n\t\tListBuffer<JCAnnotation> result = new ListBuffer<JCAnnotation>();\n\t\tfor (JavacNode child : node.down()) {\n\t\t\tif (child.getKind() == Kind.ANNOTATION) {\n\t\t\t\tJCAnnotation annotation = (JCAnnotation) child.get();\n\t\t\t\tboolean match = false;\n\t\t\t\tif (!match) for (String bn : annotationsToFind) if (typeMatches(bn, node, annotation.annotationType)) {\n\t\t\t\t\tresult.append(annotation);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result.toList();\n\t}\n\t\n\t/**\n\t * Generates a new statement that checks if the given variable is null, and if so, throws a configured exception with the\n\t * variable name as message.\n\t */\n\tpublic static JCStatement generateNullCheck(JavacTreeMaker maker, JavacNode variable, JavacNode source) {\n\t\treturn generateNullCheck(maker, (JCVariableDecl) variable.get(), source);\n\t}\n\t\n\t/**\n\t * Generates a new statement that checks if the given local is null, and if so, throws a configured exception with the\n\t * local variable name as message. \n\t */\n\tpublic static JCStatement generateNullCheck(JavacTreeMaker maker, JCExpression typeNode, Name varName, JavacNode source, String customMessage) {\n\t\tNullCheckExceptionType exceptionType = source.getAst().readConfiguration(ConfigurationKeys.NON_NULL_EXCEPTION_TYPE);\n\t\tif (exceptionType == null) exceptionType = NullCheckExceptionType.NULL_POINTER_EXCEPTION;\n\t\t\n\t\tif (typeNode != null && isPrimitive(typeNode)) return null;\n\t\tJCLiteral message = maker.Literal(exceptionType.toExceptionMessage(varName.toString(), customMessage));\n\t\t\n\t\tLombokImmutableList<String> method = exceptionType.getMethod();\n\t\tif (method != null) {\n\t\t\treturn maker.Exec(maker.Apply(List.<JCExpression>nil(), chainDots(source, method), List.of(maker.Ident(varName), message)));\n\t\t}\n\t\t\n\t\tif (exceptionType == NullCheckExceptionType.ASSERTION) {\n\t\t\treturn maker.Assert(maker.Binary(CTC_NOT_EQUAL, maker.Ident(varName), maker.Literal(CTC_BOT, null)), message);\n\t\t}\n\t\t\n\t\tJCExpression exType = genTypeRef(source, exceptionType.getExceptionType());\n\t\tJCExpression exception = maker.NewClass(null, List.<JCExpression>nil(), exType, List.<JCExpression>of(message), null);\n\t\tJCStatement throwStatement = maker.Throw(exception);\n\t\tJCBlock throwBlock = maker.Block(0, List.of(throwStatement));\n\t\treturn maker.If(maker.Binary(CTC_EQUAL, maker.Ident(varName), maker.Literal(CTC_BOT, null)), throwBlock, null);\n\t}\n\t\n\t/**\n\t * Generates a new statement that checks if the given variable is null, and if so, throws a configured exception with the\n\t * variable name as message. \n\t * \n\t * This is a special case method reserved for use when the provided declaration differs from the\n\t * variable's declaration, i.e. in a constructor or setter where the local parameter is named the same but with the prefix\n\t * stripped as a result of @Accessors.prefix.\n\t */\n\tpublic static JCStatement generateNullCheck(JavacTreeMaker maker, JCVariableDecl varDecl, JavacNode source) {\n\t\treturn generateNullCheck(maker, varDecl.vartype, varDecl.name, source, null);\n\t}\n\t\n\t/**\n\t * Given a list of field names and a node referring to a type, finds each name in the list that does not match a field within the type.\n\t */\n\tpublic static List<Integer> createListOfNonExistentFields(List<String> list, JavacNode type, boolean excludeStandard, boolean excludeTransient) {\n\t\tboolean[] matched = new boolean[list.size()];\n\t\t\n\t\tfor (JavacNode child : type.down()) {\n\t\t\tif (list.isEmpty()) break;\n\t\t\tif (child.getKind() != Kind.FIELD) continue;\n\t\t\tJCVariableDecl field = (JCVariableDecl)child.get();\n\t\t\tif (excludeStandard) {\n\t\t\t\tif ((field.mods.flags & Flags.STATIC) != 0) continue;\n\t\t\t\tif (field.name.toString().startsWith(\"$\")) continue;\n\t\t\t}\n\t\t\tif (excludeTransient && (field.mods.flags & Flags.TRANSIENT) != 0) continue;\n\t\t\t\n\t\t\tint idx = list.indexOf(child.getName());\n\t\t\tif (idx > -1) matched[idx] = true;\n\t\t}\n\t\t\n\t\tListBuffer<Integer> problematic = new ListBuffer<Integer>();\n\t\tfor (int i = 0 ; i < list.size() ; i++) {\n\t\t\tif (!matched[i]) problematic.append(i);\n\t\t}\n\t\t\n\t\treturn problematic.toList();\n\t}\n\t\n\tstatic List<JCAnnotation> unboxAndRemoveAnnotationParameter(JCAnnotation ast, String parameterName, String errorName, JavacNode annotationNode) {\n\t\tListBuffer<JCExpression> params = new ListBuffer<JCExpression>();\n\t\tListBuffer<JCAnnotation> result = new ListBuffer<JCAnnotation>();\n\t\t\n\t\touter:\n\t\tfor (JCExpression param : ast.args) {\n\t\t\tboolean allowRaw;\n\t\t\tString nameOfParam = \"value\";\n\t\t\tJCExpression valueOfParam = null;\n\t\t\tif (param instanceof JCAssign) {\n\t\t\t\tJCAssign assign = (JCAssign) param;\n\t\t\t\tif (assign.lhs instanceof JCIdent) {\n\t\t\t\t\tJCIdent ident = (JCIdent) assign.lhs;\n\t\t\t\t\tnameOfParam = ident.name.toString();\n\t\t\t\t}\n\t\t\t\tvalueOfParam = assign.rhs;\n\t\t\t}\n\t\t\t\n\t\t\t/* strip trailing underscores */ {\n\t\t\t\tint lastIdx;\n\t\t\t\tfor (lastIdx = nameOfParam.length() ; lastIdx > 0; lastIdx--) {\n\t\t\t\t\tif (nameOfParam.charAt(lastIdx - 1) != '_') break;\n\t\t\t\t}\n\t\t\t\tallowRaw = lastIdx < nameOfParam.length();\n\t\t\t\tnameOfParam = nameOfParam.substring(0, lastIdx);\n\t\t\t}\n\t\t\t\n\t\t\tif (!parameterName.equals(nameOfParam)) {\n\t\t\t\tparams.append(param);\n\t\t\t\tcontinue outer;\n\t\t\t}\n\t\t\t\n\t\t\tint endPos = Javac.getEndPosition(param.pos(), (JCCompilationUnit) annotationNode.top().get());\n\t\t\tannotationNode.getAst().removeFromDeferredDiagnostics(param.pos, endPos);\n\t\t\t\n\t\t\tif (valueOfParam instanceof JCAnnotation) {\n\t\t\t\tString dummyAnnotationName = ((JCAnnotation) valueOfParam).annotationType.toString();\n\t\t\t\tdummyAnnotationName = dummyAnnotationName.replace(\"_\", \"\").replace(\"$\", \"\").replace(\"x\", \"\").replace(\"X\", \"\");\n\t\t\t\tif (dummyAnnotationName.length() > 0) {\n\t\t\t\t\tif (allowRaw) {\n\t\t\t\t\t\tresult.append((JCAnnotation) valueOfParam);\n\t\t\t\t\t} else {\n\t\t\t\t\t\taddError(errorName, annotationNode);\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (JCExpression expr : ((JCAnnotation) valueOfParam).args) {\n\t\t\t\t\t\tif (expr instanceof JCAssign && ((JCAssign) expr).lhs instanceof JCIdent) {\n\t\t\t\t\t\t\tJCIdent id = (JCIdent) ((JCAssign) expr).lhs;\n\t\t\t\t\t\t\tif (\"value\".equals(id.name.toString())) {\n\t\t\t\t\t\t\t\texpr = ((JCAssign) expr).rhs;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\taddError(errorName, annotationNode);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (expr instanceof JCAnnotation) {\n\t\t\t\t\t\t\tresult.append((JCAnnotation) expr);\n\t\t\t\t\t\t} else if (expr instanceof JCNewArray) {\n\t\t\t\t\t\t\tfor (JCExpression expr2 : ((JCNewArray) expr).elems) {\n\t\t\t\t\t\t\t\tif (expr2 instanceof JCAnnotation) {\n\t\t\t\t\t\t\t\t\tresult.append((JCAnnotation) expr2);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\taddError(errorName, annotationNode);\n\t\t\t\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\taddError(errorName, annotationNode);\n\t\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (valueOfParam instanceof JCNewArray) {\n\t\t\t\tJCNewArray arr = (JCNewArray) valueOfParam;\n\t\t\t\tif (arr.elems.isEmpty()) {\n\t\t\t\t\t// Just remove it, this is always fine.\n\t\t\t\t} else if (allowRaw) {\n\t\t\t\t\tfor (JCExpression jce : arr.elems) {\n\t\t\t\t\t\tif (jce instanceof JCAnnotation) result.append((JCAnnotation) jce);\n\t\t\t\t\t\telse addError(errorName, annotationNode);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\taddError(errorName, annotationNode);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\taddError(errorName, annotationNode);\n\t\t\t}\n\t\t}\n\t\tfor (JCAnnotation annotation : result) {\n\t\t\tclearTypes(annotation);\n\t\t}\n\t\tast.args = params.toList();\n\t\treturn result.toList();\n\t}\n\t\n\t/**\n\t * Removes all type information from the provided tree.\n\t */\n\tprivate static void clearTypes(JCTree tree) {\n\t\ttree.accept(new TreeScanner() {\n\t\t\t@Override public void scan(JCTree tree) {\n\t\t\t\tif (tree == null) return;\n\t\t\t\ttree.type = null;\n\t\t\t\tsuper.scan(tree);\n\t\t\t}\n\t\t\t@Override public void visitClassDef(JCClassDecl tree) {\n\t\t\t\ttree.sym = null;\n\t\t\t\tsuper.visitClassDef(tree);\n\t\t\t}\n\t\t\t@Override public void visitMethodDef(JCMethodDecl tree) {\n\t\t\t\ttree.sym = null;\n\t\t\t\tsuper.visitMethodDef(tree);\n\t\t\t}\n\t\t\t@Override public void visitVarDef(JCVariableDecl tree) {\n\t\t\t\ttree.sym = null;\n\t\t\t\tsuper.visitVarDef(tree);\n\t\t\t}\n\t\t\t@Override public void visitSelect(JCFieldAccess tree) {\n\t\t\t\ttree.sym = null;\n\t\t\t\tsuper.visitSelect(tree);\n\t\t\t}\n\t\t\t@Override public void visitIdent(JCIdent tree) {\n\t\t\t\ttree.sym = null;\n\t\t\t\tsuper.visitIdent(tree);\n\t\t\t}\n\t\t\t@Override public void visitAnnotation(JCAnnotation tree) {\n\t\t\t\tJCAnnotationReflect.setAttribute(tree, null);\n\t\t\t\tsuper.visitAnnotation(tree);\n\t\t\t}\n\t\t});\n\t}\n\t\n\tprivate static void addError(String errorName, JavacNode node) {\n\t\tif (node.getLatestJavaSpecSupported() < 8) {\n\t\t\tnode.addError(\"The correct format up to JDK7 is \" + errorName + \"=@__({@SomeAnnotation, @SomeOtherAnnotation}))\");\n\t\t} else {\n\t\t\tnode.addError(\"The correct format for JDK8+ is \" + errorName + \"_={@SomeAnnotation, @SomeOtherAnnotation})\");\n\t\t}\n\t}\n\t\n\tpublic static List<JCTypeParameter> copyTypeParams(JavacNode source, List<JCTypeParameter> params) {\n\t\tif (params == null || params.isEmpty()) return params;\n\t\tListBuffer<JCTypeParameter> out = new ListBuffer<JCTypeParameter>();\n\t\tJavacTreeMaker maker = source.getTreeMaker();\n\t\tfor (JCTypeParameter tp : params) {\n\t\t\tList<JCExpression> bounds = tp.bounds;\n\t\t\tif (bounds != null && !bounds.isEmpty()) {\n\t\t\t\tListBuffer<JCExpression> boundsCopy = new ListBuffer<JCExpression>();\n\t\t\t\tfor (JCExpression expr : tp.bounds) {\n\t\t\t\t\tboundsCopy.append(cloneType(maker, expr, source));\n\t\t\t\t}\n\t\t\t\tbounds = boundsCopy.toList();\n\t\t\t}\n\t\t\tout.append(maker.TypeParameter(tp.name, bounds));\n\t\t}\n\t\treturn out.toList();\n\t}\n\t\n\tpublic static List<JCAnnotation> getTypeUseAnnotations(JCExpression from) {\n\t\tif (!JCAnnotatedTypeReflect.is(from)) return List.nil();\n\t\treturn JCAnnotatedTypeReflect.getAnnotations(from);\n\t}\n\t\n\tpublic static JCExpression removeTypeUseAnnotations(JCExpression from) {\n\t\tif (!JCAnnotatedTypeReflect.is(from)) return from;\n\t\treturn JCAnnotatedTypeReflect.getUnderlyingType(from);\n\t}\n\t\n\tpublic static JCExpression namePlusTypeParamsToTypeReference(JavacTreeMaker maker, JavacNode type, List<JCTypeParameter> params) {\n\t\tJCClassDecl td = (JCClassDecl) type.get();\n\t\tboolean instance = (td.mods.flags & Flags.STATIC) == 0;\n\t\treturn namePlusTypeParamsToTypeReference(maker, type.up(), td.name, instance, params, List.<JCAnnotation>nil());\n\t}\n\t\n\tpublic static JCExpression namePlusTypeParamsToTypeReference(JavacTreeMaker maker, JavacNode type, List<JCTypeParameter> params, List<JCAnnotation> annotations) {\n\t\tJCClassDecl td = (JCClassDecl) type.get();\n\t\tboolean instance = (td.mods.flags & Flags.STATIC) == 0;\n\t\treturn namePlusTypeParamsToTypeReference(maker, type.up(), td.name, instance, params, annotations);\n\t}\n\t\n\tpublic static JCExpression namePlusTypeParamsToTypeReference(JavacTreeMaker maker, JavacNode parentType, Name typeName, boolean instance, List<JCTypeParameter> params) {\n\t\treturn namePlusTypeParamsToTypeReference(maker, parentType, typeName, instance, params, List.<JCAnnotation>nil());\n\t}\n\t\n\tpublic static JCExpression namePlusTypeParamsToTypeReference(JavacTreeMaker maker, JavacNode parentType, Name typeName, boolean instance, List<JCTypeParameter> params, List<JCAnnotation> annotations) {\n\t\tJCExpression r = null;\n\t\tif (parentType != null && parentType.getKind() == Kind.TYPE && !parentType.getName().isEmpty()) {\n\t\t\tJCClassDecl td = (JCClassDecl) parentType.get();\n\t\t\tboolean outerInstance = instance && ((td.mods.flags & Flags.STATIC) == 0);\n\t\t\tList<JCTypeParameter> outerParams = instance ? td.typarams : List.<JCTypeParameter>nil();\n\t\t\tr = namePlusTypeParamsToTypeReference(maker, parentType.up(), td.name, outerInstance, outerParams, List.<JCAnnotation>nil());\n\t\t}\n\t\t\n\t\tr = r == null ? maker.Ident(typeName) : maker.Select(r, typeName);\n\t\tif (!annotations.isEmpty()) r = JCAnnotatedTypeReflect.create(annotations, r);\n\t\tif (!params.isEmpty()) r = maker.TypeApply(r, typeParameterNames(maker, params));\n\t\treturn r;\n\t}\n\t\n\tpublic static List<JCExpression> typeParameterNames(JavacTreeMaker maker, List<JCTypeParameter> params) {\n\t\tListBuffer<JCExpression> typeArgs = new ListBuffer<JCExpression>();\n\t\tfor (JCTypeParameter param : params) {\n\t\t\ttypeArgs.append(maker.Ident(param.name));\n\t\t}\n\t\treturn typeArgs.toList();\n\t}\n\t\n\tpublic static void sanityCheckForMethodGeneratingAnnotationsOnBuilderClass(JavacNode typeNode, JavacNode errorNode) {\n\t\tList<String> disallowed = List.nil();\n\t\tfor (JavacNode child : typeNode.down()) {\n\t\t\tfor (String annType : INVALID_ON_BUILDERS) {\n\t\t\t\tif (annotationTypeMatches(annType, child)) {\n\t\t\t\t\tint lastIndex = annType.lastIndexOf('.');\n\t\t\t\t\tdisallowed = disallowed.append(lastIndex == -1 ? annType : annType.substring(lastIndex + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint size = disallowed.size();\n\t\tif (size == 0) return;\n\t\tif (size == 1) {\n\t\t\terrorNode.addError(\"@\" + disallowed.head + \" is not allowed on builder classes.\");\n\t\t\treturn;\n\t\t}\n\t\tStringBuilder out = new StringBuilder();\n\t\tfor (String a : disallowed) out.append(\"@\").append(a).append(\", \");\n\t\tout.setLength(out.length() - 2);\n\t\terrorNode.addError(out.append(\" are not allowed on builder classes.\").toString());\n\t}\n\t\n\tstatic List<JCAnnotation> copyAnnotations(List<? extends JCExpression> in) {\n\t\tListBuffer<JCAnnotation> out = new ListBuffer<JCAnnotation>();\n\t\tfor (JCExpression expr : in) {\n\t\t\tif (!(expr instanceof JCAnnotation)) continue;\n\t\t\tout.append((JCAnnotation) expr.clone());\n\t\t}\n\t\treturn out.toList();\n\t}\n\t\n\tstatic List<JCAnnotation> mergeAnnotations(List<JCAnnotation> a, List<JCAnnotation> b) {\n\t\tif (a == null || a.isEmpty()) return b;\n\t\tif (b == null || b.isEmpty()) return a;\n\t\tListBuffer<JCAnnotation> out = new ListBuffer<JCAnnotation>();\n\t\tfor (JCAnnotation ann : a) out.append(ann);\n\t\tfor (JCAnnotation ann : b) out.append(ann);\n\t\treturn out.toList();\n\t}\n\t\n\t/**\n\t * Returns {@code true} if the provided node is an actual class and not some other type declaration (so, not an annotation definition, interface, enum, or record).\n\t */\n\tpublic static boolean isClass(JavacNode typeNode) {\n\t\treturn isClassAndDoesNotHaveFlags(typeNode, Flags.INTERFACE | Flags.ENUM | Flags.ANNOTATION | RECORD);\n\t}\n\t\n\t/**\n\t * Returns {@code true} if the provided node is an actual class or enum and not some other type declaration (so, not an annotation definition, interface, or record).\n\t */\n\tpublic static boolean isClassOrEnum(JavacNode typeNode) {\n\t\treturn isClassAndDoesNotHaveFlags(typeNode, Flags.INTERFACE | Flags.ANNOTATION | RECORD);\n\t}\n\t\n\tpublic static boolean isClassOrEnumOrInterface(JavacNode typeNode) {\n\t\treturn isClassAndDoesNotHaveFlags(typeNode, Flags.ANNOTATION | RECORD);\n\t}\n\t\n\t/**\n\t * Returns {@code true} if the provided node is an actual class, an enum or a record and not some other type declaration (so, not an annotation definition or interface).\n\t */\n\tpublic static boolean isClassEnumOrRecord(JavacNode typeNode) {\n\t\treturn isClassAndDoesNotHaveFlags(typeNode, Flags.INTERFACE | Flags.ANNOTATION);\n\t}\n\t\n\t/**\n\t * Returns {@code true} if the provided node is a record declaration (so, not an annotation definition, interface, enum, or plain class).\n\t */\n\tpublic static boolean isRecord(JavacNode typeNode) {\n\t\treturn typeNode.getKind() == Kind.TYPE && (((JCClassDecl) typeNode.get()).mods.flags & RECORD) != 0;\n\t}\n\t\n\tpublic static boolean isClassAndDoesNotHaveFlags(JavacNode typeNode, long flags) {\n\t\tJCClassDecl typeDecl = null;\n\t\tif (typeNode.get() instanceof JCClassDecl) typeDecl = (JCClassDecl) typeNode.get();\n\t\telse return false;\n\t\t\n\t\tlong typeDeclflags = typeDecl == null ? 0 : typeDecl.mods.flags;\n\t\treturn (typeDeclflags & flags) == 0;\n\t}\n\t\n\t/**\n\t * Returns {@code true} if the provided node supports static methods and types (top level or static class)\n\t */\n\tpublic static boolean isStaticAllowed(JavacNode typeNode) {\n\t\treturn typeNode.isStatic() || typeNode.up() == null || typeNode.up().getKind() == Kind.COMPILATION_UNIT || isRecord(typeNode);\n\t}\n\t\n\tpublic static JavacNode upToTypeNode(JavacNode node) {\n\t\tif (node == null) throw new NullPointerException(\"node\");\n\t\twhile ((node != null) && !(node.get() instanceof JCClassDecl)) node = node.up();\n\t\t\n\t\treturn node;\n\t}\n\t\n\tpublic static List<JCExpression> cloneTypes(JavacTreeMaker maker, List<JCExpression> in, JavacNode source) {\n\t\tif (in.isEmpty()) return List.nil();\n\t\tif (in.size() == 1) return List.of(cloneType(maker, in.get(0), source));\n\t\tListBuffer<JCExpression> lb = new ListBuffer<JCExpression>();\n\t\tfor (JCExpression expr : in) lb.append(cloneType(maker, expr, source));\n\t\treturn lb.toList();\n\t}\n\t\n\t/**\n\t * Creates a full clone of a given javac AST type node. Every part is cloned (every identifier, every select, every wildcard, every type apply, every type_use annotation).\n\t * \n\t * If there's any node in the tree that we don't know how to clone, that part isn't cloned. However, we wouldn't know what could possibly show up that we\n\t * can't currently clone; that's just a safeguard.\n\t * \n\t * This should be used if the type looks the same in the code, but resolves differently. For example, a static method that has some generics in it named after\n\t * the class's own parameter, but as its a static method, the static method's notion of {@code T} is different from the class notion of {@code T}. If you're duplicating\n\t * a type used in the class context, you need to use this method.\n\t */\n\tpublic static JCExpression cloneType(JavacTreeMaker maker, JCExpression in, JavacNode source) {\n\t\tJCExpression out = cloneType0(maker, in);\n\t\tif (out != null) recursiveSetGeneratedBy(out, source);\n\t\treturn out;\n\t}\n\t\n\tprivate static JCExpression cloneType0(JavacTreeMaker maker, JCTree in) {\n\t\tif (in == null) return null;\n\t\t\n\t\tif (in instanceof JCPrimitiveTypeTree) {\n\t\t\treturn maker.TypeIdent(TypeTag.typeTag(in));\n\t\t}\n\t\t\n\t\tif (in instanceof JCIdent) {\n\t\t\treturn maker.Ident(((JCIdent) in).name);\n\t\t}\n\t\t\n\t\tif (in instanceof JCFieldAccess) {\n\t\t\tJCFieldAccess fa = (JCFieldAccess) in;\n\t\t\treturn maker.Select(cloneType0(maker, fa.selected), fa.name);\n\t\t}\n\t\t\n\t\tif (in instanceof JCArrayTypeTree) {\n\t\t\tJCArrayTypeTree att = (JCArrayTypeTree) in;\n\t\t\treturn maker.TypeArray(cloneType0(maker, att.elemtype));\n\t\t}\n\t\t\n\t\tif (in instanceof JCTypeApply) {\n\t\t\tJCTypeApply ta = (JCTypeApply) in;\n\t\t\tListBuffer<JCExpression> lb = new ListBuffer<JCExpression>();\n\t\t\tfor (JCExpression typeArg : ta.arguments) {\n\t\t\t\tlb.append(cloneType0(maker, typeArg));\n\t\t\t}\n\t\t\treturn maker.TypeApply(cloneType0(maker, ta.clazz), lb.toList());\n\t\t}\n\t\t\n\t\tif (in instanceof JCWildcard) {\n\t\t\tJCWildcard w = (JCWildcard) in;\n\t\t\tJCExpression newInner = cloneType0(maker, w.inner);\n\t\t\tTypeBoundKind newKind;\n\t\t\tswitch (w.getKind()) {\n\t\t\tcase SUPER_WILDCARD:\n\t\t\t\tnewKind = maker.TypeBoundKind(BoundKind.SUPER);\n\t\t\t\tbreak;\n\t\t\tcase EXTENDS_WILDCARD:\n\t\t\t\tnewKind = maker.TypeBoundKind(BoundKind.EXTENDS);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\tcase UNBOUNDED_WILDCARD:\n\t\t\t\tnewKind = maker.TypeBoundKind(BoundKind.UNBOUND);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn maker.Wildcard(newKind, newInner);\n\t\t}\n\t\t\n\t\tif (JCAnnotatedTypeReflect.is(in)) {\n\t\t\tJCExpression underlyingType = cloneType0(maker, JCAnnotatedTypeReflect.getUnderlyingType(in));\n\t\t\tList<JCAnnotation> anns = copyAnnotations(JCAnnotatedTypeReflect.getAnnotations(in));\n\t\t\treturn JCAnnotatedTypeReflect.create(anns, underlyingType);\n\t\t}\n\t\t\n\t\t// This is somewhat unsafe, but it's better than outright throwing an exception here. Returning null will just cause an exception down the pipeline.\n\t\treturn (JCExpression) in;\n\t}\n\t\n\tpublic static enum CopyJavadoc {\n\t\tVERBATIM {\n\t\t\t@Override public String apply(final JCCompilationUnit cu, final JavacNode node) {\n\t\t\t\treturn Javac.getDocComment(cu, node.get());\n\t\t\t}\n\t\t},\n\t\tGETTER {\n\t\t\t@Override public String apply(final JCCompilationUnit cu, final JavacNode node) {\n\t\t\t\tfinal JCTree n = node.get();\n\t\t\t\tString javadoc = Javac.getDocComment(cu, n);\n\t\t\t\t// step 1: Check if there is a 'GETTER' section. If yes, that becomes the new method's javadoc.\n\t\t\t\tString out = getJavadocSection(javadoc, \"GETTER\");\n\t\t\t\tfinal boolean sectionBased = out != null;\n\t\t\t\tif (!sectionBased) {\n\t\t\t\t\tout = stripLinesWithTagFromJavadoc(stripSectionsFromJavadoc(javadoc), JavadocTag.PARAM);\n\t\t\t\t}\n\t\t\t\tnode.getAst().cleanupTask(\"javadocfilter-getter\", n, new CleanupTask() {\n\t\t\t\t\t@Override public void cleanup() {\n\t\t\t\t\t\tString javadoc = Javac.getDocComment(cu, n);\n\t\t\t\t\t\tif (javadoc == null || javadoc.isEmpty()) return;\n\t\t\t\t\t\tjavadoc = stripSectionsFromJavadoc(javadoc);\n\t\t\t\t\t\tif (!sectionBased) {\n\t\t\t\t\t\t\tjavadoc = stripLinesWithTagFromJavadoc(stripSectionsFromJavadoc(javadoc), JavadocTag.RETURN);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tJavac.setDocComment(cu, n, javadoc);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn out;\n\t\t\t}\n\t\t},\n\t\tSETTER {\n\t\t\t@Override public String apply(final JCCompilationUnit cu, final JavacNode node) {\n\t\t\t\treturn applySetter(cu, node, \"SETTER\");\n\t\t\t}\n\t\t},\n\t\tWITH {\n\t\t\t@Override public String apply(final JCCompilationUnit cu, final JavacNode node) {\n\t\t\t\treturn addReturnsUpdatedSelfIfNeeded(applySetter(cu, node, \"WITH|WITHER\"));\n\t\t\t}\n\t\t},\n\t\tWITH_BY {\n\t\t\t@Override public String apply(final JCCompilationUnit cu, final JavacNode node) {\n\t\t\t\treturn applySetter(cu, node, \"WITHBY|WITH_BY\");\n\t\t\t}\n\t\t};\n\t\t\n\t\tpublic abstract String apply(final JCCompilationUnit cu, final JavacNode node);\n\t\t\n\t\tprivate static String applySetter(final JCCompilationUnit cu, JavacNode node, String sectionName) {\n\t\t\tfinal JCTree n = node.get();\n\t\t\tString javadoc = Javac.getDocComment(cu, n);\n\t\t\t// step 1: Check if there is a 'SETTER' section. If yes, that becomes the new method's javadoc.\n\t\t\tString out = getJavadocSection(javadoc, sectionName);\n\t\t\tfinal boolean sectionBased = out != null;\n\t\t\tif (!sectionBased) {\n\t\t\t\tout = stripLinesWithTagFromJavadoc(stripSectionsFromJavadoc(javadoc), JavadocTag.RETURN);\n\t\t\t}\n\t\t\tnode.getAst().cleanupTask(\"javadocfilter-setter\", n, new CleanupTask() {\n\t\t\t\t@Override public void cleanup() {\n\t\t\t\t\tString javadoc = Javac.getDocComment(cu, n);\n\t\t\t\t\tif (javadoc == null || javadoc.isEmpty()) return;\n\t\t\t\t\tjavadoc = stripSectionsFromJavadoc(javadoc);\n\t\t\t\t\tif (!sectionBased) {\n\t\t\t\t\t\tjavadoc = stripLinesWithTagFromJavadoc(stripSectionsFromJavadoc(javadoc), JavadocTag.PARAM);\n\t\t\t\t\t}\n\t\t\t\t\tJavac.setDocComment(cu, n, javadoc);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn shouldReturnThis(node, JavacHandlerUtil.getAccessorsForField(node)) ? addReturnsThisIfNeeded(out) : out;\n\t\t}\n\t}\n\t\n\tpublic static void copyJavadoc(JavacNode from, JCTree to, CopyJavadoc copyMode) {\n\t\tcopyJavadoc(from, to, copyMode, false);\n\t}\n\t\n\t/**\n\t * Copies javadoc on one node to the other.\n\t * \n\t * in 'GETTER' copyMode, first a 'GETTER' segment is searched for. If it exists, that will become the javadoc for the 'to' node, and this section is\n\t * stripped out of the 'from' node. If no 'GETTER' segment is found, then the entire javadoc is taken minus any {@code @param} lines and other sections.\n\t * any {@code @return} lines are stripped from 'from'.\n\t * \n\t * in 'SETTER' mode, stripping works similarly to 'GETTER' mode, except {@code param} are copied and stripped from the original and {@code @return} are skipped.\n\t */\n\tpublic static void copyJavadoc(JavacNode from, JCTree to, CopyJavadoc copyMode, boolean forceAddReturn) {\n\t\tif (copyMode == null) copyMode = CopyJavadoc.VERBATIM;\n\t\ttry {\n\t\t\tJCCompilationUnit cu = ((JCCompilationUnit) from.top().get());\n\t\t\tString newJavadoc = copyMode.apply(cu, from);\n\t\t\tif (forceAddReturn) {\n\t\t\t\tnewJavadoc = addReturnsThisIfNeeded(newJavadoc);\n\t\t\t}\n\t\t\tJavac.setDocComment(cu, to, newJavadoc);\n\t\t} catch (Exception ignore) {}\n\t}\n\t\n\tpublic static boolean isDirectDescendantOfObject(JavacNode typeNode) {\n\t\tif (!(typeNode.get() instanceof JCClassDecl)) throw new IllegalArgumentException(\"not a type node\");\n\t\tJCTree extending = Javac.getExtendsClause((JCClassDecl) typeNode.get());\n\t\tif (extending == null) return true;\n\t\tString p = extending.toString();\n\t\treturn p.equals(\"Object\") || p.equals(\"java.lang.Object\");\n\t}\n\t\n\tpublic static void createRelevantNullableAnnotation(JavacNode typeNode, JCMethodDecl mth) {\n\t\tNullAnnotationLibrary lib = typeNode.getAst().readConfiguration(ConfigurationKeys.ADD_NULL_ANNOTATIONS);\n\t\tif (lib == null) return;\n\t\tapplyAnnotationToMethodDecl(typeNode, mth, lib.getNullableAnnotation(), lib.isTypeUse());\n\t}\n\t\n\tpublic static void createRelevantNonNullAnnotation(JavacNode typeNode, JCMethodDecl mth) {\n\t\tNullAnnotationLibrary lib = typeNode.getAst().readConfiguration(ConfigurationKeys.ADD_NULL_ANNOTATIONS);\n\t\tif (lib == null) return;\n\t\tapplyAnnotationToMethodDecl(typeNode, mth, lib.getNonNullAnnotation(), lib.isTypeUse());\n\t}\n\t\n\tpublic static void createRelevantNonNullAnnotation(JavacNode typeNode, JCVariableDecl arg) {\n\t\tNullAnnotationLibrary lib = typeNode.getAst().readConfiguration(ConfigurationKeys.ADD_NULL_ANNOTATIONS);\n\t\tif (lib == null) return;\n\t\t\n\t\tapplyAnnotationToVarDecl(typeNode, arg, lib.getNonNullAnnotation(), lib.isTypeUse());\n\t}\n\t\n\tpublic static void createRelevantNullableAnnotation(JavacNode typeNode, JCVariableDecl arg) {\n\t\tNullAnnotationLibrary lib = typeNode.getAst().readConfiguration(ConfigurationKeys.ADD_NULL_ANNOTATIONS);\n\t\tif (lib == null) return;\n\t\t\n\t\tapplyAnnotationToVarDecl(typeNode, arg, lib.getNullableAnnotation(), lib.isTypeUse());\n\t}\n\t\n\tprivate static void applyAnnotationToMethodDecl(JavacNode typeNode, JCMethodDecl mth, String annType, boolean typeUse) {\n\t\tif (annType == null) return;\n\t\tJavacTreeMaker maker = typeNode.getTreeMaker();\n\t\t\n\t\tJCAnnotation m = maker.Annotation(genTypeRef(typeNode, annType), List.<JCExpression>nil());\n\t\tif (typeUse) {\n\t\t\tJCExpression resType = mth.restype;\n\t\t\tif (resType instanceof JCTypeApply) {\n\t\t\t\tJCTypeApply ta = (JCTypeApply) resType;\n\t\t\t\tif (ta.clazz instanceof JCFieldAccess) {\n\t\t\t\t\tmth.restype = maker.TypeApply(maker.AnnotatedType(List.of(m), ta.clazz), ta.arguments);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tresType = ta.clazz;\n\t\t\t}\n\t\t\t\n\t\t\tif (resType instanceof JCFieldAccess || resType instanceof JCArrayTypeTree) {\n\t\t\t\tmth.restype = maker.AnnotatedType(List.of(m), resType);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif (JCAnnotatedTypeReflect.is(resType)) {\n\t\t\t\tList<JCAnnotation> annotations = JCAnnotatedTypeReflect.getAnnotations(resType);\n\t\t\t\tJCAnnotatedTypeReflect.setAnnotations(resType, annotations.prepend(m));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif (resType instanceof JCPrimitiveTypeTree || resType instanceof JCIdent) {\n\t\t\t\tmth.mods.annotations = mth.mods.annotations == null ? List.of(m) : mth.mods.annotations.prepend(m);\n\t\t\t}\n\t\t} else {\n\t\t\tmth.mods.annotations = mth.mods.annotations == null ? List.of(m) : mth.mods.annotations.prepend(m);\n\t\t}\n\t}\n\t\n\tprivate static void applyAnnotationToVarDecl(JavacNode typeNode, JCVariableDecl arg, String annType, boolean typeUse) {\n\t\tif (annType == null) return;\n\t\tJavacTreeMaker maker = typeNode.getTreeMaker();\n\t\t\n\t\tJCAnnotation m = maker.Annotation(genTypeRef(typeNode, annType), List.<JCExpression>nil());\n\t\tif (typeUse) {\n\t\t\tJCExpression varType = arg.vartype;\n\t\t\tJCTypeApply ta = null;\n\t\t\tif (varType instanceof JCTypeApply) {\n\t\t\t\tta = (JCTypeApply) varType;\n\t\t\t\tvarType = ta.clazz;\n\t\t\t}\n\t\t\t\n\t\t\tif (varType instanceof JCFieldAccess || varType instanceof JCArrayTypeTree) {\n\t\t\t\tvarType = maker.AnnotatedType(List.of(m), varType);\n\t\t\t\tif (ta != null) ta.clazz = varType;\n\t\t\t\telse arg.vartype = varType;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif (JCAnnotatedTypeReflect.is(varType)) {\n\t\t\t\tList<JCAnnotation> annotations = JCAnnotatedTypeReflect.getAnnotations(varType);\n\t\t\t\tJCAnnotatedTypeReflect.setAnnotations(varType, annotations.prepend(m));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif (varType instanceof JCPrimitiveTypeTree || varType instanceof JCIdent) {\n\t\t\t\targ.mods.annotations = arg.mods.annotations == null ? List.of(m) : arg.mods.annotations.prepend(m);\n\t\t\t}\n\t\t} else {\n\t\t\targ.mods.annotations = arg.mods.annotations == null ? List.of(m) : arg.mods.annotations.prepend(m);\n\t\t}\n\t}\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2009-2022 The Project Lombok Authors.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage lombok.javac.handlers;\n\nimport static com.sun.tools.javac.code.Flags.GENERATEDCONSTR;\nimport static lombok.core.handlers.HandlerUtil.*;\nimport static lombok.javac.Javac.*;\nimport static lombok.javac.JavacAugments.JCTree_generatedNode;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.regex.Pattern;\n\nimport com.sun.tools.javac.code.Attribute;\nimport com.sun.tools.javac.code.BoundKind;\nimport com.sun.tools.javac.code.Flags;\nimport com.sun.tools.javac.code.Scope;\nimport com.sun.tools.javac.code.Symbol;\nimport com.sun.tools.javac.code.Symbol.ClassSymbol;\nimport com.sun.tools.javac.code.Symbol.TypeSymbol;\nimport com.sun.tools.javac.code.Type;\nimport com.sun.tools.javac.comp.Annotate;\nimport com.sun.tools.javac.comp.AttrContext;\nimport com.sun.tools.javac.comp.Enter;\nimport com.sun.tools.javac.comp.Env;\nimport com.sun.tools.javac.comp.MemberEnter;\nimport com.sun.tools.javac.tree.JCTree;\nimport com.sun.tools.javac.tree.JCTree.JCAnnotation;\nimport com.sun.tools.javac.tree.JCTree.JCArrayTypeTree;\nimport com.sun.tools.javac.tree.JCTree.JCAssign;\nimport com.sun.tools.javac.tree.JCTree.JCBlock;\nimport com.sun.tools.javac.tree.JCTree.JCClassDecl;\nimport com.sun.tools.javac.tree.JCTree.JCCompilationUnit;\nimport com.sun.tools.javac.tree.JCTree.JCExpression;\nimport com.sun.tools.javac.tree.JCTree.JCExpressionStatement;\nimport com.sun.tools.javac.tree.JCTree.JCFieldAccess;\nimport com.sun.tools.javac.tree.JCTree.JCIdent;\nimport com.sun.tools.javac.tree.JCTree.JCImport;\nimport com.sun.tools.javac.tree.JCTree.JCLiteral;\nimport com.sun.tools.javac.tree.JCTree.JCMethodDecl;\nimport com.sun.tools.javac.tree.JCTree.JCMethodInvocation;\nimport com.sun.tools.javac.tree.JCTree.JCModifiers;\nimport com.sun.tools.javac.tree.JCTree.JCNewArray;\nimport com.sun.tools.javac.tree.JCTree.JCPrimitiveTypeTree;\nimport com.sun.tools.javac.tree.JCTree.JCStatement;\nimport com.sun.tools.javac.tree.JCTree.JCTypeApply;\nimport com.sun.tools.javac.tree.JCTree.JCTypeParameter;\nimport com.sun.tools.javac.tree.JCTree.JCVariableDecl;\nimport com.sun.tools.javac.tree.JCTree.JCWildcard;\nimport com.sun.tools.javac.tree.JCTree.TypeBoundKind;\nimport com.sun.tools.javac.tree.TreeMaker;\nimport com.sun.tools.javac.tree.TreeScanner;\nimport com.sun.tools.javac.util.Context;\nimport com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\nimport com.sun.tools.javac.util.List;\nimport com.sun.tools.javac.util.ListBuffer;\nimport com.sun.tools.javac.util.Name;\nimport com.sun.tools.javac.util.Options;\n\nimport lombok.AccessLevel;\nimport lombok.ConfigurationKeys;\nimport lombok.Data;\nimport lombok.Getter;\nimport lombok.core.AST.Kind;\nimport lombok.core.AnnotationValues;\nimport lombok.core.AnnotationValues.AnnotationValue;\nimport lombok.core.CleanupTask;\nimport lombok.core.LombokImmutableList;\nimport lombok.core.TypeResolver;\nimport lombok.core.configuration.CheckerFrameworkVersion;\nimport lombok.core.configuration.NullAnnotationLibrary;\nimport lombok.core.configuration.NullCheckExceptionType;\nimport lombok.core.configuration.TypeName;\nimport lombok.core.handlers.HandlerUtil;\nimport lombok.core.handlers.HandlerUtil.FieldAccess;\nimport lombok.delombok.LombokOptionsFactory;\nimport lombok.experimental.Accessors;\nimport lombok.experimental.Tolerate;\nimport lombok.javac.Javac;\nimport lombok.javac.JavacAugments;\nimport lombok.javac.JavacNode;\nimport lombok.javac.JavacTreeMaker;\nimport lombok.javac.JavacTreeMaker.TypeTag;\nimport lombok.permit.Permit;\n\n/**\n * Container for static utility methods useful to handlers written for javac.\n */\npublic class JavacHandlerUtil {\n\tprivate JavacHandlerUtil() {\n\t\t//Prevent instantiation\n\t}\n\t\n\tprivate static class MarkingScanner extends TreeScanner {\n\t\tprivate final JavacNode source;\n\t\t\n\t\tMarkingScanner(JavacNode source) {\n\t\t\tthis.source = source;\n\t\t}\n\t\t\n\t\t@Override public void scan(JCTree tree) {\n\t\t\tif (tree == null) return;\n\t\t\tsetGeneratedBy(tree, source);\n\t\t\tsuper.scan(tree);\n\t\t}\n\t}\n\t\n\t/**\n\t * Contributed by Jan Lahoda; many lombok transformations should not be run (or a lite version should be run) when the netbeans editor\n\t * is running javac on the open source file to find inline errors and such. As class files are compiled separately this does not affect\n\t * actual runtime behaviour or file output of the netbeans IDE.\n\t */\n\tpublic static boolean inNetbeansEditor(JavacNode node) {\n\t\treturn inNetbeansEditor(node.getContext());\n\t}\n\t\n\tpublic static boolean inNetbeansEditor(Context context) {\n\t\tOptions options = Options.instance(context);\n\t\treturn (options.keySet().contains(\"ide\") && !options.keySet().contains(\"backgroundCompilation\"));\n\t}\n\t\n\tpublic static boolean inNetbeansCompileOnSave(Context context) {\n\t\tOptions options = Options.instance(context);\n\t\treturn (options.keySet().contains(\"ide\") && options.keySet().contains(\"backgroundCompilation\"));\n\t}\n\t\n\tpublic static JCTree getGeneratedBy(JCTree node) {\n\t\treturn JCTree_generatedNode.get(node);\n\t}\n\t\n\tpublic static boolean isGenerated(JCTree node) {\n\t\treturn getGeneratedBy(node) != null;\n\t}\n\t\n\tpublic static <T extends JCTree> T recursiveSetGeneratedBy(T node, JavacNode source) {\n\t\tif (node == null) return null;\n\t\tsetGeneratedBy(node, source);\n\t\tnode.accept(new MarkingScanner(source));\n\t\treturn node;\n\t}\n\t\n\tpublic static <T extends JCTree> T setGeneratedBy(T node, JavacNode sourceNode) {\n\t\tif (node == null) return null;\n\t\tif (sourceNode == null) {\n\t\t\tJCTree_generatedNode.clear(node);\n\t\t\treturn node;\n\t\t}\n\t\tJCTree_generatedNode.set(node, sourceNode.get());\n\t\t\n\t\tif (!inNetbeansEditor(sourceNode.getContext()) || isParameter(node)) {\n\t\t\tnode.pos = sourceNode.getStartPos();\n\t\t\tstoreEnd(node, sourceNode.getEndPosition(), (JCCompilationUnit) sourceNode.top().get());\n\t\t}\n\t\treturn node;\n\t}\n\n\tpublic static boolean isParameter(JCTree node) {\n\t\treturn node instanceof JCVariableDecl && (((JCVariableDecl) node).mods.flags & Flags.PARAMETER) != 0;\n\t}\n\t\n\tpublic static boolean hasAnnotation(String type, JavacNode node) {\n\t\treturn hasAnnotation(type, node, false);\n\t}\n\t\n\tpublic static boolean hasAnnotation(Class<? extends Annotation> type, JavacNode node) {\n\t\treturn hasAnnotation(type, node, false);\n\t}\n\t\n\tpublic static boolean hasAnnotationAndDeleteIfNeccessary(Class<? extends Annotation> type, JavacNode node) {\n\t\treturn hasAnnotation(type, node, true);\n\t}\n\t\n\tprivate static boolean hasAnnotation(Class<? extends Annotation> type, JavacNode node, boolean delete) {\n\t\tif (node == null) return false;\n\t\tif (type == null) return false;\n\t\tswitch (node.getKind()) {\n\t\tcase ARGUMENT:\n\t\tcase FIELD:\n\t\tcase LOCAL:\n\t\tcase TYPE:\n\t\tcase METHOD:\n\t\t\tfor (JavacNode child : node.down()) {\n\t\t\t\tif (annotationTypeMatches(type, child)) {\n\t\t\t\t\tif (delete) deleteAnnotationIfNeccessary(child, type);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// intentional fallthrough\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tprivate static boolean hasAnnotation(String type, JavacNode node, boolean delete) {\n\t\tif (node == null) return false;\n\t\tif (type == null) return false;\n\t\tswitch (node.getKind()) {\n\t\tcase ARGUMENT:\n\t\tcase FIELD:\n\t\tcase LOCAL:\n\t\tcase TYPE:\n\t\tcase METHOD:\n\t\t\tfor (JavacNode child : node.down()) {\n\t\t\t\tif (annotationTypeMatches(type, child)) {\n\t\t\t\t\tif (delete) deleteAnnotationIfNeccessary(child, type);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// intentional fallthrough\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tpublic static JavacNode findInnerClass(JavacNode parent, String name) {\n\t\tfor (JavacNode child : parent.down()) {\n\t\t\tif (child.getKind() != Kind.TYPE) continue;\n\t\t\tJCClassDecl td = (JCClassDecl) child.get();\n\t\t\tif (td.name.contentEquals(name)) return child;\n\t\t}\n\t\treturn null;\n\t}\n\t\n\tpublic static JavacNode findAnnotation(Class<? extends Annotation> type, JavacNode node) {\n\t\treturn findAnnotation(type, node, false);\n\t}\n\t\n\tpublic static JavacNode findAnnotation(Class<? extends Annotation> type, JavacNode node, boolean delete) {\n\t\tif (node == null) return null;\n\t\tif (type == null) return null;\n\t\tswitch (node.getKind()) {\n\t\tcase ARGUMENT:\n\t\tcase FIELD:\n\t\tcase LOCAL:\n\t\tcase TYPE:\n\t\tcase METHOD:\n\t\t\tfor (JavacNode child : node.down()) {\n\t\t\t\tif (annotationTypeMatches(type, child)) {\n\t\t\t\t\tif (delete) deleteAnnotationIfNeccessary(child, type);\n\t\t\t\t\treturn child;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// intentional fallthrough\n\t\tdefault:\n\t\t\treturn null;\n\t\t}\n\t}\n\t\n\t/**\n\t * Checks if the Annotation AST Node provided is likely to be an instance of the provided annotation type.\n\t * \n\t * @param type An actual annotation type, such as {@code lombok.Getter.class}.\n\t * @param node A Lombok AST node representing an annotation in source code.\n\t */\n\tpublic static boolean annotationTypeMatches(Class<? extends Annotation> type, JavacNode node) {\n\t\tif (node.getKind() != Kind.ANNOTATION) return false;\n\t\treturn typeMatches(type, node, ((JCAnnotation) node.get()).annotationType);\n\t}\n\t\n\t/**\n\t * Checks if the Annotation AST Node provided is likely to be an instance of the provided annotation type.\n\t * \n\t * @param type An actual annotation type, such as {@code lombok.Getter.class}.\n\t * @param node A Lombok AST node representing an annotation in source code.\n\t */\n\tpublic static boolean annotationTypeMatches(String type, JavacNode node) {\n\t\tif (node.getKind() != Kind.ANNOTATION) return false;\n\t\treturn typeMatches(type, node, ((JCAnnotation) node.get()).annotationType);\n\t}\n\t\n\t/**\n\t * Checks if the given TypeReference node is likely to be a reference to the provided class.\n\t * \n\t * @param type An actual type. This method checks if {@code typeNode} is likely to be a reference to this type.\n\t * @param node A Lombok AST node. Any node in the appropriate compilation unit will do (used to get access to import statements).\n\t * @param typeNode A type reference to check.\n\t */\n\tpublic static boolean typeMatches(Class<?> type, JavacNode node, JCTree typeNode) {\n\t\treturn typeMatches(type.getName(), node, typeNode);\n\t}\n\t\n\t/**\n\t * Checks if the given TypeReference node is likely to be a reference to the provided class.\n\t * \n\t * @param type An actual type. This method checks if {@code typeNode} is likely to be a reference to this type.\n\t * @param node A Lombok AST node. Any node in the appropriate compilation unit will do (used to get access to import statements).\n\t * @param typeNode A type reference to check.\n\t */\n\tpublic static boolean typeMatches(String type, JavacNode node, JCTree typeNode) {\n\t\tString typeName = getTypeName(typeNode);\n\t\treturn typeMatches(type, node, typeName);\n\t}\n\n\tprivate static boolean typeMatches(String type, JavacNode node, String typeName) {\n\t\tif (typeName == null || typeName.length() == 0) return false;\n\t\tint lastIndexA = typeName.lastIndexOf('.') + 1;\n\t\tint lastIndexB = Math.max(type.lastIndexOf('.'), type.lastIndexOf('$')) + 1;\n\t\tint len = typeName.length() - lastIndexA;\n\t\tif (len != type.length() - lastIndexB) return false;\n\t\tfor (int i = 0; i < len; i++) if (typeName.charAt(i + lastIndexA) != type.charAt(i + lastIndexB)) return false;\n\t\tTypeResolver resolver = node.getImportListAsTypeResolver();\n\t\treturn resolver.typeMatches(node, type, typeName);\n\t}\n\n\tprivate static String getTypeName(JCTree typeNode) {\n\t\treturn typeNode == null ? null : typeNode.toString();\n\t}\n\n\t/**\n\t * Returns if a field is marked deprecated, either by {@code @Deprecated} or in javadoc\n\t * @param field the field to check\n\t * @return {@code true} if a field is marked deprecated, either by {@code @Deprecated} or in javadoc, otherwise {@code false}\n\t */\n\tpublic static boolean isFieldDeprecated(JavacNode field) {\n\t\tif (!(field.get() instanceof JCVariableDecl)) return false;\n\t\tJCVariableDecl fieldNode = (JCVariableDecl) field.get();\n\t\tif ((fieldNode.mods.flags & Flags.DEPRECATED) != 0) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (JavacNode child : field.down()) {\n\t\t\tif (annotationTypeMatches(Deprecated.class, child)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic static CheckerFrameworkVersion getCheckerFrameworkVersion(JavacNode node) {\n\t\tCheckerFrameworkVersion cfv = node.getAst().readConfiguration(ConfigurationKeys.CHECKER_FRAMEWORK);\n\t\treturn cfv == null ? CheckerFrameworkVersion.NONE : cfv;\n\t}\n\t\n\t/**\n\t * Returns if a node is marked deprecated (as picked up on by the parser).\n\t * @param node the node to check (type, method, or field decl).\n\t */\n\tpublic static boolean nodeHasDeprecatedFlag(JCTree node) {\n\t\tif (node instanceof JCVariableDecl) return (((JCVariableDecl) node).mods.flags & Flags.DEPRECATED) != 0;\n\t\tif (node instanceof JCMethodDecl) return (((JCMethodDecl) node).mods.flags & Flags.DEPRECATED) != 0;\n\t\tif (node instanceof JCClassDecl) return (((JCClassDecl) node).mods.flags & Flags.DEPRECATED) != 0;\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Creates an instance of {@code AnnotationValues} for the provided AST Node.\n\t * \n\t * @param type An annotation class type, such as {@code lombok.Getter.class}.\n\t * @param node A Lombok AST node representing an annotation in source code.\n\t */\n\tpublic static <A extends Annotation> AnnotationValues<A> createAnnotation(Class<A> type, final JavacNode node) {\n\t\treturn createAnnotation(type, (JCAnnotation) node.get(), node);\n\t}\n\t\n\t/**\n\t * Creates an instance of {@code AnnotationValues} for the provided AST Node\n\t * and Annotation expression.\n\t *\n\t * @param type An annotation class type, such as {@code lombok.Getter.class}.\n\t * @param anno the annotation expression\n\t * @param node A Lombok AST node representing an annotation in source code.\n\t */\n\tpublic static <A extends Annotation> AnnotationValues<A> createAnnotation(Class<A> type, JCAnnotation anno, final JavacNode node) {\n\t\tMap<String, AnnotationValue> values = new HashMap<String, AnnotationValue>();\n\t\tList<JCExpression> arguments = anno.getArguments();\n\t\t\n\t\tfor (JCExpression arg : arguments) {\n\t\t\tString mName;\n\t\t\tJCExpression rhs;\n\t\t\tjava.util.List<String> raws = new ArrayList<String>();\n\t\t\tjava.util.List<Object> guesses = new ArrayList<Object>();\n\t\t\tjava.util.List<Object> expressions = new ArrayList<Object>();\n\t\t\tfinal java.util.List<DiagnosticPosition> positions = new ArrayList<DiagnosticPosition>();\n\t\t\t\n\t\t\tif (arg instanceof JCAssign) {\n\t\t\t\tJCAssign assign = (JCAssign) arg;\n\t\t\t\tmName = assign.lhs.toString();\n\t\t\t\trhs = assign.rhs;\n\t\t\t} else {\n\t\t\t\trhs = arg;\n\t\t\t\tmName = \"value\";\n\t\t\t}\n\t\t\t\n\t\t\tif (rhs instanceof JCNewArray) {\n\t\t\t\tList<JCExpression> elems = ((JCNewArray) rhs).elems;\n\t\t\t\tfor (JCExpression inner : elems) {\n\t\t\t\t\traws.add(inner.toString());\n\t\t\t\t\texpressions.add(inner);\n\t\t\t\t\tif (inner instanceof JCAnnotation) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\t\t\t\tClass<A> innerClass = (Class<A>) Class.forName(inner.type.toString());\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tguesses.add(createAnnotation(innerClass, (JCAnnotation) inner, node));\n\t\t\t\t\t\t} catch (ClassNotFoundException ex) {\n\t\t\t\t\t\t\tguesses.add(calculateGuess(inner));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tguesses.add(calculateGuess(inner));\n\t\t\t\t\t}\n\t\t\t\t\tpositions.add(inner.pos());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\traws.add(rhs.toString());\n\t\t\t\texpressions.add(rhs);\n\t\t\t\tif (rhs instanceof JCAnnotation) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\t\t\tClass<A> innerClass = (Class<A>) Class.forName(rhs.type.toString());\n\t\t\t\t\t\t\n\t\t\t\t\t\tguesses.add(createAnnotation(innerClass, (JCAnnotation) rhs, node));\n\t\t\t\t\t} catch (ClassNotFoundException ex) {\n\t\t\t\t\t\tguesses.add(calculateGuess(rhs));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tguesses.add(calculateGuess(rhs));\n\t\t\t\t}\n\t\t\t\tpositions.add(rhs.pos());\n\t\t\t}\n\t\t\t\n\t\t\tvalues.put(mName, new AnnotationValue(node, raws, expressions, guesses, true) {\n\t\t\t\t@Override public void setError(String message, int valueIdx) {\n\t\t\t\t\tif (valueIdx < 0) node.addError(message);\n\t\t\t\t\telse node.addError(message, positions.get(valueIdx));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t@Override public void setWarning(String message, int valueIdx) {\n\t\t\t\t\tif (valueIdx < 0) node.addWarning(message);\n\t\t\t\t\telse node.addWarning(message, positions.get(valueIdx));\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\t\n\t\tfor (Method m : type.getDeclaredMethods()) {\n\t\t\tif (!Modifier.isPublic(m.getModifiers())) continue;\n\t\t\tString name = m.getName();\n\t\t\tif (!values.containsKey(name)) {\n\t\t\t\tvalues.put(name, new AnnotationValue(node, new ArrayList<String>(), new ArrayList<Object>(), new ArrayList<Object>(), false) {\n\t\t\t\t\t@Override public void setError(String message, int valueIdx) {\n\t\t\t\t\t\tnode.addError(message);\n\t\t\t\t\t}\n\t\t\t\t\t@Override public void setWarning(String message, int valueIdx) {\n\t\t\t\t\t\tnode.addWarning(message);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn new AnnotationValues<A>(type, values, node);\n\t}\n\t\n\t/**\n\t * Removes the annotation from javac's AST (it remains in lombok's AST),\n\t * then removes any import statement that imports this exact annotation (not star imports).\n\t * Only does this if the DeleteLombokAnnotations class is in the context.\n\t */\n\tpublic static void deleteAnnotationIfNeccessary(JavacNode annotation, String annotationType) {\n\t\tdeleteAnnotationIfNeccessary0(annotation, annotationType);\n\t}\n\t\n\t/**\n\t * Removes the annotation from javac's AST (it remains in lombok's AST),\n\t * then removes any import statement that imports this exact annotation (not star imports).\n\t * Only does this if the DeleteLombokAnnotations class is in the context.\n\t */\n\tpublic static void deleteAnnotationIfNeccessary(JavacNode annotation, Class<? extends Annotation> annotationType) {\n\t\tdeleteAnnotationIfNeccessary0(annotation, annotationType.getName());\n\t}\n\t\n\t/**\n\t * Removes the annotation from javac's AST (it remains in lombok's AST),\n\t * then removes any import statement that imports this exact annotation (not star imports).\n\t * Only does this if the DeleteLombokAnnotations class is in the context.\n\t */\n\tpublic static void deleteAnnotationIfNeccessary(JavacNode annotation, Class<? extends Annotation> annotationType1, Class<? extends Annotation> annotationType2) {\n\t\tdeleteAnnotationIfNeccessary0(annotation, annotationType1.getName(), annotationType2.getName());\n\t}\n\t\n\t/**\n\t * Removes the annotation from javac's AST (it remains in lombok's AST),\n\t * then removes any import statement that imports this exact annotation (not star imports).\n\t * Only does this if the DeleteLombokAnnotations class is in the context.\n\t */\n\tpublic static void deleteAnnotationIfNeccessary(JavacNode annotation, Class<? extends Annotation> annotationType1, String annotationType2) {\n\t\tdeleteAnnotationIfNeccessary0(annotation, annotationType1.getName(), annotationType2);\n\t}\n\t\n\tprivate static void deleteAnnotationIfNeccessary0(JavacNode annotation, String... annotationTypes) {\n\t\tif (inNetbeansEditor(annotation)) return;\n\t\tif (!annotation.shouldDeleteLombokAnnotations()) return;\n\t\tJavacNode parentNode = annotation.directUp();\n\t\tswitch (parentNode.getKind()) {\n\t\tcase FIELD:\n\t\tcase ARGUMENT:\n\t\tcase LOCAL:\n\t\t\tJCVariableDecl variable = (JCVariableDecl) parentNode.get();\n\t\t\tvariable.mods.annotations = filterList(variable.mods.annotations, annotation.get());\n\t\t\tbreak;\n\t\tcase METHOD:\n\t\t\tJCMethodDecl method = (JCMethodDecl) parentNode.get();\n\t\t\tmethod.mods.annotations = filterList(method.mods.annotations, annotation.get());\n\t\t\tbreak;\n\t\tcase TYPE:\n\t\t\ttry {\n\t\t\t\tJCClassDecl type = (JCClassDecl) parentNode.get();\n\t\t\t\ttype.mods.annotations = filterList(type.mods.annotations, annotation.get());\n\t\t\t} catch (ClassCastException e) {\n\t\t\t\t//something rather odd has been annotated. Better to just break only delombok instead of everything.\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t//This really shouldn't happen, but if it does, better just break delombok instead of breaking everything.\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tparentNode.getAst().setChanged();\n\t\tfor (String annotationType : annotationTypes) {\n\t\t\tdeleteImportFromCompilationUnit(annotation, annotationType);\n\t\t}\n\t}\n\t\n\tpublic static void deleteImportFromCompilationUnit(JavacNode node, String name) {\n\t\tif (inNetbeansEditor(node)) return;\n\t\tif (!node.shouldDeleteLombokAnnotations()) return;\n\t\t\n\t\tJCCompilationUnit unit = (JCCompilationUnit) node.top().get();\n\t\t\n\t\tfor (JCTree def : unit.defs) {\n\t\t\tif (!(def instanceof JCImport)) continue;\n\t\t\tJCImport imp0rt = (JCImport) def;\n\t\t\tif (imp0rt.staticImport) continue;\n\t\t\tif (!imp0rt.qualid.toString().equals(name)) continue;\n\t\t\tJavacAugments.JCImport_deletable.set(imp0rt, true);\n\t\t}\n\t}\n\t\n\tprivate static List<JCAnnotation> filterList(List<JCAnnotation> annotations, JCTree jcTree) {\n\t\tListBuffer<JCAnnotation> newAnnotations = new ListBuffer<JCAnnotation>();\n\t\tfor (JCAnnotation ann : annotations) {\n\t\t\tif (jcTree != ann) newAnnotations.append(ann);\n\t\t}\n\t\treturn newAnnotations.toList();\n\t}\n\t\n\t/** Serves as return value for the methods that check for the existence of fields and methods. */\n\tpublic enum MemberExistsResult {\n\t\tNOT_EXISTS, EXISTS_BY_LOMBOK, EXISTS_BY_USER;\n\t}\n\t\n\t/**\n\t * Translates the given field into all possible getter names.\n\t * Convenient wrapper around {@link HandlerUtil#toAllGetterNames(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static java.util.List<String> toAllGetterNames(JavacNode field) {\n\t\treturn HandlerUtil.toAllGetterNames(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * Translates the given field into all possible getter names.\n\t * Convenient wrapper around {@link HandlerUtil#toAllGetterNames(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static java.util.List<String> toAllGetterNames(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\treturn HandlerUtil.toAllGetterNames(field.getAst(), accessors, field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * @return the likely getter name for the stated field. (e.g. private boolean foo; to isFoo).\n\t * \n\t * Convenient wrapper around {@link HandlerUtil#toGetterName(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static String toGetterName(JavacNode field) {\n\t\treturn HandlerUtil.toGetterName(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * @return the likely getter name for the stated field. (e.g. private boolean foo; to isFoo).\n\t * \n\t * Convenient wrapper around {@link HandlerUtil#toGetterName(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static String toGetterName(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\treturn HandlerUtil.toGetterName(field.getAst(), accessors, field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * Translates the given field into all possible setter names.\n\t * Convenient wrapper around {@link HandlerUtil#toAllSetterNames(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static java.util.List<String> toAllSetterNames(JavacNode field) {\n\t\treturn HandlerUtil.toAllSetterNames(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * Translates the given field into all possible setter names.\n\t * Convenient wrapper around {@link HandlerUtil#toAllSetterNames(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static java.util.List<String> toAllSetterNames(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\treturn HandlerUtil.toAllSetterNames(field.getAst(), accessors, field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * @return the likely setter name for the stated field. (e.g. private boolean foo; to setFoo).\n\t * \n\t * Convenient wrapper around {@link HandlerUtil#toSetterName(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static String toSetterName(JavacNode field) {\n\t\treturn HandlerUtil.toSetterName(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * @return the likely setter name for the stated field. (e.g. private boolean foo; to setFoo).\n\t * \n\t * Convenient wrapper around {@link HandlerUtil#toSetterName(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static String toSetterName(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\treturn HandlerUtil.toSetterName(field.getAst(), accessors, field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * Translates the given field into all possible with names.\n\t * Convenient wrapper around {@link HandlerUtil#toAllWithNames(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static java.util.List<String> toAllWithNames(JavacNode field) {\n\t\treturn HandlerUtil.toAllWithNames(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * Translates the given field into all possible with names.\n\t * Convenient wrapper around {@link HandlerUtil#toAllWithNames(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static java.util.List<String> toAllWithNames(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\treturn HandlerUtil.toAllWithNames(field.getAst(), accessors, field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * Translates the given field into all possible withBy names.\n\t * Convenient wrapper around {@link HandlerUtil#toAllWithByNames(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static java.util.List<String> toAllWithByNames(JavacNode field) {\n\t\treturn HandlerUtil.toAllWithByNames(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * Translates the given field into all possible withBy names.\n\t * Convenient wrapper around {@link HandlerUtil#toAllWithByNames(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static java.util.List<String> toAllWithByNames(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\treturn HandlerUtil.toAllWithByNames(field.getAst(), accessors, field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * @return the likely with name for the stated field. (e.g. private boolean foo; to withFoo).\n\t * \n\t * Convenient wrapper around {@link HandlerUtil#toWithName(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static String toWithName(JavacNode field) {\n\t\treturn HandlerUtil.toWithName(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * @return the likely with name for the stated field. (e.g. private boolean foo; to withFoo).\n\t * \n\t * Convenient wrapper around {@link HandlerUtil#toWithName(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static String toWithName(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\treturn HandlerUtil.toWithName(field.getAst(), accessors, field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * @return the likely withBy name for the stated field. (e.g. private boolean foo; to withFooBy).\n\t * \n\t * Convenient wrapper around {@link HandlerUtil#toWithByName(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static String toWithByName(JavacNode field) {\n\t\treturn HandlerUtil.toWithByName(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * @return the likely withBy name for the stated field. (e.g. private boolean foo; to withFooBy).\n\t * \n\t * Convenient wrapper around {@link HandlerUtil#toWithByName(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static String toWithByName(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\treturn HandlerUtil.toWithByName(field.getAst(), accessors, field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * When generating a setter, the setter either returns void (beanspec) or Self (fluent).\n\t * This method scans for the {@code Accessors} annotation to figure that out.\n\t */\n\tpublic static boolean shouldReturnThis(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\tif ((((JCVariableDecl) field.get()).mods.flags & Flags.STATIC) != 0) return false;\n\t\t\n\t\treturn HandlerUtil.shouldReturnThis0(accessors, field.getAst());\n\t}\n\t\n\t/**\n\t * When generating a setter/getter/wither, should it be made final?\n\t */\n\tpublic static boolean shouldMakeFinal(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\tif ((((JCVariableDecl) field.get()).mods.flags & Flags.STATIC) != 0) return false;\n\t\t\n\t\treturn HandlerUtil.shouldMakeFinal0(accessors, field.getAst());\n\t}\n\t\n\tpublic static JCExpression cloneSelfType(JavacNode childOfType) {\n\t\tJavacNode typeNode = childOfType;\n\t\tJavacTreeMaker maker = childOfType.getTreeMaker();\n\t\twhile (typeNode != null && typeNode.getKind() != Kind.TYPE) typeNode = typeNode.up();\n\t\treturn JavacHandlerUtil.namePlusTypeParamsToTypeReference(maker, typeNode, ((JCClassDecl) typeNode.get()).typarams);\n\t}\n\t\n\tpublic static boolean isBoolean(JavacNode field) {\n\t\tJCExpression varType = ((JCVariableDecl) field.get()).vartype;\n\t\treturn isBoolean(varType);\n\t}\n\t\n\tpublic static boolean isBoolean(JCExpression varType) {\n\t\treturn varType != null && varType.toString().equals(\"boolean\");\n\t}\n\t\n\tpublic static Name removePrefixFromField(JavacNode field) {\n\t\tjava.util.List<String> prefixes = null;\n\t\tfor (JavacNode node : field.down()) {\n\t\t\tif (annotationTypeMatches(Accessors.class, node)) {\n\t\t\t\tAnnotationValues<Accessors> ann = createAnnotation(Accessors.class, node);\n\t\t\t\tif (ann.isExplicit(\"prefix\")) prefixes = Arrays.asList(ann.getInstance().prefix());\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (prefixes == null) {\n\t\t\tJavacNode current = field.up();\n\t\t\touter:\n\t\t\twhile (current != null) {\n\t\t\t\tfor (JavacNode node : current.down()) {\n\t\t\t\t\tif (annotationTypeMatches(Accessors.class, node)) {\n\t\t\t\t\t\tAnnotationValues<Accessors> ann = createAnnotation(Accessors.class, node);\n\t\t\t\t\t\tif (ann.isExplicit(\"prefix\")) prefixes = Arrays.asList(ann.getInstance().prefix());\n\t\t\t\t\t\tbreak outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcurrent = current.up();\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (prefixes == null) prefixes = field.getAst().readConfiguration(ConfigurationKeys.ACCESSORS_PREFIX);\n\t\t\n\t\tif (!prefixes.isEmpty()) {\n\t\t\tCharSequence newName = removePrefix(field.getName(), prefixes);\n\t\t\tif (newName != null) return field.toName(newName.toString());\n\t\t}\n\t\t\n\t\treturn ((JCVariableDecl) field.get()).name;\n\t}\n\t\n\tpublic static AnnotationValues<Accessors> getAccessorsForField(JavacNode field) {\n\t\tAnnotationValues<Accessors> values = null;\n\t\t\n\t\tfor (JavacNode node : field.down()) {\n\t\t\tif (annotationTypeMatches(Accessors.class, node)) {\n\t\t\t\tvalues = createAnnotation(Accessors.class, node);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tJavacNode current = field.up();\n\t\twhile (current != null) {\n\t\t\tfor (JavacNode node : current.down()) {\n\t\t\t\tif (annotationTypeMatches(Accessors.class, node)) {\n\t\t\t\t\tAnnotationValues<Accessors> onType = createAnnotation(Accessors.class, node);\n\t\t\t\t\tvalues = values == null ? onType : values.integrate(onType);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurrent = current.up();\n\t\t}\n\t\t\n\t\treturn values == null ? AnnotationValues.of(Accessors.class, field) : values;\n\t}\n\t\n\t/**\n\t * Checks if there is a field with the provided name.\n\t * \n\t * @param fieldName the field name to check for.\n\t * @param node Any node that represents the Type (JCClassDecl) to look in, or any child node thereof.\n\t */\n\tpublic static MemberExistsResult fieldExists(String fieldName, JavacNode node) {\n\t\tnode = upToTypeNode(node);\n\t\t\n\t\tif (node != null && node.get() instanceof JCClassDecl) {\n\t\t\tfor (JCTree def : ((JCClassDecl)node.get()).defs) {\n\t\t\t\tif (def instanceof JCVariableDecl) {\n\t\t\t\t\tif (((JCVariableDecl)def).name.contentEquals(fieldName)) {\n\t\t\t\t\t\treturn getGeneratedBy(def) == null ? MemberExistsResult.EXISTS_BY_USER : MemberExistsResult.EXISTS_BY_LOMBOK;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn MemberExistsResult.NOT_EXISTS;\n\t}\n\t\n\tpublic static MemberExistsResult methodExists(String methodName, JavacNode node, int params) {\n\t\treturn methodExists(methodName, node, true, params);\n\t}\n\t\n\t/**\n\t * Checks if there is a method with the provided name. In case of multiple methods (overloading), only\n\t * the first method decides if EXISTS_BY_USER or EXISTS_BY_LOMBOK is returned.\n\t * \n\t * @param methodName the method name to check for.\n\t * @param node Any node that represents the Type (JCClassDecl) to look in, or any child node thereof.\n\t * @param caseSensitive If the search should be case sensitive.\n\t * @param params The number of parameters the method should have; varargs count as 0-*. Set to -1 to find any method with the appropriate name regardless of parameter count.\n\t */\n\tpublic static MemberExistsResult methodExists(String methodName, JavacNode node, boolean caseSensitive, int params) {\n\t\tnode = upToTypeNode(node);\n\t\t\n\t\tif (node != null && node.get() instanceof JCClassDecl) {\n\t\t\ttop: for (JCTree def : ((JCClassDecl)node.get()).defs) {\n\t\t\t\tif (def instanceof JCMethodDecl) {\n\t\t\t\t\tJCMethodDecl md = (JCMethodDecl) def;\n\t\t\t\t\tString name = md.name.toString();\n\t\t\t\t\tboolean matches = caseSensitive ? name.equals(methodName) : name.equalsIgnoreCase(methodName);\n\t\t\t\t\tif (matches) {\n\t\t\t\t\t\tif (params > -1) {\n\t\t\t\t\t\t\tList<JCVariableDecl> ps = md.params;\n\t\t\t\t\t\t\tint minArgs = 0;\n\t\t\t\t\t\t\tint maxArgs = 0;\n\t\t\t\t\t\t\tif (ps != null && ps.length() > 0) {\n\t\t\t\t\t\t\t\tminArgs = ps.length();\n\t\t\t\t\t\t\t\tif ((ps.last().mods.flags & Flags.VARARGS) != 0) {\n\t\t\t\t\t\t\t\t\tmaxArgs = Integer.MAX_VALUE;\n\t\t\t\t\t\t\t\t\tminArgs--;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tmaxArgs = minArgs;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (params < minArgs || params > maxArgs) continue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (isTolerate(node, md)) continue top;\n\t\t\t\t\t\t\n\t\t\t\t\t\treturn getGeneratedBy(def) == null ? MemberExistsResult.EXISTS_BY_USER : MemberExistsResult.EXISTS_BY_LOMBOK;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn MemberExistsResult.NOT_EXISTS;\n\t}\n\t\n\tpublic static boolean isTolerate(JavacNode node, JCTree.JCMethodDecl md) {\n\t\tList<JCAnnotation> annotations = md.getModifiers().getAnnotations();\n\t\tif (annotations != null) for (JCTree.JCAnnotation anno : annotations) {\n\t\t\tif (typeMatches(Tolerate.class, node, anno.getAnnotationType())) return true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Checks if there is a (non-default) constructor. In case of multiple constructors (overloading), only\n\t * the first constructor decides if EXISTS_BY_USER or EXISTS_BY_LOMBOK is returned.\n\t * \n\t * @param node Any node that represents the Type (JCClassDecl) to look in, or any child node thereof.\n\t */\n\tpublic static MemberExistsResult constructorExists(JavacNode node) {\n\t\tnode = upToTypeNode(node);\n\t\t\n\t\tif (node != null && node.get() instanceof JCClassDecl) {\n\t\t\tfor (JCTree def : ((JCClassDecl) node.get()).defs) {\n\t\t\t\tif (def instanceof JCMethodDecl) {\n\t\t\t\t\tJCMethodDecl md = (JCMethodDecl) def;\n\t\t\t\t\tif (md.name.contentEquals(\"<init>\")) {\n\t\t\t\t\t\tif ((md.mods.flags & Flags.GENERATEDCONSTR) != 0) continue;\n\t\t\t\t\t\tif (isTolerate(node, md)) continue;\n\t\t\t\t\t\treturn getGeneratedBy(def) == null ? MemberExistsResult.EXISTS_BY_USER : MemberExistsResult.EXISTS_BY_LOMBOK;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn MemberExistsResult.NOT_EXISTS;\n\t}\n\t\n\tpublic static boolean isConstructorCall(final JCStatement statement) {\n\t\tif (!(statement instanceof JCExpressionStatement)) return false;\n\t\tJCExpression expr = ((JCExpressionStatement) statement).expr;\n\t\tif (!(expr instanceof JCMethodInvocation)) return false;\n\t\tJCExpression invocation = ((JCMethodInvocation) expr).meth;\n\t\tString name;\n\t\tif (invocation instanceof JCFieldAccess) {\n\t\t\tname = ((JCFieldAccess) invocation).name.toString();\n\t\t} else if (invocation instanceof JCIdent) {\n\t\t\tname = ((JCIdent) invocation).name.toString();\n\t\t} else {\n\t\t\tname = \"\";\n\t\t}\n\t\t\n\t\treturn \"super\".equals(name) || \"this\".equals(name);\n\t}\n\t\n\t/**\n\t * Turns an {@code AccessLevel} instance into the flag bit used by javac.\n\t */\n\tpublic static int toJavacModifier(AccessLevel accessLevel) {\n\t\tswitch (accessLevel) {\n\t\tcase MODULE:\n\t\tcase PACKAGE:\n\t\t\treturn 0;\n\t\tdefault:\n\t\tcase PUBLIC:\n\t\t\treturn Flags.PUBLIC;\n\t\tcase NONE:\n\t\tcase PRIVATE:\n\t\t\treturn Flags.PRIVATE;\n\t\tcase PROTECTED:\n\t\t\treturn Flags.PROTECTED;\n\t\t}\n\t}\n\t\n\tprivate static class GetterMethod {\n\t\tprivate final Name name;\n\t\tprivate final JCExpression type;\n\t\t\n\t\tGetterMethod(Name name, JCExpression type) {\n\t\t\tthis.name = name;\n\t\t\tthis.type = type;\n\t\t}\n\t}\n\t\n\tprivate static GetterMethod findGetter(JavacNode field) {\n\t\tJCVariableDecl decl = (JCVariableDecl)field.get();\n\t\tJavacNode typeNode = field.up();\n\t\tfor (String potentialGetterName : toAllGetterNames(field)) {\n\t\t\tfor (JavacNode potentialGetter : typeNode.down()) {\n\t\t\t\tif (potentialGetter.getKind() != Kind.METHOD) continue;\n\t\t\t\tJCMethodDecl method = (JCMethodDecl) potentialGetter.get();\n\t\t\t\tif (!method.name.toString().equalsIgnoreCase(potentialGetterName)) continue;\n\t\t\t\t/** static getX() methods don't count. */\n\t\t\t\tif ((method.mods.flags & Flags.STATIC) != 0) continue;\n\t\t\t\t/** Nor do getters with a non-empty parameter list. */\n\t\t\t\tif (method.params != null && method.params.size() > 0) continue;\n\t\t\t\treturn new GetterMethod(method.name, method.restype);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Check if the field has a @Getter annotation.\n\t\t\n\t\tboolean hasGetterAnnotation = false;\n\t\t\n\t\tfor (JavacNode child : field.down()) {\n\t\t\tif (child.getKind() == Kind.ANNOTATION && annotationTypeMatches(Getter.class, child)) {\n\t\t\t\tAnnotationValues<Getter> ann = createAnnotation(Getter.class, child);\n\t\t\t\tif (ann.getInstance().value() == AccessLevel.NONE) return null;   //Definitely WONT have a getter.\n\t\t\t\thasGetterAnnotation = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Check if the class has a @Getter annotation.\n\t\t\n\t\tif (!hasGetterAnnotation && HandleGetter.fieldQualifiesForGetterGeneration(field)) {\n\t\t\t//Check if the class has @Getter or @Data annotation.\n\t\t\t\n\t\t\tJavacNode containingType = field.up();\n\t\t\tif (containingType != null) for (JavacNode child : containingType.down()) {\n\t\t\t\tif (child.getKind() == Kind.ANNOTATION && annotationTypeMatches(Data.class, child)) hasGetterAnnotation = true;\n\t\t\t\tif (child.getKind() == Kind.ANNOTATION && annotationTypeMatches(Getter.class, child)) {\n\t\t\t\t\tAnnotationValues<Getter> ann = createAnnotation(Getter.class, child);\n\t\t\t\t\tif (ann.getInstance().value() == AccessLevel.NONE) return null;   //Definitely WONT have a getter.\n\t\t\t\t\thasGetterAnnotation = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (hasGetterAnnotation) {\n\t\t\tString getterName = toGetterName(field);\n\t\t\tif (getterName == null) return null;\n\t\t\treturn new GetterMethod(field.toName(getterName), decl.vartype);\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\t\n\tstatic boolean lookForGetter(JavacNode field, FieldAccess fieldAccess) {\n\t\tif (fieldAccess == FieldAccess.GETTER) return true;\n\t\tif (fieldAccess == FieldAccess.ALWAYS_FIELD) return false;\n\t\t\n\t\t// If @Getter(lazy = true) is used, then using it is mandatory.\n\t\tfor (JavacNode child : field.down()) {\n\t\t\tif (child.getKind() != Kind.ANNOTATION) continue;\n\t\t\tif (annotationTypeMatches(Getter.class, child)) {\n\t\t\t\tAnnotationValues<Getter> ann = createAnnotation(Getter.class, child);\n\t\t\t\tif (ann.getInstance().lazy()) return true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Returns the type of the field, unless a getter exists for this field, in which case the return type of the getter is returned.\n\t * \n\t * @see #createFieldAccessor(TreeMaker, JavacNode, FieldAccess)\n\t */\n\tstatic JCExpression getFieldType(JavacNode field, FieldAccess fieldAccess) {\n\t\tif (field.getKind() == Kind.METHOD) return ((JCMethodDecl) field.get()).restype;\n\t\t\n\t\tboolean lookForGetter = lookForGetter(field, fieldAccess);\n\t\t\n\t\tGetterMethod getter = lookForGetter ? findGetter(field) : null;\n\t\t\n\t\tif (getter == null) {\n\t\t\treturn ((JCVariableDecl) field.get()).vartype;\n\t\t}\n\t\t\n\t\treturn getter.type;\n\t}\n\t\n\t/**\n\t * Creates an expression that reads the field. Will either be {@code this.field} or {@code this.getField()} depending on whether or not there's a getter.\n\t */\n\tstatic JCExpression createFieldAccessor(JavacTreeMaker maker, JavacNode field, FieldAccess fieldAccess) {\n\t\treturn createFieldAccessor(maker, field, fieldAccess, null);\n\t}\n\t\n\tstatic JCExpression createFieldAccessor(JavacTreeMaker maker, JavacNode field, FieldAccess fieldAccess, JCExpression receiver) {\n\t\tboolean lookForGetter = lookForGetter(field, fieldAccess);\n\t\t\n\t\tGetterMethod getter = lookForGetter ? findGetter(field) : null;\n\t\tJCVariableDecl fieldDecl = (JCVariableDecl) field.get();\n\t\t\n\t\tif (getter == null) {\n\t\t\tif (receiver == null) {\n\t\t\t\tif ((fieldDecl.mods.flags & Flags.STATIC) == 0) {\n\t\t\t\t\treceiver = maker.Ident(field.toName(\"this\"));\n\t\t\t\t} else {\n\t\t\t\t\tJavacNode containerNode = field.up();\n\t\t\t\t\tif (containerNode != null && containerNode.get() instanceof JCClassDecl) {\n\t\t\t\t\t\tJCClassDecl container = (JCClassDecl) field.up().get();\n\t\t\t\t\t\treceiver = maker.Ident(container.name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn receiver == null ? maker.Ident(fieldDecl.name) : maker.Select(receiver, fieldDecl.name);\n\t\t}\n\t\t\n\t\tif (receiver == null) receiver = maker.Ident(field.toName(\"this\"));\n\t\tJCMethodInvocation call = maker.Apply(List.<JCExpression>nil(),\n\t\t\tmaker.Select(receiver, getter.name), List.<JCExpression>nil());\n\t\treturn call;\n\t}\n\t\n\tstatic JCExpression createMethodAccessor(JavacTreeMaker maker, JavacNode method) {\n\t\treturn createMethodAccessor(maker, method, null);\n\t}\n\t\n\tstatic JCExpression createMethodAccessor(JavacTreeMaker maker, JavacNode method, JCExpression receiver) {\n\t\tJCMethodDecl methodDecl = (JCMethodDecl) method.get();\n\t\t\n\t\tif (receiver == null && (methodDecl.mods.flags & Flags.STATIC) == 0) {\n\t\t\treceiver = maker.Ident(method.toName(\"this\"));\n\t\t} else if (receiver == null) {\n\t\t\tJavacNode containerNode = method.up();\n\t\t\tif (containerNode != null && containerNode.get() instanceof JCClassDecl) {\n\t\t\t\tJCClassDecl container = (JCClassDecl) method.up().get();\n\t\t\t\treceiver = maker.Ident(container.name);\n\t\t\t}\n\t\t}\n\t\t\n\t\tJCMethodInvocation call = maker.Apply(List.<JCExpression>nil(),\n\t\t\treceiver == null ? maker.Ident(methodDecl.name) : maker.Select(receiver, methodDecl.name), List.<JCExpression>nil());\n\t\treturn call;\n\t}\n\t\n\t/**\n\t * Adds the given new field declaration to the provided type AST Node.\n\t * The field carries the &#64;{@link SuppressWarnings}(\"all\") annotation.\n\t * Also takes care of updating the JavacAST.\n\t */\n\tpublic static JavacNode injectFieldAndMarkGenerated(JavacNode typeNode, JCVariableDecl field) {\n\t\treturn injectField(typeNode, field, true);\n\t}\n\t\n\t/**\n\t * Adds the given new field declaration to the provided type AST Node.\n\t * \n\t * Also takes care of updating the JavacAST.\n\t */\n\tpublic static JavacNode injectField(JavacNode typeNode, JCVariableDecl field) {\n\t\treturn injectField(typeNode, field, false);\n\t}\n\t\n\tpublic static JavacNode injectField(JavacNode typeNode, JCVariableDecl field, boolean addGenerated) {\n\t\treturn injectField(typeNode, field, addGenerated, false);\n\t}\n\t\n\tpublic static JavacNode injectField(JavacNode typeNode, JCVariableDecl field, boolean addGenerated, boolean specialEnumHandling) {\n\t\tJCClassDecl type = (JCClassDecl) typeNode.get();\n\t\t\n\t\tif (addGenerated) {\n\t\t\taddSuppressWarningsAll(field.mods, typeNode, typeNode.getNodeFor(getGeneratedBy(field)), typeNode.getContext());\n\t\t\taddGenerated(field.mods, typeNode, typeNode.getNodeFor(getGeneratedBy(field)), typeNode.getContext());\n\t\t}\n\t\t\n\t\tList<JCTree> insertAfter = null;\n\t\tList<JCTree> insertBefore = type.defs;\n\t\twhile (true) {\n\t\t\tboolean skip = false;\n\t\t\tif (insertBefore.head instanceof JCVariableDecl) {\n\t\t\t\tJCVariableDecl f = (JCVariableDecl) insertBefore.head;\n\t\t\t\tif ((!specialEnumHandling && isEnumConstant(f)) || isGenerated(f)) skip = true;\n\t\t\t} else if (insertBefore.head instanceof JCMethodDecl) {\n\t\t\t\tif ((((JCMethodDecl) insertBefore.head).mods.flags & GENERATEDCONSTR) != 0) skip = true;\n\t\t\t}\n\t\t\tif (skip) {\n\t\t\t\tinsertAfter = insertBefore;\n\t\t\t\tinsertBefore = insertBefore.tail;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tList<JCTree> fieldEntry = List.<JCTree>of(field);\n\t\tfieldEntry.tail = insertBefore;\n\t\tif (insertAfter == null) {\n\t\t\ttype.defs = fieldEntry;\n\t\t} else {\n\t\t\tinsertAfter.tail = fieldEntry;\n\t\t}\n\t\t\n\t\tEnterReflect.memberEnter(field, typeNode);\n\t\t\n\t\treturn typeNode.add(field, Kind.FIELD);\n\t}\n\t\n\tpublic static boolean isEnumConstant(final JCVariableDecl field) {\n\t\treturn (field.mods.flags & Flags.ENUM) != 0;\n\t}\n\t\n\tstatic class JCAnnotatedTypeReflect {\n\t\tprivate static Class<?> TYPE;\n\t\tprivate static Constructor<?> CONSTRUCTOR;\n\t\tprivate static Field ANNOTATIONS, UNDERLYING_TYPE;\n\t\t\n\t\tprivate static void initByLoader(ClassLoader classLoader) {\n\t\t\tif (TYPE != null) return;\n\t\t\tClass<?> c;\n\t\t\ttry {\n\t\t\t\tc = classLoader.loadClass(\"com.sun.tools.javac.tree.JCTree$JCAnnotatedType\");\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tinit(c);\n\t\t}\n\t\t\n\t\tprivate static void init(Class<?> in) {\n\t\t\tif (TYPE != null) return;\n\t\t\tif (!in.getName().equals(\"com.sun.tools.javac.tree.JCTree$JCAnnotatedType\")) return;\n\t\t\ttry {\n\t\t\t\tCONSTRUCTOR = Permit.getConstructor(in, List.class, JCExpression.class);\n\t\t\t\tANNOTATIONS = Permit.getField(in, \"annotations\");\n\t\t\t\tUNDERLYING_TYPE = Permit.getField(in, \"underlyingType\");\n\t\t\t\tTYPE = in;\n\t\t\t} catch (Exception ignore) {}\n\t\t}\n\t\t\n\t\tstatic boolean is(JCTree obj) {\n\t\t\tif (obj == null) return false;\n\t\t\tinit(obj.getClass());\n\t\t\treturn obj.getClass() == TYPE;\n\t\t}\n\t\t\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tstatic List<JCAnnotation> getAnnotations(JCTree obj) {\n\t\t\tinit(obj.getClass());\n\t\t\ttry {\n\t\t\t\treturn (List<JCAnnotation>) ANNOTATIONS.get(obj);\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn List.nil();\n\t\t\t}\n\t\t}\n\t\t\n\t\tstatic void setAnnotations(JCTree obj, List<JCAnnotation> anns) {\n\t\t\tinit(obj.getClass());\n\t\t\ttry {\n\t\t\t\tANNOTATIONS.set(obj, anns);\n\t\t\t} catch (Exception e) {}\n\t\t}\n\t\t\n\t\tstatic JCExpression getUnderlyingType(JCTree obj) {\n\t\t\tinit(obj.getClass());\n\t\t\ttry {\n\t\t\t\treturn (JCExpression) UNDERLYING_TYPE.get(obj);\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\t\n\t\tstatic JCExpression create(List<JCAnnotation> annotations, JCExpression underlyingType) {\n\t\t\tinitByLoader(underlyingType.getClass().getClassLoader());\n\t\t\ttry {\n\t\t\t\treturn (JCExpression) CONSTRUCTOR.newInstance(annotations, underlyingType);\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn underlyingType;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic class JCAnnotationReflect {\n\t\tprivate static final Field ATTRIBUTE;\n\n\t\tstatic {\n\t\t\tATTRIBUTE = Permit.permissiveGetField(JCAnnotation.class, \"attribute\");\n\t\t}\n\n\t\tstatic Attribute.Compound getAttribute(JCAnnotation jcAnnotation) {\n\t\t\tif (ATTRIBUTE != null) {\n\t\t\t\ttry {\n\t\t\t\t\treturn (Attribute.Compound) ATTRIBUTE.get(jcAnnotation);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t// Ignore\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tstatic void setAttribute(JCAnnotation jcAnnotation, Attribute.Compound attribute) {\n\t\t\tif (ATTRIBUTE != null) {\n\t\t\t\ttry {\n\t\t\t\t\tPermit.set(ATTRIBUTE, jcAnnotation, attribute);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t// Ignore\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// jdk9 support, types have changed, names stay the same\n\tstatic class ClassSymbolMembersField {\n\t\tprivate static final Field membersField;\n\t\tprivate static final Method removeMethod;\n\t\tprivate static final Method enterMethod;\n\t\t\n\t\tstatic {\n\t\t\tField f = null;\n\t\t\tMethod r = null;\n\t\t\tMethod e = null;\n\t\t\ttry {\n\t\t\t\tf = Permit.getField(ClassSymbol.class, \"members_field\");\n\t\t\t\tr = Permit.getMethod(f.getType(), \"remove\", Symbol.class);\n\t\t\t\te = Permit.getMethod(f.getType(), \"enter\", Symbol.class);\n\t\t\t} catch (Exception ex) {}\n\t\t\tmembersField = f;\n\t\t\tremoveMethod = r;\n\t\t\tenterMethod = e;\n\t\t}\n\t\t\n\t\tstatic void remove(ClassSymbol from, Symbol toRemove) {\n\t\t\tif (from == null) return;\n\t\t\ttry {\n\t\t\t\tScope scope = (Scope) membersField.get(from);\n\t\t\t\tif (scope == null) return;\n\t\t\t\tPermit.invoke(removeMethod, scope, toRemove);\n\t\t\t} catch (Exception e) {}\n\t\t}\n\t\t\n\t\tstatic void enter(ClassSymbol from, Symbol toEnter) {\n\t\t\tif (from == null) return;\n\t\t\ttry {\n\t\t\t\tScope scope = (Scope) membersField.get(from);\n\t\t\t\tif (scope == null) return;\n\t\t\t\tPermit.invoke(enterMethod, scope, toEnter);\n\t\t\t} catch (Exception e) {}\n\t\t}\n\t}\n\t\n\t/**\n\t * Adds the given new method declaration to the provided type AST Node.\n\t * Can also inject constructors.\n\t * \n\t * Also takes care of updating the JavacAST.\n\t */\n\tpublic static void injectMethod(JavacNode typeNode, JCMethodDecl method) {\n\t\tJCClassDecl type = (JCClassDecl) typeNode.get();\n\t\t\n\t\tif (method.getName().contentEquals(\"<init>\")) {\n\t\t\t//Scan for default constructor, and remove it.\n\t\t\tint idx = 0;\n\t\t\tfor (JCTree def : type.defs) {\n\t\t\t\tif (def instanceof JCMethodDecl) {\n\t\t\t\t\tif ((((JCMethodDecl) def).mods.flags & Flags.GENERATEDCONSTR) != 0) {\n\t\t\t\t\t\tJavacNode tossMe = typeNode.getNodeFor(def);\n\t\t\t\t\t\tif (tossMe != null) tossMe.up().removeChild(tossMe);\n\t\t\t\t\t\ttype.defs = addAllButOne(type.defs, idx);\n\t\t\t\t\t\tClassSymbolMembersField.remove(type.sym, ((JCMethodDecl) def).sym);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tidx++;\n\t\t\t}\n\t\t}\n\t\t\n\t\taddSuppressWarningsAll(method.mods, typeNode, typeNode.getNodeFor(getGeneratedBy(method)), typeNode.getContext());\n\t\taddGenerated(method.mods, typeNode, typeNode.getNodeFor(getGeneratedBy(method)), typeNode.getContext());\n\t\ttype.defs = type.defs.append(method);\n\t\t\n\t\tEnterReflect.memberEnter(method, typeNode);\n\t\t\n\t\ttypeNode.add(method, Kind.METHOD);\n\t}\n\n\t/**\n\t * Adds an inner type (class, interface, enum) to the given type. Cannot inject top-level types.\n\t * \n\t * @param typeNode parent type to inject new type into\n\t * @param type New type (class, interface, etc) to inject.\n\t * @return \n\t */\n\tpublic static JavacNode injectType(JavacNode typeNode, final JCClassDecl type) {\n\t\tJCClassDecl typeDecl = (JCClassDecl) typeNode.get();\n\t\taddSuppressWarningsAll(type.mods, typeNode, typeNode.getNodeFor(getGeneratedBy(type)), typeNode.getContext());\n\t\taddGenerated(type.mods, typeNode, typeNode.getNodeFor(getGeneratedBy(type)), typeNode.getContext());\n\t\ttypeDecl.defs = typeDecl.defs.append(type);\n\t\t\n\t\tEnterReflect.classEnter(type, typeNode);\n\t\t\n\t\treturn typeNode.add(type, Kind.TYPE);\n\t}\n\t\n\tstatic class EnterReflect {\n\t\tprivate static final Method classEnter;\n\t\tprivate static final Method memberEnter;\n\t\tprivate static final Method blockAnnotations;\n\t\tprivate static final Method unblockAnnotations;\n\t\t\n\t\tstatic {\n\t\t\tclassEnter = Permit.permissiveGetMethod(Enter.class, \"classEnter\", JCTree.class, Env.class);\n\t\t\tmemberEnter = Permit.permissiveGetMethod(MemberEnter.class, \"memberEnter\", JCTree.class, Env.class);\n\t\t\t\n\t\t\tMethod block = Permit.permissiveGetMethod(Annotate.class, \"blockAnnotations\");\n\t\t\tif (block == null) block = Permit.permissiveGetMethod(Annotate.class, \"enterStart\");\n\t\t\tblockAnnotations = block;\n\t\t\t\n\t\t\tMethod unblock = Permit.permissiveGetMethod(Annotate.class, \"unblockAnnotations\");\n\t\t\tif (unblock == null) unblock = Permit.permissiveGetMethod(Annotate.class, \"enterDone\");\n\t\t\tunblockAnnotations = unblock;\n\t\t}\n\t\t\n\t\tstatic Type classEnter(JCTree tree, JavacNode parent) {\n\t\t\tEnter enter = Enter.instance(parent.getContext());\n\t\t\tEnv<AttrContext> classEnv = enter.getEnv((TypeSymbol) parent.getElement());\n\t\t\tif (classEnv == null) return null;\n\t\t\tType type = (Type) Permit.invokeSneaky(classEnter, enter, tree, classEnv);\n\t\t\tif (type == null) return null;\n\t\t\ttype.complete();\n\t\t\treturn type;\n\t\t}\n\t\t\n\t\tstatic void memberEnter(JCTree tree, JavacNode parent) {\n\t\t\tContext context = parent.getContext();\n\t\t\tMemberEnter me = MemberEnter.instance(context);\n\t\t\tAnnotate annotate = Annotate.instance(context);\n\t\t\tEnter enter = Enter.instance(context);\n\t\t\t\n\t\t\tEnv<AttrContext> classEnv = enter.getEnv((TypeSymbol) parent.getElement());\n\t\t\tif (classEnv == null) return;\n\t\t\t\n\t\t\tPermit.invokeSneaky(blockAnnotations, annotate);\n\t\t\tPermit.invokeSneaky(memberEnter, me, tree, classEnv);\n\t\t\tPermit.invokeSneaky(unblockAnnotations, annotate);\n\t\t}\n\t}\n\t\n\tpublic static long addFinalIfNeeded(long flags, Context context) {\n\t\tboolean addFinal = LombokOptionsFactory.getDelombokOptions(context).getFormatPreferences().generateFinalParams();\n\t\t\n\t\tif (addFinal) flags |= Flags.FINAL;\n\t\treturn flags;\n\t}\n\t\n\tpublic static JCExpression genTypeRef(JavacNode node, String complexName) {\n\t\tString[] parts = complexName.split(\"\\\\.\");\n\t\tif (parts.length > 2 && parts[0].equals(\"java\") && parts[1].equals(\"lang\")) {\n\t\t\tString[] subParts = new String[parts.length - 2];\n\t\t\tSystem.arraycopy(parts, 2, subParts, 0, subParts.length);\n\t\t\treturn genJavaLangTypeRef(node, subParts);\n\t\t}\n\t\t\n\t\treturn chainDots(node, parts);\n\t}\n\t\n\tpublic static JCExpression genJavaLangTypeRef(JavacNode node, String... simpleNames) {\n\t\tif (LombokOptionsFactory.getDelombokOptions(node.getContext()).getFormatPreferences().javaLangAsFqn()) {\n\t\t\treturn chainDots(node, \"java\", \"lang\", simpleNames);\n\t\t} else {\n\t\t\treturn chainDots(node, null, null, simpleNames);\n\t\t}\n\t}\n\t\n\tpublic static JCExpression genJavaLangTypeRef(JavacNode node, int pos, String... simpleNames) {\n\t\tif (LombokOptionsFactory.getDelombokOptions(node.getContext()).getFormatPreferences().javaLangAsFqn()) {\n\t\t\treturn chainDots(node, pos, \"java\", \"lang\", simpleNames);\n\t\t} else {\n\t\t\treturn chainDots(node, pos, null, null, simpleNames);\n\t\t}\n\t}\n\t\n\tpublic static void addSuppressWarningsAll(JCModifiers mods, JavacNode node, JavacNode source, Context context) {\n\t\tif (!LombokOptionsFactory.getDelombokOptions(context).getFormatPreferences().generateSuppressWarnings()) return;\n\t\t\n\t\tboolean addJLSuppress = !Boolean.FALSE.equals(node.getAst().readConfiguration(ConfigurationKeys.ADD_SUPPRESSWARNINGS_ANNOTATIONS));\n\t\t\n\t\tif (addJLSuppress) {\n\t\t\tfor (JCAnnotation ann : mods.annotations) {\n\t\t\t\tJCTree type = ann.getAnnotationType();\n\t\t\t\tName n = null;\n\t\t\t\tif (type instanceof JCIdent) n = ((JCIdent) type).name;\n\t\t\t\telse if (type instanceof JCFieldAccess) n = ((JCFieldAccess) type).name;\n\t\t\t\tif (n != null && n.contentEquals(\"SuppressWarnings\")) {\n\t\t\t\t\taddJLSuppress = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (addJLSuppress) addAnnotation(mods, node, source, \"java.lang.SuppressWarnings\", node.getTreeMaker().Literal(\"all\"));\n\t\t\n\t\tif (Boolean.TRUE.equals(node.getAst().readConfiguration(ConfigurationKeys.ADD_FINDBUGS_SUPPRESSWARNINGS_ANNOTATIONS))) {\n\t\t\tJavacTreeMaker maker = node.getTreeMaker();\n\t\t\tJCExpression arg = maker.Assign(maker.Ident(node.toName(\"justification\")), maker.Literal(\"generated code\"));\n\t\t\taddAnnotation(mods, node, source, \"edu.umd.cs.findbugs.annotations.SuppressFBWarnings\", arg);\n\t\t}\n\t}\n\t\n\tpublic static void addGenerated(JCModifiers mods, JavacNode node, JavacNode source, Context context) {\n\t\tif (!LombokOptionsFactory.getDelombokOptions(context).getFormatPreferences().generateGenerated()) return;\n\t\t\n\t\tif (HandlerUtil.shouldAddGenerated(node)) {\n\t\t\taddAnnotation(mods, node, source, \"javax.annotation.Generated\", node.getTreeMaker().Literal(\"lombok\"));\n\t\t}\n\t\tif (Boolean.TRUE.equals(node.getAst().readConfiguration(ConfigurationKeys.ADD_LOMBOK_GENERATED_ANNOTATIONS))) {\n\t\t\taddAnnotation(mods, node, source, \"lombok.Generated\", null);\n\t\t}\n\t}\n\t\n\tpublic static void addAnnotation(JCModifiers mods, JavacNode node, JavacNode source, String annotationTypeFqn, JCExpression arg) {\n\t\tboolean isJavaLangBased;\n\t\tString simpleName; {\n\t\t\tint idx = annotationTypeFqn.lastIndexOf('.');\n\t\t\tsimpleName = idx == -1 ? annotationTypeFqn : annotationTypeFqn.substring(idx + 1);\n\t\t\t\n\t\t\tisJavaLangBased = idx == 9 && annotationTypeFqn.regionMatches(0, \"java.lang.\", 0, 10);\n\t\t}\n\t\t\n\t\tfor (JCAnnotation ann : mods.annotations) {\n\t\t\tJCTree annType = ann.getAnnotationType();\n\t\t\tif (annType instanceof JCIdent) {\n\t\t\t\tName lastPart = ((JCIdent) annType).name;\n\t\t\t\tif (lastPart.contentEquals(simpleName)) return;\n\t\t\t}\n\t\t\t\n\t\t\tif (annType instanceof JCFieldAccess) {\n\t\t\t\tif (annType.toString().equals(annotationTypeFqn)) return;\n\t\t\t}\n\t\t}\n\t\t\n\t\tJavacTreeMaker maker = node.getTreeMaker();\n\t\tJCExpression annType = isJavaLangBased ? genJavaLangTypeRef(node, simpleName) : chainDotsString(node, annotationTypeFqn);\n\t\tList<JCExpression> argList = arg != null ? List.of(arg) : List.<JCExpression>nil();\n\t\tJCAnnotation annotation = recursiveSetGeneratedBy(maker.Annotation(annType, argList), source);\n\t\tmods.annotations = mods.annotations.append(annotation);\n\t}\n\t\n\tstatic JCExpression addCheckerFrameworkReturnsReceiver(JCExpression returnType, JavacTreeMaker maker, JavacNode typeNode, CheckerFrameworkVersion cfv) {\n\t\tif (cfv.generateReturnsReceiver()) {\n\t\t\tJCAnnotation rrAnnotation = maker.Annotation(genTypeRef(typeNode, CheckerFrameworkVersion.NAME__RETURNS_RECEIVER), List.<JCExpression>nil());\n\t\t\treturnType = maker.AnnotatedType(List.of(rrAnnotation), returnType);\n\t\t}\n\t\treturn returnType;\n\t}\n\t\n\tprivate static List<JCTree> addAllButOne(List<JCTree> defs, int idx) {\n\t\tListBuffer<JCTree> out = new ListBuffer<JCTree>();\n\t\tint i = 0;\n\t\tfor (JCTree def : defs) {\n\t\t\tif (i++ != idx) out.append(def);\n\t\t}\n\t\treturn out.toList();\n\t}\n\t\n\t/**\n\t * In javac, dotted access of any kind, from {@code java.lang.String} to {@code var.methodName}\n\t * is represented by a fold-left of {@code Select} nodes with the leftmost string represented by\n\t * a {@code Ident} node. This method generates such an expression.\n\t * <p>\n\t * The position of the generated node(s) will be unpositioned (-1).\n\t * \n\t * For example, maker.Select(maker.Select(maker.Ident(NAME[java]), NAME[lang]), NAME[String]).\n\t * \n\t * @see com.sun.tools.javac.tree.JCTree.JCIdent\n\t * @see com.sun.tools.javac.tree.JCTree.JCFieldAccess\n\t */\n\tpublic static JCExpression chainDots(JavacNode node, String elem1, String elem2, String... elems) {\n\t\treturn chainDots(node, -1, elem1, elem2, elems);\n\t}\n\t\n\tpublic static JCExpression chainDots(JavacNode node, String[] elems) {\n\t\treturn chainDots(node, -1, null, null, elems);\n\t}\n\t\n\tpublic static JCExpression chainDots(JavacNode node, LombokImmutableList<String> elems) {\n\t\tassert elems != null;\n\t\t\n\t\tJavacTreeMaker maker = node.getTreeMaker();\n\t\tJCExpression e = null;\n\t\tfor (String elem : elems) {\n\t\t\tif (e == null) e = maker.Ident(node.toName(elem));\n\t\t\telse e = maker.Select(e, node.toName(elem));\n\t\t}\n\t\treturn e;\n\t}\n\t\n\t/**\n\t * In javac, dotted access of any kind, from {@code java.lang.String} to {@code var.methodName}\n\t * is represented by a fold-left of {@code Select} nodes with the leftmost string represented by\n\t * a {@code Ident} node. This method generates such an expression.\n\t * <p>\n\t * The position of the generated node(s) will be equal to the {@code pos} parameter.\n\t *\n\t * For example, maker.Select(maker.Select(maker.Ident(NAME[java]), NAME[lang]), NAME[String]).\n\t * \n\t * @see com.sun.tools.javac.tree.JCTree.JCIdent\n\t * @see com.sun.tools.javac.tree.JCTree.JCFieldAccess\n\t */\n\tpublic static JCExpression chainDots(JavacNode node, int pos, String elem1, String elem2, String... elems) {\n\t\tassert elems != null;\n\t\t\n\t\tJavacTreeMaker maker = node.getTreeMaker();\n\t\tif (pos != -1) maker = maker.at(pos);\n\t\tJCExpression e = null;\n\t\tif (elem1 != null) e = maker.Ident(node.toName(elem1));\n\t\tif (elem2 != null) e = e == null ? maker.Ident(node.toName(elem2)) : maker.Select(e, node.toName(elem2));\n\t\tfor (int i = 0 ; i < elems.length ; i++) {\n\t\t\te = e == null ? maker.Ident(node.toName(elems[i])) : maker.Select(e, node.toName(elems[i]));\n\t\t}\n\t\t\n\t\tassert e != null;\n\t\t\n\t\treturn e;\n\t}\n\t\n\t/**\n\t * In javac, dotted access of any kind, from {@code java.lang.String} to {@code var.methodName}\n\t * is represented by a fold-left of {@code Select} nodes with the leftmost string represented by\n\t * a {@code Ident} node. This method generates such an expression.\n\t * \n\t * For example, maker.Select(maker.Select(maker.Ident(NAME[java]), NAME[lang]), NAME[String]).\n\t * \n\t * @see com.sun.tools.javac.tree.JCTree.JCIdent\n\t * @see com.sun.tools.javac.tree.JCTree.JCFieldAccess\n\t */\n\tpublic static JCExpression chainDotsString(JavacNode node, String elems) {\n\t\treturn chainDots(node, null, null, elems.split(\"\\\\.\"));\n\t}\n\t\n\t/**\n\t * Searches the given field node for annotations and returns each one that matches the provided regular expression pattern.\n\t * \n\t * Only the simple name is checked - the package and any containing class are ignored.\n\t */\n\tpublic static List<JCAnnotation> findAnnotations(JavacNode fieldNode, Pattern namePattern) {\n\t\tListBuffer<JCAnnotation> result = new ListBuffer<JCAnnotation>();\n\t\tfor (JavacNode child : fieldNode.down()) {\n\t\t\tif (child.getKind() == Kind.ANNOTATION) {\n\t\t\t\tJCAnnotation annotation = (JCAnnotation) child.get();\n\t\t\t\tString name = annotation.annotationType.toString();\n\t\t\t\tint idx = name.lastIndexOf(\".\");\n\t\t\t\tString suspect = idx == -1 ? name : name.substring(idx + 1);\n\t\t\t\tif (namePattern.matcher(suspect).matches()) {\n\t\t\t\t\tresult.append(annotation);\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\t\treturn result.toList();\n\t}\n\t\n\tpublic static String scanForNearestAnnotation(JavacNode node, String... anns) {\n\t\twhile (node != null) {\n\t\t\tfor (JavacNode ann : node.down()) {\n\t\t\t\tif (ann.getKind() != Kind.ANNOTATION) continue;\n\t\t\t\tJCAnnotation a = (JCAnnotation) ann.get();\n\t\t\t\tfor (String annToFind : anns) if (typeMatches(annToFind, node, a.annotationType)) return annToFind;\n\t\t\t}\n\t\t\tnode = node.up();\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\t\n\tpublic static boolean hasNonNullAnnotations(JavacNode node) {\n\t\tfor (JavacNode child : node.down()) {\n\t\t\tif (child.getKind() == Kind.ANNOTATION) {\n\t\t\t\tJCAnnotation annotation = (JCAnnotation) child.get();\n\t\t\t\tString annotationTypeName = getTypeName(annotation.annotationType);\n\t\t\t\tfor (String nn : NONNULL_ANNOTATIONS) if (typeMatches(nn, node, annotationTypeName)) return true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tpublic static boolean hasNonNullAnnotations(JavacNode node, List<JCAnnotation> anns) {\n\t\tif (anns == null) return false;\n\t\tfor (JCAnnotation ann : anns) {\n\t\t\tString annotationTypeName = getTypeName(ann.annotationType);\n\t\t\tfor (String nn : NONNULL_ANNOTATIONS) if (typeMatches(nn, node, annotationTypeName)) return true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Searches the given field node for annotations and returns each one that is 'copyable' (either via configuration or from the base list).\n\t */\n\tpublic static List<JCAnnotation> findCopyableAnnotations(JavacNode node) {\n\t\tJCAnnotation anno = null;\n\t\tString annoName = null;\n\t\tfor (JavacNode child : node.down()) {\n\t\t\tif (child.getKind() == Kind.ANNOTATION) {\n\t\t\t\tif (anno != null) {\n\t\t\t\t\tannoName = \"\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tJCAnnotation annotation = (JCAnnotation) child.get();\n\t\t\t\tannoName = annotation.annotationType.toString();\n\t\t\t\tanno = annotation;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (annoName == null) return List.nil();\n\t\t\n\t\tjava.util.List<TypeName> configuredCopyable = node.getAst().readConfiguration(ConfigurationKeys.COPYABLE_ANNOTATIONS);\n\t\t\n\t\tif (!annoName.isEmpty()) {\n\t\t\tfor (TypeName cn : configuredCopyable) if (cn != null && typeMatches(cn.toString(), node, annoName)) return List.of(anno);\n\t\t\tfor (String bn : BASE_COPYABLE_ANNOTATIONS) if (typeMatches(bn, node, annoName)) return List.of(anno);\n\t\t}\n\n\t\tListBuffer<JCAnnotation> result = new ListBuffer<JCAnnotation>();\n\t\tfor (JavacNode child : node.down()) {\n\t\t\tif (child.getKind() == Kind.ANNOTATION) {\n\t\t\t\tJCAnnotation annotation = (JCAnnotation) child.get();\n\t\t\t\tString annotationTypeName = getTypeName(annotation.annotationType);\n\t\t\t\tboolean match = false;\n\t\t\t\tfor (TypeName cn : configuredCopyable) if (cn != null && typeMatches(cn.toString(), node, annotationTypeName)) {\n\t\t\t\t\tresult.append(annotation);\n\t\t\t\t\tmatch = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!match) for (String bn : BASE_COPYABLE_ANNOTATIONS) if (typeMatches(bn, node, annotationTypeName)) {\n\t\t\t\t\tresult.append(annotation);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result.toList();\n\t}\n\t\n\t/**\n\t * Searches the given field node for annotations that are specifically intentioned to be copied to the setter.\n\t */\n\tpublic static List<JCAnnotation> findCopyableToSetterAnnotations(JavacNode node) {\n\t\treturn findAnnotationsInList(node, COPY_TO_SETTER_ANNOTATIONS);\n\t}\n\n\t/**\n\t * Searches the given field node for annotations that are specifically intentioned to be copied to the builder's singular method.\n\t */\n\tpublic static List<JCAnnotation> findCopyableToBuilderSingularSetterAnnotations(JavacNode node) {\n\t\treturn findAnnotationsInList(node, COPY_TO_BUILDER_SINGULAR_SETTER_ANNOTATIONS);\n\t}\n\t\n\t/**\n\t * Searches the given field node for annotations that are in the given list, and returns those.\n\t */\n\tprivate static List<JCAnnotation> findAnnotationsInList(JavacNode node, java.util.List<String> annotationsToFind) {\n\t\tJCAnnotation anno = null;\n\t\tString annoName = null;\n\t\tfor (JavacNode child : node.down()) {\n\t\t\tif (child.getKind() == Kind.ANNOTATION) {\n\t\t\t\tif (anno != null) {\n\t\t\t\t\tannoName = \"\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tJCAnnotation annotation = (JCAnnotation) child.get();\n\t\t\t\tannoName = annotation.annotationType.toString();\n\t\t\t\tanno = annotation;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (annoName == null) return List.nil();\n\t\t\n\t\tif (!annoName.isEmpty()) {\n\t\t\tfor (String bn : annotationsToFind) if (typeMatches(bn, node, annoName)) return List.of(anno);\n\t\t}\n\t\t\n\t\tListBuffer<JCAnnotation> result = new ListBuffer<JCAnnotation>();\n\t\tfor (JavacNode child : node.down()) {\n\t\t\tif (child.getKind() == Kind.ANNOTATION) {\n\t\t\t\tJCAnnotation annotation = (JCAnnotation) child.get();\n\t\t\t\tString annotationTypeName = getTypeName(annotation.annotationType);\n\t\t\t\tboolean match = false;\n\t\t\t\tif (!match) for (String bn : annotationsToFind) if (typeMatches(bn, node, annotationTypeName)) {\n\t\t\t\t\tresult.append(annotation);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result.toList();\n\t}\n\t\n\t/**\n\t * Generates a new statement that checks if the given variable is null, and if so, throws a configured exception with the\n\t * variable name as message.\n\t */\n\tpublic static JCStatement generateNullCheck(JavacTreeMaker maker, JavacNode variable, JavacNode source) {\n\t\treturn generateNullCheck(maker, (JCVariableDecl) variable.get(), source);\n\t}\n\t\n\t/**\n\t * Generates a new statement that checks if the given local is null, and if so, throws a configured exception with the\n\t * local variable name as message. \n\t */\n\tpublic static JCStatement generateNullCheck(JavacTreeMaker maker, JCExpression typeNode, Name varName, JavacNode source, String customMessage) {\n\t\tNullCheckExceptionType exceptionType = source.getAst().readConfiguration(ConfigurationKeys.NON_NULL_EXCEPTION_TYPE);\n\t\tif (exceptionType == null) exceptionType = NullCheckExceptionType.NULL_POINTER_EXCEPTION;\n\t\t\n\t\tif (typeNode != null && isPrimitive(typeNode)) return null;\n\t\tJCLiteral message = maker.Literal(exceptionType.toExceptionMessage(varName.toString(), customMessage));\n\t\t\n\t\tLombokImmutableList<String> method = exceptionType.getMethod();\n\t\tif (method != null) {\n\t\t\treturn maker.Exec(maker.Apply(List.<JCExpression>nil(), chainDots(source, method), List.of(maker.Ident(varName), message)));\n\t\t}\n\t\t\n\t\tif (exceptionType == NullCheckExceptionType.ASSERTION) {\n\t\t\treturn maker.Assert(maker.Binary(CTC_NOT_EQUAL, maker.Ident(varName), maker.Literal(CTC_BOT, null)), message);\n\t\t}\n\t\t\n\t\tJCExpression exType = genTypeRef(source, exceptionType.getExceptionType());\n\t\tJCExpression exception = maker.NewClass(null, List.<JCExpression>nil(), exType, List.<JCExpression>of(message), null);\n\t\tJCStatement throwStatement = maker.Throw(exception);\n\t\tJCBlock throwBlock = maker.Block(0, List.of(throwStatement));\n\t\treturn maker.If(maker.Binary(CTC_EQUAL, maker.Ident(varName), maker.Literal(CTC_BOT, null)), throwBlock, null);\n\t}\n\t\n\t/**\n\t * Generates a new statement that checks if the given variable is null, and if so, throws a configured exception with the\n\t * variable name as message. \n\t * \n\t * This is a special case method reserved for use when the provided declaration differs from the\n\t * variable's declaration, i.e. in a constructor or setter where the local parameter is named the same but with the prefix\n\t * stripped as a result of @Accessors.prefix.\n\t */\n\tpublic static JCStatement generateNullCheck(JavacTreeMaker maker, JCVariableDecl varDecl, JavacNode source) {\n\t\treturn generateNullCheck(maker, varDecl.vartype, varDecl.name, source, null);\n\t}\n\t\n\t/**\n\t * Given a list of field names and a node referring to a type, finds each name in the list that does not match a field within the type.\n\t */\n\tpublic static List<Integer> createListOfNonExistentFields(List<String> list, JavacNode type, boolean excludeStandard, boolean excludeTransient) {\n\t\tboolean[] matched = new boolean[list.size()];\n\t\t\n\t\tfor (JavacNode child : type.down()) {\n\t\t\tif (list.isEmpty()) break;\n\t\t\tif (child.getKind() != Kind.FIELD) continue;\n\t\t\tJCVariableDecl field = (JCVariableDecl)child.get();\n\t\t\tif (excludeStandard) {\n\t\t\t\tif ((field.mods.flags & Flags.STATIC) != 0) continue;\n\t\t\t\tif (field.name.toString().startsWith(\"$\")) continue;\n\t\t\t}\n\t\t\tif (excludeTransient && (field.mods.flags & Flags.TRANSIENT) != 0) continue;\n\t\t\t\n\t\t\tint idx = list.indexOf(child.getName());\n\t\t\tif (idx > -1) matched[idx] = true;\n\t\t}\n\t\t\n\t\tListBuffer<Integer> problematic = new ListBuffer<Integer>();\n\t\tfor (int i = 0 ; i < list.size() ; i++) {\n\t\t\tif (!matched[i]) problematic.append(i);\n\t\t}\n\t\t\n\t\treturn problematic.toList();\n\t}\n\t\n\tstatic List<JCAnnotation> unboxAndRemoveAnnotationParameter(JCAnnotation ast, String parameterName, String errorName, JavacNode annotationNode) {\n\t\tListBuffer<JCExpression> params = new ListBuffer<JCExpression>();\n\t\tListBuffer<JCAnnotation> result = new ListBuffer<JCAnnotation>();\n\t\t\n\t\touter:\n\t\tfor (JCExpression param : ast.args) {\n\t\t\tboolean allowRaw;\n\t\t\tString nameOfParam = \"value\";\n\t\t\tJCExpression valueOfParam = null;\n\t\t\tif (param instanceof JCAssign) {\n\t\t\t\tJCAssign assign = (JCAssign) param;\n\t\t\t\tif (assign.lhs instanceof JCIdent) {\n\t\t\t\t\tJCIdent ident = (JCIdent) assign.lhs;\n\t\t\t\t\tnameOfParam = ident.name.toString();\n\t\t\t\t}\n\t\t\t\tvalueOfParam = assign.rhs;\n\t\t\t}\n\t\t\t\n\t\t\t/* strip trailing underscores */ {\n\t\t\t\tint lastIdx;\n\t\t\t\tfor (lastIdx = nameOfParam.length() ; lastIdx > 0; lastIdx--) {\n\t\t\t\t\tif (nameOfParam.charAt(lastIdx - 1) != '_') break;\n\t\t\t\t}\n\t\t\t\tallowRaw = lastIdx < nameOfParam.length();\n\t\t\t\tnameOfParam = nameOfParam.substring(0, lastIdx);\n\t\t\t}\n\t\t\t\n\t\t\tif (!parameterName.equals(nameOfParam)) {\n\t\t\t\tparams.append(param);\n\t\t\t\tcontinue outer;\n\t\t\t}\n\t\t\t\n\t\t\tint endPos = Javac.getEndPosition(param.pos(), (JCCompilationUnit) annotationNode.top().get());\n\t\t\tannotationNode.getAst().removeFromDeferredDiagnostics(param.pos, endPos);\n\t\t\t\n\t\t\tif (valueOfParam instanceof JCAnnotation) {\n\t\t\t\tString dummyAnnotationName = ((JCAnnotation) valueOfParam).annotationType.toString();\n\t\t\t\tdummyAnnotationName = dummyAnnotationName.replace(\"_\", \"\").replace(\"$\", \"\").replace(\"x\", \"\").replace(\"X\", \"\");\n\t\t\t\tif (dummyAnnotationName.length() > 0) {\n\t\t\t\t\tif (allowRaw) {\n\t\t\t\t\t\tresult.append((JCAnnotation) valueOfParam);\n\t\t\t\t\t} else {\n\t\t\t\t\t\taddError(errorName, annotationNode);\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (JCExpression expr : ((JCAnnotation) valueOfParam).args) {\n\t\t\t\t\t\tif (expr instanceof JCAssign && ((JCAssign) expr).lhs instanceof JCIdent) {\n\t\t\t\t\t\t\tJCIdent id = (JCIdent) ((JCAssign) expr).lhs;\n\t\t\t\t\t\t\tif (\"value\".equals(id.name.toString())) {\n\t\t\t\t\t\t\t\texpr = ((JCAssign) expr).rhs;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\taddError(errorName, annotationNode);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (expr instanceof JCAnnotation) {\n\t\t\t\t\t\t\tresult.append((JCAnnotation) expr);\n\t\t\t\t\t\t} else if (expr instanceof JCNewArray) {\n\t\t\t\t\t\t\tfor (JCExpression expr2 : ((JCNewArray) expr).elems) {\n\t\t\t\t\t\t\t\tif (expr2 instanceof JCAnnotation) {\n\t\t\t\t\t\t\t\t\tresult.append((JCAnnotation) expr2);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\taddError(errorName, annotationNode);\n\t\t\t\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\taddError(errorName, annotationNode);\n\t\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (valueOfParam instanceof JCNewArray) {\n\t\t\t\tJCNewArray arr = (JCNewArray) valueOfParam;\n\t\t\t\tif (arr.elems.isEmpty()) {\n\t\t\t\t\t// Just remove it, this is always fine.\n\t\t\t\t} else if (allowRaw) {\n\t\t\t\t\tfor (JCExpression jce : arr.elems) {\n\t\t\t\t\t\tif (jce instanceof JCAnnotation) result.append((JCAnnotation) jce);\n\t\t\t\t\t\telse addError(errorName, annotationNode);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\taddError(errorName, annotationNode);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\taddError(errorName, annotationNode);\n\t\t\t}\n\t\t}\n\t\tfor (JCAnnotation annotation : result) {\n\t\t\tclearTypes(annotation);\n\t\t}\n\t\tast.args = params.toList();\n\t\treturn result.toList();\n\t}\n\t\n\t/**\n\t * Removes all type information from the provided tree.\n\t */\n\tprivate static void clearTypes(JCTree tree) {\n\t\ttree.accept(new TreeScanner() {\n\t\t\t@Override public void scan(JCTree tree) {\n\t\t\t\tif (tree == null) return;\n\t\t\t\ttree.type = null;\n\t\t\t\tsuper.scan(tree);\n\t\t\t}\n\t\t\t@Override public void visitClassDef(JCClassDecl tree) {\n\t\t\t\ttree.sym = null;\n\t\t\t\tsuper.visitClassDef(tree);\n\t\t\t}\n\t\t\t@Override public void visitMethodDef(JCMethodDecl tree) {\n\t\t\t\ttree.sym = null;\n\t\t\t\tsuper.visitMethodDef(tree);\n\t\t\t}\n\t\t\t@Override public void visitVarDef(JCVariableDecl tree) {\n\t\t\t\ttree.sym = null;\n\t\t\t\tsuper.visitVarDef(tree);\n\t\t\t}\n\t\t\t@Override public void visitSelect(JCFieldAccess tree) {\n\t\t\t\ttree.sym = null;\n\t\t\t\tsuper.visitSelect(tree);\n\t\t\t}\n\t\t\t@Override public void visitIdent(JCIdent tree) {\n\t\t\t\ttree.sym = null;\n\t\t\t\tsuper.visitIdent(tree);\n\t\t\t}\n\t\t\t@Override public void visitAnnotation(JCAnnotation tree) {\n\t\t\t\tJCAnnotationReflect.setAttribute(tree, null);\n\t\t\t\tsuper.visitAnnotation(tree);\n\t\t\t}\n\t\t});\n\t}\n\t\n\tprivate static void addError(String errorName, JavacNode node) {\n\t\tif (node.getLatestJavaSpecSupported() < 8) {\n\t\t\tnode.addError(\"The correct format up to JDK7 is \" + errorName + \"=@__({@SomeAnnotation, @SomeOtherAnnotation}))\");\n\t\t} else {\n\t\t\tnode.addError(\"The correct format for JDK8+ is \" + errorName + \"_={@SomeAnnotation, @SomeOtherAnnotation})\");\n\t\t}\n\t}\n\t\n\tpublic static List<JCTypeParameter> copyTypeParams(JavacNode source, List<JCTypeParameter> params) {\n\t\tif (params == null || params.isEmpty()) return params;\n\t\tListBuffer<JCTypeParameter> out = new ListBuffer<JCTypeParameter>();\n\t\tJavacTreeMaker maker = source.getTreeMaker();\n\t\tfor (JCTypeParameter tp : params) {\n\t\t\tList<JCExpression> bounds = tp.bounds;\n\t\t\tif (bounds != null && !bounds.isEmpty()) {\n\t\t\t\tListBuffer<JCExpression> boundsCopy = new ListBuffer<JCExpression>();\n\t\t\t\tfor (JCExpression expr : tp.bounds) {\n\t\t\t\t\tboundsCopy.append(cloneType(maker, expr, source));\n\t\t\t\t}\n\t\t\t\tbounds = boundsCopy.toList();\n\t\t\t}\n\t\t\tout.append(maker.TypeParameter(tp.name, bounds));\n\t\t}\n\t\treturn out.toList();\n\t}\n\t\n\tpublic static List<JCAnnotation> getTypeUseAnnotations(JCExpression from) {\n\t\tif (!JCAnnotatedTypeReflect.is(from)) return List.nil();\n\t\treturn JCAnnotatedTypeReflect.getAnnotations(from);\n\t}\n\t\n\tpublic static JCExpression removeTypeUseAnnotations(JCExpression from) {\n\t\tif (!JCAnnotatedTypeReflect.is(from)) return from;\n\t\treturn JCAnnotatedTypeReflect.getUnderlyingType(from);\n\t}\n\t\n\tpublic static JCExpression namePlusTypeParamsToTypeReference(JavacTreeMaker maker, JavacNode type, List<JCTypeParameter> params) {\n\t\tJCClassDecl td = (JCClassDecl) type.get();\n\t\tboolean instance = (td.mods.flags & Flags.STATIC) == 0;\n\t\treturn namePlusTypeParamsToTypeReference(maker, type.up(), td.name, instance, params, List.<JCAnnotation>nil());\n\t}\n\t\n\tpublic static JCExpression namePlusTypeParamsToTypeReference(JavacTreeMaker maker, JavacNode type, List<JCTypeParameter> params, List<JCAnnotation> annotations) {\n\t\tJCClassDecl td = (JCClassDecl) type.get();\n\t\tboolean instance = (td.mods.flags & Flags.STATIC) == 0;\n\t\treturn namePlusTypeParamsToTypeReference(maker, type.up(), td.name, instance, params, annotations);\n\t}\n\t\n\tpublic static JCExpression namePlusTypeParamsToTypeReference(JavacTreeMaker maker, JavacNode parentType, Name typeName, boolean instance, List<JCTypeParameter> params) {\n\t\treturn namePlusTypeParamsToTypeReference(maker, parentType, typeName, instance, params, List.<JCAnnotation>nil());\n\t}\n\t\n\tpublic static JCExpression namePlusTypeParamsToTypeReference(JavacTreeMaker maker, JavacNode parentType, Name typeName, boolean instance, List<JCTypeParameter> params, List<JCAnnotation> annotations) {\n\t\tJCExpression r = null;\n\t\tif (parentType != null && parentType.getKind() == Kind.TYPE && !parentType.getName().isEmpty()) {\n\t\t\tJCClassDecl td = (JCClassDecl) parentType.get();\n\t\t\tboolean outerInstance = instance && ((td.mods.flags & Flags.STATIC) == 0);\n\t\t\tList<JCTypeParameter> outerParams = instance ? td.typarams : List.<JCTypeParameter>nil();\n\t\t\tr = namePlusTypeParamsToTypeReference(maker, parentType.up(), td.name, outerInstance, outerParams, List.<JCAnnotation>nil());\n\t\t}\n\t\t\n\t\tr = r == null ? maker.Ident(typeName) : maker.Select(r, typeName);\n\t\tif (!annotations.isEmpty()) r = JCAnnotatedTypeReflect.create(annotations, r);\n\t\tif (!params.isEmpty()) r = maker.TypeApply(r, typeParameterNames(maker, params));\n\t\treturn r;\n\t}\n\t\n\tpublic static List<JCExpression> typeParameterNames(JavacTreeMaker maker, List<JCTypeParameter> params) {\n\t\tListBuffer<JCExpression> typeArgs = new ListBuffer<JCExpression>();\n\t\tfor (JCTypeParameter param : params) {\n\t\t\ttypeArgs.append(maker.Ident(param.name));\n\t\t}\n\t\treturn typeArgs.toList();\n\t}\n\t\n\tpublic static void sanityCheckForMethodGeneratingAnnotationsOnBuilderClass(JavacNode typeNode, JavacNode errorNode) {\n\t\tList<String> disallowed = List.nil();\n\t\tfor (JavacNode child : typeNode.down()) {\n\t\t\tfor (String annType : INVALID_ON_BUILDERS) {\n\t\t\t\tif (annotationTypeMatches(annType, child)) {\n\t\t\t\t\tint lastIndex = annType.lastIndexOf('.');\n\t\t\t\t\tdisallowed = disallowed.append(lastIndex == -1 ? annType : annType.substring(lastIndex + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint size = disallowed.size();\n\t\tif (size == 0) return;\n\t\tif (size == 1) {\n\t\t\terrorNode.addError(\"@\" + disallowed.head + \" is not allowed on builder classes.\");\n\t\t\treturn;\n\t\t}\n\t\tStringBuilder out = new StringBuilder();\n\t\tfor (String a : disallowed) out.append(\"@\").append(a).append(\", \");\n\t\tout.setLength(out.length() - 2);\n\t\terrorNode.addError(out.append(\" are not allowed on builder classes.\").toString());\n\t}\n\t\n\tstatic List<JCAnnotation> copyAnnotations(List<? extends JCExpression> in) {\n\t\tListBuffer<JCAnnotation> out = new ListBuffer<JCAnnotation>();\n\t\tfor (JCExpression expr : in) {\n\t\t\tif (!(expr instanceof JCAnnotation)) continue;\n\t\t\tout.append((JCAnnotation) expr.clone());\n\t\t}\n\t\treturn out.toList();\n\t}\n\t\n\tstatic List<JCAnnotation> mergeAnnotations(List<JCAnnotation> a, List<JCAnnotation> b) {\n\t\tif (a == null || a.isEmpty()) return b;\n\t\tif (b == null || b.isEmpty()) return a;\n\t\tListBuffer<JCAnnotation> out = new ListBuffer<JCAnnotation>();\n\t\tfor (JCAnnotation ann : a) out.append(ann);\n\t\tfor (JCAnnotation ann : b) out.append(ann);\n\t\treturn out.toList();\n\t}\n\t\n\t/**\n\t * Returns {@code true} if the provided node is an actual class and not some other type declaration (so, not an annotation definition, interface, enum, or record).\n\t */\n\tpublic static boolean isClass(JavacNode typeNode) {\n\t\treturn isClassAndDoesNotHaveFlags(typeNode, Flags.INTERFACE | Flags.ENUM | Flags.ANNOTATION | RECORD);\n\t}\n\t\n\t/**\n\t * Returns {@code true} if the provided node is an actual class or enum and not some other type declaration (so, not an annotation definition, interface, or record).\n\t */\n\tpublic static boolean isClassOrEnum(JavacNode typeNode) {\n\t\treturn isClassAndDoesNotHaveFlags(typeNode, Flags.INTERFACE | Flags.ANNOTATION | RECORD);\n\t}\n\t\n\tpublic static boolean isClassOrEnumOrInterface(JavacNode typeNode) {\n\t\treturn isClassAndDoesNotHaveFlags(typeNode, Flags.ANNOTATION | RECORD);\n\t}\n\t\n\t/**\n\t * Returns {@code true} if the provided node is an actual class, an enum or a record and not some other type declaration (so, not an annotation definition or interface).\n\t */\n\tpublic static boolean isClassEnumOrRecord(JavacNode typeNode) {\n\t\treturn isClassAndDoesNotHaveFlags(typeNode, Flags.INTERFACE | Flags.ANNOTATION);\n\t}\n\t\n\t/**\n\t * Returns {@code true} if the provided node is a record declaration (so, not an annotation definition, interface, enum, or plain class).\n\t */\n\tpublic static boolean isRecord(JavacNode typeNode) {\n\t\treturn typeNode.getKind() == Kind.TYPE && (((JCClassDecl) typeNode.get()).mods.flags & RECORD) != 0;\n\t}\n\t\n\tpublic static boolean isClassAndDoesNotHaveFlags(JavacNode typeNode, long flags) {\n\t\tJCClassDecl typeDecl = null;\n\t\tif (typeNode.get() instanceof JCClassDecl) typeDecl = (JCClassDecl) typeNode.get();\n\t\telse return false;\n\t\t\n\t\tlong typeDeclflags = typeDecl == null ? 0 : typeDecl.mods.flags;\n\t\treturn (typeDeclflags & flags) == 0;\n\t}\n\t\n\t/**\n\t * Returns {@code true} if the provided node supports static methods and types (top level or static class)\n\t */\n\tpublic static boolean isStaticAllowed(JavacNode typeNode) {\n\t\treturn typeNode.isStatic() || typeNode.up() == null || typeNode.up().getKind() == Kind.COMPILATION_UNIT || isRecord(typeNode);\n\t}\n\t\n\tpublic static JavacNode upToTypeNode(JavacNode node) {\n\t\tif (node == null) throw new NullPointerException(\"node\");\n\t\twhile ((node != null) && !(node.get() instanceof JCClassDecl)) node = node.up();\n\t\t\n\t\treturn node;\n\t}\n\t\n\tpublic static List<JCExpression> cloneTypes(JavacTreeMaker maker, List<JCExpression> in, JavacNode source) {\n\t\tif (in.isEmpty()) return List.nil();\n\t\tif (in.size() == 1) return List.of(cloneType(maker, in.get(0), source));\n\t\tListBuffer<JCExpression> lb = new ListBuffer<JCExpression>();\n\t\tfor (JCExpression expr : in) lb.append(cloneType(maker, expr, source));\n\t\treturn lb.toList();\n\t}\n\t\n\t/**\n\t * Creates a full clone of a given javac AST type node. Every part is cloned (every identifier, every select, every wildcard, every type apply, every type_use annotation).\n\t * \n\t * If there's any node in the tree that we don't know how to clone, that part isn't cloned. However, we wouldn't know what could possibly show up that we\n\t * can't currently clone; that's just a safeguard.\n\t * \n\t * This should be used if the type looks the same in the code, but resolves differently. For example, a static method that has some generics in it named after\n\t * the class's own parameter, but as its a static method, the static method's notion of {@code T} is different from the class notion of {@code T}. If you're duplicating\n\t * a type used in the class context, you need to use this method.\n\t */\n\tpublic static JCExpression cloneType(JavacTreeMaker maker, JCExpression in, JavacNode source) {\n\t\tJCExpression out = cloneType0(maker, in);\n\t\tif (out != null) recursiveSetGeneratedBy(out, source);\n\t\treturn out;\n\t}\n\t\n\tprivate static JCExpression cloneType0(JavacTreeMaker maker, JCTree in) {\n\t\tif (in == null) return null;\n\t\t\n\t\tif (in instanceof JCPrimitiveTypeTree) {\n\t\t\treturn maker.TypeIdent(TypeTag.typeTag(in));\n\t\t}\n\t\t\n\t\tif (in instanceof JCIdent) {\n\t\t\treturn maker.Ident(((JCIdent) in).name);\n\t\t}\n\t\t\n\t\tif (in instanceof JCFieldAccess) {\n\t\t\tJCFieldAccess fa = (JCFieldAccess) in;\n\t\t\treturn maker.Select(cloneType0(maker, fa.selected), fa.name);\n\t\t}\n\t\t\n\t\tif (in instanceof JCArrayTypeTree) {\n\t\t\tJCArrayTypeTree att = (JCArrayTypeTree) in;\n\t\t\treturn maker.TypeArray(cloneType0(maker, att.elemtype));\n\t\t}\n\t\t\n\t\tif (in instanceof JCTypeApply) {\n\t\t\tJCTypeApply ta = (JCTypeApply) in;\n\t\t\tListBuffer<JCExpression> lb = new ListBuffer<JCExpression>();\n\t\t\tfor (JCExpression typeArg : ta.arguments) {\n\t\t\t\tlb.append(cloneType0(maker, typeArg));\n\t\t\t}\n\t\t\treturn maker.TypeApply(cloneType0(maker, ta.clazz), lb.toList());\n\t\t}\n\t\t\n\t\tif (in instanceof JCWildcard) {\n\t\t\tJCWildcard w = (JCWildcard) in;\n\t\t\tJCExpression newInner = cloneType0(maker, w.inner);\n\t\t\tTypeBoundKind newKind;\n\t\t\tswitch (w.getKind()) {\n\t\t\tcase SUPER_WILDCARD:\n\t\t\t\tnewKind = maker.TypeBoundKind(BoundKind.SUPER);\n\t\t\t\tbreak;\n\t\t\tcase EXTENDS_WILDCARD:\n\t\t\t\tnewKind = maker.TypeBoundKind(BoundKind.EXTENDS);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\tcase UNBOUNDED_WILDCARD:\n\t\t\t\tnewKind = maker.TypeBoundKind(BoundKind.UNBOUND);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn maker.Wildcard(newKind, newInner);\n\t\t}\n\t\t\n\t\tif (JCAnnotatedTypeReflect.is(in)) {\n\t\t\tJCExpression underlyingType = cloneType0(maker, JCAnnotatedTypeReflect.getUnderlyingType(in));\n\t\t\tList<JCAnnotation> anns = copyAnnotations(JCAnnotatedTypeReflect.getAnnotations(in));\n\t\t\treturn JCAnnotatedTypeReflect.create(anns, underlyingType);\n\t\t}\n\t\t\n\t\t// This is somewhat unsafe, but it's better than outright throwing an exception here. Returning null will just cause an exception down the pipeline.\n\t\treturn (JCExpression) in;\n\t}\n\t\n\tpublic static enum CopyJavadoc {\n\t\tVERBATIM {\n\t\t\t@Override public String apply(final JCCompilationUnit cu, final JavacNode node) {\n\t\t\t\treturn Javac.getDocComment(cu, node.get());\n\t\t\t}\n\t\t},\n\t\tGETTER {\n\t\t\t@Override public String apply(final JCCompilationUnit cu, final JavacNode node) {\n\t\t\t\tfinal JCTree n = node.get();\n\t\t\t\tString javadoc = Javac.getDocComment(cu, n);\n\t\t\t\t// step 1: Check if there is a 'GETTER' section. If yes, that becomes the new method's javadoc.\n\t\t\t\tString out = getJavadocSection(javadoc, \"GETTER\");\n\t\t\t\tfinal boolean sectionBased = out != null;\n\t\t\t\tif (!sectionBased) {\n\t\t\t\t\tout = stripLinesWithTagFromJavadoc(stripSectionsFromJavadoc(javadoc), JavadocTag.PARAM);\n\t\t\t\t}\n\t\t\t\tnode.getAst().cleanupTask(\"javadocfilter-getter\", n, new CleanupTask() {\n\t\t\t\t\t@Override public void cleanup() {\n\t\t\t\t\t\tString javadoc = Javac.getDocComment(cu, n);\n\t\t\t\t\t\tif (javadoc == null || javadoc.isEmpty()) return;\n\t\t\t\t\t\tjavadoc = stripSectionsFromJavadoc(javadoc);\n\t\t\t\t\t\tif (!sectionBased) {\n\t\t\t\t\t\t\tjavadoc = stripLinesWithTagFromJavadoc(stripSectionsFromJavadoc(javadoc), JavadocTag.RETURN);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tJavac.setDocComment(cu, n, javadoc);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn out;\n\t\t\t}\n\t\t},\n\t\tSETTER {\n\t\t\t@Override public String apply(final JCCompilationUnit cu, final JavacNode node) {\n\t\t\t\treturn applySetter(cu, node, \"SETTER\");\n\t\t\t}\n\t\t},\n\t\tWITH {\n\t\t\t@Override public String apply(final JCCompilationUnit cu, final JavacNode node) {\n\t\t\t\treturn addReturnsUpdatedSelfIfNeeded(applySetter(cu, node, \"WITH|WITHER\"));\n\t\t\t}\n\t\t},\n\t\tWITH_BY {\n\t\t\t@Override public String apply(final JCCompilationUnit cu, final JavacNode node) {\n\t\t\t\treturn applySetter(cu, node, \"WITHBY|WITH_BY\");\n\t\t\t}\n\t\t};\n\t\t\n\t\tpublic abstract String apply(final JCCompilationUnit cu, final JavacNode node);\n\t\t\n\t\tprivate static String applySetter(final JCCompilationUnit cu, JavacNode node, String sectionName) {\n\t\t\tfinal JCTree n = node.get();\n\t\t\tString javadoc = Javac.getDocComment(cu, n);\n\t\t\t// step 1: Check if there is a 'SETTER' section. If yes, that becomes the new method's javadoc.\n\t\t\tString out = getJavadocSection(javadoc, sectionName);\n\t\t\tfinal boolean sectionBased = out != null;\n\t\t\tif (!sectionBased) {\n\t\t\t\tout = stripLinesWithTagFromJavadoc(stripSectionsFromJavadoc(javadoc), JavadocTag.RETURN);\n\t\t\t}\n\t\t\tnode.getAst().cleanupTask(\"javadocfilter-setter\", n, new CleanupTask() {\n\t\t\t\t@Override public void cleanup() {\n\t\t\t\t\tString javadoc = Javac.getDocComment(cu, n);\n\t\t\t\t\tif (javadoc == null || javadoc.isEmpty()) return;\n\t\t\t\t\tjavadoc = stripSectionsFromJavadoc(javadoc);\n\t\t\t\t\tif (!sectionBased) {\n\t\t\t\t\t\tjavadoc = stripLinesWithTagFromJavadoc(stripSectionsFromJavadoc(javadoc), JavadocTag.PARAM);\n\t\t\t\t\t}\n\t\t\t\t\tJavac.setDocComment(cu, n, javadoc);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn shouldReturnThis(node, JavacHandlerUtil.getAccessorsForField(node)) ? addReturnsThisIfNeeded(out) : out;\n\t\t}\n\t}\n\t\n\tpublic static void copyJavadoc(JavacNode from, JCTree to, CopyJavadoc copyMode) {\n\t\tcopyJavadoc(from, to, copyMode, false);\n\t}\n\t\n\t/**\n\t * Copies javadoc on one node to the other.\n\t * \n\t * in 'GETTER' copyMode, first a 'GETTER' segment is searched for. If it exists, that will become the javadoc for the 'to' node, and this section is\n\t * stripped out of the 'from' node. If no 'GETTER' segment is found, then the entire javadoc is taken minus any {@code @param} lines and other sections.\n\t * any {@code @return} lines are stripped from 'from'.\n\t * \n\t * in 'SETTER' mode, stripping works similarly to 'GETTER' mode, except {@code param} are copied and stripped from the original and {@code @return} are skipped.\n\t */\n\tpublic static void copyJavadoc(JavacNode from, JCTree to, CopyJavadoc copyMode, boolean forceAddReturn) {\n\t\tif (copyMode == null) copyMode = CopyJavadoc.VERBATIM;\n\t\ttry {\n\t\t\tJCCompilationUnit cu = ((JCCompilationUnit) from.top().get());\n\t\t\tString newJavadoc = copyMode.apply(cu, from);\n\t\t\tif (forceAddReturn) {\n\t\t\t\tnewJavadoc = addReturnsThisIfNeeded(newJavadoc);\n\t\t\t}\n\t\t\tJavac.setDocComment(cu, to, newJavadoc);\n\t\t} catch (Exception ignore) {}\n\t}\n\t\n\tpublic static boolean isDirectDescendantOfObject(JavacNode typeNode) {\n\t\tif (!(typeNode.get() instanceof JCClassDecl)) throw new IllegalArgumentException(\"not a type node\");\n\t\tJCTree extending = Javac.getExtendsClause((JCClassDecl) typeNode.get());\n\t\tif (extending == null) return true;\n\t\tString p = extending.toString();\n\t\treturn p.equals(\"Object\") || p.equals(\"java.lang.Object\");\n\t}\n\t\n\tpublic static void createRelevantNullableAnnotation(JavacNode typeNode, JCMethodDecl mth) {\n\t\tNullAnnotationLibrary lib = typeNode.getAst().readConfiguration(ConfigurationKeys.ADD_NULL_ANNOTATIONS);\n\t\tif (lib == null) return;\n\t\tapplyAnnotationToMethodDecl(typeNode, mth, lib.getNullableAnnotation(), lib.isTypeUse());\n\t}\n\t\n\tpublic static void createRelevantNonNullAnnotation(JavacNode typeNode, JCMethodDecl mth) {\n\t\tNullAnnotationLibrary lib = typeNode.getAst().readConfiguration(ConfigurationKeys.ADD_NULL_ANNOTATIONS);\n\t\tif (lib == null) return;\n\t\tapplyAnnotationToMethodDecl(typeNode, mth, lib.getNonNullAnnotation(), lib.isTypeUse());\n\t}\n\t\n\tpublic static void createRelevantNonNullAnnotation(JavacNode typeNode, JCVariableDecl arg) {\n\t\tNullAnnotationLibrary lib = typeNode.getAst().readConfiguration(ConfigurationKeys.ADD_NULL_ANNOTATIONS);\n\t\tif (lib == null) return;\n\t\t\n\t\tapplyAnnotationToVarDecl(typeNode, arg, lib.getNonNullAnnotation(), lib.isTypeUse());\n\t}\n\t\n\tpublic static void createRelevantNullableAnnotation(JavacNode typeNode, JCVariableDecl arg) {\n\t\tNullAnnotationLibrary lib = typeNode.getAst().readConfiguration(ConfigurationKeys.ADD_NULL_ANNOTATIONS);\n\t\tif (lib == null) return;\n\t\t\n\t\tapplyAnnotationToVarDecl(typeNode, arg, lib.getNullableAnnotation(), lib.isTypeUse());\n\t}\n\t\n\tprivate static void applyAnnotationToMethodDecl(JavacNode typeNode, JCMethodDecl mth, String annType, boolean typeUse) {\n\t\tif (annType == null) return;\n\t\tJavacTreeMaker maker = typeNode.getTreeMaker();\n\t\t\n\t\tJCAnnotation m = maker.Annotation(genTypeRef(typeNode, annType), List.<JCExpression>nil());\n\t\tif (typeUse) {\n\t\t\tJCExpression resType = mth.restype;\n\t\t\tif (resType instanceof JCTypeApply) {\n\t\t\t\tJCTypeApply ta = (JCTypeApply) resType;\n\t\t\t\tif (ta.clazz instanceof JCFieldAccess) {\n\t\t\t\t\tmth.restype = maker.TypeApply(maker.AnnotatedType(List.of(m), ta.clazz), ta.arguments);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tresType = ta.clazz;\n\t\t\t}\n\t\t\t\n\t\t\tif (resType instanceof JCFieldAccess || resType instanceof JCArrayTypeTree) {\n\t\t\t\tmth.restype = maker.AnnotatedType(List.of(m), resType);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif (JCAnnotatedTypeReflect.is(resType)) {\n\t\t\t\tList<JCAnnotation> annotations = JCAnnotatedTypeReflect.getAnnotations(resType);\n\t\t\t\tJCAnnotatedTypeReflect.setAnnotations(resType, annotations.prepend(m));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif (resType instanceof JCPrimitiveTypeTree || resType instanceof JCIdent) {\n\t\t\t\tmth.mods.annotations = mth.mods.annotations == null ? List.of(m) : mth.mods.annotations.prepend(m);\n\t\t\t}\n\t\t} else {\n\t\t\tmth.mods.annotations = mth.mods.annotations == null ? List.of(m) : mth.mods.annotations.prepend(m);\n\t\t}\n\t}\n\t\n\tprivate static void applyAnnotationToVarDecl(JavacNode typeNode, JCVariableDecl arg, String annType, boolean typeUse) {\n\t\tif (annType == null) return;\n\t\tJavacTreeMaker maker = typeNode.getTreeMaker();\n\t\t\n\t\tJCAnnotation m = maker.Annotation(genTypeRef(typeNode, annType), List.<JCExpression>nil());\n\t\tif (typeUse) {\n\t\t\tJCExpression varType = arg.vartype;\n\t\t\tJCTypeApply ta = null;\n\t\t\tif (varType instanceof JCTypeApply) {\n\t\t\t\tta = (JCTypeApply) varType;\n\t\t\t\tvarType = ta.clazz;\n\t\t\t}\n\t\t\t\n\t\t\tif (varType instanceof JCFieldAccess || varType instanceof JCArrayTypeTree) {\n\t\t\t\tvarType = maker.AnnotatedType(List.of(m), varType);\n\t\t\t\tif (ta != null) ta.clazz = varType;\n\t\t\t\telse arg.vartype = varType;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif (JCAnnotatedTypeReflect.is(varType)) {\n\t\t\t\tList<JCAnnotation> annotations = JCAnnotatedTypeReflect.getAnnotations(varType);\n\t\t\t\tJCAnnotatedTypeReflect.setAnnotations(varType, annotations.prepend(m));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif (varType instanceof JCPrimitiveTypeTree || varType instanceof JCIdent) {\n\t\t\t\targ.mods.annotations = arg.mods.annotations == null ? List.of(m) : arg.mods.annotations.prepend(m);\n\t\t\t}\n\t\t} else {\n\t\t\targ.mods.annotations = arg.mods.annotations == null ? List.of(m) : arg.mods.annotations.prepend(m);\n\t\t}\n\t}\n}\n","lineNo":1677}
{"Smelly Sample":"/*\n * Copyright (C) 2009-2022 The Project Lombok Authors.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage lombok.javac.handlers;\n\nimport static com.sun.tools.javac.code.Flags.GENERATEDCONSTR;\nimport static lombok.core.handlers.HandlerUtil.*;\nimport static lombok.javac.Javac.*;\nimport static lombok.javac.JavacAugments.JCTree_generatedNode;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.regex.Pattern;\n\nimport com.sun.tools.javac.code.Attribute;\nimport com.sun.tools.javac.code.BoundKind;\nimport com.sun.tools.javac.code.Flags;\nimport com.sun.tools.javac.code.Scope;\nimport com.sun.tools.javac.code.Symbol;\nimport com.sun.tools.javac.code.Symbol.ClassSymbol;\nimport com.sun.tools.javac.code.Symbol.TypeSymbol;\nimport com.sun.tools.javac.code.Type;\nimport com.sun.tools.javac.comp.Annotate;\nimport com.sun.tools.javac.comp.AttrContext;\nimport com.sun.tools.javac.comp.Enter;\nimport com.sun.tools.javac.comp.Env;\nimport com.sun.tools.javac.comp.MemberEnter;\nimport com.sun.tools.javac.tree.JCTree;\nimport com.sun.tools.javac.tree.JCTree.JCAnnotation;\nimport com.sun.tools.javac.tree.JCTree.JCArrayTypeTree;\nimport com.sun.tools.javac.tree.JCTree.JCAssign;\nimport com.sun.tools.javac.tree.JCTree.JCBlock;\nimport com.sun.tools.javac.tree.JCTree.JCClassDecl;\nimport com.sun.tools.javac.tree.JCTree.JCCompilationUnit;\nimport com.sun.tools.javac.tree.JCTree.JCExpression;\nimport com.sun.tools.javac.tree.JCTree.JCExpressionStatement;\nimport com.sun.tools.javac.tree.JCTree.JCFieldAccess;\nimport com.sun.tools.javac.tree.JCTree.JCIdent;\nimport com.sun.tools.javac.tree.JCTree.JCImport;\nimport com.sun.tools.javac.tree.JCTree.JCLiteral;\nimport com.sun.tools.javac.tree.JCTree.JCMethodDecl;\nimport com.sun.tools.javac.tree.JCTree.JCMethodInvocation;\nimport com.sun.tools.javac.tree.JCTree.JCModifiers;\nimport com.sun.tools.javac.tree.JCTree.JCNewArray;\nimport com.sun.tools.javac.tree.JCTree.JCPrimitiveTypeTree;\nimport com.sun.tools.javac.tree.JCTree.JCStatement;\nimport com.sun.tools.javac.tree.JCTree.JCTypeApply;\nimport com.sun.tools.javac.tree.JCTree.JCTypeParameter;\nimport com.sun.tools.javac.tree.JCTree.JCVariableDecl;\nimport com.sun.tools.javac.tree.JCTree.JCWildcard;\nimport com.sun.tools.javac.tree.JCTree.TypeBoundKind;\nimport com.sun.tools.javac.tree.TreeMaker;\nimport com.sun.tools.javac.tree.TreeScanner;\nimport com.sun.tools.javac.util.Context;\nimport com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\nimport com.sun.tools.javac.util.List;\nimport com.sun.tools.javac.util.ListBuffer;\nimport com.sun.tools.javac.util.Name;\nimport com.sun.tools.javac.util.Options;\n\nimport lombok.AccessLevel;\nimport lombok.ConfigurationKeys;\nimport lombok.Data;\nimport lombok.Getter;\nimport lombok.core.AST.Kind;\nimport lombok.core.AnnotationValues;\nimport lombok.core.AnnotationValues.AnnotationValue;\nimport lombok.core.CleanupTask;\nimport lombok.core.LombokImmutableList;\nimport lombok.core.TypeResolver;\nimport lombok.core.configuration.CheckerFrameworkVersion;\nimport lombok.core.configuration.NullAnnotationLibrary;\nimport lombok.core.configuration.NullCheckExceptionType;\nimport lombok.core.configuration.TypeName;\nimport lombok.core.handlers.HandlerUtil;\nimport lombok.core.handlers.HandlerUtil.FieldAccess;\nimport lombok.delombok.LombokOptionsFactory;\nimport lombok.experimental.Accessors;\nimport lombok.experimental.Tolerate;\nimport lombok.javac.Javac;\nimport lombok.javac.JavacAugments;\nimport lombok.javac.JavacNode;\nimport lombok.javac.JavacTreeMaker;\nimport lombok.javac.JavacTreeMaker.TypeTag;\nimport lombok.permit.Permit;\n\n/**\n * Container for static utility methods useful to handlers written for javac.\n */\npublic class JavacHandlerUtil {\n\tprivate JavacHandlerUtil() {\n\t\t//Prevent instantiation\n\t}\n\t\n\tprivate static class MarkingScanner extends TreeScanner {\n\t\tprivate final JavacNode source;\n\t\t\n\t\tMarkingScanner(JavacNode source) {\n\t\t\tthis.source = source;\n\t\t}\n\t\t\n\t\t@Override public void scan(JCTree tree) {\n\t\t\tif (tree == null) return;\n\t\t\tsetGeneratedBy(tree, source);\n\t\t\tsuper.scan(tree);\n\t\t}\n\t}\n\t\n\t/**\n\t * Contributed by Jan Lahoda; many lombok transformations should not be run (or a lite version should be run) when the netbeans editor\n\t * is running javac on the open source file to find inline errors and such. As class files are compiled separately this does not affect\n\t * actual runtime behaviour or file output of the netbeans IDE.\n\t */\n\tpublic static boolean inNetbeansEditor(JavacNode node) {\n\t\treturn inNetbeansEditor(node.getContext());\n\t}\n\t\n\tpublic static boolean inNetbeansEditor(Context context) {\n\t\tOptions options = Options.instance(context);\n\t\treturn (options.keySet().contains(\"ide\") && !options.keySet().contains(\"backgroundCompilation\"));\n\t}\n\t\n\tpublic static boolean inNetbeansCompileOnSave(Context context) {\n\t\tOptions options = Options.instance(context);\n\t\treturn (options.keySet().contains(\"ide\") && options.keySet().contains(\"backgroundCompilation\"));\n\t}\n\t\n\tpublic static JCTree getGeneratedBy(JCTree node) {\n\t\treturn JCTree_generatedNode.get(node);\n\t}\n\t\n\tpublic static boolean isGenerated(JCTree node) {\n\t\treturn getGeneratedBy(node) != null;\n\t}\n\t\n\tpublic static <T extends JCTree> T recursiveSetGeneratedBy(T node, JavacNode source) {\n\t\tif (node == null) return null;\n\t\tsetGeneratedBy(node, source);\n\t\tnode.accept(new MarkingScanner(source));\n\t\treturn node;\n\t}\n\t\n\tpublic static <T extends JCTree> T setGeneratedBy(T node, JavacNode sourceNode) {\n\t\tif (node == null) return null;\n\t\tif (sourceNode == null) {\n\t\t\tJCTree_generatedNode.clear(node);\n\t\t\treturn node;\n\t\t}\n\t\tJCTree_generatedNode.set(node, sourceNode.get());\n\t\t\n\t\tif (!inNetbeansEditor(sourceNode.getContext()) || isParameter(node)) {\n\t\t\tnode.pos = sourceNode.getStartPos();\n\t\t\tstoreEnd(node, sourceNode.getEndPosition(), (JCCompilationUnit) sourceNode.top().get());\n\t\t}\n\t\treturn node;\n\t}\n\n\tpublic static boolean isParameter(JCTree node) {\n\t\treturn node instanceof JCVariableDecl && (((JCVariableDecl) node).mods.flags & Flags.PARAMETER) != 0;\n\t}\n\t\n\tpublic static boolean hasAnnotation(String type, JavacNode node) {\n\t\treturn hasAnnotation(type, node, false);\n\t}\n\t\n\tpublic static boolean hasAnnotation(Class<? extends Annotation> type, JavacNode node) {\n\t\treturn hasAnnotation(type, node, false);\n\t}\n\t\n\tpublic static boolean hasAnnotationAndDeleteIfNeccessary(Class<? extends Annotation> type, JavacNode node) {\n\t\treturn hasAnnotation(type, node, true);\n\t}\n\t\n\tprivate static boolean hasAnnotation(Class<? extends Annotation> type, JavacNode node, boolean delete) {\n\t\tif (node == null) return false;\n\t\tif (type == null) return false;\n\t\tswitch (node.getKind()) {\n\t\tcase ARGUMENT:\n\t\tcase FIELD:\n\t\tcase LOCAL:\n\t\tcase TYPE:\n\t\tcase METHOD:\n\t\t\tfor (JavacNode child : node.down()) {\n\t\t\t\tif (annotationTypeMatches(type, child)) {\n\t\t\t\t\tif (delete) deleteAnnotationIfNeccessary(child, type);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// intentional fallthrough\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tprivate static boolean hasAnnotation(String type, JavacNode node, boolean delete) {\n\t\tif (node == null) return false;\n\t\tif (type == null) return false;\n\t\tswitch (node.getKind()) {\n\t\tcase ARGUMENT:\n\t\tcase FIELD:\n\t\tcase LOCAL:\n\t\tcase TYPE:\n\t\tcase METHOD:\n\t\t\tfor (JavacNode child : node.down()) {\n\t\t\t\tif (annotationTypeMatches(type, child)) {\n\t\t\t\t\tif (delete) deleteAnnotationIfNeccessary(child, type);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// intentional fallthrough\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tpublic static JavacNode findInnerClass(JavacNode parent, String name) {\n\t\tfor (JavacNode child : parent.down()) {\n\t\t\tif (child.getKind() != Kind.TYPE) continue;\n\t\t\tJCClassDecl td = (JCClassDecl) child.get();\n\t\t\tif (td.name.contentEquals(name)) return child;\n\t\t}\n\t\treturn null;\n\t}\n\t\n\tpublic static JavacNode findAnnotation(Class<? extends Annotation> type, JavacNode node) {\n\t\treturn findAnnotation(type, node, false);\n\t}\n\t\n\tpublic static JavacNode findAnnotation(Class<? extends Annotation> type, JavacNode node, boolean delete) {\n\t\tif (node == null) return null;\n\t\tif (type == null) return null;\n\t\tswitch (node.getKind()) {\n\t\tcase ARGUMENT:\n\t\tcase FIELD:\n\t\tcase LOCAL:\n\t\tcase TYPE:\n\t\tcase METHOD:\n\t\t\tfor (JavacNode child : node.down()) {\n\t\t\t\tif (annotationTypeMatches(type, child)) {\n\t\t\t\t\tif (delete) deleteAnnotationIfNeccessary(child, type);\n\t\t\t\t\treturn child;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// intentional fallthrough\n\t\tdefault:\n\t\t\treturn null;\n\t\t}\n\t}\n\t\n\t/**\n\t * Checks if the Annotation AST Node provided is likely to be an instance of the provided annotation type.\n\t * \n\t * @param type An actual annotation type, such as {@code lombok.Getter.class}.\n\t * @param node A Lombok AST node representing an annotation in source code.\n\t */\n\tpublic static boolean annotationTypeMatches(Class<? extends Annotation> type, JavacNode node) {\n\t\tif (node.getKind() != Kind.ANNOTATION) return false;\n\t\treturn typeMatches(type, node, ((JCAnnotation) node.get()).annotationType);\n\t}\n\t\n\t/**\n\t * Checks if the Annotation AST Node provided is likely to be an instance of the provided annotation type.\n\t * \n\t * @param type An actual annotation type, such as {@code lombok.Getter.class}.\n\t * @param node A Lombok AST node representing an annotation in source code.\n\t */\n\tpublic static boolean annotationTypeMatches(String type, JavacNode node) {\n\t\tif (node.getKind() != Kind.ANNOTATION) return false;\n\t\treturn typeMatches(type, node, ((JCAnnotation) node.get()).annotationType);\n\t}\n\t\n\t/**\n\t * Checks if the given TypeReference node is likely to be a reference to the provided class.\n\t * \n\t * @param type An actual type. This method checks if {@code typeNode} is likely to be a reference to this type.\n\t * @param node A Lombok AST node. Any node in the appropriate compilation unit will do (used to get access to import statements).\n\t * @param typeNode A type reference to check.\n\t */\n\tpublic static boolean typeMatches(Class<?> type, JavacNode node, JCTree typeNode) {\n\t\treturn typeMatches(type.getName(), node, typeNode);\n\t}\n\t\n\t/**\n\t * Checks if the given TypeReference node is likely to be a reference to the provided class.\n\t * \n\t * @param type An actual type. This method checks if {@code typeNode} is likely to be a reference to this type.\n\t * @param node A Lombok AST node. Any node in the appropriate compilation unit will do (used to get access to import statements).\n\t * @param typeNode A type reference to check.\n\t */\n\tpublic static boolean typeMatches(String type, JavacNode node, JCTree typeNode) {\n\t\tString typeName = typeNode == null ? null : typeNode.toString();\n\t\tif (typeName == null || typeName.length() == 0) return false;\n\t\tint lastIndexA = typeName.lastIndexOf('.') + 1;\n\t\tint lastIndexB = Math.max(type.lastIndexOf('.'), type.lastIndexOf('$')) + 1;\n\t\tint len = typeName.length() - lastIndexA;\n\t\tif (len != type.length() - lastIndexB) return false;\n\t\tfor (int i = 0; i < len; i++) if (typeName.charAt(i + lastIndexA) != type.charAt(i + lastIndexB)) return false;\n\t\tTypeResolver resolver = node.getImportListAsTypeResolver();\n\t\treturn resolver.typeMatches(node, type, typeName);\n\t}\n\t\n\t/**\n\t * Returns if a field is marked deprecated, either by {@code @Deprecated} or in javadoc\n\t * @param field the field to check\n\t * @return {@code true} if a field is marked deprecated, either by {@code @Deprecated} or in javadoc, otherwise {@code false}\n\t */\n\tpublic static boolean isFieldDeprecated(JavacNode field) {\n\t\tif (!(field.get() instanceof JCVariableDecl)) return false;\n\t\tJCVariableDecl fieldNode = (JCVariableDecl) field.get();\n\t\tif ((fieldNode.mods.flags & Flags.DEPRECATED) != 0) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (JavacNode child : field.down()) {\n\t\t\tif (annotationTypeMatches(Deprecated.class, child)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic static CheckerFrameworkVersion getCheckerFrameworkVersion(JavacNode node) {\n\t\tCheckerFrameworkVersion cfv = node.getAst().readConfiguration(ConfigurationKeys.CHECKER_FRAMEWORK);\n\t\treturn cfv == null ? CheckerFrameworkVersion.NONE : cfv;\n\t}\n\t\n\t/**\n\t * Returns if a node is marked deprecated (as picked up on by the parser).\n\t * @param node the node to check (type, method, or field decl).\n\t */\n\tpublic static boolean nodeHasDeprecatedFlag(JCTree node) {\n\t\tif (node instanceof JCVariableDecl) return (((JCVariableDecl) node).mods.flags & Flags.DEPRECATED) != 0;\n\t\tif (node instanceof JCMethodDecl) return (((JCMethodDecl) node).mods.flags & Flags.DEPRECATED) != 0;\n\t\tif (node instanceof JCClassDecl) return (((JCClassDecl) node).mods.flags & Flags.DEPRECATED) != 0;\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Creates an instance of {@code AnnotationValues} for the provided AST Node.\n\t * \n\t * @param type An annotation class type, such as {@code lombok.Getter.class}.\n\t * @param node A Lombok AST node representing an annotation in source code.\n\t */\n\tpublic static <A extends Annotation> AnnotationValues<A> createAnnotation(Class<A> type, final JavacNode node) {\n\t\treturn createAnnotation(type, (JCAnnotation) node.get(), node);\n\t}\n\t\n\t/**\n\t * Creates an instance of {@code AnnotationValues} for the provided AST Node\n\t * and Annotation expression.\n\t *\n\t * @param type An annotation class type, such as {@code lombok.Getter.class}.\n\t * @param anno the annotation expression\n\t * @param node A Lombok AST node representing an annotation in source code.\n\t */\n\tpublic static <A extends Annotation> AnnotationValues<A> createAnnotation(Class<A> type, JCAnnotation anno, final JavacNode node) {\n\t\tMap<String, AnnotationValue> values = new HashMap<String, AnnotationValue>();\n\t\tList<JCExpression> arguments = anno.getArguments();\n\t\t\n\t\tfor (JCExpression arg : arguments) {\n\t\t\tString mName;\n\t\t\tJCExpression rhs;\n\t\t\tjava.util.List<String> raws = new ArrayList<String>();\n\t\t\tjava.util.List<Object> guesses = new ArrayList<Object>();\n\t\t\tjava.util.List<Object> expressions = new ArrayList<Object>();\n\t\t\tfinal java.util.List<DiagnosticPosition> positions = new ArrayList<DiagnosticPosition>();\n\t\t\t\n\t\t\tif (arg instanceof JCAssign) {\n\t\t\t\tJCAssign assign = (JCAssign) arg;\n\t\t\t\tmName = assign.lhs.toString();\n\t\t\t\trhs = assign.rhs;\n\t\t\t} else {\n\t\t\t\trhs = arg;\n\t\t\t\tmName = \"value\";\n\t\t\t}\n\t\t\t\n\t\t\tif (rhs instanceof JCNewArray) {\n\t\t\t\tList<JCExpression> elems = ((JCNewArray) rhs).elems;\n\t\t\t\tfor (JCExpression inner : elems) {\n\t\t\t\t\traws.add(inner.toString());\n\t\t\t\t\texpressions.add(inner);\n\t\t\t\t\tif (inner instanceof JCAnnotation) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\t\t\t\tClass<A> innerClass = (Class<A>) Class.forName(inner.type.toString());\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tguesses.add(createAnnotation(innerClass, (JCAnnotation) inner, node));\n\t\t\t\t\t\t} catch (ClassNotFoundException ex) {\n\t\t\t\t\t\t\tguesses.add(calculateGuess(inner));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tguesses.add(calculateGuess(inner));\n\t\t\t\t\t}\n\t\t\t\t\tpositions.add(inner.pos());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\traws.add(rhs.toString());\n\t\t\t\texpressions.add(rhs);\n\t\t\t\tif (rhs instanceof JCAnnotation) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\t\t\tClass<A> innerClass = (Class<A>) Class.forName(rhs.type.toString());\n\t\t\t\t\t\t\n\t\t\t\t\t\tguesses.add(createAnnotation(innerClass, (JCAnnotation) rhs, node));\n\t\t\t\t\t} catch (ClassNotFoundException ex) {\n\t\t\t\t\t\tguesses.add(calculateGuess(rhs));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tguesses.add(calculateGuess(rhs));\n\t\t\t\t}\n\t\t\t\tpositions.add(rhs.pos());\n\t\t\t}\n\t\t\t\n\t\t\tvalues.put(mName, new AnnotationValue(node, raws, expressions, guesses, true) {\n\t\t\t\t@Override public void setError(String message, int valueIdx) {\n\t\t\t\t\tif (valueIdx < 0) node.addError(message);\n\t\t\t\t\telse node.addError(message, positions.get(valueIdx));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t@Override public void setWarning(String message, int valueIdx) {\n\t\t\t\t\tif (valueIdx < 0) node.addWarning(message);\n\t\t\t\t\telse node.addWarning(message, positions.get(valueIdx));\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\t\n\t\tfor (Method m : type.getDeclaredMethods()) {\n\t\t\tif (!Modifier.isPublic(m.getModifiers())) continue;\n\t\t\tString name = m.getName();\n\t\t\tif (!values.containsKey(name)) {\n\t\t\t\tvalues.put(name, new AnnotationValue(node, new ArrayList<String>(), new ArrayList<Object>(), new ArrayList<Object>(), false) {\n\t\t\t\t\t@Override public void setError(String message, int valueIdx) {\n\t\t\t\t\t\tnode.addError(message);\n\t\t\t\t\t}\n\t\t\t\t\t@Override public void setWarning(String message, int valueIdx) {\n\t\t\t\t\t\tnode.addWarning(message);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn new AnnotationValues<A>(type, values, node);\n\t}\n\t\n\t/**\n\t * Removes the annotation from javac's AST (it remains in lombok's AST),\n\t * then removes any import statement that imports this exact annotation (not star imports).\n\t * Only does this if the DeleteLombokAnnotations class is in the context.\n\t */\n\tpublic static void deleteAnnotationIfNeccessary(JavacNode annotation, String annotationType) {\n\t\tdeleteAnnotationIfNeccessary0(annotation, annotationType);\n\t}\n\t\n\t/**\n\t * Removes the annotation from javac's AST (it remains in lombok's AST),\n\t * then removes any import statement that imports this exact annotation (not star imports).\n\t * Only does this if the DeleteLombokAnnotations class is in the context.\n\t */\n\tpublic static void deleteAnnotationIfNeccessary(JavacNode annotation, Class<? extends Annotation> annotationType) {\n\t\tdeleteAnnotationIfNeccessary0(annotation, annotationType.getName());\n\t}\n\t\n\t/**\n\t * Removes the annotation from javac's AST (it remains in lombok's AST),\n\t * then removes any import statement that imports this exact annotation (not star imports).\n\t * Only does this if the DeleteLombokAnnotations class is in the context.\n\t */\n\tpublic static void deleteAnnotationIfNeccessary(JavacNode annotation, Class<? extends Annotation> annotationType1, Class<? extends Annotation> annotationType2) {\n\t\tdeleteAnnotationIfNeccessary0(annotation, annotationType1.getName(), annotationType2.getName());\n\t}\n\t\n\t/**\n\t * Removes the annotation from javac's AST (it remains in lombok's AST),\n\t * then removes any import statement that imports this exact annotation (not star imports).\n\t * Only does this if the DeleteLombokAnnotations class is in the context.\n\t */\n\tpublic static void deleteAnnotationIfNeccessary(JavacNode annotation, Class<? extends Annotation> annotationType1, String annotationType2) {\n\t\tdeleteAnnotationIfNeccessary0(annotation, annotationType1.getName(), annotationType2);\n\t}\n\t\n\tprivate static void deleteAnnotationIfNeccessary0(JavacNode annotation, String... annotationTypes) {\n\t\tif (inNetbeansEditor(annotation)) return;\n\t\tif (!annotation.shouldDeleteLombokAnnotations()) return;\n\t\tJavacNode parentNode = annotation.directUp();\n\t\tswitch (parentNode.getKind()) {\n\t\tcase FIELD:\n\t\tcase ARGUMENT:\n\t\tcase LOCAL:\n\t\t\tJCVariableDecl variable = (JCVariableDecl) parentNode.get();\n\t\t\tvariable.mods.annotations = filterList(variable.mods.annotations, annotation.get());\n\t\t\tbreak;\n\t\tcase METHOD:\n\t\t\tJCMethodDecl method = (JCMethodDecl) parentNode.get();\n\t\t\tmethod.mods.annotations = filterList(method.mods.annotations, annotation.get());\n\t\t\tbreak;\n\t\tcase TYPE:\n\t\t\ttry {\n\t\t\t\tJCClassDecl type = (JCClassDecl) parentNode.get();\n\t\t\t\ttype.mods.annotations = filterList(type.mods.annotations, annotation.get());\n\t\t\t} catch (ClassCastException e) {\n\t\t\t\t//something rather odd has been annotated. Better to just break only delombok instead of everything.\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t//This really shouldn't happen, but if it does, better just break delombok instead of breaking everything.\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tparentNode.getAst().setChanged();\n\t\tfor (String annotationType : annotationTypes) {\n\t\t\tdeleteImportFromCompilationUnit(annotation, annotationType);\n\t\t}\n\t}\n\t\n\tpublic static void deleteImportFromCompilationUnit(JavacNode node, String name) {\n\t\tif (inNetbeansEditor(node)) return;\n\t\tif (!node.shouldDeleteLombokAnnotations()) return;\n\t\t\n\t\tJCCompilationUnit unit = (JCCompilationUnit) node.top().get();\n\t\t\n\t\tfor (JCTree def : unit.defs) {\n\t\t\tif (!(def instanceof JCImport)) continue;\n\t\t\tJCImport imp0rt = (JCImport) def;\n\t\t\tif (imp0rt.staticImport) continue;\n\t\t\tif (!imp0rt.qualid.toString().equals(name)) continue;\n\t\t\tJavacAugments.JCImport_deletable.set(imp0rt, true);\n\t\t}\n\t}\n\t\n\tprivate static List<JCAnnotation> filterList(List<JCAnnotation> annotations, JCTree jcTree) {\n\t\tListBuffer<JCAnnotation> newAnnotations = new ListBuffer<JCAnnotation>();\n\t\tfor (JCAnnotation ann : annotations) {\n\t\t\tif (jcTree != ann) newAnnotations.append(ann);\n\t\t}\n\t\treturn newAnnotations.toList();\n\t}\n\t\n\t/** Serves as return value for the methods that check for the existence of fields and methods. */\n\tpublic enum MemberExistsResult {\n\t\tNOT_EXISTS, EXISTS_BY_LOMBOK, EXISTS_BY_USER;\n\t}\n\t\n\t/**\n\t * Translates the given field into all possible getter names.\n\t * Convenient wrapper around {@link HandlerUtil#toAllGetterNames(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static java.util.List<String> toAllGetterNames(JavacNode field) {\n\t\treturn HandlerUtil.toAllGetterNames(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * Translates the given field into all possible getter names.\n\t * Convenient wrapper around {@link HandlerUtil#toAllGetterNames(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static java.util.List<String> toAllGetterNames(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\treturn HandlerUtil.toAllGetterNames(field.getAst(), accessors, field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * @return the likely getter name for the stated field. (e.g. private boolean foo; to isFoo).\n\t * \n\t * Convenient wrapper around {@link HandlerUtil#toGetterName(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static String toGetterName(JavacNode field) {\n\t\treturn HandlerUtil.toGetterName(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * @return the likely getter name for the stated field. (e.g. private boolean foo; to isFoo).\n\t * \n\t * Convenient wrapper around {@link HandlerUtil#toGetterName(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static String toGetterName(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\treturn HandlerUtil.toGetterName(field.getAst(), accessors, field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * Translates the given field into all possible setter names.\n\t * Convenient wrapper around {@link HandlerUtil#toAllSetterNames(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static java.util.List<String> toAllSetterNames(JavacNode field) {\n\t\treturn HandlerUtil.toAllSetterNames(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * Translates the given field into all possible setter names.\n\t * Convenient wrapper around {@link HandlerUtil#toAllSetterNames(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static java.util.List<String> toAllSetterNames(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\treturn HandlerUtil.toAllSetterNames(field.getAst(), accessors, field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * @return the likely setter name for the stated field. (e.g. private boolean foo; to setFoo).\n\t * \n\t * Convenient wrapper around {@link HandlerUtil#toSetterName(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static String toSetterName(JavacNode field) {\n\t\treturn HandlerUtil.toSetterName(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * @return the likely setter name for the stated field. (e.g. private boolean foo; to setFoo).\n\t * \n\t * Convenient wrapper around {@link HandlerUtil#toSetterName(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static String toSetterName(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\treturn HandlerUtil.toSetterName(field.getAst(), accessors, field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * Translates the given field into all possible with names.\n\t * Convenient wrapper around {@link HandlerUtil#toAllWithNames(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static java.util.List<String> toAllWithNames(JavacNode field) {\n\t\treturn HandlerUtil.toAllWithNames(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * Translates the given field into all possible with names.\n\t * Convenient wrapper around {@link HandlerUtil#toAllWithNames(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static java.util.List<String> toAllWithNames(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\treturn HandlerUtil.toAllWithNames(field.getAst(), accessors, field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * Translates the given field into all possible withBy names.\n\t * Convenient wrapper around {@link HandlerUtil#toAllWithByNames(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static java.util.List<String> toAllWithByNames(JavacNode field) {\n\t\treturn HandlerUtil.toAllWithByNames(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * Translates the given field into all possible withBy names.\n\t * Convenient wrapper around {@link HandlerUtil#toAllWithByNames(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static java.util.List<String> toAllWithByNames(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\treturn HandlerUtil.toAllWithByNames(field.getAst(), accessors, field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * @return the likely with name for the stated field. (e.g. private boolean foo; to withFoo).\n\t * \n\t * Convenient wrapper around {@link HandlerUtil#toWithName(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static String toWithName(JavacNode field) {\n\t\treturn HandlerUtil.toWithName(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * @return the likely with name for the stated field. (e.g. private boolean foo; to withFoo).\n\t * \n\t * Convenient wrapper around {@link HandlerUtil#toWithName(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static String toWithName(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\treturn HandlerUtil.toWithName(field.getAst(), accessors, field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * @return the likely withBy name for the stated field. (e.g. private boolean foo; to withFooBy).\n\t * \n\t * Convenient wrapper around {@link HandlerUtil#toWithByName(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static String toWithByName(JavacNode field) {\n\t\treturn HandlerUtil.toWithByName(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * @return the likely withBy name for the stated field. (e.g. private boolean foo; to withFooBy).\n\t * \n\t * Convenient wrapper around {@link HandlerUtil#toWithByName(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static String toWithByName(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\treturn HandlerUtil.toWithByName(field.getAst(), accessors, field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * When generating a setter, the setter either returns void (beanspec) or Self (fluent).\n\t * This method scans for the {@code Accessors} annotation to figure that out.\n\t */\n\tpublic static boolean shouldReturnThis(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\tif ((((JCVariableDecl) field.get()).mods.flags & Flags.STATIC) != 0) return false;\n\t\t\n\t\treturn HandlerUtil.shouldReturnThis0(accessors, field.getAst());\n\t}\n\t\n\t/**\n\t * When generating a setter/getter/wither, should it be made final?\n\t */\n\tpublic static boolean shouldMakeFinal(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\tif ((((JCVariableDecl) field.get()).mods.flags & Flags.STATIC) != 0) return false;\n\t\t\n\t\treturn HandlerUtil.shouldMakeFinal0(accessors, field.getAst());\n\t}\n\t\n\tpublic static JCExpression cloneSelfType(JavacNode childOfType) {\n\t\tJavacNode typeNode = childOfType;\n\t\tJavacTreeMaker maker = childOfType.getTreeMaker();\n\t\twhile (typeNode != null && typeNode.getKind() != Kind.TYPE) typeNode = typeNode.up();\n\t\treturn JavacHandlerUtil.namePlusTypeParamsToTypeReference(maker, typeNode, ((JCClassDecl) typeNode.get()).typarams);\n\t}\n\t\n\tpublic static boolean isBoolean(JavacNode field) {\n\t\tJCExpression varType = ((JCVariableDecl) field.get()).vartype;\n\t\treturn isBoolean(varType);\n\t}\n\t\n\tpublic static boolean isBoolean(JCExpression varType) {\n\t\treturn varType != null && varType.toString().equals(\"boolean\");\n\t}\n\t\n\tpublic static Name removePrefixFromField(JavacNode field) {\n\t\tjava.util.List<String> prefixes = null;\n\t\tfor (JavacNode node : field.down()) {\n\t\t\tif (annotationTypeMatches(Accessors.class, node)) {\n\t\t\t\tAnnotationValues<Accessors> ann = createAnnotation(Accessors.class, node);\n\t\t\t\tif (ann.isExplicit(\"prefix\")) prefixes = Arrays.asList(ann.getInstance().prefix());\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (prefixes == null) {\n\t\t\tJavacNode current = field.up();\n\t\t\touter:\n\t\t\twhile (current != null) {\n\t\t\t\tfor (JavacNode node : current.down()) {\n\t\t\t\t\tif (annotationTypeMatches(Accessors.class, node)) {\n\t\t\t\t\t\tAnnotationValues<Accessors> ann = createAnnotation(Accessors.class, node);\n\t\t\t\t\t\tif (ann.isExplicit(\"prefix\")) prefixes = Arrays.asList(ann.getInstance().prefix());\n\t\t\t\t\t\tbreak outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcurrent = current.up();\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (prefixes == null) prefixes = field.getAst().readConfiguration(ConfigurationKeys.ACCESSORS_PREFIX);\n\t\t\n\t\tif (!prefixes.isEmpty()) {\n\t\t\tCharSequence newName = removePrefix(field.getName(), prefixes);\n\t\t\tif (newName != null) return field.toName(newName.toString());\n\t\t}\n\t\t\n\t\treturn ((JCVariableDecl) field.get()).name;\n\t}\n\t\n\tpublic static AnnotationValues<Accessors> getAccessorsForField(JavacNode field) {\n\t\tAnnotationValues<Accessors> values = null;\n\t\t\n\t\tfor (JavacNode node : field.down()) {\n\t\t\tif (annotationTypeMatches(Accessors.class, node)) {\n\t\t\t\tvalues = createAnnotation(Accessors.class, node);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tJavacNode current = field.up();\n\t\twhile (current != null) {\n\t\t\tfor (JavacNode node : current.down()) {\n\t\t\t\tif (annotationTypeMatches(Accessors.class, node)) {\n\t\t\t\t\tAnnotationValues<Accessors> onType = createAnnotation(Accessors.class, node);\n\t\t\t\t\tvalues = values == null ? onType : values.integrate(onType);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurrent = current.up();\n\t\t}\n\t\t\n\t\treturn values == null ? AnnotationValues.of(Accessors.class, field) : values;\n\t}\n\t\n\t/**\n\t * Checks if there is a field with the provided name.\n\t * \n\t * @param fieldName the field name to check for.\n\t * @param node Any node that represents the Type (JCClassDecl) to look in, or any child node thereof.\n\t */\n\tpublic static MemberExistsResult fieldExists(String fieldName, JavacNode node) {\n\t\tnode = upToTypeNode(node);\n\t\t\n\t\tif (node != null && node.get() instanceof JCClassDecl) {\n\t\t\tfor (JCTree def : ((JCClassDecl)node.get()).defs) {\n\t\t\t\tif (def instanceof JCVariableDecl) {\n\t\t\t\t\tif (((JCVariableDecl)def).name.contentEquals(fieldName)) {\n\t\t\t\t\t\treturn getGeneratedBy(def) == null ? MemberExistsResult.EXISTS_BY_USER : MemberExistsResult.EXISTS_BY_LOMBOK;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn MemberExistsResult.NOT_EXISTS;\n\t}\n\t\n\tpublic static MemberExistsResult methodExists(String methodName, JavacNode node, int params) {\n\t\treturn methodExists(methodName, node, true, params);\n\t}\n\t\n\t/**\n\t * Checks if there is a method with the provided name. In case of multiple methods (overloading), only\n\t * the first method decides if EXISTS_BY_USER or EXISTS_BY_LOMBOK is returned.\n\t * \n\t * @param methodName the method name to check for.\n\t * @param node Any node that represents the Type (JCClassDecl) to look in, or any child node thereof.\n\t * @param caseSensitive If the search should be case sensitive.\n\t * @param params The number of parameters the method should have; varargs count as 0-*. Set to -1 to find any method with the appropriate name regardless of parameter count.\n\t */\n\tpublic static MemberExistsResult methodExists(String methodName, JavacNode node, boolean caseSensitive, int params) {\n\t\tnode = upToTypeNode(node);\n\t\t\n\t\tif (node != null && node.get() instanceof JCClassDecl) {\n\t\t\ttop: for (JCTree def : ((JCClassDecl)node.get()).defs) {\n\t\t\t\tif (def instanceof JCMethodDecl) {\n\t\t\t\t\tJCMethodDecl md = (JCMethodDecl) def;\n\t\t\t\t\tString name = md.name.toString();\n\t\t\t\t\tboolean matches = caseSensitive ? name.equals(methodName) : name.equalsIgnoreCase(methodName);\n\t\t\t\t\tif (matches) {\n\t\t\t\t\t\tif (params > -1) {\n\t\t\t\t\t\t\tList<JCVariableDecl> ps = md.params;\n\t\t\t\t\t\t\tint minArgs = 0;\n\t\t\t\t\t\t\tint maxArgs = 0;\n\t\t\t\t\t\t\tif (ps != null && ps.length() > 0) {\n\t\t\t\t\t\t\t\tminArgs = ps.length();\n\t\t\t\t\t\t\t\tif ((ps.last().mods.flags & Flags.VARARGS) != 0) {\n\t\t\t\t\t\t\t\t\tmaxArgs = Integer.MAX_VALUE;\n\t\t\t\t\t\t\t\t\tminArgs--;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tmaxArgs = minArgs;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (params < minArgs || params > maxArgs) continue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (isTolerate(node, md)) continue top;\n\t\t\t\t\t\t\n\t\t\t\t\t\treturn getGeneratedBy(def) == null ? MemberExistsResult.EXISTS_BY_USER : MemberExistsResult.EXISTS_BY_LOMBOK;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn MemberExistsResult.NOT_EXISTS;\n\t}\n\t\n\tpublic static boolean isTolerate(JavacNode node, JCTree.JCMethodDecl md) {\n\t\tList<JCAnnotation> annotations = md.getModifiers().getAnnotations();\n\t\tif (annotations != null) for (JCTree.JCAnnotation anno : annotations) {\n\t\t\tif (typeMatches(Tolerate.class, node, anno.getAnnotationType())) return true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Checks if there is a (non-default) constructor. In case of multiple constructors (overloading), only\n\t * the first constructor decides if EXISTS_BY_USER or EXISTS_BY_LOMBOK is returned.\n\t * \n\t * @param node Any node that represents the Type (JCClassDecl) to look in, or any child node thereof.\n\t */\n\tpublic static MemberExistsResult constructorExists(JavacNode node) {\n\t\tnode = upToTypeNode(node);\n\t\t\n\t\tif (node != null && node.get() instanceof JCClassDecl) {\n\t\t\tfor (JCTree def : ((JCClassDecl) node.get()).defs) {\n\t\t\t\tif (def instanceof JCMethodDecl) {\n\t\t\t\t\tJCMethodDecl md = (JCMethodDecl) def;\n\t\t\t\t\tif (md.name.contentEquals(\"<init>\")) {\n\t\t\t\t\t\tif ((md.mods.flags & Flags.GENERATEDCONSTR) != 0) continue;\n\t\t\t\t\t\tif (isTolerate(node, md)) continue;\n\t\t\t\t\t\treturn getGeneratedBy(def) == null ? MemberExistsResult.EXISTS_BY_USER : MemberExistsResult.EXISTS_BY_LOMBOK;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn MemberExistsResult.NOT_EXISTS;\n\t}\n\t\n\tpublic static boolean isConstructorCall(final JCStatement statement) {\n\t\tif (!(statement instanceof JCExpressionStatement)) return false;\n\t\tJCExpression expr = ((JCExpressionStatement) statement).expr;\n\t\tif (!(expr instanceof JCMethodInvocation)) return false;\n\t\tJCExpression invocation = ((JCMethodInvocation) expr).meth;\n\t\tString name;\n\t\tif (invocation instanceof JCFieldAccess) {\n\t\t\tname = ((JCFieldAccess) invocation).name.toString();\n\t\t} else if (invocation instanceof JCIdent) {\n\t\t\tname = ((JCIdent) invocation).name.toString();\n\t\t} else {\n\t\t\tname = \"\";\n\t\t}\n\t\t\n\t\treturn \"super\".equals(name) || \"this\".equals(name);\n\t}\n\t\n\t/**\n\t * Turns an {@code AccessLevel} instance into the flag bit used by javac.\n\t */\n\tpublic static int toJavacModifier(AccessLevel accessLevel) {\n\t\tswitch (accessLevel) {\n\t\tcase MODULE:\n\t\tcase PACKAGE:\n\t\t\treturn 0;\n\t\tdefault:\n\t\tcase PUBLIC:\n\t\t\treturn Flags.PUBLIC;\n\t\tcase NONE:\n\t\tcase PRIVATE:\n\t\t\treturn Flags.PRIVATE;\n\t\tcase PROTECTED:\n\t\t\treturn Flags.PROTECTED;\n\t\t}\n\t}\n\t\n\tprivate static class GetterMethod {\n\t\tprivate final Name name;\n\t\tprivate final JCExpression type;\n\t\t\n\t\tGetterMethod(Name name, JCExpression type) {\n\t\t\tthis.name = name;\n\t\t\tthis.type = type;\n\t\t}\n\t}\n\t\n\tprivate static GetterMethod findGetter(JavacNode field) {\n\t\tJCVariableDecl decl = (JCVariableDecl)field.get();\n\t\tJavacNode typeNode = field.up();\n\t\tfor (String potentialGetterName : toAllGetterNames(field)) {\n\t\t\tfor (JavacNode potentialGetter : typeNode.down()) {\n\t\t\t\tif (potentialGetter.getKind() != Kind.METHOD) continue;\n\t\t\t\tJCMethodDecl method = (JCMethodDecl) potentialGetter.get();\n\t\t\t\tif (!method.name.toString().equalsIgnoreCase(potentialGetterName)) continue;\n\t\t\t\t/** static getX() methods don't count. */\n\t\t\t\tif ((method.mods.flags & Flags.STATIC) != 0) continue;\n\t\t\t\t/** Nor do getters with a non-empty parameter list. */\n\t\t\t\tif (method.params != null && method.params.size() > 0) continue;\n\t\t\t\treturn new GetterMethod(method.name, method.restype);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Check if the field has a @Getter annotation.\n\t\t\n\t\tboolean hasGetterAnnotation = false;\n\t\t\n\t\tfor (JavacNode child : field.down()) {\n\t\t\tif (child.getKind() == Kind.ANNOTATION && annotationTypeMatches(Getter.class, child)) {\n\t\t\t\tAnnotationValues<Getter> ann = createAnnotation(Getter.class, child);\n\t\t\t\tif (ann.getInstance().value() == AccessLevel.NONE) return null;   //Definitely WONT have a getter.\n\t\t\t\thasGetterAnnotation = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Check if the class has a @Getter annotation.\n\t\t\n\t\tif (!hasGetterAnnotation && HandleGetter.fieldQualifiesForGetterGeneration(field)) {\n\t\t\t//Check if the class has @Getter or @Data annotation.\n\t\t\t\n\t\t\tJavacNode containingType = field.up();\n\t\t\tif (containingType != null) for (JavacNode child : containingType.down()) {\n\t\t\t\tif (child.getKind() == Kind.ANNOTATION && annotationTypeMatches(Data.class, child)) hasGetterAnnotation = true;\n\t\t\t\tif (child.getKind() == Kind.ANNOTATION && annotationTypeMatches(Getter.class, child)) {\n\t\t\t\t\tAnnotationValues<Getter> ann = createAnnotation(Getter.class, child);\n\t\t\t\t\tif (ann.getInstance().value() == AccessLevel.NONE) return null;   //Definitely WONT have a getter.\n\t\t\t\t\thasGetterAnnotation = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (hasGetterAnnotation) {\n\t\t\tString getterName = toGetterName(field);\n\t\t\tif (getterName == null) return null;\n\t\t\treturn new GetterMethod(field.toName(getterName), decl.vartype);\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\t\n\tstatic boolean lookForGetter(JavacNode field, FieldAccess fieldAccess) {\n\t\tif (fieldAccess == FieldAccess.GETTER) return true;\n\t\tif (fieldAccess == FieldAccess.ALWAYS_FIELD) return false;\n\t\t\n\t\t// If @Getter(lazy = true) is used, then using it is mandatory.\n\t\tfor (JavacNode child : field.down()) {\n\t\t\tif (child.getKind() != Kind.ANNOTATION) continue;\n\t\t\tif (annotationTypeMatches(Getter.class, child)) {\n\t\t\t\tAnnotationValues<Getter> ann = createAnnotation(Getter.class, child);\n\t\t\t\tif (ann.getInstance().lazy()) return true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Returns the type of the field, unless a getter exists for this field, in which case the return type of the getter is returned.\n\t * \n\t * @see #createFieldAccessor(TreeMaker, JavacNode, FieldAccess)\n\t */\n\tstatic JCExpression getFieldType(JavacNode field, FieldAccess fieldAccess) {\n\t\tif (field.getKind() == Kind.METHOD) return ((JCMethodDecl) field.get()).restype;\n\t\t\n\t\tboolean lookForGetter = lookForGetter(field, fieldAccess);\n\t\t\n\t\tGetterMethod getter = lookForGetter ? findGetter(field) : null;\n\t\t\n\t\tif (getter == null) {\n\t\t\treturn ((JCVariableDecl) field.get()).vartype;\n\t\t}\n\t\t\n\t\treturn getter.type;\n\t}\n\t\n\t/**\n\t * Creates an expression that reads the field. Will either be {@code this.field} or {@code this.getField()} depending on whether or not there's a getter.\n\t */\n\tstatic JCExpression createFieldAccessor(JavacTreeMaker maker, JavacNode field, FieldAccess fieldAccess) {\n\t\treturn createFieldAccessor(maker, field, fieldAccess, null);\n\t}\n\t\n\tstatic JCExpression createFieldAccessor(JavacTreeMaker maker, JavacNode field, FieldAccess fieldAccess, JCExpression receiver) {\n\t\tboolean lookForGetter = lookForGetter(field, fieldAccess);\n\t\t\n\t\tGetterMethod getter = lookForGetter ? findGetter(field) : null;\n\t\tJCVariableDecl fieldDecl = (JCVariableDecl) field.get();\n\t\t\n\t\tif (getter == null) {\n\t\t\tif (receiver == null) {\n\t\t\t\tif ((fieldDecl.mods.flags & Flags.STATIC) == 0) {\n\t\t\t\t\treceiver = maker.Ident(field.toName(\"this\"));\n\t\t\t\t} else {\n\t\t\t\t\tJavacNode containerNode = field.up();\n\t\t\t\t\tif (containerNode != null && containerNode.get() instanceof JCClassDecl) {\n\t\t\t\t\t\tJCClassDecl container = (JCClassDecl) field.up().get();\n\t\t\t\t\t\treceiver = maker.Ident(container.name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn receiver == null ? maker.Ident(fieldDecl.name) : maker.Select(receiver, fieldDecl.name);\n\t\t}\n\t\t\n\t\tif (receiver == null) receiver = maker.Ident(field.toName(\"this\"));\n\t\tJCMethodInvocation call = maker.Apply(List.<JCExpression>nil(),\n\t\t\tmaker.Select(receiver, getter.name), List.<JCExpression>nil());\n\t\treturn call;\n\t}\n\t\n\tstatic JCExpression createMethodAccessor(JavacTreeMaker maker, JavacNode method) {\n\t\treturn createMethodAccessor(maker, method, null);\n\t}\n\t\n\tstatic JCExpression createMethodAccessor(JavacTreeMaker maker, JavacNode method, JCExpression receiver) {\n\t\tJCMethodDecl methodDecl = (JCMethodDecl) method.get();\n\t\t\n\t\tif (receiver == null && (methodDecl.mods.flags & Flags.STATIC) == 0) {\n\t\t\treceiver = maker.Ident(method.toName(\"this\"));\n\t\t} else if (receiver == null) {\n\t\t\tJavacNode containerNode = method.up();\n\t\t\tif (containerNode != null && containerNode.get() instanceof JCClassDecl) {\n\t\t\t\tJCClassDecl container = (JCClassDecl) method.up().get();\n\t\t\t\treceiver = maker.Ident(container.name);\n\t\t\t}\n\t\t}\n\t\t\n\t\tJCMethodInvocation call = maker.Apply(List.<JCExpression>nil(),\n\t\t\treceiver == null ? maker.Ident(methodDecl.name) : maker.Select(receiver, methodDecl.name), List.<JCExpression>nil());\n\t\treturn call;\n\t}\n\t\n\t/**\n\t * Adds the given new field declaration to the provided type AST Node.\n\t * The field carries the &#64;{@link SuppressWarnings}(\"all\") annotation.\n\t * Also takes care of updating the JavacAST.\n\t */\n\tpublic static JavacNode injectFieldAndMarkGenerated(JavacNode typeNode, JCVariableDecl field) {\n\t\treturn injectField(typeNode, field, true);\n\t}\n\t\n\t/**\n\t * Adds the given new field declaration to the provided type AST Node.\n\t * \n\t * Also takes care of updating the JavacAST.\n\t */\n\tpublic static JavacNode injectField(JavacNode typeNode, JCVariableDecl field) {\n\t\treturn injectField(typeNode, field, false);\n\t}\n\t\n\tpublic static JavacNode injectField(JavacNode typeNode, JCVariableDecl field, boolean addGenerated) {\n\t\treturn injectField(typeNode, field, addGenerated, false);\n\t}\n\t\n\tpublic static JavacNode injectField(JavacNode typeNode, JCVariableDecl field, boolean addGenerated, boolean specialEnumHandling) {\n\t\tJCClassDecl type = (JCClassDecl) typeNode.get();\n\t\t\n\t\tif (addGenerated) {\n\t\t\taddSuppressWarningsAll(field.mods, typeNode, typeNode.getNodeFor(getGeneratedBy(field)), typeNode.getContext());\n\t\t\taddGenerated(field.mods, typeNode, typeNode.getNodeFor(getGeneratedBy(field)), typeNode.getContext());\n\t\t}\n\t\t\n\t\tList<JCTree> insertAfter = null;\n\t\tList<JCTree> insertBefore = type.defs;\n\t\twhile (true) {\n\t\t\tboolean skip = false;\n\t\t\tif (insertBefore.head instanceof JCVariableDecl) {\n\t\t\t\tJCVariableDecl f = (JCVariableDecl) insertBefore.head;\n\t\t\t\tif ((!specialEnumHandling && isEnumConstant(f)) || isGenerated(f)) skip = true;\n\t\t\t} else if (insertBefore.head instanceof JCMethodDecl) {\n\t\t\t\tif ((((JCMethodDecl) insertBefore.head).mods.flags & GENERATEDCONSTR) != 0) skip = true;\n\t\t\t}\n\t\t\tif (skip) {\n\t\t\t\tinsertAfter = insertBefore;\n\t\t\t\tinsertBefore = insertBefore.tail;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tList<JCTree> fieldEntry = List.<JCTree>of(field);\n\t\tfieldEntry.tail = insertBefore;\n\t\tif (insertAfter == null) {\n\t\t\ttype.defs = fieldEntry;\n\t\t} else {\n\t\t\tinsertAfter.tail = fieldEntry;\n\t\t}\n\t\t\n\t\tEnterReflect.memberEnter(field, typeNode);\n\t\t\n\t\treturn typeNode.add(field, Kind.FIELD);\n\t}\n\t\n\tpublic static boolean isEnumConstant(final JCVariableDecl field) {\n\t\treturn (field.mods.flags & Flags.ENUM) != 0;\n\t}\n\t\n\tstatic class JCAnnotatedTypeReflect {\n\t\tprivate static Class<?> TYPE;\n\t\tprivate static Constructor<?> CONSTRUCTOR;\n\t\tprivate static Field ANNOTATIONS, UNDERLYING_TYPE;\n\t\t\n\t\tprivate static void initByLoader(ClassLoader classLoader) {\n\t\t\tif (TYPE != null) return;\n\t\t\tClass<?> c;\n\t\t\ttry {\n\t\t\t\tc = classLoader.loadClass(\"com.sun.tools.javac.tree.JCTree$JCAnnotatedType\");\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tinit(c);\n\t\t}\n\t\t\n\t\tprivate static void init(Class<?> in) {\n\t\t\tif (TYPE != null) return;\n\t\t\tif (!in.getName().equals(\"com.sun.tools.javac.tree.JCTree$JCAnnotatedType\")) return;\n\t\t\ttry {\n\t\t\t\tCONSTRUCTOR = Permit.getConstructor(in, List.class, JCExpression.class);\n\t\t\t\tANNOTATIONS = Permit.getField(in, \"annotations\");\n\t\t\t\tUNDERLYING_TYPE = Permit.getField(in, \"underlyingType\");\n\t\t\t\tTYPE = in;\n\t\t\t} catch (Exception ignore) {}\n\t\t}\n\t\t\n\t\tstatic boolean is(JCTree obj) {\n\t\t\tif (obj == null) return false;\n\t\t\tinit(obj.getClass());\n\t\t\treturn obj.getClass() == TYPE;\n\t\t}\n\t\t\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tstatic List<JCAnnotation> getAnnotations(JCTree obj) {\n\t\t\tinit(obj.getClass());\n\t\t\ttry {\n\t\t\t\treturn (List<JCAnnotation>) ANNOTATIONS.get(obj);\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn List.nil();\n\t\t\t}\n\t\t}\n\t\t\n\t\tstatic void setAnnotations(JCTree obj, List<JCAnnotation> anns) {\n\t\t\tinit(obj.getClass());\n\t\t\ttry {\n\t\t\t\tANNOTATIONS.set(obj, anns);\n\t\t\t} catch (Exception e) {}\n\t\t}\n\t\t\n\t\tstatic JCExpression getUnderlyingType(JCTree obj) {\n\t\t\tinit(obj.getClass());\n\t\t\ttry {\n\t\t\t\treturn (JCExpression) UNDERLYING_TYPE.get(obj);\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\t\n\t\tstatic JCExpression create(List<JCAnnotation> annotations, JCExpression underlyingType) {\n\t\t\tinitByLoader(underlyingType.getClass().getClassLoader());\n\t\t\ttry {\n\t\t\t\treturn (JCExpression) CONSTRUCTOR.newInstance(annotations, underlyingType);\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn underlyingType;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic class JCAnnotationReflect {\n\t\tprivate static final Field ATTRIBUTE;\n\n\t\tstatic {\n\t\t\tATTRIBUTE = Permit.permissiveGetField(JCAnnotation.class, \"attribute\");\n\t\t}\n\n\t\tstatic Attribute.Compound getAttribute(JCAnnotation jcAnnotation) {\n\t\t\tif (ATTRIBUTE != null) {\n\t\t\t\ttry {\n\t\t\t\t\treturn (Attribute.Compound) ATTRIBUTE.get(jcAnnotation);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t// Ignore\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tstatic void setAttribute(JCAnnotation jcAnnotation, Attribute.Compound attribute) {\n\t\t\tif (ATTRIBUTE != null) {\n\t\t\t\ttry {\n\t\t\t\t\tPermit.set(ATTRIBUTE, jcAnnotation, attribute);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t// Ignore\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// jdk9 support, types have changed, names stay the same\n\tstatic class ClassSymbolMembersField {\n\t\tprivate static final Field membersField;\n\t\tprivate static final Method removeMethod;\n\t\tprivate static final Method enterMethod;\n\t\t\n\t\tstatic {\n\t\t\tField f = null;\n\t\t\tMethod r = null;\n\t\t\tMethod e = null;\n\t\t\ttry {\n\t\t\t\tf = Permit.getField(ClassSymbol.class, \"members_field\");\n\t\t\t\tr = Permit.getMethod(f.getType(), \"remove\", Symbol.class);\n\t\t\t\te = Permit.getMethod(f.getType(), \"enter\", Symbol.class);\n\t\t\t} catch (Exception ex) {}\n\t\t\tmembersField = f;\n\t\t\tremoveMethod = r;\n\t\t\tenterMethod = e;\n\t\t}\n\t\t\n\t\tstatic void remove(ClassSymbol from, Symbol toRemove) {\n\t\t\tif (from == null) return;\n\t\t\ttry {\n\t\t\t\tScope scope = (Scope) membersField.get(from);\n\t\t\t\tif (scope == null) return;\n\t\t\t\tPermit.invoke(removeMethod, scope, toRemove);\n\t\t\t} catch (Exception e) {}\n\t\t}\n\t\t\n\t\tstatic void enter(ClassSymbol from, Symbol toEnter) {\n\t\t\tif (from == null) return;\n\t\t\ttry {\n\t\t\t\tScope scope = (Scope) membersField.get(from);\n\t\t\t\tif (scope == null) return;\n\t\t\t\tPermit.invoke(enterMethod, scope, toEnter);\n\t\t\t} catch (Exception e) {}\n\t\t}\n\t}\n\t\n\t/**\n\t * Adds the given new method declaration to the provided type AST Node.\n\t * Can also inject constructors.\n\t * \n\t * Also takes care of updating the JavacAST.\n\t */\n\tpublic static void injectMethod(JavacNode typeNode, JCMethodDecl method) {\n\t\tJCClassDecl type = (JCClassDecl) typeNode.get();\n\t\t\n\t\tif (method.getName().contentEquals(\"<init>\")) {\n\t\t\t//Scan for default constructor, and remove it.\n\t\t\tint idx = 0;\n\t\t\tfor (JCTree def : type.defs) {\n\t\t\t\tif (def instanceof JCMethodDecl) {\n\t\t\t\t\tif ((((JCMethodDecl) def).mods.flags & Flags.GENERATEDCONSTR) != 0) {\n\t\t\t\t\t\tJavacNode tossMe = typeNode.getNodeFor(def);\n\t\t\t\t\t\tif (tossMe != null) tossMe.up().removeChild(tossMe);\n\t\t\t\t\t\ttype.defs = addAllButOne(type.defs, idx);\n\t\t\t\t\t\tClassSymbolMembersField.remove(type.sym, ((JCMethodDecl) def).sym);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tidx++;\n\t\t\t}\n\t\t}\n\t\t\n\t\taddSuppressWarningsAll(method.mods, typeNode, typeNode.getNodeFor(getGeneratedBy(method)), typeNode.getContext());\n\t\taddGenerated(method.mods, typeNode, typeNode.getNodeFor(getGeneratedBy(method)), typeNode.getContext());\n\t\ttype.defs = type.defs.append(method);\n\t\t\n\t\tEnterReflect.memberEnter(method, typeNode);\n\t\t\n\t\ttypeNode.add(method, Kind.METHOD);\n\t}\n\n\t/**\n\t * Adds an inner type (class, interface, enum) to the given type. Cannot inject top-level types.\n\t * \n\t * @param typeNode parent type to inject new type into\n\t * @param type New type (class, interface, etc) to inject.\n\t * @return \n\t */\n\tpublic static JavacNode injectType(JavacNode typeNode, final JCClassDecl type) {\n\t\tJCClassDecl typeDecl = (JCClassDecl) typeNode.get();\n\t\taddSuppressWarningsAll(type.mods, typeNode, typeNode.getNodeFor(getGeneratedBy(type)), typeNode.getContext());\n\t\taddGenerated(type.mods, typeNode, typeNode.getNodeFor(getGeneratedBy(type)), typeNode.getContext());\n\t\ttypeDecl.defs = typeDecl.defs.append(type);\n\t\t\n\t\tEnterReflect.classEnter(type, typeNode);\n\t\t\n\t\treturn typeNode.add(type, Kind.TYPE);\n\t}\n\t\n\tstatic class EnterReflect {\n\t\tprivate static final Method classEnter;\n\t\tprivate static final Method memberEnter;\n\t\tprivate static final Method blockAnnotations;\n\t\tprivate static final Method unblockAnnotations;\n\t\t\n\t\tstatic {\n\t\t\tclassEnter = Permit.permissiveGetMethod(Enter.class, \"classEnter\", JCTree.class, Env.class);\n\t\t\tmemberEnter = Permit.permissiveGetMethod(MemberEnter.class, \"memberEnter\", JCTree.class, Env.class);\n\t\t\t\n\t\t\tMethod block = Permit.permissiveGetMethod(Annotate.class, \"blockAnnotations\");\n\t\t\tif (block == null) block = Permit.permissiveGetMethod(Annotate.class, \"enterStart\");\n\t\t\tblockAnnotations = block;\n\t\t\t\n\t\t\tMethod unblock = Permit.permissiveGetMethod(Annotate.class, \"unblockAnnotations\");\n\t\t\tif (unblock == null) unblock = Permit.permissiveGetMethod(Annotate.class, \"enterDone\");\n\t\t\tunblockAnnotations = unblock;\n\t\t}\n\t\t\n\t\tstatic Type classEnter(JCTree tree, JavacNode parent) {\n\t\t\tEnter enter = Enter.instance(parent.getContext());\n\t\t\tEnv<AttrContext> classEnv = enter.getEnv((TypeSymbol) parent.getElement());\n\t\t\tif (classEnv == null) return null;\n\t\t\tType type = (Type) Permit.invokeSneaky(classEnter, enter, tree, classEnv);\n\t\t\tif (type == null) return null;\n\t\t\ttype.complete();\n\t\t\treturn type;\n\t\t}\n\t\t\n\t\tstatic void memberEnter(JCTree tree, JavacNode parent) {\n\t\t\tContext context = parent.getContext();\n\t\t\tMemberEnter me = MemberEnter.instance(context);\n\t\t\tAnnotate annotate = Annotate.instance(context);\n\t\t\tEnter enter = Enter.instance(context);\n\t\t\t\n\t\t\tEnv<AttrContext> classEnv = enter.getEnv((TypeSymbol) parent.getElement());\n\t\t\tif (classEnv == null) return;\n\t\t\t\n\t\t\tPermit.invokeSneaky(blockAnnotations, annotate);\n\t\t\tPermit.invokeSneaky(memberEnter, me, tree, classEnv);\n\t\t\tPermit.invokeSneaky(unblockAnnotations, annotate);\n\t\t}\n\t}\n\t\n\tpublic static long addFinalIfNeeded(long flags, Context context) {\n\t\tboolean addFinal = LombokOptionsFactory.getDelombokOptions(context).getFormatPreferences().generateFinalParams();\n\t\t\n\t\tif (addFinal) flags |= Flags.FINAL;\n\t\treturn flags;\n\t}\n\t\n\tpublic static JCExpression genTypeRef(JavacNode node, String complexName) {\n\t\tString[] parts = complexName.split(\"\\\\.\");\n\t\tif (parts.length > 2 && parts[0].equals(\"java\") && parts[1].equals(\"lang\")) {\n\t\t\tString[] subParts = new String[parts.length - 2];\n\t\t\tSystem.arraycopy(parts, 2, subParts, 0, subParts.length);\n\t\t\treturn genJavaLangTypeRef(node, subParts);\n\t\t}\n\t\t\n\t\treturn chainDots(node, parts);\n\t}\n\t\n\tpublic static JCExpression genJavaLangTypeRef(JavacNode node, String... simpleNames) {\n\t\tif (LombokOptionsFactory.getDelombokOptions(node.getContext()).getFormatPreferences().javaLangAsFqn()) {\n\t\t\treturn chainDots(node, \"java\", \"lang\", simpleNames);\n\t\t} else {\n\t\t\treturn chainDots(node, null, null, simpleNames);\n\t\t}\n\t}\n\t\n\tpublic static JCExpression genJavaLangTypeRef(JavacNode node, int pos, String... simpleNames) {\n\t\tif (LombokOptionsFactory.getDelombokOptions(node.getContext()).getFormatPreferences().javaLangAsFqn()) {\n\t\t\treturn chainDots(node, pos, \"java\", \"lang\", simpleNames);\n\t\t} else {\n\t\t\treturn chainDots(node, pos, null, null, simpleNames);\n\t\t}\n\t}\n\t\n\tpublic static void addSuppressWarningsAll(JCModifiers mods, JavacNode node, JavacNode source, Context context) {\n\t\tif (!LombokOptionsFactory.getDelombokOptions(context).getFormatPreferences().generateSuppressWarnings()) return;\n\t\t\n\t\tboolean addJLSuppress = !Boolean.FALSE.equals(node.getAst().readConfiguration(ConfigurationKeys.ADD_SUPPRESSWARNINGS_ANNOTATIONS));\n\t\t\n\t\tif (addJLSuppress) {\n\t\t\tfor (JCAnnotation ann : mods.annotations) {\n\t\t\t\tJCTree type = ann.getAnnotationType();\n\t\t\t\tName n = null;\n\t\t\t\tif (type instanceof JCIdent) n = ((JCIdent) type).name;\n\t\t\t\telse if (type instanceof JCFieldAccess) n = ((JCFieldAccess) type).name;\n\t\t\t\tif (n != null && n.contentEquals(\"SuppressWarnings\")) {\n\t\t\t\t\taddJLSuppress = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (addJLSuppress) addAnnotation(mods, node, source, \"java.lang.SuppressWarnings\", node.getTreeMaker().Literal(\"all\"));\n\t\t\n\t\tif (Boolean.TRUE.equals(node.getAst().readConfiguration(ConfigurationKeys.ADD_FINDBUGS_SUPPRESSWARNINGS_ANNOTATIONS))) {\n\t\t\tJavacTreeMaker maker = node.getTreeMaker();\n\t\t\tJCExpression arg = maker.Assign(maker.Ident(node.toName(\"justification\")), maker.Literal(\"generated code\"));\n\t\t\taddAnnotation(mods, node, source, \"edu.umd.cs.findbugs.annotations.SuppressFBWarnings\", arg);\n\t\t}\n\t}\n\t\n\tpublic static void addGenerated(JCModifiers mods, JavacNode node, JavacNode source, Context context) {\n\t\tif (!LombokOptionsFactory.getDelombokOptions(context).getFormatPreferences().generateGenerated()) return;\n\t\t\n\t\tif (HandlerUtil.shouldAddGenerated(node)) {\n\t\t\taddAnnotation(mods, node, source, \"javax.annotation.Generated\", node.getTreeMaker().Literal(\"lombok\"));\n\t\t}\n\t\tif (Boolean.TRUE.equals(node.getAst().readConfiguration(ConfigurationKeys.ADD_LOMBOK_GENERATED_ANNOTATIONS))) {\n\t\t\taddAnnotation(mods, node, source, \"lombok.Generated\", null);\n\t\t}\n\t}\n\t\n\tpublic static void addAnnotation(JCModifiers mods, JavacNode node, JavacNode source, String annotationTypeFqn, JCExpression arg) {\n\t\tboolean isJavaLangBased;\n\t\tString simpleName; {\n\t\t\tint idx = annotationTypeFqn.lastIndexOf('.');\n\t\t\tsimpleName = idx == -1 ? annotationTypeFqn : annotationTypeFqn.substring(idx + 1);\n\t\t\t\n\t\t\tisJavaLangBased = idx == 9 && annotationTypeFqn.regionMatches(0, \"java.lang.\", 0, 10);\n\t\t}\n\t\t\n\t\tfor (JCAnnotation ann : mods.annotations) {\n\t\t\tJCTree annType = ann.getAnnotationType();\n\t\t\tif (annType instanceof JCIdent) {\n\t\t\t\tName lastPart = ((JCIdent) annType).name;\n\t\t\t\tif (lastPart.contentEquals(simpleName)) return;\n\t\t\t}\n\t\t\t\n\t\t\tif (annType instanceof JCFieldAccess) {\n\t\t\t\tif (annType.toString().equals(annotationTypeFqn)) return;\n\t\t\t}\n\t\t}\n\t\t\n\t\tJavacTreeMaker maker = node.getTreeMaker();\n\t\tJCExpression annType = isJavaLangBased ? genJavaLangTypeRef(node, simpleName) : chainDotsString(node, annotationTypeFqn);\n\t\tList<JCExpression> argList = arg != null ? List.of(arg) : List.<JCExpression>nil();\n\t\tJCAnnotation annotation = recursiveSetGeneratedBy(maker.Annotation(annType, argList), source);\n\t\tmods.annotations = mods.annotations.append(annotation);\n\t}\n\t\n\tstatic JCExpression addCheckerFrameworkReturnsReceiver(JCExpression returnType, JavacTreeMaker maker, JavacNode typeNode, CheckerFrameworkVersion cfv) {\n\t\tif (cfv.generateReturnsReceiver()) {\n\t\t\tJCAnnotation rrAnnotation = maker.Annotation(genTypeRef(typeNode, CheckerFrameworkVersion.NAME__RETURNS_RECEIVER), List.<JCExpression>nil());\n\t\t\treturnType = maker.AnnotatedType(List.of(rrAnnotation), returnType);\n\t\t}\n\t\treturn returnType;\n\t}\n\t\n\tprivate static List<JCTree> addAllButOne(List<JCTree> defs, int idx) {\n\t\tListBuffer<JCTree> out = new ListBuffer<JCTree>();\n\t\tint i = 0;\n\t\tfor (JCTree def : defs) {\n\t\t\tif (i++ != idx) out.append(def);\n\t\t}\n\t\treturn out.toList();\n\t}\n\t\n\t/**\n\t * In javac, dotted access of any kind, from {@code java.lang.String} to {@code var.methodName}\n\t * is represented by a fold-left of {@code Select} nodes with the leftmost string represented by\n\t * a {@code Ident} node. This method generates such an expression.\n\t * <p>\n\t * The position of the generated node(s) will be unpositioned (-1).\n\t * \n\t * For example, maker.Select(maker.Select(maker.Ident(NAME[java]), NAME[lang]), NAME[String]).\n\t * \n\t * @see com.sun.tools.javac.tree.JCTree.JCIdent\n\t * @see com.sun.tools.javac.tree.JCTree.JCFieldAccess\n\t */\n\tpublic static JCExpression chainDots(JavacNode node, String elem1, String elem2, String... elems) {\n\t\treturn chainDots(node, -1, elem1, elem2, elems);\n\t}\n\t\n\tpublic static JCExpression chainDots(JavacNode node, String[] elems) {\n\t\treturn chainDots(node, -1, null, null, elems);\n\t}\n\t\n\tpublic static JCExpression chainDots(JavacNode node, LombokImmutableList<String> elems) {\n\t\tassert elems != null;\n\t\t\n\t\tJavacTreeMaker maker = node.getTreeMaker();\n\t\tJCExpression e = null;\n\t\tfor (String elem : elems) {\n\t\t\tif (e == null) e = maker.Ident(node.toName(elem));\n\t\t\telse e = maker.Select(e, node.toName(elem));\n\t\t}\n\t\treturn e;\n\t}\n\t\n\t/**\n\t * In javac, dotted access of any kind, from {@code java.lang.String} to {@code var.methodName}\n\t * is represented by a fold-left of {@code Select} nodes with the leftmost string represented by\n\t * a {@code Ident} node. This method generates such an expression.\n\t * <p>\n\t * The position of the generated node(s) will be equal to the {@code pos} parameter.\n\t *\n\t * For example, maker.Select(maker.Select(maker.Ident(NAME[java]), NAME[lang]), NAME[String]).\n\t * \n\t * @see com.sun.tools.javac.tree.JCTree.JCIdent\n\t * @see com.sun.tools.javac.tree.JCTree.JCFieldAccess\n\t */\n\tpublic static JCExpression chainDots(JavacNode node, int pos, String elem1, String elem2, String... elems) {\n\t\tassert elems != null;\n\t\t\n\t\tJavacTreeMaker maker = node.getTreeMaker();\n\t\tif (pos != -1) maker = maker.at(pos);\n\t\tJCExpression e = null;\n\t\tif (elem1 != null) e = maker.Ident(node.toName(elem1));\n\t\tif (elem2 != null) e = e == null ? maker.Ident(node.toName(elem2)) : maker.Select(e, node.toName(elem2));\n\t\tfor (int i = 0 ; i < elems.length ; i++) {\n\t\t\te = e == null ? maker.Ident(node.toName(elems[i])) : maker.Select(e, node.toName(elems[i]));\n\t\t}\n\t\t\n\t\tassert e != null;\n\t\t\n\t\treturn e;\n\t}\n\t\n\t/**\n\t * In javac, dotted access of any kind, from {@code java.lang.String} to {@code var.methodName}\n\t * is represented by a fold-left of {@code Select} nodes with the leftmost string represented by\n\t * a {@code Ident} node. This method generates such an expression.\n\t * \n\t * For example, maker.Select(maker.Select(maker.Ident(NAME[java]), NAME[lang]), NAME[String]).\n\t * \n\t * @see com.sun.tools.javac.tree.JCTree.JCIdent\n\t * @see com.sun.tools.javac.tree.JCTree.JCFieldAccess\n\t */\n\tpublic static JCExpression chainDotsString(JavacNode node, String elems) {\n\t\treturn chainDots(node, null, null, elems.split(\"\\\\.\"));\n\t}\n\t\n\t/**\n\t * Searches the given field node for annotations and returns each one that matches the provided regular expression pattern.\n\t * \n\t * Only the simple name is checked - the package and any containing class are ignored.\n\t */\n\tpublic static List<JCAnnotation> findAnnotations(JavacNode fieldNode, Pattern namePattern) {\n\t\tListBuffer<JCAnnotation> result = new ListBuffer<JCAnnotation>();\n\t\tfor (JavacNode child : fieldNode.down()) {\n\t\t\tif (child.getKind() == Kind.ANNOTATION) {\n\t\t\t\tJCAnnotation annotation = (JCAnnotation) child.get();\n\t\t\t\tString name = annotation.annotationType.toString();\n\t\t\t\tint idx = name.lastIndexOf(\".\");\n\t\t\t\tString suspect = idx == -1 ? name : name.substring(idx + 1);\n\t\t\t\tif (namePattern.matcher(suspect).matches()) {\n\t\t\t\t\tresult.append(annotation);\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\t\treturn result.toList();\n\t}\n\t\n\tpublic static String scanForNearestAnnotation(JavacNode node, String... anns) {\n\t\twhile (node != null) {\n\t\t\tfor (JavacNode ann : node.down()) {\n\t\t\t\tif (ann.getKind() != Kind.ANNOTATION) continue;\n\t\t\t\tJCAnnotation a = (JCAnnotation) ann.get();\n\t\t\t\tfor (String annToFind : anns) if (typeMatches(annToFind, node, a.annotationType)) return annToFind;\n\t\t\t}\n\t\t\tnode = node.up();\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\t\n\tpublic static boolean hasNonNullAnnotations(JavacNode node) {\n\t\tfor (JavacNode child : node.down()) {\n\t\t\tif (child.getKind() == Kind.ANNOTATION) {\n\t\t\t\tJCAnnotation annotation = (JCAnnotation) child.get();\n\t\t\t\tfor (String nn : NONNULL_ANNOTATIONS) if (typeMatches(nn, node, annotation.annotationType)) return true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tpublic static boolean hasNonNullAnnotations(JavacNode node, List<JCAnnotation> anns) {\n\t\tif (anns == null) return false;\n\t\tfor (JCAnnotation ann : anns) {\n\t\t\tfor (String nn : NONNULL_ANNOTATIONS) if (typeMatches(nn, node, ann)) return true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Searches the given field node for annotations and returns each one that is 'copyable' (either via configuration or from the base list).\n\t */\n\tpublic static List<JCAnnotation> findCopyableAnnotations(JavacNode node) {\n\t\tJCAnnotation anno = null;\n\t\tString annoName = null;\n\t\tfor (JavacNode child : node.down()) {\n\t\t\tif (child.getKind() == Kind.ANNOTATION) {\n\t\t\t\tif (anno != null) {\n\t\t\t\t\tannoName = \"\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tJCAnnotation annotation = (JCAnnotation) child.get();\n\t\t\t\tannoName = annotation.annotationType.toString();\n\t\t\t\tanno = annotation;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (annoName == null) return List.nil();\n\t\t\n\t\tjava.util.List<TypeName> configuredCopyable = node.getAst().readConfiguration(ConfigurationKeys.COPYABLE_ANNOTATIONS);\n\t\t\n\t\tif (!annoName.isEmpty()) {\n\t\t\tfor (TypeName cn : configuredCopyable) if (cn != null && typeMatches(cn.toString(), node, anno.annotationType)) return List.of(anno);\n\t\t\tfor (String bn : BASE_COPYABLE_ANNOTATIONS) if (typeMatches(bn, node, anno.annotationType)) return List.of(anno);\n\t\t}\n\t\t\n\t\tListBuffer<JCAnnotation> result = new ListBuffer<JCAnnotation>();\n\t\tfor (JavacNode child : node.down()) {\n\t\t\tif (child.getKind() == Kind.ANNOTATION) {\n\t\t\t\tJCAnnotation annotation = (JCAnnotation) child.get();\n\t\t\t\tboolean match = false;\n\t\t\t\tfor (TypeName cn : configuredCopyable) if (cn != null && typeMatches(cn.toString(), node, annotation.annotationType)) {\n\t\t\t\t\tresult.append(annotation);\n\t\t\t\t\tmatch = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!match) for (String bn : BASE_COPYABLE_ANNOTATIONS) if (typeMatches(bn, node, annotation.annotationType)) {\n\t\t\t\t\tresult.append(annotation);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result.toList();\n\t}\n\t\n\t/**\n\t * Searches the given field node for annotations that are specifically intentioned to be copied to the setter.\n\t */\n\tpublic static List<JCAnnotation> findCopyableToSetterAnnotations(JavacNode node) {\n\t\treturn findAnnotationsInList(node, COPY_TO_SETTER_ANNOTATIONS);\n\t}\n\n\t/**\n\t * Searches the given field node for annotations that are specifically intentioned to be copied to the builder's singular method.\n\t */\n\tpublic static List<JCAnnotation> findCopyableToBuilderSingularSetterAnnotations(JavacNode node) {\n\t\treturn findAnnotationsInList(node, COPY_TO_BUILDER_SINGULAR_SETTER_ANNOTATIONS);\n\t}\n\t\n\t/**\n\t * Searches the given field node for annotations that are in the given list, and returns those.\n\t */\n\tprivate static List<JCAnnotation> findAnnotationsInList(JavacNode node, java.util.List<String> annotationsToFind) {\n\t\tJCAnnotation anno = null;\n\t\tString annoName = null;\n\t\tfor (JavacNode child : node.down()) {\n\t\t\tif (child.getKind() == Kind.ANNOTATION) {\n\t\t\t\tif (anno != null) {\n\t\t\t\t\tannoName = \"\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tJCAnnotation annotation = (JCAnnotation) child.get();\n\t\t\t\tannoName = annotation.annotationType.toString();\n\t\t\t\tanno = annotation;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (annoName == null) return List.nil();\n\t\t\n\t\tif (!annoName.isEmpty()) {\n\t\t\tfor (String bn : annotationsToFind) if (typeMatches(bn, node, anno.annotationType)) return List.of(anno);\n\t\t}\n\t\t\n\t\tListBuffer<JCAnnotation> result = new ListBuffer<JCAnnotation>();\n\t\tfor (JavacNode child : node.down()) {\n\t\t\tif (child.getKind() == Kind.ANNOTATION) {\n\t\t\t\tJCAnnotation annotation = (JCAnnotation) child.get();\n\t\t\t\tboolean match = false;\n\t\t\t\tif (!match) for (String bn : annotationsToFind) if (typeMatches(bn, node, annotation.annotationType)) {\n\t\t\t\t\tresult.append(annotation);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result.toList();\n\t}\n\t\n\t/**\n\t * Generates a new statement that checks if the given variable is null, and if so, throws a configured exception with the\n\t * variable name as message.\n\t */\n\tpublic static JCStatement generateNullCheck(JavacTreeMaker maker, JavacNode variable, JavacNode source) {\n\t\treturn generateNullCheck(maker, (JCVariableDecl) variable.get(), source);\n\t}\n\t\n\t/**\n\t * Generates a new statement that checks if the given local is null, and if so, throws a configured exception with the\n\t * local variable name as message. \n\t */\n\tpublic static JCStatement generateNullCheck(JavacTreeMaker maker, JCExpression typeNode, Name varName, JavacNode source, String customMessage) {\n\t\tNullCheckExceptionType exceptionType = source.getAst().readConfiguration(ConfigurationKeys.NON_NULL_EXCEPTION_TYPE);\n\t\tif (exceptionType == null) exceptionType = NullCheckExceptionType.NULL_POINTER_EXCEPTION;\n\t\t\n\t\tif (typeNode != null && isPrimitive(typeNode)) return null;\n\t\tJCLiteral message = maker.Literal(exceptionType.toExceptionMessage(varName.toString(), customMessage));\n\t\t\n\t\tLombokImmutableList<String> method = exceptionType.getMethod();\n\t\tif (method != null) {\n\t\t\treturn maker.Exec(maker.Apply(List.<JCExpression>nil(), chainDots(source, method), List.of(maker.Ident(varName), message)));\n\t\t}\n\t\t\n\t\tif (exceptionType == NullCheckExceptionType.ASSERTION) {\n\t\t\treturn maker.Assert(maker.Binary(CTC_NOT_EQUAL, maker.Ident(varName), maker.Literal(CTC_BOT, null)), message);\n\t\t}\n\t\t\n\t\tJCExpression exType = genTypeRef(source, exceptionType.getExceptionType());\n\t\tJCExpression exception = maker.NewClass(null, List.<JCExpression>nil(), exType, List.<JCExpression>of(message), null);\n\t\tJCStatement throwStatement = maker.Throw(exception);\n\t\tJCBlock throwBlock = maker.Block(0, List.of(throwStatement));\n\t\treturn maker.If(maker.Binary(CTC_EQUAL, maker.Ident(varName), maker.Literal(CTC_BOT, null)), throwBlock, null);\n\t}\n\t\n\t/**\n\t * Generates a new statement that checks if the given variable is null, and if so, throws a configured exception with the\n\t * variable name as message. \n\t * \n\t * This is a special case method reserved for use when the provided declaration differs from the\n\t * variable's declaration, i.e. in a constructor or setter where the local parameter is named the same but with the prefix\n\t * stripped as a result of @Accessors.prefix.\n\t */\n\tpublic static JCStatement generateNullCheck(JavacTreeMaker maker, JCVariableDecl varDecl, JavacNode source) {\n\t\treturn generateNullCheck(maker, varDecl.vartype, varDecl.name, source, null);\n\t}\n\t\n\t/**\n\t * Given a list of field names and a node referring to a type, finds each name in the list that does not match a field within the type.\n\t */\n\tpublic static List<Integer> createListOfNonExistentFields(List<String> list, JavacNode type, boolean excludeStandard, boolean excludeTransient) {\n\t\tboolean[] matched = new boolean[list.size()];\n\t\t\n\t\tfor (JavacNode child : type.down()) {\n\t\t\tif (list.isEmpty()) break;\n\t\t\tif (child.getKind() != Kind.FIELD) continue;\n\t\t\tJCVariableDecl field = (JCVariableDecl)child.get();\n\t\t\tif (excludeStandard) {\n\t\t\t\tif ((field.mods.flags & Flags.STATIC) != 0) continue;\n\t\t\t\tif (field.name.toString().startsWith(\"$\")) continue;\n\t\t\t}\n\t\t\tif (excludeTransient && (field.mods.flags & Flags.TRANSIENT) != 0) continue;\n\t\t\t\n\t\t\tint idx = list.indexOf(child.getName());\n\t\t\tif (idx > -1) matched[idx] = true;\n\t\t}\n\t\t\n\t\tListBuffer<Integer> problematic = new ListBuffer<Integer>();\n\t\tfor (int i = 0 ; i < list.size() ; i++) {\n\t\t\tif (!matched[i]) problematic.append(i);\n\t\t}\n\t\t\n\t\treturn problematic.toList();\n\t}\n\t\n\tstatic List<JCAnnotation> unboxAndRemoveAnnotationParameter(JCAnnotation ast, String parameterName, String errorName, JavacNode annotationNode) {\n\t\tListBuffer<JCExpression> params = new ListBuffer<JCExpression>();\n\t\tListBuffer<JCAnnotation> result = new ListBuffer<JCAnnotation>();\n\t\t\n\t\touter:\n\t\tfor (JCExpression param : ast.args) {\n\t\t\tboolean allowRaw;\n\t\t\tString nameOfParam = \"value\";\n\t\t\tJCExpression valueOfParam = null;\n\t\t\tif (param instanceof JCAssign) {\n\t\t\t\tJCAssign assign = (JCAssign) param;\n\t\t\t\tif (assign.lhs instanceof JCIdent) {\n\t\t\t\t\tJCIdent ident = (JCIdent) assign.lhs;\n\t\t\t\t\tnameOfParam = ident.name.toString();\n\t\t\t\t}\n\t\t\t\tvalueOfParam = assign.rhs;\n\t\t\t}\n\t\t\t\n\t\t\t/* strip trailing underscores */ {\n\t\t\t\tint lastIdx;\n\t\t\t\tfor (lastIdx = nameOfParam.length() ; lastIdx > 0; lastIdx--) {\n\t\t\t\t\tif (nameOfParam.charAt(lastIdx - 1) != '_') break;\n\t\t\t\t}\n\t\t\t\tallowRaw = lastIdx < nameOfParam.length();\n\t\t\t\tnameOfParam = nameOfParam.substring(0, lastIdx);\n\t\t\t}\n\t\t\t\n\t\t\tif (!parameterName.equals(nameOfParam)) {\n\t\t\t\tparams.append(param);\n\t\t\t\tcontinue outer;\n\t\t\t}\n\t\t\t\n\t\t\tint endPos = Javac.getEndPosition(param.pos(), (JCCompilationUnit) annotationNode.top().get());\n\t\t\tannotationNode.getAst().removeFromDeferredDiagnostics(param.pos, endPos);\n\t\t\t\n\t\t\tif (valueOfParam instanceof JCAnnotation) {\n\t\t\t\tString dummyAnnotationName = ((JCAnnotation) valueOfParam).annotationType.toString();\n\t\t\t\tdummyAnnotationName = dummyAnnotationName.replace(\"_\", \"\").replace(\"$\", \"\").replace(\"x\", \"\").replace(\"X\", \"\");\n\t\t\t\tif (dummyAnnotationName.length() > 0) {\n\t\t\t\t\tif (allowRaw) {\n\t\t\t\t\t\tresult.append((JCAnnotation) valueOfParam);\n\t\t\t\t\t} else {\n\t\t\t\t\t\taddError(errorName, annotationNode);\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (JCExpression expr : ((JCAnnotation) valueOfParam).args) {\n\t\t\t\t\t\tif (expr instanceof JCAssign && ((JCAssign) expr).lhs instanceof JCIdent) {\n\t\t\t\t\t\t\tJCIdent id = (JCIdent) ((JCAssign) expr).lhs;\n\t\t\t\t\t\t\tif (\"value\".equals(id.name.toString())) {\n\t\t\t\t\t\t\t\texpr = ((JCAssign) expr).rhs;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\taddError(errorName, annotationNode);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (expr instanceof JCAnnotation) {\n\t\t\t\t\t\t\tresult.append((JCAnnotation) expr);\n\t\t\t\t\t\t} else if (expr instanceof JCNewArray) {\n\t\t\t\t\t\t\tfor (JCExpression expr2 : ((JCNewArray) expr).elems) {\n\t\t\t\t\t\t\t\tif (expr2 instanceof JCAnnotation) {\n\t\t\t\t\t\t\t\t\tresult.append((JCAnnotation) expr2);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\taddError(errorName, annotationNode);\n\t\t\t\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\taddError(errorName, annotationNode);\n\t\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (valueOfParam instanceof JCNewArray) {\n\t\t\t\tJCNewArray arr = (JCNewArray) valueOfParam;\n\t\t\t\tif (arr.elems.isEmpty()) {\n\t\t\t\t\t// Just remove it, this is always fine.\n\t\t\t\t} else if (allowRaw) {\n\t\t\t\t\tfor (JCExpression jce : arr.elems) {\n\t\t\t\t\t\tif (jce instanceof JCAnnotation) result.append((JCAnnotation) jce);\n\t\t\t\t\t\telse addError(errorName, annotationNode);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\taddError(errorName, annotationNode);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\taddError(errorName, annotationNode);\n\t\t\t}\n\t\t}\n\t\tfor (JCAnnotation annotation : result) {\n\t\t\tclearTypes(annotation);\n\t\t}\n\t\tast.args = params.toList();\n\t\treturn result.toList();\n\t}\n\t\n\t/**\n\t * Removes all type information from the provided tree.\n\t */\n\tprivate static void clearTypes(JCTree tree) {\n\t\ttree.accept(new TreeScanner() {\n\t\t\t@Override public void scan(JCTree tree) {\n\t\t\t\tif (tree == null) return;\n\t\t\t\ttree.type = null;\n\t\t\t\tsuper.scan(tree);\n\t\t\t}\n\t\t\t@Override public void visitClassDef(JCClassDecl tree) {\n\t\t\t\ttree.sym = null;\n\t\t\t\tsuper.visitClassDef(tree);\n\t\t\t}\n\t\t\t@Override public void visitMethodDef(JCMethodDecl tree) {\n\t\t\t\ttree.sym = null;\n\t\t\t\tsuper.visitMethodDef(tree);\n\t\t\t}\n\t\t\t@Override public void visitVarDef(JCVariableDecl tree) {\n\t\t\t\ttree.sym = null;\n\t\t\t\tsuper.visitVarDef(tree);\n\t\t\t}\n\t\t\t@Override public void visitSelect(JCFieldAccess tree) {\n\t\t\t\ttree.sym = null;\n\t\t\t\tsuper.visitSelect(tree);\n\t\t\t}\n\t\t\t@Override public void visitIdent(JCIdent tree) {\n\t\t\t\ttree.sym = null;\n\t\t\t\tsuper.visitIdent(tree);\n\t\t\t}\n\t\t\t@Override public void visitAnnotation(JCAnnotation tree) {\n\t\t\t\tJCAnnotationReflect.setAttribute(tree, null);\n\t\t\t\tsuper.visitAnnotation(tree);\n\t\t\t}\n\t\t});\n\t}\n\t\n\tprivate static void addError(String errorName, JavacNode node) {\n\t\tif (node.getLatestJavaSpecSupported() < 8) {\n\t\t\tnode.addError(\"The correct format up to JDK7 is \" + errorName + \"=@__({@SomeAnnotation, @SomeOtherAnnotation}))\");\n\t\t} else {\n\t\t\tnode.addError(\"The correct format for JDK8+ is \" + errorName + \"_={@SomeAnnotation, @SomeOtherAnnotation})\");\n\t\t}\n\t}\n\t\n\tpublic static List<JCTypeParameter> copyTypeParams(JavacNode source, List<JCTypeParameter> params) {\n\t\tif (params == null || params.isEmpty()) return params;\n\t\tListBuffer<JCTypeParameter> out = new ListBuffer<JCTypeParameter>();\n\t\tJavacTreeMaker maker = source.getTreeMaker();\n\t\tfor (JCTypeParameter tp : params) {\n\t\t\tList<JCExpression> bounds = tp.bounds;\n\t\t\tif (bounds != null && !bounds.isEmpty()) {\n\t\t\t\tListBuffer<JCExpression> boundsCopy = new ListBuffer<JCExpression>();\n\t\t\t\tfor (JCExpression expr : tp.bounds) {\n\t\t\t\t\tboundsCopy.append(cloneType(maker, expr, source));\n\t\t\t\t}\n\t\t\t\tbounds = boundsCopy.toList();\n\t\t\t}\n\t\t\tout.append(maker.TypeParameter(tp.name, bounds));\n\t\t}\n\t\treturn out.toList();\n\t}\n\t\n\tpublic static List<JCAnnotation> getTypeUseAnnotations(JCExpression from) {\n\t\tif (!JCAnnotatedTypeReflect.is(from)) return List.nil();\n\t\treturn JCAnnotatedTypeReflect.getAnnotations(from);\n\t}\n\t\n\tpublic static JCExpression removeTypeUseAnnotations(JCExpression from) {\n\t\tif (!JCAnnotatedTypeReflect.is(from)) return from;\n\t\treturn JCAnnotatedTypeReflect.getUnderlyingType(from);\n\t}\n\t\n\tpublic static JCExpression namePlusTypeParamsToTypeReference(JavacTreeMaker maker, JavacNode type, List<JCTypeParameter> params) {\n\t\tJCClassDecl td = (JCClassDecl) type.get();\n\t\tboolean instance = (td.mods.flags & Flags.STATIC) == 0;\n\t\treturn namePlusTypeParamsToTypeReference(maker, type.up(), td.name, instance, params, List.<JCAnnotation>nil());\n\t}\n\t\n\tpublic static JCExpression namePlusTypeParamsToTypeReference(JavacTreeMaker maker, JavacNode type, List<JCTypeParameter> params, List<JCAnnotation> annotations) {\n\t\tJCClassDecl td = (JCClassDecl) type.get();\n\t\tboolean instance = (td.mods.flags & Flags.STATIC) == 0;\n\t\treturn namePlusTypeParamsToTypeReference(maker, type.up(), td.name, instance, params, annotations);\n\t}\n\t\n\tpublic static JCExpression namePlusTypeParamsToTypeReference(JavacTreeMaker maker, JavacNode parentType, Name typeName, boolean instance, List<JCTypeParameter> params) {\n\t\treturn namePlusTypeParamsToTypeReference(maker, parentType, typeName, instance, params, List.<JCAnnotation>nil());\n\t}\n\t\n\tpublic static JCExpression namePlusTypeParamsToTypeReference(JavacTreeMaker maker, JavacNode parentType, Name typeName, boolean instance, List<JCTypeParameter> params, List<JCAnnotation> annotations) {\n\t\tJCExpression r = null;\n\t\tif (parentType != null && parentType.getKind() == Kind.TYPE && !parentType.getName().isEmpty()) {\n\t\t\tJCClassDecl td = (JCClassDecl) parentType.get();\n\t\t\tboolean outerInstance = instance && ((td.mods.flags & Flags.STATIC) == 0);\n\t\t\tList<JCTypeParameter> outerParams = instance ? td.typarams : List.<JCTypeParameter>nil();\n\t\t\tr = namePlusTypeParamsToTypeReference(maker, parentType.up(), td.name, outerInstance, outerParams, List.<JCAnnotation>nil());\n\t\t}\n\t\t\n\t\tr = r == null ? maker.Ident(typeName) : maker.Select(r, typeName);\n\t\tif (!annotations.isEmpty()) r = JCAnnotatedTypeReflect.create(annotations, r);\n\t\tif (!params.isEmpty()) r = maker.TypeApply(r, typeParameterNames(maker, params));\n\t\treturn r;\n\t}\n\t\n\tpublic static List<JCExpression> typeParameterNames(JavacTreeMaker maker, List<JCTypeParameter> params) {\n\t\tListBuffer<JCExpression> typeArgs = new ListBuffer<JCExpression>();\n\t\tfor (JCTypeParameter param : params) {\n\t\t\ttypeArgs.append(maker.Ident(param.name));\n\t\t}\n\t\treturn typeArgs.toList();\n\t}\n\t\n\tpublic static void sanityCheckForMethodGeneratingAnnotationsOnBuilderClass(JavacNode typeNode, JavacNode errorNode) {\n\t\tList<String> disallowed = List.nil();\n\t\tfor (JavacNode child : typeNode.down()) {\n\t\t\tfor (String annType : INVALID_ON_BUILDERS) {\n\t\t\t\tif (annotationTypeMatches(annType, child)) {\n\t\t\t\t\tint lastIndex = annType.lastIndexOf('.');\n\t\t\t\t\tdisallowed = disallowed.append(lastIndex == -1 ? annType : annType.substring(lastIndex + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint size = disallowed.size();\n\t\tif (size == 0) return;\n\t\tif (size == 1) {\n\t\t\terrorNode.addError(\"@\" + disallowed.head + \" is not allowed on builder classes.\");\n\t\t\treturn;\n\t\t}\n\t\tStringBuilder out = new StringBuilder();\n\t\tfor (String a : disallowed) out.append(\"@\").append(a).append(\", \");\n\t\tout.setLength(out.length() - 2);\n\t\terrorNode.addError(out.append(\" are not allowed on builder classes.\").toString());\n\t}\n\t\n\tstatic List<JCAnnotation> copyAnnotations(List<? extends JCExpression> in) {\n\t\tListBuffer<JCAnnotation> out = new ListBuffer<JCAnnotation>();\n\t\tfor (JCExpression expr : in) {\n\t\t\tif (!(expr instanceof JCAnnotation)) continue;\n\t\t\tout.append((JCAnnotation) expr.clone());\n\t\t}\n\t\treturn out.toList();\n\t}\n\t\n\tstatic List<JCAnnotation> mergeAnnotations(List<JCAnnotation> a, List<JCAnnotation> b) {\n\t\tif (a == null || a.isEmpty()) return b;\n\t\tif (b == null || b.isEmpty()) return a;\n\t\tListBuffer<JCAnnotation> out = new ListBuffer<JCAnnotation>();\n\t\tfor (JCAnnotation ann : a) out.append(ann);\n\t\tfor (JCAnnotation ann : b) out.append(ann);\n\t\treturn out.toList();\n\t}\n\t\n\t/**\n\t * Returns {@code true} if the provided node is an actual class and not some other type declaration (so, not an annotation definition, interface, enum, or record).\n\t */\n\tpublic static boolean isClass(JavacNode typeNode) {\n\t\treturn isClassAndDoesNotHaveFlags(typeNode, Flags.INTERFACE | Flags.ENUM | Flags.ANNOTATION | RECORD);\n\t}\n\t\n\t/**\n\t * Returns {@code true} if the provided node is an actual class or enum and not some other type declaration (so, not an annotation definition, interface, or record).\n\t */\n\tpublic static boolean isClassOrEnum(JavacNode typeNode) {\n\t\treturn isClassAndDoesNotHaveFlags(typeNode, Flags.INTERFACE | Flags.ANNOTATION | RECORD);\n\t}\n\t\n\tpublic static boolean isClassOrEnumOrInterface(JavacNode typeNode) {\n\t\treturn isClassAndDoesNotHaveFlags(typeNode, Flags.ANNOTATION | RECORD);\n\t}\n\t\n\t/**\n\t * Returns {@code true} if the provided node is an actual class, an enum or a record and not some other type declaration (so, not an annotation definition or interface).\n\t */\n\tpublic static boolean isClassEnumOrRecord(JavacNode typeNode) {\n\t\treturn isClassAndDoesNotHaveFlags(typeNode, Flags.INTERFACE | Flags.ANNOTATION);\n\t}\n\t\n\t/**\n\t * Returns {@code true} if the provided node is a record declaration (so, not an annotation definition, interface, enum, or plain class).\n\t */\n\tpublic static boolean isRecord(JavacNode typeNode) {\n\t\treturn typeNode.getKind() == Kind.TYPE && (((JCClassDecl) typeNode.get()).mods.flags & RECORD) != 0;\n\t}\n\t\n\tpublic static boolean isClassAndDoesNotHaveFlags(JavacNode typeNode, long flags) {\n\t\tJCClassDecl typeDecl = null;\n\t\tif (typeNode.get() instanceof JCClassDecl) typeDecl = (JCClassDecl) typeNode.get();\n\t\telse return false;\n\t\t\n\t\tlong typeDeclflags = typeDecl == null ? 0 : typeDecl.mods.flags;\n\t\treturn (typeDeclflags & flags) == 0;\n\t}\n\t\n\t/**\n\t * Returns {@code true} if the provided node supports static methods and types (top level or static class)\n\t */\n\tpublic static boolean isStaticAllowed(JavacNode typeNode) {\n\t\treturn typeNode.isStatic() || typeNode.up() == null || typeNode.up().getKind() == Kind.COMPILATION_UNIT || isRecord(typeNode);\n\t}\n\t\n\tpublic static JavacNode upToTypeNode(JavacNode node) {\n\t\tif (node == null) throw new NullPointerException(\"node\");\n\t\twhile ((node != null) && !(node.get() instanceof JCClassDecl)) node = node.up();\n\t\t\n\t\treturn node;\n\t}\n\t\n\tpublic static List<JCExpression> cloneTypes(JavacTreeMaker maker, List<JCExpression> in, JavacNode source) {\n\t\tif (in.isEmpty()) return List.nil();\n\t\tif (in.size() == 1) return List.of(cloneType(maker, in.get(0), source));\n\t\tListBuffer<JCExpression> lb = new ListBuffer<JCExpression>();\n\t\tfor (JCExpression expr : in) lb.append(cloneType(maker, expr, source));\n\t\treturn lb.toList();\n\t}\n\t\n\t/**\n\t * Creates a full clone of a given javac AST type node. Every part is cloned (every identifier, every select, every wildcard, every type apply, every type_use annotation).\n\t * \n\t * If there's any node in the tree that we don't know how to clone, that part isn't cloned. However, we wouldn't know what could possibly show up that we\n\t * can't currently clone; that's just a safeguard.\n\t * \n\t * This should be used if the type looks the same in the code, but resolves differently. For example, a static method that has some generics in it named after\n\t * the class's own parameter, but as its a static method, the static method's notion of {@code T} is different from the class notion of {@code T}. If you're duplicating\n\t * a type used in the class context, you need to use this method.\n\t */\n\tpublic static JCExpression cloneType(JavacTreeMaker maker, JCExpression in, JavacNode source) {\n\t\tJCExpression out = cloneType0(maker, in);\n\t\tif (out != null) recursiveSetGeneratedBy(out, source);\n\t\treturn out;\n\t}\n\t\n\tprivate static JCExpression cloneType0(JavacTreeMaker maker, JCTree in) {\n\t\tif (in == null) return null;\n\t\t\n\t\tif (in instanceof JCPrimitiveTypeTree) {\n\t\t\treturn maker.TypeIdent(TypeTag.typeTag(in));\n\t\t}\n\t\t\n\t\tif (in instanceof JCIdent) {\n\t\t\treturn maker.Ident(((JCIdent) in).name);\n\t\t}\n\t\t\n\t\tif (in instanceof JCFieldAccess) {\n\t\t\tJCFieldAccess fa = (JCFieldAccess) in;\n\t\t\treturn maker.Select(cloneType0(maker, fa.selected), fa.name);\n\t\t}\n\t\t\n\t\tif (in instanceof JCArrayTypeTree) {\n\t\t\tJCArrayTypeTree att = (JCArrayTypeTree) in;\n\t\t\treturn maker.TypeArray(cloneType0(maker, att.elemtype));\n\t\t}\n\t\t\n\t\tif (in instanceof JCTypeApply) {\n\t\t\tJCTypeApply ta = (JCTypeApply) in;\n\t\t\tListBuffer<JCExpression> lb = new ListBuffer<JCExpression>();\n\t\t\tfor (JCExpression typeArg : ta.arguments) {\n\t\t\t\tlb.append(cloneType0(maker, typeArg));\n\t\t\t}\n\t\t\treturn maker.TypeApply(cloneType0(maker, ta.clazz), lb.toList());\n\t\t}\n\t\t\n\t\tif (in instanceof JCWildcard) {\n\t\t\tJCWildcard w = (JCWildcard) in;\n\t\t\tJCExpression newInner = cloneType0(maker, w.inner);\n\t\t\tTypeBoundKind newKind;\n\t\t\tswitch (w.getKind()) {\n\t\t\tcase SUPER_WILDCARD:\n\t\t\t\tnewKind = maker.TypeBoundKind(BoundKind.SUPER);\n\t\t\t\tbreak;\n\t\t\tcase EXTENDS_WILDCARD:\n\t\t\t\tnewKind = maker.TypeBoundKind(BoundKind.EXTENDS);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\tcase UNBOUNDED_WILDCARD:\n\t\t\t\tnewKind = maker.TypeBoundKind(BoundKind.UNBOUND);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn maker.Wildcard(newKind, newInner);\n\t\t}\n\t\t\n\t\tif (JCAnnotatedTypeReflect.is(in)) {\n\t\t\tJCExpression underlyingType = cloneType0(maker, JCAnnotatedTypeReflect.getUnderlyingType(in));\n\t\t\tList<JCAnnotation> anns = copyAnnotations(JCAnnotatedTypeReflect.getAnnotations(in));\n\t\t\treturn JCAnnotatedTypeReflect.create(anns, underlyingType);\n\t\t}\n\t\t\n\t\t// This is somewhat unsafe, but it's better than outright throwing an exception here. Returning null will just cause an exception down the pipeline.\n\t\treturn (JCExpression) in;\n\t}\n\t\n\tpublic static enum CopyJavadoc {\n\t\tVERBATIM {\n\t\t\t@Override public String apply(final JCCompilationUnit cu, final JavacNode node) {\n\t\t\t\treturn Javac.getDocComment(cu, node.get());\n\t\t\t}\n\t\t},\n\t\tGETTER {\n\t\t\t@Override public String apply(final JCCompilationUnit cu, final JavacNode node) {\n\t\t\t\tfinal JCTree n = node.get();\n\t\t\t\tString javadoc = Javac.getDocComment(cu, n);\n\t\t\t\t// step 1: Check if there is a 'GETTER' section. If yes, that becomes the new method's javadoc.\n\t\t\t\tString out = getJavadocSection(javadoc, \"GETTER\");\n\t\t\t\tfinal boolean sectionBased = out != null;\n\t\t\t\tif (!sectionBased) {\n\t\t\t\t\tout = stripLinesWithTagFromJavadoc(stripSectionsFromJavadoc(javadoc), JavadocTag.PARAM);\n\t\t\t\t}\n\t\t\t\tnode.getAst().cleanupTask(\"javadocfilter-getter\", n, new CleanupTask() {\n\t\t\t\t\t@Override public void cleanup() {\n\t\t\t\t\t\tString javadoc = Javac.getDocComment(cu, n);\n\t\t\t\t\t\tif (javadoc == null || javadoc.isEmpty()) return;\n\t\t\t\t\t\tjavadoc = stripSectionsFromJavadoc(javadoc);\n\t\t\t\t\t\tif (!sectionBased) {\n\t\t\t\t\t\t\tjavadoc = stripLinesWithTagFromJavadoc(stripSectionsFromJavadoc(javadoc), JavadocTag.RETURN);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tJavac.setDocComment(cu, n, javadoc);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn out;\n\t\t\t}\n\t\t},\n\t\tSETTER {\n\t\t\t@Override public String apply(final JCCompilationUnit cu, final JavacNode node) {\n\t\t\t\treturn applySetter(cu, node, \"SETTER\");\n\t\t\t}\n\t\t},\n\t\tWITH {\n\t\t\t@Override public String apply(final JCCompilationUnit cu, final JavacNode node) {\n\t\t\t\treturn addReturnsUpdatedSelfIfNeeded(applySetter(cu, node, \"WITH|WITHER\"));\n\t\t\t}\n\t\t},\n\t\tWITH_BY {\n\t\t\t@Override public String apply(final JCCompilationUnit cu, final JavacNode node) {\n\t\t\t\treturn applySetter(cu, node, \"WITHBY|WITH_BY\");\n\t\t\t}\n\t\t};\n\t\t\n\t\tpublic abstract String apply(final JCCompilationUnit cu, final JavacNode node);\n\t\t\n\t\tprivate static String applySetter(final JCCompilationUnit cu, JavacNode node, String sectionName) {\n\t\t\tfinal JCTree n = node.get();\n\t\t\tString javadoc = Javac.getDocComment(cu, n);\n\t\t\t// step 1: Check if there is a 'SETTER' section. If yes, that becomes the new method's javadoc.\n\t\t\tString out = getJavadocSection(javadoc, sectionName);\n\t\t\tfinal boolean sectionBased = out != null;\n\t\t\tif (!sectionBased) {\n\t\t\t\tout = stripLinesWithTagFromJavadoc(stripSectionsFromJavadoc(javadoc), JavadocTag.RETURN);\n\t\t\t}\n\t\t\tnode.getAst().cleanupTask(\"javadocfilter-setter\", n, new CleanupTask() {\n\t\t\t\t@Override public void cleanup() {\n\t\t\t\t\tString javadoc = Javac.getDocComment(cu, n);\n\t\t\t\t\tif (javadoc == null || javadoc.isEmpty()) return;\n\t\t\t\t\tjavadoc = stripSectionsFromJavadoc(javadoc);\n\t\t\t\t\tif (!sectionBased) {\n\t\t\t\t\t\tjavadoc = stripLinesWithTagFromJavadoc(stripSectionsFromJavadoc(javadoc), JavadocTag.PARAM);\n\t\t\t\t\t}\n\t\t\t\t\tJavac.setDocComment(cu, n, javadoc);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn shouldReturnThis(node, JavacHandlerUtil.getAccessorsForField(node)) ? addReturnsThisIfNeeded(out) : out;\n\t\t}\n\t}\n\t\n\tpublic static void copyJavadoc(JavacNode from, JCTree to, CopyJavadoc copyMode) {\n\t\tcopyJavadoc(from, to, copyMode, false);\n\t}\n\t\n\t/**\n\t * Copies javadoc on one node to the other.\n\t * \n\t * in 'GETTER' copyMode, first a 'GETTER' segment is searched for. If it exists, that will become the javadoc for the 'to' node, and this section is\n\t * stripped out of the 'from' node. If no 'GETTER' segment is found, then the entire javadoc is taken minus any {@code @param} lines and other sections.\n\t * any {@code @return} lines are stripped from 'from'.\n\t * \n\t * in 'SETTER' mode, stripping works similarly to 'GETTER' mode, except {@code param} are copied and stripped from the original and {@code @return} are skipped.\n\t */\n\tpublic static void copyJavadoc(JavacNode from, JCTree to, CopyJavadoc copyMode, boolean forceAddReturn) {\n\t\tif (copyMode == null) copyMode = CopyJavadoc.VERBATIM;\n\t\ttry {\n\t\t\tJCCompilationUnit cu = ((JCCompilationUnit) from.top().get());\n\t\t\tString newJavadoc = copyMode.apply(cu, from);\n\t\t\tif (forceAddReturn) {\n\t\t\t\tnewJavadoc = addReturnsThisIfNeeded(newJavadoc);\n\t\t\t}\n\t\t\tJavac.setDocComment(cu, to, newJavadoc);\n\t\t} catch (Exception ignore) {}\n\t}\n\t\n\tpublic static boolean isDirectDescendantOfObject(JavacNode typeNode) {\n\t\tif (!(typeNode.get() instanceof JCClassDecl)) throw new IllegalArgumentException(\"not a type node\");\n\t\tJCTree extending = Javac.getExtendsClause((JCClassDecl) typeNode.get());\n\t\tif (extending == null) return true;\n\t\tString p = extending.toString();\n\t\treturn p.equals(\"Object\") || p.equals(\"java.lang.Object\");\n\t}\n\t\n\tpublic static void createRelevantNullableAnnotation(JavacNode typeNode, JCMethodDecl mth) {\n\t\tNullAnnotationLibrary lib = typeNode.getAst().readConfiguration(ConfigurationKeys.ADD_NULL_ANNOTATIONS);\n\t\tif (lib == null) return;\n\t\tapplyAnnotationToMethodDecl(typeNode, mth, lib.getNullableAnnotation(), lib.isTypeUse());\n\t}\n\t\n\tpublic static void createRelevantNonNullAnnotation(JavacNode typeNode, JCMethodDecl mth) {\n\t\tNullAnnotationLibrary lib = typeNode.getAst().readConfiguration(ConfigurationKeys.ADD_NULL_ANNOTATIONS);\n\t\tif (lib == null) return;\n\t\tapplyAnnotationToMethodDecl(typeNode, mth, lib.getNonNullAnnotation(), lib.isTypeUse());\n\t}\n\t\n\tpublic static void createRelevantNonNullAnnotation(JavacNode typeNode, JCVariableDecl arg) {\n\t\tNullAnnotationLibrary lib = typeNode.getAst().readConfiguration(ConfigurationKeys.ADD_NULL_ANNOTATIONS);\n\t\tif (lib == null) return;\n\t\t\n\t\tapplyAnnotationToVarDecl(typeNode, arg, lib.getNonNullAnnotation(), lib.isTypeUse());\n\t}\n\t\n\tpublic static void createRelevantNullableAnnotation(JavacNode typeNode, JCVariableDecl arg) {\n\t\tNullAnnotationLibrary lib = typeNode.getAst().readConfiguration(ConfigurationKeys.ADD_NULL_ANNOTATIONS);\n\t\tif (lib == null) return;\n\t\t\n\t\tapplyAnnotationToVarDecl(typeNode, arg, lib.getNullableAnnotation(), lib.isTypeUse());\n\t}\n\t\n\tprivate static void applyAnnotationToMethodDecl(JavacNode typeNode, JCMethodDecl mth, String annType, boolean typeUse) {\n\t\tif (annType == null) return;\n\t\tJavacTreeMaker maker = typeNode.getTreeMaker();\n\t\t\n\t\tJCAnnotation m = maker.Annotation(genTypeRef(typeNode, annType), List.<JCExpression>nil());\n\t\tif (typeUse) {\n\t\t\tJCExpression resType = mth.restype;\n\t\t\tif (resType instanceof JCTypeApply) {\n\t\t\t\tJCTypeApply ta = (JCTypeApply) resType;\n\t\t\t\tif (ta.clazz instanceof JCFieldAccess) {\n\t\t\t\t\tmth.restype = maker.TypeApply(maker.AnnotatedType(List.of(m), ta.clazz), ta.arguments);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tresType = ta.clazz;\n\t\t\t}\n\t\t\t\n\t\t\tif (resType instanceof JCFieldAccess || resType instanceof JCArrayTypeTree) {\n\t\t\t\tmth.restype = maker.AnnotatedType(List.of(m), resType);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif (JCAnnotatedTypeReflect.is(resType)) {\n\t\t\t\tList<JCAnnotation> annotations = JCAnnotatedTypeReflect.getAnnotations(resType);\n\t\t\t\tJCAnnotatedTypeReflect.setAnnotations(resType, annotations.prepend(m));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif (resType instanceof JCPrimitiveTypeTree || resType instanceof JCIdent) {\n\t\t\t\tmth.mods.annotations = mth.mods.annotations == null ? List.of(m) : mth.mods.annotations.prepend(m);\n\t\t\t}\n\t\t} else {\n\t\t\tmth.mods.annotations = mth.mods.annotations == null ? List.of(m) : mth.mods.annotations.prepend(m);\n\t\t}\n\t}\n\t\n\tprivate static void applyAnnotationToVarDecl(JavacNode typeNode, JCVariableDecl arg, String annType, boolean typeUse) {\n\t\tif (annType == null) return;\n\t\tJavacTreeMaker maker = typeNode.getTreeMaker();\n\t\t\n\t\tJCAnnotation m = maker.Annotation(genTypeRef(typeNode, annType), List.<JCExpression>nil());\n\t\tif (typeUse) {\n\t\t\tJCExpression varType = arg.vartype;\n\t\t\tJCTypeApply ta = null;\n\t\t\tif (varType instanceof JCTypeApply) {\n\t\t\t\tta = (JCTypeApply) varType;\n\t\t\t\tvarType = ta.clazz;\n\t\t\t}\n\t\t\t\n\t\t\tif (varType instanceof JCFieldAccess || varType instanceof JCArrayTypeTree) {\n\t\t\t\tvarType = maker.AnnotatedType(List.of(m), varType);\n\t\t\t\tif (ta != null) ta.clazz = varType;\n\t\t\t\telse arg.vartype = varType;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif (JCAnnotatedTypeReflect.is(varType)) {\n\t\t\t\tList<JCAnnotation> annotations = JCAnnotatedTypeReflect.getAnnotations(varType);\n\t\t\t\tJCAnnotatedTypeReflect.setAnnotations(varType, annotations.prepend(m));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif (varType instanceof JCPrimitiveTypeTree || varType instanceof JCIdent) {\n\t\t\t\targ.mods.annotations = arg.mods.annotations == null ? List.of(m) : arg.mods.annotations.prepend(m);\n\t\t\t}\n\t\t} else {\n\t\t\targ.mods.annotations = arg.mods.annotations == null ? List.of(m) : arg.mods.annotations.prepend(m);\n\t\t}\n\t}\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2009-2022 The Project Lombok Authors.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage lombok.javac.handlers;\n\nimport static com.sun.tools.javac.code.Flags.GENERATEDCONSTR;\nimport static lombok.core.handlers.HandlerUtil.*;\nimport static lombok.javac.Javac.*;\nimport static lombok.javac.JavacAugments.JCTree_generatedNode;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.regex.Pattern;\n\nimport com.sun.tools.javac.code.Attribute;\nimport com.sun.tools.javac.code.BoundKind;\nimport com.sun.tools.javac.code.Flags;\nimport com.sun.tools.javac.code.Scope;\nimport com.sun.tools.javac.code.Symbol;\nimport com.sun.tools.javac.code.Symbol.ClassSymbol;\nimport com.sun.tools.javac.code.Symbol.TypeSymbol;\nimport com.sun.tools.javac.code.Type;\nimport com.sun.tools.javac.comp.Annotate;\nimport com.sun.tools.javac.comp.AttrContext;\nimport com.sun.tools.javac.comp.Enter;\nimport com.sun.tools.javac.comp.Env;\nimport com.sun.tools.javac.comp.MemberEnter;\nimport com.sun.tools.javac.tree.JCTree;\nimport com.sun.tools.javac.tree.JCTree.JCAnnotation;\nimport com.sun.tools.javac.tree.JCTree.JCArrayTypeTree;\nimport com.sun.tools.javac.tree.JCTree.JCAssign;\nimport com.sun.tools.javac.tree.JCTree.JCBlock;\nimport com.sun.tools.javac.tree.JCTree.JCClassDecl;\nimport com.sun.tools.javac.tree.JCTree.JCCompilationUnit;\nimport com.sun.tools.javac.tree.JCTree.JCExpression;\nimport com.sun.tools.javac.tree.JCTree.JCExpressionStatement;\nimport com.sun.tools.javac.tree.JCTree.JCFieldAccess;\nimport com.sun.tools.javac.tree.JCTree.JCIdent;\nimport com.sun.tools.javac.tree.JCTree.JCImport;\nimport com.sun.tools.javac.tree.JCTree.JCLiteral;\nimport com.sun.tools.javac.tree.JCTree.JCMethodDecl;\nimport com.sun.tools.javac.tree.JCTree.JCMethodInvocation;\nimport com.sun.tools.javac.tree.JCTree.JCModifiers;\nimport com.sun.tools.javac.tree.JCTree.JCNewArray;\nimport com.sun.tools.javac.tree.JCTree.JCPrimitiveTypeTree;\nimport com.sun.tools.javac.tree.JCTree.JCStatement;\nimport com.sun.tools.javac.tree.JCTree.JCTypeApply;\nimport com.sun.tools.javac.tree.JCTree.JCTypeParameter;\nimport com.sun.tools.javac.tree.JCTree.JCVariableDecl;\nimport com.sun.tools.javac.tree.JCTree.JCWildcard;\nimport com.sun.tools.javac.tree.JCTree.TypeBoundKind;\nimport com.sun.tools.javac.tree.TreeMaker;\nimport com.sun.tools.javac.tree.TreeScanner;\nimport com.sun.tools.javac.util.Context;\nimport com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\nimport com.sun.tools.javac.util.List;\nimport com.sun.tools.javac.util.ListBuffer;\nimport com.sun.tools.javac.util.Name;\nimport com.sun.tools.javac.util.Options;\n\nimport lombok.AccessLevel;\nimport lombok.ConfigurationKeys;\nimport lombok.Data;\nimport lombok.Getter;\nimport lombok.core.AST.Kind;\nimport lombok.core.AnnotationValues;\nimport lombok.core.AnnotationValues.AnnotationValue;\nimport lombok.core.CleanupTask;\nimport lombok.core.LombokImmutableList;\nimport lombok.core.TypeResolver;\nimport lombok.core.configuration.CheckerFrameworkVersion;\nimport lombok.core.configuration.NullAnnotationLibrary;\nimport lombok.core.configuration.NullCheckExceptionType;\nimport lombok.core.configuration.TypeName;\nimport lombok.core.handlers.HandlerUtil;\nimport lombok.core.handlers.HandlerUtil.FieldAccess;\nimport lombok.delombok.LombokOptionsFactory;\nimport lombok.experimental.Accessors;\nimport lombok.experimental.Tolerate;\nimport lombok.javac.Javac;\nimport lombok.javac.JavacAugments;\nimport lombok.javac.JavacNode;\nimport lombok.javac.JavacTreeMaker;\nimport lombok.javac.JavacTreeMaker.TypeTag;\nimport lombok.permit.Permit;\n\n/**\n * Container for static utility methods useful to handlers written for javac.\n */\npublic class JavacHandlerUtil {\n\tprivate JavacHandlerUtil() {\n\t\t//Prevent instantiation\n\t}\n\t\n\tprivate static class MarkingScanner extends TreeScanner {\n\t\tprivate final JavacNode source;\n\t\t\n\t\tMarkingScanner(JavacNode source) {\n\t\t\tthis.source = source;\n\t\t}\n\t\t\n\t\t@Override public void scan(JCTree tree) {\n\t\t\tif (tree == null) return;\n\t\t\tsetGeneratedBy(tree, source);\n\t\t\tsuper.scan(tree);\n\t\t}\n\t}\n\t\n\t/**\n\t * Contributed by Jan Lahoda; many lombok transformations should not be run (or a lite version should be run) when the netbeans editor\n\t * is running javac on the open source file to find inline errors and such. As class files are compiled separately this does not affect\n\t * actual runtime behaviour or file output of the netbeans IDE.\n\t */\n\tpublic static boolean inNetbeansEditor(JavacNode node) {\n\t\treturn inNetbeansEditor(node.getContext());\n\t}\n\t\n\tpublic static boolean inNetbeansEditor(Context context) {\n\t\tOptions options = Options.instance(context);\n\t\treturn (options.keySet().contains(\"ide\") && !options.keySet().contains(\"backgroundCompilation\"));\n\t}\n\t\n\tpublic static boolean inNetbeansCompileOnSave(Context context) {\n\t\tOptions options = Options.instance(context);\n\t\treturn (options.keySet().contains(\"ide\") && options.keySet().contains(\"backgroundCompilation\"));\n\t}\n\t\n\tpublic static JCTree getGeneratedBy(JCTree node) {\n\t\treturn JCTree_generatedNode.get(node);\n\t}\n\t\n\tpublic static boolean isGenerated(JCTree node) {\n\t\treturn getGeneratedBy(node) != null;\n\t}\n\t\n\tpublic static <T extends JCTree> T recursiveSetGeneratedBy(T node, JavacNode source) {\n\t\tif (node == null) return null;\n\t\tsetGeneratedBy(node, source);\n\t\tnode.accept(new MarkingScanner(source));\n\t\treturn node;\n\t}\n\t\n\tpublic static <T extends JCTree> T setGeneratedBy(T node, JavacNode sourceNode) {\n\t\tif (node == null) return null;\n\t\tif (sourceNode == null) {\n\t\t\tJCTree_generatedNode.clear(node);\n\t\t\treturn node;\n\t\t}\n\t\tJCTree_generatedNode.set(node, sourceNode.get());\n\t\t\n\t\tif (!inNetbeansEditor(sourceNode.getContext()) || isParameter(node)) {\n\t\t\tnode.pos = sourceNode.getStartPos();\n\t\t\tstoreEnd(node, sourceNode.getEndPosition(), (JCCompilationUnit) sourceNode.top().get());\n\t\t}\n\t\treturn node;\n\t}\n\n\tpublic static boolean isParameter(JCTree node) {\n\t\treturn node instanceof JCVariableDecl && (((JCVariableDecl) node).mods.flags & Flags.PARAMETER) != 0;\n\t}\n\t\n\tpublic static boolean hasAnnotation(String type, JavacNode node) {\n\t\treturn hasAnnotation(type, node, false);\n\t}\n\t\n\tpublic static boolean hasAnnotation(Class<? extends Annotation> type, JavacNode node) {\n\t\treturn hasAnnotation(type, node, false);\n\t}\n\t\n\tpublic static boolean hasAnnotationAndDeleteIfNeccessary(Class<? extends Annotation> type, JavacNode node) {\n\t\treturn hasAnnotation(type, node, true);\n\t}\n\t\n\tprivate static boolean hasAnnotation(Class<? extends Annotation> type, JavacNode node, boolean delete) {\n\t\tif (node == null) return false;\n\t\tif (type == null) return false;\n\t\tswitch (node.getKind()) {\n\t\tcase ARGUMENT:\n\t\tcase FIELD:\n\t\tcase LOCAL:\n\t\tcase TYPE:\n\t\tcase METHOD:\n\t\t\tfor (JavacNode child : node.down()) {\n\t\t\t\tif (annotationTypeMatches(type, child)) {\n\t\t\t\t\tif (delete) deleteAnnotationIfNeccessary(child, type);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// intentional fallthrough\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tprivate static boolean hasAnnotation(String type, JavacNode node, boolean delete) {\n\t\tif (node == null) return false;\n\t\tif (type == null) return false;\n\t\tswitch (node.getKind()) {\n\t\tcase ARGUMENT:\n\t\tcase FIELD:\n\t\tcase LOCAL:\n\t\tcase TYPE:\n\t\tcase METHOD:\n\t\t\tfor (JavacNode child : node.down()) {\n\t\t\t\tif (annotationTypeMatches(type, child)) {\n\t\t\t\t\tif (delete) deleteAnnotationIfNeccessary(child, type);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// intentional fallthrough\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tpublic static JavacNode findInnerClass(JavacNode parent, String name) {\n\t\tfor (JavacNode child : parent.down()) {\n\t\t\tif (child.getKind() != Kind.TYPE) continue;\n\t\t\tJCClassDecl td = (JCClassDecl) child.get();\n\t\t\tif (td.name.contentEquals(name)) return child;\n\t\t}\n\t\treturn null;\n\t}\n\t\n\tpublic static JavacNode findAnnotation(Class<? extends Annotation> type, JavacNode node) {\n\t\treturn findAnnotation(type, node, false);\n\t}\n\t\n\tpublic static JavacNode findAnnotation(Class<? extends Annotation> type, JavacNode node, boolean delete) {\n\t\tif (node == null) return null;\n\t\tif (type == null) return null;\n\t\tswitch (node.getKind()) {\n\t\tcase ARGUMENT:\n\t\tcase FIELD:\n\t\tcase LOCAL:\n\t\tcase TYPE:\n\t\tcase METHOD:\n\t\t\tfor (JavacNode child : node.down()) {\n\t\t\t\tif (annotationTypeMatches(type, child)) {\n\t\t\t\t\tif (delete) deleteAnnotationIfNeccessary(child, type);\n\t\t\t\t\treturn child;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// intentional fallthrough\n\t\tdefault:\n\t\t\treturn null;\n\t\t}\n\t}\n\t\n\t/**\n\t * Checks if the Annotation AST Node provided is likely to be an instance of the provided annotation type.\n\t * \n\t * @param type An actual annotation type, such as {@code lombok.Getter.class}.\n\t * @param node A Lombok AST node representing an annotation in source code.\n\t */\n\tpublic static boolean annotationTypeMatches(Class<? extends Annotation> type, JavacNode node) {\n\t\tif (node.getKind() != Kind.ANNOTATION) return false;\n\t\treturn typeMatches(type, node, ((JCAnnotation) node.get()).annotationType);\n\t}\n\t\n\t/**\n\t * Checks if the Annotation AST Node provided is likely to be an instance of the provided annotation type.\n\t * \n\t * @param type An actual annotation type, such as {@code lombok.Getter.class}.\n\t * @param node A Lombok AST node representing an annotation in source code.\n\t */\n\tpublic static boolean annotationTypeMatches(String type, JavacNode node) {\n\t\tif (node.getKind() != Kind.ANNOTATION) return false;\n\t\treturn typeMatches(type, node, ((JCAnnotation) node.get()).annotationType);\n\t}\n\t\n\t/**\n\t * Checks if the given TypeReference node is likely to be a reference to the provided class.\n\t * \n\t * @param type An actual type. This method checks if {@code typeNode} is likely to be a reference to this type.\n\t * @param node A Lombok AST node. Any node in the appropriate compilation unit will do (used to get access to import statements).\n\t * @param typeNode A type reference to check.\n\t */\n\tpublic static boolean typeMatches(Class<?> type, JavacNode node, JCTree typeNode) {\n\t\treturn typeMatches(type.getName(), node, typeNode);\n\t}\n\t\n\t/**\n\t * Checks if the given TypeReference node is likely to be a reference to the provided class.\n\t * \n\t * @param type An actual type. This method checks if {@code typeNode} is likely to be a reference to this type.\n\t * @param node A Lombok AST node. Any node in the appropriate compilation unit will do (used to get access to import statements).\n\t * @param typeNode A type reference to check.\n\t */\n\tpublic static boolean typeMatches(String type, JavacNode node, JCTree typeNode) {\n\t\tString typeName = getTypeName(typeNode);\n\t\treturn typeMatches(type, node, typeName);\n\t}\n\n\tprivate static boolean typeMatches(String type, JavacNode node, String typeName) {\n\t\tif (typeName == null || typeName.length() == 0) return false;\n\t\tint lastIndexA = typeName.lastIndexOf('.') + 1;\n\t\tint lastIndexB = Math.max(type.lastIndexOf('.'), type.lastIndexOf('$')) + 1;\n\t\tint len = typeName.length() - lastIndexA;\n\t\tif (len != type.length() - lastIndexB) return false;\n\t\tfor (int i = 0; i < len; i++) if (typeName.charAt(i + lastIndexA) != type.charAt(i + lastIndexB)) return false;\n\t\tTypeResolver resolver = node.getImportListAsTypeResolver();\n\t\treturn resolver.typeMatches(node, type, typeName);\n\t}\n\n\tprivate static String getTypeName(JCTree typeNode) {\n\t\treturn typeNode == null ? null : typeNode.toString();\n\t}\n\n\t/**\n\t * Returns if a field is marked deprecated, either by {@code @Deprecated} or in javadoc\n\t * @param field the field to check\n\t * @return {@code true} if a field is marked deprecated, either by {@code @Deprecated} or in javadoc, otherwise {@code false}\n\t */\n\tpublic static boolean isFieldDeprecated(JavacNode field) {\n\t\tif (!(field.get() instanceof JCVariableDecl)) return false;\n\t\tJCVariableDecl fieldNode = (JCVariableDecl) field.get();\n\t\tif ((fieldNode.mods.flags & Flags.DEPRECATED) != 0) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (JavacNode child : field.down()) {\n\t\t\tif (annotationTypeMatches(Deprecated.class, child)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic static CheckerFrameworkVersion getCheckerFrameworkVersion(JavacNode node) {\n\t\tCheckerFrameworkVersion cfv = node.getAst().readConfiguration(ConfigurationKeys.CHECKER_FRAMEWORK);\n\t\treturn cfv == null ? CheckerFrameworkVersion.NONE : cfv;\n\t}\n\t\n\t/**\n\t * Returns if a node is marked deprecated (as picked up on by the parser).\n\t * @param node the node to check (type, method, or field decl).\n\t */\n\tpublic static boolean nodeHasDeprecatedFlag(JCTree node) {\n\t\tif (node instanceof JCVariableDecl) return (((JCVariableDecl) node).mods.flags & Flags.DEPRECATED) != 0;\n\t\tif (node instanceof JCMethodDecl) return (((JCMethodDecl) node).mods.flags & Flags.DEPRECATED) != 0;\n\t\tif (node instanceof JCClassDecl) return (((JCClassDecl) node).mods.flags & Flags.DEPRECATED) != 0;\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Creates an instance of {@code AnnotationValues} for the provided AST Node.\n\t * \n\t * @param type An annotation class type, such as {@code lombok.Getter.class}.\n\t * @param node A Lombok AST node representing an annotation in source code.\n\t */\n\tpublic static <A extends Annotation> AnnotationValues<A> createAnnotation(Class<A> type, final JavacNode node) {\n\t\treturn createAnnotation(type, (JCAnnotation) node.get(), node);\n\t}\n\t\n\t/**\n\t * Creates an instance of {@code AnnotationValues} for the provided AST Node\n\t * and Annotation expression.\n\t *\n\t * @param type An annotation class type, such as {@code lombok.Getter.class}.\n\t * @param anno the annotation expression\n\t * @param node A Lombok AST node representing an annotation in source code.\n\t */\n\tpublic static <A extends Annotation> AnnotationValues<A> createAnnotation(Class<A> type, JCAnnotation anno, final JavacNode node) {\n\t\tMap<String, AnnotationValue> values = new HashMap<String, AnnotationValue>();\n\t\tList<JCExpression> arguments = anno.getArguments();\n\t\t\n\t\tfor (JCExpression arg : arguments) {\n\t\t\tString mName;\n\t\t\tJCExpression rhs;\n\t\t\tjava.util.List<String> raws = new ArrayList<String>();\n\t\t\tjava.util.List<Object> guesses = new ArrayList<Object>();\n\t\t\tjava.util.List<Object> expressions = new ArrayList<Object>();\n\t\t\tfinal java.util.List<DiagnosticPosition> positions = new ArrayList<DiagnosticPosition>();\n\t\t\t\n\t\t\tif (arg instanceof JCAssign) {\n\t\t\t\tJCAssign assign = (JCAssign) arg;\n\t\t\t\tmName = assign.lhs.toString();\n\t\t\t\trhs = assign.rhs;\n\t\t\t} else {\n\t\t\t\trhs = arg;\n\t\t\t\tmName = \"value\";\n\t\t\t}\n\t\t\t\n\t\t\tif (rhs instanceof JCNewArray) {\n\t\t\t\tList<JCExpression> elems = ((JCNewArray) rhs).elems;\n\t\t\t\tfor (JCExpression inner : elems) {\n\t\t\t\t\traws.add(inner.toString());\n\t\t\t\t\texpressions.add(inner);\n\t\t\t\t\tif (inner instanceof JCAnnotation) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\t\t\t\tClass<A> innerClass = (Class<A>) Class.forName(inner.type.toString());\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tguesses.add(createAnnotation(innerClass, (JCAnnotation) inner, node));\n\t\t\t\t\t\t} catch (ClassNotFoundException ex) {\n\t\t\t\t\t\t\tguesses.add(calculateGuess(inner));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tguesses.add(calculateGuess(inner));\n\t\t\t\t\t}\n\t\t\t\t\tpositions.add(inner.pos());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\traws.add(rhs.toString());\n\t\t\t\texpressions.add(rhs);\n\t\t\t\tif (rhs instanceof JCAnnotation) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\t\t\tClass<A> innerClass = (Class<A>) Class.forName(rhs.type.toString());\n\t\t\t\t\t\t\n\t\t\t\t\t\tguesses.add(createAnnotation(innerClass, (JCAnnotation) rhs, node));\n\t\t\t\t\t} catch (ClassNotFoundException ex) {\n\t\t\t\t\t\tguesses.add(calculateGuess(rhs));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tguesses.add(calculateGuess(rhs));\n\t\t\t\t}\n\t\t\t\tpositions.add(rhs.pos());\n\t\t\t}\n\t\t\t\n\t\t\tvalues.put(mName, new AnnotationValue(node, raws, expressions, guesses, true) {\n\t\t\t\t@Override public void setError(String message, int valueIdx) {\n\t\t\t\t\tif (valueIdx < 0) node.addError(message);\n\t\t\t\t\telse node.addError(message, positions.get(valueIdx));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t@Override public void setWarning(String message, int valueIdx) {\n\t\t\t\t\tif (valueIdx < 0) node.addWarning(message);\n\t\t\t\t\telse node.addWarning(message, positions.get(valueIdx));\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\t\n\t\tfor (Method m : type.getDeclaredMethods()) {\n\t\t\tif (!Modifier.isPublic(m.getModifiers())) continue;\n\t\t\tString name = m.getName();\n\t\t\tif (!values.containsKey(name)) {\n\t\t\t\tvalues.put(name, new AnnotationValue(node, new ArrayList<String>(), new ArrayList<Object>(), new ArrayList<Object>(), false) {\n\t\t\t\t\t@Override public void setError(String message, int valueIdx) {\n\t\t\t\t\t\tnode.addError(message);\n\t\t\t\t\t}\n\t\t\t\t\t@Override public void setWarning(String message, int valueIdx) {\n\t\t\t\t\t\tnode.addWarning(message);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn new AnnotationValues<A>(type, values, node);\n\t}\n\t\n\t/**\n\t * Removes the annotation from javac's AST (it remains in lombok's AST),\n\t * then removes any import statement that imports this exact annotation (not star imports).\n\t * Only does this if the DeleteLombokAnnotations class is in the context.\n\t */\n\tpublic static void deleteAnnotationIfNeccessary(JavacNode annotation, String annotationType) {\n\t\tdeleteAnnotationIfNeccessary0(annotation, annotationType);\n\t}\n\t\n\t/**\n\t * Removes the annotation from javac's AST (it remains in lombok's AST),\n\t * then removes any import statement that imports this exact annotation (not star imports).\n\t * Only does this if the DeleteLombokAnnotations class is in the context.\n\t */\n\tpublic static void deleteAnnotationIfNeccessary(JavacNode annotation, Class<? extends Annotation> annotationType) {\n\t\tdeleteAnnotationIfNeccessary0(annotation, annotationType.getName());\n\t}\n\t\n\t/**\n\t * Removes the annotation from javac's AST (it remains in lombok's AST),\n\t * then removes any import statement that imports this exact annotation (not star imports).\n\t * Only does this if the DeleteLombokAnnotations class is in the context.\n\t */\n\tpublic static void deleteAnnotationIfNeccessary(JavacNode annotation, Class<? extends Annotation> annotationType1, Class<? extends Annotation> annotationType2) {\n\t\tdeleteAnnotationIfNeccessary0(annotation, annotationType1.getName(), annotationType2.getName());\n\t}\n\t\n\t/**\n\t * Removes the annotation from javac's AST (it remains in lombok's AST),\n\t * then removes any import statement that imports this exact annotation (not star imports).\n\t * Only does this if the DeleteLombokAnnotations class is in the context.\n\t */\n\tpublic static void deleteAnnotationIfNeccessary(JavacNode annotation, Class<? extends Annotation> annotationType1, String annotationType2) {\n\t\tdeleteAnnotationIfNeccessary0(annotation, annotationType1.getName(), annotationType2);\n\t}\n\t\n\tprivate static void deleteAnnotationIfNeccessary0(JavacNode annotation, String... annotationTypes) {\n\t\tif (inNetbeansEditor(annotation)) return;\n\t\tif (!annotation.shouldDeleteLombokAnnotations()) return;\n\t\tJavacNode parentNode = annotation.directUp();\n\t\tswitch (parentNode.getKind()) {\n\t\tcase FIELD:\n\t\tcase ARGUMENT:\n\t\tcase LOCAL:\n\t\t\tJCVariableDecl variable = (JCVariableDecl) parentNode.get();\n\t\t\tvariable.mods.annotations = filterList(variable.mods.annotations, annotation.get());\n\t\t\tbreak;\n\t\tcase METHOD:\n\t\t\tJCMethodDecl method = (JCMethodDecl) parentNode.get();\n\t\t\tmethod.mods.annotations = filterList(method.mods.annotations, annotation.get());\n\t\t\tbreak;\n\t\tcase TYPE:\n\t\t\ttry {\n\t\t\t\tJCClassDecl type = (JCClassDecl) parentNode.get();\n\t\t\t\ttype.mods.annotations = filterList(type.mods.annotations, annotation.get());\n\t\t\t} catch (ClassCastException e) {\n\t\t\t\t//something rather odd has been annotated. Better to just break only delombok instead of everything.\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t//This really shouldn't happen, but if it does, better just break delombok instead of breaking everything.\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tparentNode.getAst().setChanged();\n\t\tfor (String annotationType : annotationTypes) {\n\t\t\tdeleteImportFromCompilationUnit(annotation, annotationType);\n\t\t}\n\t}\n\t\n\tpublic static void deleteImportFromCompilationUnit(JavacNode node, String name) {\n\t\tif (inNetbeansEditor(node)) return;\n\t\tif (!node.shouldDeleteLombokAnnotations()) return;\n\t\t\n\t\tJCCompilationUnit unit = (JCCompilationUnit) node.top().get();\n\t\t\n\t\tfor (JCTree def : unit.defs) {\n\t\t\tif (!(def instanceof JCImport)) continue;\n\t\t\tJCImport imp0rt = (JCImport) def;\n\t\t\tif (imp0rt.staticImport) continue;\n\t\t\tif (!imp0rt.qualid.toString().equals(name)) continue;\n\t\t\tJavacAugments.JCImport_deletable.set(imp0rt, true);\n\t\t}\n\t}\n\t\n\tprivate static List<JCAnnotation> filterList(List<JCAnnotation> annotations, JCTree jcTree) {\n\t\tListBuffer<JCAnnotation> newAnnotations = new ListBuffer<JCAnnotation>();\n\t\tfor (JCAnnotation ann : annotations) {\n\t\t\tif (jcTree != ann) newAnnotations.append(ann);\n\t\t}\n\t\treturn newAnnotations.toList();\n\t}\n\t\n\t/** Serves as return value for the methods that check for the existence of fields and methods. */\n\tpublic enum MemberExistsResult {\n\t\tNOT_EXISTS, EXISTS_BY_LOMBOK, EXISTS_BY_USER;\n\t}\n\t\n\t/**\n\t * Translates the given field into all possible getter names.\n\t * Convenient wrapper around {@link HandlerUtil#toAllGetterNames(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static java.util.List<String> toAllGetterNames(JavacNode field) {\n\t\treturn HandlerUtil.toAllGetterNames(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * Translates the given field into all possible getter names.\n\t * Convenient wrapper around {@link HandlerUtil#toAllGetterNames(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static java.util.List<String> toAllGetterNames(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\treturn HandlerUtil.toAllGetterNames(field.getAst(), accessors, field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * @return the likely getter name for the stated field. (e.g. private boolean foo; to isFoo).\n\t * \n\t * Convenient wrapper around {@link HandlerUtil#toGetterName(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static String toGetterName(JavacNode field) {\n\t\treturn HandlerUtil.toGetterName(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * @return the likely getter name for the stated field. (e.g. private boolean foo; to isFoo).\n\t * \n\t * Convenient wrapper around {@link HandlerUtil#toGetterName(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static String toGetterName(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\treturn HandlerUtil.toGetterName(field.getAst(), accessors, field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * Translates the given field into all possible setter names.\n\t * Convenient wrapper around {@link HandlerUtil#toAllSetterNames(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static java.util.List<String> toAllSetterNames(JavacNode field) {\n\t\treturn HandlerUtil.toAllSetterNames(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * Translates the given field into all possible setter names.\n\t * Convenient wrapper around {@link HandlerUtil#toAllSetterNames(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static java.util.List<String> toAllSetterNames(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\treturn HandlerUtil.toAllSetterNames(field.getAst(), accessors, field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * @return the likely setter name for the stated field. (e.g. private boolean foo; to setFoo).\n\t * \n\t * Convenient wrapper around {@link HandlerUtil#toSetterName(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static String toSetterName(JavacNode field) {\n\t\treturn HandlerUtil.toSetterName(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * @return the likely setter name for the stated field. (e.g. private boolean foo; to setFoo).\n\t * \n\t * Convenient wrapper around {@link HandlerUtil#toSetterName(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static String toSetterName(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\treturn HandlerUtil.toSetterName(field.getAst(), accessors, field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * Translates the given field into all possible with names.\n\t * Convenient wrapper around {@link HandlerUtil#toAllWithNames(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static java.util.List<String> toAllWithNames(JavacNode field) {\n\t\treturn HandlerUtil.toAllWithNames(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * Translates the given field into all possible with names.\n\t * Convenient wrapper around {@link HandlerUtil#toAllWithNames(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static java.util.List<String> toAllWithNames(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\treturn HandlerUtil.toAllWithNames(field.getAst(), accessors, field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * Translates the given field into all possible withBy names.\n\t * Convenient wrapper around {@link HandlerUtil#toAllWithByNames(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static java.util.List<String> toAllWithByNames(JavacNode field) {\n\t\treturn HandlerUtil.toAllWithByNames(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * Translates the given field into all possible withBy names.\n\t * Convenient wrapper around {@link HandlerUtil#toAllWithByNames(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static java.util.List<String> toAllWithByNames(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\treturn HandlerUtil.toAllWithByNames(field.getAst(), accessors, field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * @return the likely with name for the stated field. (e.g. private boolean foo; to withFoo).\n\t * \n\t * Convenient wrapper around {@link HandlerUtil#toWithName(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static String toWithName(JavacNode field) {\n\t\treturn HandlerUtil.toWithName(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * @return the likely with name for the stated field. (e.g. private boolean foo; to withFoo).\n\t * \n\t * Convenient wrapper around {@link HandlerUtil#toWithName(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static String toWithName(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\treturn HandlerUtil.toWithName(field.getAst(), accessors, field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * @return the likely withBy name for the stated field. (e.g. private boolean foo; to withFooBy).\n\t * \n\t * Convenient wrapper around {@link HandlerUtil#toWithByName(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static String toWithByName(JavacNode field) {\n\t\treturn HandlerUtil.toWithByName(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * @return the likely withBy name for the stated field. (e.g. private boolean foo; to withFooBy).\n\t * \n\t * Convenient wrapper around {@link HandlerUtil#toWithByName(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static String toWithByName(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\treturn HandlerUtil.toWithByName(field.getAst(), accessors, field.getName(), isBoolean(field));\n\t}\n\t\n\t/**\n\t * When generating a setter, the setter either returns void (beanspec) or Self (fluent).\n\t * This method scans for the {@code Accessors} annotation to figure that out.\n\t */\n\tpublic static boolean shouldReturnThis(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\tif ((((JCVariableDecl) field.get()).mods.flags & Flags.STATIC) != 0) return false;\n\t\t\n\t\treturn HandlerUtil.shouldReturnThis0(accessors, field.getAst());\n\t}\n\t\n\t/**\n\t * When generating a setter/getter/wither, should it be made final?\n\t */\n\tpublic static boolean shouldMakeFinal(JavacNode field, AnnotationValues<Accessors> accessors) {\n\t\tif ((((JCVariableDecl) field.get()).mods.flags & Flags.STATIC) != 0) return false;\n\t\t\n\t\treturn HandlerUtil.shouldMakeFinal0(accessors, field.getAst());\n\t}\n\t\n\tpublic static JCExpression cloneSelfType(JavacNode childOfType) {\n\t\tJavacNode typeNode = childOfType;\n\t\tJavacTreeMaker maker = childOfType.getTreeMaker();\n\t\twhile (typeNode != null && typeNode.getKind() != Kind.TYPE) typeNode = typeNode.up();\n\t\treturn JavacHandlerUtil.namePlusTypeParamsToTypeReference(maker, typeNode, ((JCClassDecl) typeNode.get()).typarams);\n\t}\n\t\n\tpublic static boolean isBoolean(JavacNode field) {\n\t\tJCExpression varType = ((JCVariableDecl) field.get()).vartype;\n\t\treturn isBoolean(varType);\n\t}\n\t\n\tpublic static boolean isBoolean(JCExpression varType) {\n\t\treturn varType != null && varType.toString().equals(\"boolean\");\n\t}\n\t\n\tpublic static Name removePrefixFromField(JavacNode field) {\n\t\tjava.util.List<String> prefixes = null;\n\t\tfor (JavacNode node : field.down()) {\n\t\t\tif (annotationTypeMatches(Accessors.class, node)) {\n\t\t\t\tAnnotationValues<Accessors> ann = createAnnotation(Accessors.class, node);\n\t\t\t\tif (ann.isExplicit(\"prefix\")) prefixes = Arrays.asList(ann.getInstance().prefix());\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (prefixes == null) {\n\t\t\tJavacNode current = field.up();\n\t\t\touter:\n\t\t\twhile (current != null) {\n\t\t\t\tfor (JavacNode node : current.down()) {\n\t\t\t\t\tif (annotationTypeMatches(Accessors.class, node)) {\n\t\t\t\t\t\tAnnotationValues<Accessors> ann = createAnnotation(Accessors.class, node);\n\t\t\t\t\t\tif (ann.isExplicit(\"prefix\")) prefixes = Arrays.asList(ann.getInstance().prefix());\n\t\t\t\t\t\tbreak outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcurrent = current.up();\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (prefixes == null) prefixes = field.getAst().readConfiguration(ConfigurationKeys.ACCESSORS_PREFIX);\n\t\t\n\t\tif (!prefixes.isEmpty()) {\n\t\t\tCharSequence newName = removePrefix(field.getName(), prefixes);\n\t\t\tif (newName != null) return field.toName(newName.toString());\n\t\t}\n\t\t\n\t\treturn ((JCVariableDecl) field.get()).name;\n\t}\n\t\n\tpublic static AnnotationValues<Accessors> getAccessorsForField(JavacNode field) {\n\t\tAnnotationValues<Accessors> values = null;\n\t\t\n\t\tfor (JavacNode node : field.down()) {\n\t\t\tif (annotationTypeMatches(Accessors.class, node)) {\n\t\t\t\tvalues = createAnnotation(Accessors.class, node);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tJavacNode current = field.up();\n\t\twhile (current != null) {\n\t\t\tfor (JavacNode node : current.down()) {\n\t\t\t\tif (annotationTypeMatches(Accessors.class, node)) {\n\t\t\t\t\tAnnotationValues<Accessors> onType = createAnnotation(Accessors.class, node);\n\t\t\t\t\tvalues = values == null ? onType : values.integrate(onType);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurrent = current.up();\n\t\t}\n\t\t\n\t\treturn values == null ? AnnotationValues.of(Accessors.class, field) : values;\n\t}\n\t\n\t/**\n\t * Checks if there is a field with the provided name.\n\t * \n\t * @param fieldName the field name to check for.\n\t * @param node Any node that represents the Type (JCClassDecl) to look in, or any child node thereof.\n\t */\n\tpublic static MemberExistsResult fieldExists(String fieldName, JavacNode node) {\n\t\tnode = upToTypeNode(node);\n\t\t\n\t\tif (node != null && node.get() instanceof JCClassDecl) {\n\t\t\tfor (JCTree def : ((JCClassDecl)node.get()).defs) {\n\t\t\t\tif (def instanceof JCVariableDecl) {\n\t\t\t\t\tif (((JCVariableDecl)def).name.contentEquals(fieldName)) {\n\t\t\t\t\t\treturn getGeneratedBy(def) == null ? MemberExistsResult.EXISTS_BY_USER : MemberExistsResult.EXISTS_BY_LOMBOK;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn MemberExistsResult.NOT_EXISTS;\n\t}\n\t\n\tpublic static MemberExistsResult methodExists(String methodName, JavacNode node, int params) {\n\t\treturn methodExists(methodName, node, true, params);\n\t}\n\t\n\t/**\n\t * Checks if there is a method with the provided name. In case of multiple methods (overloading), only\n\t * the first method decides if EXISTS_BY_USER or EXISTS_BY_LOMBOK is returned.\n\t * \n\t * @param methodName the method name to check for.\n\t * @param node Any node that represents the Type (JCClassDecl) to look in, or any child node thereof.\n\t * @param caseSensitive If the search should be case sensitive.\n\t * @param params The number of parameters the method should have; varargs count as 0-*. Set to -1 to find any method with the appropriate name regardless of parameter count.\n\t */\n\tpublic static MemberExistsResult methodExists(String methodName, JavacNode node, boolean caseSensitive, int params) {\n\t\tnode = upToTypeNode(node);\n\t\t\n\t\tif (node != null && node.get() instanceof JCClassDecl) {\n\t\t\ttop: for (JCTree def : ((JCClassDecl)node.get()).defs) {\n\t\t\t\tif (def instanceof JCMethodDecl) {\n\t\t\t\t\tJCMethodDecl md = (JCMethodDecl) def;\n\t\t\t\t\tString name = md.name.toString();\n\t\t\t\t\tboolean matches = caseSensitive ? name.equals(methodName) : name.equalsIgnoreCase(methodName);\n\t\t\t\t\tif (matches) {\n\t\t\t\t\t\tif (params > -1) {\n\t\t\t\t\t\t\tList<JCVariableDecl> ps = md.params;\n\t\t\t\t\t\t\tint minArgs = 0;\n\t\t\t\t\t\t\tint maxArgs = 0;\n\t\t\t\t\t\t\tif (ps != null && ps.length() > 0) {\n\t\t\t\t\t\t\t\tminArgs = ps.length();\n\t\t\t\t\t\t\t\tif ((ps.last().mods.flags & Flags.VARARGS) != 0) {\n\t\t\t\t\t\t\t\t\tmaxArgs = Integer.MAX_VALUE;\n\t\t\t\t\t\t\t\t\tminArgs--;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tmaxArgs = minArgs;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (params < minArgs || params > maxArgs) continue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (isTolerate(node, md)) continue top;\n\t\t\t\t\t\t\n\t\t\t\t\t\treturn getGeneratedBy(def) == null ? MemberExistsResult.EXISTS_BY_USER : MemberExistsResult.EXISTS_BY_LOMBOK;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn MemberExistsResult.NOT_EXISTS;\n\t}\n\t\n\tpublic static boolean isTolerate(JavacNode node, JCTree.JCMethodDecl md) {\n\t\tList<JCAnnotation> annotations = md.getModifiers().getAnnotations();\n\t\tif (annotations != null) for (JCTree.JCAnnotation anno : annotations) {\n\t\t\tif (typeMatches(Tolerate.class, node, anno.getAnnotationType())) return true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Checks if there is a (non-default) constructor. In case of multiple constructors (overloading), only\n\t * the first constructor decides if EXISTS_BY_USER or EXISTS_BY_LOMBOK is returned.\n\t * \n\t * @param node Any node that represents the Type (JCClassDecl) to look in, or any child node thereof.\n\t */\n\tpublic static MemberExistsResult constructorExists(JavacNode node) {\n\t\tnode = upToTypeNode(node);\n\t\t\n\t\tif (node != null && node.get() instanceof JCClassDecl) {\n\t\t\tfor (JCTree def : ((JCClassDecl) node.get()).defs) {\n\t\t\t\tif (def instanceof JCMethodDecl) {\n\t\t\t\t\tJCMethodDecl md = (JCMethodDecl) def;\n\t\t\t\t\tif (md.name.contentEquals(\"<init>\")) {\n\t\t\t\t\t\tif ((md.mods.flags & Flags.GENERATEDCONSTR) != 0) continue;\n\t\t\t\t\t\tif (isTolerate(node, md)) continue;\n\t\t\t\t\t\treturn getGeneratedBy(def) == null ? MemberExistsResult.EXISTS_BY_USER : MemberExistsResult.EXISTS_BY_LOMBOK;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn MemberExistsResult.NOT_EXISTS;\n\t}\n\t\n\tpublic static boolean isConstructorCall(final JCStatement statement) {\n\t\tif (!(statement instanceof JCExpressionStatement)) return false;\n\t\tJCExpression expr = ((JCExpressionStatement) statement).expr;\n\t\tif (!(expr instanceof JCMethodInvocation)) return false;\n\t\tJCExpression invocation = ((JCMethodInvocation) expr).meth;\n\t\tString name;\n\t\tif (invocation instanceof JCFieldAccess) {\n\t\t\tname = ((JCFieldAccess) invocation).name.toString();\n\t\t} else if (invocation instanceof JCIdent) {\n\t\t\tname = ((JCIdent) invocation).name.toString();\n\t\t} else {\n\t\t\tname = \"\";\n\t\t}\n\t\t\n\t\treturn \"super\".equals(name) || \"this\".equals(name);\n\t}\n\t\n\t/**\n\t * Turns an {@code AccessLevel} instance into the flag bit used by javac.\n\t */\n\tpublic static int toJavacModifier(AccessLevel accessLevel) {\n\t\tswitch (accessLevel) {\n\t\tcase MODULE:\n\t\tcase PACKAGE:\n\t\t\treturn 0;\n\t\tdefault:\n\t\tcase PUBLIC:\n\t\t\treturn Flags.PUBLIC;\n\t\tcase NONE:\n\t\tcase PRIVATE:\n\t\t\treturn Flags.PRIVATE;\n\t\tcase PROTECTED:\n\t\t\treturn Flags.PROTECTED;\n\t\t}\n\t}\n\t\n\tprivate static class GetterMethod {\n\t\tprivate final Name name;\n\t\tprivate final JCExpression type;\n\t\t\n\t\tGetterMethod(Name name, JCExpression type) {\n\t\t\tthis.name = name;\n\t\t\tthis.type = type;\n\t\t}\n\t}\n\t\n\tprivate static GetterMethod findGetter(JavacNode field) {\n\t\tJCVariableDecl decl = (JCVariableDecl)field.get();\n\t\tJavacNode typeNode = field.up();\n\t\tfor (String potentialGetterName : toAllGetterNames(field)) {\n\t\t\tfor (JavacNode potentialGetter : typeNode.down()) {\n\t\t\t\tif (potentialGetter.getKind() != Kind.METHOD) continue;\n\t\t\t\tJCMethodDecl method = (JCMethodDecl) potentialGetter.get();\n\t\t\t\tif (!method.name.toString().equalsIgnoreCase(potentialGetterName)) continue;\n\t\t\t\t/** static getX() methods don't count. */\n\t\t\t\tif ((method.mods.flags & Flags.STATIC) != 0) continue;\n\t\t\t\t/** Nor do getters with a non-empty parameter list. */\n\t\t\t\tif (method.params != null && method.params.size() > 0) continue;\n\t\t\t\treturn new GetterMethod(method.name, method.restype);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Check if the field has a @Getter annotation.\n\t\t\n\t\tboolean hasGetterAnnotation = false;\n\t\t\n\t\tfor (JavacNode child : field.down()) {\n\t\t\tif (child.getKind() == Kind.ANNOTATION && annotationTypeMatches(Getter.class, child)) {\n\t\t\t\tAnnotationValues<Getter> ann = createAnnotation(Getter.class, child);\n\t\t\t\tif (ann.getInstance().value() == AccessLevel.NONE) return null;   //Definitely WONT have a getter.\n\t\t\t\thasGetterAnnotation = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Check if the class has a @Getter annotation.\n\t\t\n\t\tif (!hasGetterAnnotation && HandleGetter.fieldQualifiesForGetterGeneration(field)) {\n\t\t\t//Check if the class has @Getter or @Data annotation.\n\t\t\t\n\t\t\tJavacNode containingType = field.up();\n\t\t\tif (containingType != null) for (JavacNode child : containingType.down()) {\n\t\t\t\tif (child.getKind() == Kind.ANNOTATION && annotationTypeMatches(Data.class, child)) hasGetterAnnotation = true;\n\t\t\t\tif (child.getKind() == Kind.ANNOTATION && annotationTypeMatches(Getter.class, child)) {\n\t\t\t\t\tAnnotationValues<Getter> ann = createAnnotation(Getter.class, child);\n\t\t\t\t\tif (ann.getInstance().value() == AccessLevel.NONE) return null;   //Definitely WONT have a getter.\n\t\t\t\t\thasGetterAnnotation = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (hasGetterAnnotation) {\n\t\t\tString getterName = toGetterName(field);\n\t\t\tif (getterName == null) return null;\n\t\t\treturn new GetterMethod(field.toName(getterName), decl.vartype);\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\t\n\tstatic boolean lookForGetter(JavacNode field, FieldAccess fieldAccess) {\n\t\tif (fieldAccess == FieldAccess.GETTER) return true;\n\t\tif (fieldAccess == FieldAccess.ALWAYS_FIELD) return false;\n\t\t\n\t\t// If @Getter(lazy = true) is used, then using it is mandatory.\n\t\tfor (JavacNode child : field.down()) {\n\t\t\tif (child.getKind() != Kind.ANNOTATION) continue;\n\t\t\tif (annotationTypeMatches(Getter.class, child)) {\n\t\t\t\tAnnotationValues<Getter> ann = createAnnotation(Getter.class, child);\n\t\t\t\tif (ann.getInstance().lazy()) return true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Returns the type of the field, unless a getter exists for this field, in which case the return type of the getter is returned.\n\t * \n\t * @see #createFieldAccessor(TreeMaker, JavacNode, FieldAccess)\n\t */\n\tstatic JCExpression getFieldType(JavacNode field, FieldAccess fieldAccess) {\n\t\tif (field.getKind() == Kind.METHOD) return ((JCMethodDecl) field.get()).restype;\n\t\t\n\t\tboolean lookForGetter = lookForGetter(field, fieldAccess);\n\t\t\n\t\tGetterMethod getter = lookForGetter ? findGetter(field) : null;\n\t\t\n\t\tif (getter == null) {\n\t\t\treturn ((JCVariableDecl) field.get()).vartype;\n\t\t}\n\t\t\n\t\treturn getter.type;\n\t}\n\t\n\t/**\n\t * Creates an expression that reads the field. Will either be {@code this.field} or {@code this.getField()} depending on whether or not there's a getter.\n\t */\n\tstatic JCExpression createFieldAccessor(JavacTreeMaker maker, JavacNode field, FieldAccess fieldAccess) {\n\t\treturn createFieldAccessor(maker, field, fieldAccess, null);\n\t}\n\t\n\tstatic JCExpression createFieldAccessor(JavacTreeMaker maker, JavacNode field, FieldAccess fieldAccess, JCExpression receiver) {\n\t\tboolean lookForGetter = lookForGetter(field, fieldAccess);\n\t\t\n\t\tGetterMethod getter = lookForGetter ? findGetter(field) : null;\n\t\tJCVariableDecl fieldDecl = (JCVariableDecl) field.get();\n\t\t\n\t\tif (getter == null) {\n\t\t\tif (receiver == null) {\n\t\t\t\tif ((fieldDecl.mods.flags & Flags.STATIC) == 0) {\n\t\t\t\t\treceiver = maker.Ident(field.toName(\"this\"));\n\t\t\t\t} else {\n\t\t\t\t\tJavacNode containerNode = field.up();\n\t\t\t\t\tif (containerNode != null && containerNode.get() instanceof JCClassDecl) {\n\t\t\t\t\t\tJCClassDecl container = (JCClassDecl) field.up().get();\n\t\t\t\t\t\treceiver = maker.Ident(container.name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn receiver == null ? maker.Ident(fieldDecl.name) : maker.Select(receiver, fieldDecl.name);\n\t\t}\n\t\t\n\t\tif (receiver == null) receiver = maker.Ident(field.toName(\"this\"));\n\t\tJCMethodInvocation call = maker.Apply(List.<JCExpression>nil(),\n\t\t\tmaker.Select(receiver, getter.name), List.<JCExpression>nil());\n\t\treturn call;\n\t}\n\t\n\tstatic JCExpression createMethodAccessor(JavacTreeMaker maker, JavacNode method) {\n\t\treturn createMethodAccessor(maker, method, null);\n\t}\n\t\n\tstatic JCExpression createMethodAccessor(JavacTreeMaker maker, JavacNode method, JCExpression receiver) {\n\t\tJCMethodDecl methodDecl = (JCMethodDecl) method.get();\n\t\t\n\t\tif (receiver == null && (methodDecl.mods.flags & Flags.STATIC) == 0) {\n\t\t\treceiver = maker.Ident(method.toName(\"this\"));\n\t\t} else if (receiver == null) {\n\t\t\tJavacNode containerNode = method.up();\n\t\t\tif (containerNode != null && containerNode.get() instanceof JCClassDecl) {\n\t\t\t\tJCClassDecl container = (JCClassDecl) method.up().get();\n\t\t\t\treceiver = maker.Ident(container.name);\n\t\t\t}\n\t\t}\n\t\t\n\t\tJCMethodInvocation call = maker.Apply(List.<JCExpression>nil(),\n\t\t\treceiver == null ? maker.Ident(methodDecl.name) : maker.Select(receiver, methodDecl.name), List.<JCExpression>nil());\n\t\treturn call;\n\t}\n\t\n\t/**\n\t * Adds the given new field declaration to the provided type AST Node.\n\t * The field carries the &#64;{@link SuppressWarnings}(\"all\") annotation.\n\t * Also takes care of updating the JavacAST.\n\t */\n\tpublic static JavacNode injectFieldAndMarkGenerated(JavacNode typeNode, JCVariableDecl field) {\n\t\treturn injectField(typeNode, field, true);\n\t}\n\t\n\t/**\n\t * Adds the given new field declaration to the provided type AST Node.\n\t * \n\t * Also takes care of updating the JavacAST.\n\t */\n\tpublic static JavacNode injectField(JavacNode typeNode, JCVariableDecl field) {\n\t\treturn injectField(typeNode, field, false);\n\t}\n\t\n\tpublic static JavacNode injectField(JavacNode typeNode, JCVariableDecl field, boolean addGenerated) {\n\t\treturn injectField(typeNode, field, addGenerated, false);\n\t}\n\t\n\tpublic static JavacNode injectField(JavacNode typeNode, JCVariableDecl field, boolean addGenerated, boolean specialEnumHandling) {\n\t\tJCClassDecl type = (JCClassDecl) typeNode.get();\n\t\t\n\t\tif (addGenerated) {\n\t\t\taddSuppressWarningsAll(field.mods, typeNode, typeNode.getNodeFor(getGeneratedBy(field)), typeNode.getContext());\n\t\t\taddGenerated(field.mods, typeNode, typeNode.getNodeFor(getGeneratedBy(field)), typeNode.getContext());\n\t\t}\n\t\t\n\t\tList<JCTree> insertAfter = null;\n\t\tList<JCTree> insertBefore = type.defs;\n\t\twhile (true) {\n\t\t\tboolean skip = false;\n\t\t\tif (insertBefore.head instanceof JCVariableDecl) {\n\t\t\t\tJCVariableDecl f = (JCVariableDecl) insertBefore.head;\n\t\t\t\tif ((!specialEnumHandling && isEnumConstant(f)) || isGenerated(f)) skip = true;\n\t\t\t} else if (insertBefore.head instanceof JCMethodDecl) {\n\t\t\t\tif ((((JCMethodDecl) insertBefore.head).mods.flags & GENERATEDCONSTR) != 0) skip = true;\n\t\t\t}\n\t\t\tif (skip) {\n\t\t\t\tinsertAfter = insertBefore;\n\t\t\t\tinsertBefore = insertBefore.tail;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tList<JCTree> fieldEntry = List.<JCTree>of(field);\n\t\tfieldEntry.tail = insertBefore;\n\t\tif (insertAfter == null) {\n\t\t\ttype.defs = fieldEntry;\n\t\t} else {\n\t\t\tinsertAfter.tail = fieldEntry;\n\t\t}\n\t\t\n\t\tEnterReflect.memberEnter(field, typeNode);\n\t\t\n\t\treturn typeNode.add(field, Kind.FIELD);\n\t}\n\t\n\tpublic static boolean isEnumConstant(final JCVariableDecl field) {\n\t\treturn (field.mods.flags & Flags.ENUM) != 0;\n\t}\n\t\n\tstatic class JCAnnotatedTypeReflect {\n\t\tprivate static Class<?> TYPE;\n\t\tprivate static Constructor<?> CONSTRUCTOR;\n\t\tprivate static Field ANNOTATIONS, UNDERLYING_TYPE;\n\t\t\n\t\tprivate static void initByLoader(ClassLoader classLoader) {\n\t\t\tif (TYPE != null) return;\n\t\t\tClass<?> c;\n\t\t\ttry {\n\t\t\t\tc = classLoader.loadClass(\"com.sun.tools.javac.tree.JCTree$JCAnnotatedType\");\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tinit(c);\n\t\t}\n\t\t\n\t\tprivate static void init(Class<?> in) {\n\t\t\tif (TYPE != null) return;\n\t\t\tif (!in.getName().equals(\"com.sun.tools.javac.tree.JCTree$JCAnnotatedType\")) return;\n\t\t\ttry {\n\t\t\t\tCONSTRUCTOR = Permit.getConstructor(in, List.class, JCExpression.class);\n\t\t\t\tANNOTATIONS = Permit.getField(in, \"annotations\");\n\t\t\t\tUNDERLYING_TYPE = Permit.getField(in, \"underlyingType\");\n\t\t\t\tTYPE = in;\n\t\t\t} catch (Exception ignore) {}\n\t\t}\n\t\t\n\t\tstatic boolean is(JCTree obj) {\n\t\t\tif (obj == null) return false;\n\t\t\tinit(obj.getClass());\n\t\t\treturn obj.getClass() == TYPE;\n\t\t}\n\t\t\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tstatic List<JCAnnotation> getAnnotations(JCTree obj) {\n\t\t\tinit(obj.getClass());\n\t\t\ttry {\n\t\t\t\treturn (List<JCAnnotation>) ANNOTATIONS.get(obj);\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn List.nil();\n\t\t\t}\n\t\t}\n\t\t\n\t\tstatic void setAnnotations(JCTree obj, List<JCAnnotation> anns) {\n\t\t\tinit(obj.getClass());\n\t\t\ttry {\n\t\t\t\tANNOTATIONS.set(obj, anns);\n\t\t\t} catch (Exception e) {}\n\t\t}\n\t\t\n\t\tstatic JCExpression getUnderlyingType(JCTree obj) {\n\t\t\tinit(obj.getClass());\n\t\t\ttry {\n\t\t\t\treturn (JCExpression) UNDERLYING_TYPE.get(obj);\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\t\n\t\tstatic JCExpression create(List<JCAnnotation> annotations, JCExpression underlyingType) {\n\t\t\tinitByLoader(underlyingType.getClass().getClassLoader());\n\t\t\ttry {\n\t\t\t\treturn (JCExpression) CONSTRUCTOR.newInstance(annotations, underlyingType);\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn underlyingType;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic class JCAnnotationReflect {\n\t\tprivate static final Field ATTRIBUTE;\n\n\t\tstatic {\n\t\t\tATTRIBUTE = Permit.permissiveGetField(JCAnnotation.class, \"attribute\");\n\t\t}\n\n\t\tstatic Attribute.Compound getAttribute(JCAnnotation jcAnnotation) {\n\t\t\tif (ATTRIBUTE != null) {\n\t\t\t\ttry {\n\t\t\t\t\treturn (Attribute.Compound) ATTRIBUTE.get(jcAnnotation);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t// Ignore\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tstatic void setAttribute(JCAnnotation jcAnnotation, Attribute.Compound attribute) {\n\t\t\tif (ATTRIBUTE != null) {\n\t\t\t\ttry {\n\t\t\t\t\tPermit.set(ATTRIBUTE, jcAnnotation, attribute);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t// Ignore\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// jdk9 support, types have changed, names stay the same\n\tstatic class ClassSymbolMembersField {\n\t\tprivate static final Field membersField;\n\t\tprivate static final Method removeMethod;\n\t\tprivate static final Method enterMethod;\n\t\t\n\t\tstatic {\n\t\t\tField f = null;\n\t\t\tMethod r = null;\n\t\t\tMethod e = null;\n\t\t\ttry {\n\t\t\t\tf = Permit.getField(ClassSymbol.class, \"members_field\");\n\t\t\t\tr = Permit.getMethod(f.getType(), \"remove\", Symbol.class);\n\t\t\t\te = Permit.getMethod(f.getType(), \"enter\", Symbol.class);\n\t\t\t} catch (Exception ex) {}\n\t\t\tmembersField = f;\n\t\t\tremoveMethod = r;\n\t\t\tenterMethod = e;\n\t\t}\n\t\t\n\t\tstatic void remove(ClassSymbol from, Symbol toRemove) {\n\t\t\tif (from == null) return;\n\t\t\ttry {\n\t\t\t\tScope scope = (Scope) membersField.get(from);\n\t\t\t\tif (scope == null) return;\n\t\t\t\tPermit.invoke(removeMethod, scope, toRemove);\n\t\t\t} catch (Exception e) {}\n\t\t}\n\t\t\n\t\tstatic void enter(ClassSymbol from, Symbol toEnter) {\n\t\t\tif (from == null) return;\n\t\t\ttry {\n\t\t\t\tScope scope = (Scope) membersField.get(from);\n\t\t\t\tif (scope == null) return;\n\t\t\t\tPermit.invoke(enterMethod, scope, toEnter);\n\t\t\t} catch (Exception e) {}\n\t\t}\n\t}\n\t\n\t/**\n\t * Adds the given new method declaration to the provided type AST Node.\n\t * Can also inject constructors.\n\t * \n\t * Also takes care of updating the JavacAST.\n\t */\n\tpublic static void injectMethod(JavacNode typeNode, JCMethodDecl method) {\n\t\tJCClassDecl type = (JCClassDecl) typeNode.get();\n\t\t\n\t\tif (method.getName().contentEquals(\"<init>\")) {\n\t\t\t//Scan for default constructor, and remove it.\n\t\t\tint idx = 0;\n\t\t\tfor (JCTree def : type.defs) {\n\t\t\t\tif (def instanceof JCMethodDecl) {\n\t\t\t\t\tif ((((JCMethodDecl) def).mods.flags & Flags.GENERATEDCONSTR) != 0) {\n\t\t\t\t\t\tJavacNode tossMe = typeNode.getNodeFor(def);\n\t\t\t\t\t\tif (tossMe != null) tossMe.up().removeChild(tossMe);\n\t\t\t\t\t\ttype.defs = addAllButOne(type.defs, idx);\n\t\t\t\t\t\tClassSymbolMembersField.remove(type.sym, ((JCMethodDecl) def).sym);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tidx++;\n\t\t\t}\n\t\t}\n\t\t\n\t\taddSuppressWarningsAll(method.mods, typeNode, typeNode.getNodeFor(getGeneratedBy(method)), typeNode.getContext());\n\t\taddGenerated(method.mods, typeNode, typeNode.getNodeFor(getGeneratedBy(method)), typeNode.getContext());\n\t\ttype.defs = type.defs.append(method);\n\t\t\n\t\tEnterReflect.memberEnter(method, typeNode);\n\t\t\n\t\ttypeNode.add(method, Kind.METHOD);\n\t}\n\n\t/**\n\t * Adds an inner type (class, interface, enum) to the given type. Cannot inject top-level types.\n\t * \n\t * @param typeNode parent type to inject new type into\n\t * @param type New type (class, interface, etc) to inject.\n\t * @return \n\t */\n\tpublic static JavacNode injectType(JavacNode typeNode, final JCClassDecl type) {\n\t\tJCClassDecl typeDecl = (JCClassDecl) typeNode.get();\n\t\taddSuppressWarningsAll(type.mods, typeNode, typeNode.getNodeFor(getGeneratedBy(type)), typeNode.getContext());\n\t\taddGenerated(type.mods, typeNode, typeNode.getNodeFor(getGeneratedBy(type)), typeNode.getContext());\n\t\ttypeDecl.defs = typeDecl.defs.append(type);\n\t\t\n\t\tEnterReflect.classEnter(type, typeNode);\n\t\t\n\t\treturn typeNode.add(type, Kind.TYPE);\n\t}\n\t\n\tstatic class EnterReflect {\n\t\tprivate static final Method classEnter;\n\t\tprivate static final Method memberEnter;\n\t\tprivate static final Method blockAnnotations;\n\t\tprivate static final Method unblockAnnotations;\n\t\t\n\t\tstatic {\n\t\t\tclassEnter = Permit.permissiveGetMethod(Enter.class, \"classEnter\", JCTree.class, Env.class);\n\t\t\tmemberEnter = Permit.permissiveGetMethod(MemberEnter.class, \"memberEnter\", JCTree.class, Env.class);\n\t\t\t\n\t\t\tMethod block = Permit.permissiveGetMethod(Annotate.class, \"blockAnnotations\");\n\t\t\tif (block == null) block = Permit.permissiveGetMethod(Annotate.class, \"enterStart\");\n\t\t\tblockAnnotations = block;\n\t\t\t\n\t\t\tMethod unblock = Permit.permissiveGetMethod(Annotate.class, \"unblockAnnotations\");\n\t\t\tif (unblock == null) unblock = Permit.permissiveGetMethod(Annotate.class, \"enterDone\");\n\t\t\tunblockAnnotations = unblock;\n\t\t}\n\t\t\n\t\tstatic Type classEnter(JCTree tree, JavacNode parent) {\n\t\t\tEnter enter = Enter.instance(parent.getContext());\n\t\t\tEnv<AttrContext> classEnv = enter.getEnv((TypeSymbol) parent.getElement());\n\t\t\tif (classEnv == null) return null;\n\t\t\tType type = (Type) Permit.invokeSneaky(classEnter, enter, tree, classEnv);\n\t\t\tif (type == null) return null;\n\t\t\ttype.complete();\n\t\t\treturn type;\n\t\t}\n\t\t\n\t\tstatic void memberEnter(JCTree tree, JavacNode parent) {\n\t\t\tContext context = parent.getContext();\n\t\t\tMemberEnter me = MemberEnter.instance(context);\n\t\t\tAnnotate annotate = Annotate.instance(context);\n\t\t\tEnter enter = Enter.instance(context);\n\t\t\t\n\t\t\tEnv<AttrContext> classEnv = enter.getEnv((TypeSymbol) parent.getElement());\n\t\t\tif (classEnv == null) return;\n\t\t\t\n\t\t\tPermit.invokeSneaky(blockAnnotations, annotate);\n\t\t\tPermit.invokeSneaky(memberEnter, me, tree, classEnv);\n\t\t\tPermit.invokeSneaky(unblockAnnotations, annotate);\n\t\t}\n\t}\n\t\n\tpublic static long addFinalIfNeeded(long flags, Context context) {\n\t\tboolean addFinal = LombokOptionsFactory.getDelombokOptions(context).getFormatPreferences().generateFinalParams();\n\t\t\n\t\tif (addFinal) flags |= Flags.FINAL;\n\t\treturn flags;\n\t}\n\t\n\tpublic static JCExpression genTypeRef(JavacNode node, String complexName) {\n\t\tString[] parts = complexName.split(\"\\\\.\");\n\t\tif (parts.length > 2 && parts[0].equals(\"java\") && parts[1].equals(\"lang\")) {\n\t\t\tString[] subParts = new String[parts.length - 2];\n\t\t\tSystem.arraycopy(parts, 2, subParts, 0, subParts.length);\n\t\t\treturn genJavaLangTypeRef(node, subParts);\n\t\t}\n\t\t\n\t\treturn chainDots(node, parts);\n\t}\n\t\n\tpublic static JCExpression genJavaLangTypeRef(JavacNode node, String... simpleNames) {\n\t\tif (LombokOptionsFactory.getDelombokOptions(node.getContext()).getFormatPreferences().javaLangAsFqn()) {\n\t\t\treturn chainDots(node, \"java\", \"lang\", simpleNames);\n\t\t} else {\n\t\t\treturn chainDots(node, null, null, simpleNames);\n\t\t}\n\t}\n\t\n\tpublic static JCExpression genJavaLangTypeRef(JavacNode node, int pos, String... simpleNames) {\n\t\tif (LombokOptionsFactory.getDelombokOptions(node.getContext()).getFormatPreferences().javaLangAsFqn()) {\n\t\t\treturn chainDots(node, pos, \"java\", \"lang\", simpleNames);\n\t\t} else {\n\t\t\treturn chainDots(node, pos, null, null, simpleNames);\n\t\t}\n\t}\n\t\n\tpublic static void addSuppressWarningsAll(JCModifiers mods, JavacNode node, JavacNode source, Context context) {\n\t\tif (!LombokOptionsFactory.getDelombokOptions(context).getFormatPreferences().generateSuppressWarnings()) return;\n\t\t\n\t\tboolean addJLSuppress = !Boolean.FALSE.equals(node.getAst().readConfiguration(ConfigurationKeys.ADD_SUPPRESSWARNINGS_ANNOTATIONS));\n\t\t\n\t\tif (addJLSuppress) {\n\t\t\tfor (JCAnnotation ann : mods.annotations) {\n\t\t\t\tJCTree type = ann.getAnnotationType();\n\t\t\t\tName n = null;\n\t\t\t\tif (type instanceof JCIdent) n = ((JCIdent) type).name;\n\t\t\t\telse if (type instanceof JCFieldAccess) n = ((JCFieldAccess) type).name;\n\t\t\t\tif (n != null && n.contentEquals(\"SuppressWarnings\")) {\n\t\t\t\t\taddJLSuppress = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (addJLSuppress) addAnnotation(mods, node, source, \"java.lang.SuppressWarnings\", node.getTreeMaker().Literal(\"all\"));\n\t\t\n\t\tif (Boolean.TRUE.equals(node.getAst().readConfiguration(ConfigurationKeys.ADD_FINDBUGS_SUPPRESSWARNINGS_ANNOTATIONS))) {\n\t\t\tJavacTreeMaker maker = node.getTreeMaker();\n\t\t\tJCExpression arg = maker.Assign(maker.Ident(node.toName(\"justification\")), maker.Literal(\"generated code\"));\n\t\t\taddAnnotation(mods, node, source, \"edu.umd.cs.findbugs.annotations.SuppressFBWarnings\", arg);\n\t\t}\n\t}\n\t\n\tpublic static void addGenerated(JCModifiers mods, JavacNode node, JavacNode source, Context context) {\n\t\tif (!LombokOptionsFactory.getDelombokOptions(context).getFormatPreferences().generateGenerated()) return;\n\t\t\n\t\tif (HandlerUtil.shouldAddGenerated(node)) {\n\t\t\taddAnnotation(mods, node, source, \"javax.annotation.Generated\", node.getTreeMaker().Literal(\"lombok\"));\n\t\t}\n\t\tif (Boolean.TRUE.equals(node.getAst().readConfiguration(ConfigurationKeys.ADD_LOMBOK_GENERATED_ANNOTATIONS))) {\n\t\t\taddAnnotation(mods, node, source, \"lombok.Generated\", null);\n\t\t}\n\t}\n\t\n\tpublic static void addAnnotation(JCModifiers mods, JavacNode node, JavacNode source, String annotationTypeFqn, JCExpression arg) {\n\t\tboolean isJavaLangBased;\n\t\tString simpleName; {\n\t\t\tint idx = annotationTypeFqn.lastIndexOf('.');\n\t\t\tsimpleName = idx == -1 ? annotationTypeFqn : annotationTypeFqn.substring(idx + 1);\n\t\t\t\n\t\t\tisJavaLangBased = idx == 9 && annotationTypeFqn.regionMatches(0, \"java.lang.\", 0, 10);\n\t\t}\n\t\t\n\t\tfor (JCAnnotation ann : mods.annotations) {\n\t\t\tJCTree annType = ann.getAnnotationType();\n\t\t\tif (annType instanceof JCIdent) {\n\t\t\t\tName lastPart = ((JCIdent) annType).name;\n\t\t\t\tif (lastPart.contentEquals(simpleName)) return;\n\t\t\t}\n\t\t\t\n\t\t\tif (annType instanceof JCFieldAccess) {\n\t\t\t\tif (annType.toString().equals(annotationTypeFqn)) return;\n\t\t\t}\n\t\t}\n\t\t\n\t\tJavacTreeMaker maker = node.getTreeMaker();\n\t\tJCExpression annType = isJavaLangBased ? genJavaLangTypeRef(node, simpleName) : chainDotsString(node, annotationTypeFqn);\n\t\tList<JCExpression> argList = arg != null ? List.of(arg) : List.<JCExpression>nil();\n\t\tJCAnnotation annotation = recursiveSetGeneratedBy(maker.Annotation(annType, argList), source);\n\t\tmods.annotations = mods.annotations.append(annotation);\n\t}\n\t\n\tstatic JCExpression addCheckerFrameworkReturnsReceiver(JCExpression returnType, JavacTreeMaker maker, JavacNode typeNode, CheckerFrameworkVersion cfv) {\n\t\tif (cfv.generateReturnsReceiver()) {\n\t\t\tJCAnnotation rrAnnotation = maker.Annotation(genTypeRef(typeNode, CheckerFrameworkVersion.NAME__RETURNS_RECEIVER), List.<JCExpression>nil());\n\t\t\treturnType = maker.AnnotatedType(List.of(rrAnnotation), returnType);\n\t\t}\n\t\treturn returnType;\n\t}\n\t\n\tprivate static List<JCTree> addAllButOne(List<JCTree> defs, int idx) {\n\t\tListBuffer<JCTree> out = new ListBuffer<JCTree>();\n\t\tint i = 0;\n\t\tfor (JCTree def : defs) {\n\t\t\tif (i++ != idx) out.append(def);\n\t\t}\n\t\treturn out.toList();\n\t}\n\t\n\t/**\n\t * In javac, dotted access of any kind, from {@code java.lang.String} to {@code var.methodName}\n\t * is represented by a fold-left of {@code Select} nodes with the leftmost string represented by\n\t * a {@code Ident} node. This method generates such an expression.\n\t * <p>\n\t * The position of the generated node(s) will be unpositioned (-1).\n\t * \n\t * For example, maker.Select(maker.Select(maker.Ident(NAME[java]), NAME[lang]), NAME[String]).\n\t * \n\t * @see com.sun.tools.javac.tree.JCTree.JCIdent\n\t * @see com.sun.tools.javac.tree.JCTree.JCFieldAccess\n\t */\n\tpublic static JCExpression chainDots(JavacNode node, String elem1, String elem2, String... elems) {\n\t\treturn chainDots(node, -1, elem1, elem2, elems);\n\t}\n\t\n\tpublic static JCExpression chainDots(JavacNode node, String[] elems) {\n\t\treturn chainDots(node, -1, null, null, elems);\n\t}\n\t\n\tpublic static JCExpression chainDots(JavacNode node, LombokImmutableList<String> elems) {\n\t\tassert elems != null;\n\t\t\n\t\tJavacTreeMaker maker = node.getTreeMaker();\n\t\tJCExpression e = null;\n\t\tfor (String elem : elems) {\n\t\t\tif (e == null) e = maker.Ident(node.toName(elem));\n\t\t\telse e = maker.Select(e, node.toName(elem));\n\t\t}\n\t\treturn e;\n\t}\n\t\n\t/**\n\t * In javac, dotted access of any kind, from {@code java.lang.String} to {@code var.methodName}\n\t * is represented by a fold-left of {@code Select} nodes with the leftmost string represented by\n\t * a {@code Ident} node. This method generates such an expression.\n\t * <p>\n\t * The position of the generated node(s) will be equal to the {@code pos} parameter.\n\t *\n\t * For example, maker.Select(maker.Select(maker.Ident(NAME[java]), NAME[lang]), NAME[String]).\n\t * \n\t * @see com.sun.tools.javac.tree.JCTree.JCIdent\n\t * @see com.sun.tools.javac.tree.JCTree.JCFieldAccess\n\t */\n\tpublic static JCExpression chainDots(JavacNode node, int pos, String elem1, String elem2, String... elems) {\n\t\tassert elems != null;\n\t\t\n\t\tJavacTreeMaker maker = node.getTreeMaker();\n\t\tif (pos != -1) maker = maker.at(pos);\n\t\tJCExpression e = null;\n\t\tif (elem1 != null) e = maker.Ident(node.toName(elem1));\n\t\tif (elem2 != null) e = e == null ? maker.Ident(node.toName(elem2)) : maker.Select(e, node.toName(elem2));\n\t\tfor (int i = 0 ; i < elems.length ; i++) {\n\t\t\te = e == null ? maker.Ident(node.toName(elems[i])) : maker.Select(e, node.toName(elems[i]));\n\t\t}\n\t\t\n\t\tassert e != null;\n\t\t\n\t\treturn e;\n\t}\n\t\n\t/**\n\t * In javac, dotted access of any kind, from {@code java.lang.String} to {@code var.methodName}\n\t * is represented by a fold-left of {@code Select} nodes with the leftmost string represented by\n\t * a {@code Ident} node. This method generates such an expression.\n\t * \n\t * For example, maker.Select(maker.Select(maker.Ident(NAME[java]), NAME[lang]), NAME[String]).\n\t * \n\t * @see com.sun.tools.javac.tree.JCTree.JCIdent\n\t * @see com.sun.tools.javac.tree.JCTree.JCFieldAccess\n\t */\n\tpublic static JCExpression chainDotsString(JavacNode node, String elems) {\n\t\treturn chainDots(node, null, null, elems.split(\"\\\\.\"));\n\t}\n\t\n\t/**\n\t * Searches the given field node for annotations and returns each one that matches the provided regular expression pattern.\n\t * \n\t * Only the simple name is checked - the package and any containing class are ignored.\n\t */\n\tpublic static List<JCAnnotation> findAnnotations(JavacNode fieldNode, Pattern namePattern) {\n\t\tListBuffer<JCAnnotation> result = new ListBuffer<JCAnnotation>();\n\t\tfor (JavacNode child : fieldNode.down()) {\n\t\t\tif (child.getKind() == Kind.ANNOTATION) {\n\t\t\t\tJCAnnotation annotation = (JCAnnotation) child.get();\n\t\t\t\tString name = annotation.annotationType.toString();\n\t\t\t\tint idx = name.lastIndexOf(\".\");\n\t\t\t\tString suspect = idx == -1 ? name : name.substring(idx + 1);\n\t\t\t\tif (namePattern.matcher(suspect).matches()) {\n\t\t\t\t\tresult.append(annotation);\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\t\treturn result.toList();\n\t}\n\t\n\tpublic static String scanForNearestAnnotation(JavacNode node, String... anns) {\n\t\twhile (node != null) {\n\t\t\tfor (JavacNode ann : node.down()) {\n\t\t\t\tif (ann.getKind() != Kind.ANNOTATION) continue;\n\t\t\t\tJCAnnotation a = (JCAnnotation) ann.get();\n\t\t\t\tfor (String annToFind : anns) if (typeMatches(annToFind, node, a.annotationType)) return annToFind;\n\t\t\t}\n\t\t\tnode = node.up();\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\t\n\tpublic static boolean hasNonNullAnnotations(JavacNode node) {\n\t\tfor (JavacNode child : node.down()) {\n\t\t\tif (child.getKind() == Kind.ANNOTATION) {\n\t\t\t\tJCAnnotation annotation = (JCAnnotation) child.get();\n\t\t\t\tString annotationTypeName = getTypeName(annotation.annotationType);\n\t\t\t\tfor (String nn : NONNULL_ANNOTATIONS) if (typeMatches(nn, node, annotationTypeName)) return true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tpublic static boolean hasNonNullAnnotations(JavacNode node, List<JCAnnotation> anns) {\n\t\tif (anns == null) return false;\n\t\tfor (JCAnnotation ann : anns) {\n\t\t\tString annotationTypeName = getTypeName(ann.annotationType);\n\t\t\tfor (String nn : NONNULL_ANNOTATIONS) if (typeMatches(nn, node, annotationTypeName)) return true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Searches the given field node for annotations and returns each one that is 'copyable' (either via configuration or from the base list).\n\t */\n\tpublic static List<JCAnnotation> findCopyableAnnotations(JavacNode node) {\n\t\tJCAnnotation anno = null;\n\t\tString annoName = null;\n\t\tfor (JavacNode child : node.down()) {\n\t\t\tif (child.getKind() == Kind.ANNOTATION) {\n\t\t\t\tif (anno != null) {\n\t\t\t\t\tannoName = \"\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tJCAnnotation annotation = (JCAnnotation) child.get();\n\t\t\t\tannoName = annotation.annotationType.toString();\n\t\t\t\tanno = annotation;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (annoName == null) return List.nil();\n\t\t\n\t\tjava.util.List<TypeName> configuredCopyable = node.getAst().readConfiguration(ConfigurationKeys.COPYABLE_ANNOTATIONS);\n\t\t\n\t\tif (!annoName.isEmpty()) {\n\t\t\tfor (TypeName cn : configuredCopyable) if (cn != null && typeMatches(cn.toString(), node, annoName)) return List.of(anno);\n\t\t\tfor (String bn : BASE_COPYABLE_ANNOTATIONS) if (typeMatches(bn, node, annoName)) return List.of(anno);\n\t\t}\n\n\t\tListBuffer<JCAnnotation> result = new ListBuffer<JCAnnotation>();\n\t\tfor (JavacNode child : node.down()) {\n\t\t\tif (child.getKind() == Kind.ANNOTATION) {\n\t\t\t\tJCAnnotation annotation = (JCAnnotation) child.get();\n\t\t\t\tString annotationTypeName = getTypeName(annotation.annotationType);\n\t\t\t\tboolean match = false;\n\t\t\t\tfor (TypeName cn : configuredCopyable) if (cn != null && typeMatches(cn.toString(), node, annotationTypeName)) {\n\t\t\t\t\tresult.append(annotation);\n\t\t\t\t\tmatch = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!match) for (String bn : BASE_COPYABLE_ANNOTATIONS) if (typeMatches(bn, node, annotationTypeName)) {\n\t\t\t\t\tresult.append(annotation);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result.toList();\n\t}\n\t\n\t/**\n\t * Searches the given field node for annotations that are specifically intentioned to be copied to the setter.\n\t */\n\tpublic static List<JCAnnotation> findCopyableToSetterAnnotations(JavacNode node) {\n\t\treturn findAnnotationsInList(node, COPY_TO_SETTER_ANNOTATIONS);\n\t}\n\n\t/**\n\t * Searches the given field node for annotations that are specifically intentioned to be copied to the builder's singular method.\n\t */\n\tpublic static List<JCAnnotation> findCopyableToBuilderSingularSetterAnnotations(JavacNode node) {\n\t\treturn findAnnotationsInList(node, COPY_TO_BUILDER_SINGULAR_SETTER_ANNOTATIONS);\n\t}\n\t\n\t/**\n\t * Searches the given field node for annotations that are in the given list, and returns those.\n\t */\n\tprivate static List<JCAnnotation> findAnnotationsInList(JavacNode node, java.util.List<String> annotationsToFind) {\n\t\tJCAnnotation anno = null;\n\t\tString annoName = null;\n\t\tfor (JavacNode child : node.down()) {\n\t\t\tif (child.getKind() == Kind.ANNOTATION) {\n\t\t\t\tif (anno != null) {\n\t\t\t\t\tannoName = \"\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tJCAnnotation annotation = (JCAnnotation) child.get();\n\t\t\t\tannoName = annotation.annotationType.toString();\n\t\t\t\tanno = annotation;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (annoName == null) return List.nil();\n\t\t\n\t\tif (!annoName.isEmpty()) {\n\t\t\tfor (String bn : annotationsToFind) if (typeMatches(bn, node, annoName)) return List.of(anno);\n\t\t}\n\t\t\n\t\tListBuffer<JCAnnotation> result = new ListBuffer<JCAnnotation>();\n\t\tfor (JavacNode child : node.down()) {\n\t\t\tif (child.getKind() == Kind.ANNOTATION) {\n\t\t\t\tJCAnnotation annotation = (JCAnnotation) child.get();\n\t\t\t\tString annotationTypeName = getTypeName(annotation.annotationType);\n\t\t\t\tboolean match = false;\n\t\t\t\tif (!match) for (String bn : annotationsToFind) if (typeMatches(bn, node, annotationTypeName)) {\n\t\t\t\t\tresult.append(annotation);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result.toList();\n\t}\n\t\n\t/**\n\t * Generates a new statement that checks if the given variable is null, and if so, throws a configured exception with the\n\t * variable name as message.\n\t */\n\tpublic static JCStatement generateNullCheck(JavacTreeMaker maker, JavacNode variable, JavacNode source) {\n\t\treturn generateNullCheck(maker, (JCVariableDecl) variable.get(), source);\n\t}\n\t\n\t/**\n\t * Generates a new statement that checks if the given local is null, and if so, throws a configured exception with the\n\t * local variable name as message. \n\t */\n\tpublic static JCStatement generateNullCheck(JavacTreeMaker maker, JCExpression typeNode, Name varName, JavacNode source, String customMessage) {\n\t\tNullCheckExceptionType exceptionType = source.getAst().readConfiguration(ConfigurationKeys.NON_NULL_EXCEPTION_TYPE);\n\t\tif (exceptionType == null) exceptionType = NullCheckExceptionType.NULL_POINTER_EXCEPTION;\n\t\t\n\t\tif (typeNode != null && isPrimitive(typeNode)) return null;\n\t\tJCLiteral message = maker.Literal(exceptionType.toExceptionMessage(varName.toString(), customMessage));\n\t\t\n\t\tLombokImmutableList<String> method = exceptionType.getMethod();\n\t\tif (method != null) {\n\t\t\treturn maker.Exec(maker.Apply(List.<JCExpression>nil(), chainDots(source, method), List.of(maker.Ident(varName), message)));\n\t\t}\n\t\t\n\t\tif (exceptionType == NullCheckExceptionType.ASSERTION) {\n\t\t\treturn maker.Assert(maker.Binary(CTC_NOT_EQUAL, maker.Ident(varName), maker.Literal(CTC_BOT, null)), message);\n\t\t}\n\t\t\n\t\tJCExpression exType = genTypeRef(source, exceptionType.getExceptionType());\n\t\tJCExpression exception = maker.NewClass(null, List.<JCExpression>nil(), exType, List.<JCExpression>of(message), null);\n\t\tJCStatement throwStatement = maker.Throw(exception);\n\t\tJCBlock throwBlock = maker.Block(0, List.of(throwStatement));\n\t\treturn maker.If(maker.Binary(CTC_EQUAL, maker.Ident(varName), maker.Literal(CTC_BOT, null)), throwBlock, null);\n\t}\n\t\n\t/**\n\t * Generates a new statement that checks if the given variable is null, and if so, throws a configured exception with the\n\t * variable name as message. \n\t * \n\t * This is a special case method reserved for use when the provided declaration differs from the\n\t * variable's declaration, i.e. in a constructor or setter where the local parameter is named the same but with the prefix\n\t * stripped as a result of @Accessors.prefix.\n\t */\n\tpublic static JCStatement generateNullCheck(JavacTreeMaker maker, JCVariableDecl varDecl, JavacNode source) {\n\t\treturn generateNullCheck(maker, varDecl.vartype, varDecl.name, source, null);\n\t}\n\t\n\t/**\n\t * Given a list of field names and a node referring to a type, finds each name in the list that does not match a field within the type.\n\t */\n\tpublic static List<Integer> createListOfNonExistentFields(List<String> list, JavacNode type, boolean excludeStandard, boolean excludeTransient) {\n\t\tboolean[] matched = new boolean[list.size()];\n\t\t\n\t\tfor (JavacNode child : type.down()) {\n\t\t\tif (list.isEmpty()) break;\n\t\t\tif (child.getKind() != Kind.FIELD) continue;\n\t\t\tJCVariableDecl field = (JCVariableDecl)child.get();\n\t\t\tif (excludeStandard) {\n\t\t\t\tif ((field.mods.flags & Flags.STATIC) != 0) continue;\n\t\t\t\tif (field.name.toString().startsWith(\"$\")) continue;\n\t\t\t}\n\t\t\tif (excludeTransient && (field.mods.flags & Flags.TRANSIENT) != 0) continue;\n\t\t\t\n\t\t\tint idx = list.indexOf(child.getName());\n\t\t\tif (idx > -1) matched[idx] = true;\n\t\t}\n\t\t\n\t\tListBuffer<Integer> problematic = new ListBuffer<Integer>();\n\t\tfor (int i = 0 ; i < list.size() ; i++) {\n\t\t\tif (!matched[i]) problematic.append(i);\n\t\t}\n\t\t\n\t\treturn problematic.toList();\n\t}\n\t\n\tstatic List<JCAnnotation> unboxAndRemoveAnnotationParameter(JCAnnotation ast, String parameterName, String errorName, JavacNode annotationNode) {\n\t\tListBuffer<JCExpression> params = new ListBuffer<JCExpression>();\n\t\tListBuffer<JCAnnotation> result = new ListBuffer<JCAnnotation>();\n\t\t\n\t\touter:\n\t\tfor (JCExpression param : ast.args) {\n\t\t\tboolean allowRaw;\n\t\t\tString nameOfParam = \"value\";\n\t\t\tJCExpression valueOfParam = null;\n\t\t\tif (param instanceof JCAssign) {\n\t\t\t\tJCAssign assign = (JCAssign) param;\n\t\t\t\tif (assign.lhs instanceof JCIdent) {\n\t\t\t\t\tJCIdent ident = (JCIdent) assign.lhs;\n\t\t\t\t\tnameOfParam = ident.name.toString();\n\t\t\t\t}\n\t\t\t\tvalueOfParam = assign.rhs;\n\t\t\t}\n\t\t\t\n\t\t\t/* strip trailing underscores */ {\n\t\t\t\tint lastIdx;\n\t\t\t\tfor (lastIdx = nameOfParam.length() ; lastIdx > 0; lastIdx--) {\n\t\t\t\t\tif (nameOfParam.charAt(lastIdx - 1) != '_') break;\n\t\t\t\t}\n\t\t\t\tallowRaw = lastIdx < nameOfParam.length();\n\t\t\t\tnameOfParam = nameOfParam.substring(0, lastIdx);\n\t\t\t}\n\t\t\t\n\t\t\tif (!parameterName.equals(nameOfParam)) {\n\t\t\t\tparams.append(param);\n\t\t\t\tcontinue outer;\n\t\t\t}\n\t\t\t\n\t\t\tint endPos = Javac.getEndPosition(param.pos(), (JCCompilationUnit) annotationNode.top().get());\n\t\t\tannotationNode.getAst().removeFromDeferredDiagnostics(param.pos, endPos);\n\t\t\t\n\t\t\tif (valueOfParam instanceof JCAnnotation) {\n\t\t\t\tString dummyAnnotationName = ((JCAnnotation) valueOfParam).annotationType.toString();\n\t\t\t\tdummyAnnotationName = dummyAnnotationName.replace(\"_\", \"\").replace(\"$\", \"\").replace(\"x\", \"\").replace(\"X\", \"\");\n\t\t\t\tif (dummyAnnotationName.length() > 0) {\n\t\t\t\t\tif (allowRaw) {\n\t\t\t\t\t\tresult.append((JCAnnotation) valueOfParam);\n\t\t\t\t\t} else {\n\t\t\t\t\t\taddError(errorName, annotationNode);\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (JCExpression expr : ((JCAnnotation) valueOfParam).args) {\n\t\t\t\t\t\tif (expr instanceof JCAssign && ((JCAssign) expr).lhs instanceof JCIdent) {\n\t\t\t\t\t\t\tJCIdent id = (JCIdent) ((JCAssign) expr).lhs;\n\t\t\t\t\t\t\tif (\"value\".equals(id.name.toString())) {\n\t\t\t\t\t\t\t\texpr = ((JCAssign) expr).rhs;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\taddError(errorName, annotationNode);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (expr instanceof JCAnnotation) {\n\t\t\t\t\t\t\tresult.append((JCAnnotation) expr);\n\t\t\t\t\t\t} else if (expr instanceof JCNewArray) {\n\t\t\t\t\t\t\tfor (JCExpression expr2 : ((JCNewArray) expr).elems) {\n\t\t\t\t\t\t\t\tif (expr2 instanceof JCAnnotation) {\n\t\t\t\t\t\t\t\t\tresult.append((JCAnnotation) expr2);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\taddError(errorName, annotationNode);\n\t\t\t\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\taddError(errorName, annotationNode);\n\t\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (valueOfParam instanceof JCNewArray) {\n\t\t\t\tJCNewArray arr = (JCNewArray) valueOfParam;\n\t\t\t\tif (arr.elems.isEmpty()) {\n\t\t\t\t\t// Just remove it, this is always fine.\n\t\t\t\t} else if (allowRaw) {\n\t\t\t\t\tfor (JCExpression jce : arr.elems) {\n\t\t\t\t\t\tif (jce instanceof JCAnnotation) result.append((JCAnnotation) jce);\n\t\t\t\t\t\telse addError(errorName, annotationNode);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\taddError(errorName, annotationNode);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\taddError(errorName, annotationNode);\n\t\t\t}\n\t\t}\n\t\tfor (JCAnnotation annotation : result) {\n\t\t\tclearTypes(annotation);\n\t\t}\n\t\tast.args = params.toList();\n\t\treturn result.toList();\n\t}\n\t\n\t/**\n\t * Removes all type information from the provided tree.\n\t */\n\tprivate static void clearTypes(JCTree tree) {\n\t\ttree.accept(new TreeScanner() {\n\t\t\t@Override public void scan(JCTree tree) {\n\t\t\t\tif (tree == null) return;\n\t\t\t\ttree.type = null;\n\t\t\t\tsuper.scan(tree);\n\t\t\t}\n\t\t\t@Override public void visitClassDef(JCClassDecl tree) {\n\t\t\t\ttree.sym = null;\n\t\t\t\tsuper.visitClassDef(tree);\n\t\t\t}\n\t\t\t@Override public void visitMethodDef(JCMethodDecl tree) {\n\t\t\t\ttree.sym = null;\n\t\t\t\tsuper.visitMethodDef(tree);\n\t\t\t}\n\t\t\t@Override public void visitVarDef(JCVariableDecl tree) {\n\t\t\t\ttree.sym = null;\n\t\t\t\tsuper.visitVarDef(tree);\n\t\t\t}\n\t\t\t@Override public void visitSelect(JCFieldAccess tree) {\n\t\t\t\ttree.sym = null;\n\t\t\t\tsuper.visitSelect(tree);\n\t\t\t}\n\t\t\t@Override public void visitIdent(JCIdent tree) {\n\t\t\t\ttree.sym = null;\n\t\t\t\tsuper.visitIdent(tree);\n\t\t\t}\n\t\t\t@Override public void visitAnnotation(JCAnnotation tree) {\n\t\t\t\tJCAnnotationReflect.setAttribute(tree, null);\n\t\t\t\tsuper.visitAnnotation(tree);\n\t\t\t}\n\t\t});\n\t}\n\t\n\tprivate static void addError(String errorName, JavacNode node) {\n\t\tif (node.getLatestJavaSpecSupported() < 8) {\n\t\t\tnode.addError(\"The correct format up to JDK7 is \" + errorName + \"=@__({@SomeAnnotation, @SomeOtherAnnotation}))\");\n\t\t} else {\n\t\t\tnode.addError(\"The correct format for JDK8+ is \" + errorName + \"_={@SomeAnnotation, @SomeOtherAnnotation})\");\n\t\t}\n\t}\n\t\n\tpublic static List<JCTypeParameter> copyTypeParams(JavacNode source, List<JCTypeParameter> params) {\n\t\tif (params == null || params.isEmpty()) return params;\n\t\tListBuffer<JCTypeParameter> out = new ListBuffer<JCTypeParameter>();\n\t\tJavacTreeMaker maker = source.getTreeMaker();\n\t\tfor (JCTypeParameter tp : params) {\n\t\t\tList<JCExpression> bounds = tp.bounds;\n\t\t\tif (bounds != null && !bounds.isEmpty()) {\n\t\t\t\tListBuffer<JCExpression> boundsCopy = new ListBuffer<JCExpression>();\n\t\t\t\tfor (JCExpression expr : tp.bounds) {\n\t\t\t\t\tboundsCopy.append(cloneType(maker, expr, source));\n\t\t\t\t}\n\t\t\t\tbounds = boundsCopy.toList();\n\t\t\t}\n\t\t\tout.append(maker.TypeParameter(tp.name, bounds));\n\t\t}\n\t\treturn out.toList();\n\t}\n\t\n\tpublic static List<JCAnnotation> getTypeUseAnnotations(JCExpression from) {\n\t\tif (!JCAnnotatedTypeReflect.is(from)) return List.nil();\n\t\treturn JCAnnotatedTypeReflect.getAnnotations(from);\n\t}\n\t\n\tpublic static JCExpression removeTypeUseAnnotations(JCExpression from) {\n\t\tif (!JCAnnotatedTypeReflect.is(from)) return from;\n\t\treturn JCAnnotatedTypeReflect.getUnderlyingType(from);\n\t}\n\t\n\tpublic static JCExpression namePlusTypeParamsToTypeReference(JavacTreeMaker maker, JavacNode type, List<JCTypeParameter> params) {\n\t\tJCClassDecl td = (JCClassDecl) type.get();\n\t\tboolean instance = (td.mods.flags & Flags.STATIC) == 0;\n\t\treturn namePlusTypeParamsToTypeReference(maker, type.up(), td.name, instance, params, List.<JCAnnotation>nil());\n\t}\n\t\n\tpublic static JCExpression namePlusTypeParamsToTypeReference(JavacTreeMaker maker, JavacNode type, List<JCTypeParameter> params, List<JCAnnotation> annotations) {\n\t\tJCClassDecl td = (JCClassDecl) type.get();\n\t\tboolean instance = (td.mods.flags & Flags.STATIC) == 0;\n\t\treturn namePlusTypeParamsToTypeReference(maker, type.up(), td.name, instance, params, annotations);\n\t}\n\t\n\tpublic static JCExpression namePlusTypeParamsToTypeReference(JavacTreeMaker maker, JavacNode parentType, Name typeName, boolean instance, List<JCTypeParameter> params) {\n\t\treturn namePlusTypeParamsToTypeReference(maker, parentType, typeName, instance, params, List.<JCAnnotation>nil());\n\t}\n\t\n\tpublic static JCExpression namePlusTypeParamsToTypeReference(JavacTreeMaker maker, JavacNode parentType, Name typeName, boolean instance, List<JCTypeParameter> params, List<JCAnnotation> annotations) {\n\t\tJCExpression r = null;\n\t\tif (parentType != null && parentType.getKind() == Kind.TYPE && !parentType.getName().isEmpty()) {\n\t\t\tJCClassDecl td = (JCClassDecl) parentType.get();\n\t\t\tboolean outerInstance = instance && ((td.mods.flags & Flags.STATIC) == 0);\n\t\t\tList<JCTypeParameter> outerParams = instance ? td.typarams : List.<JCTypeParameter>nil();\n\t\t\tr = namePlusTypeParamsToTypeReference(maker, parentType.up(), td.name, outerInstance, outerParams, List.<JCAnnotation>nil());\n\t\t}\n\t\t\n\t\tr = r == null ? maker.Ident(typeName) : maker.Select(r, typeName);\n\t\tif (!annotations.isEmpty()) r = JCAnnotatedTypeReflect.create(annotations, r);\n\t\tif (!params.isEmpty()) r = maker.TypeApply(r, typeParameterNames(maker, params));\n\t\treturn r;\n\t}\n\t\n\tpublic static List<JCExpression> typeParameterNames(JavacTreeMaker maker, List<JCTypeParameter> params) {\n\t\tListBuffer<JCExpression> typeArgs = new ListBuffer<JCExpression>();\n\t\tfor (JCTypeParameter param : params) {\n\t\t\ttypeArgs.append(maker.Ident(param.name));\n\t\t}\n\t\treturn typeArgs.toList();\n\t}\n\t\n\tpublic static void sanityCheckForMethodGeneratingAnnotationsOnBuilderClass(JavacNode typeNode, JavacNode errorNode) {\n\t\tList<String> disallowed = List.nil();\n\t\tfor (JavacNode child : typeNode.down()) {\n\t\t\tfor (String annType : INVALID_ON_BUILDERS) {\n\t\t\t\tif (annotationTypeMatches(annType, child)) {\n\t\t\t\t\tint lastIndex = annType.lastIndexOf('.');\n\t\t\t\t\tdisallowed = disallowed.append(lastIndex == -1 ? annType : annType.substring(lastIndex + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint size = disallowed.size();\n\t\tif (size == 0) return;\n\t\tif (size == 1) {\n\t\t\terrorNode.addError(\"@\" + disallowed.head + \" is not allowed on builder classes.\");\n\t\t\treturn;\n\t\t}\n\t\tStringBuilder out = new StringBuilder();\n\t\tfor (String a : disallowed) out.append(\"@\").append(a).append(\", \");\n\t\tout.setLength(out.length() - 2);\n\t\terrorNode.addError(out.append(\" are not allowed on builder classes.\").toString());\n\t}\n\t\n\tstatic List<JCAnnotation> copyAnnotations(List<? extends JCExpression> in) {\n\t\tListBuffer<JCAnnotation> out = new ListBuffer<JCAnnotation>();\n\t\tfor (JCExpression expr : in) {\n\t\t\tif (!(expr instanceof JCAnnotation)) continue;\n\t\t\tout.append((JCAnnotation) expr.clone());\n\t\t}\n\t\treturn out.toList();\n\t}\n\t\n\tstatic List<JCAnnotation> mergeAnnotations(List<JCAnnotation> a, List<JCAnnotation> b) {\n\t\tif (a == null || a.isEmpty()) return b;\n\t\tif (b == null || b.isEmpty()) return a;\n\t\tListBuffer<JCAnnotation> out = new ListBuffer<JCAnnotation>();\n\t\tfor (JCAnnotation ann : a) out.append(ann);\n\t\tfor (JCAnnotation ann : b) out.append(ann);\n\t\treturn out.toList();\n\t}\n\t\n\t/**\n\t * Returns {@code true} if the provided node is an actual class and not some other type declaration (so, not an annotation definition, interface, enum, or record).\n\t */\n\tpublic static boolean isClass(JavacNode typeNode) {\n\t\treturn isClassAndDoesNotHaveFlags(typeNode, Flags.INTERFACE | Flags.ENUM | Flags.ANNOTATION | RECORD);\n\t}\n\t\n\t/**\n\t * Returns {@code true} if the provided node is an actual class or enum and not some other type declaration (so, not an annotation definition, interface, or record).\n\t */\n\tpublic static boolean isClassOrEnum(JavacNode typeNode) {\n\t\treturn isClassAndDoesNotHaveFlags(typeNode, Flags.INTERFACE | Flags.ANNOTATION | RECORD);\n\t}\n\t\n\tpublic static boolean isClassOrEnumOrInterface(JavacNode typeNode) {\n\t\treturn isClassAndDoesNotHaveFlags(typeNode, Flags.ANNOTATION | RECORD);\n\t}\n\t\n\t/**\n\t * Returns {@code true} if the provided node is an actual class, an enum or a record and not some other type declaration (so, not an annotation definition or interface).\n\t */\n\tpublic static boolean isClassEnumOrRecord(JavacNode typeNode) {\n\t\treturn isClassAndDoesNotHaveFlags(typeNode, Flags.INTERFACE | Flags.ANNOTATION);\n\t}\n\t\n\t/**\n\t * Returns {@code true} if the provided node is a record declaration (so, not an annotation definition, interface, enum, or plain class).\n\t */\n\tpublic static boolean isRecord(JavacNode typeNode) {\n\t\treturn typeNode.getKind() == Kind.TYPE && (((JCClassDecl) typeNode.get()).mods.flags & RECORD) != 0;\n\t}\n\t\n\tpublic static boolean isClassAndDoesNotHaveFlags(JavacNode typeNode, long flags) {\n\t\tJCClassDecl typeDecl = null;\n\t\tif (typeNode.get() instanceof JCClassDecl) typeDecl = (JCClassDecl) typeNode.get();\n\t\telse return false;\n\t\t\n\t\tlong typeDeclflags = typeDecl == null ? 0 : typeDecl.mods.flags;\n\t\treturn (typeDeclflags & flags) == 0;\n\t}\n\t\n\t/**\n\t * Returns {@code true} if the provided node supports static methods and types (top level or static class)\n\t */\n\tpublic static boolean isStaticAllowed(JavacNode typeNode) {\n\t\treturn typeNode.isStatic() || typeNode.up() == null || typeNode.up().getKind() == Kind.COMPILATION_UNIT || isRecord(typeNode);\n\t}\n\t\n\tpublic static JavacNode upToTypeNode(JavacNode node) {\n\t\tif (node == null) throw new NullPointerException(\"node\");\n\t\twhile ((node != null) && !(node.get() instanceof JCClassDecl)) node = node.up();\n\t\t\n\t\treturn node;\n\t}\n\t\n\tpublic static List<JCExpression> cloneTypes(JavacTreeMaker maker, List<JCExpression> in, JavacNode source) {\n\t\tif (in.isEmpty()) return List.nil();\n\t\tif (in.size() == 1) return List.of(cloneType(maker, in.get(0), source));\n\t\tListBuffer<JCExpression> lb = new ListBuffer<JCExpression>();\n\t\tfor (JCExpression expr : in) lb.append(cloneType(maker, expr, source));\n\t\treturn lb.toList();\n\t}\n\t\n\t/**\n\t * Creates a full clone of a given javac AST type node. Every part is cloned (every identifier, every select, every wildcard, every type apply, every type_use annotation).\n\t * \n\t * If there's any node in the tree that we don't know how to clone, that part isn't cloned. However, we wouldn't know what could possibly show up that we\n\t * can't currently clone; that's just a safeguard.\n\t * \n\t * This should be used if the type looks the same in the code, but resolves differently. For example, a static method that has some generics in it named after\n\t * the class's own parameter, but as its a static method, the static method's notion of {@code T} is different from the class notion of {@code T}. If you're duplicating\n\t * a type used in the class context, you need to use this method.\n\t */\n\tpublic static JCExpression cloneType(JavacTreeMaker maker, JCExpression in, JavacNode source) {\n\t\tJCExpression out = cloneType0(maker, in);\n\t\tif (out != null) recursiveSetGeneratedBy(out, source);\n\t\treturn out;\n\t}\n\t\n\tprivate static JCExpression cloneType0(JavacTreeMaker maker, JCTree in) {\n\t\tif (in == null) return null;\n\t\t\n\t\tif (in instanceof JCPrimitiveTypeTree) {\n\t\t\treturn maker.TypeIdent(TypeTag.typeTag(in));\n\t\t}\n\t\t\n\t\tif (in instanceof JCIdent) {\n\t\t\treturn maker.Ident(((JCIdent) in).name);\n\t\t}\n\t\t\n\t\tif (in instanceof JCFieldAccess) {\n\t\t\tJCFieldAccess fa = (JCFieldAccess) in;\n\t\t\treturn maker.Select(cloneType0(maker, fa.selected), fa.name);\n\t\t}\n\t\t\n\t\tif (in instanceof JCArrayTypeTree) {\n\t\t\tJCArrayTypeTree att = (JCArrayTypeTree) in;\n\t\t\treturn maker.TypeArray(cloneType0(maker, att.elemtype));\n\t\t}\n\t\t\n\t\tif (in instanceof JCTypeApply) {\n\t\t\tJCTypeApply ta = (JCTypeApply) in;\n\t\t\tListBuffer<JCExpression> lb = new ListBuffer<JCExpression>();\n\t\t\tfor (JCExpression typeArg : ta.arguments) {\n\t\t\t\tlb.append(cloneType0(maker, typeArg));\n\t\t\t}\n\t\t\treturn maker.TypeApply(cloneType0(maker, ta.clazz), lb.toList());\n\t\t}\n\t\t\n\t\tif (in instanceof JCWildcard) {\n\t\t\tJCWildcard w = (JCWildcard) in;\n\t\t\tJCExpression newInner = cloneType0(maker, w.inner);\n\t\t\tTypeBoundKind newKind;\n\t\t\tswitch (w.getKind()) {\n\t\t\tcase SUPER_WILDCARD:\n\t\t\t\tnewKind = maker.TypeBoundKind(BoundKind.SUPER);\n\t\t\t\tbreak;\n\t\t\tcase EXTENDS_WILDCARD:\n\t\t\t\tnewKind = maker.TypeBoundKind(BoundKind.EXTENDS);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\tcase UNBOUNDED_WILDCARD:\n\t\t\t\tnewKind = maker.TypeBoundKind(BoundKind.UNBOUND);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn maker.Wildcard(newKind, newInner);\n\t\t}\n\t\t\n\t\tif (JCAnnotatedTypeReflect.is(in)) {\n\t\t\tJCExpression underlyingType = cloneType0(maker, JCAnnotatedTypeReflect.getUnderlyingType(in));\n\t\t\tList<JCAnnotation> anns = copyAnnotations(JCAnnotatedTypeReflect.getAnnotations(in));\n\t\t\treturn JCAnnotatedTypeReflect.create(anns, underlyingType);\n\t\t}\n\t\t\n\t\t// This is somewhat unsafe, but it's better than outright throwing an exception here. Returning null will just cause an exception down the pipeline.\n\t\treturn (JCExpression) in;\n\t}\n\t\n\tpublic static enum CopyJavadoc {\n\t\tVERBATIM {\n\t\t\t@Override public String apply(final JCCompilationUnit cu, final JavacNode node) {\n\t\t\t\treturn Javac.getDocComment(cu, node.get());\n\t\t\t}\n\t\t},\n\t\tGETTER {\n\t\t\t@Override public String apply(final JCCompilationUnit cu, final JavacNode node) {\n\t\t\t\tfinal JCTree n = node.get();\n\t\t\t\tString javadoc = Javac.getDocComment(cu, n);\n\t\t\t\t// step 1: Check if there is a 'GETTER' section. If yes, that becomes the new method's javadoc.\n\t\t\t\tString out = getJavadocSection(javadoc, \"GETTER\");\n\t\t\t\tfinal boolean sectionBased = out != null;\n\t\t\t\tif (!sectionBased) {\n\t\t\t\t\tout = stripLinesWithTagFromJavadoc(stripSectionsFromJavadoc(javadoc), JavadocTag.PARAM);\n\t\t\t\t}\n\t\t\t\tnode.getAst().cleanupTask(\"javadocfilter-getter\", n, new CleanupTask() {\n\t\t\t\t\t@Override public void cleanup() {\n\t\t\t\t\t\tString javadoc = Javac.getDocComment(cu, n);\n\t\t\t\t\t\tif (javadoc == null || javadoc.isEmpty()) return;\n\t\t\t\t\t\tjavadoc = stripSectionsFromJavadoc(javadoc);\n\t\t\t\t\t\tif (!sectionBased) {\n\t\t\t\t\t\t\tjavadoc = stripLinesWithTagFromJavadoc(stripSectionsFromJavadoc(javadoc), JavadocTag.RETURN);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tJavac.setDocComment(cu, n, javadoc);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn out;\n\t\t\t}\n\t\t},\n\t\tSETTER {\n\t\t\t@Override public String apply(final JCCompilationUnit cu, final JavacNode node) {\n\t\t\t\treturn applySetter(cu, node, \"SETTER\");\n\t\t\t}\n\t\t},\n\t\tWITH {\n\t\t\t@Override public String apply(final JCCompilationUnit cu, final JavacNode node) {\n\t\t\t\treturn addReturnsUpdatedSelfIfNeeded(applySetter(cu, node, \"WITH|WITHER\"));\n\t\t\t}\n\t\t},\n\t\tWITH_BY {\n\t\t\t@Override public String apply(final JCCompilationUnit cu, final JavacNode node) {\n\t\t\t\treturn applySetter(cu, node, \"WITHBY|WITH_BY\");\n\t\t\t}\n\t\t};\n\t\t\n\t\tpublic abstract String apply(final JCCompilationUnit cu, final JavacNode node);\n\t\t\n\t\tprivate static String applySetter(final JCCompilationUnit cu, JavacNode node, String sectionName) {\n\t\t\tfinal JCTree n = node.get();\n\t\t\tString javadoc = Javac.getDocComment(cu, n);\n\t\t\t// step 1: Check if there is a 'SETTER' section. If yes, that becomes the new method's javadoc.\n\t\t\tString out = getJavadocSection(javadoc, sectionName);\n\t\t\tfinal boolean sectionBased = out != null;\n\t\t\tif (!sectionBased) {\n\t\t\t\tout = stripLinesWithTagFromJavadoc(stripSectionsFromJavadoc(javadoc), JavadocTag.RETURN);\n\t\t\t}\n\t\t\tnode.getAst().cleanupTask(\"javadocfilter-setter\", n, new CleanupTask() {\n\t\t\t\t@Override public void cleanup() {\n\t\t\t\t\tString javadoc = Javac.getDocComment(cu, n);\n\t\t\t\t\tif (javadoc == null || javadoc.isEmpty()) return;\n\t\t\t\t\tjavadoc = stripSectionsFromJavadoc(javadoc);\n\t\t\t\t\tif (!sectionBased) {\n\t\t\t\t\t\tjavadoc = stripLinesWithTagFromJavadoc(stripSectionsFromJavadoc(javadoc), JavadocTag.PARAM);\n\t\t\t\t\t}\n\t\t\t\t\tJavac.setDocComment(cu, n, javadoc);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn shouldReturnThis(node, JavacHandlerUtil.getAccessorsForField(node)) ? addReturnsThisIfNeeded(out) : out;\n\t\t}\n\t}\n\t\n\tpublic static void copyJavadoc(JavacNode from, JCTree to, CopyJavadoc copyMode) {\n\t\tcopyJavadoc(from, to, copyMode, false);\n\t}\n\t\n\t/**\n\t * Copies javadoc on one node to the other.\n\t * \n\t * in 'GETTER' copyMode, first a 'GETTER' segment is searched for. If it exists, that will become the javadoc for the 'to' node, and this section is\n\t * stripped out of the 'from' node. If no 'GETTER' segment is found, then the entire javadoc is taken minus any {@code @param} lines and other sections.\n\t * any {@code @return} lines are stripped from 'from'.\n\t * \n\t * in 'SETTER' mode, stripping works similarly to 'GETTER' mode, except {@code param} are copied and stripped from the original and {@code @return} are skipped.\n\t */\n\tpublic static void copyJavadoc(JavacNode from, JCTree to, CopyJavadoc copyMode, boolean forceAddReturn) {\n\t\tif (copyMode == null) copyMode = CopyJavadoc.VERBATIM;\n\t\ttry {\n\t\t\tJCCompilationUnit cu = ((JCCompilationUnit) from.top().get());\n\t\t\tString newJavadoc = copyMode.apply(cu, from);\n\t\t\tif (forceAddReturn) {\n\t\t\t\tnewJavadoc = addReturnsThisIfNeeded(newJavadoc);\n\t\t\t}\n\t\t\tJavac.setDocComment(cu, to, newJavadoc);\n\t\t} catch (Exception ignore) {}\n\t}\n\t\n\tpublic static boolean isDirectDescendantOfObject(JavacNode typeNode) {\n\t\tif (!(typeNode.get() instanceof JCClassDecl)) throw new IllegalArgumentException(\"not a type node\");\n\t\tJCTree extending = Javac.getExtendsClause((JCClassDecl) typeNode.get());\n\t\tif (extending == null) return true;\n\t\tString p = extending.toString();\n\t\treturn p.equals(\"Object\") || p.equals(\"java.lang.Object\");\n\t}\n\t\n\tpublic static void createRelevantNullableAnnotation(JavacNode typeNode, JCMethodDecl mth) {\n\t\tNullAnnotationLibrary lib = typeNode.getAst().readConfiguration(ConfigurationKeys.ADD_NULL_ANNOTATIONS);\n\t\tif (lib == null) return;\n\t\tapplyAnnotationToMethodDecl(typeNode, mth, lib.getNullableAnnotation(), lib.isTypeUse());\n\t}\n\t\n\tpublic static void createRelevantNonNullAnnotation(JavacNode typeNode, JCMethodDecl mth) {\n\t\tNullAnnotationLibrary lib = typeNode.getAst().readConfiguration(ConfigurationKeys.ADD_NULL_ANNOTATIONS);\n\t\tif (lib == null) return;\n\t\tapplyAnnotationToMethodDecl(typeNode, mth, lib.getNonNullAnnotation(), lib.isTypeUse());\n\t}\n\t\n\tpublic static void createRelevantNonNullAnnotation(JavacNode typeNode, JCVariableDecl arg) {\n\t\tNullAnnotationLibrary lib = typeNode.getAst().readConfiguration(ConfigurationKeys.ADD_NULL_ANNOTATIONS);\n\t\tif (lib == null) return;\n\t\t\n\t\tapplyAnnotationToVarDecl(typeNode, arg, lib.getNonNullAnnotation(), lib.isTypeUse());\n\t}\n\t\n\tpublic static void createRelevantNullableAnnotation(JavacNode typeNode, JCVariableDecl arg) {\n\t\tNullAnnotationLibrary lib = typeNode.getAst().readConfiguration(ConfigurationKeys.ADD_NULL_ANNOTATIONS);\n\t\tif (lib == null) return;\n\t\t\n\t\tapplyAnnotationToVarDecl(typeNode, arg, lib.getNullableAnnotation(), lib.isTypeUse());\n\t}\n\t\n\tprivate static void applyAnnotationToMethodDecl(JavacNode typeNode, JCMethodDecl mth, String annType, boolean typeUse) {\n\t\tif (annType == null) return;\n\t\tJavacTreeMaker maker = typeNode.getTreeMaker();\n\t\t\n\t\tJCAnnotation m = maker.Annotation(genTypeRef(typeNode, annType), List.<JCExpression>nil());\n\t\tif (typeUse) {\n\t\t\tJCExpression resType = mth.restype;\n\t\t\tif (resType instanceof JCTypeApply) {\n\t\t\t\tJCTypeApply ta = (JCTypeApply) resType;\n\t\t\t\tif (ta.clazz instanceof JCFieldAccess) {\n\t\t\t\t\tmth.restype = maker.TypeApply(maker.AnnotatedType(List.of(m), ta.clazz), ta.arguments);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tresType = ta.clazz;\n\t\t\t}\n\t\t\t\n\t\t\tif (resType instanceof JCFieldAccess || resType instanceof JCArrayTypeTree) {\n\t\t\t\tmth.restype = maker.AnnotatedType(List.of(m), resType);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif (JCAnnotatedTypeReflect.is(resType)) {\n\t\t\t\tList<JCAnnotation> annotations = JCAnnotatedTypeReflect.getAnnotations(resType);\n\t\t\t\tJCAnnotatedTypeReflect.setAnnotations(resType, annotations.prepend(m));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif (resType instanceof JCPrimitiveTypeTree || resType instanceof JCIdent) {\n\t\t\t\tmth.mods.annotations = mth.mods.annotations == null ? List.of(m) : mth.mods.annotations.prepend(m);\n\t\t\t}\n\t\t} else {\n\t\t\tmth.mods.annotations = mth.mods.annotations == null ? List.of(m) : mth.mods.annotations.prepend(m);\n\t\t}\n\t}\n\t\n\tprivate static void applyAnnotationToVarDecl(JavacNode typeNode, JCVariableDecl arg, String annType, boolean typeUse) {\n\t\tif (annType == null) return;\n\t\tJavacTreeMaker maker = typeNode.getTreeMaker();\n\t\t\n\t\tJCAnnotation m = maker.Annotation(genTypeRef(typeNode, annType), List.<JCExpression>nil());\n\t\tif (typeUse) {\n\t\t\tJCExpression varType = arg.vartype;\n\t\t\tJCTypeApply ta = null;\n\t\t\tif (varType instanceof JCTypeApply) {\n\t\t\t\tta = (JCTypeApply) varType;\n\t\t\t\tvarType = ta.clazz;\n\t\t\t}\n\t\t\t\n\t\t\tif (varType instanceof JCFieldAccess || varType instanceof JCArrayTypeTree) {\n\t\t\t\tvarType = maker.AnnotatedType(List.of(m), varType);\n\t\t\t\tif (ta != null) ta.clazz = varType;\n\t\t\t\telse arg.vartype = varType;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif (JCAnnotatedTypeReflect.is(varType)) {\n\t\t\t\tList<JCAnnotation> annotations = JCAnnotatedTypeReflect.getAnnotations(varType);\n\t\t\t\tJCAnnotatedTypeReflect.setAnnotations(varType, annotations.prepend(m));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif (varType instanceof JCPrimitiveTypeTree || varType instanceof JCIdent) {\n\t\t\t\targ.mods.annotations = arg.mods.annotations == null ? List.of(m) : arg.mods.annotations.prepend(m);\n\t\t\t}\n\t\t} else {\n\t\t\targ.mods.annotations = arg.mods.annotations == null ? List.of(m) : arg.mods.annotations.prepend(m);\n\t\t}\n\t}\n}\n","lineNo":1735}
{"Smelly Sample":"/*\n * Copyright (C) 2010-2021 The Project Lombok Authors.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage lombok.eclipse.agent;\n\nimport lombok.permit.Permit;\nimport org.eclipse.jdt.core.compiler.CategorizedProblem;\nimport org.eclipse.jdt.internal.compiler.CompilationResult;\nimport org.eclipse.jdt.internal.compiler.ast.ASTNode;\nimport org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.Annotation;\nimport org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.ConditionalExpression;\nimport org.eclipse.jdt.internal.compiler.ast.Expression;\nimport org.eclipse.jdt.internal.compiler.ast.ForeachStatement;\nimport org.eclipse.jdt.internal.compiler.ast.FunctionalExpression;\nimport org.eclipse.jdt.internal.compiler.ast.ImportReference;\nimport org.eclipse.jdt.internal.compiler.ast.LambdaExpression;\nimport org.eclipse.jdt.internal.compiler.ast.LocalDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference;\nimport org.eclipse.jdt.internal.compiler.ast.SingleTypeReference;\nimport org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.TypeReference;\nimport org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;\nimport org.eclipse.jdt.internal.compiler.impl.ReferenceContext;\nimport org.eclipse.jdt.internal.compiler.lookup.ArrayBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.Binding;\nimport org.eclipse.jdt.internal.compiler.lookup.BlockScope;\nimport org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope;\nimport org.eclipse.jdt.internal.compiler.lookup.ImportBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.Scope;\nimport org.eclipse.jdt.internal.compiler.lookup.TypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.TypeConstants;\nimport org.eclipse.jdt.internal.compiler.lookup.TypeIds;\nimport org.eclipse.jdt.internal.compiler.problem.AbortCompilation;\n\nimport java.lang.reflect.Field;\n\nimport static lombok.Lombok.sneakyThrow;\nimport static lombok.eclipse.Eclipse.*;\nimport static lombok.eclipse.handlers.EclipseHandlerUtil.*;\nimport static org.eclipse.jdt.core.compiler.CategorizedProblem.CAT_TYPE;\n\npublic class PatchVal {\n\t\n\t// This is half of the work for 'val' support - the other half is in PatchValEclipse. This half is enough for ecj.\n\t// Creates a copy of the 'initialization' field on a LocalDeclaration if the type of the LocalDeclaration is 'val', because the completion parser will null this out,\n\t// which in turn stops us from inferring the intended type for 'val x = 5;'. We look at the copy.\n\t// Also patches .resolve() on LocalDeclaration itself to just-in-time replace the 'val' vartype with the right one.\n\t\n\tpublic static boolean matches(String key, char[] array) {\n\t\tif (array == null || key.length() != array.length) return false;\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tif (key.charAt(i) != array[i]) return false;\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tpublic static boolean couldBe(ImportBinding[] imports, String key, TypeReference ref) {\n\t\tString[] keyParts = key.split(\"\\\\.\");\n\t\tif (ref instanceof SingleTypeReference) {\n\t\t\tchar[] token = ((SingleTypeReference)ref).token;\n\t\t\tif (!matches(keyParts[keyParts.length - 1], token)) return false;\n\t\t\tif (imports == null) return true;\n\t\t\ttop:\n\t\t\tfor (ImportBinding ib : imports) {\n\t\t\t\tImportReference ir = ib.reference;\n\t\t\t\tif (ir == null) continue;\n\t\t\t\tif (ir.isStatic()) continue;\n\t\t\t\tboolean star = ((ir.bits & ASTNode.OnDemand) != 0);\n\t\t\t\tint len = keyParts.length - (star ? 1 : 0);\n\t\t\t\tchar[][] t = ir.tokens;\n\t\t\t\tif (len != t.length) continue;\n\t\t\t\tfor (int i = 0; i < len; i++) {\n\t\t\t\t\tif (keyParts[i].length() != t[i].length) continue top;\n\t\t\t\t\tfor (int j = 0; j < t[i].length; j++) if (keyParts[i].charAt(j) != t[i][j]) continue top;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (ref instanceof QualifiedTypeReference) {\n\t\t\tchar[][] tokens = ((QualifiedTypeReference)ref).tokens;\n\t\t\tif (keyParts.length != tokens.length) return false;\n\t\t\tfor(int i = 0; i < tokens.length; ++i) {\n\t\t\t\tString part = keyParts[i];\n\t\t\t\tchar[] token = tokens[i];\n\t\t\t\tif (!matches(part, token)) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tpublic static boolean couldBe(ImportReference[] imports, String key, TypeReference ref) {\n\t\tString[] keyParts = key.split(\"\\\\.\");\n\t\tif (ref instanceof SingleTypeReference) {\n\t\t\tchar[] token = ((SingleTypeReference) ref).token;\n\t\t\tif (!matches(keyParts[keyParts.length - 1], token)) return false;\n\t\t\tif (imports == null) return true;\n\t\t\ttop:\n\t\t\tfor (ImportReference ir : imports) {\n\t\t\t\tif (ir.isStatic()) continue;\n\t\t\t\tboolean star = ((ir.bits & ASTNode.OnDemand) != 0);\n\t\t\t\tint len = keyParts.length - (star ? 1 : 0);\n\t\t\t\tchar[][] t = ir.tokens;\n\t\t\t\tif (len != t.length) continue;\n\t\t\t\tfor (int i = 0; i < len; i++) {\n\t\t\t\t\tif (keyParts[i].length() != t[i].length) continue top;\n\t\t\t\t\tfor (int j = 0; j < t[i].length; j++) if (keyParts[i].charAt(j) != t[i][j]) continue top;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (ref instanceof QualifiedTypeReference) {\n\t\t\tchar[][] tokens = ((QualifiedTypeReference) ref).tokens;\n\t\t\tif (keyParts.length != tokens.length) return false;\n\t\t\tfor(int i = 0; i < tokens.length; ++i) {\n\t\t\t\tString part = keyParts[i];\n\t\t\t\tchar[] token = tokens[i];\n\t\t\t\tif (!matches(part, token)) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tprivate static boolean is(TypeReference ref, BlockScope scope, String key) {\n\t\tScope s = scope.parent;\n\t\twhile (s != null && !(s instanceof CompilationUnitScope)) {\n\t\t\tScope ns = s.parent;\n\t\t\ts = ns == s ? null : ns;\n\t\t}\n\t\tImportBinding[] imports = null;\n\t\tif (s instanceof CompilationUnitScope) imports = ((CompilationUnitScope) s).imports;\n\t\tif (!couldBe(imports, key, ref)) return false;\n\t\t\n\t\tTypeBinding resolvedType = ref.resolvedType;\n\t\tif (resolvedType == null) resolvedType = ref.resolveType(scope, false);\n\t\tif (resolvedType == null) return false;\n\t\t\n\t\tchar[] pkg = resolvedType.qualifiedPackageName();\n\t\tchar[] nm = resolvedType.qualifiedSourceName();\n\t\tint pkgFullLength = pkg.length > 0 ? pkg.length + 1: 0;\n\t\tchar[] fullName = new char[pkgFullLength + nm.length];\n\t\tif(pkg.length > 0) {\n\t\t\tSystem.arraycopy(pkg, 0, fullName, 0, pkg.length);\n\t\t\tfullName[pkg.length] = '.';\n\t\t}\n\t\tSystem.arraycopy(nm, 0, fullName, pkgFullLength, nm.length);\n\t\treturn matches(key, fullName);\n\t}\n\t\n\tpublic static final class Reflection {\n\t\tprivate static final Field initCopyField, iterableCopyField;\n\t\t\n\t\tstatic {\n\t\t\tField a = null, b = null;\n\t\t\t\n\t\t\ttry {\n\t\t\t\ta = Permit.getField(LocalDeclaration.class, \"$initCopy\");\n\t\t\t\tb = Permit.getField(LocalDeclaration.class, \"$iterableCopy\");\n\t\t\t} catch (Throwable t) {\n\t\t\t\t//ignore - no $initCopy exists when running in ecj.\n\t\t\t}\n\t\t\t\n\t\t\tinitCopyField = a;\n\t\t\titerableCopyField = b;\n\t\t}\n\t}\n\tpublic static boolean handleValForLocalDeclaration(LocalDeclaration local, BlockScope scope) {\n\t\tif (local == null || !LocalDeclaration.class.equals(local.getClass())) return false;\n\t\tboolean decomponent = false;\n\t\t\n\t\tboolean val = isVal(local, scope);\n\t\tboolean var = isVar(local, scope);\n\t\tif (!(val || var)) return false;\n\t\t\n\t\tif (val) {\n\t\t\tStackTraceElement[] st = new Throwable().getStackTrace();\n\t\t\tfor (int i = 0; i < st.length - 2 && i < 10; i++) {\n\t\t\t\tif (st[i].getClassName().equals(\"lombok.launch.PatchFixesHider$Val\")) {\n\t\t\t\t\tboolean valInForStatement = \n\t\t\t\t\t\tst[i + 1].getClassName().equals(\"org.eclipse.jdt.internal.compiler.ast.LocalDeclaration\") &&\n\t\t\t\t\t\tst[i + 2].getClassName().equals(\"org.eclipse.jdt.internal.compiler.ast.ForStatement\");\n\t\t\t\t\tif (valInForStatement) return false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tExpression init = local.initialization;\n\t\tif (init == null && Reflection.initCopyField != null) {\n\t\t\ttry {\n\t\t\t\tinit = (Expression) Reflection.initCopyField.get(local);\n\t\t\t} catch (Exception e) {\n\t\t\t\t// init remains null.\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (init == null && Reflection.iterableCopyField != null) {\n\t\t\ttry {\n\t\t\t\tinit = (Expression) Reflection.iterableCopyField.get(local);\n\t\t\t\tdecomponent = true;\n\t\t\t} catch (Exception e) {\n\t\t\t\t// init remains null.\n\t\t\t}\n\t\t}\n\t\t\n\t\tTypeReference replacement = null;\n\t\t\n\t\t// Java 10+: Lombok uses the native 'var' support and transforms 'val' to 'final var'.\n\t\tif (hasNativeVarSupport(scope) && val) {\n\t\t\treplacement = new SingleTypeReference(\"var\".toCharArray(), pos(local.type));\n\t\t\tlocal.initialization = init;\n\t\t\tinit = null;\n\t\t}\n\t\t\n\t\tif (init != null) {\n\t\t\tif (init.getClass().getName().equals(\"org.eclipse.jdt.internal.compiler.ast.LambdaExpression\")) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tTypeBinding resolved = null;\n\t\t\ttry {\n\t\t\t\tresolved = decomponent ? getForEachComponentType(init, scope) : resolveForExpression(init, scope);\n\t\t\t} catch (NullPointerException e) {\n\t\t\t\t// This definitely occurs if as part of resolving the initializer expression, a\n\t\t\t\t// lambda expression in it must also be resolved (such as when lambdas are part of\n\t\t\t\t// a ternary expression). This can't result in a viable 'val' matching, so, we\n\t\t\t\t// just go with 'Object' and let the IDE print the appropriate errors.\n\t\t\t\tresolved = null;\n\t\t\t}\n\t\t\t\n\t\t\tif (resolved == null) {\n\t\t\t\tif (init instanceof ConditionalExpression) {\n\t\t\t\t\tConditionalExpression cexp = (ConditionalExpression) init;\n\t\t\t\t\tExpression ifTrue = cexp.valueIfTrue;\n\t\t\t\t\tExpression ifFalse = cexp.valueIfFalse;\n\t\t\t\t\tTypeBinding ifTrueResolvedType = ifTrue.resolvedType;\n\t\t\t\t\tCompilationResult compilationResult = scope.referenceCompilationUnit().compilationResult;\n\t\t\t\t\tCategorizedProblem[] problems = compilationResult.problems;\n\t\t\t\t\tCategorizedProblem lastProblem = problems[compilationResult.problemCount - 1];\n\t\t\t\t\tif (ifTrueResolvedType != null && ifFalse.resolvedType == null && lastProblem.getCategoryID() == CAT_TYPE) {\n\t\t\t\t\t\tint problemCount = compilationResult.problemCount;\n\t\t\t\t\t\tfor (int i = 0; i < problemCount; ++i) {\n\t\t\t\t\t\t\tif (problems[i] == lastProblem) {\n\t\t\t\t\t\t\t\tproblems[i] = null;\n\t\t\t\t\t\t\t\tif (i + 1 < problemCount) {\n\t\t\t\t\t\t\t\t\tSystem.arraycopy(problems, i + 1, problems, i, problemCount - i + 1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcompilationResult.removeProblem(lastProblem);\n\t\t\t\t\t\tif (!compilationResult.hasErrors()) {\n\t\t\t\t\t\t\tclearIgnoreFurtherInvestigationField(scope.referenceContext());\n\t\t\t\t\t\t\tsetValue(getField(CompilationResult.class, \"hasMandatoryErrors\"), compilationResult, false);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (ifFalse instanceof FunctionalExpression) {\n\t\t\t\t\t\t\tFunctionalExpression functionalExpression = (FunctionalExpression) ifFalse;\n\t\t\t\t\t\t\tfunctionalExpression.setExpectedType(ifTrueResolvedType);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ifFalse.resolvedType == null) {\n\t\t\t\t\t\t\tresolveForExpression(ifFalse, scope);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tresolved = ifTrueResolvedType;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (resolved != null) {\n\t\t\t\ttry {\n\t\t\t\t\treplacement = makeType(resolved, local.type, false);\n\t\t\t\t\tif (!decomponent) init.resolvedType = replacement.resolveType(scope);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t// Some type thing failed.\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (val) local.modifiers |= ClassFileConstants.AccFinal;\n\t\tlocal.annotations = addValAnnotation(local.annotations, local.type, scope);\n\t\tlocal.type = replacement != null ? replacement : new QualifiedTypeReference(TypeConstants.JAVA_LANG_OBJECT, poss(local.type, 3));\n\t\treturn false;\n\t}\n\t\n\tprivate static boolean isVar(LocalDeclaration local, BlockScope scope) {\n\t\treturn is(local.type, scope, \"lombok.experimental.var\") || is(local.type, scope, \"lombok.var\");\n\t}\n\t\n\tprivate static boolean isVal(LocalDeclaration local, BlockScope scope) {\n\t\treturn is(local.type, scope, \"lombok.val\");\n\t}\n\t\n\tprivate static boolean hasNativeVarSupport(Scope scope) {\n\t\tlong sl = scope.problemReporter().options.sourceLevel >> 16;\n\t\tlong cl = scope.problemReporter().options.complianceLevel >> 16;\n\t\tif (sl == 0) sl = cl;\n\t\tif (cl == 0) cl = sl;\n\t\treturn Math.min((int)(sl - 44), (int)(cl - 44)) >= 10;\n\t}\n\t\n\tpublic static boolean handleValForForEach(ForeachStatement forEach, BlockScope scope) {\n\t\tif (forEach.elementVariable == null) return false;\n\t\t\n\t\tboolean val = isVal(forEach.elementVariable, scope);\n\t\tboolean var = isVar(forEach.elementVariable, scope);\n\t\tif (!(val || var)) return false;\n\t\t\n\t\tif (hasNativeVarSupport(scope)) return false;\n\t\t\n\t\tTypeBinding component = getForEachComponentType(forEach.collection, scope);\n\t\tif (component == null) return false;\n\t\tTypeReference replacement = makeType(component, forEach.elementVariable.type, false);\n\t\t\n\t\tif (val) forEach.elementVariable.modifiers |= ClassFileConstants.AccFinal;\n\t\tforEach.elementVariable.annotations = addValAnnotation(forEach.elementVariable.annotations, forEach.elementVariable.type, scope);\n\t\tforEach.elementVariable.type = replacement != null ? replacement :\n\t\t\tnew QualifiedTypeReference(TypeConstants.JAVA_LANG_OBJECT, poss(forEach.elementVariable.type, 3));\n\t\t\n\t\treturn false;\n\t}\n\t\n\tprivate static Annotation[] addValAnnotation(Annotation[] originals, TypeReference originalRef, BlockScope scope) {\n\t\tAnnotation[] newAnn;\n\t\tif (originals != null) {\n\t\t\tnewAnn = new Annotation[1 + originals.length];\n\t\t\tSystem.arraycopy(originals, 0, newAnn, 0, originals.length);\n\t\t} else {\n\t\t\tnewAnn = new Annotation[1];\n\t\t}\n\t\t\n\t\tnewAnn[newAnn.length - 1] = new org.eclipse.jdt.internal.compiler.ast.MarkerAnnotation(originalRef, originalRef.sourceStart);\n\t\t\n\t\treturn newAnn;\n\t}\n\t\n\tprivate static TypeBinding getForEachComponentType(Expression collection, BlockScope scope) {\n\t\tif (collection != null) {\n\t\t\tTypeBinding resolved = collection.resolvedType;\n\t\t\tif (resolved == null) resolved = resolveForExpression(collection, scope);\n\t\t\tif (resolved == null) return null;\n\t\t\tif (resolved.isArrayType()) {\n\t\t\t\tresolved = ((ArrayBinding) resolved).elementsType();\n\t\t\t\treturn resolved;\n\t\t\t} else if (resolved instanceof ReferenceBinding) {\n\t\t\t\tReferenceBinding iterableType = ((ReferenceBinding) resolved).findSuperTypeOriginatingFrom(TypeIds.T_JavaLangIterable, false);\n\t\t\t\t\n\t\t\t\tTypeBinding[] arguments = null;\n\t\t\t\tif (iterableType != null) switch (iterableType.kind()) {\n\t\t\t\t\tcase Binding.GENERIC_TYPE : // for (T t : Iterable<T>) - in case used inside Iterable itself\n\t\t\t\t\t\targuments = iterableType.typeVariables();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase Binding.PARAMETERIZED_TYPE : // for(E e : Iterable<E>)\n\t\t\t\t\t\targuments = ((ParameterizedTypeBinding)iterableType).arguments;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase Binding.RAW_TYPE : // for(Object e : Iterable)\n\t\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (arguments != null && arguments.length == 1) {\n\t\t\t\t\treturn arguments[0];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\t\n\tprivate static TypeBinding resolveForExpression(Expression collection, BlockScope scope) {\n\t\ttry {\n\t\t\treturn collection.resolveType(scope);\n\t\t} catch (ArrayIndexOutOfBoundsException e) {\n\t\t\t// Known cause of issues; for example: val e = mth(\"X\"), where mth takes 2 arguments.\n\t\t\treturn null;\n\t\t} catch (AbortCompilation e) {\n\t\t\treturn null;\n\t\t}\n\t}\n\t\n\tprivate static void clearIgnoreFurtherInvestigationField(ReferenceContext currentContext) {\n\t\tif (currentContext instanceof AbstractMethodDeclaration) {\n\t\t\tAbstractMethodDeclaration methodDeclaration = (AbstractMethodDeclaration) currentContext;\n\t\t\tmethodDeclaration.ignoreFurtherInvestigation = false;\n\t\t} else if (currentContext instanceof LambdaExpression) {\n\t\t\tLambdaExpression lambdaExpression = (LambdaExpression) currentContext;\n\t\t\tsetValue(getField(LambdaExpression.class, \"ignoreFurtherInvestigation\"), lambdaExpression, false);\n\t\t\t\n\t\t\tScope parent = lambdaExpression.enclosingScope.parent;\n\t\t\twhile (parent != null) {\n\t\t\t\tswitch(parent.kind) {\n\t\t\t\t\tcase Scope.CLASS_SCOPE:\n\t\t\t\t\tcase Scope.METHOD_SCOPE:\n\t\t\t\t\t\tReferenceContext parentAST = parent.referenceContext();\n\t\t\t\t\t\tif (parentAST != lambdaExpression) {\n\t\t\t\t\t\t\tclearIgnoreFurtherInvestigationField(parentAST);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tparent = parent.parent;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t} else if (currentContext instanceof TypeDeclaration) {\n\t\t\tTypeDeclaration typeDeclaration = (TypeDeclaration) currentContext;\n\t\t\ttypeDeclaration.ignoreFurtherInvestigation = false;\n\t\t} else if (currentContext instanceof CompilationUnitDeclaration) {\n\t\t\tCompilationUnitDeclaration typeDeclaration = (CompilationUnitDeclaration) currentContext;\n\t\t\ttypeDeclaration.ignoreFurtherInvestigation = false;\n\t\t} else {\n\t\t\tthrow new UnsupportedOperationException(\"clearIgnoreFurtherInvestigationField for \" + currentContext.getClass());\n\t\t}\n\t}\n\t\n\tprivate static void setValue(Field field, Object object, Object value) {\n\t\ttry {\n\t\t\tfield.set(object, value);\n\t\t} catch (IllegalAccessException e) {\n\t\t\tthrow sneakyThrow(e);\n\t\t}\n\t}\n\t\n\tprivate static Field getField(Class<?> clazz, String name) {\n\t\ttry {\n\t\t\treturn Permit.getField(clazz, name);\n\t\t} catch (NoSuchFieldException e) {\n\t\t\tthrow sneakyThrow(e);\n\t\t}\n\t}\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2010-2021 The Project Lombok Authors.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage lombok.eclipse.agent;\n\nimport lombok.permit.Permit;\nimport org.eclipse.jdt.core.compiler.CategorizedProblem;\nimport org.eclipse.jdt.internal.compiler.CompilationResult;\nimport org.eclipse.jdt.internal.compiler.ast.ASTNode;\nimport org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.Annotation;\nimport org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.ConditionalExpression;\nimport org.eclipse.jdt.internal.compiler.ast.Expression;\nimport org.eclipse.jdt.internal.compiler.ast.ForeachStatement;\nimport org.eclipse.jdt.internal.compiler.ast.FunctionalExpression;\nimport org.eclipse.jdt.internal.compiler.ast.ImportReference;\nimport org.eclipse.jdt.internal.compiler.ast.LambdaExpression;\nimport org.eclipse.jdt.internal.compiler.ast.LocalDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference;\nimport org.eclipse.jdt.internal.compiler.ast.SingleTypeReference;\nimport org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.TypeReference;\nimport org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;\nimport org.eclipse.jdt.internal.compiler.impl.ReferenceContext;\nimport org.eclipse.jdt.internal.compiler.lookup.ArrayBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.Binding;\nimport org.eclipse.jdt.internal.compiler.lookup.BlockScope;\nimport org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope;\nimport org.eclipse.jdt.internal.compiler.lookup.ImportBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.Scope;\nimport org.eclipse.jdt.internal.compiler.lookup.TypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.TypeConstants;\nimport org.eclipse.jdt.internal.compiler.lookup.TypeIds;\nimport org.eclipse.jdt.internal.compiler.problem.AbortCompilation;\n\nimport java.lang.reflect.Field;\n\nimport static lombok.Lombok.sneakyThrow;\nimport static lombok.eclipse.Eclipse.*;\nimport static lombok.eclipse.handlers.EclipseHandlerUtil.*;\nimport static org.eclipse.jdt.core.compiler.CategorizedProblem.CAT_TYPE;\n\npublic class PatchVal {\n\t\n\t// This is half of the work for 'val' support - the other half is in PatchValEclipse. This half is enough for ecj.\n\t// Creates a copy of the 'initialization' field on a LocalDeclaration if the type of the LocalDeclaration is 'val', because the completion parser will null this out,\n\t// which in turn stops us from inferring the intended type for 'val x = 5;'. We look at the copy.\n\t// Also patches .resolve() on LocalDeclaration itself to just-in-time replace the 'val' vartype with the right one.\n\t\n\tpublic static boolean matches(String key, char[] array) {\n\t\tif (array == null || key.length() != array.length) return false;\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tif (key.charAt(i) != array[i]) return false;\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tpublic static boolean couldBe(ImportBinding[] imports, String key, TypeReference ref) {\n\t\tString[] keyParts = key.split(\"\\\\.\");\n\t\tif (ref instanceof SingleTypeReference) {\n\t\t\tchar[] token = ((SingleTypeReference)ref).token;\n\t\t\tif (!matches(keyParts[keyParts.length - 1], token)) return false;\n\t\t\tif (imports == null) return true;\n\t\t\ttop:\n\t\t\tfor (ImportBinding ib : imports) {\n\t\t\t\tImportReference ir = ib.reference;\n\t\t\t\tif (ir == null) continue;\n\t\t\t\tif (ir.isStatic()) continue;\n\t\t\t\tboolean star = ((ir.bits & ASTNode.OnDemand) != 0);\n\t\t\t\tint len = keyParts.length - (star ? 1 : 0);\n\t\t\t\tchar[][] t = ir.tokens;\n\t\t\t\tif (len != t.length) continue;\n\t\t\t\tfor (int i = 0; i < len; i++) {\n\t\t\t\t\tif (keyParts[i].length() != t[i].length) continue top;\n\t\t\t\t\tfor (int j = 0; j < t[i].length; j++) if (keyParts[i].charAt(j) != t[i][j]) continue top;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (ref instanceof QualifiedTypeReference) {\n\t\t\tchar[][] tokens = ((QualifiedTypeReference)ref).tokens;\n\t\t\tif (keyParts.length != tokens.length) return false;\n\t\t\tfor(int i = 0; i < tokens.length; ++i) {\n\t\t\t\tString part = keyParts[i];\n\t\t\t\tchar[] token = tokens[i];\n\t\t\t\tif (!matches(part, token)) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tpublic static boolean couldBe(ImportReference[] imports, String key, TypeReference ref) {\n\t\tString[] keyParts = key.split(\"\\\\.\");\n\t\tif (ref instanceof SingleTypeReference) {\n\t\t\tchar[] token = ((SingleTypeReference) ref).token;\n\t\t\tif (!matches(keyParts[keyParts.length - 1], token)) return false;\n\t\t\tif (imports == null) return true;\n\t\t\ttop:\n\t\t\tfor (ImportReference ir : imports) {\n\t\t\t\tif (ir.isStatic()) continue;\n\t\t\t\tboolean star = ((ir.bits & ASTNode.OnDemand) != 0);\n\t\t\t\tint len = keyParts.length - (star ? 1 : 0);\n\t\t\t\tchar[][] t = ir.tokens;\n\t\t\t\tif (len != t.length) continue;\n\t\t\t\tfor (int i = 0; i < len; i++) {\n\t\t\t\t\tif (keyParts[i].length() != t[i].length) continue top;\n\t\t\t\t\tfor (int j = 0; j < t[i].length; j++) if (keyParts[i].charAt(j) != t[i][j]) continue top;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (ref instanceof QualifiedTypeReference) {\n\t\t\tchar[][] tokens = ((QualifiedTypeReference) ref).tokens;\n\t\t\tif (keyParts.length != tokens.length) return false;\n\t\t\tfor(int i = 0; i < tokens.length; ++i) {\n\t\t\t\tString part = keyParts[i];\n\t\t\t\tchar[] token = tokens[i];\n\t\t\t\tif (!matches(part, token)) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tprivate static boolean is(TypeReference ref, BlockScope scope, String key) {\n\t\tScope s = scope.parent;\n\t\twhile (s != null && !(s instanceof CompilationUnitScope)) {\n\t\t\tScope ns = s.parent;\n\t\t\ts = ns == s ? null : ns;\n\t\t}\n\t\tImportBinding[] imports = null;\n\t\tif (s instanceof CompilationUnitScope) imports = ((CompilationUnitScope) s).imports;\n\t\tif (!couldBe(imports, key, ref)) return false;\n\t\t\n\t\tTypeBinding resolvedType = ref.resolvedType;\n\t\tif (resolvedType == null) resolvedType = ref.resolveType(scope, false);\n\t\tif (resolvedType == null) return false;\n\t\t\n\t\tchar[] pkg = resolvedType.qualifiedPackageName();\n\t\tchar[] nm = resolvedType.qualifiedSourceName();\n\t\tint pkgFullLength = pkg.length > 0 ? pkg.length + 1: 0;\n\t\tchar[] fullName = new char[pkgFullLength + nm.length];\n\t\tif(pkg.length > 0) {\n\t\t\tSystem.arraycopy(pkg, 0, fullName, 0, pkg.length);\n\t\t\tfullName[pkg.length] = '.';\n\t\t}\n\t\tSystem.arraycopy(nm, 0, fullName, pkgFullLength, nm.length);\n\t\treturn matches(key, fullName);\n\t}\n\t\n\tpublic static final class Reflection {\n\t\tprivate static final Field initCopyField, iterableCopyField;\n\t\t\n\t\tstatic {\n\t\t\tField a = null, b = null;\n\t\t\t\n\t\t\ttry {\n\t\t\t\ta = Permit.getField(LocalDeclaration.class, \"$initCopy\");\n\t\t\t\tb = Permit.getField(LocalDeclaration.class, \"$iterableCopy\");\n\t\t\t} catch (Throwable t) {\n\t\t\t\t//ignore - no $initCopy exists when running in ecj.\n\t\t\t}\n\t\t\t\n\t\t\tinitCopyField = a;\n\t\t\titerableCopyField = b;\n\t\t}\n\t}\n\tpublic static boolean handleValForLocalDeclaration(LocalDeclaration local, BlockScope scope) {\n\t\tif (local == null || !LocalDeclaration.class.equals(local.getClass())) return false;\n\t\tboolean decomponent = false;\n\t\t\n\t\tboolean val = isVal(local, scope);\n\t\tboolean var = isVar(local, scope);\n\t\tif (!(val || var)) return false;\n\t\t\n\t\tif (val) {\n\t\t\tStackTraceElement[] st = new Throwable().getStackTrace();\n\t\t\tfor (int i = 0; i < st.length - 2 && i < 10; i++) {\n\t\t\t\tif (st[i].getClassName().equals(\"lombok.launch.PatchFixesHider$Val\")) {\n\t\t\t\t\tboolean valInForStatement = \n\t\t\t\t\t\tst[i + 1].getClassName().equals(\"org.eclipse.jdt.internal.compiler.ast.LocalDeclaration\") &&\n\t\t\t\t\t\tst[i + 2].getClassName().equals(\"org.eclipse.jdt.internal.compiler.ast.ForStatement\");\n\t\t\t\t\tif (valInForStatement) return false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tExpression init = local.initialization;\n\t\tif (init == null && Reflection.initCopyField != null) {\n\t\t\ttry {\n\t\t\t\tinit = (Expression) Reflection.initCopyField.get(local);\n\t\t\t} catch (Exception e) {\n\t\t\t\t// init remains null.\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (init == null && Reflection.iterableCopyField != null) {\n\t\t\ttry {\n\t\t\t\tinit = (Expression) Reflection.iterableCopyField.get(local);\n\t\t\t\tdecomponent = true;\n\t\t\t} catch (Exception e) {\n\t\t\t\t// init remains null.\n\t\t\t}\n\t\t}\n\t\t\n\t\tTypeReference replacement = null;\n\t\t\n\t\t// Java 10+: Lombok uses the native 'var' support and transforms 'val' to 'final var'.\n\t\tif (hasNativeVarSupport(scope) && val) {\n\t\t\treplacement = new SingleTypeReference(\"var\".toCharArray(), pos(local.type));\n\t\t\tlocal.initialization = init;\n\t\t\tinit = null;\n\t\t}\n\t\t\n\t\tif (init != null) {\n\t\t\tif (init.getClass().getName().equals(\"org.eclipse.jdt.internal.compiler.ast.LambdaExpression\")) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tTypeBinding resolved = null;\n\t\t\ttry {\n\t\t\t\tresolved = decomponent ? getForEachComponentType(init, scope) : resolveForExpression(init, scope);\n\t\t\t} catch (NullPointerException e) {\n\t\t\t\t// This definitely occurs if as part of resolving the initializer expression, a\n\t\t\t\t// lambda expression in it must also be resolved (such as when lambdas are part of\n\t\t\t\t// a ternary expression). This can't result in a viable 'val' matching, so, we\n\t\t\t\t// just go with 'Object' and let the IDE print the appropriate errors.\n\t\t\t\tresolved = null;\n\t\t\t}\n\t\t\t\n\t\t\tif (resolved == null) {\n\t\t\t\tif (init instanceof ConditionalExpression) {\n\t\t\t\t\tConditionalExpression cexp = (ConditionalExpression) init;\n\t\t\t\t\tExpression ifTrue = cexp.valueIfTrue;\n\t\t\t\t\tExpression ifFalse = cexp.valueIfFalse;\n\t\t\t\t\tTypeBinding ifTrueResolvedType = ifTrue.resolvedType;\n\t\t\t\t\tCompilationResult compilationResult = scope.referenceCompilationUnit().compilationResult;\n\t\t\t\t\tCategorizedProblem[] problems = compilationResult.problems;\n\t\t\t\t\tCategorizedProblem lastProblem = problems[compilationResult.problemCount - 1];\n\t\t\t\t\tif (ifTrueResolvedType != null && ifFalse.resolvedType == null && lastProblem.getCategoryID() == CAT_TYPE) {\n\t\t\t\t\t\tint problemCount = compilationResult.problemCount;\n\t\t\t\t\t\tfor (int i = 0; i < problemCount; ++i) {\n\t\t\t\t\t\t\tif (problems[i] == lastProblem) {\n\t\t\t\t\t\t\t\tproblems[i] = null;\n\t\t\t\t\t\t\t\tif (i + 1 < problemCount) {\n\t\t\t\t\t\t\t\t\tSystem.arraycopy(problems, i + 1, problems, i, problemCount - i + 1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcompilationResult.removeProblem(lastProblem);\n\t\t\t\t\t\tif (!compilationResult.hasErrors()) {\n\t\t\t\t\t\t\tclearIgnoreFurtherInvestigationField(scope.referenceContext());\n\t\t\t\t\t\t\tsetValue(getField(CompilationResult.class, \"hasMandatoryErrors\"), compilationResult, false);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (ifFalse instanceof FunctionalExpression) {\n\t\t\t\t\t\t\tFunctionalExpression functionalExpression = (FunctionalExpression) ifFalse;\n\t\t\t\t\t\t\tfunctionalExpression.setExpectedType(ifTrueResolvedType);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ifFalse.resolvedType == null) {\n\t\t\t\t\t\t\tresolveForExpression(ifFalse, scope);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tresolved = ifTrueResolvedType;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (resolved != null) {\n\t\t\t\ttry {\n\t\t\t\t\treplacement = makeType(resolved, local.type, false);\n\t\t\t\t\tif (!decomponent) init.resolvedType = replacement.resolveType(scope);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t// Some type thing failed.\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (val) local.modifiers |= ClassFileConstants.AccFinal;\n\t\tlocal.annotations = addValAnnotation(local.annotations, local.type, scope);\n\t\tlocal.type = replacement != null ? replacement : new QualifiedTypeReference(TypeConstants.JAVA_LANG_OBJECT, poss(local.type, 3));\n\t\treturn false;\n\t}\n\t\n\tprivate static boolean isVar(LocalDeclaration local, BlockScope scope) {\n\t\treturn is(local.type, scope, \"lombok.experimental.var\") || is(local.type, scope, \"lombok.var\");\n\t}\n\t\n\tprivate static boolean isVal(LocalDeclaration local, BlockScope scope) {\n\t\treturn is(local.type, scope, \"lombok.val\");\n\t}\n\t\n\tprivate static boolean hasNativeVarSupport(Scope scope) {\n\t\tlong sl = scope.problemReporter().options.sourceLevel >> 16;\n\t\tlong cl = scope.problemReporter().options.complianceLevel >> 16;\n\t\tif (sl == 0) sl = cl;\n\t\tif (cl == 0) cl = sl;\n\t\treturn Math.min((int)(sl - 44), (int)(cl - 44)) >= 10;\n\t}\n\t\n\tpublic static boolean handleValForForEach(ForeachStatement forEach, BlockScope scope) {\n\t\tif (forEach.elementVariable == null) return false;\n\t\t\n\t\tboolean val = isVal(forEach.elementVariable, scope);\n\t\tboolean var = isVar(forEach.elementVariable, scope);\n\t\tif (!(val || var)) return false;\n\t\t\n\t\tif (hasNativeVarSupport(scope)) return false;\n\t\t\n\t\tTypeBinding component = getForEachComponentType(forEach.collection, scope);\n\t\tif (component == null) return false;\n\t\tTypeReference replacement = makeType(component, forEach.elementVariable.type, false);\n\t\t\n\t\tif (val) forEach.elementVariable.modifiers |= ClassFileConstants.AccFinal;\n\t\tforEach.elementVariable.annotations = addValAnnotation(forEach.elementVariable.annotations, forEach.elementVariable.type, scope);\n\t\tforEach.elementVariable.type = replacement != null ? replacement :\n\t\t\tnew QualifiedTypeReference(TypeConstants.JAVA_LANG_OBJECT, poss(forEach.elementVariable.type, 3));\n\t\t\n\t\treturn false;\n\t}\n\t\n\tprivate static Annotation[] addValAnnotation(Annotation[] originals, TypeReference originalRef, BlockScope scope) {\n\t\tAnnotation[] newAnn;\n\t\tif (originals != null) {\n\t\t\tnewAnn = new Annotation[1 + originals.length];\n\t\t\tSystem.arraycopy(originals, 0, newAnn, 0, originals.length);\n\t\t} else {\n\t\t\tnewAnn = new Annotation[1];\n\t\t}\n\t\t\n\t\tTypeReference qualifiedTypeRef = generateQualifiedTypeRef(originalRef, originalRef.getTypeName());\n\t\tnewAnn[newAnn.length - 1] = new org.eclipse.jdt.internal.compiler.ast.MarkerAnnotation(qualifiedTypeRef, qualifiedTypeRef.sourceStart);\n\t\t\n\t\treturn newAnn;\n\t}\n\t\n\tprivate static TypeBinding getForEachComponentType(Expression collection, BlockScope scope) {\n\t\tif (collection != null) {\n\t\t\tTypeBinding resolved = collection.resolvedType;\n\t\t\tif (resolved == null) resolved = resolveForExpression(collection, scope);\n\t\t\tif (resolved == null) return null;\n\t\t\tif (resolved.isArrayType()) {\n\t\t\t\tresolved = ((ArrayBinding) resolved).elementsType();\n\t\t\t\treturn resolved;\n\t\t\t} else if (resolved instanceof ReferenceBinding) {\n\t\t\t\tReferenceBinding iterableType = ((ReferenceBinding) resolved).findSuperTypeOriginatingFrom(TypeIds.T_JavaLangIterable, false);\n\t\t\t\t\n\t\t\t\tTypeBinding[] arguments = null;\n\t\t\t\tif (iterableType != null) switch (iterableType.kind()) {\n\t\t\t\t\tcase Binding.GENERIC_TYPE : // for (T t : Iterable<T>) - in case used inside Iterable itself\n\t\t\t\t\t\targuments = iterableType.typeVariables();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase Binding.PARAMETERIZED_TYPE : // for(E e : Iterable<E>)\n\t\t\t\t\t\targuments = ((ParameterizedTypeBinding)iterableType).arguments;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase Binding.RAW_TYPE : // for(Object e : Iterable)\n\t\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (arguments != null && arguments.length == 1) {\n\t\t\t\t\treturn arguments[0];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\t\n\tprivate static TypeBinding resolveForExpression(Expression collection, BlockScope scope) {\n\t\ttry {\n\t\t\treturn collection.resolveType(scope);\n\t\t} catch (ArrayIndexOutOfBoundsException e) {\n\t\t\t// Known cause of issues; for example: val e = mth(\"X\"), where mth takes 2 arguments.\n\t\t\treturn null;\n\t\t} catch (AbortCompilation e) {\n\t\t\treturn null;\n\t\t}\n\t}\n\t\n\tprivate static void clearIgnoreFurtherInvestigationField(ReferenceContext currentContext) {\n\t\tif (currentContext instanceof AbstractMethodDeclaration) {\n\t\t\tAbstractMethodDeclaration methodDeclaration = (AbstractMethodDeclaration) currentContext;\n\t\t\tmethodDeclaration.ignoreFurtherInvestigation = false;\n\t\t} else if (currentContext instanceof LambdaExpression) {\n\t\t\tLambdaExpression lambdaExpression = (LambdaExpression) currentContext;\n\t\t\tsetValue(getField(LambdaExpression.class, \"ignoreFurtherInvestigation\"), lambdaExpression, false);\n\t\t\t\n\t\t\tScope parent = lambdaExpression.enclosingScope.parent;\n\t\t\twhile (parent != null) {\n\t\t\t\tswitch(parent.kind) {\n\t\t\t\t\tcase Scope.CLASS_SCOPE:\n\t\t\t\t\tcase Scope.METHOD_SCOPE:\n\t\t\t\t\t\tReferenceContext parentAST = parent.referenceContext();\n\t\t\t\t\t\tif (parentAST != lambdaExpression) {\n\t\t\t\t\t\t\tclearIgnoreFurtherInvestigationField(parentAST);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tparent = parent.parent;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t} else if (currentContext instanceof TypeDeclaration) {\n\t\t\tTypeDeclaration typeDeclaration = (TypeDeclaration) currentContext;\n\t\t\ttypeDeclaration.ignoreFurtherInvestigation = false;\n\t\t} else if (currentContext instanceof CompilationUnitDeclaration) {\n\t\t\tCompilationUnitDeclaration typeDeclaration = (CompilationUnitDeclaration) currentContext;\n\t\t\ttypeDeclaration.ignoreFurtherInvestigation = false;\n\t\t} else {\n\t\t\tthrow new UnsupportedOperationException(\"clearIgnoreFurtherInvestigationField for \" + currentContext.getClass());\n\t\t}\n\t}\n\t\n\tprivate static void setValue(Field field, Object object, Object value) {\n\t\ttry {\n\t\t\tfield.set(object, value);\n\t\t} catch (IllegalAccessException e) {\n\t\t\tthrow sneakyThrow(e);\n\t\t}\n\t}\n\t\n\tprivate static Field getField(Class<?> clazz, String name) {\n\t\ttry {\n\t\t\treturn Permit.getField(clazz, name);\n\t\t} catch (NoSuchFieldException e) {\n\t\t\tthrow sneakyThrow(e);\n\t\t}\n\t}\n}\n","lineNo":362}
{"Smelly Sample":"/*\n * Copyright (C) 2010-2021 The Project Lombok Authors.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage lombok;\n\nimport java.io.File;\nimport java.io.StringWriter;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport lombok.eclipse.Eclipse;\nimport lombok.javac.CapturingDiagnosticListener.CompilerMessage;\n\nimport org.eclipse.core.internal.registry.ExtensionRegistry;\nimport org.eclipse.core.internal.runtime.Activator;\nimport org.eclipse.core.internal.runtime.PlatformActivator;\nimport org.eclipse.core.resources.ResourcesPlugin;\nimport org.eclipse.core.runtime.IExtensionRegistry;\nimport org.eclipse.core.runtime.RegistryFactory;\nimport org.eclipse.core.runtime.adaptor.EclipseStarter;\nimport org.eclipse.core.runtime.spi.IRegistryProvider;\nimport org.eclipse.jdt.core.JavaCore;\nimport org.eclipse.jdt.core.compiler.CategorizedProblem;\nimport org.eclipse.jdt.core.compiler.CharOperation;\nimport org.eclipse.jdt.core.dom.AST;\nimport org.eclipse.jdt.core.dom.CompilationUnit;\nimport org.eclipse.jdt.internal.compiler.CompilationResult;\nimport org.eclipse.jdt.internal.compiler.Compiler;\nimport org.eclipse.jdt.internal.compiler.ICompilerRequestor;\nimport org.eclipse.jdt.internal.compiler.IErrorHandlingPolicy;\nimport org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;\nimport org.eclipse.jdt.internal.compiler.batch.FileSystem;\nimport org.eclipse.jdt.internal.compiler.env.ICompilationUnit;\nimport org.eclipse.jdt.internal.compiler.impl.CompilerOptions;\nimport org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;\nimport org.eclipse.jdt.internal.core.JavaModelManager;\nimport org.osgi.framework.Bundle;\nimport org.osgi.framework.BundleContext;\n\npublic class RunTestsViaEcj extends AbstractRunTests {\n\tprotected CompilerOptions ecjCompilerOptions() {\n\t\tCompilerOptions options = new CompilerOptions();\n\t\toptions.complianceLevel = Eclipse.getLatestEcjCompilerVersionConstant();\n\t\toptions.sourceLevel = Eclipse.getLatestEcjCompilerVersionConstant();\n\t\toptions.targetJDK = Eclipse.getLatestEcjCompilerVersionConstant();\n\t\toptions.docCommentSupport = false;\n\t\toptions.parseLiteralExpressionsAsConstants = true;\n\t\toptions.inlineJsrBytecode = true;\n\t\toptions.reportUnusedDeclaredThrownExceptionExemptExceptionAndThrowable = false;\n\t\toptions.reportUnusedDeclaredThrownExceptionIncludeDocCommentReference = false;\n\t\toptions.reportUnusedDeclaredThrownExceptionWhenOverriding = false;\n\t\toptions.reportUnusedParameterIncludeDocCommentReference = false;\n\t\toptions.reportUnusedParameterWhenImplementingAbstract = false;\n\t\toptions.reportUnusedParameterWhenOverridingConcrete = false;\n\t\toptions.reportDeadCodeInTrivialIfStatement = false;\n\t\toptions.generateClassFiles = false;\n\t\tMap<String, String> warnings = new HashMap<String, String>();\n\t\twarnings.put(CompilerOptions.OPTION_ReportUnusedLocal, \"ignore\");\n\t\twarnings.put(CompilerOptions.OPTION_ReportUnusedLabel, \"ignore\");\n\t\twarnings.put(CompilerOptions.OPTION_ReportUnusedImport, \"ignore\");\n\t\twarnings.put(CompilerOptions.OPTION_ReportUnusedPrivateMember, \"ignore\");\n\t\twarnings.put(CompilerOptions.OPTION_ReportIndirectStaticAccess, \"warning\");\n\t\twarnings.put(CompilerOptions.OPTION_ReportNonStaticAccessToStatic, \"warning\");\n\t\twarnings.put(\"org.eclipse.jdt.core.compiler.problem.enablePreviewFeatures\", \"enabled\");\n\t\twarnings.put(\"org.eclipse.jdt.core.compiler.problem.reportPreviewFeatures\", \"ignore\");\n\t\tint ecjVersion = Eclipse.getEcjCompilerVersion();\n\t\twarnings.put(CompilerOptions.OPTION_Source, (ecjVersion < 9 ? \"1.\" : \"\") + ecjVersion);\n\t\toptions.set(warnings);\n\t\treturn options;\n\t}\n\t\n\tprotected IErrorHandlingPolicy ecjErrorHandlingPolicy() {\n\t\treturn new IErrorHandlingPolicy() {\n\t\t\tpublic boolean stopOnFirstError() {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\tpublic boolean proceedOnErrors() {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\t@SuppressWarnings(\"all\") // Added to the interface in later ecj version.\n\t\t\tpublic boolean ignoreAllErrors() {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t};\n\t}\n\t\n\tprivate ICompilationUnit getSourceUnit(File file, String source) {\n\t\tif (eclipseAvailable()) return new TestCompilationUnitEclipse(file.getName(), source);\n\t\treturn new TestCompilationUnitEcj(file.getName(), source);\n\t}\n\t\n\t@Override\n\tpublic boolean transformCode(Collection<CompilerMessage> messages, StringWriter result, File file, String encoding, Map<String, String> formatPreferences, int minVersion, boolean checkPositions) throws Throwable {\n\t\tfinal AtomicReference<CompilationResult> compilationResult_ = new AtomicReference<CompilationResult>();\n\t\tfinal AtomicReference<CompilationUnitDeclaration> compilationUnit_ = new AtomicReference<CompilationUnitDeclaration>();\n\t\tICompilerRequestor bitbucketRequestor = new ICompilerRequestor() {\n\t\t\t@Override public void acceptResult(CompilationResult result) {\n\t\t\t\tcompilationResult_.set(result);\n\t\t\t}\n\t\t};\n\t\t\n\t\tString source = readFile(file);\n\t\tchar[] sourceArray = source.toCharArray();\n\t\tfinal ICompilationUnit sourceUnit;\n\t\ttry {\n\t\t\tsourceUnit = getSourceUnit(file, source);\n\t\t} catch (Throwable t) {\n\t\t\tt.printStackTrace();\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tCompiler ecjCompiler = new Compiler(createFileSystem(file, minVersion), ecjErrorHandlingPolicy(), ecjCompilerOptions(), bitbucketRequestor, new DefaultProblemFactory(Locale.ENGLISH)) {\n\t\t\t@Override protected synchronized void addCompilationUnit(ICompilationUnit inUnit, CompilationUnitDeclaration parsedUnit) {\n\t\t\t\tif (inUnit == sourceUnit) compilationUnit_.set(parsedUnit);\n\t\t\t\tsuper.addCompilationUnit(inUnit, parsedUnit);\n\t\t\t}\n\t\t};\n\t\t\n\t\t// initializeEclipseBundles();\n\t\t\n\t\tecjCompiler.compile(new ICompilationUnit[] {sourceUnit});\n\t\t\n\t\tCompilationResult compilationResult = compilationResult_.get();\n\t\tCategorizedProblem[] problems = compilationResult.getAllProblems();\n\t\t\n\t\tif (problems != null) for (CategorizedProblem p : problems) {\n\t\t\tmessages.add(new CompilerMessage(p.getSourceLineNumber(), p.getSourceStart(), p.isError(), p.getMessage()));\n\t\t}\n\t\t\n\t\tCompilationUnitDeclaration cud = compilationUnit_.get();\n\t\t\n\t\tif (cud == null) result.append(\"---- No CompilationUnit provided by ecj ----\");\n\t\telse {\n\t\t\tString output = cud.toString();\n\t\t\t// starting somewhere around ecj16, the print code is a bit too cavalier with printing modifiers.\n\t\t\toutput = output.replace(\"non-sealed @val\", \"@val\");\n\t\t\tresult.append(output);\n\t\t}\n\t\t\n\t\tif (eclipseAvailable()) {\n\t\t\tEclipseDomConversion.toDomAst(cud, sourceArray);\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\t@SuppressWarnings(\"unused\")\n\tprivate static class EclipseInitializer {\n\t\tstatic void initializeEclipseBundles() throws Exception {\n\t\t\t// This code does not work yet, it's research-in-progress.\n\t\t\t// The problem is that parts of the eclipse handler (in `PatchValEclipse` and friends) do not work unless\n\t\t\t// an actual eclipse exists; PatchVal causes code to run that will end up running `ResourcesPlugin.getWorkspace()`, which\n\t\t\t// goes down a rabbit hole of pinging off of various static fields (or `getX()` calls which return static fields), all\n\t\t\t// of which are `null` until the plugin they belong to is properly initialized.\n\t\t\t// This code is work in progress to 'hack' the initialization of each plugin one-by-one, but I doubt this is the right\n\t\t\t// way to do it, as I bet it's fragile (will break when eclipse updates rather easily), and who knows how many fields\n\t\t\t// and things need to be initialized.\n\t\t\t// A better plan would be to start an actual, real eclipse, by telling `EclipseStarter.startup` to launch some sort of\n\t\t\t// application (or at least a bunch of bundles/products/apps, including the JDT). This will then take long enough that\n\t\t\t// it'll need to be cached and re-used for each test or the Eclipse test run would take far too long.\n\t\t\t\n\t\t\tBundleContext context = EclipseStarter.startup(new String[0], null);\n\t\t\tRegistryFactory.setDefaultRegistryProvider(new IRegistryProvider() {\n\t\t\t\tprivate final ExtensionRegistry REG = new ExtensionRegistry(null, null, null);\n\t\t\t\t@Override public IExtensionRegistry getRegistry() {\n\t\t\t\t\treturn REG;\n\t\t\t\t}\n\t\t\t});\n\t\t\tnew Activator().start(context);\n\t\t\tnew PlatformActivator().start(context);\n\t\t\tfor (Bundle b : context.getBundles()) System.out.println(\"BUNDLE: \" + b.getSymbolicName());\n\t\t\tnew ResourcesPlugin().start(context);\n\t\t\tJavaModelManager.getJavaModelManager().startup();\n\t\t}\n\t}\n\t\n\tstatic boolean eclipseAvailable() {\n\t\ttry {\n\t\t\tClass.forName(\"org.eclipse.jdt.core.dom.CompilationUnit\");\n\t\t} catch (Throwable t) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tprivate static final String bootRuntimePath = System.getProperty(\"delombok.bootclasspath\");\n\t\n\tprivate static class EclipseDomConversion {\n\t\tstatic CompilationUnit toDomAst(CompilationUnitDeclaration cud, final char[] source) {\n\t\t\tMap<String, String> options = new HashMap<String, String>();\n\t\t\toptions.put(JavaCore.COMPILER_SOURCE, \"11\");\n\t\t\toptions.put(\"org.eclipse.jdt.core.compiler.problem.enablePreviewFeatures\", \"enabled\");\n\t\t\t\n\t\t\torg.eclipse.jdt.internal.core.CompilationUnit ccu = new org.eclipse.jdt.internal.core.CompilationUnit(null, null, null) {\n\t\t\t\t@Override public char[] getContents() {\n\t\t\t\t\treturn source;\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn AST.convertCompilationUnit(4, cud, options, false, ccu, 0, null);\n\t\t}\n\t}\n\t\n\tprivate FileSystem createFileSystem(File file, int minVersion) {\n\t\tList<String> classpath = new ArrayList<String>();\n\t\tfor (Iterator<String> i = classpath.iterator(); i.hasNext();) {\n\t\t\tif (FileSystem.getClasspath(i.next(), \"UTF-8\", null) == null) {\n\t\t\t\ti.remove();\n\t\t\t}\n\t\t}\n\t\tif (new File(\"bin/main\").exists()) classpath.add(\"bin/main\");\n\t\tclasspath.add(\"dist/lombok.jar\");\n\t\tclasspath.add(\"build/teststubs\");\n\t\tif (bootRuntimePath == null || bootRuntimePath.isEmpty()) throw new IllegalStateException(\"System property delombok.bootclasspath is not set; set it to the rt of java6 or java8\");\n\t\tclasspath.add(bootRuntimePath);\n\t\tfor (File f : new File(\"lib/test\").listFiles()) {\n\t\t\tString fn = f.getName();\n\t\t\tif (fn.length() < 4) continue;\n\t\t\tif (!fn.substring(fn.length() - 4).toLowerCase().equals(\".jar\")) continue;\n\t\t\tclasspath.add(\"lib/test/\" + fn);\n\t\t}\n\t\treturn new FileSystem(classpath.toArray(new String[0]), new String[] {file.getAbsolutePath()}, \"UTF-8\");\n\t}\n\t\n\tprivate static final class TestCompilationUnitEcj implements ICompilationUnit {\n\t\tprivate final char[] name, source, mainTypeName;\n\t\t\n\t\tTestCompilationUnitEcj(String name, String source) {\n\t\t\tthis.source = source.toCharArray();\n\t\t\tthis.name = name.toCharArray();\n\t\t\t\n\t\t\tchar[] fileNameCharArray = getFileName();\n\t\t\tint start = CharOperation.lastIndexOf(File.separatorChar, fileNameCharArray) + 1;\n\t\t\tint end = CharOperation.lastIndexOf('.', fileNameCharArray);\n\t\t\tif (end == -1) {\n\t\t\t\tend = fileNameCharArray.length;\n\t\t\t}\n\t\t\tmainTypeName = CharOperation.subarray(fileNameCharArray, start, end);\n\t\t}\n\t\t\n\t\t@Override public char[] getFileName() {\n\t\t\treturn name;\n\t\t}\n\t\t\n\t\t@Override public char[] getContents() {\n\t\t\treturn source;\n\t\t}\n\t\t\n\t\t@Override public char[] getMainTypeName() {\n\t\t\treturn mainTypeName;\n\t\t}\n\t\t\n\t\t@Override public char[][] getPackageName() {\n\t\t\treturn null;\n\t\t}\n\t}\n\t\n\tprivate static final class TestCompilationUnitEclipse extends org.eclipse.jdt.internal.core.CompilationUnit {\n\t\tprivate final char[] source;\n\t\tprivate final char[] mainTypeName;\n\t\t\n\t\tprivate TestCompilationUnitEclipse(String name, String source) {\n\t\t\tsuper(null, name, null);\n\t\t\tthis.source = source.toCharArray();\n\t\t\t\n\t\t\tchar[] fileNameCharArray = getFileName();\n\t\t\tint start = CharOperation.lastIndexOf(File.separatorChar, fileNameCharArray) + 1;\n\t\t\tint end = CharOperation.lastIndexOf('.', fileNameCharArray);\n\t\t\tif (end == -1) {\n\t\t\t\tend = fileNameCharArray.length;\n\t\t\t}\n\t\t\tmainTypeName = CharOperation.subarray(fileNameCharArray, start, end);\n\t\t}\n\t\t\n\t\t@Override public char[] getContents() {\n\t\t\treturn source;\n\t\t}\n\t\t\n\t\t@Override public char[] getMainTypeName() {\n\t\t\treturn mainTypeName;\n\t\t}\n\t\t\n\t\t@Override public boolean ignoreOptionalProblems() {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t@Override public char[][] getPackageName() {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t@Override public char[] getModuleName() {\n\t\t\treturn null;\n\t\t}\n\t}\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2010-2021 The Project Lombok Authors.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage lombok;\n\nimport java.io.File;\nimport java.io.StringWriter;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport lombok.eclipse.Eclipse;\nimport lombok.javac.CapturingDiagnosticListener.CompilerMessage;\n\nimport org.eclipse.core.internal.registry.ExtensionRegistry;\nimport org.eclipse.core.internal.runtime.Activator;\nimport org.eclipse.core.internal.runtime.PlatformActivator;\nimport org.eclipse.core.resources.ResourcesPlugin;\nimport org.eclipse.core.runtime.IExtensionRegistry;\nimport org.eclipse.core.runtime.RegistryFactory;\nimport org.eclipse.core.runtime.adaptor.EclipseStarter;\nimport org.eclipse.core.runtime.spi.IRegistryProvider;\nimport org.eclipse.jdt.core.JavaCore;\nimport org.eclipse.jdt.core.compiler.CategorizedProblem;\nimport org.eclipse.jdt.core.compiler.CharOperation;\nimport org.eclipse.jdt.core.dom.AST;\nimport org.eclipse.jdt.core.dom.CompilationUnit;\nimport org.eclipse.jdt.internal.compiler.CompilationResult;\nimport org.eclipse.jdt.internal.compiler.Compiler;\nimport org.eclipse.jdt.internal.compiler.ICompilerRequestor;\nimport org.eclipse.jdt.internal.compiler.IErrorHandlingPolicy;\nimport org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;\nimport org.eclipse.jdt.internal.compiler.batch.FileSystem;\nimport org.eclipse.jdt.internal.compiler.env.ICompilationUnit;\nimport org.eclipse.jdt.internal.compiler.impl.CompilerOptions;\nimport org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;\nimport org.eclipse.jdt.internal.core.JavaModelManager;\nimport org.osgi.framework.Bundle;\nimport org.osgi.framework.BundleContext;\n\npublic class RunTestsViaEcj extends AbstractRunTests {\n\tprotected CompilerOptions ecjCompilerOptions() {\n\t\tCompilerOptions options = new CompilerOptions();\n\t\tMap<String, String> warnings = new HashMap<String, String>();\n\t\t\n\t\tString javaVersionString = System.getProperty(\"compiler.compliance.level\");\n\t\tlong ecjCompilerVersionConstant = Eclipse.getLatestEcjCompilerVersionConstant();\n\t\tlong ecjCompilerVersion = Eclipse.getEcjCompilerVersion();\n\t\tif (javaVersionString != null) {\n\t\t\tlong javaVersion = Long.parseLong(javaVersionString);\n\t\t\tecjCompilerVersionConstant = (javaVersion + 44) << 16;\n\t\t\tecjCompilerVersion = javaVersion;\n\t\t} else {\n\t\t\t// Preview features are only allowed if the maximum compiler version is equal to the source version\n\t\t\twarnings.put(\"org.eclipse.jdt.core.compiler.problem.enablePreviewFeatures\", \"enabled\");\n\t\t}\n\t\toptions.complianceLevel = ecjCompilerVersionConstant;\n\t\toptions.sourceLevel = ecjCompilerVersionConstant;\n\t\toptions.targetJDK = ecjCompilerVersionConstant;\n\t\toptions.docCommentSupport = false;\n\t\toptions.parseLiteralExpressionsAsConstants = true;\n\t\toptions.inlineJsrBytecode = true;\n\t\toptions.reportUnusedDeclaredThrownExceptionExemptExceptionAndThrowable = false;\n\t\toptions.reportUnusedDeclaredThrownExceptionIncludeDocCommentReference = false;\n\t\toptions.reportUnusedDeclaredThrownExceptionWhenOverriding = false;\n\t\toptions.reportUnusedParameterIncludeDocCommentReference = false;\n\t\toptions.reportUnusedParameterWhenImplementingAbstract = false;\n\t\toptions.reportUnusedParameterWhenOverridingConcrete = false;\n\t\toptions.reportDeadCodeInTrivialIfStatement = false;\n\t\toptions.generateClassFiles = false;\n\t\twarnings.put(CompilerOptions.OPTION_ReportUnusedLocal, \"ignore\");\n\t\twarnings.put(CompilerOptions.OPTION_ReportUnusedLabel, \"ignore\");\n\t\twarnings.put(CompilerOptions.OPTION_ReportUnusedImport, \"ignore\");\n\t\twarnings.put(CompilerOptions.OPTION_ReportUnusedPrivateMember, \"ignore\");\n\t\twarnings.put(CompilerOptions.OPTION_ReportIndirectStaticAccess, \"warning\");\n\t\twarnings.put(CompilerOptions.OPTION_ReportNonStaticAccessToStatic, \"warning\");\n\t\twarnings.put(\"org.eclipse.jdt.core.compiler.problem.reportPreviewFeatures\", \"ignore\");\n\t\twarnings.put(CompilerOptions.OPTION_Source, (ecjCompilerVersion < 9 ? \"1.\" : \"\") + ecjCompilerVersion);\n\t\toptions.set(warnings);\n\t\treturn options;\n\t}\n\t\n\tprotected IErrorHandlingPolicy ecjErrorHandlingPolicy() {\n\t\treturn new IErrorHandlingPolicy() {\n\t\t\tpublic boolean stopOnFirstError() {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tpublic boolean proceedOnErrors() {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\t@SuppressWarnings(\"all\") // Added to the interface in later ecj version.\n\t\t\tpublic boolean ignoreAllErrors() {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t};\n\t}\n\t\n\tprivate ICompilationUnit getSourceUnit(File file, String source) {\n\t\tif (eclipseAvailable()) return new TestCompilationUnitEclipse(file.getName(), source);\n\t\treturn new TestCompilationUnitEcj(file.getName(), source);\n\t}\n\t\n\t@Override\n\tpublic boolean transformCode(Collection<CompilerMessage> messages, StringWriter result, File file, String encoding, Map<String, String> formatPreferences, int minVersion, boolean checkPositions) throws Throwable {\n\t\tfinal AtomicReference<CompilationResult> compilationResult_ = new AtomicReference<CompilationResult>();\n\t\tfinal AtomicReference<CompilationUnitDeclaration> compilationUnit_ = new AtomicReference<CompilationUnitDeclaration>();\n\t\tICompilerRequestor bitbucketRequestor = new ICompilerRequestor() {\n\t\t\t@Override public void acceptResult(CompilationResult result) {\n\t\t\t\tcompilationResult_.set(result);\n\t\t\t}\n\t\t};\n\t\t\n\t\tString source = readFile(file);\n\t\tchar[] sourceArray = source.toCharArray();\n\t\tfinal ICompilationUnit sourceUnit;\n\t\ttry {\n\t\t\tsourceUnit = getSourceUnit(file, source);\n\t\t} catch (Throwable t) {\n\t\t\tt.printStackTrace();\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tCompiler ecjCompiler = new Compiler(createFileSystem(file, minVersion), ecjErrorHandlingPolicy(), ecjCompilerOptions(), bitbucketRequestor, new DefaultProblemFactory(Locale.ENGLISH)) {\n\t\t\t@Override protected synchronized void addCompilationUnit(ICompilationUnit inUnit, CompilationUnitDeclaration parsedUnit) {\n\t\t\t\tif (inUnit == sourceUnit) compilationUnit_.set(parsedUnit);\n\t\t\t\tsuper.addCompilationUnit(inUnit, parsedUnit);\n\t\t\t}\n\t\t};\n\t\t\n\t\t// initializeEclipseBundles();\n\t\t\n\t\tecjCompiler.compile(new ICompilationUnit[] {sourceUnit});\n\t\t\n\t\tCompilationResult compilationResult = compilationResult_.get();\n\t\tCategorizedProblem[] problems = compilationResult.getAllProblems();\n\t\t\n\t\tif (problems != null) for (CategorizedProblem p : problems) {\n\t\t\tmessages.add(new CompilerMessage(p.getSourceLineNumber(), p.getSourceStart(), p.isError(), p.getMessage()));\n\t\t}\n\t\t\n\t\tCompilationUnitDeclaration cud = compilationUnit_.get();\n\t\t\n\t\tif (cud == null) result.append(\"---- No CompilationUnit provided by ecj ----\");\n\t\telse {\n\t\t\tString output = cud.toString();\n\t\t\t// starting somewhere around ecj16, the print code is a bit too cavalier with printing modifiers.\n\t\t\toutput = output.replace(\"non-sealed @val\", \"@val\");\n\t\t\tresult.append(output);\n\t\t}\n\t\t\n\t\tif (eclipseAvailable()) {\n\t\t\tEclipseDomConversion.toDomAst(cud, sourceArray);\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\t@SuppressWarnings(\"unused\")\n\tprivate static class EclipseInitializer {\n\t\tstatic void initializeEclipseBundles() throws Exception {\n\t\t\t// This code does not work yet, it's research-in-progress.\n\t\t\t// The problem is that parts of the eclipse handler (in `PatchValEclipse` and friends) do not work unless\n\t\t\t// an actual eclipse exists; PatchVal causes code to run that will end up running `ResourcesPlugin.getWorkspace()`, which\n\t\t\t// goes down a rabbit hole of pinging off of various static fields (or `getX()` calls which return static fields), all\n\t\t\t// of which are `null` until the plugin they belong to is properly initialized.\n\t\t\t// This code is work in progress to 'hack' the initialization of each plugin one-by-one, but I doubt this is the right\n\t\t\t// way to do it, as I bet it's fragile (will break when eclipse updates rather easily), and who knows how many fields\n\t\t\t// and things need to be initialized.\n\t\t\t// A better plan would be to start an actual, real eclipse, by telling `EclipseStarter.startup` to launch some sort of\n\t\t\t// application (or at least a bunch of bundles/products/apps, including the JDT). This will then take long enough that\n\t\t\t// it'll need to be cached and re-used for each test or the Eclipse test run would take far too long.\n\t\t\t\n\t\t\tBundleContext context = EclipseStarter.startup(new String[0], null);\n\t\t\tRegistryFactory.setDefaultRegistryProvider(new IRegistryProvider() {\n\t\t\t\tprivate final ExtensionRegistry REG = new ExtensionRegistry(null, null, null);\n\t\t\t\t@Override public IExtensionRegistry getRegistry() {\n\t\t\t\t\treturn REG;\n\t\t\t\t}\n\t\t\t});\n\t\t\tnew Activator().start(context);\n\t\t\tnew PlatformActivator().start(context);\n\t\t\tfor (Bundle b : context.getBundles()) System.out.println(\"BUNDLE: \" + b.getSymbolicName());\n\t\t\tnew ResourcesPlugin().start(context);\n\t\t\tJavaModelManager.getJavaModelManager().startup();\n\t\t}\n\t}\n\t\n\tstatic boolean eclipseAvailable() {\n\t\ttry {\n\t\t\tClass.forName(\"org.eclipse.jdt.core.dom.CompilationUnit\");\n\t\t} catch (Throwable t) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tprivate static final String bootRuntimePath = System.getProperty(\"delombok.bootclasspath\");\n\t\n\tprivate static class EclipseDomConversion {\n\t\tstatic CompilationUnit toDomAst(CompilationUnitDeclaration cud, final char[] source) {\n\t\t\tMap<String, String> options = new HashMap<String, String>();\n\t\t\toptions.put(JavaCore.COMPILER_SOURCE, \"11\");\n\t\t\toptions.put(\"org.eclipse.jdt.core.compiler.problem.enablePreviewFeatures\", \"enabled\");\n\t\t\t\n\t\t\torg.eclipse.jdt.internal.core.CompilationUnit ccu = new org.eclipse.jdt.internal.core.CompilationUnit(null, null, null) {\n\t\t\t\t@Override public char[] getContents() {\n\t\t\t\t\treturn source;\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn AST.convertCompilationUnit(4, cud, options, false, ccu, 0, null);\n\t\t}\n\t}\n\t\n\tprivate FileSystem createFileSystem(File file, int minVersion) {\n\t\tList<String> classpath = new ArrayList<String>();\n\t\tfor (Iterator<String> i = classpath.iterator(); i.hasNext();) {\n\t\t\tif (FileSystem.getClasspath(i.next(), \"UTF-8\", null) == null) {\n\t\t\t\ti.remove();\n\t\t\t}\n\t\t}\n\t\tif (new File(\"bin/main\").exists()) classpath.add(\"bin/main\");\n\t\tclasspath.add(\"dist/lombok.jar\");\n\t\tclasspath.add(\"build/teststubs\");\n\t\tif (bootRuntimePath == null || bootRuntimePath.isEmpty()) throw new IllegalStateException(\"System property delombok.bootclasspath is not set; set it to the rt of java6 or java8\");\n\t\tclasspath.add(bootRuntimePath);\n\t\tfor (File f : new File(\"lib/test\").listFiles()) {\n\t\t\tString fn = f.getName();\n\t\t\tif (fn.length() < 4) continue;\n\t\t\tif (!fn.substring(fn.length() - 4).toLowerCase().equals(\".jar\")) continue;\n\t\t\tclasspath.add(\"lib/test/\" + fn);\n\t\t}\n\t\treturn new FileSystem(classpath.toArray(new String[0]), new String[] {file.getAbsolutePath()}, \"UTF-8\");\n\t}\n\t\n\tprivate static final class TestCompilationUnitEcj implements ICompilationUnit {\n\t\tprivate final char[] name, source, mainTypeName;\n\t\t\n\t\tTestCompilationUnitEcj(String name, String source) {\n\t\t\tthis.source = source.toCharArray();\n\t\t\tthis.name = name.toCharArray();\n\t\t\t\n\t\t\tchar[] fileNameCharArray = getFileName();\n\t\t\tint start = CharOperation.lastIndexOf(File.separatorChar, fileNameCharArray) + 1;\n\t\t\tint end = CharOperation.lastIndexOf('.', fileNameCharArray);\n\t\t\tif (end == -1) {\n\t\t\t\tend = fileNameCharArray.length;\n\t\t\t}\n\t\t\tmainTypeName = CharOperation.subarray(fileNameCharArray, start, end);\n\t\t}\n\t\t\n\t\t@Override public char[] getFileName() {\n\t\t\treturn name;\n\t\t}\n\t\t\n\t\t@Override public char[] getContents() {\n\t\t\treturn source;\n\t\t}\n\t\t\n\t\t@Override public char[] getMainTypeName() {\n\t\t\treturn mainTypeName;\n\t\t}\n\t\t\n\t\t@Override public char[][] getPackageName() {\n\t\t\treturn null;\n\t\t}\n\t}\n\t\n\tprivate static final class TestCompilationUnitEclipse extends org.eclipse.jdt.internal.core.CompilationUnit {\n\t\tprivate final char[] source;\n\t\tprivate final char[] mainTypeName;\n\t\t\n\t\tprivate TestCompilationUnitEclipse(String name, String source) {\n\t\t\tsuper(null, name, null);\n\t\t\tthis.source = source.toCharArray();\n\t\t\t\n\t\t\tchar[] fileNameCharArray = getFileName();\n\t\t\tint start = CharOperation.lastIndexOf(File.separatorChar, fileNameCharArray) + 1;\n\t\t\tint end = CharOperation.lastIndexOf('.', fileNameCharArray);\n\t\t\tif (end == -1) {\n\t\t\t\tend = fileNameCharArray.length;\n\t\t\t}\n\t\t\tmainTypeName = CharOperation.subarray(fileNameCharArray, start, end);\n\t\t}\n\t\t\n\t\t@Override public char[] getContents() {\n\t\t\treturn source;\n\t\t}\n\t\t\n\t\t@Override public char[] getMainTypeName() {\n\t\t\treturn mainTypeName;\n\t\t}\n\t\t\n\t\t@Override public boolean ignoreOptionalProblems() {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t@Override public char[][] getPackageName() {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t@Override public char[] getModuleName() {\n\t\t\treturn null;\n\t\t}\n\t}\n}\n","lineNo":70}
{"Smelly Sample":"/*\n * Copyright (C) 2009-2021 The Project Lombok Authors.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage lombok.eclipse.handlers;\n\nimport static lombok.core.handlers.HandlerUtil.*;\nimport static lombok.eclipse.Eclipse.*;\nimport static lombok.eclipse.EcjAugments.*;\nimport static lombok.eclipse.handlers.EclipseHandlerUtil.EclipseReflectiveMembers.*;\n\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.eclipse.jdt.core.compiler.CharOperation;\nimport org.eclipse.jdt.internal.compiler.ast.ASTNode;\nimport org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.AbstractVariableDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.AllocationExpression;\nimport org.eclipse.jdt.internal.compiler.ast.Annotation;\nimport org.eclipse.jdt.internal.compiler.ast.Argument;\nimport org.eclipse.jdt.internal.compiler.ast.ArrayInitializer;\nimport org.eclipse.jdt.internal.compiler.ast.ArrayQualifiedTypeReference;\nimport org.eclipse.jdt.internal.compiler.ast.ArrayTypeReference;\nimport org.eclipse.jdt.internal.compiler.ast.AssertStatement;\nimport org.eclipse.jdt.internal.compiler.ast.BinaryExpression;\nimport org.eclipse.jdt.internal.compiler.ast.Block;\nimport org.eclipse.jdt.internal.compiler.ast.CastExpression;\nimport org.eclipse.jdt.internal.compiler.ast.CharLiteral;\nimport org.eclipse.jdt.internal.compiler.ast.ClassLiteralAccess;\nimport org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.DoubleLiteral;\nimport org.eclipse.jdt.internal.compiler.ast.EqualExpression;\nimport org.eclipse.jdt.internal.compiler.ast.Expression;\nimport org.eclipse.jdt.internal.compiler.ast.ExtendedStringLiteral;\nimport org.eclipse.jdt.internal.compiler.ast.FalseLiteral;\nimport org.eclipse.jdt.internal.compiler.ast.FieldDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.FieldReference;\nimport org.eclipse.jdt.internal.compiler.ast.FloatLiteral;\nimport org.eclipse.jdt.internal.compiler.ast.IfStatement;\nimport org.eclipse.jdt.internal.compiler.ast.IntLiteral;\nimport org.eclipse.jdt.internal.compiler.ast.Literal;\nimport org.eclipse.jdt.internal.compiler.ast.LongLiteral;\nimport org.eclipse.jdt.internal.compiler.ast.MarkerAnnotation;\nimport org.eclipse.jdt.internal.compiler.ast.MemberValuePair;\nimport org.eclipse.jdt.internal.compiler.ast.MessageSend;\nimport org.eclipse.jdt.internal.compiler.ast.MethodDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.NameReference;\nimport org.eclipse.jdt.internal.compiler.ast.NormalAnnotation;\nimport org.eclipse.jdt.internal.compiler.ast.NullLiteral;\nimport org.eclipse.jdt.internal.compiler.ast.OperatorIds;\nimport org.eclipse.jdt.internal.compiler.ast.ParameterizedQualifiedTypeReference;\nimport org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference;\nimport org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference;\nimport org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference;\nimport org.eclipse.jdt.internal.compiler.ast.SingleMemberAnnotation;\nimport org.eclipse.jdt.internal.compiler.ast.SingleNameReference;\nimport org.eclipse.jdt.internal.compiler.ast.SingleTypeReference;\nimport org.eclipse.jdt.internal.compiler.ast.Statement;\nimport org.eclipse.jdt.internal.compiler.ast.StringLiteral;\nimport org.eclipse.jdt.internal.compiler.ast.StringLiteralConcatenation;\nimport org.eclipse.jdt.internal.compiler.ast.ThisReference;\nimport org.eclipse.jdt.internal.compiler.ast.ThrowStatement;\nimport org.eclipse.jdt.internal.compiler.ast.TrueLiteral;\nimport org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.TypeParameter;\nimport org.eclipse.jdt.internal.compiler.ast.TypeReference;\nimport org.eclipse.jdt.internal.compiler.ast.Wildcard;\nimport org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;\nimport org.eclipse.jdt.internal.compiler.lookup.Binding;\nimport org.eclipse.jdt.internal.compiler.lookup.CaptureBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.RawTypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.TypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.TypeConstants;\nimport org.eclipse.jdt.internal.compiler.lookup.TypeIds;\nimport org.eclipse.jdt.internal.compiler.lookup.WildcardBinding;\n\nimport lombok.AccessLevel;\nimport lombok.ConfigurationKeys;\nimport lombok.Data;\nimport lombok.Getter;\nimport lombok.Lombok;\nimport lombok.core.AST.Kind;\nimport lombok.core.AnnotationValues;\nimport lombok.core.AnnotationValues.AnnotationValue;\nimport lombok.core.LombokImmutableList;\nimport lombok.core.TypeResolver;\nimport lombok.core.configuration.CheckerFrameworkVersion;\nimport lombok.core.configuration.NullAnnotationLibrary;\nimport lombok.core.configuration.NullCheckExceptionType;\nimport lombok.core.configuration.TypeName;\nimport lombok.core.debug.ProblemReporter;\nimport lombok.core.handlers.HandlerUtil;\nimport lombok.core.handlers.HandlerUtil.FieldAccess;\nimport lombok.eclipse.EcjAugments;\nimport lombok.eclipse.Eclipse;\nimport lombok.eclipse.EclipseAST;\nimport lombok.eclipse.EclipseNode;\nimport lombok.experimental.Accessors;\nimport lombok.experimental.Tolerate;\nimport lombok.permit.Permit;\n\n/**\n * Container for static utility methods useful to handlers written for eclipse.\n */\npublic class EclipseHandlerUtil {\n\tprivate EclipseHandlerUtil() {\n\t\t//Prevent instantiation\n\t}\n\t\n\t/**\n\t * Generates an error in the Eclipse error log. Note that most people never look at it!\n\t * \n\t * @param cud The {@code CompilationUnitDeclaration} where the error occurred.\n\t *     An error will be generated on line 0 linking to the error log entry. Can be {@code null}.\n\t * @param message Human readable description of the problem.\n\t * @param ex The associated exception. Can be {@code null}.\n\t */\n\tpublic static void error(CompilationUnitDeclaration cud, String message, Throwable ex) {\n\t\tProblemReporter.error(message, ex);\n\t\tif (cud != null) EclipseAST.addProblemToCompilationResult(cud.getFileName(), cud.compilationResult, false, message + \" - See error log.\", 0, 0);\n\t}\n\t\n\t/**\n\t * Generates a warning in the Eclipse error log. Note that most people never look at it!\n\t * \n\t * @param message Human readable description of the problem.\n\t * @param ex The associated exception. Can be {@code null}.\n\t */\n\tpublic static void warning(String message, Throwable ex) {\n\t\tProblemReporter.warning(message, ex);\n\t}\n\t\n\tpublic static ASTNode getGeneratedBy(ASTNode node) {\n\t\treturn ASTNode_generatedBy.get(node);\n\t}\n\t\n\tpublic static boolean isGenerated(ASTNode node) {\n\t\treturn getGeneratedBy(node) != null;\n\t}\n\t\n\tpublic static <T extends ASTNode> T setGeneratedBy(T node, ASTNode source) {\n\t\tASTNode_generatedBy.set(node, source);\n\t\treturn node;\n\t}\n\t\n\tpublic static MarkerAnnotation generateDeprecatedAnnotation(ASTNode source) {\n\t\tQualifiedTypeReference qtr = new QualifiedTypeReference(new char[][] {\n\t\t\t\t{'j', 'a', 'v', 'a'}, {'l', 'a', 'n', 'g'}, {'D', 'e', 'p', 'r', 'e', 'c', 'a', 't', 'e', 'd'}}, poss(source, 3));\n\t\tsetGeneratedBy(qtr, source);\n\t\tMarkerAnnotation ma = new MarkerAnnotation(qtr, source.sourceStart);\n\t\t// No matter what value you input for sourceEnd, the AST->DOM converter of eclipse will reparse to find the end, and will fail as\n\t\t// it can't find code that isn't really there. This results in the end position being set to 2 or 0 or some weird magic value, and thus,\n\t\t// length, as calculated by end-start, is all screwed up, resulting in IllegalArgumentException during a setSourceRange call MUCH later in the process.\n\t\t// We solve it by going with a voodoo magic source start value such that the calculated length so happens to exactly be 0. 0 lengths are accepted\n\t\t// by eclipse. For some reason.\n\t\t// TL;DR: Don't change 1. 1 is sacred. Trust the 1.\n\t\t// issue: #408.\n\t\tma.sourceStart = 1;\n\t\tsetGeneratedBy(ma, source);\n\t\treturn ma;\n\t}\n\t\n\tpublic static MarkerAnnotation generateNamedAnnotation(ASTNode source, String typeName) {\n\t\tchar[][] cc = fromQualifiedName(typeName);\n\t\tQualifiedTypeReference qtr = new QualifiedTypeReference(cc, poss(source, cc.length));\n\t\tsetGeneratedBy(qtr, source);\n\t\tMarkerAnnotation ma = new MarkerAnnotation(qtr, source.sourceStart);\n\t\t// No matter what value you input for sourceEnd, the AST->DOM converter of eclipse will reparse to find the end, and will fail as\n\t\t// it can't find code that isn't really there. This results in the end position being set to 2 or 0 or some weird magic value, and thus,\n\t\t// length, as calculated by end-start, is all screwed up, resulting in IllegalArgumentException during a setSourceRange call MUCH later in the process.\n\t\t// We solve it by going with a voodoo magic source start value such that the calculated length so happens to exactly be 0. 0 lengths are accepted\n\t\t// by eclipse. For some reason.\n\t\t// TL;DR: Don't change 1. 1 is sacred. Trust the 1.\n\t\t// issue: #408.\n\t\tma.sourceStart = 1;\n\t\tsetGeneratedBy(ma, source);\n\t\treturn ma;\n\t}\n\t\n\tpublic static boolean isFieldDeprecated(EclipseNode fieldNode) {\n\t\tif (!(fieldNode.get() instanceof FieldDeclaration)) return false;\n\t\tFieldDeclaration field = (FieldDeclaration) fieldNode.get();\n\t\tif ((field.modifiers & ClassFileConstants.AccDeprecated) != 0) {\n\t\t\treturn true;\n\t\t}\n\t\tif (field.annotations == null) return false;\n\t\tfor (Annotation annotation : field.annotations) {\n\t\t\tif (typeMatches(Deprecated.class, fieldNode, annotation.type)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic static CheckerFrameworkVersion getCheckerFrameworkVersion(EclipseNode node) {\n\t\tCheckerFrameworkVersion cfv = node.getAst().readConfiguration(ConfigurationKeys.CHECKER_FRAMEWORK);\n\t\treturn cfv != null ? cfv : CheckerFrameworkVersion.NONE;\n\t}\n\t\n\t/**\n\t * Checks if the given TypeReference node is likely to be a reference to the provided class.\n\t * \n\t * @param type An actual type. This method checks if {@code typeNode} is likely to be a reference to this type.\n\t * @param node A Lombok AST node. Any node in the appropriate compilation unit will do (used to get access to import statements).\n\t * @param typeRef A type reference to check.\n\t */\n\tpublic static boolean typeMatches(Class<?> type, EclipseNode node, TypeReference typeRef) {\n\t\treturn typeMatches(type.getName(), node, typeRef);\n\t}\n\t\n\t/**\n\t * Checks if the given TypeReference node is likely to be a reference to the provided class.\n\t * \n\t * @param type An actual type. This method checks if {@code typeNode} is likely to be a reference to this type.\n\t * @param node A Lombok AST node. Any node in the appropriate compilation unit will do (used to get access to import statements).\n\t * @param typeRef A type reference to check.\n\t */\n\tpublic static boolean typeMatches(String type, EclipseNode node, TypeReference typeRef) {\n\t\tchar[][] tn = typeRef == null ? null : typeRef.getTypeName();\n\t\tif (tn == null || tn.length == 0) return false;\n\t\tchar[] lastPartA = tn[tn.length - 1];\n\t\tint lastIndex = Math.max(type.lastIndexOf('.'), type.lastIndexOf('$')) + 1;\n\t\tif (lastPartA.length != type.length() - lastIndex) return false;\n\t\tfor (int i = 0; i < lastPartA.length; i++) if (lastPartA[i] != type.charAt(i + lastIndex)) return false;\n\t\tString typeName = toQualifiedName(tn);\n\t\tTypeResolver resolver = node.getImportListAsTypeResolver();\n\t\treturn resolver.typeMatches(node, type, typeName);\n\t}\n\t\n\tpublic static void sanityCheckForMethodGeneratingAnnotationsOnBuilderClass(EclipseNode typeNode, EclipseNode errorNode) {\n\t\tList<String> disallowed = null;\n\t\tfor (EclipseNode child : typeNode.down()) {\n\t\t\tif (child.getKind() != Kind.ANNOTATION) continue;\n\t\t\tfor (String annType : INVALID_ON_BUILDERS) {\n\t\t\t\tif (annotationTypeMatches(annType, child)) {\n\t\t\t\t\tif (disallowed == null) disallowed = new ArrayList<String>();\n\t\t\t\t\tint lastIndex = annType.lastIndexOf('.');\n\t\t\t\t\tdisallowed.add(lastIndex == -1 ? annType : annType.substring(lastIndex + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint size = disallowed == null ? 0 : disallowed.size();\n\t\tif (size == 0) return;\n\t\tif (size == 1) {\n\t\t\terrorNode.addError(\"@\" + disallowed.get(0) + \" is not allowed on builder classes.\");\n\t\t\treturn;\n\t\t}\n\t\tStringBuilder out = new StringBuilder();\n\t\tfor (String a : disallowed) out.append(\"@\").append(a).append(\", \");\n\t\tout.setLength(out.length() - 2);\n\t\terrorNode.addError(out.append(\" are not allowed on builder classes.\").toString());\n\t}\n\t\n\tpublic static Annotation copyAnnotation(Annotation annotation, ASTNode source) {\n\t\tint pS = source.sourceStart, pE = source.sourceEnd;\n\t\t\n\t\tif (annotation instanceof MarkerAnnotation) {\n\t\t\tMarkerAnnotation ann = new MarkerAnnotation(copyType(annotation.type, source), pS);\n\t\t\tsetGeneratedBy(ann, source);\n\t\t\tann.declarationSourceEnd = ann.sourceEnd = ann.statementEnd = pE;\n\t\t\tcopyMemberValuePairName(ann, annotation);\n\t\t\treturn ann;\n\t\t}\n\t\t\n\t\tif (annotation instanceof SingleMemberAnnotation) {\n\t\t\tSingleMemberAnnotation ann = new SingleMemberAnnotation(copyType(annotation.type, source), pS);\n\t\t\tsetGeneratedBy(ann, source);\n\t\t\tann.declarationSourceEnd = ann.sourceEnd = ann.statementEnd = pE;\n\t\t\tann.memberValue = copyAnnotationMemberValue(((SingleMemberAnnotation) annotation).memberValue);\n\t\t\tcopyMemberValuePairName(ann, annotation);\n\t\t\treturn ann;\n\t\t}\n\t\t\n\t\tif (annotation instanceof NormalAnnotation) {\n\t\t\tNormalAnnotation ann = new NormalAnnotation(copyType(annotation.type, source), pS);\n\t\t\tsetGeneratedBy(ann, source);\n\t\t\tann.declarationSourceEnd = ann.statementEnd = ann.sourceEnd = pE;\n\t\t\tMemberValuePair[] inPairs = ((NormalAnnotation) annotation).memberValuePairs;\n\t\t\tif (inPairs == null) {\n\t\t\t\tann.memberValuePairs = null;\n\t\t\t} else {\n\t\t\t\tann.memberValuePairs = new MemberValuePair[inPairs.length];\n\t\t\t\tfor (int i = 0; i < inPairs.length; i++) ann.memberValuePairs[i] =\n\t\t\t\t\t\tnew MemberValuePair(inPairs[i].name, inPairs[i].sourceStart, inPairs[i].sourceEnd, copyAnnotationMemberValue(inPairs[i].value));\n\t\t\t}\n\t\t\tcopyMemberValuePairName(ann, annotation);\n\t\t\treturn ann;\n\t\t}\n\t\t\n\t\treturn annotation;\n\t}\n\t\n\tprivate static void copyMemberValuePairName(Annotation source, Annotation target) {\n\t\tif (ANNOTATION__MEMBER_VALUE_PAIR_NAME == null) return;\n\t\t\n\t\ttry {\n\t\t\treflectSet(ANNOTATION__MEMBER_VALUE_PAIR_NAME, source, reflect(ANNOTATION__MEMBER_VALUE_PAIR_NAME, target));\n\t\t} catch (Exception ignore) { /* Various eclipse versions don't have it */ }\n\t}\n\t\n\tstatic class EclipseReflectiveMembers {\n\t\tpublic static final Field STRING_LITERAL__LINE_NUMBER;\n\t\tpublic static final Field ANNOTATION__MEMBER_VALUE_PAIR_NAME;\n\t\tpublic static final Field TYPE_REFERENCE__ANNOTATIONS;\n\t\tpublic static final Class<?> INTERSECTION_BINDING1, INTERSECTION_BINDING2;\n\t\tpublic static final Field INTERSECTION_BINDING_TYPES1, INTERSECTION_BINDING_TYPES2;\n\t\tpublic static final Field TYPE_DECLARATION_RECORD_COMPONENTS;\n\t\tstatic {\n\t\t\tSTRING_LITERAL__LINE_NUMBER = getField(StringLiteral.class, \"lineNumber\");\n\t\t\tANNOTATION__MEMBER_VALUE_PAIR_NAME = getField(Annotation.class, \"memberValuePairName\");\n\t\t\tTYPE_REFERENCE__ANNOTATIONS = getField(TypeReference.class, \"annotations\");\n\t\t\tINTERSECTION_BINDING1 = getClass(\"org.eclipse.jdt.internal.compiler.lookup.IntersectionTypeBinding18\");\n\t\t\tINTERSECTION_BINDING2 = getClass(\"org.eclipse.jdt.internal.compiler.lookup.IntersectionCastTypeBinding\");\n\t\t\tINTERSECTION_BINDING_TYPES1 = INTERSECTION_BINDING1 == null ? null : getField(INTERSECTION_BINDING1, \"intersectingTypes\");\n\t\t\tINTERSECTION_BINDING_TYPES2 = INTERSECTION_BINDING2 == null ? null : getField(INTERSECTION_BINDING2, \"intersectingTypes\");\n\t\t\tTYPE_DECLARATION_RECORD_COMPONENTS = getField(TypeDeclaration.class, \"recordComponents\");\n\t\t}\n\t\t\n\t\tpublic static int reflectInt(Field f, Object o) {\n\t\t\ttry {\n\t\t\t\treturn ((Number) f.get(o)).intValue();\n\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static void reflectSet(Field f, Object o, Object v) {\n\t\t\ttry {\n\t\t\t\tf.set(o, v);\n\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static Object reflect(Field f, Object o) {\n\t\t\ttry {\n\t\t\t\treturn f.get(o);\n\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprivate static Class<?> getClass(String fqn) {\n\t\t\ttry {\n\t\t\t\treturn Class.forName(fqn);\n\t\t\t} catch (Throwable t) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\t\n\t\tprivate static Field getField(Class<?> c, String fName) {\n\t\t\ttry {\n\t\t\t\treturn Permit.getField(c, fName);\n\t\t\t} catch (Throwable t) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static Expression copyAnnotationMemberValue(Expression in) {\n\t\tExpression out = copyAnnotationMemberValue0(in);\n\t\tout.constant = in.constant;\n\t\treturn out;\n\t}\n\t\n\tprivate static Expression copyAnnotationMemberValue0(Expression in) {\n\t\tint s = in.sourceStart, e = in.sourceEnd;\n\t\t\n\t\t// literals\n\t\t\n\t\tif (in instanceof FalseLiteral) return new FalseLiteral(s, e);\n\t\tif (in instanceof TrueLiteral) return new TrueLiteral(s, e);\n\t\tif (in instanceof NullLiteral) return new NullLiteral(s, e);\n\t\t\n\t\tif (in instanceof CharLiteral) return new CharLiteral(((Literal) in).source(), s, e);\n\t\tif (in instanceof DoubleLiteral) return new DoubleLiteral(((Literal) in).source(), s, e);\n\t\tif (in instanceof FloatLiteral) return new FloatLiteral(((Literal) in).source(), s, e);\n\t\tif (in instanceof IntLiteral) return IntLiteral.buildIntLiteral(((Literal) in).source(), s, e);\n\t\tif (in instanceof LongLiteral) return LongLiteral.buildLongLiteral(((Literal) in).source(), s, e);\n\t\t\n\t\tif (in instanceof StringLiteral) return new StringLiteral(((Literal) in).source(), s, e, reflectInt(STRING_LITERAL__LINE_NUMBER, in) + 1);\n\t\tif (in instanceof ExtendedStringLiteral) {\n\t\t\tStringLiteral str = new StringLiteral(((Literal) in).source(), s, e, reflectInt(STRING_LITERAL__LINE_NUMBER, in) + 1);\n\t\t\tStringLiteral empty = new StringLiteral(new char[0], s, e, reflectInt(STRING_LITERAL__LINE_NUMBER, in) + 1);\n\t\t\treturn new ExtendedStringLiteral(str, empty);\n\t\t}\n\t\tif (in instanceof StringLiteralConcatenation) {\n\t\t\tExpression[] literals = ((StringLiteralConcatenation) in).literals;\n\t\t\t// 0 and 1 len shouldn't happen.\n\t\t\tif (literals.length == 0) return new StringLiteral(new char[0], s, e, 0);\n\t\t\tif (literals.length == 1) return copyAnnotationMemberValue0(literals[0]);\n\t\t\tStringLiteralConcatenation c = new StringLiteralConcatenation((StringLiteral) literals[0], (StringLiteral) literals[1]);\n\t\t\tfor (int i = 2; i < literals.length; i++) c = c.extendsWith((StringLiteral) literals[i]);\n\t\t\treturn c;\n\t\t}\n\t\t\n\t\t// enums and field accesses (as long as those are references to compile time constant literals that's also acceptable)\n\t\t\n\t\tif (in instanceof SingleNameReference) {\n\t\t\tSingleNameReference snr = (SingleNameReference) in;\n\t\t\treturn new SingleNameReference(snr.token, pos(in));\n\t\t}\n\t\tif (in instanceof QualifiedNameReference) {\n\t\t\tQualifiedNameReference qnr = (QualifiedNameReference) in;\n\t\t\treturn new QualifiedNameReference(qnr.tokens, poss(in, qnr.tokens.length), s, e);\n\t\t}\n\t\t\n\t\t// class refs\n\t\tif (in instanceof ClassLiteralAccess) return new ClassLiteralAccess(e, copyType(((ClassLiteralAccess) in).type));\n\t\t\n\t\t// arrays\n\t\tif (in instanceof ArrayInitializer) {\n\t\t\tExpression[] exprs = ((ArrayInitializer) in).expressions;\n\t\t\tExpression[] copy = new Expression[exprs.length];\n\t\t\tfor (int i = 0; i < exprs.length; i++) copy[i] = copyAnnotationMemberValue(exprs[i]);\n\t\t\tArrayInitializer out = new ArrayInitializer();\n\t\t\tout.sourceStart = s;\n\t\t\tout.sourceEnd = e;\n\t\t\tout.bits = in.bits;\n\t\t\tout.implicitConversion = in.implicitConversion;\n\t\t\tout.statementEnd = e;\n\t\t\tout.expressions = copy;\n\t\t\treturn out;\n\t\t}\n\t\t\n\t\tif (in instanceof BinaryExpression) {\n\t\t\tBinaryExpression be = (BinaryExpression) in;\n\t\t\tBinaryExpression out = new BinaryExpression(be);\n\t\t\tout.left = copyAnnotationMemberValue(be.left);\n\t\t\tout.right = copyAnnotationMemberValue(be.right);\n\t\t\tout.sourceStart = s;\n\t\t\tout.sourceEnd = e;\n\t\t\tout.statementEnd = e;\n\t\t\treturn out;\n\t\t}\n\t\t\n\t\treturn in;\n\t}\n\t\n\t/**\n\t * You can't share TypeParameter objects or bad things happen; for example, one 'T' resolves differently\n\t * from another 'T', even for the same T in a single class file. Unfortunately the TypeParameter type hierarchy\n\t * is complicated and there's no clone method on TypeParameter itself. This method can clone them.\n\t */\n\tpublic static TypeParameter[] copyTypeParams(TypeParameter[] params, ASTNode source) {\n\t\tif (params == null) return null;\n\t\tTypeParameter[] out = new TypeParameter[params.length];\n\t\tint idx = 0;\n\t\tfor (TypeParameter param : params) {\n\t\t\tTypeParameter o = new TypeParameter();\n\t\t\tsetGeneratedBy(o, source);\n\t\t\to.annotations = param.annotations;\n\t\t\to.bits = param.bits;\n\t\t\to.modifiers = param.modifiers;\n\t\t\to.name = param.name;\n\t\t\to.type = copyType(param.type, source);\n\t\t\to.sourceStart = param.sourceStart;\n\t\t\to.sourceEnd = param.sourceEnd;\n\t\t\to.declarationEnd = param.declarationEnd;\n\t\t\to.declarationSourceStart = param.declarationSourceStart;\n\t\t\to.declarationSourceEnd = param.declarationSourceEnd;\n\t\t\tif (param.bounds != null) {\n\t\t\t\tTypeReference[] b = new TypeReference[param.bounds.length];\n\t\t\t\tint idx2 = 0;\n\t\t\t\tfor (TypeReference ref : param.bounds) b[idx2++] = copyType(ref, source);\n\t\t\t\to.bounds = b;\n\t\t\t}\n\t\t\tout[idx++] = o;\n\t\t}\n\t\treturn out;\n\t}\n\t\n\tpublic static Annotation[] getTypeUseAnnotations(TypeReference from) {\n\t\tAnnotation[][] a;\n\t\ttry {\n\t\t\ta = (Annotation[][]) reflect(TYPE_REFERENCE__ANNOTATIONS, from);\n\t\t} catch (Exception e) {\n\t\t\treturn null;\n\t\t}\n\t\tif (a == null) return null;\n\t\tAnnotation[] b = a[a.length - 1];\n\t\treturn b.length == 0 ? null : b;\n\t}\n\t\n\tpublic static void removeTypeUseAnnotations(TypeReference from) {\n\t\ttry {\n\t\t\treflectSet(TYPE_REFERENCE__ANNOTATIONS, from, null);\n\t\t} catch (Exception ignore) {}\n\t}\n\t\n\tpublic static TypeReference namePlusTypeParamsToTypeReference(EclipseNode type, TypeParameter[] params, long p) {\n\t\tTypeDeclaration td = (TypeDeclaration) type.get();\n\t\tboolean instance = (td.modifiers & MODIFIERS_INDICATING_STATIC) == 0;\n\t\treturn namePlusTypeParamsToTypeReference(type.up(), td.name, instance, params, p);\n\t}\n\t\n\tpublic static TypeReference namePlusTypeParamsToTypeReference(EclipseNode parentType, char[] typeName, boolean instance, TypeParameter[] params, long p) {\n\t\tif (params != null && params.length > 0) {\n\t\t\tTypeReference[] refs = new TypeReference[params.length];\n\t\t\tint idx = 0;\n\t\t\tfor (TypeParameter param : params) {\n\t\t\t\tTypeReference typeRef = new SingleTypeReference(param.name, p);\n\t\t\t\trefs[idx++] = typeRef;\n\t\t\t}\n\t\t\treturn generateParameterizedTypeReference(parentType, typeName, instance, refs, p);\n\t\t}\n\t\t\n\t\treturn generateTypeReference(parentType, typeName, instance, p);\n\t}\n\t\n\tpublic static TypeReference[] copyTypes(TypeReference[] refs) {\n\t\treturn copyTypes(refs, null);\n\t}\n\t\n\t/**\n\t * Convenience method that creates a new array and copies each TypeReference in the source array via\n\t * {@link #copyType(TypeReference, ASTNode)}.\n\t */\n\tpublic static TypeReference[] copyTypes(TypeReference[] refs, ASTNode source) {\n\t\tif (refs == null) return null;\n\t\tTypeReference[] outs = new TypeReference[refs.length];\n\t\tint idx = 0;\n\t\tfor (TypeReference ref : refs) {\n\t\t\touts[idx++] = copyType(ref, source);\n\t\t}\n\t\treturn outs;\n\t}\n\t\n\tpublic static TypeReference copyType(TypeReference ref) {\n\t\treturn copyType(ref, null);\n\t}\n\t\n\t/**\n\t * You can't share TypeReference objects or subtle errors start happening.\n\t * Unfortunately the TypeReference type hierarchy is complicated and there's no clone\n\t * method on TypeReference itself. This method can clone them.\n\t */\n\tpublic static TypeReference copyType(TypeReference ref, ASTNode source) {\n\t\tif (ref instanceof ParameterizedQualifiedTypeReference) {\n\t\t\tParameterizedQualifiedTypeReference iRef = (ParameterizedQualifiedTypeReference) ref;\n\t\t\tTypeReference[][] args = null;\n\t\t\tif (iRef.typeArguments != null) {\n\t\t\t\targs = new TypeReference[iRef.typeArguments.length][];\n\t\t\t\tint idx = 0;\n\t\t\t\tfor (TypeReference[] inRefArray : iRef.typeArguments) {\n\t\t\t\t\tif (inRefArray == null) args[idx++] = null;\n\t\t\t\t\telse {\n\t\t\t\t\t\tTypeReference[] outRefArray = new TypeReference[inRefArray.length];\n\t\t\t\t\t\tint idx2 = 0;\n\t\t\t\t\t\tfor (TypeReference inRef : inRefArray) {\n\t\t\t\t\t\t\toutRefArray[idx2++] = copyType(inRef, source);\n\t\t\t\t\t\t}\n\t\t\t\t\t\targs[idx++] = outRefArray;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tTypeReference typeRef = new ParameterizedQualifiedTypeReference(iRef.tokens, args, iRef.dimensions(), copy(iRef.sourcePositions));\n\t\t\tcopyTypeAnns(ref, typeRef);\n\t\t\tif (source != null) setGeneratedBy(typeRef, source);\n\t\t\treturn typeRef;\n\t\t}\n\t\t\n\t\tif (ref instanceof ArrayQualifiedTypeReference) {\n\t\t\tArrayQualifiedTypeReference iRef = (ArrayQualifiedTypeReference) ref;\n\t\t\tTypeReference typeRef = new ArrayQualifiedTypeReference(iRef.tokens, iRef.dimensions(), copy(iRef.sourcePositions));\n\t\t\tcopyTypeAnns(ref, typeRef);\n\t\t\tif (source != null) setGeneratedBy(typeRef, source);\n\t\t\treturn typeRef;\n\t\t}\n\t\t\n\t\tif (ref instanceof QualifiedTypeReference) {\n\t\t\tQualifiedTypeReference iRef = (QualifiedTypeReference) ref;\n\t\t\tTypeReference typeRef = new QualifiedTypeReference(iRef.tokens, copy(iRef.sourcePositions));\n\t\t\tcopyTypeAnns(ref, typeRef);\n\t\t\tif (source != null) setGeneratedBy(typeRef, source);\n\t\t\treturn typeRef;\n\t\t}\n\t\t\n\t\tif (ref instanceof ParameterizedSingleTypeReference) {\n\t\t\tParameterizedSingleTypeReference iRef = (ParameterizedSingleTypeReference) ref;\n\t\t\tTypeReference[] args = null;\n\t\t\tif (iRef.typeArguments != null) {\n\t\t\t\targs = new TypeReference[iRef.typeArguments.length];\n\t\t\t\tint idx = 0;\n\t\t\t\tfor (TypeReference inRef : iRef.typeArguments) {\n\t\t\t\t\tif (inRef == null) args[idx++] = null;\n\t\t\t\t\telse args[idx++] = copyType(inRef, source);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tTypeReference typeRef = new ParameterizedSingleTypeReference(iRef.token, args, iRef.dimensions(), (long) iRef.sourceStart << 32 | iRef.sourceEnd);\n\t\t\tcopyTypeAnns(ref, typeRef);\n\t\t\tif (source != null) setGeneratedBy(typeRef, source);\n\t\t\treturn typeRef;\n\t\t}\n\t\t\n\t\tif (ref instanceof ArrayTypeReference) {\n\t\t\tArrayTypeReference iRef = (ArrayTypeReference) ref;\n\t\t\tTypeReference typeRef = new ArrayTypeReference(iRef.token, iRef.dimensions(), (long) iRef.sourceStart << 32 | iRef.sourceEnd);\n\t\t\tcopyTypeAnns(ref, typeRef);\n\t\t\tif (source != null) setGeneratedBy(typeRef, source);\n\t\t\treturn typeRef;\n\t\t}\n\t\t\n\t\tif (ref instanceof Wildcard) {\n\t\t\tWildcard original = (Wildcard) ref;\n\t\t\t\n\t\t\tWildcard wildcard = new Wildcard(original.kind);\n\t\t\twildcard.sourceStart = original.sourceStart;\n\t\t\twildcard.sourceEnd = original.sourceEnd;\n\t\t\tif (original.bound != null) wildcard.bound = copyType(original.bound, source);\n\t\t\tcopyTypeAnns(ref, wildcard);\n\t\t\tif (source != null) setGeneratedBy(wildcard, source);\n\t\t\treturn wildcard;\n\t\t}\n\t\t\n\t\tif (ref instanceof SingleTypeReference) {\n\t\t\tSingleTypeReference iRef = (SingleTypeReference) ref;\n\t\t\tTypeReference typeRef = new SingleTypeReference(iRef.token, (long) iRef.sourceStart << 32 | iRef.sourceEnd);\n\t\t\tcopyTypeAnns(ref, typeRef);\n\t\t\tif (source != null) setGeneratedBy(typeRef, source);\n\t\t\treturn typeRef;\n\t\t}\n\t\t\n\t\treturn ref;\n\t}\n\t\n\tprivate static void copyTypeAnns(TypeReference in, TypeReference out) {\n\t\tAnnotation[][] a;\n\t\ttry {\n\t\t\ta = (Annotation[][]) reflect(TYPE_REFERENCE__ANNOTATIONS, in);\n\t\t} catch (Exception e) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (a == null) {\n\t\t\treflectSet(TYPE_REFERENCE__ANNOTATIONS, out, null);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tAnnotation[][] b = new Annotation[a.length][];\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tif (a[i] != null) {\n\t\t\t\tb[i] = new Annotation[a[i].length];\n\t\t\t\tfor (int j = 0 ; j < a[i].length; j++) {\n\t\t\t\t\tb[i][j] = copyAnnotation(a[i][j], a[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treflectSet(TYPE_REFERENCE__ANNOTATIONS, out, b);\n\t}\n\t\n\tpublic static Annotation[] copyAnnotations(ASTNode source, Annotation[]... allAnnotations) {\n\t\tList<Annotation> result = null;\n\t\tfor (Annotation[] annotations : allAnnotations) {\n\t\t\tif (annotations != null) {\n\t\t\t\tfor (Annotation annotation : annotations) {\n\t\t\t\t\tif (result == null) result = new ArrayList<Annotation>();\n\t\t\t\t\tresult.add(copyAnnotation(annotation, source));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result == null ? null : result.toArray(new Annotation[0]);\n\t}\n\t\n\tpublic static boolean hasAnnotation(Class<? extends java.lang.annotation.Annotation> type, EclipseNode node) {\n\t\tif (node == null) return false;\n\t\tif (type == null) return false;\n\t\tswitch (node.getKind()) {\n\t\tcase ARGUMENT:\n\t\tcase FIELD:\n\t\tcase LOCAL:\n\t\tcase TYPE:\n\t\tcase METHOD:\n\t\t\tfor (EclipseNode child : node.down()) {\n\t\t\t\tif (annotationTypeMatches(type, child)) return true;\n\t\t\t}\n\t\t\t// intentional fallthrough\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tpublic static boolean hasAnnotation(String type, EclipseNode node) {\n\t\tif (node == null) return false;\n\t\tif (type == null) return false;\n\t\tswitch (node.getKind()) {\n\t\tcase ARGUMENT:\n\t\tcase FIELD:\n\t\tcase LOCAL:\n\t\tcase TYPE:\n\t\tcase METHOD:\n\t\t\tfor (EclipseNode child : node.down()) {\n\t\t\t\tif (annotationTypeMatches(type, child)) return true;\n\t\t\t}\n\t\t\t// intentional fallthrough\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tpublic static EclipseNode findInnerClass(EclipseNode parent, String name) {\n\t\tchar[] c = name.toCharArray();\n\t\tfor (EclipseNode child : parent.down()) {\n\t\t\tif (child.getKind() != Kind.TYPE) continue;\n\t\t\tTypeDeclaration td = (TypeDeclaration) child.get();\n\t\t\tif (Arrays.equals(td.name, c)) return child;\n\t\t}\n\t\treturn null;\n\t}\n\t\n\tpublic static EclipseNode findAnnotation(Class<? extends java.lang.annotation.Annotation> type, EclipseNode node) {\n\t\tif (node == null) return null;\n\t\tif (type == null) return null;\n\t\tswitch (node.getKind()) {\n\t\tcase ARGUMENT:\n\t\tcase FIELD:\n\t\tcase LOCAL:\n\t\tcase TYPE:\n\t\tcase METHOD:\n\t\t\tfor (EclipseNode child : node.down()) {\n\t\t\t\tif (annotationTypeMatches(type, child)) return child;\n\t\t\t}\n\t\t\t// intentional fallthrough\n\t\tdefault:\n\t\t\treturn null;\n\t\t}\n\t}\n\t\n\tpublic static String scanForNearestAnnotation(EclipseNode node, String... anns) {\n\t\twhile (node != null) {\n\t\t\tfor (EclipseNode ann : node.down()) {\n\t\t\t\tif (ann.getKind() != Kind.ANNOTATION) continue;\n\t\t\t\tAnnotation a = (Annotation) ann.get();\n\t\t\t\tTypeReference aType = a.type;\n\t\t\t\tfor (String annToFind : anns) if (typeMatches(annToFind, node, aType)) return annToFind;\n\t\t\t}\n\t\t\tnode = node.up();\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\t\n\tpublic static boolean hasNonNullAnnotations(EclipseNode node) {\n\t\tfor (EclipseNode child : node.down()) {\n\t\t\tif (child.getKind() != Kind.ANNOTATION) continue;\n\t\t\tAnnotation annotation = (Annotation) child.get();\n\t\t\tfor (String bn : NONNULL_ANNOTATIONS) if (typeMatches(bn, node, annotation.type)) return true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic static boolean hasNonNullAnnotations(EclipseNode node, List<Annotation> anns) {\n\t\tif (anns == null) return false;\n\t\tfor (Annotation annotation : anns) {\n\t\t\tTypeReference typeRef = annotation.type;\n\t\t\tif (typeRef != null && typeRef.getTypeName() != null) {\n\t\t\t\tfor (String bn : NONNULL_ANNOTATIONS) if (typeMatches(bn, node, typeRef)) return true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tprivate static final Annotation[] EMPTY_ANNOTATIONS_ARRAY = new Annotation[0];\n\t\n\t/**\n\t * Searches the given field node for annotations and returns each one that is 'copyable' (either via configuration or from the base list).\n\t */\n\tpublic static Annotation[] findCopyableAnnotations(EclipseNode node) {\n\t\tAbstractVariableDeclaration avd = (AbstractVariableDeclaration) node.get();\n\t\tif (avd.annotations == null) return EMPTY_ANNOTATIONS_ARRAY;\n\t\tList<Annotation> result = new ArrayList<Annotation>();\n\t\tList<TypeName> configuredCopyable = node.getAst().readConfiguration(ConfigurationKeys.COPYABLE_ANNOTATIONS);\n\t\t\n\t\tfor (Annotation annotation : avd.annotations) {\n\t\t\tTypeReference typeRef = annotation.type;\n\t\t\tboolean match = false;\n\t\t\tif (typeRef != null && typeRef.getTypeName() != null) {\n\t\t\t\tfor (TypeName cn : configuredCopyable) if (cn != null && typeMatches(cn.toString(), node, typeRef)) {\n\t\t\t\t\tresult.add(annotation);\n\t\t\t\t\tmatch = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!match) for (String bn : BASE_COPYABLE_ANNOTATIONS) if (typeMatches(bn, node, typeRef)) {\n\t\t\t\t\tresult.add(annotation);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result.toArray(EMPTY_ANNOTATIONS_ARRAY);\n\t}\n\t\n\t/**\n\t * Searches the given field node for annotations that are specifically intentioned to be copied to the setter.\n\t */\n\tpublic static Annotation[] findCopyableToSetterAnnotations(EclipseNode node) {\n\t\treturn findAnnotationsInList(node, COPY_TO_SETTER_ANNOTATIONS);\n\t}\n\n\t/**\n\t * Searches the given field node for annotations that are specifically intentioned to be copied to the builder's singular method.\n\t */\n\tpublic static Annotation[] findCopyableToBuilderSingularSetterAnnotations(EclipseNode node) {\n\t\treturn findAnnotationsInList(node, COPY_TO_BUILDER_SINGULAR_SETTER_ANNOTATIONS);\n\t}\n\t\n\t/**\n\t * Searches the given field node for annotations that are in the given list, and returns those.\n\t */\n\tprivate static Annotation[] findAnnotationsInList(EclipseNode node, java.util.List<String> annotationsToFind) {\n\t\tAbstractVariableDeclaration avd = (AbstractVariableDeclaration) node.get();\n\t\tif (avd.annotations == null) return EMPTY_ANNOTATIONS_ARRAY;\n\t\tList<Annotation> result = new ArrayList<Annotation>();\n\t\t\n\t\tfor (Annotation annotation : avd.annotations) {\n\t\t\tTypeReference typeRef = annotation.type;\n\t\t\tif (typeRef != null && typeRef.getTypeName() != null) {\n\t\t\t\tfor (String bn : annotationsToFind) if (typeMatches(bn, node, typeRef)) {\n\t\t\t\t\tresult.add(annotation);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result.toArray(EMPTY_ANNOTATIONS_ARRAY);\n\t}\n\t\n\t/**\n\t * Checks if the provided annotation type is likely to be the intended type for the given annotation node.\n\t * \n\t * This is a guess, but a decent one.\n\t */\n\tpublic static boolean annotationTypeMatches(Class<? extends java.lang.annotation.Annotation> type, EclipseNode node) {\n\t\tif (node.getKind() != Kind.ANNOTATION) return false;\n\t\treturn typeMatches(type, node, ((Annotation) node.get()).type);\n\t}\n\t\n\t/**\n\t * Checks if the provided annotation type is likely to be the intended type for the given annotation node.\n\t * \n\t * This is a guess, but a decent one.\n\t */\n\tpublic static boolean annotationTypeMatches(String type, EclipseNode node) {\n\t\tif (node.getKind() != Kind.ANNOTATION) return false;\n\t\treturn typeMatches(type, node, ((Annotation) node.get()).type);\n\t}\n\t\n\tpublic static TypeReference cloneSelfType(EclipseNode context) {\n\t\treturn cloneSelfType(context, null);\n\t}\n\t\n\tpublic static TypeReference cloneSelfType(EclipseNode context, ASTNode source) {\n\t\tint pS = source == null ? 0 : source.sourceStart, pE = source == null ? 0 : source.sourceEnd;\n\t\tlong p = (long) pS << 32 | pE;\n\t\tEclipseNode type = context;\n\t\tTypeReference result = null;\n\t\twhile (type != null && type.getKind() != Kind.TYPE) type = type.up();\n\t\tif (type != null && type.get() instanceof TypeDeclaration) {\n\t\t\tTypeDeclaration typeDecl = (TypeDeclaration) type.get();\n\t\t\tif (typeDecl.typeParameters != null && typeDecl.typeParameters.length > 0) {\n\t\t\t\tTypeReference[] refs = new TypeReference[typeDecl.typeParameters.length];\n\t\t\t\tint idx = 0;\n\t\t\t\tfor (TypeParameter param : typeDecl.typeParameters) {\n\t\t\t\t\tTypeReference typeRef = new SingleTypeReference(param.name, (long)param.sourceStart << 32 | param.sourceEnd);\n\t\t\t\t\tif (source != null) setGeneratedBy(typeRef, source);\n\t\t\t\t\trefs[idx++] = typeRef;\n\t\t\t\t}\n\t\t\t\tresult = generateParameterizedTypeReference(type, refs, p);\n\t\t\t} else {\n\t\t\t\tresult = generateTypeReference(type, p);\n\t\t\t}\n\t\t}\n\t\tif (result != null && source != null) setGeneratedBy(result, source);\n\t\treturn result;\n\t}\n\t\n\tpublic static TypeReference generateParameterizedTypeReference(EclipseNode type, TypeReference[] typeParams, long p) {\n\t\tTypeDeclaration td = (TypeDeclaration) type.get();\n\t\tchar[][] tn = getQualifiedInnerName(type.up(), td.name);\n\t\tif (tn.length == 1) return new ParameterizedSingleTypeReference(tn[0], typeParams, 0, p);\n\t\tint tnLen = tn.length;\n\t\tlong[] ps = new long[tnLen];\n\t\tfor (int i = 0; i < tnLen; i++) ps[i] = p;\n\t\tTypeReference[][] rr = new TypeReference[tnLen][];\n\t\trr[tnLen - 1] = typeParams;\n\t\tboolean instance = (td.modifiers & MODIFIERS_INDICATING_STATIC) == 0;\n\t\tif (instance) fillOuterTypeParams(rr, tnLen - 2, type.up(), p);\n\t\treturn new ParameterizedQualifiedTypeReference(tn, rr, 0, ps);\n\t}\n\t\n\tpublic static TypeReference generateParameterizedTypeReference(EclipseNode parent, char[] name, boolean instance, TypeReference[] typeParams, long p) {\n\t\tchar[][] tn = getQualifiedInnerName(parent, name);\n\t\tif (tn.length == 1) return new ParameterizedSingleTypeReference(tn[0], typeParams, 0, p);\n\t\tint tnLen = tn.length;\n\t\tlong[] ps = new long[tnLen];\n\t\tfor (int i = 0; i < tnLen; i++) ps[i] = p;\n\t\tTypeReference[][] rr = new TypeReference[tnLen][];\n\t\trr[tnLen - 1] = typeParams;\n\t\tif (instance) fillOuterTypeParams(rr, tnLen - 2, parent, p);\n\t\treturn new ParameterizedQualifiedTypeReference(tn, rr, 0, ps);\n\t}\n\t\n\tprivate static final int MODIFIERS_INDICATING_STATIC = ClassFileConstants.AccInterface | ClassFileConstants.AccStatic | ClassFileConstants.AccEnum;\n\t\n\t/**\n\t * This class will add type params to fully qualified chain of type references for inner types, such as {@code GrandParent.Parent.Child}; this is needed only as long as the chain does not involve static.\n\t * \n\t * @return {@code true} if at least one parameterization is actually added, {@code false} otherwise.\n\t */\n\tprivate static boolean fillOuterTypeParams(TypeReference[][] rr, int idx, EclipseNode node, long p) {\n\t\tif (idx < 0 || node == null || !(node.get() instanceof TypeDeclaration)) return false;\n\t\tboolean filled = false;\n\t\tTypeDeclaration td = (TypeDeclaration) node.get();\n\t\tif (0 != (td.modifiers & (ClassFileConstants.AccInterface | ClassFileConstants.AccEnum))) {\n\t\t\t// any class defs inside an enum or interface are static, even if not marked as such.\n\t\t\treturn false;\n\t\t}\n\t\tTypeParameter[] tps = td.typeParameters;\n\t\tif (tps != null && tps.length > 0) {\n\t\t\tTypeReference[] trs = new TypeReference[tps.length];\n\t\t\tfor (int i = 0; i < tps.length; i++) {\n\t\t\t\ttrs[i] = new SingleTypeReference(tps[i].name, p);\n\t\t\t}\n\t\t\trr[idx] = trs;\n\t\t\tfilled = true;\n\t\t}\n\t\t\n\t\tif ((td.modifiers & MODIFIERS_INDICATING_STATIC) != 0) return filled; // Once we hit a static class, no further typeparams needed.\n\t\tboolean f2 = fillOuterTypeParams(rr, idx - 1, node.up(), p);\n\t\treturn f2 || filled;\n\t}\n\t\n\tpublic static NameReference generateNameReference(EclipseNode type, long p) {\n\t\tchar[][] tn = getQualifiedInnerName(type.up(), ((TypeDeclaration) type.get()).name);\n\t\tif (tn.length == 1) return new SingleNameReference(tn[0], p);\n\t\tint tnLen = tn.length;\n\t\tlong[] ps = new long[tnLen];\n\t\tfor (int i = 0; i < tnLen; i++) ps[i] = p;\n\t\tint ss = (int) (p >> 32);\n\t\tint se = (int) p;\n\t\treturn new QualifiedNameReference(tn, ps, ss, se);\n\t}\n\t\n\tpublic static NameReference generateNameReference(EclipseNode parent, char[] name, long p) {\n\t\tchar[][] tn = getQualifiedInnerName(parent, name);\n\t\tif (tn.length == 1) return new SingleNameReference(tn[0], p);\n\t\tint tnLen = tn.length;\n\t\tlong[] ps = new long[tnLen];\n\t\tfor (int i = 0; i < tnLen; i++) ps[i] = p;\n\t\tint ss = (int) (p >> 32);\n\t\tint se = (int) p;\n\t\treturn new QualifiedNameReference(tn, ps, ss, se);\n\t}\n\t\n\tpublic static TypeReference generateTypeReference(EclipseNode type, long p) {\n\t\tTypeDeclaration td = (TypeDeclaration) type.get();\n\t\tchar[][] tn = getQualifiedInnerName(type.up(), td.name);\n\t\tif (tn.length == 1) return new SingleTypeReference(tn[0], p);\n\t\tint tnLen = tn.length;\n\t\tlong[] ps = new long[tnLen];\n\t\tfor (int i = 0; i < tnLen; i++) ps[i] = p;\n\t\t\n\t\t\n\t\tboolean instance = (td.modifiers & MODIFIERS_INDICATING_STATIC) == 0 && type.up() != null && type.up().get() instanceof TypeDeclaration;\n\t\tif (instance) {\n\t\t\tTypeReference[][] trs = new TypeReference[tn.length][];\n\t\t\tboolean filled = fillOuterTypeParams(trs, trs.length - 2, type.up(), p);\n\t\t\tif (filled) return new ParameterizedQualifiedTypeReference(tn, trs, 0, ps);\n\t\t}\n\t\t\n\t\treturn new QualifiedTypeReference(tn, ps);\n\t}\n\t\n\tpublic static TypeReference generateTypeReference(EclipseNode parent, char[] name, boolean instance, long p) {\n\t\tchar[][] tn = getQualifiedInnerName(parent, name);\n\t\tif (tn.length == 1) return new SingleTypeReference(tn[0], p);\n\t\tint tnLen = tn.length;\n\t\tlong[] ps = new long[tnLen];\n\t\tfor (int i = 0; i < tnLen; i++) ps[i] = p;\n\t\t\n\t\tif (instance && parent != null && parent.get() instanceof TypeDeclaration) {\n\t\t\tTypeReference[][] trs = new TypeReference[tn.length][];\n\t\t\tif (fillOuterTypeParams(trs, tn.length - 2, parent, p)) return new ParameterizedQualifiedTypeReference(tn, trs, 0, ps);\n\t\t}\n\t\t\n\t\treturn new QualifiedTypeReference(tn, ps);\n\t}\n\t\n\t/**\n\t * Generate a chain of names for the enclosing classes.\n\t * \n\t * Given for example {@code class Outer { class Inner {} }} this would generate {@code char[][] { \"Outer\", \"Inner\" }}.\n\t * For method local and top level types, this generates a size-1 char[][] where the only char[] element is {@code name} itself.\n\t */\n\tpublic static char[][] getQualifiedInnerName(EclipseNode parent, char[] name) {\n\t\tint count = 0;\n\t\t\n\t\tEclipseNode n = parent;\n\t\twhile (n != null && n.getKind() == Kind.TYPE && n.get() instanceof TypeDeclaration) {\n\t\t\tTypeDeclaration td = (TypeDeclaration) n.get();\n\t\t\tif (td.name == null || td.name.length == 0) break;\n\t\t\tcount++;\n\t\t\tn = n.up();\n\t\t}\n\t\t\n\t\tif (count == 0) return new char[][] { name };\n\t\tchar[][] res = new char[count + 1][];\n\t\tres[count] = name;\n\t\t\n\t\tn = parent;\n\t\twhile (count > 0) {\n\t\t\tTypeDeclaration td = (TypeDeclaration) n.get();\n\t\t\tres[--count] = td.name;\n\t\t\tn = n.up();\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n\t\n\tprivate static final char[] OBJECT_SIG = \"Ljava/lang/Object;\".toCharArray();\n\t\n\tprivate static int compare(char[] a, char[] b) {\n\t\tif (a == null) return b == null ? 0 : -1;\n\t\tif (b == null) return +1;\n\t\tint len = Math.min(a.length, b.length);\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tif (a[i] < b[i]) return -1;\n\t\t\tif (a[i] > b[i]) return +1;\n\t\t}\n\t\treturn a.length < b.length ? -1 : a.length > b.length ? +1 : 0;\n\t}\n\t\n\tpublic static TypeReference makeType(TypeBinding binding, ASTNode pos, boolean allowCompound) {\n\t\tObject[] arr = null;\n\t\tif (binding.getClass() == EclipseReflectiveMembers.INTERSECTION_BINDING1) {\n\t\t\tarr = (Object[]) EclipseReflectiveMembers.reflect(EclipseReflectiveMembers.INTERSECTION_BINDING_TYPES1, binding);\n\t\t} else if (binding.getClass() == EclipseReflectiveMembers.INTERSECTION_BINDING2) {\n\t\t\tarr = (Object[]) EclipseReflectiveMembers.reflect(EclipseReflectiveMembers.INTERSECTION_BINDING_TYPES2, binding);\n\t\t}\n\t\t\n\t\tif (arr != null) {\n\t\t\t// Is there a class? Alphabetically lowest wins.\n\t\t\tTypeBinding winner = null;\n\t\t\tint winLevel = 0; // 100 = array, 50 = class, 20 = typevar, 15 = wildcard, 10 = interface, 1 = Object.\n\t\t\tfor (Object b : arr) {\n\t\t\t\tif (b instanceof TypeBinding) {\n\t\t\t\t\tTypeBinding tb = (TypeBinding) b;\n\t\t\t\t\tint level = 0;\n\t\t\t\t\tif (tb.isArrayType()) level = 100;\n\t\t\t\t\telse if (tb.isClass()) level = 50;\n\t\t\t\t\telse if (tb.isTypeVariable()) level = 20;\n\t\t\t\t\telse if (tb.isWildcard()) level = 15;\n\t\t\t\t\telse level = 10;\n\t\t\t\t\t\n\t\t\t\t\tif (level == 50 && compare(tb.signature(), OBJECT_SIG) == 0) level = 1;\n\t\t\t\t\t\n\t\t\t\t\tif (winLevel > level) continue;\n\t\t\t\t\tif (winLevel < level) {\n\t\t\t\t\t\twinner = tb;\n\t\t\t\t\t\twinLevel = level;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (compare(winner.signature(), tb.signature()) > 0) winner = tb;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbinding = winner;\n\t\t}\n\t\tint dims = binding.dimensions();\n\t\tbinding = binding.leafComponentType();\n\t\t\n\t\t// Primitives\n\t\t\n\t\tchar[] base = null;\n\t\t\n\t\tswitch (binding.id) {\n\t\tcase TypeIds.T_int:\n\t\t\tbase = TypeConstants.INT;\n\t\t\tbreak;\n\t\tcase TypeIds.T_long:\n\t\t\tbase = TypeConstants.LONG;\n\t\t\tbreak;\n\t\tcase TypeIds.T_short:\n\t\t\tbase = TypeConstants.SHORT;\n\t\t\tbreak;\n\t\tcase TypeIds.T_byte:\n\t\t\tbase = TypeConstants.BYTE;\n\t\t\tbreak;\n\t\tcase TypeIds.T_double:\n\t\t\tbase = TypeConstants.DOUBLE;\n\t\t\tbreak;\n\t\tcase TypeIds.T_float:\n\t\t\tbase = TypeConstants.FLOAT;\n\t\t\tbreak;\n\t\tcase TypeIds.T_boolean:\n\t\t\tbase = TypeConstants.BOOLEAN;\n\t\t\tbreak;\n\t\tcase TypeIds.T_char:\n\t\t\tbase = TypeConstants.CHAR;\n\t\t\tbreak;\n\t\tcase TypeIds.T_void:\n\t\t\tbase = TypeConstants.VOID;\n\t\t\tbreak;\n\t\tcase TypeIds.T_null:\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tif (base != null) {\n\t\t\tif (dims > 0) {\n\t\t\t\tTypeReference result = new ArrayTypeReference(base, dims, pos(pos));\n\t\t\t\tsetGeneratedBy(result, pos);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tTypeReference result = new SingleTypeReference(base, pos(pos));\n\t\t\tsetGeneratedBy(result, pos);\n\t\t\treturn result;\n\t\t}\n\t\t\n\t\tif (binding.isAnonymousType()) {\n\t\t\tReferenceBinding ref = (ReferenceBinding)binding;\n\t\t\tReferenceBinding[] supers = ref.superInterfaces();\n\t\t\tif (supers == null || supers.length == 0) supers = new ReferenceBinding[] {ref.superclass()};\n\t\t\tif (supers[0] == null) {\n\t\t\t\tTypeReference result = new QualifiedTypeReference(TypeConstants.JAVA_LANG_OBJECT, poss(pos, 3));\n\t\t\t\tsetGeneratedBy(result, pos);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\treturn makeType(supers[0], pos, false);\n\t\t}\n\t\t\n\t\tif (binding instanceof CaptureBinding) {\n\t\t\treturn makeType(((CaptureBinding)binding).wildcard, pos, allowCompound);\n\t\t}\n\t\t\n\t\tif (binding.isUnboundWildcard()) {\n\t\t\tif (!allowCompound) {\n\t\t\t\tTypeReference result = new QualifiedTypeReference(TypeConstants.JAVA_LANG_OBJECT, poss(pos, 3));\n\t\t\t\tsetGeneratedBy(result, pos);\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\tWildcard out = new Wildcard(Wildcard.UNBOUND);\n\t\t\t\tsetGeneratedBy(out, pos);\n\t\t\t\tout.sourceStart = pos.sourceStart;\n\t\t\t\tout.sourceEnd = pos.sourceEnd;\n\t\t\t\treturn out;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (binding.isWildcard()) {\n\t\t\tWildcardBinding wildcard = (WildcardBinding) binding;\n\t\t\tif (wildcard.boundKind == Wildcard.EXTENDS) {\n\t\t\t\tif (!allowCompound) {\n\t\t\t\t\tTypeBinding bound = wildcard.bound;\n\t\t\t\t\tboolean isObject = bound.id == TypeIds.T_JavaLangObject;\n\t\t\t\t\tTypeBinding[] otherBounds = wildcard.otherBounds;\n\t\t\t\t\tif (isObject && otherBounds != null && otherBounds.length > 0) {\n\t\t\t\t\t\treturn makeType(otherBounds[0], pos, false);\n\t\t\t\t\t} else return makeType(bound, pos, false);\n\t\t\t\t} else {\n\t\t\t\t\tWildcard out = new Wildcard(Wildcard.EXTENDS);\n\t\t\t\t\tsetGeneratedBy(out, pos);\n\t\t\t\t\tout.bound = makeType(wildcard.bound, pos, false);\n\t\t\t\t\tout.sourceStart = pos.sourceStart;\n\t\t\t\t\tout.sourceEnd = pos.sourceEnd;\n\t\t\t\t\treturn out;\n\t\t\t\t}\n\t\t\t} else if (allowCompound && wildcard.boundKind == Wildcard.SUPER) {\n\t\t\t\tWildcard out = new Wildcard(Wildcard.SUPER);\n\t\t\t\tsetGeneratedBy(out, pos);\n\t\t\t\tout.bound = makeType(wildcard.bound, pos, false);\n\t\t\t\tout.sourceStart = pos.sourceStart;\n\t\t\t\tout.sourceEnd = pos.sourceEnd;\n\t\t\t\treturn out;\n\t\t\t} else {\n\t\t\t\tTypeReference result = new QualifiedTypeReference(TypeConstants.JAVA_LANG_OBJECT, poss(pos, 3));\n\t\t\t\tsetGeneratedBy(result, pos);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Keep moving up via 'binding.enclosingType()' and gather generics from each binding. We stop after a local type, or a static type, or a top-level type.\n\t\t// Finally, add however many nullTypeArgument[] arrays as that are missing, inverse the list, toArray it, and use that as PTR's typeArgument argument.\n\t\t\n\t\tList<TypeReference[]> params = new ArrayList<TypeReference[]>();\n\t\t/* Calculate generics */\n\t\tif (!(binding instanceof RawTypeBinding)) {\n\t\t\tTypeBinding b = binding;\n\t\t\twhile (true) {\n\t\t\t\tboolean isFinalStop = b.isLocalType() || !b.isMemberType() || b.enclosingType() == null;\n\t\t\t\t\n\t\t\t\tTypeReference[] tyParams = null;\n\t\t\t\tif (b instanceof ParameterizedTypeBinding) {\n\t\t\t\t\tParameterizedTypeBinding paramized = (ParameterizedTypeBinding) b;\n\t\t\t\t\tif (paramized.arguments != null) {\n\t\t\t\t\t\ttyParams = new TypeReference[paramized.arguments.length];\n\t\t\t\t\t\tfor (int i = 0; i < tyParams.length; i++) {\n\t\t\t\t\t\t\ttyParams[i] = makeType(paramized.arguments[i], pos, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tparams.add(tyParams);\n\t\t\t\tif (isFinalStop) break;\n\t\t\t\tb = b.enclosingType();\n\t\t\t}\n\t\t}\n\t\t\n\t\tchar[][] parts;\n\t\t\n\t\tif (binding.isTypeVariable()) {\n\t\t\tparts = new char[][] { binding.shortReadableName() };\n\t\t} else if (binding.isLocalType()) {\n\t\t\tparts = new char[][] { binding.sourceName() };\n\t\t} else {\n\t\t\tString[] pkg = new String(binding.qualifiedPackageName()).split(\"\\\\.\");\n\t\t\tString[] name = new String(binding.qualifiedSourceName()).split(\"\\\\.\");\n\t\t\tif (pkg.length == 1 && pkg[0].isEmpty()) pkg = new String[0];\n\t\t\tparts = new char[pkg.length + name.length][];\n\t\t\tint ptr;\n\t\t\tfor (ptr = 0; ptr < pkg.length; ptr++) parts[ptr] = pkg[ptr].toCharArray();\n\t\t\tfor (; ptr < pkg.length + name.length; ptr++) parts[ptr] = name[ptr - pkg.length].toCharArray();\n\t\t}\n\t\t\n\t\twhile (params.size() < parts.length) params.add(null);\n\t\tCollections.reverse(params);\n\t\t\n\t\tboolean isParamized = false;\n\t\t\n\t\tfor (TypeReference[] tyParams : params) {\n\t\t\tif (tyParams != null) {\n\t\t\t\tisParamized = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (isParamized) {\n\t\t\tif (parts.length > 1) {\n\t\t\t\tTypeReference[][] typeArguments = params.toArray(new TypeReference[0][]);\n\t\t\t\tTypeReference result = new ParameterizedQualifiedTypeReference(parts, typeArguments, dims, poss(pos, parts.length));\n\t\t\t\tsetGeneratedBy(result, pos);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tTypeReference result = new ParameterizedSingleTypeReference(parts[0], params.get(0), dims, pos(pos));\n\t\t\tsetGeneratedBy(result, pos);\n\t\t\treturn result;\n\t\t}\n\t\t\n\t\tif (dims > 0) {\n\t\t\tif (parts.length > 1) {\n\t\t\t\tTypeReference result = new ArrayQualifiedTypeReference(parts, dims, poss(pos, parts.length));\n\t\t\t\tsetGeneratedBy(result, pos);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tTypeReference result = new ArrayTypeReference(parts[0], dims, pos(pos));\n\t\t\tsetGeneratedBy(result, pos);\n\t\t\treturn result;\n\t\t}\n\t\t\n\t\tif (parts.length > 1) {\n\t\t\tTypeReference result = new QualifiedTypeReference(parts, poss(pos, parts.length));\n\t\t\tsetGeneratedBy(result, pos);\n\t\t\treturn result;\n\t\t}\n\t\tTypeReference result = new SingleTypeReference(parts[0], pos(pos));\n\t\tsetGeneratedBy(result, pos);\n\t\treturn result;\n\t}\n\t\n\t/**\n\t * Provides AnnotationValues with the data it needs to do its thing.\n\t */\n\tpublic static <A extends java.lang.annotation.Annotation> AnnotationValues<A>\n\t\tcreateAnnotation(Class<A> type, final EclipseNode annotationNode) {\n\t\t\n\t\tfinal Annotation annotation = (Annotation) annotationNode.get();\n\t\tMap<String, AnnotationValue> values = new HashMap<String, AnnotationValue>();\n\t\t\n\t\tMemberValuePair[] memberValuePairs = annotation.memberValuePairs();\n\t\t\n\t\tif (memberValuePairs != null) for (final MemberValuePair pair : memberValuePairs) {\n\t\t\tList<String> raws = new ArrayList<String>();\n\t\t\tList<Object> expressionValues = new ArrayList<Object>();\n\t\t\tList<Object> guesses = new ArrayList<Object>();\n\t\t\tExpression[] expressions = null;\n\t\t\t\n\t\t\tchar[] n = pair.name;\n\t\t\tString mName = (n == null || n.length == 0) ? \"value\" : new String(pair.name);\n\t\t\tfinal Expression rhs = pair.value;\n\t\t\tif (rhs instanceof ArrayInitializer) {\n\t\t\t\texpressions = ((ArrayInitializer) rhs).expressions;\n\t\t\t} else if (rhs != null) {\n\t\t\t\texpressions = new Expression[] { rhs };\n\t\t\t}\n\t\t\tif (expressions != null) for (Expression ex : expressions) {\n\t\t\t\tStringBuffer sb = new StringBuffer();\n\t\t\t\tex.print(0, sb);\n\t\t\t\traws.add(sb.toString());\n\t\t\t\texpressionValues.add(ex);\n\t\t\t\tguesses.add(calculateValue(ex));\n\t\t\t}\n\t\t\t\n\t\t\tfinal Expression[] exprs = expressions;\n\t\t\tvalues.put(mName, new AnnotationValue(annotationNode, raws, expressionValues, guesses, true) {\n\t\t\t\t@Override public void setError(String message, int valueIdx) {\n\t\t\t\t\tExpression ex;\n\t\t\t\t\tif (valueIdx == -1) ex = rhs;\n\t\t\t\t\telse ex = exprs != null ? exprs[valueIdx] : null;\n\t\t\t\t\t\n\t\t\t\t\tif (ex == null) ex = annotation;\n\t\t\t\t\t\n\t\t\t\t\tint sourceStart = ex.sourceStart;\n\t\t\t\t\tint sourceEnd = ex.sourceEnd;\n\t\t\t\t\t\n\t\t\t\t\tannotationNode.addError(message, sourceStart, sourceEnd);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t@Override public void setWarning(String message, int valueIdx) {\n\t\t\t\t\tExpression ex;\n\t\t\t\t\tif (valueIdx == -1) ex = rhs;\n\t\t\t\t\telse ex = exprs != null ? exprs[valueIdx] : null;\n\t\t\t\t\t\n\t\t\t\t\tif (ex == null) ex = annotation;\n\t\t\t\t\t\n\t\t\t\t\tint sourceStart = ex.sourceStart;\n\t\t\t\t\tint sourceEnd = ex.sourceEnd;\n\t\t\t\t\t\n\t\t\t\t\tannotationNode.addWarning(message, sourceStart, sourceEnd);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\t\n\t\tfor (Method m : type.getDeclaredMethods()) {\n\t\t\tif (!Modifier.isPublic(m.getModifiers())) continue;\n\t\t\tString name = m.getName();\n\t\t\tif (!values.containsKey(name)) {\n\t\t\t\tvalues.put(name, new AnnotationValue(annotationNode, new ArrayList<String>(), new ArrayList<Object>(), new ArrayList<Object>(), false) {\n\t\t\t\t\t@Override public void setError(String message, int valueIdx) {\n\t\t\t\t\t\tannotationNode.addError(message);\n\t\t\t\t\t}\n\t\t\t\t\t@Override public void setWarning(String message, int valueIdx) {\n\t\t\t\t\t\tannotationNode.addWarning(message);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn new AnnotationValues<A>(type, values, annotationNode);\n\t}\n\t\n\t/**\n\t * Turns an {@code AccessLevel} instance into the flag bit used by eclipse.\n\t */\n\tpublic static int toEclipseModifier(AccessLevel value) {\n\t\tswitch (value) {\n\t\tcase MODULE:\n\t\tcase PACKAGE:\n\t\t\treturn 0;\n\t\tdefault:\n\t\tcase PUBLIC:\n\t\t\treturn ClassFileConstants.AccPublic;\n\t\tcase PROTECTED:\n\t\t\treturn ClassFileConstants.AccProtected;\n\t\tcase NONE:\n\t\tcase PRIVATE:\n\t\t\treturn ClassFileConstants.AccPrivate;\n\t\t}\n\t}\n\t\n\tprivate static class GetterMethod {\n\t\tprivate final char[] name;\n\t\tprivate final TypeReference type;\n\t\t\n\t\tGetterMethod(char[] name, TypeReference type) {\n\t\t\tthis.name = name;\n\t\t\tthis.type = type;\n\t\t}\n\t}\n\t\n\tstatic void registerCreatedLazyGetter(FieldDeclaration field, char[] methodName, TypeReference returnType) {\n\t\tif (isBoolean(returnType)) {\n\t\t\tFieldDeclaration_booleanLazyGetter.set(field, true);\n\t\t}\n\t}\n\t\n\tpublic static boolean isBoolean(TypeReference typeReference) {\n\t\treturn nameEquals(typeReference.getTypeName(), \"boolean\") && typeReference.dimensions() == 0;\n\t}\n\t\n\tprivate static GetterMethod findGetter(EclipseNode field) {\n\t\tFieldDeclaration fieldDeclaration = (FieldDeclaration) field.get();\n\t\tboolean forceBool = FieldDeclaration_booleanLazyGetter.get(fieldDeclaration);\n\t\tTypeReference fieldType = fieldDeclaration.type;\n\t\tboolean isBoolean = forceBool || isBoolean(fieldType);\n\t\t\n\t\tEclipseNode typeNode = field.up();\n\t\tfor (String potentialGetterName : toAllGetterNames(field, isBoolean)) {\n\t\t\tfor (EclipseNode potentialGetter : typeNode.down()) {\n\t\t\t\tif (potentialGetter.getKind() != Kind.METHOD) continue;\n\t\t\t\tif (!(potentialGetter.get() instanceof MethodDeclaration)) continue;\n\t\t\t\tMethodDeclaration method = (MethodDeclaration) potentialGetter.get();\n\t\t\t\tif (!potentialGetterName.equalsIgnoreCase(new String(method.selector))) continue;\n\t\t\t\t/** static getX() methods don't count. */\n\t\t\t\tif ((method.modifiers & ClassFileConstants.AccStatic) != 0) continue;\n\t\t\t\t/** Nor do getters with a non-empty parameter list. */\n\t\t\t\tif (method.arguments != null && method.arguments.length > 0) continue;\n\t\t\t\treturn new GetterMethod(method.selector, method.returnType);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Check if the field has a @Getter annotation.\n\t\t\n\t\tboolean hasGetterAnnotation = false;\n\t\t\n\t\tfor (EclipseNode child : field.down()) {\n\t\t\tif (child.getKind() == Kind.ANNOTATION && annotationTypeMatches(Getter.class, child)) {\n\t\t\t\tAnnotationValues<Getter> ann = createAnnotation(Getter.class, child);\n\t\t\t\tif (ann.getInstance().value() == AccessLevel.NONE) return null;   //Definitely WONT have a getter.\n\t\t\t\thasGetterAnnotation = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Check if the class has a @Getter annotation.\n\t\t\n\t\tif (!hasGetterAnnotation && HandleGetter.fieldQualifiesForGetterGeneration(field)) {\n\t\t\t//Check if the class has @Getter or @Data annotation.\n\t\t\t\n\t\t\tEclipseNode containingType = field.up();\n\t\t\tif (containingType != null) for (EclipseNode child : containingType.down()) {\n\t\t\t\tif (child.getKind() == Kind.ANNOTATION && annotationTypeMatches(Data.class, child)) hasGetterAnnotation = true;\n\t\t\t\tif (child.getKind() == Kind.ANNOTATION && annotationTypeMatches(Getter.class, child)) {\n\t\t\t\t\tAnnotationValues<Getter> ann = createAnnotation(Getter.class, child);\n\t\t\t\t\tif (ann.getInstance().value() == AccessLevel.NONE) return null;   //Definitely WONT have a getter.\n\t\t\t\t\thasGetterAnnotation = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (hasGetterAnnotation) {\n\t\t\tString getterName = toGetterName(field, isBoolean);\n\t\t\tif (getterName == null) return null;\n\t\t\treturn new GetterMethod(getterName.toCharArray(), fieldType);\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\t\n\tstatic boolean lookForGetter(EclipseNode field, FieldAccess fieldAccess) {\n\t\tif (fieldAccess == FieldAccess.GETTER) return true;\n\t\tif (fieldAccess == FieldAccess.ALWAYS_FIELD) return false;\n\t\t\n\t\t// If @Getter(lazy = true) is used, then using it is mandatory.\n\t\tfor (EclipseNode child : field.down()) {\n\t\t\tif (child.getKind() != Kind.ANNOTATION) continue;\n\t\t\tif (annotationTypeMatches(Getter.class, child)) {\n\t\t\t\tAnnotationValues<Getter> ann = createAnnotation(Getter.class, child);\n\t\t\t\tif (ann.getInstance().lazy()) return true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tstatic TypeReference getFieldType(EclipseNode field, FieldAccess fieldAccess) {\n\t\tif (field.get() instanceof MethodDeclaration) return ((MethodDeclaration) field.get()).returnType;\n\t\t\n\t\tboolean lookForGetter = lookForGetter(field, fieldAccess);\n\t\t\n\t\tGetterMethod getter = lookForGetter ? findGetter(field) : null;\n\t\tif (getter == null) {\n\t\t\treturn ((FieldDeclaration) field.get()).type;\n\t\t}\n\t\t\n\t\treturn getter.type;\n\t}\n\t\n\tstatic Expression createFieldAccessor(EclipseNode field, FieldAccess fieldAccess, ASTNode source) {\n\t\tint pS = source == null ? 0 : source.sourceStart, pE = source == null ? 0 : source.sourceEnd;\n\t\tlong p = (long) pS << 32 | pE;\n\t\t\n\t\tboolean lookForGetter = lookForGetter(field, fieldAccess);\n\t\t\n\t\tGetterMethod getter = lookForGetter ? findGetter(field) : null;\n\t\t\n\t\tif (getter == null) {\n\t\t\tFieldDeclaration fieldDecl = (FieldDeclaration)field.get();\n\t\t\tFieldReference ref = new FieldReference(fieldDecl.name, p);\n\t\t\tif ((fieldDecl.modifiers & ClassFileConstants.AccStatic) != 0) {\n\t\t\t\tEclipseNode containerNode = field.up();\n\t\t\t\tif (containerNode != null && containerNode.get() instanceof TypeDeclaration) {\n\t\t\t\t\tref.receiver = new SingleNameReference(((TypeDeclaration)containerNode.get()).name, p);\n\t\t\t\t} else {\n\t\t\t\t\tExpression smallRef = new FieldReference(field.getName().toCharArray(), p);\n\t\t\t\t\tif (source != null) setGeneratedBy(smallRef, source);\n\t\t\t\t\treturn smallRef;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tref.receiver = new ThisReference(pS, pE);\n\t\t\t}\n\t\t\t\n\t\t\tif (source != null) {\n\t\t\t\tsetGeneratedBy(ref, source);\n\t\t\t\tsetGeneratedBy(ref.receiver, source);\n\t\t\t}\n\t\t\treturn ref;\n\t\t}\n\t\t\n\t\tMessageSend call = new MessageSend();\n\t\tsetGeneratedBy(call, source);\n\t\tcall.sourceStart = pS; call.statementEnd = call.sourceEnd = pE;\n\t\tcall.receiver = new ThisReference(pS, pE);\n\t\tsetGeneratedBy(call.receiver, source);\n\t\tcall.selector = getter.name;\n\t\treturn call;\n\t}\n\t\n\tstatic Expression createFieldAccessor(EclipseNode field, FieldAccess fieldAccess, ASTNode source, char[] receiver) {\n\t\tint pS = source.sourceStart, pE = source.sourceEnd;\n\t\tlong p = (long)pS << 32 | pE;\n\t\t\n\t\tboolean lookForGetter = lookForGetter(field, fieldAccess);\n\t\t\n\t\tGetterMethod getter = lookForGetter ? findGetter(field) : null;\n\t\t\n\t\tif (getter == null) {\n\t\t\tNameReference ref;\n\t\t\t\n\t\t\tchar[][] tokens = new char[2][];\n\t\t\ttokens[0] = receiver;\n\t\t\ttokens[1] = field.getName().toCharArray();\n\t\t\tlong[] poss = {p, p};\n\t\t\t\n\t\t\tref = new QualifiedNameReference(tokens, poss, pS, pE);\n\t\t\tsetGeneratedBy(ref, source);\n\t\t\treturn ref;\n\t\t}\n\t\t\n\t\tMessageSend call = new MessageSend();\n\t\tsetGeneratedBy(call, source);\n\t\tcall.sourceStart = pS; call.statementEnd = call.sourceEnd = pE;\n\t\tcall.receiver = new SingleNameReference(receiver, p);\n\t\tsetGeneratedBy(call.receiver, source);\n\t\tcall.selector = getter.name;\n\t\treturn call;\n\t}\n\t\n\tstatic Expression createMethodAccessor(EclipseNode method, ASTNode source) {\n\t\tint pS = source == null ? 0 : source.sourceStart, pE = source == null ? 0 : source.sourceEnd;\n\t\tlong p = (long) pS << 32 | pE;\n\t\t\n\t\tMethodDeclaration methodDecl = (MethodDeclaration) method.get();\n\t\tMessageSend call = new MessageSend();\n\t\tsetGeneratedBy(call, source);\n\t\tcall.sourceStart = pS; call.statementEnd = call.sourceEnd = pE;\n\t\tif ((methodDecl.modifiers & ClassFileConstants.AccStatic) == 0) {\n\t\t\tcall.receiver = new ThisReference(pS, pE);\n\t\t\tsetGeneratedBy(call.receiver, source);\n\t\t} else {\n\t\t\tEclipseNode containerNode = method.up();\n\t\t\tif (containerNode != null && containerNode.get() instanceof TypeDeclaration) {\n\t\t\t\tcall.receiver = new SingleNameReference(((TypeDeclaration) containerNode.get()).name, p);\n\t\t\t\tsetGeneratedBy(call.receiver, source);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcall.selector = methodDecl.selector;\n\t\treturn call;\n\t}\n\t\n\tstatic Expression createMethodAccessor(EclipseNode method, ASTNode source, char[] receiver) {\n\t\tint pS = source == null ? 0 : source.sourceStart, pE = source == null ? 0 : source.sourceEnd;\n\t\tlong p = (long) pS << 32 | pE;\n\t\t\n\t\tMethodDeclaration methodDecl = (MethodDeclaration) method.get();\n\t\tMessageSend call = new MessageSend();\n\t\tsetGeneratedBy(call, source);\n\t\tcall.sourceStart = pS; call.statementEnd = call.sourceEnd = pE;\n\t\tcall.receiver = new SingleNameReference(receiver, p);\n\t\tsetGeneratedBy(call.receiver, source);\n\t\tcall.selector = methodDecl.selector;\n\t\treturn call;\n\t}\n\t\n\t/** Serves as return value for the methods that check for the existence of fields and methods. */\n\tpublic enum MemberExistsResult {\n\t\tNOT_EXISTS, EXISTS_BY_LOMBOK, EXISTS_BY_USER;\n\t}\n\t\n\t/**\n\t * Translates the given field into all possible getter names.\n\t * Convenient wrapper around {@link HandlerUtil#toAllGetterNames(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static List<String> toAllGetterNames(EclipseNode field, boolean isBoolean) {\n\t\treturn HandlerUtil.toAllGetterNames(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean);\n\t}\n\t\n\t/**\n\t * @return the likely getter name for the stated field. (e.g. private boolean foo; to isFoo).\n\t * \n\t * Convenient wrapper around {@link HandlerUtil#toGetterName(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static String toGetterName(EclipseNode field, boolean isBoolean) {\n\t\treturn HandlerUtil.toGetterName(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean);\n\t}\n\t\n\t/**\n\t * Translates the given field into all possible setter names.\n\t * Convenient wrapper around {@link HandlerUtil#toAllSetterNames(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static java.util.List<String> toAllSetterNames(EclipseNode field, boolean isBoolean) {\n\t\treturn HandlerUtil.toAllSetterNames(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean);\n\t}\n\t\n\t/**\n\t * @return the likely setter name for the stated field. (e.g. private boolean foo; to setFoo).\n\t * \n\t * Convenient wrapper around {@link HandlerUtil#toSetterName(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static String toSetterName(EclipseNode field, boolean isBoolean) {\n\t\treturn HandlerUtil.toSetterName(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean);\n\t}\n\t\n\t/**\n\t * Translates the given field into all possible with names.\n\t * Convenient wrapper around {@link HandlerUtil#toAllWithNames(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static java.util.List<String> toAllWithNames(EclipseNode field, boolean isBoolean) {\n\t\treturn HandlerUtil.toAllWithNames(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean);\n\t}\n\t\n\t/**\n\t * Translates the given field into all possible withBy names.\n\t * Convenient wrapper around {@link HandlerUtil#toAllWithByNames(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static java.util.List<String> toAllWithByNames(EclipseNode field, boolean isBoolean) {\n\t\treturn HandlerUtil.toAllWithByNames(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean);\n\t}\n\t\n\t/**\n\t * @return the likely with name for the stated field. (e.g. private boolean foo; to withFoo).\n\t * \n\t * Convenient wrapper around {@link HandlerUtil#toWithName(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static String toWithName(EclipseNode field, boolean isBoolean) {\n\t\treturn HandlerUtil.toWithName(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean);\n\t}\n\t\n\t/**\n\t * @return the likely withBy name for the stated field. (e.g. private boolean foo; to withFooBy).\n\t * \n\t * Convenient wrapper around {@link HandlerUtil#toWithByName(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static String toWithByName(EclipseNode field, boolean isBoolean) {\n\t\treturn HandlerUtil.toWithByName(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean);\n\t}\n\t\n\t/**\n\t * When generating a setter, the setter either returns void (beanspec) or Self (fluent).\n\t * This method scans for the {@code Accessors} annotation and associated config properties to figure that out.\n\t */\n\tpublic static boolean shouldReturnThis(EclipseNode field) {\n\t\tif ((((FieldDeclaration) field.get()).modifiers & ClassFileConstants.AccStatic) != 0) return false;\n\t\tAnnotationValues<Accessors> accessors = EclipseHandlerUtil.getAccessorsForField(field);\n\t\treturn shouldReturnThis0(accessors, field.getAst());\n\t}\n\t\n\t/**\n\t * Checks if the field should be included in operations that work on 'all' fields:\n\t *    If the field is static, or starts with a '$', or is actually an enum constant, 'false' is returned, indicating you should skip it.\n\t */\n\tpublic static boolean filterField(FieldDeclaration declaration) {\n\t\treturn filterField(declaration, true);\n\t}\n\t\n\tpublic static boolean filterField(FieldDeclaration declaration, boolean skipStatic) {\n\t\t// Skip the fake fields that represent enum constants.\n\t\tif (declaration.initialization instanceof AllocationExpression &&\n\t\t\t\t((AllocationExpression) declaration.initialization).enumConstant != null) return false;\n\t\t\n\t\tif (declaration.type == null) return false;\n\t\t\n\t\t// Skip fields that start with $\n\t\tif (declaration.name.length > 0 && declaration.name[0] == '$') return false;\n\t\t\n\t\t// Skip static fields.\n\t\tif (skipStatic && (declaration.modifiers & ClassFileConstants.AccStatic) != 0) return false;\n\t\t\n\t\treturn true;\n\t}\n\t\n\tpublic static char[] removePrefixFromField(EclipseNode field) {\n\t\tList<String> prefixes = null;\n\t\tfor (EclipseNode node : field.down()) {\n\t\t\tif (annotationTypeMatches(Accessors.class, node)) {\n\t\t\t\tAnnotationValues<Accessors> ann = createAnnotation(Accessors.class, node);\n\t\t\t\tif (ann.isExplicit(\"prefix\")) prefixes = Arrays.asList(ann.getInstance().prefix());\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (prefixes == null) {\n\t\t\tEclipseNode current = field.up();\n\t\t\touter:\n\t\t\twhile (current != null) {\n\t\t\t\tfor (EclipseNode node : current.down()) {\n\t\t\t\t\tif (annotationTypeMatches(Accessors.class, node)) {\n\t\t\t\t\t\tAnnotationValues<Accessors> ann = createAnnotation(Accessors.class, node);\n\t\t\t\t\t\tif (ann.isExplicit(\"prefix\")) prefixes = Arrays.asList(ann.getInstance().prefix());\n\t\t\t\t\t\tbreak outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcurrent = current.up();\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (prefixes == null) prefixes = field.getAst().readConfiguration(ConfigurationKeys.ACCESSORS_PREFIX);\n\t\tif (!prefixes.isEmpty()) {\n\t\t\tCharSequence newName = removePrefix(field.getName(), prefixes);\n\t\t\tif (newName != null) return newName.toString().toCharArray();\n\t\t}\n\t\t\n\t\treturn ((FieldDeclaration) field.get()).name;\n\t}\n\t\n\tpublic static AnnotationValues<Accessors> getAccessorsForField(EclipseNode field) {\n\t\tfor (EclipseNode node : field.down()) {\n\t\t\tif (annotationTypeMatches(Accessors.class, node)) {\n\t\t\t\treturn createAnnotation(Accessors.class, node);\n\t\t\t}\n\t\t}\n\t\t\n\t\tEclipseNode current = field.up();\n\t\twhile (current != null) {\n\t\t\tfor (EclipseNode node : current.down()) {\n\t\t\t\tif (annotationTypeMatches(Accessors.class, node)) {\n\t\t\t\t\treturn createAnnotation(Accessors.class, node);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurrent = current.up();\n\t\t}\n\t\t\n\t\treturn AnnotationValues.of(Accessors.class, field);\n\t}\n\n\tpublic static EclipseNode upToTypeNode(EclipseNode node) {\n\t\tif (node == null) throw new NullPointerException(\"node\");\n\t\twhile (node != null && !(node.get() instanceof TypeDeclaration)) node = node.up();\n\t\treturn node;\n\t}\n\t\n\t/**\n\t * Checks if there is a field with the provided name.\n\t * \n\t * @param fieldName the field name to check for.\n\t * @param node Any node that represents the Type (TypeDeclaration) to look in, or any child node thereof.\n\t */\n\tpublic static MemberExistsResult fieldExists(String fieldName, EclipseNode node) {\n\t\tnode = upToTypeNode(node);\n\t\tchar[] fieldNameChars = null;\n\t\tif (node != null && node.get() instanceof TypeDeclaration) {\n\t\t\tTypeDeclaration typeDecl = (TypeDeclaration) node.get();\n\t\t\tif (typeDecl.fields != null) for (FieldDeclaration def : typeDecl.fields) {\n\t\t\t\tchar[] fName = def.name;\n\t\t\t\tif (fName == null) continue;\n\t\t\t\tif (fieldNameChars == null) fieldNameChars = fieldName.toCharArray();\n\t\t\t\tif (Arrays.equals(fName, fieldNameChars)) {\n\t\t\t\t\treturn getGeneratedBy(def) == null ? MemberExistsResult.EXISTS_BY_USER : MemberExistsResult.EXISTS_BY_LOMBOK;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn MemberExistsResult.NOT_EXISTS;\n\t}\n\t\n\t/**\n\t * Wrapper for {@link #methodExists(String, EclipseNode, boolean, int)} with {@code caseSensitive} = {@code true}.\n\t */\n\tpublic static MemberExistsResult methodExists(String methodName, EclipseNode node, int params) {\n\t\treturn methodExists(methodName, node, true, params);\n\t}\n\t\n\t/**\n\t * Checks if there is a method with the provided name. In case of multiple methods (overloading), only\n\t * the first method decides if EXISTS_BY_USER or EXISTS_BY_LOMBOK is returned.\n\t * \n\t * @param methodName the method name to check for.\n\t * @param node Any node that represents the Type (TypeDeclaration) to look in, or any child node thereof.\n\t * @param caseSensitive If the search should be case sensitive.\n\t * @param params The number of parameters the method should have; varargs count as 0-*. Set to -1 to find any method with the appropriate name regardless of parameter count.\n\t */\n\tpublic static MemberExistsResult methodExists(String methodName, EclipseNode node, boolean caseSensitive, int params) {\n\t\twhile (node != null && !(node.get() instanceof TypeDeclaration)) {\n\t\t\tnode = node.up();\n\t\t}\n\t\t\n\t\tif (node != null && node.get() instanceof TypeDeclaration) {\n\t\t\tTypeDeclaration typeDecl = (TypeDeclaration)node.get();\n\t\t\tif (typeDecl.methods != null) top: for (AbstractMethodDeclaration def : typeDecl.methods) {\n\t\t\t\tif (def instanceof MethodDeclaration) {\n\t\t\t\t\tchar[] mName = def.selector;\n\t\t\t\t\tif (mName == null) continue;\n\t\t\t\t\tboolean nameEquals = caseSensitive ? methodName.equals(new String(mName)) : methodName.equalsIgnoreCase(new String(mName));\n\t\t\t\t\tif (nameEquals) {\n\t\t\t\t\t\tif (params > -1) {\n\t\t\t\t\t\t\tint minArgs = 0;\n\t\t\t\t\t\t\tint maxArgs = 0;\n\t\t\t\t\t\t\tif (def.arguments != null && def.arguments.length > 0) {\n\t\t\t\t\t\t\t\tminArgs = def.arguments.length;\n\t\t\t\t\t\t\t\tif ((def.arguments[def.arguments.length - 1].type.bits & ASTNode.IsVarArgs) != 0) {\n\t\t\t\t\t\t\t\t\tminArgs--;\n\t\t\t\t\t\t\t\t\tmaxArgs = Integer.MAX_VALUE;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tmaxArgs = minArgs;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (params < minArgs || params > maxArgs) continue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (isTolerate(node, def)) continue top;\n\t\t\t\t\t\t\n\t\t\t\t\t\treturn getGeneratedBy(def) == null ? MemberExistsResult.EXISTS_BY_USER : MemberExistsResult.EXISTS_BY_LOMBOK;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn MemberExistsResult.NOT_EXISTS;\n\t}\n\t\n\tpublic static boolean isTolerate(EclipseNode node, AbstractMethodDeclaration def) {\n\t\tif (def.annotations != null) for (Annotation anno : def.annotations) {\n\t\t\tif (typeMatches(Tolerate.class, node, anno.type)) return true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Checks if there is a (non-default) constructor. In case of multiple constructors (overloading), only\n\t * the first constructor decides if EXISTS_BY_USER or EXISTS_BY_LOMBOK is returned.\n\t * \n\t * @param node Any node that represents the Type (TypeDeclaration) to look in, or any child node thereof.\n\t */\n\tpublic static MemberExistsResult constructorExists(EclipseNode node) {\n\t\tnode = upToTypeNode(node);\n\t\tif (node != null && node.get() instanceof TypeDeclaration) {\n\t\t\tTypeDeclaration typeDecl = (TypeDeclaration) node.get();\n\t\t\tif (typeDecl.methods != null) for (AbstractMethodDeclaration def : typeDecl.methods) {\n\t\t\t\tif (!(def instanceof ConstructorDeclaration)) continue;\n\t\t\t\tif ((def.bits & ASTNode.IsDefaultConstructor) != 0) continue;\n\t\t\t\tif (isTolerate(node, def)) continue;\n\t\t\t\treturn getGeneratedBy(def) == null ? MemberExistsResult.EXISTS_BY_USER : MemberExistsResult.EXISTS_BY_LOMBOK;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn MemberExistsResult.NOT_EXISTS;\n\t}\n\t\n\t/**\n\t * Inserts a field into an existing type. The type must represent a {@code TypeDeclaration}.\n\t * The field carries the &#64;{@link SuppressWarnings}(\"all\") annotation.\n\t */\n\tpublic static EclipseNode injectFieldAndMarkGenerated(EclipseNode type, FieldDeclaration field) {\n\t\tfield.annotations = addSuppressWarningsAll(type, field, field.annotations);\n\t\tfield.annotations = addGenerated(type, field, field.annotations);\n\t\treturn injectField(type, field);\n\t}\n\t\n\t/**\n\t * Inserts a field into an existing type. The type must represent a {@code TypeDeclaration}.\n\t */\n\tpublic static EclipseNode injectField(EclipseNode type, FieldDeclaration field) {\n\t\tTypeDeclaration parent = (TypeDeclaration) type.get();\n\t\t\n\t\tif (parent.fields == null) {\n\t\t\tparent.fields = new FieldDeclaration[1];\n\t\t\tparent.fields[0] = field;\n\t\t} else {\n\t\t\tint size = parent.fields.length;\n\t\t\tFieldDeclaration[] newArray = new FieldDeclaration[size + 1];\n\t\t\tSystem.arraycopy(parent.fields, 0, newArray, 0, size);\n\t\t\tint index = 0;\n\t\t\tfor (; index < size; index++) {\n\t\t\t\tFieldDeclaration f = newArray[index];\n\t\t\t\tif (isEnumConstant(f) || isGenerated(f)) continue;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tSystem.arraycopy(newArray, index, newArray, index + 1, size - index);\n\t\t\tnewArray[index] = field;\n\t\t\tparent.fields = newArray;\n\t\t}\n\t\t\n\t\tif (isEnumConstant(field) || (field.modifiers & Modifier.STATIC) != 0) {\n\t\t\tif (!hasClinit(parent)) {\n\t\t\t\tparent.addClinit();\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn type.add(field, Kind.FIELD);\n\t}\n\t\n\tpublic static boolean isEnumConstant(final FieldDeclaration field) {\n\t\treturn ((field.initialization instanceof AllocationExpression) && (((AllocationExpression) field.initialization).enumConstant == field));\n\t}\n\t\n\t/**\n\t * Inserts a method into an existing type. The type must represent a {@code TypeDeclaration}.\n\t */\n\tpublic static EclipseNode injectMethod(EclipseNode type, AbstractMethodDeclaration method) {\n\t\tmethod.annotations = addSuppressWarningsAll(type, method, method.annotations);\n\t\tmethod.annotations = addGenerated(type, method, method.annotations);\n\t\tTypeDeclaration parent = (TypeDeclaration) type.get();\n\t\t\n\t\tif (parent.methods == null) {\n\t\t\tparent.methods = new AbstractMethodDeclaration[1];\n\t\t\tparent.methods[0] = method;\n\t\t} else {\n\t\t\tif (method instanceof ConstructorDeclaration) {\n\t\t\t\tfor (int i = 0 ; i < parent.methods.length ; i++) {\n\t\t\t\t\tif (parent.methods[i] instanceof ConstructorDeclaration &&\n\t\t\t\t\t\t\t(parent.methods[i].bits & ASTNode.IsDefaultConstructor) != 0) {\n\t\t\t\t\t\tEclipseNode tossMe = type.getNodeFor(parent.methods[i]);\n\t\t\t\t\t\t\n\t\t\t\t\t\tAbstractMethodDeclaration[] withoutGeneratedConstructor = new AbstractMethodDeclaration[parent.methods.length - 1];\n\t\t\t\t\t\t\n\t\t\t\t\t\tSystem.arraycopy(parent.methods, 0, withoutGeneratedConstructor, 0, i);\n\t\t\t\t\t\tSystem.arraycopy(parent.methods, i + 1, withoutGeneratedConstructor, i, parent.methods.length - i - 1);\n\t\t\t\t\t\t\n\t\t\t\t\t\tparent.methods = withoutGeneratedConstructor;\n\t\t\t\t\t\tif (tossMe != null) tossMe.up().removeChild(tossMe);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//We insert the method in the last position of the methods registered to the type\n\t\t\t//When changing this behavior, this may trigger issue #155 and #377\n\t\t\tAbstractMethodDeclaration[] newArray = new AbstractMethodDeclaration[parent.methods.length + 1];\n\t\t\tSystem.arraycopy(parent.methods, 0, newArray, 0, parent.methods.length);\n\t\t\tnewArray[parent.methods.length] = method;\n\t\t\tparent.methods = newArray;\n\t\t}\n\t\t\n\t\treturn type.add(method, Kind.METHOD);\n\t}\n\t\n\t/**\n\t * Adds an inner type (class, interface, enum) to the given type. Cannot inject top-level types.\n\t * \n\t * @param typeNode parent type to inject new type into\n\t * @param type New type (class, interface, etc) to inject.\n\t */\n\tpublic static EclipseNode injectType(final EclipseNode typeNode, final TypeDeclaration type) {\n\t\ttype.annotations = addSuppressWarningsAll(typeNode, type, type.annotations);\n\t\ttype.annotations = addGenerated(typeNode, type, type.annotations);\n\t\tTypeDeclaration parent = (TypeDeclaration) typeNode.get();\n\t\t\n\t\tif (parent.memberTypes == null) {\n\t\t\tparent.memberTypes = new TypeDeclaration[] { type };\n\t\t} else {\n\t\t\tTypeDeclaration[] newArray = new TypeDeclaration[parent.memberTypes.length + 1];\n\t\t\tSystem.arraycopy(parent.memberTypes, 0, newArray, 0, parent.memberTypes.length);\n\t\t\tnewArray[parent.memberTypes.length] = type;\n\t\t\tparent.memberTypes = newArray;\n\t\t}\n\t\t\n\t\treturn typeNode.add(type, Kind.TYPE);\n\t}\n\t\n\tstatic final char[] ALL = \"all\".toCharArray();\n\tstatic final char[] UNCHECKED = \"unchecked\".toCharArray();\n\tprivate static final char[] JUSTIFICATION = \"justification\".toCharArray();\n\tprivate static final char[] GENERATED_CODE = \"generated code\".toCharArray();\n\tprivate static final char[] LOMBOK = \"lombok\".toCharArray();\n\tprivate static final char[][] JAVAX_ANNOTATION_GENERATED = Eclipse.fromQualifiedName(\"javax.annotation.Generated\");\n\tprivate static final char[][] LOMBOK_GENERATED = Eclipse.fromQualifiedName(\"lombok.Generated\");\n\tprivate static final char[][] EDU_UMD_CS_FINDBUGS_ANNOTATIONS_SUPPRESSFBWARNINGS = Eclipse.fromQualifiedName(\"edu.umd.cs.findbugs.annotations.SuppressFBWarnings\");\n\t\n\tpublic static Annotation[] addSuppressWarningsAll(EclipseNode node, ASTNode source, Annotation[] originalAnnotationArray) {\n\t\tAnnotation[] anns = originalAnnotationArray;\n\t\t\n\t\tif (!Boolean.FALSE.equals(node.getAst().readConfiguration(ConfigurationKeys.ADD_SUPPRESSWARNINGS_ANNOTATIONS))) {\n\t\t\tanns = addAnnotation(source, anns, TypeConstants.JAVA_LANG_SUPPRESSWARNINGS, new StringLiteral(ALL, 0, 0, 0));\n\t\t}\n\t\t\n\t\tif (Boolean.TRUE.equals(node.getAst().readConfiguration(ConfigurationKeys.ADD_FINDBUGS_SUPPRESSWARNINGS_ANNOTATIONS))) {\n\t\t\tMemberValuePair mvp = new MemberValuePair(JUSTIFICATION, 0, 0, new StringLiteral(GENERATED_CODE, 0, 0, 0));\n\t\t\tanns = addAnnotation(source, anns, EDU_UMD_CS_FINDBUGS_ANNOTATIONS_SUPPRESSFBWARNINGS, mvp);\n\t\t}\n\t\t\n\t\treturn anns;\n\t}\n\t\n\tpublic static Annotation[] addGenerated(EclipseNode node, ASTNode source, Annotation[] originalAnnotationArray) {\n\t\tAnnotation[] result = originalAnnotationArray;\n\t\tif (HandlerUtil.shouldAddGenerated(node)) {\n\t\t\tresult = addAnnotation(source, result, JAVAX_ANNOTATION_GENERATED, new StringLiteral(LOMBOK, 0, 0, 0));\n\t\t}\n\t\tif (Boolean.TRUE.equals(node.getAst().readConfiguration(ConfigurationKeys.ADD_LOMBOK_GENERATED_ANNOTATIONS))) {\n\t\t\tresult = addAnnotation(source, result, LOMBOK_GENERATED);\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tstatic Annotation[] addAnnotation(ASTNode source, Annotation[] originalAnnotationArray, char[][] annotationTypeFqn) {\n\t\treturn addAnnotation(source, originalAnnotationArray, annotationTypeFqn, (ASTNode[]) null);\n\t}\n\t\n\tstatic Annotation[] addAnnotation(ASTNode source, Annotation[] originalAnnotationArray, char[][] annotationTypeFqn, ASTNode... args) {\n\t\tchar[] simpleName = annotationTypeFqn[annotationTypeFqn.length - 1];\n\t\t\n\t\tif (originalAnnotationArray != null) for (Annotation ann : originalAnnotationArray) {\n\t\t\tif (ann.type instanceof QualifiedTypeReference) {\n\t\t\t\tchar[][] t = ((QualifiedTypeReference) ann.type).tokens;\n\t\t\t\tif (Arrays.deepEquals(t, annotationTypeFqn)) return originalAnnotationArray;\n\t\t\t}\n\t\t\t\n\t\t\tif (ann.type instanceof SingleTypeReference) {\n\t\t\t\tchar[] lastToken = ((SingleTypeReference) ann.type).token;\n\t\t\t\tif (Arrays.equals(lastToken, simpleName)) return originalAnnotationArray;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint pS = source.sourceStart, pE = source.sourceEnd;\n\t\tTypeReference qualifiedType = generateQualifiedTypeRef(source, annotationTypeFqn);\n\t\tAnnotation ann;\n\t\tif (args != null && args.length == 1 && args[0] instanceof Expression) {\n\t\t\tSingleMemberAnnotation sma = new SingleMemberAnnotation(qualifiedType, pS);\n\t\t\tsma.declarationSourceEnd = pE;\n\t\t\targs[0].sourceStart = pS;\n\t\t\targs[0].sourceEnd = pE;\n\t\t\tsma.memberValue = (Expression) args[0];\n\t\t\tsetGeneratedBy(sma.memberValue, source);\n\t\t\tann = sma;\n\t\t} else if (args != null && args.length >= 1 && arrayHasOnlyElementsOfType(args, MemberValuePair.class)) {\n\t\t\tNormalAnnotation na = new NormalAnnotation(qualifiedType, pS);\n\t\t\tna.declarationSourceEnd = pE;\n\t\t\tna.memberValuePairs = new MemberValuePair[args.length];\n\t\t\tfor (int i = 0; i < args.length; i++) {\n\t\t\t\targs[i].sourceStart = pS;\n\t\t\t\targs[i].sourceEnd = pE;\n\t\t\t\tna.memberValuePairs[i] = (MemberValuePair) args[i];\t\t\t\n\t\t\t}\n\t\t\tsetGeneratedBy(na.memberValuePairs[0], source);\n\t\t\tsetGeneratedBy(na.memberValuePairs[0].value, source);\n\t\t\tna.memberValuePairs[0].value.sourceStart = pS;\n\t\t\tna.memberValuePairs[0].value.sourceEnd = pE;\n\t\t\tann = na;\n\t\t} else {\n\t\t\tMarkerAnnotation ma = new MarkerAnnotation(qualifiedType, pS);\n\t\t\tma.declarationSourceEnd = pE;\n\t\t\tann = ma;\n\t\t}\n\t\tsetGeneratedBy(ann, source);\n\t\tif (originalAnnotationArray == null) return new Annotation[] { ann };\n\t\tAnnotation[] newAnnotationArray = new Annotation[originalAnnotationArray.length + 1];\n\t\tSystem.arraycopy(originalAnnotationArray, 0, newAnnotationArray, 0, originalAnnotationArray.length);\n\t\tnewAnnotationArray[originalAnnotationArray.length] = ann;\n\t\treturn newAnnotationArray;\n\t}\n\t\n\tprivate static boolean arrayHasOnlyElementsOfType(Object[] array, Class<?> clazz) {\n\t\tfor (Object element : array) {\n\t\t\tif (!clazz.isInstance(element))\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Generates a new statement that checks if the given local variable is null, and if so, throws a specified exception with the\n\t * variable name as message.\n\t */\n\tpublic static Statement generateNullCheck(TypeReference type, char[] variable, EclipseNode sourceNode, String customMessage) {\n\t\tNullCheckExceptionType exceptionType = sourceNode.getAst().readConfiguration(ConfigurationKeys.NON_NULL_EXCEPTION_TYPE);\n\t\tif (exceptionType == null) exceptionType = NullCheckExceptionType.NULL_POINTER_EXCEPTION;\n\t\t\n\t\tASTNode source = sourceNode.get();\n\t\t\n\t\tint pS = source.sourceStart, pE = source.sourceEnd;\n\t\tlong p = (long) pS << 32 | pE;\n\t\t\n\t\tif (type != null && isPrimitive(type)) return null;\n\t\tSingleNameReference varName = new SingleNameReference(variable, p);\n\t\tsetGeneratedBy(varName, source);\n\t\t\n\t\tStringLiteral message = new StringLiteral(exceptionType.toExceptionMessage(new String(variable), customMessage).toCharArray(), pS, pE, 0);\n\t\tsetGeneratedBy(message, source);\n\t\t\n\t\tLombokImmutableList<String> method = exceptionType.getMethod();\n\t\tif (method != null) {\n\t\t\t\n\t\t\tMessageSend invocation = new MessageSend();\n\t\t\tinvocation.sourceStart = pS; invocation.sourceEnd = pE;\n\t\t\tsetGeneratedBy(invocation, source);\n\t\t\t\n\t\t\tchar[][] utilityTypeName = new char[method.size() - 1][];\n\t\t\tfor (int i = 0; i < method.size() - 1; i++) {\n\t\t\t\tutilityTypeName[i] = method.get(i).toCharArray();\n\t\t\t}\n\t\t\t\n\t\t\tinvocation.receiver = new QualifiedNameReference(utilityTypeName, new long[method.size() - 1], pS, pE);\n\t\t\tsetGeneratedBy(invocation.receiver, source);\n\t\t\tinvocation.selector = method.get(method.size() - 1).toCharArray();\n\t\t\tinvocation.arguments = new Expression[] {varName, message};\n\t\t\treturn invocation;\n\t\t}\n\t\t\n\t\tAllocationExpression exception = new AllocationExpression();\n\t\tsetGeneratedBy(exception, source);\n\t\t\n\t\tNullLiteral nullLiteral = new NullLiteral(pS, pE);\n\t\tsetGeneratedBy(nullLiteral, source);\n\t\t\n\t\tint equalOperator = exceptionType == NullCheckExceptionType.ASSERTION ? OperatorIds.NOT_EQUAL : OperatorIds.EQUAL_EQUAL; \n\t\tEqualExpression equalExpression = new EqualExpression(varName, nullLiteral, equalOperator);\n\t\tequalExpression.sourceStart = pS; equalExpression.statementEnd = equalExpression.sourceEnd = pE;\n\t\tsetGeneratedBy(equalExpression, source);\n\t\t\n\t\tif (exceptionType == NullCheckExceptionType.ASSERTION) {\n\t\t\tStatement assertStatement = new AssertStatement(message, equalExpression, pS);\n\t\t\tsetGeneratedBy(assertStatement, source);\n\t\t\treturn assertStatement;\n\t\t}\n\t\t\n\t\tString exceptionTypeStr = exceptionType.getExceptionType();\n\t\tint partCount = 1;\n\t\tfor (int i = 0; i < exceptionTypeStr.length(); i++) if (exceptionTypeStr.charAt(i) == '.') partCount++;\n\t\tlong[] ps = new long[partCount];\n\t\tArrays.fill(ps, 0L);\n\t\texception.type = new QualifiedTypeReference(fromQualifiedName(exceptionTypeStr), ps);\n\t\tsetGeneratedBy(exception.type, source);\n\t\texception.arguments = new Expression[] {message};\n\t\t\n\t\tThrowStatement throwStatement = new ThrowStatement(exception, pS, pE);\n\t\tsetGeneratedBy(throwStatement, source);\n\t\t\n\t\tBlock throwBlock = new Block(0);\n\t\tthrowBlock.statements = new Statement[] {throwStatement};\n\t\tthrowBlock.sourceStart = pS; throwBlock.sourceEnd = pE;\n\t\tsetGeneratedBy(throwBlock, source);\n\t\tIfStatement ifStatement = new IfStatement(equalExpression, throwBlock, 0, 0);\n\t\tsetGeneratedBy(ifStatement, source);\n\t\treturn ifStatement;\n\t}\n\t\n\t/**\n\t * Generates a new statement that checks if the given variable is null, and if so, throws a specified exception with the\n\t * variable name as message.\n\t * \n\t * @param exName The name of the exception to throw; normally {@code java.lang.NullPointerException}.\n\t */\n\tpublic static Statement generateNullCheck(AbstractVariableDeclaration variable, EclipseNode sourceNode, String customMessage) {\n\t\treturn generateNullCheck(variable.type, variable.name, sourceNode, customMessage);\n\t}\n\t\n\t/**\n\t * Create an annotation of the given name, and is marked as being generated by the given source.\n\t */\n\tpublic static MarkerAnnotation makeMarkerAnnotation(char[][] name, ASTNode source) {\n\t\tlong pos = (long) source.sourceStart << 32 | source.sourceEnd;\n\t\tlong[] poss = new long[name.length];\n\t\tArrays.fill(poss, pos);\n\t\tTypeReference typeRef = new QualifiedTypeReference(name, poss);\n\t\tsetGeneratedBy(typeRef, source);\n\t\tMarkerAnnotation ann = new MarkerAnnotation(typeRef, (int) (pos >> 32));\n\t\tann.declarationSourceEnd = ann.sourceEnd = ann.statementEnd = (int) pos;\n\t\tsetGeneratedBy(ann, source);\n\t\treturn ann;\n\t}\n\t\n\t/**\n\t * Given a list of field names and a node referring to a type, finds each name in the list that does not match a field within the type.\n\t */\n\tpublic static List<Integer> createListOfNonExistentFields(List<String> list, EclipseNode type, boolean excludeStandard, boolean excludeTransient) {\n\t\tboolean[] matched = new boolean[list.size()];\n\t\t\n\t\tfor (EclipseNode child : type.down()) {\n\t\t\tif (list.isEmpty()) break;\n\t\t\tif (child.getKind() != Kind.FIELD) continue;\n\t\t\tif (excludeStandard) {\n\t\t\t\tif ((((FieldDeclaration) child.get()).modifiers & ClassFileConstants.AccStatic) != 0) continue;\n\t\t\t\tif (child.getName().startsWith(\"$\")) continue;\n\t\t\t}\n\t\t\tif (excludeTransient && (((FieldDeclaration)child.get()).modifiers & ClassFileConstants.AccTransient) != 0) continue;\n\t\t\tint idx = list.indexOf(child.getName());\n\t\t\tif (idx > -1) matched[idx] = true;\n\t\t}\n\t\t\n\t\tList<Integer> problematic = new ArrayList<Integer>();\n\t\tfor (int i = 0 ; i < list.size() ; i++) {\n\t\t\tif (!matched[i]) problematic.add(i);\n\t\t}\n\t\t\n\t\treturn problematic;\n\t}\n\t\n\t/**\n\t * In eclipse 3.7+, the CastExpression constructor was changed from a really weird version to\n\t * a less weird one. Unfortunately that means we need to use reflection as we want to be compatible\n\t * with eclipse versions before 3.7 and 3.7+.\n\t * \n\t * @param ref The {@code foo} in {@code (String)foo}.\n\t * @param castTo The {@code String} in {@code (String)foo}.\n\t */\n\tpublic static CastExpression makeCastExpression(Expression ref, TypeReference castTo, ASTNode source) {\n\t\tCastExpression result;\n\t\ttry {\n\t\t\tif (castExpressionConstructorIsTypeRefBased) {\n\t\t\t\tresult = castExpressionConstructor.newInstance(ref, castTo);\n\t\t\t} else {\n\t\t\t\tExpression castToConverted = castTo;\n\t\t\t\t\n\t\t\t\tif (castTo.getClass() == SingleTypeReference.class && !isPrimitive(castTo)) {\n\t\t\t\t\tSingleTypeReference str = (SingleTypeReference) castTo;\n\t\t\t\t\t//Why a SingleNameReference instead of a SingleTypeReference you ask? I don't know. It seems dumb. Ask the ecj guys.\n\t\t\t\t\tcastToConverted = new SingleNameReference(str.token, 0);\n\t\t\t\t\tcastToConverted.bits = (castToConverted.bits & ~Binding.VARIABLE) | Binding.TYPE;\n\t\t\t\t\tcastToConverted.sourceStart = str.sourceStart;\n\t\t\t\t\tcastToConverted.sourceEnd = str.sourceEnd;\n\t\t\t\t\tsetGeneratedBy(castToConverted, source);\n\t\t\t\t} else if (castTo.getClass() == QualifiedTypeReference.class) {\n\t\t\t\t\tQualifiedTypeReference qtr = (QualifiedTypeReference) castTo;\n\t\t\t\t\t//Same here, but for the more complex types, they stay types.\n\t\t\t\t\tcastToConverted = new QualifiedNameReference(qtr.tokens, copy(qtr.sourcePositions), qtr.sourceStart, qtr.sourceEnd);\n\t\t\t\t\tcastToConverted.bits = (castToConverted.bits & ~Binding.VARIABLE) | Binding.TYPE;\n\t\t\t\t\tsetGeneratedBy(castToConverted, source);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tresult = castExpressionConstructor.newInstance(ref, castToConverted);\n\t\t\t}\n\t\t} catch (InvocationTargetException e) {\n\t\t\tthrow Lombok.sneakyThrow(e.getCause());\n\t\t} catch (IllegalAccessException e) {\n\t\t\tthrow Lombok.sneakyThrow(e);\n\t\t} catch (InstantiationException e) {\n\t\t\tthrow Lombok.sneakyThrow(e);\n\t\t}\n\t\t\n\t\tresult.sourceStart = source.sourceStart;\n\t\tresult.sourceEnd = source.sourceEnd;\n\t\tresult.statementEnd = source.sourceEnd;\n\t\t\n\t\tsetGeneratedBy(result, source);\n\t\treturn result;\n\t}\n\t\n\tprivate static final Constructor<CastExpression> castExpressionConstructor;\n\tprivate static final boolean castExpressionConstructorIsTypeRefBased;\n\t\n\tstatic {\n\t\tConstructor<?> constructor = null;\n\t\tfor (Constructor<?> ctor : CastExpression.class.getConstructors()) {\n\t\t\tif (ctor.getParameterTypes().length != 2) continue;\n\t\t\tconstructor = ctor;\n\t\t}\n\t\t\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tConstructor<CastExpression> castExpressionConstructor_ = (Constructor<CastExpression>) constructor;\n\t\tcastExpressionConstructor = castExpressionConstructor_;\n\t\t\n\t\tcastExpressionConstructorIsTypeRefBased =\n\t\t\t\t(castExpressionConstructor.getParameterTypes()[1] == TypeReference.class);\n\t}\n\t\n\t/**\n\t * In eclipse 3.7+, IntLiterals are created using a factory-method \n\t * Unfortunately that means we need to use reflection as we want to be compatible\n\t * with eclipse versions before 3.7.\n\t */\n\tpublic static IntLiteral makeIntLiteral(char[] token, ASTNode source) {\n\t\tint pS = source == null ? 0 : source.sourceStart, pE = source == null ? 0 : source.sourceEnd;\n\t\tIntLiteral result;\n\t\tif (intLiteralConstructor != null) {\n\t\t\tresult = Permit.newInstanceSneaky(intLiteralConstructor, token, pS, pE);\n\t\t} else {\n\t\t\tresult = (IntLiteral) Permit.invokeSneaky(intLiteralFactoryMethod, null, token, pS, pE);\n\t\t}\n\t\t\n\t\tif (source != null) setGeneratedBy(result, source);\n\t\treturn result;\n\t}\n\t\n\tprivate static final Constructor<IntLiteral> intLiteralConstructor;\n\tprivate static final Method intLiteralFactoryMethod;\n\t\n\tstatic {\n\t\tClass<?>[] parameterTypes = {char[].class, int.class, int.class};\n\t\tConstructor<IntLiteral> intLiteralConstructor_ = null;\n\t\tMethod intLiteralFactoryMethod_ = null;\n\t\ttry { \n\t\t\tintLiteralConstructor_ = Permit.getConstructor(IntLiteral.class, parameterTypes);\n\t\t} catch (Throwable ignore) {\n\t\t\t// probably eclipse 3.7++\n\t\t}\n\t\ttry { \n\t\t\tintLiteralFactoryMethod_ = Permit.getMethod(IntLiteral.class, \"buildIntLiteral\", parameterTypes);\n\t\t} catch (Throwable ignore) {\n\t\t\t// probably eclipse versions before 3.7\n\t\t}\n\t\tintLiteralConstructor = intLiteralConstructor_;\n\t\tintLiteralFactoryMethod = intLiteralFactoryMethod_;\n\t}\n\t\n\tprivate static boolean isAllValidOnXCharacters(char[] in) {\n\t\tif (in == null || in.length == 0) return false;\n\t\tfor (char c : in) if (c != '_' && c != 'X' && c != 'x' && c != '$') return false;\n\t\treturn true;\n\t}\n\t\n\tpublic static void addError(String errorName, EclipseNode node) {\n\t\tif (node.getLatestJavaSpecSupported() < 8) {\n\t\t\tnode.addError(\"The correct format is \" + errorName + \"_={@SomeAnnotation, @SomeOtherAnnotation})\");\n\t\t} else {\n\t\t\tnode.addError(\"The correct format is \" + errorName + \"=@__({@SomeAnnotation, @SomeOtherAnnotation}))\");\n\t\t}\n\t}\n\t\n\tpublic static List<Annotation> unboxAndRemoveAnnotationParameter(Annotation annotation, String annotationName, String errorName, EclipseNode errorNode) {\n\t\tif (\"value\".equals(annotationName)) {\n\t\t\t// We can't unbox this, because SingleMemberAnnotation REQUIRES a value, and this method\n\t\t\t// is supposed to remove the value. That means we need to replace the SMA with either\n\t\t\t// MarkerAnnotation or NormalAnnotation and that is beyond the scope of this method as we\n\t\t\t// don't need that at the time of writing this method; we only unbox onMethod, onParameter\n\t\t\t// and onConstructor. Let's exit early and very obviously:\n\t\t\tthrow new UnsupportedOperationException(\"Lombok cannot unbox 'value' from SingleMemberAnnotation at this time.\");\n\t\t}\n\t\tif (!NormalAnnotation.class.equals(annotation.getClass())) {\n\t\t\t// Prevent MarkerAnnotation, SingleMemberAnnotation, and\n\t\t\t// CompletionOnAnnotationMemberValuePair from triggering this handler.\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t\t\n\t\tNormalAnnotation normalAnnotation = (NormalAnnotation) annotation;\n\t\tMemberValuePair[] pairs = normalAnnotation.memberValuePairs;\n\t\t\n\t\tif (pairs == null) return Collections.emptyList();\n\t\t\n\t\tchar[] nameAsCharArray = annotationName.toCharArray();\n\t\t\n\t\ttop:\n\t\tfor (int i = 0; i < pairs.length; i++) {\n\t\t\tboolean allowRaw;\n\t\t\tchar[] name = pairs[i].name;\n\t\t\tif (name == null) continue;\n\t\t\tif (name.length < nameAsCharArray.length) continue;\n\t\t\tfor (int j = 0; j < nameAsCharArray.length; j++) {\n\t\t\t\tif (name[j] != nameAsCharArray[j]) continue top;\n\t\t\t}\n\t\t\tallowRaw = name.length > nameAsCharArray.length;\n\t\t\tfor (int j = nameAsCharArray.length; j < name.length; j++) {\n\t\t\t\tif (name[j] != '_') continue top;\n\t\t\t}\n\t\t\t// If we're still here it's the targeted annotation param.\n\t\t\tExpression value = pairs[i].value;\n\t\t\tMemberValuePair[] newPairs = new MemberValuePair[pairs.length - 1];\n\t\t\tif (i > 0) System.arraycopy(pairs, 0, newPairs, 0, i);\n\t\t\tif (i < pairs.length - 1) System.arraycopy(pairs, i + 1, newPairs, i, pairs.length - i - 1);\n\t\t\tnormalAnnotation.memberValuePairs = newPairs;\n\t\t\t// We have now removed the annotation parameter and stored the value,\n\t\t\t// which we must now unbox. It's either annotations, or @__(annotations).\n\t\t\t\n\t\t\tExpression content = null;\n\t\t\t\n\t\t\tif (value instanceof ArrayInitializer) {\n\t\t\t\tif (!allowRaw) {\n\t\t\t\t\taddError(errorName, errorNode);\n\t\t\t\t\treturn Collections.emptyList();\n\t\t\t\t}\n\t\t\t\tcontent = value;\n\t\t\t} else if (!(value instanceof Annotation)) {\n\t\t\t\taddError(errorName, errorNode);\n\t\t\t\treturn Collections.emptyList();\n\t\t\t} else {\n\t\t\t\tAnnotation atDummyIdentifier = (Annotation) value;\n\t\t\t\tif (atDummyIdentifier.type instanceof SingleTypeReference && isAllValidOnXCharacters(((SingleTypeReference) atDummyIdentifier.type).token)) {\n\t\t\t\t\tif (atDummyIdentifier instanceof MarkerAnnotation) {\n\t\t\t\t\t\treturn Collections.emptyList();\n\t\t\t\t\t} else if (atDummyIdentifier instanceof NormalAnnotation) {\n\t\t\t\t\t\tMemberValuePair[] mvps = ((NormalAnnotation) atDummyIdentifier).memberValuePairs;\n\t\t\t\t\t\tif (mvps == null || mvps.length == 0) {\n\t\t\t\t\t\t\treturn Collections.emptyList();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (mvps.length == 1 && Arrays.equals(\"value\".toCharArray(), mvps[0].name)) {\n\t\t\t\t\t\t\tcontent = mvps[0].value;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (atDummyIdentifier instanceof SingleMemberAnnotation) {\n\t\t\t\t\t\tcontent = ((SingleMemberAnnotation) atDummyIdentifier).memberValue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\taddError(errorName, errorNode);\n\t\t\t\t\t\treturn Collections.emptyList();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (allowRaw) {\n\t\t\t\t\t\tcontent = atDummyIdentifier;\n\t\t\t\t\t} else {\n\t\t\t\t\t\taddError(errorName, errorNode);\n\t\t\t\t\t\treturn Collections.emptyList();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (content == null) {\n\t\t\t\taddError(errorName, errorNode);\n\t\t\t\treturn Collections.emptyList();\n\t\t\t}\n\t\t\t\n\t\t\tif (content instanceof Annotation) {\n\t\t\t\treturn Collections.singletonList((Annotation) content);\n\t\t\t} else if (content instanceof ArrayInitializer) {\n\t\t\t\tExpression[] expressions = ((ArrayInitializer) content).expressions;\n\t\t\t\tList<Annotation> result = new ArrayList<Annotation>();\n\t\t\t\tif (expressions != null) for (Expression ex : expressions) {\n\t\t\t\t\tif (ex instanceof Annotation) result.add((Annotation) ex);\n\t\t\t\t\telse {\n\t\t\t\t\t\taddError(errorName, errorNode);\n\t\t\t\t\t\treturn Collections.emptyList();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\taddError(errorName, errorNode);\n\t\t\t\treturn Collections.emptyList();\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn Collections.emptyList();\n\t}\n\t\n\tpublic static NameReference createNameReference(String name, Annotation source) {\n\t\treturn generateQualifiedNameRef(source, fromQualifiedName(name));\n\t}\n\t\n\tprivate static long[] copy(long[] array) {\n\t\treturn array == null ? null : array.clone();\n\t}\n\t\n\tpublic static <T> T[] concat(T[] first, T[] second, Class<T> type) {\n\t\tif (first == null)\n\t\t\treturn second;\n\t\tif (second == null)\n\t\t\treturn first;\n\t\tif (first.length == 0)\n\t\t\treturn second;\n\t\tif (second.length == 0)\n\t\t\treturn first;\n\t\tT[] result = newArray(type, first.length + second.length);\n\t\tSystem.arraycopy(first, 0, result, 0, first.length);\n\t\tSystem.arraycopy(second, 0, result, first.length, second.length);\n\t\treturn result;\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tprivate static <T> T[] newArray(Class<T> type, int length) {\n\t\treturn (T[]) Array.newInstance(type, length);\n\t}\n\t\n\tpublic static boolean isDirectDescendantOfObject(EclipseNode typeNode) {\n\t\tif (!(typeNode.get() instanceof TypeDeclaration)) throw new IllegalArgumentException(\"not a type node\");\n\t\tTypeDeclaration typeDecl = (TypeDeclaration) typeNode.get();\n\t\tif (typeDecl.superclass == null) return true;\n\t\tString p = typeDecl.superclass.toString();\n\t\treturn p.equals(\"Object\") || p.equals(\"java.lang.Object\");\n\t}\n\t\n\tpublic static void createRelevantNullableAnnotation(EclipseNode typeNode, MethodDeclaration mth) {\n\t\tNullAnnotationLibrary lib = typeNode.getAst().readConfiguration(ConfigurationKeys.ADD_NULL_ANNOTATIONS);\n\t\tif (lib == null) return;\n\t\t\n\t\tapplyAnnotationToMethodDecl(typeNode, mth, lib.getNullableAnnotation(), lib.isTypeUse());\n\t}\n\t\n\tpublic static void createRelevantNonNullAnnotation(EclipseNode typeNode, MethodDeclaration mth) {\n\t\tNullAnnotationLibrary lib = typeNode.getAst().readConfiguration(ConfigurationKeys.ADD_NULL_ANNOTATIONS);\n\t\tif (lib == null) return;\n\t\t\n\t\tapplyAnnotationToMethodDecl(typeNode, mth, lib.getNonNullAnnotation(), lib.isTypeUse());\n\t}\n\t\n\tpublic static void createRelevantNullableAnnotation(EclipseNode typeNode, Argument arg) {\n\t\tNullAnnotationLibrary lib = typeNode.getAst().readConfiguration(ConfigurationKeys.ADD_NULL_ANNOTATIONS);\n\t\tif (lib == null) return;\n\t\t\n\t\tapplyAnnotationToVarDecl(typeNode, arg, lib.getNullableAnnotation(), lib.isTypeUse());\n\t}\n\t\n\tpublic static void createRelevantNonNullAnnotation(EclipseNode typeNode, Argument arg) {\n\t\tNullAnnotationLibrary lib = typeNode.getAst().readConfiguration(ConfigurationKeys.ADD_NULL_ANNOTATIONS);\n\t\tif (lib == null) return;\n\t\t\n\t\tapplyAnnotationToVarDecl(typeNode, arg, lib.getNonNullAnnotation(), lib.isTypeUse());\n\t}\n\t\n\tprivate static void applyAnnotationToMethodDecl(EclipseNode typeNode, MethodDeclaration mth, String annType, boolean typeUse) {\n\t\tif (annType == null) return;\n\t\t\n\t\tint partCount = 1;\n\t\tfor (int i = 0; i < annType.length(); i++) if (annType.charAt(i) == '.') partCount++;\n\t\tlong[] ps = new long[partCount];\n\t\tArrays.fill(ps, 0L);\n\t\tAnnotation ann = new MarkerAnnotation(new QualifiedTypeReference(Eclipse.fromQualifiedName(annType), ps), 0);\n\t\t\n\t\tif (!typeUse || mth.returnType == null || mth.returnType.getTypeName().length < 2) {\n\t\t\tAnnotation[] a = mth.annotations;\n\t\t\tif (a == null) a = new Annotation[1];\n\t\t\telse {\n\t\t\t\tAnnotation[] b = new Annotation[a.length + 1];\n\t\t\t\tSystem.arraycopy(a, 0, b, 0, a.length);\n\t\t\t\ta = b;\n\t\t\t}\n\t\t\ta[a.length - 1] = ann;\n\t\t\tmth.annotations = a;\n\t\t} else {\n\t\t\tint len = mth.returnType.getTypeName().length;\n\t\t\tif (mth.returnType.annotations == null) mth.returnType.annotations = new Annotation[len][];\n\t\t\tAnnotation[] a = mth.returnType.annotations[len - 1];\n\t\t\tif (a == null) a = new Annotation[1];\n\t\t\telse {\n\t\t\t\tAnnotation[] b = new Annotation[a.length + 1];\n\t\t\t\tSystem.arraycopy(a, 0, b, 1, a.length);\n\t\t\t\ta = b;\n\t\t\t}\n\t\t\ta[0] = ann;\n\t\t\tmth.returnType.annotations[len - 1] = a;\n\t\t}\n\t}\n\tprivate static void applyAnnotationToVarDecl(EclipseNode typeNode, Argument arg, String annType, boolean typeUse) {\n\t\tif (annType == null) return;\n\t\t\n\t\tint partCount = 1;\n\t\tfor (int i = 0; i < annType.length(); i++) if (annType.charAt(i) == '.') partCount++;\n\t\tlong[] ps = new long[partCount];\n\t\tArrays.fill(ps, 0L);\n\t\tAnnotation ann = new MarkerAnnotation(new QualifiedTypeReference(Eclipse.fromQualifiedName(annType), ps), 0);\n\t\t\n\t\tif (!typeUse || arg.type.getTypeName().length < 2) {\n\t\t\tAnnotation[] a = arg.annotations;\n\t\t\tif (a == null) a = new Annotation[1];\n\t\t\telse {\n\t\t\t\tAnnotation[] b = new Annotation[a.length + 1];\n\t\t\t\tSystem.arraycopy(a, 0, b, 0, a.length);\n\t\t\t\ta = b;\n\t\t\t}\n\t\t\ta[a.length - 1] = ann;\n\t\t\targ.annotations = a;\n\t\t} else {\n\t\t\tint len = arg.type.getTypeName().length;\n\t\t\tif (arg.type.annotations == null) arg.type.annotations = new Annotation[len][];\n\t\t\tAnnotation[] a = arg.type.annotations[len - 1];\n\t\t\tif (a == null) a = new Annotation[1];\n\t\t\telse {\n\t\t\t\tAnnotation[] b = new Annotation[a.length + 1];\n\t\t\t\tSystem.arraycopy(a, 0, b, 1, a.length);\n\t\t\t\ta = b;\n\t\t\t}\n\t\t\ta[0] = ann;\n\t\t\targ.type.annotations[len - 1] = a;\n\t\t}\n\t}\n\t\n\tpublic static NameReference generateQualifiedNameRef(ASTNode source, char[]... varNames) {\n\t\tint pS = source.sourceStart, pE = source.sourceEnd;\n\t\tlong p = (long)pS << 32 | pE;\n\t\t\n\t\tNameReference ref;\n\t\t\n\t\tif (varNames.length > 1) ref = new QualifiedNameReference(varNames, new long[varNames.length], pS, pE);\n\t\telse ref = new SingleNameReference(varNames[0], p);\n\t\tsetGeneratedBy(ref, source);\n\t\treturn ref;\n\t}\n\t\n\tpublic static TypeReference generateQualifiedTypeRef(ASTNode source, char[]... varNames) {\n\t\tint pS = source.sourceStart, pE = source.sourceEnd;\n\t\tlong p = (long)pS << 32 | pE;\n\t\t\n\t\tTypeReference ref;\n\t\t\n\t\tlong[] poss = Eclipse.poss(source, varNames.length);\n\t\tif (varNames.length > 1) ref = new QualifiedTypeReference(varNames, poss);\n\t\telse ref = new SingleTypeReference(varNames[0], p);\n\t\tsetGeneratedBy(ref, source);\n\t\treturn ref;\n\t}\n\t\n\tpublic static TypeReference createTypeReference(String typeName, ASTNode source) {\n\t\treturn generateQualifiedTypeRef(source, fromQualifiedName(typeName));\n\t}\n\t\n\t/**\n\t * Returns {@code true} if the provided node is an actual class and not some other type declaration (so, not an annotation definition, interface, enum, or record).\n\t */\n\tpublic static boolean isClass(EclipseNode typeNode) {\n\t\treturn isTypeAndDoesNotHaveFlags(typeNode, ClassFileConstants.AccInterface | ClassFileConstants.AccEnum | ClassFileConstants.AccAnnotation | AccRecord);\n\t}\n\t\n\t/**\n\t * Returns {@code true} if the provided node is an actual class or enum and not some other type declaration (so, not an annotation definition, interface, or record).\n\t */\n\tpublic static boolean isClassOrEnum(EclipseNode typeNode) {\n\t\treturn isTypeAndDoesNotHaveFlags(typeNode, ClassFileConstants.AccInterface | ClassFileConstants.AccAnnotation | AccRecord);\n\t}\n\t\n\t/**\n\t * Returns {@code true} if the provided node is an actual class, an enum or a record and not some other type declaration (so, not an annotation definition or interface).\n\t */\n\tpublic static boolean isClassEnumOrRecord(EclipseNode typeNode) {\n\t\treturn isTypeAndDoesNotHaveFlags(typeNode, ClassFileConstants.AccInterface | ClassFileConstants.AccAnnotation);\n\t}\n\t\n\t/**\n\t * Returns {@code true} if the provided node is a record declaration (so, not an annotation definition, interface, enum, or plain class).\n\t */\n\tpublic static boolean isRecord(EclipseNode typeNode) {\n\t\tTypeDeclaration typeDecl = null;\n\t\tif (typeNode.get() instanceof TypeDeclaration) typeDecl = (TypeDeclaration) typeNode.get();\n\t\tint modifiers = typeDecl == null ? 0 : typeDecl.modifiers;\n\t\treturn (modifiers & AccRecord) != 0;\n\t}\n\t\n\t/**\n\t * Returns {@code true} If the provided node is a field declaration, and represents a field in a {@code record} declaration.\n\t */\n\tpublic static boolean isRecordField(EclipseNode fieldNode) {\n\t\treturn fieldNode.getKind() == Kind.FIELD && (((FieldDeclaration) fieldNode.get()).modifiers & AccRecord) != 0;\n\t}\n\t\n\t/**\n\t * Returns {@code true) if the provided node is a type declaration <em>and<\/em> is <strong>not<\/strong> of any kind indicated by the flags (the intent is to pass flags usch as `ClassFileConstants.AccEnum`).\n\t */\n\tstatic boolean isTypeAndDoesNotHaveFlags(EclipseNode typeNode, long flags) {\n\t\tTypeDeclaration typeDecl = null;\n\t\tif (typeNode.get() instanceof TypeDeclaration) typeDecl = (TypeDeclaration) typeNode.get();\n\t\tint modifiers = typeDecl == null ? 0 : typeDecl.modifiers;\n\t\treturn (modifiers & flags) == 0;\n\t}\n\t\n\t/**\n\t * Returns {@code true} if the provided node supports static methods and types (top level or static class)\n\t */\n\tpublic static boolean isStaticAllowed(EclipseNode typeNode) {\n\t\tboolean staticAllowed = true;\n\t\t\n\t\twhile (typeNode.getKind() != Kind.COMPILATION_UNIT) {\n\t\t\tif (!staticAllowed) return false;\n\t\t\t\n\t\t\tstaticAllowed = typeNode.isStatic();\n\t\t\ttypeNode = typeNode.up();\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tpublic static AbstractVariableDeclaration[] getRecordComponents(TypeDeclaration typeDeclaration) {\n\t\tif (typeDeclaration == null || (typeDeclaration.modifiers & AccRecord) == 0) return null;\n\t\ttry {\n\t\t\treturn (AbstractVariableDeclaration[]) TYPE_DECLARATION_RECORD_COMPONENTS.get(typeDeclaration);\n\t\t} catch (Exception e) {\n\t\t\t// This presumably means this isn't a JDK16 - fall through.\n\t\t}\n\t\treturn null;\n\t}\n\t\n\tpublic static Annotation[][] getRecordFieldAnnotations(TypeDeclaration typeDeclaration) {\n\t\tif (typeDeclaration.fields == null) return null;\n\t\tAnnotation[][] annotations = new Annotation[typeDeclaration.fields.length][];\n\t\t\n\t\tAbstractVariableDeclaration[] recordComponents = getRecordComponents(typeDeclaration);\n\t\tif (recordComponents != null) {\n\t\t\tint j = 0;\n\t\t\tfor (int i = 0; i < typeDeclaration.fields.length; i++) {\n\t\t\t\tif ((typeDeclaration.fields[i].modifiers & AccRecord) != 0) {\n\t\t\t\t\tannotations[i] = recordComponents[j++].annotations;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn annotations;\n\t}\n\t\n\tpublic static String getDocComment(EclipseNode eclipseNode) {\n\t\tif (eclipseNode.getAst().getSource() == null) return null;\n\t\t\n\t\tfinal ASTNode node = eclipseNode.get();\n\t\tif (node instanceof FieldDeclaration) {\n\t\t\tFieldDeclaration fieldDeclaration = (FieldDeclaration) node;\n\t\t\tchar[] rawContent = CharOperation.subarray(eclipseNode.getAst().getSource(), fieldDeclaration.declarationSourceStart, fieldDeclaration.declarationSourceEnd);\n\t\t\tString rawContentString = new String(rawContent);\n\t\t\tint startIndex = rawContentString.indexOf(\"/**\");\n\t\t\tint endIndex = rawContentString.indexOf(\"*/\");\n\t\t\tif (startIndex != -1 && endIndex != -1) {\n\t\t\t\t/* Remove all leading asterisks */\n\t\t\t\treturn rawContentString.substring(startIndex + 3, endIndex).replaceAll(\"(?m)^\\\\s*\\\\* ?\", \"\").trim();\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\t\n\tpublic static void setDocComment(CompilationUnitDeclaration cud, EclipseNode eclipseNode, String doc) {\n\t\tsetDocComment(cud, (TypeDeclaration) upToTypeNode(eclipseNode).get(), eclipseNode.get(), doc);\n\t}\n\t \n\tpublic static void setDocComment(CompilationUnitDeclaration cud, TypeDeclaration type, ASTNode node, String doc) {\n\t\tif (doc == null) return;\n\t\t\n\t\tMap<String, String> docs = EcjAugments.CompilationUnit_javadoc.setIfAbsent(cud.compilationResult.compilationUnit, new HashMap<String, String>());\n\t\tif (node instanceof AbstractMethodDeclaration) {\n\t\t\tAbstractMethodDeclaration methodDeclaration = (AbstractMethodDeclaration) node;\n\t\t\tString signature = getSignature(type, methodDeclaration);\n\t\t\t/* Add javadoc start marker, remove trailing line break, add leading asterisks to each line, add javadoc end marker */\n\t\t\tdocs.put(signature, String.format(\"/**%n%s%n */\", doc.replaceAll(\"$\\\\r?\\\\n\", \"\").replaceAll(\"(?m)^\", \" * \")));\n\t\t}\n\t}\n\t\n\tpublic static String getSignature(TypeDeclaration type, AbstractMethodDeclaration methodDeclaration) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append(type.name);\n\t\tsb.append(\".\");\n\t\tsb.append(methodDeclaration.selector);\n\t\tsb.append(\"(\");\n\t\tArgument[] arguments = methodDeclaration.arguments;\n\t\tif (arguments != null) {\n\t\t\tfor (Argument argument : arguments) {\n\t\t\t\tsb.append(String.valueOf(argument.type));\n\t\t\t}\n\t\t}\n\t\tsb.append(\")\");\n\t\treturn sb.toString();\n\t}\n\t\n\tpublic static enum CopyJavadoc {\n\t\tVERBATIM {\n\t\t\t@Override public String apply(final EclipseNode node) {\n\t\t\t\treturn getDocComment(node);\n\t\t\t}\n\t\t},\n\t\tGETTER {\n\t\t\t@Override public String apply(final EclipseNode node) {\n\t\t\t\tString javadoc = getDocComment(node);\n\t\t\t\t// step 1: Check if there is a 'GETTER' section. If yes, that becomes the new method's javadoc.\n\t\t\t\tString out = getJavadocSection(javadoc, \"GETTER\");\n\t\t\t\tfinal boolean sectionBased = out != null;\n\t\t\t\tif (!sectionBased) {\n\t\t\t\t\tout = stripLinesWithTagFromJavadoc(stripSectionsFromJavadoc(javadoc), JavadocTag.PARAM);\n\t\t\t\t}\n\t\t\t\treturn out;\n\t\t\t}\n\t\t},\n\t\tSETTER {\n\t\t\t@Override public String apply(final EclipseNode node) {\n\t\t\t\treturn applySetter(node, \"SETTER\");\n\t\t\t}\n\t\t},\n\t\tWITH {\n\t\t\t@Override public String apply(final EclipseNode node) {\n\t\t\t\treturn addReturnsUpdatedSelfIfNeeded(applySetter(node, \"WITH|WITHER\"));\n\t\t\t}\n\t\t},\n\t\tWITH_BY {\n\t\t\t@Override public String apply( final EclipseNode node) {\n\t\t\t\treturn applySetter(node, \"WITHBY|WITH_BY\");\n\t\t\t}\n\t\t};\n\t\t\n\t\tpublic abstract String apply(final EclipseNode node);\n\t\t\n\t\tprivate static String applySetter(EclipseNode node, String sectionName) {\n\t\t\tString javadoc = getDocComment(node);\n\t\t\t// step 1: Check if there is a 'SETTER' section. If yes, that becomes the new method's javadoc.\n\t\t\tString out = getJavadocSection(javadoc, sectionName);\n\t\t\tfinal boolean sectionBased = out != null;\n\t\t\tif (!sectionBased) {\n\t\t\t\tout = stripLinesWithTagFromJavadoc(stripSectionsFromJavadoc(javadoc), JavadocTag.RETURN);\n\t\t\t}\n\t\t\treturn shouldReturnThis(node) ? addReturnsThisIfNeeded(out) : out;\n\t\t}\n\t}\n\t\n\t/**\n\t * Copies javadoc on one node to the other.\n\t * \n\t * This one is a shortcut for {@link EclipseHandlerUtil#copyJavadoc(EclipseNode, ASTNode, TypeDeclaration, CopyJavadoc, boolean)}\n\t * if source and target node are in the same type.\n\t */\n\tpublic static void copyJavadoc(EclipseNode from, ASTNode to, CopyJavadoc copyMode) {\n\t\tcopyJavadoc(from, to, (TypeDeclaration) upToTypeNode(from).get(), copyMode, false);\n\t}\n\t\n\t/**\n\t * Copies javadoc on one node to the other.\n\t * \n\t * This one is a shortcut for {@link EclipseHandlerUtil#copyJavadoc(EclipseNode, ASTNode, TypeDeclaration, CopyJavadoc, boolean)}\n\t * if source and target node are in the same type.\n\t */\n\tpublic static void copyJavadoc(EclipseNode from, ASTNode to, CopyJavadoc copyMode, boolean forceAddReturn) {\n\t\tcopyJavadoc(from, to, (TypeDeclaration) upToTypeNode(from).get(), copyMode, forceAddReturn);\n\t}\n\t\n\tpublic static void copyJavadoc(EclipseNode from, ASTNode to, TypeDeclaration type, CopyJavadoc copyMode) {\n\t\tcopyJavadoc(from, to, type, copyMode, false);\n\t}\n\t\n\t/**\n\t * Copies javadoc on one node to the other.\n\t * \n\t * in 'GETTER' copyMode, first a 'GETTER' segment is searched for. If it exists, that will become the javadoc for the 'to' node, and this section is\n\t * stripped out of the 'from' node. If no 'GETTER' segment is found, then the entire javadoc is taken minus any {@code @param} lines and other sections.\n\t * any {@code @return} lines are stripped from 'from'.\n\t * \n\t * in 'SETTER' mode, stripping works similarly to 'GETTER' mode, except {@code param} are copied and stripped from the original and {@code @return} are skipped.\n\t */\n\tpublic static void copyJavadoc(EclipseNode from, ASTNode to, TypeDeclaration type, CopyJavadoc copyMode, boolean forceAddReturn) {\n\t\tif (copyMode == null) copyMode = CopyJavadoc.VERBATIM;\n\t\ttry {\n\t\t\tCompilationUnitDeclaration cud = ((CompilationUnitDeclaration) from.top().get());\n\t\t\tString newJavadoc = copyMode.apply(from);\n\t\t\tif (forceAddReturn) {\n\t\t\t\tnewJavadoc = addReturnsThisIfNeeded(newJavadoc);\n\t\t\t}\n\t\t\tsetDocComment(cud, type, to, newJavadoc);\n\t\t} catch (Exception ignore) {}\n\t}\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2009-2021 The Project Lombok Authors.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage lombok.eclipse.handlers;\n\nimport static lombok.core.handlers.HandlerUtil.*;\nimport static lombok.eclipse.Eclipse.*;\nimport static lombok.eclipse.EcjAugments.*;\nimport static lombok.eclipse.handlers.EclipseHandlerUtil.EclipseReflectiveMembers.*;\n\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.eclipse.jdt.core.compiler.CharOperation;\nimport org.eclipse.jdt.internal.compiler.ast.ASTNode;\nimport org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.AbstractVariableDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.AllocationExpression;\nimport org.eclipse.jdt.internal.compiler.ast.Annotation;\nimport org.eclipse.jdt.internal.compiler.ast.Argument;\nimport org.eclipse.jdt.internal.compiler.ast.ArrayInitializer;\nimport org.eclipse.jdt.internal.compiler.ast.ArrayQualifiedTypeReference;\nimport org.eclipse.jdt.internal.compiler.ast.ArrayTypeReference;\nimport org.eclipse.jdt.internal.compiler.ast.AssertStatement;\nimport org.eclipse.jdt.internal.compiler.ast.BinaryExpression;\nimport org.eclipse.jdt.internal.compiler.ast.Block;\nimport org.eclipse.jdt.internal.compiler.ast.CastExpression;\nimport org.eclipse.jdt.internal.compiler.ast.CharLiteral;\nimport org.eclipse.jdt.internal.compiler.ast.ClassLiteralAccess;\nimport org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.DoubleLiteral;\nimport org.eclipse.jdt.internal.compiler.ast.EqualExpression;\nimport org.eclipse.jdt.internal.compiler.ast.Expression;\nimport org.eclipse.jdt.internal.compiler.ast.ExtendedStringLiteral;\nimport org.eclipse.jdt.internal.compiler.ast.FalseLiteral;\nimport org.eclipse.jdt.internal.compiler.ast.FieldDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.FieldReference;\nimport org.eclipse.jdt.internal.compiler.ast.FloatLiteral;\nimport org.eclipse.jdt.internal.compiler.ast.IfStatement;\nimport org.eclipse.jdt.internal.compiler.ast.IntLiteral;\nimport org.eclipse.jdt.internal.compiler.ast.Literal;\nimport org.eclipse.jdt.internal.compiler.ast.LongLiteral;\nimport org.eclipse.jdt.internal.compiler.ast.MarkerAnnotation;\nimport org.eclipse.jdt.internal.compiler.ast.MemberValuePair;\nimport org.eclipse.jdt.internal.compiler.ast.MessageSend;\nimport org.eclipse.jdt.internal.compiler.ast.MethodDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.NameReference;\nimport org.eclipse.jdt.internal.compiler.ast.NormalAnnotation;\nimport org.eclipse.jdt.internal.compiler.ast.NullLiteral;\nimport org.eclipse.jdt.internal.compiler.ast.OperatorIds;\nimport org.eclipse.jdt.internal.compiler.ast.ParameterizedQualifiedTypeReference;\nimport org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference;\nimport org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference;\nimport org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference;\nimport org.eclipse.jdt.internal.compiler.ast.SingleMemberAnnotation;\nimport org.eclipse.jdt.internal.compiler.ast.SingleNameReference;\nimport org.eclipse.jdt.internal.compiler.ast.SingleTypeReference;\nimport org.eclipse.jdt.internal.compiler.ast.Statement;\nimport org.eclipse.jdt.internal.compiler.ast.StringLiteral;\nimport org.eclipse.jdt.internal.compiler.ast.StringLiteralConcatenation;\nimport org.eclipse.jdt.internal.compiler.ast.ThisReference;\nimport org.eclipse.jdt.internal.compiler.ast.ThrowStatement;\nimport org.eclipse.jdt.internal.compiler.ast.TrueLiteral;\nimport org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.TypeParameter;\nimport org.eclipse.jdt.internal.compiler.ast.TypeReference;\nimport org.eclipse.jdt.internal.compiler.ast.Wildcard;\nimport org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;\nimport org.eclipse.jdt.internal.compiler.env.ICompilationUnit;\nimport org.eclipse.jdt.internal.compiler.lookup.Binding;\nimport org.eclipse.jdt.internal.compiler.lookup.CaptureBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.RawTypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.TypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.TypeConstants;\nimport org.eclipse.jdt.internal.compiler.lookup.TypeIds;\nimport org.eclipse.jdt.internal.compiler.lookup.WildcardBinding;\n\nimport lombok.AccessLevel;\nimport lombok.ConfigurationKeys;\nimport lombok.Data;\nimport lombok.Getter;\nimport lombok.Lombok;\nimport lombok.core.AST.Kind;\nimport lombok.core.AnnotationValues;\nimport lombok.core.AnnotationValues.AnnotationValue;\nimport lombok.core.LombokImmutableList;\nimport lombok.core.TypeResolver;\nimport lombok.core.configuration.CheckerFrameworkVersion;\nimport lombok.core.configuration.NullAnnotationLibrary;\nimport lombok.core.configuration.NullCheckExceptionType;\nimport lombok.core.configuration.TypeName;\nimport lombok.core.debug.ProblemReporter;\nimport lombok.core.handlers.HandlerUtil;\nimport lombok.core.handlers.HandlerUtil.FieldAccess;\nimport lombok.eclipse.EcjAugments;\nimport lombok.eclipse.Eclipse;\nimport lombok.eclipse.EclipseAST;\nimport lombok.eclipse.EclipseNode;\nimport lombok.experimental.Accessors;\nimport lombok.experimental.Tolerate;\nimport lombok.permit.Permit;\n\n/**\n * Container for static utility methods useful to handlers written for eclipse.\n */\npublic class EclipseHandlerUtil {\n\tprivate EclipseHandlerUtil() {\n\t\t//Prevent instantiation\n\t}\n\t\n\t/**\n\t * Generates an error in the Eclipse error log. Note that most people never look at it!\n\t * \n\t * @param cud The {@code CompilationUnitDeclaration} where the error occurred.\n\t *     An error will be generated on line 0 linking to the error log entry. Can be {@code null}.\n\t * @param message Human readable description of the problem.\n\t * @param ex The associated exception. Can be {@code null}.\n\t */\n\tpublic static void error(CompilationUnitDeclaration cud, String message, Throwable ex) {\n\t\tProblemReporter.error(message, ex);\n\t\tif (cud != null) EclipseAST.addProblemToCompilationResult(cud.getFileName(), cud.compilationResult, false, message + \" - See error log.\", 0, 0);\n\t}\n\t\n\t/**\n\t * Generates a warning in the Eclipse error log. Note that most people never look at it!\n\t * \n\t * @param message Human readable description of the problem.\n\t * @param ex The associated exception. Can be {@code null}.\n\t */\n\tpublic static void warning(String message, Throwable ex) {\n\t\tProblemReporter.warning(message, ex);\n\t}\n\t\n\tpublic static ASTNode getGeneratedBy(ASTNode node) {\n\t\treturn ASTNode_generatedBy.get(node);\n\t}\n\t\n\tpublic static boolean isGenerated(ASTNode node) {\n\t\treturn getGeneratedBy(node) != null;\n\t}\n\t\n\tpublic static <T extends ASTNode> T setGeneratedBy(T node, ASTNode source) {\n\t\tASTNode_generatedBy.set(node, source);\n\t\treturn node;\n\t}\n\t\n\tpublic static MarkerAnnotation generateDeprecatedAnnotation(ASTNode source) {\n\t\tQualifiedTypeReference qtr = new QualifiedTypeReference(new char[][] {\n\t\t\t\t{'j', 'a', 'v', 'a'}, {'l', 'a', 'n', 'g'}, {'D', 'e', 'p', 'r', 'e', 'c', 'a', 't', 'e', 'd'}}, poss(source, 3));\n\t\tsetGeneratedBy(qtr, source);\n\t\tMarkerAnnotation ma = new MarkerAnnotation(qtr, source.sourceStart);\n\t\t// No matter what value you input for sourceEnd, the AST->DOM converter of eclipse will reparse to find the end, and will fail as\n\t\t// it can't find code that isn't really there. This results in the end position being set to 2 or 0 or some weird magic value, and thus,\n\t\t// length, as calculated by end-start, is all screwed up, resulting in IllegalArgumentException during a setSourceRange call MUCH later in the process.\n\t\t// We solve it by going with a voodoo magic source start value such that the calculated length so happens to exactly be 0. 0 lengths are accepted\n\t\t// by eclipse. For some reason.\n\t\t// TL;DR: Don't change 1. 1 is sacred. Trust the 1.\n\t\t// issue: #408.\n\t\tma.sourceStart = 1;\n\t\tsetGeneratedBy(ma, source);\n\t\treturn ma;\n\t}\n\t\n\tpublic static MarkerAnnotation generateNamedAnnotation(ASTNode source, String typeName) {\n\t\tchar[][] cc = fromQualifiedName(typeName);\n\t\tQualifiedTypeReference qtr = new QualifiedTypeReference(cc, poss(source, cc.length));\n\t\tsetGeneratedBy(qtr, source);\n\t\tMarkerAnnotation ma = new MarkerAnnotation(qtr, source.sourceStart);\n\t\t// No matter what value you input for sourceEnd, the AST->DOM converter of eclipse will reparse to find the end, and will fail as\n\t\t// it can't find code that isn't really there. This results in the end position being set to 2 or 0 or some weird magic value, and thus,\n\t\t// length, as calculated by end-start, is all screwed up, resulting in IllegalArgumentException during a setSourceRange call MUCH later in the process.\n\t\t// We solve it by going with a voodoo magic source start value such that the calculated length so happens to exactly be 0. 0 lengths are accepted\n\t\t// by eclipse. For some reason.\n\t\t// TL;DR: Don't change 1. 1 is sacred. Trust the 1.\n\t\t// issue: #408.\n\t\tma.sourceStart = 1;\n\t\tsetGeneratedBy(ma, source);\n\t\treturn ma;\n\t}\n\t\n\tpublic static boolean isFieldDeprecated(EclipseNode fieldNode) {\n\t\tif (!(fieldNode.get() instanceof FieldDeclaration)) return false;\n\t\tFieldDeclaration field = (FieldDeclaration) fieldNode.get();\n\t\tif ((field.modifiers & ClassFileConstants.AccDeprecated) != 0) {\n\t\t\treturn true;\n\t\t}\n\t\tif (field.annotations == null) return false;\n\t\tfor (Annotation annotation : field.annotations) {\n\t\t\tif (typeMatches(Deprecated.class, fieldNode, annotation.type)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic static CheckerFrameworkVersion getCheckerFrameworkVersion(EclipseNode node) {\n\t\tCheckerFrameworkVersion cfv = node.getAst().readConfiguration(ConfigurationKeys.CHECKER_FRAMEWORK);\n\t\treturn cfv != null ? cfv : CheckerFrameworkVersion.NONE;\n\t}\n\t\n\t/**\n\t * Checks if the given TypeReference node is likely to be a reference to the provided class.\n\t * \n\t * @param type An actual type. This method checks if {@code typeNode} is likely to be a reference to this type.\n\t * @param node A Lombok AST node. Any node in the appropriate compilation unit will do (used to get access to import statements).\n\t * @param typeRef A type reference to check.\n\t */\n\tpublic static boolean typeMatches(Class<?> type, EclipseNode node, TypeReference typeRef) {\n\t\treturn typeMatches(type.getName(), node, typeRef);\n\t}\n\t\n\t/**\n\t * Checks if the given TypeReference node is likely to be a reference to the provided class.\n\t * \n\t * @param type An actual type. This method checks if {@code typeNode} is likely to be a reference to this type.\n\t * @param node A Lombok AST node. Any node in the appropriate compilation unit will do (used to get access to import statements).\n\t * @param typeRef A type reference to check.\n\t */\n\tpublic static boolean typeMatches(String type, EclipseNode node, TypeReference typeRef) {\n\t\tchar[][] tn = typeRef == null ? null : typeRef.getTypeName();\n\t\tif (tn == null || tn.length == 0) return false;\n\t\tchar[] lastPartA = tn[tn.length - 1];\n\t\tint lastIndex = Math.max(type.lastIndexOf('.'), type.lastIndexOf('$')) + 1;\n\t\tif (lastPartA.length != type.length() - lastIndex) return false;\n\t\tfor (int i = 0; i < lastPartA.length; i++) if (lastPartA[i] != type.charAt(i + lastIndex)) return false;\n\t\tString typeName = toQualifiedName(tn);\n\t\tTypeResolver resolver = node.getImportListAsTypeResolver();\n\t\treturn resolver.typeMatches(node, type, typeName);\n\t}\n\t\n\tpublic static void sanityCheckForMethodGeneratingAnnotationsOnBuilderClass(EclipseNode typeNode, EclipseNode errorNode) {\n\t\tList<String> disallowed = null;\n\t\tfor (EclipseNode child : typeNode.down()) {\n\t\t\tif (child.getKind() != Kind.ANNOTATION) continue;\n\t\t\tfor (String annType : INVALID_ON_BUILDERS) {\n\t\t\t\tif (annotationTypeMatches(annType, child)) {\n\t\t\t\t\tif (disallowed == null) disallowed = new ArrayList<String>();\n\t\t\t\t\tint lastIndex = annType.lastIndexOf('.');\n\t\t\t\t\tdisallowed.add(lastIndex == -1 ? annType : annType.substring(lastIndex + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint size = disallowed == null ? 0 : disallowed.size();\n\t\tif (size == 0) return;\n\t\tif (size == 1) {\n\t\t\terrorNode.addError(\"@\" + disallowed.get(0) + \" is not allowed on builder classes.\");\n\t\t\treturn;\n\t\t}\n\t\tStringBuilder out = new StringBuilder();\n\t\tfor (String a : disallowed) out.append(\"@\").append(a).append(\", \");\n\t\tout.setLength(out.length() - 2);\n\t\terrorNode.addError(out.append(\" are not allowed on builder classes.\").toString());\n\t}\n\t\n\tpublic static Annotation copyAnnotation(Annotation annotation, ASTNode source) {\n\t\tint pS = source.sourceStart, pE = source.sourceEnd;\n\t\t\n\t\tif (annotation instanceof MarkerAnnotation) {\n\t\t\tMarkerAnnotation ann = new MarkerAnnotation(copyType(annotation.type, source), pS);\n\t\t\tsetGeneratedBy(ann, source);\n\t\t\tann.declarationSourceEnd = ann.sourceEnd = ann.statementEnd = pE;\n\t\t\tcopyMemberValuePairName(ann, annotation);\n\t\t\treturn ann;\n\t\t}\n\t\t\n\t\tif (annotation instanceof SingleMemberAnnotation) {\n\t\t\tSingleMemberAnnotation ann = new SingleMemberAnnotation(copyType(annotation.type, source), pS);\n\t\t\tsetGeneratedBy(ann, source);\n\t\t\tann.declarationSourceEnd = ann.sourceEnd = ann.statementEnd = pE;\n\t\t\tann.memberValue = copyAnnotationMemberValue(((SingleMemberAnnotation) annotation).memberValue);\n\t\t\tcopyMemberValuePairName(ann, annotation);\n\t\t\treturn ann;\n\t\t}\n\t\t\n\t\tif (annotation instanceof NormalAnnotation) {\n\t\t\tNormalAnnotation ann = new NormalAnnotation(copyType(annotation.type, source), pS);\n\t\t\tsetGeneratedBy(ann, source);\n\t\t\tann.declarationSourceEnd = ann.statementEnd = ann.sourceEnd = pE;\n\t\t\tMemberValuePair[] inPairs = ((NormalAnnotation) annotation).memberValuePairs;\n\t\t\tif (inPairs == null) {\n\t\t\t\tann.memberValuePairs = null;\n\t\t\t} else {\n\t\t\t\tann.memberValuePairs = new MemberValuePair[inPairs.length];\n\t\t\t\tfor (int i = 0; i < inPairs.length; i++) ann.memberValuePairs[i] =\n\t\t\t\t\t\tnew MemberValuePair(inPairs[i].name, inPairs[i].sourceStart, inPairs[i].sourceEnd, copyAnnotationMemberValue(inPairs[i].value));\n\t\t\t}\n\t\t\tcopyMemberValuePairName(ann, annotation);\n\t\t\treturn ann;\n\t\t}\n\t\t\n\t\treturn annotation;\n\t}\n\t\n\tprivate static void copyMemberValuePairName(Annotation source, Annotation target) {\n\t\tif (ANNOTATION__MEMBER_VALUE_PAIR_NAME == null) return;\n\t\t\n\t\ttry {\n\t\t\treflectSet(ANNOTATION__MEMBER_VALUE_PAIR_NAME, source, reflect(ANNOTATION__MEMBER_VALUE_PAIR_NAME, target));\n\t\t} catch (Exception ignore) { /* Various eclipse versions don't have it */ }\n\t}\n\t\n\tstatic class EclipseReflectiveMembers {\n\t\tpublic static final Field STRING_LITERAL__LINE_NUMBER;\n\t\tpublic static final Field ANNOTATION__MEMBER_VALUE_PAIR_NAME;\n\t\tpublic static final Field TYPE_REFERENCE__ANNOTATIONS;\n\t\tpublic static final Class<?> INTERSECTION_BINDING1, INTERSECTION_BINDING2;\n\t\tpublic static final Field INTERSECTION_BINDING_TYPES1, INTERSECTION_BINDING_TYPES2;\n\t\tpublic static final Field TYPE_DECLARATION_RECORD_COMPONENTS;\n\t\tpublic static final Class<?> COMPILATION_UNIT;\n\t\tpublic static final Method COMPILATION_UNIT_ORIGINAL_FROM_CLONE;\n\t\tstatic {\n\t\t\tSTRING_LITERAL__LINE_NUMBER = getField(StringLiteral.class, \"lineNumber\");\n\t\t\tANNOTATION__MEMBER_VALUE_PAIR_NAME = getField(Annotation.class, \"memberValuePairName\");\n\t\t\tTYPE_REFERENCE__ANNOTATIONS = getField(TypeReference.class, \"annotations\");\n\t\t\tINTERSECTION_BINDING1 = getClass(\"org.eclipse.jdt.internal.compiler.lookup.IntersectionTypeBinding18\");\n\t\t\tINTERSECTION_BINDING2 = getClass(\"org.eclipse.jdt.internal.compiler.lookup.IntersectionCastTypeBinding\");\n\t\t\tINTERSECTION_BINDING_TYPES1 = INTERSECTION_BINDING1 == null ? null : getField(INTERSECTION_BINDING1, \"intersectingTypes\");\n\t\t\tINTERSECTION_BINDING_TYPES2 = INTERSECTION_BINDING2 == null ? null : getField(INTERSECTION_BINDING2, \"intersectingTypes\");\n\t\t\tTYPE_DECLARATION_RECORD_COMPONENTS = getField(TypeDeclaration.class, \"recordComponents\");\n\t\t\tCOMPILATION_UNIT = getClass(\"org.eclipse.jdt.internal.core.CompilationUnit\");\n\t\t\tCOMPILATION_UNIT_ORIGINAL_FROM_CLONE = COMPILATION_UNIT == null ? null : Permit.permissiveGetMethod(COMPILATION_UNIT, \"originalFromClone\");\n\t\t}\n\t\t\n\t\tpublic static int reflectInt(Field f, Object o) {\n\t\t\ttry {\n\t\t\t\treturn ((Number) f.get(o)).intValue();\n\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static void reflectSet(Field f, Object o, Object v) {\n\t\t\ttry {\n\t\t\t\tf.set(o, v);\n\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static Object reflect(Field f, Object o) {\n\t\t\ttry {\n\t\t\t\treturn f.get(o);\n\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprivate static Class<?> getClass(String fqn) {\n\t\t\ttry {\n\t\t\t\treturn Class.forName(fqn);\n\t\t\t} catch (Throwable t) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\t\n\t\tprivate static Field getField(Class<?> c, String fName) {\n\t\t\ttry {\n\t\t\t\treturn Permit.getField(c, fName);\n\t\t\t} catch (Throwable t) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static Expression copyAnnotationMemberValue(Expression in) {\n\t\tExpression out = copyAnnotationMemberValue0(in);\n\t\tout.constant = in.constant;\n\t\treturn out;\n\t}\n\t\n\tprivate static Expression copyAnnotationMemberValue0(Expression in) {\n\t\tint s = in.sourceStart, e = in.sourceEnd;\n\t\t\n\t\t// literals\n\t\t\n\t\tif (in instanceof FalseLiteral) return new FalseLiteral(s, e);\n\t\tif (in instanceof TrueLiteral) return new TrueLiteral(s, e);\n\t\tif (in instanceof NullLiteral) return new NullLiteral(s, e);\n\t\t\n\t\tif (in instanceof CharLiteral) return new CharLiteral(((Literal) in).source(), s, e);\n\t\tif (in instanceof DoubleLiteral) return new DoubleLiteral(((Literal) in).source(), s, e);\n\t\tif (in instanceof FloatLiteral) return new FloatLiteral(((Literal) in).source(), s, e);\n\t\tif (in instanceof IntLiteral) return IntLiteral.buildIntLiteral(((Literal) in).source(), s, e);\n\t\tif (in instanceof LongLiteral) return LongLiteral.buildLongLiteral(((Literal) in).source(), s, e);\n\t\t\n\t\tif (in instanceof StringLiteral) return new StringLiteral(((Literal) in).source(), s, e, reflectInt(STRING_LITERAL__LINE_NUMBER, in) + 1);\n\t\tif (in instanceof ExtendedStringLiteral) {\n\t\t\tStringLiteral str = new StringLiteral(((Literal) in).source(), s, e, reflectInt(STRING_LITERAL__LINE_NUMBER, in) + 1);\n\t\t\tStringLiteral empty = new StringLiteral(new char[0], s, e, reflectInt(STRING_LITERAL__LINE_NUMBER, in) + 1);\n\t\t\treturn new ExtendedStringLiteral(str, empty);\n\t\t}\n\t\tif (in instanceof StringLiteralConcatenation) {\n\t\t\tExpression[] literals = ((StringLiteralConcatenation) in).literals;\n\t\t\t// 0 and 1 len shouldn't happen.\n\t\t\tif (literals.length == 0) return new StringLiteral(new char[0], s, e, 0);\n\t\t\tif (literals.length == 1) return copyAnnotationMemberValue0(literals[0]);\n\t\t\tStringLiteralConcatenation c = new StringLiteralConcatenation((StringLiteral) literals[0], (StringLiteral) literals[1]);\n\t\t\tfor (int i = 2; i < literals.length; i++) c = c.extendsWith((StringLiteral) literals[i]);\n\t\t\treturn c;\n\t\t}\n\t\t\n\t\t// enums and field accesses (as long as those are references to compile time constant literals that's also acceptable)\n\t\t\n\t\tif (in instanceof SingleNameReference) {\n\t\t\tSingleNameReference snr = (SingleNameReference) in;\n\t\t\treturn new SingleNameReference(snr.token, pos(in));\n\t\t}\n\t\tif (in instanceof QualifiedNameReference) {\n\t\t\tQualifiedNameReference qnr = (QualifiedNameReference) in;\n\t\t\treturn new QualifiedNameReference(qnr.tokens, poss(in, qnr.tokens.length), s, e);\n\t\t}\n\t\t\n\t\t// class refs\n\t\tif (in instanceof ClassLiteralAccess) return new ClassLiteralAccess(e, copyType(((ClassLiteralAccess) in).type));\n\t\t\n\t\t// arrays\n\t\tif (in instanceof ArrayInitializer) {\n\t\t\tExpression[] exprs = ((ArrayInitializer) in).expressions;\n\t\t\tExpression[] copy = new Expression[exprs.length];\n\t\t\tfor (int i = 0; i < exprs.length; i++) copy[i] = copyAnnotationMemberValue(exprs[i]);\n\t\t\tArrayInitializer out = new ArrayInitializer();\n\t\t\tout.sourceStart = s;\n\t\t\tout.sourceEnd = e;\n\t\t\tout.bits = in.bits;\n\t\t\tout.implicitConversion = in.implicitConversion;\n\t\t\tout.statementEnd = e;\n\t\t\tout.expressions = copy;\n\t\t\treturn out;\n\t\t}\n\t\t\n\t\tif (in instanceof BinaryExpression) {\n\t\t\tBinaryExpression be = (BinaryExpression) in;\n\t\t\tBinaryExpression out = new BinaryExpression(be);\n\t\t\tout.left = copyAnnotationMemberValue(be.left);\n\t\t\tout.right = copyAnnotationMemberValue(be.right);\n\t\t\tout.sourceStart = s;\n\t\t\tout.sourceEnd = e;\n\t\t\tout.statementEnd = e;\n\t\t\treturn out;\n\t\t}\n\t\t\n\t\treturn in;\n\t}\n\t\n\t/**\n\t * You can't share TypeParameter objects or bad things happen; for example, one 'T' resolves differently\n\t * from another 'T', even for the same T in a single class file. Unfortunately the TypeParameter type hierarchy\n\t * is complicated and there's no clone method on TypeParameter itself. This method can clone them.\n\t */\n\tpublic static TypeParameter[] copyTypeParams(TypeParameter[] params, ASTNode source) {\n\t\tif (params == null) return null;\n\t\tTypeParameter[] out = new TypeParameter[params.length];\n\t\tint idx = 0;\n\t\tfor (TypeParameter param : params) {\n\t\t\tTypeParameter o = new TypeParameter();\n\t\t\tsetGeneratedBy(o, source);\n\t\t\to.annotations = param.annotations;\n\t\t\to.bits = param.bits;\n\t\t\to.modifiers = param.modifiers;\n\t\t\to.name = param.name;\n\t\t\to.type = copyType(param.type, source);\n\t\t\to.sourceStart = param.sourceStart;\n\t\t\to.sourceEnd = param.sourceEnd;\n\t\t\to.declarationEnd = param.declarationEnd;\n\t\t\to.declarationSourceStart = param.declarationSourceStart;\n\t\t\to.declarationSourceEnd = param.declarationSourceEnd;\n\t\t\tif (param.bounds != null) {\n\t\t\t\tTypeReference[] b = new TypeReference[param.bounds.length];\n\t\t\t\tint idx2 = 0;\n\t\t\t\tfor (TypeReference ref : param.bounds) b[idx2++] = copyType(ref, source);\n\t\t\t\to.bounds = b;\n\t\t\t}\n\t\t\tout[idx++] = o;\n\t\t}\n\t\treturn out;\n\t}\n\t\n\tpublic static Annotation[] getTypeUseAnnotations(TypeReference from) {\n\t\tAnnotation[][] a;\n\t\ttry {\n\t\t\ta = (Annotation[][]) reflect(TYPE_REFERENCE__ANNOTATIONS, from);\n\t\t} catch (Exception e) {\n\t\t\treturn null;\n\t\t}\n\t\tif (a == null) return null;\n\t\tAnnotation[] b = a[a.length - 1];\n\t\treturn b.length == 0 ? null : b;\n\t}\n\t\n\tpublic static void removeTypeUseAnnotations(TypeReference from) {\n\t\ttry {\n\t\t\treflectSet(TYPE_REFERENCE__ANNOTATIONS, from, null);\n\t\t} catch (Exception ignore) {}\n\t}\n\t\n\tpublic static TypeReference namePlusTypeParamsToTypeReference(EclipseNode type, TypeParameter[] params, long p) {\n\t\tTypeDeclaration td = (TypeDeclaration) type.get();\n\t\tboolean instance = (td.modifiers & MODIFIERS_INDICATING_STATIC) == 0;\n\t\treturn namePlusTypeParamsToTypeReference(type.up(), td.name, instance, params, p);\n\t}\n\t\n\tpublic static TypeReference namePlusTypeParamsToTypeReference(EclipseNode parentType, char[] typeName, boolean instance, TypeParameter[] params, long p) {\n\t\tif (params != null && params.length > 0) {\n\t\t\tTypeReference[] refs = new TypeReference[params.length];\n\t\t\tint idx = 0;\n\t\t\tfor (TypeParameter param : params) {\n\t\t\t\tTypeReference typeRef = new SingleTypeReference(param.name, p);\n\t\t\t\trefs[idx++] = typeRef;\n\t\t\t}\n\t\t\treturn generateParameterizedTypeReference(parentType, typeName, instance, refs, p);\n\t\t}\n\t\t\n\t\treturn generateTypeReference(parentType, typeName, instance, p);\n\t}\n\t\n\tpublic static TypeReference[] copyTypes(TypeReference[] refs) {\n\t\treturn copyTypes(refs, null);\n\t}\n\t\n\t/**\n\t * Convenience method that creates a new array and copies each TypeReference in the source array via\n\t * {@link #copyType(TypeReference, ASTNode)}.\n\t */\n\tpublic static TypeReference[] copyTypes(TypeReference[] refs, ASTNode source) {\n\t\tif (refs == null) return null;\n\t\tTypeReference[] outs = new TypeReference[refs.length];\n\t\tint idx = 0;\n\t\tfor (TypeReference ref : refs) {\n\t\t\touts[idx++] = copyType(ref, source);\n\t\t}\n\t\treturn outs;\n\t}\n\t\n\tpublic static TypeReference copyType(TypeReference ref) {\n\t\treturn copyType(ref, null);\n\t}\n\t\n\t/**\n\t * You can't share TypeReference objects or subtle errors start happening.\n\t * Unfortunately the TypeReference type hierarchy is complicated and there's no clone\n\t * method on TypeReference itself. This method can clone them.\n\t */\n\tpublic static TypeReference copyType(TypeReference ref, ASTNode source) {\n\t\tif (ref instanceof ParameterizedQualifiedTypeReference) {\n\t\t\tParameterizedQualifiedTypeReference iRef = (ParameterizedQualifiedTypeReference) ref;\n\t\t\tTypeReference[][] args = null;\n\t\t\tif (iRef.typeArguments != null) {\n\t\t\t\targs = new TypeReference[iRef.typeArguments.length][];\n\t\t\t\tint idx = 0;\n\t\t\t\tfor (TypeReference[] inRefArray : iRef.typeArguments) {\n\t\t\t\t\tif (inRefArray == null) args[idx++] = null;\n\t\t\t\t\telse {\n\t\t\t\t\t\tTypeReference[] outRefArray = new TypeReference[inRefArray.length];\n\t\t\t\t\t\tint idx2 = 0;\n\t\t\t\t\t\tfor (TypeReference inRef : inRefArray) {\n\t\t\t\t\t\t\toutRefArray[idx2++] = copyType(inRef, source);\n\t\t\t\t\t\t}\n\t\t\t\t\t\targs[idx++] = outRefArray;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tTypeReference typeRef = new ParameterizedQualifiedTypeReference(iRef.tokens, args, iRef.dimensions(), copy(iRef.sourcePositions));\n\t\t\tcopyTypeAnns(ref, typeRef);\n\t\t\tif (source != null) setGeneratedBy(typeRef, source);\n\t\t\treturn typeRef;\n\t\t}\n\t\t\n\t\tif (ref instanceof ArrayQualifiedTypeReference) {\n\t\t\tArrayQualifiedTypeReference iRef = (ArrayQualifiedTypeReference) ref;\n\t\t\tTypeReference typeRef = new ArrayQualifiedTypeReference(iRef.tokens, iRef.dimensions(), copy(iRef.sourcePositions));\n\t\t\tcopyTypeAnns(ref, typeRef);\n\t\t\tif (source != null) setGeneratedBy(typeRef, source);\n\t\t\treturn typeRef;\n\t\t}\n\t\t\n\t\tif (ref instanceof QualifiedTypeReference) {\n\t\t\tQualifiedTypeReference iRef = (QualifiedTypeReference) ref;\n\t\t\tTypeReference typeRef = new QualifiedTypeReference(iRef.tokens, copy(iRef.sourcePositions));\n\t\t\tcopyTypeAnns(ref, typeRef);\n\t\t\tif (source != null) setGeneratedBy(typeRef, source);\n\t\t\treturn typeRef;\n\t\t}\n\t\t\n\t\tif (ref instanceof ParameterizedSingleTypeReference) {\n\t\t\tParameterizedSingleTypeReference iRef = (ParameterizedSingleTypeReference) ref;\n\t\t\tTypeReference[] args = null;\n\t\t\tif (iRef.typeArguments != null) {\n\t\t\t\targs = new TypeReference[iRef.typeArguments.length];\n\t\t\t\tint idx = 0;\n\t\t\t\tfor (TypeReference inRef : iRef.typeArguments) {\n\t\t\t\t\tif (inRef == null) args[idx++] = null;\n\t\t\t\t\telse args[idx++] = copyType(inRef, source);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tTypeReference typeRef = new ParameterizedSingleTypeReference(iRef.token, args, iRef.dimensions(), (long) iRef.sourceStart << 32 | iRef.sourceEnd);\n\t\t\tcopyTypeAnns(ref, typeRef);\n\t\t\tif (source != null) setGeneratedBy(typeRef, source);\n\t\t\treturn typeRef;\n\t\t}\n\t\t\n\t\tif (ref instanceof ArrayTypeReference) {\n\t\t\tArrayTypeReference iRef = (ArrayTypeReference) ref;\n\t\t\tTypeReference typeRef = new ArrayTypeReference(iRef.token, iRef.dimensions(), (long) iRef.sourceStart << 32 | iRef.sourceEnd);\n\t\t\tcopyTypeAnns(ref, typeRef);\n\t\t\tif (source != null) setGeneratedBy(typeRef, source);\n\t\t\treturn typeRef;\n\t\t}\n\t\t\n\t\tif (ref instanceof Wildcard) {\n\t\t\tWildcard original = (Wildcard) ref;\n\t\t\t\n\t\t\tWildcard wildcard = new Wildcard(original.kind);\n\t\t\twildcard.sourceStart = original.sourceStart;\n\t\t\twildcard.sourceEnd = original.sourceEnd;\n\t\t\tif (original.bound != null) wildcard.bound = copyType(original.bound, source);\n\t\t\tcopyTypeAnns(ref, wildcard);\n\t\t\tif (source != null) setGeneratedBy(wildcard, source);\n\t\t\treturn wildcard;\n\t\t}\n\t\t\n\t\tif (ref instanceof SingleTypeReference) {\n\t\t\tSingleTypeReference iRef = (SingleTypeReference) ref;\n\t\t\tTypeReference typeRef = new SingleTypeReference(iRef.token, (long) iRef.sourceStart << 32 | iRef.sourceEnd);\n\t\t\tcopyTypeAnns(ref, typeRef);\n\t\t\tif (source != null) setGeneratedBy(typeRef, source);\n\t\t\treturn typeRef;\n\t\t}\n\t\t\n\t\treturn ref;\n\t}\n\t\n\tprivate static void copyTypeAnns(TypeReference in, TypeReference out) {\n\t\tAnnotation[][] a;\n\t\ttry {\n\t\t\ta = (Annotation[][]) reflect(TYPE_REFERENCE__ANNOTATIONS, in);\n\t\t} catch (Exception e) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (a == null) {\n\t\t\treflectSet(TYPE_REFERENCE__ANNOTATIONS, out, null);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tAnnotation[][] b = new Annotation[a.length][];\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tif (a[i] != null) {\n\t\t\t\tb[i] = new Annotation[a[i].length];\n\t\t\t\tfor (int j = 0 ; j < a[i].length; j++) {\n\t\t\t\t\tb[i][j] = copyAnnotation(a[i][j], a[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treflectSet(TYPE_REFERENCE__ANNOTATIONS, out, b);\n\t}\n\t\n\tpublic static Annotation[] copyAnnotations(ASTNode source, Annotation[]... allAnnotations) {\n\t\tList<Annotation> result = null;\n\t\tfor (Annotation[] annotations : allAnnotations) {\n\t\t\tif (annotations != null) {\n\t\t\t\tfor (Annotation annotation : annotations) {\n\t\t\t\t\tif (result == null) result = new ArrayList<Annotation>();\n\t\t\t\t\tresult.add(copyAnnotation(annotation, source));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result == null ? null : result.toArray(new Annotation[0]);\n\t}\n\t\n\tpublic static boolean hasAnnotation(Class<? extends java.lang.annotation.Annotation> type, EclipseNode node) {\n\t\tif (node == null) return false;\n\t\tif (type == null) return false;\n\t\tswitch (node.getKind()) {\n\t\tcase ARGUMENT:\n\t\tcase FIELD:\n\t\tcase LOCAL:\n\t\tcase TYPE:\n\t\tcase METHOD:\n\t\t\tfor (EclipseNode child : node.down()) {\n\t\t\t\tif (annotationTypeMatches(type, child)) return true;\n\t\t\t}\n\t\t\t// intentional fallthrough\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tpublic static boolean hasAnnotation(String type, EclipseNode node) {\n\t\tif (node == null) return false;\n\t\tif (type == null) return false;\n\t\tswitch (node.getKind()) {\n\t\tcase ARGUMENT:\n\t\tcase FIELD:\n\t\tcase LOCAL:\n\t\tcase TYPE:\n\t\tcase METHOD:\n\t\t\tfor (EclipseNode child : node.down()) {\n\t\t\t\tif (annotationTypeMatches(type, child)) return true;\n\t\t\t}\n\t\t\t// intentional fallthrough\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tpublic static EclipseNode findInnerClass(EclipseNode parent, String name) {\n\t\tchar[] c = name.toCharArray();\n\t\tfor (EclipseNode child : parent.down()) {\n\t\t\tif (child.getKind() != Kind.TYPE) continue;\n\t\t\tTypeDeclaration td = (TypeDeclaration) child.get();\n\t\t\tif (Arrays.equals(td.name, c)) return child;\n\t\t}\n\t\treturn null;\n\t}\n\t\n\tpublic static EclipseNode findAnnotation(Class<? extends java.lang.annotation.Annotation> type, EclipseNode node) {\n\t\tif (node == null) return null;\n\t\tif (type == null) return null;\n\t\tswitch (node.getKind()) {\n\t\tcase ARGUMENT:\n\t\tcase FIELD:\n\t\tcase LOCAL:\n\t\tcase TYPE:\n\t\tcase METHOD:\n\t\t\tfor (EclipseNode child : node.down()) {\n\t\t\t\tif (annotationTypeMatches(type, child)) return child;\n\t\t\t}\n\t\t\t// intentional fallthrough\n\t\tdefault:\n\t\t\treturn null;\n\t\t}\n\t}\n\t\n\tpublic static String scanForNearestAnnotation(EclipseNode node, String... anns) {\n\t\twhile (node != null) {\n\t\t\tfor (EclipseNode ann : node.down()) {\n\t\t\t\tif (ann.getKind() != Kind.ANNOTATION) continue;\n\t\t\t\tAnnotation a = (Annotation) ann.get();\n\t\t\t\tTypeReference aType = a.type;\n\t\t\t\tfor (String annToFind : anns) if (typeMatches(annToFind, node, aType)) return annToFind;\n\t\t\t}\n\t\t\tnode = node.up();\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\t\n\tpublic static boolean hasNonNullAnnotations(EclipseNode node) {\n\t\tfor (EclipseNode child : node.down()) {\n\t\t\tif (child.getKind() != Kind.ANNOTATION) continue;\n\t\t\tAnnotation annotation = (Annotation) child.get();\n\t\t\tfor (String bn : NONNULL_ANNOTATIONS) if (typeMatches(bn, node, annotation.type)) return true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic static boolean hasNonNullAnnotations(EclipseNode node, List<Annotation> anns) {\n\t\tif (anns == null) return false;\n\t\tfor (Annotation annotation : anns) {\n\t\t\tTypeReference typeRef = annotation.type;\n\t\t\tif (typeRef != null && typeRef.getTypeName() != null) {\n\t\t\t\tfor (String bn : NONNULL_ANNOTATIONS) if (typeMatches(bn, node, typeRef)) return true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tprivate static final Annotation[] EMPTY_ANNOTATIONS_ARRAY = new Annotation[0];\n\t\n\t/**\n\t * Searches the given field node for annotations and returns each one that is 'copyable' (either via configuration or from the base list).\n\t */\n\tpublic static Annotation[] findCopyableAnnotations(EclipseNode node) {\n\t\tAbstractVariableDeclaration avd = (AbstractVariableDeclaration) node.get();\n\t\tif (avd.annotations == null) return EMPTY_ANNOTATIONS_ARRAY;\n\t\tList<Annotation> result = new ArrayList<Annotation>();\n\t\tList<TypeName> configuredCopyable = node.getAst().readConfiguration(ConfigurationKeys.COPYABLE_ANNOTATIONS);\n\t\t\n\t\tfor (Annotation annotation : avd.annotations) {\n\t\t\tTypeReference typeRef = annotation.type;\n\t\t\tboolean match = false;\n\t\t\tif (typeRef != null && typeRef.getTypeName() != null) {\n\t\t\t\tfor (TypeName cn : configuredCopyable) if (cn != null && typeMatches(cn.toString(), node, typeRef)) {\n\t\t\t\t\tresult.add(annotation);\n\t\t\t\t\tmatch = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!match) for (String bn : BASE_COPYABLE_ANNOTATIONS) if (typeMatches(bn, node, typeRef)) {\n\t\t\t\t\tresult.add(annotation);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result.toArray(EMPTY_ANNOTATIONS_ARRAY);\n\t}\n\t\n\t/**\n\t * Searches the given field node for annotations that are specifically intentioned to be copied to the setter.\n\t */\n\tpublic static Annotation[] findCopyableToSetterAnnotations(EclipseNode node) {\n\t\treturn findAnnotationsInList(node, COPY_TO_SETTER_ANNOTATIONS);\n\t}\n\n\t/**\n\t * Searches the given field node for annotations that are specifically intentioned to be copied to the builder's singular method.\n\t */\n\tpublic static Annotation[] findCopyableToBuilderSingularSetterAnnotations(EclipseNode node) {\n\t\treturn findAnnotationsInList(node, COPY_TO_BUILDER_SINGULAR_SETTER_ANNOTATIONS);\n\t}\n\t\n\t/**\n\t * Searches the given field node for annotations that are in the given list, and returns those.\n\t */\n\tprivate static Annotation[] findAnnotationsInList(EclipseNode node, java.util.List<String> annotationsToFind) {\n\t\tAbstractVariableDeclaration avd = (AbstractVariableDeclaration) node.get();\n\t\tif (avd.annotations == null) return EMPTY_ANNOTATIONS_ARRAY;\n\t\tList<Annotation> result = new ArrayList<Annotation>();\n\t\t\n\t\tfor (Annotation annotation : avd.annotations) {\n\t\t\tTypeReference typeRef = annotation.type;\n\t\t\tif (typeRef != null && typeRef.getTypeName() != null) {\n\t\t\t\tfor (String bn : annotationsToFind) if (typeMatches(bn, node, typeRef)) {\n\t\t\t\t\tresult.add(annotation);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result.toArray(EMPTY_ANNOTATIONS_ARRAY);\n\t}\n\t\n\t/**\n\t * Checks if the provided annotation type is likely to be the intended type for the given annotation node.\n\t * \n\t * This is a guess, but a decent one.\n\t */\n\tpublic static boolean annotationTypeMatches(Class<? extends java.lang.annotation.Annotation> type, EclipseNode node) {\n\t\tif (node.getKind() != Kind.ANNOTATION) return false;\n\t\treturn typeMatches(type, node, ((Annotation) node.get()).type);\n\t}\n\t\n\t/**\n\t * Checks if the provided annotation type is likely to be the intended type for the given annotation node.\n\t * \n\t * This is a guess, but a decent one.\n\t */\n\tpublic static boolean annotationTypeMatches(String type, EclipseNode node) {\n\t\tif (node.getKind() != Kind.ANNOTATION) return false;\n\t\treturn typeMatches(type, node, ((Annotation) node.get()).type);\n\t}\n\t\n\tpublic static TypeReference cloneSelfType(EclipseNode context) {\n\t\treturn cloneSelfType(context, null);\n\t}\n\t\n\tpublic static TypeReference cloneSelfType(EclipseNode context, ASTNode source) {\n\t\tint pS = source == null ? 0 : source.sourceStart, pE = source == null ? 0 : source.sourceEnd;\n\t\tlong p = (long) pS << 32 | pE;\n\t\tEclipseNode type = context;\n\t\tTypeReference result = null;\n\t\twhile (type != null && type.getKind() != Kind.TYPE) type = type.up();\n\t\tif (type != null && type.get() instanceof TypeDeclaration) {\n\t\t\tTypeDeclaration typeDecl = (TypeDeclaration) type.get();\n\t\t\tif (typeDecl.typeParameters != null && typeDecl.typeParameters.length > 0) {\n\t\t\t\tTypeReference[] refs = new TypeReference[typeDecl.typeParameters.length];\n\t\t\t\tint idx = 0;\n\t\t\t\tfor (TypeParameter param : typeDecl.typeParameters) {\n\t\t\t\t\tTypeReference typeRef = new SingleTypeReference(param.name, (long)param.sourceStart << 32 | param.sourceEnd);\n\t\t\t\t\tif (source != null) setGeneratedBy(typeRef, source);\n\t\t\t\t\trefs[idx++] = typeRef;\n\t\t\t\t}\n\t\t\t\tresult = generateParameterizedTypeReference(type, refs, p);\n\t\t\t} else {\n\t\t\t\tresult = generateTypeReference(type, p);\n\t\t\t}\n\t\t}\n\t\tif (result != null && source != null) setGeneratedBy(result, source);\n\t\treturn result;\n\t}\n\t\n\tpublic static TypeReference generateParameterizedTypeReference(EclipseNode type, TypeReference[] typeParams, long p) {\n\t\tTypeDeclaration td = (TypeDeclaration) type.get();\n\t\tchar[][] tn = getQualifiedInnerName(type.up(), td.name);\n\t\tif (tn.length == 1) return new ParameterizedSingleTypeReference(tn[0], typeParams, 0, p);\n\t\tint tnLen = tn.length;\n\t\tlong[] ps = new long[tnLen];\n\t\tfor (int i = 0; i < tnLen; i++) ps[i] = p;\n\t\tTypeReference[][] rr = new TypeReference[tnLen][];\n\t\trr[tnLen - 1] = typeParams;\n\t\tboolean instance = (td.modifiers & MODIFIERS_INDICATING_STATIC) == 0;\n\t\tif (instance) fillOuterTypeParams(rr, tnLen - 2, type.up(), p);\n\t\treturn new ParameterizedQualifiedTypeReference(tn, rr, 0, ps);\n\t}\n\t\n\tpublic static TypeReference generateParameterizedTypeReference(EclipseNode parent, char[] name, boolean instance, TypeReference[] typeParams, long p) {\n\t\tchar[][] tn = getQualifiedInnerName(parent, name);\n\t\tif (tn.length == 1) return new ParameterizedSingleTypeReference(tn[0], typeParams, 0, p);\n\t\tint tnLen = tn.length;\n\t\tlong[] ps = new long[tnLen];\n\t\tfor (int i = 0; i < tnLen; i++) ps[i] = p;\n\t\tTypeReference[][] rr = new TypeReference[tnLen][];\n\t\trr[tnLen - 1] = typeParams;\n\t\tif (instance) fillOuterTypeParams(rr, tnLen - 2, parent, p);\n\t\treturn new ParameterizedQualifiedTypeReference(tn, rr, 0, ps);\n\t}\n\t\n\tprivate static final int MODIFIERS_INDICATING_STATIC = ClassFileConstants.AccInterface | ClassFileConstants.AccStatic | ClassFileConstants.AccEnum;\n\t\n\t/**\n\t * This class will add type params to fully qualified chain of type references for inner types, such as {@code GrandParent.Parent.Child}; this is needed only as long as the chain does not involve static.\n\t * \n\t * @return {@code true} if at least one parameterization is actually added, {@code false} otherwise.\n\t */\n\tprivate static boolean fillOuterTypeParams(TypeReference[][] rr, int idx, EclipseNode node, long p) {\n\t\tif (idx < 0 || node == null || !(node.get() instanceof TypeDeclaration)) return false;\n\t\tboolean filled = false;\n\t\tTypeDeclaration td = (TypeDeclaration) node.get();\n\t\tif (0 != (td.modifiers & (ClassFileConstants.AccInterface | ClassFileConstants.AccEnum))) {\n\t\t\t// any class defs inside an enum or interface are static, even if not marked as such.\n\t\t\treturn false;\n\t\t}\n\t\tTypeParameter[] tps = td.typeParameters;\n\t\tif (tps != null && tps.length > 0) {\n\t\t\tTypeReference[] trs = new TypeReference[tps.length];\n\t\t\tfor (int i = 0; i < tps.length; i++) {\n\t\t\t\ttrs[i] = new SingleTypeReference(tps[i].name, p);\n\t\t\t}\n\t\t\trr[idx] = trs;\n\t\t\tfilled = true;\n\t\t}\n\t\t\n\t\tif ((td.modifiers & MODIFIERS_INDICATING_STATIC) != 0) return filled; // Once we hit a static class, no further typeparams needed.\n\t\tboolean f2 = fillOuterTypeParams(rr, idx - 1, node.up(), p);\n\t\treturn f2 || filled;\n\t}\n\t\n\tpublic static NameReference generateNameReference(EclipseNode type, long p) {\n\t\tchar[][] tn = getQualifiedInnerName(type.up(), ((TypeDeclaration) type.get()).name);\n\t\tif (tn.length == 1) return new SingleNameReference(tn[0], p);\n\t\tint tnLen = tn.length;\n\t\tlong[] ps = new long[tnLen];\n\t\tfor (int i = 0; i < tnLen; i++) ps[i] = p;\n\t\tint ss = (int) (p >> 32);\n\t\tint se = (int) p;\n\t\treturn new QualifiedNameReference(tn, ps, ss, se);\n\t}\n\t\n\tpublic static NameReference generateNameReference(EclipseNode parent, char[] name, long p) {\n\t\tchar[][] tn = getQualifiedInnerName(parent, name);\n\t\tif (tn.length == 1) return new SingleNameReference(tn[0], p);\n\t\tint tnLen = tn.length;\n\t\tlong[] ps = new long[tnLen];\n\t\tfor (int i = 0; i < tnLen; i++) ps[i] = p;\n\t\tint ss = (int) (p >> 32);\n\t\tint se = (int) p;\n\t\treturn new QualifiedNameReference(tn, ps, ss, se);\n\t}\n\t\n\tpublic static TypeReference generateTypeReference(EclipseNode type, long p) {\n\t\tTypeDeclaration td = (TypeDeclaration) type.get();\n\t\tchar[][] tn = getQualifiedInnerName(type.up(), td.name);\n\t\tif (tn.length == 1) return new SingleTypeReference(tn[0], p);\n\t\tint tnLen = tn.length;\n\t\tlong[] ps = new long[tnLen];\n\t\tfor (int i = 0; i < tnLen; i++) ps[i] = p;\n\t\t\n\t\t\n\t\tboolean instance = (td.modifiers & MODIFIERS_INDICATING_STATIC) == 0 && type.up() != null && type.up().get() instanceof TypeDeclaration;\n\t\tif (instance) {\n\t\t\tTypeReference[][] trs = new TypeReference[tn.length][];\n\t\t\tboolean filled = fillOuterTypeParams(trs, trs.length - 2, type.up(), p);\n\t\t\tif (filled) return new ParameterizedQualifiedTypeReference(tn, trs, 0, ps);\n\t\t}\n\t\t\n\t\treturn new QualifiedTypeReference(tn, ps);\n\t}\n\t\n\tpublic static TypeReference generateTypeReference(EclipseNode parent, char[] name, boolean instance, long p) {\n\t\tchar[][] tn = getQualifiedInnerName(parent, name);\n\t\tif (tn.length == 1) return new SingleTypeReference(tn[0], p);\n\t\tint tnLen = tn.length;\n\t\tlong[] ps = new long[tnLen];\n\t\tfor (int i = 0; i < tnLen; i++) ps[i] = p;\n\t\t\n\t\tif (instance && parent != null && parent.get() instanceof TypeDeclaration) {\n\t\t\tTypeReference[][] trs = new TypeReference[tn.length][];\n\t\t\tif (fillOuterTypeParams(trs, tn.length - 2, parent, p)) return new ParameterizedQualifiedTypeReference(tn, trs, 0, ps);\n\t\t}\n\t\t\n\t\treturn new QualifiedTypeReference(tn, ps);\n\t}\n\t\n\t/**\n\t * Generate a chain of names for the enclosing classes.\n\t * \n\t * Given for example {@code class Outer { class Inner {} }} this would generate {@code char[][] { \"Outer\", \"Inner\" }}.\n\t * For method local and top level types, this generates a size-1 char[][] where the only char[] element is {@code name} itself.\n\t */\n\tpublic static char[][] getQualifiedInnerName(EclipseNode parent, char[] name) {\n\t\tint count = 0;\n\t\t\n\t\tEclipseNode n = parent;\n\t\twhile (n != null && n.getKind() == Kind.TYPE && n.get() instanceof TypeDeclaration) {\n\t\t\tTypeDeclaration td = (TypeDeclaration) n.get();\n\t\t\tif (td.name == null || td.name.length == 0) break;\n\t\t\tcount++;\n\t\t\tn = n.up();\n\t\t}\n\t\t\n\t\tif (count == 0) return new char[][] { name };\n\t\tchar[][] res = new char[count + 1][];\n\t\tres[count] = name;\n\t\t\n\t\tn = parent;\n\t\twhile (count > 0) {\n\t\t\tTypeDeclaration td = (TypeDeclaration) n.get();\n\t\t\tres[--count] = td.name;\n\t\t\tn = n.up();\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n\t\n\tprivate static final char[] OBJECT_SIG = \"Ljava/lang/Object;\".toCharArray();\n\t\n\tprivate static int compare(char[] a, char[] b) {\n\t\tif (a == null) return b == null ? 0 : -1;\n\t\tif (b == null) return +1;\n\t\tint len = Math.min(a.length, b.length);\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tif (a[i] < b[i]) return -1;\n\t\t\tif (a[i] > b[i]) return +1;\n\t\t}\n\t\treturn a.length < b.length ? -1 : a.length > b.length ? +1 : 0;\n\t}\n\t\n\tpublic static TypeReference makeType(TypeBinding binding, ASTNode pos, boolean allowCompound) {\n\t\tObject[] arr = null;\n\t\tif (binding.getClass() == EclipseReflectiveMembers.INTERSECTION_BINDING1) {\n\t\t\tarr = (Object[]) EclipseReflectiveMembers.reflect(EclipseReflectiveMembers.INTERSECTION_BINDING_TYPES1, binding);\n\t\t} else if (binding.getClass() == EclipseReflectiveMembers.INTERSECTION_BINDING2) {\n\t\t\tarr = (Object[]) EclipseReflectiveMembers.reflect(EclipseReflectiveMembers.INTERSECTION_BINDING_TYPES2, binding);\n\t\t}\n\t\t\n\t\tif (arr != null) {\n\t\t\t// Is there a class? Alphabetically lowest wins.\n\t\t\tTypeBinding winner = null;\n\t\t\tint winLevel = 0; // 100 = array, 50 = class, 20 = typevar, 15 = wildcard, 10 = interface, 1 = Object.\n\t\t\tfor (Object b : arr) {\n\t\t\t\tif (b instanceof TypeBinding) {\n\t\t\t\t\tTypeBinding tb = (TypeBinding) b;\n\t\t\t\t\tint level = 0;\n\t\t\t\t\tif (tb.isArrayType()) level = 100;\n\t\t\t\t\telse if (tb.isClass()) level = 50;\n\t\t\t\t\telse if (tb.isTypeVariable()) level = 20;\n\t\t\t\t\telse if (tb.isWildcard()) level = 15;\n\t\t\t\t\telse level = 10;\n\t\t\t\t\t\n\t\t\t\t\tif (level == 50 && compare(tb.signature(), OBJECT_SIG) == 0) level = 1;\n\t\t\t\t\t\n\t\t\t\t\tif (winLevel > level) continue;\n\t\t\t\t\tif (winLevel < level) {\n\t\t\t\t\t\twinner = tb;\n\t\t\t\t\t\twinLevel = level;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (compare(winner.signature(), tb.signature()) > 0) winner = tb;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbinding = winner;\n\t\t}\n\t\tint dims = binding.dimensions();\n\t\tbinding = binding.leafComponentType();\n\t\t\n\t\t// Primitives\n\t\t\n\t\tchar[] base = null;\n\t\t\n\t\tswitch (binding.id) {\n\t\tcase TypeIds.T_int:\n\t\t\tbase = TypeConstants.INT;\n\t\t\tbreak;\n\t\tcase TypeIds.T_long:\n\t\t\tbase = TypeConstants.LONG;\n\t\t\tbreak;\n\t\tcase TypeIds.T_short:\n\t\t\tbase = TypeConstants.SHORT;\n\t\t\tbreak;\n\t\tcase TypeIds.T_byte:\n\t\t\tbase = TypeConstants.BYTE;\n\t\t\tbreak;\n\t\tcase TypeIds.T_double:\n\t\t\tbase = TypeConstants.DOUBLE;\n\t\t\tbreak;\n\t\tcase TypeIds.T_float:\n\t\t\tbase = TypeConstants.FLOAT;\n\t\t\tbreak;\n\t\tcase TypeIds.T_boolean:\n\t\t\tbase = TypeConstants.BOOLEAN;\n\t\t\tbreak;\n\t\tcase TypeIds.T_char:\n\t\t\tbase = TypeConstants.CHAR;\n\t\t\tbreak;\n\t\tcase TypeIds.T_void:\n\t\t\tbase = TypeConstants.VOID;\n\t\t\tbreak;\n\t\tcase TypeIds.T_null:\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tif (base != null) {\n\t\t\tif (dims > 0) {\n\t\t\t\tTypeReference result = new ArrayTypeReference(base, dims, pos(pos));\n\t\t\t\tsetGeneratedBy(result, pos);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tTypeReference result = new SingleTypeReference(base, pos(pos));\n\t\t\tsetGeneratedBy(result, pos);\n\t\t\treturn result;\n\t\t}\n\t\t\n\t\tif (binding.isAnonymousType()) {\n\t\t\tReferenceBinding ref = (ReferenceBinding)binding;\n\t\t\tReferenceBinding[] supers = ref.superInterfaces();\n\t\t\tif (supers == null || supers.length == 0) supers = new ReferenceBinding[] {ref.superclass()};\n\t\t\tif (supers[0] == null) {\n\t\t\t\tTypeReference result = new QualifiedTypeReference(TypeConstants.JAVA_LANG_OBJECT, poss(pos, 3));\n\t\t\t\tsetGeneratedBy(result, pos);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\treturn makeType(supers[0], pos, false);\n\t\t}\n\t\t\n\t\tif (binding instanceof CaptureBinding) {\n\t\t\treturn makeType(((CaptureBinding)binding).wildcard, pos, allowCompound);\n\t\t}\n\t\t\n\t\tif (binding.isUnboundWildcard()) {\n\t\t\tif (!allowCompound) {\n\t\t\t\tTypeReference result = new QualifiedTypeReference(TypeConstants.JAVA_LANG_OBJECT, poss(pos, 3));\n\t\t\t\tsetGeneratedBy(result, pos);\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\tWildcard out = new Wildcard(Wildcard.UNBOUND);\n\t\t\t\tsetGeneratedBy(out, pos);\n\t\t\t\tout.sourceStart = pos.sourceStart;\n\t\t\t\tout.sourceEnd = pos.sourceEnd;\n\t\t\t\treturn out;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (binding.isWildcard()) {\n\t\t\tWildcardBinding wildcard = (WildcardBinding) binding;\n\t\t\tif (wildcard.boundKind == Wildcard.EXTENDS) {\n\t\t\t\tif (!allowCompound) {\n\t\t\t\t\tTypeBinding bound = wildcard.bound;\n\t\t\t\t\tboolean isObject = bound.id == TypeIds.T_JavaLangObject;\n\t\t\t\t\tTypeBinding[] otherBounds = wildcard.otherBounds;\n\t\t\t\t\tif (isObject && otherBounds != null && otherBounds.length > 0) {\n\t\t\t\t\t\treturn makeType(otherBounds[0], pos, false);\n\t\t\t\t\t} else return makeType(bound, pos, false);\n\t\t\t\t} else {\n\t\t\t\t\tWildcard out = new Wildcard(Wildcard.EXTENDS);\n\t\t\t\t\tsetGeneratedBy(out, pos);\n\t\t\t\t\tout.bound = makeType(wildcard.bound, pos, false);\n\t\t\t\t\tout.sourceStart = pos.sourceStart;\n\t\t\t\t\tout.sourceEnd = pos.sourceEnd;\n\t\t\t\t\treturn out;\n\t\t\t\t}\n\t\t\t} else if (allowCompound && wildcard.boundKind == Wildcard.SUPER) {\n\t\t\t\tWildcard out = new Wildcard(Wildcard.SUPER);\n\t\t\t\tsetGeneratedBy(out, pos);\n\t\t\t\tout.bound = makeType(wildcard.bound, pos, false);\n\t\t\t\tout.sourceStart = pos.sourceStart;\n\t\t\t\tout.sourceEnd = pos.sourceEnd;\n\t\t\t\treturn out;\n\t\t\t} else {\n\t\t\t\tTypeReference result = new QualifiedTypeReference(TypeConstants.JAVA_LANG_OBJECT, poss(pos, 3));\n\t\t\t\tsetGeneratedBy(result, pos);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Keep moving up via 'binding.enclosingType()' and gather generics from each binding. We stop after a local type, or a static type, or a top-level type.\n\t\t// Finally, add however many nullTypeArgument[] arrays as that are missing, inverse the list, toArray it, and use that as PTR's typeArgument argument.\n\t\t\n\t\tList<TypeReference[]> params = new ArrayList<TypeReference[]>();\n\t\t/* Calculate generics */\n\t\tif (!(binding instanceof RawTypeBinding)) {\n\t\t\tTypeBinding b = binding;\n\t\t\twhile (true) {\n\t\t\t\tboolean isFinalStop = b.isLocalType() || !b.isMemberType() || b.enclosingType() == null;\n\t\t\t\t\n\t\t\t\tTypeReference[] tyParams = null;\n\t\t\t\tif (b instanceof ParameterizedTypeBinding) {\n\t\t\t\t\tParameterizedTypeBinding paramized = (ParameterizedTypeBinding) b;\n\t\t\t\t\tif (paramized.arguments != null) {\n\t\t\t\t\t\ttyParams = new TypeReference[paramized.arguments.length];\n\t\t\t\t\t\tfor (int i = 0; i < tyParams.length; i++) {\n\t\t\t\t\t\t\ttyParams[i] = makeType(paramized.arguments[i], pos, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tparams.add(tyParams);\n\t\t\t\tif (isFinalStop) break;\n\t\t\t\tb = b.enclosingType();\n\t\t\t}\n\t\t}\n\t\t\n\t\tchar[][] parts;\n\t\t\n\t\tif (binding.isTypeVariable()) {\n\t\t\tparts = new char[][] { binding.shortReadableName() };\n\t\t} else if (binding.isLocalType()) {\n\t\t\tparts = new char[][] { binding.sourceName() };\n\t\t} else {\n\t\t\tString[] pkg = new String(binding.qualifiedPackageName()).split(\"\\\\.\");\n\t\t\tString[] name = new String(binding.qualifiedSourceName()).split(\"\\\\.\");\n\t\t\tif (pkg.length == 1 && pkg[0].isEmpty()) pkg = new String[0];\n\t\t\tparts = new char[pkg.length + name.length][];\n\t\t\tint ptr;\n\t\t\tfor (ptr = 0; ptr < pkg.length; ptr++) parts[ptr] = pkg[ptr].toCharArray();\n\t\t\tfor (; ptr < pkg.length + name.length; ptr++) parts[ptr] = name[ptr - pkg.length].toCharArray();\n\t\t}\n\t\t\n\t\twhile (params.size() < parts.length) params.add(null);\n\t\tCollections.reverse(params);\n\t\t\n\t\tboolean isParamized = false;\n\t\t\n\t\tfor (TypeReference[] tyParams : params) {\n\t\t\tif (tyParams != null) {\n\t\t\t\tisParamized = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (isParamized) {\n\t\t\tif (parts.length > 1) {\n\t\t\t\tTypeReference[][] typeArguments = params.toArray(new TypeReference[0][]);\n\t\t\t\tTypeReference result = new ParameterizedQualifiedTypeReference(parts, typeArguments, dims, poss(pos, parts.length));\n\t\t\t\tsetGeneratedBy(result, pos);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tTypeReference result = new ParameterizedSingleTypeReference(parts[0], params.get(0), dims, pos(pos));\n\t\t\tsetGeneratedBy(result, pos);\n\t\t\treturn result;\n\t\t}\n\t\t\n\t\tif (dims > 0) {\n\t\t\tif (parts.length > 1) {\n\t\t\t\tTypeReference result = new ArrayQualifiedTypeReference(parts, dims, poss(pos, parts.length));\n\t\t\t\tsetGeneratedBy(result, pos);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tTypeReference result = new ArrayTypeReference(parts[0], dims, pos(pos));\n\t\t\tsetGeneratedBy(result, pos);\n\t\t\treturn result;\n\t\t}\n\t\t\n\t\tif (parts.length > 1) {\n\t\t\tTypeReference result = new QualifiedTypeReference(parts, poss(pos, parts.length));\n\t\t\tsetGeneratedBy(result, pos);\n\t\t\treturn result;\n\t\t}\n\t\tTypeReference result = new SingleTypeReference(parts[0], pos(pos));\n\t\tsetGeneratedBy(result, pos);\n\t\treturn result;\n\t}\n\t\n\t/**\n\t * Provides AnnotationValues with the data it needs to do its thing.\n\t */\n\tpublic static <A extends java.lang.annotation.Annotation> AnnotationValues<A>\n\t\tcreateAnnotation(Class<A> type, final EclipseNode annotationNode) {\n\t\t\n\t\tfinal Annotation annotation = (Annotation) annotationNode.get();\n\t\tMap<String, AnnotationValue> values = new HashMap<String, AnnotationValue>();\n\t\t\n\t\tMemberValuePair[] memberValuePairs = annotation.memberValuePairs();\n\t\t\n\t\tif (memberValuePairs != null) for (final MemberValuePair pair : memberValuePairs) {\n\t\t\tList<String> raws = new ArrayList<String>();\n\t\t\tList<Object> expressionValues = new ArrayList<Object>();\n\t\t\tList<Object> guesses = new ArrayList<Object>();\n\t\t\tExpression[] expressions = null;\n\t\t\t\n\t\t\tchar[] n = pair.name;\n\t\t\tString mName = (n == null || n.length == 0) ? \"value\" : new String(pair.name);\n\t\t\tfinal Expression rhs = pair.value;\n\t\t\tif (rhs instanceof ArrayInitializer) {\n\t\t\t\texpressions = ((ArrayInitializer) rhs).expressions;\n\t\t\t} else if (rhs != null) {\n\t\t\t\texpressions = new Expression[] { rhs };\n\t\t\t}\n\t\t\tif (expressions != null) for (Expression ex : expressions) {\n\t\t\t\tStringBuffer sb = new StringBuffer();\n\t\t\t\tex.print(0, sb);\n\t\t\t\traws.add(sb.toString());\n\t\t\t\texpressionValues.add(ex);\n\t\t\t\tguesses.add(calculateValue(ex));\n\t\t\t}\n\t\t\t\n\t\t\tfinal Expression[] exprs = expressions;\n\t\t\tvalues.put(mName, new AnnotationValue(annotationNode, raws, expressionValues, guesses, true) {\n\t\t\t\t@Override public void setError(String message, int valueIdx) {\n\t\t\t\t\tExpression ex;\n\t\t\t\t\tif (valueIdx == -1) ex = rhs;\n\t\t\t\t\telse ex = exprs != null ? exprs[valueIdx] : null;\n\t\t\t\t\t\n\t\t\t\t\tif (ex == null) ex = annotation;\n\t\t\t\t\t\n\t\t\t\t\tint sourceStart = ex.sourceStart;\n\t\t\t\t\tint sourceEnd = ex.sourceEnd;\n\t\t\t\t\t\n\t\t\t\t\tannotationNode.addError(message, sourceStart, sourceEnd);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t@Override public void setWarning(String message, int valueIdx) {\n\t\t\t\t\tExpression ex;\n\t\t\t\t\tif (valueIdx == -1) ex = rhs;\n\t\t\t\t\telse ex = exprs != null ? exprs[valueIdx] : null;\n\t\t\t\t\t\n\t\t\t\t\tif (ex == null) ex = annotation;\n\t\t\t\t\t\n\t\t\t\t\tint sourceStart = ex.sourceStart;\n\t\t\t\t\tint sourceEnd = ex.sourceEnd;\n\t\t\t\t\t\n\t\t\t\t\tannotationNode.addWarning(message, sourceStart, sourceEnd);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\t\n\t\tfor (Method m : type.getDeclaredMethods()) {\n\t\t\tif (!Modifier.isPublic(m.getModifiers())) continue;\n\t\t\tString name = m.getName();\n\t\t\tif (!values.containsKey(name)) {\n\t\t\t\tvalues.put(name, new AnnotationValue(annotationNode, new ArrayList<String>(), new ArrayList<Object>(), new ArrayList<Object>(), false) {\n\t\t\t\t\t@Override public void setError(String message, int valueIdx) {\n\t\t\t\t\t\tannotationNode.addError(message);\n\t\t\t\t\t}\n\t\t\t\t\t@Override public void setWarning(String message, int valueIdx) {\n\t\t\t\t\t\tannotationNode.addWarning(message);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn new AnnotationValues<A>(type, values, annotationNode);\n\t}\n\t\n\t/**\n\t * Turns an {@code AccessLevel} instance into the flag bit used by eclipse.\n\t */\n\tpublic static int toEclipseModifier(AccessLevel value) {\n\t\tswitch (value) {\n\t\tcase MODULE:\n\t\tcase PACKAGE:\n\t\t\treturn 0;\n\t\tdefault:\n\t\tcase PUBLIC:\n\t\t\treturn ClassFileConstants.AccPublic;\n\t\tcase PROTECTED:\n\t\t\treturn ClassFileConstants.AccProtected;\n\t\tcase NONE:\n\t\tcase PRIVATE:\n\t\t\treturn ClassFileConstants.AccPrivate;\n\t\t}\n\t}\n\t\n\tprivate static class GetterMethod {\n\t\tprivate final char[] name;\n\t\tprivate final TypeReference type;\n\t\t\n\t\tGetterMethod(char[] name, TypeReference type) {\n\t\t\tthis.name = name;\n\t\t\tthis.type = type;\n\t\t}\n\t}\n\t\n\tstatic void registerCreatedLazyGetter(FieldDeclaration field, char[] methodName, TypeReference returnType) {\n\t\tif (isBoolean(returnType)) {\n\t\t\tFieldDeclaration_booleanLazyGetter.set(field, true);\n\t\t}\n\t}\n\t\n\tpublic static boolean isBoolean(TypeReference typeReference) {\n\t\treturn nameEquals(typeReference.getTypeName(), \"boolean\") && typeReference.dimensions() == 0;\n\t}\n\t\n\tprivate static GetterMethod findGetter(EclipseNode field) {\n\t\tFieldDeclaration fieldDeclaration = (FieldDeclaration) field.get();\n\t\tboolean forceBool = FieldDeclaration_booleanLazyGetter.get(fieldDeclaration);\n\t\tTypeReference fieldType = fieldDeclaration.type;\n\t\tboolean isBoolean = forceBool || isBoolean(fieldType);\n\t\t\n\t\tEclipseNode typeNode = field.up();\n\t\tfor (String potentialGetterName : toAllGetterNames(field, isBoolean)) {\n\t\t\tfor (EclipseNode potentialGetter : typeNode.down()) {\n\t\t\t\tif (potentialGetter.getKind() != Kind.METHOD) continue;\n\t\t\t\tif (!(potentialGetter.get() instanceof MethodDeclaration)) continue;\n\t\t\t\tMethodDeclaration method = (MethodDeclaration) potentialGetter.get();\n\t\t\t\tif (!potentialGetterName.equalsIgnoreCase(new String(method.selector))) continue;\n\t\t\t\t/** static getX() methods don't count. */\n\t\t\t\tif ((method.modifiers & ClassFileConstants.AccStatic) != 0) continue;\n\t\t\t\t/** Nor do getters with a non-empty parameter list. */\n\t\t\t\tif (method.arguments != null && method.arguments.length > 0) continue;\n\t\t\t\treturn new GetterMethod(method.selector, method.returnType);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Check if the field has a @Getter annotation.\n\t\t\n\t\tboolean hasGetterAnnotation = false;\n\t\t\n\t\tfor (EclipseNode child : field.down()) {\n\t\t\tif (child.getKind() == Kind.ANNOTATION && annotationTypeMatches(Getter.class, child)) {\n\t\t\t\tAnnotationValues<Getter> ann = createAnnotation(Getter.class, child);\n\t\t\t\tif (ann.getInstance().value() == AccessLevel.NONE) return null;   //Definitely WONT have a getter.\n\t\t\t\thasGetterAnnotation = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Check if the class has a @Getter annotation.\n\t\t\n\t\tif (!hasGetterAnnotation && HandleGetter.fieldQualifiesForGetterGeneration(field)) {\n\t\t\t//Check if the class has @Getter or @Data annotation.\n\t\t\t\n\t\t\tEclipseNode containingType = field.up();\n\t\t\tif (containingType != null) for (EclipseNode child : containingType.down()) {\n\t\t\t\tif (child.getKind() == Kind.ANNOTATION && annotationTypeMatches(Data.class, child)) hasGetterAnnotation = true;\n\t\t\t\tif (child.getKind() == Kind.ANNOTATION && annotationTypeMatches(Getter.class, child)) {\n\t\t\t\t\tAnnotationValues<Getter> ann = createAnnotation(Getter.class, child);\n\t\t\t\t\tif (ann.getInstance().value() == AccessLevel.NONE) return null;   //Definitely WONT have a getter.\n\t\t\t\t\thasGetterAnnotation = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (hasGetterAnnotation) {\n\t\t\tString getterName = toGetterName(field, isBoolean);\n\t\t\tif (getterName == null) return null;\n\t\t\treturn new GetterMethod(getterName.toCharArray(), fieldType);\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\t\n\tstatic boolean lookForGetter(EclipseNode field, FieldAccess fieldAccess) {\n\t\tif (fieldAccess == FieldAccess.GETTER) return true;\n\t\tif (fieldAccess == FieldAccess.ALWAYS_FIELD) return false;\n\t\t\n\t\t// If @Getter(lazy = true) is used, then using it is mandatory.\n\t\tfor (EclipseNode child : field.down()) {\n\t\t\tif (child.getKind() != Kind.ANNOTATION) continue;\n\t\t\tif (annotationTypeMatches(Getter.class, child)) {\n\t\t\t\tAnnotationValues<Getter> ann = createAnnotation(Getter.class, child);\n\t\t\t\tif (ann.getInstance().lazy()) return true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tstatic TypeReference getFieldType(EclipseNode field, FieldAccess fieldAccess) {\n\t\tif (field.get() instanceof MethodDeclaration) return ((MethodDeclaration) field.get()).returnType;\n\t\t\n\t\tboolean lookForGetter = lookForGetter(field, fieldAccess);\n\t\t\n\t\tGetterMethod getter = lookForGetter ? findGetter(field) : null;\n\t\tif (getter == null) {\n\t\t\treturn ((FieldDeclaration) field.get()).type;\n\t\t}\n\t\t\n\t\treturn getter.type;\n\t}\n\t\n\tstatic Expression createFieldAccessor(EclipseNode field, FieldAccess fieldAccess, ASTNode source) {\n\t\tint pS = source == null ? 0 : source.sourceStart, pE = source == null ? 0 : source.sourceEnd;\n\t\tlong p = (long) pS << 32 | pE;\n\t\t\n\t\tboolean lookForGetter = lookForGetter(field, fieldAccess);\n\t\t\n\t\tGetterMethod getter = lookForGetter ? findGetter(field) : null;\n\t\t\n\t\tif (getter == null) {\n\t\t\tFieldDeclaration fieldDecl = (FieldDeclaration)field.get();\n\t\t\tFieldReference ref = new FieldReference(fieldDecl.name, p);\n\t\t\tif ((fieldDecl.modifiers & ClassFileConstants.AccStatic) != 0) {\n\t\t\t\tEclipseNode containerNode = field.up();\n\t\t\t\tif (containerNode != null && containerNode.get() instanceof TypeDeclaration) {\n\t\t\t\t\tref.receiver = new SingleNameReference(((TypeDeclaration)containerNode.get()).name, p);\n\t\t\t\t} else {\n\t\t\t\t\tExpression smallRef = new FieldReference(field.getName().toCharArray(), p);\n\t\t\t\t\tif (source != null) setGeneratedBy(smallRef, source);\n\t\t\t\t\treturn smallRef;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tref.receiver = new ThisReference(pS, pE);\n\t\t\t}\n\t\t\t\n\t\t\tif (source != null) {\n\t\t\t\tsetGeneratedBy(ref, source);\n\t\t\t\tsetGeneratedBy(ref.receiver, source);\n\t\t\t}\n\t\t\treturn ref;\n\t\t}\n\t\t\n\t\tMessageSend call = new MessageSend();\n\t\tsetGeneratedBy(call, source);\n\t\tcall.sourceStart = pS; call.statementEnd = call.sourceEnd = pE;\n\t\tcall.receiver = new ThisReference(pS, pE);\n\t\tsetGeneratedBy(call.receiver, source);\n\t\tcall.selector = getter.name;\n\t\treturn call;\n\t}\n\t\n\tstatic Expression createFieldAccessor(EclipseNode field, FieldAccess fieldAccess, ASTNode source, char[] receiver) {\n\t\tint pS = source.sourceStart, pE = source.sourceEnd;\n\t\tlong p = (long)pS << 32 | pE;\n\t\t\n\t\tboolean lookForGetter = lookForGetter(field, fieldAccess);\n\t\t\n\t\tGetterMethod getter = lookForGetter ? findGetter(field) : null;\n\t\t\n\t\tif (getter == null) {\n\t\t\tNameReference ref;\n\t\t\t\n\t\t\tchar[][] tokens = new char[2][];\n\t\t\ttokens[0] = receiver;\n\t\t\ttokens[1] = field.getName().toCharArray();\n\t\t\tlong[] poss = {p, p};\n\t\t\t\n\t\t\tref = new QualifiedNameReference(tokens, poss, pS, pE);\n\t\t\tsetGeneratedBy(ref, source);\n\t\t\treturn ref;\n\t\t}\n\t\t\n\t\tMessageSend call = new MessageSend();\n\t\tsetGeneratedBy(call, source);\n\t\tcall.sourceStart = pS; call.statementEnd = call.sourceEnd = pE;\n\t\tcall.receiver = new SingleNameReference(receiver, p);\n\t\tsetGeneratedBy(call.receiver, source);\n\t\tcall.selector = getter.name;\n\t\treturn call;\n\t}\n\t\n\tstatic Expression createMethodAccessor(EclipseNode method, ASTNode source) {\n\t\tint pS = source == null ? 0 : source.sourceStart, pE = source == null ? 0 : source.sourceEnd;\n\t\tlong p = (long) pS << 32 | pE;\n\t\t\n\t\tMethodDeclaration methodDecl = (MethodDeclaration) method.get();\n\t\tMessageSend call = new MessageSend();\n\t\tsetGeneratedBy(call, source);\n\t\tcall.sourceStart = pS; call.statementEnd = call.sourceEnd = pE;\n\t\tif ((methodDecl.modifiers & ClassFileConstants.AccStatic) == 0) {\n\t\t\tcall.receiver = new ThisReference(pS, pE);\n\t\t\tsetGeneratedBy(call.receiver, source);\n\t\t} else {\n\t\t\tEclipseNode containerNode = method.up();\n\t\t\tif (containerNode != null && containerNode.get() instanceof TypeDeclaration) {\n\t\t\t\tcall.receiver = new SingleNameReference(((TypeDeclaration) containerNode.get()).name, p);\n\t\t\t\tsetGeneratedBy(call.receiver, source);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcall.selector = methodDecl.selector;\n\t\treturn call;\n\t}\n\t\n\tstatic Expression createMethodAccessor(EclipseNode method, ASTNode source, char[] receiver) {\n\t\tint pS = source == null ? 0 : source.sourceStart, pE = source == null ? 0 : source.sourceEnd;\n\t\tlong p = (long) pS << 32 | pE;\n\t\t\n\t\tMethodDeclaration methodDecl = (MethodDeclaration) method.get();\n\t\tMessageSend call = new MessageSend();\n\t\tsetGeneratedBy(call, source);\n\t\tcall.sourceStart = pS; call.statementEnd = call.sourceEnd = pE;\n\t\tcall.receiver = new SingleNameReference(receiver, p);\n\t\tsetGeneratedBy(call.receiver, source);\n\t\tcall.selector = methodDecl.selector;\n\t\treturn call;\n\t}\n\t\n\t/** Serves as return value for the methods that check for the existence of fields and methods. */\n\tpublic enum MemberExistsResult {\n\t\tNOT_EXISTS, EXISTS_BY_LOMBOK, EXISTS_BY_USER;\n\t}\n\t\n\t/**\n\t * Translates the given field into all possible getter names.\n\t * Convenient wrapper around {@link HandlerUtil#toAllGetterNames(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static List<String> toAllGetterNames(EclipseNode field, boolean isBoolean) {\n\t\treturn HandlerUtil.toAllGetterNames(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean);\n\t}\n\t\n\t/**\n\t * @return the likely getter name for the stated field. (e.g. private boolean foo; to isFoo).\n\t * \n\t * Convenient wrapper around {@link HandlerUtil#toGetterName(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static String toGetterName(EclipseNode field, boolean isBoolean) {\n\t\treturn HandlerUtil.toGetterName(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean);\n\t}\n\t\n\t/**\n\t * Translates the given field into all possible setter names.\n\t * Convenient wrapper around {@link HandlerUtil#toAllSetterNames(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static java.util.List<String> toAllSetterNames(EclipseNode field, boolean isBoolean) {\n\t\treturn HandlerUtil.toAllSetterNames(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean);\n\t}\n\t\n\t/**\n\t * @return the likely setter name for the stated field. (e.g. private boolean foo; to setFoo).\n\t * \n\t * Convenient wrapper around {@link HandlerUtil#toSetterName(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static String toSetterName(EclipseNode field, boolean isBoolean) {\n\t\treturn HandlerUtil.toSetterName(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean);\n\t}\n\t\n\t/**\n\t * Translates the given field into all possible with names.\n\t * Convenient wrapper around {@link HandlerUtil#toAllWithNames(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static java.util.List<String> toAllWithNames(EclipseNode field, boolean isBoolean) {\n\t\treturn HandlerUtil.toAllWithNames(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean);\n\t}\n\t\n\t/**\n\t * Translates the given field into all possible withBy names.\n\t * Convenient wrapper around {@link HandlerUtil#toAllWithByNames(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static java.util.List<String> toAllWithByNames(EclipseNode field, boolean isBoolean) {\n\t\treturn HandlerUtil.toAllWithByNames(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean);\n\t}\n\t\n\t/**\n\t * @return the likely with name for the stated field. (e.g. private boolean foo; to withFoo).\n\t * \n\t * Convenient wrapper around {@link HandlerUtil#toWithName(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static String toWithName(EclipseNode field, boolean isBoolean) {\n\t\treturn HandlerUtil.toWithName(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean);\n\t}\n\t\n\t/**\n\t * @return the likely withBy name for the stated field. (e.g. private boolean foo; to withFooBy).\n\t * \n\t * Convenient wrapper around {@link HandlerUtil#toWithByName(lombok.core.AnnotationValues, CharSequence, boolean)}.\n\t */\n\tpublic static String toWithByName(EclipseNode field, boolean isBoolean) {\n\t\treturn HandlerUtil.toWithByName(field.getAst(), getAccessorsForField(field), field.getName(), isBoolean);\n\t}\n\t\n\t/**\n\t * When generating a setter, the setter either returns void (beanspec) or Self (fluent).\n\t * This method scans for the {@code Accessors} annotation and associated config properties to figure that out.\n\t */\n\tpublic static boolean shouldReturnThis(EclipseNode field) {\n\t\tif ((((FieldDeclaration) field.get()).modifiers & ClassFileConstants.AccStatic) != 0) return false;\n\t\tAnnotationValues<Accessors> accessors = EclipseHandlerUtil.getAccessorsForField(field);\n\t\treturn shouldReturnThis0(accessors, field.getAst());\n\t}\n\t\n\t/**\n\t * Checks if the field should be included in operations that work on 'all' fields:\n\t *    If the field is static, or starts with a '$', or is actually an enum constant, 'false' is returned, indicating you should skip it.\n\t */\n\tpublic static boolean filterField(FieldDeclaration declaration) {\n\t\treturn filterField(declaration, true);\n\t}\n\t\n\tpublic static boolean filterField(FieldDeclaration declaration, boolean skipStatic) {\n\t\t// Skip the fake fields that represent enum constants.\n\t\tif (declaration.initialization instanceof AllocationExpression &&\n\t\t\t\t((AllocationExpression) declaration.initialization).enumConstant != null) return false;\n\t\t\n\t\tif (declaration.type == null) return false;\n\t\t\n\t\t// Skip fields that start with $\n\t\tif (declaration.name.length > 0 && declaration.name[0] == '$') return false;\n\t\t\n\t\t// Skip static fields.\n\t\tif (skipStatic && (declaration.modifiers & ClassFileConstants.AccStatic) != 0) return false;\n\t\t\n\t\treturn true;\n\t}\n\t\n\tpublic static char[] removePrefixFromField(EclipseNode field) {\n\t\tList<String> prefixes = null;\n\t\tfor (EclipseNode node : field.down()) {\n\t\t\tif (annotationTypeMatches(Accessors.class, node)) {\n\t\t\t\tAnnotationValues<Accessors> ann = createAnnotation(Accessors.class, node);\n\t\t\t\tif (ann.isExplicit(\"prefix\")) prefixes = Arrays.asList(ann.getInstance().prefix());\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (prefixes == null) {\n\t\t\tEclipseNode current = field.up();\n\t\t\touter:\n\t\t\twhile (current != null) {\n\t\t\t\tfor (EclipseNode node : current.down()) {\n\t\t\t\t\tif (annotationTypeMatches(Accessors.class, node)) {\n\t\t\t\t\t\tAnnotationValues<Accessors> ann = createAnnotation(Accessors.class, node);\n\t\t\t\t\t\tif (ann.isExplicit(\"prefix\")) prefixes = Arrays.asList(ann.getInstance().prefix());\n\t\t\t\t\t\tbreak outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcurrent = current.up();\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (prefixes == null) prefixes = field.getAst().readConfiguration(ConfigurationKeys.ACCESSORS_PREFIX);\n\t\tif (!prefixes.isEmpty()) {\n\t\t\tCharSequence newName = removePrefix(field.getName(), prefixes);\n\t\t\tif (newName != null) return newName.toString().toCharArray();\n\t\t}\n\t\t\n\t\treturn ((FieldDeclaration) field.get()).name;\n\t}\n\t\n\tpublic static AnnotationValues<Accessors> getAccessorsForField(EclipseNode field) {\n\t\tfor (EclipseNode node : field.down()) {\n\t\t\tif (annotationTypeMatches(Accessors.class, node)) {\n\t\t\t\treturn createAnnotation(Accessors.class, node);\n\t\t\t}\n\t\t}\n\t\t\n\t\tEclipseNode current = field.up();\n\t\twhile (current != null) {\n\t\t\tfor (EclipseNode node : current.down()) {\n\t\t\t\tif (annotationTypeMatches(Accessors.class, node)) {\n\t\t\t\t\treturn createAnnotation(Accessors.class, node);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurrent = current.up();\n\t\t}\n\t\t\n\t\treturn AnnotationValues.of(Accessors.class, field);\n\t}\n\n\tpublic static EclipseNode upToTypeNode(EclipseNode node) {\n\t\tif (node == null) throw new NullPointerException(\"node\");\n\t\twhile (node != null && !(node.get() instanceof TypeDeclaration)) node = node.up();\n\t\treturn node;\n\t}\n\t\n\t/**\n\t * Checks if there is a field with the provided name.\n\t * \n\t * @param fieldName the field name to check for.\n\t * @param node Any node that represents the Type (TypeDeclaration) to look in, or any child node thereof.\n\t */\n\tpublic static MemberExistsResult fieldExists(String fieldName, EclipseNode node) {\n\t\tnode = upToTypeNode(node);\n\t\tchar[] fieldNameChars = null;\n\t\tif (node != null && node.get() instanceof TypeDeclaration) {\n\t\t\tTypeDeclaration typeDecl = (TypeDeclaration) node.get();\n\t\t\tif (typeDecl.fields != null) for (FieldDeclaration def : typeDecl.fields) {\n\t\t\t\tchar[] fName = def.name;\n\t\t\t\tif (fName == null) continue;\n\t\t\t\tif (fieldNameChars == null) fieldNameChars = fieldName.toCharArray();\n\t\t\t\tif (Arrays.equals(fName, fieldNameChars)) {\n\t\t\t\t\treturn getGeneratedBy(def) == null ? MemberExistsResult.EXISTS_BY_USER : MemberExistsResult.EXISTS_BY_LOMBOK;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn MemberExistsResult.NOT_EXISTS;\n\t}\n\t\n\t/**\n\t * Wrapper for {@link #methodExists(String, EclipseNode, boolean, int)} with {@code caseSensitive} = {@code true}.\n\t */\n\tpublic static MemberExistsResult methodExists(String methodName, EclipseNode node, int params) {\n\t\treturn methodExists(methodName, node, true, params);\n\t}\n\t\n\t/**\n\t * Checks if there is a method with the provided name. In case of multiple methods (overloading), only\n\t * the first method decides if EXISTS_BY_USER or EXISTS_BY_LOMBOK is returned.\n\t * \n\t * @param methodName the method name to check for.\n\t * @param node Any node that represents the Type (TypeDeclaration) to look in, or any child node thereof.\n\t * @param caseSensitive If the search should be case sensitive.\n\t * @param params The number of parameters the method should have; varargs count as 0-*. Set to -1 to find any method with the appropriate name regardless of parameter count.\n\t */\n\tpublic static MemberExistsResult methodExists(String methodName, EclipseNode node, boolean caseSensitive, int params) {\n\t\twhile (node != null && !(node.get() instanceof TypeDeclaration)) {\n\t\t\tnode = node.up();\n\t\t}\n\t\t\n\t\tif (node != null && node.get() instanceof TypeDeclaration) {\n\t\t\tTypeDeclaration typeDecl = (TypeDeclaration)node.get();\n\t\t\tif (typeDecl.methods != null) top: for (AbstractMethodDeclaration def : typeDecl.methods) {\n\t\t\t\tif (def instanceof MethodDeclaration) {\n\t\t\t\t\tchar[] mName = def.selector;\n\t\t\t\t\tif (mName == null) continue;\n\t\t\t\t\tboolean nameEquals = caseSensitive ? methodName.equals(new String(mName)) : methodName.equalsIgnoreCase(new String(mName));\n\t\t\t\t\tif (nameEquals) {\n\t\t\t\t\t\tif (params > -1) {\n\t\t\t\t\t\t\tint minArgs = 0;\n\t\t\t\t\t\t\tint maxArgs = 0;\n\t\t\t\t\t\t\tif (def.arguments != null && def.arguments.length > 0) {\n\t\t\t\t\t\t\t\tminArgs = def.arguments.length;\n\t\t\t\t\t\t\t\tif ((def.arguments[def.arguments.length - 1].type.bits & ASTNode.IsVarArgs) != 0) {\n\t\t\t\t\t\t\t\t\tminArgs--;\n\t\t\t\t\t\t\t\t\tmaxArgs = Integer.MAX_VALUE;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tmaxArgs = minArgs;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (params < minArgs || params > maxArgs) continue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (isTolerate(node, def)) continue top;\n\t\t\t\t\t\t\n\t\t\t\t\t\treturn getGeneratedBy(def) == null ? MemberExistsResult.EXISTS_BY_USER : MemberExistsResult.EXISTS_BY_LOMBOK;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn MemberExistsResult.NOT_EXISTS;\n\t}\n\t\n\tpublic static boolean isTolerate(EclipseNode node, AbstractMethodDeclaration def) {\n\t\tif (def.annotations != null) for (Annotation anno : def.annotations) {\n\t\t\tif (typeMatches(Tolerate.class, node, anno.type)) return true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Checks if there is a (non-default) constructor. In case of multiple constructors (overloading), only\n\t * the first constructor decides if EXISTS_BY_USER or EXISTS_BY_LOMBOK is returned.\n\t * \n\t * @param node Any node that represents the Type (TypeDeclaration) to look in, or any child node thereof.\n\t */\n\tpublic static MemberExistsResult constructorExists(EclipseNode node) {\n\t\tnode = upToTypeNode(node);\n\t\tif (node != null && node.get() instanceof TypeDeclaration) {\n\t\t\tTypeDeclaration typeDecl = (TypeDeclaration) node.get();\n\t\t\tif (typeDecl.methods != null) for (AbstractMethodDeclaration def : typeDecl.methods) {\n\t\t\t\tif (!(def instanceof ConstructorDeclaration)) continue;\n\t\t\t\tif ((def.bits & ASTNode.IsDefaultConstructor) != 0) continue;\n\t\t\t\tif (isTolerate(node, def)) continue;\n\t\t\t\treturn getGeneratedBy(def) == null ? MemberExistsResult.EXISTS_BY_USER : MemberExistsResult.EXISTS_BY_LOMBOK;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn MemberExistsResult.NOT_EXISTS;\n\t}\n\t\n\t/**\n\t * Inserts a field into an existing type. The type must represent a {@code TypeDeclaration}.\n\t * The field carries the &#64;{@link SuppressWarnings}(\"all\") annotation.\n\t */\n\tpublic static EclipseNode injectFieldAndMarkGenerated(EclipseNode type, FieldDeclaration field) {\n\t\tfield.annotations = addSuppressWarningsAll(type, field, field.annotations);\n\t\tfield.annotations = addGenerated(type, field, field.annotations);\n\t\treturn injectField(type, field);\n\t}\n\t\n\t/**\n\t * Inserts a field into an existing type. The type must represent a {@code TypeDeclaration}.\n\t */\n\tpublic static EclipseNode injectField(EclipseNode type, FieldDeclaration field) {\n\t\tTypeDeclaration parent = (TypeDeclaration) type.get();\n\t\t\n\t\tif (parent.fields == null) {\n\t\t\tparent.fields = new FieldDeclaration[1];\n\t\t\tparent.fields[0] = field;\n\t\t} else {\n\t\t\tint size = parent.fields.length;\n\t\t\tFieldDeclaration[] newArray = new FieldDeclaration[size + 1];\n\t\t\tSystem.arraycopy(parent.fields, 0, newArray, 0, size);\n\t\t\tint index = 0;\n\t\t\tfor (; index < size; index++) {\n\t\t\t\tFieldDeclaration f = newArray[index];\n\t\t\t\tif (isEnumConstant(f) || isGenerated(f)) continue;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tSystem.arraycopy(newArray, index, newArray, index + 1, size - index);\n\t\t\tnewArray[index] = field;\n\t\t\tparent.fields = newArray;\n\t\t}\n\t\t\n\t\tif (isEnumConstant(field) || (field.modifiers & Modifier.STATIC) != 0) {\n\t\t\tif (!hasClinit(parent)) {\n\t\t\t\tparent.addClinit();\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn type.add(field, Kind.FIELD);\n\t}\n\t\n\tpublic static boolean isEnumConstant(final FieldDeclaration field) {\n\t\treturn ((field.initialization instanceof AllocationExpression) && (((AllocationExpression) field.initialization).enumConstant == field));\n\t}\n\t\n\t/**\n\t * Inserts a method into an existing type. The type must represent a {@code TypeDeclaration}.\n\t */\n\tpublic static EclipseNode injectMethod(EclipseNode type, AbstractMethodDeclaration method) {\n\t\tmethod.annotations = addSuppressWarningsAll(type, method, method.annotations);\n\t\tmethod.annotations = addGenerated(type, method, method.annotations);\n\t\tTypeDeclaration parent = (TypeDeclaration) type.get();\n\t\t\n\t\tif (parent.methods == null) {\n\t\t\tparent.methods = new AbstractMethodDeclaration[1];\n\t\t\tparent.methods[0] = method;\n\t\t} else {\n\t\t\tif (method instanceof ConstructorDeclaration) {\n\t\t\t\tfor (int i = 0 ; i < parent.methods.length ; i++) {\n\t\t\t\t\tif (parent.methods[i] instanceof ConstructorDeclaration &&\n\t\t\t\t\t\t\t(parent.methods[i].bits & ASTNode.IsDefaultConstructor) != 0) {\n\t\t\t\t\t\tEclipseNode tossMe = type.getNodeFor(parent.methods[i]);\n\t\t\t\t\t\t\n\t\t\t\t\t\tAbstractMethodDeclaration[] withoutGeneratedConstructor = new AbstractMethodDeclaration[parent.methods.length - 1];\n\t\t\t\t\t\t\n\t\t\t\t\t\tSystem.arraycopy(parent.methods, 0, withoutGeneratedConstructor, 0, i);\n\t\t\t\t\t\tSystem.arraycopy(parent.methods, i + 1, withoutGeneratedConstructor, i, parent.methods.length - i - 1);\n\t\t\t\t\t\t\n\t\t\t\t\t\tparent.methods = withoutGeneratedConstructor;\n\t\t\t\t\t\tif (tossMe != null) tossMe.up().removeChild(tossMe);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//We insert the method in the last position of the methods registered to the type\n\t\t\t//When changing this behavior, this may trigger issue #155 and #377\n\t\t\tAbstractMethodDeclaration[] newArray = new AbstractMethodDeclaration[parent.methods.length + 1];\n\t\t\tSystem.arraycopy(parent.methods, 0, newArray, 0, parent.methods.length);\n\t\t\tnewArray[parent.methods.length] = method;\n\t\t\tparent.methods = newArray;\n\t\t}\n\t\t\n\t\treturn type.add(method, Kind.METHOD);\n\t}\n\t\n\t/**\n\t * Adds an inner type (class, interface, enum) to the given type. Cannot inject top-level types.\n\t * \n\t * @param typeNode parent type to inject new type into\n\t * @param type New type (class, interface, etc) to inject.\n\t */\n\tpublic static EclipseNode injectType(final EclipseNode typeNode, final TypeDeclaration type) {\n\t\ttype.annotations = addSuppressWarningsAll(typeNode, type, type.annotations);\n\t\ttype.annotations = addGenerated(typeNode, type, type.annotations);\n\t\tTypeDeclaration parent = (TypeDeclaration) typeNode.get();\n\t\t\n\t\tif (parent.memberTypes == null) {\n\t\t\tparent.memberTypes = new TypeDeclaration[] { type };\n\t\t} else {\n\t\t\tTypeDeclaration[] newArray = new TypeDeclaration[parent.memberTypes.length + 1];\n\t\t\tSystem.arraycopy(parent.memberTypes, 0, newArray, 0, parent.memberTypes.length);\n\t\t\tnewArray[parent.memberTypes.length] = type;\n\t\t\tparent.memberTypes = newArray;\n\t\t}\n\t\t\n\t\treturn typeNode.add(type, Kind.TYPE);\n\t}\n\t\n\tstatic final char[] ALL = \"all\".toCharArray();\n\tstatic final char[] UNCHECKED = \"unchecked\".toCharArray();\n\tprivate static final char[] JUSTIFICATION = \"justification\".toCharArray();\n\tprivate static final char[] GENERATED_CODE = \"generated code\".toCharArray();\n\tprivate static final char[] LOMBOK = \"lombok\".toCharArray();\n\tprivate static final char[][] JAVAX_ANNOTATION_GENERATED = Eclipse.fromQualifiedName(\"javax.annotation.Generated\");\n\tprivate static final char[][] LOMBOK_GENERATED = Eclipse.fromQualifiedName(\"lombok.Generated\");\n\tprivate static final char[][] EDU_UMD_CS_FINDBUGS_ANNOTATIONS_SUPPRESSFBWARNINGS = Eclipse.fromQualifiedName(\"edu.umd.cs.findbugs.annotations.SuppressFBWarnings\");\n\t\n\tpublic static Annotation[] addSuppressWarningsAll(EclipseNode node, ASTNode source, Annotation[] originalAnnotationArray) {\n\t\tAnnotation[] anns = originalAnnotationArray;\n\t\t\n\t\tif (!Boolean.FALSE.equals(node.getAst().readConfiguration(ConfigurationKeys.ADD_SUPPRESSWARNINGS_ANNOTATIONS))) {\n\t\t\tanns = addAnnotation(source, anns, TypeConstants.JAVA_LANG_SUPPRESSWARNINGS, new StringLiteral(ALL, 0, 0, 0));\n\t\t}\n\t\t\n\t\tif (Boolean.TRUE.equals(node.getAst().readConfiguration(ConfigurationKeys.ADD_FINDBUGS_SUPPRESSWARNINGS_ANNOTATIONS))) {\n\t\t\tMemberValuePair mvp = new MemberValuePair(JUSTIFICATION, 0, 0, new StringLiteral(GENERATED_CODE, 0, 0, 0));\n\t\t\tanns = addAnnotation(source, anns, EDU_UMD_CS_FINDBUGS_ANNOTATIONS_SUPPRESSFBWARNINGS, mvp);\n\t\t}\n\t\t\n\t\treturn anns;\n\t}\n\t\n\tpublic static Annotation[] addGenerated(EclipseNode node, ASTNode source, Annotation[] originalAnnotationArray) {\n\t\tAnnotation[] result = originalAnnotationArray;\n\t\tif (HandlerUtil.shouldAddGenerated(node)) {\n\t\t\tresult = addAnnotation(source, result, JAVAX_ANNOTATION_GENERATED, new StringLiteral(LOMBOK, 0, 0, 0));\n\t\t}\n\t\tif (Boolean.TRUE.equals(node.getAst().readConfiguration(ConfigurationKeys.ADD_LOMBOK_GENERATED_ANNOTATIONS))) {\n\t\t\tresult = addAnnotation(source, result, LOMBOK_GENERATED);\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tstatic Annotation[] addAnnotation(ASTNode source, Annotation[] originalAnnotationArray, char[][] annotationTypeFqn) {\n\t\treturn addAnnotation(source, originalAnnotationArray, annotationTypeFqn, (ASTNode[]) null);\n\t}\n\t\n\tstatic Annotation[] addAnnotation(ASTNode source, Annotation[] originalAnnotationArray, char[][] annotationTypeFqn, ASTNode... args) {\n\t\tchar[] simpleName = annotationTypeFqn[annotationTypeFqn.length - 1];\n\t\t\n\t\tif (originalAnnotationArray != null) for (Annotation ann : originalAnnotationArray) {\n\t\t\tif (ann.type instanceof QualifiedTypeReference) {\n\t\t\t\tchar[][] t = ((QualifiedTypeReference) ann.type).tokens;\n\t\t\t\tif (Arrays.deepEquals(t, annotationTypeFqn)) return originalAnnotationArray;\n\t\t\t}\n\t\t\t\n\t\t\tif (ann.type instanceof SingleTypeReference) {\n\t\t\t\tchar[] lastToken = ((SingleTypeReference) ann.type).token;\n\t\t\t\tif (Arrays.equals(lastToken, simpleName)) return originalAnnotationArray;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint pS = source.sourceStart, pE = source.sourceEnd;\n\t\tTypeReference qualifiedType = generateQualifiedTypeRef(source, annotationTypeFqn);\n\t\tAnnotation ann;\n\t\tif (args != null && args.length == 1 && args[0] instanceof Expression) {\n\t\t\tSingleMemberAnnotation sma = new SingleMemberAnnotation(qualifiedType, pS);\n\t\t\tsma.declarationSourceEnd = pE;\n\t\t\targs[0].sourceStart = pS;\n\t\t\targs[0].sourceEnd = pE;\n\t\t\tsma.memberValue = (Expression) args[0];\n\t\t\tsetGeneratedBy(sma.memberValue, source);\n\t\t\tann = sma;\n\t\t} else if (args != null && args.length >= 1 && arrayHasOnlyElementsOfType(args, MemberValuePair.class)) {\n\t\t\tNormalAnnotation na = new NormalAnnotation(qualifiedType, pS);\n\t\t\tna.declarationSourceEnd = pE;\n\t\t\tna.memberValuePairs = new MemberValuePair[args.length];\n\t\t\tfor (int i = 0; i < args.length; i++) {\n\t\t\t\targs[i].sourceStart = pS;\n\t\t\t\targs[i].sourceEnd = pE;\n\t\t\t\tna.memberValuePairs[i] = (MemberValuePair) args[i];\t\t\t\n\t\t\t}\n\t\t\tsetGeneratedBy(na.memberValuePairs[0], source);\n\t\t\tsetGeneratedBy(na.memberValuePairs[0].value, source);\n\t\t\tna.memberValuePairs[0].value.sourceStart = pS;\n\t\t\tna.memberValuePairs[0].value.sourceEnd = pE;\n\t\t\tann = na;\n\t\t} else {\n\t\t\tMarkerAnnotation ma = new MarkerAnnotation(qualifiedType, pS);\n\t\t\tma.declarationSourceEnd = pE;\n\t\t\tann = ma;\n\t\t}\n\t\tsetGeneratedBy(ann, source);\n\t\tif (originalAnnotationArray == null) return new Annotation[] { ann };\n\t\tAnnotation[] newAnnotationArray = new Annotation[originalAnnotationArray.length + 1];\n\t\tSystem.arraycopy(originalAnnotationArray, 0, newAnnotationArray, 0, originalAnnotationArray.length);\n\t\tnewAnnotationArray[originalAnnotationArray.length] = ann;\n\t\treturn newAnnotationArray;\n\t}\n\t\n\tprivate static boolean arrayHasOnlyElementsOfType(Object[] array, Class<?> clazz) {\n\t\tfor (Object element : array) {\n\t\t\tif (!clazz.isInstance(element))\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Generates a new statement that checks if the given local variable is null, and if so, throws a specified exception with the\n\t * variable name as message.\n\t */\n\tpublic static Statement generateNullCheck(TypeReference type, char[] variable, EclipseNode sourceNode, String customMessage) {\n\t\tNullCheckExceptionType exceptionType = sourceNode.getAst().readConfiguration(ConfigurationKeys.NON_NULL_EXCEPTION_TYPE);\n\t\tif (exceptionType == null) exceptionType = NullCheckExceptionType.NULL_POINTER_EXCEPTION;\n\t\t\n\t\tASTNode source = sourceNode.get();\n\t\t\n\t\tint pS = source.sourceStart, pE = source.sourceEnd;\n\t\tlong p = (long) pS << 32 | pE;\n\t\t\n\t\tif (type != null && isPrimitive(type)) return null;\n\t\tSingleNameReference varName = new SingleNameReference(variable, p);\n\t\tsetGeneratedBy(varName, source);\n\t\t\n\t\tStringLiteral message = new StringLiteral(exceptionType.toExceptionMessage(new String(variable), customMessage).toCharArray(), pS, pE, 0);\n\t\tsetGeneratedBy(message, source);\n\t\t\n\t\tLombokImmutableList<String> method = exceptionType.getMethod();\n\t\tif (method != null) {\n\t\t\t\n\t\t\tMessageSend invocation = new MessageSend();\n\t\t\tinvocation.sourceStart = pS; invocation.sourceEnd = pE;\n\t\t\tsetGeneratedBy(invocation, source);\n\t\t\t\n\t\t\tchar[][] utilityTypeName = new char[method.size() - 1][];\n\t\t\tfor (int i = 0; i < method.size() - 1; i++) {\n\t\t\t\tutilityTypeName[i] = method.get(i).toCharArray();\n\t\t\t}\n\t\t\t\n\t\t\tinvocation.receiver = new QualifiedNameReference(utilityTypeName, new long[method.size() - 1], pS, pE);\n\t\t\tsetGeneratedBy(invocation.receiver, source);\n\t\t\tinvocation.selector = method.get(method.size() - 1).toCharArray();\n\t\t\tinvocation.arguments = new Expression[] {varName, message};\n\t\t\treturn invocation;\n\t\t}\n\t\t\n\t\tAllocationExpression exception = new AllocationExpression();\n\t\tsetGeneratedBy(exception, source);\n\t\t\n\t\tNullLiteral nullLiteral = new NullLiteral(pS, pE);\n\t\tsetGeneratedBy(nullLiteral, source);\n\t\t\n\t\tint equalOperator = exceptionType == NullCheckExceptionType.ASSERTION ? OperatorIds.NOT_EQUAL : OperatorIds.EQUAL_EQUAL; \n\t\tEqualExpression equalExpression = new EqualExpression(varName, nullLiteral, equalOperator);\n\t\tequalExpression.sourceStart = pS; equalExpression.statementEnd = equalExpression.sourceEnd = pE;\n\t\tsetGeneratedBy(equalExpression, source);\n\t\t\n\t\tif (exceptionType == NullCheckExceptionType.ASSERTION) {\n\t\t\tStatement assertStatement = new AssertStatement(message, equalExpression, pS);\n\t\t\tsetGeneratedBy(assertStatement, source);\n\t\t\treturn assertStatement;\n\t\t}\n\t\t\n\t\tString exceptionTypeStr = exceptionType.getExceptionType();\n\t\tint partCount = 1;\n\t\tfor (int i = 0; i < exceptionTypeStr.length(); i++) if (exceptionTypeStr.charAt(i) == '.') partCount++;\n\t\tlong[] ps = new long[partCount];\n\t\tArrays.fill(ps, 0L);\n\t\texception.type = new QualifiedTypeReference(fromQualifiedName(exceptionTypeStr), ps);\n\t\tsetGeneratedBy(exception.type, source);\n\t\texception.arguments = new Expression[] {message};\n\t\t\n\t\tThrowStatement throwStatement = new ThrowStatement(exception, pS, pE);\n\t\tsetGeneratedBy(throwStatement, source);\n\t\t\n\t\tBlock throwBlock = new Block(0);\n\t\tthrowBlock.statements = new Statement[] {throwStatement};\n\t\tthrowBlock.sourceStart = pS; throwBlock.sourceEnd = pE;\n\t\tsetGeneratedBy(throwBlock, source);\n\t\tIfStatement ifStatement = new IfStatement(equalExpression, throwBlock, 0, 0);\n\t\tsetGeneratedBy(ifStatement, source);\n\t\treturn ifStatement;\n\t}\n\t\n\t/**\n\t * Generates a new statement that checks if the given variable is null, and if so, throws a specified exception with the\n\t * variable name as message.\n\t * \n\t * @param exName The name of the exception to throw; normally {@code java.lang.NullPointerException}.\n\t */\n\tpublic static Statement generateNullCheck(AbstractVariableDeclaration variable, EclipseNode sourceNode, String customMessage) {\n\t\treturn generateNullCheck(variable.type, variable.name, sourceNode, customMessage);\n\t}\n\t\n\t/**\n\t * Create an annotation of the given name, and is marked as being generated by the given source.\n\t */\n\tpublic static MarkerAnnotation makeMarkerAnnotation(char[][] name, ASTNode source) {\n\t\tlong pos = (long) source.sourceStart << 32 | source.sourceEnd;\n\t\tlong[] poss = new long[name.length];\n\t\tArrays.fill(poss, pos);\n\t\tTypeReference typeRef = new QualifiedTypeReference(name, poss);\n\t\tsetGeneratedBy(typeRef, source);\n\t\tMarkerAnnotation ann = new MarkerAnnotation(typeRef, (int) (pos >> 32));\n\t\tann.declarationSourceEnd = ann.sourceEnd = ann.statementEnd = (int) pos;\n\t\tsetGeneratedBy(ann, source);\n\t\treturn ann;\n\t}\n\t\n\t/**\n\t * Given a list of field names and a node referring to a type, finds each name in the list that does not match a field within the type.\n\t */\n\tpublic static List<Integer> createListOfNonExistentFields(List<String> list, EclipseNode type, boolean excludeStandard, boolean excludeTransient) {\n\t\tboolean[] matched = new boolean[list.size()];\n\t\t\n\t\tfor (EclipseNode child : type.down()) {\n\t\t\tif (list.isEmpty()) break;\n\t\t\tif (child.getKind() != Kind.FIELD) continue;\n\t\t\tif (excludeStandard) {\n\t\t\t\tif ((((FieldDeclaration) child.get()).modifiers & ClassFileConstants.AccStatic) != 0) continue;\n\t\t\t\tif (child.getName().startsWith(\"$\")) continue;\n\t\t\t}\n\t\t\tif (excludeTransient && (((FieldDeclaration)child.get()).modifiers & ClassFileConstants.AccTransient) != 0) continue;\n\t\t\tint idx = list.indexOf(child.getName());\n\t\t\tif (idx > -1) matched[idx] = true;\n\t\t}\n\t\t\n\t\tList<Integer> problematic = new ArrayList<Integer>();\n\t\tfor (int i = 0 ; i < list.size() ; i++) {\n\t\t\tif (!matched[i]) problematic.add(i);\n\t\t}\n\t\t\n\t\treturn problematic;\n\t}\n\t\n\t/**\n\t * In eclipse 3.7+, the CastExpression constructor was changed from a really weird version to\n\t * a less weird one. Unfortunately that means we need to use reflection as we want to be compatible\n\t * with eclipse versions before 3.7 and 3.7+.\n\t * \n\t * @param ref The {@code foo} in {@code (String)foo}.\n\t * @param castTo The {@code String} in {@code (String)foo}.\n\t */\n\tpublic static CastExpression makeCastExpression(Expression ref, TypeReference castTo, ASTNode source) {\n\t\tCastExpression result;\n\t\ttry {\n\t\t\tif (castExpressionConstructorIsTypeRefBased) {\n\t\t\t\tresult = castExpressionConstructor.newInstance(ref, castTo);\n\t\t\t} else {\n\t\t\t\tExpression castToConverted = castTo;\n\t\t\t\t\n\t\t\t\tif (castTo.getClass() == SingleTypeReference.class && !isPrimitive(castTo)) {\n\t\t\t\t\tSingleTypeReference str = (SingleTypeReference) castTo;\n\t\t\t\t\t//Why a SingleNameReference instead of a SingleTypeReference you ask? I don't know. It seems dumb. Ask the ecj guys.\n\t\t\t\t\tcastToConverted = new SingleNameReference(str.token, 0);\n\t\t\t\t\tcastToConverted.bits = (castToConverted.bits & ~Binding.VARIABLE) | Binding.TYPE;\n\t\t\t\t\tcastToConverted.sourceStart = str.sourceStart;\n\t\t\t\t\tcastToConverted.sourceEnd = str.sourceEnd;\n\t\t\t\t\tsetGeneratedBy(castToConverted, source);\n\t\t\t\t} else if (castTo.getClass() == QualifiedTypeReference.class) {\n\t\t\t\t\tQualifiedTypeReference qtr = (QualifiedTypeReference) castTo;\n\t\t\t\t\t//Same here, but for the more complex types, they stay types.\n\t\t\t\t\tcastToConverted = new QualifiedNameReference(qtr.tokens, copy(qtr.sourcePositions), qtr.sourceStart, qtr.sourceEnd);\n\t\t\t\t\tcastToConverted.bits = (castToConverted.bits & ~Binding.VARIABLE) | Binding.TYPE;\n\t\t\t\t\tsetGeneratedBy(castToConverted, source);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tresult = castExpressionConstructor.newInstance(ref, castToConverted);\n\t\t\t}\n\t\t} catch (InvocationTargetException e) {\n\t\t\tthrow Lombok.sneakyThrow(e.getCause());\n\t\t} catch (IllegalAccessException e) {\n\t\t\tthrow Lombok.sneakyThrow(e);\n\t\t} catch (InstantiationException e) {\n\t\t\tthrow Lombok.sneakyThrow(e);\n\t\t}\n\t\t\n\t\tresult.sourceStart = source.sourceStart;\n\t\tresult.sourceEnd = source.sourceEnd;\n\t\tresult.statementEnd = source.sourceEnd;\n\t\t\n\t\tsetGeneratedBy(result, source);\n\t\treturn result;\n\t}\n\t\n\tprivate static final Constructor<CastExpression> castExpressionConstructor;\n\tprivate static final boolean castExpressionConstructorIsTypeRefBased;\n\t\n\tstatic {\n\t\tConstructor<?> constructor = null;\n\t\tfor (Constructor<?> ctor : CastExpression.class.getConstructors()) {\n\t\t\tif (ctor.getParameterTypes().length != 2) continue;\n\t\t\tconstructor = ctor;\n\t\t}\n\t\t\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tConstructor<CastExpression> castExpressionConstructor_ = (Constructor<CastExpression>) constructor;\n\t\tcastExpressionConstructor = castExpressionConstructor_;\n\t\t\n\t\tcastExpressionConstructorIsTypeRefBased =\n\t\t\t\t(castExpressionConstructor.getParameterTypes()[1] == TypeReference.class);\n\t}\n\t\n\t/**\n\t * In eclipse 3.7+, IntLiterals are created using a factory-method \n\t * Unfortunately that means we need to use reflection as we want to be compatible\n\t * with eclipse versions before 3.7.\n\t */\n\tpublic static IntLiteral makeIntLiteral(char[] token, ASTNode source) {\n\t\tint pS = source == null ? 0 : source.sourceStart, pE = source == null ? 0 : source.sourceEnd;\n\t\tIntLiteral result;\n\t\tif (intLiteralConstructor != null) {\n\t\t\tresult = Permit.newInstanceSneaky(intLiteralConstructor, token, pS, pE);\n\t\t} else {\n\t\t\tresult = (IntLiteral) Permit.invokeSneaky(intLiteralFactoryMethod, null, token, pS, pE);\n\t\t}\n\t\t\n\t\tif (source != null) setGeneratedBy(result, source);\n\t\treturn result;\n\t}\n\t\n\tprivate static final Constructor<IntLiteral> intLiteralConstructor;\n\tprivate static final Method intLiteralFactoryMethod;\n\t\n\tstatic {\n\t\tClass<?>[] parameterTypes = {char[].class, int.class, int.class};\n\t\tConstructor<IntLiteral> intLiteralConstructor_ = null;\n\t\tMethod intLiteralFactoryMethod_ = null;\n\t\ttry { \n\t\t\tintLiteralConstructor_ = Permit.getConstructor(IntLiteral.class, parameterTypes);\n\t\t} catch (Throwable ignore) {\n\t\t\t// probably eclipse 3.7++\n\t\t}\n\t\ttry { \n\t\t\tintLiteralFactoryMethod_ = Permit.getMethod(IntLiteral.class, \"buildIntLiteral\", parameterTypes);\n\t\t} catch (Throwable ignore) {\n\t\t\t// probably eclipse versions before 3.7\n\t\t}\n\t\tintLiteralConstructor = intLiteralConstructor_;\n\t\tintLiteralFactoryMethod = intLiteralFactoryMethod_;\n\t}\n\t\n\tprivate static boolean isAllValidOnXCharacters(char[] in) {\n\t\tif (in == null || in.length == 0) return false;\n\t\tfor (char c : in) if (c != '_' && c != 'X' && c != 'x' && c != '$') return false;\n\t\treturn true;\n\t}\n\t\n\tpublic static void addError(String errorName, EclipseNode node) {\n\t\tif (node.getLatestJavaSpecSupported() < 8) {\n\t\t\tnode.addError(\"The correct format is \" + errorName + \"_={@SomeAnnotation, @SomeOtherAnnotation})\");\n\t\t} else {\n\t\t\tnode.addError(\"The correct format is \" + errorName + \"=@__({@SomeAnnotation, @SomeOtherAnnotation}))\");\n\t\t}\n\t}\n\t\n\tpublic static List<Annotation> unboxAndRemoveAnnotationParameter(Annotation annotation, String annotationName, String errorName, EclipseNode errorNode) {\n\t\tif (\"value\".equals(annotationName)) {\n\t\t\t// We can't unbox this, because SingleMemberAnnotation REQUIRES a value, and this method\n\t\t\t// is supposed to remove the value. That means we need to replace the SMA with either\n\t\t\t// MarkerAnnotation or NormalAnnotation and that is beyond the scope of this method as we\n\t\t\t// don't need that at the time of writing this method; we only unbox onMethod, onParameter\n\t\t\t// and onConstructor. Let's exit early and very obviously:\n\t\t\tthrow new UnsupportedOperationException(\"Lombok cannot unbox 'value' from SingleMemberAnnotation at this time.\");\n\t\t}\n\t\tif (!NormalAnnotation.class.equals(annotation.getClass())) {\n\t\t\t// Prevent MarkerAnnotation, SingleMemberAnnotation, and\n\t\t\t// CompletionOnAnnotationMemberValuePair from triggering this handler.\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t\t\n\t\tNormalAnnotation normalAnnotation = (NormalAnnotation) annotation;\n\t\tMemberValuePair[] pairs = normalAnnotation.memberValuePairs;\n\t\t\n\t\tif (pairs == null) return Collections.emptyList();\n\t\t\n\t\tchar[] nameAsCharArray = annotationName.toCharArray();\n\t\t\n\t\ttop:\n\t\tfor (int i = 0; i < pairs.length; i++) {\n\t\t\tboolean allowRaw;\n\t\t\tchar[] name = pairs[i].name;\n\t\t\tif (name == null) continue;\n\t\t\tif (name.length < nameAsCharArray.length) continue;\n\t\t\tfor (int j = 0; j < nameAsCharArray.length; j++) {\n\t\t\t\tif (name[j] != nameAsCharArray[j]) continue top;\n\t\t\t}\n\t\t\tallowRaw = name.length > nameAsCharArray.length;\n\t\t\tfor (int j = nameAsCharArray.length; j < name.length; j++) {\n\t\t\t\tif (name[j] != '_') continue top;\n\t\t\t}\n\t\t\t// If we're still here it's the targeted annotation param.\n\t\t\tExpression value = pairs[i].value;\n\t\t\tMemberValuePair[] newPairs = new MemberValuePair[pairs.length - 1];\n\t\t\tif (i > 0) System.arraycopy(pairs, 0, newPairs, 0, i);\n\t\t\tif (i < pairs.length - 1) System.arraycopy(pairs, i + 1, newPairs, i, pairs.length - i - 1);\n\t\t\tnormalAnnotation.memberValuePairs = newPairs;\n\t\t\t// We have now removed the annotation parameter and stored the value,\n\t\t\t// which we must now unbox. It's either annotations, or @__(annotations).\n\t\t\t\n\t\t\tExpression content = null;\n\t\t\t\n\t\t\tif (value instanceof ArrayInitializer) {\n\t\t\t\tif (!allowRaw) {\n\t\t\t\t\taddError(errorName, errorNode);\n\t\t\t\t\treturn Collections.emptyList();\n\t\t\t\t}\n\t\t\t\tcontent = value;\n\t\t\t} else if (!(value instanceof Annotation)) {\n\t\t\t\taddError(errorName, errorNode);\n\t\t\t\treturn Collections.emptyList();\n\t\t\t} else {\n\t\t\t\tAnnotation atDummyIdentifier = (Annotation) value;\n\t\t\t\tif (atDummyIdentifier.type instanceof SingleTypeReference && isAllValidOnXCharacters(((SingleTypeReference) atDummyIdentifier.type).token)) {\n\t\t\t\t\tif (atDummyIdentifier instanceof MarkerAnnotation) {\n\t\t\t\t\t\treturn Collections.emptyList();\n\t\t\t\t\t} else if (atDummyIdentifier instanceof NormalAnnotation) {\n\t\t\t\t\t\tMemberValuePair[] mvps = ((NormalAnnotation) atDummyIdentifier).memberValuePairs;\n\t\t\t\t\t\tif (mvps == null || mvps.length == 0) {\n\t\t\t\t\t\t\treturn Collections.emptyList();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (mvps.length == 1 && Arrays.equals(\"value\".toCharArray(), mvps[0].name)) {\n\t\t\t\t\t\t\tcontent = mvps[0].value;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (atDummyIdentifier instanceof SingleMemberAnnotation) {\n\t\t\t\t\t\tcontent = ((SingleMemberAnnotation) atDummyIdentifier).memberValue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\taddError(errorName, errorNode);\n\t\t\t\t\t\treturn Collections.emptyList();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (allowRaw) {\n\t\t\t\t\t\tcontent = atDummyIdentifier;\n\t\t\t\t\t} else {\n\t\t\t\t\t\taddError(errorName, errorNode);\n\t\t\t\t\t\treturn Collections.emptyList();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (content == null) {\n\t\t\t\taddError(errorName, errorNode);\n\t\t\t\treturn Collections.emptyList();\n\t\t\t}\n\t\t\t\n\t\t\tif (content instanceof Annotation) {\n\t\t\t\treturn Collections.singletonList((Annotation) content);\n\t\t\t} else if (content instanceof ArrayInitializer) {\n\t\t\t\tExpression[] expressions = ((ArrayInitializer) content).expressions;\n\t\t\t\tList<Annotation> result = new ArrayList<Annotation>();\n\t\t\t\tif (expressions != null) for (Expression ex : expressions) {\n\t\t\t\t\tif (ex instanceof Annotation) result.add((Annotation) ex);\n\t\t\t\t\telse {\n\t\t\t\t\t\taddError(errorName, errorNode);\n\t\t\t\t\t\treturn Collections.emptyList();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\taddError(errorName, errorNode);\n\t\t\t\treturn Collections.emptyList();\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn Collections.emptyList();\n\t}\n\t\n\tpublic static NameReference createNameReference(String name, Annotation source) {\n\t\treturn generateQualifiedNameRef(source, fromQualifiedName(name));\n\t}\n\t\n\tprivate static long[] copy(long[] array) {\n\t\treturn array == null ? null : array.clone();\n\t}\n\t\n\tpublic static <T> T[] concat(T[] first, T[] second, Class<T> type) {\n\t\tif (first == null)\n\t\t\treturn second;\n\t\tif (second == null)\n\t\t\treturn first;\n\t\tif (first.length == 0)\n\t\t\treturn second;\n\t\tif (second.length == 0)\n\t\t\treturn first;\n\t\tT[] result = newArray(type, first.length + second.length);\n\t\tSystem.arraycopy(first, 0, result, 0, first.length);\n\t\tSystem.arraycopy(second, 0, result, first.length, second.length);\n\t\treturn result;\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tprivate static <T> T[] newArray(Class<T> type, int length) {\n\t\treturn (T[]) Array.newInstance(type, length);\n\t}\n\t\n\tpublic static boolean isDirectDescendantOfObject(EclipseNode typeNode) {\n\t\tif (!(typeNode.get() instanceof TypeDeclaration)) throw new IllegalArgumentException(\"not a type node\");\n\t\tTypeDeclaration typeDecl = (TypeDeclaration) typeNode.get();\n\t\tif (typeDecl.superclass == null) return true;\n\t\tString p = typeDecl.superclass.toString();\n\t\treturn p.equals(\"Object\") || p.equals(\"java.lang.Object\");\n\t}\n\t\n\tpublic static void createRelevantNullableAnnotation(EclipseNode typeNode, MethodDeclaration mth) {\n\t\tNullAnnotationLibrary lib = typeNode.getAst().readConfiguration(ConfigurationKeys.ADD_NULL_ANNOTATIONS);\n\t\tif (lib == null) return;\n\t\t\n\t\tapplyAnnotationToMethodDecl(typeNode, mth, lib.getNullableAnnotation(), lib.isTypeUse());\n\t}\n\t\n\tpublic static void createRelevantNonNullAnnotation(EclipseNode typeNode, MethodDeclaration mth) {\n\t\tNullAnnotationLibrary lib = typeNode.getAst().readConfiguration(ConfigurationKeys.ADD_NULL_ANNOTATIONS);\n\t\tif (lib == null) return;\n\t\t\n\t\tapplyAnnotationToMethodDecl(typeNode, mth, lib.getNonNullAnnotation(), lib.isTypeUse());\n\t}\n\t\n\tpublic static void createRelevantNullableAnnotation(EclipseNode typeNode, Argument arg) {\n\t\tNullAnnotationLibrary lib = typeNode.getAst().readConfiguration(ConfigurationKeys.ADD_NULL_ANNOTATIONS);\n\t\tif (lib == null) return;\n\t\t\n\t\tapplyAnnotationToVarDecl(typeNode, arg, lib.getNullableAnnotation(), lib.isTypeUse());\n\t}\n\t\n\tpublic static void createRelevantNonNullAnnotation(EclipseNode typeNode, Argument arg) {\n\t\tNullAnnotationLibrary lib = typeNode.getAst().readConfiguration(ConfigurationKeys.ADD_NULL_ANNOTATIONS);\n\t\tif (lib == null) return;\n\t\t\n\t\tapplyAnnotationToVarDecl(typeNode, arg, lib.getNonNullAnnotation(), lib.isTypeUse());\n\t}\n\t\n\tprivate static void applyAnnotationToMethodDecl(EclipseNode typeNode, MethodDeclaration mth, String annType, boolean typeUse) {\n\t\tif (annType == null) return;\n\t\t\n\t\tint partCount = 1;\n\t\tfor (int i = 0; i < annType.length(); i++) if (annType.charAt(i) == '.') partCount++;\n\t\tlong[] ps = new long[partCount];\n\t\tArrays.fill(ps, 0L);\n\t\tAnnotation ann = new MarkerAnnotation(new QualifiedTypeReference(Eclipse.fromQualifiedName(annType), ps), 0);\n\t\t\n\t\tif (!typeUse || mth.returnType == null || mth.returnType.getTypeName().length < 2) {\n\t\t\tAnnotation[] a = mth.annotations;\n\t\t\tif (a == null) a = new Annotation[1];\n\t\t\telse {\n\t\t\t\tAnnotation[] b = new Annotation[a.length + 1];\n\t\t\t\tSystem.arraycopy(a, 0, b, 0, a.length);\n\t\t\t\ta = b;\n\t\t\t}\n\t\t\ta[a.length - 1] = ann;\n\t\t\tmth.annotations = a;\n\t\t} else {\n\t\t\tint len = mth.returnType.getTypeName().length;\n\t\t\tif (mth.returnType.annotations == null) mth.returnType.annotations = new Annotation[len][];\n\t\t\tAnnotation[] a = mth.returnType.annotations[len - 1];\n\t\t\tif (a == null) a = new Annotation[1];\n\t\t\telse {\n\t\t\t\tAnnotation[] b = new Annotation[a.length + 1];\n\t\t\t\tSystem.arraycopy(a, 0, b, 1, a.length);\n\t\t\t\ta = b;\n\t\t\t}\n\t\t\ta[0] = ann;\n\t\t\tmth.returnType.annotations[len - 1] = a;\n\t\t}\n\t}\n\tprivate static void applyAnnotationToVarDecl(EclipseNode typeNode, Argument arg, String annType, boolean typeUse) {\n\t\tif (annType == null) return;\n\t\t\n\t\tint partCount = 1;\n\t\tfor (int i = 0; i < annType.length(); i++) if (annType.charAt(i) == '.') partCount++;\n\t\tlong[] ps = new long[partCount];\n\t\tArrays.fill(ps, 0L);\n\t\tAnnotation ann = new MarkerAnnotation(new QualifiedTypeReference(Eclipse.fromQualifiedName(annType), ps), 0);\n\t\t\n\t\tif (!typeUse || arg.type.getTypeName().length < 2) {\n\t\t\tAnnotation[] a = arg.annotations;\n\t\t\tif (a == null) a = new Annotation[1];\n\t\t\telse {\n\t\t\t\tAnnotation[] b = new Annotation[a.length + 1];\n\t\t\t\tSystem.arraycopy(a, 0, b, 0, a.length);\n\t\t\t\ta = b;\n\t\t\t}\n\t\t\ta[a.length - 1] = ann;\n\t\t\targ.annotations = a;\n\t\t} else {\n\t\t\tint len = arg.type.getTypeName().length;\n\t\t\tif (arg.type.annotations == null) arg.type.annotations = new Annotation[len][];\n\t\t\tAnnotation[] a = arg.type.annotations[len - 1];\n\t\t\tif (a == null) a = new Annotation[1];\n\t\t\telse {\n\t\t\t\tAnnotation[] b = new Annotation[a.length + 1];\n\t\t\t\tSystem.arraycopy(a, 0, b, 1, a.length);\n\t\t\t\ta = b;\n\t\t\t}\n\t\t\ta[0] = ann;\n\t\t\targ.type.annotations[len - 1] = a;\n\t\t}\n\t}\n\t\n\tpublic static NameReference generateQualifiedNameRef(ASTNode source, char[]... varNames) {\n\t\tint pS = source.sourceStart, pE = source.sourceEnd;\n\t\tlong p = (long)pS << 32 | pE;\n\t\t\n\t\tNameReference ref;\n\t\t\n\t\tif (varNames.length > 1) ref = new QualifiedNameReference(varNames, new long[varNames.length], pS, pE);\n\t\telse ref = new SingleNameReference(varNames[0], p);\n\t\tsetGeneratedBy(ref, source);\n\t\treturn ref;\n\t}\n\t\n\tpublic static TypeReference generateQualifiedTypeRef(ASTNode source, char[]... varNames) {\n\t\tint pS = source.sourceStart, pE = source.sourceEnd;\n\t\tlong p = (long)pS << 32 | pE;\n\t\t\n\t\tTypeReference ref;\n\t\t\n\t\tlong[] poss = Eclipse.poss(source, varNames.length);\n\t\tif (varNames.length > 1) ref = new QualifiedTypeReference(varNames, poss);\n\t\telse ref = new SingleTypeReference(varNames[0], p);\n\t\tsetGeneratedBy(ref, source);\n\t\treturn ref;\n\t}\n\t\n\tpublic static TypeReference createTypeReference(String typeName, ASTNode source) {\n\t\treturn generateQualifiedTypeRef(source, fromQualifiedName(typeName));\n\t}\n\t\n\t/**\n\t * Returns {@code true} if the provided node is an actual class and not some other type declaration (so, not an annotation definition, interface, enum, or record).\n\t */\n\tpublic static boolean isClass(EclipseNode typeNode) {\n\t\treturn isTypeAndDoesNotHaveFlags(typeNode, ClassFileConstants.AccInterface | ClassFileConstants.AccEnum | ClassFileConstants.AccAnnotation | AccRecord);\n\t}\n\t\n\t/**\n\t * Returns {@code true} if the provided node is an actual class or enum and not some other type declaration (so, not an annotation definition, interface, or record).\n\t */\n\tpublic static boolean isClassOrEnum(EclipseNode typeNode) {\n\t\treturn isTypeAndDoesNotHaveFlags(typeNode, ClassFileConstants.AccInterface | ClassFileConstants.AccAnnotation | AccRecord);\n\t}\n\t\n\t/**\n\t * Returns {@code true} if the provided node is an actual class, an enum or a record and not some other type declaration (so, not an annotation definition or interface).\n\t */\n\tpublic static boolean isClassEnumOrRecord(EclipseNode typeNode) {\n\t\treturn isTypeAndDoesNotHaveFlags(typeNode, ClassFileConstants.AccInterface | ClassFileConstants.AccAnnotation);\n\t}\n\t\n\t/**\n\t * Returns {@code true} if the provided node is a record declaration (so, not an annotation definition, interface, enum, or plain class).\n\t */\n\tpublic static boolean isRecord(EclipseNode typeNode) {\n\t\tTypeDeclaration typeDecl = null;\n\t\tif (typeNode.get() instanceof TypeDeclaration) typeDecl = (TypeDeclaration) typeNode.get();\n\t\tint modifiers = typeDecl == null ? 0 : typeDecl.modifiers;\n\t\treturn (modifiers & AccRecord) != 0;\n\t}\n\t\n\t/**\n\t * Returns {@code true} If the provided node is a field declaration, and represents a field in a {@code record} declaration.\n\t */\n\tpublic static boolean isRecordField(EclipseNode fieldNode) {\n\t\treturn fieldNode.getKind() == Kind.FIELD && (((FieldDeclaration) fieldNode.get()).modifiers & AccRecord) != 0;\n\t}\n\t\n\t/**\n\t * Returns {@code true) if the provided node is a type declaration <em>and<\/em> is <strong>not<\/strong> of any kind indicated by the flags (the intent is to pass flags usch as `ClassFileConstants.AccEnum`).\n\t */\n\tstatic boolean isTypeAndDoesNotHaveFlags(EclipseNode typeNode, long flags) {\n\t\tTypeDeclaration typeDecl = null;\n\t\tif (typeNode.get() instanceof TypeDeclaration) typeDecl = (TypeDeclaration) typeNode.get();\n\t\tint modifiers = typeDecl == null ? 0 : typeDecl.modifiers;\n\t\treturn (modifiers & flags) == 0;\n\t}\n\t\n\t/**\n\t * Returns {@code true} if the provided node supports static methods and types (top level or static class)\n\t */\n\tpublic static boolean isStaticAllowed(EclipseNode typeNode) {\n\t\tboolean staticAllowed = true;\n\t\t\n\t\twhile (typeNode.getKind() != Kind.COMPILATION_UNIT) {\n\t\t\tif (!staticAllowed) return false;\n\t\t\t\n\t\t\tstaticAllowed = typeNode.isStatic();\n\t\t\ttypeNode = typeNode.up();\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tpublic static AbstractVariableDeclaration[] getRecordComponents(TypeDeclaration typeDeclaration) {\n\t\tif (typeDeclaration == null || (typeDeclaration.modifiers & AccRecord) == 0) return null;\n\t\ttry {\n\t\t\treturn (AbstractVariableDeclaration[]) TYPE_DECLARATION_RECORD_COMPONENTS.get(typeDeclaration);\n\t\t} catch (Exception e) {\n\t\t\t// This presumably means this isn't a JDK16 - fall through.\n\t\t}\n\t\treturn null;\n\t}\n\t\n\tpublic static Annotation[][] getRecordFieldAnnotations(TypeDeclaration typeDeclaration) {\n\t\tif (typeDeclaration.fields == null) return null;\n\t\tAnnotation[][] annotations = new Annotation[typeDeclaration.fields.length][];\n\t\t\n\t\tAbstractVariableDeclaration[] recordComponents = getRecordComponents(typeDeclaration);\n\t\tif (recordComponents != null) {\n\t\t\tint j = 0;\n\t\t\tfor (int i = 0; i < typeDeclaration.fields.length; i++) {\n\t\t\t\tif ((typeDeclaration.fields[i].modifiers & AccRecord) != 0) {\n\t\t\t\t\tannotations[i] = recordComponents[j++].annotations;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn annotations;\n\t}\n\t\n\tpublic static String getDocComment(EclipseNode eclipseNode) {\n\t\tif (eclipseNode.getAst().getSource() == null) return null;\n\t\t\n\t\tfinal ASTNode node = eclipseNode.get();\n\t\tif (node instanceof FieldDeclaration) {\n\t\t\tFieldDeclaration fieldDeclaration = (FieldDeclaration) node;\n\t\t\tchar[] rawContent = CharOperation.subarray(eclipseNode.getAst().getSource(), fieldDeclaration.declarationSourceStart, fieldDeclaration.declarationSourceEnd);\n\t\t\tString rawContentString = new String(rawContent);\n\t\t\tint startIndex = rawContentString.indexOf(\"/**\");\n\t\t\tint endIndex = rawContentString.indexOf(\"*/\");\n\t\t\tif (startIndex != -1 && endIndex != -1) {\n\t\t\t\t/* Remove all leading asterisks */\n\t\t\t\treturn rawContentString.substring(startIndex + 3, endIndex).replaceAll(\"(?m)^\\\\s*\\\\* ?\", \"\").trim();\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\t\n\tpublic static void setDocComment(CompilationUnitDeclaration cud, EclipseNode eclipseNode, String doc) {\n\t\tsetDocComment(cud, (TypeDeclaration) upToTypeNode(eclipseNode).get(), eclipseNode.get(), doc);\n\t}\n\t \n\tpublic static void setDocComment(CompilationUnitDeclaration cud, TypeDeclaration type, ASTNode node, String doc) {\n\t\tif (doc == null) return;\n\t\t\n\t\tICompilationUnit compilationUnit = cud.compilationResult.compilationUnit;\n\t\tif (compilationUnit.getClass().equals(COMPILATION_UNIT)) {\n\t\t\ttry {\n\t\t\t\tcompilationUnit = (ICompilationUnit) Permit.invoke(COMPILATION_UNIT_ORIGINAL_FROM_CLONE, compilationUnit);\n\t\t\t} catch (Throwable t) { }\n\t\t}\n\t\t\n\t\tMap<String, String> docs = EcjAugments.CompilationUnit_javadoc.setIfAbsent(compilationUnit, new HashMap<String, String>());\n\t\tif (node instanceof AbstractMethodDeclaration) {\n\t\t\tAbstractMethodDeclaration methodDeclaration = (AbstractMethodDeclaration) node;\n\t\t\tString signature = getSignature(type, methodDeclaration);\n\t\t\t/* Add javadoc start marker, remove trailing line break, add leading asterisks to each line, add javadoc end marker */\n\t\t\tdocs.put(signature, String.format(\"/**%n%s%n */\", doc.replaceAll(\"$\\\\r?\\\\n\", \"\").replaceAll(\"(?m)^\", \" * \")));\n\t\t}\n\t}\n\t\n\tpublic static String getSignature(TypeDeclaration type, AbstractMethodDeclaration methodDeclaration) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append(type.name);\n\t\tsb.append(\".\");\n\t\tsb.append(methodDeclaration.selector);\n\t\tsb.append(\"(\");\n\t\tArgument[] arguments = methodDeclaration.arguments;\n\t\tif (arguments != null) {\n\t\t\tfor (Argument argument : arguments) {\n\t\t\t\tsb.append(String.valueOf(argument.type));\n\t\t\t}\n\t\t}\n\t\tsb.append(\")\");\n\t\treturn sb.toString();\n\t}\n\t\n\tpublic static enum CopyJavadoc {\n\t\tVERBATIM {\n\t\t\t@Override public String apply(final EclipseNode node) {\n\t\t\t\treturn getDocComment(node);\n\t\t\t}\n\t\t},\n\t\tGETTER {\n\t\t\t@Override public String apply(final EclipseNode node) {\n\t\t\t\tString javadoc = getDocComment(node);\n\t\t\t\t// step 1: Check if there is a 'GETTER' section. If yes, that becomes the new method's javadoc.\n\t\t\t\tString out = getJavadocSection(javadoc, \"GETTER\");\n\t\t\t\tfinal boolean sectionBased = out != null;\n\t\t\t\tif (!sectionBased) {\n\t\t\t\t\tout = stripLinesWithTagFromJavadoc(stripSectionsFromJavadoc(javadoc), JavadocTag.PARAM);\n\t\t\t\t}\n\t\t\t\treturn out;\n\t\t\t}\n\t\t},\n\t\tSETTER {\n\t\t\t@Override public String apply(final EclipseNode node) {\n\t\t\t\treturn applySetter(node, \"SETTER\");\n\t\t\t}\n\t\t},\n\t\tWITH {\n\t\t\t@Override public String apply(final EclipseNode node) {\n\t\t\t\treturn addReturnsUpdatedSelfIfNeeded(applySetter(node, \"WITH|WITHER\"));\n\t\t\t}\n\t\t},\n\t\tWITH_BY {\n\t\t\t@Override public String apply( final EclipseNode node) {\n\t\t\t\treturn applySetter(node, \"WITHBY|WITH_BY\");\n\t\t\t}\n\t\t};\n\t\t\n\t\tpublic abstract String apply(final EclipseNode node);\n\t\t\n\t\tprivate static String applySetter(EclipseNode node, String sectionName) {\n\t\t\tString javadoc = getDocComment(node);\n\t\t\t// step 1: Check if there is a 'SETTER' section. If yes, that becomes the new method's javadoc.\n\t\t\tString out = getJavadocSection(javadoc, sectionName);\n\t\t\tfinal boolean sectionBased = out != null;\n\t\t\tif (!sectionBased) {\n\t\t\t\tout = stripLinesWithTagFromJavadoc(stripSectionsFromJavadoc(javadoc), JavadocTag.RETURN);\n\t\t\t}\n\t\t\treturn shouldReturnThis(node) ? addReturnsThisIfNeeded(out) : out;\n\t\t}\n\t}\n\t\n\t/**\n\t * Copies javadoc on one node to the other.\n\t * \n\t * This one is a shortcut for {@link EclipseHandlerUtil#copyJavadoc(EclipseNode, ASTNode, TypeDeclaration, CopyJavadoc, boolean)}\n\t * if source and target node are in the same type.\n\t */\n\tpublic static void copyJavadoc(EclipseNode from, ASTNode to, CopyJavadoc copyMode) {\n\t\tcopyJavadoc(from, to, (TypeDeclaration) upToTypeNode(from).get(), copyMode, false);\n\t}\n\t\n\t/**\n\t * Copies javadoc on one node to the other.\n\t * \n\t * This one is a shortcut for {@link EclipseHandlerUtil#copyJavadoc(EclipseNode, ASTNode, TypeDeclaration, CopyJavadoc, boolean)}\n\t * if source and target node are in the same type.\n\t */\n\tpublic static void copyJavadoc(EclipseNode from, ASTNode to, CopyJavadoc copyMode, boolean forceAddReturn) {\n\t\tcopyJavadoc(from, to, (TypeDeclaration) upToTypeNode(from).get(), copyMode, forceAddReturn);\n\t}\n\t\n\tpublic static void copyJavadoc(EclipseNode from, ASTNode to, TypeDeclaration type, CopyJavadoc copyMode) {\n\t\tcopyJavadoc(from, to, type, copyMode, false);\n\t}\n\t\n\t/**\n\t * Copies javadoc on one node to the other.\n\t * \n\t * in 'GETTER' copyMode, first a 'GETTER' segment is searched for. If it exists, that will become the javadoc for the 'to' node, and this section is\n\t * stripped out of the 'from' node. If no 'GETTER' segment is found, then the entire javadoc is taken minus any {@code @param} lines and other sections.\n\t * any {@code @return} lines are stripped from 'from'.\n\t * \n\t * in 'SETTER' mode, stripping works similarly to 'GETTER' mode, except {@code param} are copied and stripped from the original and {@code @return} are skipped.\n\t */\n\tpublic static void copyJavadoc(EclipseNode from, ASTNode to, TypeDeclaration type, CopyJavadoc copyMode, boolean forceAddReturn) {\n\t\tif (copyMode == null) copyMode = CopyJavadoc.VERBATIM;\n\t\ttry {\n\t\t\tCompilationUnitDeclaration cud = ((CompilationUnitDeclaration) from.top().get());\n\t\t\tString newJavadoc = copyMode.apply(from);\n\t\t\tif (forceAddReturn) {\n\t\t\t\tnewJavadoc = addReturnsThisIfNeeded(newJavadoc);\n\t\t\t}\n\t\t\tsetDocComment(cud, type, to, newJavadoc);\n\t\t} catch (Exception ignore) {}\n\t}\n}\n","lineNo":2739}
{"Smelly Sample":"/*\n * Copyright (C) 2009-2021 The Project Lombok Authors.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage lombok.eclipse.handlers;\n\nimport static lombok.core.handlers.HandlerUtil.handleFlagUsage;\nimport static lombok.eclipse.handlers.EclipseHandlerUtil.*;\n\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.eclipse.jdt.internal.compiler.ast.ASTNode;\nimport org.eclipse.jdt.internal.compiler.ast.Annotation;\nimport org.eclipse.jdt.internal.compiler.ast.BinaryExpression;\nimport org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.Expression;\nimport org.eclipse.jdt.internal.compiler.ast.MessageSend;\nimport org.eclipse.jdt.internal.compiler.ast.MethodDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.NameReference;\nimport org.eclipse.jdt.internal.compiler.ast.OperatorIds;\nimport org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference;\nimport org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference;\nimport org.eclipse.jdt.internal.compiler.ast.ReturnStatement;\nimport org.eclipse.jdt.internal.compiler.ast.SingleNameReference;\nimport org.eclipse.jdt.internal.compiler.ast.Statement;\nimport org.eclipse.jdt.internal.compiler.ast.StringLiteral;\nimport org.eclipse.jdt.internal.compiler.ast.SuperReference;\nimport org.eclipse.jdt.internal.compiler.ast.ThisReference;\nimport org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.TypeReference;\nimport org.eclipse.jdt.internal.compiler.lookup.TypeConstants;\n\nimport lombok.AccessLevel;\nimport lombok.ConfigurationKeys;\nimport lombok.ToString;\nimport lombok.core.AST.Kind;\nimport lombok.core.AnnotationValues;\nimport lombok.core.configuration.CallSuperType;\nimport lombok.core.configuration.CheckerFrameworkVersion;\nimport lombok.core.handlers.HandlerUtil.FieldAccess;\nimport lombok.core.handlers.InclusionExclusionUtils;\nimport lombok.core.handlers.InclusionExclusionUtils.Included;\nimport lombok.eclipse.Eclipse;\nimport lombok.eclipse.EclipseAnnotationHandler;\nimport lombok.eclipse.EclipseNode;\nimport lombok.spi.Provides;\n\n/**\n * Handles the {@code ToString} annotation for eclipse.\n */\n@Provides\npublic class HandleToString extends EclipseAnnotationHandler<ToString> {\n\tpublic void handle(AnnotationValues<ToString> annotation, Annotation ast, EclipseNode annotationNode) {\n\t\thandleFlagUsage(annotationNode, ConfigurationKeys.TO_STRING_FLAG_USAGE, \"@ToString\");\n\t\t\n\t\tToString ann = annotation.getInstance();\n\t\tList<Included<EclipseNode, ToString.Include>> members = InclusionExclusionUtils.handleToStringMarking(annotationNode.up(), annotation, annotationNode);\n\t\tif (members == null) return;\n\t\t\n\t\tBoolean callSuper = ann.callSuper();\n\t\t\n\t\tif (!annotation.isExplicit(\"callSuper\")) callSuper = null;\n\t\t\n\t\tBoolean doNotUseGettersConfiguration = annotationNode.getAst().readConfiguration(ConfigurationKeys.TO_STRING_DO_NOT_USE_GETTERS);\n\t\tboolean doNotUseGetters = annotation.isExplicit(\"doNotUseGetters\") || doNotUseGettersConfiguration == null ? ann.doNotUseGetters() : doNotUseGettersConfiguration;\n\t\tFieldAccess fieldAccess = doNotUseGetters ? FieldAccess.PREFER_FIELD : FieldAccess.GETTER;\n\t\t\n\t\tBoolean fieldNamesConfiguration = annotationNode.getAst().readConfiguration(ConfigurationKeys.TO_STRING_INCLUDE_FIELD_NAMES);\n\t\tboolean includeFieldNames = annotation.isExplicit(\"includeFieldNames\") || fieldNamesConfiguration == null ? ann.includeFieldNames() : fieldNamesConfiguration;\n\t\t\n\t\tgenerateToString(annotationNode.up(), annotationNode, members, includeFieldNames, callSuper, true, fieldAccess);\n\t}\n\t\n\tpublic void generateToStringForType(EclipseNode typeNode, EclipseNode errorNode) {\n\t\tif (hasAnnotation(ToString.class, typeNode)) {\n\t\t\t//The annotation will make it happen, so we can skip it.\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tboolean includeFieldNames = true;\n\t\ttry {\n\t\t\tBoolean configuration = typeNode.getAst().readConfiguration(ConfigurationKeys.TO_STRING_INCLUDE_FIELD_NAMES);\n\t\t\tincludeFieldNames = configuration != null ? configuration : ((Boolean)ToString.class.getMethod(\"includeFieldNames\").getDefaultValue()).booleanValue();\n\t\t} catch (Exception ignore) {}\n\t\t\n\t\tBoolean doNotUseGettersConfiguration = typeNode.getAst().readConfiguration(ConfigurationKeys.TO_STRING_DO_NOT_USE_GETTERS);\n\t\tFieldAccess access = doNotUseGettersConfiguration == null || !doNotUseGettersConfiguration ? FieldAccess.GETTER : FieldAccess.PREFER_FIELD;\n\t\t\n\t\tList<Included<EclipseNode, ToString.Include>> members = InclusionExclusionUtils.handleToStringMarking(typeNode, null, null);\n\t\tgenerateToString(typeNode, errorNode, members, includeFieldNames, null, false, access);\n\t}\n\t\n\tpublic void generateToString(EclipseNode typeNode, EclipseNode errorNode, List<Included<EclipseNode, ToString.Include>> members,\n\t\tboolean includeFieldNames, Boolean callSuper, boolean whineIfExists, FieldAccess fieldAccess) {\n\t\t\n\t\tif (!isClassOrEnum(typeNode)) {\n\t\t\terrorNode.addError(\"@ToString is only supported on a class or enum.\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tswitch (methodExists(\"toString\", typeNode, 0)) {\n\t\tcase NOT_EXISTS:\n\t\t\tif (callSuper == null) {\n\t\t\t\tif (isDirectDescendantOfObject(typeNode)) {\n\t\t\t\t\tcallSuper = false;\n\t\t\t\t} else {\n\t\t\t\t\tCallSuperType cst = typeNode.getAst().readConfiguration(ConfigurationKeys.TO_STRING_CALL_SUPER);\n\t\t\t\t\tif (cst == null) cst = CallSuperType.SKIP;\n\t\t\t\t\tswitch (cst) {\n\t\t\t\t\tdefault:\n\t\t\t\t\tcase SKIP:\n\t\t\t\t\t\tcallSuper = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase WARN:\n\t\t\t\t\t\terrorNode.addWarning(\"Generating toString implementation but without a call to superclass, even though this class does not extend java.lang.Object. If this intentional, add '@ToString(callSuper=false)' to your type.\");\n\t\t\t\t\t\tcallSuper = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CALL:\n\t\t\t\t\t\tcallSuper = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tMethodDeclaration toString = createToString(typeNode, members, includeFieldNames, callSuper, errorNode.get(), fieldAccess);\n\t\t\tinjectMethod(typeNode, toString);\n\t\t\tbreak;\n\t\tcase EXISTS_BY_LOMBOK:\n\t\t\tbreak;\n\t\tdefault:\n\t\tcase EXISTS_BY_USER:\n\t\t\tif (whineIfExists) {\n\t\t\t\terrorNode.addWarning(\"Not generating toString(): A method with that name already exists\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static MethodDeclaration createToString(EclipseNode type, Collection<Included<EclipseNode, ToString.Include>> members,\n\t\tboolean includeNames, boolean callSuper, ASTNode source, FieldAccess fieldAccess) {\n\t\t\n\t\tString typeName = getTypeName(type);\n\t\tboolean isEnum = type.isEnumType();\n\t\t\n\t\tchar[] suffix = \")\".toCharArray();\n\t\tString infixS = \", \";\n\t\tchar[] infix = infixS.toCharArray();\n\t\tint pS = source.sourceStart, pE = source.sourceEnd;\n\t\tlong p = (long) pS << 32 | pE;\n\t\tfinal int PLUS = OperatorIds.PLUS;\n\t\t\n\t\tString prefix;\n\t\t\n\t\tif (callSuper) {\n\t\t\tprefix = \"(super=\";\n\t\t} else if (members.isEmpty()) {\n\t\t\tprefix = isEnum ? \"\" : \"()\";\n\t\t} else if (includeNames) {\n\t\t\tIncluded<EclipseNode, ToString.Include> firstMember = members.iterator().next();\n\t\t\tString name = firstMember.getInc() == null ? \"\" : firstMember.getInc().name();\n\t\t\tif (name.isEmpty()) name = firstMember.getNode().getName();\n\t\t\tprefix = \"(\" + name + \"=\";\n\t\t} else {\n\t\t\tprefix = \"(\";\n\t\t}\n\t\t\n\t\tboolean first = true;\n\t\tExpression current;\n\t\tif (!isEnum) {\n\t\t\tcurrent = new StringLiteral((typeName + prefix).toCharArray(), pS, pE, 0);\n\t\t\tsetGeneratedBy(current, source);\n\t\t} else {\n\t\t\tcurrent = new StringLiteral((typeName + \".\").toCharArray(), pS, pE, 0);\n\t\t\tsetGeneratedBy(current, source);\n\n\t\t\tMessageSend thisName = new MessageSend();\n\t\t\tthisName.sourceStart = pS; thisName.sourceEnd = pE;\n\t\t\tsetGeneratedBy(thisName, source);\n\t\t\tthisName.receiver = new ThisReference(pS, pE);\n\t\t\tsetGeneratedBy(thisName.receiver, source);\n\t\t\tthisName.selector = \"name\".toCharArray();\n\t\t\tcurrent = new BinaryExpression(current, thisName, PLUS);\n\t\t\tsetGeneratedBy(current, source);\n\t\t\t\n\t\t\tif (!prefix.isEmpty()) {\n\t\t\t\tStringLiteral px = new StringLiteral(prefix.toCharArray(), pS, pE, 0);\n\t\t\t\tsetGeneratedBy(px, source);\t\t\t\t\n\t\t\t\tcurrent = new BinaryExpression(current, px, PLUS);\n\t\t\t\tcurrent.sourceStart = pS; current.sourceEnd = pE;\n\t\t\t\tsetGeneratedBy(current, source);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (callSuper) {\n\t\t\tMessageSend callToSuper = new MessageSend();\n\t\t\tcallToSuper.sourceStart = pS; callToSuper.sourceEnd = pE;\n\t\t\tsetGeneratedBy(callToSuper, source);\n\t\t\tcallToSuper.receiver = new SuperReference(pS, pE);\n\t\t\tsetGeneratedBy(callToSuper.receiver, source);\n\t\t\tcallToSuper.selector = \"toString\".toCharArray();\n\t\t\tcurrent = new BinaryExpression(current, callToSuper, PLUS);\n\t\t\tsetGeneratedBy(current, source);\n\t\t\tfirst = false;\n\t\t}\n\t\t\n\t\tfor (Included<EclipseNode, ToString.Include> member : members) {\n\t\t\tEclipseNode memberNode = member.getNode();\n\t\t\t\n\t\t\tTypeReference fieldType = getFieldType(memberNode, fieldAccess);\n\t\t\tExpression memberAccessor;\n\t\t\tif (memberNode.getKind() == Kind.METHOD) {\n\t\t\t\tmemberAccessor = createMethodAccessor(memberNode, source);\n\t\t\t} else {\n\t\t\t\tmemberAccessor = createFieldAccessor(memberNode, fieldAccess, source);\n\t\t\t}\n\t\t\t\n\t\t\t// The distinction between primitive and object will be useful if we ever add a 'hideNulls' option.\n\t\t\tboolean fieldBaseTypeIsPrimitive = BUILT_IN_TYPES.contains(new String(fieldType.getLastToken()));\n\t\t\t@SuppressWarnings(\"unused\")\n\t\t\tboolean fieldIsPrimitive = fieldType.dimensions() == 0 && fieldBaseTypeIsPrimitive;\n\t\t\tboolean fieldIsPrimitiveArray = fieldType.dimensions() == 1 && fieldBaseTypeIsPrimitive;\n\t\t\tboolean fieldIsObjectArray = fieldType.dimensions() > 0 && !fieldIsPrimitiveArray;\n\t\t\t\n\t\t\tExpression ex;\n\t\t\tif (fieldIsPrimitiveArray || fieldIsObjectArray) {\n\t\t\t\tMessageSend arrayToString = new MessageSend();\n\t\t\t\tarrayToString.sourceStart = pS; arrayToString.sourceEnd = pE;\n\t\t\t\tarrayToString.receiver = generateQualifiedNameRef(source, TypeConstants.JAVA, TypeConstants.UTIL, \"Arrays\".toCharArray());\n\t\t\t\tarrayToString.arguments = new Expression[] { memberAccessor };\n\t\t\t\tsetGeneratedBy(arrayToString.arguments[0], source);\n\t\t\t\tarrayToString.selector = (fieldIsObjectArray ? \"deepToString\" : \"toString\").toCharArray();\n\t\t\t\tex = arrayToString;\n\t\t\t} else {\n\t\t\t\tex = memberAccessor;\n\t\t\t}\n\t\t\tsetGeneratedBy(ex, source);\n\t\t\t\n\t\t\tif (first) {\n\t\t\t\tcurrent = new BinaryExpression(current, ex, PLUS);\n\t\t\t\tcurrent.sourceStart = pS; current.sourceEnd = pE;\n\t\t\t\tsetGeneratedBy(current, source);\n\t\t\t\tfirst = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tStringLiteral fieldNameLiteral;\n\t\t\tif (includeNames) {\n\t\t\t\tString n = member.getInc() == null ? \"\" : member.getInc().name();\n\t\t\t\tif (n.isEmpty()) n = memberNode.getName();\n\t\t\t\tchar[] namePlusEqualsSign = (infixS + n + \"=\").toCharArray();\n\t\t\t\tfieldNameLiteral = new StringLiteral(namePlusEqualsSign, pS, pE, 0);\n\t\t\t} else {\n\t\t\t\tfieldNameLiteral = new StringLiteral(infix, pS, pE, 0);\n\t\t\t}\n\t\t\tsetGeneratedBy(fieldNameLiteral, source);\n\t\t\tcurrent = new BinaryExpression(current, fieldNameLiteral, PLUS);\n\t\t\tsetGeneratedBy(current, source);\n\t\t\tcurrent = new BinaryExpression(current, ex, PLUS);\n\t\t\tsetGeneratedBy(current, source);\n\t\t}\n\t\tif (!first) {\n\t\t\tStringLiteral suffixLiteral = new StringLiteral(suffix, pS, pE, 0);\n\t\t\tsetGeneratedBy(suffixLiteral, source);\n\t\t\tcurrent = new BinaryExpression(current, suffixLiteral, PLUS);\n\t\t\tsetGeneratedBy(current, source);\n\t\t}\n\t\t\n\t\tReturnStatement returnStatement = new ReturnStatement(current, pS, pE);\n\t\tsetGeneratedBy(returnStatement, source);\n\t\t\n\t\tMethodDeclaration method = new MethodDeclaration(((CompilationUnitDeclaration) type.top().get()).compilationResult);\n\t\tsetGeneratedBy(method, source);\n\t\tmethod.modifiers = toEclipseModifier(AccessLevel.PUBLIC);\n\t\tmethod.returnType = new QualifiedTypeReference(TypeConstants.JAVA_LANG_STRING, new long[] {p, p, p});\n\t\tsetGeneratedBy(method.returnType, source);\n\t\tAnnotation overrideAnnotation = makeMarkerAnnotation(TypeConstants.JAVA_LANG_OVERRIDE, source);\n\t\tif (getCheckerFrameworkVersion(type).generateSideEffectFree()) {\n\t\t\tmethod.annotations = new Annotation[] { overrideAnnotation, generateNamedAnnotation(source, CheckerFrameworkVersion.NAME__SIDE_EFFECT_FREE) };\n\t\t} else {\n\t\t\tmethod.annotations = new Annotation[] { overrideAnnotation };\n\t\t}\n\t\tmethod.arguments = null;\n\t\tmethod.selector = \"toString\".toCharArray();\n\t\tmethod.thrownExceptions = null;\n\t\tmethod.typeParameters = null;\n\t\tmethod.bits |= Eclipse.ECLIPSE_DO_NOT_TOUCH_FLAG;\n\t\tmethod.bodyStart = method.declarationSourceStart = method.sourceStart = source.sourceStart;\n\t\tmethod.bodyEnd = method.declarationSourceEnd = method.sourceEnd = source.sourceEnd;\n\t\tmethod.statements = new Statement[] { returnStatement };\n\t\tEclipseHandlerUtil.createRelevantNonNullAnnotation(type, method);\n\t\treturn method;\n\t}\n\t\n\tpublic static String getTypeName(EclipseNode type) {\n\t\tString typeName = getSingleTypeName(type);\n\t\tEclipseNode upType = type.up();\n\t\twhile (upType.getKind() == Kind.TYPE) {\n\t\t\ttypeName = getSingleTypeName(upType) + \".\" + typeName;\n\t\t\tupType = upType.up();\n\t\t}\n\t\treturn typeName;\n\t}\n\t\n\tpublic static String getSingleTypeName(EclipseNode type) {\n\t\tTypeDeclaration typeDeclaration = (TypeDeclaration)type.get();\n\t\tchar[] rawTypeName = typeDeclaration.name;\n\t\treturn rawTypeName == null ? \"\" : new String(rawTypeName);\n\t}\n\t\n\tprivate static final Set<String> BUILT_IN_TYPES = Collections.unmodifiableSet(new HashSet<String>(Arrays.asList(\n\t\t\t\"byte\", \"short\", \"int\", \"long\", \"char\", \"boolean\", \"double\", \"float\")));\n\t\n\tpublic static NameReference generateQualifiedNameRef(ASTNode source, char[]... varNames) {\n\t\tint pS = source.sourceStart, pE = source.sourceEnd;\n\t\tlong p = (long)pS << 32 | pE;\n\t\tNameReference ref;\n\t\tif (varNames.length > 1) ref = new QualifiedNameReference(varNames, new long[varNames.length], pS, pE);\n\t\telse ref = new SingleNameReference(varNames[0], p);\n\t\tsetGeneratedBy(ref, source);\n\t\treturn ref;\n\t}\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2009-2021 The Project Lombok Authors.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage lombok.eclipse.handlers;\n\nimport static lombok.core.handlers.HandlerUtil.handleFlagUsage;\nimport static lombok.eclipse.handlers.EclipseHandlerUtil.*;\n\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.eclipse.jdt.internal.compiler.ast.ASTNode;\nimport org.eclipse.jdt.internal.compiler.ast.Annotation;\nimport org.eclipse.jdt.internal.compiler.ast.BinaryExpression;\nimport org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.Expression;\nimport org.eclipse.jdt.internal.compiler.ast.MessageSend;\nimport org.eclipse.jdt.internal.compiler.ast.MethodDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.NameReference;\nimport org.eclipse.jdt.internal.compiler.ast.OperatorIds;\nimport org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference;\nimport org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference;\nimport org.eclipse.jdt.internal.compiler.ast.ReturnStatement;\nimport org.eclipse.jdt.internal.compiler.ast.SingleNameReference;\nimport org.eclipse.jdt.internal.compiler.ast.Statement;\nimport org.eclipse.jdt.internal.compiler.ast.StringLiteral;\nimport org.eclipse.jdt.internal.compiler.ast.SuperReference;\nimport org.eclipse.jdt.internal.compiler.ast.ThisReference;\nimport org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.TypeReference;\nimport org.eclipse.jdt.internal.compiler.lookup.TypeConstants;\n\nimport lombok.AccessLevel;\nimport lombok.ConfigurationKeys;\nimport lombok.ToString;\nimport lombok.core.AST.Kind;\nimport lombok.core.AnnotationValues;\nimport lombok.core.configuration.CallSuperType;\nimport lombok.core.configuration.CheckerFrameworkVersion;\nimport lombok.core.handlers.HandlerUtil.FieldAccess;\nimport lombok.core.handlers.InclusionExclusionUtils;\nimport lombok.core.handlers.InclusionExclusionUtils.Included;\nimport lombok.eclipse.Eclipse;\nimport lombok.eclipse.EclipseAnnotationHandler;\nimport lombok.eclipse.EclipseNode;\nimport lombok.spi.Provides;\n\n/**\n * Handles the {@code ToString} annotation for eclipse.\n */\n@Provides\npublic class HandleToString extends EclipseAnnotationHandler<ToString> {\n\tpublic void handle(AnnotationValues<ToString> annotation, Annotation ast, EclipseNode annotationNode) {\n\t\thandleFlagUsage(annotationNode, ConfigurationKeys.TO_STRING_FLAG_USAGE, \"@ToString\");\n\t\t\n\t\tToString ann = annotation.getInstance();\n\t\tList<Included<EclipseNode, ToString.Include>> members = InclusionExclusionUtils.handleToStringMarking(annotationNode.up(), annotation, annotationNode);\n\t\tif (members == null) return;\n\t\t\n\t\tBoolean callSuper = ann.callSuper();\n\t\t\n\t\tif (!annotation.isExplicit(\"callSuper\")) callSuper = null;\n\t\t\n\t\tBoolean doNotUseGettersConfiguration = annotationNode.getAst().readConfiguration(ConfigurationKeys.TO_STRING_DO_NOT_USE_GETTERS);\n\t\tboolean doNotUseGetters = annotation.isExplicit(\"doNotUseGetters\") || doNotUseGettersConfiguration == null ? ann.doNotUseGetters() : doNotUseGettersConfiguration;\n\t\tFieldAccess fieldAccess = doNotUseGetters ? FieldAccess.PREFER_FIELD : FieldAccess.GETTER;\n\t\t\n\t\tBoolean fieldNamesConfiguration = annotationNode.getAst().readConfiguration(ConfigurationKeys.TO_STRING_INCLUDE_FIELD_NAMES);\n\t\tboolean includeFieldNames = annotation.isExplicit(\"includeFieldNames\") || fieldNamesConfiguration == null ? ann.includeFieldNames() : fieldNamesConfiguration;\n\t\t\n\t\tgenerateToString(annotationNode.up(), annotationNode, members, includeFieldNames, callSuper, true, fieldAccess);\n\t}\n\t\n\tpublic void generateToStringForType(EclipseNode typeNode, EclipseNode errorNode) {\n\t\tif (hasAnnotation(ToString.class, typeNode)) {\n\t\t\t//The annotation will make it happen, so we can skip it.\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tboolean includeFieldNames = true;\n\t\ttry {\n\t\t\tBoolean configuration = typeNode.getAst().readConfiguration(ConfigurationKeys.TO_STRING_INCLUDE_FIELD_NAMES);\n\t\t\tincludeFieldNames = configuration != null ? configuration : ((Boolean)ToString.class.getMethod(\"includeFieldNames\").getDefaultValue()).booleanValue();\n\t\t} catch (Exception ignore) {}\n\t\t\n\t\tBoolean doNotUseGettersConfiguration = typeNode.getAst().readConfiguration(ConfigurationKeys.TO_STRING_DO_NOT_USE_GETTERS);\n\t\tFieldAccess access = doNotUseGettersConfiguration == null || !doNotUseGettersConfiguration ? FieldAccess.GETTER : FieldAccess.PREFER_FIELD;\n\t\t\n\t\tList<Included<EclipseNode, ToString.Include>> members = InclusionExclusionUtils.handleToStringMarking(typeNode, null, null);\n\t\tgenerateToString(typeNode, errorNode, members, includeFieldNames, null, false, access);\n\t}\n\t\n\tpublic void generateToString(EclipseNode typeNode, EclipseNode errorNode, List<Included<EclipseNode, ToString.Include>> members,\n\t\tboolean includeFieldNames, Boolean callSuper, boolean whineIfExists, FieldAccess fieldAccess) {\n\t\t\n\t\tif (!isClassOrEnum(typeNode)) {\n\t\t\terrorNode.addError(\"@ToString is only supported on a class or enum.\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tswitch (methodExists(\"toString\", typeNode, 0)) {\n\t\tcase NOT_EXISTS:\n\t\t\tif (callSuper == null) {\n\t\t\t\tif (isDirectDescendantOfObject(typeNode)) {\n\t\t\t\t\tcallSuper = false;\n\t\t\t\t} else {\n\t\t\t\t\tCallSuperType cst = typeNode.getAst().readConfiguration(ConfigurationKeys.TO_STRING_CALL_SUPER);\n\t\t\t\t\tif (cst == null) cst = CallSuperType.SKIP;\n\t\t\t\t\tswitch (cst) {\n\t\t\t\t\tdefault:\n\t\t\t\t\tcase SKIP:\n\t\t\t\t\t\tcallSuper = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase WARN:\n\t\t\t\t\t\terrorNode.addWarning(\"Generating toString implementation but without a call to superclass, even though this class does not extend java.lang.Object. If this intentional, add '@ToString(callSuper=false)' to your type.\");\n\t\t\t\t\t\tcallSuper = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CALL:\n\t\t\t\t\t\tcallSuper = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tMethodDeclaration toString = createToString(typeNode, members, includeFieldNames, callSuper, errorNode.get(), fieldAccess);\n\t\t\tinjectMethod(typeNode, toString);\n\t\t\tbreak;\n\t\tcase EXISTS_BY_LOMBOK:\n\t\t\tbreak;\n\t\tdefault:\n\t\tcase EXISTS_BY_USER:\n\t\t\tif (whineIfExists) {\n\t\t\t\terrorNode.addWarning(\"Not generating toString(): A method with that name already exists\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static MethodDeclaration createToString(EclipseNode type, Collection<Included<EclipseNode, ToString.Include>> members,\n\t\tboolean includeNames, boolean callSuper, ASTNode source, FieldAccess fieldAccess) {\n\t\t\n\t\tString typeName = getTypeName(type);\n\t\tboolean isEnum = type.isEnumType();\n\t\t\n\t\tchar[] suffix = \")\".toCharArray();\n\t\tString infixS = \", \";\n\t\tchar[] infix = infixS.toCharArray();\n\t\tint pS = source.sourceStart, pE = source.sourceEnd;\n\t\tlong p = (long) pS << 32 | pE;\n\t\tfinal int PLUS = OperatorIds.PLUS;\n\t\t\n\t\tString prefix;\n\t\t\n\t\tif (callSuper) {\n\t\t\tprefix = \"(super=\";\n\t\t} else if (members.isEmpty()) {\n\t\t\tprefix = isEnum ? \"\" : \"()\";\n\t\t} else if (includeNames) {\n\t\t\tIncluded<EclipseNode, ToString.Include> firstMember = members.iterator().next();\n\t\t\tString name = firstMember.getInc() == null ? \"\" : firstMember.getInc().name();\n\t\t\tif (name.isEmpty()) name = firstMember.getNode().getName();\n\t\t\tprefix = \"(\" + name + \"=\";\n\t\t} else {\n\t\t\tprefix = \"(\";\n\t\t}\n\t\t\n\t\tboolean first = true;\n\t\tExpression current;\n\t\tif (!isEnum) {\n\t\t\tcurrent = new StringLiteral((typeName + prefix).toCharArray(), pS, pE, 0);\n\t\t\tsetGeneratedBy(current, source);\n\t\t} else {\n\t\t\tcurrent = new StringLiteral((typeName + \".\").toCharArray(), pS, pE, 0);\n\t\t\tsetGeneratedBy(current, source);\n\n\t\t\tMessageSend thisName = new MessageSend();\n\t\t\tthisName.sourceStart = pS; thisName.sourceEnd = pE;\n\t\t\tsetGeneratedBy(thisName, source);\n\t\t\tthisName.receiver = new ThisReference(pS, pE);\n\t\t\tsetGeneratedBy(thisName.receiver, source);\n\t\t\tthisName.selector = \"name\".toCharArray();\n\t\t\tcurrent = new BinaryExpression(current, thisName, PLUS);\n\t\t\tsetGeneratedBy(current, source);\n\t\t\t\n\t\t\tif (!prefix.isEmpty()) {\n\t\t\t\tStringLiteral px = new StringLiteral(prefix.toCharArray(), pS, pE, 0);\n\t\t\t\tsetGeneratedBy(px, source);\t\t\t\t\n\t\t\t\tcurrent = new BinaryExpression(current, px, PLUS);\n\t\t\t\tcurrent.sourceStart = pS; current.sourceEnd = pE;\n\t\t\t\tsetGeneratedBy(current, source);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (callSuper) {\n\t\t\tMessageSend callToSuper = new MessageSend();\n\t\t\tcallToSuper.sourceStart = pS; callToSuper.sourceEnd = pE;\n\t\t\tsetGeneratedBy(callToSuper, source);\n\t\t\tcallToSuper.receiver = new SuperReference(pS, pE);\n\t\t\tsetGeneratedBy(callToSuper.receiver, source);\n\t\t\tcallToSuper.selector = \"toString\".toCharArray();\n\t\t\tcurrent = new BinaryExpression(current, callToSuper, PLUS);\n\t\t\tsetGeneratedBy(current, source);\n\t\t\tfirst = false;\n\t\t}\n\t\t\n\t\tfor (Included<EclipseNode, ToString.Include> member : members) {\n\t\t\tEclipseNode memberNode = member.getNode();\n\t\t\t\n\t\t\tTypeReference fieldType = getFieldType(memberNode, fieldAccess);\n\t\t\tExpression memberAccessor;\n\t\t\tif (memberNode.getKind() == Kind.METHOD) {\n\t\t\t\tmemberAccessor = createMethodAccessor(memberNode, source);\n\t\t\t} else {\n\t\t\t\tmemberAccessor = createFieldAccessor(memberNode, fieldAccess, source);\n\t\t\t}\n\t\t\t\n\t\t\t// The distinction between primitive and object will be useful if we ever add a 'hideNulls' option.\n\t\t\tboolean fieldBaseTypeIsPrimitive = BUILT_IN_TYPES.contains(new String(fieldType.getLastToken()));\n\t\t\t@SuppressWarnings(\"unused\")\n\t\t\tboolean fieldIsPrimitive = fieldType.dimensions() == 0 && fieldBaseTypeIsPrimitive;\n\t\t\tboolean fieldIsPrimitiveArray = fieldType.dimensions() == 1 && fieldBaseTypeIsPrimitive;\n\t\t\tboolean fieldIsObjectArray = fieldType.dimensions() > 0 && !fieldIsPrimitiveArray;\n\t\t\t\n\t\t\tExpression ex;\n\t\t\tif (fieldIsPrimitiveArray || fieldIsObjectArray) {\n\t\t\t\tMessageSend arrayToString = new MessageSend();\n\t\t\t\tarrayToString.sourceStart = pS; arrayToString.sourceEnd = pE;\n\t\t\t\tarrayToString.receiver = generateQualifiedNameRef(source, TypeConstants.JAVA, TypeConstants.UTIL, \"Arrays\".toCharArray());\n\t\t\t\tarrayToString.arguments = new Expression[] { memberAccessor };\n\t\t\t\tsetGeneratedBy(arrayToString.arguments[0], source);\n\t\t\t\tarrayToString.selector = (fieldIsObjectArray ? \"deepToString\" : \"toString\").toCharArray();\n\t\t\t\tex = arrayToString;\n\t\t\t} else {\n\t\t\t\tex = memberAccessor;\n\t\t\t}\n\t\t\tsetGeneratedBy(ex, source);\n\t\t\t\n\t\t\tif (first) {\n\t\t\t\tcurrent = new BinaryExpression(current, ex, PLUS);\n\t\t\t\tcurrent.sourceStart = pS; current.sourceEnd = pE;\n\t\t\t\tsetGeneratedBy(current, source);\n\t\t\t\tfirst = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tStringLiteral fieldNameLiteral;\n\t\t\tif (includeNames) {\n\t\t\t\tString n = member.getInc() == null ? \"\" : member.getInc().name();\n\t\t\t\tif (n.isEmpty()) n = memberNode.getName();\n\t\t\t\tchar[] namePlusEqualsSign = (infixS + n + \"=\").toCharArray();\n\t\t\t\tfieldNameLiteral = new StringLiteral(namePlusEqualsSign, pS, pE, 0);\n\t\t\t} else {\n\t\t\t\tfieldNameLiteral = new StringLiteral(infix, pS, pE, 0);\n\t\t\t}\n\t\t\tsetGeneratedBy(fieldNameLiteral, source);\n\t\t\tcurrent = new BinaryExpression(current, fieldNameLiteral, PLUS);\n\t\t\tsetGeneratedBy(current, source);\n\t\t\tcurrent = new BinaryExpression(current, ex, PLUS);\n\t\t\tsetGeneratedBy(current, source);\n\t\t}\n\t\tif (!first) {\n\t\t\tStringLiteral suffixLiteral = new StringLiteral(suffix, pS, pE, 0);\n\t\t\tsetGeneratedBy(suffixLiteral, source);\n\t\t\tcurrent = new BinaryExpression(current, suffixLiteral, PLUS);\n\t\t\tsetGeneratedBy(current, source);\n\t\t}\n\t\t\n\t\tReturnStatement returnStatement = new ReturnStatement(current, pS, pE);\n\t\tsetGeneratedBy(returnStatement, source);\n\t\t\n\t\tMethodDeclaration method = new MethodDeclaration(((CompilationUnitDeclaration) type.top().get()).compilationResult);\n\t\tsetGeneratedBy(method, source);\n\t\tmethod.modifiers = toEclipseModifier(AccessLevel.PUBLIC);\n\t\tmethod.returnType = new QualifiedTypeReference(TypeConstants.JAVA_LANG_STRING, new long[] {p, p, p});\n\t\tsetGeneratedBy(method.returnType, source);\n\t\tAnnotation overrideAnnotation = makeMarkerAnnotation(TypeConstants.JAVA_LANG_OVERRIDE, source);\n\t\tif (getCheckerFrameworkVersion(type).generateSideEffectFree()) {\n\t\t\tmethod.annotations = new Annotation[] { overrideAnnotation, generateNamedAnnotation(source, CheckerFrameworkVersion.NAME__SIDE_EFFECT_FREE) };\n\t\t} else {\n\t\t\tmethod.annotations = new Annotation[] { overrideAnnotation };\n\t\t}\n\t\tmethod.arguments = null;\n\t\tmethod.selector = \"toString\".toCharArray();\n\t\tmethod.thrownExceptions = null;\n\t\tmethod.typeParameters = null;\n\t\tmethod.bits |= Eclipse.ECLIPSE_DO_NOT_TOUCH_FLAG;\n\t\tmethod.bodyStart = method.declarationSourceStart = method.sourceStart = source.sourceStart;\n\t\tmethod.bodyEnd = method.declarationSourceEnd = method.sourceEnd = source.sourceEnd;\n\t\tmethod.statements = new Statement[] { returnStatement };\n\t\tEclipseHandlerUtil.createRelevantNonNullAnnotation(type, method);\n\t\treturn method;\n\t}\n\t\n\tpublic static String getTypeName(EclipseNode type) {\n\t\tString typeName = getSingleTypeName(type);\n\t\tEclipseNode upType = type.up();\n\t\twhile (upType.getKind() == Kind.TYPE) {\n\t\t\tString upTypeName = getSingleTypeName(upType);\n\t\t\tif (upTypeName.isEmpty()) break;\n\t\t\ttypeName = upTypeName + \".\" + typeName;\n\t\t\tupType = upType.up();\n\t\t}\n\t\treturn typeName;\n\t}\n\t\n\tpublic static String getSingleTypeName(EclipseNode type) {\n\t\tTypeDeclaration typeDeclaration = (TypeDeclaration)type.get();\n\t\tchar[] rawTypeName = typeDeclaration.name;\n\t\treturn rawTypeName == null ? \"\" : new String(rawTypeName);\n\t}\n\t\n\tprivate static final Set<String> BUILT_IN_TYPES = Collections.unmodifiableSet(new HashSet<String>(Arrays.asList(\n\t\t\t\"byte\", \"short\", \"int\", \"long\", \"char\", \"boolean\", \"double\", \"float\")));\n\t\n\tpublic static NameReference generateQualifiedNameRef(ASTNode source, char[]... varNames) {\n\t\tint pS = source.sourceStart, pE = source.sourceEnd;\n\t\tlong p = (long)pS << 32 | pE;\n\t\tNameReference ref;\n\t\tif (varNames.length > 1) ref = new QualifiedNameReference(varNames, new long[varNames.length], pS, pE);\n\t\telse ref = new SingleNameReference(varNames[0], p);\n\t\tsetGeneratedBy(ref, source);\n\t\treturn ref;\n\t}\n}\n","lineNo":318}
