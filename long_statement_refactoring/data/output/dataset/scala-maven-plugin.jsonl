{"Smelly Sample":"/*\n * This is free and unencumbered software released into the public domain.\n * See UNLICENSE.\n */\npackage scala_maven;\n\nimport java.io.File;\nimport java.util.*;\nimport java.util.regex.Pattern;\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.ArtifactUtils;\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.model.Dependency;\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugin.MojoFailureException;\nimport org.apache.maven.plugins.annotations.Component;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.project.DefaultProjectBuildingRequest;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.project.ProjectBuildingRequest;\nimport org.apache.maven.repository.RepositorySystem;\nimport org.apache.maven.shared.dependency.graph.DependencyGraphBuilder;\nimport org.apache.maven.shared.dependency.graph.DependencyNode;\nimport org.apache.maven.shared.dependency.graph.filter.AncestorOrSelfDependencyNodeFilter;\nimport org.apache.maven.shared.dependency.graph.filter.AndDependencyNodeFilter;\nimport org.apache.maven.shared.dependency.graph.filter.DependencyNodeFilter;\nimport org.apache.maven.shared.dependency.graph.traversal.CollectingDependencyNodeVisitor;\nimport org.apache.maven.shared.dependency.graph.traversal.DependencyNodeVisitor;\nimport org.apache.maven.shared.dependency.graph.traversal.FilteringDependencyNodeVisitor;\nimport org.apache.maven.toolchain.Toolchain;\nimport org.apache.maven.toolchain.ToolchainManager;\nimport org.codehaus.plexus.util.StringUtils;\nimport scala_maven_dependency.*;\nimport scala_maven_executions.JavaMainCaller;\nimport scala_maven_executions.JavaMainCallerByFork;\nimport scala_maven_executions.JavaMainCallerInProcess;\nimport util.FileUtils;\nimport util.JavaLocator;\n\npublic abstract class ScalaMojoSupport extends AbstractMojo {\n\n  /** The maven project. */\n  @Parameter(property = \"project\", required = true, readonly = true)\n  protected MavenProject project;\n\n  /**\n   * The Maven Session Object\n   *\n   * <p>Note: Allows extending for 3rd-party usages\n   */\n  @Parameter(property = \"session\", required = true, readonly = true)\n  protected MavenSession session;\n\n  /** Used to look up Artifacts in the remote repository. */\n  @Component RepositorySystem factory;\n\n  /**\n   * Additional dependencies/jar to add to classpath to run \"scalaClassName\" (scope and optional\n   * field not supported) ex :\n   *\n   * <pre>\n   *    &lt;dependencies&gt;\n   *      &lt;dependency&gt;\n   *        &lt;groupId&gt;org.scala-tools&lt;/groupId&gt;\n   *        &lt;artifactId&gt;scala-compiler-addon&lt;/artifactId&gt;\n   *        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n   *      &lt;/dependency&gt;\n   *    &lt;/dependencies&gt;\n   * <\/pre>\n   */\n  @Parameter protected BasicArtifact[] dependencies;\n\n  /**\n   * Compiler plugin dependencies to use when compiling. ex:\n   *\n   * <pre>\n   * &lt;compilerPlugins&gt;\n   *   &lt;compilerPlugin&gt;\n   *     &lt;groupId&gt;my.scala.plugin&lt;/groupId&gt;\n   *     &lt;artifactId&gt;amazingPlugin&lt;/artifactId&gt;\n   *     &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n   *   &lt;/compilerPlugin&gt;\n   * &lt;/compilerPlugins&gt;\n   * <\/pre>\n   */\n  @Parameter private BasicArtifact[] compilerPlugins;\n\n  /** Jvm Arguments. */\n  @Parameter protected String[] jvmArgs;\n\n  /** compiler additional arguments */\n  @Parameter protected String[] args;\n\n  /**\n   * Additional parameter to use to call the main class. Use this parameter only from command line\n   * (\"-DaddScalacArgs=arg1|arg2|arg3|...\"), not from pom.xml. To define compiler arguments in\n   * pom.xml see the \"args\" parameter.\n   */\n  @Parameter(property = \"addScalacArgs\")\n  private String addScalacArgs;\n\n  /** override the className (FQN) of the scala tool */\n  @Parameter(required = false, property = \"maven.scala.className\")\n  protected String scalaClassName;\n\n  /** Scala 's version to use. (property 'maven.scala.version' replaced by 'scala.version') */\n  @Parameter(property = \"scala.version\")\n  private String scalaVersion;\n\n  /**\n   * Organization/group ID of the Scala used in the project. Default value is 'org.scala-lang'. This\n   * is an advanced setting used for clones of the Scala Language. It should be disregarded in\n   * standard use cases.\n   */\n  @Parameter(property = \"scala.organization\", defaultValue = \"org.scala-lang\")\n  private String scalaOrganization;\n\n  /**\n   * Scala 's version to use to check binary compatibility (like suffix in artifactId of\n   * dependency). If it is defined then it is used to checkMultipleScalaVersions\n   */\n  @Parameter(property = \"scala.compat.version\")\n  private String scalaCompatVersion;\n\n  /** Path to Scala installation to use instead of the artifact (define as dependencies). */\n  @Parameter(property = \"scala.home\")\n  private String scalaHome;\n\n  /** Arguments for javac (when using incremental compiler). */\n  @Parameter(property = \"javacArgs\")\n  protected String[] javacArgs;\n\n  /**\n   * Whether to instruct javac to generate debug symbols (when using incremental compiler)\n   *\n   * @see <a href=\n   *     \"http://maven.apache.org/plugins/maven-compiler-plugin/compile-mojo.html#debug\">://maven.apache.org/plugins/maven-compiler-plugin/compile-mojo.html#debug<\/a>\n   */\n  @Parameter(property = \"javacGenerateDebugSymbols\", defaultValue = \"true\")\n  protected boolean javacGenerateDebugSymbols = true;\n\n  /**\n   * Alternative method for specifying javac arguments (when using incremental compiler). Can be\n   * used from command line with -DaddJavacArgs=arg1|arg2|arg3|... rather than in pom.xml.\n   */\n  @Parameter(property = \"addJavacArgs\")\n  protected String addJavacArgs;\n\n  /** The -source argument for the Java compiler (when using incremental compiler). */\n  @Parameter(property = \"maven.compiler.source\")\n  protected String source;\n\n  /** The -target argument for the Java compiler (when using incremental compiler). */\n  @Parameter(property = \"maven.compiler.target\")\n  protected String target;\n\n  /**\n   * The --release argument for the Java compiler (when using incremental compiler), supported since\n   * Java9.\n   */\n  @Parameter(property = \"maven.compiler.release\")\n  protected String release;\n\n  /** The -encoding argument for the Java compiler. (when using incremental compiler). */\n  @Parameter(property = \"project.build.sourceEncoding\", defaultValue = \"UTF-8\")\n  protected String encoding;\n\n  /**\n   * Display the command line called ? (property 'maven.scala.displayCmd' replaced by 'displayCmd')\n   */\n  @Parameter(property = \"displayCmd\", defaultValue = \"false\", required = true)\n  public boolean displayCmd;\n\n  /** Forks the execution of scalac into a separate process. */\n  @Parameter(defaultValue = \"true\")\n  protected boolean fork = true;\n\n  /** Force the use of an external ArgFile to run any forked process. */\n  @Parameter(defaultValue = \"false\")\n  protected boolean forceUseArgFile = false;\n\n  /** Check if every dependencies use the same version of scala-library or scala.compat.version. */\n  @Parameter(property = \"maven.scala.checkConsistency\", defaultValue = \"true\")\n  protected boolean checkMultipleScalaVersions;\n\n  /**\n   * Determines if a detection of multiple scala versions in the dependencies will cause the build\n   * to fail.\n   */\n  @Parameter(defaultValue = \"false\")\n  protected boolean failOnMultipleScalaVersions = false;\n\n  /**\n   * Should use CanonicalPath to normalize path (true =&gt; getCanonicalPath, false =&gt;\n   * getAbsolutePath)\n   *\n   * @see <a href=\n   *     \"https://github.com/davidB/scala-maven-plugin/issues/50\">https://github.com/davidB/scala-maven-plugin/issues/50<\/a>\n   */\n  @Parameter(property = \"maven.scala.useCanonicalPath\", defaultValue = \"true\")\n  protected boolean useCanonicalPath = true;\n\n  /** The dependency tree builder to use. */\n  @Component private DependencyGraphBuilder dependencyGraphBuilder;\n\n  /** The toolchain manager to use. */\n  @Component private ToolchainManager toolchainManager;\n\n  /** List of artifacts to run plugin */\n  @Parameter(defaultValue = \"${plugin.artifacts}\")\n  protected List<Artifact> pluginArtifacts;\n\n  private MavenArtifactResolver mavenArtifactResolver;\n\n  public MavenArtifactResolver findMavenArtifactResolver() {\n    if (mavenArtifactResolver == null) {\n      mavenArtifactResolver = new MavenArtifactResolver(factory, session);\n    }\n    return mavenArtifactResolver;\n  }\n\n  private Context scalaContext;\n\n  public Context findScalaContext() throws Exception {\n    // reuse/lazy scalaContext creation (doesn't need to be Thread safe, scalaContext should be\n    // stateless)\n    if (scalaContext == null) {\n      VersionNumber scalaVersion = findScalaVersion();\n\n      ArtifactIds aids =\n          scalaVersion.major == 3 ? new ArtifactIds4Scala3(scalaVersion) : new ArtifactIds4Scala2();\n      VersionNumber requiredScalaVersion =\n          StringUtils.isNotEmpty(scalaCompatVersion)\n              ? new VersionNumberMask(scalaCompatVersion)\n              : scalaVersion;\n      if (requiredScalaVersion.compareTo(scalaVersion) != 0) {\n        String msg =\n            String.format(\n                \"Scala library detected %s doesn't match scala.compat.version : %s\",\n                scalaVersion, requiredScalaVersion);\n        if (failOnMultipleScalaVersions) {\n          getLog().error(msg);\n          throw new MojoFailureException(msg);\n        }\n        getLog().warn(msg);\n      }\n      scalaContext =\n          StringUtils.isNotEmpty(scalaHome)\n              ? new Context4ScalaHome(scalaVersion, requiredScalaVersion, aids, new File(scalaHome))\n              : new Context4ScalaRemote(\n                  scalaVersion,\n                  requiredScalaVersion,\n                  aids,\n                  scalaOrganization,\n                  findMavenArtifactResolver());\n    }\n    return scalaContext;\n  }\n\n  protected void addToClasspath(\n      String groupId,\n      String artifactId,\n      String version,\n      String classifier,\n      Set<File> classpath,\n      boolean addDependencies) {\n    MavenArtifactResolver mar = findMavenArtifactResolver();\n    if (addDependencies) {\n      for (Artifact a : mar.getJarAndDependencies(groupId, artifactId, version, classifier)) {\n        classpath.add(a.getFile());\n      }\n    } else {\n      Artifact a = mar.getJar(groupId, artifactId, version, classifier);\n      classpath.add(a.getFile());\n    }\n  }\n\n  void addCompilerToClasspath(Set<File> classpath) throws Exception {\n    Context sc = findScalaContext();\n    for (Artifact dep : sc.findCompilerAndDependencies()) {\n      classpath.add(dep.getFile());\n    }\n  }\n\n  void addLibraryToClasspath(Set<File> classpath) throws Exception {\n    Context sc = findScalaContext();\n    for (Artifact dep : sc.findLibraryAndDependencies()) {\n      classpath.add(dep.getFile());\n    }\n  }\n\n  @Override\n  public void execute() throws MojoExecutionException, MojoFailureException {\n    try {\n      String oldWay = System.getProperty(\"maven.scala.version\");\n      if (oldWay != null) {\n        getLog().warn(\"using 'maven.scala.version' is deprecated, use 'scala.version' instead\");\n        if (scalaVersion != null) {\n          scalaVersion = oldWay;\n        }\n      }\n\n      oldWay = System.getProperty(\"maven.scala.displayCmd\");\n      if (oldWay != null) {\n        getLog().warn(\"using 'maven.scala.displayCmd' is deprecated, use 'displayCmd' instead\");\n        displayCmd = displayCmd || Boolean.parseBoolean(oldWay);\n      }\n      checkScalaVersion();\n      doExecute();\n    } catch (MojoExecutionException exc) {\n      throw exc;\n    } catch (MojoFailureException | RuntimeException exc) {\n      throw exc;\n    } catch (Exception exc) {\n      throw new MojoExecutionException(\"wrap: \" + exc, exc);\n    }\n  }\n\n  protected List<Dependency> getDependencies() {\n    return project.getCompileDependencies();\n  }\n\n  private VersionNumber detectedScalaVersion = null;\n\n  private VersionNumber findScalaVersion() throws Exception {\n    if (detectedScalaVersion == null) {\n      detectedScalaVersion = findScalaVersion0();\n    }\n    return detectedScalaVersion;\n  }\n\n  private VersionNumber findScalaVersion0() throws Exception {\n    String detectedScalaVersion = scalaVersion;\n    if (StringUtils.isEmpty(detectedScalaVersion)) {\n      detectedScalaVersion =\n          findVersionFromDependencies(scalaOrganization, ArtifactIds.SCALA_LIBRARY_PATTERN);\n    }\n    if (StringUtils.isEmpty(detectedScalaVersion)) {\n      if (!MavenArtifactResolver.POM.equals(project.getPackaging())) {\n        String error =\n            String.format(\n                \"%s:%s is missing from project dependencies\",\n                scalaOrganization, ArtifactIds.SCALA_LIBRARY_PATTERN.pattern());\n        getLog().error(error);\n        throw new UnsupportedOperationException(error);\n      }\n    } else {\n      // crappy hack to retrieve the SNAPSHOT version without timestamp,...\n      // because if version is -SNAPSHOT and artifact is deployed with uniqueValue then\n      // the version\n      // get from dependency is with the timestamp and a build number (the resolved\n      // version)\n      // but scala-compiler with the same version could have different resolved\n      // version (timestamp,...)\n      boolean isSnapshot = ArtifactUtils.isSnapshot(detectedScalaVersion);\n      if (isSnapshot && !detectedScalaVersion.endsWith(\"-SNAPSHOT\")) {\n        detectedScalaVersion =\n            detectedScalaVersion.substring(\n                    0,\n                    detectedScalaVersion.lastIndexOf(\n                        '-', detectedScalaVersion.lastIndexOf('-') - 1))\n                + \"-SNAPSHOT\";\n      }\n    }\n    if (StringUtils.isEmpty(detectedScalaVersion)) {\n      throw new MojoFailureException(\"no scalaVersion detected or set\");\n    }\n    if (StringUtils.isNotEmpty(scalaVersion)) {\n      if (!scalaVersion.equals(detectedScalaVersion)) {\n        getLog()\n            .warn(\n                \"scala library version defined in dependencies doesn't match the scalaVersion of the plugin\");\n      }\n      // getLog().info(\"suggestion: remove the scalaVersion from pom.xml\");\n      // //scalaVersion could be defined in a parent pom where lib is not required\n    }\n    return new VersionNumber(detectedScalaVersion);\n  }\n\n  // TODO refactor to do only one scan of dependencies to find version\n  private String findVersionFromDependencies(String groupId, Pattern artifactId) {\n    VersionNumber version = new VersionNumber(\"0.0.0\");\n    for (Dependency dep : getDependencies()) {\n      if (groupId.equals(dep.getGroupId()) && artifactId.matcher(dep.getArtifactId()).find()) {\n        version = version.max(new VersionNumber(dep.getVersion()));\n      }\n    }\n    if (version.major == 0) {\n      List<Dependency> deps = new ArrayList<>();\n      deps.addAll(project.getModel().getDependencies());\n      if (project.getModel().getDependencyManagement() != null) {\n        deps.addAll(project.getModel().getDependencyManagement().getDependencies());\n      }\n      for (Dependency dep : deps) {\n        if (groupId.equals(dep.getGroupId()) && artifactId.matcher(dep.getArtifactId()).find()) {\n          version = version.max(new VersionNumber(dep.getVersion()));\n        }\n      }\n    }\n    return version.major == 0 ? null : version.toString();\n  }\n\n  void checkScalaVersion() throws Exception {\n    String sv = findScalaVersion().toString();\n    if (StringUtils.isNotEmpty(scalaHome)) {\n      getLog()\n          .warn(\n              String.format(\n                  \"local scala-library.jar and scala-compiler.jar from scalaHome(%s) used instead of scala %s\",\n                  scalaHome, sv));\n    }\n    if (checkMultipleScalaVersions) {\n      checkCorrectVersionsOfScalaLibrary(sv);\n    }\n  }\n\n  /**\n   * this method checks to see if there are multiple versions of the scala library\n   *\n   * @throws Exception\n   */\n  private void checkCorrectVersionsOfScalaLibrary(String scalaDefVersion) throws Exception {\n    getLog().debug(\"Checking for multiple versions of scala\");\n    // TODO - Make sure we handle bad artifacts....\n    // TODO: note that filter does not get applied due to MNG-3236\n    VersionNumber sv = new VersionNumber(scalaDefVersion);\n    VersionNumber requiredScalaVersion =\n        StringUtils.isNotEmpty(scalaCompatVersion) ? new VersionNumberMask(scalaCompatVersion) : sv;\n    if (requiredScalaVersion.compareTo(sv) != 0) {\n      String msg =\n          String.format(\n              \"Scala library detected %s doesn't match scala.compat.version : %s\",\n              sv, requiredScalaVersion);\n      if (failOnMultipleScalaVersions) {\n        getLog().error(msg);\n        throw new MojoFailureException(msg);\n      }\n      getLog().warn(msg);\n    }\n    ProjectBuildingRequest request =\n        new DefaultProjectBuildingRequest(session.getProjectBuildingRequest());\n    request.setProject(project);\n    checkArtifactForScalaVersion(\n        findScalaContext(), dependencyGraphBuilder.buildDependencyGraph(request, null));\n  }\n\n  /** Visits a node (and all dependencies) to see if it contains duplicate scala versions */\n  private void checkArtifactForScalaVersion(Context scalaContext, DependencyNode rootNode)\n      throws Exception {\n    final CheckScalaVersionVisitor visitor = new CheckScalaVersionVisitor(scalaContext, getLog());\n\n    CollectingDependencyNodeVisitor collectingVisitor = new CollectingDependencyNodeVisitor();\n    DependencyNodeVisitor firstPassVisitor =\n        new FilteringDependencyNodeVisitor(collectingVisitor, createScalaDistroDependencyFilter());\n    rootNode.accept(firstPassVisitor);\n\n    DependencyNodeFilter secondPassFilter =\n        new AncestorOrSelfDependencyNodeFilter(collectingVisitor.getNodes());\n    DependencyNodeVisitor filteredVisitor =\n        new FilteringDependencyNodeVisitor(visitor, secondPassFilter);\n\n    rootNode.accept(filteredVisitor);\n\n    if (visitor.isFailed()) {\n      visitor.logScalaDependents();\n      if (failOnMultipleScalaVersions) {\n        getLog().error(\"Multiple versions of scala libraries detected!\");\n        throw new MojoFailureException(\"Multiple versions of scala libraries detected!\");\n      }\n      getLog().warn(\"Multiple versions of scala libraries detected!\");\n    }\n  }\n\n  /** @return A filter to only extract artifacts deployed from scala distributions */\n  private DependencyNodeFilter createScalaDistroDependencyFilter() throws Exception {\n    List<DependencyNodeFilter> filters = new ArrayList<>();\n    filters.add(new ScalaDistroArtifactFilter(findScalaContext()));\n    return new AndDependencyNodeFilter(filters);\n  }\n\n  protected abstract void doExecute() throws Exception;\n\n  /**\n   * Get a {@link JavaMainCaller} used invoke a Java process. Typically, this will be one of the\n   * Scala utilities (Compiler, ScalaDoc, REPL, etc.).\n   *\n   * <p>This method does some setup on the {@link JavaMainCaller} which is not done by merely\n   * invoking {@code new} on one of the implementations. Specifically, it adds any Scala compiler\n   * plugin options, JVM options, and Scalac options defined on the plugin.\n   *\n   * @param forkOverride override the setting for {@link #fork}. Currently, this should only be set\n   *     if you are invoking the REPL.\n   * @param mainClass the JVM main class to invoke.\n   * @return a {@link JavaMainCaller} to use to invoke the given command.\n   */\n  final JavaMainCaller getScalaCommand(final boolean forkOverride, final String mainClass)\n      throws Exception {\n    JavaMainCaller cmd = getEmptyScalaCommand(mainClass, forkOverride);\n    for (String option : getScalacOptions()) {\n      cmd.addArgs(option);\n    }\n    cmd.addJvmArgs(jvmArgs);\n    return cmd;\n  }\n\n  /**\n   * Get a {@link JavaMainCaller} used invoke a Java process. Typically this will be one of the\n   * Scala utilities (Compiler, ScalaDoc, REPL, etc.).\n   *\n   * @param mainClass the JVM main class to invoke.\n   * @return a {@link JavaMainCaller} to use to invoke the given command.\n   */\n  final JavaMainCaller getEmptyScalaCommand(final String mainClass) throws Exception {\n    return getEmptyScalaCommand(mainClass, fork);\n  }\n\n  /**\n   * Get a {@link JavaMainCaller} used invoke a Java process. Typically this will be one of the\n   * Scala utilities (Compiler, ScalaDoc, REPL, etc.).\n   *\n   * @param mainClass the JVM main class to invoke.\n   * @param forkOverride override the setting for {@link #fork}. Currently this should only be set\n   *     if you are invoking the REPL.\n   * @return a {@link JavaMainCaller} to use to invoke the given command.\n   */\n  private JavaMainCaller getEmptyScalaCommand(final String mainClass, final boolean forkOverride)\n      throws Exception {\n\n    // If we are deviating from the plugin settings, let the user know\n    // what's going on.\n    if (forkOverride != fork) {\n      super.getLog().info(\"Fork behavior overridden\");\n      super.getLog()\n          .info(String.format(\"Fork for this execution is %s.\", String.valueOf(forkOverride)));\n    }\n\n    // TODO - Fork or not depending on configuration?\n    JavaMainCaller cmd;\n    String toolcp = getToolClasspath();\n    if (forkOverride) {\n      // HACK (better may need refactor)\n      boolean bootcp = true;\n      if (args != null) {\n        for (String arg : args) {\n          bootcp = bootcp && !\"-nobootcp\".equals(arg);\n        }\n      }\n      String cp = bootcp ? \"\" : toolcp;\n      bootcp =\n          bootcp && !(StringUtils.isNotEmpty(addScalacArgs) && addScalacArgs.contains(\"-nobootcp\"));\n      // scalac with args in files\n      // * works only since 2.8.0\n      // * is buggy (don't manage space in path on windows)\n      getLog().debug(\"use java command with args in file forced : \" + forceUseArgFile);\n      cmd =\n          new JavaMainCallerByFork(\n              getLog(),\n              mainClass,\n              cp,\n              null,\n              null,\n              forceUseArgFile,\n              JavaLocator.findExecutableFromToolchain(getToolchain()));\n      if (bootcp) {\n        cmd.addJvmArgs(\"-Xbootclasspath/a:\" + toolcp);\n      }\n    } else {\n      cmd = new JavaMainCallerInProcess(getLog(), mainClass, toolcp, null, null);\n    }\n    return cmd;\n  }\n\n  protected Toolchain getToolchain() {\n    return toolchainManager.getToolchainFromBuildContext(\"jdk\", session);\n  }\n\n  private String getToolClasspath() throws Exception {\n    Set<File> classpath = new TreeSet<>();\n    addLibraryToClasspath(classpath);\n    addCompilerToClasspath(classpath);\n    if (dependencies != null) {\n      for (BasicArtifact artifact : dependencies) {\n        addToClasspath(\n            artifact.groupId, artifact.artifactId, artifact.version, \"\", classpath, true);\n      }\n    }\n    return FileUtils.toMultiPath(classpath);\n  }\n\n  static String targetOption(String target, VersionNumber scalaVersion) {\n    if (scalaVersion.major == 2) {\n      if (scalaVersion.minor <= 12) {\n        if (target.equals(\"1.5\") || target.equals(\"5\")) {\n          return \"jvm-1.5\";\n        } else if (target.equals(\"1.6\") || target.equals(\"6\")) {\n          return \"jvm-1.6\";\n        } else if (target.equals(\"1.7\") || target.equals(\"7\")) {\n          return \"jvm-1.7\";\n        } else if (target.equals(\"1.8\") || target.equals(\"8\")) {\n          return \"jvm-1.8\";\n        } else {\n          // invalid or unsupported option, just ignore\n          return null;\n        }\n      } else if (target.equals(\"1.5\")) {\n        return \"5\";\n      } else if (target.equals(\"1.6\")) {\n        return \"6\";\n      } else if (target.equals(\"1.7\")) {\n        return \"7\";\n      } else if (target.equals(\"1.8\")) {\n        return \"8\";\n      }\n    }\n    return target;\n  }\n\n  protected List<String> getScalacOptions() throws Exception {\n    List<String> options = new ArrayList<>();\n    if (args != null) Collections.addAll(options, args);\n    if (StringUtils.isNotEmpty(addScalacArgs)) {\n      Collections.addAll(options, StringUtils.split(addScalacArgs, \"|\"));\n    }\n    options.addAll(getCompilerPluginOptions());\n\n    VersionNumber scalaVersion = findScalaVersion();\n\n    boolean targetIsDefined = StringUtils.isNotEmpty(target);\n    boolean releaseIsDefined = StringUtils.isNotEmpty(release);\n    boolean targetIsDeprecated = scalaVersion.compareTo(new VersionNumber(\"2.13.9\")) >= 0;\n    boolean releaseIsSupported = scalaVersion.compareTo(new VersionNumber(\"2.12.0\")) >= 0;\n\n    // target's default is \"maven.compiler.target\"'s default, which is 1.8\n    if (targetIsDefined) {\n      String targetOption = targetOption(target, scalaVersion);\n      if (targetOption != null) {\n        if (!targetIsDeprecated) {\n          options.add(\"-target:\" + targetOption);\n        } else if (!releaseIsDefined) {\n          // -target is deprecated in favor of -release\n          // no user-defined release specified\n          // set release instead, so we don't get a deprecation warning\n          options.add(\"-release\");\n          options.add(targetOption);\n        }\n      }\n    }\n\n    // release's default is \"maven.compiler.release\"'s default, which is null\n    if (releaseIsDefined && releaseIsSupported) {\n      options.add(\"-release\");\n      options.add(release);\n    }\n\n    return options;\n  }\n\n  protected List<String> getJavacOptions() {\n    List<String> options = new ArrayList<>();\n    if (javacArgs != null) Collections.addAll(options, javacArgs);\n    if (StringUtils.isNotEmpty(addJavacArgs)) {\n      Collections.addAll(options, StringUtils.split(addJavacArgs, \"|\"));\n    }\n\n    // issue #116\n    if (javacGenerateDebugSymbols) {\n      options.add(\"-g\");\n    }\n    if (StringUtils.isNotEmpty(release)) {\n      options.add(\"--release\");\n      options.add(release);\n    } else {\n      if (StringUtils.isNotEmpty(target)) {\n        options.add(\"-target\");\n        options.add(target);\n      }\n      if (StringUtils.isNotEmpty(source)) {\n        options.add(\"-source\");\n        options.add(source);\n      }\n    }\n    if (encoding != null) {\n      options.add(\"-encoding\");\n      options.add(encoding);\n    }\n    return options;\n  }\n\n  /**\n   * @return This returns whether the scala version can support having java sent into the compiler\n   *     or not\n   */\n  protected boolean isJavaSupportedByCompiler() throws Exception {\n    return findScalaVersion().compareTo(new VersionNumber(\"2.7.2\")) >= 0;\n  }\n\n  /**\n   * Adds appropriate compiler plugins to the scalac command.\n   *\n   * @param scalac\n   * @throws Exception\n   */\n  protected void addCompilerPluginOptions(JavaMainCaller scalac) throws Exception {\n    for (String option : getCompilerPluginOptions()) {\n      scalac.addArgs(option);\n    }\n  }\n\n  private List<String> getCompilerPluginOptions() throws Exception {\n    List<String> options = new ArrayList<>();\n    for (File plugin : getCompilerPlugins()) {\n      options.add(\"-Xplugin:\" + plugin.getPath());\n    }\n    return options;\n  }\n\n  /**\n   * Retrieves a list of paths to scala compiler plugins.\n   *\n   * @return The list of plugins\n   * @throws Exception\n   */\n  private Set<File> getCompilerPlugins() throws Exception {\n    Set<File> plugins = new TreeSet<>();\n    if (compilerPlugins != null) {\n      Set<File> ignoreClasspath = new TreeSet<>();\n      addCompilerToClasspath(ignoreClasspath);\n      addLibraryToClasspath(ignoreClasspath);\n      for (BasicArtifact artifact : compilerPlugins) {\n        getLog().info(\"compiler plugin: \" + artifact.toString());\n        // TODO - Ensure proper scala version for plugins\n        Set<File> pluginClassPath = new TreeSet<>();\n        addToClasspath(\n            artifact.groupId,\n            artifact.artifactId,\n            artifact.version,\n            artifact.classifier,\n            pluginClassPath,\n            false);\n        pluginClassPath.removeAll(ignoreClasspath);\n        plugins.addAll(pluginClassPath);\n      }\n    }\n    return plugins;\n  }\n}\n","Method after Refactoring":"/*\n * This is free and unencumbered software released into the public domain.\n * See UNLICENSE.\n */\npackage scala_maven;\n\nimport java.io.File;\nimport java.util.*;\nimport java.util.regex.Pattern;\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.ArtifactUtils;\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.model.Dependency;\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugin.MojoFailureException;\nimport org.apache.maven.plugins.annotations.Component;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.project.DefaultProjectBuildingRequest;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.project.ProjectBuildingRequest;\nimport org.apache.maven.repository.RepositorySystem;\nimport org.apache.maven.shared.dependency.graph.DependencyGraphBuilder;\nimport org.apache.maven.shared.dependency.graph.DependencyNode;\nimport org.apache.maven.shared.dependency.graph.filter.AncestorOrSelfDependencyNodeFilter;\nimport org.apache.maven.shared.dependency.graph.filter.AndDependencyNodeFilter;\nimport org.apache.maven.shared.dependency.graph.filter.DependencyNodeFilter;\nimport org.apache.maven.shared.dependency.graph.traversal.CollectingDependencyNodeVisitor;\nimport org.apache.maven.shared.dependency.graph.traversal.DependencyNodeVisitor;\nimport org.apache.maven.shared.dependency.graph.traversal.FilteringDependencyNodeVisitor;\nimport org.apache.maven.toolchain.Toolchain;\nimport org.apache.maven.toolchain.ToolchainManager;\nimport org.codehaus.plexus.util.StringUtils;\nimport scala_maven_dependency.*;\nimport scala_maven_executions.JavaMainCaller;\nimport scala_maven_executions.JavaMainCallerByFork;\nimport scala_maven_executions.JavaMainCallerInProcess;\nimport util.FileUtils;\nimport util.JavaLocator;\n\npublic abstract class ScalaMojoSupport extends AbstractMojo {\n\n  /** The maven project. */\n  @Parameter(property = \"project\", required = true, readonly = true)\n  protected MavenProject project;\n\n  /**\n   * The Maven Session Object\n   *\n   * <p>Note: Allows extending for 3rd-party usages\n   */\n  @Parameter(property = \"session\", required = true, readonly = true)\n  protected MavenSession session;\n\n  /** Used to look up Artifacts in the remote repository. */\n  @Component RepositorySystem factory;\n\n  /**\n   * Additional dependencies/jar to add to classpath to run \"scalaClassName\" (scope and optional\n   * field not supported) ex :\n   *\n   * <pre>\n   *    &lt;dependencies&gt;\n   *      &lt;dependency&gt;\n   *        &lt;groupId&gt;org.scala-tools&lt;/groupId&gt;\n   *        &lt;artifactId&gt;scala-compiler-addon&lt;/artifactId&gt;\n   *        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n   *      &lt;/dependency&gt;\n   *    &lt;/dependencies&gt;\n   * <\/pre>\n   */\n  @Parameter protected BasicArtifact[] dependencies;\n\n  /**\n   * Compiler plugin dependencies to use when compiling. ex:\n   *\n   * <pre>\n   * &lt;compilerPlugins&gt;\n   *   &lt;compilerPlugin&gt;\n   *     &lt;groupId&gt;my.scala.plugin&lt;/groupId&gt;\n   *     &lt;artifactId&gt;amazingPlugin&lt;/artifactId&gt;\n   *     &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n   *   &lt;/compilerPlugin&gt;\n   * &lt;/compilerPlugins&gt;\n   * <\/pre>\n   */\n  @Parameter private BasicArtifact[] compilerPlugins;\n\n  /** Jvm Arguments. */\n  @Parameter protected String[] jvmArgs;\n\n  /** compiler additional arguments */\n  @Parameter protected String[] args;\n\n  /**\n   * Additional parameter to use to call the main class. Use this parameter only from command line\n   * (\"-DaddScalacArgs=arg1|arg2|arg3|...\"), not from pom.xml. To define compiler arguments in\n   * pom.xml see the \"args\" parameter.\n   */\n  @Parameter(property = \"addScalacArgs\")\n  private String addScalacArgs;\n\n  /** override the className (FQN) of the scala tool */\n  @Parameter(required = false, property = \"maven.scala.className\")\n  protected String scalaClassName;\n\n  /** Scala 's version to use. (property 'maven.scala.version' replaced by 'scala.version') */\n  @Parameter(property = \"scala.version\")\n  private String scalaVersion;\n\n  /**\n   * Organization/group ID of the Scala used in the project. Default value is 'org.scala-lang'. This\n   * is an advanced setting used for clones of the Scala Language. It should be disregarded in\n   * standard use cases.\n   */\n  @Parameter(property = \"scala.organization\", defaultValue = \"org.scala-lang\")\n  private String scalaOrganization;\n\n  /**\n   * Scala 's version to use to check binary compatibility (like suffix in artifactId of\n   * dependency). If it is defined then it is used to checkMultipleScalaVersions\n   */\n  @Parameter(property = \"scala.compat.version\")\n  private String scalaCompatVersion;\n\n  /** Path to Scala installation to use instead of the artifact (define as dependencies). */\n  @Parameter(property = \"scala.home\")\n  private String scalaHome;\n\n  /** Arguments for javac (when using incremental compiler). */\n  @Parameter(property = \"javacArgs\")\n  protected String[] javacArgs;\n\n  /**\n   * Whether to instruct javac to generate debug symbols (when using incremental compiler)\n   *\n   * @see <a href=\n   *     \"http://maven.apache.org/plugins/maven-compiler-plugin/compile-mojo.html#debug\">://maven.apache.org/plugins/maven-compiler-plugin/compile-mojo.html#debug<\/a>\n   */\n  @Parameter(property = \"javacGenerateDebugSymbols\", defaultValue = \"true\")\n  protected boolean javacGenerateDebugSymbols = true;\n\n  /**\n   * Alternative method for specifying javac arguments (when using incremental compiler). Can be\n   * used from command line with -DaddJavacArgs=arg1|arg2|arg3|... rather than in pom.xml.\n   */\n  @Parameter(property = \"addJavacArgs\")\n  protected String addJavacArgs;\n\n  /** The -source argument for the Java compiler (when using incremental compiler). */\n  @Parameter(property = \"maven.compiler.source\")\n  protected String source;\n\n  /** The -target argument for the Java compiler (when using incremental compiler). */\n  @Parameter(property = \"maven.compiler.target\")\n  protected String target;\n\n  /**\n   * The --release argument for the Java compiler (when using incremental compiler), supported since\n   * Java9.\n   */\n  @Parameter(property = \"maven.compiler.release\")\n  protected String release;\n\n  /** The -encoding argument for the Java compiler. (when using incremental compiler). */\n  @Parameter(property = \"project.build.sourceEncoding\", defaultValue = \"UTF-8\")\n  protected String encoding;\n\n  /**\n   * Display the command line called ? (property 'maven.scala.displayCmd' replaced by 'displayCmd')\n   */\n  @Parameter(property = \"displayCmd\", defaultValue = \"false\", required = true)\n  public boolean displayCmd;\n\n  /** Forks the execution of scalac into a separate process. */\n  @Parameter(defaultValue = \"true\")\n  protected boolean fork = true;\n\n  /** Force the use of an external ArgFile to run any forked process. */\n  @Parameter(defaultValue = \"false\")\n  protected boolean forceUseArgFile = false;\n\n  /** Check if every dependencies use the same version of scala-library or scala.compat.version. */\n  @Parameter(property = \"maven.scala.checkConsistency\", defaultValue = \"true\")\n  protected boolean checkMultipleScalaVersions;\n\n  /**\n   * Determines if a detection of multiple scala versions in the dependencies will cause the build\n   * to fail.\n   */\n  @Parameter(defaultValue = \"false\")\n  protected boolean failOnMultipleScalaVersions = false;\n\n  /**\n   * Should use CanonicalPath to normalize path (true =&gt; getCanonicalPath, false =&gt;\n   * getAbsolutePath)\n   *\n   * @see <a href=\n   *     \"https://github.com/davidB/scala-maven-plugin/issues/50\">https://github.com/davidB/scala-maven-plugin/issues/50<\/a>\n   */\n  @Parameter(property = \"maven.scala.useCanonicalPath\", defaultValue = \"true\")\n  protected boolean useCanonicalPath = true;\n\n  /** The dependency tree builder to use. */\n  @Component private DependencyGraphBuilder dependencyGraphBuilder;\n\n  /** The toolchain manager to use. */\n  @Component private ToolchainManager toolchainManager;\n\n  /** List of artifacts to run plugin */\n  @Parameter(defaultValue = \"${plugin.artifacts}\")\n  protected List<Artifact> pluginArtifacts;\n\n  private MavenArtifactResolver mavenArtifactResolver;\n\n  public MavenArtifactResolver findMavenArtifactResolver() {\n    if (mavenArtifactResolver == null) {\n      mavenArtifactResolver = new MavenArtifactResolver(factory, session);\n    }\n    return mavenArtifactResolver;\n  }\n\n  private Context scalaContext;\n\n  public Context findScalaContext() throws Exception {\n    // reuse/lazy scalaContext creation (doesn't need to be Thread safe, scalaContext should be\n    // stateless)\n    if (scalaContext == null) {\n      VersionNumber scalaVersion = findScalaVersion();\n\n      ArtifactIds aids =\n          scalaVersion.major == 3 ? new ArtifactIds4Scala3(scalaVersion) : new ArtifactIds4Scala2();\n      VersionNumber requiredScalaVersion =\n          StringUtils.isNotEmpty(scalaCompatVersion)\n              ? new VersionNumberMask(scalaCompatVersion)\n              : scalaVersion;\n      if (requiredScalaVersion.compareTo(scalaVersion) != 0) {\n        String msg =\n            String.format(\n                \"Scala library detected %s doesn't match scala.compat.version : %s\",\n                scalaVersion, requiredScalaVersion);\n        if (failOnMultipleScalaVersions) {\n          getLog().error(msg);\n          throw new MojoFailureException(msg);\n        }\n        getLog().warn(msg);\n      }\n      scalaContext =\n          StringUtils.isNotEmpty(scalaHome)\n              ? new Context4ScalaHome(scalaVersion, requiredScalaVersion, aids, new File(scalaHome))\n              : new Context4ScalaRemote(\n                  scalaVersion,\n                  requiredScalaVersion,\n                  aids,\n                  scalaOrganization,\n                  findMavenArtifactResolver());\n    }\n    return scalaContext;\n  }\n\n  protected void addToClasspath(\n      String groupId,\n      String artifactId,\n      String version,\n      String classifier,\n      Set<File> classpath,\n      boolean addDependencies) {\n    MavenArtifactResolver mar = findMavenArtifactResolver();\n    if (addDependencies) {\n      for (Artifact a : mar.getJarAndDependencies(groupId, artifactId, version, classifier)) {\n        classpath.add(a.getFile());\n      }\n    } else {\n      Artifact a = mar.getJar(groupId, artifactId, version, classifier);\n      classpath.add(a.getFile());\n    }\n  }\n\n  void addCompilerToClasspath(Set<File> classpath) throws Exception {\n    Context sc = findScalaContext();\n    for (Artifact dep : sc.findCompilerAndDependencies()) {\n      classpath.add(dep.getFile());\n    }\n  }\n\n  void addLibraryToClasspath(Set<File> classpath) throws Exception {\n    Context sc = findScalaContext();\n    for (Artifact dep : sc.findLibraryAndDependencies()) {\n      classpath.add(dep.getFile());\n    }\n  }\n\n  @Override\n  public void execute() throws MojoExecutionException, MojoFailureException {\n    try {\n      String oldWay = System.getProperty(\"maven.scala.version\");\n      if (oldWay != null) {\n        getLog().warn(\"using 'maven.scala.version' is deprecated, use 'scala.version' instead\");\n        if (scalaVersion != null) {\n          scalaVersion = oldWay;\n        }\n      }\n\n      oldWay = System.getProperty(\"maven.scala.displayCmd\");\n      if (oldWay != null) {\n        getLog().warn(\"using 'maven.scala.displayCmd' is deprecated, use 'displayCmd' instead\");\n        displayCmd = displayCmd || Boolean.parseBoolean(oldWay);\n      }\n      checkScalaVersion();\n      doExecute();\n    } catch (MojoExecutionException exc) {\n      throw exc;\n    } catch (MojoFailureException | RuntimeException exc) {\n      throw exc;\n    } catch (Exception exc) {\n      throw new MojoExecutionException(\"wrap: \" + exc, exc);\n    }\n  }\n\n  protected List<Dependency> getDependencies() {\n    return project.getCompileDependencies();\n  }\n\n  private VersionNumber detectedScalaVersion = null;\n\n  private VersionNumber findScalaVersion() throws Exception {\n    if (detectedScalaVersion == null) {\n      detectedScalaVersion = findScalaVersion0();\n    }\n    return detectedScalaVersion;\n  }\n\n  private VersionNumber findScalaVersion0() throws Exception {\n    String detectedScalaVersion = scalaVersion;\n    if (StringUtils.isEmpty(detectedScalaVersion)) {\n      detectedScalaVersion =\n          findVersionFromDependencies(scalaOrganization, ArtifactIds.SCALA_LIBRARY_PATTERN);\n    }\n    if (StringUtils.isEmpty(detectedScalaVersion)) {\n      if (!MavenArtifactResolver.POM.equals(project.getPackaging())) {\n        String error =\n            String.format(\n                \"%s:%s is missing from project dependencies\",\n                scalaOrganization, ArtifactIds.SCALA_LIBRARY_PATTERN.pattern());\n        getLog().error(error);\n        throw new UnsupportedOperationException(error);\n      }\n    } else {\n      // crappy hack to retrieve the SNAPSHOT version without timestamp,...\n      // because if version is -SNAPSHOT and artifact is deployed with uniqueValue then\n      // the version\n      // get from dependency is with the timestamp and a build number (the resolved\n      // version)\n      // but scala-compiler with the same version could have different resolved\n      // version (timestamp,...)\n      boolean isSnapshot = ArtifactUtils.isSnapshot(detectedScalaVersion);\n      if (isSnapshot && !detectedScalaVersion.endsWith(\"-SNAPSHOT\")) {\n        detectedScalaVersion =\n            detectedScalaVersion.substring(\n                    0,\n                    detectedScalaVersion.lastIndexOf(\n                        '-', detectedScalaVersion.lastIndexOf('-') - 1))\n                + \"-SNAPSHOT\";\n      }\n    }\n    if (StringUtils.isEmpty(detectedScalaVersion)) {\n      throw new MojoFailureException(\"no scalaVersion detected or set\");\n    }\n    if (StringUtils.isNotEmpty(scalaVersion)) {\n      if (!scalaVersion.equals(detectedScalaVersion)) {\n        getLog()\n            .warn(\n                \"scala library version defined in dependencies doesn't match the scalaVersion of the plugin\");\n      }\n      // getLog().info(\"suggestion: remove the scalaVersion from pom.xml\");\n      // //scalaVersion could be defined in a parent pom where lib is not required\n    }\n    return new VersionNumber(detectedScalaVersion);\n  }\n\n  // TODO refactor to do only one scan of dependencies to find version\n  private String findVersionFromDependencies(String groupId, Pattern artifactId) {\n    VersionNumber version = new VersionNumber(\"0.0.0\");\n    for (Dependency dep : getDependencies()) {\n      if (groupId.equals(dep.getGroupId()) && artifactId.matcher(dep.getArtifactId()).find()) {\n        version = version.max(new VersionNumber(dep.getVersion()));\n      }\n    }\n    if (version.major == 0) {\n      List<Dependency> deps = new ArrayList<>();\n      deps.addAll(project.getModel().getDependencies());\n      if (project.getModel().getDependencyManagement() != null) {\n        deps.addAll(project.getModel().getDependencyManagement().getDependencies());\n      }\n      for (Dependency dep : deps) {\n        if (groupId.equals(dep.getGroupId()) && artifactId.matcher(dep.getArtifactId()).find()) {\n          version = version.max(new VersionNumber(dep.getVersion()));\n        }\n      }\n    }\n    return version.major == 0 ? null : version.toString();\n  }\n\n  void checkScalaVersion() throws Exception {\n    String sv = findScalaVersion().toString();\n    if (StringUtils.isNotEmpty(scalaHome)) {\n      getLog()\n          .warn(\n              String.format(\n                  \"local scala-library.jar and scala-compiler.jar from scalaHome(%s) used instead of scala %s\",\n                  scalaHome, sv));\n    }\n    if (checkMultipleScalaVersions) {\n      checkCorrectVersionsOfScalaLibrary(sv);\n    }\n  }\n\n  /**\n   * this method checks to see if there are multiple versions of the scala library\n   *\n   * @throws Exception\n   */\n  private void checkCorrectVersionsOfScalaLibrary(String scalaDefVersion) throws Exception {\n    getLog().debug(\"Checking for multiple versions of scala\");\n    // TODO - Make sure we handle bad artifacts....\n    // TODO: note that filter does not get applied due to MNG-3236\n    VersionNumber sv = new VersionNumber(scalaDefVersion);\n    VersionNumber requiredScalaVersion =\n        StringUtils.isNotEmpty(scalaCompatVersion) ? new VersionNumberMask(scalaCompatVersion) : sv;\n    if (requiredScalaVersion.compareTo(sv) != 0) {\n      String msg =\n          String.format(\n              \"Scala library detected %s doesn't match scala.compat.version : %s\",\n              sv, requiredScalaVersion);\n      if (failOnMultipleScalaVersions) {\n        getLog().error(msg);\n        throw new MojoFailureException(msg);\n      }\n      getLog().warn(msg);\n    }\n    ProjectBuildingRequest request =\n        new DefaultProjectBuildingRequest(session.getProjectBuildingRequest());\n    request.setProject(project);\n    checkArtifactForScalaVersion(\n        findScalaContext(), dependencyGraphBuilder.buildDependencyGraph(request, null));\n  }\n\n  /** Visits a node (and all dependencies) to see if it contains duplicate scala versions */\n  private void checkArtifactForScalaVersion(Context scalaContext, DependencyNode rootNode)\n      throws Exception {\n    final CheckScalaVersionVisitor visitor = new CheckScalaVersionVisitor(scalaContext, getLog());\n\n    CollectingDependencyNodeVisitor collectingVisitor = new CollectingDependencyNodeVisitor();\n    DependencyNodeVisitor firstPassVisitor =\n        new FilteringDependencyNodeVisitor(collectingVisitor, createScalaDistroDependencyFilter());\n    rootNode.accept(firstPassVisitor);\n\n    DependencyNodeFilter secondPassFilter =\n        new AncestorOrSelfDependencyNodeFilter(collectingVisitor.getNodes());\n    DependencyNodeVisitor filteredVisitor =\n        new FilteringDependencyNodeVisitor(visitor, secondPassFilter);\n\n    rootNode.accept(filteredVisitor);\n\n    if (visitor.isFailed()) {\n      visitor.logScalaDependents();\n      if (failOnMultipleScalaVersions) {\n        getLog().error(\"Multiple versions of scala libraries detected!\");\n        throw new MojoFailureException(\"Multiple versions of scala libraries detected!\");\n      }\n      getLog().warn(\"Multiple versions of scala libraries detected!\");\n    }\n  }\n\n  /** @return A filter to only extract artifacts deployed from scala distributions */\n  private DependencyNodeFilter createScalaDistroDependencyFilter() throws Exception {\n    List<DependencyNodeFilter> filters = new ArrayList<>();\n    filters.add(new ScalaDistroArtifactFilter(findScalaContext()));\n    return new AndDependencyNodeFilter(filters);\n  }\n\n  protected abstract void doExecute() throws Exception;\n\n  /**\n   * Get a {@link JavaMainCaller} used invoke a Java process. Typically, this will be one of the\n   * Scala utilities (Compiler, ScalaDoc, REPL, etc.).\n   *\n   * <p>This method does some setup on the {@link JavaMainCaller} which is not done by merely\n   * invoking {@code new} on one of the implementations. Specifically, it adds any Scala compiler\n   * plugin options, JVM options, and Scalac options defined on the plugin.\n   *\n   * @param forkOverride override the setting for {@link #fork}. Currently, this should only be set\n   *     if you are invoking the REPL.\n   * @param mainClass the JVM main class to invoke.\n   * @return a {@link JavaMainCaller} to use to invoke the given command.\n   */\n  final JavaMainCaller getScalaCommand(final boolean forkOverride, final String mainClass)\n      throws Exception {\n    JavaMainCaller cmd = getEmptyScalaCommand(mainClass, forkOverride);\n    for (String option : getScalacOptions()) {\n      cmd.addArgs(option);\n    }\n    cmd.addJvmArgs(jvmArgs);\n    return cmd;\n  }\n\n  /**\n   * Get a {@link JavaMainCaller} used invoke a Java process. Typically this will be one of the\n   * Scala utilities (Compiler, ScalaDoc, REPL, etc.).\n   *\n   * @param mainClass the JVM main class to invoke.\n   * @return a {@link JavaMainCaller} to use to invoke the given command.\n   */\n  final JavaMainCaller getEmptyScalaCommand(final String mainClass) throws Exception {\n    return getEmptyScalaCommand(mainClass, fork);\n  }\n\n  /**\n   * Get a {@link JavaMainCaller} used invoke a Java process. Typically this will be one of the\n   * Scala utilities (Compiler, ScalaDoc, REPL, etc.).\n   *\n   * @param mainClass the JVM main class to invoke.\n   * @param forkOverride override the setting for {@link #fork}. Currently this should only be set\n   *     if you are invoking the REPL.\n   * @return a {@link JavaMainCaller} to use to invoke the given command.\n   */\n  private JavaMainCaller getEmptyScalaCommand(final String mainClass, final boolean forkOverride)\n      throws Exception {\n\n    // If we are deviating from the plugin settings, let the user know\n    // what's going on.\n    if (forkOverride != fork) {\n      super.getLog().info(\"Fork behavior overridden\");\n      super.getLog()\n          .info(String.format(\"Fork for this execution is %s.\", String.valueOf(forkOverride)));\n    }\n\n    // TODO - Fork or not depending on configuration?\n    JavaMainCaller cmd;\n    String toolcp = getToolClasspath();\n    if (forkOverride) {\n      // HACK (better may need refactor)\n      boolean bootcp = true;\n      if (args != null) {\n        for (String arg : args) {\n          bootcp = bootcp && !\"-nobootcp\".equals(arg);\n        }\n      }\n      String cp = bootcp ? \"\" : toolcp;\n      bootcp =\n          bootcp && !(StringUtils.isNotEmpty(addScalacArgs) && addScalacArgs.contains(\"-nobootcp\"));\n      // scalac with args in files\n      // * works only since 2.8.0\n      // * is buggy (don't manage space in path on windows)\n      getLog().debug(\"use java command with args in file forced : \" + forceUseArgFile);\n      cmd =\n          new JavaMainCallerByFork(\n              getLog(),\n              mainClass,\n              cp,\n              null,\n              null,\n              forceUseArgFile,\n              JavaLocator.findExecutableFromToolchain(getToolchain()));\n      if (bootcp) {\n        cmd.addJvmArgs(\"-Xbootclasspath/a:\" + toolcp);\n      }\n    } else {\n      cmd = new JavaMainCallerInProcess(getLog(), mainClass, toolcp, null, null);\n    }\n    return cmd;\n  }\n\n  protected Toolchain getToolchain() {\n    return toolchainManager.getToolchainFromBuildContext(\"jdk\", session);\n  }\n\n  private String getToolClasspath() throws Exception {\n    Set<File> classpath = new TreeSet<>();\n    addLibraryToClasspath(classpath);\n    addCompilerToClasspath(classpath);\n    if (dependencies != null) {\n      for (BasicArtifact artifact : dependencies) {\n        addToClasspath(\n            artifact.groupId, artifact.artifactId, artifact.version, \"\", classpath, true);\n      }\n    }\n    return FileUtils.toMultiPath(classpath);\n  }\n\n  private static String computeTargetOption(String target) {\n    if (target.equals(\"1.5\") || target.equals(\"5\")) {\n      return \"jvm-1.5\";\n    } else if (target.equals(\"1.6\") || target.equals(\"6\")) {\n      return \"jvm-1.6\";\n    } else if (target.equals(\"1.7\") || target.equals(\"7\")) {\n      return \"jvm-1.7\";\n    } else if (target.equals(\"1.8\") || target.equals(\"8\")) {\n      return \"jvm-1.8\";\n    }\n    return null;\n  }\n\n  private static String computeReleaseOptionFromTarget(String target) {\n    if (target.equals(\"1.5\")) {\n      return \"5\";\n    } else if (target.equals(\"1.6\")) {\n      return \"6\";\n    } else if (target.equals(\"1.7\")) {\n      return \"7\";\n    } else if (target.equals(\"1.8\")) {\n      return \"8\";\n    }\n    return target;\n  }\n\n  // visible for tests\n  static List<String> computeBytecodeVersionOptions(\n      String target, String release, VersionNumber scalaVersion) {\n    List<String> options = new ArrayList<>();\n    boolean targetIsDefined = StringUtils.isNotEmpty(target);\n    boolean releaseIsDefined = StringUtils.isNotEmpty(release);\n    boolean releaseIsSupported = scalaVersion.compareTo(new VersionNumber(\"2.12.0\")) >= 0;\n    String releaseOrJavaOutputVersionOptionName =\n        scalaVersion.compareTo(new VersionNumber(\"3.1.2\")) >= 0\n            ? \"-java-output-version\"\n            : \"-release\";\n\n    if (releaseIsDefined && releaseIsSupported) {\n      // release's default is \"maven.compiler.release\"'s default, which is null\n      options.add(releaseOrJavaOutputVersionOptionName);\n      options.add(release);\n    } else if (targetIsDefined) {\n      // target's default is \"maven.compiler.target\"'s default, which is 1.8\n      if (releaseIsSupported) {\n        options.add(releaseOrJavaOutputVersionOptionName);\n        options.add(computeReleaseOptionFromTarget(target));\n      } else {\n        String correctTarget = computeTargetOption(target);\n        if (correctTarget != null) {\n          options.add(\"-target:\" + correctTarget);\n        }\n      }\n    }\n    return options;\n  }\n\n  protected List<String> getScalacOptions() throws Exception {\n    List<String> options = new ArrayList<>();\n    if (args != null) Collections.addAll(options, args);\n    if (StringUtils.isNotEmpty(addScalacArgs)) {\n      Collections.addAll(options, StringUtils.split(addScalacArgs, \"|\"));\n    }\n    options.addAll(getCompilerPluginOptions());\n    options.addAll(computeBytecodeVersionOptions(target, release, findScalaVersion()));\n\n    return options;\n  }\n\n  protected List<String> getJavacOptions() {\n    List<String> options = new ArrayList<>();\n    if (javacArgs != null) Collections.addAll(options, javacArgs);\n    if (StringUtils.isNotEmpty(addJavacArgs)) {\n      Collections.addAll(options, StringUtils.split(addJavacArgs, \"|\"));\n    }\n\n    // issue #116\n    if (javacGenerateDebugSymbols) {\n      options.add(\"-g\");\n    }\n    if (StringUtils.isNotEmpty(release)) {\n      options.add(\"--release\");\n      options.add(release);\n    } else {\n      if (StringUtils.isNotEmpty(target)) {\n        options.add(\"-target\");\n        options.add(target);\n      }\n      if (StringUtils.isNotEmpty(source)) {\n        options.add(\"-source\");\n        options.add(source);\n      }\n    }\n    if (encoding != null) {\n      options.add(\"-encoding\");\n      options.add(encoding);\n    }\n    return options;\n  }\n\n  /**\n   * @return This returns whether the scala version can support having java sent into the compiler\n   *     or not\n   */\n  protected boolean isJavaSupportedByCompiler() throws Exception {\n    return findScalaVersion().compareTo(new VersionNumber(\"2.7.2\")) >= 0;\n  }\n\n  /**\n   * Adds appropriate compiler plugins to the scalac command.\n   *\n   * @param scalac\n   * @throws Exception\n   */\n  protected void addCompilerPluginOptions(JavaMainCaller scalac) throws Exception {\n    for (String option : getCompilerPluginOptions()) {\n      scalac.addArgs(option);\n    }\n  }\n\n  private List<String> getCompilerPluginOptions() throws Exception {\n    List<String> options = new ArrayList<>();\n    for (File plugin : getCompilerPlugins()) {\n      options.add(\"-Xplugin:\" + plugin.getPath());\n    }\n    return options;\n  }\n\n  /**\n   * Retrieves a list of paths to scala compiler plugins.\n   *\n   * @return The list of plugins\n   * @throws Exception\n   */\n  private Set<File> getCompilerPlugins() throws Exception {\n    Set<File> plugins = new TreeSet<>();\n    if (compilerPlugins != null) {\n      Set<File> ignoreClasspath = new TreeSet<>();\n      addCompilerToClasspath(ignoreClasspath);\n      addLibraryToClasspath(ignoreClasspath);\n      for (BasicArtifact artifact : compilerPlugins) {\n        getLog().info(\"compiler plugin: \" + artifact.toString());\n        // TODO - Ensure proper scala version for plugins\n        Set<File> pluginClassPath = new TreeSet<>();\n        addToClasspath(\n            artifact.groupId,\n            artifact.artifactId,\n            artifact.version,\n            artifact.classifier,\n            pluginClassPath,\n            false);\n        pluginClassPath.removeAll(ignoreClasspath);\n        plugins.addAll(pluginClassPath);\n      }\n    }\n    return plugins;\n  }\n}\n","lineNo":624}
{"Smelly Sample":"/*\n * This is free and unencumbered software released into the public domain.\n * See UNLICENSE.\n */\npackage scala_maven;\n\nimport java.io.File;\nimport java.util.*;\nimport java.util.regex.Pattern;\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.ArtifactUtils;\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.model.Dependency;\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugin.MojoFailureException;\nimport org.apache.maven.plugins.annotations.Component;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.project.DefaultProjectBuildingRequest;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.project.ProjectBuildingRequest;\nimport org.apache.maven.repository.RepositorySystem;\nimport org.apache.maven.shared.dependency.graph.DependencyGraphBuilder;\nimport org.apache.maven.shared.dependency.graph.DependencyNode;\nimport org.apache.maven.shared.dependency.graph.filter.AncestorOrSelfDependencyNodeFilter;\nimport org.apache.maven.shared.dependency.graph.filter.AndDependencyNodeFilter;\nimport org.apache.maven.shared.dependency.graph.filter.DependencyNodeFilter;\nimport org.apache.maven.shared.dependency.graph.traversal.CollectingDependencyNodeVisitor;\nimport org.apache.maven.shared.dependency.graph.traversal.DependencyNodeVisitor;\nimport org.apache.maven.shared.dependency.graph.traversal.FilteringDependencyNodeVisitor;\nimport org.apache.maven.toolchain.Toolchain;\nimport org.apache.maven.toolchain.ToolchainManager;\nimport org.codehaus.plexus.util.StringUtils;\nimport scala_maven_dependency.*;\nimport scala_maven_executions.JavaMainCaller;\nimport scala_maven_executions.JavaMainCallerByFork;\nimport scala_maven_executions.JavaMainCallerInProcess;\nimport util.FileUtils;\n\npublic abstract class ScalaMojoSupport extends AbstractMojo {\n\n  /** The maven project. */\n  @Parameter(property = \"project\", required = true, readonly = true)\n  protected MavenProject project;\n\n  /**\n   * The Maven Session Object\n   *\n   * <p>Note: Allows extending for 3rd-party usages\n   */\n  @Parameter(property = \"session\", required = true, readonly = true)\n  protected MavenSession session;\n\n  /** Used to look up Artifacts in the remote repository. */\n  @Component RepositorySystem factory;\n\n  /**\n   * Additional dependencies/jar to add to classpath to run \"scalaClassName\" (scope and optional\n   * field not supported) ex :\n   *\n   * <pre>\n   *    &lt;dependencies&gt;\n   *      &lt;dependency&gt;\n   *        &lt;groupId&gt;org.scala-tools&lt;/groupId&gt;\n   *        &lt;artifactId&gt;scala-compiler-addon&lt;/artifactId&gt;\n   *        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n   *      &lt;/dependency&gt;\n   *    &lt;/dependencies&gt;\n   * <\/pre>\n   */\n  @Parameter protected BasicArtifact[] dependencies;\n\n  /**\n   * Compiler plugin dependencies to use when compiling. ex:\n   *\n   * <pre>\n   * &lt;compilerPlugins&gt;\n   *   &lt;compilerPlugin&gt;\n   *     &lt;groupId&gt;my.scala.plugin&lt;/groupId&gt;\n   *     &lt;artifactId&gt;amazingPlugin&lt;/artifactId&gt;\n   *     &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n   *   &lt;/compilerPlugin&gt;\n   * &lt;/compilerPlugins&gt;\n   * <\/pre>\n   */\n  @Parameter private BasicArtifact[] compilerPlugins;\n\n  /** Jvm Arguments. */\n  @Parameter protected String[] jvmArgs;\n\n  /** compiler additional arguments */\n  @Parameter protected String[] args;\n\n  /**\n   * Additional parameter to use to call the main class. Use this parameter only from command line\n   * (\"-DaddScalacArgs=arg1|arg2|arg3|...\"), not from pom.xml. To define compiler arguments in\n   * pom.xml see the \"args\" parameter.\n   */\n  @Parameter(property = \"addScalacArgs\")\n  private String addScalacArgs;\n\n  /** override the className (FQN) of the scala tool */\n  @Parameter(required = false, property = \"maven.scala.className\")\n  protected String scalaClassName;\n\n  /** Scala 's version to use. (property 'maven.scala.version' replaced by 'scala.version') */\n  @Parameter(property = \"scala.version\")\n  private String scalaVersion;\n\n  /**\n   * Organization/group ID of the Scala used in the project. Default value is 'org.scala-lang'. This\n   * is an advanced setting used for clones of the Scala Language. It should be disregarded in\n   * standard use cases.\n   */\n  @Parameter(property = \"scala.organization\", defaultValue = \"org.scala-lang\")\n  private String scalaOrganization;\n\n  /**\n   * Scala 's version to use to check binary compatibility (like suffix in artifactId of\n   * dependency). If it is defined then it is used to checkMultipleScalaVersions\n   */\n  @Parameter(property = \"scala.compat.version\")\n  private String scalaCompatVersion;\n\n  /** Path to Scala installation to use instead of the artifact (define as dependencies). */\n  @Parameter(property = \"scala.home\")\n  private String scalaHome;\n\n  /** Arguments for javac (when using incremental compiler). */\n  @Parameter(property = \"javacArgs\")\n  protected String[] javacArgs;\n\n  /**\n   * Whether to instruct javac to generate debug symbols (when using incremental compiler)\n   *\n   * @see <a href=\n   *     \"http://maven.apache.org/plugins/maven-compiler-plugin/compile-mojo.html#debug\">://maven.apache.org/plugins/maven-compiler-plugin/compile-mojo.html#debug<\/a>\n   */\n  @Parameter(property = \"javacGenerateDebugSymbols\", defaultValue = \"true\")\n  protected boolean javacGenerateDebugSymbols = true;\n\n  /**\n   * Alternative method for specifying javac arguments (when using incremental compiler). Can be\n   * used from command line with -DaddJavacArgs=arg1|arg2|arg3|... rather than in pom.xml.\n   */\n  @Parameter(property = \"addJavacArgs\")\n  protected String addJavacArgs;\n\n  /** The -source argument for the Java compiler (when using incremental compiler). */\n  @Parameter(property = \"maven.compiler.source\")\n  protected String source;\n\n  /** The -target argument for the Java compiler (when using incremental compiler). */\n  @Parameter(property = \"maven.compiler.target\")\n  protected String target;\n\n  /**\n   * The --release argument for the Java compiler (when using incremental compiler), supported since\n   * Java9.\n   */\n  @Parameter(property = \"maven.compiler.release\")\n  protected String release;\n\n  /** The -encoding argument for the Java compiler. (when using incremental compiler). */\n  @Parameter(property = \"project.build.sourceEncoding\", defaultValue = \"UTF-8\")\n  protected String encoding;\n\n  /**\n   * Display the command line called ? (property 'maven.scala.displayCmd' replaced by 'displayCmd')\n   */\n  @Parameter(property = \"displayCmd\", defaultValue = \"false\", required = true)\n  public boolean displayCmd;\n\n  /** Forks the execution of scalac into a separate process. */\n  @Parameter(defaultValue = \"true\")\n  protected boolean fork = true;\n\n  /** Force the use of an external ArgFile to run any forked process. */\n  @Parameter(defaultValue = \"false\")\n  protected boolean forceUseArgFile = false;\n\n  /** Check if every dependencies use the same version of scala-library or scala.compat.version. */\n  @Parameter(property = \"maven.scala.checkConsistency\", defaultValue = \"true\")\n  protected boolean checkMultipleScalaVersions;\n\n  /**\n   * Determines if a detection of multiple scala versions in the dependencies will cause the build\n   * to fail.\n   */\n  @Parameter(defaultValue = \"false\")\n  protected boolean failOnMultipleScalaVersions = false;\n\n  /**\n   * Should use CanonicalPath to normalize path (true =&gt; getCanonicalPath, false =&gt;\n   * getAbsolutePath)\n   *\n   * @see <a href=\n   *     \"https://github.com/davidB/scala-maven-plugin/issues/50\">https://github.com/davidB/scala-maven-plugin/issues/50<\/a>\n   */\n  @Parameter(property = \"maven.scala.useCanonicalPath\", defaultValue = \"true\")\n  protected boolean useCanonicalPath = true;\n\n  /** The dependency tree builder to use. */\n  @Component private DependencyGraphBuilder dependencyGraphBuilder;\n\n  /** The toolchain manager to use. */\n  @Component protected ToolchainManager toolchainManager;\n\n  /** List of artifacts to run plugin */\n  @Parameter(defaultValue = \"${plugin.artifacts}\")\n  private List<Artifact> pluginArtifacts;\n\n  private MavenArtifactResolver mavenArtifactResolver;\n\n  public MavenArtifactResolver findMavenArtifactResolver() {\n    if (mavenArtifactResolver == null) {\n      mavenArtifactResolver = new MavenArtifactResolver(factory, session);\n    }\n    return mavenArtifactResolver;\n  }\n\n  private Context scalaContext;\n\n  public Context findScalaContext() throws Exception {\n    // reuse/lazy scalaContext creation (doesn't need to be Thread safe, scalaContext should be\n    // stateless)\n    if (scalaContext == null) {\n      VersionNumber scalaVersion = findScalaVersion();\n\n      ArtifactIds aids =\n          scalaVersion.major == 3 ? new ArtifactIds4Scala3(scalaVersion) : new ArtifactIds4Scala2();\n      VersionNumber requiredScalaVersion =\n          StringUtils.isNotEmpty(scalaCompatVersion)\n              ? new VersionNumberMask(scalaCompatVersion)\n              : scalaVersion;\n      if (requiredScalaVersion.compareTo(scalaVersion) != 0) {\n        String msg =\n            String.format(\n                \"Scala library detected %s doesn't match scala.compat.version : %s\",\n                scalaVersion, requiredScalaVersion);\n        if (failOnMultipleScalaVersions) {\n          getLog().error(msg);\n          throw new MojoFailureException(msg);\n        }\n        getLog().warn(msg);\n      }\n      scalaContext =\n          StringUtils.isNotEmpty(scalaHome)\n              ? new Context4ScalaHome(scalaVersion, requiredScalaVersion, aids, new File(scalaHome))\n              : new Context4ScalaRemote(\n                  scalaVersion,\n                  requiredScalaVersion,\n                  aids,\n                  scalaOrganization,\n                  findMavenArtifactResolver());\n    }\n    return scalaContext;\n  }\n\n  protected void addToClasspath(\n      String groupId,\n      String artifactId,\n      String version,\n      String classifier,\n      Set<File> classpath,\n      boolean addDependencies)\n      throws Exception {\n    MavenArtifactResolver mar = findMavenArtifactResolver();\n    if (addDependencies) {\n      for (Artifact a : mar.getJarAndDependencies(groupId, artifactId, version, classifier)) {\n        classpath.add(a.getFile());\n      }\n    } else {\n      Artifact a = mar.getJar(groupId, artifactId, version, classifier);\n      classpath.add(a.getFile());\n    }\n  }\n\n  void addCompilerToClasspath(Set<File> classpath) throws Exception {\n    Context sc = findScalaContext();\n    for (Artifact dep : sc.findCompilerAndDependencies()) {\n      classpath.add(dep.getFile());\n    }\n  }\n\n  void addLibraryToClasspath(Set<File> classpath) throws Exception {\n    Context sc = findScalaContext();\n    for (Artifact dep : sc.findLibraryAndDependencies()) {\n      classpath.add(dep.getFile());\n    }\n  }\n\n  @Override\n  public void execute() throws MojoExecutionException, MojoFailureException {\n    try {\n      String oldWay = System.getProperty(\"maven.scala.version\");\n      if (oldWay != null) {\n        getLog().warn(\"using 'maven.scala.version' is deprecated, use 'scala.version' instead\");\n        if (scalaVersion != null) {\n          scalaVersion = oldWay;\n        }\n      }\n\n      oldWay = System.getProperty(\"maven.scala.displayCmd\");\n      if (oldWay != null) {\n        getLog().warn(\"using 'maven.scala.displayCmd' is deprecated, use 'displayCmd' instead\");\n        displayCmd = displayCmd || Boolean.parseBoolean(oldWay);\n      }\n      checkScalaVersion();\n      doExecute();\n    } catch (MojoExecutionException exc) {\n      throw exc;\n    } catch (MojoFailureException | RuntimeException exc) {\n      throw exc;\n    } catch (Exception exc) {\n      throw new MojoExecutionException(\"wrap: \" + exc, exc);\n    }\n  }\n\n  protected List<Dependency> getDependencies() {\n    return project.getCompileDependencies();\n  }\n\n  private VersionNumber detectedScalaVersion = null;\n\n  private VersionNumber findScalaVersion() throws Exception {\n    if (detectedScalaVersion == null) {\n      detectedScalaVersion = findScalaVersion0();\n    }\n    return detectedScalaVersion;\n  }\n\n  private VersionNumber findScalaVersion0() throws Exception {\n    String detectedScalaVersion = scalaVersion;\n    if (StringUtils.isEmpty(detectedScalaVersion)) {\n      detectedScalaVersion =\n          findVersionFromDependencies(scalaOrganization, ArtifactIds.SCALA_LIBRARY_PATTERN);\n    }\n    if (StringUtils.isEmpty(detectedScalaVersion)) {\n      if (!MavenArtifactResolver.POM.equals(project.getPackaging())) {\n        String error =\n            String.format(\n                \"%s:%s is missing from project dependencies\",\n                scalaOrganization, ArtifactIds.SCALA_LIBRARY_PATTERN.pattern());\n        getLog().error(error);\n        throw new UnsupportedOperationException(error);\n      }\n    } else {\n      // grappy hack to retrieve the SNAPSHOT version without timestamp,...\n      // because if version is -SNAPSHOT and artifact is deploy with uniqueValue then\n      // the version\n      // get from dependency is with the timestamp and a build number (the resolved\n      // version)\n      // but scala-compiler with the same version could have different resolved\n      // version (timestamp,...)\n      boolean isSnapshot = ArtifactUtils.isSnapshot(detectedScalaVersion);\n      if (isSnapshot && !detectedScalaVersion.endsWith(\"-SNAPSHOT\")) {\n        detectedScalaVersion =\n            detectedScalaVersion.substring(\n                    0,\n                    detectedScalaVersion.lastIndexOf(\n                        '-', detectedScalaVersion.lastIndexOf('-') - 1))\n                + \"-SNAPSHOT\";\n      }\n    }\n    if (StringUtils.isEmpty(detectedScalaVersion)) {\n      throw new MojoFailureException(\"no scalaVersion detected or set\");\n    }\n    if (StringUtils.isNotEmpty(scalaVersion)) {\n      if (!scalaVersion.equals(detectedScalaVersion)) {\n        getLog()\n            .warn(\n                \"scala library version define in dependencies doesn't match the scalaVersion of the plugin\");\n      }\n      // getLog().info(\"suggestion: remove the scalaVersion from pom.xml\");\n      // //scalaVersion could be define in a parent pom where lib is not required\n    }\n    return new VersionNumber(detectedScalaVersion);\n  }\n\n  // TODO refactor to do only one scan of dependencies to find version\n  private String findVersionFromDependencies(String groupId, Pattern artifactId) {\n    VersionNumber version = new VersionNumber(\"0.0.0\");\n    for (Dependency dep : getDependencies()) {\n      if (groupId.equals(dep.getGroupId()) && artifactId.matcher(dep.getArtifactId()).find()) {\n        version = version.max(new VersionNumber(dep.getVersion()));\n      }\n    }\n    if (version.major == 0) {\n      List<Dependency> deps = new ArrayList<>();\n      deps.addAll(project.getModel().getDependencies());\n      if (project.getModel().getDependencyManagement() != null) {\n        deps.addAll(project.getModel().getDependencyManagement().getDependencies());\n      }\n      for (Dependency dep : deps) {\n        if (groupId.equals(dep.getGroupId()) && artifactId.matcher(dep.getArtifactId()).find()) {\n          version = version.max(new VersionNumber(dep.getVersion()));\n        }\n      }\n    }\n    return version.major == 0 ? null : version.toString();\n  }\n\n  void checkScalaVersion() throws Exception {\n    String sv = findScalaVersion().toString();\n    if (StringUtils.isNotEmpty(scalaHome)) {\n      getLog()\n          .warn(\n              String.format(\n                  \"local scala-library.jar and scala-compiler.jar from scalaHome(%s) used instead of scala %s\",\n                  scalaHome, sv));\n    }\n    if (checkMultipleScalaVersions) {\n      checkCorrectVersionsOfScalaLibrary(sv);\n    }\n  }\n\n  /**\n   * this method checks to see if there are multiple versions of the scala library\n   *\n   * @throws Exception\n   */\n  private void checkCorrectVersionsOfScalaLibrary(String scalaDefVersion) throws Exception {\n    getLog().debug(\"Checking for multiple versions of scala\");\n    // TODO - Make sure we handle bad artifacts....\n    // TODO: note that filter does not get applied due to MNG-3236\n    VersionNumber sv = new VersionNumber(scalaDefVersion);\n    VersionNumber requiredScalaVersion =\n        StringUtils.isNotEmpty(scalaCompatVersion) ? new VersionNumberMask(scalaCompatVersion) : sv;\n    if (requiredScalaVersion.compareTo(sv) != 0) {\n      String msg =\n          String.format(\n              \"Scala library detected %s doesn't match scala.compat.version : %s\",\n              sv, requiredScalaVersion);\n      if (failOnMultipleScalaVersions) {\n        getLog().error(msg);\n        throw new MojoFailureException(msg);\n      }\n      getLog().warn(msg);\n    }\n    ProjectBuildingRequest request =\n        new DefaultProjectBuildingRequest(session.getProjectBuildingRequest());\n    request.setProject(project);\n    checkArtifactForScalaVersion(\n        findScalaContext(), dependencyGraphBuilder.buildDependencyGraph(request, null));\n  }\n\n  /** Visits a node (and all dependencies) to see if it contains duplicate scala versions */\n  private void checkArtifactForScalaVersion(Context scalaContext, DependencyNode rootNode)\n      throws Exception {\n    final CheckScalaVersionVisitor visitor = new CheckScalaVersionVisitor(scalaContext, getLog());\n\n    CollectingDependencyNodeVisitor collectingVisitor = new CollectingDependencyNodeVisitor();\n    DependencyNodeVisitor firstPassVisitor =\n        new FilteringDependencyNodeVisitor(collectingVisitor, createScalaDistroDependencyFilter());\n    rootNode.accept(firstPassVisitor);\n\n    DependencyNodeFilter secondPassFilter =\n        new AncestorOrSelfDependencyNodeFilter(collectingVisitor.getNodes());\n    DependencyNodeVisitor filteredVisitor =\n        new FilteringDependencyNodeVisitor(visitor, secondPassFilter);\n\n    rootNode.accept(filteredVisitor);\n\n    if (visitor.isFailed()) {\n      visitor.logScalaDependents();\n      if (failOnMultipleScalaVersions) {\n        getLog().error(\"Multiple versions of scala libraries detected!\");\n        throw new MojoFailureException(\"Multiple versions of scala libraries detected!\");\n      }\n      getLog().warn(\"Multiple versions of scala libraries detected!\");\n    }\n  }\n\n  /** @return A filter to only extract artifacts deployed from scala distributions */\n  private DependencyNodeFilter createScalaDistroDependencyFilter() throws Exception {\n    List<DependencyNodeFilter> filters = new ArrayList<>();\n    filters.add(new ScalaDistroArtifactFilter(findScalaContext()));\n    return new AndDependencyNodeFilter(filters);\n  }\n\n  protected abstract void doExecute() throws Exception;\n\n  /**\n   * Get a {@link JavaMainCaller} used invoke a Java process. Typically, this will be one of the\n   * Scala utilities (Compiler, ScalaDoc, REPL, etc.).\n   *\n   * <p>This method does some setup on the {@link JavaMainCaller} which is not done by merely\n   * invoking {@code new} on one of the implementations. Specifically, it adds any Scala compiler\n   * plugin options, JVM options, and Scalac options defined on the plugin.\n   *\n   * @param forkOverride override the setting for {@link #fork}. Currently, this should only be set\n   *     if you are invoking the REPL.\n   * @param mainClass the JVM main class to invoke.\n   * @return a {@link JavaMainCaller} to use to invoke the given command.\n   */\n  final JavaMainCaller getScalaCommand(final boolean forkOverride, final String mainClass)\n      throws Exception {\n    JavaMainCaller cmd = getEmptyScalaCommand(mainClass, forkOverride);\n    cmd.addArgs(args);\n    if (StringUtils.isNotEmpty(addScalacArgs)) {\n      cmd.addArgs(StringUtils.split(addScalacArgs, \"|\"));\n    }\n    addCompilerPluginOptions(cmd);\n    cmd.addJvmArgs(jvmArgs);\n    return cmd;\n  }\n\n  /**\n   * Get a {@link JavaMainCaller} used invoke a Java process. Typically this will be one of the\n   * Scala utilities (Compiler, ScalaDoc, REPL, etc.).\n   *\n   * @param mainClass the JVM main class to invoke.\n   * @return a {@link JavaMainCaller} to use to invoke the given command.\n   */\n  final JavaMainCaller getEmptyScalaCommand(final String mainClass) throws Exception {\n    return getEmptyScalaCommand(mainClass, fork);\n  }\n\n  /**\n   * Get a {@link JavaMainCaller} used invoke a Java process. Typically this will be one of the\n   * Scala utilities (Compiler, ScalaDoc, REPL, etc.).\n   *\n   * @param mainClass the JVM main class to invoke.\n   * @param forkOverride override the setting for {@link #fork}. Currently this should only be set\n   *     if you are invoking the REPL.\n   * @return a {@link JavaMainCaller} to use to invoke the given command.\n   */\n  private JavaMainCaller getEmptyScalaCommand(final String mainClass, final boolean forkOverride)\n      throws Exception {\n\n    // If we are deviating from the plugin settings, let the user know\n    // what's going on.\n    if (forkOverride != fork) {\n      super.getLog().info(\"Fork behavior overridden\");\n      super.getLog()\n          .info(String.format(\"Fork for this execution is %s.\", String.valueOf(forkOverride)));\n    }\n\n    // TODO - Fork or not depending on configuration?\n    JavaMainCaller cmd;\n    String toolcp = getToolClasspath();\n    if (forkOverride) {\n      // HACK (better may need refactor)\n      boolean bootcp = true;\n      if (args != null) {\n        for (String arg : args) {\n          bootcp = bootcp && !\"-nobootcp\".equals(arg);\n        }\n      }\n      String cp = bootcp ? \"\" : toolcp;\n      bootcp =\n          bootcp && !(StringUtils.isNotEmpty(addScalacArgs) && addScalacArgs.contains(\"-nobootcp\"));\n      // scalac with args in files\n      // * works only since 2.8.0\n      // * is buggy (don't manage space in path on windows)\n      getLog().debug(\"use java command with args in file forced : \" + forceUseArgFile);\n      cmd =\n          new JavaMainCallerByFork(\n              this, mainClass, cp, null, null, forceUseArgFile, getToolchain());\n      if (bootcp) {\n        cmd.addJvmArgs(\"-Xbootclasspath/a:\" + toolcp);\n      }\n    } else {\n      cmd = new JavaMainCallerInProcess(this, mainClass, toolcp, null, null);\n    }\n    return cmd;\n  }\n\n  protected Toolchain getToolchain() {\n    return toolchainManager.getToolchainFromBuildContext(\"jdk\", session);\n  }\n\n  private String getToolClasspath() throws Exception {\n    Set<File> classpath = new TreeSet<>();\n    addLibraryToClasspath(classpath);\n    addCompilerToClasspath(classpath);\n    if (dependencies != null) {\n      for (BasicArtifact artifact : dependencies) {\n        addToClasspath(\n            artifact.groupId, artifact.artifactId, artifact.version, \"\", classpath, true);\n      }\n    }\n    return FileUtils.toMultiPath(classpath);\n  }\n\n  protected List<String> getScalacOptions() throws Exception {\n    List<String> options = new ArrayList<>();\n    if (args != null) Collections.addAll(options, args);\n    if (StringUtils.isNotEmpty(addScalacArgs)) {\n      Collections.addAll(options, StringUtils.split(addScalacArgs, \"|\"));\n    }\n    options.addAll(getCompilerPluginOptions());\n\n    if (target != null && !target.isEmpty()) {\n      options.add(\"-target:\" + target);\n    }\n    if (release != null && !release.isEmpty()) {\n      options.add(\"-release\");\n      options.add(release);\n    }\n\n    return options;\n  }\n\n  protected List<String> getJavacOptions() {\n    List<String> options = new ArrayList<>();\n    if (javacArgs != null) Collections.addAll(options, javacArgs);\n    if (StringUtils.isNotEmpty(addJavacArgs)) {\n      Collections.addAll(options, StringUtils.split(addJavacArgs, \"|\"));\n    }\n\n    // issue #116\n    if (javacGenerateDebugSymbols) {\n      options.add(\"-g\");\n    }\n    if (release != null && !release.isEmpty()) {\n      options.add(\"--release\");\n      options.add(release);\n    } else {\n      if (target != null && !target.isEmpty()) {\n        options.add(\"-target\");\n        options.add(target);\n      }\n      if (source != null && !source.isEmpty()) {\n        options.add(\"-source\");\n        options.add(source);\n      }\n    }\n    if (encoding != null) {\n      options.add(\"-encoding\");\n      options.add(encoding);\n    }\n    return options;\n  }\n\n  /**\n   * @return This returns whether or not the scala version can support having java sent into the\n   *     compiler\n   */\n  protected boolean isJavaSupportedByCompiler() throws Exception {\n    return findScalaVersion().compareTo(new VersionNumber(\"2.7.2\")) >= 0;\n  }\n\n  /**\n   * Adds appropriate compiler plugins to the scalac command.\n   *\n   * @param scalac\n   * @throws Exception\n   */\n  protected void addCompilerPluginOptions(JavaMainCaller scalac) throws Exception {\n    for (String option : getCompilerPluginOptions()) {\n      scalac.addArgs(option);\n    }\n  }\n\n  private List<String> getCompilerPluginOptions() throws Exception {\n    List<String> options = new ArrayList<>();\n    for (File plugin : getCompilerPlugins()) {\n      options.add(\"-Xplugin:\" + plugin.getPath());\n    }\n    return options;\n  }\n\n  /**\n   * Retrieves a list of paths to scala compiler plugins.\n   *\n   * @return The list of plugins\n   * @throws Exception\n   */\n  private Set<File> getCompilerPlugins() throws Exception {\n    Set<File> plugins = new TreeSet<>();\n    if (compilerPlugins != null) {\n      Set<File> ignoreClasspath = new TreeSet<>();\n      addCompilerToClasspath(ignoreClasspath);\n      addLibraryToClasspath(ignoreClasspath);\n      for (BasicArtifact artifact : compilerPlugins) {\n        getLog().info(\"compiler plugin: \" + artifact.toString());\n        // TODO - Ensure proper scala version for plugins\n        Set<File> pluginClassPath = new TreeSet<>();\n        addToClasspath(\n            artifact.groupId,\n            artifact.artifactId,\n            artifact.version,\n            artifact.classifier,\n            pluginClassPath,\n            false);\n        pluginClassPath.removeAll(ignoreClasspath);\n        plugins.addAll(pluginClassPath);\n      }\n    }\n    return plugins;\n  }\n}\n","Method after Refactoring":"/*\n * This is free and unencumbered software released into the public domain.\n * See UNLICENSE.\n */\npackage scala_maven;\n\nimport java.io.File;\nimport java.util.*;\nimport java.util.regex.Pattern;\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.ArtifactUtils;\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.model.Dependency;\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugin.MojoFailureException;\nimport org.apache.maven.plugins.annotations.Component;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.project.DefaultProjectBuildingRequest;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.project.ProjectBuildingRequest;\nimport org.apache.maven.repository.RepositorySystem;\nimport org.apache.maven.shared.dependency.graph.DependencyGraphBuilder;\nimport org.apache.maven.shared.dependency.graph.DependencyNode;\nimport org.apache.maven.shared.dependency.graph.filter.AncestorOrSelfDependencyNodeFilter;\nimport org.apache.maven.shared.dependency.graph.filter.AndDependencyNodeFilter;\nimport org.apache.maven.shared.dependency.graph.filter.DependencyNodeFilter;\nimport org.apache.maven.shared.dependency.graph.traversal.CollectingDependencyNodeVisitor;\nimport org.apache.maven.shared.dependency.graph.traversal.DependencyNodeVisitor;\nimport org.apache.maven.shared.dependency.graph.traversal.FilteringDependencyNodeVisitor;\nimport org.apache.maven.toolchain.Toolchain;\nimport org.apache.maven.toolchain.ToolchainManager;\nimport org.codehaus.plexus.util.StringUtils;\nimport scala_maven_dependency.*;\nimport scala_maven_executions.JavaMainCaller;\nimport scala_maven_executions.JavaMainCallerByFork;\nimport scala_maven_executions.JavaMainCallerInProcess;\nimport util.FileUtils;\n\npublic abstract class ScalaMojoSupport extends AbstractMojo {\n\n  /** The maven project. */\n  @Parameter(property = \"project\", required = true, readonly = true)\n  protected MavenProject project;\n\n  /**\n   * The Maven Session Object\n   *\n   * <p>Note: Allows extending for 3rd-party usages\n   */\n  @Parameter(property = \"session\", required = true, readonly = true)\n  protected MavenSession session;\n\n  /** Used to look up Artifacts in the remote repository. */\n  @Component RepositorySystem factory;\n\n  /**\n   * Additional dependencies/jar to add to classpath to run \"scalaClassName\" (scope and optional\n   * field not supported) ex :\n   *\n   * <pre>\n   *    &lt;dependencies&gt;\n   *      &lt;dependency&gt;\n   *        &lt;groupId&gt;org.scala-tools&lt;/groupId&gt;\n   *        &lt;artifactId&gt;scala-compiler-addon&lt;/artifactId&gt;\n   *        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n   *      &lt;/dependency&gt;\n   *    &lt;/dependencies&gt;\n   * <\/pre>\n   */\n  @Parameter protected BasicArtifact[] dependencies;\n\n  /**\n   * Compiler plugin dependencies to use when compiling. ex:\n   *\n   * <pre>\n   * &lt;compilerPlugins&gt;\n   *   &lt;compilerPlugin&gt;\n   *     &lt;groupId&gt;my.scala.plugin&lt;/groupId&gt;\n   *     &lt;artifactId&gt;amazingPlugin&lt;/artifactId&gt;\n   *     &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n   *   &lt;/compilerPlugin&gt;\n   * &lt;/compilerPlugins&gt;\n   * <\/pre>\n   */\n  @Parameter private BasicArtifact[] compilerPlugins;\n\n  /** Jvm Arguments. */\n  @Parameter protected String[] jvmArgs;\n\n  /** compiler additional arguments */\n  @Parameter protected String[] args;\n\n  /**\n   * Additional parameter to use to call the main class. Use this parameter only from command line\n   * (\"-DaddScalacArgs=arg1|arg2|arg3|...\"), not from pom.xml. To define compiler arguments in\n   * pom.xml see the \"args\" parameter.\n   */\n  @Parameter(property = \"addScalacArgs\")\n  private String addScalacArgs;\n\n  /** override the className (FQN) of the scala tool */\n  @Parameter(required = false, property = \"maven.scala.className\")\n  protected String scalaClassName;\n\n  /** Scala 's version to use. (property 'maven.scala.version' replaced by 'scala.version') */\n  @Parameter(property = \"scala.version\")\n  private String scalaVersion;\n\n  /**\n   * Organization/group ID of the Scala used in the project. Default value is 'org.scala-lang'. This\n   * is an advanced setting used for clones of the Scala Language. It should be disregarded in\n   * standard use cases.\n   */\n  @Parameter(property = \"scala.organization\", defaultValue = \"org.scala-lang\")\n  private String scalaOrganization;\n\n  /**\n   * Scala 's version to use to check binary compatibility (like suffix in artifactId of\n   * dependency). If it is defined then it is used to checkMultipleScalaVersions\n   */\n  @Parameter(property = \"scala.compat.version\")\n  private String scalaCompatVersion;\n\n  /** Path to Scala installation to use instead of the artifact (define as dependencies). */\n  @Parameter(property = \"scala.home\")\n  private String scalaHome;\n\n  /** Arguments for javac (when using incremental compiler). */\n  @Parameter(property = \"javacArgs\")\n  protected String[] javacArgs;\n\n  /**\n   * Whether to instruct javac to generate debug symbols (when using incremental compiler)\n   *\n   * @see <a href=\n   *     \"http://maven.apache.org/plugins/maven-compiler-plugin/compile-mojo.html#debug\">://maven.apache.org/plugins/maven-compiler-plugin/compile-mojo.html#debug<\/a>\n   */\n  @Parameter(property = \"javacGenerateDebugSymbols\", defaultValue = \"true\")\n  protected boolean javacGenerateDebugSymbols = true;\n\n  /**\n   * Alternative method for specifying javac arguments (when using incremental compiler). Can be\n   * used from command line with -DaddJavacArgs=arg1|arg2|arg3|... rather than in pom.xml.\n   */\n  @Parameter(property = \"addJavacArgs\")\n  protected String addJavacArgs;\n\n  /** The -source argument for the Java compiler (when using incremental compiler). */\n  @Parameter(property = \"maven.compiler.source\")\n  protected String source;\n\n  /** The -target argument for the Java compiler (when using incremental compiler). */\n  @Parameter(property = \"maven.compiler.target\")\n  protected String target;\n\n  /**\n   * The --release argument for the Java compiler (when using incremental compiler), supported since\n   * Java9.\n   */\n  @Parameter(property = \"maven.compiler.release\")\n  protected String release;\n\n  /** The -encoding argument for the Java compiler. (when using incremental compiler). */\n  @Parameter(property = \"project.build.sourceEncoding\", defaultValue = \"UTF-8\")\n  protected String encoding;\n\n  /**\n   * Display the command line called ? (property 'maven.scala.displayCmd' replaced by 'displayCmd')\n   */\n  @Parameter(property = \"displayCmd\", defaultValue = \"false\", required = true)\n  public boolean displayCmd;\n\n  /** Forks the execution of scalac into a separate process. */\n  @Parameter(defaultValue = \"true\")\n  protected boolean fork = true;\n\n  /** Force the use of an external ArgFile to run any forked process. */\n  @Parameter(defaultValue = \"false\")\n  protected boolean forceUseArgFile = false;\n\n  /** Check if every dependencies use the same version of scala-library or scala.compat.version. */\n  @Parameter(property = \"maven.scala.checkConsistency\", defaultValue = \"true\")\n  protected boolean checkMultipleScalaVersions;\n\n  /**\n   * Determines if a detection of multiple scala versions in the dependencies will cause the build\n   * to fail.\n   */\n  @Parameter(defaultValue = \"false\")\n  protected boolean failOnMultipleScalaVersions = false;\n\n  /**\n   * Should use CanonicalPath to normalize path (true =&gt; getCanonicalPath, false =&gt;\n   * getAbsolutePath)\n   *\n   * @see <a href=\n   *     \"https://github.com/davidB/scala-maven-plugin/issues/50\">https://github.com/davidB/scala-maven-plugin/issues/50<\/a>\n   */\n  @Parameter(property = \"maven.scala.useCanonicalPath\", defaultValue = \"true\")\n  protected boolean useCanonicalPath = true;\n\n  /** The dependency tree builder to use. */\n  @Component private DependencyGraphBuilder dependencyGraphBuilder;\n\n  /** The toolchain manager to use. */\n  @Component protected ToolchainManager toolchainManager;\n\n  /** List of artifacts to run plugin */\n  @Parameter(defaultValue = \"${plugin.artifacts}\")\n  private List<Artifact> pluginArtifacts;\n\n  private MavenArtifactResolver mavenArtifactResolver;\n\n  public MavenArtifactResolver findMavenArtifactResolver() {\n    if (mavenArtifactResolver == null) {\n      mavenArtifactResolver = new MavenArtifactResolver(factory, session);\n    }\n    return mavenArtifactResolver;\n  }\n\n  private Context scalaContext;\n\n  public Context findScalaContext() throws Exception {\n    // reuse/lazy scalaContext creation (doesn't need to be Thread safe, scalaContext should be\n    // stateless)\n    if (scalaContext == null) {\n      VersionNumber scalaVersion = findScalaVersion();\n\n      ArtifactIds aids =\n          scalaVersion.major == 3 ? new ArtifactIds4Scala3(scalaVersion) : new ArtifactIds4Scala2();\n      VersionNumber requiredScalaVersion =\n          StringUtils.isNotEmpty(scalaCompatVersion)\n              ? new VersionNumberMask(scalaCompatVersion)\n              : scalaVersion;\n      if (requiredScalaVersion.compareTo(scalaVersion) != 0) {\n        String msg =\n            String.format(\n                \"Scala library detected %s doesn't match scala.compat.version : %s\",\n                scalaVersion, requiredScalaVersion);\n        if (failOnMultipleScalaVersions) {\n          getLog().error(msg);\n          throw new MojoFailureException(msg);\n        }\n        getLog().warn(msg);\n      }\n      scalaContext =\n          StringUtils.isNotEmpty(scalaHome)\n              ? new Context4ScalaHome(scalaVersion, requiredScalaVersion, aids, new File(scalaHome))\n              : new Context4ScalaRemote(\n                  scalaVersion,\n                  requiredScalaVersion,\n                  aids,\n                  scalaOrganization,\n                  findMavenArtifactResolver());\n    }\n    return scalaContext;\n  }\n\n  protected void addToClasspath(\n      String groupId,\n      String artifactId,\n      String version,\n      String classifier,\n      Set<File> classpath,\n      boolean addDependencies)\n      throws Exception {\n    MavenArtifactResolver mar = findMavenArtifactResolver();\n    if (addDependencies) {\n      for (Artifact a : mar.getJarAndDependencies(groupId, artifactId, version, classifier)) {\n        classpath.add(a.getFile());\n      }\n    } else {\n      Artifact a = mar.getJar(groupId, artifactId, version, classifier);\n      classpath.add(a.getFile());\n    }\n  }\n\n  void addCompilerToClasspath(Set<File> classpath) throws Exception {\n    Context sc = findScalaContext();\n    for (Artifact dep : sc.findCompilerAndDependencies()) {\n      classpath.add(dep.getFile());\n    }\n  }\n\n  void addLibraryToClasspath(Set<File> classpath) throws Exception {\n    Context sc = findScalaContext();\n    for (Artifact dep : sc.findLibraryAndDependencies()) {\n      classpath.add(dep.getFile());\n    }\n  }\n\n  @Override\n  public void execute() throws MojoExecutionException, MojoFailureException {\n    try {\n      String oldWay = System.getProperty(\"maven.scala.version\");\n      if (oldWay != null) {\n        getLog().warn(\"using 'maven.scala.version' is deprecated, use 'scala.version' instead\");\n        if (scalaVersion != null) {\n          scalaVersion = oldWay;\n        }\n      }\n\n      oldWay = System.getProperty(\"maven.scala.displayCmd\");\n      if (oldWay != null) {\n        getLog().warn(\"using 'maven.scala.displayCmd' is deprecated, use 'displayCmd' instead\");\n        displayCmd = displayCmd || Boolean.parseBoolean(oldWay);\n      }\n      checkScalaVersion();\n      doExecute();\n    } catch (MojoExecutionException exc) {\n      throw exc;\n    } catch (MojoFailureException | RuntimeException exc) {\n      throw exc;\n    } catch (Exception exc) {\n      throw new MojoExecutionException(\"wrap: \" + exc, exc);\n    }\n  }\n\n  protected List<Dependency> getDependencies() {\n    return project.getCompileDependencies();\n  }\n\n  private VersionNumber detectedScalaVersion = null;\n\n  private VersionNumber findScalaVersion() throws Exception {\n    if (detectedScalaVersion == null) {\n      detectedScalaVersion = findScalaVersion0();\n    }\n    return detectedScalaVersion;\n  }\n\n  private VersionNumber findScalaVersion0() throws Exception {\n    String detectedScalaVersion = scalaVersion;\n    if (StringUtils.isEmpty(detectedScalaVersion)) {\n      detectedScalaVersion =\n          findVersionFromDependencies(scalaOrganization, ArtifactIds.SCALA_LIBRARY_PATTERN);\n    }\n    if (StringUtils.isEmpty(detectedScalaVersion)) {\n      if (!MavenArtifactResolver.POM.equals(project.getPackaging())) {\n        String error =\n            String.format(\n                \"%s:%s is missing from project dependencies\",\n                scalaOrganization, ArtifactIds.SCALA_LIBRARY_PATTERN.pattern());\n        getLog().error(error);\n        throw new UnsupportedOperationException(error);\n      }\n    } else {\n      // grappy hack to retrieve the SNAPSHOT version without timestamp,...\n      // because if version is -SNAPSHOT and artifact is deploy with uniqueValue then\n      // the version\n      // get from dependency is with the timestamp and a build number (the resolved\n      // version)\n      // but scala-compiler with the same version could have different resolved\n      // version (timestamp,...)\n      boolean isSnapshot = ArtifactUtils.isSnapshot(detectedScalaVersion);\n      if (isSnapshot && !detectedScalaVersion.endsWith(\"-SNAPSHOT\")) {\n        detectedScalaVersion =\n            detectedScalaVersion.substring(\n                    0,\n                    detectedScalaVersion.lastIndexOf(\n                        '-', detectedScalaVersion.lastIndexOf('-') - 1))\n                + \"-SNAPSHOT\";\n      }\n    }\n    if (StringUtils.isEmpty(detectedScalaVersion)) {\n      throw new MojoFailureException(\"no scalaVersion detected or set\");\n    }\n    if (StringUtils.isNotEmpty(scalaVersion)) {\n      if (!scalaVersion.equals(detectedScalaVersion)) {\n        getLog()\n            .warn(\n                \"scala library version define in dependencies doesn't match the scalaVersion of the plugin\");\n      }\n      // getLog().info(\"suggestion: remove the scalaVersion from pom.xml\");\n      // //scalaVersion could be define in a parent pom where lib is not required\n    }\n    return new VersionNumber(detectedScalaVersion);\n  }\n\n  // TODO refactor to do only one scan of dependencies to find version\n  private String findVersionFromDependencies(String groupId, Pattern artifactId) {\n    VersionNumber version = new VersionNumber(\"0.0.0\");\n    for (Dependency dep : getDependencies()) {\n      if (groupId.equals(dep.getGroupId()) && artifactId.matcher(dep.getArtifactId()).find()) {\n        version = version.max(new VersionNumber(dep.getVersion()));\n      }\n    }\n    if (version.major == 0) {\n      List<Dependency> deps = new ArrayList<>();\n      deps.addAll(project.getModel().getDependencies());\n      if (project.getModel().getDependencyManagement() != null) {\n        deps.addAll(project.getModel().getDependencyManagement().getDependencies());\n      }\n      for (Dependency dep : deps) {\n        if (groupId.equals(dep.getGroupId()) && artifactId.matcher(dep.getArtifactId()).find()) {\n          version = version.max(new VersionNumber(dep.getVersion()));\n        }\n      }\n    }\n    return version.major == 0 ? null : version.toString();\n  }\n\n  void checkScalaVersion() throws Exception {\n    String sv = findScalaVersion().toString();\n    if (StringUtils.isNotEmpty(scalaHome)) {\n      getLog()\n          .warn(\n              String.format(\n                  \"local scala-library.jar and scala-compiler.jar from scalaHome(%s) used instead of scala %s\",\n                  scalaHome, sv));\n    }\n    if (checkMultipleScalaVersions) {\n      checkCorrectVersionsOfScalaLibrary(sv);\n    }\n  }\n\n  /**\n   * this method checks to see if there are multiple versions of the scala library\n   *\n   * @throws Exception\n   */\n  private void checkCorrectVersionsOfScalaLibrary(String scalaDefVersion) throws Exception {\n    getLog().debug(\"Checking for multiple versions of scala\");\n    // TODO - Make sure we handle bad artifacts....\n    // TODO: note that filter does not get applied due to MNG-3236\n    VersionNumber sv = new VersionNumber(scalaDefVersion);\n    VersionNumber requiredScalaVersion =\n        StringUtils.isNotEmpty(scalaCompatVersion) ? new VersionNumberMask(scalaCompatVersion) : sv;\n    if (requiredScalaVersion.compareTo(sv) != 0) {\n      String msg =\n          String.format(\n              \"Scala library detected %s doesn't match scala.compat.version : %s\",\n              sv, requiredScalaVersion);\n      if (failOnMultipleScalaVersions) {\n        getLog().error(msg);\n        throw new MojoFailureException(msg);\n      }\n      getLog().warn(msg);\n    }\n    ProjectBuildingRequest request =\n        new DefaultProjectBuildingRequest(session.getProjectBuildingRequest());\n    request.setProject(project);\n    checkArtifactForScalaVersion(\n        findScalaContext(), dependencyGraphBuilder.buildDependencyGraph(request, null));\n  }\n\n  /** Visits a node (and all dependencies) to see if it contains duplicate scala versions */\n  private void checkArtifactForScalaVersion(Context scalaContext, DependencyNode rootNode)\n      throws Exception {\n    final CheckScalaVersionVisitor visitor = new CheckScalaVersionVisitor(scalaContext, getLog());\n\n    CollectingDependencyNodeVisitor collectingVisitor = new CollectingDependencyNodeVisitor();\n    DependencyNodeVisitor firstPassVisitor =\n        new FilteringDependencyNodeVisitor(collectingVisitor, createScalaDistroDependencyFilter());\n    rootNode.accept(firstPassVisitor);\n\n    DependencyNodeFilter secondPassFilter =\n        new AncestorOrSelfDependencyNodeFilter(collectingVisitor.getNodes());\n    DependencyNodeVisitor filteredVisitor =\n        new FilteringDependencyNodeVisitor(visitor, secondPassFilter);\n\n    rootNode.accept(filteredVisitor);\n\n    if (visitor.isFailed()) {\n      visitor.logScalaDependents();\n      if (failOnMultipleScalaVersions) {\n        getLog().error(\"Multiple versions of scala libraries detected!\");\n        throw new MojoFailureException(\"Multiple versions of scala libraries detected!\");\n      }\n      getLog().warn(\"Multiple versions of scala libraries detected!\");\n    }\n  }\n\n  /** @return A filter to only extract artifacts deployed from scala distributions */\n  private DependencyNodeFilter createScalaDistroDependencyFilter() throws Exception {\n    List<DependencyNodeFilter> filters = new ArrayList<>();\n    filters.add(new ScalaDistroArtifactFilter(findScalaContext()));\n    return new AndDependencyNodeFilter(filters);\n  }\n\n  protected abstract void doExecute() throws Exception;\n\n  /**\n   * Get a {@link JavaMainCaller} used invoke a Java process. Typically, this will be one of the\n   * Scala utilities (Compiler, ScalaDoc, REPL, etc.).\n   *\n   * <p>This method does some setup on the {@link JavaMainCaller} which is not done by merely\n   * invoking {@code new} on one of the implementations. Specifically, it adds any Scala compiler\n   * plugin options, JVM options, and Scalac options defined on the plugin.\n   *\n   * @param forkOverride override the setting for {@link #fork}. Currently, this should only be set\n   *     if you are invoking the REPL.\n   * @param mainClass the JVM main class to invoke.\n   * @return a {@link JavaMainCaller} to use to invoke the given command.\n   */\n  final JavaMainCaller getScalaCommand(final boolean forkOverride, final String mainClass)\n      throws Exception {\n    JavaMainCaller cmd = getEmptyScalaCommand(mainClass, forkOverride);\n    cmd.addArgs(args);\n    if (StringUtils.isNotEmpty(addScalacArgs)) {\n      cmd.addArgs(StringUtils.split(addScalacArgs, \"|\"));\n    }\n    addCompilerPluginOptions(cmd);\n    cmd.addJvmArgs(jvmArgs);\n    return cmd;\n  }\n\n  /**\n   * Get a {@link JavaMainCaller} used invoke a Java process. Typically this will be one of the\n   * Scala utilities (Compiler, ScalaDoc, REPL, etc.).\n   *\n   * @param mainClass the JVM main class to invoke.\n   * @return a {@link JavaMainCaller} to use to invoke the given command.\n   */\n  final JavaMainCaller getEmptyScalaCommand(final String mainClass) throws Exception {\n    return getEmptyScalaCommand(mainClass, fork);\n  }\n\n  /**\n   * Get a {@link JavaMainCaller} used invoke a Java process. Typically this will be one of the\n   * Scala utilities (Compiler, ScalaDoc, REPL, etc.).\n   *\n   * @param mainClass the JVM main class to invoke.\n   * @param forkOverride override the setting for {@link #fork}. Currently this should only be set\n   *     if you are invoking the REPL.\n   * @return a {@link JavaMainCaller} to use to invoke the given command.\n   */\n  private JavaMainCaller getEmptyScalaCommand(final String mainClass, final boolean forkOverride)\n      throws Exception {\n\n    // If we are deviating from the plugin settings, let the user know\n    // what's going on.\n    if (forkOverride != fork) {\n      super.getLog().info(\"Fork behavior overridden\");\n      super.getLog()\n          .info(String.format(\"Fork for this execution is %s.\", String.valueOf(forkOverride)));\n    }\n\n    // TODO - Fork or not depending on configuration?\n    JavaMainCaller cmd;\n    String toolcp = getToolClasspath();\n    if (forkOverride) {\n      // HACK (better may need refactor)\n      boolean bootcp = true;\n      if (args != null) {\n        for (String arg : args) {\n          bootcp = bootcp && !\"-nobootcp\".equals(arg);\n        }\n      }\n      String cp = bootcp ? \"\" : toolcp;\n      bootcp =\n          bootcp && !(StringUtils.isNotEmpty(addScalacArgs) && addScalacArgs.contains(\"-nobootcp\"));\n      // scalac with args in files\n      // * works only since 2.8.0\n      // * is buggy (don't manage space in path on windows)\n      getLog().debug(\"use java command with args in file forced : \" + forceUseArgFile);\n      cmd =\n          new JavaMainCallerByFork(\n              this, mainClass, cp, null, null, forceUseArgFile, getToolchain());\n      if (bootcp) {\n        cmd.addJvmArgs(\"-Xbootclasspath/a:\" + toolcp);\n      }\n    } else {\n      cmd = new JavaMainCallerInProcess(this, mainClass, toolcp, null, null);\n    }\n    return cmd;\n  }\n\n  protected Toolchain getToolchain() {\n    return toolchainManager.getToolchainFromBuildContext(\"jdk\", session);\n  }\n\n  private String getToolClasspath() throws Exception {\n    Set<File> classpath = new TreeSet<>();\n    addLibraryToClasspath(classpath);\n    addCompilerToClasspath(classpath);\n    if (dependencies != null) {\n      for (BasicArtifact artifact : dependencies) {\n        addToClasspath(\n            artifact.groupId, artifact.artifactId, artifact.version, \"\", classpath, true);\n      }\n    }\n    return FileUtils.toMultiPath(classpath);\n  }\n\n  static String targetOption(String target, VersionNumber scalaVersion) {\n    if (scalaVersion.major == 2) {\n      if (scalaVersion.minor <= 12) {\n        if (target.equals(\"1.5\") || target.equals(\"5\")) {\n          return \"jvm-1.5\";\n        } else if (target.equals(\"1.6\") || target.equals(\"6\")) {\n          return \"jvm-1.6\";\n        } else if (target.equals(\"1.7\") || target.equals(\"7\")) {\n          return \"jvm-1.7\";\n        } else if (target.equals(\"1.8\") || target.equals(\"8\")) {\n          return \"jvm-1.8\";\n        } else {\n          // invalid or unsupported option, just ignore\n          return null;\n        }\n      } else if (target.equals(\"1.5\")) {\n        return \"5\";\n      } else if (target.equals(\"1.6\")) {\n        return \"6\";\n      } else if (target.equals(\"1.7\")) {\n        return \"7\";\n      } else if (target.equals(\"1.8\")) {\n        return \"8\";\n      }\n    }\n    return target;\n  }\n\n  protected List<String> getScalacOptions() throws Exception {\n    List<String> options = new ArrayList<>();\n    if (args != null) Collections.addAll(options, args);\n    if (StringUtils.isNotEmpty(addScalacArgs)) {\n      Collections.addAll(options, StringUtils.split(addScalacArgs, \"|\"));\n    }\n    options.addAll(getCompilerPluginOptions());\n\n    if (target != null && !target.isEmpty()) {\n      String targetOption = targetOption(target, findScalaVersion());\n      if (targetOption != null) {\n        options.add(\"-target:\" + targetOption);\n      }\n    }\n    if (release != null && !release.isEmpty()) {\n      options.add(\"-release\");\n      options.add(release);\n    }\n\n    return options;\n  }\n\n  protected List<String> getJavacOptions() {\n    List<String> options = new ArrayList<>();\n    if (javacArgs != null) Collections.addAll(options, javacArgs);\n    if (StringUtils.isNotEmpty(addJavacArgs)) {\n      Collections.addAll(options, StringUtils.split(addJavacArgs, \"|\"));\n    }\n\n    // issue #116\n    if (javacGenerateDebugSymbols) {\n      options.add(\"-g\");\n    }\n    if (release != null && !release.isEmpty()) {\n      options.add(\"--release\");\n      options.add(release);\n    } else {\n      if (target != null && !target.isEmpty()) {\n        options.add(\"-target\");\n        options.add(target);\n      }\n      if (source != null && !source.isEmpty()) {\n        options.add(\"-source\");\n        options.add(source);\n      }\n    }\n    if (encoding != null) {\n      options.add(\"-encoding\");\n      options.add(encoding);\n    }\n    return options;\n  }\n\n  /**\n   * @return This returns whether or not the scala version can support having java sent into the\n   *     compiler\n   */\n  protected boolean isJavaSupportedByCompiler() throws Exception {\n    return findScalaVersion().compareTo(new VersionNumber(\"2.7.2\")) >= 0;\n  }\n\n  /**\n   * Adds appropriate compiler plugins to the scalac command.\n   *\n   * @param scalac\n   * @throws Exception\n   */\n  protected void addCompilerPluginOptions(JavaMainCaller scalac) throws Exception {\n    for (String option : getCompilerPluginOptions()) {\n      scalac.addArgs(option);\n    }\n  }\n\n  private List<String> getCompilerPluginOptions() throws Exception {\n    List<String> options = new ArrayList<>();\n    for (File plugin : getCompilerPlugins()) {\n      options.add(\"-Xplugin:\" + plugin.getPath());\n    }\n    return options;\n  }\n\n  /**\n   * Retrieves a list of paths to scala compiler plugins.\n   *\n   * @return The list of plugins\n   * @throws Exception\n   */\n  private Set<File> getCompilerPlugins() throws Exception {\n    Set<File> plugins = new TreeSet<>();\n    if (compilerPlugins != null) {\n      Set<File> ignoreClasspath = new TreeSet<>();\n      addCompilerToClasspath(ignoreClasspath);\n      addLibraryToClasspath(ignoreClasspath);\n      for (BasicArtifact artifact : compilerPlugins) {\n        getLog().info(\"compiler plugin: \" + artifact.toString());\n        // TODO - Ensure proper scala version for plugins\n        Set<File> pluginClassPath = new TreeSet<>();\n        addToClasspath(\n            artifact.groupId,\n            artifact.artifactId,\n            artifact.version,\n            artifact.classifier,\n            pluginClassPath,\n            false);\n        pluginClassPath.removeAll(ignoreClasspath);\n        plugins.addAll(pluginClassPath);\n      }\n    }\n    return plugins;\n  }\n}\n","lineNo":624}
{"Smelly Sample":"\n/*\n * Copyright 2011-2020 scala-maven-plugin project (https://davidb.github.io/scala-maven-plugin/)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage sbt_inc;\n\nimport static scala.jdk.CollectionConverters.IterableHasAsScala;\nimport static scala.jdk.FunctionWrappers.FromJavaConsumer;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.*;\nimport java.util.jar.Manifest;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.plugin.logging.Log;\nimport sbt.internal.inc.*;\nimport sbt.internal.inc.FileAnalysisStore;\nimport sbt.internal.inc.ScalaInstance;\nimport sbt.internal.inc.classpath.ClasspathUtil;\nimport sbt.io.AllPassFilter$;\nimport sbt.io.IO;\nimport sbt.util.Logger;\nimport scala.Option;\nimport scala.Tuple2;\nimport scala_maven.MavenArtifactResolver;\nimport scala_maven.VersionNumber;\nimport util.FileUtils;\nimport xsbti.PathBasedFile;\nimport xsbti.T2;\nimport xsbti.VirtualFile;\nimport xsbti.compile.*;\n\npublic class SbtIncrementalCompiler {\n\n  private static final String SBT_GROUP_ID = \"org.scala-sbt\";\n  private static final String JAVA_CLASS_VERSION = System.getProperty(\"java.class.version\");\n  private static final File DEFAULT_SECONDARY_CACHE_DIR =\n      Paths.get(System.getProperty(\"user.home\"), \".sbt\", \"1.0\", \"zinc\", \"org.scala-sbt\").toFile();\n\n  private final IncrementalCompiler compiler = ZincUtil.defaultIncrementalCompiler();\n  private final CompileOrder compileOrder;\n  private final Logger logger;\n  private final Compilers compilers;\n  private final Setup setup;\n  private final AnalysisStore analysisStore;\n  private final MavenArtifactResolver resolver;\n  private final File secondaryCacheDir;\n\n  public SbtIncrementalCompiler(\n      File libraryJar,\n      File reflectJar,\n      File compilerJar,\n      VersionNumber scalaVersion,\n      List<File> extraJars,\n      Path javaHome,\n      MavenArtifactResolver resolver,\n      File secondaryCacheDir,\n      Log mavenLogger,\n      File cacheFile,\n      CompileOrder compileOrder)\n      throws Exception {\n    this.compileOrder = compileOrder;\n    this.logger = new SbtLogger(mavenLogger);\n    mavenLogger.info(\"Using incremental compilation using \" + compileOrder + \" compile order\");\n    this.resolver = resolver;\n    this.secondaryCacheDir =\n        secondaryCacheDir != null ? secondaryCacheDir : DEFAULT_SECONDARY_CACHE_DIR;\n    this.secondaryCacheDir.mkdirs();\n\n    List<File> allJars = new ArrayList<>(extraJars);\n    allJars.add(libraryJar);\n    allJars.add(reflectJar);\n    allJars.add(compilerJar);\n\n    ScalaInstance scalaInstance =\n        new ScalaInstance(\n            scalaVersion.toString(), // version\n            new URLClassLoader(\n                new URL[] {\n                  libraryJar.toURI().toURL(),\n                  reflectJar.toURI().toURL(),\n                  compilerJar.toURI().toURL()\n                }), // loader\n            ClasspathUtil.rootLoader(), // loaderLibraryOnly\n            libraryJar, // libraryJar\n            compilerJar, // compilerJar\n            allJars.toArray(new File[] {}), // allJars\n            Option.apply(scalaVersion.toString()) // explicitActual\n            );\n\n    File compilerBridgeJar = getCompiledBridgeJar(scalaInstance, mavenLogger);\n\n    ScalaCompiler scalaCompiler =\n        new AnalyzingCompiler(\n            scalaInstance, // scalaInstance\n            ZincCompilerUtil.constantBridgeProvider(scalaInstance, compilerBridgeJar), // provider\n            ClasspathOptionsUtil.auto(), // classpathOptions\n            new FromJavaConsumer(noop -> {}), // onArgsHandler\n            Option.apply(null) // classLoaderCache\n            );\n\n    compilers =\n        ZincUtil.compilers(\n            scalaInstance, ClasspathOptionsUtil.boot(), Option.apply(javaHome), scalaCompiler);\n\n    PerClasspathEntryLookup lookup =\n        new PerClasspathEntryLookup() {\n          @Override\n          public Optional<CompileAnalysis> analysis(VirtualFile classpathEntry) {\n            Path path = ((PathBasedFile) classpathEntry).toPath();\n\n            String analysisStoreFileName = null;\n            if (Files.isDirectory(path)) {\n              if (path.getFileName().equals(\"classes\")) {\n                analysisStoreFileName = \"compile\";\n\n              } else if (path.getFileName().equals(\"test-classes\")) {\n                analysisStoreFileName = \"test-compile\";\n              }\n            }\n\n            if (analysisStoreFileName != null) {\n              File analysisStoreFile =\n                  path.getParent().resolve(\"analysis\").resolve(analysisStoreFileName).toFile();\n              if (analysisStoreFile.exists()) {\n                return AnalysisStore.getCachedStore(FileAnalysisStore.binary(analysisStoreFile))\n                    .get()\n                    .map(AnalysisContents::getAnalysis);\n              }\n            }\n            return Optional.empty();\n          }\n\n          @Override\n          public DefinesClass definesClass(VirtualFile classpathEntry) {\n            return Locate.definesClass(classpathEntry);\n          }\n        };\n\n    analysisStore = AnalysisStore.getCachedStore(FileAnalysisStore.binary(cacheFile));\n\n    setup =\n        Setup.of(\n            lookup, // lookup\n            false, // skip\n            cacheFile, // cacheFile\n            CompilerCache.fresh(), // cache\n            IncOptions.of(), // incOptions\n            new LoggedReporter(100, logger, pos -> pos), // reporter\n            Optional.empty(), // optionProgress\n            new T2[] {});\n  }\n\n  private PreviousResult previousResult() {\n    Optional<AnalysisContents> analysisContents = analysisStore.get();\n    if (analysisContents.isPresent()) {\n      AnalysisContents analysisContents0 = analysisContents.get();\n      CompileAnalysis previousAnalysis = analysisContents0.getAnalysis();\n      MiniSetup previousSetup = analysisContents0.getMiniSetup();\n      return PreviousResult.of(Optional.of(previousAnalysis), Optional.of(previousSetup));\n    } else {\n      return PreviousResult.of(Optional.empty(), Optional.empty());\n    }\n  }\n\n  public void compile(\n      Set<String> classpathElements,\n      List<Path> sources,\n      Path classesDirectory,\n      List<String> scalacOptions,\n      List<String> javacOptions) {\n    List<Path> fullClasspath = new ArrayList<>();\n    fullClasspath.add(classesDirectory);\n    for (String classpathElement : classpathElements) {\n      fullClasspath.add(Paths.get(classpathElement));\n    }\n\n    CompileOptions options =\n        CompileOptions.of(\n            fullClasspath.stream()\n                .map(PlainVirtualFile::new)\n                .toArray(VirtualFile[]::new), // classpath\n            sources.stream().map(PlainVirtualFile::new).toArray(VirtualFile[]::new), // sources\n            classesDirectory, //\n            scalacOptions.toArray(new String[] {}), // scalacOptions\n            javacOptions.toArray(new String[] {}), // javacOptions\n            100, // maxErrors\n            pos -> pos, // sourcePositionMappers\n            compileOrder, // order\n            Optional.empty(), // temporaryClassesDirectory\n            Optional.of(PlainVirtualFileConverter.converter()), // _converter\n            Optional.empty(), // _stamper\n            Optional.empty() // _earlyOutput\n            );\n\n    Inputs inputs = Inputs.of(compilers, options, setup, previousResult());\n\n    CompileResult newResult = compiler.compile(inputs, logger);\n    analysisStore.set(AnalysisContents.create(newResult.analysis(), newResult.setup()));\n  }\n\n  private String compilerBridgeArtifactId(String scalaVersion) {\n    if (scalaVersion.startsWith(\"2.10.\")) {\n      return \"compiler-bridge_2.10\";\n    } else if (scalaVersion.startsWith(\"2.11.\")) {\n      return \"compiler-bridge_2.11\";\n    } else if (scalaVersion.startsWith(\"2.12.\") || scalaVersion.equals(\"2.13.0-M1\")) {\n      return \"compiler-bridge_2.12\";\n    } else {\n      return \"compiler-bridge_2.13\";\n    }\n  }\n\n  private static List<Tuple2<File, String>> computeZipEntries(List<Path> paths, Path rootDir) {\n    int rootDirLength = rootDir.toString().length();\n    Stream<Tuple2<File, String>> stream =\n        paths.stream()\n            .map(\n                path -> {\n                  String zipPath =\n                      path.toString().substring(rootDirLength + 1).replace(File.separator, \"/\");\n                  if (Files.isDirectory(path)) {\n                    zipPath = zipPath + \"/\";\n                  }\n                  return new Tuple2(path.toFile(), zipPath);\n                });\n    return stream.collect(Collectors.toList());\n  }\n\n  private File getCompiledBridgeJar(ScalaInstance scalaInstance, Log mavenLogger) throws Exception {\n\n    // eg\n    // org.scala-sbt-compiler-bridge_2.12-1.2.4-bin_2.12.10__52.0-1.2.4_20181015T090407.jar\n    String bridgeArtifactId = compilerBridgeArtifactId(scalaInstance.actualVersion());\n\n    // this file is localed in compiler-interface\n    Properties properties = new Properties();\n    try (InputStream is =\n        getClass().getClassLoader().getResourceAsStream(\"incrementalcompiler.version.properties\")) {\n      properties.load(is);\n    }\n\n    String zincVersion = properties.getProperty(\"version\");\n    String timestamp = properties.getProperty(\"timestamp\");\n\n    String cacheFileName =\n        SBT_GROUP_ID\n            + '-'\n            + bridgeArtifactId\n            + '-'\n            + zincVersion\n            + \"-bin_\"\n            + scalaInstance.actualVersion()\n            + \"__\"\n            + JAVA_CLASS_VERSION\n            + '-'\n            + zincVersion\n            + '_'\n            + timestamp\n            + \".jar\";\n\n    File cachedCompiledBridgeJar = new File(secondaryCacheDir, cacheFileName);\n\n    if (mavenLogger.isInfoEnabled()) {\n      mavenLogger.info(\"Compiler bridge file: \" + cachedCompiledBridgeJar);\n    }\n\n    if (!cachedCompiledBridgeJar.exists()) {\n      mavenLogger.info(\"Compiler bridge file is not installed yet\");\n      // compile and install\n      RawCompiler rawCompiler = new RawCompiler(scalaInstance, ClasspathOptionsUtil.auto(), logger);\n\n      File bridgeSources =\n          resolver.getJar(SBT_GROUP_ID, bridgeArtifactId, zincVersion, \"sources\").getFile();\n\n      Set<Path> bridgeSourcesDependencies =\n          resolver.getJarAndDependencies(SBT_GROUP_ID, bridgeArtifactId, zincVersion, \"sources\")\n              .stream()\n              .filter(\n                  artifact ->\n                      artifact.getScope() != null && !artifact.getScope().equals(\"provided\"))\n              .map(Artifact::getFile)\n              .map(File::toPath)\n              .collect(Collectors.toSet());\n\n      bridgeSourcesDependencies.addAll(\n          Arrays.stream(scalaInstance.allJars())\n              .sequential()\n              .map(File::toPath)\n              .collect(Collectors.toList()));\n\n      Path sourcesDir = Files.createTempDirectory(\"scala-maven-plugin-compiler-bridge-sources\");\n      Path classesDir = Files.createTempDirectory(\"scala-maven-plugin-compiler-bridge-classes\");\n\n      IO.unzip(bridgeSources, sourcesDir.toFile(), AllPassFilter$.MODULE$, true);\n\n      List<Path> bridgeSourcesScalaFiles =\n          FileUtils.listDirectoryContent(\n              sourcesDir,\n              file ->\n                  Files.isRegularFile(file) && file.getFileName().toString().endsWith(\".scala\"));\n      List<Path> bridgeSourcesNonScalaFiles =\n          FileUtils.listDirectoryContent(\n              sourcesDir,\n              file ->\n                  Files.isRegularFile(file)\n                      && !file.getFileName().toString().endsWith(\".scala\")\n                      && !file.getFileName().toString().equals(\"MANIFEST.MF\"));\n\n      try {\n        rawCompiler.apply(\n            IterableHasAsScala(bridgeSourcesScalaFiles).asScala().toSeq(), // sources:Seq[File]\n            IterableHasAsScala(bridgeSourcesDependencies).asScala().toSeq(), // classpath:Seq[File],\n            classesDir, // outputDirectory:Path,\n            IterableHasAsScala(Collections.<String>emptyList())\n                .asScala()\n                .toSeq() // options:Seq[String]\n            );\n\n        Manifest manifest = new Manifest();\n        Path sourcesManifestFile = sourcesDir.resolve(\"META-INF\").resolve(\"MANIFEST.MF\");\n        try (InputStream is = new FileInputStream(sourcesManifestFile.toFile())) {\n          manifest.read(is);\n        }\n\n        List<Tuple2<File, String>> scalaCompiledClasses =\n            computeZipEntries(FileUtils.listDirectoryContent(classesDir, file -> true), classesDir);\n        List<Tuple2<File, String>> resources =\n            computeZipEntries(bridgeSourcesNonScalaFiles, sourcesDir);\n        List<Tuple2<File, String>> allZipEntries = new ArrayList<>();\n        allZipEntries.addAll(scalaCompiledClasses);\n        allZipEntries.addAll(resources);\n\n        IO.jar(IterableHasAsScala(allZipEntries).asScala(), cachedCompiledBridgeJar, manifest);\n\n        mavenLogger.info(\"Compiler bridge installed\");\n\n      } finally {\n        FileUtils.deleteDirectory(sourcesDir);\n        FileUtils.deleteDirectory(classesDir);\n      }\n    }\n\n    return cachedCompiledBridgeJar;\n  }\n}\n","Method after Refactoring":"\n/*\n * Copyright 2011-2020 scala-maven-plugin project (https://davidb.github.io/scala-maven-plugin/)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage sbt_inc;\n\nimport static scala.jdk.CollectionConverters.IterableHasAsScala;\nimport static scala.jdk.FunctionWrappers.FromJavaConsumer;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.*;\nimport java.util.jar.Manifest;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\nimport org.apache.commons.lang3.tuple.Pair;\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.plugin.logging.Log;\nimport sbt.internal.inc.*;\nimport sbt.internal.inc.FileAnalysisStore;\nimport sbt.internal.inc.ScalaInstance;\nimport sbt.io.AllPassFilter$;\nimport sbt.io.IO;\nimport sbt.util.Logger;\nimport scala.Option;\nimport scala_maven.MavenArtifactResolver;\nimport util.FileUtils;\nimport xsbti.PathBasedFile;\nimport xsbti.T2;\nimport xsbti.VirtualFile;\nimport xsbti.compile.*;\n\npublic class SbtIncrementalCompiler {\n\n  private static final String SBT_GROUP_ID = \"org.scala-sbt\";\n  private static final String SBT_GROUP_ID_SCALA3 = \"org.scala-lang\";\n  private static final String JAVA_CLASS_VERSION = System.getProperty(\"java.class.version\");\n  private static final File DEFAULT_SECONDARY_CACHE_DIR =\n      Paths.get(System.getProperty(\"user.home\"), \".sbt\", \"1.0\", \"zinc\", \"org.scala-sbt\").toFile();\n\n  private final IncrementalCompiler compiler = ZincUtil.defaultIncrementalCompiler();\n  private final CompileOrder compileOrder;\n  private final Logger logger;\n  private final Compilers compilers;\n  private final Setup setup;\n  private final AnalysisStore analysisStore;\n  private final MavenArtifactResolver resolver;\n  private final File secondaryCacheDir;\n\n  public SbtIncrementalCompiler(\n      Path javaHome,\n      MavenArtifactResolver resolver,\n      File secondaryCacheDir,\n      Log mavenLogger,\n      File cacheFile,\n      CompileOrder compileOrder,\n      ScalaInstance scalaInstance)\n      throws Exception {\n    this.compileOrder = compileOrder;\n    this.logger = new SbtLogger(mavenLogger);\n    mavenLogger.info(\"Using incremental compilation using \" + compileOrder + \" compile order\");\n    this.resolver = resolver;\n    this.secondaryCacheDir =\n        secondaryCacheDir != null ? secondaryCacheDir : DEFAULT_SECONDARY_CACHE_DIR;\n    this.secondaryCacheDir.mkdirs();\n\n    File compilerBridgeJar = getCompiledBridgeJar(scalaInstance, mavenLogger);\n\n    ScalaCompiler scalaCompiler =\n        new AnalyzingCompiler(\n            scalaInstance, // scalaInstance\n            ZincCompilerUtil.constantBridgeProvider(scalaInstance, compilerBridgeJar), // provider\n            ClasspathOptionsUtil.auto(), // classpathOptions\n            new FromJavaConsumer(noop -> {}), // onArgsHandler\n            Option.apply(null) // classLoaderCache\n            );\n\n    compilers =\n        ZincUtil.compilers(\n            scalaInstance, ClasspathOptionsUtil.boot(), Option.apply(javaHome), scalaCompiler);\n\n    PerClasspathEntryLookup lookup =\n        new PerClasspathEntryLookup() {\n          @Override\n          public Optional<CompileAnalysis> analysis(VirtualFile classpathEntry) {\n            Path path = ((PathBasedFile) classpathEntry).toPath();\n\n            String analysisStoreFileName = null;\n            if (Files.isDirectory(path)) {\n              if (path.getFileName().equals(\"classes\")) {\n                analysisStoreFileName = \"compile\";\n\n              } else if (path.getFileName().equals(\"test-classes\")) {\n                analysisStoreFileName = \"test-compile\";\n              }\n            }\n\n            if (analysisStoreFileName != null) {\n              File analysisStoreFile =\n                  path.getParent().resolve(\"analysis\").resolve(analysisStoreFileName).toFile();\n              if (analysisStoreFile.exists()) {\n                return AnalysisStore.getCachedStore(FileAnalysisStore.binary(analysisStoreFile))\n                    .get()\n                    .map(AnalysisContents::getAnalysis);\n              }\n            }\n            return Optional.empty();\n          }\n\n          @Override\n          public DefinesClass definesClass(VirtualFile classpathEntry) {\n            return Locate.definesClass(classpathEntry);\n          }\n        };\n\n    analysisStore = AnalysisStore.getCachedStore(FileAnalysisStore.binary(cacheFile));\n\n    setup =\n        Setup.of(\n            lookup, // lookup\n            false, // skip\n            cacheFile, // cacheFile\n            CompilerCache.fresh(), // cache\n            IncOptions.of(), // incOptions\n            new LoggedReporter(100, logger, pos -> pos), // reporter\n            Optional.empty(), // optionProgress\n            new T2[] {});\n  }\n\n  private PreviousResult previousResult() {\n    Optional<AnalysisContents> analysisContents = analysisStore.get();\n    if (analysisContents.isPresent()) {\n      AnalysisContents analysisContents0 = analysisContents.get();\n      CompileAnalysis previousAnalysis = analysisContents0.getAnalysis();\n      MiniSetup previousSetup = analysisContents0.getMiniSetup();\n      return PreviousResult.of(Optional.of(previousAnalysis), Optional.of(previousSetup));\n    } else {\n      return PreviousResult.of(Optional.empty(), Optional.empty());\n    }\n  }\n\n  public void compile(\n      Set<String> classpathElements,\n      List<Path> sources,\n      Path classesDirectory,\n      List<String> scalacOptions,\n      List<String> javacOptions) {\n    List<Path> fullClasspath = new ArrayList<>();\n    fullClasspath.add(classesDirectory);\n    for (String classpathElement : classpathElements) {\n      fullClasspath.add(Paths.get(classpathElement));\n    }\n\n    CompileOptions options =\n        CompileOptions.of(\n            fullClasspath.stream()\n                .map(PlainVirtualFile::new)\n                .toArray(VirtualFile[]::new), // classpath\n            sources.stream().map(PlainVirtualFile::new).toArray(VirtualFile[]::new), // sources\n            classesDirectory, //\n            scalacOptions.toArray(new String[] {}), // scalacOptions\n            javacOptions.toArray(new String[] {}), // javacOptions\n            100, // maxErrors\n            pos -> pos, // sourcePositionMappers\n            compileOrder, // order\n            Optional.empty(), // temporaryClassesDirectory\n            Optional.of(PlainVirtualFileConverter.converter()), // _converter\n            Optional.empty(), // _stamper\n            Optional.empty() // _earlyOutput\n            );\n\n    Inputs inputs = Inputs.of(compilers, options, setup, previousResult());\n\n    CompileResult newResult = compiler.compile(inputs, logger);\n    analysisStore.set(AnalysisContents.create(newResult.analysis(), newResult.setup()));\n  }\n\n  private String compilerBridgeArtifactId(String scalaVersion) {\n    if (scalaVersion.startsWith(\"2.10.\")) {\n      return \"compiler-bridge_2.10\";\n    } else if (scalaVersion.startsWith(\"2.11.\")) {\n      return \"compiler-bridge_2.11\";\n    } else if (scalaVersion.startsWith(\"2.12.\") || scalaVersion.equals(\"2.13.0-M1\")) {\n      return \"compiler-bridge_2.12\";\n    } else if (scalaVersion.startsWith(\"2.13.\")) {\n      return \"compiler-bridge_2.13\";\n    } else {\n      return \"scala3-sbt-bridge\";\n    }\n  }\n\n  private static List<Pair<File, String>> computeZipEntries(List<Path> paths, Path rootDir) {\n    int rootDirLength = rootDir.toString().length();\n    Stream<Pair<File, String>> stream =\n        paths.stream()\n            .map(\n                path -> {\n                  String zipPath =\n                      path.toString().substring(rootDirLength + 1).replace(File.separator, \"/\");\n                  if (Files.isDirectory(path)) {\n                    zipPath = zipPath + \"/\";\n                  }\n                  return Pair.of(path.toFile(), zipPath);\n                });\n    return stream.collect(Collectors.toList());\n  }\n\n  private File getCompiledBridgeJar(ScalaInstance scalaInstance, Log mavenLogger) throws Exception {\n\n    // eg\n    // org.scala-sbt-compiler-bridge_2.12-1.2.4-bin_2.12.10__52.0-1.2.4_20181015T090407.jar\n    String bridgeArtifactId = compilerBridgeArtifactId(scalaInstance.actualVersion());\n\n    Boolean isScala3 = scalaInstance.actualVersion().startsWith(\"3\");\n\n    // this file is localed in compiler-interface\n    Properties properties = new Properties();\n    try (InputStream is =\n        getClass().getClassLoader().getResourceAsStream(\"incrementalcompiler.version.properties\")) {\n      properties.load(is);\n    }\n\n    String zincVersion = properties.getProperty(\"version\");\n    String timestamp = properties.getProperty(\"timestamp\");\n\n    String groupId = isScala3 ? SBT_GROUP_ID_SCALA3 : SBT_GROUP_ID;\n    String version = isScala3 ? scalaInstance.actualVersion() : zincVersion;\n\n    if (isScala3) {\n      return resolver.getJar(groupId, bridgeArtifactId, version, \"\").getFile();\n    }\n\n    String cacheFileName =\n        groupId\n            + '-'\n            + bridgeArtifactId\n            + '-'\n            + version\n            + \"-bin_\"\n            + scalaInstance.actualVersion()\n            + \"__\"\n            + JAVA_CLASS_VERSION\n            + '-'\n            + version\n            + '_'\n            + timestamp\n            + \".jar\";\n\n    File cachedCompiledBridgeJar = new File(secondaryCacheDir, cacheFileName);\n\n    if (mavenLogger.isInfoEnabled()) {\n      mavenLogger.info(\"Compiler bridge file: \" + cachedCompiledBridgeJar);\n    }\n\n    if (!cachedCompiledBridgeJar.exists()) {\n      mavenLogger.info(\"Compiler bridge file is not installed yet\");\n      // compile and install\n      RawCompiler rawCompiler = new RawCompiler(scalaInstance, ClasspathOptionsUtil.auto(), logger);\n\n      File bridgeSources = resolver.getJar(groupId, bridgeArtifactId, version, \"sources\").getFile();\n\n      Set<Path> bridgeSourcesDependencies =\n          resolver.getJarAndDependencies(groupId, bridgeArtifactId, version, \"sources\").stream()\n              .filter(\n                  artifact ->\n                      artifact.getScope() != null && !artifact.getScope().equals(\"provided\"))\n              .map(Artifact::getFile)\n              .map(File::toPath)\n              .collect(Collectors.toSet());\n\n      bridgeSourcesDependencies.addAll(\n          Arrays.stream(scalaInstance.allJars())\n              .sequential()\n              .map(File::toPath)\n              .collect(Collectors.toList()));\n\n      Path sourcesDir = Files.createTempDirectory(\"scala-maven-plugin-compiler-bridge-sources\");\n      Path classesDir = Files.createTempDirectory(\"scala-maven-plugin-compiler-bridge-classes\");\n\n      IO.unzip(bridgeSources, sourcesDir.toFile(), AllPassFilter$.MODULE$, true);\n\n      List<Path> bridgeSourcesScalaFiles =\n          FileUtils.listDirectoryContent(\n              sourcesDir,\n              file ->\n                  Files.isRegularFile(file) && file.getFileName().toString().endsWith(\".scala\"));\n      List<Path> bridgeSourcesNonScalaFiles =\n          FileUtils.listDirectoryContent(\n              sourcesDir,\n              file ->\n                  Files.isRegularFile(file)\n                      && !file.getFileName().toString().endsWith(\".scala\")\n                      && !file.getFileName().toString().equals(\"MANIFEST.MF\"));\n\n      try {\n        rawCompiler.apply(\n            IterableHasAsScala(bridgeSourcesScalaFiles).asScala().toSeq(), // sources:Seq[File]\n            IterableHasAsScala(bridgeSourcesDependencies).asScala().toSeq(), // classpath:Seq[File],\n            classesDir, // outputDirectory:Path,\n            IterableHasAsScala(Collections.<String>emptyList())\n                .asScala()\n                .toSeq() // options:Seq[String]\n            );\n\n        Manifest manifest = new Manifest();\n        Path sourcesManifestFile = sourcesDir.resolve(\"META-INF\").resolve(\"MANIFEST.MF\");\n        try (InputStream is = new FileInputStream(sourcesManifestFile.toFile())) {\n          manifest.read(is);\n        }\n\n        List<Pair<File, String>> scalaCompiledClasses =\n            computeZipEntries(FileUtils.listDirectoryContent(classesDir, file -> true), classesDir);\n        List<Pair<File, String>> resources =\n            computeZipEntries(bridgeSourcesNonScalaFiles, sourcesDir);\n        List<Pair<File, String>> allZipEntries = new ArrayList<>();\n        allZipEntries.addAll(scalaCompiledClasses);\n        allZipEntries.addAll(resources);\n\n        IO.jar(\n            IterableHasAsScala(\n                    allZipEntries.stream()\n                        .map(x -> scala.Tuple2.apply(x.getLeft(), x.getRight()))\n                        .collect(Collectors.toList()))\n                .asScala(),\n            cachedCompiledBridgeJar,\n            manifest);\n\n        mavenLogger.info(\"Compiler bridge installed\");\n\n      } finally {\n        FileUtils.deleteDirectory(sourcesDir);\n        FileUtils.deleteDirectory(classesDir);\n      }\n    }\n\n    return cachedCompiledBridgeJar;\n  }\n}\n","lineNo":242}
{"Smelly Sample":"\n/*\n * Copyright 2011-2020 scala-maven-plugin project (https://davidb.github.io/scala-maven-plugin/)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage sbt_inc;\n\nimport static scala.jdk.CollectionConverters.IterableHasAsScala;\nimport static scala.jdk.FunctionWrappers.FromJavaConsumer;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.*;\nimport java.util.jar.Manifest;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.plugin.logging.Log;\nimport sbt.internal.inc.*;\nimport sbt.internal.inc.FileAnalysisStore;\nimport sbt.internal.inc.ScalaInstance;\nimport sbt.internal.inc.classpath.ClasspathUtil;\nimport sbt.io.AllPassFilter$;\nimport sbt.io.IO;\nimport sbt.util.Logger;\nimport scala.Option;\nimport scala.Tuple2;\nimport scala_maven.MavenArtifactResolver;\nimport scala_maven.VersionNumber;\nimport util.FileUtils;\nimport xsbti.PathBasedFile;\nimport xsbti.T2;\nimport xsbti.VirtualFile;\nimport xsbti.compile.*;\n\npublic class SbtIncrementalCompiler {\n\n  private static final String SBT_GROUP_ID = \"org.scala-sbt\";\n  private static final String JAVA_CLASS_VERSION = System.getProperty(\"java.class.version\");\n  private static final File DEFAULT_SECONDARY_CACHE_DIR =\n      Paths.get(System.getProperty(\"user.home\"), \".sbt\", \"1.0\", \"zinc\", \"org.scala-sbt\").toFile();\n\n  private final IncrementalCompiler compiler = ZincUtil.defaultIncrementalCompiler();\n  private final CompileOrder compileOrder;\n  private final Logger logger;\n  private final Compilers compilers;\n  private final Setup setup;\n  private final AnalysisStore analysisStore;\n  private final MavenArtifactResolver resolver;\n  private final File secondaryCacheDir;\n\n  public SbtIncrementalCompiler(\n      File libraryJar,\n      File reflectJar,\n      File compilerJar,\n      VersionNumber scalaVersion,\n      List<File> extraJars,\n      Path javaHome,\n      MavenArtifactResolver resolver,\n      File secondaryCacheDir,\n      Log mavenLogger,\n      File cacheFile,\n      CompileOrder compileOrder)\n      throws Exception {\n    this.compileOrder = compileOrder;\n    this.logger = new SbtLogger(mavenLogger);\n    mavenLogger.info(\"Using incremental compilation using \" + compileOrder + \" compile order\");\n    this.resolver = resolver;\n    this.secondaryCacheDir =\n        secondaryCacheDir != null ? secondaryCacheDir : DEFAULT_SECONDARY_CACHE_DIR;\n    this.secondaryCacheDir.mkdirs();\n\n    List<File> allJars = new ArrayList<>(extraJars);\n    allJars.add(libraryJar);\n    allJars.add(reflectJar);\n    allJars.add(compilerJar);\n\n    ScalaInstance scalaInstance =\n        new ScalaInstance(\n            scalaVersion.toString(), // version\n            new URLClassLoader(\n                new URL[] {\n                  libraryJar.toURI().toURL(),\n                  reflectJar.toURI().toURL(),\n                  compilerJar.toURI().toURL()\n                }), // loader\n            ClasspathUtil.rootLoader(), // loaderLibraryOnly\n            libraryJar, // libraryJar\n            compilerJar, // compilerJar\n            allJars.toArray(new File[] {}), // allJars\n            Option.apply(scalaVersion.toString()) // explicitActual\n            );\n\n    File compilerBridgeJar = getCompiledBridgeJar(scalaInstance, mavenLogger);\n\n    ScalaCompiler scalaCompiler =\n        new AnalyzingCompiler(\n            scalaInstance, // scalaInstance\n            ZincCompilerUtil.constantBridgeProvider(scalaInstance, compilerBridgeJar), // provider\n            ClasspathOptionsUtil.auto(), // classpathOptions\n            new FromJavaConsumer(noop -> {}), // onArgsHandler\n            Option.apply(null) // classLoaderCache\n            );\n\n    compilers =\n        ZincUtil.compilers(\n            scalaInstance, ClasspathOptionsUtil.boot(), Option.apply(javaHome), scalaCompiler);\n\n    PerClasspathEntryLookup lookup =\n        new PerClasspathEntryLookup() {\n          @Override\n          public Optional<CompileAnalysis> analysis(VirtualFile classpathEntry) {\n            Path path = ((PathBasedFile) classpathEntry).toPath();\n\n            String analysisStoreFileName = null;\n            if (Files.isDirectory(path)) {\n              if (path.getFileName().equals(\"classes\")) {\n                analysisStoreFileName = \"compile\";\n\n              } else if (path.getFileName().equals(\"test-classes\")) {\n                analysisStoreFileName = \"test-compile\";\n              }\n            }\n\n            if (analysisStoreFileName != null) {\n              File analysisStoreFile =\n                  path.getParent().resolve(\"analysis\").resolve(analysisStoreFileName).toFile();\n              if (analysisStoreFile.exists()) {\n                return AnalysisStore.getCachedStore(FileAnalysisStore.binary(analysisStoreFile))\n                    .get()\n                    .map(AnalysisContents::getAnalysis);\n              }\n            }\n            return Optional.empty();\n          }\n\n          @Override\n          public DefinesClass definesClass(VirtualFile classpathEntry) {\n            return Locate.definesClass(classpathEntry);\n          }\n        };\n\n    analysisStore = AnalysisStore.getCachedStore(FileAnalysisStore.binary(cacheFile));\n\n    setup =\n        Setup.of(\n            lookup, // lookup\n            false, // skip\n            cacheFile, // cacheFile\n            CompilerCache.fresh(), // cache\n            IncOptions.of(), // incOptions\n            new LoggedReporter(100, logger, pos -> pos), // reporter\n            Optional.empty(), // optionProgress\n            new T2[] {});\n  }\n\n  private PreviousResult previousResult() {\n    Optional<AnalysisContents> analysisContents = analysisStore.get();\n    if (analysisContents.isPresent()) {\n      AnalysisContents analysisContents0 = analysisContents.get();\n      CompileAnalysis previousAnalysis = analysisContents0.getAnalysis();\n      MiniSetup previousSetup = analysisContents0.getMiniSetup();\n      return PreviousResult.of(Optional.of(previousAnalysis), Optional.of(previousSetup));\n    } else {\n      return PreviousResult.of(Optional.empty(), Optional.empty());\n    }\n  }\n\n  public void compile(\n      Set<String> classpathElements,\n      List<Path> sources,\n      Path classesDirectory,\n      List<String> scalacOptions,\n      List<String> javacOptions) {\n    List<Path> fullClasspath = new ArrayList<>();\n    fullClasspath.add(classesDirectory);\n    for (String classpathElement : classpathElements) {\n      fullClasspath.add(Paths.get(classpathElement));\n    }\n\n    CompileOptions options =\n        CompileOptions.of(\n            fullClasspath.stream()\n                .map(PlainVirtualFile::new)\n                .toArray(VirtualFile[]::new), // classpath\n            sources.stream().map(PlainVirtualFile::new).toArray(VirtualFile[]::new), // sources\n            classesDirectory, //\n            scalacOptions.toArray(new String[] {}), // scalacOptions\n            javacOptions.toArray(new String[] {}), // javacOptions\n            100, // maxErrors\n            pos -> pos, // sourcePositionMappers\n            compileOrder, // order\n            Optional.empty(), // temporaryClassesDirectory\n            Optional.of(PlainVirtualFileConverter.converter()), // _converter\n            Optional.empty(), // _stamper\n            Optional.empty() // _earlyOutput\n            );\n\n    Inputs inputs = Inputs.of(compilers, options, setup, previousResult());\n\n    CompileResult newResult = compiler.compile(inputs, logger);\n    analysisStore.set(AnalysisContents.create(newResult.analysis(), newResult.setup()));\n  }\n\n  private String compilerBridgeArtifactId(String scalaVersion) {\n    if (scalaVersion.startsWith(\"2.10.\")) {\n      return \"compiler-bridge_2.10\";\n    } else if (scalaVersion.startsWith(\"2.11.\")) {\n      return \"compiler-bridge_2.11\";\n    } else if (scalaVersion.startsWith(\"2.12.\") || scalaVersion.equals(\"2.13.0-M1\")) {\n      return \"compiler-bridge_2.12\";\n    } else {\n      return \"compiler-bridge_2.13\";\n    }\n  }\n\n  private static List<Tuple2<File, String>> computeZipEntries(List<Path> paths, Path rootDir) {\n    int rootDirLength = rootDir.toString().length();\n    Stream<Tuple2<File, String>> stream =\n        paths.stream()\n            .map(\n                path -> {\n                  String zipPath =\n                      path.toString().substring(rootDirLength + 1).replace(File.separator, \"/\");\n                  if (Files.isDirectory(path)) {\n                    zipPath = zipPath + \"/\";\n                  }\n                  return new Tuple2(path.toFile(), zipPath);\n                });\n    return stream.collect(Collectors.toList());\n  }\n\n  private File getCompiledBridgeJar(ScalaInstance scalaInstance, Log mavenLogger) throws Exception {\n\n    // eg\n    // org.scala-sbt-compiler-bridge_2.12-1.2.4-bin_2.12.10__52.0-1.2.4_20181015T090407.jar\n    String bridgeArtifactId = compilerBridgeArtifactId(scalaInstance.actualVersion());\n\n    // this file is localed in compiler-interface\n    Properties properties = new Properties();\n    try (InputStream is =\n        getClass().getClassLoader().getResourceAsStream(\"incrementalcompiler.version.properties\")) {\n      properties.load(is);\n    }\n\n    String zincVersion = properties.getProperty(\"version\");\n    String timestamp = properties.getProperty(\"timestamp\");\n\n    String cacheFileName =\n        SBT_GROUP_ID\n            + '-'\n            + bridgeArtifactId\n            + '-'\n            + zincVersion\n            + \"-bin_\"\n            + scalaInstance.actualVersion()\n            + \"__\"\n            + JAVA_CLASS_VERSION\n            + '-'\n            + zincVersion\n            + '_'\n            + timestamp\n            + \".jar\";\n\n    File cachedCompiledBridgeJar = new File(secondaryCacheDir, cacheFileName);\n\n    if (mavenLogger.isInfoEnabled()) {\n      mavenLogger.info(\"Compiler bridge file: \" + cachedCompiledBridgeJar);\n    }\n\n    if (!cachedCompiledBridgeJar.exists()) {\n      mavenLogger.info(\"Compiler bridge file is not installed yet\");\n      // compile and install\n      RawCompiler rawCompiler = new RawCompiler(scalaInstance, ClasspathOptionsUtil.auto(), logger);\n\n      File bridgeSources =\n          resolver.getJar(SBT_GROUP_ID, bridgeArtifactId, zincVersion, \"sources\").getFile();\n\n      Set<Path> bridgeSourcesDependencies =\n          resolver.getJarAndDependencies(SBT_GROUP_ID, bridgeArtifactId, zincVersion, \"sources\")\n              .stream()\n              .filter(\n                  artifact ->\n                      artifact.getScope() != null && !artifact.getScope().equals(\"provided\"))\n              .map(Artifact::getFile)\n              .map(File::toPath)\n              .collect(Collectors.toSet());\n\n      bridgeSourcesDependencies.addAll(\n          Arrays.stream(scalaInstance.allJars())\n              .sequential()\n              .map(File::toPath)\n              .collect(Collectors.toList()));\n\n      Path sourcesDir = Files.createTempDirectory(\"scala-maven-plugin-compiler-bridge-sources\");\n      Path classesDir = Files.createTempDirectory(\"scala-maven-plugin-compiler-bridge-classes\");\n\n      IO.unzip(bridgeSources, sourcesDir.toFile(), AllPassFilter$.MODULE$, true);\n\n      List<Path> bridgeSourcesScalaFiles =\n          FileUtils.listDirectoryContent(\n              sourcesDir,\n              file ->\n                  Files.isRegularFile(file) && file.getFileName().toString().endsWith(\".scala\"));\n      List<Path> bridgeSourcesNonScalaFiles =\n          FileUtils.listDirectoryContent(\n              sourcesDir,\n              file ->\n                  Files.isRegularFile(file)\n                      && !file.getFileName().toString().endsWith(\".scala\")\n                      && !file.getFileName().toString().equals(\"MANIFEST.MF\"));\n\n      try {\n        rawCompiler.apply(\n            IterableHasAsScala(bridgeSourcesScalaFiles).asScala().toSeq(), // sources:Seq[File]\n            IterableHasAsScala(bridgeSourcesDependencies).asScala().toSeq(), // classpath:Seq[File],\n            classesDir, // outputDirectory:Path,\n            IterableHasAsScala(Collections.<String>emptyList())\n                .asScala()\n                .toSeq() // options:Seq[String]\n            );\n\n        Manifest manifest = new Manifest();\n        Path sourcesManifestFile = sourcesDir.resolve(\"META-INF\").resolve(\"MANIFEST.MF\");\n        try (InputStream is = new FileInputStream(sourcesManifestFile.toFile())) {\n          manifest.read(is);\n        }\n\n        List<Tuple2<File, String>> scalaCompiledClasses =\n            computeZipEntries(FileUtils.listDirectoryContent(classesDir, file -> true), classesDir);\n        List<Tuple2<File, String>> resources =\n            computeZipEntries(bridgeSourcesNonScalaFiles, sourcesDir);\n        List<Tuple2<File, String>> allZipEntries = new ArrayList<>();\n        allZipEntries.addAll(scalaCompiledClasses);\n        allZipEntries.addAll(resources);\n\n        IO.jar(IterableHasAsScala(allZipEntries).asScala(), cachedCompiledBridgeJar, manifest);\n\n        mavenLogger.info(\"Compiler bridge installed\");\n\n      } finally {\n        FileUtils.deleteDirectory(sourcesDir);\n        FileUtils.deleteDirectory(classesDir);\n      }\n    }\n\n    return cachedCompiledBridgeJar;\n  }\n}\n","Method after Refactoring":"\n/*\n * Copyright 2011-2020 scala-maven-plugin project (https://davidb.github.io/scala-maven-plugin/)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage sbt_inc;\n\nimport static scala.jdk.CollectionConverters.IterableHasAsScala;\nimport static scala.jdk.FunctionWrappers.FromJavaConsumer;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.*;\nimport java.util.jar.Manifest;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\nimport org.apache.commons.lang3.tuple.Pair;\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.plugin.logging.Log;\nimport sbt.internal.inc.*;\nimport sbt.internal.inc.FileAnalysisStore;\nimport sbt.internal.inc.ScalaInstance;\nimport sbt.io.AllPassFilter$;\nimport sbt.io.IO;\nimport sbt.util.Logger;\nimport scala.Option;\nimport scala_maven.MavenArtifactResolver;\nimport util.FileUtils;\nimport xsbti.PathBasedFile;\nimport xsbti.T2;\nimport xsbti.VirtualFile;\nimport xsbti.compile.*;\n\npublic class SbtIncrementalCompiler {\n\n  private static final String SBT_GROUP_ID = \"org.scala-sbt\";\n  private static final String SBT_GROUP_ID_SCALA3 = \"org.scala-lang\";\n  private static final String JAVA_CLASS_VERSION = System.getProperty(\"java.class.version\");\n  private static final File DEFAULT_SECONDARY_CACHE_DIR =\n      Paths.get(System.getProperty(\"user.home\"), \".sbt\", \"1.0\", \"zinc\", \"org.scala-sbt\").toFile();\n\n  private final IncrementalCompiler compiler = ZincUtil.defaultIncrementalCompiler();\n  private final CompileOrder compileOrder;\n  private final Logger logger;\n  private final Compilers compilers;\n  private final Setup setup;\n  private final AnalysisStore analysisStore;\n  private final MavenArtifactResolver resolver;\n  private final File secondaryCacheDir;\n\n  public SbtIncrementalCompiler(\n      Path javaHome,\n      MavenArtifactResolver resolver,\n      File secondaryCacheDir,\n      Log mavenLogger,\n      File cacheFile,\n      CompileOrder compileOrder,\n      ScalaInstance scalaInstance)\n      throws Exception {\n    this.compileOrder = compileOrder;\n    this.logger = new SbtLogger(mavenLogger);\n    mavenLogger.info(\"Using incremental compilation using \" + compileOrder + \" compile order\");\n    this.resolver = resolver;\n    this.secondaryCacheDir =\n        secondaryCacheDir != null ? secondaryCacheDir : DEFAULT_SECONDARY_CACHE_DIR;\n    this.secondaryCacheDir.mkdirs();\n\n    File compilerBridgeJar = getCompiledBridgeJar(scalaInstance, mavenLogger);\n\n    ScalaCompiler scalaCompiler =\n        new AnalyzingCompiler(\n            scalaInstance, // scalaInstance\n            ZincCompilerUtil.constantBridgeProvider(scalaInstance, compilerBridgeJar), // provider\n            ClasspathOptionsUtil.auto(), // classpathOptions\n            new FromJavaConsumer(noop -> {}), // onArgsHandler\n            Option.apply(null) // classLoaderCache\n            );\n\n    compilers =\n        ZincUtil.compilers(\n            scalaInstance, ClasspathOptionsUtil.boot(), Option.apply(javaHome), scalaCompiler);\n\n    PerClasspathEntryLookup lookup =\n        new PerClasspathEntryLookup() {\n          @Override\n          public Optional<CompileAnalysis> analysis(VirtualFile classpathEntry) {\n            Path path = ((PathBasedFile) classpathEntry).toPath();\n\n            String analysisStoreFileName = null;\n            if (Files.isDirectory(path)) {\n              if (path.getFileName().equals(\"classes\")) {\n                analysisStoreFileName = \"compile\";\n\n              } else if (path.getFileName().equals(\"test-classes\")) {\n                analysisStoreFileName = \"test-compile\";\n              }\n            }\n\n            if (analysisStoreFileName != null) {\n              File analysisStoreFile =\n                  path.getParent().resolve(\"analysis\").resolve(analysisStoreFileName).toFile();\n              if (analysisStoreFile.exists()) {\n                return AnalysisStore.getCachedStore(FileAnalysisStore.binary(analysisStoreFile))\n                    .get()\n                    .map(AnalysisContents::getAnalysis);\n              }\n            }\n            return Optional.empty();\n          }\n\n          @Override\n          public DefinesClass definesClass(VirtualFile classpathEntry) {\n            return Locate.definesClass(classpathEntry);\n          }\n        };\n\n    analysisStore = AnalysisStore.getCachedStore(FileAnalysisStore.binary(cacheFile));\n\n    setup =\n        Setup.of(\n            lookup, // lookup\n            false, // skip\n            cacheFile, // cacheFile\n            CompilerCache.fresh(), // cache\n            IncOptions.of(), // incOptions\n            new LoggedReporter(100, logger, pos -> pos), // reporter\n            Optional.empty(), // optionProgress\n            new T2[] {});\n  }\n\n  private PreviousResult previousResult() {\n    Optional<AnalysisContents> analysisContents = analysisStore.get();\n    if (analysisContents.isPresent()) {\n      AnalysisContents analysisContents0 = analysisContents.get();\n      CompileAnalysis previousAnalysis = analysisContents0.getAnalysis();\n      MiniSetup previousSetup = analysisContents0.getMiniSetup();\n      return PreviousResult.of(Optional.of(previousAnalysis), Optional.of(previousSetup));\n    } else {\n      return PreviousResult.of(Optional.empty(), Optional.empty());\n    }\n  }\n\n  public void compile(\n      Set<String> classpathElements,\n      List<Path> sources,\n      Path classesDirectory,\n      List<String> scalacOptions,\n      List<String> javacOptions) {\n    List<Path> fullClasspath = new ArrayList<>();\n    fullClasspath.add(classesDirectory);\n    for (String classpathElement : classpathElements) {\n      fullClasspath.add(Paths.get(classpathElement));\n    }\n\n    CompileOptions options =\n        CompileOptions.of(\n            fullClasspath.stream()\n                .map(PlainVirtualFile::new)\n                .toArray(VirtualFile[]::new), // classpath\n            sources.stream().map(PlainVirtualFile::new).toArray(VirtualFile[]::new), // sources\n            classesDirectory, //\n            scalacOptions.toArray(new String[] {}), // scalacOptions\n            javacOptions.toArray(new String[] {}), // javacOptions\n            100, // maxErrors\n            pos -> pos, // sourcePositionMappers\n            compileOrder, // order\n            Optional.empty(), // temporaryClassesDirectory\n            Optional.of(PlainVirtualFileConverter.converter()), // _converter\n            Optional.empty(), // _stamper\n            Optional.empty() // _earlyOutput\n            );\n\n    Inputs inputs = Inputs.of(compilers, options, setup, previousResult());\n\n    CompileResult newResult = compiler.compile(inputs, logger);\n    analysisStore.set(AnalysisContents.create(newResult.analysis(), newResult.setup()));\n  }\n\n  private String compilerBridgeArtifactId(String scalaVersion) {\n    if (scalaVersion.startsWith(\"2.10.\")) {\n      return \"compiler-bridge_2.10\";\n    } else if (scalaVersion.startsWith(\"2.11.\")) {\n      return \"compiler-bridge_2.11\";\n    } else if (scalaVersion.startsWith(\"2.12.\") || scalaVersion.equals(\"2.13.0-M1\")) {\n      return \"compiler-bridge_2.12\";\n    } else if (scalaVersion.startsWith(\"2.13.\")) {\n      return \"compiler-bridge_2.13\";\n    } else {\n      return \"scala3-sbt-bridge\";\n    }\n  }\n\n  private static List<Pair<File, String>> computeZipEntries(List<Path> paths, Path rootDir) {\n    int rootDirLength = rootDir.toString().length();\n    Stream<Pair<File, String>> stream =\n        paths.stream()\n            .map(\n                path -> {\n                  String zipPath =\n                      path.toString().substring(rootDirLength + 1).replace(File.separator, \"/\");\n                  if (Files.isDirectory(path)) {\n                    zipPath = zipPath + \"/\";\n                  }\n                  return Pair.of(path.toFile(), zipPath);\n                });\n    return stream.collect(Collectors.toList());\n  }\n\n  private File getCompiledBridgeJar(ScalaInstance scalaInstance, Log mavenLogger) throws Exception {\n\n    // eg\n    // org.scala-sbt-compiler-bridge_2.12-1.2.4-bin_2.12.10__52.0-1.2.4_20181015T090407.jar\n    String bridgeArtifactId = compilerBridgeArtifactId(scalaInstance.actualVersion());\n\n    Boolean isScala3 = scalaInstance.actualVersion().startsWith(\"3\");\n\n    // this file is localed in compiler-interface\n    Properties properties = new Properties();\n    try (InputStream is =\n        getClass().getClassLoader().getResourceAsStream(\"incrementalcompiler.version.properties\")) {\n      properties.load(is);\n    }\n\n    String zincVersion = properties.getProperty(\"version\");\n    String timestamp = properties.getProperty(\"timestamp\");\n\n    String groupId = isScala3 ? SBT_GROUP_ID_SCALA3 : SBT_GROUP_ID;\n    String version = isScala3 ? scalaInstance.actualVersion() : zincVersion;\n\n    if (isScala3) {\n      return resolver.getJar(groupId, bridgeArtifactId, version, \"\").getFile();\n    }\n\n    String cacheFileName =\n        groupId\n            + '-'\n            + bridgeArtifactId\n            + '-'\n            + version\n            + \"-bin_\"\n            + scalaInstance.actualVersion()\n            + \"__\"\n            + JAVA_CLASS_VERSION\n            + '-'\n            + version\n            + '_'\n            + timestamp\n            + \".jar\";\n\n    File cachedCompiledBridgeJar = new File(secondaryCacheDir, cacheFileName);\n\n    if (mavenLogger.isInfoEnabled()) {\n      mavenLogger.info(\"Compiler bridge file: \" + cachedCompiledBridgeJar);\n    }\n\n    if (!cachedCompiledBridgeJar.exists()) {\n      mavenLogger.info(\"Compiler bridge file is not installed yet\");\n      // compile and install\n      RawCompiler rawCompiler = new RawCompiler(scalaInstance, ClasspathOptionsUtil.auto(), logger);\n\n      File bridgeSources = resolver.getJar(groupId, bridgeArtifactId, version, \"sources\").getFile();\n\n      Set<Path> bridgeSourcesDependencies =\n          resolver.getJarAndDependencies(groupId, bridgeArtifactId, version, \"sources\").stream()\n              .filter(\n                  artifact ->\n                      artifact.getScope() != null && !artifact.getScope().equals(\"provided\"))\n              .map(Artifact::getFile)\n              .map(File::toPath)\n              .collect(Collectors.toSet());\n\n      bridgeSourcesDependencies.addAll(\n          Arrays.stream(scalaInstance.allJars())\n              .sequential()\n              .map(File::toPath)\n              .collect(Collectors.toList()));\n\n      Path sourcesDir = Files.createTempDirectory(\"scala-maven-plugin-compiler-bridge-sources\");\n      Path classesDir = Files.createTempDirectory(\"scala-maven-plugin-compiler-bridge-classes\");\n\n      IO.unzip(bridgeSources, sourcesDir.toFile(), AllPassFilter$.MODULE$, true);\n\n      List<Path> bridgeSourcesScalaFiles =\n          FileUtils.listDirectoryContent(\n              sourcesDir,\n              file ->\n                  Files.isRegularFile(file) && file.getFileName().toString().endsWith(\".scala\"));\n      List<Path> bridgeSourcesNonScalaFiles =\n          FileUtils.listDirectoryContent(\n              sourcesDir,\n              file ->\n                  Files.isRegularFile(file)\n                      && !file.getFileName().toString().endsWith(\".scala\")\n                      && !file.getFileName().toString().equals(\"MANIFEST.MF\"));\n\n      try {\n        rawCompiler.apply(\n            IterableHasAsScala(bridgeSourcesScalaFiles).asScala().toSeq(), // sources:Seq[File]\n            IterableHasAsScala(bridgeSourcesDependencies).asScala().toSeq(), // classpath:Seq[File],\n            classesDir, // outputDirectory:Path,\n            IterableHasAsScala(Collections.<String>emptyList())\n                .asScala()\n                .toSeq() // options:Seq[String]\n            );\n\n        Manifest manifest = new Manifest();\n        Path sourcesManifestFile = sourcesDir.resolve(\"META-INF\").resolve(\"MANIFEST.MF\");\n        try (InputStream is = new FileInputStream(sourcesManifestFile.toFile())) {\n          manifest.read(is);\n        }\n\n        List<Pair<File, String>> scalaCompiledClasses =\n            computeZipEntries(FileUtils.listDirectoryContent(classesDir, file -> true), classesDir);\n        List<Pair<File, String>> resources =\n            computeZipEntries(bridgeSourcesNonScalaFiles, sourcesDir);\n        List<Pair<File, String>> allZipEntries = new ArrayList<>();\n        allZipEntries.addAll(scalaCompiledClasses);\n        allZipEntries.addAll(resources);\n\n        IO.jar(\n            IterableHasAsScala(\n                    allZipEntries.stream()\n                        .map(x -> scala.Tuple2.apply(x.getLeft(), x.getRight()))\n                        .collect(Collectors.toList()))\n                .asScala(),\n            cachedCompiledBridgeJar,\n            manifest);\n\n        mavenLogger.info(\"Compiler bridge installed\");\n\n      } finally {\n        FileUtils.deleteDirectory(sourcesDir);\n        FileUtils.deleteDirectory(classesDir);\n      }\n    }\n\n    return cachedCompiledBridgeJar;\n  }\n}\n","lineNo":230}
{"Smelly Sample":"\n/*\n * Copyright 2011-2020 scala-maven-plugin project (https://davidb.github.io/scala-maven-plugin/)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage sbt_inc;\n\nimport static scala.jdk.CollectionConverters.IterableHasAsScala;\nimport static scala.jdk.FunctionWrappers.FromJavaConsumer;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.*;\nimport java.util.jar.Manifest;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.plugin.logging.Log;\nimport sbt.internal.inc.*;\nimport sbt.internal.inc.FileAnalysisStore;\nimport sbt.internal.inc.ScalaInstance;\nimport sbt.internal.inc.classpath.ClasspathUtil;\nimport sbt.io.AllPassFilter$;\nimport sbt.io.IO;\nimport sbt.util.Logger;\nimport scala.Option;\nimport scala.Tuple2;\nimport scala_maven.MavenArtifactResolver;\nimport scala_maven.VersionNumber;\nimport util.FileUtils;\nimport xsbti.PathBasedFile;\nimport xsbti.T2;\nimport xsbti.VirtualFile;\nimport xsbti.compile.*;\n\npublic class SbtIncrementalCompiler {\n\n  private static final String SBT_GROUP_ID = \"org.scala-sbt\";\n  private static final String JAVA_CLASS_VERSION = System.getProperty(\"java.class.version\");\n  private static final File DEFAULT_SECONDARY_CACHE_DIR =\n      Paths.get(System.getProperty(\"user.home\"), \".sbt\", \"1.0\", \"zinc\", \"org.scala-sbt\").toFile();\n\n  private final IncrementalCompiler compiler = ZincUtil.defaultIncrementalCompiler();\n  private final CompileOrder compileOrder;\n  private final Logger logger;\n  private final Compilers compilers;\n  private final Setup setup;\n  private final AnalysisStore analysisStore;\n  private final MavenArtifactResolver resolver;\n  private final File secondaryCacheDir;\n\n  public SbtIncrementalCompiler(\n      File libraryJar,\n      File reflectJar,\n      File compilerJar,\n      VersionNumber scalaVersion,\n      List<File> extraJars,\n      Path javaHome,\n      MavenArtifactResolver resolver,\n      File secondaryCacheDir,\n      Log mavenLogger,\n      File cacheFile,\n      CompileOrder compileOrder)\n      throws Exception {\n    this.compileOrder = compileOrder;\n    this.logger = new SbtLogger(mavenLogger);\n    mavenLogger.info(\"Using incremental compilation using \" + compileOrder + \" compile order\");\n    this.resolver = resolver;\n    this.secondaryCacheDir =\n        secondaryCacheDir != null ? secondaryCacheDir : DEFAULT_SECONDARY_CACHE_DIR;\n    this.secondaryCacheDir.mkdirs();\n\n    List<File> allJars = new ArrayList<>(extraJars);\n    allJars.add(libraryJar);\n    allJars.add(reflectJar);\n    allJars.add(compilerJar);\n\n    ScalaInstance scalaInstance =\n        new ScalaInstance(\n            scalaVersion.toString(), // version\n            new URLClassLoader(\n                new URL[] {\n                  libraryJar.toURI().toURL(),\n                  reflectJar.toURI().toURL(),\n                  compilerJar.toURI().toURL()\n                }), // loader\n            ClasspathUtil.rootLoader(), // loaderLibraryOnly\n            libraryJar, // libraryJar\n            compilerJar, // compilerJar\n            allJars.toArray(new File[] {}), // allJars\n            Option.apply(scalaVersion.toString()) // explicitActual\n            );\n\n    File compilerBridgeJar = getCompiledBridgeJar(scalaInstance, mavenLogger);\n\n    ScalaCompiler scalaCompiler =\n        new AnalyzingCompiler(\n            scalaInstance, // scalaInstance\n            ZincCompilerUtil.constantBridgeProvider(scalaInstance, compilerBridgeJar), // provider\n            ClasspathOptionsUtil.auto(), // classpathOptions\n            new FromJavaConsumer(noop -> {}), // onArgsHandler\n            Option.apply(null) // classLoaderCache\n            );\n\n    compilers =\n        ZincUtil.compilers(\n            scalaInstance, ClasspathOptionsUtil.boot(), Option.apply(javaHome), scalaCompiler);\n\n    PerClasspathEntryLookup lookup =\n        new PerClasspathEntryLookup() {\n          @Override\n          public Optional<CompileAnalysis> analysis(VirtualFile classpathEntry) {\n            Path path = ((PathBasedFile) classpathEntry).toPath();\n\n            String analysisStoreFileName = null;\n            if (Files.isDirectory(path)) {\n              if (path.getFileName().equals(\"classes\")) {\n                analysisStoreFileName = \"compile\";\n\n              } else if (path.getFileName().equals(\"test-classes\")) {\n                analysisStoreFileName = \"test-compile\";\n              }\n            }\n\n            if (analysisStoreFileName != null) {\n              File analysisStoreFile =\n                  path.getParent().resolve(\"analysis\").resolve(analysisStoreFileName).toFile();\n              if (analysisStoreFile.exists()) {\n                return AnalysisStore.getCachedStore(FileAnalysisStore.binary(analysisStoreFile))\n                    .get()\n                    .map(AnalysisContents::getAnalysis);\n              }\n            }\n            return Optional.empty();\n          }\n\n          @Override\n          public DefinesClass definesClass(VirtualFile classpathEntry) {\n            return Locate.definesClass(classpathEntry);\n          }\n        };\n\n    analysisStore = AnalysisStore.getCachedStore(FileAnalysisStore.binary(cacheFile));\n\n    setup =\n        Setup.of(\n            lookup, // lookup\n            false, // skip\n            cacheFile, // cacheFile\n            CompilerCache.fresh(), // cache\n            IncOptions.of(), // incOptions\n            new LoggedReporter(100, logger, pos -> pos), // reporter\n            Optional.empty(), // optionProgress\n            new T2[] {});\n  }\n\n  private PreviousResult previousResult() {\n    Optional<AnalysisContents> analysisContents = analysisStore.get();\n    if (analysisContents.isPresent()) {\n      AnalysisContents analysisContents0 = analysisContents.get();\n      CompileAnalysis previousAnalysis = analysisContents0.getAnalysis();\n      MiniSetup previousSetup = analysisContents0.getMiniSetup();\n      return PreviousResult.of(Optional.of(previousAnalysis), Optional.of(previousSetup));\n    } else {\n      return PreviousResult.of(Optional.empty(), Optional.empty());\n    }\n  }\n\n  public void compile(\n      Set<String> classpathElements,\n      List<Path> sources,\n      Path classesDirectory,\n      List<String> scalacOptions,\n      List<String> javacOptions) {\n    List<Path> fullClasspath = new ArrayList<>();\n    fullClasspath.add(classesDirectory);\n    for (String classpathElement : classpathElements) {\n      fullClasspath.add(Paths.get(classpathElement));\n    }\n\n    CompileOptions options =\n        CompileOptions.of(\n            fullClasspath.stream()\n                .map(PlainVirtualFile::new)\n                .toArray(VirtualFile[]::new), // classpath\n            sources.stream().map(PlainVirtualFile::new).toArray(VirtualFile[]::new), // sources\n            classesDirectory, //\n            scalacOptions.toArray(new String[] {}), // scalacOptions\n            javacOptions.toArray(new String[] {}), // javacOptions\n            100, // maxErrors\n            pos -> pos, // sourcePositionMappers\n            compileOrder, // order\n            Optional.empty(), // temporaryClassesDirectory\n            Optional.of(PlainVirtualFileConverter.converter()), // _converter\n            Optional.empty(), // _stamper\n            Optional.empty() // _earlyOutput\n            );\n\n    Inputs inputs = Inputs.of(compilers, options, setup, previousResult());\n\n    CompileResult newResult = compiler.compile(inputs, logger);\n    analysisStore.set(AnalysisContents.create(newResult.analysis(), newResult.setup()));\n  }\n\n  private String compilerBridgeArtifactId(String scalaVersion) {\n    if (scalaVersion.startsWith(\"2.10.\")) {\n      return \"compiler-bridge_2.10\";\n    } else if (scalaVersion.startsWith(\"2.11.\")) {\n      return \"compiler-bridge_2.11\";\n    } else if (scalaVersion.startsWith(\"2.12.\") || scalaVersion.equals(\"2.13.0-M1\")) {\n      return \"compiler-bridge_2.12\";\n    } else {\n      return \"compiler-bridge_2.13\";\n    }\n  }\n\n  private static List<Tuple2<File, String>> computeZipEntries(List<Path> paths, Path rootDir) {\n    int rootDirLength = rootDir.toString().length();\n    Stream<Tuple2<File, String>> stream =\n        paths.stream()\n            .map(\n                path -> {\n                  String zipPath =\n                      path.toString().substring(rootDirLength + 1).replace(File.separator, \"/\");\n                  if (Files.isDirectory(path)) {\n                    zipPath = zipPath + \"/\";\n                  }\n                  return new Tuple2(path.toFile(), zipPath);\n                });\n    return stream.collect(Collectors.toList());\n  }\n\n  private File getCompiledBridgeJar(ScalaInstance scalaInstance, Log mavenLogger) throws Exception {\n\n    // eg\n    // org.scala-sbt-compiler-bridge_2.12-1.2.4-bin_2.12.10__52.0-1.2.4_20181015T090407.jar\n    String bridgeArtifactId = compilerBridgeArtifactId(scalaInstance.actualVersion());\n\n    // this file is localed in compiler-interface\n    Properties properties = new Properties();\n    try (InputStream is =\n        getClass().getClassLoader().getResourceAsStream(\"incrementalcompiler.version.properties\")) {\n      properties.load(is);\n    }\n\n    String zincVersion = properties.getProperty(\"version\");\n    String timestamp = properties.getProperty(\"timestamp\");\n\n    String cacheFileName =\n        SBT_GROUP_ID\n            + '-'\n            + bridgeArtifactId\n            + '-'\n            + zincVersion\n            + \"-bin_\"\n            + scalaInstance.actualVersion()\n            + \"__\"\n            + JAVA_CLASS_VERSION\n            + '-'\n            + zincVersion\n            + '_'\n            + timestamp\n            + \".jar\";\n\n    File cachedCompiledBridgeJar = new File(secondaryCacheDir, cacheFileName);\n\n    if (mavenLogger.isInfoEnabled()) {\n      mavenLogger.info(\"Compiler bridge file: \" + cachedCompiledBridgeJar);\n    }\n\n    if (!cachedCompiledBridgeJar.exists()) {\n      mavenLogger.info(\"Compiler bridge file is not installed yet\");\n      // compile and install\n      RawCompiler rawCompiler = new RawCompiler(scalaInstance, ClasspathOptionsUtil.auto(), logger);\n\n      File bridgeSources =\n          resolver.getJar(SBT_GROUP_ID, bridgeArtifactId, zincVersion, \"sources\").getFile();\n\n      Set<Path> bridgeSourcesDependencies =\n          resolver.getJarAndDependencies(SBT_GROUP_ID, bridgeArtifactId, zincVersion, \"sources\")\n              .stream()\n              .filter(\n                  artifact ->\n                      artifact.getScope() != null && !artifact.getScope().equals(\"provided\"))\n              .map(Artifact::getFile)\n              .map(File::toPath)\n              .collect(Collectors.toSet());\n\n      bridgeSourcesDependencies.addAll(\n          Arrays.stream(scalaInstance.allJars())\n              .sequential()\n              .map(File::toPath)\n              .collect(Collectors.toList()));\n\n      Path sourcesDir = Files.createTempDirectory(\"scala-maven-plugin-compiler-bridge-sources\");\n      Path classesDir = Files.createTempDirectory(\"scala-maven-plugin-compiler-bridge-classes\");\n\n      IO.unzip(bridgeSources, sourcesDir.toFile(), AllPassFilter$.MODULE$, true);\n\n      List<Path> bridgeSourcesScalaFiles =\n          FileUtils.listDirectoryContent(\n              sourcesDir,\n              file ->\n                  Files.isRegularFile(file) && file.getFileName().toString().endsWith(\".scala\"));\n      List<Path> bridgeSourcesNonScalaFiles =\n          FileUtils.listDirectoryContent(\n              sourcesDir,\n              file ->\n                  Files.isRegularFile(file)\n                      && !file.getFileName().toString().endsWith(\".scala\")\n                      && !file.getFileName().toString().equals(\"MANIFEST.MF\"));\n\n      try {\n        rawCompiler.apply(\n            IterableHasAsScala(bridgeSourcesScalaFiles).asScala().toSeq(), // sources:Seq[File]\n            IterableHasAsScala(bridgeSourcesDependencies).asScala().toSeq(), // classpath:Seq[File],\n            classesDir, // outputDirectory:Path,\n            IterableHasAsScala(Collections.<String>emptyList())\n                .asScala()\n                .toSeq() // options:Seq[String]\n            );\n\n        Manifest manifest = new Manifest();\n        Path sourcesManifestFile = sourcesDir.resolve(\"META-INF\").resolve(\"MANIFEST.MF\");\n        try (InputStream is = new FileInputStream(sourcesManifestFile.toFile())) {\n          manifest.read(is);\n        }\n\n        List<Tuple2<File, String>> scalaCompiledClasses =\n            computeZipEntries(FileUtils.listDirectoryContent(classesDir, file -> true), classesDir);\n        List<Tuple2<File, String>> resources =\n            computeZipEntries(bridgeSourcesNonScalaFiles, sourcesDir);\n        List<Tuple2<File, String>> allZipEntries = new ArrayList<>();\n        allZipEntries.addAll(scalaCompiledClasses);\n        allZipEntries.addAll(resources);\n\n        IO.jar(IterableHasAsScala(allZipEntries).asScala(), cachedCompiledBridgeJar, manifest);\n\n        mavenLogger.info(\"Compiler bridge installed\");\n\n      } finally {\n        FileUtils.deleteDirectory(sourcesDir);\n        FileUtils.deleteDirectory(classesDir);\n      }\n    }\n\n    return cachedCompiledBridgeJar;\n  }\n}\n","Method after Refactoring":"\n/*\n * Copyright 2011-2020 scala-maven-plugin project (https://davidb.github.io/scala-maven-plugin/)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage sbt_inc;\n\nimport static scala.jdk.CollectionConverters.IterableHasAsScala;\nimport static scala.jdk.FunctionWrappers.FromJavaConsumer;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.*;\nimport java.util.jar.Manifest;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\nimport org.apache.commons.lang3.tuple.Pair;\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.plugin.logging.Log;\nimport sbt.internal.inc.*;\nimport sbt.internal.inc.FileAnalysisStore;\nimport sbt.internal.inc.ScalaInstance;\nimport sbt.io.AllPassFilter$;\nimport sbt.io.IO;\nimport sbt.util.Logger;\nimport scala.Option;\nimport scala_maven.MavenArtifactResolver;\nimport util.FileUtils;\nimport xsbti.PathBasedFile;\nimport xsbti.T2;\nimport xsbti.VirtualFile;\nimport xsbti.compile.*;\n\npublic class SbtIncrementalCompiler {\n\n  private static final String SBT_GROUP_ID = \"org.scala-sbt\";\n  private static final String SBT_GROUP_ID_SCALA3 = \"org.scala-lang\";\n  private static final String JAVA_CLASS_VERSION = System.getProperty(\"java.class.version\");\n  private static final File DEFAULT_SECONDARY_CACHE_DIR =\n      Paths.get(System.getProperty(\"user.home\"), \".sbt\", \"1.0\", \"zinc\", \"org.scala-sbt\").toFile();\n\n  private final IncrementalCompiler compiler = ZincUtil.defaultIncrementalCompiler();\n  private final CompileOrder compileOrder;\n  private final Logger logger;\n  private final Compilers compilers;\n  private final Setup setup;\n  private final AnalysisStore analysisStore;\n  private final MavenArtifactResolver resolver;\n  private final File secondaryCacheDir;\n\n  public SbtIncrementalCompiler(\n      Path javaHome,\n      MavenArtifactResolver resolver,\n      File secondaryCacheDir,\n      Log mavenLogger,\n      File cacheFile,\n      CompileOrder compileOrder,\n      ScalaInstance scalaInstance)\n      throws Exception {\n    this.compileOrder = compileOrder;\n    this.logger = new SbtLogger(mavenLogger);\n    mavenLogger.info(\"Using incremental compilation using \" + compileOrder + \" compile order\");\n    this.resolver = resolver;\n    this.secondaryCacheDir =\n        secondaryCacheDir != null ? secondaryCacheDir : DEFAULT_SECONDARY_CACHE_DIR;\n    this.secondaryCacheDir.mkdirs();\n\n    File compilerBridgeJar = getCompiledBridgeJar(scalaInstance, mavenLogger);\n\n    ScalaCompiler scalaCompiler =\n        new AnalyzingCompiler(\n            scalaInstance, // scalaInstance\n            ZincCompilerUtil.constantBridgeProvider(scalaInstance, compilerBridgeJar), // provider\n            ClasspathOptionsUtil.auto(), // classpathOptions\n            new FromJavaConsumer(noop -> {}), // onArgsHandler\n            Option.apply(null) // classLoaderCache\n            );\n\n    compilers =\n        ZincUtil.compilers(\n            scalaInstance, ClasspathOptionsUtil.boot(), Option.apply(javaHome), scalaCompiler);\n\n    PerClasspathEntryLookup lookup =\n        new PerClasspathEntryLookup() {\n          @Override\n          public Optional<CompileAnalysis> analysis(VirtualFile classpathEntry) {\n            Path path = ((PathBasedFile) classpathEntry).toPath();\n\n            String analysisStoreFileName = null;\n            if (Files.isDirectory(path)) {\n              if (path.getFileName().equals(\"classes\")) {\n                analysisStoreFileName = \"compile\";\n\n              } else if (path.getFileName().equals(\"test-classes\")) {\n                analysisStoreFileName = \"test-compile\";\n              }\n            }\n\n            if (analysisStoreFileName != null) {\n              File analysisStoreFile =\n                  path.getParent().resolve(\"analysis\").resolve(analysisStoreFileName).toFile();\n              if (analysisStoreFile.exists()) {\n                return AnalysisStore.getCachedStore(FileAnalysisStore.binary(analysisStoreFile))\n                    .get()\n                    .map(AnalysisContents::getAnalysis);\n              }\n            }\n            return Optional.empty();\n          }\n\n          @Override\n          public DefinesClass definesClass(VirtualFile classpathEntry) {\n            return Locate.definesClass(classpathEntry);\n          }\n        };\n\n    analysisStore = AnalysisStore.getCachedStore(FileAnalysisStore.binary(cacheFile));\n\n    setup =\n        Setup.of(\n            lookup, // lookup\n            false, // skip\n            cacheFile, // cacheFile\n            CompilerCache.fresh(), // cache\n            IncOptions.of(), // incOptions\n            new LoggedReporter(100, logger, pos -> pos), // reporter\n            Optional.empty(), // optionProgress\n            new T2[] {});\n  }\n\n  private PreviousResult previousResult() {\n    Optional<AnalysisContents> analysisContents = analysisStore.get();\n    if (analysisContents.isPresent()) {\n      AnalysisContents analysisContents0 = analysisContents.get();\n      CompileAnalysis previousAnalysis = analysisContents0.getAnalysis();\n      MiniSetup previousSetup = analysisContents0.getMiniSetup();\n      return PreviousResult.of(Optional.of(previousAnalysis), Optional.of(previousSetup));\n    } else {\n      return PreviousResult.of(Optional.empty(), Optional.empty());\n    }\n  }\n\n  public void compile(\n      Set<String> classpathElements,\n      List<Path> sources,\n      Path classesDirectory,\n      List<String> scalacOptions,\n      List<String> javacOptions) {\n    List<Path> fullClasspath = new ArrayList<>();\n    fullClasspath.add(classesDirectory);\n    for (String classpathElement : classpathElements) {\n      fullClasspath.add(Paths.get(classpathElement));\n    }\n\n    CompileOptions options =\n        CompileOptions.of(\n            fullClasspath.stream()\n                .map(PlainVirtualFile::new)\n                .toArray(VirtualFile[]::new), // classpath\n            sources.stream().map(PlainVirtualFile::new).toArray(VirtualFile[]::new), // sources\n            classesDirectory, //\n            scalacOptions.toArray(new String[] {}), // scalacOptions\n            javacOptions.toArray(new String[] {}), // javacOptions\n            100, // maxErrors\n            pos -> pos, // sourcePositionMappers\n            compileOrder, // order\n            Optional.empty(), // temporaryClassesDirectory\n            Optional.of(PlainVirtualFileConverter.converter()), // _converter\n            Optional.empty(), // _stamper\n            Optional.empty() // _earlyOutput\n            );\n\n    Inputs inputs = Inputs.of(compilers, options, setup, previousResult());\n\n    CompileResult newResult = compiler.compile(inputs, logger);\n    analysisStore.set(AnalysisContents.create(newResult.analysis(), newResult.setup()));\n  }\n\n  private String compilerBridgeArtifactId(String scalaVersion) {\n    if (scalaVersion.startsWith(\"2.10.\")) {\n      return \"compiler-bridge_2.10\";\n    } else if (scalaVersion.startsWith(\"2.11.\")) {\n      return \"compiler-bridge_2.11\";\n    } else if (scalaVersion.startsWith(\"2.12.\") || scalaVersion.equals(\"2.13.0-M1\")) {\n      return \"compiler-bridge_2.12\";\n    } else if (scalaVersion.startsWith(\"2.13.\")) {\n      return \"compiler-bridge_2.13\";\n    } else {\n      return \"scala3-sbt-bridge\";\n    }\n  }\n\n  private static List<Pair<File, String>> computeZipEntries(List<Path> paths, Path rootDir) {\n    int rootDirLength = rootDir.toString().length();\n    Stream<Pair<File, String>> stream =\n        paths.stream()\n            .map(\n                path -> {\n                  String zipPath =\n                      path.toString().substring(rootDirLength + 1).replace(File.separator, \"/\");\n                  if (Files.isDirectory(path)) {\n                    zipPath = zipPath + \"/\";\n                  }\n                  return Pair.of(path.toFile(), zipPath);\n                });\n    return stream.collect(Collectors.toList());\n  }\n\n  private File getCompiledBridgeJar(ScalaInstance scalaInstance, Log mavenLogger) throws Exception {\n\n    // eg\n    // org.scala-sbt-compiler-bridge_2.12-1.2.4-bin_2.12.10__52.0-1.2.4_20181015T090407.jar\n    String bridgeArtifactId = compilerBridgeArtifactId(scalaInstance.actualVersion());\n\n    Boolean isScala3 = scalaInstance.actualVersion().startsWith(\"3\");\n\n    // this file is localed in compiler-interface\n    Properties properties = new Properties();\n    try (InputStream is =\n        getClass().getClassLoader().getResourceAsStream(\"incrementalcompiler.version.properties\")) {\n      properties.load(is);\n    }\n\n    String zincVersion = properties.getProperty(\"version\");\n    String timestamp = properties.getProperty(\"timestamp\");\n\n    String groupId = isScala3 ? SBT_GROUP_ID_SCALA3 : SBT_GROUP_ID;\n    String version = isScala3 ? scalaInstance.actualVersion() : zincVersion;\n\n    if (isScala3) {\n      return resolver.getJar(groupId, bridgeArtifactId, version, \"\").getFile();\n    }\n\n    String cacheFileName =\n        groupId\n            + '-'\n            + bridgeArtifactId\n            + '-'\n            + version\n            + \"-bin_\"\n            + scalaInstance.actualVersion()\n            + \"__\"\n            + JAVA_CLASS_VERSION\n            + '-'\n            + version\n            + '_'\n            + timestamp\n            + \".jar\";\n\n    File cachedCompiledBridgeJar = new File(secondaryCacheDir, cacheFileName);\n\n    if (mavenLogger.isInfoEnabled()) {\n      mavenLogger.info(\"Compiler bridge file: \" + cachedCompiledBridgeJar);\n    }\n\n    if (!cachedCompiledBridgeJar.exists()) {\n      mavenLogger.info(\"Compiler bridge file is not installed yet\");\n      // compile and install\n      RawCompiler rawCompiler = new RawCompiler(scalaInstance, ClasspathOptionsUtil.auto(), logger);\n\n      File bridgeSources = resolver.getJar(groupId, bridgeArtifactId, version, \"sources\").getFile();\n\n      Set<Path> bridgeSourcesDependencies =\n          resolver.getJarAndDependencies(groupId, bridgeArtifactId, version, \"sources\").stream()\n              .filter(\n                  artifact ->\n                      artifact.getScope() != null && !artifact.getScope().equals(\"provided\"))\n              .map(Artifact::getFile)\n              .map(File::toPath)\n              .collect(Collectors.toSet());\n\n      bridgeSourcesDependencies.addAll(\n          Arrays.stream(scalaInstance.allJars())\n              .sequential()\n              .map(File::toPath)\n              .collect(Collectors.toList()));\n\n      Path sourcesDir = Files.createTempDirectory(\"scala-maven-plugin-compiler-bridge-sources\");\n      Path classesDir = Files.createTempDirectory(\"scala-maven-plugin-compiler-bridge-classes\");\n\n      IO.unzip(bridgeSources, sourcesDir.toFile(), AllPassFilter$.MODULE$, true);\n\n      List<Path> bridgeSourcesScalaFiles =\n          FileUtils.listDirectoryContent(\n              sourcesDir,\n              file ->\n                  Files.isRegularFile(file) && file.getFileName().toString().endsWith(\".scala\"));\n      List<Path> bridgeSourcesNonScalaFiles =\n          FileUtils.listDirectoryContent(\n              sourcesDir,\n              file ->\n                  Files.isRegularFile(file)\n                      && !file.getFileName().toString().endsWith(\".scala\")\n                      && !file.getFileName().toString().equals(\"MANIFEST.MF\"));\n\n      try {\n        rawCompiler.apply(\n            IterableHasAsScala(bridgeSourcesScalaFiles).asScala().toSeq(), // sources:Seq[File]\n            IterableHasAsScala(bridgeSourcesDependencies).asScala().toSeq(), // classpath:Seq[File],\n            classesDir, // outputDirectory:Path,\n            IterableHasAsScala(Collections.<String>emptyList())\n                .asScala()\n                .toSeq() // options:Seq[String]\n            );\n\n        Manifest manifest = new Manifest();\n        Path sourcesManifestFile = sourcesDir.resolve(\"META-INF\").resolve(\"MANIFEST.MF\");\n        try (InputStream is = new FileInputStream(sourcesManifestFile.toFile())) {\n          manifest.read(is);\n        }\n\n        List<Pair<File, String>> scalaCompiledClasses =\n            computeZipEntries(FileUtils.listDirectoryContent(classesDir, file -> true), classesDir);\n        List<Pair<File, String>> resources =\n            computeZipEntries(bridgeSourcesNonScalaFiles, sourcesDir);\n        List<Pair<File, String>> allZipEntries = new ArrayList<>();\n        allZipEntries.addAll(scalaCompiledClasses);\n        allZipEntries.addAll(resources);\n\n        IO.jar(\n            IterableHasAsScala(\n                    allZipEntries.stream()\n                        .map(x -> scala.Tuple2.apply(x.getLeft(), x.getRight()))\n                        .collect(Collectors.toList()))\n                .asScala(),\n            cachedCompiledBridgeJar,\n            manifest);\n\n        mavenLogger.info(\"Compiler bridge installed\");\n\n      } finally {\n        FileUtils.deleteDirectory(sourcesDir);\n        FileUtils.deleteDirectory(classesDir);\n      }\n    }\n\n    return cachedCompiledBridgeJar;\n  }\n}\n","lineNo":243}
{"Smelly Sample":"\n/*\n * Copyright 2011-2020 scala-maven-plugin project (https://davidb.github.io/scala-maven-plugin/)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage scala_maven;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport sbt_inc.SbtIncrementalCompiler;\nimport scala_maven_executions.JavaMainCaller;\nimport scala_maven_executions.MainHelper;\nimport util.JavaLocator;\nimport xsbti.compile.CompileOrder;\n\n/** Abstract parent of all Scala Mojo who run compilation */\npublic abstract class ScalaCompilerSupport extends ScalaSourceMojoSupport {\n\n  public enum RecompileMode {\n    /** all sources are recompiled */\n    all,\n\n    /** incrementally recompile modified sources and other affected sources */\n    incremental\n  }\n\n  /** Keeps track of if we get compile errors in incremental mode */\n  private boolean compileErrors;\n\n  /**\n   * Recompile mode to use when sources were previously compiled and there is at least one change,\n   * see {@link RecompileMode}.\n   */\n  @Parameter(property = \"recompileMode\", defaultValue = \"incremental\")\n  RecompileMode recompileMode;\n\n  /**\n   * notifyCompilation if true then print a message \"path: compiling\" for each root directory or\n   * files that will be compiled. Useful for debug, and for integration with Editor/IDE to reset\n   * markers only for compiled files.\n   */\n  @Parameter(property = \"notifyCompilation\", defaultValue = \"true\")\n  private boolean notifyCompilation;\n\n  /**\n   * Compile order for Scala and Java sources for sbt incremental compile.\n   *\n   * <p>Can be Mixed, JavaThenScala, or ScalaThenJava.\n   */\n  @Parameter(property = \"compileOrder\", defaultValue = \"Mixed\")\n  private CompileOrder compileOrder;\n\n  /**\n   * Location of the incremental compile will install compiled compiler bridge jars. Default is\n   * sbt's \"~/.sbt/1.0/zinc/org.scala-sbt\".\n   */\n  @Parameter(property = \"secondaryCacheDir\")\n  private File secondaryCacheDir;\n\n  protected abstract File getOutputDir() throws Exception;\n\n  protected abstract Set<String> getClasspathElements() throws Exception;\n\n  private long _lastCompileAt = -1;\n\n  private SbtIncrementalCompiler incremental;\n\n  /** Analysis cache file for incremental recompilation. */\n  protected abstract File getAnalysisCacheFile() throws Exception;\n\n  @Override\n  protected void doExecute() throws Exception {\n    if (getLog().isDebugEnabled()) {\n      for (File directory : getSourceDirectories()) {\n        getLog().debug(FileUtils.pathOf(directory, useCanonicalPath));\n      }\n    }\n    File outputDir = FileUtils.fileOf(getOutputDir(), useCanonicalPath);\n    File analysisCacheFile = FileUtils.fileOf(getAnalysisCacheFile(), useCanonicalPath);\n    int nbFiles =\n        compile(\n            getSourceDirectories(), outputDir, analysisCacheFile, getClasspathElements(), false);\n    switch (nbFiles) {\n      case -1:\n        getLog().info(\"No sources to compile\");\n        break;\n      case 0:\n        getLog().info(\"Nothing to compile - all classes are up to date\");\n        break;\n      default:\n        break;\n    }\n  }\n\n  protected int compile(\n      List<File> sourceRootDirs,\n      File outputDir,\n      File analysisCacheFile,\n      Set<String> classpathElements,\n      boolean compileInLoop)\n      throws Exception {\n    if (!compileInLoop && recompileMode == RecompileMode.incremental) {\n      // if not compileInLoop, invoke incrementalCompile immediately\n      long n0 = System.nanoTime();\n      int res =\n          incrementalCompile(\n              classpathElements, sourceRootDirs, outputDir, analysisCacheFile, false);\n      getLog().info(String.format(\"compile in %.1f s\", (System.nanoTime() - n0) / 1_000_000_000.0));\n      return res;\n    }\n\n    long t0 = System.currentTimeMillis();\n    long n0 = System.nanoTime();\n    LastCompilationInfo lastCompilationInfo = LastCompilationInfo.find(sourceRootDirs, outputDir);\n    if (_lastCompileAt < 0) {\n      _lastCompileAt = lastCompilationInfo.getLastSuccessfullTS();\n    }\n\n    List<File> files = getFilesToCompile(sourceRootDirs, _lastCompileAt);\n\n    if (files == null) {\n      return -1;\n    }\n\n    if (files.size() < 1) {\n      return 0;\n    }\n    if (!outputDir.exists()) {\n      outputDir.mkdirs();\n    }\n    long n1 = System.nanoTime();\n    long t1 = t0 + ((n1 - n0) / 1_000_000);\n\n    if (compileInLoop && recompileMode == RecompileMode.incremental) {\n      // if compileInLoop, do not invoke incrementalCompile when there's no change\n      int retCode =\n          incrementalCompile(classpathElements, sourceRootDirs, outputDir, analysisCacheFile, true);\n      _lastCompileAt = t1;\n      if (retCode == 1) {\n        lastCompilationInfo.setLastSuccessfullTS(t1);\n      }\n      return retCode;\n    }\n\n    getLog()\n        .info(\n            String.format(\n                \"Compiling %d source files to %s at %d\",\n                files.size(), outputDir.getAbsolutePath(), t1));\n    JavaMainCaller jcmd = getScalaCommand();\n    jcmd.redirectToLog();\n    if (!classpathElements.isEmpty())\n      jcmd.addArgs(\"-classpath\", MainHelper.toMultiPath(classpathElements));\n    jcmd.addArgs(\"-d\", outputDir.getAbsolutePath());\n    // jcmd.addArgs(\"-sourcepath\", sourceDir.getAbsolutePath());\n    for (File f : files) {\n      jcmd.addArgs(f.getAbsolutePath());\n    }\n    if (jcmd.run(displayCmd, !compileInLoop)) {\n      lastCompilationInfo.setLastSuccessfullTS(t1);\n    } else {\n      compileErrors = true;\n    }\n    getLog().info(String.format(\"prepare-compile in %.1f s\", (n1 - n0) / 1_000_000_000.0));\n    getLog().info(String.format(\"compile in %.1f s\", (System.nanoTime() - n1) / 1_000_000_000.0));\n    _lastCompileAt = t1;\n    return files.size();\n  }\n\n  /** Returns true if the previous compile failed */\n  boolean hasCompileErrors() {\n    return compileErrors;\n  }\n\n  void clearCompileErrors() {\n    compileErrors = false;\n  }\n\n  private List<File> getFilesToCompile(List<File> sourceRootDirs, long lastSuccessfulCompileTime)\n      throws Exception {\n    List<File> sourceFiles = findSourceWithFilters(sourceRootDirs);\n    if (sourceFiles.size() == 0) {\n      return null;\n    }\n\n    // filter uptodate\n    // filter is not applied to .java, because scalac failed to used existing .class\n    // for unmodified .java\n    // failed with \"error while loading Xxx, class file\n    // '.../target/classes/.../Xxxx.class' is broken\"\n    // (restore how it work in 2.11 and failed in 2.12)\n    // TODO a better behavior : if there is at least one .scala to compile then add\n    // all .java, if there is at least one .java then add all .scala (because we\n    // don't manage class dependency)\n    List<File> files = new ArrayList<>(sourceFiles.size());\n    if (_lastCompileAt > 0\n        || (recompileMode != RecompileMode.all && (lastSuccessfulCompileTime > 0))) {\n      ArrayList<File> modifiedScalaFiles = new ArrayList<>(sourceFiles.size());\n      ArrayList<File> modifiedJavaFiles = new ArrayList<>(sourceFiles.size());\n      for (File f : sourceFiles) {\n        if (f.lastModified() >= lastSuccessfulCompileTime) {\n          if (f.getName().endsWith(\".java\")) {\n            modifiedJavaFiles.add(f);\n          } else {\n            modifiedScalaFiles.add(f);\n          }\n        }\n      }\n      if ((modifiedScalaFiles.size() != 0) || (modifiedJavaFiles.size() != 0)) {\n        files.addAll(sourceFiles);\n        notifyCompilation(sourceRootDirs);\n      }\n    } else {\n      files.addAll(sourceFiles);\n      notifyCompilation(sourceRootDirs);\n    }\n    return files;\n  }\n\n  private void notifyCompilation(List<File> files) throws Exception {\n    if (notifyCompilation) {\n      for (File f : files) {\n        getLog()\n            .info(String.format(\"%s:-1: info: compiling\", FileUtils.pathOf(f, useCanonicalPath)));\n      }\n    }\n  }\n\n  private static class LastCompilationInfo {\n    static LastCompilationInfo find(List<File> sourceRootDirs, File outputDir) {\n      StringBuilder hash = new StringBuilder();\n      for (File f : sourceRootDirs) {\n        hash.append(f.toString());\n      }\n      return new LastCompilationInfo(\n          new File(outputDir.getAbsolutePath() + \".\" + hash.toString().hashCode() + \".timestamp\"),\n          outputDir);\n    }\n\n    private final File _lastCompileAtFile;\n    private final File _outputDir;\n\n    private LastCompilationInfo(File f, File outputDir) {\n      _lastCompileAtFile = f;\n      _outputDir = outputDir;\n    }\n\n    long getLastSuccessfullTS() {\n      long back = -1;\n      if (_lastCompileAtFile.exists() && _outputDir.exists() && _outputDir.list().length > 0) {\n        back = _lastCompileAtFile.lastModified();\n      }\n      return back;\n    }\n\n    void setLastSuccessfullTS(long v) throws Exception {\n      if (!_lastCompileAtFile.exists()) {\n        FileUtils.fileWrite(_lastCompileAtFile.getAbsolutePath(), \".\");\n      }\n      _lastCompileAtFile.setLastModified(v);\n    }\n  }\n\n  // Incremental compilation\n  private int incrementalCompile(\n      Set<String> classpathElements,\n      List<File> sourceRootDirs,\n      File outputDir,\n      File cacheFile,\n      boolean compileInLoop)\n      throws Exception {\n    List<File> sources = findSourceWithFilters(sourceRootDirs);\n    if (sources.isEmpty()) {\n      return -1;\n    }\n\n    // TODO - Do we really need this duplicated here?\n    if (!outputDir.exists()) {\n      outputDir.mkdirs();\n    }\n\n    if (incremental == null) {\n      File libraryJar = getLibraryJar();\n      List<File> extraJars = getCompilerDependencies();\n      extraJars.remove(libraryJar);\n      File javaHome = JavaLocator.findHomeFromToolchain(getToolchain());\n      incremental =\n          new SbtIncrementalCompiler(\n              libraryJar,\n              getReflectJar(),\n              getCompilerJar(),\n              findScalaVersion(),\n              extraJars,\n              javaHome.toPath(),\n              new MavenArtifactResolver(factory, session),\n              secondaryCacheDir,\n              getLog(),\n              cacheFile,\n              compileOrder);\n    }\n\n    classpathElements.remove(outputDir.getAbsolutePath());\n    List<String> scalacOptions = getScalaOptions();\n    List<String> javacOptions = getJavacOptions();\n\n    try {\n      incremental.compile(\n          classpathElements,\n          sources.stream().map(File::toPath).collect(Collectors.toList()),\n          outputDir.toPath(),\n          scalacOptions,\n          javacOptions);\n    } catch (xsbti.CompileFailed e) {\n      if (compileInLoop) {\n        compileErrors = true;\n      } else {\n        throw e;\n      }\n    }\n\n    return 1;\n  }\n}\n","Method after Refactoring":"\n/*\n * Copyright 2011-2020 scala-maven-plugin project (https://davidb.github.io/scala-maven-plugin/)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage scala_maven;\n\nimport java.io.File;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport sbt.internal.inc.ScalaInstance;\nimport sbt.internal.inc.classpath.ClasspathUtil;\nimport sbt_inc.SbtIncrementalCompiler;\nimport scala.Option;\nimport scala_maven_executions.JavaMainCaller;\nimport scala_maven_executions.MainHelper;\nimport util.JavaLocator;\nimport xsbti.compile.CompileOrder;\n\n/** Abstract parent of all Scala Mojo who run compilation */\npublic abstract class ScalaCompilerSupport extends ScalaSourceMojoSupport {\n\n  public enum RecompileMode {\n    /** all sources are recompiled */\n    all,\n\n    /** incrementally recompile modified sources and other affected sources */\n    incremental\n  }\n\n  /** Keeps track of if we get compile errors in incremental mode */\n  private boolean compileErrors;\n\n  /**\n   * Recompile mode to use when sources were previously compiled and there is at least one change,\n   * see {@link RecompileMode}.\n   */\n  @Parameter(property = \"recompileMode\", defaultValue = \"incremental\")\n  RecompileMode recompileMode;\n\n  /**\n   * notifyCompilation if true then print a message \"path: compiling\" for each root directory or\n   * files that will be compiled. Useful for debug, and for integration with Editor/IDE to reset\n   * markers only for compiled files.\n   */\n  @Parameter(property = \"notifyCompilation\", defaultValue = \"true\")\n  private boolean notifyCompilation;\n\n  /**\n   * Compile order for Scala and Java sources for sbt incremental compile.\n   *\n   * <p>Can be Mixed, JavaThenScala, or ScalaThenJava.\n   */\n  @Parameter(property = \"compileOrder\", defaultValue = \"Mixed\")\n  private CompileOrder compileOrder;\n\n  /**\n   * Location of the incremental compile will install compiled compiler bridge jars. Default is\n   * sbt's \"~/.sbt/1.0/zinc/org.scala-sbt\".\n   */\n  @Parameter(property = \"secondaryCacheDir\")\n  private File secondaryCacheDir;\n\n  protected abstract File getOutputDir() throws Exception;\n\n  protected abstract Set<String> getClasspathElements() throws Exception;\n\n  private long _lastCompileAt = -1;\n\n  private SbtIncrementalCompiler incremental;\n\n  /** Analysis cache file for incremental recompilation. */\n  protected abstract File getAnalysisCacheFile() throws Exception;\n\n  @Override\n  protected void doExecute() throws Exception {\n    if (getLog().isDebugEnabled()) {\n      for (File directory : getSourceDirectories()) {\n        getLog().debug(FileUtils.pathOf(directory, useCanonicalPath));\n      }\n    }\n    File outputDir = FileUtils.fileOf(getOutputDir(), useCanonicalPath);\n    File analysisCacheFile = FileUtils.fileOf(getAnalysisCacheFile(), useCanonicalPath);\n    int nbFiles =\n        compile(\n            getSourceDirectories(), outputDir, analysisCacheFile, getClasspathElements(), false);\n    switch (nbFiles) {\n      case -1:\n        getLog().info(\"No sources to compile\");\n        break;\n      case 0:\n        getLog().info(\"Nothing to compile - all classes are up to date\");\n        break;\n      default:\n        break;\n    }\n  }\n\n  protected int compile(\n      List<File> sourceRootDirs,\n      File outputDir,\n      File analysisCacheFile,\n      Set<String> classpathElements,\n      boolean compileInLoop)\n      throws Exception {\n    if (!compileInLoop && recompileMode == RecompileMode.incremental) {\n      // if not compileInLoop, invoke incrementalCompile immediately\n      long n0 = System.nanoTime();\n      int res =\n          incrementalCompile(\n              classpathElements, sourceRootDirs, outputDir, analysisCacheFile, false);\n      getLog().info(String.format(\"compile in %.1f s\", (System.nanoTime() - n0) / 1_000_000_000.0));\n      return res;\n    }\n\n    long t0 = System.currentTimeMillis();\n    long n0 = System.nanoTime();\n    LastCompilationInfo lastCompilationInfo = LastCompilationInfo.find(sourceRootDirs, outputDir);\n    if (_lastCompileAt < 0) {\n      _lastCompileAt = lastCompilationInfo.getLastSuccessfullTS();\n    }\n\n    List<File> files = getFilesToCompile(sourceRootDirs, _lastCompileAt);\n\n    if (files == null) {\n      return -1;\n    }\n\n    if (files.size() < 1) {\n      return 0;\n    }\n    if (!outputDir.exists()) {\n      outputDir.mkdirs();\n    }\n    long n1 = System.nanoTime();\n    long t1 = t0 + ((n1 - n0) / 1_000_000);\n\n    if (compileInLoop && recompileMode == RecompileMode.incremental) {\n      // if compileInLoop, do not invoke incrementalCompile when there's no change\n      int retCode =\n          incrementalCompile(classpathElements, sourceRootDirs, outputDir, analysisCacheFile, true);\n      _lastCompileAt = t1;\n      if (retCode == 1) {\n        lastCompilationInfo.setLastSuccessfullTS(t1);\n      }\n      return retCode;\n    }\n\n    getLog()\n        .info(\n            String.format(\n                \"Compiling %d source files to %s at %d\",\n                files.size(), outputDir.getAbsolutePath(), t1));\n    JavaMainCaller jcmd = getScalaCommand();\n    jcmd.redirectToLog();\n    if (!classpathElements.isEmpty())\n      jcmd.addArgs(\"-classpath\", MainHelper.toMultiPath(classpathElements));\n    jcmd.addArgs(\"-d\", outputDir.getAbsolutePath());\n    // jcmd.addArgs(\"-sourcepath\", sourceDir.getAbsolutePath());\n    for (File f : files) {\n      jcmd.addArgs(f.getAbsolutePath());\n    }\n    try {\n      if (jcmd.run(displayCmd, !compileInLoop)) {\n        lastCompilationInfo.setLastSuccessfullTS(t1);\n      } else {\n        compileErrors = true;\n      }\n    } catch (Exception e) {\n      System.out.println(\"exception compilation error occurred!!!\");\n      e.printStackTrace();\n    }\n    getLog().info(String.format(\"prepare-compile in %.1f s\", (n1 - n0) / 1_000_000_000.0));\n    getLog().info(String.format(\"compile in %.1f s\", (System.nanoTime() - n1) / 1_000_000_000.0));\n    _lastCompileAt = t1;\n    return files.size();\n  }\n\n  /** Returns true if the previous compile failed */\n  boolean hasCompileErrors() {\n    return compileErrors;\n  }\n\n  void clearCompileErrors() {\n    compileErrors = false;\n  }\n\n  private List<File> getFilesToCompile(List<File> sourceRootDirs, long lastSuccessfulCompileTime)\n      throws Exception {\n    List<File> sourceFiles = findSourceWithFilters(sourceRootDirs);\n    if (sourceFiles.size() == 0) {\n      return null;\n    }\n\n    // filter uptodate\n    // filter is not applied to .java, because scalac failed to used existing .class\n    // for unmodified .java\n    // failed with \"error while loading Xxx, class file\n    // '.../target/classes/.../Xxxx.class' is broken\"\n    // (restore how it work in 2.11 and failed in 2.12)\n    // TODO a better behavior : if there is at least one .scala to compile then add\n    // all .java, if there is at least one .java then add all .scala (because we\n    // don't manage class dependency)\n    List<File> files = new ArrayList<>(sourceFiles.size());\n    if (_lastCompileAt > 0\n        || (recompileMode != RecompileMode.all && (lastSuccessfulCompileTime > 0))) {\n      ArrayList<File> modifiedScalaFiles = new ArrayList<>(sourceFiles.size());\n      ArrayList<File> modifiedJavaFiles = new ArrayList<>(sourceFiles.size());\n      for (File f : sourceFiles) {\n        if (f.lastModified() >= lastSuccessfulCompileTime) {\n          if (f.getName().endsWith(\".java\")) {\n            modifiedJavaFiles.add(f);\n          } else {\n            modifiedScalaFiles.add(f);\n          }\n        }\n      }\n      if ((modifiedScalaFiles.size() != 0) || (modifiedJavaFiles.size() != 0)) {\n        files.addAll(sourceFiles);\n        notifyCompilation(sourceRootDirs);\n      }\n    } else {\n      files.addAll(sourceFiles);\n      notifyCompilation(sourceRootDirs);\n    }\n    return files;\n  }\n\n  private void notifyCompilation(List<File> files) throws Exception {\n    if (notifyCompilation) {\n      for (File f : files) {\n        getLog()\n            .info(String.format(\"%s:-1: info: compiling\", FileUtils.pathOf(f, useCanonicalPath)));\n      }\n    }\n  }\n\n  private static class LastCompilationInfo {\n    static LastCompilationInfo find(List<File> sourceRootDirs, File outputDir) {\n      StringBuilder hash = new StringBuilder();\n      for (File f : sourceRootDirs) {\n        hash.append(f.toString());\n      }\n      return new LastCompilationInfo(\n          new File(outputDir.getAbsolutePath() + \".\" + hash.toString().hashCode() + \".timestamp\"),\n          outputDir);\n    }\n\n    private final File _lastCompileAtFile;\n    private final File _outputDir;\n\n    private LastCompilationInfo(File f, File outputDir) {\n      _lastCompileAtFile = f;\n      _outputDir = outputDir;\n    }\n\n    long getLastSuccessfullTS() {\n      long back = -1;\n      if (_lastCompileAtFile.exists() && _outputDir.exists() && _outputDir.list().length > 0) {\n        back = _lastCompileAtFile.lastModified();\n      }\n      return back;\n    }\n\n    void setLastSuccessfullTS(long v) throws Exception {\n      if (!_lastCompileAtFile.exists()) {\n        FileUtils.fileWrite(_lastCompileAtFile.getAbsolutePath(), \".\");\n      }\n      _lastCompileAtFile.setLastModified(v);\n    }\n  }\n\n  private ScalaInstance getScalaInstanceForS2(\n      File libraryJar,\n      File reflectJar,\n      File compilerJar,\n      VersionNumber scalaVersion,\n      List<File> extraJars)\n      throws Exception {\n\n    List<File> allJars = new ArrayList<>(extraJars);\n    allJars.add(libraryJar);\n    allJars.add(reflectJar);\n    allJars.add(compilerJar);\n\n    URL[] urls =\n        new URL[] {\n          libraryJar.toURI().toURL(), reflectJar.toURI().toURL(), compilerJar.toURI().toURL()\n        };\n\n    URLClassLoader classLoader = new URLClassLoader(urls);\n    return new ScalaInstance(\n        scalaVersion.toString(), // version\n        classLoader, // loader\n        ClasspathUtil.rootLoader(), // loaderLibraryOnly\n        libraryJar, // libraryJar\n        compilerJar, // compilerJar\n        allJars.toArray(new File[] {}), // allJars\n        Option.apply(scalaVersion.toString()) // explicitActual\n        );\n  }\n\n  private ScalaInstance getScalaInstanceForS3(VersionNumber scalaVersion) throws Exception {\n    String version = scalaVersion.toString();\n    String scalaOrg = getScalaOrganization();\n    Set<Artifact> artifactSet =\n        new MavenArtifactResolver(factory, session)\n            .getJarAndDependencies(\n                scalaOrg, getScala3ArtifactId(SCALA3_COMPILER_ARTIFACTID), version, null);\n    Set<Artifact> compilerJarSet = artifactSet.stream().collect(Collectors.toSet());\n    File[] compilerJars = compilerJarSet.stream().map(x -> x.getFile()).toArray(File[]::new);\n    URL[] compilerJarUrls =\n        Stream.of(compilerJars)\n            .map(\n                x -> {\n                  try {\n                    return x.toURI().toURL();\n                  } catch (MalformedURLException e) {\n                    e.printStackTrace();\n                    return null;\n                  }\n                })\n            .toArray(URL[]::new);\n\n    File[] libraryJars =\n        compilerJarSet.stream()\n            .filter(\n                x ->\n                    x.getArtifactId().contains(\"scala3-library\")\n                        || x.getArtifactId().contains(\"scala-library\"))\n            .map(x -> x.getFile())\n            .toArray(File[]::new);\n\n    URL[] libraryJarUrls =\n        Stream.of(libraryJars)\n            .map(\n                x -> {\n                  try {\n                    return x.toURI().toURL();\n                  } catch (MalformedURLException e) {\n                    e.printStackTrace();\n                    return null;\n                  }\n                })\n            .toArray(URL[]::new);\n\n    ArrayList<File> allJars = new ArrayList<>();\n    allJars.addAll(Arrays.asList(compilerJars));\n    allJars.addAll(Arrays.asList(libraryJars));\n\n    File[] allJarFiles = allJars.stream().toArray(File[]::new);\n    URLClassLoader loaderLibraryOnly =\n        new Scala3CompilerLoader(libraryJarUrls, xsbti.Reporter.class.getClassLoader());\n    URLClassLoader loaderCompilerOnly = new URLClassLoader(compilerJarUrls, loaderLibraryOnly);\n    URLClassLoader loader = loaderCompilerOnly;\n\n    return new ScalaInstance(\n        scalaVersion.toString(),\n        loader,\n        loaderCompilerOnly,\n        loaderLibraryOnly,\n        libraryJars,\n        compilerJars,\n        allJarFiles,\n        Option.apply(scalaVersion.toString()));\n  }\n\n  // Incremental compilation\n  private int incrementalCompile(\n      Set<String> classpathElements,\n      List<File> sourceRootDirs,\n      File outputDir,\n      File cacheFile,\n      boolean compileInLoop)\n      throws Exception {\n    List<File> sources = findSourceWithFilters(sourceRootDirs);\n    if (sources.isEmpty()) {\n      return -1;\n    }\n\n    // TODO - Do we really need this duplicated here?\n    if (!outputDir.exists()) {\n      outputDir.mkdirs();\n    }\n\n    if (incremental == null) {\n      File libraryJar = getLibraryJar();\n      List<File> extraJars = getCompilerDependencies();\n      extraJars.remove(libraryJar);\n      File javaHome = JavaLocator.findHomeFromToolchain(getToolchain());\n      VersionNumber versionNumber = findScalaVersion();\n      ScalaInstance instance =\n          versionNumber.major == 3\n              ? getScalaInstanceForS3(versionNumber)\n              : getScalaInstanceForS2(\n                  libraryJar, getReflectJar(), getCompilerJar(), findScalaVersion(), extraJars);\n\n      incremental =\n          new SbtIncrementalCompiler(\n              javaHome.toPath(),\n              new MavenArtifactResolver(factory, session),\n              secondaryCacheDir,\n              getLog(),\n              cacheFile,\n              compileOrder,\n              instance);\n    }\n\n    classpathElements.remove(outputDir.getAbsolutePath());\n    List<String> scalacOptions = getScalaOptions();\n    List<String> javacOptions = getJavacOptions();\n\n    try {\n      incremental.compile(\n          classpathElements,\n          sources.stream().map(File::toPath).collect(Collectors.toList()),\n          outputDir.toPath(),\n          scalacOptions,\n          javacOptions);\n    } catch (xsbti.CompileFailed e) {\n      if (compileInLoop) {\n        compileErrors = true;\n      } else {\n        throw e;\n      }\n    }\n\n    return 1;\n  }\n}\n","lineNo":411}
{"Smelly Sample":"\n/*\n * Copyright 2011-2020 scala-maven-plugin project (https://davidb.github.io/scala-maven-plugin/)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage scala_maven;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.ArtifactUtils;\nimport org.apache.maven.artifact.factory.ArtifactFactory;\nimport org.apache.maven.artifact.metadata.ArtifactMetadataSource;\nimport org.apache.maven.artifact.repository.ArtifactRepository;\nimport org.apache.maven.artifact.resolver.ArtifactCollector;\nimport org.apache.maven.artifact.resolver.ArtifactResolutionRequest;\nimport org.apache.maven.artifact.resolver.ArtifactResolver;\nimport org.apache.maven.artifact.resolver.filter.AndArtifactFilter;\nimport org.apache.maven.artifact.resolver.filter.ArtifactFilter;\nimport org.apache.maven.artifact.resolver.filter.ScopeArtifactFilter;\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.model.Dependency;\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugin.MojoFailureException;\nimport org.apache.maven.plugins.annotations.Component;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.project.DefaultProjectBuildingRequest;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.project.MavenProjectBuilder;\nimport org.apache.maven.project.ProjectBuildingRequest;\nimport org.apache.maven.repository.RepositorySystem;\nimport org.apache.maven.shared.dependency.graph.DependencyGraphBuilder;\nimport org.apache.maven.shared.dependency.graph.DependencyNode;\nimport org.apache.maven.shared.dependency.graph.filter.AncestorOrSelfDependencyNodeFilter;\nimport org.apache.maven.shared.dependency.graph.filter.AndDependencyNodeFilter;\nimport org.apache.maven.shared.dependency.graph.filter.DependencyNodeFilter;\nimport org.apache.maven.shared.dependency.graph.traversal.CollectingDependencyNodeVisitor;\nimport org.apache.maven.shared.dependency.graph.traversal.DependencyNodeVisitor;\nimport org.apache.maven.shared.dependency.graph.traversal.FilteringDependencyNodeVisitor;\nimport org.apache.maven.toolchain.Toolchain;\nimport org.apache.maven.toolchain.ToolchainManager;\nimport org.codehaus.plexus.util.StringUtils;\nimport scala_maven_dependency.CheckScalaVersionVisitor;\nimport scala_maven_dependency.ScalaDistroArtifactFilter;\nimport scala_maven_executions.JavaMainCaller;\nimport scala_maven_executions.JavaMainCallerByFork;\nimport scala_maven_executions.JavaMainCallerInProcess;\nimport scala_maven_executions.MainHelper;\n\npublic abstract class ScalaMojoSupport extends AbstractMojo {\n\n  private static final String SCALA_LIBRARY_ARTIFACTID = \"scala-library\";\n  private static final String SCALA_REFLECT_ARTIFACTID = \"scala-reflect\";\n  private static final String SCALA_COMPILER_ARTIFACTID = \"scala-compiler\";\n\n  /** Constant {@link String} for \"pom\". Used to specify the Maven POM artifact type. */\n  protected static final String POM = \"pom\";\n\n  /** Constant {@link String} for \"jar\". Used to specify the Maven JAR artifact type. */\n  static final String JAR = \"jar\";\n\n  /** The maven project. */\n  @Parameter(property = \"project\", required = true, readonly = true)\n  protected MavenProject project;\n\n  /**\n   * The Maven Session Object\n   *\n   * <p>Note: Allows extending for 3rd-party usages\n   */\n  @Parameter(property = \"session\", required = true, readonly = true)\n  protected MavenSession session;\n\n  /** Used to look up Artifacts in the remote repository. */\n  @Component RepositorySystem factory;\n\n  /** Used to look up Artifacts in the remote repository. */\n  @Component private ArtifactResolver resolver;\n\n  /** Location of the local repository. */\n  @Parameter(property = \"localRepository\", readonly = true, required = true)\n  private ArtifactRepository localRepo;\n\n  /** List of Remote Repositories used by the resolver */\n  @Parameter(property = \"project.remoteArtifactRepositories\", readonly = true, required = true)\n  private List<ArtifactRepository> remoteRepos;\n\n  /**\n   * Additional dependencies/jar to add to classpath to run \"scalaClassName\" (scope and optional\n   * field not supported) ex :\n   *\n   * <pre>\n   *    &lt;dependencies&gt;\n   *      &lt;dependency&gt;\n   *        &lt;groupId&gt;org.scala-tools&lt;/groupId&gt;\n   *        &lt;artifactId&gt;scala-compiler-addon&lt;/artifactId&gt;\n   *        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n   *      &lt;/dependency&gt;\n   *    &lt;/dependencies&gt;\n   * <\/pre>\n   */\n  @Parameter protected BasicArtifact[] dependencies;\n\n  /**\n   * Compiler plugin dependencies to use when compiling. ex:\n   *\n   * <pre>\n   * &lt;compilerPlugins&gt;\n   *   &lt;compilerPlugin&gt;\n   *     &lt;groupId&gt;my.scala.plugin&lt;/groupId&gt;\n   *     &lt;artifactId&gt;amazingPlugin&lt;/artifactId&gt;\n   *     &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n   *   &lt;/compilerPlugin&gt;\n   * &lt;/compilerPlugins&gt;\n   * <\/pre>\n   */\n  @Parameter private BasicArtifact[] compilerPlugins;\n\n  /** Jvm Arguments. */\n  @Parameter protected String[] jvmArgs;\n\n  /** compiler additional arguments */\n  @Parameter protected String[] args;\n\n  /**\n   * Additional parameter to use to call the main class. Use this parameter only from command line\n   * (\"-DaddScalacArgs=arg1|arg2|arg3|...\"), not from pom.xml. To define compiler arguments in\n   * pom.xml see the \"args\" parameter.\n   */\n  @Parameter(property = \"addScalacArgs\")\n  private String addScalacArgs;\n\n  /** className (FQN) of the scala tool to provide as */\n  @Parameter(\n      required = true,\n      property = \"maven.scala.className\",\n      defaultValue = \"scala.tools.nsc.Main\")\n  protected String scalaClassName;\n\n  /** Scala 's version to use. (property 'maven.scala.version' replaced by 'scala.version') */\n  @Parameter(property = \"scala.version\")\n  private String scalaVersion;\n\n  /**\n   * Organization/group ID of the Scala used in the project. Default value is 'org.scala-lang'. This\n   * is an advanced setting used for clones of the Scala Language. It should be disregarded in\n   * standard use cases.\n   */\n  @Parameter(property = \"scala.organization\", defaultValue = \"org.scala-lang\")\n  private String scalaOrganization;\n\n  public String getScalaOrganization() {\n    return scalaOrganization;\n  }\n\n  /**\n   * Scala 's version to use to check binary compatibility (like suffix in artifactId of\n   * dependency). If it is defined then it is used to checkMultipleScalaVersions\n   */\n  @Parameter(property = \"scala.compat.version\")\n  private String scalaCompatVersion;\n\n  /** Path to Scala installation to use instead of the artifact (define as dependencies). */\n  @Parameter(property = \"scala.home\")\n  private String scalaHome;\n\n  /** Arguments for javac (when using incremental compiler). */\n  @Parameter(property = \"javacArgs\")\n  protected String[] javacArgs;\n\n  /**\n   * Whether to instruct javac to generate debug symbols (when using incremental compiler)\n   *\n   * @see <a href=\n   *     \"http://maven.apache.org/plugins/maven-compiler-plugin/compile-mojo.html#debug\">://maven.apache.org/plugins/maven-compiler-plugin/compile-mojo.html#debug<\/a>\n   */\n  @Parameter(property = \"javacGenerateDebugSymbols\", defaultValue = \"true\")\n  protected boolean javacGenerateDebugSymbols = true;\n\n  /**\n   * Alternative method for specifying javac arguments (when using incremental compiler). Can be\n   * used from command line with -DaddJavacArgs=arg1|arg2|arg3|... rather than in pom.xml.\n   */\n  @Parameter(property = \"addJavacArgs\")\n  protected String addJavacArgs;\n\n  /** The -source argument for the Java compiler (when using incremental compiler). */\n  @Parameter(property = \"maven.compiler.source\")\n  protected String source;\n\n  /** The -target argument for the Java compiler (when using incremental compiler). */\n  @Parameter(property = \"maven.compiler.target\")\n  protected String target;\n\n  /** The -encoding argument for the Java compiler. (when using incremental compiler). */\n  @Parameter(property = \"project.build.sourceEncoding\", defaultValue = \"UTF-8\")\n  protected String encoding;\n\n  /**\n   * Display the command line called ? (property 'maven.scala.displayCmd' replaced by 'displayCmd')\n   */\n  @Parameter(property = \"displayCmd\", defaultValue = \"false\", required = true)\n  public boolean displayCmd;\n\n  /** Forks the execution of scalac into a separate process. */\n  @Parameter(defaultValue = \"true\")\n  protected boolean fork = true;\n\n  /** Force the use of an external ArgFile to run any forked process. */\n  @Parameter(defaultValue = \"false\")\n  protected boolean forceUseArgFile = false;\n\n  /** Check if every dependencies use the same version of scala-library or scala.compat.version. */\n  @Parameter(property = \"maven.scala.checkConsistency\", defaultValue = \"true\")\n  protected boolean checkMultipleScalaVersions;\n\n  /**\n   * Determines if a detection of multiple scala versions in the dependencies will cause the build\n   * to fail.\n   */\n  @Parameter(defaultValue = \"false\")\n  protected boolean failOnMultipleScalaVersions = false;\n\n  /**\n   * Should use CanonicalPath to normalize path (true =&gt; getCanonicalPath, false =&gt;\n   * getAbsolutePath)\n   *\n   * @see <a href=\n   *     \"https://github.com/davidB/scala-maven-plugin/issues/50\">https://github.com/davidB/scala-maven-plugin/issues/50<\/a>\n   */\n  @Parameter(property = \"maven.scala.useCanonicalPath\", defaultValue = \"true\")\n  protected boolean useCanonicalPath = true;\n\n  /** Artifact factory, needed to download source jars. */\n  @Component protected MavenProjectBuilder mavenProjectBuilder;\n\n  /** The artifact repository to use. */\n  @Parameter(property = \"localRepository\", required = true, readonly = true)\n  private ArtifactRepository localRepository;\n\n  /** The artifact factory to use. */\n  @Component private ArtifactFactory artifactFactory;\n\n  /** The artifact metadata source to use. */\n  @Component private ArtifactMetadataSource artifactMetadataSource;\n\n  /** The artifact collector to use. */\n  @Component private ArtifactCollector artifactCollector;\n\n  /** The dependency tree builder to use. */\n  @Component private DependencyGraphBuilder dependencyGraphBuilder;\n\n  /** The toolchain manager to use. */\n  @Component protected ToolchainManager toolchainManager;\n\n  /** List of artifacts to run plugin */\n  @Parameter(defaultValue = \"${plugin.artifacts}\")\n  private List<Artifact> pluginArtifacts;\n\n  private VersionNumber _scalaVersionN;\n\n  /**\n   * Constructs an {@link Artifact} for Scala Compiler.\n   *\n   * @param scalaVersion the version of the Scala Compiler/Library we are using for this execution.\n   * @return a {@link Artifact} for the Scala Compiler.\n   */\n  final Artifact scalaCompilerArtifact(String scalaVersion) {\n    return factory.createArtifact(\n        getScalaOrganization(),\n        ScalaMojoSupport.SCALA_COMPILER_ARTIFACTID,\n        scalaVersion,\n        \"\",\n        ScalaMojoSupport.POM);\n  }\n\n  /**\n   * This method resolves all transitive dependencies of an artifact.\n   *\n   * @param artifact the {@link Artifact} used to retrieve dependencies.\n   * @return resolved {@link Set} of dependencies.\n   */\n  final Set<Artifact> resolveArtifactDependencies(final Artifact artifact) {\n    final AndArtifactFilter filter = new AndArtifactFilter();\n    filter.add(new ScopeArtifactFilter(Artifact.SCOPE_TEST));\n    filter.add(art -> !art.isOptional());\n\n    // Use the collection filter as the resolution filter.\n    return resolveDependencyArtifacts(artifact, filter, filter);\n  }\n\n  /**\n   * This method resolves all transitive dependencies of an artifact.\n   *\n   * @param artifact the {@link Artifact} used to retrieve dependencies.\n   * @param collectionFilter an {@link ArtifactFilter} used to determine which members dependency\n   *     graph should be downloaded.\n   * @param resolutionFilter an {@link ArtifactFilter} used to determine which members of the\n   *     dependency graph should be included in resolution.\n   * @return resolved {@link Set} of dependencies.\n   */\n  private Set<Artifact> resolveDependencyArtifacts(\n      final Artifact artifact,\n      final ArtifactFilter collectionFilter,\n      final ArtifactFilter resolutionFilter) {\n    return resolveDependencyArtifacts(\n        artifact, collectionFilter, resolutionFilter, this.remoteRepos, this.localRepo);\n  }\n\n  /**\n   * This method resolves all transitive dependencies of an artifact.\n   *\n   * @param artifact the {@link Artifact} used to retrieve dependencies.\n   * @param collectionFilter an {@link ArtifactFilter} used to determine which members of the\n   *     dependency graph should be included in resolution.\n   * @param resolutionFilter an {@link ArtifactFilter} used to determine which members of the\n   *     dependency graph should be included in resolution.\n   * @param remoteRepositories a {@link List} of remote {@link ArtifactRepository} values to used\n   *     for dependency resolution of the provided {@link Artifact}.\n   * @param localRepository the local {@link ArtifactRepository} to use for dependency resolution of\n   *     the given {@link Artifact}.\n   * @return resolved {@link Set} of dependencies.\n   */\n  private Set<Artifact> resolveDependencyArtifacts(\n      final Artifact artifact,\n      final ArtifactFilter collectionFilter,\n      final ArtifactFilter resolutionFilter,\n      final List<ArtifactRepository> remoteRepositories,\n      final ArtifactRepository localRepository) {\n    final ArtifactResolutionRequest arr =\n        this.createArtifactResolutionRequest(\n            artifact, collectionFilter, resolutionFilter, remoteRepositories, localRepository);\n\n    // TODO follow the dependenciesManagement and override rules\n    return factory.resolve(arr).getArtifacts();\n  }\n\n  /**\n   * Create a {@link ArtifactResolutionRequest}.\n   *\n   * @param artifact the {@link Artifact} used to retrieve dependencies.\n   * @param collectionFilter an {@link ArtifactFilter} used to determine which members dependency\n   *     graph should be downloaded.\n   * @param resolutionFilter an {@link ArtifactFilter} used to determine which members of the\n   *     dependency graph should be included in resolution\n   * @param remoteRepositories a {@link List} of remote {@link ArtifactRepository} values to used\n   *     for dependency resolution of the provided {@link Artifact}.\n   * @param localRepository the local {@link ArtifactRepository} to use for dependency resolution of\n   *     the given {@link Artifact}.\n   * @return an {@link ArtifactResolutionRequest}, typically used for dependency resolution requests\n   *     against an {@link ArtifactResolver}.\n   */\n  private ArtifactResolutionRequest createArtifactResolutionRequest(\n      final Artifact artifact,\n      final ArtifactFilter collectionFilter,\n      final ArtifactFilter resolutionFilter,\n      final List<ArtifactRepository> remoteRepositories,\n      final ArtifactRepository localRepository) {\n    final ArtifactResolutionRequest arr = new ArtifactResolutionRequest();\n\n    arr.setArtifact(artifact);\n    arr.setCollectionFilter(collectionFilter);\n    arr.setResolutionFilter(resolutionFilter);\n    arr.setResolveRoot(false);\n    arr.setResolveTransitively(true);\n    arr.setRemoteRepositories(remoteRepositories);\n    arr.setLocalRepository(localRepository);\n\n    return arr;\n  }\n\n  private void addToClasspath(\n      String groupId, String artifactId, String version, Set<String> classpath) throws Exception {\n    addToClasspath(groupId, artifactId, version, classpath, true);\n  }\n\n  private void addToClasspath(\n      String groupId,\n      String artifactId,\n      String version,\n      Set<String> classpath,\n      boolean addDependencies)\n      throws Exception {\n    addToClasspath(\n        factory.createArtifact(\n            groupId, artifactId, version, Artifact.SCOPE_RUNTIME, ScalaMojoSupport.JAR),\n        classpath,\n        addDependencies);\n  }\n\n  /**\n   * added for classifier support.\n   *\n   * @author Christoph Radig\n   * @todo might want to merge with existing \"addToClasspath\" methods.\n   */\n  private void addToClasspath(\n      String groupId,\n      String artifactId,\n      String version,\n      String classifier,\n      Set<String> classpath,\n      boolean addDependencies)\n      throws Exception {\n    Dependency d = new Dependency();\n    d.setGroupId(groupId);\n    d.setArtifactId(artifactId);\n    d.setVersion(version);\n    d.setType(ScalaMojoSupport.JAR);\n    d.setClassifier(classifier);\n    d.setScope(Artifact.SCOPE_RUNTIME);\n    addToClasspath(factory.createDependencyArtifact(d), classpath, addDependencies);\n  }\n\n  void addToClasspath(Artifact artifact, Set<String> classpath, boolean addDependencies)\n      throws Exception {\n    resolver.resolve(artifact, remoteRepos, localRepo);\n    classpath.add(FileUtils.pathOf(artifact.getFile(), useCanonicalPath));\n    if (addDependencies) {\n      for (Artifact dep : resolveArtifactDependencies(artifact)) {\n        addToClasspath(dep, classpath, addDependencies);\n      }\n    }\n  }\n\n  void addCompilerToClasspath(Set<String> classpath) throws Exception {\n    classpath.add(FileUtils.pathOf(getCompilerJar(), useCanonicalPath));\n    for (File dep : getCompilerDependencies()) {\n      classpath.add(FileUtils.pathOf(dep, useCanonicalPath));\n    }\n  }\n\n  void addLibraryToClasspath(Set<String> classpath) throws Exception {\n    classpath.add(FileUtils.pathOf(getLibraryJar(), useCanonicalPath));\n  }\n\n  @Override\n  public void execute() throws MojoExecutionException, MojoFailureException {\n    try {\n      String oldWay = System.getProperty(\"maven.scala.version\");\n      if (oldWay != null) {\n        getLog().warn(\"using 'maven.scala.version' is deprecated, use 'scala.version' instead\");\n        if (scalaVersion != null) {\n          scalaVersion = oldWay;\n        }\n      }\n\n      oldWay = System.getProperty(\"maven.scala.displayCmd\");\n      if (oldWay != null) {\n        getLog().warn(\"using 'maven.scala.displayCmd' is deprecated, use 'displayCmd' instead\");\n        displayCmd = displayCmd || Boolean.parseBoolean(oldWay);\n      }\n      checkScalaVersion();\n      doExecute();\n    } catch (MojoExecutionException exc) {\n      throw exc;\n    } catch (MojoFailureException | RuntimeException exc) {\n      throw exc;\n    } catch (Exception exc) {\n      throw new MojoExecutionException(\"wrap: \" + exc, exc);\n    }\n  }\n\n  protected List<Dependency> getDependencies() {\n    return project.getCompileDependencies();\n  }\n\n  VersionNumber findScalaVersion() throws Exception {\n    if (_scalaVersionN == null) {\n      String detectedScalaVersion = scalaVersion;\n      if (StringUtils.isEmpty(detectedScalaVersion)) {\n        detectedScalaVersion = findScalaVersionFromDependencies();\n      }\n      if (StringUtils.isEmpty(detectedScalaVersion)) {\n        if (!ScalaMojoSupport.POM.equals(project.getPackaging().toLowerCase())) {\n          String error =\n              getScalaOrganization()\n                  + \":\"\n                  + SCALA_LIBRARY_ARTIFACTID\n                  + \" is missing from project dependencies\";\n          getLog().error(error);\n          throw new UnsupportedOperationException(error);\n        }\n      } else {\n        // grappy hack to retrieve the SNAPSHOT version without timestamp,...\n        // because if version is -SNAPSHOT and artifact is deploy with uniqueValue then\n        // the version\n        // get from dependency is with the timestamp and a build number (the resolved\n        // version)\n        // but scala-compiler with the same version could have different resolved\n        // version (timestamp,...)\n        boolean isSnapshot = ArtifactUtils.isSnapshot(detectedScalaVersion);\n        if (isSnapshot && !detectedScalaVersion.endsWith(\"-SNAPSHOT\")) {\n          detectedScalaVersion =\n              detectedScalaVersion.substring(\n                      0,\n                      detectedScalaVersion.lastIndexOf(\n                          '-', detectedScalaVersion.lastIndexOf('-') - 1))\n                  + \"-SNAPSHOT\";\n        }\n      }\n      if (StringUtils.isEmpty(detectedScalaVersion)) {\n        throw new MojoFailureException(\"no scalaVersion detected or set\");\n      }\n      if (StringUtils.isNotEmpty(scalaVersion)) {\n        if (!scalaVersion.equals(detectedScalaVersion)) {\n          getLog()\n              .warn(\n                  \"scala library version define in dependencies doesn't match the scalaVersion of the plugin\");\n        }\n        // getLog().info(\"suggestion: remove the scalaVersion from pom.xml\");\n        // //scalaVersion could be define in a parent pom where lib is not required\n      }\n      _scalaVersionN = new VersionNumber(detectedScalaVersion);\n    }\n    return _scalaVersionN;\n  }\n\n  private String findScalaVersionFromDependencies() {\n    return findVersionFromDependencies(getScalaOrganization(), SCALA_LIBRARY_ARTIFACTID);\n  }\n\n  // TODO refactor to do only one scan of dependencies to find version\n  private String findVersionFromDependencies(String groupId, String artifactId) {\n    String version = null;\n    for (Dependency dep : getDependencies()) {\n      if (groupId.equals(dep.getGroupId()) && artifactId.equals(dep.getArtifactId())) {\n        version = dep.getVersion();\n      }\n    }\n    if (StringUtils.isEmpty(version)) {\n      List<Dependency> deps = new ArrayList<>();\n      deps.addAll(project.getModel().getDependencies());\n      if (project.getModel().getDependencyManagement() != null) {\n        deps.addAll(project.getModel().getDependencyManagement().getDependencies());\n      }\n      for (Dependency dep : deps) {\n        if (groupId.equals(dep.getGroupId()) && artifactId.equals(dep.getArtifactId())) {\n          version = dep.getVersion();\n        }\n      }\n    }\n    return version;\n  }\n\n  void checkScalaVersion() throws Exception {\n    String sv = findScalaVersion().toString();\n    if (StringUtils.isNotEmpty(scalaHome)) {\n      getLog()\n          .warn(\n              String.format(\n                  \"local scala-library.jar and scala-compiler.jar from scalaHome(%s) used instead of scala %s\",\n                  scalaHome, sv));\n    }\n    if (checkMultipleScalaVersions) {\n      checkCorrectVersionsOfScalaLibrary(sv);\n    }\n  }\n\n  /**\n   * this method checks to see if there are multiple versions of the scala library\n   *\n   * @throws Exception\n   */\n  private void checkCorrectVersionsOfScalaLibrary(String scalaDefVersion) throws Exception {\n    getLog().debug(\"Checking for multiple versions of scala\");\n    // TODO - Make sure we handle bad artifacts....\n    // TODO: note that filter does not get applied due to MNG-3236\n    VersionNumber sv = new VersionNumber(scalaDefVersion);\n    VersionNumber requiredScalaVersion =\n        StringUtils.isNotEmpty(scalaCompatVersion) ? new VersionNumberMask(scalaCompatVersion) : sv;\n    if (requiredScalaVersion.compareTo(sv) != 0) {\n      String msg =\n          String.format(\n              \"Scala library detected %s doesn't match scala.compat.version : %s\",\n              sv, requiredScalaVersion);\n      if (failOnMultipleScalaVersions) {\n        getLog().error(msg);\n        throw new MojoFailureException(msg);\n      }\n      getLog().warn(msg);\n    }\n    ProjectBuildingRequest request =\n        new DefaultProjectBuildingRequest(session.getProjectBuildingRequest());\n    request.setProject(project);\n    checkArtifactForScalaVersion(\n        requiredScalaVersion, dependencyGraphBuilder.buildDependencyGraph(request, null));\n  }\n\n  /** Visits a node (and all dependencies) to see if it contains duplicate scala versions */\n  private void checkArtifactForScalaVersion(\n      VersionNumber requiredScalaVersion, DependencyNode rootNode) throws Exception {\n    final CheckScalaVersionVisitor visitor =\n        new CheckScalaVersionVisitor(requiredScalaVersion, getLog(), getScalaOrganization());\n\n    CollectingDependencyNodeVisitor collectingVisitor = new CollectingDependencyNodeVisitor();\n    DependencyNodeVisitor firstPassVisitor =\n        new FilteringDependencyNodeVisitor(collectingVisitor, createScalaDistroDependencyFilter());\n    rootNode.accept(firstPassVisitor);\n\n    DependencyNodeFilter secondPassFilter =\n        new AncestorOrSelfDependencyNodeFilter(collectingVisitor.getNodes());\n    DependencyNodeVisitor filteredVisitor =\n        new FilteringDependencyNodeVisitor(visitor, secondPassFilter);\n\n    rootNode.accept(filteredVisitor);\n\n    if (visitor.isFailed()) {\n      visitor.logScalaDependents();\n      if (failOnMultipleScalaVersions) {\n        getLog().error(\"Multiple versions of scala libraries detected!\");\n        throw new MojoFailureException(\"Multiple versions of scala libraries detected!\");\n      }\n      getLog().warn(\"Multiple versions of scala libraries detected!\");\n    }\n  }\n\n  /** @return A filter to only extract artifacts deployed from scala distributions */\n  private DependencyNodeFilter createScalaDistroDependencyFilter() {\n    List<DependencyNodeFilter> filters = new ArrayList<>();\n    filters.add(new ScalaDistroArtifactFilter(getScalaOrganization()));\n    return new AndDependencyNodeFilter(filters);\n  }\n\n  protected abstract void doExecute() throws Exception;\n\n  protected JavaMainCaller getScalaCommand() throws Exception {\n    return getScalaCommand(fork, scalaClassName);\n  }\n\n  /**\n   * Get a {@link JavaMainCaller} used invoke a Java process. Typically this will be one of the\n   * Scala utilities (Compiler, ScalaDoc, REPL, etc.).\n   *\n   * <p>This method does some setup on the {@link JavaMainCaller} which is not done by merely\n   * invoking {@code new} on one of the implementations. Specifically, it adds any Scala compiler\n   * plugin options, JVM options, and Scalac options defined on the plugin.\n   *\n   * @param forkOverride override the setting for {@link #fork}. Currently this should only be set\n   *     if you are invoking the REPL.\n   * @param mainClass the JVM main class to invoke.\n   * @return a {@link JavaMainCaller} to use to invoke the given command.\n   */\n  final JavaMainCaller getScalaCommand(final boolean forkOverride, final String mainClass)\n      throws Exception {\n    JavaMainCaller cmd = getEmptyScalaCommand(mainClass, forkOverride);\n    cmd.addArgs(args);\n    if (StringUtils.isNotEmpty(addScalacArgs)) {\n      cmd.addArgs(StringUtils.split(addScalacArgs, \"|\"));\n    }\n    addCompilerPluginOptions(cmd);\n    cmd.addJvmArgs(jvmArgs);\n    return cmd;\n  }\n\n  /**\n   * Get a {@link JavaMainCaller} used invoke a Java process. Typically this will be one of the\n   * Scala utilities (Compiler, ScalaDoc, REPL, etc.).\n   *\n   * @param mainClass the JVM main class to invoke.\n   * @return a {@link JavaMainCaller} to use to invoke the given command.\n   */\n  final JavaMainCaller getEmptyScalaCommand(final String mainClass) throws Exception {\n    return getEmptyScalaCommand(mainClass, fork);\n  }\n\n  /**\n   * Get a {@link JavaMainCaller} used invoke a Java process. Typically this will be one of the\n   * Scala utilities (Compiler, ScalaDoc, REPL, etc.).\n   *\n   * @param mainClass the JVM main class to invoke.\n   * @param forkOverride override the setting for {@link #fork}. Currently this should only be set\n   *     if you are invoking the REPL.\n   * @return a {@link JavaMainCaller} to use to invoke the given command.\n   */\n  private JavaMainCaller getEmptyScalaCommand(final String mainClass, final boolean forkOverride)\n      throws Exception {\n\n    // If we are deviating from the plugin settings, let the user know\n    // what's going on.\n    if (forkOverride != fork) {\n      super.getLog().info(\"Fork behavior overridden\");\n      super.getLog()\n          .info(String.format(\"Fork for this execution is %s.\", String.valueOf(forkOverride)));\n    }\n\n    // TODO - Fork or not depending on configuration?\n    JavaMainCaller cmd;\n    String toolcp = getToolClasspath();\n    if (forkOverride) {\n      // HACK (better may need refactor)\n      boolean bootcp = true;\n      if (args != null) {\n        for (String arg : args) {\n          bootcp = bootcp && !\"-nobootcp\".equals(arg);\n        }\n      }\n      String cp = bootcp ? \"\" : toolcp;\n      bootcp =\n          bootcp && !(StringUtils.isNotEmpty(addScalacArgs) && addScalacArgs.contains(\"-nobootcp\"));\n      // scalac with args in files\n      // * works only since 2.8.0\n      // * is buggy (don't manage space in path on windows)\n      getLog().debug(\"use java command with args in file forced : \" + forceUseArgFile);\n      cmd =\n          new JavaMainCallerByFork(\n              this, mainClass, cp, null, null, forceUseArgFile, getToolchain());\n      if (bootcp) {\n        cmd.addJvmArgs(\"-Xbootclasspath/a:\" + toolcp);\n      }\n    } else {\n      cmd = new JavaMainCallerInProcess(this, mainClass, toolcp, null, null);\n    }\n    return cmd;\n  }\n\n  protected Toolchain getToolchain() {\n    return toolchainManager.getToolchainFromBuildContext(\"jdk\", session);\n  }\n\n  private String getToolClasspath() throws Exception {\n    Set<String> classpath = new LinkedHashSet<>();\n    addLibraryToClasspath(classpath);\n    addCompilerToClasspath(classpath);\n    if (dependencies != null) {\n      for (BasicArtifact artifact : dependencies) {\n        addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, classpath);\n      }\n    }\n    return MainHelper.toMultiPath(classpath.toArray(new String[] {}));\n  }\n\n  protected List<String> getScalaOptions() throws Exception {\n    List<String> options = new ArrayList<>();\n    if (args != null) Collections.addAll(options, args);\n    if (StringUtils.isNotEmpty(addScalacArgs)) {\n      Collections.addAll(options, StringUtils.split(addScalacArgs, \"|\"));\n    }\n    options.addAll(getCompilerPluginOptions());\n    return options;\n  }\n\n  protected List<String> getJavacOptions() {\n    List<String> options = new ArrayList<>();\n    if (javacArgs != null) Collections.addAll(options, javacArgs);\n    if (StringUtils.isNotEmpty(addJavacArgs)) {\n      Collections.addAll(options, StringUtils.split(addJavacArgs, \"|\"));\n    }\n\n    // issue #116\n    if (javacGenerateDebugSymbols) {\n      options.add(\"-g\");\n    }\n    if (target != null && !target.isEmpty()) {\n      options.add(\"-target\");\n      options.add(target);\n    }\n    if (source != null && !source.isEmpty()) {\n      options.add(\"-source\");\n      options.add(source);\n    }\n    if (encoding != null) {\n      options.add(\"-encoding\");\n      options.add(encoding);\n    }\n    return options;\n  }\n\n  protected File getLibraryJar() throws Exception {\n    if (StringUtils.isNotEmpty(scalaHome)) {\n      File lib = new File(scalaHome, \"lib\");\n      return new File(lib, SCALA_LIBRARY_ARTIFACTID + \".jar\");\n    }\n    return getArtifactJar(\n        getScalaOrganization(), SCALA_LIBRARY_ARTIFACTID, findScalaVersion().toString());\n  }\n\n  protected File getReflectJar() throws Exception {\n    if (StringUtils.isNotEmpty(scalaHome)) {\n      File lib = new File(scalaHome, \"lib\");\n      return new File(lib, SCALA_REFLECT_ARTIFACTID + \".jar\");\n    }\n    return getArtifactJar(\n        getScalaOrganization(), SCALA_REFLECT_ARTIFACTID, findScalaVersion().toString());\n  }\n\n  protected File getCompilerJar() throws Exception {\n    if (StringUtils.isNotEmpty(scalaHome)) {\n      File lib = new File(scalaHome, \"lib\");\n      return new File(lib, SCALA_COMPILER_ARTIFACTID + \".jar\");\n    }\n    return getArtifactJar(\n        getScalaOrganization(), SCALA_COMPILER_ARTIFACTID, findScalaVersion().toString());\n  }\n\n  protected List<File> getCompilerDependencies() throws Exception {\n    List<File> d = new ArrayList<>();\n    if (StringUtils.isEmpty(scalaHome)) {\n      for (Artifact artifact :\n          getAllDependencies(\n              getScalaOrganization(), SCALA_COMPILER_ARTIFACTID, findScalaVersion().toString())) {\n        d.add(artifact.getFile());\n      }\n    } else {\n      for (File f : new File(scalaHome, \"lib\").listFiles()) {\n        String name = f.getName();\n        if (name.endsWith(\".jar\")\n            && !name.contains(\"scala-library\")\n            && !name.contains(\"scala-compiler\")) {\n          d.add(f);\n        }\n      }\n    }\n    return d;\n  }\n\n  protected File getArtifactJar(String groupId, String artifactId, String version)\n      throws Exception {\n    Artifact artifact =\n        factory.createArtifact(\n            groupId, artifactId, version, Artifact.SCOPE_RUNTIME, ScalaMojoSupport.JAR);\n    resolver.resolve(artifact, remoteRepos, localRepo);\n    return artifact.getFile();\n  }\n\n  private Set<Artifact> getAllDependencies(String groupId, String artifactId, String version) {\n    Set<Artifact> result = new HashSet<>();\n    Artifact pom = factory.createArtifact(groupId, artifactId, version, \"\", ScalaMojoSupport.POM);\n    Set<Artifact> d = resolveArtifactDependencies(pom);\n    result.addAll(d);\n    for (Artifact dependency : d) {\n      Set<Artifact> transitive =\n          getAllDependencies(\n              dependency.getGroupId(), dependency.getArtifactId(), dependency.getVersion());\n      result.addAll(transitive);\n    }\n    return result;\n  }\n\n  /**\n   * @return This returns whether or not the scala version can support having java sent into the\n   *     compiler\n   */\n  protected boolean isJavaSupportedByCompiler() throws Exception {\n    return findScalaVersion().compareTo(new VersionNumber(\"2.7.2\")) >= 0;\n  }\n\n  /**\n   * Adds appropriate compiler plugins to the scalac command.\n   *\n   * @param scalac\n   * @throws Exception\n   */\n  protected void addCompilerPluginOptions(JavaMainCaller scalac) throws Exception {\n    for (String option : getCompilerPluginOptions()) {\n      scalac.addArgs(option);\n    }\n  }\n\n  private List<String> getCompilerPluginOptions() throws Exception {\n    List<String> options = new ArrayList<>();\n    for (String plugin : getCompilerPlugins()) {\n      options.add(\"-Xplugin:\" + plugin);\n    }\n    return options;\n  }\n\n  /**\n   * Retrieves a list of paths to scala compiler plugins.\n   *\n   * @return The list of plugins\n   * @throws Exception\n   */\n  private Set<String> getCompilerPlugins() throws Exception {\n    Set<String> plugins = new HashSet<>();\n    if (compilerPlugins != null) {\n      Set<String> ignoreClasspath = new LinkedHashSet<>();\n      addCompilerToClasspath(ignoreClasspath);\n      addLibraryToClasspath(ignoreClasspath);\n      for (BasicArtifact artifact : compilerPlugins) {\n        getLog().info(\"compiler plugin: \" + artifact.toString());\n        // TODO - Ensure proper scala version for plugins\n        Set<String> pluginClassPath = new HashSet<>();\n        // TODO - Pull in transitive dependencies.\n        addToClasspath(\n            artifact.groupId,\n            artifact.artifactId,\n            artifact.version,\n            artifact.classifier,\n            pluginClassPath,\n            false);\n        pluginClassPath.removeAll(ignoreClasspath);\n        plugins.addAll(pluginClassPath);\n      }\n    }\n    return plugins;\n  }\n}\n","Method after Refactoring":"\n/*\n * Copyright 2011-2020 scala-maven-plugin project (https://davidb.github.io/scala-maven-plugin/)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage scala_maven;\n\nimport java.io.File;\nimport java.util.*;\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.ArtifactUtils;\nimport org.apache.maven.artifact.factory.ArtifactFactory;\nimport org.apache.maven.artifact.metadata.ArtifactMetadataSource;\nimport org.apache.maven.artifact.repository.ArtifactRepository;\nimport org.apache.maven.artifact.resolver.ArtifactCollector;\nimport org.apache.maven.artifact.resolver.ArtifactResolutionRequest;\nimport org.apache.maven.artifact.resolver.ArtifactResolver;\nimport org.apache.maven.artifact.resolver.filter.AndArtifactFilter;\nimport org.apache.maven.artifact.resolver.filter.ArtifactFilter;\nimport org.apache.maven.artifact.resolver.filter.ScopeArtifactFilter;\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.model.Dependency;\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugin.MojoFailureException;\nimport org.apache.maven.plugins.annotations.Component;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.project.DefaultProjectBuildingRequest;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.project.MavenProjectBuilder;\nimport org.apache.maven.project.ProjectBuildingRequest;\nimport org.apache.maven.repository.RepositorySystem;\nimport org.apache.maven.shared.dependency.graph.DependencyGraphBuilder;\nimport org.apache.maven.shared.dependency.graph.DependencyNode;\nimport org.apache.maven.shared.dependency.graph.filter.AncestorOrSelfDependencyNodeFilter;\nimport org.apache.maven.shared.dependency.graph.filter.AndDependencyNodeFilter;\nimport org.apache.maven.shared.dependency.graph.filter.DependencyNodeFilter;\nimport org.apache.maven.shared.dependency.graph.traversal.CollectingDependencyNodeVisitor;\nimport org.apache.maven.shared.dependency.graph.traversal.DependencyNodeVisitor;\nimport org.apache.maven.shared.dependency.graph.traversal.FilteringDependencyNodeVisitor;\nimport org.apache.maven.toolchain.Toolchain;\nimport org.apache.maven.toolchain.ToolchainManager;\nimport org.codehaus.plexus.util.StringUtils;\nimport scala_maven_dependency.CheckScalaVersionVisitor;\nimport scala_maven_dependency.ScalaDistroArtifactFilter;\nimport scala_maven_executions.JavaMainCaller;\nimport scala_maven_executions.JavaMainCallerByFork;\nimport scala_maven_executions.JavaMainCallerInProcess;\nimport scala_maven_executions.MainHelper;\n\npublic abstract class ScalaMojoSupport extends AbstractMojo {\n\n  protected static final String SCALA_LIBRARY_ARTIFACTID = \"scala-library\";\n  protected static final String SCALA_REFLECT_ARTIFACTID = \"scala-reflect\";\n  protected static final String SCALA_COMPILER_ARTIFACTID = \"scala-compiler\";\n\n  protected static final String SCALA3_LIBRARY_ARTIFACTID = \"scala3-library\";\n  protected static final String SCALA3_INTERFACES_ARTIFACTID = \"scala3-interfaces\";\n  protected static final String SCALA3_REFLECT_ARTIFACTID = \"scala3-reflect\";\n  protected static final String SCALA3_COMPILER_ARTIFACTID = \"scala3-compiler\";\n\n  /** Constant {@link String} for \"pom\". Used to specify the Maven POM artifact type. */\n  protected static final String POM = \"pom\";\n\n  /** Constant {@link String} for \"jar\". Used to specify the Maven JAR artifact type. */\n  static final String JAR = \"jar\";\n\n  /** The maven project. */\n  @Parameter(property = \"project\", required = true, readonly = true)\n  protected MavenProject project;\n\n  /**\n   * The Maven Session Object\n   *\n   * <p>Note: Allows extending for 3rd-party usages\n   */\n  @Parameter(property = \"session\", required = true, readonly = true)\n  protected MavenSession session;\n\n  /** Used to look up Artifacts in the remote repository. */\n  @Component RepositorySystem factory;\n\n  /** Used to look up Artifacts in the remote repository. */\n  @Component protected ArtifactResolver resolver;\n\n  /** Location of the local repository. */\n  @Parameter(property = \"localRepository\", readonly = true, required = true)\n  private ArtifactRepository localRepo;\n\n  /** List of Remote Repositories used by the resolver */\n  @Parameter(property = \"project.remoteArtifactRepositories\", readonly = true, required = true)\n  private List<ArtifactRepository> remoteRepos;\n\n  /**\n   * Additional dependencies/jar to add to classpath to run \"scalaClassName\" (scope and optional\n   * field not supported) ex :\n   *\n   * <pre>\n   *    &lt;dependencies&gt;\n   *      &lt;dependency&gt;\n   *        &lt;groupId&gt;org.scala-tools&lt;/groupId&gt;\n   *        &lt;artifactId&gt;scala-compiler-addon&lt;/artifactId&gt;\n   *        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n   *      &lt;/dependency&gt;\n   *    &lt;/dependencies&gt;\n   * <\/pre>\n   */\n  @Parameter protected BasicArtifact[] dependencies;\n\n  /**\n   * Compiler plugin dependencies to use when compiling. ex:\n   *\n   * <pre>\n   * &lt;compilerPlugins&gt;\n   *   &lt;compilerPlugin&gt;\n   *     &lt;groupId&gt;my.scala.plugin&lt;/groupId&gt;\n   *     &lt;artifactId&gt;amazingPlugin&lt;/artifactId&gt;\n   *     &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n   *   &lt;/compilerPlugin&gt;\n   * &lt;/compilerPlugins&gt;\n   * <\/pre>\n   */\n  @Parameter private BasicArtifact[] compilerPlugins;\n\n  /** Jvm Arguments. */\n  @Parameter protected String[] jvmArgs;\n\n  /** compiler additional arguments */\n  @Parameter protected String[] args;\n\n  /**\n   * Additional parameter to use to call the main class. Use this parameter only from command line\n   * (\"-DaddScalacArgs=arg1|arg2|arg3|...\"), not from pom.xml. To define compiler arguments in\n   * pom.xml see the \"args\" parameter.\n   */\n  @Parameter(property = \"addScalacArgs\")\n  private String addScalacArgs;\n\n  /** className (FQN) of the scala tool to provide as */\n  @Parameter(\n      required = true,\n      property = \"maven.scala.className\",\n      defaultValue = \"scala.tools.nsc.Main\")\n  protected String scalaClassName;\n\n  /** Scala 's version to use. (property 'maven.scala.version' replaced by 'scala.version') */\n  @Parameter(property = \"scala.version\")\n  private String scalaVersion;\n\n  /**\n   * Organization/group ID of the Scala used in the project. Default value is 'org.scala-lang'. This\n   * is an advanced setting used for clones of the Scala Language. It should be disregarded in\n   * standard use cases.\n   */\n  @Parameter(property = \"scala.organization\", defaultValue = \"org.scala-lang\")\n  private String scalaOrganization;\n\n  public String getScalaOrganization() {\n    return scalaOrganization;\n  }\n\n  /**\n   * Scala 's version to use to check binary compatibility (like suffix in artifactId of\n   * dependency). If it is defined then it is used to checkMultipleScalaVersions\n   */\n  @Parameter(property = \"scala.compat.version\")\n  private String scalaCompatVersion;\n\n  /** Path to Scala installation to use instead of the artifact (define as dependencies). */\n  @Parameter(property = \"scala.home\")\n  private String scalaHome;\n\n  /** Arguments for javac (when using incremental compiler). */\n  @Parameter(property = \"javacArgs\")\n  protected String[] javacArgs;\n\n  /**\n   * Whether to instruct javac to generate debug symbols (when using incremental compiler)\n   *\n   * @see <a href=\n   *     \"http://maven.apache.org/plugins/maven-compiler-plugin/compile-mojo.html#debug\">://maven.apache.org/plugins/maven-compiler-plugin/compile-mojo.html#debug<\/a>\n   */\n  @Parameter(property = \"javacGenerateDebugSymbols\", defaultValue = \"true\")\n  protected boolean javacGenerateDebugSymbols = true;\n\n  /**\n   * Alternative method for specifying javac arguments (when using incremental compiler). Can be\n   * used from command line with -DaddJavacArgs=arg1|arg2|arg3|... rather than in pom.xml.\n   */\n  @Parameter(property = \"addJavacArgs\")\n  protected String addJavacArgs;\n\n  /** The -source argument for the Java compiler (when using incremental compiler). */\n  @Parameter(property = \"maven.compiler.source\")\n  protected String source;\n\n  /** The -target argument for the Java compiler (when using incremental compiler). */\n  @Parameter(property = \"maven.compiler.target\")\n  protected String target;\n\n  /** The -encoding argument for the Java compiler. (when using incremental compiler). */\n  @Parameter(property = \"project.build.sourceEncoding\", defaultValue = \"UTF-8\")\n  protected String encoding;\n\n  /**\n   * Display the command line called ? (property 'maven.scala.displayCmd' replaced by 'displayCmd')\n   */\n  @Parameter(property = \"displayCmd\", defaultValue = \"false\", required = true)\n  public boolean displayCmd;\n\n  /** Forks the execution of scalac into a separate process. */\n  @Parameter(defaultValue = \"true\")\n  protected boolean fork = true;\n\n  /** Force the use of an external ArgFile to run any forked process. */\n  @Parameter(defaultValue = \"false\")\n  protected boolean forceUseArgFile = false;\n\n  /** Check if every dependencies use the same version of scala-library or scala.compat.version. */\n  @Parameter(property = \"maven.scala.checkConsistency\", defaultValue = \"true\")\n  protected boolean checkMultipleScalaVersions;\n\n  /**\n   * Determines if a detection of multiple scala versions in the dependencies will cause the build\n   * to fail.\n   */\n  @Parameter(defaultValue = \"false\")\n  protected boolean failOnMultipleScalaVersions = false;\n\n  /**\n   * Should use CanonicalPath to normalize path (true =&gt; getCanonicalPath, false =&gt;\n   * getAbsolutePath)\n   *\n   * @see <a href=\n   *     \"https://github.com/davidB/scala-maven-plugin/issues/50\">https://github.com/davidB/scala-maven-plugin/issues/50<\/a>\n   */\n  @Parameter(property = \"maven.scala.useCanonicalPath\", defaultValue = \"true\")\n  protected boolean useCanonicalPath = true;\n\n  /** Artifact factory, needed to download source jars. */\n  @Component protected MavenProjectBuilder mavenProjectBuilder;\n\n  /** The artifact repository to use. */\n  @Parameter(property = \"localRepository\", required = true, readonly = true)\n  private ArtifactRepository localRepository;\n\n  /** The artifact factory to use. */\n  @Component private ArtifactFactory artifactFactory;\n\n  /** The artifact metadata source to use. */\n  @Component private ArtifactMetadataSource artifactMetadataSource;\n\n  /** The artifact collector to use. */\n  @Component private ArtifactCollector artifactCollector;\n\n  /** The dependency tree builder to use. */\n  @Component private DependencyGraphBuilder dependencyGraphBuilder;\n\n  /** The toolchain manager to use. */\n  @Component protected ToolchainManager toolchainManager;\n\n  /** List of artifacts to run plugin */\n  @Parameter(defaultValue = \"${plugin.artifacts}\")\n  private List<Artifact> pluginArtifacts;\n\n  private VersionNumber _scalaVersionN;\n\n  /**\n   * Constructs an {@link Artifact} for Scala Compiler.\n   *\n   * @param scalaVersion the version of the Scala Compiler/Library we are using for this execution.\n   * @return a {@link Artifact} for the Scala Compiler.\n   */\n  protected final Artifact scalaCompilerArtifact(String scalaVersion) {\n    return factory.createArtifact(\n        getScalaOrganization(),\n        scalaVersion.startsWith(\"3\")\n            ? SCALA3_COMPILER_ARTIFACTID\n            : ScalaMojoSupport.SCALA_COMPILER_ARTIFACTID,\n        scalaVersion,\n        \"\",\n        ScalaMojoSupport.POM);\n  }\n\n  /**\n   * This method resolves all transitive dependencies of an artifact.\n   *\n   * @param artifact the {@link Artifact} used to retrieve dependencies.\n   * @return resolved {@link Set} of dependencies.\n   */\n  final Set<Artifact> resolveArtifactDependencies(final Artifact artifact) {\n    final AndArtifactFilter filter = new AndArtifactFilter();\n    filter.add(new ScopeArtifactFilter(Artifact.SCOPE_TEST));\n    filter.add(art -> !art.isOptional());\n\n    // Use the collection filter as the resolution filter.\n    return resolveDependencyArtifacts(artifact, filter, filter);\n  }\n\n  /**\n   * This method resolves all transitive dependencies of an artifact.\n   *\n   * @param artifact the {@link Artifact} used to retrieve dependencies.\n   * @param collectionFilter an {@link ArtifactFilter} used to determine which members dependency\n   *     graph should be downloaded.\n   * @param resolutionFilter an {@link ArtifactFilter} used to determine which members of the\n   *     dependency graph should be included in resolution.\n   * @return resolved {@link Set} of dependencies.\n   */\n  private Set<Artifact> resolveDependencyArtifacts(\n      final Artifact artifact,\n      final ArtifactFilter collectionFilter,\n      final ArtifactFilter resolutionFilter) {\n    return resolveDependencyArtifacts(\n        artifact, collectionFilter, resolutionFilter, this.remoteRepos, this.localRepo);\n  }\n\n  /**\n   * This method resolves all transitive dependencies of an artifact.\n   *\n   * @param artifact the {@link Artifact} used to retrieve dependencies.\n   * @param collectionFilter an {@link ArtifactFilter} used to determine which members of the\n   *     dependency graph should be included in resolution.\n   * @param resolutionFilter an {@link ArtifactFilter} used to determine which members of the\n   *     dependency graph should be included in resolution.\n   * @param remoteRepositories a {@link List} of remote {@link ArtifactRepository} values to used\n   *     for dependency resolution of the provided {@link Artifact}.\n   * @param localRepository the local {@link ArtifactRepository} to use for dependency resolution of\n   *     the given {@link Artifact}.\n   * @return resolved {@link Set} of dependencies.\n   */\n  private Set<Artifact> resolveDependencyArtifacts(\n      final Artifact artifact,\n      final ArtifactFilter collectionFilter,\n      final ArtifactFilter resolutionFilter,\n      final List<ArtifactRepository> remoteRepositories,\n      final ArtifactRepository localRepository) {\n    final ArtifactResolutionRequest arr =\n        this.createArtifactResolutionRequest(\n            artifact, collectionFilter, resolutionFilter, remoteRepositories, localRepository);\n\n    // TODO follow the dependenciesManagement and override rules\n    return factory.resolve(arr).getArtifacts();\n  }\n\n  /**\n   * Create a {@link ArtifactResolutionRequest}.\n   *\n   * @param artifact the {@link Artifact} used to retrieve dependencies.\n   * @param collectionFilter an {@link ArtifactFilter} used to determine which members dependency\n   *     graph should be downloaded.\n   * @param resolutionFilter an {@link ArtifactFilter} used to determine which members of the\n   *     dependency graph should be included in resolution\n   * @param remoteRepositories a {@link List} of remote {@link ArtifactRepository} values to used\n   *     for dependency resolution of the provided {@link Artifact}.\n   * @param localRepository the local {@link ArtifactRepository} to use for dependency resolution of\n   *     the given {@link Artifact}.\n   * @return an {@link ArtifactResolutionRequest}, typically used for dependency resolution requests\n   *     against an {@link ArtifactResolver}.\n   */\n  private ArtifactResolutionRequest createArtifactResolutionRequest(\n      final Artifact artifact,\n      final ArtifactFilter collectionFilter,\n      final ArtifactFilter resolutionFilter,\n      final List<ArtifactRepository> remoteRepositories,\n      final ArtifactRepository localRepository) {\n    final ArtifactResolutionRequest arr = new ArtifactResolutionRequest();\n\n    arr.setArtifact(artifact);\n    arr.setCollectionFilter(collectionFilter);\n    arr.setResolutionFilter(resolutionFilter);\n    arr.setResolveRoot(false);\n    arr.setResolveTransitively(true);\n    arr.setRemoteRepositories(remoteRepositories);\n    arr.setLocalRepository(localRepository);\n\n    return arr;\n  }\n\n  private void addToClasspath(\n      String groupId, String artifactId, String version, Set<String> classpath) throws Exception {\n    addToClasspath(groupId, artifactId, version, classpath, true);\n  }\n\n  private void addToClasspath(\n      String groupId,\n      String artifactId,\n      String version,\n      Set<String> classpath,\n      boolean addDependencies)\n      throws Exception {\n    addToClasspath(\n        factory.createArtifact(\n            groupId, artifactId, version, Artifact.SCOPE_RUNTIME, ScalaMojoSupport.JAR),\n        classpath,\n        addDependencies);\n  }\n\n  /**\n   * added for classifier support.\n   *\n   * @author Christoph Radig\n   * @todo might want to merge with existing \"addToClasspath\" methods.\n   */\n  private void addToClasspath(\n      String groupId,\n      String artifactId,\n      String version,\n      String classifier,\n      Set<String> classpath,\n      boolean addDependencies)\n      throws Exception {\n    Dependency d = new Dependency();\n    d.setGroupId(groupId);\n    d.setArtifactId(artifactId);\n    d.setVersion(version);\n    d.setType(ScalaMojoSupport.JAR);\n    d.setClassifier(classifier);\n    d.setScope(Artifact.SCOPE_RUNTIME);\n    addToClasspath(factory.createDependencyArtifact(d), classpath, addDependencies);\n  }\n\n  void addToClasspath(Artifact artifact, Set<String> classpath, boolean addDependencies)\n      throws Exception {\n    resolver.resolve(artifact, remoteRepos, localRepo);\n    classpath.add(FileUtils.pathOf(artifact.getFile(), useCanonicalPath));\n    if (addDependencies) {\n      for (Artifact dep : resolveArtifactDependencies(artifact)) {\n        addToClasspath(dep, classpath, addDependencies);\n      }\n    }\n  }\n\n  void addCompilerToClasspath(Set<String> classpath) throws Exception {\n    classpath.add(FileUtils.pathOf(getCompilerJar(), useCanonicalPath));\n    for (File dep : getCompilerDependencies()) {\n      classpath.add(FileUtils.pathOf(dep, useCanonicalPath));\n    }\n  }\n\n  void addLibraryToClasspath(Set<String> classpath) throws Exception {\n    classpath.add(FileUtils.pathOf(getLibraryJar(), useCanonicalPath));\n  }\n\n  @Override\n  public void execute() throws MojoExecutionException, MojoFailureException {\n    try {\n      String oldWay = System.getProperty(\"maven.scala.version\");\n      if (oldWay != null) {\n        getLog().warn(\"using 'maven.scala.version' is deprecated, use 'scala.version' instead\");\n        if (scalaVersion != null) {\n          scalaVersion = oldWay;\n        }\n      }\n\n      oldWay = System.getProperty(\"maven.scala.displayCmd\");\n      if (oldWay != null) {\n        getLog().warn(\"using 'maven.scala.displayCmd' is deprecated, use 'displayCmd' instead\");\n        displayCmd = displayCmd || Boolean.parseBoolean(oldWay);\n      }\n      checkScalaVersion();\n      doExecute();\n    } catch (MojoExecutionException exc) {\n      throw exc;\n    } catch (MojoFailureException | RuntimeException exc) {\n      throw exc;\n    } catch (Exception exc) {\n      throw new MojoExecutionException(\"wrap: \" + exc, exc);\n    }\n  }\n\n  protected List<Dependency> getDependencies() {\n    return project.getCompileDependencies();\n  }\n\n  VersionNumber findScalaVersion() throws Exception {\n    if (_scalaVersionN == null) {\n      String detectedScalaVersion = scalaVersion;\n      if (StringUtils.isEmpty(detectedScalaVersion)) {\n        detectedScalaVersion = findScalaVersionFromDependencies();\n      }\n      if (StringUtils.isEmpty(detectedScalaVersion)) {\n        if (!ScalaMojoSupport.POM.equals(project.getPackaging())) {\n          String error =\n              getScalaOrganization()\n                  + \":\"\n                  + (_scalaVersionN.major == 3\n                      ? getScala3ArtifactId(SCALA3_LIBRARY_ARTIFACTID)\n                      : SCALA_LIBRARY_ARTIFACTID)\n                  + \" is missing from project dependencies\";\n          getLog().error(error);\n          throw new UnsupportedOperationException(error);\n        }\n      } else {\n        // grappy hack to retrieve the SNAPSHOT version without timestamp,...\n        // because if version is -SNAPSHOT and artifact is deploy with uniqueValue then\n        // the version\n        // get from dependency is with the timestamp and a build number (the resolved\n        // version)\n        // but scala-compiler with the same version could have different resolved\n        // version (timestamp,...)\n        boolean isSnapshot = ArtifactUtils.isSnapshot(detectedScalaVersion);\n        if (isSnapshot && !detectedScalaVersion.endsWith(\"-SNAPSHOT\")) {\n          detectedScalaVersion =\n              detectedScalaVersion.substring(\n                      0,\n                      detectedScalaVersion.lastIndexOf(\n                          '-', detectedScalaVersion.lastIndexOf('-') - 1))\n                  + \"-SNAPSHOT\";\n        }\n      }\n      if (StringUtils.isEmpty(detectedScalaVersion)) {\n        throw new MojoFailureException(\"no scalaVersion detected or set\");\n      }\n      if (StringUtils.isNotEmpty(scalaVersion)) {\n        if (!scalaVersion.equals(detectedScalaVersion)) {\n          getLog()\n              .warn(\n                  \"scala library version define in dependencies doesn't match the scalaVersion of the plugin\");\n        }\n        // getLog().info(\"suggestion: remove the scalaVersion from pom.xml\");\n        // //scalaVersion could be define in a parent pom where lib is not required\n      }\n      _scalaVersionN = new VersionNumber(detectedScalaVersion);\n    }\n    return _scalaVersionN;\n  }\n\n  private String findScalaVersionFromDependencies() {\n    return findVersionFromDependencies(\n        getScalaOrganization(),\n        new HashSet<String>(Arrays.asList(SCALA3_LIBRARY_ARTIFACTID, SCALA_LIBRARY_ARTIFACTID)));\n  }\n\n  // TODO refactor to do only one scan of dependencies to find version\n  private String findVersionFromDependencies(String groupId, Set<String> artifactId) {\n    String version = null;\n    for (Dependency dep : getDependencies()) {\n      if (groupId.equals(dep.getGroupId()) && artifactId.contains(dep.getArtifactId())) {\n        version = dep.getVersion();\n      }\n    }\n    if (StringUtils.isEmpty(version)) {\n      List<Dependency> deps = new ArrayList<>();\n      deps.addAll(project.getModel().getDependencies());\n      if (project.getModel().getDependencyManagement() != null) {\n        deps.addAll(project.getModel().getDependencyManagement().getDependencies());\n      }\n      for (Dependency dep : deps) {\n        if (groupId.equals(dep.getGroupId()) && artifactId.contains(dep.getArtifactId())) {\n          version = dep.getVersion();\n        }\n      }\n    }\n    return version;\n  }\n\n  void checkScalaVersion() throws Exception {\n    String sv = findScalaVersion().toString();\n    if (StringUtils.isNotEmpty(scalaHome)) {\n      getLog()\n          .warn(\n              String.format(\n                  \"local scala-library.jar and scala-compiler.jar from scalaHome(%s) used instead of scala %s\",\n                  scalaHome, sv));\n    }\n    if (checkMultipleScalaVersions) {\n      checkCorrectVersionsOfScalaLibrary(sv);\n    }\n  }\n\n  /**\n   * this method checks to see if there are multiple versions of the scala library\n   *\n   * @throws Exception\n   */\n  private void checkCorrectVersionsOfScalaLibrary(String scalaDefVersion) throws Exception {\n    getLog().debug(\"Checking for multiple versions of scala\");\n    // TODO - Make sure we handle bad artifacts....\n    // TODO: note that filter does not get applied due to MNG-3236\n    VersionNumber sv = new VersionNumber(scalaDefVersion);\n    VersionNumber requiredScalaVersion =\n        StringUtils.isNotEmpty(scalaCompatVersion) ? new VersionNumberMask(scalaCompatVersion) : sv;\n    if (requiredScalaVersion.compareTo(sv) != 0) {\n      String msg =\n          String.format(\n              \"Scala library detected %s doesn't match scala.compat.version : %s\",\n              sv, requiredScalaVersion);\n      if (failOnMultipleScalaVersions) {\n        getLog().error(msg);\n        throw new MojoFailureException(msg);\n      }\n      getLog().warn(msg);\n    }\n    ProjectBuildingRequest request =\n        new DefaultProjectBuildingRequest(session.getProjectBuildingRequest());\n    request.setProject(project);\n    checkArtifactForScalaVersion(\n        requiredScalaVersion, dependencyGraphBuilder.buildDependencyGraph(request, null));\n  }\n\n  /** Visits a node (and all dependencies) to see if it contains duplicate scala versions */\n  private void checkArtifactForScalaVersion(\n      VersionNumber requiredScalaVersion, DependencyNode rootNode) throws Exception {\n    final CheckScalaVersionVisitor visitor =\n        new CheckScalaVersionVisitor(requiredScalaVersion, getLog(), getScalaOrganization());\n\n    CollectingDependencyNodeVisitor collectingVisitor = new CollectingDependencyNodeVisitor();\n    DependencyNodeVisitor firstPassVisitor =\n        new FilteringDependencyNodeVisitor(collectingVisitor, createScalaDistroDependencyFilter());\n    rootNode.accept(firstPassVisitor);\n\n    DependencyNodeFilter secondPassFilter =\n        new AncestorOrSelfDependencyNodeFilter(collectingVisitor.getNodes());\n    DependencyNodeVisitor filteredVisitor =\n        new FilteringDependencyNodeVisitor(visitor, secondPassFilter);\n\n    rootNode.accept(filteredVisitor);\n\n    if (visitor.isFailed()) {\n      visitor.logScalaDependents();\n      if (failOnMultipleScalaVersions) {\n        getLog().error(\"Multiple versions of scala libraries detected!\");\n        throw new MojoFailureException(\"Multiple versions of scala libraries detected!\");\n      }\n      getLog().warn(\"Multiple versions of scala libraries detected!\");\n    }\n  }\n\n  /** @return A filter to only extract artifacts deployed from scala distributions */\n  private DependencyNodeFilter createScalaDistroDependencyFilter() {\n    List<DependencyNodeFilter> filters = new ArrayList<>();\n    filters.add(new ScalaDistroArtifactFilter(getScalaOrganization()));\n    return new AndDependencyNodeFilter(filters);\n  }\n\n  protected abstract void doExecute() throws Exception;\n\n  protected JavaMainCaller getScalaCommand() throws Exception {\n    return getScalaCommand(fork, scalaClassName);\n  }\n\n  /**\n   * Get a {@link JavaMainCaller} used invoke a Java process. Typically this will be one of the\n   * Scala utilities (Compiler, ScalaDoc, REPL, etc.).\n   *\n   * <p>This method does some setup on the {@link JavaMainCaller} which is not done by merely\n   * invoking {@code new} on one of the implementations. Specifically, it adds any Scala compiler\n   * plugin options, JVM options, and Scalac options defined on the plugin.\n   *\n   * @param forkOverride override the setting for {@link #fork}. Currently this should only be set\n   *     if you are invoking the REPL.\n   * @param mainClass the JVM main class to invoke.\n   * @return a {@link JavaMainCaller} to use to invoke the given command.\n   */\n  final JavaMainCaller getScalaCommand(final boolean forkOverride, final String mainClass)\n      throws Exception {\n    JavaMainCaller cmd = getEmptyScalaCommand(mainClass, forkOverride);\n    cmd.addArgs(args);\n    if (StringUtils.isNotEmpty(addScalacArgs)) {\n      cmd.addArgs(StringUtils.split(addScalacArgs, \"|\"));\n    }\n    addCompilerPluginOptions(cmd);\n    cmd.addJvmArgs(jvmArgs);\n    return cmd;\n  }\n\n  /**\n   * Get a {@link JavaMainCaller} used invoke a Java process. Typically this will be one of the\n   * Scala utilities (Compiler, ScalaDoc, REPL, etc.).\n   *\n   * @param mainClass the JVM main class to invoke.\n   * @return a {@link JavaMainCaller} to use to invoke the given command.\n   */\n  final JavaMainCaller getEmptyScalaCommand(final String mainClass) throws Exception {\n    return getEmptyScalaCommand(mainClass, fork);\n  }\n\n  /**\n   * Get a {@link JavaMainCaller} used invoke a Java process. Typically this will be one of the\n   * Scala utilities (Compiler, ScalaDoc, REPL, etc.).\n   *\n   * @param mainClass the JVM main class to invoke.\n   * @param forkOverride override the setting for {@link #fork}. Currently this should only be set\n   *     if you are invoking the REPL.\n   * @return a {@link JavaMainCaller} to use to invoke the given command.\n   */\n  private JavaMainCaller getEmptyScalaCommand(final String mainClass, final boolean forkOverride)\n      throws Exception {\n\n    // If we are deviating from the plugin settings, let the user know\n    // what's going on.\n    if (forkOverride != fork) {\n      super.getLog().info(\"Fork behavior overridden\");\n      super.getLog()\n          .info(String.format(\"Fork for this execution is %s.\", String.valueOf(forkOverride)));\n    }\n\n    // TODO - Fork or not depending on configuration?\n    JavaMainCaller cmd;\n    String toolcp = getToolClasspath();\n    if (forkOverride) {\n      // HACK (better may need refactor)\n      boolean bootcp = true;\n      if (args != null) {\n        for (String arg : args) {\n          bootcp = bootcp && !\"-nobootcp\".equals(arg);\n        }\n      }\n      String cp = bootcp ? \"\" : toolcp;\n      bootcp =\n          bootcp && !(StringUtils.isNotEmpty(addScalacArgs) && addScalacArgs.contains(\"-nobootcp\"));\n      // scalac with args in files\n      // * works only since 2.8.0\n      // * is buggy (don't manage space in path on windows)\n      getLog().debug(\"use java command with args in file forced : \" + forceUseArgFile);\n      cmd =\n          new JavaMainCallerByFork(\n              this, mainClass, cp, null, null, forceUseArgFile, getToolchain());\n      if (bootcp) {\n        cmd.addJvmArgs(\"-Xbootclasspath/a:\" + toolcp);\n      }\n    } else {\n      cmd = new JavaMainCallerInProcess(this, mainClass, toolcp, null, null);\n    }\n    return cmd;\n  }\n\n  protected Toolchain getToolchain() {\n    return toolchainManager.getToolchainFromBuildContext(\"jdk\", session);\n  }\n\n  private String getToolClasspath() throws Exception {\n    Set<String> classpath = new LinkedHashSet<>();\n    addLibraryToClasspath(classpath);\n    addCompilerToClasspath(classpath);\n    if (dependencies != null) {\n      for (BasicArtifact artifact : dependencies) {\n        addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, classpath);\n      }\n    }\n    return MainHelper.toMultiPath(classpath.toArray(new String[] {}));\n  }\n\n  protected List<String> getScalaOptions() throws Exception {\n    List<String> options = new ArrayList<>();\n    if (args != null) Collections.addAll(options, args);\n    if (StringUtils.isNotEmpty(addScalacArgs)) {\n      Collections.addAll(options, StringUtils.split(addScalacArgs, \"|\"));\n    }\n    options.addAll(getCompilerPluginOptions());\n    return options;\n  }\n\n  protected List<String> getJavacOptions() {\n    List<String> options = new ArrayList<>();\n    if (javacArgs != null) Collections.addAll(options, javacArgs);\n    if (StringUtils.isNotEmpty(addJavacArgs)) {\n      Collections.addAll(options, StringUtils.split(addJavacArgs, \"|\"));\n    }\n\n    // issue #116\n    if (javacGenerateDebugSymbols) {\n      options.add(\"-g\");\n    }\n    if (target != null && !target.isEmpty()) {\n      options.add(\"-target\");\n      options.add(target);\n    }\n    if (source != null && !source.isEmpty()) {\n      options.add(\"-source\");\n      options.add(source);\n    }\n    if (encoding != null) {\n      options.add(\"-encoding\");\n      options.add(encoding);\n    }\n    return options;\n  }\n\n  protected String getScala3ArtifactId(String a) {\n    return _scalaVersionN.major == 3 ? a + \"_\" + getBinaryVersionForScala3() : a;\n  }\n\n  private String getBinaryVersionForScala3() {\n    return _scalaVersionN.major == 3\n            && _scalaVersionN.minor == 0\n            && _scalaVersionN.bugfix == 0\n            && _scalaVersionN.modifier != null\n        ? _scalaVersionN.toString()\n        : \"3\";\n  }\n\n  protected File getLibraryJar() throws Exception {\n    return getLibraryJar(findScalaVersion());\n  }\n\n  protected File getLibraryJar(VersionNumber versionNumber) throws Exception {\n    String scalaLibrary =\n        _scalaVersionN.major == 3\n            ? getScala3ArtifactId(SCALA3_LIBRARY_ARTIFACTID)\n            : SCALA_LIBRARY_ARTIFACTID;\n    if (StringUtils.isNotEmpty(scalaHome)) {\n      File lib = new File(scalaHome, \"lib\");\n      return new File(lib, scalaLibrary + \".jar\");\n    }\n    return getArtifactJar(getScalaOrganization(), scalaLibrary, versionNumber.toString());\n  }\n\n  protected File getReflectJar() throws Exception {\n    if (_scalaVersionN.major != 3) {\n      String scalaReflect =\n          _scalaVersionN.major == 3\n              ? getScala3ArtifactId(SCALA3_REFLECT_ARTIFACTID)\n              : SCALA_REFLECT_ARTIFACTID;\n      if (StringUtils.isNotEmpty(scalaHome)) {\n        File lib = new File(scalaHome, \"lib\");\n        return new File(lib, scalaReflect + \".jar\");\n      }\n      return getArtifactJar(getScalaOrganization(), scalaReflect, findScalaVersion().toString());\n    }\n    return null;\n  }\n\n  protected File getCompilerJar() throws Exception {\n    return getCompilerJar(findScalaVersion());\n  }\n\n  protected File getCompilerJar(VersionNumber versionNumber) throws Exception {\n    String scalaCompile =\n        _scalaVersionN.major == 3\n            ? getScala3ArtifactId(SCALA3_COMPILER_ARTIFACTID)\n            : SCALA_COMPILER_ARTIFACTID;\n    if (StringUtils.isNotEmpty(scalaHome)) {\n      File lib = new File(scalaHome, \"lib\");\n      return new File(lib, scalaCompile + \".jar\");\n    }\n    return getArtifactJar(getScalaOrganization(), scalaCompile, versionNumber.toString());\n  }\n\n  protected List<File> getCompilerDependencies() throws Exception {\n    List<File> d = new ArrayList<>();\n    if (StringUtils.isEmpty(scalaHome)) {\n      for (Artifact artifact :\n          getAllDependencies(\n              getScalaOrganization(),\n              _scalaVersionN.major == 3\n                  ? getScala3ArtifactId(SCALA3_COMPILER_ARTIFACTID)\n                  : SCALA_COMPILER_ARTIFACTID,\n              findScalaVersion().toString())) {\n        d.add(artifact.getFile());\n      }\n    } else {\n      for (File f : new File(scalaHome, \"lib\").listFiles()) {\n        String name = f.getName();\n        if (name.endsWith(\".jar\")\n            && (!name.contains(\"scala-library\") || !name.contains(\"scala3-library\"))\n            && (!name.contains(\"scala-compiler\") || !name.contains(\"scala3-compiler\"))) {\n          d.add(f);\n        }\n      }\n    }\n    return d;\n  }\n\n  protected File getArtifactJar(String groupId, String artifactId, String version)\n      throws Exception {\n    Artifact artifact =\n        factory.createArtifact(\n            groupId, artifactId, version, Artifact.SCOPE_RUNTIME, ScalaMojoSupport.JAR);\n    resolver.resolve(artifact, remoteRepos, localRepo);\n    return artifact.getFile();\n  }\n\n  private Set<Artifact> getAllDependencies(String groupId, String artifactId, String version) {\n    Set<Artifact> result = new HashSet<>();\n    Artifact pom = factory.createArtifact(groupId, artifactId, version, \"\", ScalaMojoSupport.POM);\n    Set<Artifact> d = resolveArtifactDependencies(pom);\n    result.addAll(d);\n    for (Artifact dependency : d) {\n      Set<Artifact> transitive =\n          getAllDependencies(\n              dependency.getGroupId(), dependency.getArtifactId(), dependency.getVersion());\n      result.addAll(transitive);\n    }\n    return result;\n  }\n\n  /**\n   * @return This returns whether or not the scala version can support having java sent into the\n   *     compiler\n   */\n  protected boolean isJavaSupportedByCompiler() throws Exception {\n    return findScalaVersion().compareTo(new VersionNumber(\"2.7.2\")) >= 0;\n  }\n\n  /**\n   * Adds appropriate compiler plugins to the scalac command.\n   *\n   * @param scalac\n   * @throws Exception\n   */\n  protected void addCompilerPluginOptions(JavaMainCaller scalac) throws Exception {\n    for (String option : getCompilerPluginOptions()) {\n      scalac.addArgs(option);\n    }\n  }\n\n  private List<String> getCompilerPluginOptions() throws Exception {\n    List<String> options = new ArrayList<>();\n    for (String plugin : getCompilerPlugins()) {\n      options.add(\"-Xplugin:\" + plugin);\n    }\n    return options;\n  }\n\n  /**\n   * Retrieves a list of paths to scala compiler plugins.\n   *\n   * @return The list of plugins\n   * @throws Exception\n   */\n  private Set<String> getCompilerPlugins() throws Exception {\n    Set<String> plugins = new HashSet<>();\n    if (compilerPlugins != null) {\n      Set<String> ignoreClasspath = new LinkedHashSet<>();\n      addCompilerToClasspath(ignoreClasspath);\n      addLibraryToClasspath(ignoreClasspath);\n      for (BasicArtifact artifact : compilerPlugins) {\n        getLog().info(\"compiler plugin: \" + artifact.toString());\n        // TODO - Ensure proper scala version for plugins\n        Set<String> pluginClassPath = new HashSet<>();\n        // TODO - Pull in transitive dependencies.\n        addToClasspath(\n            artifact.groupId,\n            artifact.artifactId,\n            artifact.version,\n            artifact.classifier,\n            pluginClassPath,\n            false);\n        pluginClassPath.removeAll(ignoreClasspath);\n        plugins.addAll(pluginClassPath);\n      }\n    }\n    return plugins;\n  }\n}\n","lineNo":810}
{"Smelly Sample":"\n/*\n * Copyright 2011-2020 scala-maven-plugin project (https://davidb.github.io/scala-maven-plugin/)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage scala_maven;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.ArtifactUtils;\nimport org.apache.maven.artifact.factory.ArtifactFactory;\nimport org.apache.maven.artifact.metadata.ArtifactMetadataSource;\nimport org.apache.maven.artifact.repository.ArtifactRepository;\nimport org.apache.maven.artifact.resolver.ArtifactCollector;\nimport org.apache.maven.artifact.resolver.ArtifactResolutionRequest;\nimport org.apache.maven.artifact.resolver.ArtifactResolver;\nimport org.apache.maven.artifact.resolver.filter.AndArtifactFilter;\nimport org.apache.maven.artifact.resolver.filter.ArtifactFilter;\nimport org.apache.maven.artifact.resolver.filter.ScopeArtifactFilter;\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.model.Dependency;\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugin.MojoFailureException;\nimport org.apache.maven.plugins.annotations.Component;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.project.DefaultProjectBuildingRequest;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.project.MavenProjectBuilder;\nimport org.apache.maven.project.ProjectBuildingRequest;\nimport org.apache.maven.repository.RepositorySystem;\nimport org.apache.maven.shared.dependency.graph.DependencyGraphBuilder;\nimport org.apache.maven.shared.dependency.graph.DependencyNode;\nimport org.apache.maven.shared.dependency.graph.filter.AncestorOrSelfDependencyNodeFilter;\nimport org.apache.maven.shared.dependency.graph.filter.AndDependencyNodeFilter;\nimport org.apache.maven.shared.dependency.graph.filter.DependencyNodeFilter;\nimport org.apache.maven.shared.dependency.graph.traversal.CollectingDependencyNodeVisitor;\nimport org.apache.maven.shared.dependency.graph.traversal.DependencyNodeVisitor;\nimport org.apache.maven.shared.dependency.graph.traversal.FilteringDependencyNodeVisitor;\nimport org.apache.maven.toolchain.Toolchain;\nimport org.apache.maven.toolchain.ToolchainManager;\nimport org.codehaus.plexus.util.StringUtils;\nimport scala_maven_dependency.CheckScalaVersionVisitor;\nimport scala_maven_dependency.ScalaDistroArtifactFilter;\nimport scala_maven_executions.JavaMainCaller;\nimport scala_maven_executions.JavaMainCallerByFork;\nimport scala_maven_executions.JavaMainCallerInProcess;\nimport scala_maven_executions.MainHelper;\n\npublic abstract class ScalaMojoSupport extends AbstractMojo {\n\n  private static final String SCALA_LIBRARY_ARTIFACTID = \"scala-library\";\n  private static final String SCALA_REFLECT_ARTIFACTID = \"scala-reflect\";\n  private static final String SCALA_COMPILER_ARTIFACTID = \"scala-compiler\";\n\n  /** Constant {@link String} for \"pom\". Used to specify the Maven POM artifact type. */\n  protected static final String POM = \"pom\";\n\n  /** Constant {@link String} for \"jar\". Used to specify the Maven JAR artifact type. */\n  static final String JAR = \"jar\";\n\n  /** The maven project. */\n  @Parameter(property = \"project\", required = true, readonly = true)\n  protected MavenProject project;\n\n  /**\n   * The Maven Session Object\n   *\n   * <p>Note: Allows extending for 3rd-party usages\n   */\n  @Parameter(property = \"session\", required = true, readonly = true)\n  protected MavenSession session;\n\n  /** Used to look up Artifacts in the remote repository. */\n  @Component RepositorySystem factory;\n\n  /** Used to look up Artifacts in the remote repository. */\n  @Component private ArtifactResolver resolver;\n\n  /** Location of the local repository. */\n  @Parameter(property = \"localRepository\", readonly = true, required = true)\n  private ArtifactRepository localRepo;\n\n  /** List of Remote Repositories used by the resolver */\n  @Parameter(property = \"project.remoteArtifactRepositories\", readonly = true, required = true)\n  private List<ArtifactRepository> remoteRepos;\n\n  /**\n   * Additional dependencies/jar to add to classpath to run \"scalaClassName\" (scope and optional\n   * field not supported) ex :\n   *\n   * <pre>\n   *    &lt;dependencies&gt;\n   *      &lt;dependency&gt;\n   *        &lt;groupId&gt;org.scala-tools&lt;/groupId&gt;\n   *        &lt;artifactId&gt;scala-compiler-addon&lt;/artifactId&gt;\n   *        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n   *      &lt;/dependency&gt;\n   *    &lt;/dependencies&gt;\n   * <\/pre>\n   */\n  @Parameter protected BasicArtifact[] dependencies;\n\n  /**\n   * Compiler plugin dependencies to use when compiling. ex:\n   *\n   * <pre>\n   * &lt;compilerPlugins&gt;\n   *   &lt;compilerPlugin&gt;\n   *     &lt;groupId&gt;my.scala.plugin&lt;/groupId&gt;\n   *     &lt;artifactId&gt;amazingPlugin&lt;/artifactId&gt;\n   *     &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n   *   &lt;/compilerPlugin&gt;\n   * &lt;/compilerPlugins&gt;\n   * <\/pre>\n   */\n  @Parameter private BasicArtifact[] compilerPlugins;\n\n  /** Jvm Arguments. */\n  @Parameter protected String[] jvmArgs;\n\n  /** compiler additional arguments */\n  @Parameter protected String[] args;\n\n  /**\n   * Additional parameter to use to call the main class. Use this parameter only from command line\n   * (\"-DaddScalacArgs=arg1|arg2|arg3|...\"), not from pom.xml. To define compiler arguments in\n   * pom.xml see the \"args\" parameter.\n   */\n  @Parameter(property = \"addScalacArgs\")\n  private String addScalacArgs;\n\n  /** className (FQN) of the scala tool to provide as */\n  @Parameter(\n      required = true,\n      property = \"maven.scala.className\",\n      defaultValue = \"scala.tools.nsc.Main\")\n  protected String scalaClassName;\n\n  /** Scala 's version to use. (property 'maven.scala.version' replaced by 'scala.version') */\n  @Parameter(property = \"scala.version\")\n  private String scalaVersion;\n\n  /**\n   * Organization/group ID of the Scala used in the project. Default value is 'org.scala-lang'. This\n   * is an advanced setting used for clones of the Scala Language. It should be disregarded in\n   * standard use cases.\n   */\n  @Parameter(property = \"scala.organization\", defaultValue = \"org.scala-lang\")\n  private String scalaOrganization;\n\n  public String getScalaOrganization() {\n    return scalaOrganization;\n  }\n\n  /**\n   * Scala 's version to use to check binary compatibility (like suffix in artifactId of\n   * dependency). If it is defined then it is used to checkMultipleScalaVersions\n   */\n  @Parameter(property = \"scala.compat.version\")\n  private String scalaCompatVersion;\n\n  /** Path to Scala installation to use instead of the artifact (define as dependencies). */\n  @Parameter(property = \"scala.home\")\n  private String scalaHome;\n\n  /** Arguments for javac (when using incremental compiler). */\n  @Parameter(property = \"javacArgs\")\n  protected String[] javacArgs;\n\n  /**\n   * Whether to instruct javac to generate debug symbols (when using incremental compiler)\n   *\n   * @see <a href=\n   *     \"http://maven.apache.org/plugins/maven-compiler-plugin/compile-mojo.html#debug\">://maven.apache.org/plugins/maven-compiler-plugin/compile-mojo.html#debug<\/a>\n   */\n  @Parameter(property = \"javacGenerateDebugSymbols\", defaultValue = \"true\")\n  protected boolean javacGenerateDebugSymbols = true;\n\n  /**\n   * Alternative method for specifying javac arguments (when using incremental compiler). Can be\n   * used from command line with -DaddJavacArgs=arg1|arg2|arg3|... rather than in pom.xml.\n   */\n  @Parameter(property = \"addJavacArgs\")\n  protected String addJavacArgs;\n\n  /** The -source argument for the Java compiler (when using incremental compiler). */\n  @Parameter(property = \"maven.compiler.source\")\n  protected String source;\n\n  /** The -target argument for the Java compiler (when using incremental compiler). */\n  @Parameter(property = \"maven.compiler.target\")\n  protected String target;\n\n  /** The -encoding argument for the Java compiler. (when using incremental compiler). */\n  @Parameter(property = \"project.build.sourceEncoding\", defaultValue = \"UTF-8\")\n  protected String encoding;\n\n  /**\n   * Display the command line called ? (property 'maven.scala.displayCmd' replaced by 'displayCmd')\n   */\n  @Parameter(property = \"displayCmd\", defaultValue = \"false\", required = true)\n  public boolean displayCmd;\n\n  /** Forks the execution of scalac into a separate process. */\n  @Parameter(defaultValue = \"true\")\n  protected boolean fork = true;\n\n  /** Force the use of an external ArgFile to run any forked process. */\n  @Parameter(defaultValue = \"false\")\n  protected boolean forceUseArgFile = false;\n\n  /** Check if every dependencies use the same version of scala-library or scala.compat.version. */\n  @Parameter(property = \"maven.scala.checkConsistency\", defaultValue = \"true\")\n  protected boolean checkMultipleScalaVersions;\n\n  /**\n   * Determines if a detection of multiple scala versions in the dependencies will cause the build\n   * to fail.\n   */\n  @Parameter(defaultValue = \"false\")\n  protected boolean failOnMultipleScalaVersions = false;\n\n  /**\n   * Should use CanonicalPath to normalize path (true =&gt; getCanonicalPath, false =&gt;\n   * getAbsolutePath)\n   *\n   * @see <a href=\n   *     \"https://github.com/davidB/scala-maven-plugin/issues/50\">https://github.com/davidB/scala-maven-plugin/issues/50<\/a>\n   */\n  @Parameter(property = \"maven.scala.useCanonicalPath\", defaultValue = \"true\")\n  protected boolean useCanonicalPath = true;\n\n  /** Artifact factory, needed to download source jars. */\n  @Component protected MavenProjectBuilder mavenProjectBuilder;\n\n  /** The artifact repository to use. */\n  @Parameter(property = \"localRepository\", required = true, readonly = true)\n  private ArtifactRepository localRepository;\n\n  /** The artifact factory to use. */\n  @Component private ArtifactFactory artifactFactory;\n\n  /** The artifact metadata source to use. */\n  @Component private ArtifactMetadataSource artifactMetadataSource;\n\n  /** The artifact collector to use. */\n  @Component private ArtifactCollector artifactCollector;\n\n  /** The dependency tree builder to use. */\n  @Component private DependencyGraphBuilder dependencyGraphBuilder;\n\n  /** The toolchain manager to use. */\n  @Component protected ToolchainManager toolchainManager;\n\n  /** List of artifacts to run plugin */\n  @Parameter(defaultValue = \"${plugin.artifacts}\")\n  private List<Artifact> pluginArtifacts;\n\n  private VersionNumber _scalaVersionN;\n\n  /**\n   * Constructs an {@link Artifact} for Scala Compiler.\n   *\n   * @param scalaVersion the version of the Scala Compiler/Library we are using for this execution.\n   * @return a {@link Artifact} for the Scala Compiler.\n   */\n  final Artifact scalaCompilerArtifact(String scalaVersion) {\n    return factory.createArtifact(\n        getScalaOrganization(),\n        ScalaMojoSupport.SCALA_COMPILER_ARTIFACTID,\n        scalaVersion,\n        \"\",\n        ScalaMojoSupport.POM);\n  }\n\n  /**\n   * This method resolves all transitive dependencies of an artifact.\n   *\n   * @param artifact the {@link Artifact} used to retrieve dependencies.\n   * @return resolved {@link Set} of dependencies.\n   */\n  final Set<Artifact> resolveArtifactDependencies(final Artifact artifact) {\n    final AndArtifactFilter filter = new AndArtifactFilter();\n    filter.add(new ScopeArtifactFilter(Artifact.SCOPE_TEST));\n    filter.add(art -> !art.isOptional());\n\n    // Use the collection filter as the resolution filter.\n    return resolveDependencyArtifacts(artifact, filter, filter);\n  }\n\n  /**\n   * This method resolves all transitive dependencies of an artifact.\n   *\n   * @param artifact the {@link Artifact} used to retrieve dependencies.\n   * @param collectionFilter an {@link ArtifactFilter} used to determine which members dependency\n   *     graph should be downloaded.\n   * @param resolutionFilter an {@link ArtifactFilter} used to determine which members of the\n   *     dependency graph should be included in resolution.\n   * @return resolved {@link Set} of dependencies.\n   */\n  private Set<Artifact> resolveDependencyArtifacts(\n      final Artifact artifact,\n      final ArtifactFilter collectionFilter,\n      final ArtifactFilter resolutionFilter) {\n    return resolveDependencyArtifacts(\n        artifact, collectionFilter, resolutionFilter, this.remoteRepos, this.localRepo);\n  }\n\n  /**\n   * This method resolves all transitive dependencies of an artifact.\n   *\n   * @param artifact the {@link Artifact} used to retrieve dependencies.\n   * @param collectionFilter an {@link ArtifactFilter} used to determine which members of the\n   *     dependency graph should be included in resolution.\n   * @param resolutionFilter an {@link ArtifactFilter} used to determine which members of the\n   *     dependency graph should be included in resolution.\n   * @param remoteRepositories a {@link List} of remote {@link ArtifactRepository} values to used\n   *     for dependency resolution of the provided {@link Artifact}.\n   * @param localRepository the local {@link ArtifactRepository} to use for dependency resolution of\n   *     the given {@link Artifact}.\n   * @return resolved {@link Set} of dependencies.\n   */\n  private Set<Artifact> resolveDependencyArtifacts(\n      final Artifact artifact,\n      final ArtifactFilter collectionFilter,\n      final ArtifactFilter resolutionFilter,\n      final List<ArtifactRepository> remoteRepositories,\n      final ArtifactRepository localRepository) {\n    final ArtifactResolutionRequest arr =\n        this.createArtifactResolutionRequest(\n            artifact, collectionFilter, resolutionFilter, remoteRepositories, localRepository);\n\n    // TODO follow the dependenciesManagement and override rules\n    return factory.resolve(arr).getArtifacts();\n  }\n\n  /**\n   * Create a {@link ArtifactResolutionRequest}.\n   *\n   * @param artifact the {@link Artifact} used to retrieve dependencies.\n   * @param collectionFilter an {@link ArtifactFilter} used to determine which members dependency\n   *     graph should be downloaded.\n   * @param resolutionFilter an {@link ArtifactFilter} used to determine which members of the\n   *     dependency graph should be included in resolution\n   * @param remoteRepositories a {@link List} of remote {@link ArtifactRepository} values to used\n   *     for dependency resolution of the provided {@link Artifact}.\n   * @param localRepository the local {@link ArtifactRepository} to use for dependency resolution of\n   *     the given {@link Artifact}.\n   * @return an {@link ArtifactResolutionRequest}, typically used for dependency resolution requests\n   *     against an {@link ArtifactResolver}.\n   */\n  private ArtifactResolutionRequest createArtifactResolutionRequest(\n      final Artifact artifact,\n      final ArtifactFilter collectionFilter,\n      final ArtifactFilter resolutionFilter,\n      final List<ArtifactRepository> remoteRepositories,\n      final ArtifactRepository localRepository) {\n    final ArtifactResolutionRequest arr = new ArtifactResolutionRequest();\n\n    arr.setArtifact(artifact);\n    arr.setCollectionFilter(collectionFilter);\n    arr.setResolutionFilter(resolutionFilter);\n    arr.setResolveRoot(false);\n    arr.setResolveTransitively(true);\n    arr.setRemoteRepositories(remoteRepositories);\n    arr.setLocalRepository(localRepository);\n\n    return arr;\n  }\n\n  private void addToClasspath(\n      String groupId, String artifactId, String version, Set<String> classpath) throws Exception {\n    addToClasspath(groupId, artifactId, version, classpath, true);\n  }\n\n  private void addToClasspath(\n      String groupId,\n      String artifactId,\n      String version,\n      Set<String> classpath,\n      boolean addDependencies)\n      throws Exception {\n    addToClasspath(\n        factory.createArtifact(\n            groupId, artifactId, version, Artifact.SCOPE_RUNTIME, ScalaMojoSupport.JAR),\n        classpath,\n        addDependencies);\n  }\n\n  /**\n   * added for classifier support.\n   *\n   * @author Christoph Radig\n   * @todo might want to merge with existing \"addToClasspath\" methods.\n   */\n  private void addToClasspath(\n      String groupId,\n      String artifactId,\n      String version,\n      String classifier,\n      Set<String> classpath,\n      boolean addDependencies)\n      throws Exception {\n    Dependency d = new Dependency();\n    d.setGroupId(groupId);\n    d.setArtifactId(artifactId);\n    d.setVersion(version);\n    d.setType(ScalaMojoSupport.JAR);\n    d.setClassifier(classifier);\n    d.setScope(Artifact.SCOPE_RUNTIME);\n    addToClasspath(factory.createDependencyArtifact(d), classpath, addDependencies);\n  }\n\n  void addToClasspath(Artifact artifact, Set<String> classpath, boolean addDependencies)\n      throws Exception {\n    resolver.resolve(artifact, remoteRepos, localRepo);\n    classpath.add(FileUtils.pathOf(artifact.getFile(), useCanonicalPath));\n    if (addDependencies) {\n      for (Artifact dep : resolveArtifactDependencies(artifact)) {\n        addToClasspath(dep, classpath, addDependencies);\n      }\n    }\n  }\n\n  void addCompilerToClasspath(Set<String> classpath) throws Exception {\n    classpath.add(FileUtils.pathOf(getCompilerJar(), useCanonicalPath));\n    for (File dep : getCompilerDependencies()) {\n      classpath.add(FileUtils.pathOf(dep, useCanonicalPath));\n    }\n  }\n\n  void addLibraryToClasspath(Set<String> classpath) throws Exception {\n    classpath.add(FileUtils.pathOf(getLibraryJar(), useCanonicalPath));\n  }\n\n  @Override\n  public void execute() throws MojoExecutionException, MojoFailureException {\n    try {\n      String oldWay = System.getProperty(\"maven.scala.version\");\n      if (oldWay != null) {\n        getLog().warn(\"using 'maven.scala.version' is deprecated, use 'scala.version' instead\");\n        if (scalaVersion != null) {\n          scalaVersion = oldWay;\n        }\n      }\n\n      oldWay = System.getProperty(\"maven.scala.displayCmd\");\n      if (oldWay != null) {\n        getLog().warn(\"using 'maven.scala.displayCmd' is deprecated, use 'displayCmd' instead\");\n        displayCmd = displayCmd || Boolean.parseBoolean(oldWay);\n      }\n      checkScalaVersion();\n      doExecute();\n    } catch (MojoExecutionException exc) {\n      throw exc;\n    } catch (MojoFailureException | RuntimeException exc) {\n      throw exc;\n    } catch (Exception exc) {\n      throw new MojoExecutionException(\"wrap: \" + exc, exc);\n    }\n  }\n\n  protected List<Dependency> getDependencies() {\n    return project.getCompileDependencies();\n  }\n\n  VersionNumber findScalaVersion() throws Exception {\n    if (_scalaVersionN == null) {\n      String detectedScalaVersion = scalaVersion;\n      if (StringUtils.isEmpty(detectedScalaVersion)) {\n        detectedScalaVersion = findScalaVersionFromDependencies();\n      }\n      if (StringUtils.isEmpty(detectedScalaVersion)) {\n        if (!ScalaMojoSupport.POM.equals(project.getPackaging().toLowerCase())) {\n          String error =\n              getScalaOrganization()\n                  + \":\"\n                  + SCALA_LIBRARY_ARTIFACTID\n                  + \" is missing from project dependencies\";\n          getLog().error(error);\n          throw new UnsupportedOperationException(error);\n        }\n      } else {\n        // grappy hack to retrieve the SNAPSHOT version without timestamp,...\n        // because if version is -SNAPSHOT and artifact is deploy with uniqueValue then\n        // the version\n        // get from dependency is with the timestamp and a build number (the resolved\n        // version)\n        // but scala-compiler with the same version could have different resolved\n        // version (timestamp,...)\n        boolean isSnapshot = ArtifactUtils.isSnapshot(detectedScalaVersion);\n        if (isSnapshot && !detectedScalaVersion.endsWith(\"-SNAPSHOT\")) {\n          detectedScalaVersion =\n              detectedScalaVersion.substring(\n                      0,\n                      detectedScalaVersion.lastIndexOf(\n                          '-', detectedScalaVersion.lastIndexOf('-') - 1))\n                  + \"-SNAPSHOT\";\n        }\n      }\n      if (StringUtils.isEmpty(detectedScalaVersion)) {\n        throw new MojoFailureException(\"no scalaVersion detected or set\");\n      }\n      if (StringUtils.isNotEmpty(scalaVersion)) {\n        if (!scalaVersion.equals(detectedScalaVersion)) {\n          getLog()\n              .warn(\n                  \"scala library version define in dependencies doesn't match the scalaVersion of the plugin\");\n        }\n        // getLog().info(\"suggestion: remove the scalaVersion from pom.xml\");\n        // //scalaVersion could be define in a parent pom where lib is not required\n      }\n      _scalaVersionN = new VersionNumber(detectedScalaVersion);\n    }\n    return _scalaVersionN;\n  }\n\n  private String findScalaVersionFromDependencies() {\n    return findVersionFromDependencies(getScalaOrganization(), SCALA_LIBRARY_ARTIFACTID);\n  }\n\n  // TODO refactor to do only one scan of dependencies to find version\n  private String findVersionFromDependencies(String groupId, String artifactId) {\n    String version = null;\n    for (Dependency dep : getDependencies()) {\n      if (groupId.equals(dep.getGroupId()) && artifactId.equals(dep.getArtifactId())) {\n        version = dep.getVersion();\n      }\n    }\n    if (StringUtils.isEmpty(version)) {\n      List<Dependency> deps = new ArrayList<>();\n      deps.addAll(project.getModel().getDependencies());\n      if (project.getModel().getDependencyManagement() != null) {\n        deps.addAll(project.getModel().getDependencyManagement().getDependencies());\n      }\n      for (Dependency dep : deps) {\n        if (groupId.equals(dep.getGroupId()) && artifactId.equals(dep.getArtifactId())) {\n          version = dep.getVersion();\n        }\n      }\n    }\n    return version;\n  }\n\n  void checkScalaVersion() throws Exception {\n    String sv = findScalaVersion().toString();\n    if (StringUtils.isNotEmpty(scalaHome)) {\n      getLog()\n          .warn(\n              String.format(\n                  \"local scala-library.jar and scala-compiler.jar from scalaHome(%s) used instead of scala %s\",\n                  scalaHome, sv));\n    }\n    if (checkMultipleScalaVersions) {\n      checkCorrectVersionsOfScalaLibrary(sv);\n    }\n  }\n\n  /**\n   * this method checks to see if there are multiple versions of the scala library\n   *\n   * @throws Exception\n   */\n  private void checkCorrectVersionsOfScalaLibrary(String scalaDefVersion) throws Exception {\n    getLog().debug(\"Checking for multiple versions of scala\");\n    // TODO - Make sure we handle bad artifacts....\n    // TODO: note that filter does not get applied due to MNG-3236\n    VersionNumber sv = new VersionNumber(scalaDefVersion);\n    VersionNumber requiredScalaVersion =\n        StringUtils.isNotEmpty(scalaCompatVersion) ? new VersionNumberMask(scalaCompatVersion) : sv;\n    if (requiredScalaVersion.compareTo(sv) != 0) {\n      String msg =\n          String.format(\n              \"Scala library detected %s doesn't match scala.compat.version : %s\",\n              sv, requiredScalaVersion);\n      if (failOnMultipleScalaVersions) {\n        getLog().error(msg);\n        throw new MojoFailureException(msg);\n      }\n      getLog().warn(msg);\n    }\n    ProjectBuildingRequest request =\n        new DefaultProjectBuildingRequest(session.getProjectBuildingRequest());\n    request.setProject(project);\n    checkArtifactForScalaVersion(\n        requiredScalaVersion, dependencyGraphBuilder.buildDependencyGraph(request, null));\n  }\n\n  /** Visits a node (and all dependencies) to see if it contains duplicate scala versions */\n  private void checkArtifactForScalaVersion(\n      VersionNumber requiredScalaVersion, DependencyNode rootNode) throws Exception {\n    final CheckScalaVersionVisitor visitor =\n        new CheckScalaVersionVisitor(requiredScalaVersion, getLog(), getScalaOrganization());\n\n    CollectingDependencyNodeVisitor collectingVisitor = new CollectingDependencyNodeVisitor();\n    DependencyNodeVisitor firstPassVisitor =\n        new FilteringDependencyNodeVisitor(collectingVisitor, createScalaDistroDependencyFilter());\n    rootNode.accept(firstPassVisitor);\n\n    DependencyNodeFilter secondPassFilter =\n        new AncestorOrSelfDependencyNodeFilter(collectingVisitor.getNodes());\n    DependencyNodeVisitor filteredVisitor =\n        new FilteringDependencyNodeVisitor(visitor, secondPassFilter);\n\n    rootNode.accept(filteredVisitor);\n\n    if (visitor.isFailed()) {\n      visitor.logScalaDependents();\n      if (failOnMultipleScalaVersions) {\n        getLog().error(\"Multiple versions of scala libraries detected!\");\n        throw new MojoFailureException(\"Multiple versions of scala libraries detected!\");\n      }\n      getLog().warn(\"Multiple versions of scala libraries detected!\");\n    }\n  }\n\n  /** @return A filter to only extract artifacts deployed from scala distributions */\n  private DependencyNodeFilter createScalaDistroDependencyFilter() {\n    List<DependencyNodeFilter> filters = new ArrayList<>();\n    filters.add(new ScalaDistroArtifactFilter(getScalaOrganization()));\n    return new AndDependencyNodeFilter(filters);\n  }\n\n  protected abstract void doExecute() throws Exception;\n\n  protected JavaMainCaller getScalaCommand() throws Exception {\n    return getScalaCommand(fork, scalaClassName);\n  }\n\n  /**\n   * Get a {@link JavaMainCaller} used invoke a Java process. Typically this will be one of the\n   * Scala utilities (Compiler, ScalaDoc, REPL, etc.).\n   *\n   * <p>This method does some setup on the {@link JavaMainCaller} which is not done by merely\n   * invoking {@code new} on one of the implementations. Specifically, it adds any Scala compiler\n   * plugin options, JVM options, and Scalac options defined on the plugin.\n   *\n   * @param forkOverride override the setting for {@link #fork}. Currently this should only be set\n   *     if you are invoking the REPL.\n   * @param mainClass the JVM main class to invoke.\n   * @return a {@link JavaMainCaller} to use to invoke the given command.\n   */\n  final JavaMainCaller getScalaCommand(final boolean forkOverride, final String mainClass)\n      throws Exception {\n    JavaMainCaller cmd = getEmptyScalaCommand(mainClass, forkOverride);\n    cmd.addArgs(args);\n    if (StringUtils.isNotEmpty(addScalacArgs)) {\n      cmd.addArgs(StringUtils.split(addScalacArgs, \"|\"));\n    }\n    addCompilerPluginOptions(cmd);\n    cmd.addJvmArgs(jvmArgs);\n    return cmd;\n  }\n\n  /**\n   * Get a {@link JavaMainCaller} used invoke a Java process. Typically this will be one of the\n   * Scala utilities (Compiler, ScalaDoc, REPL, etc.).\n   *\n   * @param mainClass the JVM main class to invoke.\n   * @return a {@link JavaMainCaller} to use to invoke the given command.\n   */\n  final JavaMainCaller getEmptyScalaCommand(final String mainClass) throws Exception {\n    return getEmptyScalaCommand(mainClass, fork);\n  }\n\n  /**\n   * Get a {@link JavaMainCaller} used invoke a Java process. Typically this will be one of the\n   * Scala utilities (Compiler, ScalaDoc, REPL, etc.).\n   *\n   * @param mainClass the JVM main class to invoke.\n   * @param forkOverride override the setting for {@link #fork}. Currently this should only be set\n   *     if you are invoking the REPL.\n   * @return a {@link JavaMainCaller} to use to invoke the given command.\n   */\n  private JavaMainCaller getEmptyScalaCommand(final String mainClass, final boolean forkOverride)\n      throws Exception {\n\n    // If we are deviating from the plugin settings, let the user know\n    // what's going on.\n    if (forkOverride != fork) {\n      super.getLog().info(\"Fork behavior overridden\");\n      super.getLog()\n          .info(String.format(\"Fork for this execution is %s.\", String.valueOf(forkOverride)));\n    }\n\n    // TODO - Fork or not depending on configuration?\n    JavaMainCaller cmd;\n    String toolcp = getToolClasspath();\n    if (forkOverride) {\n      // HACK (better may need refactor)\n      boolean bootcp = true;\n      if (args != null) {\n        for (String arg : args) {\n          bootcp = bootcp && !\"-nobootcp\".equals(arg);\n        }\n      }\n      String cp = bootcp ? \"\" : toolcp;\n      bootcp =\n          bootcp && !(StringUtils.isNotEmpty(addScalacArgs) && addScalacArgs.contains(\"-nobootcp\"));\n      // scalac with args in files\n      // * works only since 2.8.0\n      // * is buggy (don't manage space in path on windows)\n      getLog().debug(\"use java command with args in file forced : \" + forceUseArgFile);\n      cmd =\n          new JavaMainCallerByFork(\n              this, mainClass, cp, null, null, forceUseArgFile, getToolchain());\n      if (bootcp) {\n        cmd.addJvmArgs(\"-Xbootclasspath/a:\" + toolcp);\n      }\n    } else {\n      cmd = new JavaMainCallerInProcess(this, mainClass, toolcp, null, null);\n    }\n    return cmd;\n  }\n\n  protected Toolchain getToolchain() {\n    return toolchainManager.getToolchainFromBuildContext(\"jdk\", session);\n  }\n\n  private String getToolClasspath() throws Exception {\n    Set<String> classpath = new LinkedHashSet<>();\n    addLibraryToClasspath(classpath);\n    addCompilerToClasspath(classpath);\n    if (dependencies != null) {\n      for (BasicArtifact artifact : dependencies) {\n        addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, classpath);\n      }\n    }\n    return MainHelper.toMultiPath(classpath.toArray(new String[] {}));\n  }\n\n  protected List<String> getScalaOptions() throws Exception {\n    List<String> options = new ArrayList<>();\n    if (args != null) Collections.addAll(options, args);\n    if (StringUtils.isNotEmpty(addScalacArgs)) {\n      Collections.addAll(options, StringUtils.split(addScalacArgs, \"|\"));\n    }\n    options.addAll(getCompilerPluginOptions());\n    return options;\n  }\n\n  protected List<String> getJavacOptions() {\n    List<String> options = new ArrayList<>();\n    if (javacArgs != null) Collections.addAll(options, javacArgs);\n    if (StringUtils.isNotEmpty(addJavacArgs)) {\n      Collections.addAll(options, StringUtils.split(addJavacArgs, \"|\"));\n    }\n\n    // issue #116\n    if (javacGenerateDebugSymbols) {\n      options.add(\"-g\");\n    }\n    if (target != null && !target.isEmpty()) {\n      options.add(\"-target\");\n      options.add(target);\n    }\n    if (source != null && !source.isEmpty()) {\n      options.add(\"-source\");\n      options.add(source);\n    }\n    if (encoding != null) {\n      options.add(\"-encoding\");\n      options.add(encoding);\n    }\n    return options;\n  }\n\n  protected File getLibraryJar() throws Exception {\n    if (StringUtils.isNotEmpty(scalaHome)) {\n      File lib = new File(scalaHome, \"lib\");\n      return new File(lib, SCALA_LIBRARY_ARTIFACTID + \".jar\");\n    }\n    return getArtifactJar(\n        getScalaOrganization(), SCALA_LIBRARY_ARTIFACTID, findScalaVersion().toString());\n  }\n\n  protected File getReflectJar() throws Exception {\n    if (StringUtils.isNotEmpty(scalaHome)) {\n      File lib = new File(scalaHome, \"lib\");\n      return new File(lib, SCALA_REFLECT_ARTIFACTID + \".jar\");\n    }\n    return getArtifactJar(\n        getScalaOrganization(), SCALA_REFLECT_ARTIFACTID, findScalaVersion().toString());\n  }\n\n  protected File getCompilerJar() throws Exception {\n    if (StringUtils.isNotEmpty(scalaHome)) {\n      File lib = new File(scalaHome, \"lib\");\n      return new File(lib, SCALA_COMPILER_ARTIFACTID + \".jar\");\n    }\n    return getArtifactJar(\n        getScalaOrganization(), SCALA_COMPILER_ARTIFACTID, findScalaVersion().toString());\n  }\n\n  protected List<File> getCompilerDependencies() throws Exception {\n    List<File> d = new ArrayList<>();\n    if (StringUtils.isEmpty(scalaHome)) {\n      for (Artifact artifact :\n          getAllDependencies(\n              getScalaOrganization(), SCALA_COMPILER_ARTIFACTID, findScalaVersion().toString())) {\n        d.add(artifact.getFile());\n      }\n    } else {\n      for (File f : new File(scalaHome, \"lib\").listFiles()) {\n        String name = f.getName();\n        if (name.endsWith(\".jar\")\n            && !name.contains(\"scala-library\")\n            && !name.contains(\"scala-compiler\")) {\n          d.add(f);\n        }\n      }\n    }\n    return d;\n  }\n\n  protected File getArtifactJar(String groupId, String artifactId, String version)\n      throws Exception {\n    Artifact artifact =\n        factory.createArtifact(\n            groupId, artifactId, version, Artifact.SCOPE_RUNTIME, ScalaMojoSupport.JAR);\n    resolver.resolve(artifact, remoteRepos, localRepo);\n    return artifact.getFile();\n  }\n\n  private Set<Artifact> getAllDependencies(String groupId, String artifactId, String version) {\n    Set<Artifact> result = new HashSet<>();\n    Artifact pom = factory.createArtifact(groupId, artifactId, version, \"\", ScalaMojoSupport.POM);\n    Set<Artifact> d = resolveArtifactDependencies(pom);\n    result.addAll(d);\n    for (Artifact dependency : d) {\n      Set<Artifact> transitive =\n          getAllDependencies(\n              dependency.getGroupId(), dependency.getArtifactId(), dependency.getVersion());\n      result.addAll(transitive);\n    }\n    return result;\n  }\n\n  /**\n   * @return This returns whether or not the scala version can support having java sent into the\n   *     compiler\n   */\n  protected boolean isJavaSupportedByCompiler() throws Exception {\n    return findScalaVersion().compareTo(new VersionNumber(\"2.7.2\")) >= 0;\n  }\n\n  /**\n   * Adds appropriate compiler plugins to the scalac command.\n   *\n   * @param scalac\n   * @throws Exception\n   */\n  protected void addCompilerPluginOptions(JavaMainCaller scalac) throws Exception {\n    for (String option : getCompilerPluginOptions()) {\n      scalac.addArgs(option);\n    }\n  }\n\n  private List<String> getCompilerPluginOptions() throws Exception {\n    List<String> options = new ArrayList<>();\n    for (String plugin : getCompilerPlugins()) {\n      options.add(\"-Xplugin:\" + plugin);\n    }\n    return options;\n  }\n\n  /**\n   * Retrieves a list of paths to scala compiler plugins.\n   *\n   * @return The list of plugins\n   * @throws Exception\n   */\n  private Set<String> getCompilerPlugins() throws Exception {\n    Set<String> plugins = new HashSet<>();\n    if (compilerPlugins != null) {\n      Set<String> ignoreClasspath = new LinkedHashSet<>();\n      addCompilerToClasspath(ignoreClasspath);\n      addLibraryToClasspath(ignoreClasspath);\n      for (BasicArtifact artifact : compilerPlugins) {\n        getLog().info(\"compiler plugin: \" + artifact.toString());\n        // TODO - Ensure proper scala version for plugins\n        Set<String> pluginClassPath = new HashSet<>();\n        // TODO - Pull in transitive dependencies.\n        addToClasspath(\n            artifact.groupId,\n            artifact.artifactId,\n            artifact.version,\n            artifact.classifier,\n            pluginClassPath,\n            false);\n        pluginClassPath.removeAll(ignoreClasspath);\n        plugins.addAll(pluginClassPath);\n      }\n    }\n    return plugins;\n  }\n}\n","Method after Refactoring":"\n/*\n * Copyright 2011-2020 scala-maven-plugin project (https://davidb.github.io/scala-maven-plugin/)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage scala_maven;\n\nimport java.io.File;\nimport java.util.*;\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.ArtifactUtils;\nimport org.apache.maven.artifact.factory.ArtifactFactory;\nimport org.apache.maven.artifact.metadata.ArtifactMetadataSource;\nimport org.apache.maven.artifact.repository.ArtifactRepository;\nimport org.apache.maven.artifact.resolver.ArtifactCollector;\nimport org.apache.maven.artifact.resolver.ArtifactResolutionRequest;\nimport org.apache.maven.artifact.resolver.ArtifactResolver;\nimport org.apache.maven.artifact.resolver.filter.AndArtifactFilter;\nimport org.apache.maven.artifact.resolver.filter.ArtifactFilter;\nimport org.apache.maven.artifact.resolver.filter.ScopeArtifactFilter;\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.model.Dependency;\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugin.MojoFailureException;\nimport org.apache.maven.plugins.annotations.Component;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.project.DefaultProjectBuildingRequest;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.project.MavenProjectBuilder;\nimport org.apache.maven.project.ProjectBuildingRequest;\nimport org.apache.maven.repository.RepositorySystem;\nimport org.apache.maven.shared.dependency.graph.DependencyGraphBuilder;\nimport org.apache.maven.shared.dependency.graph.DependencyNode;\nimport org.apache.maven.shared.dependency.graph.filter.AncestorOrSelfDependencyNodeFilter;\nimport org.apache.maven.shared.dependency.graph.filter.AndDependencyNodeFilter;\nimport org.apache.maven.shared.dependency.graph.filter.DependencyNodeFilter;\nimport org.apache.maven.shared.dependency.graph.traversal.CollectingDependencyNodeVisitor;\nimport org.apache.maven.shared.dependency.graph.traversal.DependencyNodeVisitor;\nimport org.apache.maven.shared.dependency.graph.traversal.FilteringDependencyNodeVisitor;\nimport org.apache.maven.toolchain.Toolchain;\nimport org.apache.maven.toolchain.ToolchainManager;\nimport org.codehaus.plexus.util.StringUtils;\nimport scala_maven_dependency.CheckScalaVersionVisitor;\nimport scala_maven_dependency.ScalaDistroArtifactFilter;\nimport scala_maven_executions.JavaMainCaller;\nimport scala_maven_executions.JavaMainCallerByFork;\nimport scala_maven_executions.JavaMainCallerInProcess;\nimport scala_maven_executions.MainHelper;\n\npublic abstract class ScalaMojoSupport extends AbstractMojo {\n\n  protected static final String SCALA_LIBRARY_ARTIFACTID = \"scala-library\";\n  protected static final String SCALA_REFLECT_ARTIFACTID = \"scala-reflect\";\n  protected static final String SCALA_COMPILER_ARTIFACTID = \"scala-compiler\";\n\n  protected static final String SCALA3_LIBRARY_ARTIFACTID = \"scala3-library\";\n  protected static final String SCALA3_INTERFACES_ARTIFACTID = \"scala3-interfaces\";\n  protected static final String SCALA3_REFLECT_ARTIFACTID = \"scala3-reflect\";\n  protected static final String SCALA3_COMPILER_ARTIFACTID = \"scala3-compiler\";\n\n  /** Constant {@link String} for \"pom\". Used to specify the Maven POM artifact type. */\n  protected static final String POM = \"pom\";\n\n  /** Constant {@link String} for \"jar\". Used to specify the Maven JAR artifact type. */\n  static final String JAR = \"jar\";\n\n  /** The maven project. */\n  @Parameter(property = \"project\", required = true, readonly = true)\n  protected MavenProject project;\n\n  /**\n   * The Maven Session Object\n   *\n   * <p>Note: Allows extending for 3rd-party usages\n   */\n  @Parameter(property = \"session\", required = true, readonly = true)\n  protected MavenSession session;\n\n  /** Used to look up Artifacts in the remote repository. */\n  @Component RepositorySystem factory;\n\n  /** Used to look up Artifacts in the remote repository. */\n  @Component protected ArtifactResolver resolver;\n\n  /** Location of the local repository. */\n  @Parameter(property = \"localRepository\", readonly = true, required = true)\n  private ArtifactRepository localRepo;\n\n  /** List of Remote Repositories used by the resolver */\n  @Parameter(property = \"project.remoteArtifactRepositories\", readonly = true, required = true)\n  private List<ArtifactRepository> remoteRepos;\n\n  /**\n   * Additional dependencies/jar to add to classpath to run \"scalaClassName\" (scope and optional\n   * field not supported) ex :\n   *\n   * <pre>\n   *    &lt;dependencies&gt;\n   *      &lt;dependency&gt;\n   *        &lt;groupId&gt;org.scala-tools&lt;/groupId&gt;\n   *        &lt;artifactId&gt;scala-compiler-addon&lt;/artifactId&gt;\n   *        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n   *      &lt;/dependency&gt;\n   *    &lt;/dependencies&gt;\n   * <\/pre>\n   */\n  @Parameter protected BasicArtifact[] dependencies;\n\n  /**\n   * Compiler plugin dependencies to use when compiling. ex:\n   *\n   * <pre>\n   * &lt;compilerPlugins&gt;\n   *   &lt;compilerPlugin&gt;\n   *     &lt;groupId&gt;my.scala.plugin&lt;/groupId&gt;\n   *     &lt;artifactId&gt;amazingPlugin&lt;/artifactId&gt;\n   *     &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n   *   &lt;/compilerPlugin&gt;\n   * &lt;/compilerPlugins&gt;\n   * <\/pre>\n   */\n  @Parameter private BasicArtifact[] compilerPlugins;\n\n  /** Jvm Arguments. */\n  @Parameter protected String[] jvmArgs;\n\n  /** compiler additional arguments */\n  @Parameter protected String[] args;\n\n  /**\n   * Additional parameter to use to call the main class. Use this parameter only from command line\n   * (\"-DaddScalacArgs=arg1|arg2|arg3|...\"), not from pom.xml. To define compiler arguments in\n   * pom.xml see the \"args\" parameter.\n   */\n  @Parameter(property = \"addScalacArgs\")\n  private String addScalacArgs;\n\n  /** className (FQN) of the scala tool to provide as */\n  @Parameter(\n      required = true,\n      property = \"maven.scala.className\",\n      defaultValue = \"scala.tools.nsc.Main\")\n  protected String scalaClassName;\n\n  /** Scala 's version to use. (property 'maven.scala.version' replaced by 'scala.version') */\n  @Parameter(property = \"scala.version\")\n  private String scalaVersion;\n\n  /**\n   * Organization/group ID of the Scala used in the project. Default value is 'org.scala-lang'. This\n   * is an advanced setting used for clones of the Scala Language. It should be disregarded in\n   * standard use cases.\n   */\n  @Parameter(property = \"scala.organization\", defaultValue = \"org.scala-lang\")\n  private String scalaOrganization;\n\n  public String getScalaOrganization() {\n    return scalaOrganization;\n  }\n\n  /**\n   * Scala 's version to use to check binary compatibility (like suffix in artifactId of\n   * dependency). If it is defined then it is used to checkMultipleScalaVersions\n   */\n  @Parameter(property = \"scala.compat.version\")\n  private String scalaCompatVersion;\n\n  /** Path to Scala installation to use instead of the artifact (define as dependencies). */\n  @Parameter(property = \"scala.home\")\n  private String scalaHome;\n\n  /** Arguments for javac (when using incremental compiler). */\n  @Parameter(property = \"javacArgs\")\n  protected String[] javacArgs;\n\n  /**\n   * Whether to instruct javac to generate debug symbols (when using incremental compiler)\n   *\n   * @see <a href=\n   *     \"http://maven.apache.org/plugins/maven-compiler-plugin/compile-mojo.html#debug\">://maven.apache.org/plugins/maven-compiler-plugin/compile-mojo.html#debug<\/a>\n   */\n  @Parameter(property = \"javacGenerateDebugSymbols\", defaultValue = \"true\")\n  protected boolean javacGenerateDebugSymbols = true;\n\n  /**\n   * Alternative method for specifying javac arguments (when using incremental compiler). Can be\n   * used from command line with -DaddJavacArgs=arg1|arg2|arg3|... rather than in pom.xml.\n   */\n  @Parameter(property = \"addJavacArgs\")\n  protected String addJavacArgs;\n\n  /** The -source argument for the Java compiler (when using incremental compiler). */\n  @Parameter(property = \"maven.compiler.source\")\n  protected String source;\n\n  /** The -target argument for the Java compiler (when using incremental compiler). */\n  @Parameter(property = \"maven.compiler.target\")\n  protected String target;\n\n  /** The -encoding argument for the Java compiler. (when using incremental compiler). */\n  @Parameter(property = \"project.build.sourceEncoding\", defaultValue = \"UTF-8\")\n  protected String encoding;\n\n  /**\n   * Display the command line called ? (property 'maven.scala.displayCmd' replaced by 'displayCmd')\n   */\n  @Parameter(property = \"displayCmd\", defaultValue = \"false\", required = true)\n  public boolean displayCmd;\n\n  /** Forks the execution of scalac into a separate process. */\n  @Parameter(defaultValue = \"true\")\n  protected boolean fork = true;\n\n  /** Force the use of an external ArgFile to run any forked process. */\n  @Parameter(defaultValue = \"false\")\n  protected boolean forceUseArgFile = false;\n\n  /** Check if every dependencies use the same version of scala-library or scala.compat.version. */\n  @Parameter(property = \"maven.scala.checkConsistency\", defaultValue = \"true\")\n  protected boolean checkMultipleScalaVersions;\n\n  /**\n   * Determines if a detection of multiple scala versions in the dependencies will cause the build\n   * to fail.\n   */\n  @Parameter(defaultValue = \"false\")\n  protected boolean failOnMultipleScalaVersions = false;\n\n  /**\n   * Should use CanonicalPath to normalize path (true =&gt; getCanonicalPath, false =&gt;\n   * getAbsolutePath)\n   *\n   * @see <a href=\n   *     \"https://github.com/davidB/scala-maven-plugin/issues/50\">https://github.com/davidB/scala-maven-plugin/issues/50<\/a>\n   */\n  @Parameter(property = \"maven.scala.useCanonicalPath\", defaultValue = \"true\")\n  protected boolean useCanonicalPath = true;\n\n  /** Artifact factory, needed to download source jars. */\n  @Component protected MavenProjectBuilder mavenProjectBuilder;\n\n  /** The artifact repository to use. */\n  @Parameter(property = \"localRepository\", required = true, readonly = true)\n  private ArtifactRepository localRepository;\n\n  /** The artifact factory to use. */\n  @Component private ArtifactFactory artifactFactory;\n\n  /** The artifact metadata source to use. */\n  @Component private ArtifactMetadataSource artifactMetadataSource;\n\n  /** The artifact collector to use. */\n  @Component private ArtifactCollector artifactCollector;\n\n  /** The dependency tree builder to use. */\n  @Component private DependencyGraphBuilder dependencyGraphBuilder;\n\n  /** The toolchain manager to use. */\n  @Component protected ToolchainManager toolchainManager;\n\n  /** List of artifacts to run plugin */\n  @Parameter(defaultValue = \"${plugin.artifacts}\")\n  private List<Artifact> pluginArtifacts;\n\n  private VersionNumber _scalaVersionN;\n\n  /**\n   * Constructs an {@link Artifact} for Scala Compiler.\n   *\n   * @param scalaVersion the version of the Scala Compiler/Library we are using for this execution.\n   * @return a {@link Artifact} for the Scala Compiler.\n   */\n  protected final Artifact scalaCompilerArtifact(String scalaVersion) {\n    return factory.createArtifact(\n        getScalaOrganization(),\n        scalaVersion.startsWith(\"3\")\n            ? SCALA3_COMPILER_ARTIFACTID\n            : ScalaMojoSupport.SCALA_COMPILER_ARTIFACTID,\n        scalaVersion,\n        \"\",\n        ScalaMojoSupport.POM);\n  }\n\n  /**\n   * This method resolves all transitive dependencies of an artifact.\n   *\n   * @param artifact the {@link Artifact} used to retrieve dependencies.\n   * @return resolved {@link Set} of dependencies.\n   */\n  final Set<Artifact> resolveArtifactDependencies(final Artifact artifact) {\n    final AndArtifactFilter filter = new AndArtifactFilter();\n    filter.add(new ScopeArtifactFilter(Artifact.SCOPE_TEST));\n    filter.add(art -> !art.isOptional());\n\n    // Use the collection filter as the resolution filter.\n    return resolveDependencyArtifacts(artifact, filter, filter);\n  }\n\n  /**\n   * This method resolves all transitive dependencies of an artifact.\n   *\n   * @param artifact the {@link Artifact} used to retrieve dependencies.\n   * @param collectionFilter an {@link ArtifactFilter} used to determine which members dependency\n   *     graph should be downloaded.\n   * @param resolutionFilter an {@link ArtifactFilter} used to determine which members of the\n   *     dependency graph should be included in resolution.\n   * @return resolved {@link Set} of dependencies.\n   */\n  private Set<Artifact> resolveDependencyArtifacts(\n      final Artifact artifact,\n      final ArtifactFilter collectionFilter,\n      final ArtifactFilter resolutionFilter) {\n    return resolveDependencyArtifacts(\n        artifact, collectionFilter, resolutionFilter, this.remoteRepos, this.localRepo);\n  }\n\n  /**\n   * This method resolves all transitive dependencies of an artifact.\n   *\n   * @param artifact the {@link Artifact} used to retrieve dependencies.\n   * @param collectionFilter an {@link ArtifactFilter} used to determine which members of the\n   *     dependency graph should be included in resolution.\n   * @param resolutionFilter an {@link ArtifactFilter} used to determine which members of the\n   *     dependency graph should be included in resolution.\n   * @param remoteRepositories a {@link List} of remote {@link ArtifactRepository} values to used\n   *     for dependency resolution of the provided {@link Artifact}.\n   * @param localRepository the local {@link ArtifactRepository} to use for dependency resolution of\n   *     the given {@link Artifact}.\n   * @return resolved {@link Set} of dependencies.\n   */\n  private Set<Artifact> resolveDependencyArtifacts(\n      final Artifact artifact,\n      final ArtifactFilter collectionFilter,\n      final ArtifactFilter resolutionFilter,\n      final List<ArtifactRepository> remoteRepositories,\n      final ArtifactRepository localRepository) {\n    final ArtifactResolutionRequest arr =\n        this.createArtifactResolutionRequest(\n            artifact, collectionFilter, resolutionFilter, remoteRepositories, localRepository);\n\n    // TODO follow the dependenciesManagement and override rules\n    return factory.resolve(arr).getArtifacts();\n  }\n\n  /**\n   * Create a {@link ArtifactResolutionRequest}.\n   *\n   * @param artifact the {@link Artifact} used to retrieve dependencies.\n   * @param collectionFilter an {@link ArtifactFilter} used to determine which members dependency\n   *     graph should be downloaded.\n   * @param resolutionFilter an {@link ArtifactFilter} used to determine which members of the\n   *     dependency graph should be included in resolution\n   * @param remoteRepositories a {@link List} of remote {@link ArtifactRepository} values to used\n   *     for dependency resolution of the provided {@link Artifact}.\n   * @param localRepository the local {@link ArtifactRepository} to use for dependency resolution of\n   *     the given {@link Artifact}.\n   * @return an {@link ArtifactResolutionRequest}, typically used for dependency resolution requests\n   *     against an {@link ArtifactResolver}.\n   */\n  private ArtifactResolutionRequest createArtifactResolutionRequest(\n      final Artifact artifact,\n      final ArtifactFilter collectionFilter,\n      final ArtifactFilter resolutionFilter,\n      final List<ArtifactRepository> remoteRepositories,\n      final ArtifactRepository localRepository) {\n    final ArtifactResolutionRequest arr = new ArtifactResolutionRequest();\n\n    arr.setArtifact(artifact);\n    arr.setCollectionFilter(collectionFilter);\n    arr.setResolutionFilter(resolutionFilter);\n    arr.setResolveRoot(false);\n    arr.setResolveTransitively(true);\n    arr.setRemoteRepositories(remoteRepositories);\n    arr.setLocalRepository(localRepository);\n\n    return arr;\n  }\n\n  private void addToClasspath(\n      String groupId, String artifactId, String version, Set<String> classpath) throws Exception {\n    addToClasspath(groupId, artifactId, version, classpath, true);\n  }\n\n  private void addToClasspath(\n      String groupId,\n      String artifactId,\n      String version,\n      Set<String> classpath,\n      boolean addDependencies)\n      throws Exception {\n    addToClasspath(\n        factory.createArtifact(\n            groupId, artifactId, version, Artifact.SCOPE_RUNTIME, ScalaMojoSupport.JAR),\n        classpath,\n        addDependencies);\n  }\n\n  /**\n   * added for classifier support.\n   *\n   * @author Christoph Radig\n   * @todo might want to merge with existing \"addToClasspath\" methods.\n   */\n  private void addToClasspath(\n      String groupId,\n      String artifactId,\n      String version,\n      String classifier,\n      Set<String> classpath,\n      boolean addDependencies)\n      throws Exception {\n    Dependency d = new Dependency();\n    d.setGroupId(groupId);\n    d.setArtifactId(artifactId);\n    d.setVersion(version);\n    d.setType(ScalaMojoSupport.JAR);\n    d.setClassifier(classifier);\n    d.setScope(Artifact.SCOPE_RUNTIME);\n    addToClasspath(factory.createDependencyArtifact(d), classpath, addDependencies);\n  }\n\n  void addToClasspath(Artifact artifact, Set<String> classpath, boolean addDependencies)\n      throws Exception {\n    resolver.resolve(artifact, remoteRepos, localRepo);\n    classpath.add(FileUtils.pathOf(artifact.getFile(), useCanonicalPath));\n    if (addDependencies) {\n      for (Artifact dep : resolveArtifactDependencies(artifact)) {\n        addToClasspath(dep, classpath, addDependencies);\n      }\n    }\n  }\n\n  void addCompilerToClasspath(Set<String> classpath) throws Exception {\n    classpath.add(FileUtils.pathOf(getCompilerJar(), useCanonicalPath));\n    for (File dep : getCompilerDependencies()) {\n      classpath.add(FileUtils.pathOf(dep, useCanonicalPath));\n    }\n  }\n\n  void addLibraryToClasspath(Set<String> classpath) throws Exception {\n    classpath.add(FileUtils.pathOf(getLibraryJar(), useCanonicalPath));\n  }\n\n  @Override\n  public void execute() throws MojoExecutionException, MojoFailureException {\n    try {\n      String oldWay = System.getProperty(\"maven.scala.version\");\n      if (oldWay != null) {\n        getLog().warn(\"using 'maven.scala.version' is deprecated, use 'scala.version' instead\");\n        if (scalaVersion != null) {\n          scalaVersion = oldWay;\n        }\n      }\n\n      oldWay = System.getProperty(\"maven.scala.displayCmd\");\n      if (oldWay != null) {\n        getLog().warn(\"using 'maven.scala.displayCmd' is deprecated, use 'displayCmd' instead\");\n        displayCmd = displayCmd || Boolean.parseBoolean(oldWay);\n      }\n      checkScalaVersion();\n      doExecute();\n    } catch (MojoExecutionException exc) {\n      throw exc;\n    } catch (MojoFailureException | RuntimeException exc) {\n      throw exc;\n    } catch (Exception exc) {\n      throw new MojoExecutionException(\"wrap: \" + exc, exc);\n    }\n  }\n\n  protected List<Dependency> getDependencies() {\n    return project.getCompileDependencies();\n  }\n\n  VersionNumber findScalaVersion() throws Exception {\n    if (_scalaVersionN == null) {\n      String detectedScalaVersion = scalaVersion;\n      if (StringUtils.isEmpty(detectedScalaVersion)) {\n        detectedScalaVersion = findScalaVersionFromDependencies();\n      }\n      if (StringUtils.isEmpty(detectedScalaVersion)) {\n        if (!ScalaMojoSupport.POM.equals(project.getPackaging())) {\n          String error =\n              getScalaOrganization()\n                  + \":\"\n                  + (_scalaVersionN.major == 3\n                      ? getScala3ArtifactId(SCALA3_LIBRARY_ARTIFACTID)\n                      : SCALA_LIBRARY_ARTIFACTID)\n                  + \" is missing from project dependencies\";\n          getLog().error(error);\n          throw new UnsupportedOperationException(error);\n        }\n      } else {\n        // grappy hack to retrieve the SNAPSHOT version without timestamp,...\n        // because if version is -SNAPSHOT and artifact is deploy with uniqueValue then\n        // the version\n        // get from dependency is with the timestamp and a build number (the resolved\n        // version)\n        // but scala-compiler with the same version could have different resolved\n        // version (timestamp,...)\n        boolean isSnapshot = ArtifactUtils.isSnapshot(detectedScalaVersion);\n        if (isSnapshot && !detectedScalaVersion.endsWith(\"-SNAPSHOT\")) {\n          detectedScalaVersion =\n              detectedScalaVersion.substring(\n                      0,\n                      detectedScalaVersion.lastIndexOf(\n                          '-', detectedScalaVersion.lastIndexOf('-') - 1))\n                  + \"-SNAPSHOT\";\n        }\n      }\n      if (StringUtils.isEmpty(detectedScalaVersion)) {\n        throw new MojoFailureException(\"no scalaVersion detected or set\");\n      }\n      if (StringUtils.isNotEmpty(scalaVersion)) {\n        if (!scalaVersion.equals(detectedScalaVersion)) {\n          getLog()\n              .warn(\n                  \"scala library version define in dependencies doesn't match the scalaVersion of the plugin\");\n        }\n        // getLog().info(\"suggestion: remove the scalaVersion from pom.xml\");\n        // //scalaVersion could be define in a parent pom where lib is not required\n      }\n      _scalaVersionN = new VersionNumber(detectedScalaVersion);\n    }\n    return _scalaVersionN;\n  }\n\n  private String findScalaVersionFromDependencies() {\n    return findVersionFromDependencies(\n        getScalaOrganization(),\n        new HashSet<String>(Arrays.asList(SCALA3_LIBRARY_ARTIFACTID, SCALA_LIBRARY_ARTIFACTID)));\n  }\n\n  // TODO refactor to do only one scan of dependencies to find version\n  private String findVersionFromDependencies(String groupId, Set<String> artifactId) {\n    String version = null;\n    for (Dependency dep : getDependencies()) {\n      if (groupId.equals(dep.getGroupId()) && artifactId.contains(dep.getArtifactId())) {\n        version = dep.getVersion();\n      }\n    }\n    if (StringUtils.isEmpty(version)) {\n      List<Dependency> deps = new ArrayList<>();\n      deps.addAll(project.getModel().getDependencies());\n      if (project.getModel().getDependencyManagement() != null) {\n        deps.addAll(project.getModel().getDependencyManagement().getDependencies());\n      }\n      for (Dependency dep : deps) {\n        if (groupId.equals(dep.getGroupId()) && artifactId.contains(dep.getArtifactId())) {\n          version = dep.getVersion();\n        }\n      }\n    }\n    return version;\n  }\n\n  void checkScalaVersion() throws Exception {\n    String sv = findScalaVersion().toString();\n    if (StringUtils.isNotEmpty(scalaHome)) {\n      getLog()\n          .warn(\n              String.format(\n                  \"local scala-library.jar and scala-compiler.jar from scalaHome(%s) used instead of scala %s\",\n                  scalaHome, sv));\n    }\n    if (checkMultipleScalaVersions) {\n      checkCorrectVersionsOfScalaLibrary(sv);\n    }\n  }\n\n  /**\n   * this method checks to see if there are multiple versions of the scala library\n   *\n   * @throws Exception\n   */\n  private void checkCorrectVersionsOfScalaLibrary(String scalaDefVersion) throws Exception {\n    getLog().debug(\"Checking for multiple versions of scala\");\n    // TODO - Make sure we handle bad artifacts....\n    // TODO: note that filter does not get applied due to MNG-3236\n    VersionNumber sv = new VersionNumber(scalaDefVersion);\n    VersionNumber requiredScalaVersion =\n        StringUtils.isNotEmpty(scalaCompatVersion) ? new VersionNumberMask(scalaCompatVersion) : sv;\n    if (requiredScalaVersion.compareTo(sv) != 0) {\n      String msg =\n          String.format(\n              \"Scala library detected %s doesn't match scala.compat.version : %s\",\n              sv, requiredScalaVersion);\n      if (failOnMultipleScalaVersions) {\n        getLog().error(msg);\n        throw new MojoFailureException(msg);\n      }\n      getLog().warn(msg);\n    }\n    ProjectBuildingRequest request =\n        new DefaultProjectBuildingRequest(session.getProjectBuildingRequest());\n    request.setProject(project);\n    checkArtifactForScalaVersion(\n        requiredScalaVersion, dependencyGraphBuilder.buildDependencyGraph(request, null));\n  }\n\n  /** Visits a node (and all dependencies) to see if it contains duplicate scala versions */\n  private void checkArtifactForScalaVersion(\n      VersionNumber requiredScalaVersion, DependencyNode rootNode) throws Exception {\n    final CheckScalaVersionVisitor visitor =\n        new CheckScalaVersionVisitor(requiredScalaVersion, getLog(), getScalaOrganization());\n\n    CollectingDependencyNodeVisitor collectingVisitor = new CollectingDependencyNodeVisitor();\n    DependencyNodeVisitor firstPassVisitor =\n        new FilteringDependencyNodeVisitor(collectingVisitor, createScalaDistroDependencyFilter());\n    rootNode.accept(firstPassVisitor);\n\n    DependencyNodeFilter secondPassFilter =\n        new AncestorOrSelfDependencyNodeFilter(collectingVisitor.getNodes());\n    DependencyNodeVisitor filteredVisitor =\n        new FilteringDependencyNodeVisitor(visitor, secondPassFilter);\n\n    rootNode.accept(filteredVisitor);\n\n    if (visitor.isFailed()) {\n      visitor.logScalaDependents();\n      if (failOnMultipleScalaVersions) {\n        getLog().error(\"Multiple versions of scala libraries detected!\");\n        throw new MojoFailureException(\"Multiple versions of scala libraries detected!\");\n      }\n      getLog().warn(\"Multiple versions of scala libraries detected!\");\n    }\n  }\n\n  /** @return A filter to only extract artifacts deployed from scala distributions */\n  private DependencyNodeFilter createScalaDistroDependencyFilter() {\n    List<DependencyNodeFilter> filters = new ArrayList<>();\n    filters.add(new ScalaDistroArtifactFilter(getScalaOrganization()));\n    return new AndDependencyNodeFilter(filters);\n  }\n\n  protected abstract void doExecute() throws Exception;\n\n  protected JavaMainCaller getScalaCommand() throws Exception {\n    return getScalaCommand(fork, scalaClassName);\n  }\n\n  /**\n   * Get a {@link JavaMainCaller} used invoke a Java process. Typically this will be one of the\n   * Scala utilities (Compiler, ScalaDoc, REPL, etc.).\n   *\n   * <p>This method does some setup on the {@link JavaMainCaller} which is not done by merely\n   * invoking {@code new} on one of the implementations. Specifically, it adds any Scala compiler\n   * plugin options, JVM options, and Scalac options defined on the plugin.\n   *\n   * @param forkOverride override the setting for {@link #fork}. Currently this should only be set\n   *     if you are invoking the REPL.\n   * @param mainClass the JVM main class to invoke.\n   * @return a {@link JavaMainCaller} to use to invoke the given command.\n   */\n  final JavaMainCaller getScalaCommand(final boolean forkOverride, final String mainClass)\n      throws Exception {\n    JavaMainCaller cmd = getEmptyScalaCommand(mainClass, forkOverride);\n    cmd.addArgs(args);\n    if (StringUtils.isNotEmpty(addScalacArgs)) {\n      cmd.addArgs(StringUtils.split(addScalacArgs, \"|\"));\n    }\n    addCompilerPluginOptions(cmd);\n    cmd.addJvmArgs(jvmArgs);\n    return cmd;\n  }\n\n  /**\n   * Get a {@link JavaMainCaller} used invoke a Java process. Typically this will be one of the\n   * Scala utilities (Compiler, ScalaDoc, REPL, etc.).\n   *\n   * @param mainClass the JVM main class to invoke.\n   * @return a {@link JavaMainCaller} to use to invoke the given command.\n   */\n  final JavaMainCaller getEmptyScalaCommand(final String mainClass) throws Exception {\n    return getEmptyScalaCommand(mainClass, fork);\n  }\n\n  /**\n   * Get a {@link JavaMainCaller} used invoke a Java process. Typically this will be one of the\n   * Scala utilities (Compiler, ScalaDoc, REPL, etc.).\n   *\n   * @param mainClass the JVM main class to invoke.\n   * @param forkOverride override the setting for {@link #fork}. Currently this should only be set\n   *     if you are invoking the REPL.\n   * @return a {@link JavaMainCaller} to use to invoke the given command.\n   */\n  private JavaMainCaller getEmptyScalaCommand(final String mainClass, final boolean forkOverride)\n      throws Exception {\n\n    // If we are deviating from the plugin settings, let the user know\n    // what's going on.\n    if (forkOverride != fork) {\n      super.getLog().info(\"Fork behavior overridden\");\n      super.getLog()\n          .info(String.format(\"Fork for this execution is %s.\", String.valueOf(forkOverride)));\n    }\n\n    // TODO - Fork or not depending on configuration?\n    JavaMainCaller cmd;\n    String toolcp = getToolClasspath();\n    if (forkOverride) {\n      // HACK (better may need refactor)\n      boolean bootcp = true;\n      if (args != null) {\n        for (String arg : args) {\n          bootcp = bootcp && !\"-nobootcp\".equals(arg);\n        }\n      }\n      String cp = bootcp ? \"\" : toolcp;\n      bootcp =\n          bootcp && !(StringUtils.isNotEmpty(addScalacArgs) && addScalacArgs.contains(\"-nobootcp\"));\n      // scalac with args in files\n      // * works only since 2.8.0\n      // * is buggy (don't manage space in path on windows)\n      getLog().debug(\"use java command with args in file forced : \" + forceUseArgFile);\n      cmd =\n          new JavaMainCallerByFork(\n              this, mainClass, cp, null, null, forceUseArgFile, getToolchain());\n      if (bootcp) {\n        cmd.addJvmArgs(\"-Xbootclasspath/a:\" + toolcp);\n      }\n    } else {\n      cmd = new JavaMainCallerInProcess(this, mainClass, toolcp, null, null);\n    }\n    return cmd;\n  }\n\n  protected Toolchain getToolchain() {\n    return toolchainManager.getToolchainFromBuildContext(\"jdk\", session);\n  }\n\n  private String getToolClasspath() throws Exception {\n    Set<String> classpath = new LinkedHashSet<>();\n    addLibraryToClasspath(classpath);\n    addCompilerToClasspath(classpath);\n    if (dependencies != null) {\n      for (BasicArtifact artifact : dependencies) {\n        addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, classpath);\n      }\n    }\n    return MainHelper.toMultiPath(classpath.toArray(new String[] {}));\n  }\n\n  protected List<String> getScalaOptions() throws Exception {\n    List<String> options = new ArrayList<>();\n    if (args != null) Collections.addAll(options, args);\n    if (StringUtils.isNotEmpty(addScalacArgs)) {\n      Collections.addAll(options, StringUtils.split(addScalacArgs, \"|\"));\n    }\n    options.addAll(getCompilerPluginOptions());\n    return options;\n  }\n\n  protected List<String> getJavacOptions() {\n    List<String> options = new ArrayList<>();\n    if (javacArgs != null) Collections.addAll(options, javacArgs);\n    if (StringUtils.isNotEmpty(addJavacArgs)) {\n      Collections.addAll(options, StringUtils.split(addJavacArgs, \"|\"));\n    }\n\n    // issue #116\n    if (javacGenerateDebugSymbols) {\n      options.add(\"-g\");\n    }\n    if (target != null && !target.isEmpty()) {\n      options.add(\"-target\");\n      options.add(target);\n    }\n    if (source != null && !source.isEmpty()) {\n      options.add(\"-source\");\n      options.add(source);\n    }\n    if (encoding != null) {\n      options.add(\"-encoding\");\n      options.add(encoding);\n    }\n    return options;\n  }\n\n  protected String getScala3ArtifactId(String a) {\n    return _scalaVersionN.major == 3 ? a + \"_\" + getBinaryVersionForScala3() : a;\n  }\n\n  private String getBinaryVersionForScala3() {\n    return _scalaVersionN.major == 3\n            && _scalaVersionN.minor == 0\n            && _scalaVersionN.bugfix == 0\n            && _scalaVersionN.modifier != null\n        ? _scalaVersionN.toString()\n        : \"3\";\n  }\n\n  protected File getLibraryJar() throws Exception {\n    return getLibraryJar(findScalaVersion());\n  }\n\n  protected File getLibraryJar(VersionNumber versionNumber) throws Exception {\n    String scalaLibrary =\n        _scalaVersionN.major == 3\n            ? getScala3ArtifactId(SCALA3_LIBRARY_ARTIFACTID)\n            : SCALA_LIBRARY_ARTIFACTID;\n    if (StringUtils.isNotEmpty(scalaHome)) {\n      File lib = new File(scalaHome, \"lib\");\n      return new File(lib, scalaLibrary + \".jar\");\n    }\n    return getArtifactJar(getScalaOrganization(), scalaLibrary, versionNumber.toString());\n  }\n\n  protected File getReflectJar() throws Exception {\n    if (_scalaVersionN.major != 3) {\n      String scalaReflect =\n          _scalaVersionN.major == 3\n              ? getScala3ArtifactId(SCALA3_REFLECT_ARTIFACTID)\n              : SCALA_REFLECT_ARTIFACTID;\n      if (StringUtils.isNotEmpty(scalaHome)) {\n        File lib = new File(scalaHome, \"lib\");\n        return new File(lib, scalaReflect + \".jar\");\n      }\n      return getArtifactJar(getScalaOrganization(), scalaReflect, findScalaVersion().toString());\n    }\n    return null;\n  }\n\n  protected File getCompilerJar() throws Exception {\n    return getCompilerJar(findScalaVersion());\n  }\n\n  protected File getCompilerJar(VersionNumber versionNumber) throws Exception {\n    String scalaCompile =\n        _scalaVersionN.major == 3\n            ? getScala3ArtifactId(SCALA3_COMPILER_ARTIFACTID)\n            : SCALA_COMPILER_ARTIFACTID;\n    if (StringUtils.isNotEmpty(scalaHome)) {\n      File lib = new File(scalaHome, \"lib\");\n      return new File(lib, scalaCompile + \".jar\");\n    }\n    return getArtifactJar(getScalaOrganization(), scalaCompile, versionNumber.toString());\n  }\n\n  protected List<File> getCompilerDependencies() throws Exception {\n    List<File> d = new ArrayList<>();\n    if (StringUtils.isEmpty(scalaHome)) {\n      for (Artifact artifact :\n          getAllDependencies(\n              getScalaOrganization(),\n              _scalaVersionN.major == 3\n                  ? getScala3ArtifactId(SCALA3_COMPILER_ARTIFACTID)\n                  : SCALA_COMPILER_ARTIFACTID,\n              findScalaVersion().toString())) {\n        d.add(artifact.getFile());\n      }\n    } else {\n      for (File f : new File(scalaHome, \"lib\").listFiles()) {\n        String name = f.getName();\n        if (name.endsWith(\".jar\")\n            && (!name.contains(\"scala-library\") || !name.contains(\"scala3-library\"))\n            && (!name.contains(\"scala-compiler\") || !name.contains(\"scala3-compiler\"))) {\n          d.add(f);\n        }\n      }\n    }\n    return d;\n  }\n\n  protected File getArtifactJar(String groupId, String artifactId, String version)\n      throws Exception {\n    Artifact artifact =\n        factory.createArtifact(\n            groupId, artifactId, version, Artifact.SCOPE_RUNTIME, ScalaMojoSupport.JAR);\n    resolver.resolve(artifact, remoteRepos, localRepo);\n    return artifact.getFile();\n  }\n\n  private Set<Artifact> getAllDependencies(String groupId, String artifactId, String version) {\n    Set<Artifact> result = new HashSet<>();\n    Artifact pom = factory.createArtifact(groupId, artifactId, version, \"\", ScalaMojoSupport.POM);\n    Set<Artifact> d = resolveArtifactDependencies(pom);\n    result.addAll(d);\n    for (Artifact dependency : d) {\n      Set<Artifact> transitive =\n          getAllDependencies(\n              dependency.getGroupId(), dependency.getArtifactId(), dependency.getVersion());\n      result.addAll(transitive);\n    }\n    return result;\n  }\n\n  /**\n   * @return This returns whether or not the scala version can support having java sent into the\n   *     compiler\n   */\n  protected boolean isJavaSupportedByCompiler() throws Exception {\n    return findScalaVersion().compareTo(new VersionNumber(\"2.7.2\")) >= 0;\n  }\n\n  /**\n   * Adds appropriate compiler plugins to the scalac command.\n   *\n   * @param scalac\n   * @throws Exception\n   */\n  protected void addCompilerPluginOptions(JavaMainCaller scalac) throws Exception {\n    for (String option : getCompilerPluginOptions()) {\n      scalac.addArgs(option);\n    }\n  }\n\n  private List<String> getCompilerPluginOptions() throws Exception {\n    List<String> options = new ArrayList<>();\n    for (String plugin : getCompilerPlugins()) {\n      options.add(\"-Xplugin:\" + plugin);\n    }\n    return options;\n  }\n\n  /**\n   * Retrieves a list of paths to scala compiler plugins.\n   *\n   * @return The list of plugins\n   * @throws Exception\n   */\n  private Set<String> getCompilerPlugins() throws Exception {\n    Set<String> plugins = new HashSet<>();\n    if (compilerPlugins != null) {\n      Set<String> ignoreClasspath = new LinkedHashSet<>();\n      addCompilerToClasspath(ignoreClasspath);\n      addLibraryToClasspath(ignoreClasspath);\n      for (BasicArtifact artifact : compilerPlugins) {\n        getLog().info(\"compiler plugin: \" + artifact.toString());\n        // TODO - Ensure proper scala version for plugins\n        Set<String> pluginClassPath = new HashSet<>();\n        // TODO - Pull in transitive dependencies.\n        addToClasspath(\n            artifact.groupId,\n            artifact.artifactId,\n            artifact.version,\n            artifact.classifier,\n            pluginClassPath,\n            false);\n        pluginClassPath.removeAll(ignoreClasspath);\n        plugins.addAll(pluginClassPath);\n      }\n    }\n    return plugins;\n  }\n}\n","lineNo":841}
{"Smelly Sample":"\n/*\n * Copyright 2011-2020 scala-maven-plugin project (https://davidb.github.io/scala-maven-plugin/)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage scala_maven;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.ArtifactUtils;\nimport org.apache.maven.artifact.factory.ArtifactFactory;\nimport org.apache.maven.artifact.metadata.ArtifactMetadataSource;\nimport org.apache.maven.artifact.repository.ArtifactRepository;\nimport org.apache.maven.artifact.resolver.ArtifactCollector;\nimport org.apache.maven.artifact.resolver.ArtifactResolutionRequest;\nimport org.apache.maven.artifact.resolver.ArtifactResolver;\nimport org.apache.maven.artifact.resolver.filter.AndArtifactFilter;\nimport org.apache.maven.artifact.resolver.filter.ArtifactFilter;\nimport org.apache.maven.artifact.resolver.filter.ScopeArtifactFilter;\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.model.Dependency;\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugin.MojoFailureException;\nimport org.apache.maven.plugins.annotations.Component;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.project.DefaultProjectBuildingRequest;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.project.MavenProjectBuilder;\nimport org.apache.maven.project.ProjectBuildingRequest;\nimport org.apache.maven.repository.RepositorySystem;\nimport org.apache.maven.shared.dependency.graph.DependencyGraphBuilder;\nimport org.apache.maven.shared.dependency.graph.DependencyNode;\nimport org.apache.maven.shared.dependency.graph.filter.AncestorOrSelfDependencyNodeFilter;\nimport org.apache.maven.shared.dependency.graph.filter.AndDependencyNodeFilter;\nimport org.apache.maven.shared.dependency.graph.filter.DependencyNodeFilter;\nimport org.apache.maven.shared.dependency.graph.traversal.CollectingDependencyNodeVisitor;\nimport org.apache.maven.shared.dependency.graph.traversal.DependencyNodeVisitor;\nimport org.apache.maven.shared.dependency.graph.traversal.FilteringDependencyNodeVisitor;\nimport org.apache.maven.toolchain.Toolchain;\nimport org.apache.maven.toolchain.ToolchainManager;\nimport org.codehaus.plexus.util.StringUtils;\nimport scala_maven_dependency.CheckScalaVersionVisitor;\nimport scala_maven_dependency.ScalaDistroArtifactFilter;\nimport scala_maven_executions.JavaMainCaller;\nimport scala_maven_executions.JavaMainCallerByFork;\nimport scala_maven_executions.JavaMainCallerInProcess;\nimport scala_maven_executions.MainHelper;\n\npublic abstract class ScalaMojoSupport extends AbstractMojo {\n\n  private static final String SCALA_LIBRARY_ARTIFACTID = \"scala-library\";\n  private static final String SCALA_REFLECT_ARTIFACTID = \"scala-reflect\";\n  private static final String SCALA_COMPILER_ARTIFACTID = \"scala-compiler\";\n\n  /** Constant {@link String} for \"pom\". Used to specify the Maven POM artifact type. */\n  protected static final String POM = \"pom\";\n\n  /** Constant {@link String} for \"jar\". Used to specify the Maven JAR artifact type. */\n  static final String JAR = \"jar\";\n\n  /** The maven project. */\n  @Parameter(property = \"project\", required = true, readonly = true)\n  protected MavenProject project;\n\n  /**\n   * The Maven Session Object\n   *\n   * <p>Note: Allows extending for 3rd-party usages\n   */\n  @Parameter(property = \"session\", required = true, readonly = true)\n  protected MavenSession session;\n\n  /** Used to look up Artifacts in the remote repository. */\n  @Component RepositorySystem factory;\n\n  /** Used to look up Artifacts in the remote repository. */\n  @Component private ArtifactResolver resolver;\n\n  /** Location of the local repository. */\n  @Parameter(property = \"localRepository\", readonly = true, required = true)\n  private ArtifactRepository localRepo;\n\n  /** List of Remote Repositories used by the resolver */\n  @Parameter(property = \"project.remoteArtifactRepositories\", readonly = true, required = true)\n  private List<ArtifactRepository> remoteRepos;\n\n  /**\n   * Additional dependencies/jar to add to classpath to run \"scalaClassName\" (scope and optional\n   * field not supported) ex :\n   *\n   * <pre>\n   *    &lt;dependencies&gt;\n   *      &lt;dependency&gt;\n   *        &lt;groupId&gt;org.scala-tools&lt;/groupId&gt;\n   *        &lt;artifactId&gt;scala-compiler-addon&lt;/artifactId&gt;\n   *        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n   *      &lt;/dependency&gt;\n   *    &lt;/dependencies&gt;\n   * <\/pre>\n   */\n  @Parameter protected BasicArtifact[] dependencies;\n\n  /**\n   * Compiler plugin dependencies to use when compiling. ex:\n   *\n   * <pre>\n   * &lt;compilerPlugins&gt;\n   *   &lt;compilerPlugin&gt;\n   *     &lt;groupId&gt;my.scala.plugin&lt;/groupId&gt;\n   *     &lt;artifactId&gt;amazingPlugin&lt;/artifactId&gt;\n   *     &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n   *   &lt;/compilerPlugin&gt;\n   * &lt;/compilerPlugins&gt;\n   * <\/pre>\n   */\n  @Parameter private BasicArtifact[] compilerPlugins;\n\n  /** Jvm Arguments. */\n  @Parameter protected String[] jvmArgs;\n\n  /** compiler additional arguments */\n  @Parameter protected String[] args;\n\n  /**\n   * Additional parameter to use to call the main class. Use this parameter only from command line\n   * (\"-DaddScalacArgs=arg1|arg2|arg3|...\"), not from pom.xml. To define compiler arguments in\n   * pom.xml see the \"args\" parameter.\n   */\n  @Parameter(property = \"addScalacArgs\")\n  private String addScalacArgs;\n\n  /** className (FQN) of the scala tool to provide as */\n  @Parameter(\n      required = true,\n      property = \"maven.scala.className\",\n      defaultValue = \"scala.tools.nsc.Main\")\n  protected String scalaClassName;\n\n  /** Scala 's version to use. (property 'maven.scala.version' replaced by 'scala.version') */\n  @Parameter(property = \"scala.version\")\n  private String scalaVersion;\n\n  /**\n   * Organization/group ID of the Scala used in the project. Default value is 'org.scala-lang'. This\n   * is an advanced setting used for clones of the Scala Language. It should be disregarded in\n   * standard use cases.\n   */\n  @Parameter(property = \"scala.organization\", defaultValue = \"org.scala-lang\")\n  private String scalaOrganization;\n\n  public String getScalaOrganization() {\n    return scalaOrganization;\n  }\n\n  /**\n   * Scala 's version to use to check binary compatibility (like suffix in artifactId of\n   * dependency). If it is defined then it is used to checkMultipleScalaVersions\n   */\n  @Parameter(property = \"scala.compat.version\")\n  private String scalaCompatVersion;\n\n  /** Path to Scala installation to use instead of the artifact (define as dependencies). */\n  @Parameter(property = \"scala.home\")\n  private String scalaHome;\n\n  /** Arguments for javac (when using incremental compiler). */\n  @Parameter(property = \"javacArgs\")\n  protected String[] javacArgs;\n\n  /**\n   * Whether to instruct javac to generate debug symbols (when using incremental compiler)\n   *\n   * @see <a href=\n   *     \"http://maven.apache.org/plugins/maven-compiler-plugin/compile-mojo.html#debug\">://maven.apache.org/plugins/maven-compiler-plugin/compile-mojo.html#debug<\/a>\n   */\n  @Parameter(property = \"javacGenerateDebugSymbols\", defaultValue = \"true\")\n  protected boolean javacGenerateDebugSymbols = true;\n\n  /**\n   * Alternative method for specifying javac arguments (when using incremental compiler). Can be\n   * used from command line with -DaddJavacArgs=arg1|arg2|arg3|... rather than in pom.xml.\n   */\n  @Parameter(property = \"addJavacArgs\")\n  protected String addJavacArgs;\n\n  /** The -source argument for the Java compiler (when using incremental compiler). */\n  @Parameter(property = \"maven.compiler.source\")\n  protected String source;\n\n  /** The -target argument for the Java compiler (when using incremental compiler). */\n  @Parameter(property = \"maven.compiler.target\")\n  protected String target;\n\n  /** The -encoding argument for the Java compiler. (when using incremental compiler). */\n  @Parameter(property = \"project.build.sourceEncoding\", defaultValue = \"UTF-8\")\n  protected String encoding;\n\n  /**\n   * Display the command line called ? (property 'maven.scala.displayCmd' replaced by 'displayCmd')\n   */\n  @Parameter(property = \"displayCmd\", defaultValue = \"false\", required = true)\n  public boolean displayCmd;\n\n  /** Forks the execution of scalac into a separate process. */\n  @Parameter(defaultValue = \"true\")\n  protected boolean fork = true;\n\n  /** Force the use of an external ArgFile to run any forked process. */\n  @Parameter(defaultValue = \"false\")\n  protected boolean forceUseArgFile = false;\n\n  /** Check if every dependencies use the same version of scala-library or scala.compat.version. */\n  @Parameter(property = \"maven.scala.checkConsistency\", defaultValue = \"true\")\n  protected boolean checkMultipleScalaVersions;\n\n  /**\n   * Determines if a detection of multiple scala versions in the dependencies will cause the build\n   * to fail.\n   */\n  @Parameter(defaultValue = \"false\")\n  protected boolean failOnMultipleScalaVersions = false;\n\n  /**\n   * Should use CanonicalPath to normalize path (true =&gt; getCanonicalPath, false =&gt;\n   * getAbsolutePath)\n   *\n   * @see <a href=\n   *     \"https://github.com/davidB/scala-maven-plugin/issues/50\">https://github.com/davidB/scala-maven-plugin/issues/50<\/a>\n   */\n  @Parameter(property = \"maven.scala.useCanonicalPath\", defaultValue = \"true\")\n  protected boolean useCanonicalPath = true;\n\n  /** Artifact factory, needed to download source jars. */\n  @Component protected MavenProjectBuilder mavenProjectBuilder;\n\n  /** The artifact repository to use. */\n  @Parameter(property = \"localRepository\", required = true, readonly = true)\n  private ArtifactRepository localRepository;\n\n  /** The artifact factory to use. */\n  @Component private ArtifactFactory artifactFactory;\n\n  /** The artifact metadata source to use. */\n  @Component private ArtifactMetadataSource artifactMetadataSource;\n\n  /** The artifact collector to use. */\n  @Component private ArtifactCollector artifactCollector;\n\n  /** The dependency tree builder to use. */\n  @Component private DependencyGraphBuilder dependencyGraphBuilder;\n\n  /** The toolchain manager to use. */\n  @Component protected ToolchainManager toolchainManager;\n\n  /** List of artifacts to run plugin */\n  @Parameter(defaultValue = \"${plugin.artifacts}\")\n  private List<Artifact> pluginArtifacts;\n\n  private VersionNumber _scalaVersionN;\n\n  /**\n   * Constructs an {@link Artifact} for Scala Compiler.\n   *\n   * @param scalaVersion the version of the Scala Compiler/Library we are using for this execution.\n   * @return a {@link Artifact} for the Scala Compiler.\n   */\n  final Artifact scalaCompilerArtifact(String scalaVersion) {\n    return factory.createArtifact(\n        getScalaOrganization(),\n        ScalaMojoSupport.SCALA_COMPILER_ARTIFACTID,\n        scalaVersion,\n        \"\",\n        ScalaMojoSupport.POM);\n  }\n\n  /**\n   * This method resolves all transitive dependencies of an artifact.\n   *\n   * @param artifact the {@link Artifact} used to retrieve dependencies.\n   * @return resolved {@link Set} of dependencies.\n   */\n  final Set<Artifact> resolveArtifactDependencies(final Artifact artifact) {\n    final AndArtifactFilter filter = new AndArtifactFilter();\n    filter.add(new ScopeArtifactFilter(Artifact.SCOPE_TEST));\n    filter.add(art -> !art.isOptional());\n\n    // Use the collection filter as the resolution filter.\n    return resolveDependencyArtifacts(artifact, filter, filter);\n  }\n\n  /**\n   * This method resolves all transitive dependencies of an artifact.\n   *\n   * @param artifact the {@link Artifact} used to retrieve dependencies.\n   * @param collectionFilter an {@link ArtifactFilter} used to determine which members dependency\n   *     graph should be downloaded.\n   * @param resolutionFilter an {@link ArtifactFilter} used to determine which members of the\n   *     dependency graph should be included in resolution.\n   * @return resolved {@link Set} of dependencies.\n   */\n  private Set<Artifact> resolveDependencyArtifacts(\n      final Artifact artifact,\n      final ArtifactFilter collectionFilter,\n      final ArtifactFilter resolutionFilter) {\n    return resolveDependencyArtifacts(\n        artifact, collectionFilter, resolutionFilter, this.remoteRepos, this.localRepo);\n  }\n\n  /**\n   * This method resolves all transitive dependencies of an artifact.\n   *\n   * @param artifact the {@link Artifact} used to retrieve dependencies.\n   * @param collectionFilter an {@link ArtifactFilter} used to determine which members of the\n   *     dependency graph should be included in resolution.\n   * @param resolutionFilter an {@link ArtifactFilter} used to determine which members of the\n   *     dependency graph should be included in resolution.\n   * @param remoteRepositories a {@link List} of remote {@link ArtifactRepository} values to used\n   *     for dependency resolution of the provided {@link Artifact}.\n   * @param localRepository the local {@link ArtifactRepository} to use for dependency resolution of\n   *     the given {@link Artifact}.\n   * @return resolved {@link Set} of dependencies.\n   */\n  private Set<Artifact> resolveDependencyArtifacts(\n      final Artifact artifact,\n      final ArtifactFilter collectionFilter,\n      final ArtifactFilter resolutionFilter,\n      final List<ArtifactRepository> remoteRepositories,\n      final ArtifactRepository localRepository) {\n    final ArtifactResolutionRequest arr =\n        this.createArtifactResolutionRequest(\n            artifact, collectionFilter, resolutionFilter, remoteRepositories, localRepository);\n\n    // TODO follow the dependenciesManagement and override rules\n    return factory.resolve(arr).getArtifacts();\n  }\n\n  /**\n   * Create a {@link ArtifactResolutionRequest}.\n   *\n   * @param artifact the {@link Artifact} used to retrieve dependencies.\n   * @param collectionFilter an {@link ArtifactFilter} used to determine which members dependency\n   *     graph should be downloaded.\n   * @param resolutionFilter an {@link ArtifactFilter} used to determine which members of the\n   *     dependency graph should be included in resolution\n   * @param remoteRepositories a {@link List} of remote {@link ArtifactRepository} values to used\n   *     for dependency resolution of the provided {@link Artifact}.\n   * @param localRepository the local {@link ArtifactRepository} to use for dependency resolution of\n   *     the given {@link Artifact}.\n   * @return an {@link ArtifactResolutionRequest}, typically used for dependency resolution requests\n   *     against an {@link ArtifactResolver}.\n   */\n  private ArtifactResolutionRequest createArtifactResolutionRequest(\n      final Artifact artifact,\n      final ArtifactFilter collectionFilter,\n      final ArtifactFilter resolutionFilter,\n      final List<ArtifactRepository> remoteRepositories,\n      final ArtifactRepository localRepository) {\n    final ArtifactResolutionRequest arr = new ArtifactResolutionRequest();\n\n    arr.setArtifact(artifact);\n    arr.setCollectionFilter(collectionFilter);\n    arr.setResolutionFilter(resolutionFilter);\n    arr.setResolveRoot(false);\n    arr.setResolveTransitively(true);\n    arr.setRemoteRepositories(remoteRepositories);\n    arr.setLocalRepository(localRepository);\n\n    return arr;\n  }\n\n  private void addToClasspath(\n      String groupId, String artifactId, String version, Set<String> classpath) throws Exception {\n    addToClasspath(groupId, artifactId, version, classpath, true);\n  }\n\n  private void addToClasspath(\n      String groupId,\n      String artifactId,\n      String version,\n      Set<String> classpath,\n      boolean addDependencies)\n      throws Exception {\n    addToClasspath(\n        factory.createArtifact(\n            groupId, artifactId, version, Artifact.SCOPE_RUNTIME, ScalaMojoSupport.JAR),\n        classpath,\n        addDependencies);\n  }\n\n  /**\n   * added for classifier support.\n   *\n   * @author Christoph Radig\n   * @todo might want to merge with existing \"addToClasspath\" methods.\n   */\n  private void addToClasspath(\n      String groupId,\n      String artifactId,\n      String version,\n      String classifier,\n      Set<String> classpath,\n      boolean addDependencies)\n      throws Exception {\n    Dependency d = new Dependency();\n    d.setGroupId(groupId);\n    d.setArtifactId(artifactId);\n    d.setVersion(version);\n    d.setType(ScalaMojoSupport.JAR);\n    d.setClassifier(classifier);\n    d.setScope(Artifact.SCOPE_RUNTIME);\n    addToClasspath(factory.createDependencyArtifact(d), classpath, addDependencies);\n  }\n\n  void addToClasspath(Artifact artifact, Set<String> classpath, boolean addDependencies)\n      throws Exception {\n    resolver.resolve(artifact, remoteRepos, localRepo);\n    classpath.add(FileUtils.pathOf(artifact.getFile(), useCanonicalPath));\n    if (addDependencies) {\n      for (Artifact dep : resolveArtifactDependencies(artifact)) {\n        addToClasspath(dep, classpath, addDependencies);\n      }\n    }\n  }\n\n  void addCompilerToClasspath(Set<String> classpath) throws Exception {\n    classpath.add(FileUtils.pathOf(getCompilerJar(), useCanonicalPath));\n    for (File dep : getCompilerDependencies()) {\n      classpath.add(FileUtils.pathOf(dep, useCanonicalPath));\n    }\n  }\n\n  void addLibraryToClasspath(Set<String> classpath) throws Exception {\n    classpath.add(FileUtils.pathOf(getLibraryJar(), useCanonicalPath));\n  }\n\n  @Override\n  public void execute() throws MojoExecutionException, MojoFailureException {\n    try {\n      String oldWay = System.getProperty(\"maven.scala.version\");\n      if (oldWay != null) {\n        getLog().warn(\"using 'maven.scala.version' is deprecated, use 'scala.version' instead\");\n        if (scalaVersion != null) {\n          scalaVersion = oldWay;\n        }\n      }\n\n      oldWay = System.getProperty(\"maven.scala.displayCmd\");\n      if (oldWay != null) {\n        getLog().warn(\"using 'maven.scala.displayCmd' is deprecated, use 'displayCmd' instead\");\n        displayCmd = displayCmd || Boolean.parseBoolean(oldWay);\n      }\n      checkScalaVersion();\n      doExecute();\n    } catch (MojoExecutionException exc) {\n      throw exc;\n    } catch (MojoFailureException | RuntimeException exc) {\n      throw exc;\n    } catch (Exception exc) {\n      throw new MojoExecutionException(\"wrap: \" + exc, exc);\n    }\n  }\n\n  protected List<Dependency> getDependencies() {\n    return project.getCompileDependencies();\n  }\n\n  VersionNumber findScalaVersion() throws Exception {\n    if (_scalaVersionN == null) {\n      String detectedScalaVersion = scalaVersion;\n      if (StringUtils.isEmpty(detectedScalaVersion)) {\n        detectedScalaVersion = findScalaVersionFromDependencies();\n      }\n      if (StringUtils.isEmpty(detectedScalaVersion)) {\n        if (!ScalaMojoSupport.POM.equals(project.getPackaging().toLowerCase())) {\n          String error =\n              getScalaOrganization()\n                  + \":\"\n                  + SCALA_LIBRARY_ARTIFACTID\n                  + \" is missing from project dependencies\";\n          getLog().error(error);\n          throw new UnsupportedOperationException(error);\n        }\n      } else {\n        // grappy hack to retrieve the SNAPSHOT version without timestamp,...\n        // because if version is -SNAPSHOT and artifact is deploy with uniqueValue then\n        // the version\n        // get from dependency is with the timestamp and a build number (the resolved\n        // version)\n        // but scala-compiler with the same version could have different resolved\n        // version (timestamp,...)\n        boolean isSnapshot = ArtifactUtils.isSnapshot(detectedScalaVersion);\n        if (isSnapshot && !detectedScalaVersion.endsWith(\"-SNAPSHOT\")) {\n          detectedScalaVersion =\n              detectedScalaVersion.substring(\n                      0,\n                      detectedScalaVersion.lastIndexOf(\n                          '-', detectedScalaVersion.lastIndexOf('-') - 1))\n                  + \"-SNAPSHOT\";\n        }\n      }\n      if (StringUtils.isEmpty(detectedScalaVersion)) {\n        throw new MojoFailureException(\"no scalaVersion detected or set\");\n      }\n      if (StringUtils.isNotEmpty(scalaVersion)) {\n        if (!scalaVersion.equals(detectedScalaVersion)) {\n          getLog()\n              .warn(\n                  \"scala library version define in dependencies doesn't match the scalaVersion of the plugin\");\n        }\n        // getLog().info(\"suggestion: remove the scalaVersion from pom.xml\");\n        // //scalaVersion could be define in a parent pom where lib is not required\n      }\n      _scalaVersionN = new VersionNumber(detectedScalaVersion);\n    }\n    return _scalaVersionN;\n  }\n\n  private String findScalaVersionFromDependencies() {\n    return findVersionFromDependencies(getScalaOrganization(), SCALA_LIBRARY_ARTIFACTID);\n  }\n\n  // TODO refactor to do only one scan of dependencies to find version\n  private String findVersionFromDependencies(String groupId, String artifactId) {\n    String version = null;\n    for (Dependency dep : getDependencies()) {\n      if (groupId.equals(dep.getGroupId()) && artifactId.equals(dep.getArtifactId())) {\n        version = dep.getVersion();\n      }\n    }\n    if (StringUtils.isEmpty(version)) {\n      List<Dependency> deps = new ArrayList<>();\n      deps.addAll(project.getModel().getDependencies());\n      if (project.getModel().getDependencyManagement() != null) {\n        deps.addAll(project.getModel().getDependencyManagement().getDependencies());\n      }\n      for (Dependency dep : deps) {\n        if (groupId.equals(dep.getGroupId()) && artifactId.equals(dep.getArtifactId())) {\n          version = dep.getVersion();\n        }\n      }\n    }\n    return version;\n  }\n\n  void checkScalaVersion() throws Exception {\n    String sv = findScalaVersion().toString();\n    if (StringUtils.isNotEmpty(scalaHome)) {\n      getLog()\n          .warn(\n              String.format(\n                  \"local scala-library.jar and scala-compiler.jar from scalaHome(%s) used instead of scala %s\",\n                  scalaHome, sv));\n    }\n    if (checkMultipleScalaVersions) {\n      checkCorrectVersionsOfScalaLibrary(sv);\n    }\n  }\n\n  /**\n   * this method checks to see if there are multiple versions of the scala library\n   *\n   * @throws Exception\n   */\n  private void checkCorrectVersionsOfScalaLibrary(String scalaDefVersion) throws Exception {\n    getLog().debug(\"Checking for multiple versions of scala\");\n    // TODO - Make sure we handle bad artifacts....\n    // TODO: note that filter does not get applied due to MNG-3236\n    VersionNumber sv = new VersionNumber(scalaDefVersion);\n    VersionNumber requiredScalaVersion =\n        StringUtils.isNotEmpty(scalaCompatVersion) ? new VersionNumberMask(scalaCompatVersion) : sv;\n    if (requiredScalaVersion.compareTo(sv) != 0) {\n      String msg =\n          String.format(\n              \"Scala library detected %s doesn't match scala.compat.version : %s\",\n              sv, requiredScalaVersion);\n      if (failOnMultipleScalaVersions) {\n        getLog().error(msg);\n        throw new MojoFailureException(msg);\n      }\n      getLog().warn(msg);\n    }\n    ProjectBuildingRequest request =\n        new DefaultProjectBuildingRequest(session.getProjectBuildingRequest());\n    request.setProject(project);\n    checkArtifactForScalaVersion(\n        requiredScalaVersion, dependencyGraphBuilder.buildDependencyGraph(request, null));\n  }\n\n  /** Visits a node (and all dependencies) to see if it contains duplicate scala versions */\n  private void checkArtifactForScalaVersion(\n      VersionNumber requiredScalaVersion, DependencyNode rootNode) throws Exception {\n    final CheckScalaVersionVisitor visitor =\n        new CheckScalaVersionVisitor(requiredScalaVersion, getLog(), getScalaOrganization());\n\n    CollectingDependencyNodeVisitor collectingVisitor = new CollectingDependencyNodeVisitor();\n    DependencyNodeVisitor firstPassVisitor =\n        new FilteringDependencyNodeVisitor(collectingVisitor, createScalaDistroDependencyFilter());\n    rootNode.accept(firstPassVisitor);\n\n    DependencyNodeFilter secondPassFilter =\n        new AncestorOrSelfDependencyNodeFilter(collectingVisitor.getNodes());\n    DependencyNodeVisitor filteredVisitor =\n        new FilteringDependencyNodeVisitor(visitor, secondPassFilter);\n\n    rootNode.accept(filteredVisitor);\n\n    if (visitor.isFailed()) {\n      visitor.logScalaDependents();\n      if (failOnMultipleScalaVersions) {\n        getLog().error(\"Multiple versions of scala libraries detected!\");\n        throw new MojoFailureException(\"Multiple versions of scala libraries detected!\");\n      }\n      getLog().warn(\"Multiple versions of scala libraries detected!\");\n    }\n  }\n\n  /** @return A filter to only extract artifacts deployed from scala distributions */\n  private DependencyNodeFilter createScalaDistroDependencyFilter() {\n    List<DependencyNodeFilter> filters = new ArrayList<>();\n    filters.add(new ScalaDistroArtifactFilter(getScalaOrganization()));\n    return new AndDependencyNodeFilter(filters);\n  }\n\n  protected abstract void doExecute() throws Exception;\n\n  protected JavaMainCaller getScalaCommand() throws Exception {\n    return getScalaCommand(fork, scalaClassName);\n  }\n\n  /**\n   * Get a {@link JavaMainCaller} used invoke a Java process. Typically this will be one of the\n   * Scala utilities (Compiler, ScalaDoc, REPL, etc.).\n   *\n   * <p>This method does some setup on the {@link JavaMainCaller} which is not done by merely\n   * invoking {@code new} on one of the implementations. Specifically, it adds any Scala compiler\n   * plugin options, JVM options, and Scalac options defined on the plugin.\n   *\n   * @param forkOverride override the setting for {@link #fork}. Currently this should only be set\n   *     if you are invoking the REPL.\n   * @param mainClass the JVM main class to invoke.\n   * @return a {@link JavaMainCaller} to use to invoke the given command.\n   */\n  final JavaMainCaller getScalaCommand(final boolean forkOverride, final String mainClass)\n      throws Exception {\n    JavaMainCaller cmd = getEmptyScalaCommand(mainClass, forkOverride);\n    cmd.addArgs(args);\n    if (StringUtils.isNotEmpty(addScalacArgs)) {\n      cmd.addArgs(StringUtils.split(addScalacArgs, \"|\"));\n    }\n    addCompilerPluginOptions(cmd);\n    cmd.addJvmArgs(jvmArgs);\n    return cmd;\n  }\n\n  /**\n   * Get a {@link JavaMainCaller} used invoke a Java process. Typically this will be one of the\n   * Scala utilities (Compiler, ScalaDoc, REPL, etc.).\n   *\n   * @param mainClass the JVM main class to invoke.\n   * @return a {@link JavaMainCaller} to use to invoke the given command.\n   */\n  final JavaMainCaller getEmptyScalaCommand(final String mainClass) throws Exception {\n    return getEmptyScalaCommand(mainClass, fork);\n  }\n\n  /**\n   * Get a {@link JavaMainCaller} used invoke a Java process. Typically this will be one of the\n   * Scala utilities (Compiler, ScalaDoc, REPL, etc.).\n   *\n   * @param mainClass the JVM main class to invoke.\n   * @param forkOverride override the setting for {@link #fork}. Currently this should only be set\n   *     if you are invoking the REPL.\n   * @return a {@link JavaMainCaller} to use to invoke the given command.\n   */\n  private JavaMainCaller getEmptyScalaCommand(final String mainClass, final boolean forkOverride)\n      throws Exception {\n\n    // If we are deviating from the plugin settings, let the user know\n    // what's going on.\n    if (forkOverride != fork) {\n      super.getLog().info(\"Fork behavior overridden\");\n      super.getLog()\n          .info(String.format(\"Fork for this execution is %s.\", String.valueOf(forkOverride)));\n    }\n\n    // TODO - Fork or not depending on configuration?\n    JavaMainCaller cmd;\n    String toolcp = getToolClasspath();\n    if (forkOverride) {\n      // HACK (better may need refactor)\n      boolean bootcp = true;\n      if (args != null) {\n        for (String arg : args) {\n          bootcp = bootcp && !\"-nobootcp\".equals(arg);\n        }\n      }\n      String cp = bootcp ? \"\" : toolcp;\n      bootcp =\n          bootcp && !(StringUtils.isNotEmpty(addScalacArgs) && addScalacArgs.contains(\"-nobootcp\"));\n      // scalac with args in files\n      // * works only since 2.8.0\n      // * is buggy (don't manage space in path on windows)\n      getLog().debug(\"use java command with args in file forced : \" + forceUseArgFile);\n      cmd =\n          new JavaMainCallerByFork(\n              this, mainClass, cp, null, null, forceUseArgFile, getToolchain());\n      if (bootcp) {\n        cmd.addJvmArgs(\"-Xbootclasspath/a:\" + toolcp);\n      }\n    } else {\n      cmd = new JavaMainCallerInProcess(this, mainClass, toolcp, null, null);\n    }\n    return cmd;\n  }\n\n  protected Toolchain getToolchain() {\n    return toolchainManager.getToolchainFromBuildContext(\"jdk\", session);\n  }\n\n  private String getToolClasspath() throws Exception {\n    Set<String> classpath = new LinkedHashSet<>();\n    addLibraryToClasspath(classpath);\n    addCompilerToClasspath(classpath);\n    if (dependencies != null) {\n      for (BasicArtifact artifact : dependencies) {\n        addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, classpath);\n      }\n    }\n    return MainHelper.toMultiPath(classpath.toArray(new String[] {}));\n  }\n\n  protected List<String> getScalaOptions() throws Exception {\n    List<String> options = new ArrayList<>();\n    if (args != null) Collections.addAll(options, args);\n    if (StringUtils.isNotEmpty(addScalacArgs)) {\n      Collections.addAll(options, StringUtils.split(addScalacArgs, \"|\"));\n    }\n    options.addAll(getCompilerPluginOptions());\n    return options;\n  }\n\n  protected List<String> getJavacOptions() {\n    List<String> options = new ArrayList<>();\n    if (javacArgs != null) Collections.addAll(options, javacArgs);\n    if (StringUtils.isNotEmpty(addJavacArgs)) {\n      Collections.addAll(options, StringUtils.split(addJavacArgs, \"|\"));\n    }\n\n    // issue #116\n    if (javacGenerateDebugSymbols) {\n      options.add(\"-g\");\n    }\n    if (target != null && !target.isEmpty()) {\n      options.add(\"-target\");\n      options.add(target);\n    }\n    if (source != null && !source.isEmpty()) {\n      options.add(\"-source\");\n      options.add(source);\n    }\n    if (encoding != null) {\n      options.add(\"-encoding\");\n      options.add(encoding);\n    }\n    return options;\n  }\n\n  protected File getLibraryJar() throws Exception {\n    if (StringUtils.isNotEmpty(scalaHome)) {\n      File lib = new File(scalaHome, \"lib\");\n      return new File(lib, SCALA_LIBRARY_ARTIFACTID + \".jar\");\n    }\n    return getArtifactJar(\n        getScalaOrganization(), SCALA_LIBRARY_ARTIFACTID, findScalaVersion().toString());\n  }\n\n  protected File getReflectJar() throws Exception {\n    if (StringUtils.isNotEmpty(scalaHome)) {\n      File lib = new File(scalaHome, \"lib\");\n      return new File(lib, SCALA_REFLECT_ARTIFACTID + \".jar\");\n    }\n    return getArtifactJar(\n        getScalaOrganization(), SCALA_REFLECT_ARTIFACTID, findScalaVersion().toString());\n  }\n\n  protected File getCompilerJar() throws Exception {\n    if (StringUtils.isNotEmpty(scalaHome)) {\n      File lib = new File(scalaHome, \"lib\");\n      return new File(lib, SCALA_COMPILER_ARTIFACTID + \".jar\");\n    }\n    return getArtifactJar(\n        getScalaOrganization(), SCALA_COMPILER_ARTIFACTID, findScalaVersion().toString());\n  }\n\n  protected List<File> getCompilerDependencies() throws Exception {\n    List<File> d = new ArrayList<>();\n    if (StringUtils.isEmpty(scalaHome)) {\n      for (Artifact artifact :\n          getAllDependencies(\n              getScalaOrganization(), SCALA_COMPILER_ARTIFACTID, findScalaVersion().toString())) {\n        d.add(artifact.getFile());\n      }\n    } else {\n      for (File f : new File(scalaHome, \"lib\").listFiles()) {\n        String name = f.getName();\n        if (name.endsWith(\".jar\")\n            && !name.contains(\"scala-library\")\n            && !name.contains(\"scala-compiler\")) {\n          d.add(f);\n        }\n      }\n    }\n    return d;\n  }\n\n  protected File getArtifactJar(String groupId, String artifactId, String version)\n      throws Exception {\n    Artifact artifact =\n        factory.createArtifact(\n            groupId, artifactId, version, Artifact.SCOPE_RUNTIME, ScalaMojoSupport.JAR);\n    resolver.resolve(artifact, remoteRepos, localRepo);\n    return artifact.getFile();\n  }\n\n  private Set<Artifact> getAllDependencies(String groupId, String artifactId, String version) {\n    Set<Artifact> result = new HashSet<>();\n    Artifact pom = factory.createArtifact(groupId, artifactId, version, \"\", ScalaMojoSupport.POM);\n    Set<Artifact> d = resolveArtifactDependencies(pom);\n    result.addAll(d);\n    for (Artifact dependency : d) {\n      Set<Artifact> transitive =\n          getAllDependencies(\n              dependency.getGroupId(), dependency.getArtifactId(), dependency.getVersion());\n      result.addAll(transitive);\n    }\n    return result;\n  }\n\n  /**\n   * @return This returns whether or not the scala version can support having java sent into the\n   *     compiler\n   */\n  protected boolean isJavaSupportedByCompiler() throws Exception {\n    return findScalaVersion().compareTo(new VersionNumber(\"2.7.2\")) >= 0;\n  }\n\n  /**\n   * Adds appropriate compiler plugins to the scalac command.\n   *\n   * @param scalac\n   * @throws Exception\n   */\n  protected void addCompilerPluginOptions(JavaMainCaller scalac) throws Exception {\n    for (String option : getCompilerPluginOptions()) {\n      scalac.addArgs(option);\n    }\n  }\n\n  private List<String> getCompilerPluginOptions() throws Exception {\n    List<String> options = new ArrayList<>();\n    for (String plugin : getCompilerPlugins()) {\n      options.add(\"-Xplugin:\" + plugin);\n    }\n    return options;\n  }\n\n  /**\n   * Retrieves a list of paths to scala compiler plugins.\n   *\n   * @return The list of plugins\n   * @throws Exception\n   */\n  private Set<String> getCompilerPlugins() throws Exception {\n    Set<String> plugins = new HashSet<>();\n    if (compilerPlugins != null) {\n      Set<String> ignoreClasspath = new LinkedHashSet<>();\n      addCompilerToClasspath(ignoreClasspath);\n      addLibraryToClasspath(ignoreClasspath);\n      for (BasicArtifact artifact : compilerPlugins) {\n        getLog().info(\"compiler plugin: \" + artifact.toString());\n        // TODO - Ensure proper scala version for plugins\n        Set<String> pluginClassPath = new HashSet<>();\n        // TODO - Pull in transitive dependencies.\n        addToClasspath(\n            artifact.groupId,\n            artifact.artifactId,\n            artifact.version,\n            artifact.classifier,\n            pluginClassPath,\n            false);\n        pluginClassPath.removeAll(ignoreClasspath);\n        plugins.addAll(pluginClassPath);\n      }\n    }\n    return plugins;\n  }\n}\n","Method after Refactoring":"\n/*\n * Copyright 2011-2020 scala-maven-plugin project (https://davidb.github.io/scala-maven-plugin/)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage scala_maven;\n\nimport java.io.File;\nimport java.util.*;\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.ArtifactUtils;\nimport org.apache.maven.artifact.factory.ArtifactFactory;\nimport org.apache.maven.artifact.metadata.ArtifactMetadataSource;\nimport org.apache.maven.artifact.repository.ArtifactRepository;\nimport org.apache.maven.artifact.resolver.ArtifactCollector;\nimport org.apache.maven.artifact.resolver.ArtifactResolutionRequest;\nimport org.apache.maven.artifact.resolver.ArtifactResolver;\nimport org.apache.maven.artifact.resolver.filter.AndArtifactFilter;\nimport org.apache.maven.artifact.resolver.filter.ArtifactFilter;\nimport org.apache.maven.artifact.resolver.filter.ScopeArtifactFilter;\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.model.Dependency;\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugin.MojoFailureException;\nimport org.apache.maven.plugins.annotations.Component;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.project.DefaultProjectBuildingRequest;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.project.MavenProjectBuilder;\nimport org.apache.maven.project.ProjectBuildingRequest;\nimport org.apache.maven.repository.RepositorySystem;\nimport org.apache.maven.shared.dependency.graph.DependencyGraphBuilder;\nimport org.apache.maven.shared.dependency.graph.DependencyNode;\nimport org.apache.maven.shared.dependency.graph.filter.AncestorOrSelfDependencyNodeFilter;\nimport org.apache.maven.shared.dependency.graph.filter.AndDependencyNodeFilter;\nimport org.apache.maven.shared.dependency.graph.filter.DependencyNodeFilter;\nimport org.apache.maven.shared.dependency.graph.traversal.CollectingDependencyNodeVisitor;\nimport org.apache.maven.shared.dependency.graph.traversal.DependencyNodeVisitor;\nimport org.apache.maven.shared.dependency.graph.traversal.FilteringDependencyNodeVisitor;\nimport org.apache.maven.toolchain.Toolchain;\nimport org.apache.maven.toolchain.ToolchainManager;\nimport org.codehaus.plexus.util.StringUtils;\nimport scala_maven_dependency.CheckScalaVersionVisitor;\nimport scala_maven_dependency.ScalaDistroArtifactFilter;\nimport scala_maven_executions.JavaMainCaller;\nimport scala_maven_executions.JavaMainCallerByFork;\nimport scala_maven_executions.JavaMainCallerInProcess;\nimport scala_maven_executions.MainHelper;\n\npublic abstract class ScalaMojoSupport extends AbstractMojo {\n\n  protected static final String SCALA_LIBRARY_ARTIFACTID = \"scala-library\";\n  protected static final String SCALA_REFLECT_ARTIFACTID = \"scala-reflect\";\n  protected static final String SCALA_COMPILER_ARTIFACTID = \"scala-compiler\";\n\n  protected static final String SCALA3_LIBRARY_ARTIFACTID = \"scala3-library\";\n  protected static final String SCALA3_INTERFACES_ARTIFACTID = \"scala3-interfaces\";\n  protected static final String SCALA3_REFLECT_ARTIFACTID = \"scala3-reflect\";\n  protected static final String SCALA3_COMPILER_ARTIFACTID = \"scala3-compiler\";\n\n  /** Constant {@link String} for \"pom\". Used to specify the Maven POM artifact type. */\n  protected static final String POM = \"pom\";\n\n  /** Constant {@link String} for \"jar\". Used to specify the Maven JAR artifact type. */\n  static final String JAR = \"jar\";\n\n  /** The maven project. */\n  @Parameter(property = \"project\", required = true, readonly = true)\n  protected MavenProject project;\n\n  /**\n   * The Maven Session Object\n   *\n   * <p>Note: Allows extending for 3rd-party usages\n   */\n  @Parameter(property = \"session\", required = true, readonly = true)\n  protected MavenSession session;\n\n  /** Used to look up Artifacts in the remote repository. */\n  @Component RepositorySystem factory;\n\n  /** Used to look up Artifacts in the remote repository. */\n  @Component protected ArtifactResolver resolver;\n\n  /** Location of the local repository. */\n  @Parameter(property = \"localRepository\", readonly = true, required = true)\n  private ArtifactRepository localRepo;\n\n  /** List of Remote Repositories used by the resolver */\n  @Parameter(property = \"project.remoteArtifactRepositories\", readonly = true, required = true)\n  private List<ArtifactRepository> remoteRepos;\n\n  /**\n   * Additional dependencies/jar to add to classpath to run \"scalaClassName\" (scope and optional\n   * field not supported) ex :\n   *\n   * <pre>\n   *    &lt;dependencies&gt;\n   *      &lt;dependency&gt;\n   *        &lt;groupId&gt;org.scala-tools&lt;/groupId&gt;\n   *        &lt;artifactId&gt;scala-compiler-addon&lt;/artifactId&gt;\n   *        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n   *      &lt;/dependency&gt;\n   *    &lt;/dependencies&gt;\n   * <\/pre>\n   */\n  @Parameter protected BasicArtifact[] dependencies;\n\n  /**\n   * Compiler plugin dependencies to use when compiling. ex:\n   *\n   * <pre>\n   * &lt;compilerPlugins&gt;\n   *   &lt;compilerPlugin&gt;\n   *     &lt;groupId&gt;my.scala.plugin&lt;/groupId&gt;\n   *     &lt;artifactId&gt;amazingPlugin&lt;/artifactId&gt;\n   *     &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n   *   &lt;/compilerPlugin&gt;\n   * &lt;/compilerPlugins&gt;\n   * <\/pre>\n   */\n  @Parameter private BasicArtifact[] compilerPlugins;\n\n  /** Jvm Arguments. */\n  @Parameter protected String[] jvmArgs;\n\n  /** compiler additional arguments */\n  @Parameter protected String[] args;\n\n  /**\n   * Additional parameter to use to call the main class. Use this parameter only from command line\n   * (\"-DaddScalacArgs=arg1|arg2|arg3|...\"), not from pom.xml. To define compiler arguments in\n   * pom.xml see the \"args\" parameter.\n   */\n  @Parameter(property = \"addScalacArgs\")\n  private String addScalacArgs;\n\n  /** className (FQN) of the scala tool to provide as */\n  @Parameter(\n      required = true,\n      property = \"maven.scala.className\",\n      defaultValue = \"scala.tools.nsc.Main\")\n  protected String scalaClassName;\n\n  /** Scala 's version to use. (property 'maven.scala.version' replaced by 'scala.version') */\n  @Parameter(property = \"scala.version\")\n  private String scalaVersion;\n\n  /**\n   * Organization/group ID of the Scala used in the project. Default value is 'org.scala-lang'. This\n   * is an advanced setting used for clones of the Scala Language. It should be disregarded in\n   * standard use cases.\n   */\n  @Parameter(property = \"scala.organization\", defaultValue = \"org.scala-lang\")\n  private String scalaOrganization;\n\n  public String getScalaOrganization() {\n    return scalaOrganization;\n  }\n\n  /**\n   * Scala 's version to use to check binary compatibility (like suffix in artifactId of\n   * dependency). If it is defined then it is used to checkMultipleScalaVersions\n   */\n  @Parameter(property = \"scala.compat.version\")\n  private String scalaCompatVersion;\n\n  /** Path to Scala installation to use instead of the artifact (define as dependencies). */\n  @Parameter(property = \"scala.home\")\n  private String scalaHome;\n\n  /** Arguments for javac (when using incremental compiler). */\n  @Parameter(property = \"javacArgs\")\n  protected String[] javacArgs;\n\n  /**\n   * Whether to instruct javac to generate debug symbols (when using incremental compiler)\n   *\n   * @see <a href=\n   *     \"http://maven.apache.org/plugins/maven-compiler-plugin/compile-mojo.html#debug\">://maven.apache.org/plugins/maven-compiler-plugin/compile-mojo.html#debug<\/a>\n   */\n  @Parameter(property = \"javacGenerateDebugSymbols\", defaultValue = \"true\")\n  protected boolean javacGenerateDebugSymbols = true;\n\n  /**\n   * Alternative method for specifying javac arguments (when using incremental compiler). Can be\n   * used from command line with -DaddJavacArgs=arg1|arg2|arg3|... rather than in pom.xml.\n   */\n  @Parameter(property = \"addJavacArgs\")\n  protected String addJavacArgs;\n\n  /** The -source argument for the Java compiler (when using incremental compiler). */\n  @Parameter(property = \"maven.compiler.source\")\n  protected String source;\n\n  /** The -target argument for the Java compiler (when using incremental compiler). */\n  @Parameter(property = \"maven.compiler.target\")\n  protected String target;\n\n  /** The -encoding argument for the Java compiler. (when using incremental compiler). */\n  @Parameter(property = \"project.build.sourceEncoding\", defaultValue = \"UTF-8\")\n  protected String encoding;\n\n  /**\n   * Display the command line called ? (property 'maven.scala.displayCmd' replaced by 'displayCmd')\n   */\n  @Parameter(property = \"displayCmd\", defaultValue = \"false\", required = true)\n  public boolean displayCmd;\n\n  /** Forks the execution of scalac into a separate process. */\n  @Parameter(defaultValue = \"true\")\n  protected boolean fork = true;\n\n  /** Force the use of an external ArgFile to run any forked process. */\n  @Parameter(defaultValue = \"false\")\n  protected boolean forceUseArgFile = false;\n\n  /** Check if every dependencies use the same version of scala-library or scala.compat.version. */\n  @Parameter(property = \"maven.scala.checkConsistency\", defaultValue = \"true\")\n  protected boolean checkMultipleScalaVersions;\n\n  /**\n   * Determines if a detection of multiple scala versions in the dependencies will cause the build\n   * to fail.\n   */\n  @Parameter(defaultValue = \"false\")\n  protected boolean failOnMultipleScalaVersions = false;\n\n  /**\n   * Should use CanonicalPath to normalize path (true =&gt; getCanonicalPath, false =&gt;\n   * getAbsolutePath)\n   *\n   * @see <a href=\n   *     \"https://github.com/davidB/scala-maven-plugin/issues/50\">https://github.com/davidB/scala-maven-plugin/issues/50<\/a>\n   */\n  @Parameter(property = \"maven.scala.useCanonicalPath\", defaultValue = \"true\")\n  protected boolean useCanonicalPath = true;\n\n  /** Artifact factory, needed to download source jars. */\n  @Component protected MavenProjectBuilder mavenProjectBuilder;\n\n  /** The artifact repository to use. */\n  @Parameter(property = \"localRepository\", required = true, readonly = true)\n  private ArtifactRepository localRepository;\n\n  /** The artifact factory to use. */\n  @Component private ArtifactFactory artifactFactory;\n\n  /** The artifact metadata source to use. */\n  @Component private ArtifactMetadataSource artifactMetadataSource;\n\n  /** The artifact collector to use. */\n  @Component private ArtifactCollector artifactCollector;\n\n  /** The dependency tree builder to use. */\n  @Component private DependencyGraphBuilder dependencyGraphBuilder;\n\n  /** The toolchain manager to use. */\n  @Component protected ToolchainManager toolchainManager;\n\n  /** List of artifacts to run plugin */\n  @Parameter(defaultValue = \"${plugin.artifacts}\")\n  private List<Artifact> pluginArtifacts;\n\n  private VersionNumber _scalaVersionN;\n\n  /**\n   * Constructs an {@link Artifact} for Scala Compiler.\n   *\n   * @param scalaVersion the version of the Scala Compiler/Library we are using for this execution.\n   * @return a {@link Artifact} for the Scala Compiler.\n   */\n  protected final Artifact scalaCompilerArtifact(String scalaVersion) {\n    return factory.createArtifact(\n        getScalaOrganization(),\n        scalaVersion.startsWith(\"3\")\n            ? SCALA3_COMPILER_ARTIFACTID\n            : ScalaMojoSupport.SCALA_COMPILER_ARTIFACTID,\n        scalaVersion,\n        \"\",\n        ScalaMojoSupport.POM);\n  }\n\n  /**\n   * This method resolves all transitive dependencies of an artifact.\n   *\n   * @param artifact the {@link Artifact} used to retrieve dependencies.\n   * @return resolved {@link Set} of dependencies.\n   */\n  final Set<Artifact> resolveArtifactDependencies(final Artifact artifact) {\n    final AndArtifactFilter filter = new AndArtifactFilter();\n    filter.add(new ScopeArtifactFilter(Artifact.SCOPE_TEST));\n    filter.add(art -> !art.isOptional());\n\n    // Use the collection filter as the resolution filter.\n    return resolveDependencyArtifacts(artifact, filter, filter);\n  }\n\n  /**\n   * This method resolves all transitive dependencies of an artifact.\n   *\n   * @param artifact the {@link Artifact} used to retrieve dependencies.\n   * @param collectionFilter an {@link ArtifactFilter} used to determine which members dependency\n   *     graph should be downloaded.\n   * @param resolutionFilter an {@link ArtifactFilter} used to determine which members of the\n   *     dependency graph should be included in resolution.\n   * @return resolved {@link Set} of dependencies.\n   */\n  private Set<Artifact> resolveDependencyArtifacts(\n      final Artifact artifact,\n      final ArtifactFilter collectionFilter,\n      final ArtifactFilter resolutionFilter) {\n    return resolveDependencyArtifacts(\n        artifact, collectionFilter, resolutionFilter, this.remoteRepos, this.localRepo);\n  }\n\n  /**\n   * This method resolves all transitive dependencies of an artifact.\n   *\n   * @param artifact the {@link Artifact} used to retrieve dependencies.\n   * @param collectionFilter an {@link ArtifactFilter} used to determine which members of the\n   *     dependency graph should be included in resolution.\n   * @param resolutionFilter an {@link ArtifactFilter} used to determine which members of the\n   *     dependency graph should be included in resolution.\n   * @param remoteRepositories a {@link List} of remote {@link ArtifactRepository} values to used\n   *     for dependency resolution of the provided {@link Artifact}.\n   * @param localRepository the local {@link ArtifactRepository} to use for dependency resolution of\n   *     the given {@link Artifact}.\n   * @return resolved {@link Set} of dependencies.\n   */\n  private Set<Artifact> resolveDependencyArtifacts(\n      final Artifact artifact,\n      final ArtifactFilter collectionFilter,\n      final ArtifactFilter resolutionFilter,\n      final List<ArtifactRepository> remoteRepositories,\n      final ArtifactRepository localRepository) {\n    final ArtifactResolutionRequest arr =\n        this.createArtifactResolutionRequest(\n            artifact, collectionFilter, resolutionFilter, remoteRepositories, localRepository);\n\n    // TODO follow the dependenciesManagement and override rules\n    return factory.resolve(arr).getArtifacts();\n  }\n\n  /**\n   * Create a {@link ArtifactResolutionRequest}.\n   *\n   * @param artifact the {@link Artifact} used to retrieve dependencies.\n   * @param collectionFilter an {@link ArtifactFilter} used to determine which members dependency\n   *     graph should be downloaded.\n   * @param resolutionFilter an {@link ArtifactFilter} used to determine which members of the\n   *     dependency graph should be included in resolution\n   * @param remoteRepositories a {@link List} of remote {@link ArtifactRepository} values to used\n   *     for dependency resolution of the provided {@link Artifact}.\n   * @param localRepository the local {@link ArtifactRepository} to use for dependency resolution of\n   *     the given {@link Artifact}.\n   * @return an {@link ArtifactResolutionRequest}, typically used for dependency resolution requests\n   *     against an {@link ArtifactResolver}.\n   */\n  private ArtifactResolutionRequest createArtifactResolutionRequest(\n      final Artifact artifact,\n      final ArtifactFilter collectionFilter,\n      final ArtifactFilter resolutionFilter,\n      final List<ArtifactRepository> remoteRepositories,\n      final ArtifactRepository localRepository) {\n    final ArtifactResolutionRequest arr = new ArtifactResolutionRequest();\n\n    arr.setArtifact(artifact);\n    arr.setCollectionFilter(collectionFilter);\n    arr.setResolutionFilter(resolutionFilter);\n    arr.setResolveRoot(false);\n    arr.setResolveTransitively(true);\n    arr.setRemoteRepositories(remoteRepositories);\n    arr.setLocalRepository(localRepository);\n\n    return arr;\n  }\n\n  private void addToClasspath(\n      String groupId, String artifactId, String version, Set<String> classpath) throws Exception {\n    addToClasspath(groupId, artifactId, version, classpath, true);\n  }\n\n  private void addToClasspath(\n      String groupId,\n      String artifactId,\n      String version,\n      Set<String> classpath,\n      boolean addDependencies)\n      throws Exception {\n    addToClasspath(\n        factory.createArtifact(\n            groupId, artifactId, version, Artifact.SCOPE_RUNTIME, ScalaMojoSupport.JAR),\n        classpath,\n        addDependencies);\n  }\n\n  /**\n   * added for classifier support.\n   *\n   * @author Christoph Radig\n   * @todo might want to merge with existing \"addToClasspath\" methods.\n   */\n  private void addToClasspath(\n      String groupId,\n      String artifactId,\n      String version,\n      String classifier,\n      Set<String> classpath,\n      boolean addDependencies)\n      throws Exception {\n    Dependency d = new Dependency();\n    d.setGroupId(groupId);\n    d.setArtifactId(artifactId);\n    d.setVersion(version);\n    d.setType(ScalaMojoSupport.JAR);\n    d.setClassifier(classifier);\n    d.setScope(Artifact.SCOPE_RUNTIME);\n    addToClasspath(factory.createDependencyArtifact(d), classpath, addDependencies);\n  }\n\n  void addToClasspath(Artifact artifact, Set<String> classpath, boolean addDependencies)\n      throws Exception {\n    resolver.resolve(artifact, remoteRepos, localRepo);\n    classpath.add(FileUtils.pathOf(artifact.getFile(), useCanonicalPath));\n    if (addDependencies) {\n      for (Artifact dep : resolveArtifactDependencies(artifact)) {\n        addToClasspath(dep, classpath, addDependencies);\n      }\n    }\n  }\n\n  void addCompilerToClasspath(Set<String> classpath) throws Exception {\n    classpath.add(FileUtils.pathOf(getCompilerJar(), useCanonicalPath));\n    for (File dep : getCompilerDependencies()) {\n      classpath.add(FileUtils.pathOf(dep, useCanonicalPath));\n    }\n  }\n\n  void addLibraryToClasspath(Set<String> classpath) throws Exception {\n    classpath.add(FileUtils.pathOf(getLibraryJar(), useCanonicalPath));\n  }\n\n  @Override\n  public void execute() throws MojoExecutionException, MojoFailureException {\n    try {\n      String oldWay = System.getProperty(\"maven.scala.version\");\n      if (oldWay != null) {\n        getLog().warn(\"using 'maven.scala.version' is deprecated, use 'scala.version' instead\");\n        if (scalaVersion != null) {\n          scalaVersion = oldWay;\n        }\n      }\n\n      oldWay = System.getProperty(\"maven.scala.displayCmd\");\n      if (oldWay != null) {\n        getLog().warn(\"using 'maven.scala.displayCmd' is deprecated, use 'displayCmd' instead\");\n        displayCmd = displayCmd || Boolean.parseBoolean(oldWay);\n      }\n      checkScalaVersion();\n      doExecute();\n    } catch (MojoExecutionException exc) {\n      throw exc;\n    } catch (MojoFailureException | RuntimeException exc) {\n      throw exc;\n    } catch (Exception exc) {\n      throw new MojoExecutionException(\"wrap: \" + exc, exc);\n    }\n  }\n\n  protected List<Dependency> getDependencies() {\n    return project.getCompileDependencies();\n  }\n\n  VersionNumber findScalaVersion() throws Exception {\n    if (_scalaVersionN == null) {\n      String detectedScalaVersion = scalaVersion;\n      if (StringUtils.isEmpty(detectedScalaVersion)) {\n        detectedScalaVersion = findScalaVersionFromDependencies();\n      }\n      if (StringUtils.isEmpty(detectedScalaVersion)) {\n        if (!ScalaMojoSupport.POM.equals(project.getPackaging())) {\n          String error =\n              getScalaOrganization()\n                  + \":\"\n                  + (_scalaVersionN.major == 3\n                      ? getScala3ArtifactId(SCALA3_LIBRARY_ARTIFACTID)\n                      : SCALA_LIBRARY_ARTIFACTID)\n                  + \" is missing from project dependencies\";\n          getLog().error(error);\n          throw new UnsupportedOperationException(error);\n        }\n      } else {\n        // grappy hack to retrieve the SNAPSHOT version without timestamp,...\n        // because if version is -SNAPSHOT and artifact is deploy with uniqueValue then\n        // the version\n        // get from dependency is with the timestamp and a build number (the resolved\n        // version)\n        // but scala-compiler with the same version could have different resolved\n        // version (timestamp,...)\n        boolean isSnapshot = ArtifactUtils.isSnapshot(detectedScalaVersion);\n        if (isSnapshot && !detectedScalaVersion.endsWith(\"-SNAPSHOT\")) {\n          detectedScalaVersion =\n              detectedScalaVersion.substring(\n                      0,\n                      detectedScalaVersion.lastIndexOf(\n                          '-', detectedScalaVersion.lastIndexOf('-') - 1))\n                  + \"-SNAPSHOT\";\n        }\n      }\n      if (StringUtils.isEmpty(detectedScalaVersion)) {\n        throw new MojoFailureException(\"no scalaVersion detected or set\");\n      }\n      if (StringUtils.isNotEmpty(scalaVersion)) {\n        if (!scalaVersion.equals(detectedScalaVersion)) {\n          getLog()\n              .warn(\n                  \"scala library version define in dependencies doesn't match the scalaVersion of the plugin\");\n        }\n        // getLog().info(\"suggestion: remove the scalaVersion from pom.xml\");\n        // //scalaVersion could be define in a parent pom where lib is not required\n      }\n      _scalaVersionN = new VersionNumber(detectedScalaVersion);\n    }\n    return _scalaVersionN;\n  }\n\n  private String findScalaVersionFromDependencies() {\n    return findVersionFromDependencies(\n        getScalaOrganization(),\n        new HashSet<String>(Arrays.asList(SCALA3_LIBRARY_ARTIFACTID, SCALA_LIBRARY_ARTIFACTID)));\n  }\n\n  // TODO refactor to do only one scan of dependencies to find version\n  private String findVersionFromDependencies(String groupId, Set<String> artifactId) {\n    String version = null;\n    for (Dependency dep : getDependencies()) {\n      if (groupId.equals(dep.getGroupId()) && artifactId.contains(dep.getArtifactId())) {\n        version = dep.getVersion();\n      }\n    }\n    if (StringUtils.isEmpty(version)) {\n      List<Dependency> deps = new ArrayList<>();\n      deps.addAll(project.getModel().getDependencies());\n      if (project.getModel().getDependencyManagement() != null) {\n        deps.addAll(project.getModel().getDependencyManagement().getDependencies());\n      }\n      for (Dependency dep : deps) {\n        if (groupId.equals(dep.getGroupId()) && artifactId.contains(dep.getArtifactId())) {\n          version = dep.getVersion();\n        }\n      }\n    }\n    return version;\n  }\n\n  void checkScalaVersion() throws Exception {\n    String sv = findScalaVersion().toString();\n    if (StringUtils.isNotEmpty(scalaHome)) {\n      getLog()\n          .warn(\n              String.format(\n                  \"local scala-library.jar and scala-compiler.jar from scalaHome(%s) used instead of scala %s\",\n                  scalaHome, sv));\n    }\n    if (checkMultipleScalaVersions) {\n      checkCorrectVersionsOfScalaLibrary(sv);\n    }\n  }\n\n  /**\n   * this method checks to see if there are multiple versions of the scala library\n   *\n   * @throws Exception\n   */\n  private void checkCorrectVersionsOfScalaLibrary(String scalaDefVersion) throws Exception {\n    getLog().debug(\"Checking for multiple versions of scala\");\n    // TODO - Make sure we handle bad artifacts....\n    // TODO: note that filter does not get applied due to MNG-3236\n    VersionNumber sv = new VersionNumber(scalaDefVersion);\n    VersionNumber requiredScalaVersion =\n        StringUtils.isNotEmpty(scalaCompatVersion) ? new VersionNumberMask(scalaCompatVersion) : sv;\n    if (requiredScalaVersion.compareTo(sv) != 0) {\n      String msg =\n          String.format(\n              \"Scala library detected %s doesn't match scala.compat.version : %s\",\n              sv, requiredScalaVersion);\n      if (failOnMultipleScalaVersions) {\n        getLog().error(msg);\n        throw new MojoFailureException(msg);\n      }\n      getLog().warn(msg);\n    }\n    ProjectBuildingRequest request =\n        new DefaultProjectBuildingRequest(session.getProjectBuildingRequest());\n    request.setProject(project);\n    checkArtifactForScalaVersion(\n        requiredScalaVersion, dependencyGraphBuilder.buildDependencyGraph(request, null));\n  }\n\n  /** Visits a node (and all dependencies) to see if it contains duplicate scala versions */\n  private void checkArtifactForScalaVersion(\n      VersionNumber requiredScalaVersion, DependencyNode rootNode) throws Exception {\n    final CheckScalaVersionVisitor visitor =\n        new CheckScalaVersionVisitor(requiredScalaVersion, getLog(), getScalaOrganization());\n\n    CollectingDependencyNodeVisitor collectingVisitor = new CollectingDependencyNodeVisitor();\n    DependencyNodeVisitor firstPassVisitor =\n        new FilteringDependencyNodeVisitor(collectingVisitor, createScalaDistroDependencyFilter());\n    rootNode.accept(firstPassVisitor);\n\n    DependencyNodeFilter secondPassFilter =\n        new AncestorOrSelfDependencyNodeFilter(collectingVisitor.getNodes());\n    DependencyNodeVisitor filteredVisitor =\n        new FilteringDependencyNodeVisitor(visitor, secondPassFilter);\n\n    rootNode.accept(filteredVisitor);\n\n    if (visitor.isFailed()) {\n      visitor.logScalaDependents();\n      if (failOnMultipleScalaVersions) {\n        getLog().error(\"Multiple versions of scala libraries detected!\");\n        throw new MojoFailureException(\"Multiple versions of scala libraries detected!\");\n      }\n      getLog().warn(\"Multiple versions of scala libraries detected!\");\n    }\n  }\n\n  /** @return A filter to only extract artifacts deployed from scala distributions */\n  private DependencyNodeFilter createScalaDistroDependencyFilter() {\n    List<DependencyNodeFilter> filters = new ArrayList<>();\n    filters.add(new ScalaDistroArtifactFilter(getScalaOrganization()));\n    return new AndDependencyNodeFilter(filters);\n  }\n\n  protected abstract void doExecute() throws Exception;\n\n  protected JavaMainCaller getScalaCommand() throws Exception {\n    return getScalaCommand(fork, scalaClassName);\n  }\n\n  /**\n   * Get a {@link JavaMainCaller} used invoke a Java process. Typically this will be one of the\n   * Scala utilities (Compiler, ScalaDoc, REPL, etc.).\n   *\n   * <p>This method does some setup on the {@link JavaMainCaller} which is not done by merely\n   * invoking {@code new} on one of the implementations. Specifically, it adds any Scala compiler\n   * plugin options, JVM options, and Scalac options defined on the plugin.\n   *\n   * @param forkOverride override the setting for {@link #fork}. Currently this should only be set\n   *     if you are invoking the REPL.\n   * @param mainClass the JVM main class to invoke.\n   * @return a {@link JavaMainCaller} to use to invoke the given command.\n   */\n  final JavaMainCaller getScalaCommand(final boolean forkOverride, final String mainClass)\n      throws Exception {\n    JavaMainCaller cmd = getEmptyScalaCommand(mainClass, forkOverride);\n    cmd.addArgs(args);\n    if (StringUtils.isNotEmpty(addScalacArgs)) {\n      cmd.addArgs(StringUtils.split(addScalacArgs, \"|\"));\n    }\n    addCompilerPluginOptions(cmd);\n    cmd.addJvmArgs(jvmArgs);\n    return cmd;\n  }\n\n  /**\n   * Get a {@link JavaMainCaller} used invoke a Java process. Typically this will be one of the\n   * Scala utilities (Compiler, ScalaDoc, REPL, etc.).\n   *\n   * @param mainClass the JVM main class to invoke.\n   * @return a {@link JavaMainCaller} to use to invoke the given command.\n   */\n  final JavaMainCaller getEmptyScalaCommand(final String mainClass) throws Exception {\n    return getEmptyScalaCommand(mainClass, fork);\n  }\n\n  /**\n   * Get a {@link JavaMainCaller} used invoke a Java process. Typically this will be one of the\n   * Scala utilities (Compiler, ScalaDoc, REPL, etc.).\n   *\n   * @param mainClass the JVM main class to invoke.\n   * @param forkOverride override the setting for {@link #fork}. Currently this should only be set\n   *     if you are invoking the REPL.\n   * @return a {@link JavaMainCaller} to use to invoke the given command.\n   */\n  private JavaMainCaller getEmptyScalaCommand(final String mainClass, final boolean forkOverride)\n      throws Exception {\n\n    // If we are deviating from the plugin settings, let the user know\n    // what's going on.\n    if (forkOverride != fork) {\n      super.getLog().info(\"Fork behavior overridden\");\n      super.getLog()\n          .info(String.format(\"Fork for this execution is %s.\", String.valueOf(forkOverride)));\n    }\n\n    // TODO - Fork or not depending on configuration?\n    JavaMainCaller cmd;\n    String toolcp = getToolClasspath();\n    if (forkOverride) {\n      // HACK (better may need refactor)\n      boolean bootcp = true;\n      if (args != null) {\n        for (String arg : args) {\n          bootcp = bootcp && !\"-nobootcp\".equals(arg);\n        }\n      }\n      String cp = bootcp ? \"\" : toolcp;\n      bootcp =\n          bootcp && !(StringUtils.isNotEmpty(addScalacArgs) && addScalacArgs.contains(\"-nobootcp\"));\n      // scalac with args in files\n      // * works only since 2.8.0\n      // * is buggy (don't manage space in path on windows)\n      getLog().debug(\"use java command with args in file forced : \" + forceUseArgFile);\n      cmd =\n          new JavaMainCallerByFork(\n              this, mainClass, cp, null, null, forceUseArgFile, getToolchain());\n      if (bootcp) {\n        cmd.addJvmArgs(\"-Xbootclasspath/a:\" + toolcp);\n      }\n    } else {\n      cmd = new JavaMainCallerInProcess(this, mainClass, toolcp, null, null);\n    }\n    return cmd;\n  }\n\n  protected Toolchain getToolchain() {\n    return toolchainManager.getToolchainFromBuildContext(\"jdk\", session);\n  }\n\n  private String getToolClasspath() throws Exception {\n    Set<String> classpath = new LinkedHashSet<>();\n    addLibraryToClasspath(classpath);\n    addCompilerToClasspath(classpath);\n    if (dependencies != null) {\n      for (BasicArtifact artifact : dependencies) {\n        addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, classpath);\n      }\n    }\n    return MainHelper.toMultiPath(classpath.toArray(new String[] {}));\n  }\n\n  protected List<String> getScalaOptions() throws Exception {\n    List<String> options = new ArrayList<>();\n    if (args != null) Collections.addAll(options, args);\n    if (StringUtils.isNotEmpty(addScalacArgs)) {\n      Collections.addAll(options, StringUtils.split(addScalacArgs, \"|\"));\n    }\n    options.addAll(getCompilerPluginOptions());\n    return options;\n  }\n\n  protected List<String> getJavacOptions() {\n    List<String> options = new ArrayList<>();\n    if (javacArgs != null) Collections.addAll(options, javacArgs);\n    if (StringUtils.isNotEmpty(addJavacArgs)) {\n      Collections.addAll(options, StringUtils.split(addJavacArgs, \"|\"));\n    }\n\n    // issue #116\n    if (javacGenerateDebugSymbols) {\n      options.add(\"-g\");\n    }\n    if (target != null && !target.isEmpty()) {\n      options.add(\"-target\");\n      options.add(target);\n    }\n    if (source != null && !source.isEmpty()) {\n      options.add(\"-source\");\n      options.add(source);\n    }\n    if (encoding != null) {\n      options.add(\"-encoding\");\n      options.add(encoding);\n    }\n    return options;\n  }\n\n  protected String getScala3ArtifactId(String a) {\n    return _scalaVersionN.major == 3 ? a + \"_\" + getBinaryVersionForScala3() : a;\n  }\n\n  private String getBinaryVersionForScala3() {\n    return _scalaVersionN.major == 3\n            && _scalaVersionN.minor == 0\n            && _scalaVersionN.bugfix == 0\n            && _scalaVersionN.modifier != null\n        ? _scalaVersionN.toString()\n        : \"3\";\n  }\n\n  protected File getLibraryJar() throws Exception {\n    return getLibraryJar(findScalaVersion());\n  }\n\n  protected File getLibraryJar(VersionNumber versionNumber) throws Exception {\n    String scalaLibrary =\n        _scalaVersionN.major == 3\n            ? getScala3ArtifactId(SCALA3_LIBRARY_ARTIFACTID)\n            : SCALA_LIBRARY_ARTIFACTID;\n    if (StringUtils.isNotEmpty(scalaHome)) {\n      File lib = new File(scalaHome, \"lib\");\n      return new File(lib, scalaLibrary + \".jar\");\n    }\n    return getArtifactJar(getScalaOrganization(), scalaLibrary, versionNumber.toString());\n  }\n\n  protected File getReflectJar() throws Exception {\n    if (_scalaVersionN.major != 3) {\n      String scalaReflect =\n          _scalaVersionN.major == 3\n              ? getScala3ArtifactId(SCALA3_REFLECT_ARTIFACTID)\n              : SCALA_REFLECT_ARTIFACTID;\n      if (StringUtils.isNotEmpty(scalaHome)) {\n        File lib = new File(scalaHome, \"lib\");\n        return new File(lib, scalaReflect + \".jar\");\n      }\n      return getArtifactJar(getScalaOrganization(), scalaReflect, findScalaVersion().toString());\n    }\n    return null;\n  }\n\n  protected File getCompilerJar() throws Exception {\n    return getCompilerJar(findScalaVersion());\n  }\n\n  protected File getCompilerJar(VersionNumber versionNumber) throws Exception {\n    String scalaCompile =\n        _scalaVersionN.major == 3\n            ? getScala3ArtifactId(SCALA3_COMPILER_ARTIFACTID)\n            : SCALA_COMPILER_ARTIFACTID;\n    if (StringUtils.isNotEmpty(scalaHome)) {\n      File lib = new File(scalaHome, \"lib\");\n      return new File(lib, scalaCompile + \".jar\");\n    }\n    return getArtifactJar(getScalaOrganization(), scalaCompile, versionNumber.toString());\n  }\n\n  protected List<File> getCompilerDependencies() throws Exception {\n    List<File> d = new ArrayList<>();\n    if (StringUtils.isEmpty(scalaHome)) {\n      for (Artifact artifact :\n          getAllDependencies(\n              getScalaOrganization(),\n              _scalaVersionN.major == 3\n                  ? getScala3ArtifactId(SCALA3_COMPILER_ARTIFACTID)\n                  : SCALA_COMPILER_ARTIFACTID,\n              findScalaVersion().toString())) {\n        d.add(artifact.getFile());\n      }\n    } else {\n      for (File f : new File(scalaHome, \"lib\").listFiles()) {\n        String name = f.getName();\n        if (name.endsWith(\".jar\")\n            && (!name.contains(\"scala-library\") || !name.contains(\"scala3-library\"))\n            && (!name.contains(\"scala-compiler\") || !name.contains(\"scala3-compiler\"))) {\n          d.add(f);\n        }\n      }\n    }\n    return d;\n  }\n\n  protected File getArtifactJar(String groupId, String artifactId, String version)\n      throws Exception {\n    Artifact artifact =\n        factory.createArtifact(\n            groupId, artifactId, version, Artifact.SCOPE_RUNTIME, ScalaMojoSupport.JAR);\n    resolver.resolve(artifact, remoteRepos, localRepo);\n    return artifact.getFile();\n  }\n\n  private Set<Artifact> getAllDependencies(String groupId, String artifactId, String version) {\n    Set<Artifact> result = new HashSet<>();\n    Artifact pom = factory.createArtifact(groupId, artifactId, version, \"\", ScalaMojoSupport.POM);\n    Set<Artifact> d = resolveArtifactDependencies(pom);\n    result.addAll(d);\n    for (Artifact dependency : d) {\n      Set<Artifact> transitive =\n          getAllDependencies(\n              dependency.getGroupId(), dependency.getArtifactId(), dependency.getVersion());\n      result.addAll(transitive);\n    }\n    return result;\n  }\n\n  /**\n   * @return This returns whether or not the scala version can support having java sent into the\n   *     compiler\n   */\n  protected boolean isJavaSupportedByCompiler() throws Exception {\n    return findScalaVersion().compareTo(new VersionNumber(\"2.7.2\")) >= 0;\n  }\n\n  /**\n   * Adds appropriate compiler plugins to the scalac command.\n   *\n   * @param scalac\n   * @throws Exception\n   */\n  protected void addCompilerPluginOptions(JavaMainCaller scalac) throws Exception {\n    for (String option : getCompilerPluginOptions()) {\n      scalac.addArgs(option);\n    }\n  }\n\n  private List<String> getCompilerPluginOptions() throws Exception {\n    List<String> options = new ArrayList<>();\n    for (String plugin : getCompilerPlugins()) {\n      options.add(\"-Xplugin:\" + plugin);\n    }\n    return options;\n  }\n\n  /**\n   * Retrieves a list of paths to scala compiler plugins.\n   *\n   * @return The list of plugins\n   * @throws Exception\n   */\n  private Set<String> getCompilerPlugins() throws Exception {\n    Set<String> plugins = new HashSet<>();\n    if (compilerPlugins != null) {\n      Set<String> ignoreClasspath = new LinkedHashSet<>();\n      addCompilerToClasspath(ignoreClasspath);\n      addLibraryToClasspath(ignoreClasspath);\n      for (BasicArtifact artifact : compilerPlugins) {\n        getLog().info(\"compiler plugin: \" + artifact.toString());\n        // TODO - Ensure proper scala version for plugins\n        Set<String> pluginClassPath = new HashSet<>();\n        // TODO - Pull in transitive dependencies.\n        addToClasspath(\n            artifact.groupId,\n            artifact.artifactId,\n            artifact.version,\n            artifact.classifier,\n            pluginClassPath,\n            false);\n        pluginClassPath.removeAll(ignoreClasspath);\n        plugins.addAll(pluginClassPath);\n      }\n    }\n    return plugins;\n  }\n}\n","lineNo":823}
{"Smelly Sample":"package sbt_inc;\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.plugin.logging.Log;\nimport sbt.internal.inc.FileAnalysisStore;\nimport sbt.internal.inc.ScalaInstance;\nimport sbt.internal.inc.*;\nimport sbt.internal.inc.classpath.ClasspathUtilities;\nimport sbt.io.AllPassFilter$;\nimport sbt.io.IO;\nimport sbt.util.Logger;\nimport scala.Option;\nimport scala.Tuple2;\nimport scala.collection.JavaConverters;\nimport scala.compat.java8.functionConverterImpls.FromJavaConsumer;\nimport scala_maven.MavenArtifactResolver;\nimport scala_maven.VersionNumber;\nimport util.FileUtils;\nimport xsbti.T2;\nimport xsbti.compile.AnalysisStore;\nimport xsbti.compile.CompilerCache;\nimport xsbti.compile.*;\n\nimport java.io.File;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.*;\nimport java.util.jar.Attributes;\nimport java.util.jar.Manifest;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\npublic class SbtIncrementalCompiler {\n\n    private static final String SBT_GROUP_ID = \"org.scala-sbt\";\n    private static final String JAVA_CLASS_VERSION = System.getProperty(\"java.class.version\");\n    private static final File DEFAULT_SECONDARY_CACHE_DIR = Paths\n        .get(System.getProperty(\"user.home\"), \".sbt\", \"1.0\", \"zinc\", \"org.scala-sbt\").toFile();\n\n    private final IncrementalCompiler compiler = ZincUtil.defaultIncrementalCompiler();\n    private final CompileOrder compileOrder;\n    private final Logger logger;\n    private final Compilers compilers;\n    private final Setup setup;\n    private final AnalysisStore analysisStore;\n    private final MavenArtifactResolver resolver;\n    private final File secondaryCacheDir;\n\n    public SbtIncrementalCompiler(File libraryJar, File reflectJar, File compilerJar, VersionNumber scalaVersion,\n        List<File> extraJars, File javaHome, MavenArtifactResolver resolver, File secondaryCacheDir, Log mavenLogger,\n        File cacheFile, CompileOrder compileOrder) throws Exception {\n        this.compileOrder = compileOrder;\n        this.logger = new SbtLogger(mavenLogger);\n        mavenLogger.info(\"Using incremental compilation using \" + compileOrder + \" compile order\");\n        this.resolver = resolver;\n        this.secondaryCacheDir = secondaryCacheDir != null ? secondaryCacheDir : DEFAULT_SECONDARY_CACHE_DIR;\n        this.secondaryCacheDir.mkdirs();\n\n        List<File> allJars = new ArrayList<>(extraJars);\n        allJars.add(libraryJar);\n        allJars.add(reflectJar);\n        allJars.add(compilerJar);\n\n        ScalaInstance scalaInstance = new ScalaInstance( //\n            scalaVersion.toString(), // version\n            new URLClassLoader(\n                new URL[] { libraryJar.toURI().toURL(), reflectJar.toURI().toURL(), compilerJar.toURI().toURL() }), // loader\n            ClasspathUtilities.rootLoader(), // loaderLibraryOnly\n            libraryJar, // libraryJar\n            compilerJar, // compilerJar\n            allJars.toArray(new File[] {}), // allJars\n            Option.apply(scalaVersion.toString()) // explicitActual\n        );\n\n        File compilerBridgeJar = getCompiledBridgeJar(scalaInstance, mavenLogger);\n\n        ScalaCompiler scalaCompiler = new AnalyzingCompiler( //\n            scalaInstance, // scalaInstance\n            ZincCompilerUtil.constantBridgeProvider(scalaInstance, compilerBridgeJar), // provider\n            ClasspathOptionsUtil.auto(), // classpathOptions\n            new FromJavaConsumer<>(noop -> {\n            }), // onArgsHandler\n            Option.apply(null) // classLoaderCache\n        );\n\n        compilers = ZincUtil.compilers( //\n            scalaInstance, //\n            ClasspathOptionsUtil.boot(), //\n            Option.apply(javaHome), // javaHome\n            scalaCompiler);\n\n        PerClasspathEntryLookup lookup = new PerClasspathEntryLookup() {\n            @Override\n            public Optional<CompileAnalysis> analysis(File classpathEntry) {\n                String analysisStoreFileName = null;\n                if (classpathEntry.isDirectory()) {\n                    if (classpathEntry.getName().equals(\"classes\")) {\n                        analysisStoreFileName = \"compile\";\n\n                    } else if (classpathEntry.getName().equals(\"test-classes\")) {\n                        analysisStoreFileName = \"test-compile\";\n                    }\n                }\n\n                if (analysisStoreFileName != null) {\n                    File analysisStoreFile = Paths.get(classpathEntry.getParent(), \"analysis\", analysisStoreFileName)\n                        .toFile();\n                    if (analysisStoreFile.exists()) {\n                        return AnalysisStore.getCachedStore(FileAnalysisStore.binary(analysisStoreFile)).get()\n                            .map(AnalysisContents::getAnalysis);\n                    }\n                }\n                return Optional.empty();\n            }\n\n            @Override\n            public DefinesClass definesClass(File classpathEntry) {\n                return Locate.definesClass(classpathEntry);\n            }\n        };\n\n        analysisStore = AnalysisStore.getCachedStore(FileAnalysisStore.binary(cacheFile));\n\n        setup = Setup.of( //\n            lookup, // lookup\n            false, // skip\n            cacheFile, // cacheFile\n            CompilerCache.fresh(), // cache\n            IncOptions.of(), // incOptions\n            new LoggedReporter(100, logger, pos -> pos), // reporter\n            Optional.empty(), // optionProgress\n            new T2[] {});\n    }\n\n    private PreviousResult previousResult() {\n        Optional<AnalysisContents> analysisContents = analysisStore.get();\n        if (analysisContents.isPresent()) {\n            AnalysisContents analysisContents0 = analysisContents.get();\n            CompileAnalysis previousAnalysis = analysisContents0.getAnalysis();\n            MiniSetup previousSetup = analysisContents0.getMiniSetup();\n            return PreviousResult.of(Optional.of(previousAnalysis), Optional.of(previousSetup));\n        } else {\n            return PreviousResult.of(Optional.empty(), Optional.empty());\n        }\n    }\n\n    public void compile(Set<String> classpathElements, List<File> sources, File classesDirectory,\n        List<String> scalacOptions, List<String> javacOptions) {\n        List<File> fullClasspath = new ArrayList<>();\n        fullClasspath.add(classesDirectory);\n        for (String classpathElement : classpathElements) {\n            fullClasspath.add(new File(classpathElement));\n        }\n\n        CompileOptions options = CompileOptions.of( //\n            fullClasspath.toArray(new File[] {}), // classpath\n            sources.toArray(new File[] {}), // sources\n            classesDirectory, //\n            scalacOptions.toArray(new String[] {}), // scalacOptions\n            javacOptions.toArray(new String[] {}), // javacOptions\n            100, // maxErrors\n            pos -> pos, // sourcePositionMappers\n            compileOrder, // order\n            Optional.empty() // temporaryClassesDirectory\n        );\n\n        Inputs inputs = Inputs.of(compilers, options, setup, previousResult());\n\n        CompileResult newResult = compiler.compile(inputs, logger);\n        analysisStore.set(AnalysisContents.create(newResult.analysis(), newResult.setup()));\n    }\n\n    private String compilerBridgeArtifactId(String scalaVersion) {\n        if (scalaVersion.startsWith(\"2.10.\")) {\n            return \"compiler-bridge_2.10\";\n        } else if (scalaVersion.startsWith(\"2.11.\")) {\n            return \"compiler-bridge_2.11\";\n        } else if (scalaVersion.startsWith(\"2.12.\") || scalaVersion.equals(\"2.13.0-M1\")) {\n            return \"compiler-bridge_2.12\";\n        } else {\n            return \"compiler-bridge_2.13\";\n        }\n    }\n\n    private File getCompiledBridgeJar(ScalaInstance scalaInstance, Log mavenLogger) throws Exception {\n\n        // eg\n        // org.scala-sbt-compiler-bridge_2.12-1.2.4-bin_2.12.10__52.0-1.2.4_20181015T090407.jar\n        String bridgeArtifactId = compilerBridgeArtifactId(scalaInstance.actualVersion());\n\n        // this file is localed in compiler-interface\n        Properties properties = new Properties();\n        try (InputStream is = getClass().getClassLoader()\n            .getResourceAsStream(\"incrementalcompiler.version.properties\")) {\n            properties.load(is);\n        }\n\n        String zincVersion = properties.getProperty(\"version\");\n        String timestamp = properties.getProperty(\"timestamp\");\n\n        String cacheFileName = SBT_GROUP_ID + '-' + bridgeArtifactId + '-' + zincVersion + \"-bin_\"\n            + scalaInstance.actualVersion() + \"__\" + JAVA_CLASS_VERSION + '-' + zincVersion + '_' + timestamp + \".jar\";\n\n        File cachedCompiledBridgeJar = new File(secondaryCacheDir, cacheFileName);\n\n        if (mavenLogger.isInfoEnabled()) {\n            mavenLogger.info(\"Compiler bridge file: \" + cachedCompiledBridgeJar);\n        }\n\n        if (!cachedCompiledBridgeJar.exists()) {\n            mavenLogger.info(\"Compiler bridge file is not installed yet\");\n            // compile and install\n            RawCompiler rawCompiler = new RawCompiler(scalaInstance, ClasspathOptionsUtil.auto(), logger);\n\n            File bridgeSources = resolver.getJar(SBT_GROUP_ID, bridgeArtifactId, zincVersion, \"sources\").getFile();\n\n            Set<File> bridgeSourcesDependencies = resolver\n                .getJarAndDependencies(SBT_GROUP_ID, bridgeArtifactId, zincVersion, \"sources\") //\n                .stream() //\n                .filter(artifact -> artifact.getScope() != null && !artifact.getScope().equals(\"provided\")) //\n                .map(Artifact::getFile) //\n                .collect(Collectors.toSet());\n\n            bridgeSourcesDependencies.addAll(Arrays.asList(scalaInstance.allJars()));\n\n            File sourcesDir = Files.createTempDirectory(\"scala-maven-plugin-compiler-bridge-sources\").toFile();\n            File classesDir = Files.createTempDirectory(\"scala-maven-plugin-compiler-bridge-classes\").toFile();\n\n            IO.unzip(bridgeSources, sourcesDir, AllPassFilter$.MODULE$, true);\n\n            try {\n                rawCompiler.apply(\n                    JavaConverters.iterableAsScalaIterable(FileUtils.listDirectoryContent(sourcesDir.toPath(),\n                        file -> file.isFile() && file.getName().endsWith(\".scala\"))).seq().toSeq(), // sources:Seq[File]\n                    JavaConverters.iterableAsScalaIterable(bridgeSourcesDependencies).seq().toSeq(), // classpath:Seq[File],\n                    classesDir, // outputDirectory:File,\n                    JavaConverters.collectionAsScalaIterable(Collections.<String>emptyList()).seq().toSeq() // options:Seq[String]\n                );\n\n                Manifest manifest = new Manifest();\n                Attributes mainAttributes = manifest.getMainAttributes();\n                mainAttributes.putValue(Attributes.Name.MANIFEST_VERSION.toString(), \"1.0\");\n                mainAttributes.putValue(Attributes.Name.SPECIFICATION_VENDOR.toString(), SBT_GROUP_ID);\n                mainAttributes.putValue(Attributes.Name.SPECIFICATION_TITLE.toString(), \"Compiler Bridge\");\n                mainAttributes.putValue(Attributes.Name.SPECIFICATION_VERSION.toString(), zincVersion);\n\n                int classesDirPathLength = classesDir.toString().length();\n                Stream<Tuple2<File, String>> stream = FileUtils.listDirectoryContent(classesDir.toPath(), file -> true) //\n                    .stream() //\n                    .map(file -> {\n                        String path = file.toString().substring(classesDirPathLength + 1).replace(File.separator, \"/\");\n                        if (file.isDirectory()) {\n                            path = path + \"/\";\n                        }\n                        return new Tuple2(file, path);\n                    });\n                List<Tuple2<File, String>> classes = stream.collect(Collectors.toList());\n\n                IO.jar(JavaConverters.collectionAsScalaIterable(classes), cachedCompiledBridgeJar, new Manifest());\n\n                mavenLogger.info(\"Compiler bridge installed\");\n\n            } finally {\n                FileUtils.deleteDirectory(sourcesDir.toPath());\n                FileUtils.deleteDirectory(classesDir.toPath());\n            }\n        }\n\n        return cachedCompiledBridgeJar;\n    }\n}\n","Method after Refactoring":"package sbt_inc;\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.plugin.logging.Log;\nimport sbt.internal.inc.FileAnalysisStore;\nimport sbt.internal.inc.ScalaInstance;\nimport sbt.internal.inc.*;\nimport sbt.internal.inc.classpath.ClasspathUtil;\nimport sbt.io.AllPassFilter$;\nimport sbt.io.IO;\nimport sbt.util.Logger;\nimport scala.Option;\nimport scala.Tuple2;\nimport scala_maven.MavenArtifactResolver;\nimport scala_maven.VersionNumber;\nimport util.FileUtils;\nimport xsbti.PathBasedFile;\nimport xsbti.T2;\nimport xsbti.VirtualFile;\nimport xsbti.compile.*;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.*;\nimport java.util.jar.Manifest;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport static scala.jdk.CollectionConverters.IterableHasAsScala;\nimport static scala.jdk.FunctionWrappers.FromJavaConsumer;\n\npublic class SbtIncrementalCompiler {\n\n    private static final String SBT_GROUP_ID = \"org.scala-sbt\";\n    private static final String JAVA_CLASS_VERSION = System.getProperty(\"java.class.version\");\n    private static final File DEFAULT_SECONDARY_CACHE_DIR =\n        Paths.get(System.getProperty(\"user.home\"), \".sbt\", \"1.0\", \"zinc\", \"org.scala-sbt\").toFile();\n\n    private final IncrementalCompiler compiler = ZincUtil.defaultIncrementalCompiler();\n    private final CompileOrder compileOrder;\n    private final Logger logger;\n    private final Compilers compilers;\n    private final Setup setup;\n    private final AnalysisStore analysisStore;\n    private final MavenArtifactResolver resolver;\n    private final File secondaryCacheDir;\n\n    public SbtIncrementalCompiler(\n        File libraryJar,\n        File reflectJar,\n        File compilerJar,\n        VersionNumber scalaVersion,\n        List<File> extraJars,\n        Path javaHome,\n        MavenArtifactResolver resolver,\n        File secondaryCacheDir,\n        Log mavenLogger,\n        File cacheFile,\n        CompileOrder compileOrder)\n        throws Exception {\n        this.compileOrder = compileOrder;\n        this.logger = new SbtLogger(mavenLogger);\n        mavenLogger.info(\"Using incremental compilation using \" + compileOrder + \" compile order\");\n        this.resolver = resolver;\n        this.secondaryCacheDir =\n            secondaryCacheDir != null ? secondaryCacheDir : DEFAULT_SECONDARY_CACHE_DIR;\n        this.secondaryCacheDir.mkdirs();\n\n        List<File> allJars = new ArrayList<>(extraJars);\n        allJars.add(libraryJar);\n        allJars.add(reflectJar);\n        allJars.add(compilerJar);\n\n        ScalaInstance scalaInstance =\n            new ScalaInstance(\n                scalaVersion.toString(), // version\n                new URLClassLoader(\n                    new URL[]{\n                        libraryJar.toURI().toURL(),\n                        reflectJar.toURI().toURL(),\n                        compilerJar.toURI().toURL()\n                    }), // loader\n                ClasspathUtil.rootLoader(), // loaderLibraryOnly\n                libraryJar, // libraryJar\n                compilerJar, // compilerJar\n                allJars.toArray(new File[]{}), // allJars\n                Option.apply(scalaVersion.toString()) // explicitActual\n            );\n\n        File compilerBridgeJar = getCompiledBridgeJar(scalaInstance, mavenLogger);\n\n        ScalaCompiler scalaCompiler =\n            new AnalyzingCompiler(\n                scalaInstance, // scalaInstance\n                ZincCompilerUtil.constantBridgeProvider(scalaInstance, compilerBridgeJar), // provider\n                ClasspathOptionsUtil.auto(), // classpathOptions\n                new FromJavaConsumer(noop -> {\n                }), // onArgsHandler\n                Option.apply(null) // classLoaderCache\n            );\n\n        compilers =\n            ZincUtil.compilers(\n                scalaInstance, ClasspathOptionsUtil.boot(), Option.apply(javaHome), scalaCompiler);\n\n        PerClasspathEntryLookup lookup =\n            new PerClasspathEntryLookup() {\n                @Override\n                public Optional<CompileAnalysis> analysis(VirtualFile classpathEntry) {\n                    Path path = ((PathBasedFile) classpathEntry).toPath();\n\n                    String analysisStoreFileName = null;\n                    if (Files.isDirectory(path)) {\n                        if (path.getFileName().equals(\"classes\")) {\n                            analysisStoreFileName = \"compile\";\n\n                        } else if (path.getFileName().equals(\"test-classes\")) {\n                            analysisStoreFileName = \"test-compile\";\n                        }\n                    }\n\n                    if (analysisStoreFileName != null) {\n                        File analysisStoreFile =\n                            path.getParent().resolve(\"analysis\").resolve(analysisStoreFileName).toFile();\n                        if (analysisStoreFile.exists()) {\n                            return AnalysisStore.getCachedStore(FileAnalysisStore.binary(analysisStoreFile))\n                                .get()\n                                .map(AnalysisContents::getAnalysis);\n                        }\n                    }\n                    return Optional.empty();\n                }\n\n                @Override\n                public DefinesClass definesClass(VirtualFile classpathEntry) {\n                    return Locate.definesClass(classpathEntry);\n                }\n            };\n\n        analysisStore = AnalysisStore.getCachedStore(FileAnalysisStore.binary(cacheFile));\n\n        setup =\n            Setup.of( //\n                lookup, // lookup\n                false, // skip\n                cacheFile, // cacheFile\n                CompilerCache.fresh(), // cache\n                IncOptions.of(), // incOptions\n                new LoggedReporter(100, logger, pos -> pos), // reporter\n                Optional.empty(), // optionProgress\n                new T2[]{});\n    }\n\n    private PreviousResult previousResult() {\n        Optional<AnalysisContents> analysisContents = analysisStore.get();\n        if (analysisContents.isPresent()) {\n            AnalysisContents analysisContents0 = analysisContents.get();\n            CompileAnalysis previousAnalysis = analysisContents0.getAnalysis();\n            MiniSetup previousSetup = analysisContents0.getMiniSetup();\n            return PreviousResult.of(Optional.of(previousAnalysis), Optional.of(previousSetup));\n        } else {\n            return PreviousResult.of(Optional.empty(), Optional.empty());\n        }\n    }\n\n    public void compile(\n        Set<String> classpathElements,\n        List<Path> sources,\n        Path classesDirectory,\n        List<String> scalacOptions,\n        List<String> javacOptions) {\n        List<Path> fullClasspath = new ArrayList<>();\n        fullClasspath.add(classesDirectory);\n        for (String classpathElement : classpathElements) {\n            fullClasspath.add(Paths.get(classpathElement));\n        }\n\n        CompileOptions options =\n            CompileOptions.of( //\n                fullClasspath.stream()\n                    .map(PlainVirtualFile::new)\n                    .toArray(VirtualFile[]::new), // classpath\n                sources.stream().map(PlainVirtualFile::new).toArray(VirtualFile[]::new), // sources\n                classesDirectory, //\n                scalacOptions.toArray(new String[]{}), // scalacOptions\n                javacOptions.toArray(new String[]{}), // javacOptions\n                100, // maxErrors\n                pos -> pos, // sourcePositionMappers\n                compileOrder, // order\n                Optional.empty(), // temporaryClassesDirectory\n                Optional.of(PlainVirtualFileConverter.converter()), // _converter\n                Optional.empty(), // _stamper\n                Optional.empty() // _earlyOutput\n            );\n\n        Inputs inputs = Inputs.of(compilers, options, setup, previousResult());\n\n        CompileResult newResult = compiler.compile(inputs, logger);\n        analysisStore.set(AnalysisContents.create(newResult.analysis(), newResult.setup()));\n    }\n\n    private String compilerBridgeArtifactId(String scalaVersion) {\n        if (scalaVersion.startsWith(\"2.10.\")) {\n            return \"compiler-bridge_2.10\";\n        } else if (scalaVersion.startsWith(\"2.11.\")) {\n            return \"compiler-bridge_2.11\";\n        } else if (scalaVersion.startsWith(\"2.12.\") || scalaVersion.equals(\"2.13.0-M1\")) {\n            return \"compiler-bridge_2.12\";\n        } else {\n            return \"compiler-bridge_2.13\";\n        }\n    }\n\n    private static List<Tuple2<File, String>> computeZipEntries(List<Path> paths, Path rootDir) {\n        int rootDirLength = rootDir.toString().length();\n        Stream<Tuple2<File, String>> stream =\n            paths.stream()\n                .map(\n                    path -> {\n                        String zipPath =\n                            path.toString().substring(rootDirLength + 1).replace(File.separator, \"/\");\n                        if (Files.isDirectory(path)) {\n                            zipPath = zipPath + \"/\";\n                        }\n                        return new Tuple2(path.toFile(), zipPath);\n                    });\n        return stream.collect(Collectors.toList());\n    }\n\n    private File getCompiledBridgeJar(ScalaInstance scalaInstance, Log mavenLogger) throws Exception {\n\n        // eg\n        // org.scala-sbt-compiler-bridge_2.12-1.2.4-bin_2.12.10__52.0-1.2.4_20181015T090407.jar\n        String bridgeArtifactId = compilerBridgeArtifactId(scalaInstance.actualVersion());\n\n        // this file is localed in compiler-interface\n        Properties properties = new Properties();\n        try (InputStream is =\n                 getClass().getClassLoader().getResourceAsStream(\"incrementalcompiler.version.properties\")) {\n            properties.load(is);\n        }\n\n        String zincVersion = properties.getProperty(\"version\");\n        String timestamp = properties.getProperty(\"timestamp\");\n\n        String cacheFileName =\n            SBT_GROUP_ID\n                + '-'\n                + bridgeArtifactId\n                + '-'\n                + zincVersion\n                + \"-bin_\"\n                + scalaInstance.actualVersion()\n                + \"__\"\n                + JAVA_CLASS_VERSION\n                + '-'\n                + zincVersion\n                + '_'\n                + timestamp\n                + \".jar\";\n\n        File cachedCompiledBridgeJar = new File(secondaryCacheDir, cacheFileName);\n\n        if (mavenLogger.isInfoEnabled()) {\n            mavenLogger.info(\"Compiler bridge file: \" + cachedCompiledBridgeJar);\n        }\n\n        if (!cachedCompiledBridgeJar.exists()) {\n            mavenLogger.info(\"Compiler bridge file is not installed yet\");\n            // compile and install\n            RawCompiler rawCompiler = new RawCompiler(scalaInstance, ClasspathOptionsUtil.auto(), logger);\n\n            File bridgeSources =\n                resolver.getJar(SBT_GROUP_ID, bridgeArtifactId, zincVersion, \"sources\").getFile();\n\n            Set<Path> bridgeSourcesDependencies =\n                resolver.getJarAndDependencies(SBT_GROUP_ID, bridgeArtifactId, zincVersion, \"sources\") //\n                    .stream() //\n                    .filter(\n                        artifact ->\n                            artifact.getScope() != null && !artifact.getScope().equals(\"provided\")) //\n                    .map(Artifact::getFile)\n                    .map(File::toPath)\n                    .collect(Collectors.toSet());\n\n            bridgeSourcesDependencies.addAll(\n                Arrays.stream(scalaInstance.allJars())\n                    .sequential()\n                    .map(File::toPath)\n                    .collect(Collectors.toList()));\n\n            Path sourcesDir = Files.createTempDirectory(\"scala-maven-plugin-compiler-bridge-sources\");\n            Path classesDir = Files.createTempDirectory(\"scala-maven-plugin-compiler-bridge-classes\");\n\n            IO.unzip(bridgeSources, sourcesDir.toFile(), AllPassFilter$.MODULE$, true);\n\n            List<Path> bridgeSourcesScalaFiles =\n                FileUtils.listDirectoryContent(\n                    sourcesDir,\n                    file ->\n                        Files.isRegularFile(file) && file.getFileName().toString().endsWith(\".scala\"));\n            List<Path> bridgeSourcesNonScalaFiles =\n                FileUtils.listDirectoryContent(\n                    sourcesDir,\n                    file ->\n                        Files.isRegularFile(file)\n                            && !file.getFileName().toString().endsWith(\".scala\")\n                            && !file.getFileName().toString().equals(\"MANIFEST.MF\"));\n\n            try {\n                rawCompiler.apply(\n                    IterableHasAsScala(bridgeSourcesScalaFiles).asScala().toSeq(), // sources:Seq[File]\n                    IterableHasAsScala(bridgeSourcesDependencies).asScala().toSeq(), // classpath:Seq[File],\n                    classesDir, // outputDirectory:Path,\n                    IterableHasAsScala(Collections.<String>emptyList())\n                        .asScala()\n                        .toSeq() // options:Seq[String]\n                );\n\n                Manifest manifest = new Manifest();\n                Path sourcesManifestFile = sourcesDir.resolve(\"META-INF\").resolve(\"MANIFEST.MF\");\n                try (InputStream is = new FileInputStream(sourcesManifestFile.toFile())) {\n                    manifest.read(is);\n                }\n\n                List<Tuple2<File, String>> scalaCompiledClasses =\n                    computeZipEntries(FileUtils.listDirectoryContent(classesDir, file -> true), classesDir);\n                List<Tuple2<File, String>> resources =\n                    computeZipEntries(bridgeSourcesNonScalaFiles, sourcesDir);\n                List<Tuple2<File, String>> allZipEntries = new ArrayList<>();\n                allZipEntries.addAll(scalaCompiledClasses);\n                allZipEntries.addAll(resources);\n\n                IO.jar(IterableHasAsScala(allZipEntries).asScala(), cachedCompiledBridgeJar, manifest);\n\n                mavenLogger.info(\"Compiler bridge installed\");\n\n            } finally {\n                FileUtils.deleteDirectory(sourcesDir);\n                FileUtils.deleteDirectory(classesDir);\n            }\n        }\n\n        return cachedCompiledBridgeJar;\n    }\n}\n","lineNo":303}
{"Smelly Sample":"package scala_maven;\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.resolver.ArtifactResolutionRequest;\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.repository.RepositorySystem;\n\nimport java.util.Set;\n\npublic class MavenArtifactResolver {\n\n    private final RepositorySystem repositorySystem;\n    private final MavenSession session;\n\n    public MavenArtifactResolver(RepositorySystem repositorySystem, MavenSession session) {\n        this.repositorySystem = repositorySystem;\n        this.session = session;\n    }\n\n    public Artifact getJar(String groupId, String artifactId, String version, String classifier) {\n        Artifact artifact = createJarArtifact(groupId, artifactId, version, classifier);\n        return resolve(artifact, false).iterator().next();\n    }\n\n    public Set<Artifact> getJarAndDependencies(String groupId, String artifactId, String version, String classifier) {\n        Artifact artifact = createJarArtifact(groupId, artifactId, version, classifier);\n        return resolve(artifact, true);\n    }\n\n    private Artifact createJarArtifact(String groupId, String artifactId, String version, String classifier) {\n        return classifier == null ? repositorySystem.createArtifact(groupId, artifactId, version, ScalaMojoSupport.JAR)\n            : repositorySystem.createArtifactWithClassifier(groupId, artifactId, version, ScalaMojoSupport.JAR,\n                classifier);\n    }\n\n    private Set<Artifact> resolve(Artifact artifact, boolean transitively) {\n        ArtifactResolutionRequest request = new ArtifactResolutionRequest() //\n            .setArtifact(artifact) //\n            .setResolveRoot(true) //\n            .setResolveTransitively(transitively) //\n            .setServers(session.getRequest().getServers()) //\n            .setMirrors(session.getRequest().getMirrors()) //\n            .setProxies(session.getRequest().getProxies()) //\n            .setLocalRepository(session.getLocalRepository()) //\n            .setRemoteRepositories(session.getCurrentProject().getRemoteArtifactRepositories());\n        return repositorySystem.resolve(request).getArtifacts();\n    }\n}\n","Method after Refactoring":"package scala_maven;\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.resolver.ArtifactResolutionRequest;\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.repository.RepositorySystem;\n\nimport java.util.NoSuchElementException;\nimport java.util.Set;\n\npublic class MavenArtifactResolver {\n\n    private final RepositorySystem repositorySystem;\n    private final MavenSession session;\n\n    public MavenArtifactResolver(RepositorySystem repositorySystem, MavenSession session) {\n        this.repositorySystem = repositorySystem;\n        this.session = session;\n    }\n\n    public Artifact getJar(String groupId, String artifactId, String version, String classifier) {\n        Artifact artifact = createJarArtifact(groupId, artifactId, version, classifier);\n        Set<Artifact> resolvedArtifacts = resolve(artifact, false);\n        if (resolvedArtifacts.isEmpty()) {\n            throw new NoSuchElementException(String.format(\"Could not resolve artifact %s:%s:%s:%s\", groupId, artifactId, version, classifier));\n        }\n        return resolvedArtifacts.iterator().next();\n    }\n\n    public Set<Artifact> getJarAndDependencies(String groupId, String artifactId, String version, String classifier) {\n        Artifact artifact = createJarArtifact(groupId, artifactId, version, classifier);\n        return resolve(artifact, true);\n    }\n\n    private Artifact createJarArtifact(String groupId, String artifactId, String version, String classifier) {\n        return classifier == null ? repositorySystem.createArtifact(groupId, artifactId, version, ScalaMojoSupport.JAR)\n            : repositorySystem.createArtifactWithClassifier(groupId, artifactId, version, ScalaMojoSupport.JAR,\n                classifier);\n    }\n\n    private Set<Artifact> resolve(Artifact artifact, boolean transitively) {\n        ArtifactResolutionRequest request = new ArtifactResolutionRequest() //\n            .setArtifact(artifact) //\n            .setResolveRoot(true) //\n            .setResolveTransitively(transitively) //\n            .setServers(session.getRequest().getServers()) //\n            .setMirrors(session.getRequest().getMirrors()) //\n            .setProxies(session.getRequest().getProxies()) //\n            .setLocalRepository(session.getLocalRepository()) //\n            .setRemoteRepositories(session.getCurrentProject().getRemoteArtifactRepositories());\n        return repositorySystem.resolve(request).getArtifacts();\n    }\n}\n","lineNo":23}
{"Smelly Sample":"package sbt_inc;\n\nimport org.apache.maven.plugin.logging.Log;\nimport sbt.util.Level;\nimport sbt.util.Logger;\nimport scala.Enumeration;\nimport scala.Function0;\n\npublic class SbtLogger extends Logger {\n\n    private final Log log;\n\n    SbtLogger(Log l) {\n        this.log = l;\n    }\n\n    @Override\n    public void trace(Function0<Throwable> t) {\n        if (log.isDebugEnabled()) {\n            log.debug(t.apply());\n        }\n    }\n\n    @Override\n    public void success(Function0<String> message) {\n        if (log.isInfoEnabled()) {\n            log.info(\"Success: \" + message.apply());\n        }\n    }\n\n    @Override\n    public void log(Enumeration.Value level, Function0<String> message) {\n        if (level.equals(Level.Error())) {\n            log.error(message.apply());\n        } else if (level.equals(Level.Warn())) {\n            log.warn(message.apply());\n        } else if (level.equals(Level.Info())) {\n            log.info(message.apply());\n        } else if (level.equals(Level.Debug())) {\n            log.debug(message.apply());\n        }\n    }\n}\n","Method after Refactoring":"package sbt_inc;\n\nimport org.apache.maven.plugin.logging.Log;\nimport sbt.util.Level;\nimport sbt.util.Logger;\nimport scala.Enumeration;\nimport scala.Function0;\n\npublic class SbtLogger extends Logger {\n\n    private final Log log;\n\n    SbtLogger(Log l) {\n        this.log = l;\n    }\n\n    @Override\n    public void trace(Function0<Throwable> t) {\n        if (log.isDebugEnabled()) {\n            log.debug(t.apply());\n        }\n    }\n\n    @Override\n    public void success(Function0<String> message) {\n        if (log.isInfoEnabled()) {\n            log.info(\"Success: \" + message.apply());\n        }\n    }\n\n    @Override\n    public void log(Enumeration.Value level, Function0<String> message) {\n        String s = message.apply();\n        String prefix = \"[\" + level.toString() + \"] \";\n        if (s.regionMatches(true, 0, prefix, 0, prefix.length())) {\n            s = s.substring(prefix.length());\n        }\n        if (level.equals(Level.Error())) {\n            log.error(s);\n        } else if (level.equals(Level.Warn())) {\n            log.warn(s);\n        } else if (level.equals(Level.Info())) {\n            log.info(s);\n        } else if (level.equals(Level.Debug())) {\n            log.debug(s);\n        }\n    }\n}\n","lineNo":33}
{"Smelly Sample":"package scala_maven;\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.ArtifactUtils;\nimport org.apache.maven.artifact.factory.ArtifactFactory;\nimport org.apache.maven.artifact.metadata.ArtifactMetadataSource;\nimport org.apache.maven.artifact.repository.ArtifactRepository;\nimport org.apache.maven.artifact.resolver.ArtifactCollector;\nimport org.apache.maven.artifact.resolver.ArtifactResolutionRequest;\nimport org.apache.maven.artifact.resolver.ArtifactResolver;\nimport org.apache.maven.artifact.resolver.filter.AndArtifactFilter;\nimport org.apache.maven.artifact.resolver.filter.ArtifactFilter;\nimport org.apache.maven.artifact.resolver.filter.ScopeArtifactFilter;\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.model.Dependency;\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugin.MojoFailureException;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.project.MavenProjectBuilder;\nimport org.apache.maven.repository.RepositorySystem;\nimport org.apache.maven.shared.dependency.graph.DependencyGraphBuilder;\nimport org.apache.maven.shared.dependency.graph.DependencyNode;\nimport org.apache.maven.shared.dependency.graph.filter.AncestorOrSelfDependencyNodeFilter;\nimport org.apache.maven.shared.dependency.graph.filter.AndDependencyNodeFilter;\nimport org.apache.maven.shared.dependency.graph.filter.DependencyNodeFilter;\nimport org.apache.maven.shared.dependency.graph.traversal.CollectingDependencyNodeVisitor;\nimport org.apache.maven.shared.dependency.graph.traversal.DependencyNodeVisitor;\nimport org.apache.maven.shared.dependency.graph.traversal.FilteringDependencyNodeVisitor;\nimport org.apache.maven.toolchain.ToolchainManager;\nimport org.codehaus.plexus.util.StringUtils;\nimport scala_maven_dependency.CheckScalaVersionVisitor;\nimport scala_maven_dependency.ScalaDistroArtifactFilter;\nimport scala_maven_executions.JavaMainCaller;\nimport scala_maven_executions.JavaMainCallerByFork;\nimport scala_maven_executions.JavaMainCallerInProcess;\nimport scala_maven_executions.MainHelper;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\n\npublic abstract class ScalaMojoSupport extends AbstractMojo {\n\n    public static final String SCALA_LIBRARY_ARTIFACTID= \"scala-library\";\n    public static final String SCALA_COMPILER_ARTIFACTID= \"scala-compiler\";\n\n    /**\n     * Constant {@link String} for \"pom\". Used to specify the Maven POM artifact\n     * type.\n     */\n    protected static final String POM = \"pom\";\n\n    /**\n     * Constant {@link String} for \"jar\". Used to specify the Maven JAR artifact\n     * type.\n     */\n    protected static final String JAR = \"jar\";\n\n    /**\n     * The maven project.\n     *\n     * @parameter property=\"project\"\n     * @required\n     * @readonly\n     */\n    protected MavenProject project;\n\n    /**\n     * The Maven Session Object\n     *\n     * @parameter property=\"session\"\n     * @required\n     * @readonly\n     */\n    protected MavenSession session;\n\n    /**\n     * Contains the full list of projects in the reactor.\n     *\n     * @parameter default-value=\"${reactorProjects}\"\n     * @required\n     * @readonly\n     */\n    protected List<MavenProject> reactorProjects;\n\n    /**\n     * Used to look up Artifacts in the remote repository.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    protected RepositorySystem factory;\n\n    /**\n     * Used to look up Artifacts in the remote repository.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    protected ArtifactResolver resolver;\n    /**\n     * Location of the local repository.\n     *\n     * @parameter property=\"localRepository\"\n     * @readonly\n     * @required\n     */\n    protected ArtifactRepository localRepo;\n\n    /**\n     * List of Remote Repositories used by the resolver\n     *\n     * @parameter property=\"project.remoteArtifactRepositories\"\n     * @readonly\n     * @required\n     */\n    protected List<ArtifactRepository> remoteRepos;\n\n    /**\n     * Additional dependencies/jar to add to classpath to run \"scalaClassName\" (scope and optional field not supported)\n     * ex :\n     * <pre>\n     *    &lt;dependencies>\n     *      &lt;dependency>\n     *        &lt;groupId>org.scala-tools&lt;/groupId>\n     *        &lt;artifactId>scala-compiler-addon&lt;/artifactId>\n     *        &lt;version>1.0-SNAPSHOT&lt;/version>\n     *      &lt;/dependency>\n     *    &lt;/dependencies>\n     * <\/pre>\n     * @parameter\n     */\n    protected BasicArtifact[] dependencies;\n\n    /**\n     * Compiler plugin dependencies to use when compiling.\n     * ex:\n     * <pre>\n     * &lt;compilerPlugins>\n     *   &lt;compilerPlugin>\n     *     &lt;groupId>my.scala.plugin&lt;/groupId>\n     *     &lt;artifactId>amazingPlugin&lt;/artifactId>\n     *     &lt;version>1.0-SNAPSHOT&lt;/version>\n     *   &lt;/compilerPlugin>\n     * &lt;/compilerPlugins>\n     * <\/pre>\n     * @parameter\n     */\n    protected BasicArtifact[] compilerPlugins;\n\n    /**\n     * Jvm Arguments.\n     *\n     * @parameter\n     */\n    protected String[] jvmArgs;\n\n    /**\n     * compiler additional arguments\n     *\n     * @parameter\n     */\n    protected String[] args;\n\n    /**\n     * Additional parameter to use to call the main class.\n     * Use this parameter only from command line (\"-DaddScalacArgs=arg1|arg2|arg3|...\"), not from pom.xml.\n     * To define compiler arguments in pom.xml see the \"args\" parameter.\n     * @parameter property=\"addScalacArgs\"\n     */\n    protected String addScalacArgs;\n\n    /**\n     * className (FQN) of the scala tool to provide as\n     *\n     * @required\n     * @parameter property=\"maven.scala.className\"\n     *            default-value=\"scala.tools.nsc.Main\"\n     */\n    protected String scalaClassName;\n\n    /**\n     * Scala 's version to use.\n     * (property 'maven.scala.version' replaced by 'scala.version')\n     *\n     * @parameter property=\"scala.version\"\n     */\n    private String scalaVersion;\n\n    /**\n     * Organization/group ID of the Scala used in the project.\n     * Default value is 'org.scala-lang'.\n     * This is an advanced setting used for clones of the Scala Language.\n     * It should be disregarded in standard use cases.\n     *\n     * @parameter property=\"scala.organization\"\n     *            default-value=\"org.scala-lang\"\n     */\n    private String scalaOrganization;\n\n    public String getScalaOrganization(){\n        return scalaOrganization;\n    }\n\n    /**\n     * Scala 's version to use to check binary compatibility (like suffix in artifactId of dependency).\n     * If it is defined then it is used to checkMultipleScalaVersions\n     *\n     * @parameter property=\"scala.compat.version\"\n     */\n    private String scalaCompatVersion;\n\n    /**\n     * Path to Scala installation to use instead of the artifact (define as dependencies).\n     *\n     * @parameter property=\"scala.home\"\n     */\n    private String scalaHome;\n\n    /**\n     * Arguments for javac (when using incremental compiler).\n     *\n     * @parameter property=\"javacArgs\"\n     */\n    protected String[] javacArgs;\n\n    /**\n     * Whether to instruct javac to generate debug symbols (when using incremental compiler)\n     * @see <a href=\"http://maven.apache.org/plugins/maven-compiler-plugin/compile-mojo.html#debug\">://maven.apache.org/plugins/maven-compiler-plugin/compile-mojo.html#debug<\/a>\n     *\n     * @parameter property=\"javacGenerateDebugSymbols\"\n     *            default-value=\"true\"\n     */\n    @SuppressWarnings(\"unused\")\n    protected boolean javacGenerateDebugSymbols = true;\n\n    /**\n     * Alternative method for specifying javac arguments (when using incremental compiler).\n     * Can be used from command line with -DaddJavacArgs=arg1|arg2|arg3|... rather than in pom.xml.\n     *\n     * @parameter property=\"addJavacArgs\"\n     */\n    protected String addJavacArgs;\n\n\n    /**\n     * The -source argument for the Java compiler (when using incremental compiler).\n     *\n     * @parameter property=\"maven.compiler.source\"\n     */\n    protected String source;\n\n    /**\n     * The -target argument for the Java compiler (when using incremental compiler).\n     *\n     * @parameter property=\"maven.compiler.target\"\n     */\n    protected String target;\n\n    /**\n     * The -encoding argument for the Java compiler. (when using incremental compiler).\n     *\n     * @parameter property=\"project.build.sourceEncoding\" default-value=\"UTF-8\"\n     */\n    protected String encoding;\n\n    /**\n     * Display the command line called ?\n     * (property 'maven.scala.displayCmd' replaced by 'displayCmd')\n     *\n     * @required\n     * @parameter property=\"displayCmd\"\n     *            default-value=\"false\"\n     */\n    public boolean displayCmd;\n\n    /**\n     * Forks the execution of scalac into a separate process.\n     *\n     * @parameter default-value=\"true\"\n     */\n    protected boolean fork = true;\n\n    /**\n     * Force the use of an external ArgFile to run any forked process.\n     *\n     * @parameter default-value=\"false\"\n     */\n    protected boolean forceUseArgFile = false;\n\n    /**\n     * Check if every dependencies use the same version of scala-library or scala.compat.version.\n     *\n     * @parameter property=\"maven.scala.checkConsistency\" default-value=\"true\"\n     */\n    protected boolean checkMultipleScalaVersions;\n\n    /**\n     * Determines if a detection of multiple scala versions in the dependencies will cause the build to fail.\n     *\n     * @parameter default-value=\"false\"\n     */\n    protected boolean failOnMultipleScalaVersions = false;\n\n    /**\n     * Should use CanonicalPath to normalize path (true => getCanonicalPath, false => getAbsolutePath)\n     * @see <a href=\"https://github.com/davidB/maven-scala-plugin/issues/50\">https://github.com/davidB/maven-scala-plugin/issues/50<\/a>\n     * @parameter property=\"maven.scala.useCanonicalPath\" default-value=\"true\"\n     */\n    protected boolean useCanonicalPath = true;\n\n    /**\n     * Artifact factory, needed to download source jars.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    protected MavenProjectBuilder mavenProjectBuilder;\n\n    /**\n     * The artifact repository to use.\n     *\n     * @parameter property=\"localRepository\"\n     * @required\n     * @readonly\n     */\n    private ArtifactRepository localRepository;\n\n    /**\n     * The artifact factory to use.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    private ArtifactFactory artifactFactory;\n\n    /**\n     * The artifact metadata source to use.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    private ArtifactMetadataSource artifactMetadataSource;\n\n    /**\n     * The artifact collector to use.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    private ArtifactCollector artifactCollector;\n\n    /**\n     * The dependency tree builder to use.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    private DependencyGraphBuilder dependencyTreeBuilder;\n\n    /**\n     * The toolchain manager to use.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    protected ToolchainManager toolchainManager;\n\n    /**\n     * List of artifacts to run plugin\n     * \n     * @parameter default-value=\"${plugin.artifacts}\"\n     */\n    private List<Artifact> pluginArtifacts;\n\n    private VersionNumber _scalaVersionN;\n\n    /**\n     * Constructs an {@link Artifact} for Scala Compiler.\n     *\n     * @param scalaVersion the version of the Scala Compiler/Library we are\n     *        using for this execution.\n     *\n     * @return a {@link Artifact} for the Scala Compiler.\n     */\n    protected final Artifact scalaCompilerArtifact(final String scalaVersion) {\n        return this.factory.createArtifact(this.getScalaOrganization(),\n                                           ScalaMojoSupport.SCALA_COMPILER_ARTIFACTID,\n                                           scalaVersion,\n                                           \"\",\n                                           ScalaMojoSupport.POM);\n    }\n\n    /**\n     * This method resolves all transitive dependencies of an artifact.\n     *\n     * @param artifact the {@link Artifact} used to retrieve dependencies.\n     *\n     * @return resolved {@link Set} of dependencies.\n     *\n     * @throws {@link Exception} when various artifact resolution mechanisms fail.\n     */\n    protected final Set<Artifact> resolveArtifactDependencies(final Artifact artifact) throws Exception {\n        final AndArtifactFilter filter = new AndArtifactFilter();\n        filter.add(new ScopeArtifactFilter(Artifact.SCOPE_TEST));\n        filter.add(new ArtifactFilter(){\n                public boolean include(Artifact artifact) {\n                    return !artifact.isOptional();\n                }\n            });\n\n        // Use the collection filter as the resolution filter.\n        return resolveDependencyArtifacts(artifact,\n                                          filter,\n                                          filter);\n    }\n\n    /**\n     * This method resolves all transitive dependencies of an artifact.\n     *\n     * @param artifact the {@link Artifact} used to retrieve dependencies.\n     * @param collectionFilter an {@link ArtifactFilter} used to determine which\n     *        members of the dependency graph should be included in resolution.\n     * @param collectionFilter an {@link ArtifactFilter} used to determine which\n     *        members dependency graph should be downloaded.\n     *\n     * @return resolved {@link Set} of dependencies.\n     *\n     * @throws {@link Exception} when various artifact resolution mechanisms fail.\n     */\n    protected final Set<Artifact> resolveDependencyArtifacts(final Artifact artifact,\n                                                             final ArtifactFilter collectionFilter,\n                                                             final ArtifactFilter resolutionFilter) throws Exception {\n        return this.resolveDependencyArtifacts(artifact,\n                                               collectionFilter,\n                                               resolutionFilter,\n                                               this.remoteRepos,\n                                               this.localRepo);\n    }\n\n    /**\n     * This method resolves all transitive dependencies of an artifact.\n     *\n     * @param artifact the {@link Artifact} used to retrieve dependencies.\n     * @param collectionFilter an {@link ArtifactFilter} used to determine which\n     *        members of the dependency graph should be included in resolution.\n     * @param collectionFilter an {@link ArtifactFilter} used to determine which\n     *        members dependency graph should be downloaded.\n     * @param remoteRepositories a {@link List} of remote {@link\n     *        ArtifactRespository} values to used for dependency resolution of\n     *        the provided {@link Artifact}.\n     * @param localRepository the local {@link ArtifactRepository} to use for\n     *        dependency resolution of the given {@link Artifact}.\n     *\n     * @return resolved {@link Set} of dependencies.\n     *\n     * @throws {@link Exception} when various artifact resolution mechanisms fail.\n     */\n    protected final Set<Artifact> resolveDependencyArtifacts(final Artifact artifact,\n                                                             final ArtifactFilter collectionFilter,\n                                                             final ArtifactFilter resolutionFilter,\n                                                             final List<ArtifactRepository> remoteRepositories,\n                                                             final ArtifactRepository localRepository) throws Exception {\n        final ArtifactResolutionRequest arr =\n            this.createArtifactResolutionRequest(artifact,\n                                                 collectionFilter,\n                                                 resolutionFilter,\n                                                 remoteRepositories,\n                                                 localRepository);\n\n        //TODO follow the dependenciesManagement and override rules\n        return this.resolver.resolve(arr).getArtifacts();\n    }\n\n    /**\n     * Create a {@link ArtifactResolutionRequest}.\n     *\n     * @param artifact the {@link Artifact} used to retrieve dependencies.\n     * @param collectionFilter an {@link ArtifactFilter} used to determine which\n     *        members of the dependency graph should be included in resolution.\n     * @param collectionFilter an {@link ArtifactFilter} used to determine which\n     *        members dependency graph should be downloaded.\n     * @param remoteRepositories a {@link List} of remote {@link\n     *        ArtifactRespository} values to used for dependency resolution of\n     *        the provided {@link Artifact}.\n     * @param localRepository the local {@link ArtifactRepository} to use for\n     *        dependency resolution of the given {@link Artifact}.\n     *\n     * @return an {@link ArtifactResolutionRequest}, typically used for\n     *         dependency resolution requests against an {@link\n     *         ArtifactResolver}.\n     */\n    private ArtifactResolutionRequest createArtifactResolutionRequest(final Artifact artifact,\n                                                                      final ArtifactFilter collectionFilter,\n                                                                      final ArtifactFilter resolutionFilter,\n                                                                      final List<ArtifactRepository> remoteRepositories,\n                                                                      final ArtifactRepository localRepository) {\n        final ArtifactResolutionRequest arr = new ArtifactResolutionRequest();\n\n        arr.setArtifact(artifact);\n        arr.setCollectionFilter(collectionFilter);\n        arr.setResolutionFilter(resolutionFilter);\n        arr.setResolveRoot(false);\n        arr.setResolveTransitively(true);\n        arr.setRemoteRepositories(remoteRepositories);\n        arr.setLocalRepository(localRepository);\n\n        return arr;\n    }\n\n    public void addToClasspath(String groupId, String artifactId, String version, Set<String> classpath) throws Exception {\n        addToClasspath(groupId, artifactId, version, classpath, true);\n    }\n\n\n    public void addToClasspath(String groupId, String artifactId, String version, Set<String> classpath, boolean addDependencies) throws Exception {\n        addToClasspath(factory.createArtifact(groupId, artifactId, version, Artifact.SCOPE_RUNTIME, ScalaMojoSupport.JAR), classpath, addDependencies);\n    }\n\n    /**\n     * added for classifier support.\n     * @author Christoph Radig\n     * @todo might want to merge with existing \"addToClasspath\" methods.\n     */\n    public void addToClasspath(String groupId, String artifactId, String version, String classifier, Set<String> classpath, boolean addDependencies) throws Exception {\n      Dependency d = new Dependency();\n      d.setGroupId(groupId);\n      d.setArtifactId(artifactId);\n      d.setVersion(version);\n      d.setType(ScalaMojoSupport.JAR);\n      d.setClassifier(classifier);\n      d.setScope(Artifact.SCOPE_RUNTIME);\n      addToClasspath(factory.createDependencyArtifact(d), classpath, addDependencies);\n    }\n\n    protected void addToClasspath(Artifact artifact, Set<String> classpath, boolean addDependencies) throws Exception {\n        resolver.resolve(artifact, remoteRepos, localRepo);\n        classpath.add(FileUtils.pathOf(artifact.getFile(), useCanonicalPath));\n        if (addDependencies) {\n            for (Artifact dep : resolveArtifactDependencies(artifact)) {\n                addToClasspath(dep, classpath, addDependencies);\n            }\n        }\n    }\n\n    protected void addCompilerToClasspath(Set<String> classpath) throws Exception {\n      classpath.add(FileUtils.pathOf(getCompilerJar(), useCanonicalPath));\n      for (File dep : getCompilerDependencies()) {\n        classpath.add(FileUtils.pathOf(dep, useCanonicalPath));\n      }\n    }\n\n    protected void addLibraryToClasspath(Set<String> classpath) throws Exception {\n      classpath.add(FileUtils.pathOf(getLibraryJar(), useCanonicalPath));\n    }\n\n    @Override\n    public void execute() throws MojoExecutionException, MojoFailureException {\n        try {\n            String oldWay = System.getProperty(\"maven.scala.version\");\n            if (oldWay != null) {\n                getLog().warn(\"using 'maven.scala.version' is deprecated, use 'scala.version' instead\");\n                if (scalaVersion != null) {\n                    scalaVersion = oldWay;\n                }\n            }\n\n            oldWay = System.getProperty(\"maven.scala.displayCmd\");\n            if (oldWay != null) {\n                getLog().warn(\"using 'maven.scala.displayCmd' is deprecated, use 'displayCmd' instead\");\n                displayCmd = displayCmd || Boolean.parseBoolean(oldWay);\n            }\n            checkScalaVersion();\n            doExecute();\n        } catch (MojoExecutionException exc) {\n            throw exc;\n        } catch (MojoFailureException exc) {\n            throw exc;\n        } catch (RuntimeException exc) {\n            throw exc;\n        } catch (Exception exc) {\n            throw new MojoExecutionException(\"wrap: \" + exc, exc);\n        }\n    }\n\n    protected List<Dependency> getDependencies() {\n        return project.getCompileDependencies();\n    }\n\n    protected VersionNumber findScalaVersion() throws Exception {\n        if (_scalaVersionN == null) {\n            String detectedScalaVersion = scalaVersion;\n            if (StringUtils.isEmpty(detectedScalaVersion)) {\n                detectedScalaVersion = findScalaVersionFromDependencies();\n            }\n            if (StringUtils.isEmpty(detectedScalaVersion)) {\n                if (!ScalaMojoSupport.POM.equals( project.getPackaging().toLowerCase() )) {\n                    getLog().warn(\"you don't define \"+ getScalaOrganization() + \":\" + SCALA_LIBRARY_ARTIFACTID + \" as a dependency of the project\");\n                }\n                detectedScalaVersion = \"0.0.0\";\n            } else {\n                // grappy hack to retrieve the SNAPSHOT version without timestamp,...\n                // because if version is -SNAPSHOT and artifact is deploy with uniqueValue then the version\n                // get from dependency is with the timestamp and a build number (the resolved version)\n                // but scala-compiler with the same version could have different resolved version (timestamp,...)\n                boolean isSnapshot = ArtifactUtils.isSnapshot(detectedScalaVersion);\n                if (isSnapshot && !detectedScalaVersion.endsWith(\"-SNAPSHOT\")) {\n                    detectedScalaVersion = detectedScalaVersion.substring(0, detectedScalaVersion.lastIndexOf('-', detectedScalaVersion.lastIndexOf('-')-1)) + \"-SNAPSHOT\";\n                }\n            }\n            if (StringUtils.isEmpty(detectedScalaVersion)) {\n                throw new MojoFailureException(\"no scalaVersion detected or set\");\n            }\n            if (StringUtils.isNotEmpty(scalaVersion)) {\n                if (!scalaVersion.equals(detectedScalaVersion)) {\n                    getLog().warn(\"scala library version define in dependencies doesn't match the scalaVersion of the plugin\");\n                }\n                //getLog().info(\"suggestion: remove the scalaVersion from pom.xml\"); //scalaVersion could be define in a parent pom where lib is not required\n            }\n            _scalaVersionN = new VersionNumber(detectedScalaVersion);\n        }\n        return _scalaVersionN;\n    }\n\n    private String findScalaVersionFromDependencies() throws Exception {\n        return findVersionFromDependencies(getScalaOrganization(), SCALA_LIBRARY_ARTIFACTID);\n    }\n\n    //TODO refactor to do only one scan of dependencies to find version\n    protected String findVersionFromDependencies(String groupId, String artifactId) throws Exception {\n        String version = null;\n        for (Dependency dep : getDependencies()) {\n            if (groupId.equals(dep.getGroupId()) && artifactId.equals(dep.getArtifactId())) {\n                version = dep.getVersion();\n            }\n        }\n        if (StringUtils.isEmpty(version)) {\n            List<Dependency> deps = new ArrayList<Dependency>();\n            deps.addAll(project.getModel().getDependencies());\n            if (project.getModel().getDependencyManagement() != null) {\n                deps.addAll(project.getModel().getDependencyManagement().getDependencies());\n            }\n            for (Dependency dep : deps) {\n                if (groupId.equals(dep.getGroupId()) && artifactId.equals(dep.getArtifactId())) {\n                    version = dep.getVersion();\n                }\n            }\n        }\n        return version;\n    }\n\n    protected void checkScalaVersion() throws Exception {\n        String sv = findScalaVersion().toString();\n        if (StringUtils.isNotEmpty(scalaHome)) {\n            getLog().warn(String.format(\"local scala-library.jar and scala-compiler.jar from scalaHome(%s) used instead of scala %s\", scalaHome, sv));\n        }\n        if (checkMultipleScalaVersions) {\n            checkCorrectVersionsOfScalaLibrary(sv);\n        }\n    }\n\n    /** this method checks to see if there are multiple versions of the scala library\n     * @throws Exception */\n    private void checkCorrectVersionsOfScalaLibrary(String scalaDefVersion) throws Exception {\n        getLog().debug(\"Checking for multiple versions of scala\");\n        //TODO - Make sure we handle bad artifacts....\n        // TODO: note that filter does not get applied due to MNG-3236\n        VersionNumber sv = new VersionNumber(scalaDefVersion);\n        VersionNumber requiredScalaVersion = StringUtils.isNotEmpty(scalaCompatVersion) ? new VersionNumberMask(scalaCompatVersion) : sv;\n        if (requiredScalaVersion.compareTo(sv) != 0) {\n          String msg = String.format(\"Scala library detected %s doesn't match scala.compat.version : %s\", sv, requiredScalaVersion);\n          if(failOnMultipleScalaVersions) {\n            getLog().error(msg);\n            throw new MojoFailureException(msg);\n          }\n          getLog().warn(msg);\n        }\n        checkArtifactForScalaVersion(requiredScalaVersion, dependencyTreeBuilder.buildDependencyGraph(project.getProjectBuildingRequest(), null));\n    }\n\n\n    /** Visits a node (and all dependencies) to see if it contains duplicate scala versions */\n    private void checkArtifactForScalaVersion(VersionNumber requiredScalaVersion, DependencyNode rootNode) throws Exception {\n        final CheckScalaVersionVisitor visitor = new CheckScalaVersionVisitor(requiredScalaVersion, getLog(), getScalaOrganization());\n\n        CollectingDependencyNodeVisitor collectingVisitor = new CollectingDependencyNodeVisitor();\n        DependencyNodeVisitor firstPassVisitor = new FilteringDependencyNodeVisitor( collectingVisitor, createScalaDistroDependencyFilter() );\n        rootNode.accept( firstPassVisitor );\n\n        DependencyNodeFilter secondPassFilter = new AncestorOrSelfDependencyNodeFilter( collectingVisitor.getNodes() );\n        DependencyNodeVisitor filteredVisitor = new FilteringDependencyNodeVisitor( visitor, secondPassFilter );\n\n        rootNode.accept( filteredVisitor );\n\n        if(visitor.isFailed()) {\n            visitor.logScalaDependents();\n            if(failOnMultipleScalaVersions) {\n                getLog().error(\"Multiple versions of scala libraries detected!\");\n                throw new MojoFailureException(\"Multiple versions of scala libraries detected!\");\n            }\n            getLog().warn(\"Multiple versions of scala libraries detected!\");\n        }\n    }\n\n    /**\n     * @return\n     *          A filter to only extract artifacts deployed from scala distributions\n     */\n    private DependencyNodeFilter createScalaDistroDependencyFilter() {\n        List<DependencyNodeFilter> filters = new ArrayList<DependencyNodeFilter>();\n        filters.add(new ScalaDistroArtifactFilter(getScalaOrganization()));\n        return new AndDependencyNodeFilter(filters);\n    }\n\n\n\n    protected abstract void doExecute() throws Exception;\n\n\n    protected JavaMainCaller getScalaCommand() throws Exception {\n        return this.getScalaCommand(this.fork,\n                                    this.scalaClassName);\n    }\n\n    /**\n     * Get a {@link JavaMainCaller} used invoke a Java process. Typically this\n     * will be one of the Scala utilities (Compiler, ScalaDoc, REPL, etc.).\n     * <p>\n     * This method does some setup on the {@link JavaMainCaller} which is not\n     * done by merely invoking {@code new} on one of the\n     * implementations. Specifically, it adds any Scala compiler plugin options,\n     * JVM options, and Scalac options defined on the plugin.\n     *\n     * @param forkOverride override the setting for {@link #fork}. Currently\n     *        this should only be set if you are invoking the REPL.\n     * @param mainClass the JVM main class to invoke.\n     *\n     * @return a {@link JavaMainCaller} to use to invoke the given command.\n     */\n    protected final JavaMainCaller getScalaCommand(final boolean forkOverride,\n                                                   final String mainClass) throws Exception {\n        JavaMainCaller cmd = getEmptyScalaCommand(mainClass, forkOverride);\n        cmd.addArgs(args);\n        if (StringUtils.isNotEmpty(addScalacArgs)) {\n          cmd.addArgs(StringUtils.split(addScalacArgs, \"|\"));\n        }\n        addCompilerPluginOptions(cmd);\n        cmd.addJvmArgs(jvmArgs);\n        return cmd;\n    }\n\n    /**\n     * Get a {@link JavaMainCaller} used invoke a Java process. Typically this\n     * will be one of the Scala utilities (Compiler, ScalaDoc, REPL, etc.).\n     *\n     * @param mainClass the JVM main class to invoke.\n     *\n     * @return a {@link JavaMainCaller} to use to invoke the given command.\n     */\n    protected final JavaMainCaller getEmptyScalaCommand(final String mainClass) throws Exception {\n        return this.getEmptyScalaCommand(mainClass, this.fork);\n    }\n\n    /**\n     * Get a {@link JavaMainCaller} used invoke a Java process. Typically this\n     * will be one of the Scala utilities (Compiler, ScalaDoc, REPL, etc.).\n     *\n     * @param mainClass the JVM main class to invoke.\n     * @param forkOverride override the setting for {@link #fork}. Currently\n     *        this should only be set if you are invoking the REPL.\n     *\n     * @return a {@link JavaMainCaller} to use to invoke the given command.\n     */\n    protected JavaMainCaller getEmptyScalaCommand(final String mainClass,\n                                                  final boolean forkOverride) throws Exception {\n\n        // If we are deviating from the plugin settings, let the user know\n        // what's going on.\n        if (forkOverride != this.fork) {\n            super.getLog().info(\"Fork behavior overridden\");\n            super.getLog().info(String.format(\"Fork for this execution is %s.\", String.valueOf(forkOverride)));\n        }\n\n        //TODO - Fork or not depending on configuration?\n        JavaMainCaller cmd;\n        String toolcp = getToolClasspath();\n        if(forkOverride) {\n            // HACK (better may need refactor)\n            boolean bootcp = true;\n            if (args != null) {\n                for(String arg : args) {\n                    bootcp = bootcp && !\"-nobootcp\".equals(arg);\n                }\n            }\n            String cp = bootcp ? \"\" : toolcp;\n            bootcp = bootcp && !(StringUtils.isNotEmpty(addScalacArgs) && addScalacArgs.contains(\"-nobootcp\"));\n            // scalac with args in files\n            // * works only since 2.8.0\n            // * is buggy (don't manage space in path on windows)\n            getLog().debug(\"use java command with args in file forced : \" + forceUseArgFile);\n            cmd = new JavaMainCallerByFork(this, mainClass, cp, null, null, forceUseArgFile, toolchainManager.getToolchainFromBuildContext(\"jdk\", session));\n            if (bootcp) {\n                cmd.addJvmArgs(\"-Xbootclasspath/a:\" + toolcp);\n            }\n        } else  {\n            cmd = new JavaMainCallerInProcess(this, mainClass, toolcp, null, null);\n        }\n        return cmd;\n    }\n\n    private String getToolClasspath() throws Exception {\n        Set<String> classpath = new LinkedHashSet<String>();\n        addLibraryToClasspath(classpath);\n        addCompilerToClasspath(classpath);\n//        addToClasspath(SCALA_GROUPID, \"scala-decoder\", scalaVersion, classpath);\n//        addToClasspath(SCALA_GROUPID, \"scala-dbc\", scalaVersion, classpath);\n        if (dependencies != null) {\n            for(BasicArtifact artifact: dependencies) {\n                addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, classpath);\n            }\n        }\n        return MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()]));\n    }\n\n    protected List<String> getScalaOptions() throws Exception {\n        List<String> options = new ArrayList<String>();\n        if (args != null) Collections.addAll(options, args);\n        if (StringUtils.isNotEmpty(addScalacArgs)) {\n            Collections.addAll(options, StringUtils.split(addScalacArgs, \"|\"));\n        }\n        options.addAll(getCompilerPluginOptions());\n        return options;\n    }\n\n    protected List<String> getJavacOptions() throws Exception {\n        List<String> options = new ArrayList<String>();\n        if (javacArgs != null) Collections.addAll(options, javacArgs);\n        if (StringUtils.isNotEmpty(addJavacArgs)) {\n            Collections.addAll(options, StringUtils.split(addJavacArgs, \"|\"));\n        }\n\n        // issue #116\n        if (javacGenerateDebugSymbols) {\n            options.add(\"-g\");\n        }\n        if (target != null) {\n            options.add(\"-target\");\n            options.add(target);\n        }\n        if (source != null) {\n          options.add(\"-source\");\n          options.add(source);\n        }\n        if (encoding != null) {\n          options.add(\"-encoding\");\n          options.add(encoding);\n        }\n        return options;\n    }\n\n    protected File getLibraryJar() throws Exception {\n      if (StringUtils.isNotEmpty(scalaHome)) {\n        File lib = new File(scalaHome, \"lib\");\n        return new File(lib, \"scala-library.jar\");\n      }\n      return getArtifactJar(getScalaOrganization(), SCALA_LIBRARY_ARTIFACTID, findScalaVersion().toString());\n    }\n\n    protected File getCompilerJar() throws Exception {\n      if(StringUtils.isNotEmpty(scalaHome)) {\n        File lib = new File(scalaHome, \"lib\");\n        return new File(lib, \"scala-compiler.jar\");\n      }\n      return getArtifactJar(getScalaOrganization(), SCALA_COMPILER_ARTIFACTID, findScalaVersion().toString());\n    }\n\n    protected List<File> getCompilerDependencies() throws Exception {\n      List<File> d = new ArrayList<File>();\n      if(StringUtils.isEmpty(scalaHome)) {\n        for (Artifact artifact : getAllDependencies(getScalaOrganization(), SCALA_COMPILER_ARTIFACTID, findScalaVersion().toString())) {\n          d.add(artifact.getFile());\n        }\n      } else {\n        for(File f : new File(scalaHome, \"lib\").listFiles()) {\n          String name = f.getName();\n          if (name.endsWith(\".jar\") && !name.contains(\"scala-library\") && !name.contains(\"scala-compiler\")) {\n            d.add(f);\n          }\n        }\n      }\n      return d;\n    }\n\n    protected File getArtifactJar(String groupId, String artifactId, String version) throws Exception {\n        Artifact artifact = factory.createArtifact(groupId, artifactId, version, Artifact.SCOPE_RUNTIME, ScalaMojoSupport.JAR);\n        resolver.resolve(artifact, remoteRepos, localRepo);\n        return artifact.getFile();\n    }\n\n    protected File getArtifactJar(String groupId, String artifactId, String version, String classifier) throws Exception {\n        Artifact artifact = factory.createArtifactWithClassifier(groupId, artifactId, version, ScalaMojoSupport.JAR, classifier);\n        resolver.resolve(artifact, remoteRepos, localRepo);\n        return artifact.getFile();\n    }\n\n    protected Set<Artifact> getAllDependencies(String groupId, String artifactId, String version) throws Exception {\n        Set<Artifact> result = new HashSet<Artifact>();\n        Artifact pom = factory.createArtifact(groupId, artifactId, version, \"\", ScalaMojoSupport.POM);\n        Set<Artifact> d = resolveArtifactDependencies(pom);\n        result.addAll(d);\n        for (Artifact dependency : d) {\n            Set<Artifact> transitive = getAllDependencies(dependency.getGroupId(), dependency.getArtifactId(), dependency.getVersion());\n            result.addAll(transitive);\n        }\n        return result;\n    }\n\n    /**\n     * @return\n     *           This returns whether or not the scala version can support having java sent into the compiler\n     */\n    protected boolean isJavaSupportedByCompiler() throws Exception {\n        return findScalaVersion().compareTo(new VersionNumber(\"2.7.2\")) >= 0;\n    }\n\n\n    /**\n     * Adds appropriate compiler plugins to the scalac command.\n     * @param scalac\n     * @throws Exception\n     */\n    protected void addCompilerPluginOptions(JavaMainCaller scalac) throws Exception {\n        for (String option : getCompilerPluginOptions()) {\n            scalac.addArgs(option);\n        }\n    }\n\n    protected List<String> getCompilerPluginOptions() throws Exception {\n        List<String> options = new ArrayList<String>();\n        for (String plugin : getCompilerPlugins()) {\n            options.add(\"-Xplugin:\" + plugin);\n        }\n        return options;\n    }\n\n    /**\n     * Retrieves a list of paths to scala compiler plugins.\n     *\n     * @return The list of plugins\n     * @throws Exception\n     */\n    private Set<String> getCompilerPlugins() throws Exception {\n        Set<String> plugins = new HashSet<String>();\n        if (compilerPlugins != null) {\n            Set<String> ignoreClasspath = new LinkedHashSet<String>();\n            addCompilerToClasspath(ignoreClasspath);\n            addLibraryToClasspath(ignoreClasspath);\n            for (BasicArtifact artifact : compilerPlugins) {\n                getLog().info(\"compiler plugin: \" + artifact.toString());\n                // TODO - Ensure proper scala version for plugins\n                Set<String> pluginClassPath = new HashSet<String>();\n                //TODO - Pull in transitive dependencies.\n                addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, artifact.classifier, pluginClassPath, false);\n                pluginClassPath.removeAll(ignoreClasspath);\n                plugins.addAll(pluginClassPath);\n            }\n        }\n        return plugins;\n    }\n\n    protected String findVersionFromPluginArtifacts(String groupId, String artifactId) throws Exception {\n        String version = null;\n        for (Artifact art : pluginArtifacts) {\n            if (groupId.equals(art.getGroupId()) && artifactId.equals(art.getArtifactId())) {\n                version = art.getVersion();\n            }\n        }\n        return version;\n    }\n\n    protected File getPluginArtifactJar(String groupId, String artifactId, String version) throws Exception {\n        return getPluginArtifactJar(groupId, artifactId, version, null);\n    }\n\n    protected File getPluginArtifactJar(String groupId, String artifactId, String version, String classifier) throws Exception {\n        Artifact artifact = null;\n        for (Artifact art : pluginArtifacts) {\n            if (groupId.equals(art.getGroupId()) && artifactId.equals(art.getArtifactId()) && version.equals(art.getVersion())){\n            \tif ((classifier == null && art.getClassifier() == null) || (classifier != null && classifier.equals(art.getClassifier()))) {\n            \t\tartifact = art;\n            \t}\n            }\n        }\n        if (artifact == null) {\n\t    \tString msg = String.format(\"can't find artifact %s::%s::%s-%s\", groupId, artifactId, version, classifier);\n\t    \tgetLog().error(msg);\n\t    \tthrow new Exception(msg);\n        }\n        return artifact.getFile();\n    }\n}\n","Method after Refactoring":"package scala_maven;\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.ArtifactUtils;\nimport org.apache.maven.artifact.factory.ArtifactFactory;\nimport org.apache.maven.artifact.metadata.ArtifactMetadataSource;\nimport org.apache.maven.artifact.repository.ArtifactRepository;\nimport org.apache.maven.artifact.resolver.ArtifactCollector;\nimport org.apache.maven.artifact.resolver.ArtifactResolutionRequest;\nimport org.apache.maven.artifact.resolver.ArtifactResolver;\nimport org.apache.maven.artifact.resolver.filter.AndArtifactFilter;\nimport org.apache.maven.artifact.resolver.filter.ArtifactFilter;\nimport org.apache.maven.artifact.resolver.filter.ScopeArtifactFilter;\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.model.Dependency;\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugin.MojoFailureException;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.project.MavenProjectBuilder;\nimport org.apache.maven.project.ProjectBuildingRequest;\nimport org.apache.maven.repository.RepositorySystem;\nimport org.apache.maven.shared.dependency.graph.DependencyGraphBuilder;\nimport org.apache.maven.shared.dependency.graph.DependencyNode;\nimport org.apache.maven.shared.dependency.graph.filter.AncestorOrSelfDependencyNodeFilter;\nimport org.apache.maven.shared.dependency.graph.filter.AndDependencyNodeFilter;\nimport org.apache.maven.shared.dependency.graph.filter.DependencyNodeFilter;\nimport org.apache.maven.shared.dependency.graph.traversal.CollectingDependencyNodeVisitor;\nimport org.apache.maven.shared.dependency.graph.traversal.DependencyNodeVisitor;\nimport org.apache.maven.shared.dependency.graph.traversal.FilteringDependencyNodeVisitor;\nimport org.apache.maven.toolchain.ToolchainManager;\nimport org.codehaus.plexus.util.StringUtils;\nimport scala_maven_dependency.CheckScalaVersionVisitor;\nimport scala_maven_dependency.ScalaDistroArtifactFilter;\nimport scala_maven_executions.JavaMainCaller;\nimport scala_maven_executions.JavaMainCallerByFork;\nimport scala_maven_executions.JavaMainCallerInProcess;\nimport scala_maven_executions.MainHelper;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\n\npublic abstract class ScalaMojoSupport extends AbstractMojo {\n\n    public static final String SCALA_LIBRARY_ARTIFACTID= \"scala-library\";\n    public static final String SCALA_COMPILER_ARTIFACTID= \"scala-compiler\";\n\n    /**\n     * Constant {@link String} for \"pom\". Used to specify the Maven POM artifact\n     * type.\n     */\n    protected static final String POM = \"pom\";\n\n    /**\n     * Constant {@link String} for \"jar\". Used to specify the Maven JAR artifact\n     * type.\n     */\n    protected static final String JAR = \"jar\";\n\n    /**\n     * The maven project.\n     *\n     * @parameter property=\"project\"\n     * @required\n     * @readonly\n     */\n    protected MavenProject project;\n\n    /**\n     * The Maven Session Object\n     *\n     * @parameter property=\"session\"\n     * @required\n     * @readonly\n     */\n    protected MavenSession session;\n\n    /**\n     * Contains the full list of projects in the reactor.\n     *\n     * @parameter default-value=\"${reactorProjects}\"\n     * @required\n     * @readonly\n     */\n    protected List<MavenProject> reactorProjects;\n\n    /**\n     * Used to look up Artifacts in the remote repository.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    protected RepositorySystem factory;\n\n    /**\n     * Used to look up Artifacts in the remote repository.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    protected ArtifactResolver resolver;\n    /**\n     * Location of the local repository.\n     *\n     * @parameter property=\"localRepository\"\n     * @readonly\n     * @required\n     */\n    protected ArtifactRepository localRepo;\n\n    /**\n     * List of Remote Repositories used by the resolver\n     *\n     * @parameter property=\"project.remoteArtifactRepositories\"\n     * @readonly\n     * @required\n     */\n    protected List<ArtifactRepository> remoteRepos;\n\n    /**\n     * Additional dependencies/jar to add to classpath to run \"scalaClassName\" (scope and optional field not supported)\n     * ex :\n     * <pre>\n     *    &lt;dependencies>\n     *      &lt;dependency>\n     *        &lt;groupId>org.scala-tools&lt;/groupId>\n     *        &lt;artifactId>scala-compiler-addon&lt;/artifactId>\n     *        &lt;version>1.0-SNAPSHOT&lt;/version>\n     *      &lt;/dependency>\n     *    &lt;/dependencies>\n     * <\/pre>\n     * @parameter\n     */\n    protected BasicArtifact[] dependencies;\n\n    /**\n     * Compiler plugin dependencies to use when compiling.\n     * ex:\n     * <pre>\n     * &lt;compilerPlugins>\n     *   &lt;compilerPlugin>\n     *     &lt;groupId>my.scala.plugin&lt;/groupId>\n     *     &lt;artifactId>amazingPlugin&lt;/artifactId>\n     *     &lt;version>1.0-SNAPSHOT&lt;/version>\n     *   &lt;/compilerPlugin>\n     * &lt;/compilerPlugins>\n     * <\/pre>\n     * @parameter\n     */\n    protected BasicArtifact[] compilerPlugins;\n\n    /**\n     * Jvm Arguments.\n     *\n     * @parameter\n     */\n    protected String[] jvmArgs;\n\n    /**\n     * compiler additional arguments\n     *\n     * @parameter\n     */\n    protected String[] args;\n\n    /**\n     * Additional parameter to use to call the main class.\n     * Use this parameter only from command line (\"-DaddScalacArgs=arg1|arg2|arg3|...\"), not from pom.xml.\n     * To define compiler arguments in pom.xml see the \"args\" parameter.\n     * @parameter property=\"addScalacArgs\"\n     */\n    protected String addScalacArgs;\n\n    /**\n     * className (FQN) of the scala tool to provide as\n     *\n     * @required\n     * @parameter property=\"maven.scala.className\"\n     *            default-value=\"scala.tools.nsc.Main\"\n     */\n    protected String scalaClassName;\n\n    /**\n     * Scala 's version to use.\n     * (property 'maven.scala.version' replaced by 'scala.version')\n     *\n     * @parameter property=\"scala.version\"\n     */\n    private String scalaVersion;\n\n    /**\n     * Organization/group ID of the Scala used in the project.\n     * Default value is 'org.scala-lang'.\n     * This is an advanced setting used for clones of the Scala Language.\n     * It should be disregarded in standard use cases.\n     *\n     * @parameter property=\"scala.organization\"\n     *            default-value=\"org.scala-lang\"\n     */\n    private String scalaOrganization;\n\n    public String getScalaOrganization(){\n        return scalaOrganization;\n    }\n\n    /**\n     * Scala 's version to use to check binary compatibility (like suffix in artifactId of dependency).\n     * If it is defined then it is used to checkMultipleScalaVersions\n     *\n     * @parameter property=\"scala.compat.version\"\n     */\n    private String scalaCompatVersion;\n\n    /**\n     * Path to Scala installation to use instead of the artifact (define as dependencies).\n     *\n     * @parameter property=\"scala.home\"\n     */\n    private String scalaHome;\n\n    /**\n     * Arguments for javac (when using incremental compiler).\n     *\n     * @parameter property=\"javacArgs\"\n     */\n    protected String[] javacArgs;\n\n    /**\n     * Whether to instruct javac to generate debug symbols (when using incremental compiler)\n     * @see <a href=\"http://maven.apache.org/plugins/maven-compiler-plugin/compile-mojo.html#debug\">://maven.apache.org/plugins/maven-compiler-plugin/compile-mojo.html#debug<\/a>\n     *\n     * @parameter property=\"javacGenerateDebugSymbols\"\n     *            default-value=\"true\"\n     */\n    @SuppressWarnings(\"unused\")\n    protected boolean javacGenerateDebugSymbols = true;\n\n    /**\n     * Alternative method for specifying javac arguments (when using incremental compiler).\n     * Can be used from command line with -DaddJavacArgs=arg1|arg2|arg3|... rather than in pom.xml.\n     *\n     * @parameter property=\"addJavacArgs\"\n     */\n    protected String addJavacArgs;\n\n\n    /**\n     * The -source argument for the Java compiler (when using incremental compiler).\n     *\n     * @parameter property=\"maven.compiler.source\"\n     */\n    protected String source;\n\n    /**\n     * The -target argument for the Java compiler (when using incremental compiler).\n     *\n     * @parameter property=\"maven.compiler.target\"\n     */\n    protected String target;\n\n    /**\n     * The -encoding argument for the Java compiler. (when using incremental compiler).\n     *\n     * @parameter property=\"project.build.sourceEncoding\" default-value=\"UTF-8\"\n     */\n    protected String encoding;\n\n    /**\n     * Display the command line called ?\n     * (property 'maven.scala.displayCmd' replaced by 'displayCmd')\n     *\n     * @required\n     * @parameter property=\"displayCmd\"\n     *            default-value=\"false\"\n     */\n    public boolean displayCmd;\n\n    /**\n     * Forks the execution of scalac into a separate process.\n     *\n     * @parameter default-value=\"true\"\n     */\n    protected boolean fork = true;\n\n    /**\n     * Force the use of an external ArgFile to run any forked process.\n     *\n     * @parameter default-value=\"false\"\n     */\n    protected boolean forceUseArgFile = false;\n\n    /**\n     * Check if every dependencies use the same version of scala-library or scala.compat.version.\n     *\n     * @parameter property=\"maven.scala.checkConsistency\" default-value=\"true\"\n     */\n    protected boolean checkMultipleScalaVersions;\n\n    /**\n     * Determines if a detection of multiple scala versions in the dependencies will cause the build to fail.\n     *\n     * @parameter default-value=\"false\"\n     */\n    protected boolean failOnMultipleScalaVersions = false;\n\n    /**\n     * Should use CanonicalPath to normalize path (true => getCanonicalPath, false => getAbsolutePath)\n     * @see <a href=\"https://github.com/davidB/maven-scala-plugin/issues/50\">https://github.com/davidB/maven-scala-plugin/issues/50<\/a>\n     * @parameter property=\"maven.scala.useCanonicalPath\" default-value=\"true\"\n     */\n    protected boolean useCanonicalPath = true;\n\n    /**\n     * Artifact factory, needed to download source jars.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    protected MavenProjectBuilder mavenProjectBuilder;\n\n    /**\n     * The artifact repository to use.\n     *\n     * @parameter property=\"localRepository\"\n     * @required\n     * @readonly\n     */\n    private ArtifactRepository localRepository;\n\n    /**\n     * The artifact factory to use.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    private ArtifactFactory artifactFactory;\n\n    /**\n     * The artifact metadata source to use.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    private ArtifactMetadataSource artifactMetadataSource;\n\n    /**\n     * The artifact collector to use.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    private ArtifactCollector artifactCollector;\n\n    /**\n     * The dependency tree builder to use.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    private DependencyGraphBuilder dependencyTreeBuilder;\n\n    /**\n     * The toolchain manager to use.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    protected ToolchainManager toolchainManager;\n\n    /**\n     * List of artifacts to run plugin\n     * \n     * @parameter default-value=\"${plugin.artifacts}\"\n     */\n    private List<Artifact> pluginArtifacts;\n\n    private VersionNumber _scalaVersionN;\n\n    /**\n     * Constructs an {@link Artifact} for Scala Compiler.\n     *\n     * @param scalaVersion the version of the Scala Compiler/Library we are\n     *        using for this execution.\n     *\n     * @return a {@link Artifact} for the Scala Compiler.\n     */\n    protected final Artifact scalaCompilerArtifact(final String scalaVersion) {\n        return this.factory.createArtifact(this.getScalaOrganization(),\n                                           ScalaMojoSupport.SCALA_COMPILER_ARTIFACTID,\n                                           scalaVersion,\n                                           \"\",\n                                           ScalaMojoSupport.POM);\n    }\n\n    /**\n     * This method resolves all transitive dependencies of an artifact.\n     *\n     * @param artifact the {@link Artifact} used to retrieve dependencies.\n     *\n     * @return resolved {@link Set} of dependencies.\n     *\n     * @throws {@link Exception} when various artifact resolution mechanisms fail.\n     */\n    protected final Set<Artifact> resolveArtifactDependencies(final Artifact artifact) throws Exception {\n        final AndArtifactFilter filter = new AndArtifactFilter();\n        filter.add(new ScopeArtifactFilter(Artifact.SCOPE_TEST));\n        filter.add(new ArtifactFilter(){\n                public boolean include(Artifact artifact) {\n                    return !artifact.isOptional();\n                }\n            });\n\n        // Use the collection filter as the resolution filter.\n        return resolveDependencyArtifacts(artifact,\n                                          filter,\n                                          filter);\n    }\n\n    /**\n     * This method resolves all transitive dependencies of an artifact.\n     *\n     * @param artifact the {@link Artifact} used to retrieve dependencies.\n     * @param collectionFilter an {@link ArtifactFilter} used to determine which\n     *        members of the dependency graph should be included in resolution.\n     * @param collectionFilter an {@link ArtifactFilter} used to determine which\n     *        members dependency graph should be downloaded.\n     *\n     * @return resolved {@link Set} of dependencies.\n     *\n     * @throws {@link Exception} when various artifact resolution mechanisms fail.\n     */\n    protected final Set<Artifact> resolveDependencyArtifacts(final Artifact artifact,\n                                                             final ArtifactFilter collectionFilter,\n                                                             final ArtifactFilter resolutionFilter) throws Exception {\n        return this.resolveDependencyArtifacts(artifact,\n                                               collectionFilter,\n                                               resolutionFilter,\n                                               this.remoteRepos,\n                                               this.localRepo);\n    }\n\n    /**\n     * This method resolves all transitive dependencies of an artifact.\n     *\n     * @param artifact the {@link Artifact} used to retrieve dependencies.\n     * @param collectionFilter an {@link ArtifactFilter} used to determine which\n     *        members of the dependency graph should be included in resolution.\n     * @param collectionFilter an {@link ArtifactFilter} used to determine which\n     *        members dependency graph should be downloaded.\n     * @param remoteRepositories a {@link List} of remote {@link\n     *        ArtifactRespository} values to used for dependency resolution of\n     *        the provided {@link Artifact}.\n     * @param localRepository the local {@link ArtifactRepository} to use for\n     *        dependency resolution of the given {@link Artifact}.\n     *\n     * @return resolved {@link Set} of dependencies.\n     *\n     * @throws {@link Exception} when various artifact resolution mechanisms fail.\n     */\n    protected final Set<Artifact> resolveDependencyArtifacts(final Artifact artifact,\n                                                             final ArtifactFilter collectionFilter,\n                                                             final ArtifactFilter resolutionFilter,\n                                                             final List<ArtifactRepository> remoteRepositories,\n                                                             final ArtifactRepository localRepository) throws Exception {\n        final ArtifactResolutionRequest arr =\n            this.createArtifactResolutionRequest(artifact,\n                                                 collectionFilter,\n                                                 resolutionFilter,\n                                                 remoteRepositories,\n                                                 localRepository);\n\n        //TODO follow the dependenciesManagement and override rules\n        return this.resolver.resolve(arr).getArtifacts();\n    }\n\n    /**\n     * Create a {@link ArtifactResolutionRequest}.\n     *\n     * @param artifact the {@link Artifact} used to retrieve dependencies.\n     * @param collectionFilter an {@link ArtifactFilter} used to determine which\n     *        members of the dependency graph should be included in resolution.\n     * @param collectionFilter an {@link ArtifactFilter} used to determine which\n     *        members dependency graph should be downloaded.\n     * @param remoteRepositories a {@link List} of remote {@link\n     *        ArtifactRespository} values to used for dependency resolution of\n     *        the provided {@link Artifact}.\n     * @param localRepository the local {@link ArtifactRepository} to use for\n     *        dependency resolution of the given {@link Artifact}.\n     *\n     * @return an {@link ArtifactResolutionRequest}, typically used for\n     *         dependency resolution requests against an {@link\n     *         ArtifactResolver}.\n     */\n    private ArtifactResolutionRequest createArtifactResolutionRequest(final Artifact artifact,\n                                                                      final ArtifactFilter collectionFilter,\n                                                                      final ArtifactFilter resolutionFilter,\n                                                                      final List<ArtifactRepository> remoteRepositories,\n                                                                      final ArtifactRepository localRepository) {\n        final ArtifactResolutionRequest arr = new ArtifactResolutionRequest();\n\n        arr.setArtifact(artifact);\n        arr.setCollectionFilter(collectionFilter);\n        arr.setResolutionFilter(resolutionFilter);\n        arr.setResolveRoot(false);\n        arr.setResolveTransitively(true);\n        arr.setRemoteRepositories(remoteRepositories);\n        arr.setLocalRepository(localRepository);\n\n        return arr;\n    }\n\n    public void addToClasspath(String groupId, String artifactId, String version, Set<String> classpath) throws Exception {\n        addToClasspath(groupId, artifactId, version, classpath, true);\n    }\n\n\n    public void addToClasspath(String groupId, String artifactId, String version, Set<String> classpath, boolean addDependencies) throws Exception {\n        addToClasspath(factory.createArtifact(groupId, artifactId, version, Artifact.SCOPE_RUNTIME, ScalaMojoSupport.JAR), classpath, addDependencies);\n    }\n\n    /**\n     * added for classifier support.\n     * @author Christoph Radig\n     * @todo might want to merge with existing \"addToClasspath\" methods.\n     */\n    public void addToClasspath(String groupId, String artifactId, String version, String classifier, Set<String> classpath, boolean addDependencies) throws Exception {\n      Dependency d = new Dependency();\n      d.setGroupId(groupId);\n      d.setArtifactId(artifactId);\n      d.setVersion(version);\n      d.setType(ScalaMojoSupport.JAR);\n      d.setClassifier(classifier);\n      d.setScope(Artifact.SCOPE_RUNTIME);\n      addToClasspath(factory.createDependencyArtifact(d), classpath, addDependencies);\n    }\n\n    protected void addToClasspath(Artifact artifact, Set<String> classpath, boolean addDependencies) throws Exception {\n        resolver.resolve(artifact, remoteRepos, localRepo);\n        classpath.add(FileUtils.pathOf(artifact.getFile(), useCanonicalPath));\n        if (addDependencies) {\n            for (Artifact dep : resolveArtifactDependencies(artifact)) {\n                addToClasspath(dep, classpath, addDependencies);\n            }\n        }\n    }\n\n    protected void addCompilerToClasspath(Set<String> classpath) throws Exception {\n      classpath.add(FileUtils.pathOf(getCompilerJar(), useCanonicalPath));\n      for (File dep : getCompilerDependencies()) {\n        classpath.add(FileUtils.pathOf(dep, useCanonicalPath));\n      }\n    }\n\n    protected void addLibraryToClasspath(Set<String> classpath) throws Exception {\n      classpath.add(FileUtils.pathOf(getLibraryJar(), useCanonicalPath));\n    }\n\n    @Override\n    public void execute() throws MojoExecutionException, MojoFailureException {\n        try {\n            String oldWay = System.getProperty(\"maven.scala.version\");\n            if (oldWay != null) {\n                getLog().warn(\"using 'maven.scala.version' is deprecated, use 'scala.version' instead\");\n                if (scalaVersion != null) {\n                    scalaVersion = oldWay;\n                }\n            }\n\n            oldWay = System.getProperty(\"maven.scala.displayCmd\");\n            if (oldWay != null) {\n                getLog().warn(\"using 'maven.scala.displayCmd' is deprecated, use 'displayCmd' instead\");\n                displayCmd = displayCmd || Boolean.parseBoolean(oldWay);\n            }\n            checkScalaVersion();\n            doExecute();\n        } catch (MojoExecutionException exc) {\n            throw exc;\n        } catch (MojoFailureException exc) {\n            throw exc;\n        } catch (RuntimeException exc) {\n            throw exc;\n        } catch (Exception exc) {\n            throw new MojoExecutionException(\"wrap: \" + exc, exc);\n        }\n    }\n\n    protected List<Dependency> getDependencies() {\n        return project.getCompileDependencies();\n    }\n\n    protected VersionNumber findScalaVersion() throws Exception {\n        if (_scalaVersionN == null) {\n            String detectedScalaVersion = scalaVersion;\n            if (StringUtils.isEmpty(detectedScalaVersion)) {\n                detectedScalaVersion = findScalaVersionFromDependencies();\n            }\n            if (StringUtils.isEmpty(detectedScalaVersion)) {\n                if (!ScalaMojoSupport.POM.equals( project.getPackaging().toLowerCase() )) {\n                    getLog().warn(\"you don't define \"+ getScalaOrganization() + \":\" + SCALA_LIBRARY_ARTIFACTID + \" as a dependency of the project\");\n                }\n                detectedScalaVersion = \"0.0.0\";\n            } else {\n                // grappy hack to retrieve the SNAPSHOT version without timestamp,...\n                // because if version is -SNAPSHOT and artifact is deploy with uniqueValue then the version\n                // get from dependency is with the timestamp and a build number (the resolved version)\n                // but scala-compiler with the same version could have different resolved version (timestamp,...)\n                boolean isSnapshot = ArtifactUtils.isSnapshot(detectedScalaVersion);\n                if (isSnapshot && !detectedScalaVersion.endsWith(\"-SNAPSHOT\")) {\n                    detectedScalaVersion = detectedScalaVersion.substring(0, detectedScalaVersion.lastIndexOf('-', detectedScalaVersion.lastIndexOf('-')-1)) + \"-SNAPSHOT\";\n                }\n            }\n            if (StringUtils.isEmpty(detectedScalaVersion)) {\n                throw new MojoFailureException(\"no scalaVersion detected or set\");\n            }\n            if (StringUtils.isNotEmpty(scalaVersion)) {\n                if (!scalaVersion.equals(detectedScalaVersion)) {\n                    getLog().warn(\"scala library version define in dependencies doesn't match the scalaVersion of the plugin\");\n                }\n                //getLog().info(\"suggestion: remove the scalaVersion from pom.xml\"); //scalaVersion could be define in a parent pom where lib is not required\n            }\n            _scalaVersionN = new VersionNumber(detectedScalaVersion);\n        }\n        return _scalaVersionN;\n    }\n\n    private String findScalaVersionFromDependencies() throws Exception {\n        return findVersionFromDependencies(getScalaOrganization(), SCALA_LIBRARY_ARTIFACTID);\n    }\n\n    //TODO refactor to do only one scan of dependencies to find version\n    protected String findVersionFromDependencies(String groupId, String artifactId) throws Exception {\n        String version = null;\n        for (Dependency dep : getDependencies()) {\n            if (groupId.equals(dep.getGroupId()) && artifactId.equals(dep.getArtifactId())) {\n                version = dep.getVersion();\n            }\n        }\n        if (StringUtils.isEmpty(version)) {\n            List<Dependency> deps = new ArrayList<Dependency>();\n            deps.addAll(project.getModel().getDependencies());\n            if (project.getModel().getDependencyManagement() != null) {\n                deps.addAll(project.getModel().getDependencyManagement().getDependencies());\n            }\n            for (Dependency dep : deps) {\n                if (groupId.equals(dep.getGroupId()) && artifactId.equals(dep.getArtifactId())) {\n                    version = dep.getVersion();\n                }\n            }\n        }\n        return version;\n    }\n\n    protected void checkScalaVersion() throws Exception {\n        String sv = findScalaVersion().toString();\n        if (StringUtils.isNotEmpty(scalaHome)) {\n            getLog().warn(String.format(\"local scala-library.jar and scala-compiler.jar from scalaHome(%s) used instead of scala %s\", scalaHome, sv));\n        }\n        if (checkMultipleScalaVersions) {\n            checkCorrectVersionsOfScalaLibrary(sv);\n        }\n    }\n\n    /** this method checks to see if there are multiple versions of the scala library\n     * @throws Exception */\n    private void checkCorrectVersionsOfScalaLibrary(String scalaDefVersion) throws Exception {\n        getLog().debug(\"Checking for multiple versions of scala\");\n        //TODO - Make sure we handle bad artifacts....\n        // TODO: note that filter does not get applied due to MNG-3236\n        VersionNumber sv = new VersionNumber(scalaDefVersion);\n        VersionNumber requiredScalaVersion = StringUtils.isNotEmpty(scalaCompatVersion) ? new VersionNumberMask(scalaCompatVersion) : sv;\n        if (requiredScalaVersion.compareTo(sv) != 0) {\n          String msg = String.format(\"Scala library detected %s doesn't match scala.compat.version : %s\", sv, requiredScalaVersion);\n          if(failOnMultipleScalaVersions) {\n            getLog().error(msg);\n            throw new MojoFailureException(msg);\n          }\n          getLog().warn(msg);\n        }\n        ProjectBuildingRequest request = project.getProjectBuildingRequest();\n        request.setProject(project);\n        checkArtifactForScalaVersion(requiredScalaVersion, dependencyTreeBuilder.buildDependencyGraph(request, null));\n    }\n\n\n    /** Visits a node (and all dependencies) to see if it contains duplicate scala versions */\n    private void checkArtifactForScalaVersion(VersionNumber requiredScalaVersion, DependencyNode rootNode) throws Exception {\n        final CheckScalaVersionVisitor visitor = new CheckScalaVersionVisitor(requiredScalaVersion, getLog(), getScalaOrganization());\n\n        CollectingDependencyNodeVisitor collectingVisitor = new CollectingDependencyNodeVisitor();\n        DependencyNodeVisitor firstPassVisitor = new FilteringDependencyNodeVisitor( collectingVisitor, createScalaDistroDependencyFilter() );\n        rootNode.accept( firstPassVisitor );\n\n        DependencyNodeFilter secondPassFilter = new AncestorOrSelfDependencyNodeFilter( collectingVisitor.getNodes() );\n        DependencyNodeVisitor filteredVisitor = new FilteringDependencyNodeVisitor( visitor, secondPassFilter );\n\n        rootNode.accept( filteredVisitor );\n\n        if(visitor.isFailed()) {\n            visitor.logScalaDependents();\n            if(failOnMultipleScalaVersions) {\n                getLog().error(\"Multiple versions of scala libraries detected!\");\n                throw new MojoFailureException(\"Multiple versions of scala libraries detected!\");\n            }\n            getLog().warn(\"Multiple versions of scala libraries detected!\");\n        }\n    }\n\n    /**\n     * @return\n     *          A filter to only extract artifacts deployed from scala distributions\n     */\n    private DependencyNodeFilter createScalaDistroDependencyFilter() {\n        List<DependencyNodeFilter> filters = new ArrayList<DependencyNodeFilter>();\n        filters.add(new ScalaDistroArtifactFilter(getScalaOrganization()));\n        return new AndDependencyNodeFilter(filters);\n    }\n\n\n\n    protected abstract void doExecute() throws Exception;\n\n\n    protected JavaMainCaller getScalaCommand() throws Exception {\n        return this.getScalaCommand(this.fork,\n                                    this.scalaClassName);\n    }\n\n    /**\n     * Get a {@link JavaMainCaller} used invoke a Java process. Typically this\n     * will be one of the Scala utilities (Compiler, ScalaDoc, REPL, etc.).\n     * <p>\n     * This method does some setup on the {@link JavaMainCaller} which is not\n     * done by merely invoking {@code new} on one of the\n     * implementations. Specifically, it adds any Scala compiler plugin options,\n     * JVM options, and Scalac options defined on the plugin.\n     *\n     * @param forkOverride override the setting for {@link #fork}. Currently\n     *        this should only be set if you are invoking the REPL.\n     * @param mainClass the JVM main class to invoke.\n     *\n     * @return a {@link JavaMainCaller} to use to invoke the given command.\n     */\n    protected final JavaMainCaller getScalaCommand(final boolean forkOverride,\n                                                   final String mainClass) throws Exception {\n        JavaMainCaller cmd = getEmptyScalaCommand(mainClass, forkOverride);\n        cmd.addArgs(args);\n        if (StringUtils.isNotEmpty(addScalacArgs)) {\n          cmd.addArgs(StringUtils.split(addScalacArgs, \"|\"));\n        }\n        addCompilerPluginOptions(cmd);\n        cmd.addJvmArgs(jvmArgs);\n        return cmd;\n    }\n\n    /**\n     * Get a {@link JavaMainCaller} used invoke a Java process. Typically this\n     * will be one of the Scala utilities (Compiler, ScalaDoc, REPL, etc.).\n     *\n     * @param mainClass the JVM main class to invoke.\n     *\n     * @return a {@link JavaMainCaller} to use to invoke the given command.\n     */\n    protected final JavaMainCaller getEmptyScalaCommand(final String mainClass) throws Exception {\n        return this.getEmptyScalaCommand(mainClass, this.fork);\n    }\n\n    /**\n     * Get a {@link JavaMainCaller} used invoke a Java process. Typically this\n     * will be one of the Scala utilities (Compiler, ScalaDoc, REPL, etc.).\n     *\n     * @param mainClass the JVM main class to invoke.\n     * @param forkOverride override the setting for {@link #fork}. Currently\n     *        this should only be set if you are invoking the REPL.\n     *\n     * @return a {@link JavaMainCaller} to use to invoke the given command.\n     */\n    protected JavaMainCaller getEmptyScalaCommand(final String mainClass,\n                                                  final boolean forkOverride) throws Exception {\n\n        // If we are deviating from the plugin settings, let the user know\n        // what's going on.\n        if (forkOverride != this.fork) {\n            super.getLog().info(\"Fork behavior overridden\");\n            super.getLog().info(String.format(\"Fork for this execution is %s.\", String.valueOf(forkOverride)));\n        }\n\n        //TODO - Fork or not depending on configuration?\n        JavaMainCaller cmd;\n        String toolcp = getToolClasspath();\n        if(forkOverride) {\n            // HACK (better may need refactor)\n            boolean bootcp = true;\n            if (args != null) {\n                for(String arg : args) {\n                    bootcp = bootcp && !\"-nobootcp\".equals(arg);\n                }\n            }\n            String cp = bootcp ? \"\" : toolcp;\n            bootcp = bootcp && !(StringUtils.isNotEmpty(addScalacArgs) && addScalacArgs.contains(\"-nobootcp\"));\n            // scalac with args in files\n            // * works only since 2.8.0\n            // * is buggy (don't manage space in path on windows)\n            getLog().debug(\"use java command with args in file forced : \" + forceUseArgFile);\n            cmd = new JavaMainCallerByFork(this, mainClass, cp, null, null, forceUseArgFile, toolchainManager.getToolchainFromBuildContext(\"jdk\", session));\n            if (bootcp) {\n                cmd.addJvmArgs(\"-Xbootclasspath/a:\" + toolcp);\n            }\n        } else  {\n            cmd = new JavaMainCallerInProcess(this, mainClass, toolcp, null, null);\n        }\n        return cmd;\n    }\n\n    private String getToolClasspath() throws Exception {\n        Set<String> classpath = new LinkedHashSet<String>();\n        addLibraryToClasspath(classpath);\n        addCompilerToClasspath(classpath);\n//        addToClasspath(SCALA_GROUPID, \"scala-decoder\", scalaVersion, classpath);\n//        addToClasspath(SCALA_GROUPID, \"scala-dbc\", scalaVersion, classpath);\n        if (dependencies != null) {\n            for(BasicArtifact artifact: dependencies) {\n                addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, classpath);\n            }\n        }\n        return MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()]));\n    }\n\n    protected List<String> getScalaOptions() throws Exception {\n        List<String> options = new ArrayList<String>();\n        if (args != null) Collections.addAll(options, args);\n        if (StringUtils.isNotEmpty(addScalacArgs)) {\n            Collections.addAll(options, StringUtils.split(addScalacArgs, \"|\"));\n        }\n        options.addAll(getCompilerPluginOptions());\n        return options;\n    }\n\n    protected List<String> getJavacOptions() throws Exception {\n        List<String> options = new ArrayList<String>();\n        if (javacArgs != null) Collections.addAll(options, javacArgs);\n        if (StringUtils.isNotEmpty(addJavacArgs)) {\n            Collections.addAll(options, StringUtils.split(addJavacArgs, \"|\"));\n        }\n\n        // issue #116\n        if (javacGenerateDebugSymbols) {\n            options.add(\"-g\");\n        }\n        if (target != null) {\n            options.add(\"-target\");\n            options.add(target);\n        }\n        if (source != null) {\n          options.add(\"-source\");\n          options.add(source);\n        }\n        if (encoding != null) {\n          options.add(\"-encoding\");\n          options.add(encoding);\n        }\n        return options;\n    }\n\n    protected File getLibraryJar() throws Exception {\n      if (StringUtils.isNotEmpty(scalaHome)) {\n        File lib = new File(scalaHome, \"lib\");\n        return new File(lib, \"scala-library.jar\");\n      }\n      return getArtifactJar(getScalaOrganization(), SCALA_LIBRARY_ARTIFACTID, findScalaVersion().toString());\n    }\n\n    protected File getCompilerJar() throws Exception {\n      if(StringUtils.isNotEmpty(scalaHome)) {\n        File lib = new File(scalaHome, \"lib\");\n        return new File(lib, \"scala-compiler.jar\");\n      }\n      return getArtifactJar(getScalaOrganization(), SCALA_COMPILER_ARTIFACTID, findScalaVersion().toString());\n    }\n\n    protected List<File> getCompilerDependencies() throws Exception {\n      List<File> d = new ArrayList<File>();\n      if(StringUtils.isEmpty(scalaHome)) {\n        for (Artifact artifact : getAllDependencies(getScalaOrganization(), SCALA_COMPILER_ARTIFACTID, findScalaVersion().toString())) {\n          d.add(artifact.getFile());\n        }\n      } else {\n        for(File f : new File(scalaHome, \"lib\").listFiles()) {\n          String name = f.getName();\n          if (name.endsWith(\".jar\") && !name.contains(\"scala-library\") && !name.contains(\"scala-compiler\")) {\n            d.add(f);\n          }\n        }\n      }\n      return d;\n    }\n\n    protected File getArtifactJar(String groupId, String artifactId, String version) throws Exception {\n        Artifact artifact = factory.createArtifact(groupId, artifactId, version, Artifact.SCOPE_RUNTIME, ScalaMojoSupport.JAR);\n        resolver.resolve(artifact, remoteRepos, localRepo);\n        return artifact.getFile();\n    }\n\n    protected File getArtifactJar(String groupId, String artifactId, String version, String classifier) throws Exception {\n        Artifact artifact = factory.createArtifactWithClassifier(groupId, artifactId, version, ScalaMojoSupport.JAR, classifier);\n        resolver.resolve(artifact, remoteRepos, localRepo);\n        return artifact.getFile();\n    }\n\n    protected Set<Artifact> getAllDependencies(String groupId, String artifactId, String version) throws Exception {\n        Set<Artifact> result = new HashSet<Artifact>();\n        Artifact pom = factory.createArtifact(groupId, artifactId, version, \"\", ScalaMojoSupport.POM);\n        Set<Artifact> d = resolveArtifactDependencies(pom);\n        result.addAll(d);\n        for (Artifact dependency : d) {\n            Set<Artifact> transitive = getAllDependencies(dependency.getGroupId(), dependency.getArtifactId(), dependency.getVersion());\n            result.addAll(transitive);\n        }\n        return result;\n    }\n\n    /**\n     * @return\n     *           This returns whether or not the scala version can support having java sent into the compiler\n     */\n    protected boolean isJavaSupportedByCompiler() throws Exception {\n        return findScalaVersion().compareTo(new VersionNumber(\"2.7.2\")) >= 0;\n    }\n\n\n    /**\n     * Adds appropriate compiler plugins to the scalac command.\n     * @param scalac\n     * @throws Exception\n     */\n    protected void addCompilerPluginOptions(JavaMainCaller scalac) throws Exception {\n        for (String option : getCompilerPluginOptions()) {\n            scalac.addArgs(option);\n        }\n    }\n\n    protected List<String> getCompilerPluginOptions() throws Exception {\n        List<String> options = new ArrayList<String>();\n        for (String plugin : getCompilerPlugins()) {\n            options.add(\"-Xplugin:\" + plugin);\n        }\n        return options;\n    }\n\n    /**\n     * Retrieves a list of paths to scala compiler plugins.\n     *\n     * @return The list of plugins\n     * @throws Exception\n     */\n    private Set<String> getCompilerPlugins() throws Exception {\n        Set<String> plugins = new HashSet<String>();\n        if (compilerPlugins != null) {\n            Set<String> ignoreClasspath = new LinkedHashSet<String>();\n            addCompilerToClasspath(ignoreClasspath);\n            addLibraryToClasspath(ignoreClasspath);\n            for (BasicArtifact artifact : compilerPlugins) {\n                getLog().info(\"compiler plugin: \" + artifact.toString());\n                // TODO - Ensure proper scala version for plugins\n                Set<String> pluginClassPath = new HashSet<String>();\n                //TODO - Pull in transitive dependencies.\n                addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, artifact.classifier, pluginClassPath, false);\n                pluginClassPath.removeAll(ignoreClasspath);\n                plugins.addAll(pluginClassPath);\n            }\n        }\n        return plugins;\n    }\n\n    protected String findVersionFromPluginArtifacts(String groupId, String artifactId) throws Exception {\n        String version = null;\n        for (Artifact art : pluginArtifacts) {\n            if (groupId.equals(art.getGroupId()) && artifactId.equals(art.getArtifactId())) {\n                version = art.getVersion();\n            }\n        }\n        return version;\n    }\n\n    protected File getPluginArtifactJar(String groupId, String artifactId, String version) throws Exception {\n        return getPluginArtifactJar(groupId, artifactId, version, null);\n    }\n\n    protected File getPluginArtifactJar(String groupId, String artifactId, String version, String classifier) throws Exception {\n        Artifact artifact = null;\n        for (Artifact art : pluginArtifacts) {\n            if (groupId.equals(art.getGroupId()) && artifactId.equals(art.getArtifactId()) && version.equals(art.getVersion())){\n            \tif ((classifier == null && art.getClassifier() == null) || (classifier != null && classifier.equals(art.getClassifier()))) {\n            \t\tartifact = art;\n            \t}\n            }\n        }\n        if (artifact == null) {\n\t    \tString msg = String.format(\"can't find artifact %s::%s::%s-%s\", groupId, artifactId, version, classifier);\n\t    \tgetLog().error(msg);\n\t    \tthrow new Exception(msg);\n        }\n        return artifact.getFile();\n    }\n}\n","lineNo":692}
{"Smelly Sample":"package scala_maven;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Calendar;\nimport java.util.List;\nimport java.util.Locale;\n\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.reporting.MavenReport;\nimport org.apache.maven.reporting.MavenReportException;\nimport org.codehaus.doxia.sink.Sink;\nimport org.codehaus.plexus.util.StringUtils;\n\nimport scala_maven_executions.JavaMainCaller;\nimport scala_maven_executions.MainHelper;\n\n/**\n * Produces Scala API documentation.\n *\n * @goal doc\n * @requiresDependencyResolution compile\n * @execute phase=\"generate-sources\"\n */\npublic class ScalaDocMojo extends ScalaSourceMojoSupport implements MavenReport {\n\n    /**\n     * Specify window title of generated HTML documentation.\n     * [scaladoc, vscaladoc]\n     *\n     * @parameter expression=\"${windowtitle}\"\n     *            default-value=\"${project.name} ${project.version} API\"\n     */\n    protected String windowtitle;\n\n    /**\n     * Specifies the text to be placed at the bottom of each output file. If you\n     * want to use html you have to put it in a CDATA section, eg.\n     * &lt;![CDATA[Copyright 2005, &lt;a\n     * href=\"http://www.mycompany.com\">MyCompany, Inc.&lt;a>]]&gt;\n     * [scaladoc, vscaladoc]\n     *\n     * @parameter expression=\"${bottom}\"\n     *            default-value=\"Copyright (c) {inceptionYear}-{currentYear} {organizationName}. All Rights Reserved.\"\n     */\n    protected String bottom;\n\n    /**\n     * Charset for cross-platform viewing of generated documentation.\n     * [scaladoc, vscaladoc]\n     *\n     * @parameter expression=\"${charset}\" default-value=\"ISO-8859-1\"\n     */\n    protected String charset;\n\n    /**\n     * Include title for the overview page.\n     * [scaladoc, scaladoc2, vscaladoc]\n     *\n     * @parameter expression=\"${doctitle}\"\n     *            default-value=\"${project.name} ${project.version} API\"\n     */\n    protected String doctitle;\n\n    /**\n     * Include footer text for each page.\n     * [scaladoc, vscaladoc]\n     *\n     * @parameter expression=\"${footer}\"\n     */\n    protected String footer;\n\n    /**\n     * Include header text for each page\n     * [scaladoc, vscaladoc]\n     *\n     * @parameter expression=\"${header}\"\n     */\n    protected String header;\n\n    /**\n     * Generate source in HTML\n     * [scaladoc, vscaladoc]\n     *\n     * @parameter expression=\"${linksource}\" default-value=\"true\"\n     */\n    protected boolean linksource;\n\n    /**\n     * Suppress description and tags, generate only declarations\n     * [scaladoc, vscaladoc]\n     *\n     * @parameter expression=\"${nocomment}\" default-value=\"false\"\n     */\n    protected boolean nocomment;\n\n    /**\n     * File to change style of the generated documentation\n     * [scaladoc, vscaladoc]\n     *\n     * @parameter expression=\"${stylesheetfile}\"\n     */\n    protected File stylesheetfile;\n\n    /**\n     * Include top text for each page\n     * [scaladoc, vscaladoc]\n     *\n     * @parameter expression=\"${top}\"\n     */\n    protected String top;\n\n    /**\n     * Specifies the destination directory where scalaDoc saves the generated\n     * HTML files.\n     *\n     * @parameter expression=\"scaladocs\"\n     * @required\n     */\n    protected String outputDirectory;\n\n    /**\n     * Specifies the destination directory where javadoc saves the generated HTML files.\n     *\n     * @parameter expression=\"${project.reporting.outputDirectory}/scaladocs\"\n     * @required\n     */\n    protected File reportOutputDirectory;\n\n    /**\n     * The name of the Scaladoc report.\n     *\n     * @since 2.1\n     * @parameter expression=\"${name}\" default-value=\"ScalaDocs\"\n     */\n    private String name;\n\n    /**\n     * The description of the Scaladoc report.\n     *\n     * @since 2.1\n     * @parameter expression=\"${description}\" default-value=\"ScalaDoc API\n     *            documentation.\"\n     */\n    private String description;\n\n    /**\n     * className (FQN) of the main scaladoc to use, if not define, the the scalaClassName is used\n     *\n     * @parameter expression=\"${maven.scaladoc.className}\"\n     */\n    protected String scaladocClassName;\n\n    /**\n     * If you want to use vscaladoc to generate api instead of regular scaladoc, set the version of vscaladoc you want to use.\n     *\n     * @parameter expression=\"${maven.scaladoc.vscaladocVersion}\"\n     */\n    protected String vscaladocVersion;\n\n    /**\n     * To allow running aggregation only from command line use \"-DforceAggregate=true\" (avoid using in pom.xml).\n     * [scaladoc, vscaladoc]\n     *\n     * @parameter expression=\"${forceAggregate}\" default-value=\"false\"\n     */\n    protected boolean forceAggregate = false;\n\n    /**\n     * If you want to aggregate only direct sub modules.\n     *\n     * @parameter expression=\"${maven.scaladoc.aggregateDirectOnly}\" default-value=\"true\"\n     */\n    protected boolean aggregateDirectOnly = true;\n\n    /**\n     * The directory which contains scala/java source files\n     *\n     * @parameter expression=\"${project.build.sourceDirectory}/../scala\"\n     */\n    protected File sourceDir;\n\n    private List<File> _sourceFiles;\n\n    @Override\n    protected List<File> getSourceDirectories() throws Exception {\n        List<String> sources = project.getCompileSourceRoots();\n        //Quick fix in case the user has not added the \"add-source\" goal.\n        String scalaSourceDir = FileUtils.pathOf(sourceDir, useCanonicalPath);\n        if(!sources.contains(scalaSourceDir)) {\n            sources.add(scalaSourceDir);\n        }\n        return normalize(sources);\n    }\n\n    @Override\n    public boolean canGenerateReport() {\n        // there is modules to aggregate\n        boolean back = ((project.isExecutionRoot() || forceAggregate) && canAggregate() && project.getCollectedProjects().size() > 0);\n        back = back || (findSourceFiles().size() != 0);\n        return back;\n    }\n\n    /**\n     * @return\n     * @throws Exception\n     */\n    private List<File> findSourceFiles() {\n        if (_sourceFiles == null) {\n            try {\n                _sourceFiles = findSourceWithFilters();\n            } catch (Exception exc) {\n                throw new RuntimeException(\"can't define source to process\", exc);\n            }\n        }\n        return _sourceFiles;\n    }\n\n    private boolean canAggregate() {\n        return StringUtils.isNotEmpty(vscaladocVersion) && (new VersionNumber(vscaladocVersion).compareTo(new VersionNumber(\"1.1\")) >= 0);\n    }\n\n    @Override\n    public boolean isExternalReport() {\n        return true;\n    }\n\n    @Override\n    public String getCategoryName() {\n        return CATEGORY_PROJECT_REPORTS;\n    }\n\n    @Override\n    public String getDescription(Locale locale) {\n        if (StringUtils.isEmpty(description)) {\n            return \"ScalaDoc API documentation\";\n        }\n        return description;\n    }\n\n    @Override\n    public String getName(Locale locale) {\n        if (StringUtils.isEmpty(name)) {\n            return \"ScalaDocs\";\n        }\n        return name;\n    }\n\n    @Override\n    public String getOutputName() {\n        return outputDirectory + \"/index\";\n    }\n\n    @Override\n    public File getReportOutputDirectory() {\n        if (reportOutputDirectory == null) {\n            reportOutputDirectory = new File(project.getBasedir(), project.getReporting().getOutputDirectory() + \"/\" + outputDirectory).getAbsoluteFile();\n        }\n        return reportOutputDirectory;\n    }\n\n    @Override\n    public void setReportOutputDirectory(File v) {\n        if (v != null && outputDirectory != null && !v.getAbsolutePath().endsWith(outputDirectory)) {\n            this.reportOutputDirectory = new File(v, outputDirectory);\n        } else {\n            this.reportOutputDirectory = v;\n        }\n    }\n\n    @Override\n    public void doExecute() throws Exception {\n        // SiteRendererSink sink = siteRenderer.createSink(new\n        // File(project.getReporting().getOutputDirectory(), getOutputName() +\n        // \".html\");\n        generate(null, Locale.getDefault());\n    }\n\n\n    @Override\n    protected JavaMainCaller getScalaCommand() throws Exception {\n        //This ensures we have a valid scala version...\n        checkScalaVersion();\n        boolean isPreviousScala271 = (new VersionNumber(\"2.7.1\").compareTo(findScalaVersion()) > 0);\n        if (StringUtils.isEmpty(scaladocClassName)) {\n            if (!isPreviousScala271) {\n                scaladocClassName = \"scala.tools.nsc.ScalaDoc\";\n            } else {\n                scaladocClassName = scalaClassName;\n            }\n        }\n\n        JavaMainCaller jcmd = getEmptyScalaCommand(scaladocClassName);\n        jcmd.addArgs(args);\n        jcmd.addJvmArgs(jvmArgs);\n\n        if (isPreviousScala271){\n            jcmd.addArgs(\"-Ydoc\");\n        }\n        // copy the classpathElements to not modify the global project definition see https://github.com/davidB/maven-scala-plugin/issues/60\n        List<String> paths = new ArrayList<String>(project.getCompileClasspathElements());\n        paths.remove(project.getBuild().getOutputDirectory()); //remove output to avoid \"error for\" : error:  XXX is already defined as package XXX ... object XXX {\n        jcmd.addOption(\"-classpath\", MainHelper.toMultiPath(paths));\n        //jcmd.addOption(\"-sourcepath\", sourceDir.getAbsolutePath());\n\n        boolean isScaladoc2 = (new VersionNumber(\"2.8.0\").compareTo(findScalaVersion()) <= 0) && (\"scala.tools.nsc.ScalaDoc\".equals(scaladocClassName));\n        if (isScaladoc2) {\n            jcmd.addArgs(\"-doc-format:html\");\n            jcmd.addOption(\"-doc-title\", doctitle);\n        } else {\n            jcmd.addOption(\"-bottom\", getBottomText());\n            jcmd.addOption(\"-charset\", charset);\n            jcmd.addOption(\"-doctitle\", doctitle);\n            jcmd.addOption(\"-footer\", footer);\n            jcmd.addOption(\"-header\", header);\n            jcmd.addOption(\"-linksource\", linksource);\n            jcmd.addOption(\"-nocomment\", nocomment);\n            jcmd.addOption(\"-stylesheetfile\", stylesheetfile);\n            jcmd.addOption(\"-top\", top);\n            jcmd.addOption(\"-windowtitle\", windowtitle);\n        }\n        return jcmd;\n    }\n\n    @Override\n    public void generate(Sink sink, Locale locale) throws MavenReportException {\n        try {\n            if (!canGenerateReport()) {\n                getLog().warn(\"No source files found\");\n                return;\n            }\n\n            File reportOutputDir = getReportOutputDirectory();\n            if (!reportOutputDir.exists()) {\n                reportOutputDir.mkdirs();\n            }\n            if (StringUtils.isNotEmpty(vscaladocVersion)) {\n                scaladocClassName = \"org.scala_tools.vscaladoc.Main\";\n                BasicArtifact artifact = new BasicArtifact();\n                artifact.artifactId = \"vscaladoc\";\n                artifact.groupId = \"org.scala-tools\";\n                artifact.version = vscaladocVersion;\n                dependencies = new BasicArtifact[]{artifact};\n            }\n\n            List<File> sources = findSourceFiles();\n            if (sources.size() > 0) {\n                JavaMainCaller jcmd = getScalaCommand();\n                jcmd.addOption(\"-d\", reportOutputDir.getAbsolutePath());\n                for (File x : sources) {\n                    jcmd.addArgs(FileUtils.pathOf(x, useCanonicalPath));\n                }\n                jcmd.run(displayCmd);\n            }\n            if (forceAggregate) {\n                aggregate(project);\n            } else {\n                // Mojo could not be run from parent after all its children\n                // So the aggregation will be run after the last child\n                tryAggregateUpper(project);\n            }\n\n        } catch (MavenReportException exc) {\n            throw exc;\n        } catch (RuntimeException exc) {\n            throw exc;\n        } catch (Exception exc) {\n            throw new MavenReportException(\"wrap: \" + exc.getMessage(), exc);\n        }\n    }\n\n    protected void tryAggregateUpper(MavenProject prj) throws Exception {\n        if (prj != null && prj.hasParent() && canAggregate()) {\n            MavenProject parent = prj.getParent();\n            List<MavenProject> modules = parent.getCollectedProjects();\n            if ((modules.size() > 1) && prj.equals(modules.get(modules.size() - 1))) {\n                aggregate(parent);\n            }\n        }\n    }\n\n    protected void aggregate(MavenProject parent) throws Exception {\n        List<MavenProject> modules = parent.getCollectedProjects();\n        File dest = new File(parent.getReporting().getOutputDirectory() +\"/\" + outputDirectory);\n        getLog().info(\"start aggregation into \" + dest);\n        StringBuilder mpath = new StringBuilder();\n        for (MavenProject module : modules) {\n            if ( \"pom\".equals( module.getPackaging().toLowerCase() ) ) {\n                continue;\n            }\n            if (aggregateDirectOnly && module.getParent() != parent) {\n                continue;\n            }\n            File subScaladocPath = new File(module.getReporting().getOutputDirectory() +\"/\" + outputDirectory).getAbsoluteFile();\n            //System.out.println(\" -> \" + project.getModulePathAdjustment(module)  +\" // \" + subScaladocPath + \" // \" + module.getBasedir() );\n            if (subScaladocPath.exists()) {\n                mpath.append(subScaladocPath).append(File.pathSeparatorChar);\n            }\n        }\n        if (mpath.length() != 0) {\n            getLog().info(\"aggregate vscaladoc from : \" + mpath);\n            JavaMainCaller jcmd = getScalaCommand();\n            jcmd.addOption(\"-d\", dest.getAbsolutePath());\n            jcmd.addOption(\"-aggregate\", mpath.toString());\n            jcmd.run(displayCmd);\n        } else {\n            getLog().warn(\"no vscaladoc to aggregate\");\n        }\n        tryAggregateUpper(parent);\n    }\n\n    /**\n     * Method that sets the bottom text that will be displayed on the bottom of\n     * the javadocs.\n     *\n     * @param inceptionYear the year when the project was started\n     * @return a String that contains the text that will be displayed at the\n     *         bottom of the javadoc\n     */\n    private String getBottomText() {\n        String inceptionYear = project.getInceptionYear();\n        int actualYear = Calendar.getInstance().get(Calendar.YEAR);\n        String year = String.valueOf(actualYear);\n\n        String theBottom = StringUtils.replace(bottom, \"{currentYear}\", year);\n\n        if (inceptionYear != null) {\n            if (inceptionYear.equals(year)) {\n                theBottom = StringUtils.replace(theBottom, \"{inceptionYear}-\", \"\");\n            } else {\n                theBottom = StringUtils.replace(theBottom, \"{inceptionYear}\", inceptionYear);\n            }\n        } else {\n            theBottom = StringUtils.replace(theBottom, \"{inceptionYear}-\", \"\");\n        }\n\n        if (project.getOrganization() == null) {\n            theBottom = StringUtils.replace(theBottom, \" {organizationName}\", \"\");\n        } else {\n            if ((project.getOrganization() != null) && (StringUtils.isNotEmpty(project.getOrganization().getName()))) {\n                if (StringUtils.isNotEmpty(project.getOrganization().getUrl())) {\n                    theBottom = StringUtils.replace(theBottom, \"{organizationName}\", \"<a href=\\\"\" + project.getOrganization().getUrl() + \"\\\">\" + project.getOrganization().getName() + \"<\/a>\");\n                } else {\n                    theBottom = StringUtils.replace(theBottom, \"{organizationName}\", project.getOrganization().getName());\n                }\n            } else {\n                theBottom = StringUtils.replace(theBottom, \" {organizationName}\", \"\");\n            }\n        }\n\n        return theBottom;\n    }\n}\n","Method after Refactoring":"package scala_maven;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Calendar;\nimport java.util.List;\nimport java.util.Locale;\n\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.reporting.MavenReport;\nimport org.apache.maven.reporting.MavenReportException;\nimport org.codehaus.doxia.sink.Sink;\nimport org.codehaus.plexus.util.StringUtils;\n\nimport scala_maven_executions.JavaMainCaller;\nimport scala_maven_executions.MainHelper;\n\n/**\n * Produces Scala API documentation.\n *\n * @goal doc\n * @requiresDependencyResolution compile\n * @execute phase=\"generate-sources\"\n */\npublic class ScalaDocMojo extends ScalaSourceMojoSupport implements MavenReport {\n\n    /**\n     * Specify window title of generated HTML documentation.\n     * [scaladoc, vscaladoc]\n     *\n     * @parameter expression=\"${windowtitle}\"\n     *            default-value=\"${project.name} ${project.version} API\"\n     */\n    protected String windowtitle;\n\n    /**\n     * Specifies the text to be placed at the bottom of each output file. If you\n     * want to use html you have to put it in a CDATA section, eg.\n     * &lt;![CDATA[Copyright 2005, &lt;a\n     * href=\"http://www.mycompany.com\">MyCompany, Inc.&lt;a>]]&gt;\n     * [scaladoc, vscaladoc]\n     *\n     * @parameter expression=\"${bottom}\"\n     *            default-value=\"Copyright (c) {inceptionYear}-{currentYear} {organizationName}. All Rights Reserved.\"\n     */\n    protected String bottom;\n\n    /**\n     * Charset for cross-platform viewing of generated documentation.\n     * [scaladoc, vscaladoc]\n     *\n     * @parameter expression=\"${charset}\" default-value=\"ISO-8859-1\"\n     */\n    protected String charset;\n\n    /**\n     * Include title for the overview page.\n     * [scaladoc, scaladoc2, vscaladoc]\n     *\n     * @parameter expression=\"${doctitle}\"\n     *            default-value=\"${project.name} ${project.version} API\"\n     */\n    protected String doctitle;\n\n    /**\n     * Include footer text for each page.\n     * [scaladoc, vscaladoc]\n     *\n     * @parameter expression=\"${footer}\"\n     */\n    protected String footer;\n\n    /**\n     * Include header text for each page\n     * [scaladoc, vscaladoc]\n     *\n     * @parameter expression=\"${header}\"\n     */\n    protected String header;\n\n    /**\n     * Generate source in HTML\n     * [scaladoc, vscaladoc]\n     *\n     * @parameter expression=\"${linksource}\" default-value=\"true\"\n     */\n    protected boolean linksource;\n\n    /**\n     * Suppress description and tags, generate only declarations\n     * [scaladoc, vscaladoc]\n     *\n     * @parameter expression=\"${nocomment}\" default-value=\"false\"\n     */\n    protected boolean nocomment;\n\n    /**\n     * File to change style of the generated documentation\n     * [scaladoc, vscaladoc]\n     *\n     * @parameter expression=\"${stylesheetfile}\"\n     */\n    protected File stylesheetfile;\n\n    /**\n     * Include top text for each page\n     * [scaladoc, vscaladoc]\n     *\n     * @parameter expression=\"${top}\"\n     */\n    protected String top;\n\n    /**\n     * Specifies the destination directory where scalaDoc saves the generated\n     * HTML files.\n     *\n     * @parameter expression=\"scaladocs\"\n     * @required\n     */\n    protected String outputDirectory;\n\n    /**\n     * Specifies the destination directory where javadoc saves the generated HTML files.\n     *\n     * @parameter expression=\"${project.reporting.outputDirectory}/scaladocs\"\n     * @required\n     */\n    protected File reportOutputDirectory;\n\n    /**\n     * The name of the Scaladoc report.\n     *\n     * @since 2.1\n     * @parameter expression=\"${name}\" default-value=\"ScalaDocs\"\n     */\n    private String name;\n\n    /**\n     * The description of the Scaladoc report.\n     *\n     * @since 2.1\n     * @parameter expression=\"${description}\" default-value=\"ScalaDoc API\n     *            documentation.\"\n     */\n    private String description;\n\n    /**\n     * className (FQN) of the main scaladoc to use, if not define, the the scalaClassName is used\n     *\n     * @parameter expression=\"${maven.scaladoc.className}\"\n     */\n    protected String scaladocClassName;\n\n    /**\n     * If you want to use vscaladoc to generate api instead of regular scaladoc, set the version of vscaladoc you want to use.\n     *\n     * @parameter expression=\"${maven.scaladoc.vscaladocVersion}\"\n     */\n    protected String vscaladocVersion;\n\n    /**\n     * To allow running aggregation only from command line use \"-DforceAggregate=true\" (avoid using in pom.xml).\n     * [scaladoc, vscaladoc]\n     *\n     * @parameter expression=\"${forceAggregate}\" default-value=\"false\"\n     */\n    protected boolean forceAggregate = false;\n\n    /**\n     * If you want to aggregate only direct sub modules.\n     *\n     * @parameter expression=\"${maven.scaladoc.aggregateDirectOnly}\" default-value=\"true\"\n     */\n    protected boolean aggregateDirectOnly = true;\n\n    /**\n     * The directory which contains scala/java source files\n     *\n     * @parameter expression=\"${project.build.sourceDirectory}/../scala\"\n     */\n    protected File sourceDir;\n\n    private List<File> _sourceFiles;\n\n    @Override\n    protected List<File> getSourceDirectories() throws Exception {\n        List<String> sources = project.getCompileSourceRoots();\n        //Quick fix in case the user has not added the \"add-source\" goal.\n        String scalaSourceDir = FileUtils.pathOf(sourceDir, useCanonicalPath);\n        if(!sources.contains(scalaSourceDir)) {\n            sources.add(scalaSourceDir);\n        }\n        return normalize(sources);\n    }\n\n    @Override\n    public boolean canGenerateReport() {\n        // there is modules to aggregate\n        boolean back = ((project.isExecutionRoot() || forceAggregate) && canAggregate() && project.getCollectedProjects().size() > 0);\n        back = back || (findSourceFiles().size() != 0);\n        return back;\n    }\n\n    /**\n     * @return\n     * @throws Exception\n     */\n    private List<File> findSourceFiles() {\n        if (_sourceFiles == null) {\n            try {\n                _sourceFiles = findSourceWithFilters();\n            } catch (Exception exc) {\n                throw new RuntimeException(\"can't define source to process\", exc);\n            }\n        }\n        return _sourceFiles;\n    }\n\n    private boolean canAggregate() {\n        return StringUtils.isNotEmpty(vscaladocVersion) && (new VersionNumber(vscaladocVersion).compareTo(new VersionNumber(\"1.1\")) >= 0);\n    }\n\n    @Override\n    public boolean isExternalReport() {\n        return true;\n    }\n\n    @Override\n    public String getCategoryName() {\n        return CATEGORY_PROJECT_REPORTS;\n    }\n\n    @Override\n    public String getDescription(Locale locale) {\n        if (StringUtils.isEmpty(description)) {\n            return \"ScalaDoc API documentation\";\n        }\n        return description;\n    }\n\n    @Override\n    public String getName(Locale locale) {\n        if (StringUtils.isEmpty(name)) {\n            return \"ScalaDocs\";\n        }\n        return name;\n    }\n\n    @Override\n    public String getOutputName() {\n        return outputDirectory + \"/index\";\n    }\n\n    @Override\n    public File getReportOutputDirectory() {\n        if (reportOutputDirectory == null) {\n            reportOutputDirectory = new File(project.getBasedir(), project.getReporting().getOutputDirectory() + \"/\" + outputDirectory).getAbsoluteFile();\n        }\n        return reportOutputDirectory;\n    }\n\n    @Override\n    public void setReportOutputDirectory(File v) {\n        if (v != null && outputDirectory != null && !v.getAbsolutePath().endsWith(outputDirectory)) {\n            this.reportOutputDirectory = new File(v, outputDirectory);\n        } else {\n            this.reportOutputDirectory = v;\n        }\n    }\n\n    @Override\n    public void doExecute() throws Exception {\n        // SiteRendererSink sink = siteRenderer.createSink(new\n        // File(project.getReporting().getOutputDirectory(), getOutputName() +\n        // \".html\");\n        generate(null, Locale.getDefault());\n    }\n\n\n    @Override\n    protected JavaMainCaller getScalaCommand() throws Exception {\n        //This ensures we have a valid scala version...\n        checkScalaVersion();\n        VersionNumber sv = findScalaVersion();\n        boolean isPreviousScala271 = (new VersionNumber(\"2.7.1\").compareTo(sv) > 0 && !sv.isZero());\n        if (StringUtils.isEmpty(scaladocClassName)) {\n            if (!isPreviousScala271) {\n                scaladocClassName = \"scala.tools.nsc.ScalaDoc\";\n            } else {\n                scaladocClassName = scalaClassName;\n            }\n        }\n\n        JavaMainCaller jcmd = getEmptyScalaCommand(scaladocClassName);\n        jcmd.addArgs(args);\n        jcmd.addJvmArgs(jvmArgs);\n\n        if (isPreviousScala271){\n            jcmd.addArgs(\"-Ydoc\");\n        }\n        // copy the classpathElements to not modify the global project definition see https://github.com/davidB/maven-scala-plugin/issues/60\n        List<String> paths = new ArrayList<String>(project.getCompileClasspathElements());\n        paths.remove(project.getBuild().getOutputDirectory()); //remove output to avoid \"error for\" : error:  XXX is already defined as package XXX ... object XXX {\n        jcmd.addOption(\"-classpath\", MainHelper.toMultiPath(paths));\n        //jcmd.addOption(\"-sourcepath\", sourceDir.getAbsolutePath());\n\n        boolean isScaladoc2 = (new VersionNumber(\"2.8.0\").compareTo(sv) <= 0 || sv.isZero()) && (\"scala.tools.nsc.ScalaDoc\".equals(scaladocClassName));\n        if (isScaladoc2) {\n            jcmd.addArgs(\"-doc-format:html\");\n            jcmd.addOption(\"-doc-title\", doctitle);\n        } else {\n            jcmd.addOption(\"-bottom\", getBottomText());\n            jcmd.addOption(\"-charset\", charset);\n            jcmd.addOption(\"-doctitle\", doctitle);\n            jcmd.addOption(\"-footer\", footer);\n            jcmd.addOption(\"-header\", header);\n            jcmd.addOption(\"-linksource\", linksource);\n            jcmd.addOption(\"-nocomment\", nocomment);\n            jcmd.addOption(\"-stylesheetfile\", stylesheetfile);\n            jcmd.addOption(\"-top\", top);\n            jcmd.addOption(\"-windowtitle\", windowtitle);\n        }\n        return jcmd;\n    }\n\n    @Override\n    public void generate(Sink sink, Locale locale) throws MavenReportException {\n        try {\n            if (!canGenerateReport()) {\n                getLog().warn(\"No source files found\");\n                return;\n            }\n\n            File reportOutputDir = getReportOutputDirectory();\n            if (!reportOutputDir.exists()) {\n                reportOutputDir.mkdirs();\n            }\n            if (StringUtils.isNotEmpty(vscaladocVersion)) {\n                scaladocClassName = \"org.scala_tools.vscaladoc.Main\";\n                BasicArtifact artifact = new BasicArtifact();\n                artifact.artifactId = \"vscaladoc\";\n                artifact.groupId = \"org.scala-tools\";\n                artifact.version = vscaladocVersion;\n                dependencies = new BasicArtifact[]{artifact};\n            }\n\n            List<File> sources = findSourceFiles();\n            if (sources.size() > 0) {\n                JavaMainCaller jcmd = getScalaCommand();\n                jcmd.addOption(\"-d\", reportOutputDir.getAbsolutePath());\n                for (File x : sources) {\n                    jcmd.addArgs(FileUtils.pathOf(x, useCanonicalPath));\n                }\n                jcmd.run(displayCmd);\n            }\n            if (forceAggregate) {\n                aggregate(project);\n            } else {\n                // Mojo could not be run from parent after all its children\n                // So the aggregation will be run after the last child\n                tryAggregateUpper(project);\n            }\n\n        } catch (MavenReportException exc) {\n            throw exc;\n        } catch (RuntimeException exc) {\n            throw exc;\n        } catch (Exception exc) {\n            throw new MavenReportException(\"wrap: \" + exc.getMessage(), exc);\n        }\n    }\n\n    protected void tryAggregateUpper(MavenProject prj) throws Exception {\n        if (prj != null && prj.hasParent() && canAggregate()) {\n            MavenProject parent = prj.getParent();\n            List<MavenProject> modules = parent.getCollectedProjects();\n            if ((modules.size() > 1) && prj.equals(modules.get(modules.size() - 1))) {\n                aggregate(parent);\n            }\n        }\n    }\n\n    protected void aggregate(MavenProject parent) throws Exception {\n        List<MavenProject> modules = parent.getCollectedProjects();\n        File dest = new File(parent.getReporting().getOutputDirectory() +\"/\" + outputDirectory);\n        getLog().info(\"start aggregation into \" + dest);\n        StringBuilder mpath = new StringBuilder();\n        for (MavenProject module : modules) {\n            if ( \"pom\".equals( module.getPackaging().toLowerCase() ) ) {\n                continue;\n            }\n            if (aggregateDirectOnly && module.getParent() != parent) {\n                continue;\n            }\n            File subScaladocPath = new File(module.getReporting().getOutputDirectory() +\"/\" + outputDirectory).getAbsoluteFile();\n            //System.out.println(\" -> \" + project.getModulePathAdjustment(module)  +\" // \" + subScaladocPath + \" // \" + module.getBasedir() );\n            if (subScaladocPath.exists()) {\n                mpath.append(subScaladocPath).append(File.pathSeparatorChar);\n            }\n        }\n        if (mpath.length() != 0) {\n            getLog().info(\"aggregate vscaladoc from : \" + mpath);\n            JavaMainCaller jcmd = getScalaCommand();\n            jcmd.addOption(\"-d\", dest.getAbsolutePath());\n            jcmd.addOption(\"-aggregate\", mpath.toString());\n            jcmd.run(displayCmd);\n        } else {\n            getLog().warn(\"no vscaladoc to aggregate\");\n        }\n        tryAggregateUpper(parent);\n    }\n\n    /**\n     * Method that sets the bottom text that will be displayed on the bottom of\n     * the javadocs.\n     *\n     * @param inceptionYear the year when the project was started\n     * @return a String that contains the text that will be displayed at the\n     *         bottom of the javadoc\n     */\n    private String getBottomText() {\n        String inceptionYear = project.getInceptionYear();\n        int actualYear = Calendar.getInstance().get(Calendar.YEAR);\n        String year = String.valueOf(actualYear);\n\n        String theBottom = StringUtils.replace(bottom, \"{currentYear}\", year);\n\n        if (inceptionYear != null) {\n            if (inceptionYear.equals(year)) {\n                theBottom = StringUtils.replace(theBottom, \"{inceptionYear}-\", \"\");\n            } else {\n                theBottom = StringUtils.replace(theBottom, \"{inceptionYear}\", inceptionYear);\n            }\n        } else {\n            theBottom = StringUtils.replace(theBottom, \"{inceptionYear}-\", \"\");\n        }\n\n        if (project.getOrganization() == null) {\n            theBottom = StringUtils.replace(theBottom, \" {organizationName}\", \"\");\n        } else {\n            if ((project.getOrganization() != null) && (StringUtils.isNotEmpty(project.getOrganization().getName()))) {\n                if (StringUtils.isNotEmpty(project.getOrganization().getUrl())) {\n                    theBottom = StringUtils.replace(theBottom, \"{organizationName}\", \"<a href=\\\"\" + project.getOrganization().getUrl() + \"\\\">\" + project.getOrganization().getName() + \"<\/a>\");\n                } else {\n                    theBottom = StringUtils.replace(theBottom, \"{organizationName}\", project.getOrganization().getName());\n                }\n            } else {\n                theBottom = StringUtils.replace(theBottom, \" {organizationName}\", \"\");\n            }\n        }\n\n        return theBottom;\n    }\n}\n","lineNo":284}
{"Smelly Sample":"package scala_maven;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.ArtifactUtils;\nimport org.apache.maven.artifact.factory.ArtifactFactory;\nimport org.apache.maven.artifact.metadata.ArtifactMetadataSource;\nimport org.apache.maven.artifact.repository.ArtifactRepository;\nimport org.apache.maven.artifact.resolver.ArtifactCollector;\nimport org.apache.maven.artifact.resolver.ArtifactNotFoundException;\nimport org.apache.maven.artifact.resolver.ArtifactResolutionException;\nimport org.apache.maven.artifact.resolver.ArtifactResolver;\nimport org.apache.maven.artifact.resolver.filter.AndArtifactFilter;\nimport org.apache.maven.artifact.resolver.filter.ArtifactFilter;\nimport org.apache.maven.artifact.resolver.filter.ScopeArtifactFilter;\nimport org.apache.maven.artifact.versioning.VersionRange;\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.model.Dependency;\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugin.MojoFailureException;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.project.MavenProjectBuilder;\nimport org.apache.maven.project.ProjectBuildingException;\nimport org.apache.maven.project.artifact.InvalidDependencyVersionException;\nimport org.apache.maven.repository.RepositorySystem;\nimport org.apache.maven.shared.dependency.tree.DependencyNode;\nimport org.apache.maven.shared.dependency.tree.DependencyTreeBuilder;\nimport org.apache.maven.shared.dependency.tree.filter.AncestorOrSelfDependencyNodeFilter;\nimport org.apache.maven.shared.dependency.tree.filter.AndDependencyNodeFilter;\nimport org.apache.maven.shared.dependency.tree.filter.DependencyNodeFilter;\nimport org.apache.maven.shared.dependency.tree.traversal.CollectingDependencyNodeVisitor;\nimport org.apache.maven.shared.dependency.tree.traversal.DependencyNodeVisitor;\nimport org.apache.maven.shared.dependency.tree.traversal.FilteringDependencyNodeVisitor;\nimport org.apache.maven.toolchain.ToolchainManager;\nimport org.codehaus.plexus.util.StringUtils;\nimport scala_maven_dependency.CheckScalaVersionVisitor;\nimport scala_maven_dependency.ScalaDistroArtifactFilter;\nimport scala_maven_executions.JavaMainCaller;\nimport scala_maven_executions.JavaMainCallerByFork;\nimport scala_maven_executions.JavaMainCallerInProcess;\nimport scala_maven_executions.MainHelper;\n\npublic abstract class ScalaMojoSupport extends AbstractMojo {\n\n    public static final String SCALA_GROUPID= \"org.scala-lang\";\n    public static final String SCALA_LIBRARY_ARTIFACTID= \"scala-library\";\n    public static final String SCALA_COMPILER_ARTIFACTID= \"scala-compiler\";\n    \n    /**\n     * @parameter expression=\"${project}\"\n     * @required\n     * @readonly\n     */\n    protected MavenProject project;\n\n    /**\n     * The Maven Session Object\n     *\n     * @parameter expression=\"${session}\"\n     * @required\n     * @readonly\n     */\n    protected MavenSession session;\n\n    /**\n     * Contains the full list of projects in the reactor.\n     *\n     * @parameter default-value=\"${reactorProjects}\"\n     * @required\n     * @readonly\n     */\n    protected List<MavenProject> reactorProjects;\n\n    /**\n     * Used to look up Artifacts in the remote repository.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    protected RepositorySystem factory;\n\n    /**\n     * Used to look up Artifacts in the remote repository.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    protected ArtifactResolver resolver;\n    /**\n     * Location of the local repository.\n     *\n     * @parameter expression=\"${localRepository}\"\n     * @readonly\n     * @required\n     */\n    protected ArtifactRepository localRepo;\n\n    /**\n     * List of Remote Repositories used by the resolver\n     *\n     * @parameter expression=\"${project.remoteArtifactRepositories}\"\n     * @readonly\n     * @required\n     */\n    protected List<?> remoteRepos;\n\n    /**\n     * Additional dependencies/jar to add to classpath to run \"scalaClassName\" (scope and optional field not supported)\n     * ex :\n     * <pre>\n     *    &lt;dependencies>\n     *      &lt;dependency>\n     *        &lt;groupId>org.scala-tools&lt;/groupId>\n     *        &lt;artifactId>scala-compiler-addon&lt;/artifactId>\n     *        &lt;version>1.0-SNAPSHOT&lt;/version>\n     *      &lt;/dependency>\n     *    &lt;/dependencies>\n     * <\/pre>\n     * @parameter\n     */\n    protected BasicArtifact[] dependencies;\n\n    /**\n     * Compiler plugin dependencies to use when compiling.\n     * ex:\n     * @parameter\n     * <xmp>\n     * <compilerPlugins>\n     * <compilerPlugin>\n     * <groupId>my.scala.plugin<\/groupId>\n     * <artifactId>amazingPlugin<\/artifactId>\n     * <version>1.0-SNAPSHOT<\/version>\n     * <\/compilerPlugin>\n     * <\/compilerPlugins>\n     * <\/xmp>\n     */\n    protected BasicArtifact[] compilerPlugins;\n\n    /**\n     * Jvm Arguments.\n     *\n     * @parameter\n     */\n    protected String[] jvmArgs;\n\n    /**\n     * compiler additionnals arguments\n     *\n     * @parameter\n     */\n    protected String[] args;\n\n    /**\n     * Additional parameter to use to call the main class\n     * Using this parameter only from command line (\"-DaddScalacArgs=arg1|arg2|arg3|...\"), not from pom.xml.\n     * @parameter expression=\"${addScalacArgs}\"\n     */\n    protected String addScalacArgs;\n\n    /**\n     * className (FQN) of the scala tool to provide as\n     *\n     * @required\n     * @parameter expression=\"${maven.scala.className}\"\n     *            default-value=\"scala.tools.nsc.Main\"\n     */\n    protected String scalaClassName;\n\n    /**\n     * Scala 's version to use.\n     * (property 'maven.scala.version' replaced by 'scala.version')\n     *\n     * @parameter expression=\"${scala.version}\"\n     */\n    private String scalaVersion;\n\n    /**\n     * Path to Scala installation to use instead of the artifact (define as dependencies).\n     *\n     * @parameter expression=\"${scala.home}\"\n     */\n    private String scalaHome;\n\n    /**\n     * Arguments for javac (when using incremental compiler).\n     *\n     * @parameter expression=\"${javacArgs}\"\n     */\n    protected String[] javacArgs;@SuppressWarnings(\"unused\") \n\n    /**\n     * Whether to instruct javac to generate debug symbols (when using incremental compiler)\n     * @see {@link http://maven.apache.org/plugins/maven-compiler-plugin/compile-mojo.html#debug}\n     *\n     * @parameter expression=\"${javacGenerateDebugSymbols}\"\n     *            default-value=\"true\"\n     */\n    protected boolean javacGenerateDebugSymbols = true;\n\n    /**\n     * Alternative method for specifying javac arguments (when using incremental compiler).\n     * Can be used from command line with -DaddJavacArgs=arg1|arg2|arg3|... rather than in pom.xml.\n     *\n     * @parameter expression=\"${addJavacArgs}\"\n     */\n    protected String addJavacArgs;\n\n    \n    /**\n     * The -source argument for the Java compiler (when using incremental compiler).\n     *\n     * @parameter expression=\"${maven.compiler.source}\"\n     */\n    protected String source;\n    \n    /**\n     * The -target argument for the Java compiler (when using incremental compiler).\n     *\n     * @parameter expression=\"${maven.compiler.target}\"\n     */\n    protected String target;\n    \n    /**\n     * The -encoding argument for the Java compiler. (when using incremental compiler).\n     *\n     * @parameter expression=\"${project.build.sourceEncoding}\"\n     */\n    protected String encoding;\n    \n    /**\n     * Display the command line called ?\n     * (property 'maven.scala.displayCmd' replaced by 'displayCmd')\n     *\n     * @required\n     * @parameter expression=\"${displayCmd}\"\n     *            default-value=\"false\"\n     */\n    public boolean displayCmd;\n\n    /**\n     * Forks the execution of scalac into a separate process.\n     *\n     * @parameter default-value=\"true\"\n     */\n    protected boolean fork = true;\n\n    /**\n     * Force the use of an external ArgFile to run any forked process.\n     *\n     * @parameter default-value=\"false\"\n     */\n    protected boolean forceUseArgFile = false;\n\n    /**\n     * Check if every dependencies use the same version of scala-library.\n     *\n     * @parameter expression=\"${maven.scala.checkConsistency}\" default-value=\"true\"\n     */\n    protected boolean checkMultipleScalaVersions;\n\n    /**\n     * Determines if a detection of multiple scala versions in the dependencies will cause the build to fail.\n     *\n     * @parameter default-value=\"false\"\n     */\n    protected boolean failOnMultipleScalaVersions = false;\n\n    /**\n     * Should use CanonicalPath to normalize path (true => getCanonicalPath, false => getAbsolutePath)\n     * @see https://github.com/davidB/maven-scala-plugin/issues/50\n     * @parameter expression=\"${maven.scala.useCanonicalPath}\" default-value=\"true\"\n     */\n    protected boolean useCanonicalPath = true;\n\n    /**\n     * Artifact factory, needed to download source jars.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    protected MavenProjectBuilder mavenProjectBuilder;\n\n    /**\n     * The artifact repository to use.\n     *\n     * @parameter expression=\"${localRepository}\"\n     * @required\n     * @readonly\n     */\n    private ArtifactRepository localRepository;\n\n    /**\n     * The artifact factory to use.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    private ArtifactFactory artifactFactory;\n\n    /**\n     * The artifact metadata source to use.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    private ArtifactMetadataSource artifactMetadataSource;\n\n    /**\n     * The artifact collector to use.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    private ArtifactCollector artifactCollector;\n\n    /**\n     * The dependency tree builder to use.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    private DependencyTreeBuilder dependencyTreeBuilder;\n\n    /**\n     * The toolchain manager to use.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    protected ToolchainManager toolchainManager;\n\n    /** @parameter default-value=\"${plugin.artifacts}\" */\n    private List<Artifact> pluginArtifacts;\n\n    private VersionNumber _scalaVersionN;\n\n    /**\n     * This method resolves the dependency artifacts from the project.\n     *\n     * @param theProject The POM.\n     * @return resolved set of dependency artifacts.\n     *\n     * @throws ArtifactResolutionException\n     * @throws ArtifactNotFoundException\n     * @throws InvalidDependencyVersionException\n     */\n    protected Set<Artifact> resolveDependencyArtifacts(MavenProject theProject) throws Exception {\n        AndArtifactFilter filter = new AndArtifactFilter();\n        filter.add(new ScopeArtifactFilter(Artifact.SCOPE_TEST));\n        filter.add(new ArtifactFilter(){\n            public boolean include(Artifact artifact) {\n                return !artifact.isOptional();\n            }\n        });\n        //TODO follow the dependenciesManagement and override rules\n        Set<Artifact> artifacts = theProject.createArtifacts(artifactFactory, Artifact.SCOPE_RUNTIME, filter);\n        for (Artifact artifact : artifacts) {\n            resolver.resolve(artifact, remoteRepos, localRepo);\n        }\n        return artifacts;\n    }\n\n    /**\n     * This method resolves all transitive dependencies of an artifact.\n     *\n     * @param artifact the artifact used to retrieve dependencies\n     *\n     * @return resolved set of dependencies\n     *\n     * @throws ArtifactResolutionException\n     * @throws ArtifactNotFoundException\n     * @throws ProjectBuildingException\n     * @throws InvalidDependencyVersionException\n     */\n    protected Set<Artifact> resolveArtifactDependencies(Artifact artifact) throws Exception {\n        Artifact pomArtifact = factory.createArtifact(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), \"\", \"pom\");\n        MavenProject pomProject = mavenProjectBuilder.buildFromRepository(pomArtifact, remoteRepos, localRepo);\n        return resolveDependencyArtifacts(pomProject);\n    }\n\n    public void addToClasspath(String groupId, String artifactId, String version, Set<String> classpath) throws Exception {\n        addToClasspath(groupId, artifactId, version, classpath, true);\n    }\n\n\n    public void addToClasspath(String groupId, String artifactId, String version, Set<String> classpath, boolean addDependencies) throws Exception {\n        addToClasspath(factory.createArtifact(groupId, artifactId, version, Artifact.SCOPE_RUNTIME, \"jar\"), classpath, addDependencies);\n    }\n\n    /**\n     * added for classifier support.\n     * @author Christoph Radig\n     * @todo might want to merge with existing \"addToClasspath\" methods.\n     */\n    public void addToClasspath(String groupId, String artifactId, String version, String classifier, Set<String> classpath, boolean addDependencies) throws Exception {\n      Dependency d = new Dependency();\n      d.setGroupId(groupId);\n      d.setArtifactId(artifactId);\n      d.setVersion(version);\n      d.setType(\"jar\");\n      d.setClassifier(classifier);\n      d.setScope(Artifact.SCOPE_RUNTIME);\n      addToClasspath(factory.createDependencyArtifact(d), classpath, addDependencies);\n    }\n\n    protected void addToClasspath(Artifact artifact, Set<String> classpath, boolean addDependencies) throws Exception {\n        resolver.resolve(artifact, remoteRepos, localRepo);\n        classpath.add(FileUtils.pathOf(artifact.getFile(), useCanonicalPath));\n        if (addDependencies) {\n            for (Artifact dep : resolveArtifactDependencies(artifact)) {\n                addToClasspath(dep, classpath, addDependencies);\n            }\n        }\n    }\n\n    protected void addCompilerToClasspath(Set<String> classpath) throws Exception {\n      classpath.add(FileUtils.pathOf(getCompilerJar(), useCanonicalPath));\n      for (File dep : getCompilerDependencies()) {\n        classpath.add(FileUtils.pathOf(dep, useCanonicalPath));\n      }\n    }\n\n    protected void addLibraryToClasspath(Set<String> classpath) throws Exception {\n      classpath.add(FileUtils.pathOf(getLibraryJar(), useCanonicalPath));\n    }\n\n    @Override\n    public void execute() throws MojoExecutionException, MojoFailureException {\n        try {\n            String oldWay = System.getProperty(\"maven.scala.version\");\n            if (oldWay != null) {\n                getLog().warn(\"using 'maven.scala.version' is deprecated, use 'scala.version' instead\");\n                if (scalaVersion != null) {\n                    scalaVersion = oldWay;\n                }\n            }\n\n            oldWay = System.getProperty(\"maven.scala.displayCmd\");\n            if (oldWay != null) {\n                getLog().warn(\"using 'maven.scala.displayCmd' is deprecated, use 'displayCmd' instead\");\n                displayCmd = displayCmd || Boolean.parseBoolean(oldWay);\n            }\n            checkScalaVersion();\n            doExecute();\n        } catch (MojoExecutionException exc) {\n            throw exc;\n        } catch (MojoFailureException exc) {\n            throw exc;\n        } catch (RuntimeException exc) {\n            throw exc;\n        } catch (Exception exc) {\n            throw new MojoExecutionException(\"wrap: \" + exc, exc);\n        }\n    }\n\n    protected List<Dependency> getDependencies() {\n        return project.getCompileDependencies();\n    }\n\n    protected VersionNumber findScalaVersion() throws Exception {\n        if (_scalaVersionN == null) {\n            String detectedScalaVersion = scalaVersion;\n            if (StringUtils.isEmpty(detectedScalaVersion)) {\n                detectedScalaVersion = findScalaVersionFromDependencies();\n            }\n            if (StringUtils.isEmpty(detectedScalaVersion)) {\n                if (!\"pom\".equals( project.getPackaging().toLowerCase() )) {\n                    getLog().warn(\"you don't define \"+SCALA_GROUPID + \":\" + SCALA_LIBRARY_ARTIFACTID + \" as a dependency of the project\");\n                }\n                detectedScalaVersion = \"0.0.0\";\n            } else {\n                // grappy hack to retrieve the SNAPSHOT version without timestamp,...\n                // because if version is -SNAPSHOT and artifact is deploy with uniqueValue then the version\n                // get from dependency is with the timestamp and a build number (the resolved version)\n                // but scala-compiler with the same version could have different resolved version (timestamp,...)\n                boolean isSnapshot = ArtifactUtils.isSnapshot(detectedScalaVersion);\n                if (isSnapshot && !detectedScalaVersion.endsWith(\"-SNAPSHOT\")) {\n                    detectedScalaVersion = detectedScalaVersion.substring(0, detectedScalaVersion.lastIndexOf('-', detectedScalaVersion.lastIndexOf('-')-1)) + \"-SNAPSHOT\";\n                }\n            }\n            if (StringUtils.isEmpty(detectedScalaVersion)) {\n                throw new MojoFailureException(\"no scalaVersion detected or set\");\n            }\n            if (StringUtils.isNotEmpty(scalaVersion)) {\n                if (!scalaVersion.equals(detectedScalaVersion)) {\n                    getLog().warn(\"scala library version define in dependencies doesn't match the scalaVersion of the plugin\");\n                }\n                //getLog().info(\"suggestion: remove the scalaVersion from pom.xml\"); //scalaVersion could be define in a parent pom where lib is not required\n            }\n            _scalaVersionN = new VersionNumber(detectedScalaVersion);\n        }\n        return _scalaVersionN;\n    }\n\n    private String findScalaVersionFromDependencies() throws Exception {\n        return findVersionFromDependencies(SCALA_GROUPID, SCALA_LIBRARY_ARTIFACTID);\n    }\n\n    //TODO refactor to do only one scan of dependencies to find version\n    protected String findVersionFromDependencies(String groupId, String artifactId) throws Exception {\n        String version = null;\n        for (Dependency dep : getDependencies()) {\n            if (groupId.equals(dep.getGroupId()) && artifactId.equals(dep.getArtifactId())) {\n                version = dep.getVersion();\n            }\n        }\n        if (StringUtils.isEmpty(version)) {\n            List<Dependency> deps = new ArrayList<Dependency>();\n            deps.addAll(project.getModel().getDependencies());\n            if (project.getModel().getDependencyManagement() != null) {\n                deps.addAll(project.getModel().getDependencyManagement().getDependencies());\n            }\n            for (Dependency dep : deps) {\n                if (groupId.equals(dep.getGroupId()) && artifactId.equals(dep.getArtifactId())) {\n                    version = dep.getVersion();\n                }\n            }\n        }\n        return version;\n    }\n\n    protected void checkScalaVersion() throws Exception {\n        String sv = findScalaVersion().toString();\n        if (StringUtils.isNotEmpty(scalaHome)) {\n            getLog().warn(String.format(\"local scala-library.jar and scala-compiler.jar from scalaHome(%s) used instead of scala %s\", scalaHome, sv));\n        }\n        if (checkMultipleScalaVersions) {\n            checkCorrectVersionsOfScalaLibrary(sv);\n        }\n    }\n\n    /** this method checks to see if there are multiple versions of the scala library\n     * @throws Exception */\n    private void checkCorrectVersionsOfScalaLibrary(String requiredScalaVersion) throws Exception {\n        getLog().debug(\"Checking for multiple versions of scala\");\n        //TODO - Make sure we handle bad artifacts....\n        // TODO: note that filter does not get applied due to MNG-3236\n            checkArtifactForScalaVersion(requiredScalaVersion, dependencyTreeBuilder.buildDependencyTree( project, localRepository, artifactFactory,\n                    artifactMetadataSource, null, artifactCollector ));\n    }\n\n\n    /** Visits a node (and all dependencies) to see if it contains duplicate scala versions */\n    private void checkArtifactForScalaVersion(String requiredScalaVersion, DependencyNode rootNode) throws Exception {\n        final CheckScalaVersionVisitor visitor = new CheckScalaVersionVisitor(requiredScalaVersion, getLog());\n\n        CollectingDependencyNodeVisitor collectingVisitor = new CollectingDependencyNodeVisitor();\n        DependencyNodeVisitor firstPassVisitor = new FilteringDependencyNodeVisitor( collectingVisitor, createScalaDistroDependencyFilter() );\n        rootNode.accept( firstPassVisitor );\n\n        DependencyNodeFilter secondPassFilter = new AncestorOrSelfDependencyNodeFilter( collectingVisitor.getNodes() );\n        DependencyNodeVisitor filteredVisitor = new FilteringDependencyNodeVisitor( visitor, secondPassFilter );\n\n        rootNode.accept( filteredVisitor );\n\n        if(visitor.isFailed()) {\n            visitor.logScalaDependents();\n            if(failOnMultipleScalaVersions) {\n                getLog().error(\"Multiple versions of scala libraries detected!\");\n                throw new MojoFailureException(\"Multiple versions of scala libraries detected!\");\n            }\n            getLog().warn(\"Multiple versions of scala libraries detected!\");\n        }\n    }\n\n    /**\n     * @return\n     *          A filter to only extract artifacts deployed from scala distributions\n     */\n    private DependencyNodeFilter createScalaDistroDependencyFilter() {\n        List<ArtifactFilter> filters = new ArrayList<ArtifactFilter>();\n        filters.add(new ScalaDistroArtifactFilter());\n        return new AndDependencyNodeFilter(filters);\n    }\n\n\n\n    protected abstract void doExecute() throws Exception;\n\n\n    protected JavaMainCaller getScalaCommand() throws Exception {\n        JavaMainCaller cmd = getEmptyScalaCommand(scalaClassName);\n        cmd.addArgs(args);\n        if (StringUtils.isNotEmpty(addScalacArgs)) {\n          cmd.addArgs(StringUtils.split(addScalacArgs, \"|\"));\n        }\n        addCompilerPluginOptions(cmd);\n        cmd.addJvmArgs(jvmArgs);\n        return cmd;\n    }\n\n    protected JavaMainCaller getEmptyScalaCommand(String mainClass) throws Exception {\n        //TODO - Fork or not depending on configuration?\n        JavaMainCaller cmd;\n        if(fork) {\n           // scalac with args in files\n           // * works only since 2.8.0\n           // * is buggy (don't manage space in path on windows)\n            getLog().debug(\"use java command with args in file forced : \" + forceUseArgFile);\n\n            cmd = new JavaMainCallerByFork(this, mainClass, getToolClasspath(), null, null, forceUseArgFile, toolchainManager.getToolchainFromBuildContext(\"jdk\", session));\n        } else  {\n            cmd = new JavaMainCallerInProcess(this, mainClass, getToolClasspath(), null, null);\n        }\n        // HACK (better may need refactor)\n        boolean bootcp = true;\n        if (args != null) {\n          for(String arg : args) {\n            bootcp = bootcp && !\"-nobootcp\".equals(arg);\n          }\n        }\n        bootcp = bootcp && !(StringUtils.isNotEmpty(addScalacArgs) && addScalacArgs.contains(\"-nobootcp\"));\n        if (bootcp) {\n          cmd.addJvmArgs(\"-Xbootclasspath/a:\"+ getBootClasspath());\n        }\n        return cmd;\n    }\n\n    private String getToolClasspath() throws Exception {\n        Set<String> classpath = new LinkedHashSet<String>();\n        addCompilerToClasspath(classpath);\n//        addToClasspath(SCALA_GROUPID, \"scala-decoder\", scalaVersion, classpath);\n//        addToClasspath(SCALA_GROUPID, \"scala-dbc\", scalaVersion, classpath);\n        if (dependencies != null) {\n            for(BasicArtifact artifact: dependencies) {\n                addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, classpath);\n            }\n        }\n        return MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()]));\n    }\n\n    private String getBootClasspath() throws Exception {\n        Set<String> classpath = new LinkedHashSet<String>();\n        addLibraryToClasspath(classpath);\n        return MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()]));\n    }\n\n    protected List<String> getScalaOptions() throws Exception {\n        List<String> options = new ArrayList<String>();\n        if (args != null) Collections.addAll(options, args);\n        if (StringUtils.isNotEmpty(addScalacArgs)) {\n            Collections.addAll(options, StringUtils.split(addScalacArgs, \"|\"));\n        }\n        options.addAll(getCompilerPluginOptions());\n        return options;\n    }\n\n    protected List<String> getJavacOptions() throws Exception {\n        List<String> options = new ArrayList<String>();\n        if (javacArgs != null) Collections.addAll(options, javacArgs);\n        if (StringUtils.isNotEmpty(addJavacArgs)) {\n            Collections.addAll(options, StringUtils.split(addJavacArgs, \"|\"));\n        }\n\n        // issue #116\n        if (javacGenerateDebugSymbols) {\n            options.add(\"-g\");\n        }\n        if (target != null) {\n            options.add(\"-target\");\n            options.add(target);\n        }\n        if (source != null) {\n          options.add(\"-source\");\n          options.add(source);\n        }\n        if (encoding != null) {\n          options.add(\"-encoding\");\n          options.add(encoding);\n        }\n        return options;\n    }\n\n    protected File getLibraryJar() throws Exception {\n      if (!StringUtils.isEmpty(scalaHome)) {\n        File lib = new File(scalaHome, \"lib\");\n        return new File(lib, \"scala-library.jar\");\n      }\n      return getArtifactJar(SCALA_GROUPID, SCALA_LIBRARY_ARTIFACTID, findScalaVersion().toString());\n    }\n\n    protected File getCompilerJar() throws Exception {\n      if(!StringUtils.isEmpty(scalaHome)) {\n        File lib = new File(scalaHome, \"lib\");\n        return new File(lib, \"scala-compiler.jar\");\n      }\n      return getArtifactJar(SCALA_GROUPID, SCALA_COMPILER_ARTIFACTID, findScalaVersion().toString());\n    }\n\n    protected List<File> getCompilerDependencies() throws Exception {\n      List<File> d = new ArrayList<File>();\n      if(StringUtils.isEmpty(scalaHome)) {\n        for (Artifact artifact : getAllDependencies(SCALA_GROUPID, SCALA_COMPILER_ARTIFACTID, findScalaVersion().toString())) {\n          d.add(artifact.getFile());\n        }\n      }\n      return d;\n    }\n\n    protected File getArtifactJar(String groupId, String artifactId, String version) throws Exception {\n        Artifact artifact = factory.createArtifact(groupId, artifactId, version, Artifact.SCOPE_RUNTIME, \"jar\");\n        resolver.resolve(artifact, remoteRepos, localRepo);\n        return artifact.getFile();\n    }\n\n    protected File getArtifactJar(String groupId, String artifactId, String version, String classifier) throws Exception {\n        Artifact artifact = factory.createArtifactWithClassifier(groupId, artifactId, version, \"jar\", classifier);\n        resolver.resolve(artifact, remoteRepos, localRepo);\n        return artifact.getFile();\n    }\n\n    protected Set<Artifact> getAllDependencies(String groupId, String artifactId, String version) throws Exception {\n        Set<Artifact> result = new HashSet<Artifact>();\n        Artifact pom = factory.createArtifact(groupId, artifactId, version, \"\", \"pom\");\n        MavenProject p = mavenProjectBuilder.buildFromRepository(pom, remoteRepos, localRepo);\n        Set<Artifact> d = resolveDependencyArtifacts(p);\n        result.addAll(d);\n        for (Artifact dependency : d) {\n            Set<Artifact> transitive = getAllDependencies(dependency.getGroupId(), dependency.getArtifactId(), dependency.getVersion());\n            result.addAll(transitive);\n        }\n        return result;\n    }\n\n    /**\n     * @return\n     *           This returns whether or not the scala version can support having java sent into the compiler\n     */\n    protected boolean isJavaSupportedByCompiler() throws Exception {\n        return findScalaVersion().compareTo(new VersionNumber(\"2.7.2\")) >= 0;\n    }\n\n\n    /**\n     * Adds appropriate compiler plugins to the scalac command.\n     * @param scalac\n     * @throws Exception\n     */\n    protected void addCompilerPluginOptions(JavaMainCaller scalac) throws Exception {\n        for (String option : getCompilerPluginOptions()) {\n            scalac.addArgs(option);\n        }\n    }\n\n    protected List<String> getCompilerPluginOptions() throws Exception {\n        List<String> options = new ArrayList<String>();\n        for (String plugin : getCompilerPlugins()) {\n            options.add(\"-Xplugin:\" + plugin);\n        }\n        return options;\n    }\n\n    /**\n     * Retrieves a list of paths to scala compiler plugins.\n     *\n     * @return The list of plugins\n     * @throws Exception\n     */\n    private Set<String> getCompilerPlugins() throws Exception {\n        Set<String> plugins = new HashSet<String>();\n        if (compilerPlugins != null) {\n            Set<String> ignoreClasspath = new LinkedHashSet<String>();\n            addCompilerToClasspath(ignoreClasspath);\n            addLibraryToClasspath(ignoreClasspath);\n            for (BasicArtifact artifact : compilerPlugins) {\n                getLog().info(\"compiler plugin: \" + artifact.toString());\n                // TODO - Ensure proper scala version for plugins\n                Set<String> pluginClassPath = new HashSet<String>();\n                //TODO - Pull in transitive dependencies.\n                addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, artifact.classifier, pluginClassPath, false);\n                pluginClassPath.removeAll(ignoreClasspath);\n                plugins.addAll(pluginClassPath);\n            }\n        }\n        return plugins;\n    }\n\n    protected String findVersionFromPluginArtifacts(String groupId, String artifactId) throws Exception {\n        String version = null;\n        for (Artifact art : pluginArtifacts) {\n            if (groupId.equals(art.getGroupId()) && artifactId.equals(art.getArtifactId())) {\n                version = art.getVersion();\n            }\n        }\n        return version;\n    }\n\n    protected File getPluginArtifactJar(String groupId, String artifactId, String version) throws Exception {\n        return getPluginArtifactJar(groupId, artifactId, version, null);\n    }\n\n    protected File getPluginArtifactJar(String groupId, String artifactId, String version, String classifier) throws Exception {\n        Artifact artifact = null;\n        for (Artifact art : pluginArtifacts) {\n            if (groupId.equals(art.getGroupId()) && artifactId.equals(art.getArtifactId()) && version.equals(art.getVersion())){\n            \tif ((classifier == null && art.getClassifier() == null) || (classifier != null && classifier.equals(art.getClassifier()))) {\n            \t\tartifact = art;\n            \t}\n            }\n        }\n        if (artifact == null) {\n\t    \tString msg = String.format(\"can't find artifact %s::%s::%s-%s\", groupId, artifactId, version, classifier);\n\t    \tgetLog().error(msg);\n\t    \tthrow new Exception(msg);\n        }\n        return artifact.getFile();\n    }\n}\n","Method after Refactoring":"package scala_maven;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.ArtifactUtils;\nimport org.apache.maven.artifact.factory.ArtifactFactory;\nimport org.apache.maven.artifact.metadata.ArtifactMetadataSource;\nimport org.apache.maven.artifact.repository.ArtifactRepository;\nimport org.apache.maven.artifact.resolver.ArtifactCollector;\nimport org.apache.maven.artifact.resolver.ArtifactNotFoundException;\nimport org.apache.maven.artifact.resolver.ArtifactResolutionException;\nimport org.apache.maven.artifact.resolver.ArtifactResolver;\nimport org.apache.maven.artifact.resolver.filter.AndArtifactFilter;\nimport org.apache.maven.artifact.resolver.filter.ArtifactFilter;\nimport org.apache.maven.artifact.resolver.filter.ScopeArtifactFilter;\nimport org.apache.maven.artifact.versioning.VersionRange;\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.model.Dependency;\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugin.MojoFailureException;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.project.MavenProjectBuilder;\nimport org.apache.maven.project.ProjectBuildingException;\nimport org.apache.maven.project.artifact.InvalidDependencyVersionException;\nimport org.apache.maven.repository.RepositorySystem;\nimport org.apache.maven.shared.dependency.tree.DependencyNode;\nimport org.apache.maven.shared.dependency.tree.DependencyTreeBuilder;\nimport org.apache.maven.shared.dependency.tree.filter.AncestorOrSelfDependencyNodeFilter;\nimport org.apache.maven.shared.dependency.tree.filter.AndDependencyNodeFilter;\nimport org.apache.maven.shared.dependency.tree.filter.DependencyNodeFilter;\nimport org.apache.maven.shared.dependency.tree.traversal.CollectingDependencyNodeVisitor;\nimport org.apache.maven.shared.dependency.tree.traversal.DependencyNodeVisitor;\nimport org.apache.maven.shared.dependency.tree.traversal.FilteringDependencyNodeVisitor;\nimport org.apache.maven.toolchain.ToolchainManager;\nimport org.codehaus.plexus.util.StringUtils;\nimport scala_maven_dependency.CheckScalaVersionVisitor;\nimport scala_maven_dependency.ScalaDistroArtifactFilter;\nimport scala_maven_executions.JavaMainCaller;\nimport scala_maven_executions.JavaMainCallerByFork;\nimport scala_maven_executions.JavaMainCallerInProcess;\nimport scala_maven_executions.MainHelper;\n\npublic abstract class ScalaMojoSupport extends AbstractMojo {\n\n    public static final String SCALA_GROUPID= \"org.scala-lang\";\n    public static final String SCALA_LIBRARY_ARTIFACTID= \"scala-library\";\n    public static final String SCALA_COMPILER_ARTIFACTID= \"scala-compiler\";\n    \n    /**\n     * @parameter expression=\"${project}\"\n     * @required\n     * @readonly\n     */\n    protected MavenProject project;\n\n    /**\n     * The Maven Session Object\n     *\n     * @parameter expression=\"${session}\"\n     * @required\n     * @readonly\n     */\n    protected MavenSession session;\n\n    /**\n     * Contains the full list of projects in the reactor.\n     *\n     * @parameter default-value=\"${reactorProjects}\"\n     * @required\n     * @readonly\n     */\n    protected List<MavenProject> reactorProjects;\n\n    /**\n     * Used to look up Artifacts in the remote repository.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    protected RepositorySystem factory;\n\n    /**\n     * Used to look up Artifacts in the remote repository.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    protected ArtifactResolver resolver;\n    /**\n     * Location of the local repository.\n     *\n     * @parameter expression=\"${localRepository}\"\n     * @readonly\n     * @required\n     */\n    protected ArtifactRepository localRepo;\n\n    /**\n     * List of Remote Repositories used by the resolver\n     *\n     * @parameter expression=\"${project.remoteArtifactRepositories}\"\n     * @readonly\n     * @required\n     */\n    protected List<?> remoteRepos;\n\n    /**\n     * Additional dependencies/jar to add to classpath to run \"scalaClassName\" (scope and optional field not supported)\n     * ex :\n     * <pre>\n     *    &lt;dependencies>\n     *      &lt;dependency>\n     *        &lt;groupId>org.scala-tools&lt;/groupId>\n     *        &lt;artifactId>scala-compiler-addon&lt;/artifactId>\n     *        &lt;version>1.0-SNAPSHOT&lt;/version>\n     *      &lt;/dependency>\n     *    &lt;/dependencies>\n     * <\/pre>\n     * @parameter\n     */\n    protected BasicArtifact[] dependencies;\n\n    /**\n     * Compiler plugin dependencies to use when compiling.\n     * ex:\n     * @parameter\n     * <xmp>\n     * <compilerPlugins>\n     * <compilerPlugin>\n     * <groupId>my.scala.plugin<\/groupId>\n     * <artifactId>amazingPlugin<\/artifactId>\n     * <version>1.0-SNAPSHOT<\/version>\n     * <\/compilerPlugin>\n     * <\/compilerPlugins>\n     * <\/xmp>\n     */\n    protected BasicArtifact[] compilerPlugins;\n\n    /**\n     * Jvm Arguments.\n     *\n     * @parameter\n     */\n    protected String[] jvmArgs;\n\n    /**\n     * compiler additionnals arguments\n     *\n     * @parameter\n     */\n    protected String[] args;\n\n    /**\n     * Additional parameter to use to call the main class\n     * Using this parameter only from command line (\"-DaddScalacArgs=arg1|arg2|arg3|...\"), not from pom.xml.\n     * @parameter expression=\"${addScalacArgs}\"\n     */\n    protected String addScalacArgs;\n\n    /**\n     * className (FQN) of the scala tool to provide as\n     *\n     * @required\n     * @parameter expression=\"${maven.scala.className}\"\n     *            default-value=\"scala.tools.nsc.Main\"\n     */\n    protected String scalaClassName;\n\n    /**\n     * Scala 's version to use.\n     * (property 'maven.scala.version' replaced by 'scala.version')\n     *\n     * @parameter expression=\"${scala.version}\"\n     */\n    private String scalaVersion;\n\n    /**\n     * Path to Scala installation to use instead of the artifact (define as dependencies).\n     *\n     * @parameter expression=\"${scala.home}\"\n     */\n    private String scalaHome;\n\n    /**\n     * Arguments for javac (when using incremental compiler).\n     *\n     * @parameter expression=\"${javacArgs}\"\n     */\n    protected String[] javacArgs;@SuppressWarnings(\"unused\") \n\n    /**\n     * Whether to instruct javac to generate debug symbols (when using incremental compiler)\n     * @see {@link http://maven.apache.org/plugins/maven-compiler-plugin/compile-mojo.html#debug}\n     *\n     * @parameter expression=\"${javacGenerateDebugSymbols}\"\n     *            default-value=\"true\"\n     */\n    protected boolean javacGenerateDebugSymbols = true;\n\n    /**\n     * Alternative method for specifying javac arguments (when using incremental compiler).\n     * Can be used from command line with -DaddJavacArgs=arg1|arg2|arg3|... rather than in pom.xml.\n     *\n     * @parameter expression=\"${addJavacArgs}\"\n     */\n    protected String addJavacArgs;\n\n    \n    /**\n     * The -source argument for the Java compiler (when using incremental compiler).\n     *\n     * @parameter expression=\"${maven.compiler.source}\"\n     */\n    protected String source;\n    \n    /**\n     * The -target argument for the Java compiler (when using incremental compiler).\n     *\n     * @parameter expression=\"${maven.compiler.target}\"\n     */\n    protected String target;\n    \n    /**\n     * The -encoding argument for the Java compiler. (when using incremental compiler).\n     *\n     * @parameter expression=\"${project.build.sourceEncoding}\"\n     */\n    protected String encoding;\n    \n    /**\n     * Display the command line called ?\n     * (property 'maven.scala.displayCmd' replaced by 'displayCmd')\n     *\n     * @required\n     * @parameter expression=\"${displayCmd}\"\n     *            default-value=\"false\"\n     */\n    public boolean displayCmd;\n\n    /**\n     * Forks the execution of scalac into a separate process.\n     *\n     * @parameter default-value=\"true\"\n     */\n    protected boolean fork = true;\n\n    /**\n     * Force the use of an external ArgFile to run any forked process.\n     *\n     * @parameter default-value=\"false\"\n     */\n    protected boolean forceUseArgFile = false;\n\n    /**\n     * Check if every dependencies use the same version of scala-library.\n     *\n     * @parameter expression=\"${maven.scala.checkConsistency}\" default-value=\"true\"\n     */\n    protected boolean checkMultipleScalaVersions;\n\n    /**\n     * Determines if a detection of multiple scala versions in the dependencies will cause the build to fail.\n     *\n     * @parameter default-value=\"false\"\n     */\n    protected boolean failOnMultipleScalaVersions = false;\n\n    /**\n     * Should use CanonicalPath to normalize path (true => getCanonicalPath, false => getAbsolutePath)\n     * @see https://github.com/davidB/maven-scala-plugin/issues/50\n     * @parameter expression=\"${maven.scala.useCanonicalPath}\" default-value=\"true\"\n     */\n    protected boolean useCanonicalPath = true;\n\n    /**\n     * Artifact factory, needed to download source jars.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    protected MavenProjectBuilder mavenProjectBuilder;\n\n    /**\n     * The artifact repository to use.\n     *\n     * @parameter expression=\"${localRepository}\"\n     * @required\n     * @readonly\n     */\n    private ArtifactRepository localRepository;\n\n    /**\n     * The artifact factory to use.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    private ArtifactFactory artifactFactory;\n\n    /**\n     * The artifact metadata source to use.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    private ArtifactMetadataSource artifactMetadataSource;\n\n    /**\n     * The artifact collector to use.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    private ArtifactCollector artifactCollector;\n\n    /**\n     * The dependency tree builder to use.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    private DependencyTreeBuilder dependencyTreeBuilder;\n\n    /**\n     * The toolchain manager to use.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    protected ToolchainManager toolchainManager;\n\n    /** @parameter default-value=\"${plugin.artifacts}\" */\n    private List<Artifact> pluginArtifacts;\n\n    private VersionNumber _scalaVersionN;\n\n    /**\n     * This method resolves the dependency artifacts from the project.\n     *\n     * @param theProject The POM.\n     * @return resolved set of dependency artifacts.\n     *\n     * @throws ArtifactResolutionException\n     * @throws ArtifactNotFoundException\n     * @throws InvalidDependencyVersionException\n     */\n    protected Set<Artifact> resolveDependencyArtifacts(MavenProject theProject) throws Exception {\n        AndArtifactFilter filter = new AndArtifactFilter();\n        filter.add(new ScopeArtifactFilter(Artifact.SCOPE_TEST));\n        filter.add(new ArtifactFilter(){\n            public boolean include(Artifact artifact) {\n                return !artifact.isOptional();\n            }\n        });\n        //TODO follow the dependenciesManagement and override rules\n        Set<Artifact> artifacts = theProject.createArtifacts(artifactFactory, Artifact.SCOPE_RUNTIME, filter);\n        for (Artifact artifact : artifacts) {\n            resolver.resolve(artifact, remoteRepos, localRepo);\n        }\n        return artifacts;\n    }\n\n    /**\n     * This method resolves all transitive dependencies of an artifact.\n     *\n     * @param artifact the artifact used to retrieve dependencies\n     *\n     * @return resolved set of dependencies\n     *\n     * @throws ArtifactResolutionException\n     * @throws ArtifactNotFoundException\n     * @throws ProjectBuildingException\n     * @throws InvalidDependencyVersionException\n     */\n    protected Set<Artifact> resolveArtifactDependencies(Artifact artifact) throws Exception {\n        Artifact pomArtifact = factory.createArtifact(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), \"\", \"pom\");\n        MavenProject pomProject = mavenProjectBuilder.buildFromRepository(pomArtifact, remoteRepos, localRepo);\n        return resolveDependencyArtifacts(pomProject);\n    }\n\n    public void addToClasspath(String groupId, String artifactId, String version, Set<String> classpath) throws Exception {\n        addToClasspath(groupId, artifactId, version, classpath, true);\n    }\n\n\n    public void addToClasspath(String groupId, String artifactId, String version, Set<String> classpath, boolean addDependencies) throws Exception {\n        addToClasspath(factory.createArtifact(groupId, artifactId, version, Artifact.SCOPE_RUNTIME, \"jar\"), classpath, addDependencies);\n    }\n\n    /**\n     * added for classifier support.\n     * @author Christoph Radig\n     * @todo might want to merge with existing \"addToClasspath\" methods.\n     */\n    public void addToClasspath(String groupId, String artifactId, String version, String classifier, Set<String> classpath, boolean addDependencies) throws Exception {\n      Dependency d = new Dependency();\n      d.setGroupId(groupId);\n      d.setArtifactId(artifactId);\n      d.setVersion(version);\n      d.setType(\"jar\");\n      d.setClassifier(classifier);\n      d.setScope(Artifact.SCOPE_RUNTIME);\n      addToClasspath(factory.createDependencyArtifact(d), classpath, addDependencies);\n    }\n\n    protected void addToClasspath(Artifact artifact, Set<String> classpath, boolean addDependencies) throws Exception {\n        resolver.resolve(artifact, remoteRepos, localRepo);\n        classpath.add(FileUtils.pathOf(artifact.getFile(), useCanonicalPath));\n        if (addDependencies) {\n            for (Artifact dep : resolveArtifactDependencies(artifact)) {\n                addToClasspath(dep, classpath, addDependencies);\n            }\n        }\n    }\n\n    protected void addCompilerToClasspath(Set<String> classpath) throws Exception {\n      classpath.add(FileUtils.pathOf(getCompilerJar(), useCanonicalPath));\n      for (File dep : getCompilerDependencies()) {\n        classpath.add(FileUtils.pathOf(dep, useCanonicalPath));\n      }\n    }\n\n    protected void addLibraryToClasspath(Set<String> classpath) throws Exception {\n      classpath.add(FileUtils.pathOf(getLibraryJar(), useCanonicalPath));\n    }\n\n    @Override\n    public void execute() throws MojoExecutionException, MojoFailureException {\n        try {\n            String oldWay = System.getProperty(\"maven.scala.version\");\n            if (oldWay != null) {\n                getLog().warn(\"using 'maven.scala.version' is deprecated, use 'scala.version' instead\");\n                if (scalaVersion != null) {\n                    scalaVersion = oldWay;\n                }\n            }\n\n            oldWay = System.getProperty(\"maven.scala.displayCmd\");\n            if (oldWay != null) {\n                getLog().warn(\"using 'maven.scala.displayCmd' is deprecated, use 'displayCmd' instead\");\n                displayCmd = displayCmd || Boolean.parseBoolean(oldWay);\n            }\n            checkScalaVersion();\n            doExecute();\n        } catch (MojoExecutionException exc) {\n            throw exc;\n        } catch (MojoFailureException exc) {\n            throw exc;\n        } catch (RuntimeException exc) {\n            throw exc;\n        } catch (Exception exc) {\n            throw new MojoExecutionException(\"wrap: \" + exc, exc);\n        }\n    }\n\n    protected List<Dependency> getDependencies() {\n        return project.getCompileDependencies();\n    }\n\n    protected VersionNumber findScalaVersion() throws Exception {\n        if (_scalaVersionN == null) {\n            String detectedScalaVersion = scalaVersion;\n            if (StringUtils.isEmpty(detectedScalaVersion)) {\n                detectedScalaVersion = findScalaVersionFromDependencies();\n            }\n            if (StringUtils.isEmpty(detectedScalaVersion)) {\n                if (!\"pom\".equals( project.getPackaging().toLowerCase() )) {\n                    getLog().warn(\"you don't define \"+SCALA_GROUPID + \":\" + SCALA_LIBRARY_ARTIFACTID + \" as a dependency of the project\");\n                }\n                detectedScalaVersion = \"0.0.0\";\n            } else {\n                // grappy hack to retrieve the SNAPSHOT version without timestamp,...\n                // because if version is -SNAPSHOT and artifact is deploy with uniqueValue then the version\n                // get from dependency is with the timestamp and a build number (the resolved version)\n                // but scala-compiler with the same version could have different resolved version (timestamp,...)\n                boolean isSnapshot = ArtifactUtils.isSnapshot(detectedScalaVersion);\n                if (isSnapshot && !detectedScalaVersion.endsWith(\"-SNAPSHOT\")) {\n                    detectedScalaVersion = detectedScalaVersion.substring(0, detectedScalaVersion.lastIndexOf('-', detectedScalaVersion.lastIndexOf('-')-1)) + \"-SNAPSHOT\";\n                }\n            }\n            if (StringUtils.isEmpty(detectedScalaVersion)) {\n                throw new MojoFailureException(\"no scalaVersion detected or set\");\n            }\n            if (StringUtils.isNotEmpty(scalaVersion)) {\n                if (!scalaVersion.equals(detectedScalaVersion)) {\n                    getLog().warn(\"scala library version define in dependencies doesn't match the scalaVersion of the plugin\");\n                }\n                //getLog().info(\"suggestion: remove the scalaVersion from pom.xml\"); //scalaVersion could be define in a parent pom where lib is not required\n            }\n            _scalaVersionN = new VersionNumber(detectedScalaVersion);\n        }\n        return _scalaVersionN;\n    }\n\n    private String findScalaVersionFromDependencies() throws Exception {\n        return findVersionFromDependencies(SCALA_GROUPID, SCALA_LIBRARY_ARTIFACTID);\n    }\n\n    //TODO refactor to do only one scan of dependencies to find version\n    protected String findVersionFromDependencies(String groupId, String artifactId) throws Exception {\n        String version = null;\n        for (Dependency dep : getDependencies()) {\n            if (groupId.equals(dep.getGroupId()) && artifactId.equals(dep.getArtifactId())) {\n                version = dep.getVersion();\n            }\n        }\n        if (StringUtils.isEmpty(version)) {\n            List<Dependency> deps = new ArrayList<Dependency>();\n            deps.addAll(project.getModel().getDependencies());\n            if (project.getModel().getDependencyManagement() != null) {\n                deps.addAll(project.getModel().getDependencyManagement().getDependencies());\n            }\n            for (Dependency dep : deps) {\n                if (groupId.equals(dep.getGroupId()) && artifactId.equals(dep.getArtifactId())) {\n                    version = dep.getVersion();\n                }\n            }\n        }\n        return version;\n    }\n\n    protected void checkScalaVersion() throws Exception {\n        String sv = findScalaVersion().toString();\n        if (StringUtils.isNotEmpty(scalaHome)) {\n            getLog().warn(String.format(\"local scala-library.jar and scala-compiler.jar from scalaHome(%s) used instead of scala %s\", scalaHome, sv));\n        }\n        if (checkMultipleScalaVersions) {\n            checkCorrectVersionsOfScalaLibrary(sv);\n        }\n    }\n\n    /** this method checks to see if there are multiple versions of the scala library\n     * @throws Exception */\n    private void checkCorrectVersionsOfScalaLibrary(String requiredScalaVersion) throws Exception {\n        getLog().debug(\"Checking for multiple versions of scala\");\n        //TODO - Make sure we handle bad artifacts....\n        // TODO: note that filter does not get applied due to MNG-3236\n            checkArtifactForScalaVersion(requiredScalaVersion, dependencyTreeBuilder.buildDependencyTree( project, localRepository, artifactFactory,\n                    artifactMetadataSource, null, artifactCollector ));\n    }\n\n\n    /** Visits a node (and all dependencies) to see if it contains duplicate scala versions */\n    private void checkArtifactForScalaVersion(String requiredScalaVersion, DependencyNode rootNode) throws Exception {\n        final CheckScalaVersionVisitor visitor = new CheckScalaVersionVisitor(requiredScalaVersion, getLog());\n\n        CollectingDependencyNodeVisitor collectingVisitor = new CollectingDependencyNodeVisitor();\n        DependencyNodeVisitor firstPassVisitor = new FilteringDependencyNodeVisitor( collectingVisitor, createScalaDistroDependencyFilter() );\n        rootNode.accept( firstPassVisitor );\n\n        DependencyNodeFilter secondPassFilter = new AncestorOrSelfDependencyNodeFilter( collectingVisitor.getNodes() );\n        DependencyNodeVisitor filteredVisitor = new FilteringDependencyNodeVisitor( visitor, secondPassFilter );\n\n        rootNode.accept( filteredVisitor );\n\n        if(visitor.isFailed()) {\n            visitor.logScalaDependents();\n            if(failOnMultipleScalaVersions) {\n                getLog().error(\"Multiple versions of scala libraries detected!\");\n                throw new MojoFailureException(\"Multiple versions of scala libraries detected!\");\n            }\n            getLog().warn(\"Multiple versions of scala libraries detected!\");\n        }\n    }\n\n    /**\n     * @return\n     *          A filter to only extract artifacts deployed from scala distributions\n     */\n    private DependencyNodeFilter createScalaDistroDependencyFilter() {\n        List<ArtifactFilter> filters = new ArrayList<ArtifactFilter>();\n        filters.add(new ScalaDistroArtifactFilter());\n        return new AndDependencyNodeFilter(filters);\n    }\n\n\n\n    protected abstract void doExecute() throws Exception;\n\n\n    protected JavaMainCaller getScalaCommand() throws Exception {\n        JavaMainCaller cmd = getEmptyScalaCommand(scalaClassName);\n        cmd.addArgs(args);\n        if (StringUtils.isNotEmpty(addScalacArgs)) {\n          cmd.addArgs(StringUtils.split(addScalacArgs, \"|\"));\n        }\n        addCompilerPluginOptions(cmd);\n        cmd.addJvmArgs(jvmArgs);\n        return cmd;\n    }\n\n    protected JavaMainCaller getEmptyScalaCommand(String mainClass) throws Exception {\n      \n      //TODO - Fork or not depending on configuration?\n      JavaMainCaller cmd;\n      String toolcp = getToolClasspath();\n      if(fork) {\n        // HACK (better may need refactor)\n        boolean bootcp = true;\n        if (args != null) {\n          for(String arg : args) {\n            bootcp = bootcp && !\"-nobootcp\".equals(arg);\n          }\n        }\n        String cp = bootcp ? \"\" : toolcp;\n        bootcp = bootcp && !(StringUtils.isNotEmpty(addScalacArgs) && addScalacArgs.contains(\"-nobootcp\"));\n        // scalac with args in files\n        // * works only since 2.8.0\n        // * is buggy (don't manage space in path on windows)\n        getLog().debug(\"use java command with args in file forced : \" + forceUseArgFile);\n        cmd = new JavaMainCallerByFork(this, mainClass, cp, null, null, forceUseArgFile, toolchainManager.getToolchainFromBuildContext(\"jdk\", session));\n        if (bootcp) {\n          cmd.addJvmArgs(\"-Xbootclasspath/a:\" + toolcp);\n        }\n      } else  {\n        cmd = new JavaMainCallerInProcess(this, mainClass, toolcp, null, null);\n      }\n      return cmd;\n    }\n\n    private String getToolClasspath() throws Exception {\n        Set<String> classpath = new LinkedHashSet<String>();\n        addCompilerToClasspath(classpath);\n//        addToClasspath(SCALA_GROUPID, \"scala-decoder\", scalaVersion, classpath);\n//        addToClasspath(SCALA_GROUPID, \"scala-dbc\", scalaVersion, classpath);\n        if (dependencies != null) {\n            for(BasicArtifact artifact: dependencies) {\n                addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, classpath);\n            }\n        }\n        return MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()]));\n    }\n\n    protected List<String> getScalaOptions() throws Exception {\n        List<String> options = new ArrayList<String>();\n        if (args != null) Collections.addAll(options, args);\n        if (StringUtils.isNotEmpty(addScalacArgs)) {\n            Collections.addAll(options, StringUtils.split(addScalacArgs, \"|\"));\n        }\n        options.addAll(getCompilerPluginOptions());\n        return options;\n    }\n\n    protected List<String> getJavacOptions() throws Exception {\n        List<String> options = new ArrayList<String>();\n        if (javacArgs != null) Collections.addAll(options, javacArgs);\n        if (StringUtils.isNotEmpty(addJavacArgs)) {\n            Collections.addAll(options, StringUtils.split(addJavacArgs, \"|\"));\n        }\n\n        // issue #116\n        if (javacGenerateDebugSymbols) {\n            options.add(\"-g\");\n        }\n        if (target != null) {\n            options.add(\"-target\");\n            options.add(target);\n        }\n        if (source != null) {\n          options.add(\"-source\");\n          options.add(source);\n        }\n        if (encoding != null) {\n          options.add(\"-encoding\");\n          options.add(encoding);\n        }\n        return options;\n    }\n\n    protected File getLibraryJar() throws Exception {\n      if (!StringUtils.isEmpty(scalaHome)) {\n        File lib = new File(scalaHome, \"lib\");\n        return new File(lib, \"scala-library.jar\");\n      }\n      return getArtifactJar(SCALA_GROUPID, SCALA_LIBRARY_ARTIFACTID, findScalaVersion().toString());\n    }\n\n    protected File getCompilerJar() throws Exception {\n      if(!StringUtils.isEmpty(scalaHome)) {\n        File lib = new File(scalaHome, \"lib\");\n        return new File(lib, \"scala-compiler.jar\");\n      }\n      return getArtifactJar(SCALA_GROUPID, SCALA_COMPILER_ARTIFACTID, findScalaVersion().toString());\n    }\n\n    protected List<File> getCompilerDependencies() throws Exception {\n      List<File> d = new ArrayList<File>();\n      if(StringUtils.isEmpty(scalaHome)) {\n        for (Artifact artifact : getAllDependencies(SCALA_GROUPID, SCALA_COMPILER_ARTIFACTID, findScalaVersion().toString())) {\n          d.add(artifact.getFile());\n        }\n      } else {\n        for(File f : new File(scalaHome, \"lib\").listFiles()) {\n          String name = f.getName();\n          if (name.endsWith(\".jar\") && !name.contains(\"scala-library\") && !name.contains(\"scala-compiler\")) {\n            d.add(f);\n          }\n        }\n      }\n      return d;\n    }\n\n    protected File getArtifactJar(String groupId, String artifactId, String version) throws Exception {\n        Artifact artifact = factory.createArtifact(groupId, artifactId, version, Artifact.SCOPE_RUNTIME, \"jar\");\n        resolver.resolve(artifact, remoteRepos, localRepo);\n        return artifact.getFile();\n    }\n\n    protected File getArtifactJar(String groupId, String artifactId, String version, String classifier) throws Exception {\n        Artifact artifact = factory.createArtifactWithClassifier(groupId, artifactId, version, \"jar\", classifier);\n        resolver.resolve(artifact, remoteRepos, localRepo);\n        return artifact.getFile();\n    }\n\n    protected Set<Artifact> getAllDependencies(String groupId, String artifactId, String version) throws Exception {\n        Set<Artifact> result = new HashSet<Artifact>();\n        Artifact pom = factory.createArtifact(groupId, artifactId, version, \"\", \"pom\");\n        MavenProject p = mavenProjectBuilder.buildFromRepository(pom, remoteRepos, localRepo);\n        Set<Artifact> d = resolveDependencyArtifacts(p);\n        result.addAll(d);\n        for (Artifact dependency : d) {\n            Set<Artifact> transitive = getAllDependencies(dependency.getGroupId(), dependency.getArtifactId(), dependency.getVersion());\n            result.addAll(transitive);\n        }\n        return result;\n    }\n\n    /**\n     * @return\n     *           This returns whether or not the scala version can support having java sent into the compiler\n     */\n    protected boolean isJavaSupportedByCompiler() throws Exception {\n        return findScalaVersion().compareTo(new VersionNumber(\"2.7.2\")) >= 0;\n    }\n\n\n    /**\n     * Adds appropriate compiler plugins to the scalac command.\n     * @param scalac\n     * @throws Exception\n     */\n    protected void addCompilerPluginOptions(JavaMainCaller scalac) throws Exception {\n        for (String option : getCompilerPluginOptions()) {\n            scalac.addArgs(option);\n        }\n    }\n\n    protected List<String> getCompilerPluginOptions() throws Exception {\n        List<String> options = new ArrayList<String>();\n        for (String plugin : getCompilerPlugins()) {\n            options.add(\"-Xplugin:\" + plugin);\n        }\n        return options;\n    }\n\n    /**\n     * Retrieves a list of paths to scala compiler plugins.\n     *\n     * @return The list of plugins\n     * @throws Exception\n     */\n    private Set<String> getCompilerPlugins() throws Exception {\n        Set<String> plugins = new HashSet<String>();\n        if (compilerPlugins != null) {\n            Set<String> ignoreClasspath = new LinkedHashSet<String>();\n            addCompilerToClasspath(ignoreClasspath);\n            addLibraryToClasspath(ignoreClasspath);\n            for (BasicArtifact artifact : compilerPlugins) {\n                getLog().info(\"compiler plugin: \" + artifact.toString());\n                // TODO - Ensure proper scala version for plugins\n                Set<String> pluginClassPath = new HashSet<String>();\n                //TODO - Pull in transitive dependencies.\n                addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, artifact.classifier, pluginClassPath, false);\n                pluginClassPath.removeAll(ignoreClasspath);\n                plugins.addAll(pluginClassPath);\n            }\n        }\n        return plugins;\n    }\n\n    protected String findVersionFromPluginArtifacts(String groupId, String artifactId) throws Exception {\n        String version = null;\n        for (Artifact art : pluginArtifacts) {\n            if (groupId.equals(art.getGroupId()) && artifactId.equals(art.getArtifactId())) {\n                version = art.getVersion();\n            }\n        }\n        return version;\n    }\n\n    protected File getPluginArtifactJar(String groupId, String artifactId, String version) throws Exception {\n        return getPluginArtifactJar(groupId, artifactId, version, null);\n    }\n\n    protected File getPluginArtifactJar(String groupId, String artifactId, String version, String classifier) throws Exception {\n        Artifact artifact = null;\n        for (Artifact art : pluginArtifacts) {\n            if (groupId.equals(art.getGroupId()) && artifactId.equals(art.getArtifactId()) && version.equals(art.getVersion())){\n            \tif ((classifier == null && art.getClassifier() == null) || (classifier != null && classifier.equals(art.getClassifier()))) {\n            \t\tartifact = art;\n            \t}\n            }\n        }\n        if (artifact == null) {\n\t    \tString msg = String.format(\"can't find artifact %s::%s::%s-%s\", groupId, artifactId, version, classifier);\n\t    \tgetLog().error(msg);\n\t    \tthrow new Exception(msg);\n        }\n        return artifact.getFile();\n    }\n}\n","lineNo":613}
{"Smelly Sample":"package scala_maven;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.ArtifactUtils;\nimport org.apache.maven.artifact.factory.ArtifactFactory;\nimport org.apache.maven.artifact.metadata.ArtifactMetadataSource;\nimport org.apache.maven.artifact.repository.ArtifactRepository;\nimport org.apache.maven.artifact.resolver.ArtifactCollector;\nimport org.apache.maven.artifact.resolver.ArtifactNotFoundException;\nimport org.apache.maven.artifact.resolver.ArtifactResolutionException;\nimport org.apache.maven.artifact.resolver.ArtifactResolver;\nimport org.apache.maven.artifact.resolver.filter.AndArtifactFilter;\nimport org.apache.maven.artifact.resolver.filter.ArtifactFilter;\nimport org.apache.maven.artifact.resolver.filter.ScopeArtifactFilter;\nimport org.apache.maven.artifact.versioning.VersionRange;\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.model.Dependency;\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugin.MojoFailureException;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.project.MavenProjectBuilder;\nimport org.apache.maven.project.ProjectBuildingException;\nimport org.apache.maven.project.artifact.InvalidDependencyVersionException;\nimport org.apache.maven.repository.RepositorySystem;\nimport org.apache.maven.shared.dependency.tree.DependencyNode;\nimport org.apache.maven.shared.dependency.tree.DependencyTreeBuilder;\nimport org.apache.maven.shared.dependency.tree.filter.AncestorOrSelfDependencyNodeFilter;\nimport org.apache.maven.shared.dependency.tree.filter.AndDependencyNodeFilter;\nimport org.apache.maven.shared.dependency.tree.filter.DependencyNodeFilter;\nimport org.apache.maven.shared.dependency.tree.traversal.CollectingDependencyNodeVisitor;\nimport org.apache.maven.shared.dependency.tree.traversal.DependencyNodeVisitor;\nimport org.apache.maven.shared.dependency.tree.traversal.FilteringDependencyNodeVisitor;\nimport org.apache.maven.toolchain.ToolchainManager;\nimport org.codehaus.plexus.util.StringUtils;\nimport scala_maven_dependency.CheckScalaVersionVisitor;\nimport scala_maven_dependency.ScalaDistroArtifactFilter;\nimport scala_maven_executions.JavaMainCaller;\nimport scala_maven_executions.JavaMainCallerByFork;\nimport scala_maven_executions.JavaMainCallerInProcess;\nimport scala_maven_executions.MainHelper;\n\npublic abstract class ScalaMojoSupport extends AbstractMojo {\n\n    public static final String SCALA_GROUPID= \"org.scala-lang\";\n    public static final String SCALA_LIBRARY_ARTIFACTID= \"scala-library\";\n    public static final String SCALA_COMPILER_ARTIFACTID= \"scala-compiler\";\n    \n    /**\n     * @parameter expression=\"${project}\"\n     * @required\n     * @readonly\n     */\n    protected MavenProject project;\n\n    /**\n     * The Maven Session Object\n     *\n     * @parameter expression=\"${session}\"\n     * @required\n     * @readonly\n     */\n    protected MavenSession session;\n\n    /**\n     * Contains the full list of projects in the reactor.\n     *\n     * @parameter default-value=\"${reactorProjects}\"\n     * @required\n     * @readonly\n     */\n    protected List<MavenProject> reactorProjects;\n\n    /**\n     * Used to look up Artifacts in the remote repository.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    protected RepositorySystem factory;\n\n    /**\n     * Used to look up Artifacts in the remote repository.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    protected ArtifactResolver resolver;\n    /**\n     * Location of the local repository.\n     *\n     * @parameter expression=\"${localRepository}\"\n     * @readonly\n     * @required\n     */\n    protected ArtifactRepository localRepo;\n\n    /**\n     * List of Remote Repositories used by the resolver\n     *\n     * @parameter expression=\"${project.remoteArtifactRepositories}\"\n     * @readonly\n     * @required\n     */\n    protected List<?> remoteRepos;\n\n    /**\n     * Additional dependencies/jar to add to classpath to run \"scalaClassName\" (scope and optional field not supported)\n     * ex :\n     * <pre>\n     *    &lt;dependencies>\n     *      &lt;dependency>\n     *        &lt;groupId>org.scala-tools&lt;/groupId>\n     *        &lt;artifactId>scala-compiler-addon&lt;/artifactId>\n     *        &lt;version>1.0-SNAPSHOT&lt;/version>\n     *      &lt;/dependency>\n     *    &lt;/dependencies>\n     * <\/pre>\n     * @parameter\n     */\n    protected BasicArtifact[] dependencies;\n\n    /**\n     * Compiler plugin dependencies to use when compiling.\n     * ex:\n     * @parameter\n     * <xmp>\n     * <compilerPlugins>\n     * <compilerPlugin>\n     * <groupId>my.scala.plugin<\/groupId>\n     * <artifactId>amazingPlugin<\/artifactId>\n     * <version>1.0-SNAPSHOT<\/version>\n     * <\/compilerPlugin>\n     * <\/compilerPlugins>\n     * <\/xmp>\n     */\n    protected BasicArtifact[] compilerPlugins;\n\n    /**\n     * Jvm Arguments.\n     *\n     * @parameter\n     */\n    protected String[] jvmArgs;\n\n    /**\n     * compiler additionnals arguments\n     *\n     * @parameter\n     */\n    protected String[] args;\n\n    /**\n     * Additional parameter to use to call the main class\n     * Using this parameter only from command line (\"-DaddScalacArgs=arg1|arg2|arg3|...\"), not from pom.xml.\n     * @parameter expression=\"${addScalacArgs}\"\n     */\n    protected String addScalacArgs;\n\n    /**\n     * className (FQN) of the scala tool to provide as\n     *\n     * @required\n     * @parameter expression=\"${maven.scala.className}\"\n     *            default-value=\"scala.tools.nsc.Main\"\n     */\n    protected String scalaClassName;\n\n    /**\n     * Scala 's version to use.\n     * (property 'maven.scala.version' replaced by 'scala.version')\n     *\n     * @parameter expression=\"${scala.version}\"\n     */\n    private String scalaVersion;\n\n    /**\n     * Path to Scala installation to use instead of the artifact (define as dependencies).\n     *\n     * @parameter expression=\"${scala.home}\"\n     */\n    private String scalaHome;\n\n    /**\n     * Arguments for javac (when using incremental compiler).\n     *\n     * @parameter expression=\"${javacArgs}\"\n     */\n    protected String[] javacArgs;@SuppressWarnings(\"unused\") \n\n    /**\n     * Whether to instruct javac to generate debug symbols (when using incremental compiler)\n     * @see {@link http://maven.apache.org/plugins/maven-compiler-plugin/compile-mojo.html#debug}\n     *\n     * @parameter expression=\"${javacGenerateDebugSymbols}\"\n     *            default-value=\"true\"\n     */\n    protected boolean javacGenerateDebugSymbols = true;\n\n    /**\n     * Alternative method for specifying javac arguments (when using incremental compiler).\n     * Can be used from command line with -DaddJavacArgs=arg1|arg2|arg3|... rather than in pom.xml.\n     *\n     * @parameter expression=\"${addJavacArgs}\"\n     */\n    protected String addJavacArgs;\n\n    \n    /**\n     * The -source argument for the Java compiler (when using incremental compiler).\n     *\n     * @parameter expression=\"${maven.compiler.source}\"\n     */\n    protected String source;\n    \n    /**\n     * The -target argument for the Java compiler (when using incremental compiler).\n     *\n     * @parameter expression=\"${maven.compiler.target}\"\n     */\n    protected String target;\n    \n    /**\n     * The -encoding argument for the Java compiler. (when using incremental compiler).\n     *\n     * @parameter expression=\"${project.build.sourceEncoding}\"\n     */\n    protected String encoding;\n    \n    /**\n     * Display the command line called ?\n     * (property 'maven.scala.displayCmd' replaced by 'displayCmd')\n     *\n     * @required\n     * @parameter expression=\"${displayCmd}\"\n     *            default-value=\"false\"\n     */\n    public boolean displayCmd;\n\n    /**\n     * Forks the execution of scalac into a separate process.\n     *\n     * @parameter default-value=\"true\"\n     */\n    protected boolean fork = true;\n\n    /**\n     * Force the use of an external ArgFile to run any forked process.\n     *\n     * @parameter default-value=\"false\"\n     */\n    protected boolean forceUseArgFile = false;\n\n    /**\n     * Check if every dependencies use the same version of scala-library.\n     *\n     * @parameter expression=\"${maven.scala.checkConsistency}\" default-value=\"true\"\n     */\n    protected boolean checkMultipleScalaVersions;\n\n    /**\n     * Determines if a detection of multiple scala versions in the dependencies will cause the build to fail.\n     *\n     * @parameter default-value=\"false\"\n     */\n    protected boolean failOnMultipleScalaVersions = false;\n\n    /**\n     * Should use CanonicalPath to normalize path (true => getCanonicalPath, false => getAbsolutePath)\n     * @see https://github.com/davidB/maven-scala-plugin/issues/50\n     * @parameter expression=\"${maven.scala.useCanonicalPath}\" default-value=\"true\"\n     */\n    protected boolean useCanonicalPath = true;\n\n    /**\n     * Artifact factory, needed to download source jars.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    protected MavenProjectBuilder mavenProjectBuilder;\n\n    /**\n     * The artifact repository to use.\n     *\n     * @parameter expression=\"${localRepository}\"\n     * @required\n     * @readonly\n     */\n    private ArtifactRepository localRepository;\n\n    /**\n     * The artifact factory to use.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    private ArtifactFactory artifactFactory;\n\n    /**\n     * The artifact metadata source to use.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    private ArtifactMetadataSource artifactMetadataSource;\n\n    /**\n     * The artifact collector to use.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    private ArtifactCollector artifactCollector;\n\n    /**\n     * The dependency tree builder to use.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    private DependencyTreeBuilder dependencyTreeBuilder;\n\n    /**\n     * The toolchain manager to use.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    protected ToolchainManager toolchainManager;\n\n    /** @parameter default-value=\"${plugin.artifacts}\" */\n    private List<Artifact> pluginArtifacts;\n\n    private VersionNumber _scalaVersionN;\n\n    /**\n     * This method resolves the dependency artifacts from the project.\n     *\n     * @param theProject The POM.\n     * @return resolved set of dependency artifacts.\n     *\n     * @throws ArtifactResolutionException\n     * @throws ArtifactNotFoundException\n     * @throws InvalidDependencyVersionException\n     */\n    protected Set<Artifact> resolveDependencyArtifacts(MavenProject theProject) throws Exception {\n        AndArtifactFilter filter = new AndArtifactFilter();\n        filter.add(new ScopeArtifactFilter(Artifact.SCOPE_TEST));\n        filter.add(new ArtifactFilter(){\n            public boolean include(Artifact artifact) {\n                return !artifact.isOptional();\n            }\n        });\n        //TODO follow the dependenciesManagement and override rules\n        Set<Artifact> artifacts = theProject.createArtifacts(artifactFactory, Artifact.SCOPE_RUNTIME, filter);\n        for (Artifact artifact : artifacts) {\n            resolver.resolve(artifact, remoteRepos, localRepo);\n        }\n        return artifacts;\n    }\n\n    /**\n     * This method resolves all transitive dependencies of an artifact.\n     *\n     * @param artifact the artifact used to retrieve dependencies\n     *\n     * @return resolved set of dependencies\n     *\n     * @throws ArtifactResolutionException\n     * @throws ArtifactNotFoundException\n     * @throws ProjectBuildingException\n     * @throws InvalidDependencyVersionException\n     */\n    protected Set<Artifact> resolveArtifactDependencies(Artifact artifact) throws Exception {\n        Artifact pomArtifact = factory.createArtifact(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), \"\", \"pom\");\n        MavenProject pomProject = mavenProjectBuilder.buildFromRepository(pomArtifact, remoteRepos, localRepo);\n        return resolveDependencyArtifacts(pomProject);\n    }\n\n    public void addToClasspath(String groupId, String artifactId, String version, Set<String> classpath) throws Exception {\n        addToClasspath(groupId, artifactId, version, classpath, true);\n    }\n\n\n    public void addToClasspath(String groupId, String artifactId, String version, Set<String> classpath, boolean addDependencies) throws Exception {\n        addToClasspath(factory.createArtifact(groupId, artifactId, version, Artifact.SCOPE_RUNTIME, \"jar\"), classpath, addDependencies);\n    }\n\n    /**\n     * added for classifier support.\n     * @author Christoph Radig\n     * @todo might want to merge with existing \"addToClasspath\" methods.\n     */\n    public void addToClasspath(String groupId, String artifactId, String version, String classifier, Set<String> classpath, boolean addDependencies) throws Exception {\n      Dependency d = new Dependency();\n      d.setGroupId(groupId);\n      d.setArtifactId(artifactId);\n      d.setVersion(version);\n      d.setType(\"jar\");\n      d.setClassifier(classifier);\n      d.setScope(Artifact.SCOPE_RUNTIME);\n      addToClasspath(factory.createDependencyArtifact(d), classpath, addDependencies);\n    }\n\n    protected void addToClasspath(Artifact artifact, Set<String> classpath, boolean addDependencies) throws Exception {\n        resolver.resolve(artifact, remoteRepos, localRepo);\n        classpath.add(FileUtils.pathOf(artifact.getFile(), useCanonicalPath));\n        if (addDependencies) {\n            for (Artifact dep : resolveArtifactDependencies(artifact)) {\n                addToClasspath(dep, classpath, addDependencies);\n            }\n        }\n    }\n\n    protected void addCompilerToClasspath(Set<String> classpath) throws Exception {\n      classpath.add(FileUtils.pathOf(getCompilerJar(), useCanonicalPath));\n      for (File dep : getCompilerDependencies()) {\n        classpath.add(FileUtils.pathOf(dep, useCanonicalPath));\n      }\n    }\n\n    protected void addLibraryToClasspath(Set<String> classpath) throws Exception {\n      classpath.add(FileUtils.pathOf(getLibraryJar(), useCanonicalPath));\n    }\n\n    @Override\n    public void execute() throws MojoExecutionException, MojoFailureException {\n        try {\n            String oldWay = System.getProperty(\"maven.scala.version\");\n            if (oldWay != null) {\n                getLog().warn(\"using 'maven.scala.version' is deprecated, use 'scala.version' instead\");\n                if (scalaVersion != null) {\n                    scalaVersion = oldWay;\n                }\n            }\n\n            oldWay = System.getProperty(\"maven.scala.displayCmd\");\n            if (oldWay != null) {\n                getLog().warn(\"using 'maven.scala.displayCmd' is deprecated, use 'displayCmd' instead\");\n                displayCmd = displayCmd || Boolean.parseBoolean(oldWay);\n            }\n            checkScalaVersion();\n            doExecute();\n        } catch (MojoExecutionException exc) {\n            throw exc;\n        } catch (MojoFailureException exc) {\n            throw exc;\n        } catch (RuntimeException exc) {\n            throw exc;\n        } catch (Exception exc) {\n            throw new MojoExecutionException(\"wrap: \" + exc, exc);\n        }\n    }\n\n    protected List<Dependency> getDependencies() {\n        return project.getCompileDependencies();\n    }\n\n    protected VersionNumber findScalaVersion() throws Exception {\n        if (_scalaVersionN == null) {\n            String detectedScalaVersion = scalaVersion;\n            if (StringUtils.isEmpty(detectedScalaVersion)) {\n                detectedScalaVersion = findScalaVersionFromDependencies();\n            }\n            if (StringUtils.isEmpty(detectedScalaVersion)) {\n                if (!\"pom\".equals( project.getPackaging().toLowerCase() )) {\n                    getLog().warn(\"you don't define \"+SCALA_GROUPID + \":\" + SCALA_LIBRARY_ARTIFACTID + \" as a dependency of the project\");\n                }\n                detectedScalaVersion = \"0.0.0\";\n            } else {\n                // grappy hack to retrieve the SNAPSHOT version without timestamp,...\n                // because if version is -SNAPSHOT and artifact is deploy with uniqueValue then the version\n                // get from dependency is with the timestamp and a build number (the resolved version)\n                // but scala-compiler with the same version could have different resolved version (timestamp,...)\n                boolean isSnapshot = ArtifactUtils.isSnapshot(detectedScalaVersion);\n                if (isSnapshot && !detectedScalaVersion.endsWith(\"-SNAPSHOT\")) {\n                    detectedScalaVersion = detectedScalaVersion.substring(0, detectedScalaVersion.lastIndexOf('-', detectedScalaVersion.lastIndexOf('-')-1)) + \"-SNAPSHOT\";\n                }\n            }\n            if (StringUtils.isEmpty(detectedScalaVersion)) {\n                throw new MojoFailureException(\"no scalaVersion detected or set\");\n            }\n            if (StringUtils.isNotEmpty(scalaVersion)) {\n                if (!scalaVersion.equals(detectedScalaVersion)) {\n                    getLog().warn(\"scala library version define in dependencies doesn't match the scalaVersion of the plugin\");\n                }\n                //getLog().info(\"suggestion: remove the scalaVersion from pom.xml\"); //scalaVersion could be define in a parent pom where lib is not required\n            }\n            _scalaVersionN = new VersionNumber(detectedScalaVersion);\n        }\n        return _scalaVersionN;\n    }\n\n    private String findScalaVersionFromDependencies() throws Exception {\n        return findVersionFromDependencies(SCALA_GROUPID, SCALA_LIBRARY_ARTIFACTID);\n    }\n\n    //TODO refactor to do only one scan of dependencies to find version\n    protected String findVersionFromDependencies(String groupId, String artifactId) throws Exception {\n        String version = null;\n        for (Dependency dep : getDependencies()) {\n            if (groupId.equals(dep.getGroupId()) && artifactId.equals(dep.getArtifactId())) {\n                version = dep.getVersion();\n            }\n        }\n        if (StringUtils.isEmpty(version)) {\n            List<Dependency> deps = new ArrayList<Dependency>();\n            deps.addAll(project.getModel().getDependencies());\n            if (project.getModel().getDependencyManagement() != null) {\n                deps.addAll(project.getModel().getDependencyManagement().getDependencies());\n            }\n            for (Dependency dep : deps) {\n                if (groupId.equals(dep.getGroupId()) && artifactId.equals(dep.getArtifactId())) {\n                    version = dep.getVersion();\n                }\n            }\n        }\n        return version;\n    }\n\n    protected void checkScalaVersion() throws Exception {\n        String sv = findScalaVersion().toString();\n        if (StringUtils.isNotEmpty(scalaHome)) {\n            getLog().warn(String.format(\"local scala-library.jar and scala-compiler.jar from scalaHome(%s) used instead of scala %s\", scalaHome, sv));\n        }\n        if (checkMultipleScalaVersions) {\n            checkCorrectVersionsOfScalaLibrary(sv);\n        }\n    }\n\n    /** this method checks to see if there are multiple versions of the scala library\n     * @throws Exception */\n    private void checkCorrectVersionsOfScalaLibrary(String requiredScalaVersion) throws Exception {\n        getLog().debug(\"Checking for multiple versions of scala\");\n        //TODO - Make sure we handle bad artifacts....\n        // TODO: note that filter does not get applied due to MNG-3236\n            checkArtifactForScalaVersion(requiredScalaVersion, dependencyTreeBuilder.buildDependencyTree( project, localRepository, artifactFactory,\n                    artifactMetadataSource, null, artifactCollector ));\n    }\n\n\n    /** Visits a node (and all dependencies) to see if it contains duplicate scala versions */\n    private void checkArtifactForScalaVersion(String requiredScalaVersion, DependencyNode rootNode) throws Exception {\n        final CheckScalaVersionVisitor visitor = new CheckScalaVersionVisitor(requiredScalaVersion, getLog());\n\n        CollectingDependencyNodeVisitor collectingVisitor = new CollectingDependencyNodeVisitor();\n        DependencyNodeVisitor firstPassVisitor = new FilteringDependencyNodeVisitor( collectingVisitor, createScalaDistroDependencyFilter() );\n        rootNode.accept( firstPassVisitor );\n\n        DependencyNodeFilter secondPassFilter = new AncestorOrSelfDependencyNodeFilter( collectingVisitor.getNodes() );\n        DependencyNodeVisitor filteredVisitor = new FilteringDependencyNodeVisitor( visitor, secondPassFilter );\n\n        rootNode.accept( filteredVisitor );\n\n        if(visitor.isFailed()) {\n            visitor.logScalaDependents();\n            if(failOnMultipleScalaVersions) {\n                getLog().error(\"Multiple versions of scala libraries detected!\");\n                throw new MojoFailureException(\"Multiple versions of scala libraries detected!\");\n            }\n            getLog().warn(\"Multiple versions of scala libraries detected!\");\n        }\n    }\n\n    /**\n     * @return\n     *          A filter to only extract artifacts deployed from scala distributions\n     */\n    private DependencyNodeFilter createScalaDistroDependencyFilter() {\n        List<ArtifactFilter> filters = new ArrayList<ArtifactFilter>();\n        filters.add(new ScalaDistroArtifactFilter());\n        return new AndDependencyNodeFilter(filters);\n    }\n\n\n\n    protected abstract void doExecute() throws Exception;\n\n\n    protected JavaMainCaller getScalaCommand() throws Exception {\n        JavaMainCaller cmd = getEmptyScalaCommand(scalaClassName);\n        cmd.addArgs(args);\n        if (StringUtils.isNotEmpty(addScalacArgs)) {\n          cmd.addArgs(StringUtils.split(addScalacArgs, \"|\"));\n        }\n        addCompilerPluginOptions(cmd);\n        cmd.addJvmArgs(jvmArgs);\n        return cmd;\n    }\n\n    protected JavaMainCaller getEmptyScalaCommand(String mainClass) throws Exception {\n        //TODO - Fork or not depending on configuration?\n        JavaMainCaller cmd;\n        if(fork) {\n           // scalac with args in files\n           // * works only since 2.8.0\n           // * is buggy (don't manage space in path on windows)\n            getLog().debug(\"use java command with args in file forced : \" + forceUseArgFile);\n\n            cmd = new JavaMainCallerByFork(this, mainClass, getToolClasspath(), null, null, forceUseArgFile, toolchainManager.getToolchainFromBuildContext(\"jdk\", session));\n        } else  {\n            cmd = new JavaMainCallerInProcess(this, mainClass, getToolClasspath(), null, null);\n        }\n        // HACK (better may need refactor)\n        boolean bootcp = true;\n        if (args != null) {\n          for(String arg : args) {\n            bootcp = bootcp && !\"-nobootcp\".equals(arg);\n          }\n        }\n        bootcp = bootcp && !(StringUtils.isNotEmpty(addScalacArgs) && addScalacArgs.contains(\"-nobootcp\"));\n        if (bootcp) {\n          cmd.addJvmArgs(\"-Xbootclasspath/a:\"+ getBootClasspath());\n        }\n        return cmd;\n    }\n\n    private String getToolClasspath() throws Exception {\n        Set<String> classpath = new LinkedHashSet<String>();\n        addCompilerToClasspath(classpath);\n//        addToClasspath(SCALA_GROUPID, \"scala-decoder\", scalaVersion, classpath);\n//        addToClasspath(SCALA_GROUPID, \"scala-dbc\", scalaVersion, classpath);\n        if (dependencies != null) {\n            for(BasicArtifact artifact: dependencies) {\n                addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, classpath);\n            }\n        }\n        return MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()]));\n    }\n\n    private String getBootClasspath() throws Exception {\n        Set<String> classpath = new LinkedHashSet<String>();\n        addLibraryToClasspath(classpath);\n        return MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()]));\n    }\n\n    protected List<String> getScalaOptions() throws Exception {\n        List<String> options = new ArrayList<String>();\n        if (args != null) Collections.addAll(options, args);\n        if (StringUtils.isNotEmpty(addScalacArgs)) {\n            Collections.addAll(options, StringUtils.split(addScalacArgs, \"|\"));\n        }\n        options.addAll(getCompilerPluginOptions());\n        return options;\n    }\n\n    protected List<String> getJavacOptions() throws Exception {\n        List<String> options = new ArrayList<String>();\n        if (javacArgs != null) Collections.addAll(options, javacArgs);\n        if (StringUtils.isNotEmpty(addJavacArgs)) {\n            Collections.addAll(options, StringUtils.split(addJavacArgs, \"|\"));\n        }\n\n        // issue #116\n        if (javacGenerateDebugSymbols) {\n            options.add(\"-g\");\n        }\n        if (target != null) {\n            options.add(\"-target\");\n            options.add(target);\n        }\n        if (source != null) {\n          options.add(\"-source\");\n          options.add(source);\n        }\n        if (encoding != null) {\n          options.add(\"-encoding\");\n          options.add(encoding);\n        }\n        return options;\n    }\n\n    protected File getLibraryJar() throws Exception {\n      if (!StringUtils.isEmpty(scalaHome)) {\n        File lib = new File(scalaHome, \"lib\");\n        return new File(lib, \"scala-library.jar\");\n      }\n      return getArtifactJar(SCALA_GROUPID, SCALA_LIBRARY_ARTIFACTID, findScalaVersion().toString());\n    }\n\n    protected File getCompilerJar() throws Exception {\n      if(!StringUtils.isEmpty(scalaHome)) {\n        File lib = new File(scalaHome, \"lib\");\n        return new File(lib, \"scala-compiler.jar\");\n      }\n      return getArtifactJar(SCALA_GROUPID, SCALA_COMPILER_ARTIFACTID, findScalaVersion().toString());\n    }\n\n    protected List<File> getCompilerDependencies() throws Exception {\n      List<File> d = new ArrayList<File>();\n      if(StringUtils.isEmpty(scalaHome)) {\n        for (Artifact artifact : getAllDependencies(SCALA_GROUPID, SCALA_COMPILER_ARTIFACTID, findScalaVersion().toString())) {\n          d.add(artifact.getFile());\n        }\n      }\n      return d;\n    }\n\n    protected File getArtifactJar(String groupId, String artifactId, String version) throws Exception {\n        Artifact artifact = factory.createArtifact(groupId, artifactId, version, Artifact.SCOPE_RUNTIME, \"jar\");\n        resolver.resolve(artifact, remoteRepos, localRepo);\n        return artifact.getFile();\n    }\n\n    protected File getArtifactJar(String groupId, String artifactId, String version, String classifier) throws Exception {\n        Artifact artifact = factory.createArtifactWithClassifier(groupId, artifactId, version, \"jar\", classifier);\n        resolver.resolve(artifact, remoteRepos, localRepo);\n        return artifact.getFile();\n    }\n\n    protected Set<Artifact> getAllDependencies(String groupId, String artifactId, String version) throws Exception {\n        Set<Artifact> result = new HashSet<Artifact>();\n        Artifact pom = factory.createArtifact(groupId, artifactId, version, \"\", \"pom\");\n        MavenProject p = mavenProjectBuilder.buildFromRepository(pom, remoteRepos, localRepo);\n        Set<Artifact> d = resolveDependencyArtifacts(p);\n        result.addAll(d);\n        for (Artifact dependency : d) {\n            Set<Artifact> transitive = getAllDependencies(dependency.getGroupId(), dependency.getArtifactId(), dependency.getVersion());\n            result.addAll(transitive);\n        }\n        return result;\n    }\n\n    /**\n     * @return\n     *           This returns whether or not the scala version can support having java sent into the compiler\n     */\n    protected boolean isJavaSupportedByCompiler() throws Exception {\n        return findScalaVersion().compareTo(new VersionNumber(\"2.7.2\")) >= 0;\n    }\n\n\n    /**\n     * Adds appropriate compiler plugins to the scalac command.\n     * @param scalac\n     * @throws Exception\n     */\n    protected void addCompilerPluginOptions(JavaMainCaller scalac) throws Exception {\n        for (String option : getCompilerPluginOptions()) {\n            scalac.addArgs(option);\n        }\n    }\n\n    protected List<String> getCompilerPluginOptions() throws Exception {\n        List<String> options = new ArrayList<String>();\n        for (String plugin : getCompilerPlugins()) {\n            options.add(\"-Xplugin:\" + plugin);\n        }\n        return options;\n    }\n\n    /**\n     * Retrieves a list of paths to scala compiler plugins.\n     *\n     * @return The list of plugins\n     * @throws Exception\n     */\n    private Set<String> getCompilerPlugins() throws Exception {\n        Set<String> plugins = new HashSet<String>();\n        if (compilerPlugins != null) {\n            Set<String> ignoreClasspath = new LinkedHashSet<String>();\n            addCompilerToClasspath(ignoreClasspath);\n            addLibraryToClasspath(ignoreClasspath);\n            for (BasicArtifact artifact : compilerPlugins) {\n                getLog().info(\"compiler plugin: \" + artifact.toString());\n                // TODO - Ensure proper scala version for plugins\n                Set<String> pluginClassPath = new HashSet<String>();\n                //TODO - Pull in transitive dependencies.\n                addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, artifact.classifier, pluginClassPath, false);\n                pluginClassPath.removeAll(ignoreClasspath);\n                plugins.addAll(pluginClassPath);\n            }\n        }\n        return plugins;\n    }\n\n    protected String findVersionFromPluginArtifacts(String groupId, String artifactId) throws Exception {\n        String version = null;\n        for (Artifact art : pluginArtifacts) {\n            if (groupId.equals(art.getGroupId()) && artifactId.equals(art.getArtifactId())) {\n                version = art.getVersion();\n            }\n        }\n        return version;\n    }\n\n    protected File getPluginArtifactJar(String groupId, String artifactId, String version) throws Exception {\n        return getPluginArtifactJar(groupId, artifactId, version, null);\n    }\n\n    protected File getPluginArtifactJar(String groupId, String artifactId, String version, String classifier) throws Exception {\n        Artifact artifact = null;\n        for (Artifact art : pluginArtifacts) {\n            if (groupId.equals(art.getGroupId()) && artifactId.equals(art.getArtifactId()) && version.equals(art.getVersion())){\n            \tif ((classifier == null && art.getClassifier() == null) || (classifier != null && classifier.equals(art.getClassifier()))) {\n            \t\tartifact = art;\n            \t}\n            }\n        }\n        if (artifact == null) {\n\t    \tString msg = String.format(\"can't find artifact %s::%s::%s-%s\", groupId, artifactId, version, classifier);\n\t    \tgetLog().error(msg);\n\t    \tthrow new Exception(msg);\n        }\n        return artifact.getFile();\n    }\n}\n","Method after Refactoring":"package scala_maven;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.ArtifactUtils;\nimport org.apache.maven.artifact.factory.ArtifactFactory;\nimport org.apache.maven.artifact.metadata.ArtifactMetadataSource;\nimport org.apache.maven.artifact.repository.ArtifactRepository;\nimport org.apache.maven.artifact.resolver.ArtifactCollector;\nimport org.apache.maven.artifact.resolver.ArtifactNotFoundException;\nimport org.apache.maven.artifact.resolver.ArtifactResolutionException;\nimport org.apache.maven.artifact.resolver.ArtifactResolver;\nimport org.apache.maven.artifact.resolver.filter.AndArtifactFilter;\nimport org.apache.maven.artifact.resolver.filter.ArtifactFilter;\nimport org.apache.maven.artifact.resolver.filter.ScopeArtifactFilter;\nimport org.apache.maven.artifact.versioning.VersionRange;\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.model.Dependency;\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugin.MojoFailureException;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.project.MavenProjectBuilder;\nimport org.apache.maven.project.ProjectBuildingException;\nimport org.apache.maven.project.artifact.InvalidDependencyVersionException;\nimport org.apache.maven.repository.RepositorySystem;\nimport org.apache.maven.shared.dependency.tree.DependencyNode;\nimport org.apache.maven.shared.dependency.tree.DependencyTreeBuilder;\nimport org.apache.maven.shared.dependency.tree.filter.AncestorOrSelfDependencyNodeFilter;\nimport org.apache.maven.shared.dependency.tree.filter.AndDependencyNodeFilter;\nimport org.apache.maven.shared.dependency.tree.filter.DependencyNodeFilter;\nimport org.apache.maven.shared.dependency.tree.traversal.CollectingDependencyNodeVisitor;\nimport org.apache.maven.shared.dependency.tree.traversal.DependencyNodeVisitor;\nimport org.apache.maven.shared.dependency.tree.traversal.FilteringDependencyNodeVisitor;\nimport org.apache.maven.toolchain.ToolchainManager;\nimport org.codehaus.plexus.util.StringUtils;\nimport scala_maven_dependency.CheckScalaVersionVisitor;\nimport scala_maven_dependency.ScalaDistroArtifactFilter;\nimport scala_maven_executions.JavaMainCaller;\nimport scala_maven_executions.JavaMainCallerByFork;\nimport scala_maven_executions.JavaMainCallerInProcess;\nimport scala_maven_executions.MainHelper;\n\npublic abstract class ScalaMojoSupport extends AbstractMojo {\n\n    public static final String SCALA_GROUPID= \"org.scala-lang\";\n    public static final String SCALA_LIBRARY_ARTIFACTID= \"scala-library\";\n    public static final String SCALA_COMPILER_ARTIFACTID= \"scala-compiler\";\n    \n    /**\n     * @parameter expression=\"${project}\"\n     * @required\n     * @readonly\n     */\n    protected MavenProject project;\n\n    /**\n     * The Maven Session Object\n     *\n     * @parameter expression=\"${session}\"\n     * @required\n     * @readonly\n     */\n    protected MavenSession session;\n\n    /**\n     * Contains the full list of projects in the reactor.\n     *\n     * @parameter default-value=\"${reactorProjects}\"\n     * @required\n     * @readonly\n     */\n    protected List<MavenProject> reactorProjects;\n\n    /**\n     * Used to look up Artifacts in the remote repository.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    protected RepositorySystem factory;\n\n    /**\n     * Used to look up Artifacts in the remote repository.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    protected ArtifactResolver resolver;\n    /**\n     * Location of the local repository.\n     *\n     * @parameter expression=\"${localRepository}\"\n     * @readonly\n     * @required\n     */\n    protected ArtifactRepository localRepo;\n\n    /**\n     * List of Remote Repositories used by the resolver\n     *\n     * @parameter expression=\"${project.remoteArtifactRepositories}\"\n     * @readonly\n     * @required\n     */\n    protected List<?> remoteRepos;\n\n    /**\n     * Additional dependencies/jar to add to classpath to run \"scalaClassName\" (scope and optional field not supported)\n     * ex :\n     * <pre>\n     *    &lt;dependencies>\n     *      &lt;dependency>\n     *        &lt;groupId>org.scala-tools&lt;/groupId>\n     *        &lt;artifactId>scala-compiler-addon&lt;/artifactId>\n     *        &lt;version>1.0-SNAPSHOT&lt;/version>\n     *      &lt;/dependency>\n     *    &lt;/dependencies>\n     * <\/pre>\n     * @parameter\n     */\n    protected BasicArtifact[] dependencies;\n\n    /**\n     * Compiler plugin dependencies to use when compiling.\n     * ex:\n     * @parameter\n     * <xmp>\n     * <compilerPlugins>\n     * <compilerPlugin>\n     * <groupId>my.scala.plugin<\/groupId>\n     * <artifactId>amazingPlugin<\/artifactId>\n     * <version>1.0-SNAPSHOT<\/version>\n     * <\/compilerPlugin>\n     * <\/compilerPlugins>\n     * <\/xmp>\n     */\n    protected BasicArtifact[] compilerPlugins;\n\n    /**\n     * Jvm Arguments.\n     *\n     * @parameter\n     */\n    protected String[] jvmArgs;\n\n    /**\n     * compiler additionnals arguments\n     *\n     * @parameter\n     */\n    protected String[] args;\n\n    /**\n     * Additional parameter to use to call the main class\n     * Using this parameter only from command line (\"-DaddScalacArgs=arg1|arg2|arg3|...\"), not from pom.xml.\n     * @parameter expression=\"${addScalacArgs}\"\n     */\n    protected String addScalacArgs;\n\n    /**\n     * className (FQN) of the scala tool to provide as\n     *\n     * @required\n     * @parameter expression=\"${maven.scala.className}\"\n     *            default-value=\"scala.tools.nsc.Main\"\n     */\n    protected String scalaClassName;\n\n    /**\n     * Scala 's version to use.\n     * (property 'maven.scala.version' replaced by 'scala.version')\n     *\n     * @parameter expression=\"${scala.version}\"\n     */\n    private String scalaVersion;\n\n    /**\n     * Path to Scala installation to use instead of the artifact (define as dependencies).\n     *\n     * @parameter expression=\"${scala.home}\"\n     */\n    private String scalaHome;\n\n    /**\n     * Arguments for javac (when using incremental compiler).\n     *\n     * @parameter expression=\"${javacArgs}\"\n     */\n    protected String[] javacArgs;@SuppressWarnings(\"unused\") \n\n    /**\n     * Whether to instruct javac to generate debug symbols (when using incremental compiler)\n     * @see {@link http://maven.apache.org/plugins/maven-compiler-plugin/compile-mojo.html#debug}\n     *\n     * @parameter expression=\"${javacGenerateDebugSymbols}\"\n     *            default-value=\"true\"\n     */\n    protected boolean javacGenerateDebugSymbols = true;\n\n    /**\n     * Alternative method for specifying javac arguments (when using incremental compiler).\n     * Can be used from command line with -DaddJavacArgs=arg1|arg2|arg3|... rather than in pom.xml.\n     *\n     * @parameter expression=\"${addJavacArgs}\"\n     */\n    protected String addJavacArgs;\n\n    \n    /**\n     * The -source argument for the Java compiler (when using incremental compiler).\n     *\n     * @parameter expression=\"${maven.compiler.source}\"\n     */\n    protected String source;\n    \n    /**\n     * The -target argument for the Java compiler (when using incremental compiler).\n     *\n     * @parameter expression=\"${maven.compiler.target}\"\n     */\n    protected String target;\n    \n    /**\n     * The -encoding argument for the Java compiler. (when using incremental compiler).\n     *\n     * @parameter expression=\"${project.build.sourceEncoding}\"\n     */\n    protected String encoding;\n    \n    /**\n     * Display the command line called ?\n     * (property 'maven.scala.displayCmd' replaced by 'displayCmd')\n     *\n     * @required\n     * @parameter expression=\"${displayCmd}\"\n     *            default-value=\"false\"\n     */\n    public boolean displayCmd;\n\n    /**\n     * Forks the execution of scalac into a separate process.\n     *\n     * @parameter default-value=\"true\"\n     */\n    protected boolean fork = true;\n\n    /**\n     * Force the use of an external ArgFile to run any forked process.\n     *\n     * @parameter default-value=\"false\"\n     */\n    protected boolean forceUseArgFile = false;\n\n    /**\n     * Check if every dependencies use the same version of scala-library.\n     *\n     * @parameter expression=\"${maven.scala.checkConsistency}\" default-value=\"true\"\n     */\n    protected boolean checkMultipleScalaVersions;\n\n    /**\n     * Determines if a detection of multiple scala versions in the dependencies will cause the build to fail.\n     *\n     * @parameter default-value=\"false\"\n     */\n    protected boolean failOnMultipleScalaVersions = false;\n\n    /**\n     * Should use CanonicalPath to normalize path (true => getCanonicalPath, false => getAbsolutePath)\n     * @see https://github.com/davidB/maven-scala-plugin/issues/50\n     * @parameter expression=\"${maven.scala.useCanonicalPath}\" default-value=\"true\"\n     */\n    protected boolean useCanonicalPath = true;\n\n    /**\n     * Artifact factory, needed to download source jars.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    protected MavenProjectBuilder mavenProjectBuilder;\n\n    /**\n     * The artifact repository to use.\n     *\n     * @parameter expression=\"${localRepository}\"\n     * @required\n     * @readonly\n     */\n    private ArtifactRepository localRepository;\n\n    /**\n     * The artifact factory to use.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    private ArtifactFactory artifactFactory;\n\n    /**\n     * The artifact metadata source to use.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    private ArtifactMetadataSource artifactMetadataSource;\n\n    /**\n     * The artifact collector to use.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    private ArtifactCollector artifactCollector;\n\n    /**\n     * The dependency tree builder to use.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    private DependencyTreeBuilder dependencyTreeBuilder;\n\n    /**\n     * The toolchain manager to use.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    protected ToolchainManager toolchainManager;\n\n    /** @parameter default-value=\"${plugin.artifacts}\" */\n    private List<Artifact> pluginArtifacts;\n\n    private VersionNumber _scalaVersionN;\n\n    /**\n     * This method resolves the dependency artifacts from the project.\n     *\n     * @param theProject The POM.\n     * @return resolved set of dependency artifacts.\n     *\n     * @throws ArtifactResolutionException\n     * @throws ArtifactNotFoundException\n     * @throws InvalidDependencyVersionException\n     */\n    protected Set<Artifact> resolveDependencyArtifacts(MavenProject theProject) throws Exception {\n        AndArtifactFilter filter = new AndArtifactFilter();\n        filter.add(new ScopeArtifactFilter(Artifact.SCOPE_TEST));\n        filter.add(new ArtifactFilter(){\n            public boolean include(Artifact artifact) {\n                return !artifact.isOptional();\n            }\n        });\n        //TODO follow the dependenciesManagement and override rules\n        Set<Artifact> artifacts = theProject.createArtifacts(artifactFactory, Artifact.SCOPE_RUNTIME, filter);\n        for (Artifact artifact : artifacts) {\n            resolver.resolve(artifact, remoteRepos, localRepo);\n        }\n        return artifacts;\n    }\n\n    /**\n     * This method resolves all transitive dependencies of an artifact.\n     *\n     * @param artifact the artifact used to retrieve dependencies\n     *\n     * @return resolved set of dependencies\n     *\n     * @throws ArtifactResolutionException\n     * @throws ArtifactNotFoundException\n     * @throws ProjectBuildingException\n     * @throws InvalidDependencyVersionException\n     */\n    protected Set<Artifact> resolveArtifactDependencies(Artifact artifact) throws Exception {\n        Artifact pomArtifact = factory.createArtifact(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), \"\", \"pom\");\n        MavenProject pomProject = mavenProjectBuilder.buildFromRepository(pomArtifact, remoteRepos, localRepo);\n        return resolveDependencyArtifacts(pomProject);\n    }\n\n    public void addToClasspath(String groupId, String artifactId, String version, Set<String> classpath) throws Exception {\n        addToClasspath(groupId, artifactId, version, classpath, true);\n    }\n\n\n    public void addToClasspath(String groupId, String artifactId, String version, Set<String> classpath, boolean addDependencies) throws Exception {\n        addToClasspath(factory.createArtifact(groupId, artifactId, version, Artifact.SCOPE_RUNTIME, \"jar\"), classpath, addDependencies);\n    }\n\n    /**\n     * added for classifier support.\n     * @author Christoph Radig\n     * @todo might want to merge with existing \"addToClasspath\" methods.\n     */\n    public void addToClasspath(String groupId, String artifactId, String version, String classifier, Set<String> classpath, boolean addDependencies) throws Exception {\n      Dependency d = new Dependency();\n      d.setGroupId(groupId);\n      d.setArtifactId(artifactId);\n      d.setVersion(version);\n      d.setType(\"jar\");\n      d.setClassifier(classifier);\n      d.setScope(Artifact.SCOPE_RUNTIME);\n      addToClasspath(factory.createDependencyArtifact(d), classpath, addDependencies);\n    }\n\n    protected void addToClasspath(Artifact artifact, Set<String> classpath, boolean addDependencies) throws Exception {\n        resolver.resolve(artifact, remoteRepos, localRepo);\n        classpath.add(FileUtils.pathOf(artifact.getFile(), useCanonicalPath));\n        if (addDependencies) {\n            for (Artifact dep : resolveArtifactDependencies(artifact)) {\n                addToClasspath(dep, classpath, addDependencies);\n            }\n        }\n    }\n\n    protected void addCompilerToClasspath(Set<String> classpath) throws Exception {\n      classpath.add(FileUtils.pathOf(getCompilerJar(), useCanonicalPath));\n      for (File dep : getCompilerDependencies()) {\n        classpath.add(FileUtils.pathOf(dep, useCanonicalPath));\n      }\n    }\n\n    protected void addLibraryToClasspath(Set<String> classpath) throws Exception {\n      classpath.add(FileUtils.pathOf(getLibraryJar(), useCanonicalPath));\n    }\n\n    @Override\n    public void execute() throws MojoExecutionException, MojoFailureException {\n        try {\n            String oldWay = System.getProperty(\"maven.scala.version\");\n            if (oldWay != null) {\n                getLog().warn(\"using 'maven.scala.version' is deprecated, use 'scala.version' instead\");\n                if (scalaVersion != null) {\n                    scalaVersion = oldWay;\n                }\n            }\n\n            oldWay = System.getProperty(\"maven.scala.displayCmd\");\n            if (oldWay != null) {\n                getLog().warn(\"using 'maven.scala.displayCmd' is deprecated, use 'displayCmd' instead\");\n                displayCmd = displayCmd || Boolean.parseBoolean(oldWay);\n            }\n            checkScalaVersion();\n            doExecute();\n        } catch (MojoExecutionException exc) {\n            throw exc;\n        } catch (MojoFailureException exc) {\n            throw exc;\n        } catch (RuntimeException exc) {\n            throw exc;\n        } catch (Exception exc) {\n            throw new MojoExecutionException(\"wrap: \" + exc, exc);\n        }\n    }\n\n    protected List<Dependency> getDependencies() {\n        return project.getCompileDependencies();\n    }\n\n    protected VersionNumber findScalaVersion() throws Exception {\n        if (_scalaVersionN == null) {\n            String detectedScalaVersion = scalaVersion;\n            if (StringUtils.isEmpty(detectedScalaVersion)) {\n                detectedScalaVersion = findScalaVersionFromDependencies();\n            }\n            if (StringUtils.isEmpty(detectedScalaVersion)) {\n                if (!\"pom\".equals( project.getPackaging().toLowerCase() )) {\n                    getLog().warn(\"you don't define \"+SCALA_GROUPID + \":\" + SCALA_LIBRARY_ARTIFACTID + \" as a dependency of the project\");\n                }\n                detectedScalaVersion = \"0.0.0\";\n            } else {\n                // grappy hack to retrieve the SNAPSHOT version without timestamp,...\n                // because if version is -SNAPSHOT and artifact is deploy with uniqueValue then the version\n                // get from dependency is with the timestamp and a build number (the resolved version)\n                // but scala-compiler with the same version could have different resolved version (timestamp,...)\n                boolean isSnapshot = ArtifactUtils.isSnapshot(detectedScalaVersion);\n                if (isSnapshot && !detectedScalaVersion.endsWith(\"-SNAPSHOT\")) {\n                    detectedScalaVersion = detectedScalaVersion.substring(0, detectedScalaVersion.lastIndexOf('-', detectedScalaVersion.lastIndexOf('-')-1)) + \"-SNAPSHOT\";\n                }\n            }\n            if (StringUtils.isEmpty(detectedScalaVersion)) {\n                throw new MojoFailureException(\"no scalaVersion detected or set\");\n            }\n            if (StringUtils.isNotEmpty(scalaVersion)) {\n                if (!scalaVersion.equals(detectedScalaVersion)) {\n                    getLog().warn(\"scala library version define in dependencies doesn't match the scalaVersion of the plugin\");\n                }\n                //getLog().info(\"suggestion: remove the scalaVersion from pom.xml\"); //scalaVersion could be define in a parent pom where lib is not required\n            }\n            _scalaVersionN = new VersionNumber(detectedScalaVersion);\n        }\n        return _scalaVersionN;\n    }\n\n    private String findScalaVersionFromDependencies() throws Exception {\n        return findVersionFromDependencies(SCALA_GROUPID, SCALA_LIBRARY_ARTIFACTID);\n    }\n\n    //TODO refactor to do only one scan of dependencies to find version\n    protected String findVersionFromDependencies(String groupId, String artifactId) throws Exception {\n        String version = null;\n        for (Dependency dep : getDependencies()) {\n            if (groupId.equals(dep.getGroupId()) && artifactId.equals(dep.getArtifactId())) {\n                version = dep.getVersion();\n            }\n        }\n        if (StringUtils.isEmpty(version)) {\n            List<Dependency> deps = new ArrayList<Dependency>();\n            deps.addAll(project.getModel().getDependencies());\n            if (project.getModel().getDependencyManagement() != null) {\n                deps.addAll(project.getModel().getDependencyManagement().getDependencies());\n            }\n            for (Dependency dep : deps) {\n                if (groupId.equals(dep.getGroupId()) && artifactId.equals(dep.getArtifactId())) {\n                    version = dep.getVersion();\n                }\n            }\n        }\n        return version;\n    }\n\n    protected void checkScalaVersion() throws Exception {\n        String sv = findScalaVersion().toString();\n        if (StringUtils.isNotEmpty(scalaHome)) {\n            getLog().warn(String.format(\"local scala-library.jar and scala-compiler.jar from scalaHome(%s) used instead of scala %s\", scalaHome, sv));\n        }\n        if (checkMultipleScalaVersions) {\n            checkCorrectVersionsOfScalaLibrary(sv);\n        }\n    }\n\n    /** this method checks to see if there are multiple versions of the scala library\n     * @throws Exception */\n    private void checkCorrectVersionsOfScalaLibrary(String requiredScalaVersion) throws Exception {\n        getLog().debug(\"Checking for multiple versions of scala\");\n        //TODO - Make sure we handle bad artifacts....\n        // TODO: note that filter does not get applied due to MNG-3236\n            checkArtifactForScalaVersion(requiredScalaVersion, dependencyTreeBuilder.buildDependencyTree( project, localRepository, artifactFactory,\n                    artifactMetadataSource, null, artifactCollector ));\n    }\n\n\n    /** Visits a node (and all dependencies) to see if it contains duplicate scala versions */\n    private void checkArtifactForScalaVersion(String requiredScalaVersion, DependencyNode rootNode) throws Exception {\n        final CheckScalaVersionVisitor visitor = new CheckScalaVersionVisitor(requiredScalaVersion, getLog());\n\n        CollectingDependencyNodeVisitor collectingVisitor = new CollectingDependencyNodeVisitor();\n        DependencyNodeVisitor firstPassVisitor = new FilteringDependencyNodeVisitor( collectingVisitor, createScalaDistroDependencyFilter() );\n        rootNode.accept( firstPassVisitor );\n\n        DependencyNodeFilter secondPassFilter = new AncestorOrSelfDependencyNodeFilter( collectingVisitor.getNodes() );\n        DependencyNodeVisitor filteredVisitor = new FilteringDependencyNodeVisitor( visitor, secondPassFilter );\n\n        rootNode.accept( filteredVisitor );\n\n        if(visitor.isFailed()) {\n            visitor.logScalaDependents();\n            if(failOnMultipleScalaVersions) {\n                getLog().error(\"Multiple versions of scala libraries detected!\");\n                throw new MojoFailureException(\"Multiple versions of scala libraries detected!\");\n            }\n            getLog().warn(\"Multiple versions of scala libraries detected!\");\n        }\n    }\n\n    /**\n     * @return\n     *          A filter to only extract artifacts deployed from scala distributions\n     */\n    private DependencyNodeFilter createScalaDistroDependencyFilter() {\n        List<ArtifactFilter> filters = new ArrayList<ArtifactFilter>();\n        filters.add(new ScalaDistroArtifactFilter());\n        return new AndDependencyNodeFilter(filters);\n    }\n\n\n\n    protected abstract void doExecute() throws Exception;\n\n\n    protected JavaMainCaller getScalaCommand() throws Exception {\n        JavaMainCaller cmd = getEmptyScalaCommand(scalaClassName);\n        cmd.addArgs(args);\n        if (StringUtils.isNotEmpty(addScalacArgs)) {\n          cmd.addArgs(StringUtils.split(addScalacArgs, \"|\"));\n        }\n        addCompilerPluginOptions(cmd);\n        cmd.addJvmArgs(jvmArgs);\n        return cmd;\n    }\n\n    protected JavaMainCaller getEmptyScalaCommand(String mainClass) throws Exception {\n      \n      //TODO - Fork or not depending on configuration?\n      JavaMainCaller cmd;\n      String toolcp = getToolClasspath();\n      if(fork) {\n        // HACK (better may need refactor)\n        boolean bootcp = true;\n        if (args != null) {\n          for(String arg : args) {\n            bootcp = bootcp && !\"-nobootcp\".equals(arg);\n          }\n        }\n        String cp = bootcp ? \"\" : toolcp;\n        bootcp = bootcp && !(StringUtils.isNotEmpty(addScalacArgs) && addScalacArgs.contains(\"-nobootcp\"));\n        // scalac with args in files\n        // * works only since 2.8.0\n        // * is buggy (don't manage space in path on windows)\n        getLog().debug(\"use java command with args in file forced : \" + forceUseArgFile);\n        cmd = new JavaMainCallerByFork(this, mainClass, cp, null, null, forceUseArgFile, toolchainManager.getToolchainFromBuildContext(\"jdk\", session));\n        if (bootcp) {\n          cmd.addJvmArgs(\"-Xbootclasspath/a:\" + toolcp);\n        }\n      } else  {\n        cmd = new JavaMainCallerInProcess(this, mainClass, toolcp, null, null);\n      }\n      return cmd;\n    }\n\n    private String getToolClasspath() throws Exception {\n        Set<String> classpath = new LinkedHashSet<String>();\n        addCompilerToClasspath(classpath);\n//        addToClasspath(SCALA_GROUPID, \"scala-decoder\", scalaVersion, classpath);\n//        addToClasspath(SCALA_GROUPID, \"scala-dbc\", scalaVersion, classpath);\n        if (dependencies != null) {\n            for(BasicArtifact artifact: dependencies) {\n                addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, classpath);\n            }\n        }\n        return MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()]));\n    }\n\n    protected List<String> getScalaOptions() throws Exception {\n        List<String> options = new ArrayList<String>();\n        if (args != null) Collections.addAll(options, args);\n        if (StringUtils.isNotEmpty(addScalacArgs)) {\n            Collections.addAll(options, StringUtils.split(addScalacArgs, \"|\"));\n        }\n        options.addAll(getCompilerPluginOptions());\n        return options;\n    }\n\n    protected List<String> getJavacOptions() throws Exception {\n        List<String> options = new ArrayList<String>();\n        if (javacArgs != null) Collections.addAll(options, javacArgs);\n        if (StringUtils.isNotEmpty(addJavacArgs)) {\n            Collections.addAll(options, StringUtils.split(addJavacArgs, \"|\"));\n        }\n\n        // issue #116\n        if (javacGenerateDebugSymbols) {\n            options.add(\"-g\");\n        }\n        if (target != null) {\n            options.add(\"-target\");\n            options.add(target);\n        }\n        if (source != null) {\n          options.add(\"-source\");\n          options.add(source);\n        }\n        if (encoding != null) {\n          options.add(\"-encoding\");\n          options.add(encoding);\n        }\n        return options;\n    }\n\n    protected File getLibraryJar() throws Exception {\n      if (!StringUtils.isEmpty(scalaHome)) {\n        File lib = new File(scalaHome, \"lib\");\n        return new File(lib, \"scala-library.jar\");\n      }\n      return getArtifactJar(SCALA_GROUPID, SCALA_LIBRARY_ARTIFACTID, findScalaVersion().toString());\n    }\n\n    protected File getCompilerJar() throws Exception {\n      if(!StringUtils.isEmpty(scalaHome)) {\n        File lib = new File(scalaHome, \"lib\");\n        return new File(lib, \"scala-compiler.jar\");\n      }\n      return getArtifactJar(SCALA_GROUPID, SCALA_COMPILER_ARTIFACTID, findScalaVersion().toString());\n    }\n\n    protected List<File> getCompilerDependencies() throws Exception {\n      List<File> d = new ArrayList<File>();\n      if(StringUtils.isEmpty(scalaHome)) {\n        for (Artifact artifact : getAllDependencies(SCALA_GROUPID, SCALA_COMPILER_ARTIFACTID, findScalaVersion().toString())) {\n          d.add(artifact.getFile());\n        }\n      } else {\n        for(File f : new File(scalaHome, \"lib\").listFiles()) {\n          String name = f.getName();\n          if (name.endsWith(\".jar\") && !name.contains(\"scala-library\") && !name.contains(\"scala-compiler\")) {\n            d.add(f);\n          }\n        }\n      }\n      return d;\n    }\n\n    protected File getArtifactJar(String groupId, String artifactId, String version) throws Exception {\n        Artifact artifact = factory.createArtifact(groupId, artifactId, version, Artifact.SCOPE_RUNTIME, \"jar\");\n        resolver.resolve(artifact, remoteRepos, localRepo);\n        return artifact.getFile();\n    }\n\n    protected File getArtifactJar(String groupId, String artifactId, String version, String classifier) throws Exception {\n        Artifact artifact = factory.createArtifactWithClassifier(groupId, artifactId, version, \"jar\", classifier);\n        resolver.resolve(artifact, remoteRepos, localRepo);\n        return artifact.getFile();\n    }\n\n    protected Set<Artifact> getAllDependencies(String groupId, String artifactId, String version) throws Exception {\n        Set<Artifact> result = new HashSet<Artifact>();\n        Artifact pom = factory.createArtifact(groupId, artifactId, version, \"\", \"pom\");\n        MavenProject p = mavenProjectBuilder.buildFromRepository(pom, remoteRepos, localRepo);\n        Set<Artifact> d = resolveDependencyArtifacts(p);\n        result.addAll(d);\n        for (Artifact dependency : d) {\n            Set<Artifact> transitive = getAllDependencies(dependency.getGroupId(), dependency.getArtifactId(), dependency.getVersion());\n            result.addAll(transitive);\n        }\n        return result;\n    }\n\n    /**\n     * @return\n     *           This returns whether or not the scala version can support having java sent into the compiler\n     */\n    protected boolean isJavaSupportedByCompiler() throws Exception {\n        return findScalaVersion().compareTo(new VersionNumber(\"2.7.2\")) >= 0;\n    }\n\n\n    /**\n     * Adds appropriate compiler plugins to the scalac command.\n     * @param scalac\n     * @throws Exception\n     */\n    protected void addCompilerPluginOptions(JavaMainCaller scalac) throws Exception {\n        for (String option : getCompilerPluginOptions()) {\n            scalac.addArgs(option);\n        }\n    }\n\n    protected List<String> getCompilerPluginOptions() throws Exception {\n        List<String> options = new ArrayList<String>();\n        for (String plugin : getCompilerPlugins()) {\n            options.add(\"-Xplugin:\" + plugin);\n        }\n        return options;\n    }\n\n    /**\n     * Retrieves a list of paths to scala compiler plugins.\n     *\n     * @return The list of plugins\n     * @throws Exception\n     */\n    private Set<String> getCompilerPlugins() throws Exception {\n        Set<String> plugins = new HashSet<String>();\n        if (compilerPlugins != null) {\n            Set<String> ignoreClasspath = new LinkedHashSet<String>();\n            addCompilerToClasspath(ignoreClasspath);\n            addLibraryToClasspath(ignoreClasspath);\n            for (BasicArtifact artifact : compilerPlugins) {\n                getLog().info(\"compiler plugin: \" + artifact.toString());\n                // TODO - Ensure proper scala version for plugins\n                Set<String> pluginClassPath = new HashSet<String>();\n                //TODO - Pull in transitive dependencies.\n                addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, artifact.classifier, pluginClassPath, false);\n                pluginClassPath.removeAll(ignoreClasspath);\n                plugins.addAll(pluginClassPath);\n            }\n        }\n        return plugins;\n    }\n\n    protected String findVersionFromPluginArtifacts(String groupId, String artifactId) throws Exception {\n        String version = null;\n        for (Artifact art : pluginArtifacts) {\n            if (groupId.equals(art.getGroupId()) && artifactId.equals(art.getArtifactId())) {\n                version = art.getVersion();\n            }\n        }\n        return version;\n    }\n\n    protected File getPluginArtifactJar(String groupId, String artifactId, String version) throws Exception {\n        return getPluginArtifactJar(groupId, artifactId, version, null);\n    }\n\n    protected File getPluginArtifactJar(String groupId, String artifactId, String version, String classifier) throws Exception {\n        Artifact artifact = null;\n        for (Artifact art : pluginArtifacts) {\n            if (groupId.equals(art.getGroupId()) && artifactId.equals(art.getArtifactId()) && version.equals(art.getVersion())){\n            \tif ((classifier == null && art.getClassifier() == null) || (classifier != null && classifier.equals(art.getClassifier()))) {\n            \t\tartifact = art;\n            \t}\n            }\n        }\n        if (artifact == null) {\n\t    \tString msg = String.format(\"can't find artifact %s::%s::%s-%s\", groupId, artifactId, version, classifier);\n\t    \tgetLog().error(msg);\n\t    \tthrow new Exception(msg);\n        }\n        return artifact.getFile();\n    }\n}\n","lineNo":622}
{"Smelly Sample":"package scala_maven;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.ArtifactUtils;\nimport org.apache.maven.artifact.factory.ArtifactFactory;\nimport org.apache.maven.artifact.metadata.ArtifactMetadataSource;\nimport org.apache.maven.artifact.repository.ArtifactRepository;\nimport org.apache.maven.artifact.resolver.ArtifactCollector;\nimport org.apache.maven.artifact.resolver.ArtifactNotFoundException;\nimport org.apache.maven.artifact.resolver.ArtifactResolutionException;\nimport org.apache.maven.artifact.resolver.ArtifactResolver;\nimport org.apache.maven.artifact.resolver.filter.AndArtifactFilter;\nimport org.apache.maven.artifact.resolver.filter.ArtifactFilter;\nimport org.apache.maven.artifact.resolver.filter.ScopeArtifactFilter;\nimport org.apache.maven.artifact.versioning.VersionRange;\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.model.Dependency;\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugin.MojoFailureException;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.project.MavenProjectBuilder;\nimport org.apache.maven.project.ProjectBuildingException;\nimport org.apache.maven.project.artifact.InvalidDependencyVersionException;\nimport org.apache.maven.repository.RepositorySystem;\nimport org.apache.maven.shared.dependency.tree.DependencyNode;\nimport org.apache.maven.shared.dependency.tree.DependencyTreeBuilder;\nimport org.apache.maven.shared.dependency.tree.filter.AncestorOrSelfDependencyNodeFilter;\nimport org.apache.maven.shared.dependency.tree.filter.AndDependencyNodeFilter;\nimport org.apache.maven.shared.dependency.tree.filter.DependencyNodeFilter;\nimport org.apache.maven.shared.dependency.tree.traversal.CollectingDependencyNodeVisitor;\nimport org.apache.maven.shared.dependency.tree.traversal.DependencyNodeVisitor;\nimport org.apache.maven.shared.dependency.tree.traversal.FilteringDependencyNodeVisitor;\nimport org.apache.maven.toolchain.ToolchainManager;\nimport org.codehaus.plexus.util.StringUtils;\nimport scala_maven_dependency.CheckScalaVersionVisitor;\nimport scala_maven_dependency.ScalaDistroArtifactFilter;\nimport scala_maven_executions.JavaMainCaller;\nimport scala_maven_executions.JavaMainCallerByFork;\nimport scala_maven_executions.JavaMainCallerInProcess;\nimport scala_maven_executions.MainHelper;\n\npublic abstract class ScalaMojoSupport extends AbstractMojo {\n\n    public static final String SCALA_GROUPID= \"org.scala-lang\";\n    public static final String SCALA_LIBRARY_ARTIFACTID= \"scala-library\";\n    public static final String SCALA_COMPILER_ARTIFACTID= \"scala-compiler\";\n    \n    /**\n     * @parameter expression=\"${project}\"\n     * @required\n     * @readonly\n     */\n    protected MavenProject project;\n\n    /**\n     * The Maven Session Object\n     *\n     * @parameter expression=\"${session}\"\n     * @required\n     * @readonly\n     */\n    protected MavenSession session;\n\n    /**\n     * Contains the full list of projects in the reactor.\n     *\n     * @parameter default-value=\"${reactorProjects}\"\n     * @required\n     * @readonly\n     */\n    protected List<MavenProject> reactorProjects;\n\n    /**\n     * Used to look up Artifacts in the remote repository.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    protected RepositorySystem factory;\n\n    /**\n     * Used to look up Artifacts in the remote repository.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    protected ArtifactResolver resolver;\n    /**\n     * Location of the local repository.\n     *\n     * @parameter expression=\"${localRepository}\"\n     * @readonly\n     * @required\n     */\n    protected ArtifactRepository localRepo;\n\n    /**\n     * List of Remote Repositories used by the resolver\n     *\n     * @parameter expression=\"${project.remoteArtifactRepositories}\"\n     * @readonly\n     * @required\n     */\n    protected List<?> remoteRepos;\n\n    /**\n     * Additional dependencies/jar to add to classpath to run \"scalaClassName\" (scope and optional field not supported)\n     * ex :\n     * <pre>\n     *    &lt;dependencies>\n     *      &lt;dependency>\n     *        &lt;groupId>org.scala-tools&lt;/groupId>\n     *        &lt;artifactId>scala-compiler-addon&lt;/artifactId>\n     *        &lt;version>1.0-SNAPSHOT&lt;/version>\n     *      &lt;/dependency>\n     *    &lt;/dependencies>\n     * <\/pre>\n     * @parameter\n     */\n    protected BasicArtifact[] dependencies;\n\n    /**\n     * Compiler plugin dependencies to use when compiling.\n     * ex:\n     * @parameter\n     * <xmp>\n     * <compilerPlugins>\n     * <compilerPlugin>\n     * <groupId>my.scala.plugin<\/groupId>\n     * <artifactId>amazingPlugin<\/artifactId>\n     * <version>1.0-SNAPSHOT<\/version>\n     * <\/compilerPlugin>\n     * <\/compilerPlugins>\n     * <\/xmp>\n     */\n    protected BasicArtifact[] compilerPlugins;\n\n    /**\n     * Jvm Arguments.\n     *\n     * @parameter\n     */\n    protected String[] jvmArgs;\n\n    /**\n     * compiler additionnals arguments\n     *\n     * @parameter\n     */\n    protected String[] args;\n\n    /**\n     * Additional parameter to use to call the main class\n     * Using this parameter only from command line (\"-DaddScalacArgs=arg1|arg2|arg3|...\"), not from pom.xml.\n     * @parameter expression=\"${addScalacArgs}\"\n     */\n    protected String addScalacArgs;\n\n    /**\n     * className (FQN) of the scala tool to provide as\n     *\n     * @required\n     * @parameter expression=\"${maven.scala.className}\"\n     *            default-value=\"scala.tools.nsc.Main\"\n     */\n    protected String scalaClassName;\n\n    /**\n     * Scala 's version to use.\n     * (property 'maven.scala.version' replaced by 'scala.version')\n     *\n     * @parameter expression=\"${scala.version}\"\n     */\n    private String scalaVersion;\n\n    /**\n     * Path to Scala installation.\n     *\n     * @parameter expression=\"${scala.home}\"\n     */\n    private String scalaHome;\n\n    /**\n     * Arguments for javac (when using incremental compiler).\n     *\n     * @parameter expression=\"${javacArgs}\"\n     */\n    protected String[] javacArgs;@SuppressWarnings(\"unused\") \n\n    /**\n     * Whether to instruct javac to generate debug symbols (when using incremental compiler)\n     * @see {@link http://maven.apache.org/plugins/maven-compiler-plugin/compile-mojo.html#debug}\n     *\n     * @parameter expression=\"${javacGenerateDebugSymbols}\"\n     *            default-value=\"true\"\n     */\n    protected boolean javacGenerateDebugSymbols = true;\n\n    /**\n     * Alternative method for specifying javac arguments (when using incremental compiler).\n     * Can be used from command line with -DaddJavacArgs=arg1|arg2|arg3|... rather than in pom.xml.\n     *\n     * @parameter expression=\"${addJavacArgs}\"\n     */\n    protected String addJavacArgs;\n\n    \n    /**\n     * The -source argument for the Java compiler (when using incremental compiler).\n     *\n     * @parameter expression=\"${maven.compiler.source}\"\n     */\n    protected String source;\n    \n    /**\n     * The -target argument for the Java compiler (when using incremental compiler).\n     *\n     * @parameter expression=\"${maven.compiler.target}\"\n     */\n    protected String target;\n    \n    /**\n     * The -encoding argument for the Java compiler. (when using incremental compiler).\n     *\n     * @parameter expression=\"${project.build.sourceEncoding}\"\n     */\n    protected String encoding;\n    \n    /**\n     * Display the command line called ?\n     * (property 'maven.scala.displayCmd' replaced by 'displayCmd')\n     *\n     * @required\n     * @parameter expression=\"${displayCmd}\"\n     *            default-value=\"false\"\n     */\n    public boolean displayCmd;\n\n    /**\n     * Forks the execution of scalac into a separate process.\n     *\n     * @parameter default-value=\"true\"\n     */\n    protected boolean fork = true;\n\n    /**\n     * Force the use of an external ArgFile to run any forked process.\n     *\n     * @parameter default-value=\"false\"\n     */\n    protected boolean forceUseArgFile = false;\n\n    /**\n     * Check if every dependencies use the same version of scala-library.\n     *\n     * @parameter expression=\"${maven.scala.checkConsistency}\" default-value=\"true\"\n     */\n    protected boolean checkMultipleScalaVersions;\n\n    /**\n     * Determines if a detection of multiple scala versions in the dependencies will cause the build to fail.\n     *\n     * @parameter default-value=\"false\"\n     */\n    protected boolean failOnMultipleScalaVersions = false;\n\n    /**\n     * Should use CanonicalPath to normalize path (true => getCanonicalPath, false => getAbsolutePath)\n     * @see https://github.com/davidB/maven-scala-plugin/issues/50\n     * @parameter expression=\"${maven.scala.useCanonicalPath}\" default-value=\"true\"\n     */\n    protected boolean useCanonicalPath = true;\n\n    /**\n     * Artifact factory, needed to download source jars.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    protected MavenProjectBuilder mavenProjectBuilder;\n\n    /**\n     * The artifact repository to use.\n     *\n     * @parameter expression=\"${localRepository}\"\n     * @required\n     * @readonly\n     */\n    private ArtifactRepository localRepository;\n\n    /**\n     * The artifact factory to use.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    private ArtifactFactory artifactFactory;\n\n    /**\n     * The artifact metadata source to use.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    private ArtifactMetadataSource artifactMetadataSource;\n\n    /**\n     * The artifact collector to use.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    private ArtifactCollector artifactCollector;\n\n    /**\n     * The dependency tree builder to use.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    private DependencyTreeBuilder dependencyTreeBuilder;\n\n    /**\n     * The toolchain manager to use.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    protected ToolchainManager toolchainManager;\n\n    /** @parameter default-value=\"${plugin.artifacts}\" */\n    private List<Artifact> pluginArtifacts;\n\n    private VersionNumber _scalaVersionN;\n\n    /**\n     * This method resolves the dependency artifacts from the project.\n     *\n     * @param theProject The POM.\n     * @return resolved set of dependency artifacts.\n     *\n     * @throws ArtifactResolutionException\n     * @throws ArtifactNotFoundException\n     * @throws InvalidDependencyVersionException\n     */\n    protected Set<Artifact> resolveDependencyArtifacts(MavenProject theProject) throws Exception {\n        AndArtifactFilter filter = new AndArtifactFilter();\n        filter.add(new ScopeArtifactFilter(Artifact.SCOPE_TEST));\n        filter.add(new ArtifactFilter(){\n            public boolean include(Artifact artifact) {\n                return !artifact.isOptional();\n            }\n        });\n        //TODO follow the dependenciesManagement and override rules\n        Set<Artifact> artifacts = theProject.createArtifacts(artifactFactory, Artifact.SCOPE_RUNTIME, filter);\n        for (Artifact artifact : artifacts) {\n            resolver.resolve(artifact, remoteRepos, localRepo);\n        }\n        return artifacts;\n    }\n\n    /**\n     * This method resolves all transitive dependencies of an artifact.\n     *\n     * @param artifact the artifact used to retrieve dependencies\n     *\n     * @return resolved set of dependencies\n     *\n     * @throws ArtifactResolutionException\n     * @throws ArtifactNotFoundException\n     * @throws ProjectBuildingException\n     * @throws InvalidDependencyVersionException\n     */\n    protected Set<Artifact> resolveArtifactDependencies(Artifact artifact) throws Exception {\n        Artifact pomArtifact = factory.createArtifact(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), \"\", \"pom\");\n        MavenProject pomProject = mavenProjectBuilder.buildFromRepository(pomArtifact, remoteRepos, localRepo);\n        return resolveDependencyArtifacts(pomProject);\n    }\n\n    public void addToClasspath(String groupId, String artifactId, String version, Set<String> classpath) throws Exception {\n        addToClasspath(groupId, artifactId, version, classpath, true);\n    }\n\n\n    public void addToClasspath(String groupId, String artifactId, String version, Set<String> classpath, boolean addDependencies) throws Exception {\n        addToClasspath(factory.createArtifact(groupId, artifactId, version, Artifact.SCOPE_RUNTIME, \"jar\"), classpath, addDependencies);\n    }\n\n    /**\n     * added for classifier support.\n     * @author Christoph Radig\n     * @todo might want to merge with existing \"addToClasspath\" methods.\n     */\n    public void addToClasspath(String groupId, String artifactId, String version, String classifier, Set<String> classpath, boolean addDependencies) throws Exception {\n      Dependency d = new Dependency();\n      d.setGroupId(groupId);\n      d.setArtifactId(artifactId);\n      d.setVersion(version);\n      d.setType(\"jar\");\n      d.setClassifier(classifier);\n      d.setScope(Artifact.SCOPE_RUNTIME);\n      addToClasspath(factory.createDependencyArtifact(d), classpath, addDependencies);\n    }\n\n    protected void addToClasspath(Artifact artifact, Set<String> classpath, boolean addDependencies) throws Exception {\n        resolver.resolve(artifact, remoteRepos, localRepo);\n        classpath.add(FileUtils.pathOf(artifact.getFile(), useCanonicalPath));\n        if (addDependencies) {\n            for (Artifact dep : resolveArtifactDependencies(artifact)) {\n                addToClasspath(dep, classpath, addDependencies);\n            }\n        }\n    }\n\n    protected void addCompilerToClasspath(Set<String> classpath) throws Exception {\n      classpath.add(FileUtils.pathOf(getCompilerJar(), useCanonicalPath));\n      for (File dep : getCompilerDependencies()) {\n        classpath.add(FileUtils.pathOf(dep, useCanonicalPath));\n      }\n    }\n\n    protected void addLibraryToClasspath(Set<String> classpath) throws Exception {\n      classpath.add(FileUtils.pathOf(getLibraryJar(), useCanonicalPath));\n    }\n\n    @Override\n    public void execute() throws MojoExecutionException, MojoFailureException {\n        try {\n            String oldWay = System.getProperty(\"maven.scala.version\");\n            if (oldWay != null) {\n                getLog().warn(\"using 'maven.scala.version' is deprecated, use 'scala.version' instead\");\n                if (scalaVersion != null) {\n                    scalaVersion = oldWay;\n                }\n            }\n\n            oldWay = System.getProperty(\"maven.scala.displayCmd\");\n            if (oldWay != null) {\n                getLog().warn(\"using 'maven.scala.displayCmd' is deprecated, use 'displayCmd' instead\");\n                displayCmd = displayCmd || Boolean.parseBoolean(oldWay);\n            }\n            checkScalaVersion();\n            doExecute();\n        } catch (MojoExecutionException exc) {\n            throw exc;\n        } catch (MojoFailureException exc) {\n            throw exc;\n        } catch (RuntimeException exc) {\n            throw exc;\n        } catch (Exception exc) {\n            throw new MojoExecutionException(\"wrap: \" + exc, exc);\n        }\n    }\n\n    protected List<Dependency> getDependencies() {\n        return project.getCompileDependencies();\n    }\n\n    protected VersionNumber findScalaVersion() throws Exception {\n        if (_scalaVersionN == null) {\n            String detectedScalaVersion = scalaVersion;\n            if (StringUtils.isEmpty(detectedScalaVersion)) {\n                detectedScalaVersion = findScalaVersionFromDependencies();\n            }\n            if (StringUtils.isEmpty(detectedScalaVersion)) {\n                if (!\"pom\".equals( project.getPackaging().toLowerCase() )) {\n                    getLog().warn(\"you don't define \"+SCALA_GROUPID + \":\" + SCALA_LIBRARY_ARTIFACTID + \" as a dependency of the project\");\n                }\n                detectedScalaVersion = \"0.0.0\";\n            } else {\n                // grappy hack to retrieve the SNAPSHOT version without timestamp,...\n                // because if version is -SNAPSHOT and artifact is deploy with uniqueValue then the version\n                // get from dependency is with the timestamp and a build number (the resolved version)\n                // but scala-compiler with the same version could have different resolved version (timestamp,...)\n                boolean isSnapshot = ArtifactUtils.isSnapshot(detectedScalaVersion);\n                if (isSnapshot && !detectedScalaVersion.endsWith(\"-SNAPSHOT\")) {\n                    detectedScalaVersion = detectedScalaVersion.substring(0, detectedScalaVersion.lastIndexOf('-', detectedScalaVersion.lastIndexOf('-')-1)) + \"-SNAPSHOT\";\n                }\n            }\n            if (StringUtils.isEmpty(detectedScalaVersion)) {\n                throw new MojoFailureException(\"no scalaVersion detected or set\");\n            }\n            if (StringUtils.isNotEmpty(scalaVersion)) {\n                if (!scalaVersion.equals(detectedScalaVersion)) {\n                    getLog().warn(\"scala library version define in dependencies doesn't match the scalaVersion of the plugin\");\n                }\n                //getLog().info(\"suggestion: remove the scalaVersion from pom.xml\"); //scalaVersion could be define in a parent pom where lib is not required\n            }\n            _scalaVersionN = new VersionNumber(detectedScalaVersion);\n        }\n        return _scalaVersionN;\n    }\n\n    private String findScalaVersionFromDependencies() throws Exception {\n        return findVersionFromDependencies(SCALA_GROUPID, SCALA_LIBRARY_ARTIFACTID);\n    }\n\n    //TODO refactor to do only one scan of dependencies to find version\n    protected String findVersionFromDependencies(String groupId, String artifactId) throws Exception {\n        String version = null;\n        for (Dependency dep : getDependencies()) {\n            if (groupId.equals(dep.getGroupId()) && artifactId.equals(dep.getArtifactId())) {\n                version = dep.getVersion();\n            }\n        }\n        if (StringUtils.isEmpty(version)) {\n            List<Dependency> deps = new ArrayList<Dependency>();\n            deps.addAll(project.getModel().getDependencies());\n            if (project.getModel().getDependencyManagement() != null) {\n                deps.addAll(project.getModel().getDependencyManagement().getDependencies());\n            }\n            for (Dependency dep : deps) {\n                if (groupId.equals(dep.getGroupId()) && artifactId.equals(dep.getArtifactId())) {\n                    version = dep.getVersion();\n                }\n            }\n        }\n        return version;\n    }\n\n    protected void checkScalaVersion() throws Exception {\n        if (checkMultipleScalaVersions) {\n            checkCorrectVersionsOfScalaLibrary(findScalaVersion().toString());\n        }\n    }\n\n    /** this method checks to see if there are multiple versions of the scala library\n     * @throws Exception */\n    private void checkCorrectVersionsOfScalaLibrary(String requiredScalaVersion) throws Exception {\n        getLog().debug(\"Checking for multiple versions of scala\");\n        //TODO - Make sure we handle bad artifacts....\n        // TODO: note that filter does not get applied due to MNG-3236\n            checkArtifactForScalaVersion(requiredScalaVersion, dependencyTreeBuilder.buildDependencyTree( project, localRepository, artifactFactory,\n                    artifactMetadataSource, null, artifactCollector ));\n    }\n\n\n    /** Visits a node (and all dependencies) to see if it contains duplicate scala versions */\n    private void checkArtifactForScalaVersion(String requiredScalaVersion, DependencyNode rootNode) throws Exception {\n        final CheckScalaVersionVisitor visitor = new CheckScalaVersionVisitor(requiredScalaVersion, getLog());\n\n        CollectingDependencyNodeVisitor collectingVisitor = new CollectingDependencyNodeVisitor();\n        DependencyNodeVisitor firstPassVisitor = new FilteringDependencyNodeVisitor( collectingVisitor, createScalaDistroDependencyFilter() );\n        rootNode.accept( firstPassVisitor );\n\n        DependencyNodeFilter secondPassFilter = new AncestorOrSelfDependencyNodeFilter( collectingVisitor.getNodes() );\n        DependencyNodeVisitor filteredVisitor = new FilteringDependencyNodeVisitor( visitor, secondPassFilter );\n\n        rootNode.accept( filteredVisitor );\n\n        if(visitor.isFailed()) {\n            visitor.logScalaDependents();\n            if(failOnMultipleScalaVersions) {\n                getLog().error(\"Multiple versions of scala libraries detected!\");\n                throw new MojoFailureException(\"Multiple versions of scala libraries detected!\");\n            }\n            getLog().warn(\"Multiple versions of scala libraries detected!\");\n        }\n    }\n\n    /**\n     * @return\n     *          A filter to only extract artifacts deployed from scala distributions\n     */\n    private DependencyNodeFilter createScalaDistroDependencyFilter() {\n        List<ArtifactFilter> filters = new ArrayList<ArtifactFilter>();\n        filters.add(new ScalaDistroArtifactFilter());\n        return new AndDependencyNodeFilter(filters);\n    }\n\n\n\n    protected abstract void doExecute() throws Exception;\n\n\n    protected JavaMainCaller getScalaCommand() throws Exception {\n        JavaMainCaller cmd = getEmptyScalaCommand(scalaClassName);\n        cmd.addArgs(args);\n        if (StringUtils.isNotEmpty(addScalacArgs)) {\n          cmd.addArgs(StringUtils.split(addScalacArgs, \"|\"));\n        }\n        addCompilerPluginOptions(cmd);\n        cmd.addJvmArgs(jvmArgs);\n        return cmd;\n    }\n\n    protected JavaMainCaller getEmptyScalaCommand(String mainClass) throws Exception {\n        //TODO - Fork or not depending on configuration?\n        JavaMainCaller cmd;\n        if(fork) {\n           // scalac with args in files\n           // * works only since 2.8.0\n           // * is buggy (don't manage space in path on windows)\n            getLog().debug(\"use java command with args in file forced : \" + forceUseArgFile);\n\n            cmd = new JavaMainCallerByFork(this, mainClass, getToolClasspath(), null, null, forceUseArgFile, toolchainManager.getToolchainFromBuildContext(\"jdk\", session));\n        } else  {\n            cmd = new JavaMainCallerInProcess(this, mainClass, getToolClasspath(), null, null);\n        }\n        cmd.addJvmArgs(\"-Xbootclasspath/a:\"+ getBootClasspath());\n        return cmd;\n    }\n\n    private String getToolClasspath() throws Exception {\n        Set<String> classpath = new LinkedHashSet<String>();\n        addCompilerToClasspath(classpath);\n//        addToClasspath(SCALA_GROUPID, \"scala-decoder\", scalaVersion, classpath);\n//        addToClasspath(SCALA_GROUPID, \"scala-dbc\", scalaVersion, classpath);\n        if (dependencies != null) {\n            for(BasicArtifact artifact: dependencies) {\n                addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, classpath);\n            }\n        }\n        return MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()]));\n    }\n\n    private String getBootClasspath() throws Exception {\n        Set<String> classpath = new LinkedHashSet<String>();\n        addLibraryToClasspath(classpath);\n        return MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()]));\n    }\n\n    protected List<String> getScalaOptions() throws Exception {\n        List<String> options = new ArrayList<String>();\n        if (args != null) Collections.addAll(options, args);\n        if (StringUtils.isNotEmpty(addScalacArgs)) {\n            Collections.addAll(options, StringUtils.split(addScalacArgs, \"|\"));\n        }\n        options.addAll(getCompilerPluginOptions());\n        return options;\n    }\n\n    protected List<String> getJavacOptions() throws Exception {\n        List<String> options = new ArrayList<String>();\n        if (javacArgs != null) Collections.addAll(options, javacArgs);\n        if (StringUtils.isNotEmpty(addJavacArgs)) {\n            Collections.addAll(options, StringUtils.split(addJavacArgs, \"|\"));\n        }\n\n        // issue #116\n        if (javacGenerateDebugSymbols) {\n            options.add(\"-g\");\n        }\n        if (target != null) {\n            options.add(\"-target\");\n            options.add(target);\n        }\n        if (source != null) {\n          options.add(\"-source\");\n          options.add(source);\n        }\n        if (encoding != null) {\n          options.add(\"-encoding\");\n          options.add(encoding);\n        }\n        return options;\n    }\n\n    protected File getLibraryJar() throws Exception {\n      if (!StringUtils.isEmpty(scalaHome)) {\n        File lib = new File(scalaHome, \"lib\");\n        return new File(lib, \"scala-library.jar\");\n      }\n      return getArtifactJar(SCALA_GROUPID, SCALA_LIBRARY_ARTIFACTID, findScalaVersion().toString());\n    }\n\n    protected File getCompilerJar() throws Exception {\n      if(!StringUtils.isEmpty(scalaHome)) {\n        File lib = new File(scalaHome, \"lib\");\n        return new File(lib, \"scala-compiler.jar\");\n      }\n      return getArtifactJar(SCALA_GROUPID, SCALA_COMPILER_ARTIFACTID, findScalaVersion().toString());\n    }\n\n    protected List<File> getCompilerDependencies() throws Exception {\n      List<File> d = new ArrayList<File>();\n      if(StringUtils.isEmpty(scalaHome)) {\n        for (Artifact artifact : getAllDependencies(SCALA_GROUPID, SCALA_COMPILER_ARTIFACTID, findScalaVersion().toString())) {\n          d.add(artifact.getFile());\n        }\n      }\n      return d;\n    }\n\n    protected File getArtifactJar(String groupId, String artifactId, String version) throws Exception {\n        Artifact artifact = factory.createArtifact(groupId, artifactId, version, Artifact.SCOPE_RUNTIME, \"jar\");\n        resolver.resolve(artifact, remoteRepos, localRepo);\n        return artifact.getFile();\n    }\n\n    protected File getArtifactJar(String groupId, String artifactId, String version, String classifier) throws Exception {\n        Artifact artifact = factory.createArtifactWithClassifier(groupId, artifactId, version, \"jar\", classifier);\n        resolver.resolve(artifact, remoteRepos, localRepo);\n        return artifact.getFile();\n    }\n\n    protected Set<Artifact> getAllDependencies(String groupId, String artifactId, String version) throws Exception {\n        Set<Artifact> result = new HashSet<Artifact>();\n        Artifact pom = factory.createArtifact(groupId, artifactId, version, \"\", \"pom\");\n        MavenProject p = mavenProjectBuilder.buildFromRepository(pom, remoteRepos, localRepo);\n        Set<Artifact> d = resolveDependencyArtifacts(p);\n        result.addAll(d);\n        for (Artifact dependency : d) {\n            Set<Artifact> transitive = getAllDependencies(dependency.getGroupId(), dependency.getArtifactId(), dependency.getVersion());\n            result.addAll(transitive);\n        }\n        return result;\n    }\n\n    /**\n     * @return\n     *           This returns whether or not the scala version can support having java sent into the compiler\n     */\n    protected boolean isJavaSupportedByCompiler() throws Exception {\n        return findScalaVersion().compareTo(new VersionNumber(\"2.7.2\")) >= 0;\n    }\n\n\n    /**\n     * Adds appropriate compiler plugins to the scalac command.\n     * @param scalac\n     * @throws Exception\n     */\n    protected void addCompilerPluginOptions(JavaMainCaller scalac) throws Exception {\n        for (String option : getCompilerPluginOptions()) {\n            scalac.addArgs(option);\n        }\n    }\n\n    protected List<String> getCompilerPluginOptions() throws Exception {\n        List<String> options = new ArrayList<String>();\n        for (String plugin : getCompilerPlugins()) {\n            options.add(\"-Xplugin:\" + plugin);\n        }\n        return options;\n    }\n\n    /**\n     * Retrieves a list of paths to scala compiler plugins.\n     *\n     * @return The list of plugins\n     * @throws Exception\n     */\n    private Set<String> getCompilerPlugins() throws Exception {\n        Set<String> plugins = new HashSet<String>();\n        if (compilerPlugins != null) {\n            Set<String> ignoreClasspath = new LinkedHashSet<String>();\n            addCompilerToClasspath(ignoreClasspath);\n            addLibraryToClasspath(ignoreClasspath);\n            for (BasicArtifact artifact : compilerPlugins) {\n                getLog().info(\"compiler plugin: \" + artifact.toString());\n                // TODO - Ensure proper scala version for plugins\n                Set<String> pluginClassPath = new HashSet<String>();\n                //TODO - Pull in transitive dependencies.\n                addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, artifact.classifier, pluginClassPath, false);\n                pluginClassPath.removeAll(ignoreClasspath);\n                plugins.addAll(pluginClassPath);\n            }\n        }\n        return plugins;\n    }\n\n    protected String findVersionFromPluginArtifacts(String groupId, String artifactId) throws Exception {\n        String version = null;\n        for (Artifact art : pluginArtifacts) {\n            if (groupId.equals(art.getGroupId()) && artifactId.equals(art.getArtifactId())) {\n                version = art.getVersion();\n            }\n        }\n        return version;\n    }\n\n    protected File getPluginArtifactJar(String groupId, String artifactId, String version) throws Exception {\n        return getPluginArtifactJar(groupId, artifactId, version, null);\n    }\n\n    protected File getPluginArtifactJar(String groupId, String artifactId, String version, String classifier) throws Exception {\n        Artifact artifact = null;\n        for (Artifact art : pluginArtifacts) {\n            if (groupId.equals(art.getGroupId()) && artifactId.equals(art.getArtifactId()) && version.equals(art.getVersion())){\n            \tif ((classifier == null && art.getClassifier() == null) || (classifier != null && classifier.equals(art.getClassifier()))) {\n            \t\tartifact = art;\n            \t}\n            }\n        }\n        if (artifact == null) {\n\t    \tString msg = String.format(\"can't find artifact %s::%s::%s-%s\", groupId, artifactId, version, classifier);\n\t    \tgetLog().error(msg);\n\t    \tthrow new Exception(msg);\n        }\n        return artifact.getFile();\n    }\n}\n","Method after Refactoring":"package scala_maven;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.artifact.ArtifactUtils;\nimport org.apache.maven.artifact.factory.ArtifactFactory;\nimport org.apache.maven.artifact.metadata.ArtifactMetadataSource;\nimport org.apache.maven.artifact.repository.ArtifactRepository;\nimport org.apache.maven.artifact.resolver.ArtifactCollector;\nimport org.apache.maven.artifact.resolver.ArtifactNotFoundException;\nimport org.apache.maven.artifact.resolver.ArtifactResolutionException;\nimport org.apache.maven.artifact.resolver.ArtifactResolver;\nimport org.apache.maven.artifact.resolver.filter.AndArtifactFilter;\nimport org.apache.maven.artifact.resolver.filter.ArtifactFilter;\nimport org.apache.maven.artifact.resolver.filter.ScopeArtifactFilter;\nimport org.apache.maven.artifact.versioning.VersionRange;\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.model.Dependency;\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugin.MojoFailureException;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.project.MavenProjectBuilder;\nimport org.apache.maven.project.ProjectBuildingException;\nimport org.apache.maven.project.artifact.InvalidDependencyVersionException;\nimport org.apache.maven.repository.RepositorySystem;\nimport org.apache.maven.shared.dependency.tree.DependencyNode;\nimport org.apache.maven.shared.dependency.tree.DependencyTreeBuilder;\nimport org.apache.maven.shared.dependency.tree.filter.AncestorOrSelfDependencyNodeFilter;\nimport org.apache.maven.shared.dependency.tree.filter.AndDependencyNodeFilter;\nimport org.apache.maven.shared.dependency.tree.filter.DependencyNodeFilter;\nimport org.apache.maven.shared.dependency.tree.traversal.CollectingDependencyNodeVisitor;\nimport org.apache.maven.shared.dependency.tree.traversal.DependencyNodeVisitor;\nimport org.apache.maven.shared.dependency.tree.traversal.FilteringDependencyNodeVisitor;\nimport org.apache.maven.toolchain.ToolchainManager;\nimport org.codehaus.plexus.util.StringUtils;\nimport scala_maven_dependency.CheckScalaVersionVisitor;\nimport scala_maven_dependency.ScalaDistroArtifactFilter;\nimport scala_maven_executions.JavaMainCaller;\nimport scala_maven_executions.JavaMainCallerByFork;\nimport scala_maven_executions.JavaMainCallerInProcess;\nimport scala_maven_executions.MainHelper;\n\npublic abstract class ScalaMojoSupport extends AbstractMojo {\n\n    public static final String SCALA_GROUPID= \"org.scala-lang\";\n    public static final String SCALA_LIBRARY_ARTIFACTID= \"scala-library\";\n    public static final String SCALA_COMPILER_ARTIFACTID= \"scala-compiler\";\n    \n    /**\n     * @parameter expression=\"${project}\"\n     * @required\n     * @readonly\n     */\n    protected MavenProject project;\n\n    /**\n     * The Maven Session Object\n     *\n     * @parameter expression=\"${session}\"\n     * @required\n     * @readonly\n     */\n    protected MavenSession session;\n\n    /**\n     * Contains the full list of projects in the reactor.\n     *\n     * @parameter default-value=\"${reactorProjects}\"\n     * @required\n     * @readonly\n     */\n    protected List<MavenProject> reactorProjects;\n\n    /**\n     * Used to look up Artifacts in the remote repository.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    protected RepositorySystem factory;\n\n    /**\n     * Used to look up Artifacts in the remote repository.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    protected ArtifactResolver resolver;\n    /**\n     * Location of the local repository.\n     *\n     * @parameter expression=\"${localRepository}\"\n     * @readonly\n     * @required\n     */\n    protected ArtifactRepository localRepo;\n\n    /**\n     * List of Remote Repositories used by the resolver\n     *\n     * @parameter expression=\"${project.remoteArtifactRepositories}\"\n     * @readonly\n     * @required\n     */\n    protected List<?> remoteRepos;\n\n    /**\n     * Additional dependencies/jar to add to classpath to run \"scalaClassName\" (scope and optional field not supported)\n     * ex :\n     * <pre>\n     *    &lt;dependencies>\n     *      &lt;dependency>\n     *        &lt;groupId>org.scala-tools&lt;/groupId>\n     *        &lt;artifactId>scala-compiler-addon&lt;/artifactId>\n     *        &lt;version>1.0-SNAPSHOT&lt;/version>\n     *      &lt;/dependency>\n     *    &lt;/dependencies>\n     * <\/pre>\n     * @parameter\n     */\n    protected BasicArtifact[] dependencies;\n\n    /**\n     * Compiler plugin dependencies to use when compiling.\n     * ex:\n     * @parameter\n     * <xmp>\n     * <compilerPlugins>\n     * <compilerPlugin>\n     * <groupId>my.scala.plugin<\/groupId>\n     * <artifactId>amazingPlugin<\/artifactId>\n     * <version>1.0-SNAPSHOT<\/version>\n     * <\/compilerPlugin>\n     * <\/compilerPlugins>\n     * <\/xmp>\n     */\n    protected BasicArtifact[] compilerPlugins;\n\n    /**\n     * Jvm Arguments.\n     *\n     * @parameter\n     */\n    protected String[] jvmArgs;\n\n    /**\n     * compiler additionnals arguments\n     *\n     * @parameter\n     */\n    protected String[] args;\n\n    /**\n     * Additional parameter to use to call the main class\n     * Using this parameter only from command line (\"-DaddScalacArgs=arg1|arg2|arg3|...\"), not from pom.xml.\n     * @parameter expression=\"${addScalacArgs}\"\n     */\n    protected String addScalacArgs;\n\n    /**\n     * className (FQN) of the scala tool to provide as\n     *\n     * @required\n     * @parameter expression=\"${maven.scala.className}\"\n     *            default-value=\"scala.tools.nsc.Main\"\n     */\n    protected String scalaClassName;\n\n    /**\n     * Scala 's version to use.\n     * (property 'maven.scala.version' replaced by 'scala.version')\n     *\n     * @parameter expression=\"${scala.version}\"\n     */\n    private String scalaVersion;\n\n    /**\n     * Path to Scala installation to use instead of the artifact (define as dependencies).\n     *\n     * @parameter expression=\"${scala.home}\"\n     */\n    private String scalaHome;\n\n    /**\n     * Arguments for javac (when using incremental compiler).\n     *\n     * @parameter expression=\"${javacArgs}\"\n     */\n    protected String[] javacArgs;@SuppressWarnings(\"unused\") \n\n    /**\n     * Whether to instruct javac to generate debug symbols (when using incremental compiler)\n     * @see {@link http://maven.apache.org/plugins/maven-compiler-plugin/compile-mojo.html#debug}\n     *\n     * @parameter expression=\"${javacGenerateDebugSymbols}\"\n     *            default-value=\"true\"\n     */\n    protected boolean javacGenerateDebugSymbols = true;\n\n    /**\n     * Alternative method for specifying javac arguments (when using incremental compiler).\n     * Can be used from command line with -DaddJavacArgs=arg1|arg2|arg3|... rather than in pom.xml.\n     *\n     * @parameter expression=\"${addJavacArgs}\"\n     */\n    protected String addJavacArgs;\n\n    \n    /**\n     * The -source argument for the Java compiler (when using incremental compiler).\n     *\n     * @parameter expression=\"${maven.compiler.source}\"\n     */\n    protected String source;\n    \n    /**\n     * The -target argument for the Java compiler (when using incremental compiler).\n     *\n     * @parameter expression=\"${maven.compiler.target}\"\n     */\n    protected String target;\n    \n    /**\n     * The -encoding argument for the Java compiler. (when using incremental compiler).\n     *\n     * @parameter expression=\"${project.build.sourceEncoding}\"\n     */\n    protected String encoding;\n    \n    /**\n     * Display the command line called ?\n     * (property 'maven.scala.displayCmd' replaced by 'displayCmd')\n     *\n     * @required\n     * @parameter expression=\"${displayCmd}\"\n     *            default-value=\"false\"\n     */\n    public boolean displayCmd;\n\n    /**\n     * Forks the execution of scalac into a separate process.\n     *\n     * @parameter default-value=\"true\"\n     */\n    protected boolean fork = true;\n\n    /**\n     * Force the use of an external ArgFile to run any forked process.\n     *\n     * @parameter default-value=\"false\"\n     */\n    protected boolean forceUseArgFile = false;\n\n    /**\n     * Check if every dependencies use the same version of scala-library.\n     *\n     * @parameter expression=\"${maven.scala.checkConsistency}\" default-value=\"true\"\n     */\n    protected boolean checkMultipleScalaVersions;\n\n    /**\n     * Determines if a detection of multiple scala versions in the dependencies will cause the build to fail.\n     *\n     * @parameter default-value=\"false\"\n     */\n    protected boolean failOnMultipleScalaVersions = false;\n\n    /**\n     * Should use CanonicalPath to normalize path (true => getCanonicalPath, false => getAbsolutePath)\n     * @see https://github.com/davidB/maven-scala-plugin/issues/50\n     * @parameter expression=\"${maven.scala.useCanonicalPath}\" default-value=\"true\"\n     */\n    protected boolean useCanonicalPath = true;\n\n    /**\n     * Artifact factory, needed to download source jars.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    protected MavenProjectBuilder mavenProjectBuilder;\n\n    /**\n     * The artifact repository to use.\n     *\n     * @parameter expression=\"${localRepository}\"\n     * @required\n     * @readonly\n     */\n    private ArtifactRepository localRepository;\n\n    /**\n     * The artifact factory to use.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    private ArtifactFactory artifactFactory;\n\n    /**\n     * The artifact metadata source to use.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    private ArtifactMetadataSource artifactMetadataSource;\n\n    /**\n     * The artifact collector to use.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    private ArtifactCollector artifactCollector;\n\n    /**\n     * The dependency tree builder to use.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    private DependencyTreeBuilder dependencyTreeBuilder;\n\n    /**\n     * The toolchain manager to use.\n     *\n     * @component\n     * @required\n     * @readonly\n     */\n    protected ToolchainManager toolchainManager;\n\n    /** @parameter default-value=\"${plugin.artifacts}\" */\n    private List<Artifact> pluginArtifacts;\n\n    private VersionNumber _scalaVersionN;\n\n    /**\n     * This method resolves the dependency artifacts from the project.\n     *\n     * @param theProject The POM.\n     * @return resolved set of dependency artifacts.\n     *\n     * @throws ArtifactResolutionException\n     * @throws ArtifactNotFoundException\n     * @throws InvalidDependencyVersionException\n     */\n    protected Set<Artifact> resolveDependencyArtifacts(MavenProject theProject) throws Exception {\n        AndArtifactFilter filter = new AndArtifactFilter();\n        filter.add(new ScopeArtifactFilter(Artifact.SCOPE_TEST));\n        filter.add(new ArtifactFilter(){\n            public boolean include(Artifact artifact) {\n                return !artifact.isOptional();\n            }\n        });\n        //TODO follow the dependenciesManagement and override rules\n        Set<Artifact> artifacts = theProject.createArtifacts(artifactFactory, Artifact.SCOPE_RUNTIME, filter);\n        for (Artifact artifact : artifacts) {\n            resolver.resolve(artifact, remoteRepos, localRepo);\n        }\n        return artifacts;\n    }\n\n    /**\n     * This method resolves all transitive dependencies of an artifact.\n     *\n     * @param artifact the artifact used to retrieve dependencies\n     *\n     * @return resolved set of dependencies\n     *\n     * @throws ArtifactResolutionException\n     * @throws ArtifactNotFoundException\n     * @throws ProjectBuildingException\n     * @throws InvalidDependencyVersionException\n     */\n    protected Set<Artifact> resolveArtifactDependencies(Artifact artifact) throws Exception {\n        Artifact pomArtifact = factory.createArtifact(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), \"\", \"pom\");\n        MavenProject pomProject = mavenProjectBuilder.buildFromRepository(pomArtifact, remoteRepos, localRepo);\n        return resolveDependencyArtifacts(pomProject);\n    }\n\n    public void addToClasspath(String groupId, String artifactId, String version, Set<String> classpath) throws Exception {\n        addToClasspath(groupId, artifactId, version, classpath, true);\n    }\n\n\n    public void addToClasspath(String groupId, String artifactId, String version, Set<String> classpath, boolean addDependencies) throws Exception {\n        addToClasspath(factory.createArtifact(groupId, artifactId, version, Artifact.SCOPE_RUNTIME, \"jar\"), classpath, addDependencies);\n    }\n\n    /**\n     * added for classifier support.\n     * @author Christoph Radig\n     * @todo might want to merge with existing \"addToClasspath\" methods.\n     */\n    public void addToClasspath(String groupId, String artifactId, String version, String classifier, Set<String> classpath, boolean addDependencies) throws Exception {\n      Dependency d = new Dependency();\n      d.setGroupId(groupId);\n      d.setArtifactId(artifactId);\n      d.setVersion(version);\n      d.setType(\"jar\");\n      d.setClassifier(classifier);\n      d.setScope(Artifact.SCOPE_RUNTIME);\n      addToClasspath(factory.createDependencyArtifact(d), classpath, addDependencies);\n    }\n\n    protected void addToClasspath(Artifact artifact, Set<String> classpath, boolean addDependencies) throws Exception {\n        resolver.resolve(artifact, remoteRepos, localRepo);\n        classpath.add(FileUtils.pathOf(artifact.getFile(), useCanonicalPath));\n        if (addDependencies) {\n            for (Artifact dep : resolveArtifactDependencies(artifact)) {\n                addToClasspath(dep, classpath, addDependencies);\n            }\n        }\n    }\n\n    protected void addCompilerToClasspath(Set<String> classpath) throws Exception {\n      classpath.add(FileUtils.pathOf(getCompilerJar(), useCanonicalPath));\n      for (File dep : getCompilerDependencies()) {\n        classpath.add(FileUtils.pathOf(dep, useCanonicalPath));\n      }\n    }\n\n    protected void addLibraryToClasspath(Set<String> classpath) throws Exception {\n      classpath.add(FileUtils.pathOf(getLibraryJar(), useCanonicalPath));\n    }\n\n    @Override\n    public void execute() throws MojoExecutionException, MojoFailureException {\n        try {\n            String oldWay = System.getProperty(\"maven.scala.version\");\n            if (oldWay != null) {\n                getLog().warn(\"using 'maven.scala.version' is deprecated, use 'scala.version' instead\");\n                if (scalaVersion != null) {\n                    scalaVersion = oldWay;\n                }\n            }\n\n            oldWay = System.getProperty(\"maven.scala.displayCmd\");\n            if (oldWay != null) {\n                getLog().warn(\"using 'maven.scala.displayCmd' is deprecated, use 'displayCmd' instead\");\n                displayCmd = displayCmd || Boolean.parseBoolean(oldWay);\n            }\n            checkScalaVersion();\n            doExecute();\n        } catch (MojoExecutionException exc) {\n            throw exc;\n        } catch (MojoFailureException exc) {\n            throw exc;\n        } catch (RuntimeException exc) {\n            throw exc;\n        } catch (Exception exc) {\n            throw new MojoExecutionException(\"wrap: \" + exc, exc);\n        }\n    }\n\n    protected List<Dependency> getDependencies() {\n        return project.getCompileDependencies();\n    }\n\n    protected VersionNumber findScalaVersion() throws Exception {\n        if (_scalaVersionN == null) {\n            String detectedScalaVersion = scalaVersion;\n            if (StringUtils.isEmpty(detectedScalaVersion)) {\n                detectedScalaVersion = findScalaVersionFromDependencies();\n            }\n            if (StringUtils.isEmpty(detectedScalaVersion)) {\n                if (!\"pom\".equals( project.getPackaging().toLowerCase() )) {\n                    getLog().warn(\"you don't define \"+SCALA_GROUPID + \":\" + SCALA_LIBRARY_ARTIFACTID + \" as a dependency of the project\");\n                }\n                detectedScalaVersion = \"0.0.0\";\n            } else {\n                // grappy hack to retrieve the SNAPSHOT version without timestamp,...\n                // because if version is -SNAPSHOT and artifact is deploy with uniqueValue then the version\n                // get from dependency is with the timestamp and a build number (the resolved version)\n                // but scala-compiler with the same version could have different resolved version (timestamp,...)\n                boolean isSnapshot = ArtifactUtils.isSnapshot(detectedScalaVersion);\n                if (isSnapshot && !detectedScalaVersion.endsWith(\"-SNAPSHOT\")) {\n                    detectedScalaVersion = detectedScalaVersion.substring(0, detectedScalaVersion.lastIndexOf('-', detectedScalaVersion.lastIndexOf('-')-1)) + \"-SNAPSHOT\";\n                }\n            }\n            if (StringUtils.isEmpty(detectedScalaVersion)) {\n                throw new MojoFailureException(\"no scalaVersion detected or set\");\n            }\n            if (StringUtils.isNotEmpty(scalaVersion)) {\n                if (!scalaVersion.equals(detectedScalaVersion)) {\n                    getLog().warn(\"scala library version define in dependencies doesn't match the scalaVersion of the plugin\");\n                }\n                //getLog().info(\"suggestion: remove the scalaVersion from pom.xml\"); //scalaVersion could be define in a parent pom where lib is not required\n            }\n            _scalaVersionN = new VersionNumber(detectedScalaVersion);\n        }\n        return _scalaVersionN;\n    }\n\n    private String findScalaVersionFromDependencies() throws Exception {\n        return findVersionFromDependencies(SCALA_GROUPID, SCALA_LIBRARY_ARTIFACTID);\n    }\n\n    //TODO refactor to do only one scan of dependencies to find version\n    protected String findVersionFromDependencies(String groupId, String artifactId) throws Exception {\n        String version = null;\n        for (Dependency dep : getDependencies()) {\n            if (groupId.equals(dep.getGroupId()) && artifactId.equals(dep.getArtifactId())) {\n                version = dep.getVersion();\n            }\n        }\n        if (StringUtils.isEmpty(version)) {\n            List<Dependency> deps = new ArrayList<Dependency>();\n            deps.addAll(project.getModel().getDependencies());\n            if (project.getModel().getDependencyManagement() != null) {\n                deps.addAll(project.getModel().getDependencyManagement().getDependencies());\n            }\n            for (Dependency dep : deps) {\n                if (groupId.equals(dep.getGroupId()) && artifactId.equals(dep.getArtifactId())) {\n                    version = dep.getVersion();\n                }\n            }\n        }\n        return version;\n    }\n\n    protected void checkScalaVersion() throws Exception {\n        String sv = findScalaVersion().toString();\n        if (StringUtils.isNotEmpty(scalaHome)) {\n            getLog().warn(String.format(\"local scala-library.jar and scala-compiler.jar from scalaHome(%s) used instead of scala %s\", scalaHome, sv));\n        }\n        if (checkMultipleScalaVersions) {\n            checkCorrectVersionsOfScalaLibrary(sv);\n        }\n    }\n\n    /** this method checks to see if there are multiple versions of the scala library\n     * @throws Exception */\n    private void checkCorrectVersionsOfScalaLibrary(String requiredScalaVersion) throws Exception {\n        getLog().debug(\"Checking for multiple versions of scala\");\n        //TODO - Make sure we handle bad artifacts....\n        // TODO: note that filter does not get applied due to MNG-3236\n            checkArtifactForScalaVersion(requiredScalaVersion, dependencyTreeBuilder.buildDependencyTree( project, localRepository, artifactFactory,\n                    artifactMetadataSource, null, artifactCollector ));\n    }\n\n\n    /** Visits a node (and all dependencies) to see if it contains duplicate scala versions */\n    private void checkArtifactForScalaVersion(String requiredScalaVersion, DependencyNode rootNode) throws Exception {\n        final CheckScalaVersionVisitor visitor = new CheckScalaVersionVisitor(requiredScalaVersion, getLog());\n\n        CollectingDependencyNodeVisitor collectingVisitor = new CollectingDependencyNodeVisitor();\n        DependencyNodeVisitor firstPassVisitor = new FilteringDependencyNodeVisitor( collectingVisitor, createScalaDistroDependencyFilter() );\n        rootNode.accept( firstPassVisitor );\n\n        DependencyNodeFilter secondPassFilter = new AncestorOrSelfDependencyNodeFilter( collectingVisitor.getNodes() );\n        DependencyNodeVisitor filteredVisitor = new FilteringDependencyNodeVisitor( visitor, secondPassFilter );\n\n        rootNode.accept( filteredVisitor );\n\n        if(visitor.isFailed()) {\n            visitor.logScalaDependents();\n            if(failOnMultipleScalaVersions) {\n                getLog().error(\"Multiple versions of scala libraries detected!\");\n                throw new MojoFailureException(\"Multiple versions of scala libraries detected!\");\n            }\n            getLog().warn(\"Multiple versions of scala libraries detected!\");\n        }\n    }\n\n    /**\n     * @return\n     *          A filter to only extract artifacts deployed from scala distributions\n     */\n    private DependencyNodeFilter createScalaDistroDependencyFilter() {\n        List<ArtifactFilter> filters = new ArrayList<ArtifactFilter>();\n        filters.add(new ScalaDistroArtifactFilter());\n        return new AndDependencyNodeFilter(filters);\n    }\n\n\n\n    protected abstract void doExecute() throws Exception;\n\n\n    protected JavaMainCaller getScalaCommand() throws Exception {\n        JavaMainCaller cmd = getEmptyScalaCommand(scalaClassName);\n        cmd.addArgs(args);\n        if (StringUtils.isNotEmpty(addScalacArgs)) {\n          cmd.addArgs(StringUtils.split(addScalacArgs, \"|\"));\n        }\n        addCompilerPluginOptions(cmd);\n        cmd.addJvmArgs(jvmArgs);\n        return cmd;\n    }\n\n    protected JavaMainCaller getEmptyScalaCommand(String mainClass) throws Exception {\n        //TODO - Fork or not depending on configuration?\n        JavaMainCaller cmd;\n        if(fork) {\n           // scalac with args in files\n           // * works only since 2.8.0\n           // * is buggy (don't manage space in path on windows)\n            getLog().debug(\"use java command with args in file forced : \" + forceUseArgFile);\n\n            cmd = new JavaMainCallerByFork(this, mainClass, getToolClasspath(), null, null, forceUseArgFile, toolchainManager.getToolchainFromBuildContext(\"jdk\", session));\n        } else  {\n            cmd = new JavaMainCallerInProcess(this, mainClass, getToolClasspath(), null, null);\n        }\n        cmd.addJvmArgs(\"-Xbootclasspath/a:\"+ getBootClasspath());\n        return cmd;\n    }\n\n    private String getToolClasspath() throws Exception {\n        Set<String> classpath = new LinkedHashSet<String>();\n        addCompilerToClasspath(classpath);\n//        addToClasspath(SCALA_GROUPID, \"scala-decoder\", scalaVersion, classpath);\n//        addToClasspath(SCALA_GROUPID, \"scala-dbc\", scalaVersion, classpath);\n        if (dependencies != null) {\n            for(BasicArtifact artifact: dependencies) {\n                addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, classpath);\n            }\n        }\n        return MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()]));\n    }\n\n    private String getBootClasspath() throws Exception {\n        Set<String> classpath = new LinkedHashSet<String>();\n        addLibraryToClasspath(classpath);\n        return MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()]));\n    }\n\n    protected List<String> getScalaOptions() throws Exception {\n        List<String> options = new ArrayList<String>();\n        if (args != null) Collections.addAll(options, args);\n        if (StringUtils.isNotEmpty(addScalacArgs)) {\n            Collections.addAll(options, StringUtils.split(addScalacArgs, \"|\"));\n        }\n        options.addAll(getCompilerPluginOptions());\n        return options;\n    }\n\n    protected List<String> getJavacOptions() throws Exception {\n        List<String> options = new ArrayList<String>();\n        if (javacArgs != null) Collections.addAll(options, javacArgs);\n        if (StringUtils.isNotEmpty(addJavacArgs)) {\n            Collections.addAll(options, StringUtils.split(addJavacArgs, \"|\"));\n        }\n\n        // issue #116\n        if (javacGenerateDebugSymbols) {\n            options.add(\"-g\");\n        }\n        if (target != null) {\n            options.add(\"-target\");\n            options.add(target);\n        }\n        if (source != null) {\n          options.add(\"-source\");\n          options.add(source);\n        }\n        if (encoding != null) {\n          options.add(\"-encoding\");\n          options.add(encoding);\n        }\n        return options;\n    }\n\n    protected File getLibraryJar() throws Exception {\n      if (!StringUtils.isEmpty(scalaHome)) {\n        File lib = new File(scalaHome, \"lib\");\n        return new File(lib, \"scala-library.jar\");\n      }\n      return getArtifactJar(SCALA_GROUPID, SCALA_LIBRARY_ARTIFACTID, findScalaVersion().toString());\n    }\n\n    protected File getCompilerJar() throws Exception {\n      if(!StringUtils.isEmpty(scalaHome)) {\n        File lib = new File(scalaHome, \"lib\");\n        return new File(lib, \"scala-compiler.jar\");\n      }\n      return getArtifactJar(SCALA_GROUPID, SCALA_COMPILER_ARTIFACTID, findScalaVersion().toString());\n    }\n\n    protected List<File> getCompilerDependencies() throws Exception {\n      List<File> d = new ArrayList<File>();\n      if(StringUtils.isEmpty(scalaHome)) {\n        for (Artifact artifact : getAllDependencies(SCALA_GROUPID, SCALA_COMPILER_ARTIFACTID, findScalaVersion().toString())) {\n          d.add(artifact.getFile());\n        }\n      }\n      return d;\n    }\n\n    protected File getArtifactJar(String groupId, String artifactId, String version) throws Exception {\n        Artifact artifact = factory.createArtifact(groupId, artifactId, version, Artifact.SCOPE_RUNTIME, \"jar\");\n        resolver.resolve(artifact, remoteRepos, localRepo);\n        return artifact.getFile();\n    }\n\n    protected File getArtifactJar(String groupId, String artifactId, String version, String classifier) throws Exception {\n        Artifact artifact = factory.createArtifactWithClassifier(groupId, artifactId, version, \"jar\", classifier);\n        resolver.resolve(artifact, remoteRepos, localRepo);\n        return artifact.getFile();\n    }\n\n    protected Set<Artifact> getAllDependencies(String groupId, String artifactId, String version) throws Exception {\n        Set<Artifact> result = new HashSet<Artifact>();\n        Artifact pom = factory.createArtifact(groupId, artifactId, version, \"\", \"pom\");\n        MavenProject p = mavenProjectBuilder.buildFromRepository(pom, remoteRepos, localRepo);\n        Set<Artifact> d = resolveDependencyArtifacts(p);\n        result.addAll(d);\n        for (Artifact dependency : d) {\n            Set<Artifact> transitive = getAllDependencies(dependency.getGroupId(), dependency.getArtifactId(), dependency.getVersion());\n            result.addAll(transitive);\n        }\n        return result;\n    }\n\n    /**\n     * @return\n     *           This returns whether or not the scala version can support having java sent into the compiler\n     */\n    protected boolean isJavaSupportedByCompiler() throws Exception {\n        return findScalaVersion().compareTo(new VersionNumber(\"2.7.2\")) >= 0;\n    }\n\n\n    /**\n     * Adds appropriate compiler plugins to the scalac command.\n     * @param scalac\n     * @throws Exception\n     */\n    protected void addCompilerPluginOptions(JavaMainCaller scalac) throws Exception {\n        for (String option : getCompilerPluginOptions()) {\n            scalac.addArgs(option);\n        }\n    }\n\n    protected List<String> getCompilerPluginOptions() throws Exception {\n        List<String> options = new ArrayList<String>();\n        for (String plugin : getCompilerPlugins()) {\n            options.add(\"-Xplugin:\" + plugin);\n        }\n        return options;\n    }\n\n    /**\n     * Retrieves a list of paths to scala compiler plugins.\n     *\n     * @return The list of plugins\n     * @throws Exception\n     */\n    private Set<String> getCompilerPlugins() throws Exception {\n        Set<String> plugins = new HashSet<String>();\n        if (compilerPlugins != null) {\n            Set<String> ignoreClasspath = new LinkedHashSet<String>();\n            addCompilerToClasspath(ignoreClasspath);\n            addLibraryToClasspath(ignoreClasspath);\n            for (BasicArtifact artifact : compilerPlugins) {\n                getLog().info(\"compiler plugin: \" + artifact.toString());\n                // TODO - Ensure proper scala version for plugins\n                Set<String> pluginClassPath = new HashSet<String>();\n                //TODO - Pull in transitive dependencies.\n                addToClasspath(artifact.groupId, artifact.artifactId, artifact.version, artifact.classifier, pluginClassPath, false);\n                pluginClassPath.removeAll(ignoreClasspath);\n                plugins.addAll(pluginClassPath);\n            }\n        }\n        return plugins;\n    }\n\n    protected String findVersionFromPluginArtifacts(String groupId, String artifactId) throws Exception {\n        String version = null;\n        for (Artifact art : pluginArtifacts) {\n            if (groupId.equals(art.getGroupId()) && artifactId.equals(art.getArtifactId())) {\n                version = art.getVersion();\n            }\n        }\n        return version;\n    }\n\n    protected File getPluginArtifactJar(String groupId, String artifactId, String version) throws Exception {\n        return getPluginArtifactJar(groupId, artifactId, version, null);\n    }\n\n    protected File getPluginArtifactJar(String groupId, String artifactId, String version, String classifier) throws Exception {\n        Artifact artifact = null;\n        for (Artifact art : pluginArtifacts) {\n            if (groupId.equals(art.getGroupId()) && artifactId.equals(art.getArtifactId()) && version.equals(art.getVersion())){\n            \tif ((classifier == null && art.getClassifier() == null) || (classifier != null && classifier.equals(art.getClassifier()))) {\n            \t\tartifact = art;\n            \t}\n            }\n        }\n        if (artifact == null) {\n\t    \tString msg = String.format(\"can't find artifact %s::%s::%s-%s\", groupId, artifactId, version, classifier);\n\t    \tgetLog().error(msg);\n\t    \tthrow new Exception(msg);\n        }\n        return artifact.getFile();\n    }\n}\n","lineNo":540}
{"Smelly Sample":" package scala_maven;\n\nimport java.io.File;\nimport java.util.List;\n\nimport org.apache.maven.model.Dependency;\n\n/**\n * Compiles a directory of Scala source. Corresponds roughly to the compile goal\n * of the maven-compiler-plugin\n *\n * @phase compile\n * @goal compile\n * @requiresDependencyResolution compile\n * @threadSafe\n */\npublic class ScalaCompileMojo extends ScalaCompilerSupport {\n\n    /**\n     * The directory in which to place compilation output\n     *\n     * @parameter expression=\"${project.build.outputDirectory}\"\n     */\n    protected File outputDir;\n\n    /**\n     * The directory which contains scala/java source files\n     *\n     * @parameter expression=\"${project.build.sourceDirectory}/../scala\"\n     */\n    protected File sourceDir;\n    \n    @Override\n    @SuppressWarnings(\"unchecked\")\n    protected List<File> getSourceDirectories() throws Exception {\n        List<String> sources = project.getCompileSourceRoots();\n        //Quick fix in case the user has not added the \"add-source\" goal.\n        String scalaSourceDir = FileUtils.pathOf(sourceDir, useCanonicalPath);\n        if(!sources.contains(scalaSourceDir)) {\n            sources.add(scalaSourceDir);\n        }\n        return normalize(sources);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    protected List<String> getClasspathElements() throws Exception {\n        return TychoUtilities.addOsgiClasspathElements(project, project.getCompileClasspathElements());\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    protected List<Dependency> getDependencies() {\n        return project.getCompileDependencies();\n    }\n\n    @Override\n    protected File getOutputDir() throws Exception {\n        return outputDir.getAbsoluteFile();\n    }\n}\n","Method after Refactoring":" package scala_maven;\n\nimport java.io.File;\nimport java.util.List;\n\nimport org.apache.maven.model.Dependency;\n\n/**\n * Compiles a directory of Scala source. Corresponds roughly to the compile goal\n * of the maven-compiler-plugin\n *\n * @phase compile\n * @goal compile\n * @requiresDependencyResolution compile\n * @threadSafe\n */\npublic class ScalaCompileMojo extends ScalaCompilerSupport {\n\n    /**\n     * The directory in which to place compilation output\n     *\n     * @parameter expression=\"${project.build.outputDirectory}\"\n     */\n    protected File outputDir;\n\n    /**\n     * The directory which contains scala/java source files\n     *\n     * @parameter expression=\"${project.build.sourceDirectory}/../scala\"\n     */\n    protected File sourceDir;\n    \n    @Override\n    @SuppressWarnings(\"unchecked\")\n    protected List<File> getSourceDirectories() throws Exception {\n        List<String> sources = project.getCompileSourceRoots();\n        //Quick fix in case the user has not added the \"add-source\" goal.\n        String scalaSourceDir = FileUtils.pathOf(sourceDir, useCanonicalPath);\n        if(!sources.contains(scalaSourceDir)) {\n            sources.add(scalaSourceDir);\n        }\n        return normalize(sources);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    protected List<String> getClasspathElements() throws Exception {\n        List<String> back = project.getCompileClasspathElements();\n        back.remove(project.getBuild().getOutputDirectory());\n        back.add(getOutputDir().getAbsolutePath());\n        back = TychoUtilities.addOsgiClasspathElements(project, back);\n        return back;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    protected List<Dependency> getDependencies() {\n        return project.getCompileDependencies();\n    }\n\n    @Override\n    protected File getOutputDir() throws Exception {\n        return outputDir.getAbsoluteFile();\n    }\n}\n","lineNo":48}
{"Smelly Sample":"/*\n * Copyright 2007 scala-tools.org\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions\n * and limitations under the License.\n */\npackage org_scala_tools_maven;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport org_scala_tools_maven_executions.JavaMainCaller;\nimport org_scala_tools_maven_executions.JavaMainCallerInProcess;\nimport org_scala_tools_maven_executions.MainHelper;\n\n/**\n * Run the Scala console with all the classes of the projects (dependencies and builded)\n *\n * @goal console\n * @requiresDependencyResolution test\n * @inheritByDefault false\n * @requiresDirectInvocation true\n * @executionStrategy once-per-session\n */\npublic class ScalaConsoleMojo extends ScalaMojoSupport {\n\n    /**\n     * The console to run.\n     *\n     * @parameter expression=\"${mainConsole}\" default-value=\"scala.tools.nsc.MainGenericRunner\"\n     * @required\n     */\n    protected String mainConsole;\n\n    /**\n     * Add the test classpath (include classes from test directory), to the console's classpath ?\n     *\n     * @parameter expression=\"${maven.scala.console.useTestClasspath}\" default-value=\"true\"\n     * @required\n     */\n    protected boolean useTestClasspath;\n\n    /**\n     * Add the runtime classpath, to the console's classpath ?\n     *\n     * @parameter expression=\"${maven.scala.console.useRuntimeClasspath}\" default-value=\"true\"\n     * @required\n     */\n    protected boolean useRuntimeClasspath;\n\n    /**\n     * Path of the javaRebel jar. If this option is set then the console run\n     * with <a href=\"http://www.zeroturnaround.com/javarebel/\">javarebel<\/a> enabled.\n     *\n     * @parameter expression=\"${javarebel.jar.path}\"\n     */\n    protected File javaRebelPath;\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    protected void doExecute() throws Exception {\n        //TODO - Many other paths uses the getScalaCommand()!!! We should try to use that as much as possibel to help maintainability.\n        String sv = findScalaVersion().toString();\n        Set<String> classpath = new HashSet<String>();\n        addToClasspath(\"org.scala-lang\", \"scala-compiler\", sv, classpath);\n        addToClasspath(\"org.scala-lang\", \"scala-library\", sv, classpath);\n        addToClasspath(\"jline\", \"jline\", \"0.9.94\", classpath);\n        classpath.addAll(project.getCompileClasspathElements());\n        if (useTestClasspath) {\n            classpath.addAll(project.getTestClasspathElements());\n        }\n        if (useRuntimeClasspath) {\n            classpath.addAll(project.getRuntimeClasspathElements());\n        }\n        String classpathStr = MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()]));\n        JavaMainCaller jcmd = null;\n        List<String> list = new ArrayList<String>(args != null ? args.length + 3 : 3);\n        if(args != null) {\n            for(String arg : args) {\n                list.add(arg);\n            }\n        }\n        list.add(\"-cp\");\n        list.add(classpathStr);\n\n        if(fork) {\n            getLog().warn(\"maven-scala-plugin cannot fork scala console!!  Running in process\");\n        }\n\n        jcmd = new JavaMainCallerInProcess(this, mainConsole, classpathStr, jvmArgs, list.toArray(new String[list.size()]));\n        //We need to make sure compiler plugins are sent into the interpreter as well!\n        addCompilerPluginOptions(jcmd);\n        if (javaRebelPath != null) {\n            if (!javaRebelPath.exists()) {\n                getLog().warn(\"javaRevelPath '\"+javaRebelPath.getCanonicalPath()+\"' not found\");\n            } else {\n                jcmd.addJvmArgs(\"-noverify\", \"-javaagent:\" + javaRebelPath.getCanonicalPath());\n            }\n        }\n        jcmd.run(displayCmd);\n    }\n}\n","Method after Refactoring":"/*\n * Copyright 2007 scala-tools.org\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions\n * and limitations under the License.\n */\npackage org_scala_tools_maven;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport org_scala_tools_maven_executions.JavaMainCaller;\nimport org_scala_tools_maven_executions.JavaMainCallerInProcess;\nimport org_scala_tools_maven_executions.MainHelper;\n\n/**\n * Run the Scala console with all the classes of the projects (dependencies and builded)\n *\n * @goal console\n * @requiresDependencyResolution test\n * @inheritByDefault false\n * @requiresDirectInvocation true\n * @executionStrategy once-per-session\n */\npublic class ScalaConsoleMojo extends ScalaMojoSupport {\n\n    /**\n     * The console to run.\n     *\n     * @parameter expression=\"${mainConsole}\" default-value=\"scala.tools.nsc.MainGenericRunner\"\n     * @required\n     */\n    protected String mainConsole;\n\n    /**\n     * Add the test classpath (include classes from test directory), to the console's classpath ?\n     *\n     * @parameter expression=\"${maven.scala.console.useTestClasspath}\" default-value=\"true\"\n     * @required\n     */\n    protected boolean useTestClasspath;\n\n    /**\n     * Add the runtime classpath, to the console's classpath ?\n     *\n     * @parameter expression=\"${maven.scala.console.useRuntimeClasspath}\" default-value=\"true\"\n     * @required\n     */\n    protected boolean useRuntimeClasspath;\n\n    /**\n     * Path of the javaRebel jar. If this option is set then the console run\n     * with <a href=\"http://www.zeroturnaround.com/javarebel/\">javarebel<\/a> enabled.\n     *\n     * @parameter expression=\"${javarebel.jar.path}\"\n     */\n    protected File javaRebelPath;\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    protected void doExecute() throws Exception {\n        //TODO - Many other paths uses the getScalaCommand()!!! We should try to use that as much as possibel to help maintainability.\n        VersionNumber scalaVersion = findScalaVersion();\n        String sv = scalaVersion.toString();\n        Set<String> classpath = new HashSet<String>();\n        addToClasspath(\"org.scala-lang\", \"scala-compiler\", sv, classpath);\n        addToClasspath(\"org.scala-lang\", \"scala-library\", sv, classpath);\n        if (new VersionNumber(\"2.9.0\").compareTo(scalaVersion) <= 0) {\n          addToClasspath(\"org.scala-lang\", \"jline\", sv, classpath);\n        } else {\n          addToClasspath(\"jline\", \"jline\", \"0.9.94\", classpath);\n        }\n        classpath.addAll(project.getCompileClasspathElements());\n        if (useTestClasspath) {\n            classpath.addAll(project.getTestClasspathElements());\n        }\n        if (useRuntimeClasspath) {\n            classpath.addAll(project.getRuntimeClasspathElements());\n        }\n        String classpathStr = MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()]));\n        JavaMainCaller jcmd = null;\n        List<String> list = new ArrayList<String>(args != null ? args.length + 3 : 3);\n        if(args != null) {\n            for(String arg : args) {\n                list.add(arg);\n            }\n        }\n        list.add(\"-cp\");\n        list.add(classpathStr);\n\n        if(fork) {\n            getLog().warn(\"maven-scala-plugin cannot fork scala console!!  Running in process\");\n        }\n\n        jcmd = new JavaMainCallerInProcess(this, mainConsole, classpathStr, jvmArgs, list.toArray(new String[list.size()]));\n        //We need to make sure compiler plugins are sent into the interpreter as well!\n        addCompilerPluginOptions(jcmd);\n        if (javaRebelPath != null) {\n            if (!javaRebelPath.exists()) {\n                getLog().warn(\"javaRevelPath '\"+javaRebelPath.getCanonicalPath()+\"' not found\");\n            } else {\n                jcmd.addJvmArgs(\"-noverify\", \"-javaagent:\" + javaRebelPath.getCanonicalPath());\n            }\n        }\n        jcmd.run(displayCmd);\n    }\n}\n","lineNo":75}
{"Smelly Sample":"/*\n * Copyright 2007 scala-tools.org\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions\n * and limitations under the License.\n */\npackage org_scala_tools_maven;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.model.License;\nimport org.apache.maven.project.MavenProject;\nimport org.codehaus.jackson.JsonEncoding;\nimport org.codehaus.jackson.JsonFactory;\nimport org.codehaus.jackson.JsonGenerator;\nimport org.codehaus.jackson.map.ObjectMapper;\nimport org.codehaus.plexus.util.StringUtils;\nimport org_scala_tools_maven_executions.JavaMainCaller;\n\nimport edu.emory.mathcs.backport.java.util.Arrays;\n\n/**\n * Produces Scala API documentation in Json (use vscaladoc2_genjson).\n * \n * @goal genjson\n * @requiresDependencyResolution compile\n * @execute phase=\"generate-sources\"\n * @since 2.15.0\n */\npublic class ScalaGenJsonMojo extends ScalaSourceMojoSupport {\n\n  /**\n   * Define the html fragment for logo.\n   * \n   * @parameter expression=\"${logo}\"\n   *            default-value=\"<a href='${project.url}'>${project.name}<\/a>\"\n   */\n  protected String logo;\n\n  /**\n   * Define the html fragment for license (default : use info of the first entry of pom.xml/project/licenses).\n   * \n   * @parameter expression=\"${license}\" \n   */\n  protected String license;\n\n  /**\n   * Define the artifact's tags (space separator).\n   * \n   * @parameter expression=\"${tags}\" default-value=\"\"\n   */\n  protected String tags = \"\";\n\n  // /**\n  // * Generate source in HTML (not yet supported by vscaladoc2)\n  // *\n  // *\n  // * @parameter expression=\"${linksource}\" default-value=\"true\"\n  // */\n  // protected boolean linksource;\n\n  /**\n   * Define the html fragment for description (use in overview page).\n   * \n   * @parameter expression=\"${description}\"\n   *            default-value=\"${project.description}\"\n   */\n  private String description;\n\n  /**\n   * Define the version of vscaladoc2_genjson to use.\n   * \n   * @parameter expression=\"${vscaladoc2_genjson.version}\"\n   *            default-value=\"0.2\"\n   */\n  protected String vscaladoc2Version;\n\n  /**\n   * The directory which contains scala/java source files\n   * \n   * @parameter expression=\"${project.build.sourceDirectory}/../scala\"\n   */\n  protected File sourceDir;\n\n  protected String _mainClass = \"net_alchim31_vscaladoc2_genjson.Main\";\n  protected boolean _prettyPrint = true;\n\n  public ScalaGenJsonMojo() throws Exception {\n    super();\n  }\n\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  protected List<File> getSourceDirectories() throws Exception {\n    List<String> sources = project.getCompileSourceRoots();\n    // Quick fix in case the user has not added the \"add-source\" goal.\n    String scalaSourceDir = sourceDir.getCanonicalPath();\n    if (!sources.contains(scalaSourceDir)) {\n      sources.add(scalaSourceDir);\n    }\n    return normalize(sources);\n  }\n\n  @Override\n  protected void doExecute() throws Exception {\n    if (StringUtils.isNotEmpty(_mainClass)) {\n      File cfg = makeJsonCfg();\n      setDependenciesForJcmd();\n      JavaMainCaller jcmd = getEmptyScalaCommand(_mainClass);\n      jcmd.addJvmArgs(jvmArgs);\n      jcmd.addArgs(cfg.getCanonicalPath());\n      jcmd.run(displayCmd);\n    } else {\n      getLog().warn(\"Not mainClass or valid launcher found/define\");\n    }\n  }\n\n  private void setDependenciesForJcmd() {\n    BasicArtifact artifact = new BasicArtifact();\n    artifact.artifactId = \"vscaladoc2_genjson\";\n    artifact.groupId = \"net.alchim31.vscaladoc2\";\n    artifact.version = vscaladoc2Version;\n    dependencies = new BasicArtifact[] { artifact };\n  }\n\n  private void toJson(Object pojo, boolean prettyPrint, File f) throws Exception {\n    ObjectMapper m = new ObjectMapper();\n    JsonFactory jf = new JsonFactory();\n    JsonGenerator jg = jf.createJsonGenerator(f, JsonEncoding.UTF8);\n    if (prettyPrint) {\n      jg.useDefaultPrettyPrinter();\n    }\n    m.writeValue(jg, pojo);\n  }\n\n  private File makeJsonCfg() throws Exception {\n    initFilters();\n    File dir = new File(project.getBuild().getDirectory());\n    dir.mkdirs();\n    File f = new File(dir, \"vscaladoc2_cfg.json\");\n    toJson(new Cfg(this), _prettyPrint, f);\n    return f;\n  }\n\n  protected static class Cfg {\n    public String groupId = \"\";\n    public String artifactId = \"undef\";\n    public String version = \"0.0.0\";\n    public String description = \"\";\n    public String logo = \"\";\n    public String license = \"\";\n    public String kind = \"\";\n    public String tags = \"\";\n    public List<List<String>> dependencies = Collections.emptyList();\n    public List<List<Object>> sources = Collections.emptyList();\n    public List<String> artifacts = Collections.emptyList();\n    public List<String> additionnalArgs = Collections.emptyList();\n\n    @SuppressWarnings(\"unchecked\")\n    protected Cfg(ScalaGenJsonMojo data) throws Exception {\n      groupId = data.project.getGroupId();\n      artifactId = data.project.getArtifactId();\n      version = data.project.getVersion();\n      logo = data.logo;\n      license = data.license;\n      description = data.description;\n      tags = data.tags;\n      if (StringUtils.isBlank(license) && !data.project.getLicenses().isEmpty()) {\n        License lic = (License) data.project.getLicenses().get(0); \n        license = String.format(\"<a href='%s'>%s<\/a>\", lic.getUrl(), lic.getName());\n      }\n      dependencies = makeDependencies(data);\n      sources = makeSources(data);\n      artifacts = makeArtifacts(data);\n      if (data.args != null && data.args.length > 0) {\n        additionnalArgs = Arrays.asList(data.args);\n      }\n      kind = makeKind(data);\n    }\n\n    private String makeKind(ScalaGenJsonMojo data) {\n      String back = null;\n      String pkg = data.project.getPackaging();\n      if (\"pom\".equals(pkg)) {\n        back = \"group\";\n      } else {\n        back = pkg;\n      }\n      return back;\n    }\n\n    protected List<List<String>> makeDependencies(ScalaGenJsonMojo data) throws Exception {\n      List<List<String>> back = new ArrayList<List<String>>();\n      @SuppressWarnings(\"unchecked\")\n      List<Artifact> deps = data.project.getCompileArtifacts();\n      for (Artifact dep : deps) {\n        List<String> e = new ArrayList<String>(3);\n        e.add(dep.getFile().getCanonicalPath());\n        e.add(dep.getArtifactId() + \"/\" + dep.getVersion());\n        back.add(e);\n      }\n      return back;\n    }\n\n    protected List<List<Object>> makeSources(ScalaGenJsonMojo data) throws Exception {\n      List<List<Object>> back = new ArrayList<List<Object>>();\n      List<File> dirs = data.getSourceDirectories();\n      List<String> includes = new ArrayList<String>(data.includes);\n      List<String> excludes = new ArrayList<String>(data.excludes);\n      for (File dir : dirs) {\n        List<Object> e = new ArrayList<Object>(3);\n        e.add(dir.getCanonicalPath());\n        e.add(excludes);\n        e.add(includes);\n        back.add(e);\n      }\n      return back;\n    }\n\n    protected List<String> makeArtifacts(ScalaGenJsonMojo data) throws Exception {\n      List<String> back = new ArrayList<String>();\n      @SuppressWarnings(\"unchecked\")\n      List<MavenProject> modules = data.project.getCollectedProjects();\n      for (MavenProject module : modules) {\n        back.add(module.getArtifactId() + \"/\" + module.getVersion());\n      }\n      return back;\n    }\n  }\n}\n","Method after Refactoring":"/*\n * Copyright 2007 scala-tools.org\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions\n * and limitations under the License.\n */\npackage org_scala_tools_maven;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.model.License;\nimport org.apache.maven.project.MavenProject;\nimport org.codehaus.jackson.JsonEncoding;\nimport org.codehaus.jackson.JsonFactory;\nimport org.codehaus.jackson.JsonGenerator;\nimport org.codehaus.jackson.JsonNode;\nimport org.codehaus.jackson.map.ObjectMapper;\nimport org.codehaus.jackson.node.ObjectNode;\nimport org.codehaus.plexus.util.StringUtils;\nimport org_scala_tools_maven_executions.JavaMainCaller;\n\nimport edu.emory.mathcs.backport.java.util.Arrays;\n\n/**\n * Produces Scala API documentation in Json (use vscaladoc2_genjson).\n *\n * @goal genjson\n * @requiresDependencyResolution compile\n * @execute phase=\"generate-sources\"\n * @since 2.15.0\n */\npublic class ScalaGenJsonMojo extends ScalaSourceMojoSupport {\n\n  /**\n   * Define the html fragment for logo.\n   *\n   * @parameter expression=\"${genjson.logo}\"\n   *            default-value=\"<a href='${project.url}'>${project.name}<\/a>\"\n   */\n  protected String logo;\n\n  /**\n   * Define the html fragment for license (default : use info of the first entry of pom.xml/project/licenses).\n   *\n   * @parameter expression=\"${genjson.license}\"\n   */\n  protected String license;\n\n  /**\n   * Define the artifact's tags (space separator).\n   *\n   * @parameter expression=\"${genjson.tags}\" default-value=\"\"\n   */\n  protected String tags = \"\";\n\n  // /**\n  // * Generate source in HTML (not yet supported by vscaladoc2)\n  // *\n  // *\n  // * @parameter expression=\"${linksource}\" default-value=\"true\"\n  // */\n  // protected boolean linksource;\n\n  /**\n   * Define the html fragment for description (use in overview page).\n   *\n   * @parameter expression=\"${genjson.description}\"\n   *            default-value=\"${project.description}\"\n   */\n  private String description;\n\n  /**\n   * Define the html fragment for description (use in overview page).\n   *\n   * @parameter expression=\"${genjson.linksources}\"\n   *            default-value=\"\"\n   */\n  private String linksources;\n\n  /**\n   * Allow to override the artifactId used to generated json doc. Can be need sometimes (eg : for parent/group of projects)\n   *\n   * @parameter expression=\"${genjson.artifactId}\"\n   *            default-value=\"${project.artifactId}\"\n   */\n  private String artifactId;\n\n  /**\n   * An optional json object as string used to override base configuration generated\n   * (useful for additional, not yet supported, entry)\n   *\n   * @parameter expression=\"${genjson.override}\"\n   */\n  private String overrideJson;\n\n  /**\n   * Define the version of vscaladoc2_genjson to use.\n   *\n   * @parameter expression=\"${genjson.version}\"\n   *            default-value=\"0.3\"\n   */\n  protected String vscaladoc2Version;\n\n  /**\n   * The directory which contains scala/java source files\n   *\n   * @parameter expression=\"${project.build.sourceDirectory}/../scala\"\n   */\n  protected File sourceDir;\n\n  protected String _mainClass = \"net_alchim31_vscaladoc2_genjson.Main\";\n  protected boolean _prettyPrint = true;\n\n  public ScalaGenJsonMojo() throws Exception {\n    super();\n  }\n\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  protected List<File> getSourceDirectories() throws Exception {\n    List<String> sources = project.getCompileSourceRoots();\n    // Quick fix in case the user has not added the \"add-source\" goal.\n    String scalaSourceDir = sourceDir.getCanonicalPath();\n    if (!sources.contains(scalaSourceDir)) {\n      sources.add(scalaSourceDir);\n    }\n    return normalize(sources);\n  }\n\n  @Override\n  protected void doExecute() throws Exception {\n    if (StringUtils.isNotEmpty(_mainClass)) {\n      File cfg = makeJsonCfg();\n      setDependenciesForJcmd();\n      JavaMainCaller jcmd = getEmptyScalaCommand(_mainClass);\n      jcmd.addJvmArgs(jvmArgs);\n      jcmd.addArgs(cfg.getCanonicalPath());\n      jcmd.run(displayCmd);\n    } else {\n      getLog().warn(\"Not mainClass or valid launcher found/define\");\n    }\n  }\n\n  private void setDependenciesForJcmd() {\n    BasicArtifact artifact = new BasicArtifact();\n    artifact.artifactId = \"vscaladoc2_genjson\";\n    artifact.groupId = \"net.alchim31.vscaladoc2\";\n    artifact.version = vscaladoc2Version;\n    dependencies = new BasicArtifact[] { artifact };\n  }\n\n  private void toJson(Object pojo, boolean prettyPrint, File f) throws Exception {\n    ObjectMapper m = new ObjectMapper();\n    JsonFactory jf = new JsonFactory();\n    JsonGenerator jg = jf.createJsonGenerator(f, JsonEncoding.UTF8);\n    if (prettyPrint) {\n      jg.useDefaultPrettyPrinter();\n    }\n    ObjectNode tree = m.valueToTree(pojo);\n\n    if (StringUtils.isNotEmpty(overrideJson)) {\n      JsonNode overrideTree = m.readValue(overrideJson, JsonNode.class);\n      Iterator<String>  ks = overrideTree.getFieldNames();\n      while( ks.hasNext()) {\n        String k = ks.next();\n        JsonNode v = overrideTree.get(k);\n        tree.put(k, v);\n      }\n    }\n\n    m.writeTree(jg, tree);\n  }\n\n  private File makeJsonCfg() throws Exception {\n    initFilters();\n    File dir = new File(project.getBuild().getDirectory());\n    dir.mkdirs();\n    File f = new File(dir, \"vscaladoc2_cfg.json\");\n    toJson(new Cfg(this), _prettyPrint, f);\n    return f;\n  }\n\n  protected static class Cfg {\n    public String groupId = \"\";\n    public String artifactId = \"undef\";\n    public String version = \"0.0.0\";\n    public String description = \"\";\n    public String logo = \"\";\n    public String license = \"\";\n    public String kind = \"\";\n    public String tags = \"\";\n    public String linksources = \"\";\n    public List<List<String>> dependencies = Collections.emptyList();\n    public List<List<Object>> sources = Collections.emptyList();\n    public List<String> artifacts = Collections.emptyList();\n    public List<String> additionnalArgs = Collections.emptyList();\n\n    @SuppressWarnings(\"unchecked\")\n    protected Cfg(ScalaGenJsonMojo data) throws Exception {\n      groupId = data.project.getGroupId();\n      artifactId = data.artifactId;\n      version = data.project.getVersion();\n      logo = data.logo;\n      license = data.license;\n      description = data.description;\n      tags = data.tags;\n      linksources = data.linksources;\n      if (StringUtils.isBlank(license) && !data.project.getLicenses().isEmpty()) {\n        License lic = (License) data.project.getLicenses().get(0);\n        license = String.format(\"<a href='%s'>%s<\/a>\", lic.getUrl(), lic.getName());\n      }\n      dependencies = makeDependencies(data);\n      sources = makeSources(data);\n      artifacts = makeArtifacts(data);\n      if (data.args != null && data.args.length > 0) {\n        additionnalArgs = Arrays.asList(data.args);\n      }\n      kind = makeKind(data);\n    }\n\n    private String makeKind(ScalaGenJsonMojo data) {\n      String back = null;\n      String pkg = data.project.getPackaging();\n      if (\"pom\".equals(pkg)) {\n        back = \"group\";\n      } else {\n        back = pkg;\n      }\n      return back;\n    }\n\n    protected List<List<String>> makeDependencies(ScalaGenJsonMojo data) throws Exception {\n      List<List<String>> back = new ArrayList<List<String>>();\n      @SuppressWarnings(\"unchecked\")\n      List<Artifact> deps = data.project.getCompileArtifacts();\n      for (Artifact dep : deps) {\n        List<String> e = new ArrayList<String>(3);\n        e.add(dep.getFile().getCanonicalPath());\n        e.add(dep.getArtifactId() + \"/\" + dep.getVersion());\n        back.add(e);\n      }\n      return back;\n    }\n\n    protected List<List<Object>> makeSources(ScalaGenJsonMojo data) throws Exception {\n      List<List<Object>> back = new ArrayList<List<Object>>();\n      List<File> dirs = data.getSourceDirectories();\n      List<String> includes = new ArrayList<String>(data.includes);\n      List<String> excludes = new ArrayList<String>(data.excludes);\n      for (File dir : dirs) {\n        List<Object> e = new ArrayList<Object>(3);\n        e.add(dir.getCanonicalPath());\n        e.add(excludes);\n        e.add(includes);\n        back.add(e);\n      }\n      return back;\n    }\n\n    protected List<String> makeArtifacts(ScalaGenJsonMojo data) throws Exception {\n      List<String> back = new ArrayList<String>();\n      @SuppressWarnings(\"unchecked\")\n      List<MavenProject> modules = data.project.getCollectedProjects();\n      for (MavenProject module : modules) {\n        back.add(module.getArtifactId() + \"/\" + module.getVersion());\n      }\n      return back;\n    }\n  }\n}\n","lineNo":173}
{"Smelly Sample":"/*\n * Copyright 2007 scala-tools.org\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions\n * and limitations under the License.\n */\npackage org_scala_tools_maven;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Calendar;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Set;\n\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.reporting.MavenReport;\nimport org.apache.maven.reporting.MavenReportException;\nimport org.codehaus.doxia.sink.Sink;\nimport org.codehaus.plexus.util.StringUtils;\nimport org_scala_tools_maven_executions.JavaMainCaller;\nimport org_scala_tools_maven_executions.MainHelper;\n\n/**\n * Produces Scala API documentation.\n *\n * @goal doc\n * @requiresDependencyResolution compile\n * @execute phase=\"generate-sources\"\n */\npublic class ScalaDocMojo extends ScalaMojoSupport implements MavenReport {\n    /**\n     * Specify window title of generated HTML documentation.\n     *\n     * @parameter expression=\"${windowtitle}\"\n     *            default-value=\"${project.name} ${project.version} API\"\n     */\n    protected String windowtitle;\n\n    /**\n     * Specifies the text to be placed at the bottom of each output file. If you\n     * want to use html you have to put it in a CDATA section, eg.\n     * &lt;![CDATA[Copyright 2005, &lt;a\n     * href=\"http://www.mycompany.com\">MyCompany, Inc.&lt;a>]]&gt;\n     *\n     * @parameter expression=\"${bottom}\"\n     *            default-value=\"Copyright (c) {inceptionYear}-{currentYear} {organizationName}. All Rights Reserved.\"\n     */\n    protected String bottom;\n\n    /**\n     * Charset for cross-platform viewing of generated documentation.\n     *\n     * @parameter expression=\"${charset}\" default-value=\"ISO-8859-1\"\n     */\n    protected String charset;\n\n    /**\n     * Include title for the overview page.\n     *\n     * @parameter expression=\"${doctitle}\"\n     *            default-value=\"${project.name} ${project.version} API\"\n     */\n    protected String doctitle;\n\n    /**\n     * Include footer text for each page.\n     *\n     * @parameter expression=\"${footer}\"\n     */\n    protected String footer;\n\n    /**\n     * Include header text for each page\n     *\n     * @parameter expression=\"${header}\"\n     */\n    protected String header;\n\n    /**\n     * Generate source in HTML\n     *\n     * @parameter expression=\"${linksource}\" default-value=\"true\"\n     */\n    protected boolean linksource;\n\n    /**\n     * Suppress description and tags, generate only declarations\n     *\n     * @parameter expression=\"${nocomment}\" default-value=\"false\"\n     */\n    protected boolean nocomment;\n\n    /**\n     * File to change style of the generated documentation\n     *\n     * @parameter expression=\"${stylesheetfile}\"\n     */\n    protected File stylesheetfile;\n\n    /**\n     * Include top text for each page\n     *\n     * @parameter expression=\"${top}\"\n     */\n    protected String top;\n\n    /**\n     * The directory in which to find scala source\n     *\n     * @parameter expression=\"${project.build.sourceDirectory}/../scala\"\n     */\n    protected File sourceDir;\n\n    /**\n     * Specifies the destination directory where scalaDoc saves the generated\n     * HTML files.\n     *\n     * @parameter expression=\"scaladocs\"\n     * @required\n     */\n    private String outputDirectory;\n\n    /**\n     * Specifies the destination directory where javadoc saves the generated HTML files.\n     *\n     * @parameter expression=\"${project.reporting.outputDirectory}/scaladocs\"\n     * @required\n     */\n    private File reportOutputDirectory;\n\n    /**\n     * The name of the Scaladoc report.\n     *\n     * @since 2.1\n     * @parameter expression=\"${name}\" default-value=\"ScalaDocs\"\n     */\n    private String name;\n\n    /**\n     * The description of the Scaladoc report.\n     *\n     * @since 2.1\n     * @parameter expression=\"${description}\" default-value=\"ScalaDoc API\n     *            documentation.\"\n     */\n    private String description;\n\n    /**\n     * className (FQN) of the main scaladoc to use, if not define, the the scalaClassName is used\n     *\n     * @parameter expression=\"${maven.scaladoc.className}\"\n     */\n    protected String scaladocClassName;\n\n    /**\n     * If you want to use vscaladoc to generate api instead of regular scaladoc, set the version of vscaladoc you want to use.\n     *\n     * @parameter expression=\"${maven.scaladoc.vscaladocVersion}\"\n     */\n    protected String vscaladocVersion;\n\n    /**\n     * To allow running aggregation only from command line use \"-Dforce-aggregate=true\" (avoid using in pom.xml).\n     *\n     * @parameter expression=\"${force-aggregate}\" default-value=\"false\"\n     */\n    protected boolean forceAggregate = false;\n\n    /**\n     * If you want to aggregate only direct sub modules.\n     *\n     * @parameter expression=\"${maven.scaladoc.aggregateDirectOnly}\" default-value=\"true\"\n     */\n    protected boolean aggregateDirectOnly = true;\n\n    private String[] sourceFiles_ = null;\n\n    /**\n     * A list of inclusion filters for the compiler.\n     *\n     * @parameter\n     */\n    private Set<String> includes = new HashSet<String>();\n\n    /**\n     * A list of exclusion filters for the compiler.\n     *\n     * @parameter\n     */\n    private Set<String> excludes = new HashSet<String>();\n\n\n    private String[] findSourceFiles() {\n        if (sourceFiles_ == null) {\n            if(includes.isEmpty()) {\n                includes.add(\"**/*.scala\");\n            }\n            sourceFiles_ = MainHelper.findFiles(sourceDir, includes.toArray(new String[includes.size()]), excludes.toArray(new String[excludes.size()]));\n        }\n        return sourceFiles_;\n    }\n\n    public boolean canGenerateReport() {\n        try {\n            sourceDir = sourceDir.getCanonicalFile();\n        } catch (IOException exc) {\n            sourceDir = sourceDir.getAbsoluteFile();\n        }\n        // there is source to compile\n        boolean back = sourceDir.exists() && (findSourceFiles().length != 0);\n        // there is modules to aggregate\n        back = back || ((project.isExecutionRoot() || forceAggregate) && StringUtils.isNotEmpty(vscaladocVersion) && (new VersionNumber(vscaladocVersion).compareTo(new VersionNumber(\"1.1\")) >= 0) && project.getCollectedProjects().size() > 0);\n        return back;\n    }\n\n    public boolean isExternalReport() {\n        return true;\n    }\n\n    public String getCategoryName() {\n        return CATEGORY_PROJECT_REPORTS;\n    }\n\n    public String getDescription(Locale locale) {\n        if (StringUtils.isEmpty(description)) {\n            return \"ScalaDoc API documentation\";\n        }\n        return description;\n    }\n\n    public String getName(Locale locale) {\n        if (StringUtils.isEmpty(name)) {\n            return \"ScalaDocs\";\n        }\n        return name;\n    }\n\n    public String getOutputName() {\n        return outputDirectory + \"/index\";\n    }\n\n    public File getReportOutputDirectory() {\n        if (reportOutputDirectory == null) {\n            reportOutputDirectory = new File(project.getBasedir(), project.getReporting().getOutputDirectory() + \"/\" + outputDirectory).getAbsoluteFile();\n        }\n        return reportOutputDirectory;\n    }\n\n    public void setReportOutputDirectory(File reportOutputDirectory) {\n        if (reportOutputDirectory != null && !reportOutputDirectory.getAbsolutePath().endsWith(outputDirectory)) {\n            this.reportOutputDirectory = new File(reportOutputDirectory, outputDirectory);\n        }\n        else {\n            this.reportOutputDirectory = reportOutputDirectory;\n        }\n    }\n\n    @Override\n    public void doExecute() throws Exception {\n        // SiteRendererSink sink = siteRenderer.createSink(new\n        // File(project.getReporting().getOutputDirectory(), getOutputName() +\n        // \".html\");\n        generate(null, Locale.getDefault());\n    }\n\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    protected JavaMainCaller getScalaCommand() throws Exception {\n        //This ensures we have a valid scala version...\n        checkScalaVersion();\n        boolean isPreviousScala271 = (new VersionNumber(\"2.7.1\").compareTo(new VersionNumber(scalaVersion)) > 0);\n        if (StringUtils.isEmpty(scaladocClassName)) {\n            if (!isPreviousScala271) {\n                scaladocClassName = \"scala.tools.nsc.ScalaDoc\";\n            } else {\n                scaladocClassName = scalaClassName;\n            }\n        }\n\n        JavaMainCaller jcmd = getEmptyScalaCommand(scaladocClassName);\n        jcmd.addArgs(args);\n        jcmd.addJvmArgs(jvmArgs);\n\n        if (isPreviousScala271){\n            jcmd.addArgs(\"-Ydoc\");\n        }\n\n        jcmd.addOption(\"-classpath\", MainHelper.toMultiPath(project.getCompileClasspathElements()));\n        jcmd.addOption(\"-sourcepath\", sourceDir.getAbsolutePath());\n\n        boolean isScaladoc2 = (new VersionNumber(\"2.8.0\").compareTo(new VersionNumber(scalaVersion)) <= 0) && (\"scala.tools.nsc.ScalaDoc\".equals(scaladocClassName));\n        if (isScaladoc2) {\n            jcmd.addArgs(\"-doc-format:html\");\n            jcmd.addOption(\"-doc-title\", doctitle);\n        } else {\n            jcmd.addOption(\"-bottom\", getBottomText());\n            jcmd.addOption(\"-charset\", charset);\n            jcmd.addOption(\"-doctitle\", doctitle);\n            jcmd.addOption(\"-footer\", footer);\n            jcmd.addOption(\"-header\", header);\n            jcmd.addOption(\"-linksource\", linksource);\n            jcmd.addOption(\"-nocomment\", nocomment);\n            jcmd.addOption(\"-stylesheetfile\", stylesheetfile);\n            jcmd.addOption(\"-top\", top);\n            jcmd.addOption(\"-windowtitle\", windowtitle);\n        }\n        return jcmd;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public void generate(Sink sink, Locale locale) throws MavenReportException {\n        try {\n            if (!canGenerateReport()) {\n                getLog().warn(\"No source files found in \" + sourceDir);\n                return;\n            }\n\n            File reportOutputDir = getReportOutputDirectory();\n            if (!reportOutputDir.exists()) {\n                reportOutputDir.mkdirs();\n            }\n            if (StringUtils.isNotEmpty(vscaladocVersion)) {\n                scaladocClassName = \"org.scala_tools.vscaladoc.Main\";\n                BasicArtifact artifact = new BasicArtifact();\n                artifact.artifactId = \"vscaladoc\";\n                artifact.groupId = \"org.scala-tools\";\n                artifact.version = vscaladocVersion;\n                dependencies = new BasicArtifact[]{artifact};\n            }\n\n            if (sourceDir.exists()) {\n                JavaMainCaller jcmd = getScalaCommand();\n                jcmd.addOption(\"-d\", reportOutputDir.getAbsolutePath());\n                String[] sources = findSourceFiles();\n                if (sources.length > 0) {\n                    for (String x : sources) {\n                        jcmd.addArgs(sourceDir + File.separator + x);\n                    }\n                    jcmd.run(displayCmd);\n                }\n            }\n            if (forceAggregate) {\n                aggregate(project);\n            } else {\n                // Mojo could not be run from parent after all its children\n                // So the aggregation will be run after the last child\n                if (project.hasParent()) {\n                    MavenProject parent = project.getParent();\n                    List<MavenProject> modules = parent.getCollectedProjects();\n                    if ((modules.size() > 1) && project.equals(modules.get(modules.size() - 1))) {\n                        aggregate(parent);\n                    }\n                }\n            }\n\n        } catch (MavenReportException exc) {\n            throw exc;\n        } catch (RuntimeException exc) {\n            throw exc;\n        } catch (Exception exc) {\n            throw new MavenReportException(\"wrap: \" + exc.getMessage(), exc);\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    protected void aggregate(MavenProject parent) throws Exception {\n        List<MavenProject> modules = parent.getCollectedProjects();\n        File dest = new File(parent.getReporting().getOutputDirectory() +\"/\" + outputDirectory);\n        getLog().info(\"start aggregation into \" + dest);\n        StringBuilder mpath = new StringBuilder();\n        for (MavenProject module : modules) {\n            if ( \"pom\".equals( module.getPackaging().toLowerCase() ) ) {\n                continue;\n            }\n            if (aggregateDirectOnly && module.getParent() != parent) {\n                continue;\n            }\n            File subScaladocPath = new File(module.getReporting().getOutputDirectory() +\"/\" + outputDirectory).getAbsoluteFile();\n            //System.out.println(\" -> \" + project.getModulePathAdjustment(module)  +\" // \" + subScaladocPath + \" // \" + module.getBasedir() );\n            if (subScaladocPath.exists()) {\n                mpath.append(subScaladocPath).append(File.pathSeparatorChar);\n            }\n        }\n        if (mpath.length() != 0) {\n            getLog().info(\"aggregate vscaladoc from : \" + mpath);\n            JavaMainCaller jcmd = getScalaCommand();\n            jcmd.addOption(\"-d\", dest.getAbsolutePath());\n            jcmd.addOption(\"-aggregate\", mpath.toString());\n            jcmd.run(displayCmd);\n        } else {\n            getLog().warn(\"no vscaladoc to aggregate\");\n        }\n    }\n\n    /**\n     * Method that sets the bottom text that will be displayed on the bottom of\n     * the javadocs.\n     *\n     * @param inceptionYear the year when the project was started\n     * @return a String that contains the text that will be displayed at the\n     *         bottom of the javadoc\n     */\n    private String getBottomText() {\n        String inceptionYear = project.getInceptionYear();\n        int actualYear = Calendar.getInstance().get(Calendar.YEAR);\n        String year = String.valueOf(actualYear);\n\n        String theBottom = StringUtils.replace(bottom, \"{currentYear}\", year);\n\n        if (inceptionYear != null) {\n            if (inceptionYear.equals(year)) {\n                theBottom = StringUtils.replace(theBottom, \"{inceptionYear}-\", \"\");\n            } else {\n                theBottom = StringUtils.replace(theBottom, \"{inceptionYear}\", inceptionYear);\n            }\n        } else {\n            theBottom = StringUtils.replace(theBottom, \"{inceptionYear}-\", \"\");\n        }\n\n        if (project.getOrganization() == null) {\n            theBottom = StringUtils.replace(theBottom, \" {organizationName}\", \"\");\n        } else {\n            if ((project.getOrganization() != null) && (StringUtils.isNotEmpty(project.getOrganization().getName()))) {\n                if (StringUtils.isNotEmpty(project.getOrganization().getUrl())) {\n                    theBottom = StringUtils.replace(theBottom, \"{organizationName}\", \"<a href=\\\"\" + project.getOrganization().getUrl() + \"\\\">\" + project.getOrganization().getName() + \"<\/a>\");\n                } else {\n                    theBottom = StringUtils.replace(theBottom, \"{organizationName}\", project.getOrganization().getName());\n                }\n            } else {\n                theBottom = StringUtils.replace(theBottom, \" {organizationName}\", \"\");\n            }\n        }\n\n        return theBottom;\n    }\n}\n","Method after Refactoring":"/*\n * Copyright 2007 scala-tools.org\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions\n * and limitations under the License.\n */\npackage org_scala_tools_maven;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Calendar;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Set;\n\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.reporting.MavenReport;\nimport org.apache.maven.reporting.MavenReportException;\nimport org.codehaus.doxia.sink.Sink;\nimport org.codehaus.plexus.util.StringUtils;\nimport org_scala_tools_maven_executions.JavaMainCaller;\nimport org_scala_tools_maven_executions.MainHelper;\n\n/**\n * Produces Scala API documentation.\n *\n * @goal doc\n * @requiresDependencyResolution compile\n * @execute phase=\"generate-sources\"\n */\npublic class ScalaDocMojo extends ScalaMojoSupport implements MavenReport {\n    /**\n     * Specify window title of generated HTML documentation.\n     *\n     * @parameter expression=\"${windowtitle}\"\n     *            default-value=\"${project.name} ${project.version} API\"\n     */\n    protected String windowtitle;\n\n    /**\n     * Specifies the text to be placed at the bottom of each output file. If you\n     * want to use html you have to put it in a CDATA section, eg.\n     * &lt;![CDATA[Copyright 2005, &lt;a\n     * href=\"http://www.mycompany.com\">MyCompany, Inc.&lt;a>]]&gt;\n     *\n     * @parameter expression=\"${bottom}\"\n     *            default-value=\"Copyright (c) {inceptionYear}-{currentYear} {organizationName}. All Rights Reserved.\"\n     */\n    protected String bottom;\n\n    /**\n     * Charset for cross-platform viewing of generated documentation.\n     *\n     * @parameter expression=\"${charset}\" default-value=\"ISO-8859-1\"\n     */\n    protected String charset;\n\n    /**\n     * Include title for the overview page.\n     *\n     * @parameter expression=\"${doctitle}\"\n     *            default-value=\"${project.name} ${project.version} API\"\n     */\n    protected String doctitle;\n\n    /**\n     * Include footer text for each page.\n     *\n     * @parameter expression=\"${footer}\"\n     */\n    protected String footer;\n\n    /**\n     * Include header text for each page\n     *\n     * @parameter expression=\"${header}\"\n     */\n    protected String header;\n\n    /**\n     * Generate source in HTML\n     *\n     * @parameter expression=\"${linksource}\" default-value=\"true\"\n     */\n    protected boolean linksource;\n\n    /**\n     * Suppress description and tags, generate only declarations\n     *\n     * @parameter expression=\"${nocomment}\" default-value=\"false\"\n     */\n    protected boolean nocomment;\n\n    /**\n     * File to change style of the generated documentation\n     *\n     * @parameter expression=\"${stylesheetfile}\"\n     */\n    protected File stylesheetfile;\n\n    /**\n     * Include top text for each page\n     *\n     * @parameter expression=\"${top}\"\n     */\n    protected String top;\n\n    /**\n     * The directory in which to find scala source\n     *\n     * @parameter expression=\"${project.build.sourceDirectory}/../scala\"\n     */\n    protected File sourceDir;\n\n    /**\n     * Specifies the destination directory where scalaDoc saves the generated\n     * HTML files.\n     *\n     * @parameter expression=\"scaladocs\"\n     * @required\n     */\n    private String outputDirectory;\n\n    /**\n     * Specifies the destination directory where javadoc saves the generated HTML files.\n     *\n     * @parameter expression=\"${project.reporting.outputDirectory}/scaladocs\"\n     * @required\n     */\n    private File reportOutputDirectory;\n\n    /**\n     * The name of the Scaladoc report.\n     *\n     * @since 2.1\n     * @parameter expression=\"${name}\" default-value=\"ScalaDocs\"\n     */\n    private String name;\n\n    /**\n     * The description of the Scaladoc report.\n     *\n     * @since 2.1\n     * @parameter expression=\"${description}\" default-value=\"ScalaDoc API\n     *            documentation.\"\n     */\n    private String description;\n\n    /**\n     * className (FQN) of the main scaladoc to use, if not define, the the scalaClassName is used\n     *\n     * @parameter expression=\"${maven.scaladoc.className}\"\n     */\n    protected String scaladocClassName;\n\n    /**\n     * If you want to use vscaladoc to generate api instead of regular scaladoc, set the version of vscaladoc you want to use.\n     *\n     * @parameter expression=\"${maven.scaladoc.vscaladocVersion}\"\n     */\n    protected String vscaladocVersion;\n\n    /**\n     * To allow running aggregation only from command line use \"-Dforce-aggregate=true\" (avoid using in pom.xml).\n     *\n     * @parameter expression=\"${force-aggregate}\" default-value=\"false\"\n     */\n    protected boolean forceAggregate = false;\n\n    /**\n     * If you want to aggregate only direct sub modules.\n     *\n     * @parameter expression=\"${maven.scaladoc.aggregateDirectOnly}\" default-value=\"true\"\n     */\n    protected boolean aggregateDirectOnly = true;\n\n    private String[] sourceFiles_ = null;\n\n    /**\n     * A list of inclusion filters for the compiler.\n     *\n     * @parameter\n     */\n    private Set<String> includes = new HashSet<String>();\n\n    /**\n     * A list of exclusion filters for the compiler.\n     *\n     * @parameter\n     */\n    private Set<String> excludes = new HashSet<String>();\n\n\n    private String[] findSourceFiles() {\n        if (sourceFiles_ == null) {\n            if(includes.isEmpty()) {\n                includes.add(\"**/*.scala\");\n            }\n            sourceFiles_ = MainHelper.findFiles(sourceDir, includes.toArray(new String[includes.size()]), excludes.toArray(new String[excludes.size()]));\n        }\n        return sourceFiles_;\n    }\n\n    public boolean canGenerateReport() {\n        try {\n            sourceDir = sourceDir.getCanonicalFile();\n        } catch (IOException exc) {\n            sourceDir = sourceDir.getAbsoluteFile();\n        }\n        // there is source to compile\n        boolean back = sourceDir.exists() && (findSourceFiles().length != 0);\n        // there is modules to aggregate\n        back = back || ((project.isExecutionRoot() || forceAggregate) && StringUtils.isNotEmpty(vscaladocVersion) && (new VersionNumber(vscaladocVersion).compareTo(new VersionNumber(\"1.1\")) >= 0) && project.getCollectedProjects().size() > 0);\n        return back;\n    }\n\n    public boolean isExternalReport() {\n        return true;\n    }\n\n    public String getCategoryName() {\n        return CATEGORY_PROJECT_REPORTS;\n    }\n\n    public String getDescription(@SuppressWarnings(\"unused\") Locale locale) {\n        if (StringUtils.isEmpty(description)) {\n            return \"ScalaDoc API documentation\";\n        }\n        return description;\n    }\n\n    public String getName(@SuppressWarnings(\"unused\") Locale locale) {\n        if (StringUtils.isEmpty(name)) {\n            return \"ScalaDocs\";\n        }\n        return name;\n    }\n\n    public String getOutputName() {\n        return outputDirectory + \"/index\";\n    }\n\n    public File getReportOutputDirectory() {\n        if (reportOutputDirectory == null) {\n            reportOutputDirectory = new File(project.getBasedir(), project.getReporting().getOutputDirectory() + \"/\" + outputDirectory).getAbsoluteFile();\n        }\n        return reportOutputDirectory;\n    }\n\n    public void setReportOutputDirectory(File reportOutputDirectory) {\n        if (reportOutputDirectory != null && !reportOutputDirectory.getAbsolutePath().endsWith(outputDirectory)) {\n            this.reportOutputDirectory = new File(reportOutputDirectory, outputDirectory);\n        }\n        else {\n            this.reportOutputDirectory = reportOutputDirectory;\n        }\n    }\n\n    @Override\n    public void doExecute() throws Exception {\n        // SiteRendererSink sink = siteRenderer.createSink(new\n        // File(project.getReporting().getOutputDirectory(), getOutputName() +\n        // \".html\");\n        generate(null, Locale.getDefault());\n    }\n\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    protected JavaMainCaller getScalaCommand() throws Exception {\n        //This ensures we have a valid scala version...\n        checkScalaVersion();\n        boolean isPreviousScala271 = (new VersionNumber(\"2.7.1\").compareTo(new VersionNumber(scalaVersion)) > 0);\n        if (StringUtils.isEmpty(scaladocClassName)) {\n            if (!isPreviousScala271) {\n                scaladocClassName = \"scala.tools.nsc.ScalaDoc\";\n            } else {\n                scaladocClassName = scalaClassName;\n            }\n        }\n\n        JavaMainCaller jcmd = getEmptyScalaCommand(scaladocClassName);\n        jcmd.addArgs(args);\n        jcmd.addJvmArgs(jvmArgs);\n\n        if (isPreviousScala271){\n            jcmd.addArgs(\"-Ydoc\");\n        }\n        List<String> paths = project.getCompileClasspathElements();\n        paths.remove(project.getBuild().getOutputDirectory()); //remove output to avoid \"error for\" : error:  XXX is already defined as package XXX ... object XXX {\n        jcmd.addOption(\"-classpath\", MainHelper.toMultiPath(paths));\n        jcmd.addOption(\"-sourcepath\", sourceDir.getAbsolutePath());\n\n        boolean isScaladoc2 = (new VersionNumber(\"2.8.0\").compareTo(new VersionNumber(scalaVersion)) <= 0) && (\"scala.tools.nsc.ScalaDoc\".equals(scaladocClassName));\n        if (isScaladoc2) {\n            jcmd.addArgs(\"-doc-format:html\");\n            jcmd.addOption(\"-doc-title\", doctitle);\n        } else {\n            jcmd.addOption(\"-bottom\", getBottomText());\n            jcmd.addOption(\"-charset\", charset);\n            jcmd.addOption(\"-doctitle\", doctitle);\n            jcmd.addOption(\"-footer\", footer);\n            jcmd.addOption(\"-header\", header);\n            jcmd.addOption(\"-linksource\", linksource);\n            jcmd.addOption(\"-nocomment\", nocomment);\n            jcmd.addOption(\"-stylesheetfile\", stylesheetfile);\n            jcmd.addOption(\"-top\", top);\n            jcmd.addOption(\"-windowtitle\", windowtitle);\n        }\n        return jcmd;\n    }\n\n    public void generate(@SuppressWarnings(\"unused\") Sink sink, @SuppressWarnings(\"unused\") Locale locale) throws MavenReportException {\n        try {\n            if (!canGenerateReport()) {\n                getLog().warn(\"No source files found in \" + sourceDir);\n                return;\n            }\n\n            File reportOutputDir = getReportOutputDirectory();\n            if (!reportOutputDir.exists()) {\n                reportOutputDir.mkdirs();\n            }\n            if (StringUtils.isNotEmpty(vscaladocVersion)) {\n                scaladocClassName = \"org.scala_tools.vscaladoc.Main\";\n                BasicArtifact artifact = new BasicArtifact();\n                artifact.artifactId = \"vscaladoc\";\n                artifact.groupId = \"org.scala-tools\";\n                artifact.version = vscaladocVersion;\n                dependencies = new BasicArtifact[]{artifact};\n            }\n\n            if (sourceDir.exists()) {\n                JavaMainCaller jcmd = getScalaCommand();\n                jcmd.addOption(\"-d\", reportOutputDir.getAbsolutePath());\n                String[] sources = findSourceFiles();\n                if (sources.length > 0) {\n                    for (String x : sources) {\n                        jcmd.addArgs(sourceDir + File.separator + x);\n                    }\n                    jcmd.run(displayCmd);\n                }\n            }\n            if (forceAggregate) {\n                aggregate(project);\n            } else {\n                // Mojo could not be run from parent after all its children\n                // So the aggregation will be run after the last child\n                tryAggregateUpper(project);\n            }\n\n        } catch (MavenReportException exc) {\n            throw exc;\n        } catch (RuntimeException exc) {\n            throw exc;\n        } catch (Exception exc) {\n            throw new MavenReportException(\"wrap: \" + exc.getMessage(), exc);\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    protected void tryAggregateUpper(MavenProject prj) throws Exception {\n        if (prj != null && prj.hasParent()) {\n            MavenProject parent = prj.getParent();\n            List<MavenProject> modules = parent.getCollectedProjects();\n            if ((modules.size() > 1) && prj.equals(modules.get(modules.size() - 1))) {\n                aggregate(parent);\n            }\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    protected void aggregate(MavenProject parent) throws Exception {\n        List<MavenProject> modules = parent.getCollectedProjects();\n        File dest = new File(parent.getReporting().getOutputDirectory() +\"/\" + outputDirectory);\n        getLog().info(\"start aggregation into \" + dest);\n        StringBuilder mpath = new StringBuilder();\n        for (MavenProject module : modules) {\n            if ( \"pom\".equals( module.getPackaging().toLowerCase() ) ) {\n                continue;\n            }\n            if (aggregateDirectOnly && module.getParent() != parent) {\n                continue;\n            }\n            File subScaladocPath = new File(module.getReporting().getOutputDirectory() +\"/\" + outputDirectory).getAbsoluteFile();\n            //System.out.println(\" -> \" + project.getModulePathAdjustment(module)  +\" // \" + subScaladocPath + \" // \" + module.getBasedir() );\n            if (subScaladocPath.exists()) {\n                mpath.append(subScaladocPath).append(File.pathSeparatorChar);\n            }\n        }\n        if (mpath.length() != 0) {\n            getLog().info(\"aggregate vscaladoc from : \" + mpath);\n            JavaMainCaller jcmd = getScalaCommand();\n            jcmd.addOption(\"-d\", dest.getAbsolutePath());\n            jcmd.addOption(\"-aggregate\", mpath.toString());\n            jcmd.run(displayCmd);\n        } else {\n            getLog().warn(\"no vscaladoc to aggregate\");\n        }\n        tryAggregateUpper(parent);\n    }\n\n    /**\n     * Method that sets the bottom text that will be displayed on the bottom of\n     * the javadocs.\n     *\n     * @param inceptionYear the year when the project was started\n     * @return a String that contains the text that will be displayed at the\n     *         bottom of the javadoc\n     */\n    private String getBottomText() {\n        String inceptionYear = project.getInceptionYear();\n        int actualYear = Calendar.getInstance().get(Calendar.YEAR);\n        String year = String.valueOf(actualYear);\n\n        String theBottom = StringUtils.replace(bottom, \"{currentYear}\", year);\n\n        if (inceptionYear != null) {\n            if (inceptionYear.equals(year)) {\n                theBottom = StringUtils.replace(theBottom, \"{inceptionYear}-\", \"\");\n            } else {\n                theBottom = StringUtils.replace(theBottom, \"{inceptionYear}\", inceptionYear);\n            }\n        } else {\n            theBottom = StringUtils.replace(theBottom, \"{inceptionYear}-\", \"\");\n        }\n\n        if (project.getOrganization() == null) {\n            theBottom = StringUtils.replace(theBottom, \" {organizationName}\", \"\");\n        } else {\n            if ((project.getOrganization() != null) && (StringUtils.isNotEmpty(project.getOrganization().getName()))) {\n                if (StringUtils.isNotEmpty(project.getOrganization().getUrl())) {\n                    theBottom = StringUtils.replace(theBottom, \"{organizationName}\", \"<a href=\\\"\" + project.getOrganization().getUrl() + \"\\\">\" + project.getOrganization().getName() + \"<\/a>\");\n                } else {\n                    theBottom = StringUtils.replace(theBottom, \"{organizationName}\", project.getOrganization().getName());\n                }\n            } else {\n                theBottom = StringUtils.replace(theBottom, \" {organizationName}\", \"\");\n            }\n        }\n\n        return theBottom;\n    }\n}\n","lineNo":299}
{"Smelly Sample":"package org_scala_tools_maven_cs;\n\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.StringReader;\nimport java.io.StringWriter;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.apache.maven.plugin.logging.Log;\nimport org.codehaus.plexus.util.FileUtils;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.StringUtils;\n\nimport org_scala_tools_maven.ScalaMojoSupport;\nimport org_scala_tools_maven_executions.JavaMainCaller;\nimport org_scala_tools_maven_executions.JavaMainCallerByFork;\nimport org_scala_tools_maven_executions.MainHelper;\n\n/**\n * ScalacsClient is a client used to send request to a scalacs running server.\n *\n * @author davidB\n */\npublic class ScalacsClient {\n    public static Pattern linePattern = Pattern.compile(\"^-(INFO|WARN|ERROR)\\t([^\\t]*)\\t([^\\t]*)\\t(.*)$\");\n    public static Pattern locationPattern = Pattern.compile(\"([^#]*)#(\\\\d+),(\\\\d+),(\\\\d+),(\\\\d+)\");\n\n    public enum Level {INFO, WARN, ERROR};\n\n    public static class LogEvent {\n        public Level level = Level.INFO;\n        public String category = \"\";\n        public File file = null;\n        public int line = 0;\n        public int column = 0;\n        public int offset = 0;\n        public int length = 0;\n        public CharSequence text = \"\";\n\n        @Override\n        public String toString() {\n            return level + \"*\" + category + \"*\" + file + \"*\" + line + \"*\" + column + \"*\" + offset + \"*\"+ length + \"*\"+ text+ \"*\";\n        }\n    }\n\n    private Log _log;\n    private ScalaMojoSupport _mojo;\n    private String _csVersion;\n    private String[] _jvmArgs;\n\n    public ScalacsClient(ScalaMojoSupport mojo, String csVersion, String[] jvmArgs) {\n        _log = mojo.getLog();\n        _mojo = mojo;\n        _csVersion = csVersion;\n        _jvmArgs = jvmArgs;\n    }\n\n    public List<LogEvent> parse(String response) throws Exception {\n        List<LogEvent> back = new LinkedList<LogEvent>();\n        BufferedReader in = new BufferedReader(new StringReader(response));\n        try {\n            for(String l = in.readLine(); l != null; l =in.readLine()){\n                Matcher m = linePattern.matcher(l);\n                if (m.matches()) {\n                    LogEvent e = new LogEvent();\n                    e.level = Level.valueOf(m.group(1).toUpperCase());\n                    e.category = m.group(2);\n                    e.text = m.group(4).replace('§', '\\n');\n                    Matcher ml = locationPattern.matcher(m.group(3));\n                    if (ml.matches()) {\n                        e.file = new File(ml.group(1));\n                        e.line = Integer.parseInt(m.group(2));\n                        e.column = Integer.parseInt(m.group(3));\n                        e.offset = Integer.parseInt(m.group(4));\n                        e.length = Integer.parseInt(m.group(5));\n                    }\n                    back.add(e);\n                }\n            }\n        } finally {\n            IOUtil.close(in);\n        }\n        return back;\n    }\n\n    /**\n     * request to createOrUpdate one or more project define in the Yaml syntax, each project definition should be separated by \"---\"\n     * @return the output (log) of the request\n     * @throws Exception\n     */\n    public String sendRequestCreateOrUpdate(String yamlDef) throws Exception {\n        String back = \"\";\n        try {\n            back = sendRequest(\"createOrUpdate\", yamlDef);\n        } catch (java.net.ConnectException exc) {\n            startNewServer();\n            back = sendRequest(\"createOrUpdate\", yamlDef);\n        }\n        return back;\n    }\n\n    /**\n     * @return the output (log) of the request\n     * @throws Exception\n     */\n    public String sendRequestRemove(String projectName) throws Exception {\n        return sendRequest(\"remove?p=\" + projectName, null);\n    }\n\n    /**\n     *\n     * @return the output (log) of the request\n     * @throws Exception\n     */\n    public String sendRequestCompile(String projectName, boolean withDependencies, boolean withDependent) throws Exception {\n        StringBuilder query = new StringBuilder(\"compile?\");\n        if (StringUtils.isNotEmpty(projectName)) {\n            query.append(\"p=\").append(projectName);\n            if (!withDependencies) {\n                query.append(\"&noDependencies=true\");\n            }\n            if (!withDependent) {\n                query.append(\"&noDependent=true\");\n            }\n        }\n        return sendRequest(query.toString(), null);\n    }\n\n    /**\n     *\n     * @return the output (log) of the request\n     * @throws Exception\n     */\n    public String sendRequestClean() throws Exception {\n        return sendRequest(\"clean\", null);\n    }\n\n    /**\n     *\n     * @return the output (log) of the request\n     * @throws Exception\n     */\n    public String sendRequestStop() throws Exception {\n        return sendRequest(\"stop\", null);\n    }\n\n    protected String sendRequest(String action, String data) throws Exception {\n        URL url = new URL(\"http://127.0.0.1:27616/\" + action);\n        traceUrl(url);\n        URLConnection cnx = url.openConnection();\n        cnx.setDoOutput(StringUtils.isNotEmpty(data));\n        cnx.setDoInput(true);\n        if (StringUtils.isNotEmpty(data)) {\n            OutputStream os = cnx.getOutputStream();\n            try {\n                IOUtil.copy(new StringReader(data), os);\n            } finally {\n                IOUtil.close(os);\n            }\n        }\n        InputStream is = cnx.getInputStream();\n        try {\n            String back = IOUtil.toString(is);\n            return back;\n        } finally {\n            IOUtil.close(is);\n        }\n    }\n\n    /**\n     * Implementation could override this method if it want to print, log, url requested\n     *\n     * @throws Exception\n     */\n    public void traceUrl(URL url) throws Exception {\n        _log.debug(\"request : \" + url);\n    }\n\n    /**\n     * Implementation should provide a way to startNewServer (used if call sendRequestCreateOrUpdate and no server is up)\n     *\n     * @throws Exception\n     */\n    public void startNewServer() throws Exception{\n        _log.info(\"start scala-tools-server...\");\n        Set<String> classpath = new HashSet<String>();\n        //_mojo.addToClasspath(\"net.alchim31\", \"scalacs\", _csVersion, classpath, true);\n        //JavaMainCaller jcmd = new JavaMainCallerByFork(_mojo, \"net_alchim31_scalacs.HttpServer\", MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])), null, null, false);\n\n        _mojo.addToClasspath(\"org.scala-tools.sbt\", \"sbt-launch\", \"0.7.2\", classpath, true);\n        File scalaCsBootConf = installConf(new File(System.getProperty(\"user.home\"), \".sbt-launch/scalacs-\"+ _csVersion +\".boot.properties\"));\n        JavaMainCaller jcmd = new JavaMainCallerByFork(_mojo, \"xsbt.boot.Boot\", MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])), _jvmArgs, new String[]{scalaCsBootConf.getCanonicalPath()}, false);\n        jcmd.spawn(_mojo.displayCmd);\n        boolean started = false;\n        for(int i = 60; i>0 && !started; i--) {\n            try {\n                System.out.print(\".\");\n                Thread.sleep(1000);\n                sendRequest(\"ping\", null);\n                started = true;\n                System.out.println(\"\\n started\");\n            } catch (java.net.ConnectException exc) {\n                started = false; //useless but more readable\n            }\n        }\n        if (!started) {\n            throw new IllegalStateException(\"can't start and connect to scalacs\");\n        }\n    }\n\n    private File installConf(File scalaCsBootConf) throws Exception {\n        if (!scalaCsBootConf.isFile()) {\n            scalaCsBootConf.getParentFile().mkdirs();\n            InputStream is = null;\n            StringWriter sw = new StringWriter();\n            try {\n                is = this.getClass().getResourceAsStream(\"scalacs.boot.properties\");\n                IOUtil.copy(is, sw);\n            } finally {\n                IOUtil.close(is);\n                IOUtil.close(sw);\n            }\n            Properties p = new Properties(System.getProperties());\n            p.setProperty(\"scalacs.version\", _csVersion);\n            p.setProperty(\"scalacs.directory\", scalaCsBootConf.getParentFile().getCanonicalPath());\n            String cfg = StringUtils.interpolate(sw.toString(), p);\n            FileUtils.fileWrite(scalaCsBootConf.getCanonicalPath(), \"UTF-8\", cfg);\n        }\n        return scalaCsBootConf;\n    }\n}\n","Method after Refactoring":"package org_scala_tools_maven_cs;\n\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.RandomAccessFile;\nimport java.io.StringReader;\nimport java.io.StringWriter;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.apache.maven.plugin.logging.Log;\nimport org.codehaus.plexus.util.FileUtils;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.StringUtils;\n\nimport org_scala_tools_maven.ScalaMojoSupport;\nimport org_scala_tools_maven_executions.JavaMainCaller;\nimport org_scala_tools_maven_executions.JavaMainCallerByFork;\nimport org_scala_tools_maven_executions.MainHelper;\nimport org_scala_tools_maven_executions.SpawnMonitor;\n\n/**\n * ScalacsClient is a client used to send request to a scalacs running server.\n *\n * @author davidB\n */\npublic class ScalacsClient {\n    public static final String BOOT_PROP_RSRC = \"scalacs.boot.properties\";\n    public static Pattern linePattern = Pattern.compile(\"^-(INFO|WARN|ERROR)\\t([^\\t]*)\\t([^\\t]*)\\t(.*)$\");\n    public static Pattern locationPattern = Pattern.compile(\"([^#]*)#(\\\\d+),(\\\\d+),(\\\\d+),(\\\\d+)\");\n\n    public enum Level {INFO, WARN, ERROR};\n\n    public static class LogEvent {\n        public Level level = Level.INFO;\n        public String category = \"\";\n        public File file = null;\n        public int line = 0;\n        public int column = 0;\n        public int offset = 0;\n        public int length = 0;\n        public CharSequence text = \"\";\n\n        @Override\n        public String toString() {\n            return level + \"*\" + category + \"*\" + file + \"*\" + line + \"*\" + column + \"*\" + offset + \"*\"+ length + \"*\"+ text+ \"*\";\n        }\n    }\n\n    private Log _log;\n    private ScalaMojoSupport _mojo;\n    private String _csVersion;\n    private String[] _jvmArgs;\n\n    public ScalacsClient(ScalaMojoSupport mojo, String csVersion, String[] jvmArgs) {\n        _log = mojo.getLog();\n        _mojo = mojo;\n        _csVersion = csVersion;\n        _jvmArgs = jvmArgs;\n    }\n\n    public List<LogEvent> parse(String response) throws Exception {\n        List<LogEvent> back = new LinkedList<LogEvent>();\n        BufferedReader in = new BufferedReader(new StringReader(response));\n        try {\n            for(String l = in.readLine(); l != null; l =in.readLine()){\n                Matcher m = linePattern.matcher(l);\n                if (m.matches()) {\n                    LogEvent e = new LogEvent();\n                    e.level = Level.valueOf(m.group(1).toUpperCase());\n                    e.category = m.group(2);\n                    e.text = m.group(4).replace('§', '\\n');\n                    Matcher ml = locationPattern.matcher(m.group(3));\n                    if (ml.matches()) {\n                        e.file = new File(ml.group(1));\n                        e.line = Integer.parseInt(m.group(2));\n                        e.column = Integer.parseInt(m.group(3));\n                        e.offset = Integer.parseInt(m.group(4));\n                        e.length = Integer.parseInt(m.group(5));\n                    }\n                    back.add(e);\n                }\n            }\n        } finally {\n            IOUtil.close(in);\n        }\n        return back;\n    }\n\n    /**\n     * request to createOrUpdate one or more project define in the Yaml syntax, each project definition should be separated by \"---\"\n     * @return the output (log) of the request\n     * @throws Exception\n     */\n    public String sendRequestCreateOrUpdate(String yamlDef) throws Exception {\n        String back = \"\";\n        try {\n            back = sendRequest(\"createOrUpdate\", yamlDef);\n        } catch (java.net.ConnectException exc) {\n            startNewServer();\n            back = sendRequest(\"createOrUpdate\", yamlDef);\n        }\n        return back;\n    }\n\n    /**\n     * @return the output (log) of the request\n     * @throws Exception\n     */\n    public String sendRequestRemove(String projectName) throws Exception {\n        return sendRequest(\"remove?p=\" + projectName, null);\n    }\n\n    /**\n     *\n     * @return the output (log) of the request\n     * @throws Exception\n     */\n    public String sendRequestCompile(String projectName, boolean withDependencies, boolean withDependent) throws Exception {\n        StringBuilder query = new StringBuilder(\"compile\");\n        if (StringUtils.isNotEmpty(projectName)) {\n            query.append(\"?p=\").append(projectName);\n            if (!withDependencies) {\n                query.append(\"&noDependencies=true\");\n            }\n            // not supported by scalacs 0.2\n            if (!withDependent) {\n                query.append(\"&noDependent=true\");\n            }\n        }\n        return sendRequest(query.toString(), null);\n    }\n\n    /**\n     *\n     * @return the output (log) of the request\n     * @throws Exception\n     */\n    public String sendRequestClean() throws Exception {\n        return sendRequest(\"clean\", null);\n    }\n\n    /**\n     *\n     * @return the output (log) of the request\n     * @throws Exception\n     */\n    public String sendRequestStop() throws Exception {\n        return sendRequest(\"stop\", null);\n    }\n\n    protected String sendRequest(String action, String data) throws Exception {\n        URL url = new URL(\"http://127.0.0.1:27616/\" + action);\n        traceUrl(url);\n        URLConnection cnx = url.openConnection();\n        cnx.setDoOutput(StringUtils.isNotEmpty(data));\n        cnx.setDoInput(true);\n        if (StringUtils.isNotEmpty(data)) {\n            OutputStream os = cnx.getOutputStream();\n            try {\n                IOUtil.copy(new StringReader(data), os);\n            } finally {\n                IOUtil.close(os);\n            }\n        }\n        InputStream is = cnx.getInputStream();\n        try {\n            String back = IOUtil.toString(is);\n            return back;\n        } finally {\n            IOUtil.close(is);\n        }\n    }\n\n    /**\n     * Implementation could override this method if it want to print, log, url requested\n     *\n     * @throws Exception\n     */\n    public void traceUrl(URL url) throws Exception {\n        String msg = \"request : \" + url;\n        if (_mojo.displayCmd) {\n            _log.info(msg);\n        } else {\n            _log.debug(msg);\n        }\n    }\n\n    /**\n     * Implementation should provide a way to startNewServer (used if call sendRequestCreateOrUpdate and no server is up)\n     *\n     * @throws Exception\n     */\n    public void startNewServer() throws Exception{\n        _log.info(\"start scala-tools-server...\");\n        Set<String> classpath = new HashSet<String>();\n        //_mojo.addToClasspath(\"net.alchim31\", \"scalacs\", _csVersion, classpath, true);\n        //JavaMainCaller jcmd = new JavaMainCallerByFork(_mojo, \"net_alchim31_scalacs.HttpServer\", MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])), null, null, false);\n\n        _mojo.addToClasspath(\"org.scala-tools.sbt\", \"sbt-launch\", \"0.7.2\", classpath, true);\n        String[] jvmArgs = new String[(_jvmArgs == null)?1:_jvmArgs.length + 1];\n        File installDir = new File(System.getProperty(\"user.home\"), \".sbt-launch\");\n        jvmArgs[0] = \"-Dsbt.boot.properties=\"+ installConf(new File(installDir, \"scalacs-\"+ _csVersion +\".boot.properties\")).getCanonicalPath();\n        if (_jvmArgs != null) {\n            System.arraycopy(_jvmArgs, 0, jvmArgs, 1, _jvmArgs.length);\n        }\n        FileTailer tailer = new FileTailer(new File(installDir, \"update.log\"));\n        boolean started = false;\n        try {\n            JavaMainCaller jcmd = new JavaMainCallerByFork(_mojo, \"xsbt.boot.Boot\", MainHelper.toMultiPath(classpath.toArray(new String[classpath.size()])), jvmArgs, null, false);\n            SpawnMonitor mon = jcmd.spawn(_mojo.displayCmd);\n            for(int i = 60; i>0 && !started && mon.isRunning(); i--) {\n                try {\n                    if (_mojo.displayCmd) {\n                        System.out.print(tailer.whatNew());\n                    } else {\n                        System.out.print(\".\");\n                    }\n                    Thread.sleep(1000);\n                    sendRequest(\"ping\", null);\n                    started = true;\n                } catch (java.net.ConnectException exc) {\n                    started = false; //useless but more readable\n                }\n            }\n            if (_mojo.displayCmd) {\n                System.out.print(tailer.whatNew());\n            }\n            System.out.println(\"\");\n        } finally {\n            tailer.close();\n        }\n        if (!started) {\n            throw new IllegalStateException(\"can't start and connect to scalacs\");\n        } else {\n            _mojo.getLog().info(\"scalacs connected\");\n        }\n    }\n\n    private File installConf(File scalaCsBootConf) throws Exception {\n        if (!scalaCsBootConf.isFile()) {\n            scalaCsBootConf.getParentFile().mkdirs();\n            InputStream is = null;\n            StringWriter sw = new StringWriter();\n            try {\n                is = this.getClass().getResourceAsStream(BOOT_PROP_RSRC);\n                if (is == null) {\n                    is = Thread.currentThread().getContextClassLoader().getResourceAsStream(BOOT_PROP_RSRC);\n                }\n                if (is == null) {\n                    String abspath = \"/\" + this.getClass().getPackage().getName().replace('.', '/') + \"/\" + BOOT_PROP_RSRC;\n                    is = Thread.currentThread().getContextClassLoader().getResourceAsStream(abspath);\n                    if (is == null) {\n                        throw new IllegalStateException(\"can't find \" + abspath + \" in the classpath\");\n                    }\n                }\n                IOUtil.copy(is, sw);\n            } finally {\n                IOUtil.close(is);\n                IOUtil.close(sw);\n            }\n            Properties p = new Properties(System.getProperties());\n            p.setProperty(\"scalacs.version\", _csVersion);\n            p.setProperty(\"scalacs.directory\", scalaCsBootConf.getParentFile().getCanonicalPath());\n            String cfg = StringUtils.interpolate(sw.toString(), p);\n            FileUtils.fileWrite(scalaCsBootConf.getCanonicalPath(), \"UTF-8\", cfg);\n        }\n        return scalaCsBootConf;\n    }\n\n    private static class FileTailer {\n        private long _filePointer;\n        private RandomAccessFile _raf;\n        private File _file;\n        public FileTailer(File f) throws Exception {\n            _file = f;\n            _filePointer = f.length();\n            _raf = null;\n        }\n\n        public CharSequence whatNew() throws Exception {\n            StringBuilder back = new StringBuilder();\n            if (_raf == null && _file.isFile()) {\n                _raf = new RandomAccessFile(_file, \"r\" );\n            }\n            if (_raf != null) {\n                // Compare the length of the file to the file pointer\n                long fileLength = _file.length();\n                if( fileLength < _filePointer ) {\n                  // Log file must have been rotated or deleted;\n                  // reopen the file and reset the file pointer\n                  close();\n                  _raf = new RandomAccessFile(_file, \"r\" );\n                  _filePointer = 0;\n                }\n\n                if( fileLength > _filePointer ) {\n                  // There is data to read\n                  _raf.seek( _filePointer );\n//                  back = _raf.readUTF();\n\n                  String line =  null;\n                  while( (line = _raf.readLine())!= null ) {\n                    back.append( line ).append('\\n');\n                  }\n                  _filePointer = _raf.getFilePointer();\n                }\n            }\n            return back;\n        }\n        public void close() {\n            try {\n                if (_raf != null) {\n                    _raf.close();\n                    _raf = null;\n                }\n            } catch(Exception e) {\n                // ignore\n            }\n        }\n    }\n}\n","lineNo":191}
{"Smelly Sample":"/*\n * Copyright 2007 scala-tools.org\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions\n * and limitations under the License.\n */\npackage org.scala_tools.maven;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Calendar;\nimport java.util.Locale;\n\nimport org.apache.maven.reporting.MavenReport;\nimport org.apache.maven.reporting.MavenReportException;\nimport org.codehaus.doxia.sink.Sink;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.scala_tools.maven.executions.JavaMainCaller;\n\n/**\n * Produces Scala API documentation.\n *\n * @goal doc\n * @requiresDependencyResolution compile\n */\npublic class ScalaDocMojo extends ScalaMojoSupport implements MavenReport {\n    /**\n     * Specify window title of generated HTML documentation.\n     *\n     * @parameter expression=\"${windowtitle}\"\n     *            default-value=\"${project.name} ${project.version} API\"\n     */\n    protected String windowtitle;\n\n    /**\n     * Specifies the text to be placed at the bottom of each output file. If you\n     * want to use html you have to put it in a CDATA section, eg.\n     * &lt;![CDATA[Copyright 2005, &lt;a\n     * href=\"http://www.mycompany.com\">MyCompany, Inc.&lt;a>]]&gt;\n     *\n     * @parameter expression=\"${bottom}\"\n     *            default-value=\"Copyright (c) {inceptionYear}-{currentYear} {organizationName}. All Rights Reserved.\"\n     */\n    protected String bottom;\n\n    /**\n     * Charset for cross-platform viewing of generated documentation.\n     *\n     * @parameter expression=\"${charset}\" default-value=\"ISO-8859-1\"\n     */\n    protected String charset;\n\n    /**\n     * Include title for the overview page.\n     *\n     * @parameter expression=\"${doctitle}\"\n     *            default-value=\"${project.name} ${project.version} API\"\n     */\n    protected String doctitle;\n\n    /**\n     * Include footer text for each page.\n     *\n     * @parameter expression=\"${footer}\"\n     */\n    protected String footer;\n\n    /**\n     * Include header text for each page\n     *\n     * @parameter expression=\"${header}\"\n     */\n    protected String header;\n\n    /**\n     * Generate source in HTML\n     *\n     * @parameter expression=\"${linksource}\" default=\"true\"\n     */\n    protected boolean linksource;\n\n    /**\n     * Suppress description and tags, generate only declarations\n     *\n     * @parameter expression=\"${nocomment}\" default=\"false\"\n     */\n    protected boolean nocomment;\n\n    /**\n     * File to change style of the generated documentation\n     *\n     * @parameter expression=\"${stylesheetfile}\"\n     */\n    protected File stylesheetfile;\n\n    /**\n     * Include top text for each page\n     *\n     * @parameter expression=\"${top}\"\n     */\n    protected String top;\n\n    /**\n     * @parameter expression=\"${project.build.sourceDirectory}/../scala\"\n     */\n    protected File sourceDir;\n\n    /**\n     * Specifies the destination directory where scalaDoc saves the generated\n     * HTML files.\n     *\n     * @parameter expression=\"scaladocs\"\n     * @required\n     */\n    private String outputDirectory;\n\n    /**\n     * Specifies the destination directory where javadoc saves the generated HTML files.\n     *\n     * @parameter expression=\"${project.reporting.outputDirectory}/scaladocs\"\n     * @required\n     */\n    private File reportOutputDirectory;\n\n    /**\n     * The name of the Scaladoc report.\n     *\n     * @since 2.1\n     * @parameter expression=\"${name}\" default-value=\"ScalaDocs\"\n     */\n    private String name;\n\n    /**\n     * The description of the Scaladoc report.\n     *\n     * @since 2.1\n     * @parameter expression=\"${description}\" default-value=\"ScalaDoc API\n     *            documentation.\"\n     */\n    private String description;\n\n    /**\n     * className (FQN) of the main scaladoc to use, if not define, the the scalaClassName is used\n     *\n     * @parameter expression=\"${maven.scaladoc.className}\"\n     */\n    protected String scaladocClassName;\n\n    /**\n     * If you want to use vscaladoc to generate api instead of regular scaladoc, set the version of vscaladoc you want to use.\n     *\n     * @parameter expression=\"${maven.scaladoc.vscaladocVersion}\"\n     */\n    protected String vscaladocVersion;\n\n\n    private String[] sourceFiles_ = null;\n    private String[] findSourceFiles() {\n        if (sourceFiles_ == null) {\n            sourceFiles_ = JavaCommand.findFiles(sourceDir, \"**/*.scala\");\n        }\n        return sourceFiles_;\n    }\n\n    public boolean canGenerateReport() {\n        try {\n            sourceDir = sourceDir.getCanonicalFile();\n        } catch (IOException exc) {\n            sourceDir = sourceDir.getAbsoluteFile();\n        }\n        return sourceDir.exists() && (findSourceFiles().length != 0);\n    }\n\n    public boolean isExternalReport() {\n        return true;\n    }\n\n    public String getCategoryName() {\n        return CATEGORY_PROJECT_REPORTS;\n    }\n\n    public String getDescription(Locale locale) {\n        if (StringUtils.isEmpty(description)) {\n            return \"ScalaDoc API documentation\";\n        }\n        return description;\n    }\n\n    public String getName(Locale locale) {\n        if (StringUtils.isEmpty(name)) {\n            return \"ScalaDocs\";\n        }\n        return name;\n    }\n\n    public String getOutputName() {\n        return outputDirectory + \"/index\";\n    }\n\n    public File getReportOutputDirectory() {\n        if (reportOutputDirectory == null) {\n            reportOutputDirectory = new File(project.getReporting().getOutputDirectory(), outputDirectory);\n        }\n        return reportOutputDirectory;\n    }\n\n    public void setReportOutputDirectory(File reportOutputDirectory) {\n        this.reportOutputDirectory = new File(reportOutputDirectory, outputDirectory);\n    }\n\n    @Override\n    public void doExecute() throws Exception {\n        // SiteRendererSink sink = siteRenderer.createSink(new\n        // File(project.getReporting().getOutputDirectory(), getOutputName() +\n        // \".html\");\n        generate(null, Locale.getDefault());\n    }\n\n\n    @Override\n    protected JavaMainCaller getScalaCommand() throws Exception {\n        String oldClazz = scalaClassName;\n        //This ensures we have a valid scala version...\n        checkScalaVersion();\n        boolean isPreviousScala271 = (new VersionNumber(\"2.7.1\").compareTo(new VersionNumber(scalaVersion)) > 0);\n        if (!isPreviousScala271) {\n            scalaClassName = \"scala.tools.nsc.ScalaDoc\";\n        }\n        if (StringUtils.isNotEmpty(scaladocClassName)) {\n            scalaClassName = scaladocClassName;\n        }\n        JavaMainCaller cmd = getEmptyScalaCommand(scalaClassName);\n        cmd.addArgs(args);\n        cmd.addJvmArgs(jvmArgs);\n        if (isPreviousScala271){\n            cmd.addArgs(\"-Ydoc\");\n        }\n        scalaClassName = oldClazz;\n        return cmd;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public void generate(Sink sink, Locale locale) throws MavenReportException {\n        try {\n            if (!canGenerateReport()) {\n                getLog().warn(\"No source files found in \" + sourceDir);\n                return;\n            }\n\n            File reportOutputDir = getReportOutputDirectory();\n            if (!reportOutputDir.exists()) {\n                reportOutputDir.mkdirs();\n            }\n            if (StringUtils.isNotEmpty(vscaladocVersion)) {\n                scaladocClassName = \"org.scala_tools.vscaladoc.Main\";\n                BasicArtifact artifact = new BasicArtifact();\n                artifact.artifactId = \"vscaladoc\";\n                artifact.groupId = \"org.scala-tools\";\n                artifact.version = vscaladocVersion;\n                dependencies = new BasicArtifact[]{artifact};\n            }\n            JavaMainCaller jcmd = getScalaCommand();\n            jcmd.addOption(\"-classpath\", JavaCommand.toMultiPath(project.getCompileClasspathElements()));\n            jcmd.addOption(\"-d\", reportOutputDir.getAbsolutePath());\n            jcmd.addOption(\"-sourcepath\", sourceDir.getAbsolutePath());\n            jcmd.addOption(\"-bottom\", getBottomText());\n            jcmd.addOption(\"-charset\", charset);\n            jcmd.addOption(\"-doctitle\", doctitle);\n            jcmd.addOption(\"-footer\", footer);\n            jcmd.addOption(\"-header\", header);\n            jcmd.addOption(\"-linksource\", linksource);\n            jcmd.addOption(\"-nocomment\", nocomment);\n            jcmd.addOption(\"-stylesheetfile\", stylesheetfile);\n            jcmd.addOption(\"-top\", top);\n            jcmd.addOption(\"-windowtitle\", windowtitle);\n            for (String x : findSourceFiles()) {\n                jcmd.addArgs(sourceDir + File.separator + x);\n            }\n            jcmd.run(displayCmd);\n        } catch (MavenReportException exc) {\n            throw exc;\n        } catch (RuntimeException exc) {\n            throw exc;\n        } catch (Exception exc) {\n            throw new MavenReportException(\"wrap: \" + exc.getMessage(), exc);\n        }\n    }\n\n    /**\n     * Method that sets the bottom text that will be displayed on the bottom of\n     * the javadocs.\n     *\n     * @param inceptionYear the year when the project was started\n     * @return a String that contains the text that will be displayed at the\n     *         bottom of the javadoc\n     */\n    private String getBottomText() {\n        String inceptionYear = project.getInceptionYear();\n        int actualYear = Calendar.getInstance().get(Calendar.YEAR);\n        String year = String.valueOf(actualYear);\n\n        String theBottom = StringUtils.replace(bottom, \"{currentYear}\", year);\n\n        if (inceptionYear != null) {\n            if (inceptionYear.equals(year)) {\n                theBottom = StringUtils.replace(theBottom, \"{inceptionYear}-\", \"\");\n            } else {\n                theBottom = StringUtils.replace(theBottom, \"{inceptionYear}\", inceptionYear);\n            }\n        } else {\n            theBottom = StringUtils.replace(theBottom, \"{inceptionYear}-\", \"\");\n        }\n\n        if (project.getOrganization() == null) {\n            theBottom = StringUtils.replace(theBottom, \" {organizationName}\", \"\");\n        } else {\n            if ((project.getOrganization() != null) && (StringUtils.isNotEmpty(project.getOrganization().getName()))) {\n                if (StringUtils.isNotEmpty(project.getOrganization().getUrl())) {\n                    theBottom = StringUtils.replace(theBottom, \"{organizationName}\", \"<a href=\\\"\" + project.getOrganization().getUrl() + \"\\\">\" + project.getOrganization().getName() + \"<\/a>\");\n                } else {\n                    theBottom = StringUtils.replace(theBottom, \"{organizationName}\", project.getOrganization().getName());\n                }\n            } else {\n                theBottom = StringUtils.replace(theBottom, \" {organizationName}\", \"\");\n            }\n        }\n\n        return theBottom;\n    }\n}\n","Method after Refactoring":"/*\n * Copyright 2007 scala-tools.org\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions\n * and limitations under the License.\n */\npackage org.scala_tools.maven;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Calendar;\nimport java.util.List;\nimport java.util.Locale;\n\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.reporting.MavenReport;\nimport org.apache.maven.reporting.MavenReportException;\nimport org.codehaus.doxia.sink.Sink;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.scala_tools.maven.executions.JavaMainCaller;\n\n/**\n * Produces Scala API documentation.\n *\n * @goal doc\n * //aggregator\n * @requiresDependencyResolution compile\n */\npublic class ScalaDocMojo extends ScalaMojoSupport implements MavenReport {\n    /**\n     * Specify window title of generated HTML documentation.\n     *\n     * @parameter expression=\"${windowtitle}\"\n     *            default-value=\"${project.name} ${project.version} API\"\n     */\n    protected String windowtitle;\n\n    /**\n     * Specifies the text to be placed at the bottom of each output file. If you\n     * want to use html you have to put it in a CDATA section, eg.\n     * &lt;![CDATA[Copyright 2005, &lt;a\n     * href=\"http://www.mycompany.com\">MyCompany, Inc.&lt;a>]]&gt;\n     *\n     * @parameter expression=\"${bottom}\"\n     *            default-value=\"Copyright (c) {inceptionYear}-{currentYear} {organizationName}. All Rights Reserved.\"\n     */\n    protected String bottom;\n\n    /**\n     * Charset for cross-platform viewing of generated documentation.\n     *\n     * @parameter expression=\"${charset}\" default-value=\"ISO-8859-1\"\n     */\n    protected String charset;\n\n    /**\n     * Include title for the overview page.\n     *\n     * @parameter expression=\"${doctitle}\"\n     *            default-value=\"${project.name} ${project.version} API\"\n     */\n    protected String doctitle;\n\n    /**\n     * Include footer text for each page.\n     *\n     * @parameter expression=\"${footer}\"\n     */\n    protected String footer;\n\n    /**\n     * Include header text for each page\n     *\n     * @parameter expression=\"${header}\"\n     */\n    protected String header;\n\n    /**\n     * Generate source in HTML\n     *\n     * @parameter expression=\"${linksource}\" default=\"true\"\n     */\n    protected boolean linksource;\n\n    /**\n     * Suppress description and tags, generate only declarations\n     *\n     * @parameter expression=\"${nocomment}\" default=\"false\"\n     */\n    protected boolean nocomment;\n\n    /**\n     * File to change style of the generated documentation\n     *\n     * @parameter expression=\"${stylesheetfile}\"\n     */\n    protected File stylesheetfile;\n\n    /**\n     * Include top text for each page\n     *\n     * @parameter expression=\"${top}\"\n     */\n    protected String top;\n\n    /**\n     * @parameter expression=\"${project.build.sourceDirectory}/../scala\"\n     */\n    protected File sourceDir;\n\n    /**\n     * Specifies the destination directory where scalaDoc saves the generated\n     * HTML files.\n     *\n     * @parameter expression=\"scaladocs\"\n     * @required\n     */\n    private String outputDirectory;\n\n    /**\n     * Specifies the destination directory where javadoc saves the generated HTML files.\n     *\n     * @parameter expression=\"${project.reporting.outputDirectory}/scaladocs\"\n     * @required\n     */\n    private File reportOutputDirectory;\n\n    /**\n     * The name of the Scaladoc report.\n     *\n     * @since 2.1\n     * @parameter expression=\"${name}\" default-value=\"ScalaDocs\"\n     */\n    private String name;\n\n    /**\n     * The description of the Scaladoc report.\n     *\n     * @since 2.1\n     * @parameter expression=\"${description}\" default-value=\"ScalaDoc API\n     *            documentation.\"\n     */\n    private String description;\n\n    /**\n     * className (FQN) of the main scaladoc to use, if not define, the the scalaClassName is used\n     *\n     * @parameter expression=\"${maven.scaladoc.className}\"\n     */\n    protected String scaladocClassName;\n\n    /**\n     * If you want to use vscaladoc to generate api instead of regular scaladoc, set the version of vscaladoc you want to use.\n     *\n     * @parameter expression=\"${maven.scaladoc.vscaladocVersion}\"\n     */\n    protected String vscaladocVersion;\n\n    /**\n     * To allow running aggregation only from command line use \"-Dforce-aggregate=true\" (avoid using in pom.xml).\n     *\n     * @parameter expression=\"${force-aggregate}\" default=\"false\"\n     */\n    protected boolean forceAggregate = false;\n\n    /**\n     * If you want to aggregate only direct sub modules.\n     *\n     * @parameter expression=\"${maven.scaladoc.aggregateDirectOnly}\" default=\"true\"\n     */\n    protected boolean aggregateDirectOnly = true;\n\n    private String[] sourceFiles_ = null;\n    private String[] findSourceFiles() {\n        if (sourceFiles_ == null) {\n            sourceFiles_ = JavaCommand.findFiles(sourceDir, \"**/*.scala\");\n        }\n        return sourceFiles_;\n    }\n\n    public boolean canGenerateReport() {\n        try {\n            sourceDir = sourceDir.getCanonicalFile();\n        } catch (IOException exc) {\n            sourceDir = sourceDir.getAbsoluteFile();\n        }\n        // there is source to compile\n        boolean back = sourceDir.exists() && (findSourceFiles().length != 0);\n        // there is modules to aggregate\n        back = back || ((project.isExecutionRoot() || forceAggregate) && StringUtils.isNotEmpty(vscaladocVersion) && (new VersionNumber(vscaladocVersion).compareTo(new VersionNumber(\"1.1\")) >= 0) && project.getCollectedProjects().size() > 0);\n        return back;\n    }\n\n    public boolean isExternalReport() {\n        return true;\n    }\n\n    public String getCategoryName() {\n        return CATEGORY_PROJECT_REPORTS;\n    }\n\n    public String getDescription(Locale locale) {\n        if (StringUtils.isEmpty(description)) {\n            return \"ScalaDoc API documentation\";\n        }\n        return description;\n    }\n\n    public String getName(Locale locale) {\n        if (StringUtils.isEmpty(name)) {\n            return \"ScalaDocs\";\n        }\n        return name;\n    }\n\n    public String getOutputName() {\n        return outputDirectory + \"/index\";\n    }\n\n    public File getReportOutputDirectory() {\n        if (reportOutputDirectory == null) {\n            reportOutputDirectory = new File(project.getBasedir(), project.getReporting().getOutputDirectory() +\"/\" + outputDirectory).getAbsoluteFile();\n        }\n        return reportOutputDirectory;\n    }\n\n    public void setReportOutputDirectory(File reportOutputDirectory) {\n        this.reportOutputDirectory = new File(reportOutputDirectory, outputDirectory);\n    }\n\n    @Override\n    public void doExecute() throws Exception {\n        // SiteRendererSink sink = siteRenderer.createSink(new\n        // File(project.getReporting().getOutputDirectory(), getOutputName() +\n        // \".html\");\n        generate(null, Locale.getDefault());\n    }\n\n\n    @Override\n    protected JavaMainCaller getScalaCommand() throws Exception {\n        String oldClazz = scalaClassName;\n        //This ensures we have a valid scala version...\n        checkScalaVersion();\n        boolean isPreviousScala271 = (new VersionNumber(\"2.7.1\").compareTo(new VersionNumber(scalaVersion)) > 0);\n        if (!isPreviousScala271) {\n            scalaClassName = \"scala.tools.nsc.ScalaDoc\";\n        }\n        if (StringUtils.isNotEmpty(scaladocClassName)) {\n            scalaClassName = scaladocClassName;\n        }\n        JavaMainCaller cmd = getEmptyScalaCommand(scalaClassName);\n        cmd.addArgs(args);\n        cmd.addJvmArgs(jvmArgs);\n        if (isPreviousScala271){\n            cmd.addArgs(\"-Ydoc\");\n        }\n        scalaClassName = oldClazz;\n        return cmd;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public void generate(Sink sink, Locale locale) throws MavenReportException {\n        try {\n            if (!canGenerateReport()) {\n                getLog().warn(\"No source files found in \" + sourceDir);\n                return;\n            }\n\n            File reportOutputDir = getReportOutputDirectory();\n            if (!reportOutputDir.exists()) {\n                reportOutputDir.mkdirs();\n            }\n            if (StringUtils.isNotEmpty(vscaladocVersion)) {\n                scaladocClassName = \"org.scala_tools.vscaladoc.Main\";\n                BasicArtifact artifact = new BasicArtifact();\n                artifact.artifactId = \"vscaladoc\";\n                artifact.groupId = \"org.scala-tools\";\n                artifact.version = vscaladocVersion;\n                dependencies = new BasicArtifact[]{artifact};\n            }\n\n            if (sourceDir.exists()) {\n                JavaMainCaller jcmd = newScalaDocCmd();\n                jcmd.addOption(\"-d\", reportOutputDir.getAbsolutePath());\n                String[] sources = findSourceFiles();\n                if (sources.length > 0) {\n                    for (String x : sources) {\n                        jcmd.addArgs(sourceDir + File.separator + x);\n                    }\n                    jcmd.run(displayCmd);\n                }\n            }\n            if (forceAggregate) {\n                aggregate(project);\n            } else {\n                // Mojo could not be run from parent after all its children\n                // So the aggregation will be run after the last child\n                if (project.hasParent()) {\n                    MavenProject parent = project.getParent();\n                    List<MavenProject> modules = parent.getCollectedProjects();\n                    System.out.println(\">>> modules size \" + modules.size());\n                    if ((modules.size() > 1) && project.equals(modules.get(modules.size() - 1))) {\n                        aggregate(parent);\n                    }\n                }\n            }\n\n        } catch (MavenReportException exc) {\n            throw exc;\n        } catch (RuntimeException exc) {\n            throw exc;\n        } catch (Exception exc) {\n            throw new MavenReportException(\"wrap: \" + exc.getMessage(), exc);\n        }\n    }\n    protected JavaMainCaller newScalaDocCmd() throws Exception {\n        JavaMainCaller jcmd = getScalaCommand();\n        jcmd.addOption(\"-classpath\", JavaCommand.toMultiPath(project.getCompileClasspathElements()));\n        jcmd.addOption(\"-sourcepath\", sourceDir.getAbsolutePath());\n        jcmd.addOption(\"-bottom\", getBottomText());\n        jcmd.addOption(\"-charset\", charset);\n        jcmd.addOption(\"-doctitle\", doctitle);\n        jcmd.addOption(\"-footer\", footer);\n        jcmd.addOption(\"-header\", header);\n        jcmd.addOption(\"-linksource\", linksource);\n        jcmd.addOption(\"-nocomment\", nocomment);\n        jcmd.addOption(\"-stylesheetfile\", stylesheetfile);\n        jcmd.addOption(\"-top\", top);\n        jcmd.addOption(\"-windowtitle\", windowtitle);\n        return jcmd;\n    }\n\n    protected void aggregate(MavenProject parent) throws Exception {\n        List<MavenProject> modules = parent.getCollectedProjects();\n        File dest = new File(parent.getBasedir(), parent.getReporting().getOutputDirectory() +\"/\" + outputDirectory);\n        getLog().info(\"start aggregation into \" + dest);\n        StringBuilder mpath = new StringBuilder();\n        for (MavenProject module : modules) {\n            if ( \"pom\".equals( module.getPackaging().toLowerCase() ) ) {\n                continue;\n            }\n            if (aggregateDirectOnly && module.getParent() != parent) {\n                continue;\n            }\n            File subScaladocPath = new File(module.getBasedir(), module.getReporting().getOutputDirectory() +\"/\" + outputDirectory).getAbsoluteFile();\n            //System.out.println(\" -> \" + project.getModulePathAdjustment(module)  +\" // \" + subScaladocPath + \" // \" + module.getBasedir() );\n            if (subScaladocPath.exists()) {\n                mpath.append(subScaladocPath).append(File.pathSeparatorChar);\n            }\n        }\n        if (mpath.length() != 0) {\n            getLog().info(\"aggregate vscaladoc from : \" + mpath);\n            JavaMainCaller jcmd = newScalaDocCmd();\n            jcmd.addOption(\"-d\", dest.getAbsolutePath());\n            jcmd.addOption(\"-aggregate\", mpath.toString());\n            jcmd.run(displayCmd);\n        } else {\n            getLog().warn(\"no vscaladoc to aggregate\");\n        }\n    }\n\n    /**\n     * Method that sets the bottom text that will be displayed on the bottom of\n     * the javadocs.\n     *\n     * @param inceptionYear the year when the project was started\n     * @return a String that contains the text that will be displayed at the\n     *         bottom of the javadoc\n     */\n    private String getBottomText() {\n        String inceptionYear = project.getInceptionYear();\n        int actualYear = Calendar.getInstance().get(Calendar.YEAR);\n        String year = String.valueOf(actualYear);\n\n        String theBottom = StringUtils.replace(bottom, \"{currentYear}\", year);\n\n        if (inceptionYear != null) {\n            if (inceptionYear.equals(year)) {\n                theBottom = StringUtils.replace(theBottom, \"{inceptionYear}-\", \"\");\n            } else {\n                theBottom = StringUtils.replace(theBottom, \"{inceptionYear}\", inceptionYear);\n            }\n        } else {\n            theBottom = StringUtils.replace(theBottom, \"{inceptionYear}-\", \"\");\n        }\n\n        if (project.getOrganization() == null) {\n            theBottom = StringUtils.replace(theBottom, \" {organizationName}\", \"\");\n        } else {\n            if ((project.getOrganization() != null) && (StringUtils.isNotEmpty(project.getOrganization().getName()))) {\n                if (StringUtils.isNotEmpty(project.getOrganization().getUrl())) {\n                    theBottom = StringUtils.replace(theBottom, \"{organizationName}\", \"<a href=\\\"\" + project.getOrganization().getUrl() + \"\\\">\" + project.getOrganization().getName() + \"<\/a>\");\n                } else {\n                    theBottom = StringUtils.replace(theBottom, \"{organizationName}\", project.getOrganization().getName());\n                }\n            } else {\n                theBottom = StringUtils.replace(theBottom, \" {organizationName}\", \"\");\n            }\n        }\n\n        return theBottom;\n    }\n}\n","lineNo":295}
