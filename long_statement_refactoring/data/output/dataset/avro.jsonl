{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.avro.util;\n\nimport org.apache.avro.LogicalType;\nimport org.apache.avro.LogicalTypes;\nimport org.apache.avro.Schema;\nimport org.apache.avro.file.CodecFactory;\nimport org.apache.avro.file.DataFileWriter;\nimport org.apache.avro.generic.GenericArray;\nimport org.apache.avro.generic.GenericData;\nimport org.apache.avro.generic.GenericDatumWriter;\n\nimport java.io.File;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.time.Duration;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\n\n/** Generates schema data as Java objects with random values. */\npublic class RandomData implements Iterable<Object> {\n  public static final String USE_DEFAULT = \"use-default\";\n  private final GenericData genericData;\n\n  private static final int MILLIS_IN_DAY = (int) Duration.ofDays(1).toMillis();\n\n  private final Schema root;\n  private final long seed;\n  private final int count;\n  private final boolean utf8ForString;\n\n  public RandomData(Schema schema, int count) {\n    this(schema, count, false);\n  }\n\n  public RandomData(Schema schema, int count, long seed) {\n    this(schema, count, seed, false);\n  }\n\n  public RandomData(Schema schema, int count, boolean utf8ForString) {\n    this(schema, count, System.currentTimeMillis(), utf8ForString);\n  }\n\n  public RandomData(Schema schema, int count, long seed, boolean utf8ForString) {\n    this(GenericData.get(), schema, count, seed, utf8ForString);\n  }\n\n  public RandomData(GenericData genericData, Schema schema, int count) {\n    this(genericData, schema, count, false);\n  }\n\n  public RandomData(GenericData genericData, Schema schema, int count, long seed) {\n    this(genericData, schema, count, seed, false);\n  }\n\n  public RandomData(GenericData genericData, Schema schema, int count, boolean utf8ForString) {\n    this(genericData, schema, count, System.currentTimeMillis(), utf8ForString);\n  }\n\n  public RandomData(GenericData genericData, Schema schema, int count, long seed, boolean utf8ForString) {\n    this.genericData = genericData;\n    this.root = schema;\n    this.seed = seed;\n    this.count = count;\n    this.utf8ForString = utf8ForString;\n  }\n\n  @Override\n  public Iterator<Object> iterator() {\n    return new Iterator<Object>() {\n      private int n;\n      private final Random random = new Random(seed);\n\n      @Override\n      public boolean hasNext() {\n        return n < count;\n      }\n\n      @Override\n      public Object next() {\n        n++;\n        return generate(root, random, 0);\n      }\n\n      @Override\n      public void remove() {\n        throw new UnsupportedOperationException();\n      }\n    };\n  }\n\n  @SuppressWarnings(value = \"unchecked\")\n  private Object generate(Schema schema, Random random, int d) {\n    switch (schema.getType()) {\n    case RECORD:\n      Object record = genericData.newRecord(null, schema);\n      for (Schema.Field field : schema.getFields()) {\n        Object value = (field.getObjectProp(USE_DEFAULT) == null) ? generate(field.schema(), random, d + 1)\n            : GenericData.get().getDefaultValue(field);\n        genericData.setField(record, field.name(), field.pos(), value);\n      }\n      return record;\n    case ENUM:\n      List<String> symbols = schema.getEnumSymbols();\n      return genericData.createEnum(symbols.get(random.nextInt(symbols.size())), schema);\n    case ARRAY:\n      int length = Math.max(0, (random.nextInt(5) + 2) - d);\n      GenericArray<Object> array = (GenericArray<Object>) genericData.newArray(null, length, schema);\n      for (int i = 0; i < length; i++)\n        array.add(generate(schema.getElementType(), random, d + 1));\n      return array;\n    case MAP:\n      length = Math.max(0, (random.nextInt(5) + 2) - d);\n      Map<Object, Object> map = (Map<Object, Object>) genericData.newMap(null, length);\n      for (int i = 0; i < length; i++) {\n        map.put(randomString(random, 40), generate(schema.getValueType(), random, d + 1));\n      }\n      return map;\n    case UNION:\n      List<Schema> types = schema.getTypes();\n      return generate(types.get(random.nextInt(types.size())), random, d);\n    case FIXED:\n      byte[] bytes = new byte[schema.getFixedSize()];\n      random.nextBytes(bytes);\n      return genericData.createFixed(null, bytes, schema);\n    case STRING:\n      return randomString(random, 40);\n    case BYTES:\n      return randomBytes(random, 40);\n    case INT:\n      return this.randomInt(random, schema.getLogicalType());\n    case LONG:\n      return this.randomLong(random, schema.getLogicalType());\n    case FLOAT:\n      return random.nextFloat();\n    case DOUBLE:\n      return random.nextDouble();\n    case BOOLEAN:\n      return random.nextBoolean();\n    case NULL:\n      return null;\n    default:\n      throw new RuntimeException(\"Unknown type: \" + schema);\n    }\n  }\n\n  private static final Charset UTF8 = StandardCharsets.UTF_8;\n\n  private int randomInt(Random random, LogicalType type) {\n    if (type instanceof LogicalTypes.TimeMillis) {\n      return random.nextInt(RandomData.MILLIS_IN_DAY - 1);\n    }\n    // LogicalTypes.Date LocalDate.MAX.toEpochDay() > Integer.MAX;\n    return random.nextInt();\n  }\n\n  private long randomLong(Random random, LogicalType type) {\n    if (type instanceof LogicalTypes.TimeMicros) {\n      return ThreadLocalRandom.current().nextLong(RandomData.MILLIS_IN_DAY * 1000L);\n    }\n    // For LogicalTypes.TimestampMillis, every long would be OK,\n    // Instant.MAX.toEpochMilli() failed and would be > Long.MAX_VALUE.\n    return random.nextLong();\n  }\n\n  private Object randomString(Random random, int maxLength) {\n    int length = random.nextInt(maxLength);\n    byte[] bytes = new byte[length];\n    for (int i = 0; i < length; i++) {\n      bytes[i] = (byte) ('a' + random.nextInt('z' - 'a'));\n    }\n    return utf8ForString ? new Utf8(bytes) : new String(bytes, UTF8);\n  }\n\n  private static ByteBuffer randomBytes(Random rand, int maxLength) {\n    ByteBuffer bytes = ByteBuffer.allocate(rand.nextInt(maxLength));\n    bytes.limit(bytes.capacity());\n    rand.nextBytes(bytes.array());\n    return bytes;\n  }\n\n  public static void main(String[] args) throws Exception {\n    if (args.length < 3 || args.length > 4) {\n      System.out.println(\"Usage: RandomData <schemafile> <outputfile> <count> [codec]\");\n      System.exit(-1);\n    }\n    Schema sch = new Schema.Parser().parse(new File(args[0]));\n    try (DataFileWriter<Object> writer = new DataFileWriter<>(new GenericDatumWriter<>())) {\n      writer.setCodec(CodecFactory.fromString(args.length >= 4 ? args[3] : \"null\"));\n      writer.setMeta(\"user_metadata\", \"someByteArray\".getBytes(StandardCharsets.UTF_8));\n      writer.create(sch, new File(args[1]));\n\n      for (Object datum : new RandomData(sch, Integer.parseInt(args[2]))) {\n        writer.append(datum);\n      }\n    }\n  }\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.avro.util;\n\nimport org.apache.avro.LogicalType;\nimport org.apache.avro.LogicalTypes;\nimport org.apache.avro.Schema;\nimport org.apache.avro.file.CodecFactory;\nimport org.apache.avro.file.DataFileWriter;\nimport org.apache.avro.generic.GenericArray;\nimport org.apache.avro.generic.GenericData;\nimport org.apache.avro.generic.GenericDatumWriter;\n\nimport java.io.File;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.time.Duration;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\n\n/** Generates schema data as Java objects with random values. */\npublic class RandomData implements Iterable<Object> {\n  public static final String USE_DEFAULT = \"use-default\";\n  private final GenericData genericData;\n\n  private static final int MILLIS_IN_DAY = (int) Duration.ofDays(1).toMillis();\n\n  private final Schema root;\n  private final long seed;\n  private final int count;\n  private final boolean utf8ForString;\n\n  public RandomData(Schema schema, int count) {\n    this(schema, count, false);\n  }\n\n  public RandomData(Schema schema, int count, long seed) {\n    this(schema, count, seed, false);\n  }\n\n  public RandomData(Schema schema, int count, boolean utf8ForString) {\n    this(schema, count, System.currentTimeMillis(), utf8ForString);\n  }\n\n  public RandomData(Schema schema, int count, long seed, boolean utf8ForString) {\n    this(GenericData.get(), schema, count, seed, utf8ForString);\n  }\n\n  public RandomData(GenericData genericData, Schema schema, int count) {\n    this(genericData, schema, count, false);\n  }\n\n  public RandomData(GenericData genericData, Schema schema, int count, long seed) {\n    this(genericData, schema, count, seed, false);\n  }\n\n  public RandomData(GenericData genericData, Schema schema, int count, boolean utf8ForString) {\n    this(genericData, schema, count, System.currentTimeMillis(), utf8ForString);\n  }\n\n  public RandomData(GenericData genericData, Schema schema, int count, long seed, boolean utf8ForString) {\n    this.genericData = genericData;\n    this.root = schema;\n    this.seed = seed;\n    this.count = count;\n    this.utf8ForString = utf8ForString;\n  }\n\n  @Override\n  public Iterator<Object> iterator() {\n    return new Iterator<Object>() {\n      private int n;\n      private final Random random = new Random(seed);\n\n      @Override\n      public boolean hasNext() {\n        return n < count;\n      }\n\n      @Override\n      public Object next() {\n        n++;\n        return generate(root, random, 0);\n      }\n\n      @Override\n      public void remove() {\n        throw new UnsupportedOperationException();\n      }\n    };\n  }\n\n  @SuppressWarnings(value = \"unchecked\")\n  private Object generate(Schema schema, Random random, int d) {\n    switch (schema.getType()) {\n    case RECORD:\n      Object record = genericData.newRecord(null, schema);\n      for (Schema.Field field : schema.getFields()) {\n        Object value = (field.getObjectProp(USE_DEFAULT) == null) ? generate(field.schema(), random, d + 1)\n            : GenericData.get().getDefaultValue(field);\n        genericData.setField(record, field.name(), field.pos(), value);\n      }\n      return record;\n    case ENUM:\n      List<String> symbols = schema.getEnumSymbols();\n      return genericData.createEnum(symbols.get(random.nextInt(symbols.size())), schema);\n    case ARRAY:\n      int length = Math.max(0, (random.nextInt(5) + 2) - d);\n      GenericArray<Object> array = (GenericArray<Object>) genericData.newArray(null, length, schema);\n      for (int i = 0; i < length; i++)\n        array.add(generate(schema.getElementType(), random, d + 1));\n      return array;\n    case MAP:\n      length = Math.max(0, (random.nextInt(5) + 2) - d);\n      Map<Object, Object> map = (Map<Object, Object>) genericData.newMap(null, length);\n      for (int i = 0; i < length; i++) {\n        map.put(randomString(random, 40), generate(schema.getValueType(), random, d + 1));\n      }\n      return map;\n    case UNION:\n      List<Schema> types = schema.getTypes();\n      return generate(types.get(random.nextInt(types.size())), random, d);\n    case FIXED:\n      byte[] bytes = new byte[schema.getFixedSize()];\n      random.nextBytes(bytes);\n      return genericData.createFixed(null, bytes, schema);\n    case STRING:\n      return randomString(random, 40);\n    case BYTES:\n      return randomBytes(random, 40);\n    case INT:\n      return this.randomInt(random, schema.getLogicalType());\n    case LONG:\n      return this.randomLong(random, schema.getLogicalType());\n    case FLOAT:\n      return random.nextFloat();\n    case DOUBLE:\n      return random.nextDouble();\n    case BOOLEAN:\n      return random.nextBoolean();\n    case NULL:\n      return null;\n    default:\n      throw new RuntimeException(\"Unknown type: \" + schema);\n    }\n  }\n\n  private static final Charset UTF8 = StandardCharsets.UTF_8;\n\n  private int randomInt(Random random, LogicalType type) {\n    if (type instanceof LogicalTypes.TimeMillis) {\n      return random.nextInt(RandomData.MILLIS_IN_DAY - 1);\n    }\n    // LogicalTypes.Date LocalDate.MAX.toEpochDay() > Integer.MAX;\n    return random.nextInt();\n  }\n\n  private long randomLong(Random random, LogicalType type) {\n    if (type instanceof LogicalTypes.TimeMicros) {\n      return ThreadLocalRandom.current().nextLong(RandomData.MILLIS_IN_DAY * 1000L);\n    }\n    // For LogicalTypes.TimestampMillis, every long would be OK,\n    // Instant.MAX.toEpochMilli() failed and would be > Long.MAX_VALUE.\n    return random.nextLong();\n  }\n\n  private Object randomString(Random random, int maxLength) {\n    int length = random.nextInt(maxLength);\n    byte[] bytes = new byte[length];\n    for (int i = 0; i < length; i++) {\n      bytes[i] = (byte) ('a' + random.nextInt('z' - 'a'));\n    }\n    return utf8ForString ? new Utf8(bytes) : new String(bytes, UTF8);\n  }\n\n  private static ByteBuffer randomBytes(Random rand, int maxLength) {\n    ByteBuffer bytes = ByteBuffer.allocate(rand.nextInt(maxLength));\n    bytes.limit(bytes.capacity());\n    rand.nextBytes(bytes.array());\n    return bytes;\n  }\n\n  public static void main(String[] args) throws Exception {\n    if (args.length < 3 || args.length > 4) {\n      System.out.println(\"Usage: RandomData <schemafile> <outputfile> <count> [codec]\");\n      System.exit(-1);\n    }\n    Schema sch = new Schema.Parser().parse(new File(args[0]));\n    try (DataFileWriter<Object> writer = new DataFileWriter<>(new GenericDatumWriter<>())) {\n      writer.setCodec(CodecFactory.fromString(args.length >= 4 ? args[3] : \"null\"));\n      writer.setMeta(\"user_metadata\", \"someByteArray\".getBytes(StandardCharsets.UTF_8));\n      File file = new File(args[1]);\n      Files.createDirectories(Paths.get(file.getParent()));\n      writer.create(sch, file);\n\n      for (Object datum : new RandomData(sch, Integer.parseInt(args[2]))) {\n        writer.append(datum);\n      }\n    }\n  }\n}\n","lineNo":213}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.avro.mojo;\n\nimport org.apache.avro.Protocol;\nimport org.apache.avro.compiler.specific.SpecificCompiler;\nimport org.apache.avro.generic.GenericData;\nimport org.apache.avro.idl.IdlFile;\nimport org.apache.avro.idl.IdlReader;\nimport org.apache.maven.artifact.DependencyResolutionRequiredException;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Generate Java classes and interfaces from AvroIDL files (.avdl)\n *\n * @goal idl\n * @requiresDependencyResolution runtime\n * @phase generate-sources\n * @threadSafe\n */\npublic class IDLMojo extends AbstractAvroMojo {\n  /**\n   * A set of Ant-like inclusion patterns used to select files from the source\n   * directory for processing. By default, the pattern <code>**&#47;*.avdl<\/code>\n   * is used to select IDL files.\n   *\n   * @parameter\n   */\n  private String[] includes = new String[] { \"**/*.avdl\" };\n\n  /**\n   * A set of Ant-like inclusion patterns used to select files from the source\n   * directory for processing. By default, the pattern <code>**&#47;*.avdl<\/code>\n   * is used to select IDL files.\n   *\n   * @parameter\n   */\n  private String[] testIncludes = new String[] { \"**/*.avdl\" };\n\n  @Override\n  protected void doCompile(String filename, File sourceDirectory, File outputDirectory) throws IOException {\n    try {\n      @SuppressWarnings(\"rawtypes\")\n      List runtimeClasspathElements = project.getRuntimeClasspathElements();\n\n      List<URL> runtimeUrls = new ArrayList<>();\n\n      // Add the source directory of avro files to the classpath so that\n      // imports can refer to other idl files as classpath resources\n      runtimeUrls.add(sourceDirectory.toURI().toURL());\n\n      // If runtimeClasspathElements is not empty values add its values to Idl path.\n      if (runtimeClasspathElements != null && !runtimeClasspathElements.isEmpty()) {\n        for (Object runtimeClasspathElement : runtimeClasspathElements) {\n          String element = (String) runtimeClasspathElement;\n          runtimeUrls.add(new File(element).toURI().toURL());\n        }\n      }\n\n      final ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();\n      URLClassLoader projPathLoader = new URLClassLoader(runtimeUrls.toArray(new URL[0]), contextClassLoader);\n      Thread.currentThread().setContextClassLoader(projPathLoader);\n      try {\n        IdlReader parser = new IdlReader();\n        IdlFile idlFile = parser.parse(sourceDirectory.toPath().resolve(filename));\n        for (String warning : idlFile.getWarnings()) {\n          getLog().warn(warning);\n        }\n        idlFile = parser.resolve(idlFile);\n        final SpecificCompiler compiler;\n        final Protocol protocol = idlFile.getProtocol();\n        if (protocol != null) {\n          compiler = new SpecificCompiler(protocol);\n        } else {\n          compiler = new SpecificCompiler(idlFile.getNamedSchemas().values());\n        }\n        compiler.setStringType(GenericData.StringType.valueOf(stringType));\n        compiler.setTemplateDir(templateDirectory);\n        compiler.setFieldVisibility(getFieldVisibility());\n        compiler.setCreateOptionalGetters(createOptionalGetters);\n        compiler.setGettersReturnOptional(gettersReturnOptional);\n        compiler.setOptionalGettersForNullableFieldsOnly(optionalGettersForNullableFieldsOnly);\n        compiler.setCreateSetters(createSetters);\n        compiler.setAdditionalVelocityTools(instantiateAdditionalVelocityTools());\n        compiler.setEnableDecimalLogicalType(enableDecimalLogicalType);\n        for (String customConversion : customConversions) {\n          compiler.addCustomConversion(projPathLoader.loadClass(customConversion));\n        }\n        compiler.setOutputCharacterEncoding(project.getProperties().getProperty(\"project.build.sourceEncoding\"));\n        compiler.compileToDestination(null, outputDirectory);\n      } finally {\n        Thread.currentThread().setContextClassLoader(contextClassLoader);\n      }\n    } catch (ClassNotFoundException | DependencyResolutionRequiredException e) {\n      throw new IOException(e);\n    }\n  }\n\n  @Override\n  protected String[] getIncludes() {\n    return includes;\n  }\n\n  @Override\n  protected String[] getTestIncludes() {\n    return testIncludes;\n  }\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.avro.mojo;\n\nimport org.apache.avro.Protocol;\nimport org.apache.avro.compiler.specific.SpecificCompiler;\nimport org.apache.avro.generic.GenericData;\nimport org.apache.avro.idl.IdlFile;\nimport org.apache.avro.idl.IdlReader;\nimport org.apache.maven.artifact.DependencyResolutionRequiredException;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Generate Java classes and interfaces from AvroIDL files (.avdl)\n *\n * @goal idl\n * @requiresDependencyResolution runtime\n * @phase generate-sources\n * @threadSafe\n */\npublic class IDLMojo extends AbstractAvroMojo {\n  /**\n   * A set of Ant-like inclusion patterns used to select files from the source\n   * directory for processing. By default, the pattern <code>**&#47;*.avdl<\/code>\n   * is used to select IDL files.\n   *\n   * @parameter\n   */\n  private String[] includes = new String[] { \"**/*.avdl\" };\n\n  /**\n   * A set of Ant-like inclusion patterns used to select files from the source\n   * directory for processing. By default, the pattern <code>**&#47;*.avdl<\/code>\n   * is used to select IDL files.\n   *\n   * @parameter\n   */\n  private String[] testIncludes = new String[] { \"**/*.avdl\" };\n\n  @Override\n  protected void doCompile(String filename, File sourceDirectory, File outputDirectory) throws IOException {\n    try {\n      @SuppressWarnings(\"rawtypes\")\n      List runtimeClasspathElements = project.getRuntimeClasspathElements();\n\n      List<URL> runtimeUrls = new ArrayList<>();\n\n      // Add the source directory of avro files to the classpath so that\n      // imports can refer to other idl files as classpath resources\n      runtimeUrls.add(sourceDirectory.toURI().toURL());\n\n      // If runtimeClasspathElements is not empty values add its values to Idl path.\n      if (runtimeClasspathElements != null && !runtimeClasspathElements.isEmpty()) {\n        for (Object runtimeClasspathElement : runtimeClasspathElements) {\n          String element = (String) runtimeClasspathElement;\n          runtimeUrls.add(new File(element).toURI().toURL());\n        }\n      }\n\n      final ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();\n      URLClassLoader projPathLoader = new URLClassLoader(runtimeUrls.toArray(new URL[0]), contextClassLoader);\n      Thread.currentThread().setContextClassLoader(projPathLoader);\n      try {\n        IdlReader parser = new IdlReader();\n        Path sourceFilePath = sourceDirectory.toPath().resolve(filename);\n        IdlFile idlFile = parser.parse(sourceFilePath);\n        for (String warning : idlFile.getWarnings()) {\n          getLog().warn(warning);\n        }\n        idlFile = parser.resolve(idlFile);\n        final SpecificCompiler compiler;\n        final Protocol protocol = idlFile.getProtocol();\n        if (protocol != null) {\n          compiler = new SpecificCompiler(protocol);\n        } else {\n          compiler = new SpecificCompiler(idlFile.getNamedSchemas().values());\n        }\n        compiler.setStringType(GenericData.StringType.valueOf(stringType));\n        compiler.setTemplateDir(templateDirectory);\n        compiler.setFieldVisibility(getFieldVisibility());\n        compiler.setCreateOptionalGetters(createOptionalGetters);\n        compiler.setGettersReturnOptional(gettersReturnOptional);\n        compiler.setOptionalGettersForNullableFieldsOnly(optionalGettersForNullableFieldsOnly);\n        compiler.setCreateSetters(createSetters);\n        compiler.setAdditionalVelocityTools(instantiateAdditionalVelocityTools());\n        compiler.setEnableDecimalLogicalType(enableDecimalLogicalType);\n        for (String customConversion : customConversions) {\n          compiler.addCustomConversion(projPathLoader.loadClass(customConversion));\n        }\n        compiler.setOutputCharacterEncoding(project.getProperties().getProperty(\"project.build.sourceEncoding\"));\n        compiler.compileToDestination(sourceFilePath.toFile(), outputDirectory);\n      } finally {\n        Thread.currentThread().setContextClassLoader(contextClassLoader);\n      }\n    } catch (ClassNotFoundException | DependencyResolutionRequiredException e) {\n      throw new IOException(e);\n    }\n  }\n\n  @Override\n  protected String[] getIncludes() {\n    return includes;\n  }\n\n  @Override\n  protected String[] getTestIncludes() {\n    return testIncludes;\n  }\n}\n","lineNo":88}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.avro.reflect;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.Matchers.is;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.lang.reflect.Array;\nimport java.nio.ByteBuffer;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Random;\nimport org.apache.avro.AvroRuntimeException;\nimport org.apache.avro.AvroTypeException;\nimport org.apache.avro.JsonProperties;\nimport org.apache.avro.Protocol;\nimport org.apache.avro.Schema;\nimport org.apache.avro.Schema.Field;\nimport org.apache.avro.SchemaBuilder;\nimport org.apache.avro.generic.GenericData;\nimport org.apache.avro.io.Decoder;\nimport org.apache.avro.io.DecoderFactory;\nimport org.apache.avro.io.Encoder;\nimport org.apache.avro.io.EncoderFactory;\nimport org.apache.avro.reflect.TestReflect.SampleRecord.AnotherSampleRecord;\nimport org.apache.avro.util.Utf8;\nimport org.junit.jupiter.api.Test;\n\npublic class TestReflect {\n\n  EncoderFactory factory = new EncoderFactory();\n\n  // test primitive type inference\n  @Test\n  void testVoid() {\n    check(Void.TYPE, \"\\\"null\\\"\");\n    check(Void.class, \"\\\"null\\\"\");\n  }\n\n  @Test\n  void testBoolean() {\n    check(Boolean.TYPE, \"\\\"boolean\\\"\");\n    check(Boolean.class, \"\\\"boolean\\\"\");\n  }\n\n  @Test\n  void testInt() {\n    check(Integer.TYPE, \"\\\"int\\\"\");\n    check(Integer.class, \"\\\"int\\\"\");\n  }\n\n  @Test\n  void testByte() {\n    check(Byte.TYPE, \"{\\\"type\\\":\\\"int\\\",\\\"java-class\\\":\\\"java.lang.Byte\\\"}\");\n    check(Byte.class, \"{\\\"type\\\":\\\"int\\\",\\\"java-class\\\":\\\"java.lang.Byte\\\"}\");\n  }\n\n  @Test\n  void testShort() {\n    check(Short.TYPE, \"{\\\"type\\\":\\\"int\\\",\\\"java-class\\\":\\\"java.lang.Short\\\"}\");\n    check(Short.class, \"{\\\"type\\\":\\\"int\\\",\\\"java-class\\\":\\\"java.lang.Short\\\"}\");\n  }\n\n  @Test\n  void testChar() {\n    check(Character.TYPE, \"{\\\"type\\\":\\\"int\\\",\\\"java-class\\\":\\\"java.lang.Character\\\"}\");\n    check(Character.class, \"{\\\"type\\\":\\\"int\\\",\\\"java-class\\\":\\\"java.lang.Character\\\"}\");\n  }\n\n  @Test\n  void testLong() {\n    check(Long.TYPE, \"\\\"long\\\"\");\n    check(Long.class, \"\\\"long\\\"\");\n  }\n\n  @Test\n  void testFloat() {\n    check(Float.TYPE, \"\\\"float\\\"\");\n    check(Float.class, \"\\\"float\\\"\");\n  }\n\n  @Test\n  void testDouble() {\n    check(Double.TYPE, \"\\\"double\\\"\");\n    check(Double.class, \"\\\"double\\\"\");\n  }\n\n  @Test\n  void string() {\n    check(\"Foo\", \"\\\"string\\\"\");\n  }\n\n  @Test\n  void bytes() {\n    check(ByteBuffer.allocate(0), \"\\\"bytes\\\"\");\n    check(new byte[0], \"{\\\"type\\\":\\\"bytes\\\",\\\"java-class\\\":\\\"[B\\\"}\");\n  }\n\n  @Test\n  void unionWithCollection() {\n    Schema s = new Schema.Parser().parse(\"[\\\"null\\\", {\\\"type\\\":\\\"array\\\",\\\"items\\\":\\\"float\\\"}]\");\n    GenericData data = ReflectData.get();\n    assertEquals(1, data.resolveUnion(s, new ArrayList<Float>()));\n  }\n\n  @Test\n  void unionWithMap() {\n    Schema s = new Schema.Parser().parse(\"[\\\"null\\\", {\\\"type\\\":\\\"map\\\",\\\"values\\\":\\\"float\\\"}]\");\n    GenericData data = ReflectData.get();\n    assertEquals(1, data.resolveUnion(s, new HashMap<String, Float>()));\n  }\n\n  @Test\n  void unionWithMapWithUtf8Keys() {\n    Schema s = new Schema.Parser().parse(\"[\\\"null\\\", {\\\"type\\\":\\\"map\\\",\\\"values\\\":\\\"float\\\"}]\");\n    GenericData data = ReflectData.get();\n    HashMap<Utf8, Float> map = new HashMap<>();\n    map.put(new Utf8(\"foo\"), 1.0f);\n    assertEquals(1, data.resolveUnion(s, map));\n  }\n\n  @Test\n  void unionWithFixed() {\n    Schema s = new Schema.Parser().parse(\"[\\\"null\\\", {\\\"type\\\":\\\"fixed\\\",\\\"name\\\":\\\"f\\\",\\\"size\\\":1}]\");\n    Schema f = new Schema.Parser().parse(\"{\\\"type\\\":\\\"fixed\\\",\\\"name\\\":\\\"f\\\",\\\"size\\\":1}\");\n    GenericData data = ReflectData.get();\n    assertEquals(1, data.resolveUnion(s, new GenericData.Fixed(f)));\n  }\n\n  @Test\n  void unionWithEnum() {\n    Schema s = new Schema.Parser().parse(\"[\\\"null\\\", {\\\"type\\\":\\\"enum\\\",\\\"name\\\":\\\"E\\\",\\\"namespace\\\":\"\n        + \"\\\"org.apache.avro.reflect.TestReflect\\\",\\\"symbols\\\":[\\\"A\\\",\\\"B\\\"]}]\");\n    GenericData data = ReflectData.get();\n    assertEquals(1, data.resolveUnion(s, E.A));\n  }\n\n  @Test\n  void unionWithBytes() {\n    Schema s = new Schema.Parser().parse(\"[\\\"null\\\", \\\"bytes\\\"]\");\n    GenericData data = ReflectData.get();\n    assertEquals(1, data.resolveUnion(s, ByteBuffer.wrap(new byte[] { 1 })));\n  }\n\n  // test map, array and list type inference\n  public static class R1 {\n    private Map<String, String> mapField = new HashMap<>();\n    private String[] arrayField = new String[] { \"foo\" };\n    private List<String> listField = new ArrayList<>();\n\n    {\n      mapField.put(\"foo\", \"bar\");\n      listField.add(\"foo\");\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (!(o instanceof R1))\n        return false;\n      R1 that = (R1) o;\n      return mapField.equals(that.mapField) && Arrays.equals(this.arrayField, that.arrayField)\n          && listField.equals(that.listField);\n    }\n  }\n\n  @Test\n  void map() throws Exception {\n    check(R1.class.getDeclaredField(\"mapField\").getGenericType(), \"{\\\"type\\\":\\\"map\\\",\\\"values\\\":\\\"string\\\"}\");\n  }\n\n  @Test\n  void array() throws Exception {\n    check(R1.class.getDeclaredField(\"arrayField\").getGenericType(),\n        \"{\\\"type\\\":\\\"array\\\",\\\"items\\\":\\\"string\\\",\\\"java-class\\\":\\\"[Ljava.lang.String;\\\"}\");\n  }\n\n  @Test\n  void list() throws Exception {\n    check(R1.class.getDeclaredField(\"listField\").getGenericType(),\n        \"{\\\"type\\\":\\\"array\\\",\\\"items\\\":\\\"string\\\"\" + \",\\\"java-class\\\":\\\"java.util.List\\\"}\");\n  }\n\n  @Test\n  void r1() throws Exception {\n    checkReadWrite(new R1());\n  }\n\n  // test record, array and list i/o\n  public static class R2 {\n    private String[] arrayField;\n    private Collection<String> collectionField;\n\n    @Override\n    public boolean equals(Object o) {\n      if (!(o instanceof R2))\n        return false;\n      R2 that = (R2) o;\n      return Arrays.equals(this.arrayField, that.arrayField) && collectionField.equals(that.collectionField);\n    }\n  }\n\n  @Test\n  void r2() throws Exception {\n    R2 r2 = new R2();\n    r2.arrayField = new String[] { \"foo\" };\n    r2.collectionField = new ArrayList<>();\n    r2.collectionField.add(\"foo\");\n    checkReadWrite(r2);\n  }\n\n  // test array i/o of unboxed type\n  public static class R3 {\n    private int[] intArray;\n\n    @Override\n    public boolean equals(Object o) {\n      if (!(o instanceof R3))\n        return false;\n      R3 that = (R3) o;\n      return Arrays.equals(this.intArray, that.intArray);\n    }\n  }\n\n  @Test\n  void r3() throws Exception {\n    R3 r3 = new R3();\n    r3.intArray = new int[] { 1 };\n    checkReadWrite(r3);\n  }\n\n  // test inherited fields & short datatype\n  public static class R4 {\n    public short value;\n    public short[] shorts;\n    public byte b;\n    public char c;\n\n    @Override\n    public boolean equals(Object o) {\n      if (!(o instanceof R4))\n        return false;\n      R4 that = (R4) o;\n      return this.value == that.value && Arrays.equals(this.shorts, that.shorts) && this.b == that.b\n          && this.c == that.c;\n    }\n  }\n\n  public static class R5 extends R4 {\n  }\n\n  @Test\n  void r5() throws Exception {\n    R5 r5 = new R5();\n    r5.value = 1;\n    r5.shorts = new short[] { 3, 255, 256, Short.MAX_VALUE, Short.MIN_VALUE };\n    r5.b = 99;\n    r5.c = 'a';\n    checkReadWrite(r5);\n  }\n\n  // test union annotation on a class\n  @Union({ R7.class, R8.class })\n  public static class R6 {\n  }\n\n  public static class R7 extends R6 {\n    public int value;\n\n    @Override\n    public boolean equals(Object o) {\n      if (!(o instanceof R7))\n        return false;\n      return this.value == ((R7) o).value;\n    }\n  }\n\n  public static class R8 extends R6 {\n    public float value;\n\n    @Override\n    public boolean equals(Object o) {\n      if (!(o instanceof R8))\n        return false;\n      return this.value == ((R8) o).value;\n    }\n  }\n\n  // test arrays of union annotated class\n  public static class R9 {\n    public R6[] r6s;\n\n    @Override\n    public boolean equals(Object o) {\n      if (!(o instanceof R9))\n        return false;\n      return Arrays.equals(this.r6s, ((R9) o).r6s);\n    }\n  }\n\n  @Test\n  void r6() throws Exception {\n    R7 r7 = new R7();\n    r7.value = 1;\n    checkReadWrite(r7, ReflectData.get().getSchema(R6.class));\n    R8 r8 = new R8();\n    r8.value = 1;\n    checkReadWrite(r8, ReflectData.get().getSchema(R6.class));\n    R9 r9 = new R9();\n    r9.r6s = new R6[] { r7, r8 };\n    checkReadWrite(r9, ReflectData.get().getSchema(R9.class));\n  }\n\n  // test union in fields\n  public static class R9_1 {\n    @Union({ Void.class, R7.class, R8.class })\n    public Object value;\n\n    @Override\n    public boolean equals(Object o) {\n      if (!(o instanceof R9_1))\n        return false;\n      if (this.value == null)\n        return ((R9_1) o).value == null;\n      return this.value.equals(((R9_1) o).value);\n    }\n  }\n\n  @Test\n  void r6_1() throws Exception {\n    R7 r7 = new R7();\n    r7.value = 1;\n    checkReadWrite(r7, ReflectData.get().getSchema(R6.class));\n    R8 r8 = new R8();\n    r8.value = 1;\n    checkReadWrite(r8, ReflectData.get().getSchema(R6.class));\n    R9_1 r9_1 = new R9_1();\n    r9_1.value = null;\n    checkReadWrite(r9_1, ReflectData.get().getSchema(R9_1.class));\n    r9_1.value = r7;\n    checkReadWrite(r9_1, ReflectData.get().getSchema(R9_1.class));\n    r9_1.value = r8;\n    checkReadWrite(r9_1, ReflectData.get().getSchema(R9_1.class));\n  }\n\n  // test union annotation on methods and parameters\n  public static interface P0 {\n    @Union({ Void.class, String.class })\n    String foo(@Union({ Void.class, String.class }) String s);\n  }\n\n  @Test\n  void p0() throws Exception {\n    Protocol p0 = ReflectData.get().getProtocol(P0.class);\n    Protocol.Message message = p0.getMessages().get(\"foo\");\n    // check response schema is union\n    Schema response = message.getResponse();\n    assertEquals(Schema.Type.UNION, response.getType());\n    assertEquals(Schema.Type.NULL, response.getTypes().get(0).getType());\n    assertEquals(Schema.Type.STRING, response.getTypes().get(1).getType());\n    // check request schema is union\n    Schema request = message.getRequest();\n    Field field = request.getField(\"s\");\n    assertNotNull(field, \"field 's' should not be null\");\n    Schema param = field.schema();\n    assertEquals(Schema.Type.UNION, param.getType());\n    assertEquals(Schema.Type.NULL, param.getTypes().get(0).getType());\n    assertEquals(Schema.Type.STRING, param.getTypes().get(1).getType());\n    // check union erasure\n    assertEquals(String.class, ReflectData.get().getClass(response));\n    assertEquals(String.class, ReflectData.get().getClass(param));\n  }\n\n  // test Stringable annotation\n  @Stringable\n  public static class R10 {\n    private String text;\n\n    public R10(String text) {\n      this.text = text;\n    }\n\n    @Override\n    public String toString() {\n      return text;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (!(o instanceof R10))\n        return false;\n      return this.text.equals(((R10) o).text);\n    }\n  }\n\n  @Test\n  void r10() throws Exception {\n    Schema r10Schema = ReflectData.get().getSchema(R10.class);\n    assertEquals(Schema.Type.STRING, r10Schema.getType());\n    assertEquals(R10.class.getName(), r10Schema.getProp(\"java-class\"));\n    checkReadWrite(new R10(\"foo\"), r10Schema);\n  }\n\n  // test Nullable annotation on field\n  public static class R11 {\n    @Nullable\n    private String text;\n\n    @Override\n    public boolean equals(Object o) {\n      if (!(o instanceof R11))\n        return false;\n      R11 that = (R11) o;\n      if (this.text == null)\n        return that.text == null;\n      return this.text.equals(that.text);\n    }\n  }\n\n  @Test\n  void r11() throws Exception {\n    Schema r11Record = ReflectData.get().getSchema(R11.class);\n    assertEquals(Schema.Type.RECORD, r11Record.getType());\n    Field r11Field = r11Record.getField(\"text\");\n    assertEquals(JsonProperties.NULL_VALUE, r11Field.defaultVal());\n    Schema r11FieldSchema = r11Field.schema();\n    assertEquals(Schema.Type.UNION, r11FieldSchema.getType());\n    assertEquals(Schema.Type.NULL, r11FieldSchema.getTypes().get(0).getType());\n    Schema r11String = r11FieldSchema.getTypes().get(1);\n    assertEquals(Schema.Type.STRING, r11String.getType());\n    R11 r11 = new R11();\n    checkReadWrite(r11, r11Record);\n    r11.text = \"foo\";\n    checkReadWrite(r11, r11Record);\n  }\n\n  // test nullable annotation on methods and parameters\n  public static interface P1 {\n    @Nullable\n    String foo(@Nullable String s);\n  }\n\n  @Test\n  void p1() throws Exception {\n    Protocol p1 = ReflectData.get().getProtocol(P1.class);\n    Protocol.Message message = p1.getMessages().get(\"foo\");\n    // check response schema is union\n    Schema response = message.getResponse();\n    assertEquals(Schema.Type.UNION, response.getType());\n    assertEquals(Schema.Type.NULL, response.getTypes().get(0).getType());\n    assertEquals(Schema.Type.STRING, response.getTypes().get(1).getType());\n    // check request schema is union\n    Schema request = message.getRequest();\n    Field field = request.getField(\"s\");\n    assertNotNull(field, \"field 's' should not be null\");\n    Schema param = field.schema();\n    assertEquals(Schema.Type.UNION, param.getType());\n    assertEquals(Schema.Type.NULL, param.getTypes().get(0).getType());\n    assertEquals(Schema.Type.STRING, param.getTypes().get(1).getType());\n    // check union erasure\n    assertEquals(String.class, ReflectData.get().getClass(response));\n    assertEquals(String.class, ReflectData.get().getClass(param));\n  }\n\n  // test AvroSchema annotation\n  public static class R12 { // fields\n    @AvroSchema(\"\\\"int\\\"\")\n    Object x;\n\n    @AvroSchema(\"{\\\"type\\\":\\\"array\\\",\\\"items\\\":[\\\"null\\\",\\\"string\\\"]}\")\n    List<String> strings;\n  }\n\n  @Test\n  void r12() throws Exception {\n    Schema s = ReflectData.get().getSchema(R12.class);\n    assertEquals(Schema.Type.INT, s.getField(\"x\").schema().getType());\n    assertEquals(new Schema.Parser().parse(\"{\\\"type\\\":\\\"array\\\",\\\"items\\\":[\\\"null\\\",\\\"string\\\"]}\"),\n        s.getField(\"strings\").schema());\n  }\n\n  @AvroSchema(\"\\\"null\\\"\") // record\n  public static class R13 {\n  }\n\n  @Test\n  void r13() throws Exception {\n    Schema s = ReflectData.get().getSchema(R13.class);\n    assertEquals(Schema.Type.NULL, s.getType());\n  }\n\n  public interface P4 {\n    @AvroSchema(\"\\\"int\\\"\") // message value\n    Object foo(@AvroSchema(\"\\\"int\\\"\") Object x); // message param\n  }\n\n  @Test\n  void p4() throws Exception {\n    Protocol p = ReflectData.get().getProtocol(P4.class);\n    Protocol.Message message = p.getMessages().get(\"foo\");\n    assertEquals(Schema.Type.INT, message.getResponse().getType());\n    Field field = message.getRequest().getField(\"x\");\n    assertEquals(Schema.Type.INT, field.schema().getType());\n  }\n\n  // test error\n  @SuppressWarnings(\"serial\")\n  public static class E1 extends Exception {\n  }\n\n  public static interface P2 {\n    void error() throws E1;\n  }\n\n  @Test\n  void p2() throws Exception {\n    Schema e1 = ReflectData.get().getSchema(E1.class);\n    assertEquals(Schema.Type.RECORD, e1.getType());\n    assertTrue(e1.isError());\n    Field message = e1.getField(\"detailMessage\");\n    assertNotNull(message, \"field 'detailMessage' should not be null\");\n    Schema messageSchema = message.schema();\n    assertEquals(Schema.Type.UNION, messageSchema.getType());\n    assertEquals(Schema.Type.NULL, messageSchema.getTypes().get(0).getType());\n    assertEquals(Schema.Type.STRING, messageSchema.getTypes().get(1).getType());\n\n    Protocol p2 = ReflectData.get().getProtocol(P2.class);\n    Protocol.Message m = p2.getMessages().get(\"error\");\n    // check error schema is union\n    Schema response = m.getErrors();\n    assertEquals(Schema.Type.UNION, response.getType());\n    assertEquals(Schema.Type.STRING, response.getTypes().get(0).getType());\n    assertEquals(e1, response.getTypes().get(1));\n  }\n\n  @Test\n  void noPackage() throws Exception {\n    Class<?> noPackage = Class.forName(\"NoPackage\");\n    Schema s = ReflectData.get().getSchema(noPackage);\n    assertEquals(noPackage.getName(), ReflectData.getClassName(s));\n  }\n\n  void checkReadWrite(Object object) throws Exception {\n    checkReadWrite(object, ReflectData.get().getSchema(object.getClass()));\n  }\n\n  void checkReadWrite(Object object, Schema s) throws Exception {\n    ReflectDatumWriter<Object> writer = new ReflectDatumWriter<>(s);\n    ByteArrayOutputStream out = new ByteArrayOutputStream();\n    writer.write(object, factory.directBinaryEncoder(out, null));\n    ReflectDatumReader<Object> reader = new ReflectDatumReader<>(s);\n    Object after = reader.read(null, DecoderFactory.get().binaryDecoder(out.toByteArray(), null));\n    assertEquals(object, after);\n\n    // check reflective setField works for records\n    if (s.getType().equals(Schema.Type.RECORD)) {\n      Object copy = object.getClass().getDeclaredConstructor().newInstance();\n      for (Field f : s.getFields()) {\n        Object val = ReflectData.get().getField(object, f.name(), f.pos());\n        ReflectData.get().setField(copy, f.name(), f.pos(), val);\n      }\n      assertEquals(object, copy, \"setField\");\n    }\n  }\n\n  public static enum E {\n    A, B\n  }\n\n  @Test\n  void testEnum() throws Exception {\n    check(E.class, \"{\\\"type\\\":\\\"enum\\\",\\\"name\\\":\\\"E\\\",\\\"namespace\\\":\"\n        + \"\\\"org.apache.avro.reflect.TestReflect\\\",\\\"symbols\\\":[\\\"A\\\",\\\"B\\\"]}\");\n  }\n\n  public static class R {\n    int a;\n    long b;\n  }\n\n  @Test\n  void record() throws Exception {\n    check(R.class,\n        \"{\\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"R\\\",\\\"namespace\\\":\" + \"\\\"org.apache.avro.reflect.TestReflect\\\",\\\"fields\\\":[\"\n            + \"{\\\"name\\\":\\\"a\\\",\\\"type\\\":\\\"int\\\"},\" + \"{\\\"name\\\":\\\"b\\\",\\\"type\\\":\\\"long\\\"}]}\");\n  }\n\n  public static class RAvroIgnore {\n    @AvroIgnore\n    int a;\n  }\n\n  @Test\n  void annotationAvroIgnore() throws Exception {\n    check(RAvroIgnore.class, \"{\\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"RAvroIgnore\\\",\\\"namespace\\\":\"\n        + \"\\\"org.apache.avro.reflect.TestReflect\\\",\\\"fields\\\":[]}\");\n  }\n\n  @AvroMeta(key = \"X\", value = \"Y\")\n  public static class RAvroMeta {\n    @AvroMeta(key = \"K\", value = \"V\")\n    int a;\n  }\n\n  @Test\n  void annotationAvroMeta() throws Exception {\n    check(RAvroMeta.class,\n        \"{\\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"RAvroMeta\\\",\\\"namespace\\\":\"\n            + \"\\\"org.apache.avro.reflect.TestReflect\\\",\\\"fields\\\":[\" + \"{\\\"name\\\":\\\"a\\\",\\\"type\\\":\\\"int\\\",\\\"K\\\":\\\"V\\\"}]\"\n            + \",\\\"X\\\":\\\"Y\\\"}\");\n  }\n\n  @AvroMeta(key = \"X\", value = \"Y\")\n  @AvroMeta(key = \"A\", value = \"B\")\n  public static class RAvroMultiMeta {\n    @AvroMeta(key = \"K\", value = \"V\")\n    @AvroMeta(key = \"L\", value = \"W\")\n    int a;\n  }\n\n  @Test\n  void annotationMultiAvroMeta() {\n    check(RAvroMultiMeta.class,\n        \"{\\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"RAvroMultiMeta\\\",\\\"namespace\\\":\"\n            + \"\\\"org.apache.avro.reflect.TestReflect\\\",\\\"fields\\\":[\"\n            + \"{\\\"name\\\":\\\"a\\\",\\\"type\\\":\\\"int\\\",\\\"K\\\":\\\"V\\\",\\\"L\\\":\\\"W\\\"}]\" + \",\\\"X\\\":\\\"Y\\\",\\\"A\\\":\\\"B\\\"}\");\n  }\n\n  public static class RAvroDuplicateFieldMeta {\n    @AvroMeta(key = \"K\", value = \"V\")\n    @AvroMeta(key = \"K\", value = \"W\")\n    int a;\n  }\n\n  @Test\n  void annotationDuplicateFieldAvroMeta() {\n    assertThrows(AvroTypeException.class, () -> {\n      ReflectData.get().getSchema(RAvroDuplicateFieldMeta.class);\n    });\n  }\n\n  @AvroMeta(key = \"K\", value = \"V\")\n  @AvroMeta(key = \"K\", value = \"W\")\n  public static class RAvroDuplicateTypeMeta {\n    int a;\n  }\n\n  @Test\n  void annotationDuplicateTypeAvroMeta() {\n    assertThrows(AvroTypeException.class, () -> {\n      ReflectData.get().getSchema(RAvroDuplicateTypeMeta.class);\n    });\n  }\n\n  public static class RAvroName {\n    @AvroName(\"b\")\n    int a;\n  }\n\n  @Test\n  void annotationAvroName() throws Exception {\n    check(RAvroName.class, \"{\\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"RAvroName\\\",\\\"namespace\\\":\"\n        + \"\\\"org.apache.avro.reflect.TestReflect\\\",\\\"fields\\\":[\" + \"{\\\"name\\\":\\\"b\\\",\\\"type\\\":\\\"int\\\"}]}\");\n  }\n\n  public static class RAvroNameCollide {\n    @AvroName(\"b\")\n    int a;\n    int b;\n  }\n\n  @Test\n  void annotationAvroNameCollide() throws Exception {\n    assertThrows(Exception.class, () -> {\n      check(RAvroNameCollide.class,\n          \"{\\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"RAvroNameCollide\\\",\\\"namespace\\\":\"\n              + \"\\\"org.apache.avro.reflect.TestReflect\\\",\\\"fields\\\":[\" + \"{\\\"name\\\":\\\"b\\\",\\\"type\\\":\\\"int\\\"},\"\n              + \"{\\\"name\\\":\\\"b\\\",\\\"type\\\":\\\"int\\\"}]}\");\n    });\n  }\n\n  public static class RAvroStringableField {\n    @Stringable\n    int a;\n  }\n\n  @Test\n  void annotationAvroStringableFields() throws Exception {\n    check(RAvroStringableField.class, \"{\\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"RAvroStringableField\\\",\\\"namespace\\\":\"\n        + \"\\\"org.apache.avro.reflect.TestReflect\\\",\\\"fields\\\":[\" + \"{\\\"name\\\":\\\"a\\\",\\\"type\\\":\\\"string\\\"}]}\");\n  }\n\n  private void check(Object o, String schemaJson) {\n    check(o.getClass(), schemaJson);\n  }\n\n  private void check(java.lang.reflect.Type type, String schemaJson) {\n    assertEquals(schemaJson, ReflectData.get().getSchema(type).toString());\n  }\n\n  @Test\n  void recordIO() throws IOException {\n    Schema schm = ReflectData.get().getSchema(SampleRecord.class);\n    ReflectDatumWriter<SampleRecord> writer = new ReflectDatumWriter<>(schm);\n    ByteArrayOutputStream out = new ByteArrayOutputStream();\n    SampleRecord record = new SampleRecord();\n    record.x = 5;\n    record.y = 10;\n    writer.write(record, factory.directBinaryEncoder(out, null));\n    ReflectDatumReader<SampleRecord> reader = new ReflectDatumReader<>(schm);\n    SampleRecord decoded = reader.read(null, DecoderFactory.get().binaryDecoder(out.toByteArray(), null));\n    assertEquals(record, decoded);\n  }\n\n  public static class AvroEncRecord {\n    @AvroEncode(using = DateAsLongEncoding.class)\n    java.util.Date date;\n\n    @Override\n    public boolean equals(Object o) {\n      if (!(o instanceof AvroEncRecord))\n        return false;\n      return date.equals(((AvroEncRecord) o).date);\n    }\n  }\n\n  public static class multipleAnnotationRecord {\n    @AvroIgnore\n    @Stringable\n    Integer i1;\n\n    @AvroIgnore\n    @Nullable\n    Integer i2;\n\n    @AvroIgnore\n    @AvroName(\"j\")\n    Integer i3;\n\n    @AvroIgnore\n    @AvroEncode(using = DateAsLongEncoding.class)\n    java.util.Date i4;\n\n    @Stringable\n    @Nullable\n    Integer i5;\n\n    @Stringable\n    @AvroName(\"j6\")\n    Integer i6 = 6;\n\n    @Stringable\n    @AvroEncode(using = DateAsLongEncoding.class)\n    java.util.Date i7 = new java.util.Date(7L);\n\n    @Nullable\n    @AvroName(\"j8\")\n    Integer i8;\n\n    @Nullable\n    @AvroEncode(using = DateAsLongEncoding.class)\n    java.util.Date i9;\n\n    @AvroName(\"j10\")\n    @AvroEncode(using = DateAsLongEncoding.class)\n    java.util.Date i10 = new java.util.Date(10L);\n\n    @Stringable\n    @Nullable\n    @AvroName(\"j11\")\n    @AvroEncode(using = DateAsLongEncoding.class)\n    java.util.Date i11;\n  }\n\n  @Test\n  void multipleAnnotations() throws IOException {\n    Schema schm = ReflectData.get().getSchema(multipleAnnotationRecord.class);\n    ReflectDatumWriter<multipleAnnotationRecord> writer = new ReflectDatumWriter<>(schm);\n    ByteArrayOutputStream out = new ByteArrayOutputStream();\n    multipleAnnotationRecord record = new multipleAnnotationRecord();\n    record.i1 = 1;\n    record.i2 = 2;\n    record.i3 = 3;\n    record.i4 = new java.util.Date(4L);\n    record.i5 = 5;\n    record.i6 = 6;\n    record.i7 = new java.util.Date(7L);\n    record.i8 = 8;\n    record.i9 = new java.util.Date(9L);\n    record.i10 = new java.util.Date(10L);\n    record.i11 = new java.util.Date(11L);\n\n    writer.write(record, factory.directBinaryEncoder(out, null));\n    ReflectDatumReader<multipleAnnotationRecord> reader = new ReflectDatumReader<>(schm);\n    multipleAnnotationRecord decoded = reader.read(new multipleAnnotationRecord(),\n        DecoderFactory.get().binaryDecoder(out.toByteArray(), null));\n    assertNull(decoded.i1);\n    assertNull(decoded.i2);\n    assertNull(decoded.i3);\n    assertNull(decoded.i4);\n    assertEquals(decoded.i5, 5);\n    assertEquals(decoded.i6, 6);\n    assertEquals(decoded.i7.getTime(), 7);\n    assertEquals(decoded.i8, 8);\n    assertEquals(decoded.i9.getTime(), 9);\n    assertEquals(decoded.i10.getTime(), 10);\n    assertEquals(decoded.i11.getTime(), 11);\n  }\n\n  @Test\n  void avroEncodeInducing() throws IOException {\n    Schema schm = ReflectData.get().getSchema(AvroEncRecord.class);\n    assertEquals(schm.toString(),\n        \"{\\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"AvroEncRecord\\\",\\\"namespace\"\n            + \"\\\":\\\"org.apache.avro.reflect.TestReflect\\\",\\\"fields\\\":[{\\\"name\\\":\\\"date\\\",\"\n            + \"\\\"type\\\":{\\\"type\\\":\\\"long\\\",\\\"CustomEncoding\\\":\\\"DateAsLongEncoding\\\"}}]}\");\n  }\n\n  @Test\n  void avroEncodeIO() throws IOException {\n    Schema schm = ReflectData.get().getSchema(AvroEncRecord.class);\n    ReflectDatumWriter<AvroEncRecord> writer = new ReflectDatumWriter<>(schm);\n    ByteArrayOutputStream out = new ByteArrayOutputStream();\n    AvroEncRecord record = new AvroEncRecord();\n    record.date = new java.util.Date(948833323L);\n    writer.write(record, factory.directBinaryEncoder(out, null));\n    ReflectDatumReader<AvroEncRecord> reader = new ReflectDatumReader<>(schm);\n    AvroEncRecord decoded = reader.read(new AvroEncRecord(),\n        DecoderFactory.get().binaryDecoder(out.toByteArray(), null));\n    assertEquals(record, decoded);\n  }\n\n  @Test\n  void recordWithNullIO() throws IOException {\n    ReflectData reflectData = ReflectData.AllowNull.get();\n    Schema schm = reflectData.getSchema(AnotherSampleRecord.class);\n    ReflectDatumWriter<AnotherSampleRecord> writer = new ReflectDatumWriter<>(schm);\n    ByteArrayOutputStream out = new ByteArrayOutputStream();\n    // keep record.a null and see if that works\n    Encoder e = factory.directBinaryEncoder(out, null);\n    AnotherSampleRecord a = new AnotherSampleRecord();\n    writer.write(a, e);\n    AnotherSampleRecord b = new AnotherSampleRecord(10);\n    writer.write(b, e);\n    e.flush();\n    ReflectDatumReader<AnotherSampleRecord> reader = new ReflectDatumReader<>(schm);\n    ByteArrayInputStream in = new ByteArrayInputStream(out.toByteArray());\n    Decoder d = DecoderFactory.get().binaryDecoder(in, null);\n    AnotherSampleRecord decoded = reader.read(null, d);\n    assertEquals(a, decoded);\n    decoded = reader.read(null, d);\n    assertEquals(b, decoded);\n  }\n\n  @Test\n  void disableUnsafe() throws Exception {\n    String saved = System.getProperty(\"avro.disable.unsafe\");\n    try {\n      System.setProperty(\"avro.disable.unsafe\", \"true\");\n      ReflectData.ACCESSOR_CACHE.remove(multipleAnnotationRecord.class);\n      ReflectData.ACCESSOR_CACHE.remove(AnotherSampleRecord.class);\n      ReflectionUtil.resetFieldAccess();\n      multipleAnnotations();\n      recordWithNullIO();\n    } finally {\n      if (saved == null)\n        System.clearProperty(\"avro.disable.unsafe\");\n      else\n        System.setProperty(\"avro.disable.unsafe\", saved);\n      ReflectData.ACCESSOR_CACHE.remove(multipleAnnotationRecord.class);\n      ReflectData.ACCESSOR_CACHE.remove(AnotherSampleRecord.class);\n      ReflectionUtil.resetFieldAccess();\n    }\n  }\n\n  public static class SampleRecord {\n    public int x = 1;\n    private int y = 2;\n\n    @Override\n    public int hashCode() {\n      return x + y;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n      if (this == obj)\n        return true;\n      if (obj == null)\n        return false;\n      if (getClass() != obj.getClass())\n        return false;\n      final SampleRecord other = (SampleRecord) obj;\n      if (x != other.x)\n        return false;\n      return y == other.y;\n    }\n\n    public static class AnotherSampleRecord {\n      private Integer a = null;\n      private SampleRecord s = null;\n\n      public AnotherSampleRecord() {\n      }\n\n      AnotherSampleRecord(Integer a) {\n        this.a = a;\n        this.s = new SampleRecord();\n      }\n\n      @Override\n      public int hashCode() {\n        int hash = (a != null ? a.hashCode() : 0);\n        hash += (s != null ? s.hashCode() : 0);\n        return hash;\n      }\n\n      @Override\n      public boolean equals(Object other) {\n        if (other instanceof AnotherSampleRecord) {\n          AnotherSampleRecord o = (AnotherSampleRecord) other;\n          return (this.a != null || o.a == null) && (this.a == null || this.a.equals(o.a))\n              && (this.s != null || o.s == null) && (this.s == null || this.s.equals(o.s));\n        } else {\n          return false;\n        }\n      }\n    }\n  }\n\n  public static class X {\n    int i;\n  }\n\n  public static class B1 {\n    X x;\n  }\n\n  public static class B2 {\n    X x;\n  }\n\n  public static class A {\n    B1 b1;\n    B2 b2;\n  }\n\n  public static interface C {\n    void foo(A a);\n  }\n\n  @Test\n  void forwardReference() {\n    ReflectData data = ReflectData.get();\n    Protocol reflected = data.getProtocol(C.class);\n    Protocol reparsed = Protocol.parse(reflected.toString());\n    assertEquals(reflected, reparsed);\n    assert (reparsed.getTypes().contains(data.getSchema(A.class)));\n    assert (reparsed.getTypes().contains(data.getSchema(B1.class)));\n    assert (reparsed.getTypes().contains(data.getSchema(B2.class)));\n    assert (reparsed.getTypes().contains(data.getSchema(X.class)));\n  }\n\n  public static interface P3 {\n    void m1();\n\n    void m1(int x);\n  }\n\n  @Test\n  void overloadedMethod() {\n    assertThrows(AvroTypeException.class, () -> {\n      ReflectData.get().getProtocol(P3.class);\n    });\n  }\n\n  @Test\n  void noPackageSchema() throws Exception {\n    ReflectData.get().getSchema(Class.forName(\"NoPackage\"));\n  }\n\n  @Test\n  void noPackageProtocol() throws Exception {\n    ReflectData.get().getProtocol(Class.forName(\"NoPackage\"));\n  }\n\n  public static class Y {\n    int i;\n  }\n\n  /** Test nesting of reflect data within generic. */\n  @Test\n  void reflectWithinGeneric() throws Exception {\n    ReflectData data = ReflectData.get();\n    // define a record with a field that's a specific Y\n    Schema schema = Schema.createRecord(\"Foo\", \"\", \"x.y.z\", false);\n    List<Schema.Field> fields = new ArrayList<>();\n    fields.add(new Schema.Field(\"f\", data.getSchema(Y.class), \"\", null));\n    schema.setFields(fields);\n\n    // create a generic instance of this record\n    Y y = new Y();\n    y.i = 1;\n    GenericData.Record record = new GenericData.Record(schema);\n    record.put(\"f\", y);\n\n    // test that this instance can be written & re-read\n    checkBinary(schema, record);\n  }\n\n  @Test\n  void primitiveArray() throws Exception {\n    testPrimitiveArrays(false);\n  }\n\n  @Test\n  void primitiveArrayBlocking() throws Exception {\n    testPrimitiveArrays(true);\n  }\n\n  private void testPrimitiveArrays(boolean blocking) throws Exception {\n    testPrimitiveArray(boolean.class, blocking);\n    testPrimitiveArray(byte.class, blocking);\n    testPrimitiveArray(short.class, blocking);\n    testPrimitiveArray(char.class, blocking);\n    testPrimitiveArray(int.class, blocking);\n    testPrimitiveArray(long.class, blocking);\n    testPrimitiveArray(float.class, blocking);\n    testPrimitiveArray(double.class, blocking);\n  }\n\n  private void testPrimitiveArray(Class<?> c, boolean blocking) throws Exception {\n    ReflectData data = new ReflectData();\n    Random r = new Random();\n    int size = 200;\n    Object array = Array.newInstance(c, size);\n    Schema s = data.getSchema(array.getClass());\n    for (int i = 0; i < size; i++) {\n      Array.set(array, i, randomFor(c, r));\n    }\n    checkBinary(data, s, array, false, blocking);\n  }\n\n  private Object randomFor(Class<?> c, Random r) {\n    if (c == boolean.class)\n      return r.nextBoolean();\n    if (c == int.class)\n      return r.nextInt();\n    if (c == long.class)\n      return r.nextLong();\n    if (c == byte.class)\n      return (byte) r.nextInt();\n    if (c == float.class)\n      return r.nextFloat();\n    if (c == double.class)\n      return r.nextDouble();\n    if (c == char.class)\n      return (char) r.nextInt();\n    if (c == short.class)\n      return (short) r.nextInt();\n    return null;\n  }\n\n  /** Test union of null and an array. */\n  @Test\n  void nullArray() throws Exception {\n    String json = \"[{\\\"type\\\":\\\"array\\\", \\\"items\\\": \\\"long\\\"}, \\\"null\\\"]\";\n    Schema schema = new Schema.Parser().parse(json);\n    checkBinary(schema, null);\n  }\n\n  /** Test stringable classes. */\n  @Test\n  void stringables() throws Exception {\n    checkStringable(java.math.BigDecimal.class, \"10\");\n    checkStringable(java.math.BigInteger.class, \"20\");\n    checkStringable(java.net.URI.class, \"foo://bar:9000/baz\");\n    checkStringable(java.net.URL.class, \"http://bar:9000/baz\");\n    checkStringable(java.io.File.class, \"foo.bar\");\n  }\n\n  @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n  public void checkStringable(Class c, String value) throws Exception {\n    ReflectData data = new ReflectData();\n    Schema schema = data.getSchema(c);\n    assertEquals(\"{\\\"type\\\":\\\"string\\\",\\\"java-class\\\":\\\"\" + c.getName() + \"\\\"}\", schema.toString());\n    checkBinary(schema, c.getConstructor(String.class).newInstance(value));\n  }\n\n  public static class M1 {\n    Map<Integer, String> integerKeyMap;\n    Map<java.math.BigInteger, String> bigIntegerKeyMap;\n    Map<java.math.BigDecimal, String> bigDecimalKeyMap;\n    Map<java.io.File, String> fileKeyMap;\n  }\n\n  /** Test Map with stringable key classes. */\n  @Test\n  void stringableMapKeys() throws Exception {\n    M1 record = new M1();\n    record.integerKeyMap = new HashMap<>(1);\n    record.integerKeyMap.put(10, \"foo\");\n\n    record.bigIntegerKeyMap = new HashMap<>(1);\n    record.bigIntegerKeyMap.put(java.math.BigInteger.TEN, \"bar\");\n\n    record.bigDecimalKeyMap = new HashMap<>(1);\n    record.bigDecimalKeyMap.put(java.math.BigDecimal.ONE, \"bigDecimal\");\n\n    record.fileKeyMap = new HashMap<>(1);\n    record.fileKeyMap.put(new java.io.File(\"foo.bar\"), \"file\");\n\n    ReflectData data = new ReflectData().addStringable(Integer.class);\n\n    checkBinary(data, data.getSchema(M1.class), record, true);\n  }\n\n  public static class NullableStringable {\n    java.math.BigDecimal number;\n  }\n\n  @Test\n  void nullableStringableField() throws Exception {\n    NullableStringable datum = new NullableStringable();\n    datum.number = java.math.BigDecimal.TEN;\n\n    Schema schema = ReflectData.AllowNull.get().getSchema(NullableStringable.class);\n    checkBinary(schema, datum);\n  }\n\n  public static void checkBinary(ReflectData reflectData, Schema schema, Object datum, boolean equals)\n      throws IOException {\n    checkBinary(reflectData, schema, datum, equals, false);\n  }\n\n  private static void checkBinary(ReflectData reflectData, Schema schema, Object datum, boolean equals,\n      boolean blocking) throws IOException {\n    ReflectDatumWriter<Object> writer = new ReflectDatumWriter<>(schema);\n    ByteArrayOutputStream out = new ByteArrayOutputStream();\n    if (!blocking) {\n      writer.write(datum, EncoderFactory.get().directBinaryEncoder(out, null));\n    } else {\n      writer.write(datum, new EncoderFactory().configureBlockSize(64).blockingBinaryEncoder(out, null));\n    }\n    writer.write(datum, EncoderFactory.get().directBinaryEncoder(out, null));\n    byte[] data = out.toByteArray();\n\n    ReflectDatumReader<Object> reader = new ReflectDatumReader<>(schema);\n    Object decoded = reader.read(null, DecoderFactory.get().binaryDecoder(data, null));\n\n    assertEquals(0, reflectData.compare(datum, decoded, schema, equals));\n  }\n\n  public static void checkBinary(Schema schema, Object datum) throws IOException {\n    checkBinary(ReflectData.get(), schema, datum, false);\n  }\n\n  /** Test that the error message contains the name of the class. */\n  @Test\n  void reflectFieldError() throws Exception {\n    Object datum = \"\";\n    try {\n      ReflectData.get().getField(datum, \"notAFieldOfString\", 0);\n    } catch (AvroRuntimeException e) {\n      assertTrue(e.getMessage().contains(datum.getClass().getName()));\n    }\n  }\n\n  @AvroAlias(alias = \"a\", space = \"b\")\n  private static class AliasA {\n  }\n\n  @AvroAlias(alias = \"a\", space = \"\")\n  private static class AliasB {\n  }\n\n  @AvroAlias(alias = \"a\")\n  private static class AliasC {\n  }\n\n  @Test\n  void avroAliasOnClass() {\n    check(AliasA.class,\n        \"{\\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"AliasA\\\",\\\"namespace\\\":\\\"org.apache.avro.reflect.TestReflect\\\",\\\"fields\\\":[],\\\"aliases\\\":[\\\"b.a\\\"]}\");\n    check(AliasB.class,\n        \"{\\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"AliasB\\\",\\\"namespace\\\":\\\"org.apache.avro.reflect.TestReflect\\\",\\\"fields\\\":[],\\\"aliases\\\":[\\\"a\\\"]}\");\n    check(AliasC.class,\n        \"{\\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"AliasC\\\",\\\"namespace\\\":\\\"org.apache.avro.reflect.TestReflect\\\",\\\"fields\\\":[],\\\"aliases\\\":[\\\"a\\\"]}\");\n  }\n\n  @AvroAlias(alias = \"alias1\", space = \"space1\")\n  @AvroAlias(alias = \"alias2\", space = \"space2\")\n  private static class MultipleAliasRecord {\n\n  }\n\n  @Test\n  void multipleAliasAnnotationsOnClass() {\n    check(MultipleAliasRecord.class,\n        \"{\\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"MultipleAliasRecord\\\",\\\"namespace\\\":\\\"org.apache.avro.reflect.TestReflect\\\",\\\"fields\\\":[],\\\"aliases\\\":[\\\"space1.alias1\\\",\\\"space2.alias2\\\"]}\");\n\n  }\n\n  private static class Z {\n  }\n\n  @Test\n  void dollarTerminatedNamespaceCompatibility() {\n    ReflectData data = ReflectData.get();\n    Schema s = new Schema.Parser().setValidate(false).parse(\n        \"{\\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"Z\\\",\\\"namespace\\\":\\\"org.apache.avro.reflect.TestReflect$\\\",\\\"fields\\\":[]}\");\n    assertEquals(data.getSchema(data.getClass(s)).toString(),\n        \"{\\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"Z\\\",\\\"namespace\\\":\\\"org.apache.avro.reflect.TestReflect\\\",\\\"fields\\\":[]}\");\n  }\n\n  @Test\n  void dollarTerminatedNestedStaticClassNamespaceCompatibility() {\n    ReflectData data = ReflectData.get();\n    // Older versions of Avro generated this namespace on nested records.\n    Schema s = new Schema.Parser().setValidate(false).parse(\n        \"{\\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"AnotherSampleRecord\\\",\\\"namespace\\\":\\\"org.apache.avro.reflect.TestReflect$SampleRecord\\\",\\\"fields\\\":[]}\");\n    assertThat(data.getSchema(data.getClass(s)).getFullName(),\n        is(\"org.apache.avro.reflect.TestReflect.SampleRecord.AnotherSampleRecord\"));\n  }\n\n  private static class ClassWithAliasOnField {\n    @AvroAlias(alias = \"aliasName\")\n    int primitiveField;\n  }\n\n  private static class ClassWithMultipleAliasesOnField {\n    @AvroAlias(alias = \"alias1\")\n    @AvroAlias(alias = \"alias2\")\n    int primitiveField;\n  }\n\n  private static class ClassWithAliasAndNamespaceOnField {\n    @AvroAlias(alias = \"aliasName\", space = \"forbidden.space.entry\")\n    int primitiveField;\n  }\n\n  @Test\n  void avroAliasOnField() {\n\n    Schema expectedSchema = SchemaBuilder.record(ClassWithAliasOnField.class.getSimpleName())\n        .namespace(\"org.apache.avro.reflect.TestReflect\").fields().name(\"primitiveField\").aliases(\"aliasName\")\n        .type(Schema.create(org.apache.avro.Schema.Type.INT)).noDefault().endRecord();\n\n    check(ClassWithAliasOnField.class, expectedSchema.toString());\n  }\n\n  @Test\n  void namespaceDefinitionOnFieldAliasMustThrowException() {\n    assertThrows(AvroRuntimeException.class, () -> {\n      ReflectData.get().getSchema(ClassWithAliasAndNamespaceOnField.class);\n    });\n  }\n\n  @Test\n  public void testMultipleFieldAliases() {\n    Field field = new Field(\"primitiveField\", Schema.create(Schema.Type.INT));\n    field.addAlias(\"alias1\");\n    field.addAlias(\"alias2\");\n    Schema avroMultiMeta = Schema.createRecord(\"ClassWithMultipleAliasesOnField\", null,\n        \"org.apache.avro.reflect.TestReflect\", false, Arrays.asList(field));\n\n    Schema schema = ReflectData.get().getSchema(ClassWithMultipleAliasesOnField.class);\n    assertEquals(avroMultiMeta, schema);\n  }\n\n  private static class OptionalTest {\n    Optional<Integer> foo;\n  }\n\n  @Test\n  public void testOptional() {\n    check(OptionalTest.class,\n        \"{\\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"OptionalTest\\\",\"\n            + \"\\\"namespace\\\":\\\"org.apache.avro.reflect.TestReflect\\\",\\\"fields\\\":[\"\n            + \"{\\\"name\\\":\\\"foo\\\",\\\"type\\\":[\\\"null\\\",\\\"int\\\"],\\\"default\\\":null}]}\");\n  }\n\n  private static class DefaultTest {\n    @AvroDefault(\"1\")\n    int foo;\n  }\n\n  @Test\n  void avroDefault() {\n    check(DefaultTest.class,\n        \"{\\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"DefaultTest\\\",\"\n            + \"\\\"namespace\\\":\\\"org.apache.avro.reflect.TestReflect\\\",\\\"fields\\\":[\"\n            + \"{\\\"name\\\":\\\"foo\\\",\\\"type\\\":\\\"int\\\",\\\"default\\\":1}]}\");\n  }\n\n  public static class NullableBytesTest {\n    @Nullable\n    byte[] bytes;\n\n    NullableBytesTest() {\n    }\n\n    NullableBytesTest(byte[] bytes) {\n      this.bytes = bytes;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n      return obj instanceof NullableBytesTest && Arrays.equals(((NullableBytesTest) obj).bytes, this.bytes);\n    }\n  }\n\n  @Test\n  void nullableByteArrayNotNullValue() throws Exception {\n    checkReadWrite(new NullableBytesTest(\"foo\".getBytes(UTF_8)));\n  }\n\n  @Test\n  void nullableByteArrayNullValue() throws Exception {\n    checkReadWrite(new NullableBytesTest());\n  }\n\n  private enum DocTestEnum {\n    ENUM_1, ENUM_2\n  }\n\n  @AvroDoc(\"DocTest class docs\")\n  private static class DocTest {\n    @AvroDoc(\"Some Documentation\")\n    int foo;\n\n    @AvroDoc(\"Some other Documentation\")\n    DocTestEnum enums;\n\n    @AvroDoc(\"And again\")\n    DefaultTest defaultTest;\n  }\n\n  @Test\n  void avroDoc() {\n    check(DocTest.class,\n        \"{\\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"DocTest\\\",\\\"namespace\\\":\\\"org.apache.avro.reflect.TestReflect\\\",\"\n            + \"\\\"doc\\\":\\\"DocTest class docs\\\",\" + \"\\\"fields\\\":[\"\n            + \"{\\\"name\\\":\\\"defaultTest\\\",\\\"type\\\":{\\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"DefaultTest\\\",\"\n            + \"\\\"fields\\\":[{\\\"name\\\":\\\"foo\\\",\\\"type\\\":\\\"int\\\",\\\"default\\\":1}]},\\\"doc\\\":\\\"And again\\\"},\"\n            + \"{\\\"name\\\":\\\"enums\\\",\\\"type\\\":{\\\"type\\\":\\\"enum\\\",\\\"name\\\":\\\"DocTestEnum\\\",\"\n            + \"\\\"symbols\\\":[\\\"ENUM_1\\\",\\\"ENUM_2\\\"]},\\\"doc\\\":\\\"Some other Documentation\\\"},\"\n            + \"{\\\"name\\\":\\\"foo\\\",\\\"type\\\":\\\"int\\\",\\\"doc\\\":\\\"Some Documentation\\\"}\" + \"]}\");\n  }\n\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.avro.reflect;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.Matchers.is;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.lang.reflect.Array;\nimport java.nio.ByteBuffer;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Random;\nimport org.apache.avro.AvroRuntimeException;\nimport org.apache.avro.AvroTypeException;\nimport org.apache.avro.JsonProperties;\nimport org.apache.avro.Protocol;\nimport org.apache.avro.Schema;\nimport org.apache.avro.Schema.Field;\nimport org.apache.avro.SchemaBuilder;\nimport org.apache.avro.generic.GenericData;\nimport org.apache.avro.io.Decoder;\nimport org.apache.avro.io.DecoderFactory;\nimport org.apache.avro.io.Encoder;\nimport org.apache.avro.io.EncoderFactory;\nimport org.apache.avro.reflect.TestReflect.SampleRecord.AnotherSampleRecord;\nimport org.apache.avro.util.Utf8;\nimport org.junit.jupiter.api.Test;\n\npublic class TestReflect {\n\n  EncoderFactory factory = new EncoderFactory();\n\n  // test primitive type inference\n  @Test\n  void testVoid() {\n    check(Void.TYPE, \"\\\"null\\\"\");\n    check(Void.class, \"\\\"null\\\"\");\n  }\n\n  @Test\n  void testBoolean() {\n    check(Boolean.TYPE, \"\\\"boolean\\\"\");\n    check(Boolean.class, \"\\\"boolean\\\"\");\n  }\n\n  @Test\n  void testInt() {\n    check(Integer.TYPE, \"\\\"int\\\"\");\n    check(Integer.class, \"\\\"int\\\"\");\n  }\n\n  @Test\n  void testByte() {\n    check(Byte.TYPE, \"{\\\"type\\\":\\\"int\\\",\\\"java-class\\\":\\\"java.lang.Byte\\\"}\");\n    check(Byte.class, \"{\\\"type\\\":\\\"int\\\",\\\"java-class\\\":\\\"java.lang.Byte\\\"}\");\n  }\n\n  @Test\n  void testShort() {\n    check(Short.TYPE, \"{\\\"type\\\":\\\"int\\\",\\\"java-class\\\":\\\"java.lang.Short\\\"}\");\n    check(Short.class, \"{\\\"type\\\":\\\"int\\\",\\\"java-class\\\":\\\"java.lang.Short\\\"}\");\n  }\n\n  @Test\n  void testChar() {\n    check(Character.TYPE, \"{\\\"type\\\":\\\"int\\\",\\\"java-class\\\":\\\"java.lang.Character\\\"}\");\n    check(Character.class, \"{\\\"type\\\":\\\"int\\\",\\\"java-class\\\":\\\"java.lang.Character\\\"}\");\n  }\n\n  @Test\n  void testLong() {\n    check(Long.TYPE, \"\\\"long\\\"\");\n    check(Long.class, \"\\\"long\\\"\");\n  }\n\n  @Test\n  void testFloat() {\n    check(Float.TYPE, \"\\\"float\\\"\");\n    check(Float.class, \"\\\"float\\\"\");\n  }\n\n  @Test\n  void testDouble() {\n    check(Double.TYPE, \"\\\"double\\\"\");\n    check(Double.class, \"\\\"double\\\"\");\n  }\n\n  @Test\n  void string() {\n    check(\"Foo\", \"\\\"string\\\"\");\n  }\n\n  @Test\n  void bytes() {\n    check(ByteBuffer.allocate(0), \"\\\"bytes\\\"\");\n    check(new byte[0], \"{\\\"type\\\":\\\"bytes\\\",\\\"java-class\\\":\\\"[B\\\"}\");\n  }\n\n  @Test\n  void unionWithCollection() {\n    Schema s = new Schema.Parser().parse(\"[\\\"null\\\", {\\\"type\\\":\\\"array\\\",\\\"items\\\":\\\"float\\\"}]\");\n    GenericData data = ReflectData.get();\n    assertEquals(1, data.resolveUnion(s, new ArrayList<Float>()));\n  }\n\n  @Test\n  void unionWithMap() {\n    Schema s = new Schema.Parser().parse(\"[\\\"null\\\", {\\\"type\\\":\\\"map\\\",\\\"values\\\":\\\"float\\\"}]\");\n    GenericData data = ReflectData.get();\n    assertEquals(1, data.resolveUnion(s, new HashMap<String, Float>()));\n  }\n\n  @Test\n  void unionWithMapWithUtf8Keys() {\n    Schema s = new Schema.Parser().parse(\"[\\\"null\\\", {\\\"type\\\":\\\"map\\\",\\\"values\\\":\\\"float\\\"}]\");\n    GenericData data = ReflectData.get();\n    HashMap<Utf8, Float> map = new HashMap<>();\n    map.put(new Utf8(\"foo\"), 1.0f);\n    assertEquals(1, data.resolveUnion(s, map));\n  }\n\n  @Test\n  void unionWithFixed() {\n    Schema s = new Schema.Parser().parse(\"[\\\"null\\\", {\\\"type\\\":\\\"fixed\\\",\\\"name\\\":\\\"f\\\",\\\"size\\\":1}]\");\n    Schema f = new Schema.Parser().parse(\"{\\\"type\\\":\\\"fixed\\\",\\\"name\\\":\\\"f\\\",\\\"size\\\":1}\");\n    GenericData data = ReflectData.get();\n    assertEquals(1, data.resolveUnion(s, new GenericData.Fixed(f)));\n  }\n\n  @Test\n  void unionWithEnum() {\n    Schema s = new Schema.Parser().parse(\"[\\\"null\\\", {\\\"type\\\":\\\"enum\\\",\\\"name\\\":\\\"E\\\",\\\"namespace\\\":\"\n        + \"\\\"org.apache.avro.reflect.TestReflect\\\",\\\"symbols\\\":[\\\"A\\\",\\\"B\\\"]}]\");\n    GenericData data = ReflectData.get();\n    assertEquals(1, data.resolveUnion(s, E.A));\n  }\n\n  @Test\n  void unionWithBytes() {\n    Schema s = new Schema.Parser().parse(\"[\\\"null\\\", \\\"bytes\\\"]\");\n    GenericData data = ReflectData.get();\n    assertEquals(1, data.resolveUnion(s, ByteBuffer.wrap(new byte[] { 1 })));\n  }\n\n  // test map, array and list type inference\n  public static class R1 {\n    private Map<String, String> mapField = new HashMap<>();\n    private String[] arrayField = new String[] { \"foo\" };\n    private List<String> listField = new ArrayList<>();\n\n    {\n      mapField.put(\"foo\", \"bar\");\n      listField.add(\"foo\");\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (!(o instanceof R1))\n        return false;\n      R1 that = (R1) o;\n      return mapField.equals(that.mapField) && Arrays.equals(this.arrayField, that.arrayField)\n          && listField.equals(that.listField);\n    }\n  }\n\n  @Test\n  void map() throws Exception {\n    check(R1.class.getDeclaredField(\"mapField\").getGenericType(), \"{\\\"type\\\":\\\"map\\\",\\\"values\\\":\\\"string\\\"}\");\n  }\n\n  @Test\n  void array() throws Exception {\n    check(R1.class.getDeclaredField(\"arrayField\").getGenericType(),\n        \"{\\\"type\\\":\\\"array\\\",\\\"items\\\":\\\"string\\\",\\\"java-class\\\":\\\"[Ljava.lang.String;\\\"}\");\n  }\n\n  @Test\n  void list() throws Exception {\n    check(R1.class.getDeclaredField(\"listField\").getGenericType(),\n        \"{\\\"type\\\":\\\"array\\\",\\\"items\\\":\\\"string\\\"\" + \",\\\"java-class\\\":\\\"java.util.List\\\"}\");\n  }\n\n  @Test\n  void r1() throws Exception {\n    checkReadWrite(new R1());\n  }\n\n  // test record, array and list i/o\n  public static class R2 {\n    private String[] arrayField;\n    private Collection<String> collectionField;\n\n    @Override\n    public boolean equals(Object o) {\n      if (!(o instanceof R2))\n        return false;\n      R2 that = (R2) o;\n      return Arrays.equals(this.arrayField, that.arrayField) && collectionField.equals(that.collectionField);\n    }\n  }\n\n  @Test\n  void r2() throws Exception {\n    R2 r2 = new R2();\n    r2.arrayField = new String[] { \"foo\" };\n    r2.collectionField = new ArrayList<>();\n    r2.collectionField.add(\"foo\");\n    checkReadWrite(r2);\n  }\n\n  // test array i/o of unboxed type\n  public static class R3 {\n    private int[] intArray;\n\n    @Override\n    public boolean equals(Object o) {\n      if (!(o instanceof R3))\n        return false;\n      R3 that = (R3) o;\n      return Arrays.equals(this.intArray, that.intArray);\n    }\n  }\n\n  @Test\n  void r3() throws Exception {\n    R3 r3 = new R3();\n    r3.intArray = new int[] { 1 };\n    checkReadWrite(r3);\n  }\n\n  // test inherited fields & short datatype\n  public static class R4 {\n    public short value;\n    public short[] shorts;\n    public byte b;\n    public char c;\n\n    @Override\n    public boolean equals(Object o) {\n      if (!(o instanceof R4))\n        return false;\n      R4 that = (R4) o;\n      return this.value == that.value && Arrays.equals(this.shorts, that.shorts) && this.b == that.b\n          && this.c == that.c;\n    }\n  }\n\n  public static class R5 extends R4 {\n  }\n\n  @Test\n  void r5() throws Exception {\n    R5 r5 = new R5();\n    r5.value = 1;\n    r5.shorts = new short[] { 3, 255, 256, Short.MAX_VALUE, Short.MIN_VALUE };\n    r5.b = 99;\n    r5.c = 'a';\n    checkReadWrite(r5);\n  }\n\n  // test union annotation on a class\n  @Union({ R7.class, R8.class })\n  public static class R6 {\n  }\n\n  public static class R7 extends R6 {\n    public int value;\n\n    @Override\n    public boolean equals(Object o) {\n      if (!(o instanceof R7))\n        return false;\n      return this.value == ((R7) o).value;\n    }\n  }\n\n  public static class R8 extends R6 {\n    public float value;\n\n    @Override\n    public boolean equals(Object o) {\n      if (!(o instanceof R8))\n        return false;\n      return this.value == ((R8) o).value;\n    }\n  }\n\n  // test arrays of union annotated class\n  public static class R9 {\n    public R6[] r6s;\n\n    @Override\n    public boolean equals(Object o) {\n      if (!(o instanceof R9))\n        return false;\n      return Arrays.equals(this.r6s, ((R9) o).r6s);\n    }\n  }\n\n  @Test\n  void r6() throws Exception {\n    R7 r7 = new R7();\n    r7.value = 1;\n    checkReadWrite(r7, ReflectData.get().getSchema(R6.class));\n    R8 r8 = new R8();\n    r8.value = 1;\n    checkReadWrite(r8, ReflectData.get().getSchema(R6.class));\n    R9 r9 = new R9();\n    r9.r6s = new R6[] { r7, r8 };\n    checkReadWrite(r9, ReflectData.get().getSchema(R9.class));\n  }\n\n  // test union in fields\n  public static class R9_1 {\n    @Union({ Void.class, R7.class, R8.class })\n    public Object value;\n\n    @Override\n    public boolean equals(Object o) {\n      if (!(o instanceof R9_1))\n        return false;\n      if (this.value == null)\n        return ((R9_1) o).value == null;\n      return this.value.equals(((R9_1) o).value);\n    }\n  }\n\n  @Test\n  void r6_1() throws Exception {\n    R7 r7 = new R7();\n    r7.value = 1;\n    checkReadWrite(r7, ReflectData.get().getSchema(R6.class));\n    R8 r8 = new R8();\n    r8.value = 1;\n    checkReadWrite(r8, ReflectData.get().getSchema(R6.class));\n    R9_1 r9_1 = new R9_1();\n    r9_1.value = null;\n    checkReadWrite(r9_1, ReflectData.get().getSchema(R9_1.class));\n    r9_1.value = r7;\n    checkReadWrite(r9_1, ReflectData.get().getSchema(R9_1.class));\n    r9_1.value = r8;\n    checkReadWrite(r9_1, ReflectData.get().getSchema(R9_1.class));\n  }\n\n  // test union annotation on methods and parameters\n  public static interface P0 {\n    @Union({ Void.class, String.class })\n    String foo(@Union({ Void.class, String.class }) String s);\n  }\n\n  @Test\n  void p0() throws Exception {\n    Protocol p0 = ReflectData.get().getProtocol(P0.class);\n    Protocol.Message message = p0.getMessages().get(\"foo\");\n    // check response schema is union\n    Schema response = message.getResponse();\n    assertEquals(Schema.Type.UNION, response.getType());\n    assertEquals(Schema.Type.NULL, response.getTypes().get(0).getType());\n    assertEquals(Schema.Type.STRING, response.getTypes().get(1).getType());\n    // check request schema is union\n    Schema request = message.getRequest();\n    Field field = request.getField(\"s\");\n    assertNotNull(field, \"field 's' should not be null\");\n    Schema param = field.schema();\n    assertEquals(Schema.Type.UNION, param.getType());\n    assertEquals(Schema.Type.NULL, param.getTypes().get(0).getType());\n    assertEquals(Schema.Type.STRING, param.getTypes().get(1).getType());\n    // check union erasure\n    assertEquals(String.class, ReflectData.get().getClass(response));\n    assertEquals(String.class, ReflectData.get().getClass(param));\n  }\n\n  // test Stringable annotation\n  @Stringable\n  public static class R10 {\n    private String text;\n\n    public R10(String text) {\n      this.text = text;\n    }\n\n    @Override\n    public String toString() {\n      return text;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (!(o instanceof R10))\n        return false;\n      return this.text.equals(((R10) o).text);\n    }\n  }\n\n  @Test\n  void r10() throws Exception {\n    Schema r10Schema = ReflectData.get().getSchema(R10.class);\n    assertEquals(Schema.Type.STRING, r10Schema.getType());\n    assertEquals(R10.class.getName(), r10Schema.getProp(\"java-class\"));\n    checkReadWrite(new R10(\"foo\"), r10Schema);\n  }\n\n  // test Nullable annotation on field\n  public static class R11 {\n    @Nullable\n    private String text;\n\n    @Override\n    public boolean equals(Object o) {\n      if (!(o instanceof R11))\n        return false;\n      R11 that = (R11) o;\n      if (this.text == null)\n        return that.text == null;\n      return this.text.equals(that.text);\n    }\n  }\n\n  @Test\n  void r11() throws Exception {\n    Schema r11Record = ReflectData.get().getSchema(R11.class);\n    assertEquals(Schema.Type.RECORD, r11Record.getType());\n    Field r11Field = r11Record.getField(\"text\");\n    assertEquals(JsonProperties.NULL_VALUE, r11Field.defaultVal());\n    Schema r11FieldSchema = r11Field.schema();\n    assertEquals(Schema.Type.UNION, r11FieldSchema.getType());\n    assertEquals(Schema.Type.NULL, r11FieldSchema.getTypes().get(0).getType());\n    Schema r11String = r11FieldSchema.getTypes().get(1);\n    assertEquals(Schema.Type.STRING, r11String.getType());\n    R11 r11 = new R11();\n    checkReadWrite(r11, r11Record);\n    r11.text = \"foo\";\n    checkReadWrite(r11, r11Record);\n  }\n\n  // test nullable annotation on methods and parameters\n  public static interface P1 {\n    @Nullable\n    String foo(@Nullable String s);\n  }\n\n  @Test\n  void p1() throws Exception {\n    Protocol p1 = ReflectData.get().getProtocol(P1.class);\n    Protocol.Message message = p1.getMessages().get(\"foo\");\n    // check response schema is union\n    Schema response = message.getResponse();\n    assertEquals(Schema.Type.UNION, response.getType());\n    assertEquals(Schema.Type.NULL, response.getTypes().get(0).getType());\n    assertEquals(Schema.Type.STRING, response.getTypes().get(1).getType());\n    // check request schema is union\n    Schema request = message.getRequest();\n    Field field = request.getField(\"s\");\n    assertNotNull(field, \"field 's' should not be null\");\n    Schema param = field.schema();\n    assertEquals(Schema.Type.UNION, param.getType());\n    assertEquals(Schema.Type.NULL, param.getTypes().get(0).getType());\n    assertEquals(Schema.Type.STRING, param.getTypes().get(1).getType());\n    // check union erasure\n    assertEquals(String.class, ReflectData.get().getClass(response));\n    assertEquals(String.class, ReflectData.get().getClass(param));\n  }\n\n  // test AvroSchema annotation\n  public static class R12 { // fields\n    @AvroSchema(\"\\\"int\\\"\")\n    Object x;\n\n    @AvroSchema(\"{\\\"type\\\":\\\"array\\\",\\\"items\\\":[\\\"null\\\",\\\"string\\\"]}\")\n    List<String> strings;\n  }\n\n  @Test\n  void r12() throws Exception {\n    Schema s = ReflectData.get().getSchema(R12.class);\n    assertEquals(Schema.Type.INT, s.getField(\"x\").schema().getType());\n    assertEquals(new Schema.Parser().parse(\"{\\\"type\\\":\\\"array\\\",\\\"items\\\":[\\\"null\\\",\\\"string\\\"]}\"),\n        s.getField(\"strings\").schema());\n  }\n\n  @AvroSchema(\"\\\"null\\\"\") // record\n  public static class R13 {\n  }\n\n  @Test\n  void r13() throws Exception {\n    Schema s = ReflectData.get().getSchema(R13.class);\n    assertEquals(Schema.Type.NULL, s.getType());\n  }\n\n  public interface P4 {\n    @AvroSchema(\"\\\"int\\\"\") // message value\n    Object foo(@AvroSchema(\"\\\"int\\\"\") Object x); // message param\n  }\n\n  @Test\n  void p4() throws Exception {\n    Protocol p = ReflectData.get().getProtocol(P4.class);\n    Protocol.Message message = p.getMessages().get(\"foo\");\n    assertEquals(Schema.Type.INT, message.getResponse().getType());\n    Field field = message.getRequest().getField(\"x\");\n    assertEquals(Schema.Type.INT, field.schema().getType());\n  }\n\n  // test error\n  @SuppressWarnings(\"serial\")\n  public static class E1 extends Exception {\n  }\n\n  public static interface P2 {\n    void error() throws E1;\n  }\n\n  @Test\n  void p2() throws Exception {\n    Schema e1 = ReflectData.get().getSchema(E1.class);\n    assertEquals(Schema.Type.RECORD, e1.getType());\n    assertTrue(e1.isError());\n    Field message = e1.getField(\"detailMessage\");\n    assertNotNull(message, \"field 'detailMessage' should not be null\");\n    Schema messageSchema = message.schema();\n    assertEquals(Schema.Type.UNION, messageSchema.getType());\n    assertEquals(Schema.Type.NULL, messageSchema.getTypes().get(0).getType());\n    assertEquals(Schema.Type.STRING, messageSchema.getTypes().get(1).getType());\n\n    Protocol p2 = ReflectData.get().getProtocol(P2.class);\n    Protocol.Message m = p2.getMessages().get(\"error\");\n    // check error schema is union\n    Schema response = m.getErrors();\n    assertEquals(Schema.Type.UNION, response.getType());\n    assertEquals(Schema.Type.STRING, response.getTypes().get(0).getType());\n    assertEquals(e1, response.getTypes().get(1));\n  }\n\n  @Test\n  void noPackage() throws Exception {\n    Class<?> noPackage = Class.forName(\"NoPackage\");\n    Schema s = ReflectData.get().getSchema(noPackage);\n    assertEquals(noPackage.getName(), ReflectData.getClassName(s));\n  }\n\n  void checkReadWrite(Object object) throws Exception {\n    checkReadWrite(object, ReflectData.get().getSchema(object.getClass()));\n  }\n\n  void checkReadWrite(Object object, Schema s) throws Exception {\n    ReflectDatumWriter<Object> writer = new ReflectDatumWriter<>(s);\n    ByteArrayOutputStream out = new ByteArrayOutputStream();\n    writer.write(object, factory.directBinaryEncoder(out, null));\n    ReflectDatumReader<Object> reader = new ReflectDatumReader<>(s);\n    Object after = reader.read(null, DecoderFactory.get().binaryDecoder(out.toByteArray(), null));\n    assertEquals(object, after);\n\n    // check reflective setField works for records\n    if (s.getType().equals(Schema.Type.RECORD)) {\n      Object copy = object.getClass().getDeclaredConstructor().newInstance();\n      for (Field f : s.getFields()) {\n        Object val = ReflectData.get().getField(object, f.name(), f.pos());\n        ReflectData.get().setField(copy, f.name(), f.pos(), val);\n      }\n      assertEquals(object, copy, \"setField\");\n    }\n  }\n\n  public static enum E {\n    A, B\n  }\n\n  @Test\n  void testEnum() throws Exception {\n    check(E.class, \"{\\\"type\\\":\\\"enum\\\",\\\"name\\\":\\\"E\\\",\\\"namespace\\\":\"\n        + \"\\\"org.apache.avro.reflect.TestReflect\\\",\\\"symbols\\\":[\\\"A\\\",\\\"B\\\"]}\");\n  }\n\n  public static class R {\n    int a;\n    long b;\n  }\n\n  @Test\n  void record() throws Exception {\n    check(R.class,\n        \"{\\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"R\\\",\\\"namespace\\\":\" + \"\\\"org.apache.avro.reflect.TestReflect\\\",\\\"fields\\\":[\"\n            + \"{\\\"name\\\":\\\"a\\\",\\\"type\\\":\\\"int\\\"},\" + \"{\\\"name\\\":\\\"b\\\",\\\"type\\\":\\\"long\\\"}]}\");\n  }\n\n  public static class RAvroIgnore {\n    @AvroIgnore\n    int a;\n  }\n\n  @Test\n  void annotationAvroIgnore() throws Exception {\n    check(RAvroIgnore.class, \"{\\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"RAvroIgnore\\\",\\\"namespace\\\":\"\n        + \"\\\"org.apache.avro.reflect.TestReflect\\\",\\\"fields\\\":[]}\");\n  }\n\n  @AvroMeta(key = \"X\", value = \"Y\")\n  public static class RAvroMeta {\n    @AvroMeta(key = \"K\", value = \"V\")\n    int a;\n  }\n\n  @Test\n  void annotationAvroMeta() throws Exception {\n    check(RAvroMeta.class,\n        \"{\\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"RAvroMeta\\\",\\\"namespace\\\":\"\n            + \"\\\"org.apache.avro.reflect.TestReflect\\\",\\\"fields\\\":[\" + \"{\\\"name\\\":\\\"a\\\",\\\"type\\\":\\\"int\\\",\\\"K\\\":\\\"V\\\"}]\"\n            + \",\\\"X\\\":\\\"Y\\\"}\");\n  }\n\n  @AvroMeta(key = \"X\", value = \"Y\")\n  @AvroMeta(key = \"A\", value = \"B\")\n  public static class RAvroMultiMeta {\n    @AvroMeta(key = \"K\", value = \"V\")\n    @AvroMeta(key = \"L\", value = \"W\")\n    int a;\n  }\n\n  @Test\n  void annotationMultiAvroMeta() {\n    check(RAvroMultiMeta.class,\n        \"{\\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"RAvroMultiMeta\\\",\\\"namespace\\\":\"\n            + \"\\\"org.apache.avro.reflect.TestReflect\\\",\\\"fields\\\":[\"\n            + \"{\\\"name\\\":\\\"a\\\",\\\"type\\\":\\\"int\\\",\\\"K\\\":\\\"V\\\",\\\"L\\\":\\\"W\\\"}]\" + \",\\\"X\\\":\\\"Y\\\",\\\"A\\\":\\\"B\\\"}\");\n  }\n\n  public static class RAvroDuplicateFieldMeta {\n    @AvroMeta(key = \"K\", value = \"V\")\n    @AvroMeta(key = \"K\", value = \"W\")\n    int a;\n  }\n\n  @Test\n  void annotationDuplicateFieldAvroMeta() {\n    assertThrows(AvroTypeException.class, () -> {\n      ReflectData.get().getSchema(RAvroDuplicateFieldMeta.class);\n    });\n  }\n\n  @AvroMeta(key = \"K\", value = \"V\")\n  @AvroMeta(key = \"K\", value = \"W\")\n  public static class RAvroDuplicateTypeMeta {\n    int a;\n  }\n\n  @Test\n  void annotationDuplicateTypeAvroMeta() {\n    assertThrows(AvroTypeException.class, () -> {\n      ReflectData.get().getSchema(RAvroDuplicateTypeMeta.class);\n    });\n  }\n\n  public static class RAvroName {\n    @AvroName(\"b\")\n    int a;\n  }\n\n  @Test\n  void annotationAvroName() throws Exception {\n    check(RAvroName.class, \"{\\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"RAvroName\\\",\\\"namespace\\\":\"\n        + \"\\\"org.apache.avro.reflect.TestReflect\\\",\\\"fields\\\":[\" + \"{\\\"name\\\":\\\"b\\\",\\\"type\\\":\\\"int\\\"}]}\");\n  }\n\n  public static class RAvroNameCollide {\n    @AvroName(\"b\")\n    int a;\n    int b;\n  }\n\n  @Test\n  void annotationAvroNameCollide() throws Exception {\n    assertThrows(Exception.class, () -> {\n      check(RAvroNameCollide.class,\n          \"{\\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"RAvroNameCollide\\\",\\\"namespace\\\":\"\n              + \"\\\"org.apache.avro.reflect.TestReflect\\\",\\\"fields\\\":[\" + \"{\\\"name\\\":\\\"b\\\",\\\"type\\\":\\\"int\\\"},\"\n              + \"{\\\"name\\\":\\\"b\\\",\\\"type\\\":\\\"int\\\"}]}\");\n    });\n  }\n\n  public static class RAvroStringableField {\n    @Stringable\n    int a;\n  }\n\n  @Test\n  void annotationAvroStringableFields() throws Exception {\n    check(RAvroStringableField.class, \"{\\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"RAvroStringableField\\\",\\\"namespace\\\":\"\n        + \"\\\"org.apache.avro.reflect.TestReflect\\\",\\\"fields\\\":[\" + \"{\\\"name\\\":\\\"a\\\",\\\"type\\\":\\\"string\\\"}]}\");\n  }\n\n  private void check(Object o, String schemaJson) {\n    check(o.getClass(), schemaJson);\n  }\n\n  private void check(java.lang.reflect.Type type, String schemaJson) {\n    assertEquals(schemaJson, ReflectData.get().getSchema(type).toString());\n  }\n\n  @Test\n  void recordIO() throws IOException {\n    Schema schm = ReflectData.get().getSchema(SampleRecord.class);\n    ReflectDatumWriter<SampleRecord> writer = new ReflectDatumWriter<>(schm);\n    ByteArrayOutputStream out = new ByteArrayOutputStream();\n    SampleRecord record = new SampleRecord();\n    record.x = 5;\n    record.y = 10;\n    writer.write(record, factory.directBinaryEncoder(out, null));\n    ReflectDatumReader<SampleRecord> reader = new ReflectDatumReader<>(schm);\n    SampleRecord decoded = reader.read(null, DecoderFactory.get().binaryDecoder(out.toByteArray(), null));\n    assertEquals(record, decoded);\n  }\n\n  public static class AvroEncRecord {\n    @AvroEncode(using = DateAsLongEncoding.class)\n    java.util.Date date;\n\n    @Override\n    public boolean equals(Object o) {\n      if (!(o instanceof AvroEncRecord))\n        return false;\n      return date.equals(((AvroEncRecord) o).date);\n    }\n  }\n\n  public static class multipleAnnotationRecord {\n    @AvroIgnore\n    @Stringable\n    Integer i1;\n\n    @AvroIgnore\n    @Nullable\n    Integer i2;\n\n    @AvroIgnore\n    @AvroName(\"j\")\n    Integer i3;\n\n    @AvroIgnore\n    @AvroEncode(using = DateAsLongEncoding.class)\n    java.util.Date i4;\n\n    @Stringable\n    @Nullable\n    Integer i5;\n\n    @Stringable\n    @AvroName(\"j6\")\n    Integer i6 = 6;\n\n    @Stringable\n    @AvroEncode(using = DateAsLongEncoding.class)\n    java.util.Date i7 = new java.util.Date(7L);\n\n    @Nullable\n    @AvroName(\"j8\")\n    Integer i8;\n\n    @Nullable\n    @AvroEncode(using = DateAsLongEncoding.class)\n    java.util.Date i9;\n\n    @AvroName(\"j10\")\n    @AvroEncode(using = DateAsLongEncoding.class)\n    java.util.Date i10 = new java.util.Date(10L);\n\n    @Stringable\n    @Nullable\n    @AvroName(\"j11\")\n    @AvroEncode(using = DateAsLongEncoding.class)\n    java.util.Date i11;\n  }\n\n  @Test\n  void multipleAnnotations() throws IOException {\n    Schema schm = ReflectData.get().getSchema(multipleAnnotationRecord.class);\n    ReflectDatumWriter<multipleAnnotationRecord> writer = new ReflectDatumWriter<>(schm);\n    ByteArrayOutputStream out = new ByteArrayOutputStream();\n    multipleAnnotationRecord record = new multipleAnnotationRecord();\n    record.i1 = 1;\n    record.i2 = 2;\n    record.i3 = 3;\n    record.i4 = new java.util.Date(4L);\n    record.i5 = 5;\n    record.i6 = 6;\n    record.i7 = new java.util.Date(7L);\n    record.i8 = 8;\n    record.i9 = new java.util.Date(9L);\n    record.i10 = new java.util.Date(10L);\n    record.i11 = new java.util.Date(11L);\n\n    writer.write(record, factory.directBinaryEncoder(out, null));\n    ReflectDatumReader<multipleAnnotationRecord> reader = new ReflectDatumReader<>(schm);\n    multipleAnnotationRecord decoded = reader.read(new multipleAnnotationRecord(),\n        DecoderFactory.get().binaryDecoder(out.toByteArray(), null));\n    assertNull(decoded.i1);\n    assertNull(decoded.i2);\n    assertNull(decoded.i3);\n    assertNull(decoded.i4);\n    assertEquals(decoded.i5, 5);\n    assertEquals(decoded.i6, 6);\n    assertEquals(decoded.i7.getTime(), 7);\n    assertEquals(decoded.i8, 8);\n    assertEquals(decoded.i9.getTime(), 9);\n    assertEquals(decoded.i10.getTime(), 10);\n    assertEquals(decoded.i11.getTime(), 11);\n  }\n\n  @Test\n  void avroEncodeInducing() throws IOException {\n    Schema schm = ReflectData.get().getSchema(AvroEncRecord.class);\n    assertEquals(schm.toString(),\n        \"{\\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"AvroEncRecord\\\",\\\"namespace\"\n            + \"\\\":\\\"org.apache.avro.reflect.TestReflect\\\",\\\"fields\\\":[{\\\"name\\\":\\\"date\\\",\"\n            + \"\\\"type\\\":{\\\"type\\\":\\\"long\\\",\\\"CustomEncoding\\\":\\\"DateAsLongEncoding\\\"}}]}\");\n  }\n\n  @Test\n  void avroEncodeIO() throws IOException {\n    Schema schm = ReflectData.get().getSchema(AvroEncRecord.class);\n    ReflectDatumWriter<AvroEncRecord> writer = new ReflectDatumWriter<>(schm);\n    ByteArrayOutputStream out = new ByteArrayOutputStream();\n    AvroEncRecord record = new AvroEncRecord();\n    record.date = new java.util.Date(948833323L);\n    writer.write(record, factory.directBinaryEncoder(out, null));\n    ReflectDatumReader<AvroEncRecord> reader = new ReflectDatumReader<>(schm);\n    AvroEncRecord decoded = reader.read(new AvroEncRecord(),\n        DecoderFactory.get().binaryDecoder(out.toByteArray(), null));\n    assertEquals(record, decoded);\n  }\n\n  @Test\n  void recordWithNullIO() throws IOException {\n    ReflectData reflectData = ReflectData.AllowNull.get();\n    Schema schm = reflectData.getSchema(AnotherSampleRecord.class);\n    ReflectDatumWriter<AnotherSampleRecord> writer = new ReflectDatumWriter<>(schm);\n    ByteArrayOutputStream out = new ByteArrayOutputStream();\n    // keep record.a null and see if that works\n    Encoder e = factory.directBinaryEncoder(out, null);\n    AnotherSampleRecord a = new AnotherSampleRecord();\n    writer.write(a, e);\n    AnotherSampleRecord b = new AnotherSampleRecord(10);\n    writer.write(b, e);\n    e.flush();\n    ReflectDatumReader<AnotherSampleRecord> reader = new ReflectDatumReader<>(schm);\n    ByteArrayInputStream in = new ByteArrayInputStream(out.toByteArray());\n    Decoder d = DecoderFactory.get().binaryDecoder(in, null);\n    AnotherSampleRecord decoded = reader.read(null, d);\n    assertEquals(a, decoded);\n    decoded = reader.read(null, d);\n    assertEquals(b, decoded);\n  }\n\n  @Test\n  void disableUnsafe() throws Exception {\n    String saved = System.getProperty(\"avro.disable.unsafe\");\n    try {\n      System.setProperty(\"avro.disable.unsafe\", \"true\");\n      ReflectData.ACCESSOR_CACHE.remove(multipleAnnotationRecord.class);\n      ReflectData.ACCESSOR_CACHE.remove(AnotherSampleRecord.class);\n      ReflectionUtil.resetFieldAccess();\n      multipleAnnotations();\n      recordWithNullIO();\n    } finally {\n      if (saved == null)\n        System.clearProperty(\"avro.disable.unsafe\");\n      else\n        System.setProperty(\"avro.disable.unsafe\", saved);\n      ReflectData.ACCESSOR_CACHE.remove(multipleAnnotationRecord.class);\n      ReflectData.ACCESSOR_CACHE.remove(AnotherSampleRecord.class);\n      ReflectionUtil.resetFieldAccess();\n    }\n  }\n\n  public static class SampleRecord {\n    public int x = 1;\n    private int y = 2;\n\n    @Override\n    public int hashCode() {\n      return x + y;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n      if (this == obj)\n        return true;\n      if (obj == null)\n        return false;\n      if (getClass() != obj.getClass())\n        return false;\n      final SampleRecord other = (SampleRecord) obj;\n      if (x != other.x)\n        return false;\n      return y == other.y;\n    }\n\n    public static class AnotherSampleRecord {\n      private Integer a = null;\n      private SampleRecord s = null;\n\n      public AnotherSampleRecord() {\n      }\n\n      AnotherSampleRecord(Integer a) {\n        this.a = a;\n        this.s = new SampleRecord();\n      }\n\n      @Override\n      public int hashCode() {\n        int hash = (a != null ? a.hashCode() : 0);\n        hash += (s != null ? s.hashCode() : 0);\n        return hash;\n      }\n\n      @Override\n      public boolean equals(Object other) {\n        if (other instanceof AnotherSampleRecord) {\n          AnotherSampleRecord o = (AnotherSampleRecord) other;\n          return (this.a != null || o.a == null) && (this.a == null || this.a.equals(o.a))\n              && (this.s != null || o.s == null) && (this.s == null || this.s.equals(o.s));\n        } else {\n          return false;\n        }\n      }\n    }\n  }\n\n  public static class X {\n    int i;\n  }\n\n  public static class B1 {\n    X x;\n  }\n\n  public static class B2 {\n    X x;\n  }\n\n  public static class A {\n    B1 b1;\n    B2 b2;\n  }\n\n  public static interface C {\n    void foo(A a);\n  }\n\n  @Test\n  void forwardReference() {\n    ReflectData data = ReflectData.get();\n    Protocol reflected = data.getProtocol(C.class);\n    String ref = reflected.toString();\n    Protocol reparsed = Protocol.parse(ref);\n    assertEquals(reflected, reparsed);\n    assert (reparsed.getTypes().contains(data.getSchema(A.class)));\n    assert (reparsed.getTypes().contains(data.getSchema(B1.class)));\n    assert (reparsed.getTypes().contains(data.getSchema(B2.class)));\n    assert (reparsed.getTypes().contains(data.getSchema(X.class)));\n  }\n\n  public static interface P3 {\n    void m1();\n\n    void m1(int x);\n  }\n\n  @Test\n  void overloadedMethod() {\n    assertThrows(AvroTypeException.class, () -> {\n      ReflectData.get().getProtocol(P3.class);\n    });\n  }\n\n  @Test\n  void noPackageSchema() throws Exception {\n    ReflectData.get().getSchema(Class.forName(\"NoPackage\"));\n  }\n\n  @Test\n  void noPackageProtocol() throws Exception {\n    ReflectData.get().getProtocol(Class.forName(\"NoPackage\"));\n  }\n\n  public static class Y {\n    int i;\n  }\n\n  /** Test nesting of reflect data within generic. */\n  @Test\n  void reflectWithinGeneric() throws Exception {\n    ReflectData data = ReflectData.get();\n    // define a record with a field that's a specific Y\n    Schema schema = Schema.createRecord(\"Foo\", \"\", \"x.y.z\", false);\n    List<Schema.Field> fields = new ArrayList<>();\n    fields.add(new Schema.Field(\"f\", data.getSchema(Y.class), \"\", null));\n    schema.setFields(fields);\n\n    // create a generic instance of this record\n    Y y = new Y();\n    y.i = 1;\n    GenericData.Record record = new GenericData.Record(schema);\n    record.put(\"f\", y);\n\n    // test that this instance can be written & re-read\n    checkBinary(schema, record);\n  }\n\n  @Test\n  void primitiveArray() throws Exception {\n    testPrimitiveArrays(false);\n  }\n\n  @Test\n  void primitiveArrayBlocking() throws Exception {\n    testPrimitiveArrays(true);\n  }\n\n  private void testPrimitiveArrays(boolean blocking) throws Exception {\n    testPrimitiveArray(boolean.class, blocking);\n    testPrimitiveArray(byte.class, blocking);\n    testPrimitiveArray(short.class, blocking);\n    testPrimitiveArray(char.class, blocking);\n    testPrimitiveArray(int.class, blocking);\n    testPrimitiveArray(long.class, blocking);\n    testPrimitiveArray(float.class, blocking);\n    testPrimitiveArray(double.class, blocking);\n  }\n\n  private void testPrimitiveArray(Class<?> c, boolean blocking) throws Exception {\n    ReflectData data = new ReflectData();\n    Random r = new Random();\n    int size = 200;\n    Object array = Array.newInstance(c, size);\n    Schema s = data.getSchema(array.getClass());\n    for (int i = 0; i < size; i++) {\n      Array.set(array, i, randomFor(c, r));\n    }\n    checkBinary(data, s, array, false, blocking);\n  }\n\n  private Object randomFor(Class<?> c, Random r) {\n    if (c == boolean.class)\n      return r.nextBoolean();\n    if (c == int.class)\n      return r.nextInt();\n    if (c == long.class)\n      return r.nextLong();\n    if (c == byte.class)\n      return (byte) r.nextInt();\n    if (c == float.class)\n      return r.nextFloat();\n    if (c == double.class)\n      return r.nextDouble();\n    if (c == char.class)\n      return (char) r.nextInt();\n    if (c == short.class)\n      return (short) r.nextInt();\n    return null;\n  }\n\n  /** Test union of null and an array. */\n  @Test\n  void nullArray() throws Exception {\n    String json = \"[{\\\"type\\\":\\\"array\\\", \\\"items\\\": \\\"long\\\"}, \\\"null\\\"]\";\n    Schema schema = new Schema.Parser().parse(json);\n    checkBinary(schema, null);\n  }\n\n  /** Test stringable classes. */\n  @Test\n  void stringables() throws Exception {\n    checkStringable(java.math.BigDecimal.class, \"10\");\n    checkStringable(java.math.BigInteger.class, \"20\");\n    checkStringable(java.net.URI.class, \"foo://bar:9000/baz\");\n    checkStringable(java.net.URL.class, \"http://bar:9000/baz\");\n    checkStringable(java.io.File.class, \"foo.bar\");\n  }\n\n  @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n  public void checkStringable(Class c, String value) throws Exception {\n    ReflectData data = new ReflectData();\n    Schema schema = data.getSchema(c);\n    assertEquals(\"{\\\"type\\\":\\\"string\\\",\\\"java-class\\\":\\\"\" + c.getName() + \"\\\"}\", schema.toString());\n    checkBinary(schema, c.getConstructor(String.class).newInstance(value));\n  }\n\n  public static class M1 {\n    Map<Integer, String> integerKeyMap;\n    Map<java.math.BigInteger, String> bigIntegerKeyMap;\n    Map<java.math.BigDecimal, String> bigDecimalKeyMap;\n    Map<java.io.File, String> fileKeyMap;\n  }\n\n  /** Test Map with stringable key classes. */\n  @Test\n  void stringableMapKeys() throws Exception {\n    M1 record = new M1();\n    record.integerKeyMap = new HashMap<>(1);\n    record.integerKeyMap.put(10, \"foo\");\n\n    record.bigIntegerKeyMap = new HashMap<>(1);\n    record.bigIntegerKeyMap.put(java.math.BigInteger.TEN, \"bar\");\n\n    record.bigDecimalKeyMap = new HashMap<>(1);\n    record.bigDecimalKeyMap.put(java.math.BigDecimal.ONE, \"bigDecimal\");\n\n    record.fileKeyMap = new HashMap<>(1);\n    record.fileKeyMap.put(new java.io.File(\"foo.bar\"), \"file\");\n\n    ReflectData data = new ReflectData().addStringable(Integer.class);\n\n    checkBinary(data, data.getSchema(M1.class), record, true);\n  }\n\n  public static class NullableStringable {\n    java.math.BigDecimal number;\n  }\n\n  @Test\n  void nullableStringableField() throws Exception {\n    NullableStringable datum = new NullableStringable();\n    datum.number = java.math.BigDecimal.TEN;\n\n    Schema schema = ReflectData.AllowNull.get().getSchema(NullableStringable.class);\n    checkBinary(schema, datum);\n  }\n\n  public static void checkBinary(ReflectData reflectData, Schema schema, Object datum, boolean equals)\n      throws IOException {\n    checkBinary(reflectData, schema, datum, equals, false);\n  }\n\n  private static void checkBinary(ReflectData reflectData, Schema schema, Object datum, boolean equals,\n      boolean blocking) throws IOException {\n    ReflectDatumWriter<Object> writer = new ReflectDatumWriter<>(schema);\n    ByteArrayOutputStream out = new ByteArrayOutputStream();\n    if (!blocking) {\n      writer.write(datum, EncoderFactory.get().directBinaryEncoder(out, null));\n    } else {\n      writer.write(datum, new EncoderFactory().configureBlockSize(64).blockingBinaryEncoder(out, null));\n    }\n    writer.write(datum, EncoderFactory.get().directBinaryEncoder(out, null));\n    byte[] data = out.toByteArray();\n\n    ReflectDatumReader<Object> reader = new ReflectDatumReader<>(schema);\n    Object decoded = reader.read(null, DecoderFactory.get().binaryDecoder(data, null));\n\n    assertEquals(0, reflectData.compare(datum, decoded, schema, equals));\n  }\n\n  public static void checkBinary(Schema schema, Object datum) throws IOException {\n    checkBinary(ReflectData.get(), schema, datum, false);\n  }\n\n  /** Test that the error message contains the name of the class. */\n  @Test\n  void reflectFieldError() throws Exception {\n    Object datum = \"\";\n    try {\n      ReflectData.get().getField(datum, \"notAFieldOfString\", 0);\n    } catch (AvroRuntimeException e) {\n      assertTrue(e.getMessage().contains(datum.getClass().getName()));\n    }\n  }\n\n  @AvroAlias(alias = \"a\", space = \"b\")\n  private static class AliasA {\n  }\n\n  @AvroAlias(alias = \"a\", space = \"\")\n  private static class AliasB {\n  }\n\n  @AvroAlias(alias = \"a\")\n  private static class AliasC {\n  }\n\n  @Test\n  void avroAliasOnClass() {\n    check(AliasA.class,\n        \"{\\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"AliasA\\\",\\\"namespace\\\":\\\"org.apache.avro.reflect.TestReflect\\\",\\\"fields\\\":[],\\\"aliases\\\":[\\\"b.a\\\"]}\");\n    check(AliasB.class,\n        \"{\\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"AliasB\\\",\\\"namespace\\\":\\\"org.apache.avro.reflect.TestReflect\\\",\\\"fields\\\":[],\\\"aliases\\\":[\\\"a\\\"]}\");\n    check(AliasC.class,\n        \"{\\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"AliasC\\\",\\\"namespace\\\":\\\"org.apache.avro.reflect.TestReflect\\\",\\\"fields\\\":[],\\\"aliases\\\":[\\\"a\\\"]}\");\n  }\n\n  @AvroAlias(alias = \"alias1\", space = \"space1\")\n  @AvroAlias(alias = \"alias2\", space = \"space2\")\n  private static class MultipleAliasRecord {\n\n  }\n\n  @Test\n  void multipleAliasAnnotationsOnClass() {\n    check(MultipleAliasRecord.class,\n        \"{\\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"MultipleAliasRecord\\\",\\\"namespace\\\":\\\"org.apache.avro.reflect.TestReflect\\\",\\\"fields\\\":[],\\\"aliases\\\":[\\\"space1.alias1\\\",\\\"space2.alias2\\\"]}\");\n\n  }\n\n  private static class Z {\n  }\n\n  @Test\n  void dollarTerminatedNamespaceCompatibility() {\n    ReflectData data = ReflectData.get();\n    Schema s = new Schema.Parser().setValidate(false).parse(\n        \"{\\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"Z\\\",\\\"namespace\\\":\\\"org.apache.avro.reflect.TestReflect$\\\",\\\"fields\\\":[]}\");\n    assertEquals(data.getSchema(data.getClass(s)).toString(),\n        \"{\\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"Z\\\",\\\"namespace\\\":\\\"org.apache.avro.reflect.TestReflect\\\",\\\"fields\\\":[]}\");\n  }\n\n  @Test\n  void dollarTerminatedNestedStaticClassNamespaceCompatibility() {\n    ReflectData data = ReflectData.get();\n    // Older versions of Avro generated this namespace on nested records.\n    Schema s = new Schema.Parser().setValidate(false).parse(\n        \"{\\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"AnotherSampleRecord\\\",\\\"namespace\\\":\\\"org.apache.avro.reflect.TestReflect$SampleRecord\\\",\\\"fields\\\":[]}\");\n    assertThat(data.getSchema(data.getClass(s)).getFullName(),\n        is(\"org.apache.avro.reflect.TestReflect.SampleRecord.AnotherSampleRecord\"));\n  }\n\n  private static class ClassWithAliasOnField {\n    @AvroAlias(alias = \"aliasName\")\n    int primitiveField;\n  }\n\n  private static class ClassWithMultipleAliasesOnField {\n    @AvroAlias(alias = \"alias1\")\n    @AvroAlias(alias = \"alias2\")\n    int primitiveField;\n  }\n\n  private static class ClassWithAliasAndNamespaceOnField {\n    @AvroAlias(alias = \"aliasName\", space = \"forbidden.space.entry\")\n    int primitiveField;\n  }\n\n  @Test\n  void avroAliasOnField() {\n\n    Schema expectedSchema = SchemaBuilder.record(ClassWithAliasOnField.class.getSimpleName())\n        .namespace(\"org.apache.avro.reflect.TestReflect\").fields().name(\"primitiveField\").aliases(\"aliasName\")\n        .type(Schema.create(org.apache.avro.Schema.Type.INT)).noDefault().endRecord();\n\n    check(ClassWithAliasOnField.class, expectedSchema.toString());\n  }\n\n  @Test\n  void namespaceDefinitionOnFieldAliasMustThrowException() {\n    assertThrows(AvroRuntimeException.class, () -> {\n      ReflectData.get().getSchema(ClassWithAliasAndNamespaceOnField.class);\n    });\n  }\n\n  @Test\n  public void testMultipleFieldAliases() {\n    Field field = new Field(\"primitiveField\", Schema.create(Schema.Type.INT));\n    field.addAlias(\"alias1\");\n    field.addAlias(\"alias2\");\n    Schema avroMultiMeta = Schema.createRecord(\"ClassWithMultipleAliasesOnField\", null,\n        \"org.apache.avro.reflect.TestReflect\", false, Arrays.asList(field));\n\n    Schema schema = ReflectData.get().getSchema(ClassWithMultipleAliasesOnField.class);\n    assertEquals(avroMultiMeta, schema);\n  }\n\n  private static class OptionalTest {\n    Optional<Integer> foo;\n  }\n\n  @Test\n  public void testOptional() {\n    check(OptionalTest.class,\n        \"{\\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"OptionalTest\\\",\"\n            + \"\\\"namespace\\\":\\\"org.apache.avro.reflect.TestReflect\\\",\\\"fields\\\":[\"\n            + \"{\\\"name\\\":\\\"foo\\\",\\\"type\\\":[\\\"null\\\",\\\"int\\\"],\\\"default\\\":null}]}\");\n  }\n\n  private static class DefaultTest {\n    @AvroDefault(\"1\")\n    int foo;\n  }\n\n  @Test\n  void avroDefault() {\n    check(DefaultTest.class,\n        \"{\\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"DefaultTest\\\",\"\n            + \"\\\"namespace\\\":\\\"org.apache.avro.reflect.TestReflect\\\",\\\"fields\\\":[\"\n            + \"{\\\"name\\\":\\\"foo\\\",\\\"type\\\":\\\"int\\\",\\\"default\\\":1}]}\");\n  }\n\n  public static class NullableBytesTest {\n    @Nullable\n    byte[] bytes;\n\n    NullableBytesTest() {\n    }\n\n    NullableBytesTest(byte[] bytes) {\n      this.bytes = bytes;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n      return obj instanceof NullableBytesTest && Arrays.equals(((NullableBytesTest) obj).bytes, this.bytes);\n    }\n  }\n\n  @Test\n  void nullableByteArrayNotNullValue() throws Exception {\n    checkReadWrite(new NullableBytesTest(\"foo\".getBytes(UTF_8)));\n  }\n\n  @Test\n  void nullableByteArrayNullValue() throws Exception {\n    checkReadWrite(new NullableBytesTest());\n  }\n\n  private enum DocTestEnum {\n    ENUM_1, ENUM_2\n  }\n\n  @AvroDoc(\"DocTest class docs\")\n  private static class DocTest {\n    @AvroDoc(\"Some Documentation\")\n    int foo;\n\n    @AvroDoc(\"Some other Documentation\")\n    DocTestEnum enums;\n\n    @AvroDoc(\"And again\")\n    DefaultTest defaultTest;\n  }\n\n  @Test\n  void avroDoc() {\n    check(DocTest.class,\n        \"{\\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"DocTest\\\",\\\"namespace\\\":\\\"org.apache.avro.reflect.TestReflect\\\",\"\n            + \"\\\"doc\\\":\\\"DocTest class docs\\\",\" + \"\\\"fields\\\":[\"\n            + \"{\\\"name\\\":\\\"defaultTest\\\",\\\"type\\\":{\\\"type\\\":\\\"record\\\",\\\"name\\\":\\\"DefaultTest\\\",\"\n            + \"\\\"fields\\\":[{\\\"name\\\":\\\"foo\\\",\\\"type\\\":\\\"int\\\",\\\"default\\\":1}]},\\\"doc\\\":\\\"And again\\\"},\"\n            + \"{\\\"name\\\":\\\"enums\\\",\\\"type\\\":{\\\"type\\\":\\\"enum\\\",\\\"name\\\":\\\"DocTestEnum\\\",\"\n            + \"\\\"symbols\\\":[\\\"ENUM_1\\\",\\\"ENUM_2\\\"]},\\\"doc\\\":\\\"Some other Documentation\\\"},\"\n            + \"{\\\"name\\\":\\\"foo\\\",\\\"type\\\":\\\"int\\\",\\\"doc\\\":\\\"Some Documentation\\\"}\" + \"]}\");\n  }\n\n}\n","lineNo":980}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.avro.tool;\n\nimport org.apache.avro.Protocol;\nimport org.apache.avro.compiler.idl.Idl;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.util.List;\n\n/**\n * Tool implementation for generating Avro JSON schemata from idl format files.\n */\npublic class IdlTool implements Tool {\n  @Override\n  public int run(InputStream in, PrintStream out, PrintStream err, List<String> args) throws Exception {\n\n    PrintStream parseOut = out;\n\n    if (args.size() > 2 || (args.size() == 1 && (args.get(0).equals(\"--help\") || args.get(0).equals(\"-help\")))) {\n      err.println(\"Usage: idl [in] [out]\");\n      err.println();\n      err.println(\"If an output path is not specified, outputs to stdout.\");\n      err.println(\"If no input or output is specified, takes input from\");\n      err.println(\"stdin and outputs to stdin.\");\n      err.println(\"The special path \\\"-\\\" may also be specified to refer to\");\n      err.println(\"stdin and stdout.\");\n      return -1;\n    }\n\n    Idl parser;\n    if (args.size() >= 1 && !\"-\".equals(args.get(0))) {\n      parser = new Idl(new File(args.get(0)));\n    } else {\n      parser = new Idl(in);\n    }\n\n    if (args.size() == 2 && !\"-\".equals(args.get(1))) {\n      parseOut = new PrintStream(new FileOutputStream(args.get(1)));\n    }\n\n    Protocol p = parser.CompilationUnit();\n    final List<String> warnings = parser.getWarningsAfterParsing();\n    for (String warning : warnings) {\n      err.println(\"Warning: \" + warning);\n    }\n    try {\n      parseOut.print(p.toString(true));\n    } finally {\n      if (parseOut != out) // Close only the newly created FileOutputStream\n        parseOut.close();\n    }\n    return 0;\n  }\n\n  @Override\n  public String getName() {\n    return \"idl\";\n  }\n\n  @Override\n  public String getShortDescription() {\n    return \"Generates a JSON schema from an Avro IDL file\";\n  }\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.avro.tool;\n\nimport org.apache.avro.Protocol;\nimport org.apache.avro.compiler.idl.Idl;\nimport org.apache.avro.idl.IdlFile;\nimport org.apache.avro.idl.IdlReader;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.util.List;\n\n/**\n * Tool implementation for generating Avro JSON schemata from idl format files.\n */\npublic class IdlTool implements Tool {\n  @Override\n  public int run(InputStream in, PrintStream out, PrintStream err, List<String> args) throws Exception {\n\n    boolean useJavaCC = \"--useJavaCC\".equals(getArg(args, 0, null));\n    if (args.size() > (useJavaCC ? 3 : 2)\n        || (args.size() == 1 && (args.get(0).equals(\"--help\") || args.get(0).equals(\"-help\")))) {\n      err.println(\"Usage: idl [--useJavaCC] [in [out]]\");\n      err.println();\n      err.println(\"If an output path is not specified, outputs to stdout.\");\n      err.println(\"If no input or output is specified, takes input from\");\n      err.println(\"stdin and outputs to stdout.\");\n      err.println(\"The special path \\\"-\\\" may also be specified to refer to\");\n      err.println(\"stdin and stdout.\");\n      return -1;\n    }\n\n    String inputName = getArg(args, useJavaCC ? 1 : 0, \"-\");\n    File inputFile = \"-\".equals(inputName) ? null : new File(inputName);\n    String outputName = getArg(args, useJavaCC ? 2 : 1, \"-\");\n    File outputFile = \"-\".equals(outputName) ? null : new File(outputName);\n\n    Protocol p;\n    if (useJavaCC) {\n      try (Idl parser = new Idl(inputFile)) {\n        p = parser.CompilationUnit();\n        for (String warning : parser.getWarningsAfterParsing()) {\n          err.println(\"Warning: \" + warning);\n        }\n      }\n    } else {\n      IdlReader parser = new IdlReader();\n      IdlFile idlFile = inputFile == null ? parser.parse(in) : parser.parse(inputFile.toPath());\n      for (String warning : idlFile.getWarnings()) {\n        err.println(\"Warning: \" + warning);\n      }\n      p = idlFile.getProtocol();\n    }\n\n    PrintStream parseOut = out;\n    if (outputFile != null) {\n      parseOut = new PrintStream(new FileOutputStream(outputFile));\n    }\n\n    try {\n      parseOut.print(p.toString(true));\n    } finally {\n      if (parseOut != out) // Close only the newly created FileOutputStream\n        parseOut.close();\n    }\n    return 0;\n  }\n\n  private String getArg(List<String> args, int index, String defaultValue) {\n    if (index < args.size()) {\n      return args.get(index);\n    } else {\n      return defaultValue;\n    }\n  }\n\n  @Override\n  public String getName() {\n    return \"idl\";\n  }\n\n  @Override\n  public String getShortDescription() {\n    return \"Generates a JSON protocol from an Avro IDL file\";\n  }\n}\n","lineNo":55}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.avro.tool;\n\nimport org.apache.avro.Protocol;\nimport org.apache.avro.compiler.idl.Idl;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.util.List;\n\n/**\n * Tool implementation for generating Avro JSON schemata from idl format files.\n */\npublic class IdlTool implements Tool {\n  @Override\n  public int run(InputStream in, PrintStream out, PrintStream err, List<String> args) throws Exception {\n\n    PrintStream parseOut = out;\n\n    if (args.size() > 2 || (args.size() == 1 && (args.get(0).equals(\"--help\") || args.get(0).equals(\"-help\")))) {\n      err.println(\"Usage: idl [in] [out]\");\n      err.println();\n      err.println(\"If an output path is not specified, outputs to stdout.\");\n      err.println(\"If no input or output is specified, takes input from\");\n      err.println(\"stdin and outputs to stdin.\");\n      err.println(\"The special path \\\"-\\\" may also be specified to refer to\");\n      err.println(\"stdin and stdout.\");\n      return -1;\n    }\n\n    Idl parser;\n    if (args.size() >= 1 && !\"-\".equals(args.get(0))) {\n      parser = new Idl(new File(args.get(0)));\n    } else {\n      parser = new Idl(in);\n    }\n\n    if (args.size() == 2 && !\"-\".equals(args.get(1))) {\n      parseOut = new PrintStream(new FileOutputStream(args.get(1)));\n    }\n\n    Protocol p = parser.CompilationUnit();\n    final List<String> warnings = parser.getWarningsAfterParsing();\n    for (String warning : warnings) {\n      err.println(\"Warning: \" + warning);\n    }\n    try {\n      parseOut.print(p.toString(true));\n    } finally {\n      if (parseOut != out) // Close only the newly created FileOutputStream\n        parseOut.close();\n    }\n    return 0;\n  }\n\n  @Override\n  public String getName() {\n    return \"idl\";\n  }\n\n  @Override\n  public String getShortDescription() {\n    return \"Generates a JSON schema from an Avro IDL file\";\n  }\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.avro.tool;\n\nimport org.apache.avro.Protocol;\nimport org.apache.avro.compiler.idl.Idl;\nimport org.apache.avro.idl.IdlFile;\nimport org.apache.avro.idl.IdlReader;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.util.List;\n\n/**\n * Tool implementation for generating Avro JSON schemata from idl format files.\n */\npublic class IdlTool implements Tool {\n  @Override\n  public int run(InputStream in, PrintStream out, PrintStream err, List<String> args) throws Exception {\n\n    boolean useJavaCC = \"--useJavaCC\".equals(getArg(args, 0, null));\n    if (args.size() > (useJavaCC ? 3 : 2)\n        || (args.size() == 1 && (args.get(0).equals(\"--help\") || args.get(0).equals(\"-help\")))) {\n      err.println(\"Usage: idl [--useJavaCC] [in [out]]\");\n      err.println();\n      err.println(\"If an output path is not specified, outputs to stdout.\");\n      err.println(\"If no input or output is specified, takes input from\");\n      err.println(\"stdin and outputs to stdout.\");\n      err.println(\"The special path \\\"-\\\" may also be specified to refer to\");\n      err.println(\"stdin and stdout.\");\n      return -1;\n    }\n\n    String inputName = getArg(args, useJavaCC ? 1 : 0, \"-\");\n    File inputFile = \"-\".equals(inputName) ? null : new File(inputName);\n    String outputName = getArg(args, useJavaCC ? 2 : 1, \"-\");\n    File outputFile = \"-\".equals(outputName) ? null : new File(outputName);\n\n    Protocol p;\n    if (useJavaCC) {\n      try (Idl parser = new Idl(inputFile)) {\n        p = parser.CompilationUnit();\n        for (String warning : parser.getWarningsAfterParsing()) {\n          err.println(\"Warning: \" + warning);\n        }\n      }\n    } else {\n      IdlReader parser = new IdlReader();\n      IdlFile idlFile = inputFile == null ? parser.parse(in) : parser.parse(inputFile.toPath());\n      for (String warning : idlFile.getWarnings()) {\n        err.println(\"Warning: \" + warning);\n      }\n      p = idlFile.getProtocol();\n    }\n\n    PrintStream parseOut = out;\n    if (outputFile != null) {\n      parseOut = new PrintStream(new FileOutputStream(outputFile));\n    }\n\n    try {\n      parseOut.print(p.toString(true));\n    } finally {\n      if (parseOut != out) // Close only the newly created FileOutputStream\n        parseOut.close();\n    }\n    return 0;\n  }\n\n  private String getArg(List<String> args, int index, String defaultValue) {\n    if (index < args.size()) {\n      return args.get(index);\n    } else {\n      return defaultValue;\n    }\n  }\n\n  @Override\n  public String getName() {\n    return \"idl\";\n  }\n\n  @Override\n  public String getShortDescription() {\n    return \"Generates a JSON protocol from an Avro IDL file\";\n  }\n}\n","lineNo":53}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.avro;\n\nimport com.fasterxml.jackson.core.JsonFactory;\nimport com.fasterxml.jackson.core.JsonGenerator;\nimport com.fasterxml.jackson.core.JsonParseException;\nimport com.fasterxml.jackson.core.JsonParser;\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.node.DoubleNode;\nimport com.fasterxml.jackson.databind.node.NullNode;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.Serializable;\nimport java.io.StringWriter;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.IdentityHashMap;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\nimport org.apache.avro.util.internal.Accessor;\nimport org.apache.avro.util.internal.Accessor.FieldAccessor;\nimport org.apache.avro.util.internal.JacksonUtils;\nimport org.apache.avro.util.internal.ThreadLocalWithInitial;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport static org.apache.avro.LogicalType.LOGICAL_TYPE_PROP;\n\n/**\n * An abstract data type.\n * <p>\n * A schema may be one of:\n * <ul>\n * <li>A <i>record<\/i>, mapping field names to field value data;\n * <li>An <i>enum<\/i>, containing one of a small set of symbols;\n * <li>An <i>array<\/i> of values, all of the same schema;\n * <li>A <i>map<\/i>, containing string/value pairs, of a declared schema;\n * <li>A <i>union<\/i> of other schemas;\n * <li>A <i>fixed<\/i> sized binary object;\n * <li>A unicode <i>string<\/i>;\n * <li>A sequence of <i>bytes<\/i>;\n * <li>A 32-bit signed <i>int<\/i>;\n * <li>A 64-bit signed <i>long<\/i>;\n * <li>A 32-bit IEEE single-<i>float<\/i>; or\n * <li>A 64-bit IEEE <i>double<\/i>-float; or\n * <li>A <i>boolean<\/i>; or\n * <li><i>null<\/i>.\n * <\/ul>\n *\n * A schema can be constructed using one of its static <tt>createXXX<\/tt>\n * methods, or more conveniently using {@link SchemaBuilder}. The schema objects\n * are <i>logically<\/i> immutable. There are only two mutating methods -\n * {@link #setFields(List)} and {@link #addProp(String, String)}. The following\n * restrictions apply on these two methods.\n * <ul>\n * <li>{@link #setFields(List)}, can be called at most once. This method exists\n * in order to enable clients to build recursive schemas.\n * <li>{@link #addProp(String, String)} can be called with property names that\n * are not present already. It is not possible to change or delete an existing\n * property.\n * <\/ul>\n */\npublic abstract class Schema extends JsonProperties implements Serializable {\n\n  private static final long serialVersionUID = 1L;\n\n  protected Object writeReplace() {\n    SerializableSchema ss = new SerializableSchema();\n    ss.schemaString = toString();\n    return ss;\n  }\n\n  private static final class SerializableSchema implements Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    private String schemaString;\n\n    private Object readResolve() {\n      return new Schema.Parser().parse(schemaString);\n    }\n  }\n\n  static final JsonFactory FACTORY = new JsonFactory();\n  static final Logger LOG = LoggerFactory.getLogger(Schema.class);\n  static final ObjectMapper MAPPER = new ObjectMapper(FACTORY);\n\n  private static final int NO_HASHCODE = Integer.MIN_VALUE;\n\n  static {\n    FACTORY.enable(JsonParser.Feature.ALLOW_COMMENTS);\n    FACTORY.setCodec(MAPPER);\n  }\n\n  /** The type of a schema. */\n  public enum Type {\n    RECORD, ENUM, ARRAY, MAP, UNION, FIXED, STRING, BYTES, INT, LONG, FLOAT, DOUBLE, BOOLEAN, NULL;\n\n    private final String name;\n\n    private Type() {\n      this.name = this.name().toLowerCase(Locale.ENGLISH);\n    }\n\n    public String getName() {\n      return name;\n    }\n  };\n\n  private final Type type;\n  private LogicalType logicalType = null;\n\n  Schema(Type type) {\n    super(type == Type.ENUM ? ENUM_RESERVED : SCHEMA_RESERVED);\n    this.type = type;\n  }\n\n  /** Create a schema for a primitive type. */\n  public static Schema create(Type type) {\n    switch (type) {\n    case STRING:\n      return new StringSchema();\n    case BYTES:\n      return new BytesSchema();\n    case INT:\n      return new IntSchema();\n    case LONG:\n      return new LongSchema();\n    case FLOAT:\n      return new FloatSchema();\n    case DOUBLE:\n      return new DoubleSchema();\n    case BOOLEAN:\n      return new BooleanSchema();\n    case NULL:\n      return new NullSchema();\n    default:\n      throw new AvroRuntimeException(\"Can't create a: \" + type);\n    }\n  }\n\n  private static final Set<String> SCHEMA_RESERVED = new HashSet<>(\n      Arrays.asList(\"doc\", \"fields\", \"items\", \"name\", \"namespace\", \"size\", \"symbols\", \"values\", \"type\", \"aliases\"));\n\n  private static final Set<String> ENUM_RESERVED = new HashSet<>(SCHEMA_RESERVED);\n  static {\n    ENUM_RESERVED.add(\"default\");\n  }\n\n  int hashCode = NO_HASHCODE;\n\n  @Override\n  public void addProp(String name, String value) {\n    super.addProp(name, value);\n    hashCode = NO_HASHCODE;\n  }\n\n  @Override\n  public void addProp(String name, Object value) {\n    super.addProp(name, value);\n    hashCode = NO_HASHCODE;\n  }\n\n  public LogicalType getLogicalType() {\n    return logicalType;\n  }\n\n  void setLogicalType(LogicalType logicalType) {\n    this.logicalType = logicalType;\n  }\n\n  /**\n   * Create an anonymous record schema.\n   *\n   * @deprecated This method allows to create Schema objects that cannot be parsed\n   *             by {@link Schema.Parser#parse(String)}. It will be removed in a\n   *             future version of Avro. Better use\n   *             i{@link #createRecord(String, String, String, boolean, List)} to\n   *             produce a fully qualified Schema.\n   */\n  @Deprecated\n  public static Schema createRecord(List<Field> fields) {\n    Schema result = createRecord(null, null, null, false);\n    result.setFields(fields);\n    return result;\n  }\n\n  /** Create a named record schema. */\n  public static Schema createRecord(String name, String doc, String namespace, boolean isError) {\n    return new RecordSchema(new Name(name, namespace), doc, isError);\n  }\n\n  /** Create a named record schema with fields already set. */\n  public static Schema createRecord(String name, String doc, String namespace, boolean isError, List<Field> fields) {\n    return new RecordSchema(new Name(name, namespace), doc, isError, fields);\n  }\n\n  /** Create an enum schema. */\n  public static Schema createEnum(String name, String doc, String namespace, List<String> values) {\n    return new EnumSchema(new Name(name, namespace), doc, new LockableArrayList<>(values), null);\n  }\n\n  /** Create an enum schema. */\n  public static Schema createEnum(String name, String doc, String namespace, List<String> values, String enumDefault) {\n    return new EnumSchema(new Name(name, namespace), doc, new LockableArrayList<>(values), enumDefault);\n  }\n\n  /** Create an array schema. */\n  public static Schema createArray(Schema elementType) {\n    return new ArraySchema(elementType);\n  }\n\n  /** Create a map schema. */\n  public static Schema createMap(Schema valueType) {\n    return new MapSchema(valueType);\n  }\n\n  /** Create a union schema. */\n  public static Schema createUnion(List<Schema> types) {\n    return new UnionSchema(new LockableArrayList<>(types));\n  }\n\n  /** Create a union schema. */\n  public static Schema createUnion(Schema... types) {\n    return createUnion(new LockableArrayList<>(types));\n  }\n\n  /** Create a fixed schema. */\n  public static Schema createFixed(String name, String doc, String space, int size) {\n    return new FixedSchema(new Name(name, space), doc, size);\n  }\n\n  /** Return the type of this schema. */\n  public Type getType() {\n    return type;\n  }\n\n  /**\n   * If this is a record, returns the Field with the given name\n   * <tt>fieldName<\/tt>. If there is no field by that name, a <tt>null<\/tt> is\n   * returned.\n   */\n  public Field getField(String fieldname) {\n    throw new AvroRuntimeException(\"Not a record: \" + this);\n  }\n\n  /**\n   * If this is a record, returns the fields in it. The returned list is in the\n   * order of their positions.\n   */\n  public List<Field> getFields() {\n    throw new AvroRuntimeException(\"Not a record: \" + this);\n  }\n\n  /**\n   * If this is a record, returns whether the fields have been set.\n   */\n  public boolean hasFields() {\n    throw new AvroRuntimeException(\"Not a record: \" + this);\n  }\n\n  /**\n   * If this is a record, set its fields. The fields can be set only once in a\n   * schema.\n   */\n  public void setFields(List<Field> fields) {\n    throw new AvroRuntimeException(\"Not a record: \" + this);\n  }\n\n  /** If this is an enum, return its symbols. */\n  public List<String> getEnumSymbols() {\n    throw new AvroRuntimeException(\"Not an enum: \" + this);\n  }\n\n  /** If this is an enum, return its default value. */\n  public String getEnumDefault() {\n    throw new AvroRuntimeException(\"Not an enum: \" + this);\n  }\n\n  /** If this is an enum, return a symbol's ordinal value. */\n  public int getEnumOrdinal(String symbol) {\n    throw new AvroRuntimeException(\"Not an enum: \" + this);\n  }\n\n  /** If this is an enum, returns true if it contains given symbol. */\n  public boolean hasEnumSymbol(String symbol) {\n    throw new AvroRuntimeException(\"Not an enum: \" + this);\n  }\n\n  /**\n   * If this is a record, enum or fixed, returns its name, otherwise the name of\n   * the primitive type.\n   */\n  public String getName() {\n    return type.name;\n  }\n\n  /**\n   * If this is a record, enum, or fixed, returns its docstring, if available.\n   * Otherwise, returns null.\n   */\n  public String getDoc() {\n    return null;\n  }\n\n  /** If this is a record, enum or fixed, returns its namespace, if any. */\n  public String getNamespace() {\n    throw new AvroRuntimeException(\"Not a named type: \" + this);\n  }\n\n  /**\n   * If this is a record, enum or fixed, returns its namespace-qualified name,\n   * otherwise returns the name of the primitive type.\n   */\n  public String getFullName() {\n    return getName();\n  }\n\n  /** If this is a record, enum or fixed, add an alias. */\n  public void addAlias(String alias) {\n    throw new AvroRuntimeException(\"Not a named type: \" + this);\n  }\n\n  /** If this is a record, enum or fixed, add an alias. */\n  public void addAlias(String alias, String space) {\n    throw new AvroRuntimeException(\"Not a named type: \" + this);\n  }\n\n  /** If this is a record, enum or fixed, return its aliases, if any. */\n  public Set<String> getAliases() {\n    throw new AvroRuntimeException(\"Not a named type: \" + this);\n  }\n\n  /** Returns true if this record is an error type. */\n  public boolean isError() {\n    throw new AvroRuntimeException(\"Not a record: \" + this);\n  }\n\n  /** If this is an array, returns its element type. */\n  public Schema getElementType() {\n    throw new AvroRuntimeException(\"Not an array: \" + this);\n  }\n\n  /** If this is a map, returns its value type. */\n  public Schema getValueType() {\n    throw new AvroRuntimeException(\"Not a map: \" + this);\n  }\n\n  /** If this is a union, returns its types. */\n  public List<Schema> getTypes() {\n    throw new AvroRuntimeException(\"Not a union: \" + this);\n  }\n\n  /** If this is a union, return the branch with the provided full name. */\n  public Integer getIndexNamed(String name) {\n    throw new AvroRuntimeException(\"Not a union: \" + this);\n  }\n\n  /** If this is fixed, returns its size. */\n  public int getFixedSize() {\n    throw new AvroRuntimeException(\"Not fixed: \" + this);\n  }\n\n  /** Render this as <a href=\"https://json.org/\">JSON<\/a>. */\n  @Override\n  public String toString() {\n    return toString(false);\n  }\n\n  /**\n   * Render this as <a href=\"https://json.org/\">JSON<\/a>.\n   *\n   * @param pretty if true, pretty-print JSON.\n   */\n  public String toString(boolean pretty) {\n    return toString(new Names(), pretty);\n  }\n\n  /**\n   * Render this as <a href=\"https://json.org/\">JSON<\/a>, but without inlining the\n   * referenced schemas.\n   *\n   * @param referencedSchemas referenced schemas\n   * @param pretty            if true, pretty-print JSON.\n   */\n  // Use at your own risk. This method should be removed with AVRO-2832.\n  @Deprecated\n  public String toString(Collection<Schema> referencedSchemas, boolean pretty) {\n    Schema.Names names = new Schema.Names();\n    if (referencedSchemas != null) {\n      for (Schema s : referencedSchemas) {\n        names.add(s);\n      }\n    }\n    return toString(names, pretty);\n  }\n\n  String toString(Names names, boolean pretty) {\n    try {\n      StringWriter writer = new StringWriter();\n      JsonGenerator gen = FACTORY.createGenerator(writer);\n      if (pretty)\n        gen.useDefaultPrettyPrinter();\n      toJson(names, gen);\n      gen.flush();\n      return writer.toString();\n    } catch (IOException e) {\n      throw new AvroRuntimeException(e);\n    }\n  }\n\n  void toJson(Names names, JsonGenerator gen) throws IOException {\n    if (!hasProps()) { // no props defined\n      gen.writeString(getName()); // just write name\n    } else {\n      gen.writeStartObject();\n      gen.writeStringField(\"type\", getName());\n      writeProps(gen);\n      gen.writeEndObject();\n    }\n  }\n\n  void fieldsToJson(Names names, JsonGenerator gen) throws IOException {\n    throw new AvroRuntimeException(\"Not a record: \" + this);\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (o == this)\n      return true;\n    if (!(o instanceof Schema))\n      return false;\n    Schema that = (Schema) o;\n    if (!(this.type == that.type))\n      return false;\n    return equalCachedHash(that) && propsEqual(that);\n  }\n\n  @Override\n  public final int hashCode() {\n    if (hashCode == NO_HASHCODE)\n      hashCode = computeHash();\n    return hashCode;\n  }\n\n  int computeHash() {\n    return getType().hashCode() + propsHashCode();\n  }\n\n  final boolean equalCachedHash(Schema other) {\n    return (hashCode == other.hashCode) || (hashCode == NO_HASHCODE) || (other.hashCode == NO_HASHCODE);\n  }\n\n  private static final Set<String> FIELD_RESERVED = Collections\n      .unmodifiableSet(new HashSet<>(Arrays.asList(\"default\", \"doc\", \"name\", \"order\", \"type\", \"aliases\")));\n\n  /** Returns true if this record is an union type. */\n  public boolean isUnion() {\n    return this instanceof UnionSchema;\n  }\n\n  /** Returns true if this record is an union type containing null. */\n  public boolean isNullable() {\n    if (!isUnion()) {\n      return getType().equals(Schema.Type.NULL);\n    }\n\n    for (Schema schema : getTypes()) {\n      if (schema.isNullable()) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /** A field within a record. */\n  public static class Field extends JsonProperties {\n\n    static {\n      Accessor.setAccessor(new FieldAccessor() {\n        @Override\n        protected JsonNode defaultValue(Field field) {\n          return field.defaultValue();\n        }\n\n        @Override\n        protected Field createField(String name, Schema schema, String doc, JsonNode defaultValue) {\n          return new Field(name, schema, doc, defaultValue, true, Order.ASCENDING);\n        }\n\n        @Override\n        protected Field createField(String name, Schema schema, String doc, JsonNode defaultValue, boolean validate,\n            Order order) {\n          return new Field(name, schema, doc, defaultValue, validate, order);\n        }\n      });\n    }\n\n    /** How values of this field should be ordered when sorting records. */\n    public enum Order {\n      ASCENDING, DESCENDING, IGNORE;\n\n      private final String name;\n\n      Order() {\n        this.name = this.name().toLowerCase(Locale.ENGLISH);\n      }\n    }\n\n    /**\n     * For Schema unions with a \"null\" type as the first entry, this can be used to\n     * specify that the default for the union is null.\n     */\n    public static final Object NULL_DEFAULT_VALUE = new Object();\n\n    private final String name; // name of the field.\n    private int position = -1;\n    private final Schema schema;\n    private final String doc;\n    private final JsonNode defaultValue;\n    private final Order order;\n    private Set<String> aliases;\n\n    Field(String name, Schema schema, String doc, JsonNode defaultValue, boolean validateDefault, Order order) {\n      super(FIELD_RESERVED);\n      this.name = validateName(name);\n      this.schema = Objects.requireNonNull(schema, \"schema is required and cannot be null\");\n      this.doc = doc;\n      this.defaultValue = validateDefault ? validateDefault(name, schema, defaultValue) : defaultValue;\n      this.order = Objects.requireNonNull(order, \"Order cannot be null\");\n    }\n\n    /**\n     * Constructs a new Field instance with the same {@code name}, {@code doc},\n     * {@code defaultValue}, and {@code order} as {@code field} has with changing\n     * the schema to the specified one. It also copies all the {@code props} and\n     * {@code aliases}.\n     */\n    public Field(Field field, Schema schema) {\n      this(field.name, schema, field.doc, field.defaultValue, true, field.order);\n      putAll(field);\n      if (field.aliases != null)\n        aliases = new LinkedHashSet<>(field.aliases);\n    }\n\n    /**\n     *\n     */\n    public Field(String name, Schema schema) {\n      this(name, schema, (String) null, (JsonNode) null, true, Order.ASCENDING);\n    }\n\n    /**\n     *\n     */\n    public Field(String name, Schema schema, String doc) {\n      this(name, schema, doc, (JsonNode) null, true, Order.ASCENDING);\n    }\n\n    /**\n     * @param defaultValue the default value for this field specified using the\n     *                     mapping in {@link JsonProperties}\n     */\n    public Field(String name, Schema schema, String doc, Object defaultValue) {\n      this(name, schema, doc,\n          defaultValue == NULL_DEFAULT_VALUE ? NullNode.getInstance() : JacksonUtils.toJsonNode(defaultValue), true,\n          Order.ASCENDING);\n    }\n\n    /**\n     * @param defaultValue the default value for this field specified using the\n     *                     mapping in {@link JsonProperties}\n     */\n    public Field(String name, Schema schema, String doc, Object defaultValue, Order order) {\n      this(name, schema, doc,\n          defaultValue == NULL_DEFAULT_VALUE ? NullNode.getInstance() : JacksonUtils.toJsonNode(defaultValue), true,\n          Objects.requireNonNull(order));\n    }\n\n    public String name() {\n      return name;\n    };\n\n    /** The position of this field within the record. */\n    public int pos() {\n      return position;\n    }\n\n    /** This field's {@link Schema}. */\n    public Schema schema() {\n      return schema;\n    }\n\n    /** Field's documentation within the record, if set. May return null. */\n    public String doc() {\n      return doc;\n    }\n\n    /**\n     * @return true if this Field has a default value set. Can be used to determine\n     *         if a \"null\" return from defaultVal() is due to that being the default\n     *         value or just not set.\n     */\n    public boolean hasDefaultValue() {\n      return defaultValue != null;\n    }\n\n    JsonNode defaultValue() {\n      return defaultValue;\n    }\n\n    /**\n     * @return the default value for this field specified using the mapping in\n     *         {@link JsonProperties}\n     */\n    public Object defaultVal() {\n      return JacksonUtils.toObject(defaultValue, schema);\n    }\n\n    public Order order() {\n      return order;\n    }\n\n    public void addAlias(String alias) {\n      if (aliases == null)\n        this.aliases = new LinkedHashSet<>();\n      aliases.add(alias);\n    }\n\n    /** Return the defined aliases as an unmodifiable Set. */\n    public Set<String> aliases() {\n      if (aliases == null)\n        return Collections.emptySet();\n      return Collections.unmodifiableSet(aliases);\n    }\n\n    @Override\n    public boolean equals(Object other) {\n      if (other == this)\n        return true;\n      if (!(other instanceof Field))\n        return false;\n      Field that = (Field) other;\n      return (name.equals(that.name)) && (schema.equals(that.schema)) && defaultValueEquals(that.defaultValue)\n          && (order == that.order) && propsEqual(that);\n    }\n\n    @Override\n    public int hashCode() {\n      return name.hashCode() + schema.computeHash();\n    }\n\n    private boolean defaultValueEquals(JsonNode thatDefaultValue) {\n      if (defaultValue == null)\n        return thatDefaultValue == null;\n      if (thatDefaultValue == null)\n        return false;\n      if (Double.isNaN(defaultValue.doubleValue()))\n        return Double.isNaN(thatDefaultValue.doubleValue());\n      return defaultValue.equals(thatDefaultValue);\n    }\n\n    @Override\n    public String toString() {\n      return name + \" type:\" + schema.type + \" pos:\" + position;\n    }\n  }\n\n  static class Name {\n    private final String name;\n    private final String space;\n    private final String full;\n\n    public Name(String name, String space) {\n      if (name == null) { // anonymous\n        this.name = this.space = this.full = null;\n        return;\n      }\n      int lastDot = name.lastIndexOf('.');\n      if (lastDot < 0) { // unqualified name\n        this.name = validateName(name);\n      } else { // qualified name\n        space = name.substring(0, lastDot); // get space from name\n        this.name = validateName(name.substring(lastDot + 1));\n      }\n      if (\"\".equals(space))\n        space = null;\n      this.space = space;\n      this.full = (this.space == null) ? this.name : this.space + \".\" + this.name;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (o == this)\n        return true;\n      if (!(o instanceof Name))\n        return false;\n      Name that = (Name) o;\n      return Objects.equals(full, that.full);\n    }\n\n    @Override\n    public int hashCode() {\n      return full == null ? 0 : full.hashCode();\n    }\n\n    @Override\n    public String toString() {\n      return full;\n    }\n\n    public void writeName(Names names, JsonGenerator gen) throws IOException {\n      if (name != null)\n        gen.writeStringField(\"name\", name);\n      if (space != null) {\n        if (!space.equals(names.space()))\n          gen.writeStringField(\"namespace\", space);\n      } else if (names.space() != null) { // null within non-null\n        gen.writeStringField(\"namespace\", \"\");\n      }\n    }\n\n    public String getQualified(String defaultSpace) {\n      return this.shouldWriteFull(defaultSpace) ? full : name;\n    }\n\n    /**\n     * Determine if full name must be written. There are 2 cases for true :\n     * defaultSpace != from this.space or name is already a Schema.Type (int, array\n     * ...)\n     *\n     * @param defaultSpace : default name space.\n     * @return true if full name must be written.\n     */\n    private boolean shouldWriteFull(String defaultSpace) {\n      if (space != null && space.equals(defaultSpace)) {\n        for (Type schemaType : Type.values()) {\n          if (schemaType.name.equals(name)) {\n            // name is a 'Type', so namespace must be written\n            return true;\n          }\n        }\n        // this.space == defaultSpace\n        return false;\n      }\n      // this.space != defaultSpace, so namespace must be written.\n      return true;\n    }\n\n  }\n\n  private static abstract class NamedSchema extends Schema {\n    final Name name;\n    final String doc;\n    Set<Name> aliases;\n\n    public NamedSchema(Type type, Name name, String doc) {\n      super(type);\n      this.name = name;\n      this.doc = doc;\n      if (PRIMITIVES.containsKey(name.full)) {\n        throw new AvroTypeException(\"Schemas may not be named after primitives: \" + name.full);\n      }\n    }\n\n    @Override\n    public String getName() {\n      return name.name;\n    }\n\n    @Override\n    public String getDoc() {\n      return doc;\n    }\n\n    @Override\n    public String getNamespace() {\n      return name.space;\n    }\n\n    @Override\n    public String getFullName() {\n      return name.full;\n    }\n\n    @Override\n    public void addAlias(String alias) {\n      addAlias(alias, null);\n    }\n\n    @Override\n    public void addAlias(String name, String space) {\n      if (aliases == null)\n        this.aliases = new LinkedHashSet<>();\n      if (space == null)\n        space = this.name.space;\n      aliases.add(new Name(name, space));\n    }\n\n    @Override\n    public Set<String> getAliases() {\n      Set<String> result = new LinkedHashSet<>();\n      if (aliases != null)\n        for (Name alias : aliases)\n          result.add(alias.full);\n      return result;\n    }\n\n    public boolean writeNameRef(Names names, JsonGenerator gen) throws IOException {\n      if (this.equals(names.get(name))) {\n        gen.writeString(name.getQualified(names.space()));\n        return true;\n      } else if (name.name != null) {\n        names.put(name, this);\n      }\n      return false;\n    }\n\n    public void writeName(Names names, JsonGenerator gen) throws IOException {\n      name.writeName(names, gen);\n    }\n\n    public boolean equalNames(NamedSchema that) {\n      return this.name.equals(that.name);\n    }\n\n    @Override\n    int computeHash() {\n      return super.computeHash() + name.hashCode();\n    }\n\n    public void aliasesToJson(JsonGenerator gen) throws IOException {\n      if (aliases == null || aliases.isEmpty())\n        return;\n      gen.writeFieldName(\"aliases\");\n      gen.writeStartArray();\n      for (Name alias : aliases)\n        gen.writeString(alias.getQualified(name.space));\n      gen.writeEndArray();\n    }\n\n  }\n\n  /**\n   * Useful as key of {@link Map}s when traversing two schemas at the same time\n   * and need to watch for recursion.\n   */\n  public static class SeenPair {\n    private Object s1;\n    private Object s2;\n\n    public SeenPair(Object s1, Object s2) {\n      this.s1 = s1;\n      this.s2 = s2;\n    }\n\n    public boolean equals(Object o) {\n      if (!(o instanceof SeenPair))\n        return false;\n      return this.s1 == ((SeenPair) o).s1 && this.s2 == ((SeenPair) o).s2;\n    }\n\n    @Override\n    public int hashCode() {\n      return System.identityHashCode(s1) + System.identityHashCode(s2);\n    }\n  }\n\n  private static final ThreadLocal<Set> SEEN_EQUALS = ThreadLocalWithInitial.of(HashSet::new);\n  private static final ThreadLocal<Map> SEEN_HASHCODE = ThreadLocalWithInitial.of(IdentityHashMap::new);\n\n  @SuppressWarnings(value = \"unchecked\")\n  private static class RecordSchema extends NamedSchema {\n    private List<Field> fields;\n    private Map<String, Field> fieldMap;\n    private final boolean isError;\n\n    public RecordSchema(Name name, String doc, boolean isError) {\n      super(Type.RECORD, name, doc);\n      this.isError = isError;\n    }\n\n    public RecordSchema(Name name, String doc, boolean isError, List<Field> fields) {\n      super(Type.RECORD, name, doc);\n      this.isError = isError;\n      setFields(fields);\n    }\n\n    @Override\n    public boolean isError() {\n      return isError;\n    }\n\n    @Override\n    public Field getField(String fieldname) {\n      if (fieldMap == null)\n        throw new AvroRuntimeException(\"Schema fields not set yet\");\n      return fieldMap.get(fieldname);\n    }\n\n    @Override\n    public List<Field> getFields() {\n      if (fields == null)\n        throw new AvroRuntimeException(\"Schema fields not set yet\");\n      return fields;\n    }\n\n    @Override\n    public boolean hasFields() {\n      return fields != null;\n    }\n\n    @Override\n    public void setFields(List<Field> fields) {\n      if (this.fields != null) {\n        throw new AvroRuntimeException(\"Fields are already set\");\n      }\n      int i = 0;\n      fieldMap = new HashMap<>(Math.multiplyExact(2, fields.size()));\n      LockableArrayList<Field> ff = new LockableArrayList<>(fields.size());\n      for (Field f : fields) {\n        if (f.position != -1) {\n          throw new AvroRuntimeException(\"Field already used: \" + f);\n        }\n        f.position = i++;\n        final Field existingField = fieldMap.put(f.name(), f);\n        if (existingField != null) {\n          throw new AvroRuntimeException(\n              String.format(\"Duplicate field %s in record %s: %s and %s.\", f.name(), name, f, existingField));\n        }\n        ff.add(f);\n      }\n      this.fields = ff.lock();\n      this.hashCode = NO_HASHCODE;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (o == this)\n        return true;\n      if (!(o instanceof RecordSchema))\n        return false;\n      RecordSchema that = (RecordSchema) o;\n      if (!equalCachedHash(that))\n        return false;\n      if (!equalNames(that))\n        return false;\n      if (!propsEqual(that))\n        return false;\n      Set seen = SEEN_EQUALS.get();\n      SeenPair here = new SeenPair(this, o);\n      if (seen.contains(here))\n        return true; // prevent stack overflow\n      boolean first = seen.isEmpty();\n      try {\n        seen.add(here);\n        return Objects.equals(fields, that.fields);\n      } finally {\n        if (first)\n          seen.clear();\n      }\n    }\n\n    @Override\n    int computeHash() {\n      Map seen = SEEN_HASHCODE.get();\n      if (seen.containsKey(this))\n        return 0; // prevent stack overflow\n      boolean first = seen.isEmpty();\n      try {\n        seen.put(this, this);\n        return super.computeHash() + fields.hashCode();\n      } finally {\n        if (first)\n          seen.clear();\n      }\n    }\n\n    @Override\n    void toJson(Names names, JsonGenerator gen) throws IOException {\n      if (writeNameRef(names, gen))\n        return;\n      String savedSpace = names.space; // save namespace\n      gen.writeStartObject();\n      gen.writeStringField(\"type\", isError ? \"error\" : \"record\");\n      writeName(names, gen);\n      names.space = name.space; // set default namespace\n      if (getDoc() != null)\n        gen.writeStringField(\"doc\", getDoc());\n\n      if (fields != null) {\n        gen.writeFieldName(\"fields\");\n        fieldsToJson(names, gen);\n      }\n\n      writeProps(gen);\n      aliasesToJson(gen);\n      gen.writeEndObject();\n      names.space = savedSpace; // restore namespace\n    }\n\n    @Override\n    void fieldsToJson(Names names, JsonGenerator gen) throws IOException {\n      gen.writeStartArray();\n      for (Field f : fields) {\n        gen.writeStartObject();\n        gen.writeStringField(\"name\", f.name());\n        gen.writeFieldName(\"type\");\n        f.schema().toJson(names, gen);\n        if (f.doc() != null)\n          gen.writeStringField(\"doc\", f.doc());\n        if (f.hasDefaultValue()) {\n          gen.writeFieldName(\"default\");\n          gen.writeTree(f.defaultValue());\n        }\n        if (f.order() != Field.Order.ASCENDING)\n          gen.writeStringField(\"order\", f.order().name);\n        if (f.aliases != null && f.aliases.size() != 0) {\n          gen.writeFieldName(\"aliases\");\n          gen.writeStartArray();\n          for (String alias : f.aliases)\n            gen.writeString(alias);\n          gen.writeEndArray();\n        }\n        f.writeProps(gen);\n        gen.writeEndObject();\n      }\n      gen.writeEndArray();\n    }\n  }\n\n  private static class EnumSchema extends NamedSchema {\n    private final List<String> symbols;\n    private final Map<String, Integer> ordinals;\n    private final String enumDefault;\n\n    public EnumSchema(Name name, String doc, LockableArrayList<String> symbols, String enumDefault) {\n      super(Type.ENUM, name, doc);\n      this.symbols = symbols.lock();\n      this.ordinals = new HashMap<>(Math.multiplyExact(2, symbols.size()));\n      this.enumDefault = enumDefault;\n      int i = 0;\n      for (String symbol : symbols) {\n        if (ordinals.put(validateName(symbol), i++) != null) {\n          throw new SchemaParseException(\"Duplicate enum symbol: \" + symbol);\n        }\n      }\n      if (enumDefault != null && !symbols.contains(enumDefault)) {\n        throw new SchemaParseException(\n            \"The Enum Default: \" + enumDefault + \" is not in the enum symbol set: \" + symbols);\n      }\n    }\n\n    @Override\n    public List<String> getEnumSymbols() {\n      return symbols;\n    }\n\n    @Override\n    public boolean hasEnumSymbol(String symbol) {\n      return ordinals.containsKey(symbol);\n    }\n\n    @Override\n    public int getEnumOrdinal(String symbol) {\n      return ordinals.get(symbol);\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (o == this)\n        return true;\n      if (!(o instanceof EnumSchema))\n        return false;\n      EnumSchema that = (EnumSchema) o;\n      return equalCachedHash(that) && equalNames(that) && symbols.equals(that.symbols) && propsEqual(that);\n    }\n\n    @Override\n    public String getEnumDefault() {\n      return enumDefault;\n    }\n\n    @Override\n    int computeHash() {\n      return super.computeHash() + symbols.hashCode();\n    }\n\n    @Override\n    void toJson(Names names, JsonGenerator gen) throws IOException {\n      if (writeNameRef(names, gen))\n        return;\n      gen.writeStartObject();\n      gen.writeStringField(\"type\", \"enum\");\n      writeName(names, gen);\n      if (getDoc() != null)\n        gen.writeStringField(\"doc\", getDoc());\n      gen.writeArrayFieldStart(\"symbols\");\n      for (String symbol : symbols)\n        gen.writeString(symbol);\n      gen.writeEndArray();\n      if (getEnumDefault() != null)\n        gen.writeStringField(\"default\", getEnumDefault());\n      writeProps(gen);\n      aliasesToJson(gen);\n      gen.writeEndObject();\n    }\n  }\n\n  private static class ArraySchema extends Schema {\n    private final Schema elementType;\n\n    public ArraySchema(Schema elementType) {\n      super(Type.ARRAY);\n      this.elementType = elementType;\n    }\n\n    @Override\n    public Schema getElementType() {\n      return elementType;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (o == this)\n        return true;\n      if (!(o instanceof ArraySchema))\n        return false;\n      ArraySchema that = (ArraySchema) o;\n      return equalCachedHash(that) && elementType.equals(that.elementType) && propsEqual(that);\n    }\n\n    @Override\n    int computeHash() {\n      return super.computeHash() + elementType.computeHash();\n    }\n\n    @Override\n    void toJson(Names names, JsonGenerator gen) throws IOException {\n      gen.writeStartObject();\n      gen.writeStringField(\"type\", \"array\");\n      gen.writeFieldName(\"items\");\n      elementType.toJson(names, gen);\n      writeProps(gen);\n      gen.writeEndObject();\n    }\n  }\n\n  private static class MapSchema extends Schema {\n    private final Schema valueType;\n\n    public MapSchema(Schema valueType) {\n      super(Type.MAP);\n      this.valueType = valueType;\n    }\n\n    @Override\n    public Schema getValueType() {\n      return valueType;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (o == this)\n        return true;\n      if (!(o instanceof MapSchema))\n        return false;\n      MapSchema that = (MapSchema) o;\n      return equalCachedHash(that) && valueType.equals(that.valueType) && propsEqual(that);\n    }\n\n    @Override\n    int computeHash() {\n      return super.computeHash() + valueType.computeHash();\n    }\n\n    @Override\n    void toJson(Names names, JsonGenerator gen) throws IOException {\n      gen.writeStartObject();\n      gen.writeStringField(\"type\", \"map\");\n      gen.writeFieldName(\"values\");\n      valueType.toJson(names, gen);\n      writeProps(gen);\n      gen.writeEndObject();\n    }\n  }\n\n  private static class UnionSchema extends Schema {\n    private final List<Schema> types;\n    private final Map<String, Integer> indexByName;\n\n    public UnionSchema(LockableArrayList<Schema> types) {\n      super(Type.UNION);\n      this.indexByName = new HashMap<>(Math.multiplyExact(2, types.size()));\n      this.types = types.lock();\n      int index = 0;\n      for (Schema type : types) {\n        if (type.getType() == Type.UNION) {\n          throw new AvroRuntimeException(\"Nested union: \" + this);\n        }\n        String name = type.getFullName();\n        if (name == null) {\n          throw new AvroRuntimeException(\"Nameless in union:\" + this);\n        }\n        if (indexByName.put(name, index++) != null) {\n          throw new AvroRuntimeException(\"Duplicate in union:\" + name);\n        }\n      }\n    }\n\n    @Override\n    public List<Schema> getTypes() {\n      return types;\n    }\n\n    @Override\n    public Integer getIndexNamed(String name) {\n      return indexByName.get(name);\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (o == this)\n        return true;\n      if (!(o instanceof UnionSchema))\n        return false;\n      UnionSchema that = (UnionSchema) o;\n      return equalCachedHash(that) && types.equals(that.types) && propsEqual(that);\n    }\n\n    @Override\n    int computeHash() {\n      int hash = super.computeHash();\n      for (Schema type : types)\n        hash += type.computeHash();\n      return hash;\n    }\n\n    @Override\n    public void addProp(String name, String value) {\n      throw new AvroRuntimeException(\"Can't set properties on a union: \" + this);\n    }\n\n    @Override\n    void toJson(Names names, JsonGenerator gen) throws IOException {\n      gen.writeStartArray();\n      for (Schema type : types)\n        type.toJson(names, gen);\n      gen.writeEndArray();\n    }\n\n    @Override\n    public String getName() {\n      return super.getName()\n          + this.getTypes().stream().map(Schema::getName).collect(Collectors.joining(\", \", \"[\", \"]\"));\n    }\n  }\n\n  private static class FixedSchema extends NamedSchema {\n    private final int size;\n\n    public FixedSchema(Name name, String doc, int size) {\n      super(Type.FIXED, name, doc);\n      if (size < 0)\n        throw new IllegalArgumentException(\"Invalid fixed size: \" + size);\n      this.size = size;\n    }\n\n    @Override\n    public int getFixedSize() {\n      return size;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (o == this)\n        return true;\n      if (!(o instanceof FixedSchema))\n        return false;\n      FixedSchema that = (FixedSchema) o;\n      return equalCachedHash(that) && equalNames(that) && size == that.size && propsEqual(that);\n    }\n\n    @Override\n    int computeHash() {\n      return super.computeHash() + size;\n    }\n\n    @Override\n    void toJson(Names names, JsonGenerator gen) throws IOException {\n      if (writeNameRef(names, gen))\n        return;\n      gen.writeStartObject();\n      gen.writeStringField(\"type\", \"fixed\");\n      writeName(names, gen);\n      if (getDoc() != null)\n        gen.writeStringField(\"doc\", getDoc());\n      gen.writeNumberField(\"size\", size);\n      writeProps(gen);\n      aliasesToJson(gen);\n      gen.writeEndObject();\n    }\n  }\n\n  private static class StringSchema extends Schema {\n    public StringSchema() {\n      super(Type.STRING);\n    }\n  }\n\n  private static class BytesSchema extends Schema {\n    public BytesSchema() {\n      super(Type.BYTES);\n    }\n  }\n\n  private static class IntSchema extends Schema {\n    public IntSchema() {\n      super(Type.INT);\n    }\n  }\n\n  private static class LongSchema extends Schema {\n    public LongSchema() {\n      super(Type.LONG);\n    }\n  }\n\n  private static class FloatSchema extends Schema {\n    public FloatSchema() {\n      super(Type.FLOAT);\n    }\n  }\n\n  private static class DoubleSchema extends Schema {\n    public DoubleSchema() {\n      super(Type.DOUBLE);\n    }\n  }\n\n  private static class BooleanSchema extends Schema {\n    public BooleanSchema() {\n      super(Type.BOOLEAN);\n    }\n  }\n\n  private static class NullSchema extends Schema {\n    public NullSchema() {\n      super(Type.NULL);\n    }\n  }\n\n  /**\n   * A parser for JSON-format schemas. Each named schema parsed with a parser is\n   * added to the names known to the parser so that subsequently parsed schemas\n   * may refer to it by name.\n   */\n  public static class Parser {\n    private Names names = new Names();\n    private boolean validate = true;\n    private boolean validateDefaults = true;\n\n    /**\n     * Adds the provided types to the set of defined, named types known to this\n     * parser. deprecated: use addTypes(Iterable<Schema> types)\n     */\n    @Deprecated\n    public Parser addTypes(Map<String, Schema> types) {\n      return this.addTypes(types.values());\n    }\n\n    /**\n     * Adds the provided types to the set of defined, named types known to this\n     * parser.\n     */\n    public Parser addTypes(Iterable<Schema> types) {\n      for (Schema s : types)\n        names.add(s);\n      return this;\n    }\n\n    /** Returns the set of defined, named types known to this parser. */\n    public Map<String, Schema> getTypes() {\n      Map<String, Schema> result = new LinkedHashMap<>();\n      for (Schema s : names.values())\n        result.put(s.getFullName(), s);\n      return result;\n    }\n\n    /** Enable or disable name validation. */\n    public Parser setValidate(boolean validate) {\n      this.validate = validate;\n      return this;\n    }\n\n    /** True iff names are validated. True by default. */\n    public boolean getValidate() {\n      return this.validate;\n    }\n\n    /** Enable or disable default value validation. */\n    public Parser setValidateDefaults(boolean validateDefaults) {\n      this.validateDefaults = validateDefaults;\n      return this;\n    }\n\n    /** True iff default values are validated. False by default. */\n    public boolean getValidateDefaults() {\n      return this.validateDefaults;\n    }\n\n    /**\n     * Parse a schema from the provided file. If named, the schema is added to the\n     * names known to this parser.\n     */\n    public Schema parse(File file) throws IOException {\n      return parse(FACTORY.createParser(file), false);\n    }\n\n    /**\n     * Parse a schema from the provided stream. If named, the schema is added to the\n     * names known to this parser. The input stream stays open after the parsing.\n     */\n    public Schema parse(InputStream in) throws IOException {\n      return parse(FACTORY.createParser(in).disable(JsonParser.Feature.AUTO_CLOSE_SOURCE), true);\n    }\n\n    /** Read a schema from one or more json strings */\n    public Schema parse(String s, String... more) {\n      StringBuilder b = new StringBuilder(s);\n      for (String part : more)\n        b.append(part);\n      return parse(b.toString());\n    }\n\n    /**\n     * Parse a schema from the provided string. If named, the schema is added to the\n     * names known to this parser.\n     */\n    public Schema parse(String s) {\n      try {\n        return parse(FACTORY.createParser(s), false);\n      } catch (IOException e) {\n        throw new SchemaParseException(e);\n      }\n    }\n\n    private Schema parse(JsonParser parser, boolean allowDanglingContent) throws IOException {\n      boolean saved = validateNames.get();\n      boolean savedValidateDefaults = VALIDATE_DEFAULTS.get();\n      try {\n        validateNames.set(validate);\n        VALIDATE_DEFAULTS.set(validateDefaults);\n        JsonNode jsonNode = MAPPER.readTree(parser);\n        Schema schema = Schema.parse(jsonNode, names);\n        if (!allowDanglingContent) {\n          String dangling;\n          StringWriter danglingWriter = new StringWriter();\n          int numCharsReleased = parser.releaseBuffered(danglingWriter);\n          if (numCharsReleased == -1) {\n            ByteArrayOutputStream danglingOutputStream = new ByteArrayOutputStream();\n            parser.releaseBuffered(danglingOutputStream); // if input isnt chars above it must be bytes\n            dangling = new String(danglingOutputStream.toByteArray(), StandardCharsets.UTF_8).trim();\n          } else {\n            dangling = danglingWriter.toString().trim();\n          }\n          if (!dangling.isEmpty()) {\n            throw new SchemaParseException(\"dangling content after end of schema: \" + dangling);\n          }\n        }\n        return schema;\n      } catch (JsonParseException e) {\n        throw new SchemaParseException(e);\n      } finally {\n        parser.close();\n        validateNames.set(saved);\n        VALIDATE_DEFAULTS.set(savedValidateDefaults);\n      }\n    }\n  }\n\n  /**\n   * Constructs a Schema object from JSON schema file <tt>file<\/tt>. The contents\n   * of <tt>file<\/tt> is expected to be in UTF-8 format.\n   *\n   * @param file The file to read the schema from.\n   * @return The freshly built Schema.\n   * @throws IOException if there was trouble reading the contents or they are\n   *                     invalid\n   * @deprecated use {@link Schema.Parser} instead.\n   */\n  @Deprecated\n  public static Schema parse(File file) throws IOException {\n    return new Parser().parse(file);\n  }\n\n  /**\n   * Constructs a Schema object from JSON schema stream <tt>in<\/tt>. The contents\n   * of <tt>in<\/tt> is expected to be in UTF-8 format.\n   *\n   * @param in The input stream to read the schema from.\n   * @return The freshly built Schema.\n   * @throws IOException if there was trouble reading the contents or they are\n   *                     invalid\n   * @deprecated use {@link Schema.Parser} instead.\n   */\n  @Deprecated\n  public static Schema parse(InputStream in) throws IOException {\n    return new Parser().parse(in);\n  }\n\n  /**\n   * Construct a schema from <a href=\"https://json.org/\">JSON<\/a> text.\n   *\n   * @deprecated use {@link Schema.Parser} instead.\n   */\n  @Deprecated\n  public static Schema parse(String jsonSchema) {\n    return new Parser().parse(jsonSchema);\n  }\n\n  /**\n   * Construct a schema from <a href=\"https://json.org/\">JSON<\/a> text.\n   *\n   * @param validate true if names should be validated, false if not.\n   * @deprecated use {@link Schema.Parser} instead.\n   */\n  @Deprecated\n  public static Schema parse(String jsonSchema, boolean validate) {\n    return new Parser().setValidate(validate).parse(jsonSchema);\n  }\n\n  static final Map<String, Type> PRIMITIVES = new HashMap<>();\n  static {\n    PRIMITIVES.put(\"string\", Type.STRING);\n    PRIMITIVES.put(\"bytes\", Type.BYTES);\n    PRIMITIVES.put(\"int\", Type.INT);\n    PRIMITIVES.put(\"long\", Type.LONG);\n    PRIMITIVES.put(\"float\", Type.FLOAT);\n    PRIMITIVES.put(\"double\", Type.DOUBLE);\n    PRIMITIVES.put(\"boolean\", Type.BOOLEAN);\n    PRIMITIVES.put(\"null\", Type.NULL);\n  }\n\n  static class Names extends LinkedHashMap<Name, Schema> {\n    private static final long serialVersionUID = 1L;\n    private String space; // default namespace\n\n    public Names() {\n    }\n\n    public Names(String space) {\n      this.space = space;\n    }\n\n    public String space() {\n      return space;\n    }\n\n    public void space(String space) {\n      this.space = space;\n    }\n\n    public Schema get(String o) {\n      Type primitive = PRIMITIVES.get(o);\n      if (primitive != null) {\n        return Schema.create(primitive);\n      }\n      Name name = new Name(o, space);\n      if (!containsKey(name)) {\n        // if not in default try anonymous\n        name = new Name(o, \"\");\n      }\n      return super.get(name);\n    }\n\n    public boolean contains(Schema schema) {\n      return get(((NamedSchema) schema).name) != null;\n    }\n\n    public void add(Schema schema) {\n      put(((NamedSchema) schema).name, schema);\n    }\n\n    @Override\n    public Schema put(Name name, Schema schema) {\n      if (containsKey(name))\n        throw new SchemaParseException(\"Can't redefine: \" + name);\n      return super.put(name, schema);\n    }\n  }\n\n  private static ThreadLocal<Boolean> validateNames = ThreadLocalWithInitial.of(() -> true);\n\n  private static String validateName(String name) {\n    if (!validateNames.get())\n      return name; // not validating names\n    if (name == null)\n      throw new SchemaParseException(\"Null name\");\n    int length = name.length();\n    if (length == 0)\n      throw new SchemaParseException(\"Empty name\");\n    char first = name.charAt(0);\n    if (!(Character.isLetter(first) || first == '_'))\n      throw new SchemaParseException(\"Illegal initial character: \" + name);\n    for (int i = 1; i < length; i++) {\n      char c = name.charAt(i);\n      if (!(Character.isLetterOrDigit(c) || c == '_'))\n        throw new SchemaParseException(\"Illegal character in: \" + name);\n    }\n    return name;\n  }\n\n  private static final ThreadLocal<Boolean> VALIDATE_DEFAULTS = ThreadLocalWithInitial.of(() -> true);\n\n  private static JsonNode validateDefault(String fieldName, Schema schema, JsonNode defaultValue) {\n    if (VALIDATE_DEFAULTS.get() && (defaultValue != null) && !isValidDefault(schema, defaultValue)) { // invalid default\n      String message = \"Invalid default for field \" + fieldName + \": \" + defaultValue + \" not a \" + schema;\n      throw new AvroTypeException(message); // throw exception\n    }\n    return defaultValue;\n  }\n\n  private static boolean isValidDefault(Schema schema, JsonNode defaultValue) {\n    if (defaultValue == null)\n      return false;\n    switch (schema.getType()) {\n    case STRING:\n    case BYTES:\n    case ENUM:\n    case FIXED:\n      return defaultValue.isTextual();\n    case INT:\n      return defaultValue.isIntegralNumber() && defaultValue.canConvertToInt();\n    case LONG:\n      return defaultValue.isIntegralNumber() && defaultValue.canConvertToLong();\n    case FLOAT:\n    case DOUBLE:\n      return defaultValue.isNumber();\n    case BOOLEAN:\n      return defaultValue.isBoolean();\n    case NULL:\n      return defaultValue.isNull();\n    case ARRAY:\n      if (!defaultValue.isArray())\n        return false;\n      for (JsonNode element : defaultValue)\n        if (!isValidDefault(schema.getElementType(), element))\n          return false;\n      return true;\n    case MAP:\n      if (!defaultValue.isObject())\n        return false;\n      for (JsonNode value : defaultValue)\n        if (!isValidDefault(schema.getValueType(), value))\n          return false;\n      return true;\n    case UNION: // union default: first branch\n      return isValidDefault(schema.getTypes().get(0), defaultValue);\n    case RECORD:\n      if (!defaultValue.isObject())\n        return false;\n      for (Field field : schema.getFields())\n        if (!isValidValue(field.schema(),\n            defaultValue.has(field.name()) ? defaultValue.get(field.name()) : field.defaultValue()))\n          return false;\n      return true;\n    default:\n      return false;\n    }\n  }\n\n  /**\n   * Validate a value against the schema.\n   * \n   * @param schema : schema for value.\n   * @param value  : value to validate.\n   * @return true if ok.\n   */\n  private static boolean isValidValue(Schema schema, JsonNode value) {\n    if (value == null)\n      return false;\n    if (schema.isUnion()) {\n      // For Union, only need that one sub schema is ok.\n      for (Schema sub : schema.getTypes()) {\n        if (Schema.isValidDefault(sub, value)) {\n          return true;\n        }\n      }\n      return false;\n    } else {\n      // for other types, same as validate default.\n      return Schema.isValidDefault(schema, value);\n    }\n  }\n\n  /** @see #parse(String) */\n  static Schema parse(JsonNode schema, Names names) {\n    if (schema == null) {\n      throw new SchemaParseException(\"Cannot parse <null> schema\");\n    }\n    if (schema.isTextual()) { // name\n      Schema result = names.get(schema.textValue());\n      if (result == null)\n        throw new SchemaParseException(\"Undefined name: \" + schema);\n      return result;\n    } else if (schema.isObject()) {\n      Schema result;\n      String type = getRequiredText(schema, \"type\", \"No type\");\n      Name name = null;\n      String savedSpace = names.space();\n      String doc = null;\n      final boolean isTypeError = \"error\".equals(type);\n      final boolean isTypeRecord = \"record\".equals(type);\n      final boolean isTypeEnum = \"enum\".equals(type);\n      final boolean isTypeFixed = \"fixed\".equals(type);\n      if (isTypeRecord || isTypeError || isTypeEnum || isTypeFixed) {\n        String space = getOptionalText(schema, \"namespace\");\n        doc = getOptionalText(schema, \"doc\");\n        if (space == null)\n          space = savedSpace;\n        name = new Name(getRequiredText(schema, \"name\", \"No name in schema\"), space);\n        names.space(name.space); // set default namespace\n      }\n      if (PRIMITIVES.containsKey(type)) { // primitive\n        result = create(PRIMITIVES.get(type));\n      } else if (isTypeRecord || isTypeError) { // record\n        List<Field> fields = new ArrayList<>();\n        result = new RecordSchema(name, doc, isTypeError);\n        if (name != null)\n          names.add(result);\n        JsonNode fieldsNode = schema.get(\"fields\");\n        if (fieldsNode == null || !fieldsNode.isArray())\n          throw new SchemaParseException(\"Record has no fields: \" + schema);\n        for (JsonNode field : fieldsNode) {\n          String fieldName = getRequiredText(field, \"name\", \"No field name\");\n          String fieldDoc = getOptionalText(field, \"doc\");\n          JsonNode fieldTypeNode = field.get(\"type\");\n          if (fieldTypeNode == null)\n            throw new SchemaParseException(\"No field type: \" + field);\n          if (fieldTypeNode.isTextual() && names.get(fieldTypeNode.textValue()) == null)\n            throw new SchemaParseException(fieldTypeNode + \" is not a defined name.\" + \" The type of the \\\"\" + fieldName\n                + \"\\\" field must be a defined name or a {\\\"type\\\": ...} expression.\");\n          Schema fieldSchema = parse(fieldTypeNode, names);\n          Field.Order order = Field.Order.ASCENDING;\n          JsonNode orderNode = field.get(\"order\");\n          if (orderNode != null)\n            order = Field.Order.valueOf(orderNode.textValue().toUpperCase(Locale.ENGLISH));\n          JsonNode defaultValue = field.get(\"default\");\n          if (defaultValue != null\n              && (Type.FLOAT.equals(fieldSchema.getType()) || Type.DOUBLE.equals(fieldSchema.getType()))\n              && defaultValue.isTextual())\n            defaultValue = new DoubleNode(Double.valueOf(defaultValue.textValue()));\n          Field f = new Field(fieldName, fieldSchema, fieldDoc, defaultValue, true, order);\n          Iterator<String> i = field.fieldNames();\n          while (i.hasNext()) { // add field props\n            String prop = i.next();\n            if (!FIELD_RESERVED.contains(prop))\n              f.addProp(prop, field.get(prop));\n          }\n          f.aliases = parseAliases(field);\n          fields.add(f);\n          if (fieldSchema.getLogicalType() == null && getOptionalText(field, LOGICAL_TYPE_PROP) != null)\n            LOG.warn(\n                \"Ignored the {}.{}.logicalType property (\\\"{}\\\"). It should probably be nested inside the \\\"type\\\" for the field.\",\n                name, fieldName, getOptionalText(field, \"logicalType\"));\n        }\n        result.setFields(fields);\n      } else if (isTypeEnum) { // enum\n        JsonNode symbolsNode = schema.get(\"symbols\");\n        if (symbolsNode == null || !symbolsNode.isArray())\n          throw new SchemaParseException(\"Enum has no symbols: \" + schema);\n        LockableArrayList<String> symbols = new LockableArrayList<>(symbolsNode.size());\n        for (JsonNode n : symbolsNode)\n          symbols.add(n.textValue());\n        JsonNode enumDefault = schema.get(\"default\");\n        String defaultSymbol = null;\n        if (enumDefault != null)\n          defaultSymbol = enumDefault.textValue();\n        result = new EnumSchema(name, doc, symbols, defaultSymbol);\n        if (name != null)\n          names.add(result);\n      } else if (type.equals(\"array\")) { // array\n        JsonNode itemsNode = schema.get(\"items\");\n        if (itemsNode == null)\n          throw new SchemaParseException(\"Array has no items type: \" + schema);\n        result = new ArraySchema(parse(itemsNode, names));\n      } else if (type.equals(\"map\")) { // map\n        JsonNode valuesNode = schema.get(\"values\");\n        if (valuesNode == null)\n          throw new SchemaParseException(\"Map has no values type: \" + schema);\n        result = new MapSchema(parse(valuesNode, names));\n      } else if (isTypeFixed) { // fixed\n        JsonNode sizeNode = schema.get(\"size\");\n        if (sizeNode == null || !sizeNode.isInt())\n          throw new SchemaParseException(\"Invalid or no size: \" + schema);\n        result = new FixedSchema(name, doc, sizeNode.intValue());\n        if (name != null)\n          names.add(result);\n      } else { // For unions with self reference\n        Name nameFromType = new Name(type, names.space);\n        if (names.containsKey(nameFromType)) {\n          return names.get(nameFromType);\n        }\n        throw new SchemaParseException(\"Type not supported: \" + type);\n      }\n      Iterator<String> i = schema.fieldNames();\n\n      Set reserved = SCHEMA_RESERVED;\n      if (isTypeEnum) {\n        reserved = ENUM_RESERVED;\n      }\n      while (i.hasNext()) { // add properties\n        String prop = i.next();\n        if (!reserved.contains(prop)) // ignore reserved\n          result.addProp(prop, schema.get(prop));\n      }\n      // parse logical type if present\n      result.logicalType = LogicalTypes.fromSchemaIgnoreInvalid(result);\n      names.space(savedSpace); // restore space\n      if (result instanceof NamedSchema) {\n        Set<String> aliases = parseAliases(schema);\n        if (aliases != null) // add aliases\n          for (String alias : aliases)\n            result.addAlias(alias);\n      }\n      return result;\n    } else if (schema.isArray()) { // union\n      LockableArrayList<Schema> types = new LockableArrayList<>(schema.size());\n      for (JsonNode typeNode : schema)\n        types.add(parse(typeNode, names));\n      return new UnionSchema(types);\n    } else {\n      throw new SchemaParseException(\"Schema not yet supported: \" + schema);\n    }\n  }\n\n  static Set<String> parseAliases(JsonNode node) {\n    JsonNode aliasesNode = node.get(\"aliases\");\n    if (aliasesNode == null)\n      return null;\n    if (!aliasesNode.isArray())\n      throw new SchemaParseException(\"aliases not an array: \" + node);\n    Set<String> aliases = new LinkedHashSet<>();\n    for (JsonNode aliasNode : aliasesNode) {\n      if (!aliasNode.isTextual())\n        throw new SchemaParseException(\"alias not a string: \" + aliasNode);\n      aliases.add(aliasNode.textValue());\n    }\n    return aliases;\n  }\n\n  /**\n   * Extracts text value associated to key from the container JsonNode, and throws\n   * {@link SchemaParseException} if it doesn't exist.\n   *\n   * @param container Container where to find key.\n   * @param key       Key to look for in container.\n   * @param error     String to prepend to the SchemaParseException.\n   */\n  private static String getRequiredText(JsonNode container, String key, String error) {\n    String out = getOptionalText(container, key);\n    if (null == out) {\n      throw new SchemaParseException(error + \": \" + container);\n    }\n    return out;\n  }\n\n  /** Extracts text value associated to key from the container JsonNode. */\n  private static String getOptionalText(JsonNode container, String key) {\n    JsonNode jsonNode = container.get(key);\n    return jsonNode != null ? jsonNode.textValue() : null;\n  }\n\n  static JsonNode parseJson(String s) {\n    try {\n      return MAPPER.readTree(FACTORY.createParser(s));\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /**\n   * Parses the specified json string to an object.\n   */\n  public static Object parseJsonToObject(String s) {\n    return JacksonUtils.toObject(parseJson(s));\n  }\n\n  /**\n   * Rewrite a writer's schema using the aliases from a reader's schema. This\n   * permits reading records, enums and fixed schemas whose names have changed,\n   * and records whose field names have changed. The returned schema always\n   * contains the same data elements in the same order, but with possibly\n   * different names.\n   */\n  public static Schema applyAliases(Schema writer, Schema reader) {\n    if (writer.equals(reader))\n      return writer; // same schema\n\n    // create indexes of names\n    Map<Schema, Schema> seen = new IdentityHashMap<>(1);\n    Map<Name, Name> aliases = new HashMap<>(1);\n    Map<Name, Map<String, String>> fieldAliases = new HashMap<>(1);\n    getAliases(reader, seen, aliases, fieldAliases);\n\n    if (aliases.size() == 0 && fieldAliases.size() == 0)\n      return writer; // no aliases\n\n    seen.clear();\n    return applyAliases(writer, seen, aliases, fieldAliases);\n  }\n\n  private static Schema applyAliases(Schema s, Map<Schema, Schema> seen, Map<Name, Name> aliases,\n      Map<Name, Map<String, String>> fieldAliases) {\n\n    Name name = s instanceof NamedSchema ? ((NamedSchema) s).name : null;\n    Schema result = s;\n    switch (s.getType()) {\n    case RECORD:\n      if (seen.containsKey(s))\n        return seen.get(s); // break loops\n      if (aliases.containsKey(name))\n        name = aliases.get(name);\n      result = Schema.createRecord(name.full, s.getDoc(), null, s.isError());\n      seen.put(s, result);\n      List<Field> newFields = new ArrayList<>();\n      for (Field f : s.getFields()) {\n        Schema fSchema = applyAliases(f.schema, seen, aliases, fieldAliases);\n        String fName = getFieldAlias(name, f.name, fieldAliases);\n        Field newF = new Field(fName, fSchema, f.doc, f.defaultValue, true, f.order);\n        newF.putAll(f); // copy props\n        newFields.add(newF);\n      }\n      result.setFields(newFields);\n      break;\n    case ENUM:\n      if (aliases.containsKey(name))\n        result = Schema.createEnum(aliases.get(name).full, s.getDoc(), null, s.getEnumSymbols(), s.getEnumDefault());\n      break;\n    case ARRAY:\n      Schema e = applyAliases(s.getElementType(), seen, aliases, fieldAliases);\n      if (!e.equals(s.getElementType()))\n        result = Schema.createArray(e);\n      break;\n    case MAP:\n      Schema v = applyAliases(s.getValueType(), seen, aliases, fieldAliases);\n      if (!v.equals(s.getValueType()))\n        result = Schema.createMap(v);\n      break;\n    case UNION:\n      List<Schema> types = new ArrayList<>();\n      for (Schema branch : s.getTypes())\n        types.add(applyAliases(branch, seen, aliases, fieldAliases));\n      result = Schema.createUnion(types);\n      break;\n    case FIXED:\n      if (aliases.containsKey(name))\n        result = Schema.createFixed(aliases.get(name).full, s.getDoc(), null, s.getFixedSize());\n      break;\n    default:\n      // NO-OP\n    }\n    if (!result.equals(s))\n      result.putAll(s); // copy props\n    return result;\n  }\n\n  private static void getAliases(Schema schema, Map<Schema, Schema> seen, Map<Name, Name> aliases,\n      Map<Name, Map<String, String>> fieldAliases) {\n    if (schema instanceof NamedSchema) {\n      NamedSchema namedSchema = (NamedSchema) schema;\n      if (namedSchema.aliases != null)\n        for (Name alias : namedSchema.aliases)\n          aliases.put(alias, namedSchema.name);\n    }\n    switch (schema.getType()) {\n    case RECORD:\n      if (seen.containsKey(schema))\n        return; // break loops\n      seen.put(schema, schema);\n      RecordSchema record = (RecordSchema) schema;\n      for (Field field : schema.getFields()) {\n        if (field.aliases != null)\n          for (String fieldAlias : field.aliases) {\n            Map<String, String> recordAliases = fieldAliases.computeIfAbsent(record.name, k -> new HashMap<>());\n            recordAliases.put(fieldAlias, field.name);\n          }\n        getAliases(field.schema, seen, aliases, fieldAliases);\n      }\n      if (record.aliases != null && fieldAliases.containsKey(record.name))\n        for (Name recordAlias : record.aliases)\n          fieldAliases.put(recordAlias, fieldAliases.get(record.name));\n      break;\n    case ARRAY:\n      getAliases(schema.getElementType(), seen, aliases, fieldAliases);\n      break;\n    case MAP:\n      getAliases(schema.getValueType(), seen, aliases, fieldAliases);\n      break;\n    case UNION:\n      for (Schema s : schema.getTypes())\n        getAliases(s, seen, aliases, fieldAliases);\n      break;\n    }\n  }\n\n  private static String getFieldAlias(Name record, String field, Map<Name, Map<String, String>> fieldAliases) {\n    Map<String, String> recordAliases = fieldAliases.get(record);\n    if (recordAliases == null)\n      return field;\n    String alias = recordAliases.get(field);\n    if (alias == null)\n      return field;\n    return alias;\n  }\n\n  /**\n   * No change is permitted on LockableArrayList once lock() has been called on\n   * it.\n   *\n   * @param <E>\n   */\n\n  /*\n   * This class keeps a boolean variable <tt>locked<\/tt> which is set to\n   * <tt>true<\/tt> in the lock() method. It's legal to call lock() any number of\n   * times. Any lock() other than the first one is a no-op.\n   *\n   * This class throws <tt>IllegalStateException<\/tt> if a mutating operation is\n   * performed after being locked. Since modifications through iterator also use\n   * the list's mutating operations, this effectively blocks all modifications.\n   */\n  static class LockableArrayList<E> extends ArrayList<E> {\n    private static final long serialVersionUID = 1L;\n    private boolean locked = false;\n\n    public LockableArrayList() {\n    }\n\n    public LockableArrayList(int size) {\n      super(size);\n    }\n\n    public LockableArrayList(List<E> types) {\n      super(types);\n    }\n\n    public LockableArrayList(E... types) {\n      super(types.length);\n      Collections.addAll(this, types);\n    }\n\n    public List<E> lock() {\n      locked = true;\n      return this;\n    }\n\n    private void ensureUnlocked() {\n      if (locked) {\n        throw new IllegalStateException();\n      }\n    }\n\n    @Override\n    public boolean add(E e) {\n      ensureUnlocked();\n      return super.add(e);\n    }\n\n    @Override\n    public boolean remove(Object o) {\n      ensureUnlocked();\n      return super.remove(o);\n    }\n\n    @Override\n    public E remove(int index) {\n      ensureUnlocked();\n      return super.remove(index);\n    }\n\n    @Override\n    public boolean addAll(Collection<? extends E> c) {\n      ensureUnlocked();\n      return super.addAll(c);\n    }\n\n    @Override\n    public boolean addAll(int index, Collection<? extends E> c) {\n      ensureUnlocked();\n      return super.addAll(index, c);\n    }\n\n    @Override\n    public boolean removeAll(Collection<?> c) {\n      ensureUnlocked();\n      return super.removeAll(c);\n    }\n\n    @Override\n    public boolean retainAll(Collection<?> c) {\n      ensureUnlocked();\n      return super.retainAll(c);\n    }\n\n    @Override\n    public void clear() {\n      ensureUnlocked();\n      super.clear();\n    }\n  }\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.avro;\n\nimport com.fasterxml.jackson.core.JsonFactory;\nimport com.fasterxml.jackson.core.JsonGenerator;\nimport com.fasterxml.jackson.core.JsonParseException;\nimport com.fasterxml.jackson.core.JsonParser;\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.node.DoubleNode;\nimport com.fasterxml.jackson.databind.node.NullNode;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.Serializable;\nimport java.io.StringWriter;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.IdentityHashMap;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport java.util.stream.StreamSupport;\n\nimport org.apache.avro.util.internal.Accessor;\nimport org.apache.avro.util.internal.Accessor.FieldAccessor;\nimport org.apache.avro.util.internal.JacksonUtils;\nimport org.apache.avro.util.internal.ThreadLocalWithInitial;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport static org.apache.avro.LogicalType.LOGICAL_TYPE_PROP;\n\n/**\n * An abstract data type.\n * <p>\n * A schema may be one of:\n * <ul>\n * <li>A <i>record<\/i>, mapping field names to field value data;\n * <li>An <i>enum<\/i>, containing one of a small set of symbols;\n * <li>An <i>array<\/i> of values, all of the same schema;\n * <li>A <i>map<\/i>, containing string/value pairs, of a declared schema;\n * <li>A <i>union<\/i> of other schemas;\n * <li>A <i>fixed<\/i> sized binary object;\n * <li>A unicode <i>string<\/i>;\n * <li>A sequence of <i>bytes<\/i>;\n * <li>A 32-bit signed <i>int<\/i>;\n * <li>A 64-bit signed <i>long<\/i>;\n * <li>A 32-bit IEEE single-<i>float<\/i>; or\n * <li>A 64-bit IEEE <i>double<\/i>-float; or\n * <li>A <i>boolean<\/i>; or\n * <li><i>null<\/i>.\n * <\/ul>\n *\n * A schema can be constructed using one of its static <tt>createXXX<\/tt>\n * methods, or more conveniently using {@link SchemaBuilder}. The schema objects\n * are <i>logically<\/i> immutable. There are only two mutating methods -\n * {@link #setFields(List)} and {@link #addProp(String, String)}. The following\n * restrictions apply on these two methods.\n * <ul>\n * <li>{@link #setFields(List)}, can be called at most once. This method exists\n * in order to enable clients to build recursive schemas.\n * <li>{@link #addProp(String, String)} can be called with property names that\n * are not present already. It is not possible to change or delete an existing\n * property.\n * <\/ul>\n */\npublic abstract class Schema extends JsonProperties implements Serializable {\n\n  private static final long serialVersionUID = 1L;\n\n  protected Object writeReplace() {\n    SerializableSchema ss = new SerializableSchema();\n    ss.schemaString = toString();\n    return ss;\n  }\n\n  private static final class SerializableSchema implements Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    private String schemaString;\n\n    private Object readResolve() {\n      return new Schema.Parser().parse(schemaString);\n    }\n  }\n\n  static final JsonFactory FACTORY = new JsonFactory();\n  static final Logger LOG = LoggerFactory.getLogger(Schema.class);\n  static final ObjectMapper MAPPER = new ObjectMapper(FACTORY);\n\n  private static final int NO_HASHCODE = Integer.MIN_VALUE;\n\n  static {\n    FACTORY.enable(JsonParser.Feature.ALLOW_COMMENTS);\n    FACTORY.setCodec(MAPPER);\n  }\n\n  /** The type of a schema. */\n  public enum Type {\n    RECORD, ENUM, ARRAY, MAP, UNION, FIXED, STRING, BYTES, INT, LONG, FLOAT, DOUBLE, BOOLEAN, NULL;\n\n    private final String name;\n\n    private Type() {\n      this.name = this.name().toLowerCase(Locale.ENGLISH);\n    }\n\n    public String getName() {\n      return name;\n    }\n  };\n\n  private final Type type;\n  private LogicalType logicalType = null;\n\n  Schema(Type type) {\n    super(type == Type.ENUM ? ENUM_RESERVED : SCHEMA_RESERVED);\n    this.type = type;\n  }\n\n  /** Create a schema for a primitive type. */\n  public static Schema create(Type type) {\n    switch (type) {\n    case STRING:\n      return new StringSchema();\n    case BYTES:\n      return new BytesSchema();\n    case INT:\n      return new IntSchema();\n    case LONG:\n      return new LongSchema();\n    case FLOAT:\n      return new FloatSchema();\n    case DOUBLE:\n      return new DoubleSchema();\n    case BOOLEAN:\n      return new BooleanSchema();\n    case NULL:\n      return new NullSchema();\n    default:\n      throw new AvroRuntimeException(\"Can't create a: \" + type);\n    }\n  }\n\n  private static final Set<String> SCHEMA_RESERVED = new HashSet<>(\n      Arrays.asList(\"doc\", \"fields\", \"items\", \"name\", \"namespace\", \"size\", \"symbols\", \"values\", \"type\", \"aliases\"));\n\n  private static final Set<String> ENUM_RESERVED = new HashSet<>(SCHEMA_RESERVED);\n  static {\n    ENUM_RESERVED.add(\"default\");\n  }\n\n  int hashCode = NO_HASHCODE;\n\n  @Override\n  public void addProp(String name, String value) {\n    super.addProp(name, value);\n    hashCode = NO_HASHCODE;\n  }\n\n  @Override\n  public void addProp(String name, Object value) {\n    super.addProp(name, value);\n    hashCode = NO_HASHCODE;\n  }\n\n  public LogicalType getLogicalType() {\n    return logicalType;\n  }\n\n  void setLogicalType(LogicalType logicalType) {\n    this.logicalType = logicalType;\n  }\n\n  /**\n   * Create an anonymous record schema.\n   *\n   * @deprecated This method allows to create Schema objects that cannot be parsed\n   *             by {@link Schema.Parser#parse(String)}. It will be removed in a\n   *             future version of Avro. Better use\n   *             i{@link #createRecord(String, String, String, boolean, List)} to\n   *             produce a fully qualified Schema.\n   */\n  @Deprecated\n  public static Schema createRecord(List<Field> fields) {\n    Schema result = createRecord(null, null, null, false);\n    result.setFields(fields);\n    return result;\n  }\n\n  /** Create a named record schema. */\n  public static Schema createRecord(String name, String doc, String namespace, boolean isError) {\n    return new RecordSchema(new Name(name, namespace), doc, isError);\n  }\n\n  /** Create a named record schema with fields already set. */\n  public static Schema createRecord(String name, String doc, String namespace, boolean isError, List<Field> fields) {\n    return new RecordSchema(new Name(name, namespace), doc, isError, fields);\n  }\n\n  /** Create an enum schema. */\n  public static Schema createEnum(String name, String doc, String namespace, List<String> values) {\n    return new EnumSchema(new Name(name, namespace), doc, new LockableArrayList<>(values), null);\n  }\n\n  /** Create an enum schema. */\n  public static Schema createEnum(String name, String doc, String namespace, List<String> values, String enumDefault) {\n    return new EnumSchema(new Name(name, namespace), doc, new LockableArrayList<>(values), enumDefault);\n  }\n\n  /** Create an array schema. */\n  public static Schema createArray(Schema elementType) {\n    return new ArraySchema(elementType);\n  }\n\n  /** Create a map schema. */\n  public static Schema createMap(Schema valueType) {\n    return new MapSchema(valueType);\n  }\n\n  /** Create a union schema. */\n  public static Schema createUnion(List<Schema> types) {\n    return new UnionSchema(new LockableArrayList<>(types));\n  }\n\n  /** Create a union schema. */\n  public static Schema createUnion(Schema... types) {\n    return createUnion(new LockableArrayList<>(types));\n  }\n\n  /** Create a fixed schema. */\n  public static Schema createFixed(String name, String doc, String space, int size) {\n    return new FixedSchema(new Name(name, space), doc, size);\n  }\n\n  /** Return the type of this schema. */\n  public Type getType() {\n    return type;\n  }\n\n  /**\n   * If this is a record, returns the Field with the given name\n   * <tt>fieldName<\/tt>. If there is no field by that name, a <tt>null<\/tt> is\n   * returned.\n   */\n  public Field getField(String fieldname) {\n    throw new AvroRuntimeException(\"Not a record: \" + this);\n  }\n\n  /**\n   * If this is a record, returns the fields in it. The returned list is in the\n   * order of their positions.\n   */\n  public List<Field> getFields() {\n    throw new AvroRuntimeException(\"Not a record: \" + this);\n  }\n\n  /**\n   * If this is a record, returns whether the fields have been set.\n   */\n  public boolean hasFields() {\n    throw new AvroRuntimeException(\"Not a record: \" + this);\n  }\n\n  /**\n   * If this is a record, set its fields. The fields can be set only once in a\n   * schema.\n   */\n  public void setFields(List<Field> fields) {\n    throw new AvroRuntimeException(\"Not a record: \" + this);\n  }\n\n  /** If this is an enum, return its symbols. */\n  public List<String> getEnumSymbols() {\n    throw new AvroRuntimeException(\"Not an enum: \" + this);\n  }\n\n  /** If this is an enum, return its default value. */\n  public String getEnumDefault() {\n    throw new AvroRuntimeException(\"Not an enum: \" + this);\n  }\n\n  /** If this is an enum, return a symbol's ordinal value. */\n  public int getEnumOrdinal(String symbol) {\n    throw new AvroRuntimeException(\"Not an enum: \" + this);\n  }\n\n  /** If this is an enum, returns true if it contains given symbol. */\n  public boolean hasEnumSymbol(String symbol) {\n    throw new AvroRuntimeException(\"Not an enum: \" + this);\n  }\n\n  /**\n   * If this is a record, enum or fixed, returns its name, otherwise the name of\n   * the primitive type.\n   */\n  public String getName() {\n    return type.name;\n  }\n\n  /**\n   * If this is a record, enum, or fixed, returns its docstring, if available.\n   * Otherwise, returns null.\n   */\n  public String getDoc() {\n    return null;\n  }\n\n  /** If this is a record, enum or fixed, returns its namespace, if any. */\n  public String getNamespace() {\n    throw new AvroRuntimeException(\"Not a named type: \" + this);\n  }\n\n  /**\n   * If this is a record, enum or fixed, returns its namespace-qualified name,\n   * otherwise returns the name of the primitive type.\n   */\n  public String getFullName() {\n    return getName();\n  }\n\n  /** If this is a record, enum or fixed, add an alias. */\n  public void addAlias(String alias) {\n    throw new AvroRuntimeException(\"Not a named type: \" + this);\n  }\n\n  /** If this is a record, enum or fixed, add an alias. */\n  public void addAlias(String alias, String space) {\n    throw new AvroRuntimeException(\"Not a named type: \" + this);\n  }\n\n  /** If this is a record, enum or fixed, return its aliases, if any. */\n  public Set<String> getAliases() {\n    throw new AvroRuntimeException(\"Not a named type: \" + this);\n  }\n\n  /** Returns true if this record is an error type. */\n  public boolean isError() {\n    throw new AvroRuntimeException(\"Not a record: \" + this);\n  }\n\n  /** If this is an array, returns its element type. */\n  public Schema getElementType() {\n    throw new AvroRuntimeException(\"Not an array: \" + this);\n  }\n\n  /** If this is a map, returns its value type. */\n  public Schema getValueType() {\n    throw new AvroRuntimeException(\"Not a map: \" + this);\n  }\n\n  /** If this is a union, returns its types. */\n  public List<Schema> getTypes() {\n    throw new AvroRuntimeException(\"Not a union: \" + this);\n  }\n\n  /** If this is a union, return the branch with the provided full name. */\n  public Integer getIndexNamed(String name) {\n    throw new AvroRuntimeException(\"Not a union: \" + this);\n  }\n\n  /** If this is fixed, returns its size. */\n  public int getFixedSize() {\n    throw new AvroRuntimeException(\"Not fixed: \" + this);\n  }\n\n  /** Render this as <a href=\"https://json.org/\">JSON<\/a>. */\n  @Override\n  public String toString() {\n    return toString(false);\n  }\n\n  /**\n   * Render this as <a href=\"https://json.org/\">JSON<\/a>.\n   *\n   * @param pretty if true, pretty-print JSON.\n   */\n  public String toString(boolean pretty) {\n    return toString(new Names(), pretty);\n  }\n\n  /**\n   * Render this as <a href=\"https://json.org/\">JSON<\/a>, but without inlining the\n   * referenced schemas.\n   *\n   * @param referencedSchemas referenced schemas\n   * @param pretty            if true, pretty-print JSON.\n   */\n  // Use at your own risk. This method should be removed with AVRO-2832.\n  @Deprecated\n  public String toString(Collection<Schema> referencedSchemas, boolean pretty) {\n    Schema.Names names = new Schema.Names();\n    if (referencedSchemas != null) {\n      for (Schema s : referencedSchemas) {\n        names.add(s);\n      }\n    }\n    return toString(names, pretty);\n  }\n\n  String toString(Names names, boolean pretty) {\n    try {\n      StringWriter writer = new StringWriter();\n      JsonGenerator gen = FACTORY.createGenerator(writer);\n      if (pretty)\n        gen.useDefaultPrettyPrinter();\n      toJson(names, gen);\n      gen.flush();\n      return writer.toString();\n    } catch (IOException e) {\n      throw new AvroRuntimeException(e);\n    }\n  }\n\n  void toJson(Names names, JsonGenerator gen) throws IOException {\n    if (!hasProps()) { // no props defined\n      gen.writeString(getName()); // just write name\n    } else {\n      gen.writeStartObject();\n      gen.writeStringField(\"type\", getName());\n      writeProps(gen);\n      gen.writeEndObject();\n    }\n  }\n\n  void fieldsToJson(Names names, JsonGenerator gen) throws IOException {\n    throw new AvroRuntimeException(\"Not a record: \" + this);\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (o == this)\n      return true;\n    if (!(o instanceof Schema))\n      return false;\n    Schema that = (Schema) o;\n    if (!(this.type == that.type))\n      return false;\n    return equalCachedHash(that) && propsEqual(that);\n  }\n\n  @Override\n  public final int hashCode() {\n    if (hashCode == NO_HASHCODE)\n      hashCode = computeHash();\n    return hashCode;\n  }\n\n  int computeHash() {\n    return getType().hashCode() + propsHashCode();\n  }\n\n  final boolean equalCachedHash(Schema other) {\n    return (hashCode == other.hashCode) || (hashCode == NO_HASHCODE) || (other.hashCode == NO_HASHCODE);\n  }\n\n  private static final Set<String> FIELD_RESERVED = Collections\n      .unmodifiableSet(new HashSet<>(Arrays.asList(\"default\", \"doc\", \"name\", \"order\", \"type\", \"aliases\")));\n\n  /** Returns true if this record is an union type. */\n  public boolean isUnion() {\n    return this instanceof UnionSchema;\n  }\n\n  /** Returns true if this record is an union type containing null. */\n  public boolean isNullable() {\n    if (!isUnion()) {\n      return getType().equals(Schema.Type.NULL);\n    }\n\n    for (Schema schema : getTypes()) {\n      if (schema.isNullable()) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /** A field within a record. */\n  public static class Field extends JsonProperties {\n\n    static {\n      Accessor.setAccessor(new FieldAccessor() {\n        @Override\n        protected JsonNode defaultValue(Field field) {\n          return field.defaultValue();\n        }\n\n        @Override\n        protected Field createField(String name, Schema schema, String doc, JsonNode defaultValue) {\n          return new Field(name, schema, doc, defaultValue, true, Order.ASCENDING);\n        }\n\n        @Override\n        protected Field createField(String name, Schema schema, String doc, JsonNode defaultValue, boolean validate,\n            Order order) {\n          return new Field(name, schema, doc, defaultValue, validate, order);\n        }\n      });\n    }\n\n    /** How values of this field should be ordered when sorting records. */\n    public enum Order {\n      ASCENDING, DESCENDING, IGNORE;\n\n      private final String name;\n\n      Order() {\n        this.name = this.name().toLowerCase(Locale.ENGLISH);\n      }\n    }\n\n    /**\n     * For Schema unions with a \"null\" type as the first entry, this can be used to\n     * specify that the default for the union is null.\n     */\n    public static final Object NULL_DEFAULT_VALUE = new Object();\n\n    private final String name; // name of the field.\n    private int position = -1;\n    private final Schema schema;\n    private final String doc;\n    private final JsonNode defaultValue;\n    private final Order order;\n    private Set<String> aliases;\n\n    Field(String name, Schema schema, String doc, JsonNode defaultValue, boolean validateDefault, Order order) {\n      super(FIELD_RESERVED);\n      this.name = validateName(name);\n      this.schema = Objects.requireNonNull(schema, \"schema is required and cannot be null\");\n      this.doc = doc;\n      this.defaultValue = validateDefault ? validateDefault(name, schema, defaultValue) : defaultValue;\n      this.order = Objects.requireNonNull(order, \"Order cannot be null\");\n    }\n\n    /**\n     * Constructs a new Field instance with the same {@code name}, {@code doc},\n     * {@code defaultValue}, and {@code order} as {@code field} has with changing\n     * the schema to the specified one. It also copies all the {@code props} and\n     * {@code aliases}.\n     */\n    public Field(Field field, Schema schema) {\n      this(field.name, schema, field.doc, field.defaultValue, true, field.order);\n      putAll(field);\n      if (field.aliases != null)\n        aliases = new LinkedHashSet<>(field.aliases);\n    }\n\n    /**\n     *\n     */\n    public Field(String name, Schema schema) {\n      this(name, schema, (String) null, (JsonNode) null, true, Order.ASCENDING);\n    }\n\n    /**\n     *\n     */\n    public Field(String name, Schema schema, String doc) {\n      this(name, schema, doc, (JsonNode) null, true, Order.ASCENDING);\n    }\n\n    /**\n     * @param defaultValue the default value for this field specified using the\n     *                     mapping in {@link JsonProperties}\n     */\n    public Field(String name, Schema schema, String doc, Object defaultValue) {\n      this(name, schema, doc,\n          defaultValue == NULL_DEFAULT_VALUE ? NullNode.getInstance() : JacksonUtils.toJsonNode(defaultValue), true,\n          Order.ASCENDING);\n    }\n\n    /**\n     * @param defaultValue the default value for this field specified using the\n     *                     mapping in {@link JsonProperties}\n     */\n    public Field(String name, Schema schema, String doc, Object defaultValue, Order order) {\n      this(name, schema, doc,\n          defaultValue == NULL_DEFAULT_VALUE ? NullNode.getInstance() : JacksonUtils.toJsonNode(defaultValue), true,\n          Objects.requireNonNull(order));\n    }\n\n    public String name() {\n      return name;\n    };\n\n    /** The position of this field within the record. */\n    public int pos() {\n      return position;\n    }\n\n    /** This field's {@link Schema}. */\n    public Schema schema() {\n      return schema;\n    }\n\n    /** Field's documentation within the record, if set. May return null. */\n    public String doc() {\n      return doc;\n    }\n\n    /**\n     * @return true if this Field has a default value set. Can be used to determine\n     *         if a \"null\" return from defaultVal() is due to that being the default\n     *         value or just not set.\n     */\n    public boolean hasDefaultValue() {\n      return defaultValue != null;\n    }\n\n    JsonNode defaultValue() {\n      return defaultValue;\n    }\n\n    /**\n     * @return the default value for this field specified using the mapping in\n     *         {@link JsonProperties}\n     */\n    public Object defaultVal() {\n      return JacksonUtils.toObject(defaultValue, schema);\n    }\n\n    public Order order() {\n      return order;\n    }\n\n    public void addAlias(String alias) {\n      if (aliases == null)\n        this.aliases = new LinkedHashSet<>();\n      aliases.add(alias);\n    }\n\n    /** Return the defined aliases as an unmodifiable Set. */\n    public Set<String> aliases() {\n      if (aliases == null)\n        return Collections.emptySet();\n      return Collections.unmodifiableSet(aliases);\n    }\n\n    @Override\n    public boolean equals(Object other) {\n      if (other == this)\n        return true;\n      if (!(other instanceof Field))\n        return false;\n      Field that = (Field) other;\n      return (name.equals(that.name)) && (schema.equals(that.schema)) && defaultValueEquals(that.defaultValue)\n          && (order == that.order) && propsEqual(that);\n    }\n\n    @Override\n    public int hashCode() {\n      return name.hashCode() + schema.computeHash();\n    }\n\n    private boolean defaultValueEquals(JsonNode thatDefaultValue) {\n      if (defaultValue == null)\n        return thatDefaultValue == null;\n      if (thatDefaultValue == null)\n        return false;\n      if (Double.isNaN(defaultValue.doubleValue()))\n        return Double.isNaN(thatDefaultValue.doubleValue());\n      return defaultValue.equals(thatDefaultValue);\n    }\n\n    @Override\n    public String toString() {\n      return name + \" type:\" + schema.type + \" pos:\" + position;\n    }\n\n    /**\n     * Parse field.\n     *\n     * @param field     : json field definition.\n     * @param names     : names map.\n     * @param namespace : current working namespace.\n     * @return field.\n     */\n    static Field parse(JsonNode field, Names names, String namespace) {\n      String fieldName = getRequiredText(field, \"name\", \"No field name\");\n      String fieldDoc = getOptionalText(field, \"doc\");\n      JsonNode fieldTypeNode = field.get(\"type\");\n      if (fieldTypeNode == null) {\n        throw new SchemaParseException(\"No field type: \" + field);\n      }\n\n      Schema fieldSchema = null;\n      if (fieldTypeNode.isTextual()) {\n        Schema schemaField = names.get(fieldTypeNode.textValue());\n        if (schemaField == null) {\n          schemaField = names.get(namespace + \".\" + fieldTypeNode.textValue());\n        }\n        if (schemaField == null) {\n          throw new SchemaParseException(fieldTypeNode + \" is not a defined name.\" + \" The type of the \\\"\" + fieldName\n              + \"\\\" field must be a defined name or a {\\\"type\\\": ...} expression.\");\n        }\n        fieldSchema = schemaField;\n      } else if (fieldTypeNode.isObject()) {\n        fieldSchema = resolveSchema(fieldTypeNode, names, namespace);\n        if (fieldSchema == null) {\n          fieldSchema = Schema.parseCompleteSchema(fieldTypeNode, names, namespace);\n        }\n      } else if (fieldTypeNode.isArray()) {\n        List<Schema> unionTypes = new ArrayList<>();\n\n        fieldTypeNode.forEach((JsonNode node) -> {\n          Schema subSchema = null;\n          if (node.isTextual()) {\n            subSchema = names.get(node.asText());\n            if (subSchema == null) {\n              subSchema = names.get(namespace + \".\" + node.asText());\n            }\n          } else if (node.isObject()) {\n            subSchema = Schema.parseCompleteSchema(node, names, namespace);\n          } else {\n            throw new SchemaParseException(\"Illegal type in union : \" + node);\n          }\n          if (subSchema == null) {\n            throw new SchemaParseException(\"Null element in union : \" + node);\n          }\n          unionTypes.add(subSchema);\n        });\n\n        fieldSchema = Schema.createUnion(unionTypes);\n      }\n\n      if (fieldSchema == null) {\n        throw new SchemaParseException(\"Can't find type for field \" + fieldName);\n      }\n      Field.Order order = Field.Order.ASCENDING;\n      JsonNode orderNode = field.get(\"order\");\n      if (orderNode != null)\n        order = Field.Order.valueOf(orderNode.textValue().toUpperCase(Locale.ENGLISH));\n      JsonNode defaultValue = field.get(\"default\");\n\n      if (defaultValue != null\n          && (Type.FLOAT.equals(fieldSchema.getType()) || Type.DOUBLE.equals(fieldSchema.getType()))\n          && defaultValue.isTextual()) {\n        try {\n          defaultValue = new DoubleNode(Double.valueOf(defaultValue.textValue()));\n        } catch (NumberFormatException ex) {\n          throw new SchemaParseException(\n              \"Can't parse number '\" + defaultValue.textValue() + \"' for field '\" + fieldName);\n        }\n      }\n\n      Field f = new Field(fieldName, fieldSchema, fieldDoc, defaultValue, true, order);\n      Iterator<String> i = field.fieldNames();\n      while (i.hasNext()) { // add field props\n        String prop = i.next();\n        if (!FIELD_RESERVED.contains(prop))\n          f.addProp(prop, field.get(prop));\n      }\n      f.aliases = parseAliases(field);\n\n      return f;\n    }\n\n  }\n\n  static class Name {\n    private final String name;\n    private final String space;\n    private final String full;\n\n    public Name(String name, String space) {\n      if (name == null) { // anonymous\n        this.name = this.space = this.full = null;\n        return;\n      }\n      int lastDot = name.lastIndexOf('.');\n      if (lastDot < 0) { // unqualified name\n        this.name = validateName(name);\n      } else { // qualified name\n        space = name.substring(0, lastDot); // get space from name\n        this.name = validateName(name.substring(lastDot + 1));\n      }\n      if (\"\".equals(space))\n        space = null;\n      this.space = space;\n      this.full = (this.space == null) ? this.name : this.space + \".\" + this.name;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (o == this)\n        return true;\n      if (!(o instanceof Name))\n        return false;\n      Name that = (Name) o;\n      return Objects.equals(full, that.full);\n    }\n\n    @Override\n    public int hashCode() {\n      return full == null ? 0 : full.hashCode();\n    }\n\n    @Override\n    public String toString() {\n      return full;\n    }\n\n    public void writeName(Names names, JsonGenerator gen) throws IOException {\n      if (name != null)\n        gen.writeStringField(\"name\", name);\n      if (space != null) {\n        if (!space.equals(names.space()))\n          gen.writeStringField(\"namespace\", space);\n      } else if (names.space() != null) { // null within non-null\n        gen.writeStringField(\"namespace\", \"\");\n      }\n    }\n\n    public String getQualified(String defaultSpace) {\n      return this.shouldWriteFull(defaultSpace) ? full : name;\n    }\n\n    /**\n     * Determine if full name must be written. There are 2 cases for true :\n     * defaultSpace != from this.space or name is already a Schema.Type (int, array\n     * ...)\n     *\n     * @param defaultSpace : default name space.\n     * @return true if full name must be written.\n     */\n    private boolean shouldWriteFull(String defaultSpace) {\n      if (space != null && space.equals(defaultSpace)) {\n        for (Type schemaType : Type.values()) {\n          if (schemaType.name.equals(name)) {\n            // name is a 'Type', so namespace must be written\n            return true;\n          }\n        }\n        // this.space == defaultSpace\n        return false;\n      }\n      // this.space != defaultSpace, so namespace must be written.\n      return true;\n    }\n\n  }\n\n  private static abstract class NamedSchema extends Schema {\n    final Name name;\n    final String doc;\n    Set<Name> aliases;\n\n    public NamedSchema(Type type, Name name, String doc) {\n      super(type);\n      this.name = name;\n      this.doc = doc;\n      if (PRIMITIVES.containsKey(name.full)) {\n        throw new AvroTypeException(\"Schemas may not be named after primitives: \" + name.full);\n      }\n    }\n\n    @Override\n    public String getName() {\n      return name.name;\n    }\n\n    @Override\n    public String getDoc() {\n      return doc;\n    }\n\n    @Override\n    public String getNamespace() {\n      return name.space;\n    }\n\n    @Override\n    public String getFullName() {\n      return name.full;\n    }\n\n    @Override\n    public void addAlias(String alias) {\n      addAlias(alias, null);\n    }\n\n    @Override\n    public void addAlias(String name, String space) {\n      if (aliases == null)\n        this.aliases = new LinkedHashSet<>();\n      if (space == null)\n        space = this.name.space;\n      aliases.add(new Name(name, space));\n    }\n\n    @Override\n    public Set<String> getAliases() {\n      Set<String> result = new LinkedHashSet<>();\n      if (aliases != null)\n        for (Name alias : aliases)\n          result.add(alias.full);\n      return result;\n    }\n\n    public boolean writeNameRef(Names names, JsonGenerator gen) throws IOException {\n      if (this.equals(names.get(name))) {\n        gen.writeString(name.getQualified(names.space()));\n        return true;\n      } else if (name.name != null) {\n        names.put(name, this);\n      }\n      return false;\n    }\n\n    public void writeName(Names names, JsonGenerator gen) throws IOException {\n      name.writeName(names, gen);\n    }\n\n    public boolean equalNames(NamedSchema that) {\n      return this.name.equals(that.name);\n    }\n\n    @Override\n    int computeHash() {\n      return super.computeHash() + name.hashCode();\n    }\n\n    public void aliasesToJson(JsonGenerator gen) throws IOException {\n      if (aliases == null || aliases.isEmpty())\n        return;\n      gen.writeFieldName(\"aliases\");\n      gen.writeStartArray();\n      for (Name alias : aliases)\n        gen.writeString(alias.getQualified(name.space));\n      gen.writeEndArray();\n    }\n\n  }\n\n  /**\n   * Useful as key of {@link Map}s when traversing two schemas at the same time\n   * and need to watch for recursion.\n   */\n  public static class SeenPair {\n    private Object s1;\n    private Object s2;\n\n    public SeenPair(Object s1, Object s2) {\n      this.s1 = s1;\n      this.s2 = s2;\n    }\n\n    public boolean equals(Object o) {\n      if (!(o instanceof SeenPair))\n        return false;\n      return this.s1 == ((SeenPair) o).s1 && this.s2 == ((SeenPair) o).s2;\n    }\n\n    @Override\n    public int hashCode() {\n      return System.identityHashCode(s1) + System.identityHashCode(s2);\n    }\n  }\n\n  private static final ThreadLocal<Set> SEEN_EQUALS = ThreadLocalWithInitial.of(HashSet::new);\n  private static final ThreadLocal<Map> SEEN_HASHCODE = ThreadLocalWithInitial.of(IdentityHashMap::new);\n\n  @SuppressWarnings(value = \"unchecked\")\n  private static class RecordSchema extends NamedSchema {\n    private List<Field> fields;\n    private Map<String, Field> fieldMap;\n    private final boolean isError;\n\n    public RecordSchema(Name name, String doc, boolean isError) {\n      super(Type.RECORD, name, doc);\n      this.isError = isError;\n    }\n\n    public RecordSchema(Name name, String doc, boolean isError, List<Field> fields) {\n      super(Type.RECORD, name, doc);\n      this.isError = isError;\n      setFields(fields);\n    }\n\n    @Override\n    public boolean isError() {\n      return isError;\n    }\n\n    @Override\n    public Field getField(String fieldname) {\n      if (fieldMap == null)\n        throw new AvroRuntimeException(\"Schema fields not set yet\");\n      return fieldMap.get(fieldname);\n    }\n\n    @Override\n    public List<Field> getFields() {\n      if (fields == null)\n        throw new AvroRuntimeException(\"Schema fields not set yet\");\n      return fields;\n    }\n\n    @Override\n    public boolean hasFields() {\n      return fields != null;\n    }\n\n    @Override\n    public void setFields(List<Field> fields) {\n      if (this.fields != null) {\n        throw new AvroRuntimeException(\"Fields are already set\");\n      }\n      int i = 0;\n      fieldMap = new HashMap<>(Math.multiplyExact(2, fields.size()));\n      LockableArrayList<Field> ff = new LockableArrayList<>(fields.size());\n      for (Field f : fields) {\n        if (f.position != -1) {\n          throw new AvroRuntimeException(\"Field already used: \" + f);\n        }\n        f.position = i++;\n        final Field existingField = fieldMap.put(f.name(), f);\n        if (existingField != null) {\n          throw new AvroRuntimeException(\n              String.format(\"Duplicate field %s in record %s: %s and %s.\", f.name(), name, f, existingField));\n        }\n        ff.add(f);\n      }\n      this.fields = ff.lock();\n      this.hashCode = NO_HASHCODE;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (o == this)\n        return true;\n      if (!(o instanceof RecordSchema))\n        return false;\n      RecordSchema that = (RecordSchema) o;\n      if (!equalCachedHash(that))\n        return false;\n      if (!equalNames(that))\n        return false;\n      if (!propsEqual(that))\n        return false;\n      Set seen = SEEN_EQUALS.get();\n      SeenPair here = new SeenPair(this, o);\n      if (seen.contains(here))\n        return true; // prevent stack overflow\n      boolean first = seen.isEmpty();\n      try {\n        seen.add(here);\n        return Objects.equals(fields, that.fields);\n      } finally {\n        if (first)\n          seen.clear();\n      }\n    }\n\n    @Override\n    int computeHash() {\n      Map seen = SEEN_HASHCODE.get();\n      if (seen.containsKey(this))\n        return 0; // prevent stack overflow\n      boolean first = seen.isEmpty();\n      try {\n        seen.put(this, this);\n        return super.computeHash() + fields.hashCode();\n      } finally {\n        if (first)\n          seen.clear();\n      }\n    }\n\n    @Override\n    void toJson(Names names, JsonGenerator gen) throws IOException {\n      if (writeNameRef(names, gen))\n        return;\n      String savedSpace = names.space; // save namespace\n      gen.writeStartObject();\n      gen.writeStringField(\"type\", isError ? \"error\" : \"record\");\n      writeName(names, gen);\n      names.space = name.space; // set default namespace\n      if (getDoc() != null)\n        gen.writeStringField(\"doc\", getDoc());\n\n      if (fields != null) {\n        gen.writeFieldName(\"fields\");\n        fieldsToJson(names, gen);\n      }\n\n      writeProps(gen);\n      aliasesToJson(gen);\n      gen.writeEndObject();\n      names.space = savedSpace; // restore namespace\n    }\n\n    @Override\n    void fieldsToJson(Names names, JsonGenerator gen) throws IOException {\n      gen.writeStartArray();\n      for (Field f : fields) {\n        gen.writeStartObject();\n        gen.writeStringField(\"name\", f.name());\n        gen.writeFieldName(\"type\");\n        f.schema().toJson(names, gen);\n        if (f.doc() != null)\n          gen.writeStringField(\"doc\", f.doc());\n        if (f.hasDefaultValue()) {\n          gen.writeFieldName(\"default\");\n          gen.writeTree(f.defaultValue());\n        }\n        if (f.order() != Field.Order.ASCENDING)\n          gen.writeStringField(\"order\", f.order().name);\n        if (f.aliases != null && f.aliases.size() != 0) {\n          gen.writeFieldName(\"aliases\");\n          gen.writeStartArray();\n          for (String alias : f.aliases)\n            gen.writeString(alias);\n          gen.writeEndArray();\n        }\n        f.writeProps(gen);\n        gen.writeEndObject();\n      }\n      gen.writeEndArray();\n    }\n  }\n\n  private static class EnumSchema extends NamedSchema {\n    private final List<String> symbols;\n    private final Map<String, Integer> ordinals;\n    private final String enumDefault;\n\n    public EnumSchema(Name name, String doc, LockableArrayList<String> symbols, String enumDefault) {\n      super(Type.ENUM, name, doc);\n      this.symbols = symbols.lock();\n      this.ordinals = new HashMap<>(Math.multiplyExact(2, symbols.size()));\n      this.enumDefault = enumDefault;\n      int i = 0;\n      for (String symbol : symbols) {\n        if (ordinals.put(validateName(symbol), i++) != null) {\n          throw new SchemaParseException(\"Duplicate enum symbol: \" + symbol);\n        }\n      }\n      if (enumDefault != null && !symbols.contains(enumDefault)) {\n        throw new SchemaParseException(\n            \"The Enum Default: \" + enumDefault + \" is not in the enum symbol set: \" + symbols);\n      }\n    }\n\n    @Override\n    public List<String> getEnumSymbols() {\n      return symbols;\n    }\n\n    @Override\n    public boolean hasEnumSymbol(String symbol) {\n      return ordinals.containsKey(symbol);\n    }\n\n    @Override\n    public int getEnumOrdinal(String symbol) {\n      return ordinals.get(symbol);\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (o == this)\n        return true;\n      if (!(o instanceof EnumSchema))\n        return false;\n      EnumSchema that = (EnumSchema) o;\n      return equalCachedHash(that) && equalNames(that) && symbols.equals(that.symbols) && propsEqual(that);\n    }\n\n    @Override\n    public String getEnumDefault() {\n      return enumDefault;\n    }\n\n    @Override\n    int computeHash() {\n      return super.computeHash() + symbols.hashCode();\n    }\n\n    @Override\n    void toJson(Names names, JsonGenerator gen) throws IOException {\n      if (writeNameRef(names, gen))\n        return;\n      gen.writeStartObject();\n      gen.writeStringField(\"type\", \"enum\");\n      writeName(names, gen);\n      if (getDoc() != null)\n        gen.writeStringField(\"doc\", getDoc());\n      gen.writeArrayFieldStart(\"symbols\");\n      for (String symbol : symbols)\n        gen.writeString(symbol);\n      gen.writeEndArray();\n      if (getEnumDefault() != null)\n        gen.writeStringField(\"default\", getEnumDefault());\n      writeProps(gen);\n      aliasesToJson(gen);\n      gen.writeEndObject();\n    }\n  }\n\n  private static class ArraySchema extends Schema {\n    private final Schema elementType;\n\n    public ArraySchema(Schema elementType) {\n      super(Type.ARRAY);\n      this.elementType = elementType;\n    }\n\n    @Override\n    public Schema getElementType() {\n      return elementType;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (o == this)\n        return true;\n      if (!(o instanceof ArraySchema))\n        return false;\n      ArraySchema that = (ArraySchema) o;\n      return equalCachedHash(that) && elementType.equals(that.elementType) && propsEqual(that);\n    }\n\n    @Override\n    int computeHash() {\n      return super.computeHash() + elementType.computeHash();\n    }\n\n    @Override\n    void toJson(Names names, JsonGenerator gen) throws IOException {\n      gen.writeStartObject();\n      gen.writeStringField(\"type\", \"array\");\n      gen.writeFieldName(\"items\");\n      elementType.toJson(names, gen);\n      writeProps(gen);\n      gen.writeEndObject();\n    }\n  }\n\n  private static class MapSchema extends Schema {\n    private final Schema valueType;\n\n    public MapSchema(Schema valueType) {\n      super(Type.MAP);\n      this.valueType = valueType;\n    }\n\n    @Override\n    public Schema getValueType() {\n      return valueType;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (o == this)\n        return true;\n      if (!(o instanceof MapSchema))\n        return false;\n      MapSchema that = (MapSchema) o;\n      return equalCachedHash(that) && valueType.equals(that.valueType) && propsEqual(that);\n    }\n\n    @Override\n    int computeHash() {\n      return super.computeHash() + valueType.computeHash();\n    }\n\n    @Override\n    void toJson(Names names, JsonGenerator gen) throws IOException {\n      gen.writeStartObject();\n      gen.writeStringField(\"type\", \"map\");\n      gen.writeFieldName(\"values\");\n      valueType.toJson(names, gen);\n      writeProps(gen);\n      gen.writeEndObject();\n    }\n  }\n\n  private static class UnionSchema extends Schema {\n    private final List<Schema> types;\n    private final Map<String, Integer> indexByName;\n\n    public UnionSchema(LockableArrayList<Schema> types) {\n      super(Type.UNION);\n      this.indexByName = new HashMap<>(Math.multiplyExact(2, types.size()));\n      this.types = types.lock();\n      int index = 0;\n      for (Schema type : types) {\n        if (type.getType() == Type.UNION) {\n          throw new AvroRuntimeException(\"Nested union: \" + this);\n        }\n        String name = type.getFullName();\n        if (name == null) {\n          throw new AvroRuntimeException(\"Nameless in union:\" + this);\n        }\n        if (indexByName.put(name, index++) != null) {\n          throw new AvroRuntimeException(\"Duplicate in union:\" + name);\n        }\n      }\n    }\n\n    @Override\n    public List<Schema> getTypes() {\n      return types;\n    }\n\n    @Override\n    public Integer getIndexNamed(String name) {\n      return indexByName.get(name);\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (o == this)\n        return true;\n      if (!(o instanceof UnionSchema))\n        return false;\n      UnionSchema that = (UnionSchema) o;\n      return equalCachedHash(that) && types.equals(that.types) && propsEqual(that);\n    }\n\n    @Override\n    int computeHash() {\n      int hash = super.computeHash();\n      for (Schema type : types)\n        hash += type.computeHash();\n      return hash;\n    }\n\n    @Override\n    public void addProp(String name, String value) {\n      throw new AvroRuntimeException(\"Can't set properties on a union: \" + this);\n    }\n\n    @Override\n    void toJson(Names names, JsonGenerator gen) throws IOException {\n      gen.writeStartArray();\n      for (Schema type : types)\n        type.toJson(names, gen);\n      gen.writeEndArray();\n    }\n\n    @Override\n    public String getName() {\n      return super.getName()\n          + this.getTypes().stream().map(Schema::getName).collect(Collectors.joining(\", \", \"[\", \"]\"));\n    }\n  }\n\n  private static class FixedSchema extends NamedSchema {\n    private final int size;\n\n    public FixedSchema(Name name, String doc, int size) {\n      super(Type.FIXED, name, doc);\n      if (size < 0)\n        throw new IllegalArgumentException(\"Invalid fixed size: \" + size);\n      this.size = size;\n    }\n\n    @Override\n    public int getFixedSize() {\n      return size;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (o == this)\n        return true;\n      if (!(o instanceof FixedSchema))\n        return false;\n      FixedSchema that = (FixedSchema) o;\n      return equalCachedHash(that) && equalNames(that) && size == that.size && propsEqual(that);\n    }\n\n    @Override\n    int computeHash() {\n      return super.computeHash() + size;\n    }\n\n    @Override\n    void toJson(Names names, JsonGenerator gen) throws IOException {\n      if (writeNameRef(names, gen))\n        return;\n      gen.writeStartObject();\n      gen.writeStringField(\"type\", \"fixed\");\n      writeName(names, gen);\n      if (getDoc() != null)\n        gen.writeStringField(\"doc\", getDoc());\n      gen.writeNumberField(\"size\", size);\n      writeProps(gen);\n      aliasesToJson(gen);\n      gen.writeEndObject();\n    }\n  }\n\n  private static class StringSchema extends Schema {\n    public StringSchema() {\n      super(Type.STRING);\n    }\n  }\n\n  private static class BytesSchema extends Schema {\n    public BytesSchema() {\n      super(Type.BYTES);\n    }\n  }\n\n  private static class IntSchema extends Schema {\n    public IntSchema() {\n      super(Type.INT);\n    }\n  }\n\n  private static class LongSchema extends Schema {\n    public LongSchema() {\n      super(Type.LONG);\n    }\n  }\n\n  private static class FloatSchema extends Schema {\n    public FloatSchema() {\n      super(Type.FLOAT);\n    }\n  }\n\n  private static class DoubleSchema extends Schema {\n    public DoubleSchema() {\n      super(Type.DOUBLE);\n    }\n  }\n\n  private static class BooleanSchema extends Schema {\n    public BooleanSchema() {\n      super(Type.BOOLEAN);\n    }\n  }\n\n  private static class NullSchema extends Schema {\n    public NullSchema() {\n      super(Type.NULL);\n    }\n  }\n\n  /**\n   * A parser for JSON-format schemas. Each named schema parsed with a parser is\n   * added to the names known to the parser so that subsequently parsed schemas\n   * may refer to it by name.\n   */\n  public static class Parser {\n    private Names names = new Names();\n    private boolean validate = true;\n    private boolean validateDefaults = true;\n\n    /**\n     * Adds the provided types to the set of defined, named types known to this\n     * parser. deprecated: use addTypes(Iterable<Schema> types)\n     */\n    @Deprecated\n    public Parser addTypes(Map<String, Schema> types) {\n      return this.addTypes(types.values());\n    }\n\n    /**\n     * Adds the provided types to the set of defined, named types known to this\n     * parser.\n     */\n    public Parser addTypes(Iterable<Schema> types) {\n      for (Schema s : types)\n        names.add(s);\n      return this;\n    }\n\n    /** Returns the set of defined, named types known to this parser. */\n    public Map<String, Schema> getTypes() {\n      Map<String, Schema> result = new LinkedHashMap<>();\n      for (Schema s : names.values())\n        result.put(s.getFullName(), s);\n      return result;\n    }\n\n    /** Enable or disable name validation. */\n    public Parser setValidate(boolean validate) {\n      this.validate = validate;\n      return this;\n    }\n\n    /** True iff names are validated. True by default. */\n    public boolean getValidate() {\n      return this.validate;\n    }\n\n    /** Enable or disable default value validation. */\n    public Parser setValidateDefaults(boolean validateDefaults) {\n      this.validateDefaults = validateDefaults;\n      return this;\n    }\n\n    /** True iff default values are validated. False by default. */\n    public boolean getValidateDefaults() {\n      return this.validateDefaults;\n    }\n\n    /**\n     * Parse a schema from the provided file. If named, the schema is added to the\n     * names known to this parser.\n     */\n    public Schema parse(File file) throws IOException {\n      return parse(FACTORY.createParser(file), false);\n    }\n\n    public List<Schema> parse(Iterable<File> sources) throws IOException {\n      final List<Schema> schemas = new ArrayList<>();\n      for (File source : sources) {\n        final Schema emptySchema = parseNamesDeclared(FACTORY.createParser(source));\n        schemas.add(emptySchema);\n      }\n\n      for (File source : sources) {\n        parseFieldsOnly(FACTORY.createParser(source));\n      }\n\n      return schemas;\n    }\n\n    /**\n     * Parse a schema from the provided stream. If named, the schema is added to the\n     * names known to this parser. The input stream stays open after the parsing.\n     */\n    public Schema parse(InputStream in) throws IOException {\n      return parse(FACTORY.createParser(in).disable(JsonParser.Feature.AUTO_CLOSE_SOURCE), true);\n    }\n\n    /** Read a schema from one or more json strings */\n    public Schema parse(String s, String... more) {\n      StringBuilder b = new StringBuilder(s);\n      for (String part : more)\n        b.append(part);\n      return parse(b.toString());\n    }\n\n    /**\n     * Parse a schema from the provided string. If named, the schema is added to the\n     * names known to this parser.\n     */\n    public Schema parse(String s) {\n      try {\n        return parse(FACTORY.createParser(s), false);\n      } catch (IOException e) {\n        throw new SchemaParseException(e);\n      }\n    }\n\n    private static interface ParseFunction {\n      Schema parse(JsonNode node) throws IOException;\n    }\n\n    private Schema runParser(JsonParser parser, ParseFunction f) throws IOException {\n      boolean saved = validateNames.get();\n      boolean savedValidateDefaults = VALIDATE_DEFAULTS.get();\n      try {\n        validateNames.set(validate);\n        VALIDATE_DEFAULTS.set(validateDefaults);\n        JsonNode jsonNode = MAPPER.readTree(parser);\n        return f.parse(jsonNode);\n      } catch (JsonParseException e) {\n        throw new SchemaParseException(e);\n      } finally {\n        parser.close();\n        validateNames.set(saved);\n        VALIDATE_DEFAULTS.set(savedValidateDefaults);\n      }\n    }\n\n    private Schema parse(JsonParser parser, final boolean allowDanglingContent) throws IOException {\n      return this.runParser(parser, (JsonNode jsonNode) -> {\n        Schema schema = Schema.parse(jsonNode, names);\n        if (!allowDanglingContent) {\n          String dangling;\n          StringWriter danglingWriter = new StringWriter();\n          int numCharsReleased = parser.releaseBuffered(danglingWriter);\n          if (numCharsReleased == -1) {\n            ByteArrayOutputStream danglingOutputStream = new ByteArrayOutputStream();\n            parser.releaseBuffered(danglingOutputStream); // if input isnt chars above it must be bytes\n            dangling = new String(danglingOutputStream.toByteArray(), StandardCharsets.UTF_8).trim();\n          } else {\n            dangling = danglingWriter.toString().trim();\n          }\n          if (!dangling.isEmpty()) {\n            throw new SchemaParseException(\"dangling content after end of schema: \" + dangling);\n          }\n        }\n        return schema;\n      });\n    }\n\n    private Schema parseNamesDeclared(JsonParser parser) throws IOException {\n      return this.runParser(parser, (JsonNode jsonNode) -> Schema.parseNamesDeclared(jsonNode, names, names.space));\n    }\n\n    private Schema parseFieldsOnly(JsonParser parser) throws IOException {\n      return this.runParser(parser, (JsonNode jsonNode) -> Schema.parseCompleteSchema(jsonNode, names, names.space));\n    }\n\n  }\n\n  /**\n   * Constructs a Schema object from JSON schema file <tt>file<\/tt>. The contents\n   * of <tt>file<\/tt> is expected to be in UTF-8 format.\n   *\n   * @param file The file to read the schema from.\n   * @return The freshly built Schema.\n   * @throws IOException if there was trouble reading the contents or they are\n   *                     invalid\n   * @deprecated use {@link Schema.Parser} instead.\n   */\n  @Deprecated\n  public static Schema parse(File file) throws IOException {\n    return new Parser().parse(file);\n  }\n\n  /**\n   * Constructs a Schema object from JSON schema stream <tt>in<\/tt>. The contents\n   * of <tt>in<\/tt> is expected to be in UTF-8 format.\n   *\n   * @param in The input stream to read the schema from.\n   * @return The freshly built Schema.\n   * @throws IOException if there was trouble reading the contents or they are\n   *                     invalid\n   * @deprecated use {@link Schema.Parser} instead.\n   */\n  @Deprecated\n  public static Schema parse(InputStream in) throws IOException {\n    return new Parser().parse(in);\n  }\n\n  /**\n   * Construct a schema from <a href=\"https://json.org/\">JSON<\/a> text.\n   *\n   * @deprecated use {@link Schema.Parser} instead.\n   */\n  @Deprecated\n  public static Schema parse(String jsonSchema) {\n    return new Parser().parse(jsonSchema);\n  }\n\n  /**\n   * Construct a schema from <a href=\"https://json.org/\">JSON<\/a> text.\n   *\n   * @param validate true if names should be validated, false if not.\n   * @deprecated use {@link Schema.Parser} instead.\n   */\n  @Deprecated\n  public static Schema parse(String jsonSchema, boolean validate) {\n    return new Parser().setValidate(validate).parse(jsonSchema);\n  }\n\n  static final Map<String, Type> PRIMITIVES = new HashMap<>();\n  static {\n    PRIMITIVES.put(\"string\", Type.STRING);\n    PRIMITIVES.put(\"bytes\", Type.BYTES);\n    PRIMITIVES.put(\"int\", Type.INT);\n    PRIMITIVES.put(\"long\", Type.LONG);\n    PRIMITIVES.put(\"float\", Type.FLOAT);\n    PRIMITIVES.put(\"double\", Type.DOUBLE);\n    PRIMITIVES.put(\"boolean\", Type.BOOLEAN);\n    PRIMITIVES.put(\"null\", Type.NULL);\n  }\n\n  static class Names extends LinkedHashMap<Name, Schema> {\n    private static final long serialVersionUID = 1L;\n    private String space; // default namespace\n\n    public Names() {\n    }\n\n    public Names(String space) {\n      this.space = space;\n    }\n\n    public String space() {\n      return space;\n    }\n\n    public void space(String space) {\n      this.space = space;\n    }\n\n    public Schema get(String o) {\n      Type primitive = PRIMITIVES.get(o);\n      if (primitive != null) {\n        return Schema.create(primitive);\n      }\n      Name name = new Name(o, space);\n      if (!containsKey(name)) {\n        // if not in default try anonymous\n        name = new Name(o, \"\");\n      }\n      return super.get(name);\n    }\n\n    public boolean contains(Schema schema) {\n      return get(((NamedSchema) schema).name) != null;\n    }\n\n    public void add(Schema schema) {\n      put(((NamedSchema) schema).name, schema);\n    }\n\n    @Override\n    public Schema put(Name name, Schema schema) {\n      if (containsKey(name)) {\n        final Schema other = super.get(name);\n        if (!Objects.equals(other, schema)) {\n          throw new SchemaParseException(\"Can't redefine: \" + name);\n        } else {\n          return schema;\n        }\n      }\n      return super.put(name, schema);\n    }\n  }\n\n  private static ThreadLocal<Boolean> validateNames = ThreadLocalWithInitial.of(() -> true);\n\n  private static String validateName(String name) {\n    if (!validateNames.get())\n      return name; // not validating names\n    if (name == null)\n      throw new SchemaParseException(\"Null name\");\n    int length = name.length();\n    if (length == 0)\n      throw new SchemaParseException(\"Empty name\");\n    char first = name.charAt(0);\n    if (!(Character.isLetter(first) || first == '_'))\n      throw new SchemaParseException(\"Illegal initial character: \" + name);\n    for (int i = 1; i < length; i++) {\n      char c = name.charAt(i);\n      if (!(Character.isLetterOrDigit(c) || c == '_'))\n        throw new SchemaParseException(\"Illegal character in: \" + name);\n    }\n    return name;\n  }\n\n  private static final ThreadLocal<Boolean> VALIDATE_DEFAULTS = ThreadLocalWithInitial.of(() -> true);\n\n  private static JsonNode validateDefault(String fieldName, Schema schema, JsonNode defaultValue) {\n    if (VALIDATE_DEFAULTS.get() && (defaultValue != null) && !isValidDefault(schema, defaultValue)) { // invalid default\n      String message = \"Invalid default for field \" + fieldName + \": \" + defaultValue + \" not a \" + schema;\n      throw new AvroTypeException(message); // throw exception\n    }\n    return defaultValue;\n  }\n\n  private static boolean isValidDefault(Schema schema, JsonNode defaultValue) {\n    if (defaultValue == null)\n      return false;\n    switch (schema.getType()) {\n    case STRING:\n    case BYTES:\n    case ENUM:\n    case FIXED:\n      return defaultValue.isTextual();\n    case INT:\n      return defaultValue.isIntegralNumber() && defaultValue.canConvertToInt();\n    case LONG:\n      return defaultValue.isIntegralNumber() && defaultValue.canConvertToLong();\n    case FLOAT:\n    case DOUBLE:\n      return defaultValue.isNumber();\n    case BOOLEAN:\n      return defaultValue.isBoolean();\n    case NULL:\n      return defaultValue.isNull();\n    case ARRAY:\n      if (!defaultValue.isArray())\n        return false;\n      for (JsonNode element : defaultValue)\n        if (!isValidDefault(schema.getElementType(), element))\n          return false;\n      return true;\n    case MAP:\n      if (!defaultValue.isObject())\n        return false;\n      for (JsonNode value : defaultValue)\n        if (!isValidDefault(schema.getValueType(), value))\n          return false;\n      return true;\n    case UNION: // union default: first branch\n      return isValidDefault(schema.getTypes().get(0), defaultValue);\n    case RECORD:\n      if (!defaultValue.isObject())\n        return false;\n      for (Field field : schema.getFields())\n        if (!isValidValue(field.schema(),\n            defaultValue.has(field.name()) ? defaultValue.get(field.name()) : field.defaultValue()))\n          return false;\n      return true;\n    default:\n      return false;\n    }\n  }\n\n  /**\n   * Validate a value against the schema.\n   *\n   * @param schema : schema for value.\n   * @param value  : value to validate.\n   * @return true if ok.\n   */\n  private static boolean isValidValue(Schema schema, JsonNode value) {\n    if (value == null)\n      return false;\n    if (schema.isUnion()) {\n      // For Union, only need that one sub schema is ok.\n      for (Schema sub : schema.getTypes()) {\n        if (Schema.isValidDefault(sub, value)) {\n          return true;\n        }\n      }\n      return false;\n    } else {\n      // for other types, same as validate default.\n      return Schema.isValidDefault(schema, value);\n    }\n  }\n\n  /**\n   * Parse named schema in order to fill names map. This method does not parse\n   * field of record/error schema.\n   *\n   * @param schema           : json schema representation.\n   * @param names            : map of named schema.\n   * @param currentNameSpace : current working name space.\n   * @return schema.\n   */\n  private static Schema parseNamesDeclared(JsonNode schema, Names names, String currentNameSpace) {\n    if (schema == null) {\n      return null;\n    }\n    if (schema.isObject()) {\n\n      String type = Schema.getOptionalText(schema, \"type\");\n      Name name = null;\n\n      String doc = null;\n      Schema result = null;\n      final boolean isTypeError = \"error\".equals(type);\n      final boolean isTypeRecord = \"record\".equals(type);\n      final boolean isTypeEnum = \"enum\".equals(type);\n      final boolean isTypeFixed = \"fixed\".equals(type);\n\n      if (isTypeRecord || isTypeError || isTypeEnum || isTypeFixed) {\n        String space = getOptionalText(schema, \"namespace\");\n        doc = getOptionalText(schema, \"doc\");\n        if (space == null)\n          space = currentNameSpace;\n        name = new Name(getRequiredText(schema, \"name\", \"No name in schema\"), space);\n      }\n      if (isTypeRecord || isTypeError) { // record\n        result = new RecordSchema(name, doc, isTypeError);\n        names.add(result);\n        JsonNode fieldsNode = schema.get(\"fields\");\n\n        if (fieldsNode == null || !fieldsNode.isArray())\n          throw new SchemaParseException(\"Record has no fields: \" + schema);\n        exploreFields(fieldsNode, names, name != null ? name.space : null);\n\n      } else if (isTypeEnum) { // enum\n        JsonNode symbolsNode = schema.get(\"symbols\");\n        if (symbolsNode == null || !symbolsNode.isArray())\n          throw new SchemaParseException(\"Enum has no symbols: \" + schema);\n        LockableArrayList<String> symbols = new LockableArrayList<>(symbolsNode.size());\n        for (JsonNode n : symbolsNode)\n          symbols.add(n.textValue());\n        JsonNode enumDefault = schema.get(\"default\");\n        String defaultSymbol = null;\n        if (enumDefault != null)\n          defaultSymbol = enumDefault.textValue();\n        result = new EnumSchema(name, doc, symbols, defaultSymbol);\n        names.add(result);\n      } else if (type.equals(\"array\")) { // array\n        JsonNode itemsNode = schema.get(\"items\");\n        if (itemsNode == null)\n          throw new SchemaParseException(\"Array has no items type: \" + schema);\n        final Schema items = Schema.parseNamesDeclared(itemsNode, names, currentNameSpace);\n        result = Schema.createArray(items);\n      } else if (type.equals(\"map\")) { // map\n        JsonNode valuesNode = schema.get(\"values\");\n        if (valuesNode == null)\n          throw new SchemaParseException(\"Map has no values type: \" + schema);\n        final Schema values = Schema.parseNamesDeclared(valuesNode, names, currentNameSpace);\n        result = Schema.createMap(values);\n      } else if (isTypeFixed) { // fixed\n        JsonNode sizeNode = schema.get(\"size\");\n        if (sizeNode == null || !sizeNode.isInt())\n          throw new SchemaParseException(\"Invalid or no size: \" + schema);\n        result = new FixedSchema(name, doc, sizeNode.intValue());\n        if (name != null)\n          names.add(result);\n      } else if (PRIMITIVES.containsKey(type)) {\n        result = Schema.create(PRIMITIVES.get(type));\n      }\n      if (result != null) {\n        Set<String> reserved = SCHEMA_RESERVED;\n        if (isTypeEnum) {\n          reserved = ENUM_RESERVED;\n        }\n        Schema.addProperties(schema, reserved, result);\n      }\n      return result;\n    } else if (schema.isArray()) {\n      List<Schema> subs = new ArrayList<>(schema.size());\n      schema.forEach((JsonNode item) -> {\n        Schema sub = Schema.parseNamesDeclared(item, names, currentNameSpace);\n        if (sub != null) {\n          subs.add(sub);\n        }\n      });\n      return Schema.createUnion(subs);\n    } else if (schema.isTextual()) {\n      String value = schema.asText();\n      return names.get(value);\n    }\n    return null;\n  }\n\n  private static void addProperties(JsonNode schema, Set<String> reserved, Schema avroSchema) {\n    Iterator<String> i = schema.fieldNames();\n    while (i.hasNext()) { // add properties\n      String prop = i.next();\n      if (!reserved.contains(prop)) // ignore reserved\n        avroSchema.addProp(prop, schema.get(prop));\n    }\n    // parse logical type if present\n    avroSchema.logicalType = LogicalTypes.fromSchemaIgnoreInvalid(avroSchema);\n    // names.space(savedSpace); // restore space\n    if (avroSchema instanceof NamedSchema) {\n      Set<String> aliases = parseAliases(schema);\n      if (aliases != null) // add aliases\n        for (String alias : aliases)\n          avroSchema.addAlias(alias);\n    }\n  }\n\n  /**\n   * Explore record fields in order to fill names map with inner defined named\n   * types.\n   *\n   * @param fieldsNode : json node for field.\n   * @param names      : names map.\n   * @param nameSpace  : current working namespace.\n   */\n  private static void exploreFields(JsonNode fieldsNode, Names names, String nameSpace) {\n    for (JsonNode field : fieldsNode) {\n      final JsonNode fieldType = field.get(\"type\");\n      if (fieldType != null) {\n        if (fieldType.isObject()) {\n          parseNamesDeclared(fieldType, names, nameSpace);\n        } else if (fieldType.isArray()) {\n          exploreFields(fieldType, names, nameSpace);\n        } else if (fieldType.isTextual() && field.isObject()) {\n          parseNamesDeclared(field, names, nameSpace);\n        }\n      }\n    }\n  }\n\n  /**\n   * in complement of parseNamesDeclared, this method parse schema in details.\n   *\n   * @param schema       : json schema.\n   * @param names        : names map.\n   * @param currentSpace : current working name space.\n   * @return complete schema.\n   */\n  static Schema parseCompleteSchema(JsonNode schema, Names names, String currentSpace) {\n    if (schema == null) {\n      throw new SchemaParseException(\"Cannot parse <null> schema\");\n    }\n    if (schema.isTextual()) {\n      String type = schema.asText();\n      Schema avroSchema = names.get(type);\n      if (avroSchema == null) {\n        avroSchema = names.get(currentSpace + \".\" + type);\n      }\n      return avroSchema;\n    }\n    if (schema.isArray()) {\n      List<Schema> schemas = StreamSupport.stream(schema.spliterator(), false)\n          .map((JsonNode sub) -> parseCompleteSchema(sub, names, currentSpace)).collect(Collectors.toList());\n      return Schema.createUnion(schemas);\n    }\n    if (schema.isObject()) {\n      Schema result = null;\n      String type = getRequiredText(schema, \"type\", \"No type\");\n      Name name = null;\n\n      final boolean isTypeError = \"error\".equals(type);\n      final boolean isTypeRecord = \"record\".equals(type);\n      final boolean isTypeArray = \"array\".equals(type);\n\n      if (isTypeRecord || isTypeError || \"enum\".equals(type) || \"fixed\".equals(type)) {\n        // named schema\n        String space = getOptionalText(schema, \"namespace\");\n\n        if (space == null)\n          space = currentSpace;\n        name = new Name(getRequiredText(schema, \"name\", \"No name in schema\"), space);\n\n        result = names.get(name);\n        if (result == null) {\n          throw new SchemaParseException(\"Unparsed field type \" + name);\n        }\n      }\n      if (isTypeRecord || isTypeError) {\n        if (result != null && !result.hasFields()) {\n          final List<Field> fields = new ArrayList<>();\n          JsonNode fieldsNode = schema.get(\"fields\");\n          if (fieldsNode == null || !fieldsNode.isArray())\n            throw new SchemaParseException(\"Record has no fields: \" + schema);\n\n          for (JsonNode field : fieldsNode) {\n            Field f = Field.parse(field, names, name.space);\n\n            fields.add(f);\n            if (f.schema.getLogicalType() == null && getOptionalText(field, LOGICAL_TYPE_PROP) != null)\n              LOG.warn(\n                  \"Ignored the {}.{}.logicalType property (\\\"{}\\\"). It should probably be nested inside the \\\"type\\\" for the field.\",\n                  name, f.name, getOptionalText(field, \"logicalType\"));\n          }\n          result.setFields(fields);\n        }\n      } else if (isTypeArray) {\n        JsonNode items = schema.get(\"items\");\n        Schema schemaItems = parseCompleteSchema(items, names, currentSpace);\n        result = Schema.createArray(schemaItems);\n      } else if (\"map\".equals(type)) {\n        JsonNode values = schema.get(\"values\");\n        Schema mapItems = parseCompleteSchema(values, names, currentSpace);\n        result = Schema.createMap(mapItems);\n      } else if (result == null) {\n        result = names.get(currentSpace + \".\" + type);\n        if (result == null) {\n          result = names.get(type);\n        }\n      }\n\n      Set<String> reserved = SCHEMA_RESERVED;\n      if (\"enum\".equals(type)) {\n        reserved = ENUM_RESERVED;\n      }\n      Schema.addProperties(schema, reserved, result);\n      return result;\n    }\n    return null;\n  }\n\n  static Schema parse(JsonNode schema, Names names) {\n    if (schema == null) {\n      throw new SchemaParseException(\"Cannot parse <null> schema\");\n    }\n\n    Schema result = Schema.parseNamesDeclared(schema, names, names.space);\n    Schema.parseCompleteSchema(schema, names, names.space);\n\n    return result;\n  }\n\n  static Schema resolveSchema(JsonNode schema, Names names, String currentNameSpace) {\n    String np = currentNameSpace;\n    String nodeName = getOptionalText(schema, \"name\");\n    if (nodeName != null) {\n      final JsonNode nameSpace = schema.get(\"namespace\");\n      StringBuilder fullName = new StringBuilder();\n      if (nameSpace != null && nameSpace.isTextual()) {\n        fullName.append(nameSpace.asText()).append(\".\");\n        np = nameSpace.asText();\n      }\n      fullName.append(nodeName);\n      Schema schema1 = names.get(fullName.toString());\n\n      if (schema1 != null && schema1.getType() == Type.RECORD && !schema1.hasFields()) {\n        Schema.parseCompleteSchema(schema, names, np);\n      }\n      return schema1;\n    }\n    return null;\n  }\n\n  static Set<String> parseAliases(JsonNode node) {\n    JsonNode aliasesNode = node.get(\"aliases\");\n    if (aliasesNode == null)\n      return null;\n    if (!aliasesNode.isArray())\n      throw new SchemaParseException(\"aliases not an array: \" + node);\n    Set<String> aliases = new LinkedHashSet<>();\n    for (JsonNode aliasNode : aliasesNode) {\n      if (!aliasNode.isTextual())\n        throw new SchemaParseException(\"alias not a string: \" + aliasNode);\n      aliases.add(aliasNode.textValue());\n    }\n    return aliases;\n  }\n\n  /**\n   * Extracts text value associated to key from the container JsonNode, and throws\n   * {@link SchemaParseException} if it doesn't exist.\n   *\n   * @param container Container where to find key.\n   * @param key       Key to look for in container.\n   * @param error     String to prepend to the SchemaParseException.\n   */\n  private static String getRequiredText(JsonNode container, String key, String error) {\n    String out = getOptionalText(container, key);\n    if (null == out) {\n      throw new SchemaParseException(error + \": \" + container);\n    }\n    return out;\n  }\n\n  /** Extracts text value associated to key from the container JsonNode. */\n  private static String getOptionalText(JsonNode container, String key) {\n    JsonNode jsonNode = container.get(key);\n    return jsonNode != null ? jsonNode.textValue() : null;\n  }\n\n  static JsonNode parseJson(String s) {\n    try {\n      return MAPPER.readTree(FACTORY.createParser(s));\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /**\n   * Parses the specified json string to an object.\n   */\n  public static Object parseJsonToObject(String s) {\n    return JacksonUtils.toObject(parseJson(s));\n  }\n\n  /**\n   * Rewrite a writer's schema using the aliases from a reader's schema. This\n   * permits reading records, enums and fixed schemas whose names have changed,\n   * and records whose field names have changed. The returned schema always\n   * contains the same data elements in the same order, but with possibly\n   * different names.\n   */\n  public static Schema applyAliases(Schema writer, Schema reader) {\n    if (writer.equals(reader))\n      return writer; // same schema\n\n    // create indexes of names\n    Map<Schema, Schema> seen = new IdentityHashMap<>(1);\n    Map<Name, Name> aliases = new HashMap<>(1);\n    Map<Name, Map<String, String>> fieldAliases = new HashMap<>(1);\n    getAliases(reader, seen, aliases, fieldAliases);\n\n    if (aliases.size() == 0 && fieldAliases.size() == 0)\n      return writer; // no aliases\n\n    seen.clear();\n    return applyAliases(writer, seen, aliases, fieldAliases);\n  }\n\n  private static Schema applyAliases(Schema s, Map<Schema, Schema> seen, Map<Name, Name> aliases,\n      Map<Name, Map<String, String>> fieldAliases) {\n\n    Name name = s instanceof NamedSchema ? ((NamedSchema) s).name : null;\n    Schema result = s;\n    switch (s.getType()) {\n    case RECORD:\n      if (seen.containsKey(s))\n        return seen.get(s); // break loops\n      if (aliases.containsKey(name))\n        name = aliases.get(name);\n      result = Schema.createRecord(name.full, s.getDoc(), null, s.isError());\n      seen.put(s, result);\n      List<Field> newFields = new ArrayList<>();\n      for (Field f : s.getFields()) {\n        Schema fSchema = applyAliases(f.schema, seen, aliases, fieldAliases);\n        String fName = getFieldAlias(name, f.name, fieldAliases);\n        Field newF = new Field(fName, fSchema, f.doc, f.defaultValue, true, f.order);\n        newF.putAll(f); // copy props\n        newFields.add(newF);\n      }\n      result.setFields(newFields);\n      break;\n    case ENUM:\n      if (aliases.containsKey(name))\n        result = Schema.createEnum(aliases.get(name).full, s.getDoc(), null, s.getEnumSymbols(), s.getEnumDefault());\n      break;\n    case ARRAY:\n      Schema e = applyAliases(s.getElementType(), seen, aliases, fieldAliases);\n      if (!e.equals(s.getElementType()))\n        result = Schema.createArray(e);\n      break;\n    case MAP:\n      Schema v = applyAliases(s.getValueType(), seen, aliases, fieldAliases);\n      if (!v.equals(s.getValueType()))\n        result = Schema.createMap(v);\n      break;\n    case UNION:\n      List<Schema> types = new ArrayList<>();\n      for (Schema branch : s.getTypes())\n        types.add(applyAliases(branch, seen, aliases, fieldAliases));\n      result = Schema.createUnion(types);\n      break;\n    case FIXED:\n      if (aliases.containsKey(name))\n        result = Schema.createFixed(aliases.get(name).full, s.getDoc(), null, s.getFixedSize());\n      break;\n    default:\n      // NO-OP\n    }\n    if (!result.equals(s))\n      result.putAll(s); // copy props\n    return result;\n  }\n\n  private static void getAliases(Schema schema, Map<Schema, Schema> seen, Map<Name, Name> aliases,\n      Map<Name, Map<String, String>> fieldAliases) {\n    if (schema instanceof NamedSchema) {\n      NamedSchema namedSchema = (NamedSchema) schema;\n      if (namedSchema.aliases != null)\n        for (Name alias : namedSchema.aliases)\n          aliases.put(alias, namedSchema.name);\n    }\n    switch (schema.getType()) {\n    case RECORD:\n      if (seen.containsKey(schema))\n        return; // break loops\n      seen.put(schema, schema);\n      RecordSchema record = (RecordSchema) schema;\n      for (Field field : schema.getFields()) {\n        if (field.aliases != null)\n          for (String fieldAlias : field.aliases) {\n            Map<String, String> recordAliases = fieldAliases.computeIfAbsent(record.name, k -> new HashMap<>());\n            recordAliases.put(fieldAlias, field.name);\n          }\n        getAliases(field.schema, seen, aliases, fieldAliases);\n      }\n      if (record.aliases != null && fieldAliases.containsKey(record.name))\n        for (Name recordAlias : record.aliases)\n          fieldAliases.put(recordAlias, fieldAliases.get(record.name));\n      break;\n    case ARRAY:\n      getAliases(schema.getElementType(), seen, aliases, fieldAliases);\n      break;\n    case MAP:\n      getAliases(schema.getValueType(), seen, aliases, fieldAliases);\n      break;\n    case UNION:\n      for (Schema s : schema.getTypes())\n        getAliases(s, seen, aliases, fieldAliases);\n      break;\n    }\n  }\n\n  private static String getFieldAlias(Name record, String field, Map<Name, Map<String, String>> fieldAliases) {\n    Map<String, String> recordAliases = fieldAliases.get(record);\n    if (recordAliases == null)\n      return field;\n    String alias = recordAliases.get(field);\n    if (alias == null)\n      return field;\n    return alias;\n  }\n\n  /**\n   * No change is permitted on LockableArrayList once lock() has been called on\n   * it.\n   *\n   * @param <E>\n   */\n\n  /*\n   * This class keeps a boolean variable <tt>locked<\/tt> which is set to\n   * <tt>true<\/tt> in the lock() method. It's legal to call lock() any number of\n   * times. Any lock() other than the first one is a no-op.\n   *\n   * This class throws <tt>IllegalStateException<\/tt> if a mutating operation is\n   * performed after being locked. Since modifications through iterator also use\n   * the list's mutating operations, this effectively blocks all modifications.\n   */\n  static class LockableArrayList<E> extends ArrayList<E> {\n    private static final long serialVersionUID = 1L;\n    private boolean locked = false;\n\n    public LockableArrayList() {\n    }\n\n    public LockableArrayList(int size) {\n      super(size);\n    }\n\n    public LockableArrayList(List<E> types) {\n      super(types);\n    }\n\n    public LockableArrayList(E... types) {\n      super(types.length);\n      Collections.addAll(this, types);\n    }\n\n    public List<E> lock() {\n      locked = true;\n      return this;\n    }\n\n    private void ensureUnlocked() {\n      if (locked) {\n        throw new IllegalStateException();\n      }\n    }\n\n    @Override\n    public boolean add(E e) {\n      ensureUnlocked();\n      return super.add(e);\n    }\n\n    @Override\n    public boolean remove(Object o) {\n      ensureUnlocked();\n      return super.remove(o);\n    }\n\n    @Override\n    public E remove(int index) {\n      ensureUnlocked();\n      return super.remove(index);\n    }\n\n    @Override\n    public boolean addAll(Collection<? extends E> c) {\n      ensureUnlocked();\n      return super.addAll(c);\n    }\n\n    @Override\n    public boolean addAll(int index, Collection<? extends E> c) {\n      ensureUnlocked();\n      return super.addAll(index, c);\n    }\n\n    @Override\n    public boolean removeAll(Collection<?> c) {\n      ensureUnlocked();\n      return super.removeAll(c);\n    }\n\n    @Override\n    public boolean retainAll(Collection<?> c) {\n      ensureUnlocked();\n      return super.retainAll(c);\n    }\n\n    @Override\n    public void clear() {\n      ensureUnlocked();\n      super.clear();\n    }\n  }\n}\n","lineNo":1875}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.avro.io.parsing;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.apache.avro.AvroTypeException;\nimport org.apache.avro.Resolver;\nimport org.apache.avro.Schema;\nimport org.apache.avro.Schema.Field;\nimport org.apache.avro.io.Encoder;\nimport org.apache.avro.io.EncoderFactory;\nimport org.apache.avro.util.internal.Accessor;\nimport org.apache.avro.util.internal.Accessor.ResolvingGrammarGeneratorAccessor;\n\nimport com.fasterxml.jackson.databind.JsonNode;\n\n/**\n * The class that generates a resolving grammar to resolve between two schemas.\n */\npublic class ResolvingGrammarGenerator extends ValidatingGrammarGenerator {\n\n  static {\n    Accessor.setAccessor(new ResolvingGrammarGeneratorAccessor() {\n      @Override\n      protected void encode(Encoder e, Schema s, JsonNode n) throws IOException {\n        ResolvingGrammarGenerator.encode(e, s, n);\n      }\n    });\n  }\n\n  /**\n   * Resolves the writer schema <tt>writer<\/tt> and the reader schema\n   * <tt>reader<\/tt> and returns the start symbol for the grammar generated.\n   *\n   * @param writer The schema used by the writer\n   * @param reader The schema used by the reader\n   * @return The start symbol for the resolving grammar\n   * @throws IOException\n   */\n  public final Symbol generate(Schema writer, Schema reader) throws IOException {\n    Resolver.Action r = Resolver.resolve(writer, reader);\n    return Symbol.root(generate(r, new HashMap<>()));\n  }\n\n  /**\n   * Takes a {@link Resolver.Action} for resolving two schemas and returns the\n   * start symbol for a grammar that implements that resolution. If the action is\n   * for a record and there's already a symbol for that record in <tt>seen<\/tt>,\n   * then that symbol is returned. Otherwise a new symbol is generated and\n   * returned.\n   *\n   * @param action The resolver to be implemented\n   * @param seen   The &lt;Action&gt; to symbol map of start symbols of resolving\n   *               grammars so far.\n   * @return The start symbol for the resolving grammar\n   * @throws IOException\n   */\n  private Symbol generate(Resolver.Action action, Map<Object, Symbol> seen) throws IOException {\n    if (action instanceof Resolver.DoNothing) {\n      return simpleGen(action.writer, seen);\n\n    } else if (action instanceof Resolver.ErrorAction) {\n      return Symbol.error(action.toString());\n\n    } else if (action instanceof Resolver.Skip) {\n      return Symbol.skipAction(simpleGen(action.writer, seen));\n\n    } else if (action instanceof Resolver.Promote) {\n      return Symbol.resolve(simpleGen(action.writer, seen), simpleGen(action.reader, seen));\n\n    } else if (action instanceof Resolver.ReaderUnion) {\n      Resolver.ReaderUnion ru = (Resolver.ReaderUnion) action;\n      Symbol s = generate(ru.actualAction, seen);\n      return Symbol.seq(Symbol.unionAdjustAction(ru.firstMatch, s), Symbol.UNION);\n\n    } else if (action.writer.getType() == Schema.Type.ARRAY) {\n      Symbol es = generate(((Resolver.Container) action).elementAction, seen);\n      return Symbol.seq(Symbol.repeat(Symbol.ARRAY_END, es), Symbol.ARRAY_START);\n\n    } else if (action.writer.getType() == Schema.Type.MAP) {\n      Symbol es = generate(((Resolver.Container) action).elementAction, seen);\n      return Symbol.seq(Symbol.repeat(Symbol.MAP_END, es, Symbol.STRING), Symbol.MAP_START);\n\n    } else if (action.writer.getType() == Schema.Type.UNION) {\n      if (((Resolver.WriterUnion) action).unionEquiv) {\n        return simpleGen(action.reader, seen);\n      }\n      Resolver.Action[] branches = ((Resolver.WriterUnion) action).actions;\n      Symbol[] symbols = new Symbol[branches.length];\n      String[] labels = new String[branches.length];\n      int i = 0;\n      for (Resolver.Action branch : branches) {\n        symbols[i] = generate(branch, seen);\n        labels[i] = action.writer.getTypes().get(i).getFullName();\n        i++;\n      }\n      return Symbol.seq(Symbol.alt(symbols, labels), Symbol.WRITER_UNION_ACTION);\n    } else if (action instanceof Resolver.EnumAdjust) {\n      Resolver.EnumAdjust e = (Resolver.EnumAdjust) action;\n      Object[] adjs = new Object[e.adjustments.length];\n      for (int i = 0; i < adjs.length; i++) {\n        adjs[i] = (0 <= e.adjustments[i] ? Integer.valueOf(e.adjustments[i])\n            : \"No match for \" + e.writer.getEnumSymbols().get(i));\n      }\n      return Symbol.seq(Symbol.enumAdjustAction(e.reader.getEnumSymbols().size(), adjs), Symbol.ENUM);\n\n    } else if (action instanceof Resolver.RecordAdjust) {\n      Symbol result = seen.get(action);\n      if (result == null) {\n        final Resolver.RecordAdjust ra = (Resolver.RecordAdjust) action;\n        int defaultCount = ra.readerOrder.length - ra.firstDefault;\n        int count = 1 + ra.fieldActions.length + 3 * defaultCount;\n        final Symbol[] production = new Symbol[count];\n        result = Symbol.seq(production);\n        seen.put(action, result);\n        production[--count] = Symbol.fieldOrderAction(ra.readerOrder);\n\n        final Resolver.Action[] actions = ra.fieldActions;\n        for (Resolver.Action wfa : actions) {\n          production[--count] = generate(wfa, seen);\n        }\n        for (int i = ra.firstDefault; i < ra.readerOrder.length; i++) {\n          final Schema.Field rf = ra.readerOrder[i];\n          byte[] bb = getBinary(rf.schema(), Accessor.defaultValue(rf));\n          production[--count] = Symbol.defaultStartAction(bb);\n          production[--count] = simpleGen(rf.schema(), seen);\n          production[--count] = Symbol.DEFAULT_END_ACTION;\n        }\n      }\n      return result;\n    }\n\n    throw new IllegalArgumentException(\"Unrecognized Resolver.Action: \" + action);\n  }\n\n  private Symbol simpleGen(Schema s, Map<Object, Symbol> seen) {\n    switch (s.getType()) {\n    case NULL:\n      return Symbol.NULL;\n    case BOOLEAN:\n      return Symbol.BOOLEAN;\n    case INT:\n      return Symbol.INT;\n    case LONG:\n      return Symbol.LONG;\n    case FLOAT:\n      return Symbol.FLOAT;\n    case DOUBLE:\n      return Symbol.DOUBLE;\n    case BYTES:\n      return Symbol.BYTES;\n    case STRING:\n      return Symbol.STRING;\n\n    case FIXED:\n      return Symbol.seq(Symbol.intCheckAction(s.getFixedSize()), Symbol.FIXED);\n\n    case ENUM:\n      return Symbol.seq(Symbol.enumAdjustAction(s.getEnumSymbols().size(), null), Symbol.ENUM);\n\n    case ARRAY:\n      return Symbol.seq(Symbol.repeat(Symbol.ARRAY_END, simpleGen(s.getElementType(), seen)), Symbol.ARRAY_START);\n\n    case MAP:\n      return Symbol.seq(Symbol.repeat(Symbol.MAP_END, simpleGen(s.getValueType(), seen), Symbol.STRING),\n          Symbol.MAP_START);\n\n    case UNION: {\n      final List<Schema> subs = s.getTypes();\n      final Symbol[] symbols = new Symbol[subs.size()];\n      final String[] labels = new String[subs.size()];\n      int i = 0;\n      for (Schema b : s.getTypes()) {\n        symbols[i] = simpleGen(b, seen);\n        labels[i++] = b.getFullName();\n      }\n      return Symbol.seq(Symbol.alt(symbols, labels), Symbol.UNION);\n    }\n\n    case RECORD: {\n      Symbol result = seen.get(s);\n      if (result == null) {\n        final Symbol[] production = new Symbol[s.getFields().size() + 1];\n        result = Symbol.seq(production);\n        seen.put(s, result);\n        int i = production.length;\n        production[--i] = Symbol.fieldOrderAction(s.getFields().toArray(new Schema.Field[0]));\n        for (Field f : s.getFields()) {\n          production[--i] = simpleGen(f.schema(), seen);\n        }\n        // FieldOrderAction is needed even though the field-order hasn't changed,\n        // because the _reader_ doesn't know the field order hasn't changed, and\n        // thus it will probably call {@ ResolvingDecoder.fieldOrder} to find out.\n      }\n      return result;\n    }\n\n    default:\n      throw new IllegalArgumentException(\"Unexpected schema: \" + s);\n    }\n  }\n\n  private static EncoderFactory factory = new EncoderFactory().configureBufferSize(32);\n\n  /**\n   * Returns the Avro binary encoded version of <tt>n<\/tt> according to the schema\n   * <tt>s<\/tt>.\n   *\n   * @param s The schema for encoding\n   * @param n The Json node that has the value to be encoded.\n   * @return The binary encoded version of <tt>n<\/tt>.\n   * @throws IOException\n   */\n  private static byte[] getBinary(Schema s, JsonNode n) throws IOException {\n    ByteArrayOutputStream out = new ByteArrayOutputStream();\n    Encoder e = factory.binaryEncoder(out, null);\n    encode(e, s, n);\n    e.flush();\n    return out.toByteArray();\n  }\n\n  /**\n   * Encodes the given Json node <tt>n<\/tt> on to the encoder <tt>e<\/tt> according\n   * to the schema <tt>s<\/tt>.\n   *\n   * @param e The encoder to encode into.\n   * @param s The schema for the object being encoded.\n   * @param n The Json node to encode.\n   * @throws IOException\n   */\n  public static void encode(Encoder e, Schema s, JsonNode n) throws IOException {\n    switch (s.getType()) {\n    case RECORD:\n      for (Field f : s.getFields()) {\n        String name = f.name();\n        JsonNode v = n.get(name);\n        if (v == null) {\n          v = Accessor.defaultValue(f);\n        }\n        if (v == null) {\n          throw new AvroTypeException(\"No default value for: \" + name);\n        }\n        encode(e, f.schema(), v);\n      }\n      break;\n    case ENUM:\n      e.writeEnum(s.getEnumOrdinal(n.textValue()));\n      break;\n    case ARRAY:\n      e.writeArrayStart();\n      e.setItemCount(n.size());\n      Schema i = s.getElementType();\n      for (JsonNode node : n) {\n        e.startItem();\n        encode(e, i, node);\n      }\n      e.writeArrayEnd();\n      break;\n    case MAP:\n      e.writeMapStart();\n      e.setItemCount(n.size());\n      Schema v = s.getValueType();\n      for (Iterator<String> it = n.fieldNames(); it.hasNext();) {\n        e.startItem();\n        String key = it.next();\n        e.writeString(key);\n        encode(e, v, n.get(key));\n      }\n      e.writeMapEnd();\n      break;\n    case UNION:\n      e.writeIndex(0);\n      encode(e, s.getTypes().get(0), n);\n      break;\n    case FIXED:\n      if (!n.isTextual())\n        throw new AvroTypeException(\"Non-string default value for fixed: \" + n);\n      byte[] bb = n.textValue().getBytes(StandardCharsets.ISO_8859_1);\n      if (bb.length != s.getFixedSize()) {\n        bb = Arrays.copyOf(bb, s.getFixedSize());\n      }\n      e.writeFixed(bb);\n      break;\n    case STRING:\n      if (!n.isTextual())\n        throw new AvroTypeException(\"Non-string default value for string: \" + n);\n      e.writeString(n.textValue());\n      break;\n    case BYTES:\n      if (!n.isTextual())\n        throw new AvroTypeException(\"Non-string default value for bytes: \" + n);\n      e.writeBytes(n.textValue().getBytes(StandardCharsets.ISO_8859_1));\n      break;\n    case INT:\n      if (!n.isNumber())\n        throw new AvroTypeException(\"Non-numeric default value for int: \" + n);\n      e.writeInt(n.intValue());\n      break;\n    case LONG:\n      if (!n.isNumber())\n        throw new AvroTypeException(\"Non-numeric default value for long: \" + n);\n      e.writeLong(n.longValue());\n      break;\n    case FLOAT:\n      if (!n.isNumber())\n        throw new AvroTypeException(\"Non-numeric default value for float: \" + n);\n      e.writeFloat((float) n.doubleValue());\n      break;\n    case DOUBLE:\n      if (!n.isNumber())\n        throw new AvroTypeException(\"Non-numeric default value for double: \" + n);\n      e.writeDouble(n.doubleValue());\n      break;\n    case BOOLEAN:\n      if (!n.isBoolean())\n        throw new AvroTypeException(\"Non-boolean default for boolean: \" + n);\n      e.writeBoolean(n.booleanValue());\n      break;\n    case NULL:\n      if (!n.isNull())\n        throw new AvroTypeException(\"Non-null default value for null type: \" + n);\n      e.writeNull();\n      break;\n    }\n  }\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.avro.io.parsing;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.apache.avro.AvroTypeException;\nimport org.apache.avro.Resolver;\nimport org.apache.avro.Schema;\nimport org.apache.avro.Schema.Field;\nimport org.apache.avro.io.Encoder;\nimport org.apache.avro.io.EncoderFactory;\nimport org.apache.avro.util.internal.Accessor;\nimport org.apache.avro.util.internal.Accessor.ResolvingGrammarGeneratorAccessor;\n\nimport com.fasterxml.jackson.databind.JsonNode;\n\n/**\n * The class that generates a resolving grammar to resolve between two schemas.\n */\npublic class ResolvingGrammarGenerator extends ValidatingGrammarGenerator {\n\n  static {\n    Accessor.setAccessor(new ResolvingGrammarGeneratorAccessor() {\n      @Override\n      protected void encode(Encoder e, Schema s, JsonNode n) throws IOException {\n        ResolvingGrammarGenerator.encode(e, s, n);\n      }\n    });\n  }\n\n  /**\n   * Resolves the writer schema <tt>writer<\/tt> and the reader schema\n   * <tt>reader<\/tt> and returns the start symbol for the grammar generated.\n   *\n   * @param writer The schema used by the writer\n   * @param reader The schema used by the reader\n   * @return The start symbol for the resolving grammar\n   * @throws IOException\n   */\n  public final Symbol generate(Schema writer, Schema reader) throws IOException {\n    Resolver.Action r = Resolver.resolve(writer, reader);\n    return Symbol.root(generate(r, new HashMap<>()));\n  }\n\n  /**\n   * Takes a {@link Resolver.Action} for resolving two schemas and returns the\n   * start symbol for a grammar that implements that resolution. If the action is\n   * for a record and there's already a symbol for that record in <tt>seen<\/tt>,\n   * then that symbol is returned. Otherwise a new symbol is generated and\n   * returned.\n   *\n   * @param action The resolver to be implemented\n   * @param seen   The &lt;Action&gt; to symbol map of start symbols of resolving\n   *               grammars so far.\n   * @return The start symbol for the resolving grammar\n   * @throws IOException\n   */\n  private Symbol generate(Resolver.Action action, Map<Object, Symbol> seen) throws IOException {\n    if (action instanceof Resolver.DoNothing) {\n      return simpleGen(action.writer, seen);\n\n    } else if (action instanceof Resolver.ErrorAction) {\n      return Symbol.error(action.toString());\n\n    } else if (action instanceof Resolver.Skip) {\n      return Symbol.skipAction(simpleGen(action.writer, seen));\n\n    } else if (action instanceof Resolver.Promote) {\n      return Symbol.resolve(simpleGen(action.writer, seen), simpleGen(action.reader, seen));\n\n    } else if (action instanceof Resolver.ReaderUnion) {\n      Resolver.ReaderUnion ru = (Resolver.ReaderUnion) action;\n      Symbol s = generate(ru.actualAction, seen);\n      return Symbol.seq(Symbol.unionAdjustAction(ru.firstMatch, s), Symbol.UNION);\n\n    } else if (action.writer.getType() == Schema.Type.ARRAY) {\n      Symbol es = generate(((Resolver.Container) action).elementAction, seen);\n      return Symbol.seq(Symbol.repeat(Symbol.ARRAY_END, es), Symbol.ARRAY_START);\n\n    } else if (action.writer.getType() == Schema.Type.MAP) {\n      Symbol es = generate(((Resolver.Container) action).elementAction, seen);\n      return Symbol.seq(Symbol.repeat(Symbol.MAP_END, es, Symbol.STRING), Symbol.MAP_START);\n\n    } else if (action.writer.getType() == Schema.Type.UNION) {\n      if (((Resolver.WriterUnion) action).unionEquiv) {\n        return simpleGen(action.reader, seen);\n      }\n      Resolver.Action[] branches = ((Resolver.WriterUnion) action).actions;\n      Symbol[] symbols = new Symbol[branches.length];\n      String[] labels = new String[branches.length];\n      int i = 0;\n      for (Resolver.Action branch : branches) {\n        symbols[i] = generate(branch, seen);\n        labels[i] = action.writer.getTypes().get(i).getFullName();\n        i++;\n      }\n      return Symbol.seq(Symbol.alt(symbols, labels), Symbol.WRITER_UNION_ACTION);\n    } else if (action instanceof Resolver.EnumAdjust) {\n      Resolver.EnumAdjust e = (Resolver.EnumAdjust) action;\n      Object[] adjs = new Object[e.adjustments.length];\n      for (int i = 0; i < adjs.length; i++) {\n        adjs[i] = (0 <= e.adjustments[i] ? Integer.valueOf(e.adjustments[i])\n            : \"No match for \" + e.writer.getEnumSymbols().get(i));\n      }\n      return Symbol.seq(Symbol.enumAdjustAction(e.reader.getEnumSymbols().size(), adjs), Symbol.ENUM);\n\n    } else if (action instanceof Resolver.RecordAdjust) {\n      Symbol result = seen.get(action);\n      if (result == null) {\n        final Resolver.RecordAdjust ra = (Resolver.RecordAdjust) action;\n        int defaultCount = ra.readerOrder.length - ra.firstDefault;\n        int count = 1 + ra.fieldActions.length + 3 * defaultCount;\n        final Symbol[] production = new Symbol[count];\n        result = Symbol.seq(production);\n        seen.put(action, result);\n        production[--count] = Symbol.fieldOrderAction(ra.readerOrder);\n\n        final Resolver.Action[] actions = ra.fieldActions;\n        for (Resolver.Action wfa : actions) {\n          production[--count] = generate(wfa, seen);\n        }\n        for (int i = ra.firstDefault; i < ra.readerOrder.length; i++) {\n          final Schema.Field rf = ra.readerOrder[i];\n          byte[] bb = getBinary(rf.schema(), Accessor.defaultValue(rf));\n          production[--count] = Symbol.defaultStartAction(bb);\n          production[--count] = simpleGen(rf.schema(), seen);\n          production[--count] = Symbol.DEFAULT_END_ACTION;\n        }\n      }\n      return result;\n    }\n\n    throw new IllegalArgumentException(\"Unrecognized Resolver.Action: \" + action);\n  }\n\n  private Symbol simpleGen(Schema s, Map<Object, Symbol> seen) {\n    switch (s.getType()) {\n    case NULL:\n      return Symbol.NULL;\n    case BOOLEAN:\n      return Symbol.BOOLEAN;\n    case INT:\n      return Symbol.INT;\n    case LONG:\n      return Symbol.LONG;\n    case FLOAT:\n      return Symbol.FLOAT;\n    case DOUBLE:\n      return Symbol.DOUBLE;\n    case BYTES:\n      return Symbol.BYTES;\n    case STRING:\n      return Symbol.STRING;\n\n    case FIXED:\n      return Symbol.seq(Symbol.intCheckAction(s.getFixedSize()), Symbol.FIXED);\n\n    case ENUM:\n      return Symbol.seq(Symbol.enumAdjustAction(s.getEnumSymbols().size(), null), Symbol.ENUM);\n\n    case ARRAY:\n      return Symbol.seq(Symbol.repeat(Symbol.ARRAY_END, simpleGen(s.getElementType(), seen)), Symbol.ARRAY_START);\n\n    case MAP:\n      return Symbol.seq(Symbol.repeat(Symbol.MAP_END, simpleGen(s.getValueType(), seen), Symbol.STRING),\n          Symbol.MAP_START);\n\n    case UNION: {\n      final List<Schema> subs = s.getTypes();\n      final Symbol[] symbols = new Symbol[subs.size()];\n      final String[] labels = new String[subs.size()];\n      int i = 0;\n      for (Schema b : s.getTypes()) {\n        symbols[i] = simpleGen(b, seen);\n        labels[i++] = b.getFullName();\n      }\n      return Symbol.seq(Symbol.alt(symbols, labels), Symbol.UNION);\n    }\n\n    case RECORD: {\n      Symbol result = seen.get(s);\n      if (result == null) {\n        final Symbol[] production = new Symbol[s.getFields().size() + 1];\n        result = Symbol.seq(production);\n        seen.put(s, result);\n        int i = production.length;\n        production[--i] = Symbol.fieldOrderAction(s.getFields().toArray(new Schema.Field[0]));\n        for (Field f : s.getFields()) {\n          production[--i] = simpleGen(f.schema(), seen);\n        }\n        // FieldOrderAction is needed even though the field-order hasn't changed,\n        // because the _reader_ doesn't know the field order hasn't changed, and\n        // thus it will probably call {@ ResolvingDecoder.fieldOrder} to find out.\n      }\n      return result;\n    }\n\n    default:\n      throw new IllegalArgumentException(\"Unexpected schema: \" + s);\n    }\n  }\n\n  private static EncoderFactory factory = new EncoderFactory().configureBufferSize(32);\n\n  /**\n   * Returns the Avro binary encoded version of <tt>n<\/tt> according to the schema\n   * <tt>s<\/tt>.\n   *\n   * @param s The schema for encoding\n   * @param n The Json node that has the value to be encoded.\n   * @return The binary encoded version of <tt>n<\/tt>.\n   * @throws IOException\n   */\n  private static byte[] getBinary(Schema s, JsonNode n) throws IOException {\n    ByteArrayOutputStream out = new ByteArrayOutputStream();\n    Encoder e = factory.binaryEncoder(out, null);\n    encode(e, s, n);\n    e.flush();\n    return out.toByteArray();\n  }\n\n  /**\n   * Encodes the given Json node <tt>n<\/tt> on to the encoder <tt>e<\/tt> according\n   * to the schema <tt>s<\/tt>.\n   *\n   * @param e The encoder to encode into.\n   * @param s The schema for the object being encoded.\n   * @param n The Json node to encode.\n   * @throws IOException\n   */\n  public static void encode(Encoder e, Schema s, JsonNode n) throws IOException {\n    switch (s.getType()) {\n    case RECORD:\n      for (Field f : s.getFields()) {\n        String name = f.name();\n        JsonNode v = n.get(name);\n        if (v == null) {\n          v = Accessor.defaultValue(f);\n        }\n        if (v == null) {\n          throw new AvroTypeException(\"No default value for: \" + name);\n        }\n        encode(e, f.schema(), v);\n      }\n      break;\n    case ENUM:\n      e.writeEnum(s.getEnumOrdinal(n.textValue()));\n      break;\n    case ARRAY:\n      e.writeArrayStart();\n      e.setItemCount(n.size());\n      Schema i = s.getElementType();\n      for (JsonNode node : n) {\n        e.startItem();\n        encode(e, i, node);\n      }\n      e.writeArrayEnd();\n      break;\n    case MAP:\n      e.writeMapStart();\n      e.setItemCount(n.size());\n      Schema v = s.getValueType();\n      for (Iterator<String> it = n.fieldNames(); it.hasNext();) {\n        e.startItem();\n        String key = it.next();\n        e.writeString(key);\n        encode(e, v, n.get(key));\n      }\n      e.writeMapEnd();\n      break;\n    case UNION:\n      int correctIndex = 0;\n      List<Schema> innerTypes = s.getTypes();\n      while (correctIndex < innerTypes.size() && !isCompatible(innerTypes.get(correctIndex).getType(), n)) {\n        correctIndex++;\n      }\n      if (correctIndex >= innerTypes.size()) {\n        throw new AvroTypeException(\"Not compatible default value for union: \" + n);\n      }\n      e.writeIndex(correctIndex);\n      encode(e, innerTypes.get(correctIndex), n);\n      break;\n    case FIXED:\n      if (!n.isTextual())\n        throw new AvroTypeException(\"Non-string default value for fixed: \" + n);\n      byte[] bb = n.textValue().getBytes(StandardCharsets.ISO_8859_1);\n      if (bb.length != s.getFixedSize()) {\n        bb = Arrays.copyOf(bb, s.getFixedSize());\n      }\n      e.writeFixed(bb);\n      break;\n    case STRING:\n      if (!n.isTextual())\n        throw new AvroTypeException(\"Non-string default value for string: \" + n);\n      e.writeString(n.textValue());\n      break;\n    case BYTES:\n      if (!n.isTextual())\n        throw new AvroTypeException(\"Non-string default value for bytes: \" + n);\n      e.writeBytes(n.textValue().getBytes(StandardCharsets.ISO_8859_1));\n      break;\n    case INT:\n      if (!n.isNumber())\n        throw new AvroTypeException(\"Non-numeric default value for int: \" + n);\n      e.writeInt(n.intValue());\n      break;\n    case LONG:\n      if (!n.isNumber())\n        throw new AvroTypeException(\"Non-numeric default value for long: \" + n);\n      e.writeLong(n.longValue());\n      break;\n    case FLOAT:\n      if (!n.isNumber())\n        throw new AvroTypeException(\"Non-numeric default value for float: \" + n);\n      e.writeFloat((float) n.doubleValue());\n      break;\n    case DOUBLE:\n      if (!n.isNumber())\n        throw new AvroTypeException(\"Non-numeric default value for double: \" + n);\n      e.writeDouble(n.doubleValue());\n      break;\n    case BOOLEAN:\n      if (!n.isBoolean())\n        throw new AvroTypeException(\"Non-boolean default for boolean: \" + n);\n      e.writeBoolean(n.booleanValue());\n      break;\n    case NULL:\n      if (!n.isNull())\n        throw new AvroTypeException(\"Non-null default value for null type: \" + n);\n      e.writeNull();\n      break;\n    }\n  }\n\n  private static boolean isCompatible(Schema.Type stype, JsonNode value) {\n    switch (stype) {\n    case RECORD:\n    case ENUM:\n    case ARRAY:\n    case MAP:\n    case UNION:\n      return true;\n    case FIXED:\n    case STRING:\n    case BYTES:\n      return value.isTextual();\n    case INT:\n    case LONG:\n    case FLOAT:\n    case DOUBLE:\n      return value.isNumber();\n    case BOOLEAN:\n      return value.isBoolean();\n    case NULL:\n      return value.isNull();\n    }\n    return true;\n  }\n}\n","lineNo":295}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.avro.io.parsing;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.apache.avro.AvroTypeException;\nimport org.apache.avro.Resolver;\nimport org.apache.avro.Schema;\nimport org.apache.avro.Schema.Field;\nimport org.apache.avro.io.Encoder;\nimport org.apache.avro.io.EncoderFactory;\nimport org.apache.avro.util.internal.Accessor;\nimport org.apache.avro.util.internal.Accessor.ResolvingGrammarGeneratorAccessor;\n\nimport com.fasterxml.jackson.databind.JsonNode;\n\n/**\n * The class that generates a resolving grammar to resolve between two schemas.\n */\npublic class ResolvingGrammarGenerator extends ValidatingGrammarGenerator {\n\n  static {\n    Accessor.setAccessor(new ResolvingGrammarGeneratorAccessor() {\n      @Override\n      protected void encode(Encoder e, Schema s, JsonNode n) throws IOException {\n        ResolvingGrammarGenerator.encode(e, s, n);\n      }\n    });\n  }\n\n  /**\n   * Resolves the writer schema <tt>writer<\/tt> and the reader schema\n   * <tt>reader<\/tt> and returns the start symbol for the grammar generated.\n   *\n   * @param writer The schema used by the writer\n   * @param reader The schema used by the reader\n   * @return The start symbol for the resolving grammar\n   * @throws IOException\n   */\n  public final Symbol generate(Schema writer, Schema reader) throws IOException {\n    Resolver.Action r = Resolver.resolve(writer, reader);\n    return Symbol.root(generate(r, new HashMap<>()));\n  }\n\n  /**\n   * Takes a {@link Resolver.Action} for resolving two schemas and returns the\n   * start symbol for a grammar that implements that resolution. If the action is\n   * for a record and there's already a symbol for that record in <tt>seen<\/tt>,\n   * then that symbol is returned. Otherwise a new symbol is generated and\n   * returned.\n   *\n   * @param action The resolver to be implemented\n   * @param seen   The &lt;Action&gt; to symbol map of start symbols of resolving\n   *               grammars so far.\n   * @return The start symbol for the resolving grammar\n   * @throws IOException\n   */\n  private Symbol generate(Resolver.Action action, Map<Object, Symbol> seen) throws IOException {\n    if (action instanceof Resolver.DoNothing) {\n      return simpleGen(action.writer, seen);\n\n    } else if (action instanceof Resolver.ErrorAction) {\n      return Symbol.error(action.toString());\n\n    } else if (action instanceof Resolver.Skip) {\n      return Symbol.skipAction(simpleGen(action.writer, seen));\n\n    } else if (action instanceof Resolver.Promote) {\n      return Symbol.resolve(simpleGen(action.writer, seen), simpleGen(action.reader, seen));\n\n    } else if (action instanceof Resolver.ReaderUnion) {\n      Resolver.ReaderUnion ru = (Resolver.ReaderUnion) action;\n      Symbol s = generate(ru.actualAction, seen);\n      return Symbol.seq(Symbol.unionAdjustAction(ru.firstMatch, s), Symbol.UNION);\n\n    } else if (action.writer.getType() == Schema.Type.ARRAY) {\n      Symbol es = generate(((Resolver.Container) action).elementAction, seen);\n      return Symbol.seq(Symbol.repeat(Symbol.ARRAY_END, es), Symbol.ARRAY_START);\n\n    } else if (action.writer.getType() == Schema.Type.MAP) {\n      Symbol es = generate(((Resolver.Container) action).elementAction, seen);\n      return Symbol.seq(Symbol.repeat(Symbol.MAP_END, es, Symbol.STRING), Symbol.MAP_START);\n\n    } else if (action.writer.getType() == Schema.Type.UNION) {\n      if (((Resolver.WriterUnion) action).unionEquiv) {\n        return simpleGen(action.reader, seen);\n      }\n      Resolver.Action[] branches = ((Resolver.WriterUnion) action).actions;\n      Symbol[] symbols = new Symbol[branches.length];\n      String[] labels = new String[branches.length];\n      int i = 0;\n      for (Resolver.Action branch : branches) {\n        symbols[i] = generate(branch, seen);\n        labels[i] = action.writer.getTypes().get(i).getFullName();\n        i++;\n      }\n      return Symbol.seq(Symbol.alt(symbols, labels), Symbol.WRITER_UNION_ACTION);\n    } else if (action instanceof Resolver.EnumAdjust) {\n      Resolver.EnumAdjust e = (Resolver.EnumAdjust) action;\n      Object[] adjs = new Object[e.adjustments.length];\n      for (int i = 0; i < adjs.length; i++) {\n        adjs[i] = (0 <= e.adjustments[i] ? Integer.valueOf(e.adjustments[i])\n            : \"No match for \" + e.writer.getEnumSymbols().get(i));\n      }\n      return Symbol.seq(Symbol.enumAdjustAction(e.reader.getEnumSymbols().size(), adjs), Symbol.ENUM);\n\n    } else if (action instanceof Resolver.RecordAdjust) {\n      Symbol result = seen.get(action);\n      if (result == null) {\n        final Resolver.RecordAdjust ra = (Resolver.RecordAdjust) action;\n        int defaultCount = ra.readerOrder.length - ra.firstDefault;\n        int count = 1 + ra.fieldActions.length + 3 * defaultCount;\n        final Symbol[] production = new Symbol[count];\n        result = Symbol.seq(production);\n        seen.put(action, result);\n        production[--count] = Symbol.fieldOrderAction(ra.readerOrder);\n\n        final Resolver.Action[] actions = ra.fieldActions;\n        for (Resolver.Action wfa : actions) {\n          production[--count] = generate(wfa, seen);\n        }\n        for (int i = ra.firstDefault; i < ra.readerOrder.length; i++) {\n          final Schema.Field rf = ra.readerOrder[i];\n          byte[] bb = getBinary(rf.schema(), Accessor.defaultValue(rf));\n          production[--count] = Symbol.defaultStartAction(bb);\n          production[--count] = simpleGen(rf.schema(), seen);\n          production[--count] = Symbol.DEFAULT_END_ACTION;\n        }\n      }\n      return result;\n    }\n\n    throw new IllegalArgumentException(\"Unrecognized Resolver.Action: \" + action);\n  }\n\n  private Symbol simpleGen(Schema s, Map<Object, Symbol> seen) {\n    switch (s.getType()) {\n    case NULL:\n      return Symbol.NULL;\n    case BOOLEAN:\n      return Symbol.BOOLEAN;\n    case INT:\n      return Symbol.INT;\n    case LONG:\n      return Symbol.LONG;\n    case FLOAT:\n      return Symbol.FLOAT;\n    case DOUBLE:\n      return Symbol.DOUBLE;\n    case BYTES:\n      return Symbol.BYTES;\n    case STRING:\n      return Symbol.STRING;\n\n    case FIXED:\n      return Symbol.seq(Symbol.intCheckAction(s.getFixedSize()), Symbol.FIXED);\n\n    case ENUM:\n      return Symbol.seq(Symbol.enumAdjustAction(s.getEnumSymbols().size(), null), Symbol.ENUM);\n\n    case ARRAY:\n      return Symbol.seq(Symbol.repeat(Symbol.ARRAY_END, simpleGen(s.getElementType(), seen)), Symbol.ARRAY_START);\n\n    case MAP:\n      return Symbol.seq(Symbol.repeat(Symbol.MAP_END, simpleGen(s.getValueType(), seen), Symbol.STRING),\n          Symbol.MAP_START);\n\n    case UNION: {\n      final List<Schema> subs = s.getTypes();\n      final Symbol[] symbols = new Symbol[subs.size()];\n      final String[] labels = new String[subs.size()];\n      int i = 0;\n      for (Schema b : s.getTypes()) {\n        symbols[i] = simpleGen(b, seen);\n        labels[i++] = b.getFullName();\n      }\n      return Symbol.seq(Symbol.alt(symbols, labels), Symbol.UNION);\n    }\n\n    case RECORD: {\n      Symbol result = seen.get(s);\n      if (result == null) {\n        final Symbol[] production = new Symbol[s.getFields().size() + 1];\n        result = Symbol.seq(production);\n        seen.put(s, result);\n        int i = production.length;\n        production[--i] = Symbol.fieldOrderAction(s.getFields().toArray(new Schema.Field[0]));\n        for (Field f : s.getFields()) {\n          production[--i] = simpleGen(f.schema(), seen);\n        }\n        // FieldOrderAction is needed even though the field-order hasn't changed,\n        // because the _reader_ doesn't know the field order hasn't changed, and\n        // thus it will probably call {@ ResolvingDecoder.fieldOrder} to find out.\n      }\n      return result;\n    }\n\n    default:\n      throw new IllegalArgumentException(\"Unexpected schema: \" + s);\n    }\n  }\n\n  private static EncoderFactory factory = new EncoderFactory().configureBufferSize(32);\n\n  /**\n   * Returns the Avro binary encoded version of <tt>n<\/tt> according to the schema\n   * <tt>s<\/tt>.\n   *\n   * @param s The schema for encoding\n   * @param n The Json node that has the value to be encoded.\n   * @return The binary encoded version of <tt>n<\/tt>.\n   * @throws IOException\n   */\n  private static byte[] getBinary(Schema s, JsonNode n) throws IOException {\n    ByteArrayOutputStream out = new ByteArrayOutputStream();\n    Encoder e = factory.binaryEncoder(out, null);\n    encode(e, s, n);\n    e.flush();\n    return out.toByteArray();\n  }\n\n  /**\n   * Encodes the given Json node <tt>n<\/tt> on to the encoder <tt>e<\/tt> according\n   * to the schema <tt>s<\/tt>.\n   *\n   * @param e The encoder to encode into.\n   * @param s The schema for the object being encoded.\n   * @param n The Json node to encode.\n   * @throws IOException\n   */\n  public static void encode(Encoder e, Schema s, JsonNode n) throws IOException {\n    switch (s.getType()) {\n    case RECORD:\n      for (Field f : s.getFields()) {\n        String name = f.name();\n        JsonNode v = n.get(name);\n        if (v == null) {\n          v = Accessor.defaultValue(f);\n        }\n        if (v == null) {\n          throw new AvroTypeException(\"No default value for: \" + name);\n        }\n        encode(e, f.schema(), v);\n      }\n      break;\n    case ENUM:\n      e.writeEnum(s.getEnumOrdinal(n.textValue()));\n      break;\n    case ARRAY:\n      e.writeArrayStart();\n      e.setItemCount(n.size());\n      Schema i = s.getElementType();\n      for (JsonNode node : n) {\n        e.startItem();\n        encode(e, i, node);\n      }\n      e.writeArrayEnd();\n      break;\n    case MAP:\n      e.writeMapStart();\n      e.setItemCount(n.size());\n      Schema v = s.getValueType();\n      for (Iterator<String> it = n.fieldNames(); it.hasNext();) {\n        e.startItem();\n        String key = it.next();\n        e.writeString(key);\n        encode(e, v, n.get(key));\n      }\n      e.writeMapEnd();\n      break;\n    case UNION:\n      e.writeIndex(0);\n      encode(e, s.getTypes().get(0), n);\n      break;\n    case FIXED:\n      if (!n.isTextual())\n        throw new AvroTypeException(\"Non-string default value for fixed: \" + n);\n      byte[] bb = n.textValue().getBytes(StandardCharsets.ISO_8859_1);\n      if (bb.length != s.getFixedSize()) {\n        bb = Arrays.copyOf(bb, s.getFixedSize());\n      }\n      e.writeFixed(bb);\n      break;\n    case STRING:\n      if (!n.isTextual())\n        throw new AvroTypeException(\"Non-string default value for string: \" + n);\n      e.writeString(n.textValue());\n      break;\n    case BYTES:\n      if (!n.isTextual())\n        throw new AvroTypeException(\"Non-string default value for bytes: \" + n);\n      e.writeBytes(n.textValue().getBytes(StandardCharsets.ISO_8859_1));\n      break;\n    case INT:\n      if (!n.isNumber())\n        throw new AvroTypeException(\"Non-numeric default value for int: \" + n);\n      e.writeInt(n.intValue());\n      break;\n    case LONG:\n      if (!n.isNumber())\n        throw new AvroTypeException(\"Non-numeric default value for long: \" + n);\n      e.writeLong(n.longValue());\n      break;\n    case FLOAT:\n      if (!n.isNumber())\n        throw new AvroTypeException(\"Non-numeric default value for float: \" + n);\n      e.writeFloat((float) n.doubleValue());\n      break;\n    case DOUBLE:\n      if (!n.isNumber())\n        throw new AvroTypeException(\"Non-numeric default value for double: \" + n);\n      e.writeDouble(n.doubleValue());\n      break;\n    case BOOLEAN:\n      if (!n.isBoolean())\n        throw new AvroTypeException(\"Non-boolean default for boolean: \" + n);\n      e.writeBoolean(n.booleanValue());\n      break;\n    case NULL:\n      if (!n.isNull())\n        throw new AvroTypeException(\"Non-null default value for null type: \" + n);\n      e.writeNull();\n      break;\n    }\n  }\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.avro.io.parsing;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.apache.avro.AvroTypeException;\nimport org.apache.avro.Resolver;\nimport org.apache.avro.Schema;\nimport org.apache.avro.Schema.Field;\nimport org.apache.avro.io.Encoder;\nimport org.apache.avro.io.EncoderFactory;\nimport org.apache.avro.util.internal.Accessor;\nimport org.apache.avro.util.internal.Accessor.ResolvingGrammarGeneratorAccessor;\n\nimport com.fasterxml.jackson.databind.JsonNode;\n\n/**\n * The class that generates a resolving grammar to resolve between two schemas.\n */\npublic class ResolvingGrammarGenerator extends ValidatingGrammarGenerator {\n\n  static {\n    Accessor.setAccessor(new ResolvingGrammarGeneratorAccessor() {\n      @Override\n      protected void encode(Encoder e, Schema s, JsonNode n) throws IOException {\n        ResolvingGrammarGenerator.encode(e, s, n);\n      }\n    });\n  }\n\n  /**\n   * Resolves the writer schema <tt>writer<\/tt> and the reader schema\n   * <tt>reader<\/tt> and returns the start symbol for the grammar generated.\n   *\n   * @param writer The schema used by the writer\n   * @param reader The schema used by the reader\n   * @return The start symbol for the resolving grammar\n   * @throws IOException\n   */\n  public final Symbol generate(Schema writer, Schema reader) throws IOException {\n    Resolver.Action r = Resolver.resolve(writer, reader);\n    return Symbol.root(generate(r, new HashMap<>()));\n  }\n\n  /**\n   * Takes a {@link Resolver.Action} for resolving two schemas and returns the\n   * start symbol for a grammar that implements that resolution. If the action is\n   * for a record and there's already a symbol for that record in <tt>seen<\/tt>,\n   * then that symbol is returned. Otherwise a new symbol is generated and\n   * returned.\n   *\n   * @param action The resolver to be implemented\n   * @param seen   The &lt;Action&gt; to symbol map of start symbols of resolving\n   *               grammars so far.\n   * @return The start symbol for the resolving grammar\n   * @throws IOException\n   */\n  private Symbol generate(Resolver.Action action, Map<Object, Symbol> seen) throws IOException {\n    if (action instanceof Resolver.DoNothing) {\n      return simpleGen(action.writer, seen);\n\n    } else if (action instanceof Resolver.ErrorAction) {\n      return Symbol.error(action.toString());\n\n    } else if (action instanceof Resolver.Skip) {\n      return Symbol.skipAction(simpleGen(action.writer, seen));\n\n    } else if (action instanceof Resolver.Promote) {\n      return Symbol.resolve(simpleGen(action.writer, seen), simpleGen(action.reader, seen));\n\n    } else if (action instanceof Resolver.ReaderUnion) {\n      Resolver.ReaderUnion ru = (Resolver.ReaderUnion) action;\n      Symbol s = generate(ru.actualAction, seen);\n      return Symbol.seq(Symbol.unionAdjustAction(ru.firstMatch, s), Symbol.UNION);\n\n    } else if (action.writer.getType() == Schema.Type.ARRAY) {\n      Symbol es = generate(((Resolver.Container) action).elementAction, seen);\n      return Symbol.seq(Symbol.repeat(Symbol.ARRAY_END, es), Symbol.ARRAY_START);\n\n    } else if (action.writer.getType() == Schema.Type.MAP) {\n      Symbol es = generate(((Resolver.Container) action).elementAction, seen);\n      return Symbol.seq(Symbol.repeat(Symbol.MAP_END, es, Symbol.STRING), Symbol.MAP_START);\n\n    } else if (action.writer.getType() == Schema.Type.UNION) {\n      if (((Resolver.WriterUnion) action).unionEquiv) {\n        return simpleGen(action.reader, seen);\n      }\n      Resolver.Action[] branches = ((Resolver.WriterUnion) action).actions;\n      Symbol[] symbols = new Symbol[branches.length];\n      String[] labels = new String[branches.length];\n      int i = 0;\n      for (Resolver.Action branch : branches) {\n        symbols[i] = generate(branch, seen);\n        labels[i] = action.writer.getTypes().get(i).getFullName();\n        i++;\n      }\n      return Symbol.seq(Symbol.alt(symbols, labels), Symbol.WRITER_UNION_ACTION);\n    } else if (action instanceof Resolver.EnumAdjust) {\n      Resolver.EnumAdjust e = (Resolver.EnumAdjust) action;\n      Object[] adjs = new Object[e.adjustments.length];\n      for (int i = 0; i < adjs.length; i++) {\n        adjs[i] = (0 <= e.adjustments[i] ? Integer.valueOf(e.adjustments[i])\n            : \"No match for \" + e.writer.getEnumSymbols().get(i));\n      }\n      return Symbol.seq(Symbol.enumAdjustAction(e.reader.getEnumSymbols().size(), adjs), Symbol.ENUM);\n\n    } else if (action instanceof Resolver.RecordAdjust) {\n      Symbol result = seen.get(action);\n      if (result == null) {\n        final Resolver.RecordAdjust ra = (Resolver.RecordAdjust) action;\n        int defaultCount = ra.readerOrder.length - ra.firstDefault;\n        int count = 1 + ra.fieldActions.length + 3 * defaultCount;\n        final Symbol[] production = new Symbol[count];\n        result = Symbol.seq(production);\n        seen.put(action, result);\n        production[--count] = Symbol.fieldOrderAction(ra.readerOrder);\n\n        final Resolver.Action[] actions = ra.fieldActions;\n        for (Resolver.Action wfa : actions) {\n          production[--count] = generate(wfa, seen);\n        }\n        for (int i = ra.firstDefault; i < ra.readerOrder.length; i++) {\n          final Schema.Field rf = ra.readerOrder[i];\n          byte[] bb = getBinary(rf.schema(), Accessor.defaultValue(rf));\n          production[--count] = Symbol.defaultStartAction(bb);\n          production[--count] = simpleGen(rf.schema(), seen);\n          production[--count] = Symbol.DEFAULT_END_ACTION;\n        }\n      }\n      return result;\n    }\n\n    throw new IllegalArgumentException(\"Unrecognized Resolver.Action: \" + action);\n  }\n\n  private Symbol simpleGen(Schema s, Map<Object, Symbol> seen) {\n    switch (s.getType()) {\n    case NULL:\n      return Symbol.NULL;\n    case BOOLEAN:\n      return Symbol.BOOLEAN;\n    case INT:\n      return Symbol.INT;\n    case LONG:\n      return Symbol.LONG;\n    case FLOAT:\n      return Symbol.FLOAT;\n    case DOUBLE:\n      return Symbol.DOUBLE;\n    case BYTES:\n      return Symbol.BYTES;\n    case STRING:\n      return Symbol.STRING;\n\n    case FIXED:\n      return Symbol.seq(Symbol.intCheckAction(s.getFixedSize()), Symbol.FIXED);\n\n    case ENUM:\n      return Symbol.seq(Symbol.enumAdjustAction(s.getEnumSymbols().size(), null), Symbol.ENUM);\n\n    case ARRAY:\n      return Symbol.seq(Symbol.repeat(Symbol.ARRAY_END, simpleGen(s.getElementType(), seen)), Symbol.ARRAY_START);\n\n    case MAP:\n      return Symbol.seq(Symbol.repeat(Symbol.MAP_END, simpleGen(s.getValueType(), seen), Symbol.STRING),\n          Symbol.MAP_START);\n\n    case UNION: {\n      final List<Schema> subs = s.getTypes();\n      final Symbol[] symbols = new Symbol[subs.size()];\n      final String[] labels = new String[subs.size()];\n      int i = 0;\n      for (Schema b : s.getTypes()) {\n        symbols[i] = simpleGen(b, seen);\n        labels[i++] = b.getFullName();\n      }\n      return Symbol.seq(Symbol.alt(symbols, labels), Symbol.UNION);\n    }\n\n    case RECORD: {\n      Symbol result = seen.get(s);\n      if (result == null) {\n        final Symbol[] production = new Symbol[s.getFields().size() + 1];\n        result = Symbol.seq(production);\n        seen.put(s, result);\n        int i = production.length;\n        production[--i] = Symbol.fieldOrderAction(s.getFields().toArray(new Schema.Field[0]));\n        for (Field f : s.getFields()) {\n          production[--i] = simpleGen(f.schema(), seen);\n        }\n        // FieldOrderAction is needed even though the field-order hasn't changed,\n        // because the _reader_ doesn't know the field order hasn't changed, and\n        // thus it will probably call {@ ResolvingDecoder.fieldOrder} to find out.\n      }\n      return result;\n    }\n\n    default:\n      throw new IllegalArgumentException(\"Unexpected schema: \" + s);\n    }\n  }\n\n  private static EncoderFactory factory = new EncoderFactory().configureBufferSize(32);\n\n  /**\n   * Returns the Avro binary encoded version of <tt>n<\/tt> according to the schema\n   * <tt>s<\/tt>.\n   *\n   * @param s The schema for encoding\n   * @param n The Json node that has the value to be encoded.\n   * @return The binary encoded version of <tt>n<\/tt>.\n   * @throws IOException\n   */\n  private static byte[] getBinary(Schema s, JsonNode n) throws IOException {\n    ByteArrayOutputStream out = new ByteArrayOutputStream();\n    Encoder e = factory.binaryEncoder(out, null);\n    encode(e, s, n);\n    e.flush();\n    return out.toByteArray();\n  }\n\n  /**\n   * Encodes the given Json node <tt>n<\/tt> on to the encoder <tt>e<\/tt> according\n   * to the schema <tt>s<\/tt>.\n   *\n   * @param e The encoder to encode into.\n   * @param s The schema for the object being encoded.\n   * @param n The Json node to encode.\n   * @throws IOException\n   */\n  public static void encode(Encoder e, Schema s, JsonNode n) throws IOException {\n    switch (s.getType()) {\n    case RECORD:\n      for (Field f : s.getFields()) {\n        String name = f.name();\n        JsonNode v = n.get(name);\n        if (v == null) {\n          v = Accessor.defaultValue(f);\n        }\n        if (v == null) {\n          throw new AvroTypeException(\"No default value for: \" + name);\n        }\n        encode(e, f.schema(), v);\n      }\n      break;\n    case ENUM:\n      e.writeEnum(s.getEnumOrdinal(n.textValue()));\n      break;\n    case ARRAY:\n      e.writeArrayStart();\n      e.setItemCount(n.size());\n      Schema i = s.getElementType();\n      for (JsonNode node : n) {\n        e.startItem();\n        encode(e, i, node);\n      }\n      e.writeArrayEnd();\n      break;\n    case MAP:\n      e.writeMapStart();\n      e.setItemCount(n.size());\n      Schema v = s.getValueType();\n      for (Iterator<String> it = n.fieldNames(); it.hasNext();) {\n        e.startItem();\n        String key = it.next();\n        e.writeString(key);\n        encode(e, v, n.get(key));\n      }\n      e.writeMapEnd();\n      break;\n    case UNION:\n      int correctIndex = 0;\n      List<Schema> innerTypes = s.getTypes();\n      while (correctIndex < innerTypes.size() && !isCompatible(innerTypes.get(correctIndex).getType(), n)) {\n        correctIndex++;\n      }\n      if (correctIndex >= innerTypes.size()) {\n        throw new AvroTypeException(\"Not compatible default value for union: \" + n);\n      }\n      e.writeIndex(correctIndex);\n      encode(e, innerTypes.get(correctIndex), n);\n      break;\n    case FIXED:\n      if (!n.isTextual())\n        throw new AvroTypeException(\"Non-string default value for fixed: \" + n);\n      byte[] bb = n.textValue().getBytes(StandardCharsets.ISO_8859_1);\n      if (bb.length != s.getFixedSize()) {\n        bb = Arrays.copyOf(bb, s.getFixedSize());\n      }\n      e.writeFixed(bb);\n      break;\n    case STRING:\n      if (!n.isTextual())\n        throw new AvroTypeException(\"Non-string default value for string: \" + n);\n      e.writeString(n.textValue());\n      break;\n    case BYTES:\n      if (!n.isTextual())\n        throw new AvroTypeException(\"Non-string default value for bytes: \" + n);\n      e.writeBytes(n.textValue().getBytes(StandardCharsets.ISO_8859_1));\n      break;\n    case INT:\n      if (!n.isNumber())\n        throw new AvroTypeException(\"Non-numeric default value for int: \" + n);\n      e.writeInt(n.intValue());\n      break;\n    case LONG:\n      if (!n.isNumber())\n        throw new AvroTypeException(\"Non-numeric default value for long: \" + n);\n      e.writeLong(n.longValue());\n      break;\n    case FLOAT:\n      if (!n.isNumber())\n        throw new AvroTypeException(\"Non-numeric default value for float: \" + n);\n      e.writeFloat((float) n.doubleValue());\n      break;\n    case DOUBLE:\n      if (!n.isNumber())\n        throw new AvroTypeException(\"Non-numeric default value for double: \" + n);\n      e.writeDouble(n.doubleValue());\n      break;\n    case BOOLEAN:\n      if (!n.isBoolean())\n        throw new AvroTypeException(\"Non-boolean default for boolean: \" + n);\n      e.writeBoolean(n.booleanValue());\n      break;\n    case NULL:\n      if (!n.isNull())\n        throw new AvroTypeException(\"Non-null default value for null type: \" + n);\n      e.writeNull();\n      break;\n    }\n  }\n\n  private static boolean isCompatible(Schema.Type stype, JsonNode value) {\n    switch (stype) {\n    case RECORD:\n    case ENUM:\n    case ARRAY:\n    case MAP:\n    case UNION:\n      return true;\n    case FIXED:\n    case STRING:\n    case BYTES:\n      return value.isTextual();\n    case INT:\n    case LONG:\n    case FLOAT:\n    case DOUBLE:\n      return value.isNumber();\n    case BOOLEAN:\n      return value.isBoolean();\n    case NULL:\n      return value.isNull();\n    }\n    return true;\n  }\n}\n","lineNo":296}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.avro;\n\nimport java.math.RoundingMode;\nimport org.apache.avro.generic.GenericData;\nimport org.apache.avro.generic.GenericEnumSymbol;\nimport org.apache.avro.generic.GenericFixed;\nimport org.apache.avro.generic.IndexedRecord;\n\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.nio.ByteBuffer;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.UUID;\n\npublic class Conversions {\n\n  public static class UUIDConversion extends Conversion<UUID> {\n    @Override\n    public Class<UUID> getConvertedType() {\n      return UUID.class;\n    }\n\n    @Override\n    public Schema getRecommendedSchema() {\n      return LogicalTypes.uuid().addToSchema(Schema.create(Schema.Type.STRING));\n    }\n\n    @Override\n    public String getLogicalTypeName() {\n      return \"uuid\";\n    }\n\n    @Override\n    public UUID fromCharSequence(CharSequence value, Schema schema, LogicalType type) {\n      return UUID.fromString(value.toString());\n    }\n\n    @Override\n    public CharSequence toCharSequence(UUID value, Schema schema, LogicalType type) {\n      return value.toString();\n    }\n  }\n\n  public static class DecimalConversion extends Conversion<BigDecimal> {\n    @Override\n    public Class<BigDecimal> getConvertedType() {\n      return BigDecimal.class;\n    }\n\n    @Override\n    public Schema getRecommendedSchema() {\n      throw new UnsupportedOperationException(\"No recommended schema for decimal (scale is required)\");\n    }\n\n    @Override\n    public String getLogicalTypeName() {\n      return \"decimal\";\n    }\n\n    @Override\n    public BigDecimal fromBytes(ByteBuffer value, Schema schema, LogicalType type) {\n      int scale = ((LogicalTypes.Decimal) type).getScale();\n      // always copy the bytes out because BigInteger has no offset/length ctor\n      byte[] bytes = new byte[value.remaining()];\n      value.duplicate().get(bytes);\n      return new BigDecimal(new BigInteger(bytes), scale);\n    }\n\n    @Override\n    public ByteBuffer toBytes(BigDecimal value, Schema schema, LogicalType type) {\n      value = validate((LogicalTypes.Decimal) type, value);\n\n      return ByteBuffer.wrap(value.unscaledValue().toByteArray());\n    }\n\n    @Override\n    public BigDecimal fromFixed(GenericFixed value, Schema schema, LogicalType type) {\n      int scale = ((LogicalTypes.Decimal) type).getScale();\n      return new BigDecimal(new BigInteger(value.bytes()), scale);\n    }\n\n    @Override\n    public GenericFixed toFixed(BigDecimal value, Schema schema, LogicalType type) {\n      value = validate((LogicalTypes.Decimal) type, value);\n\n      byte fillByte = (byte) (value.signum() < 0 ? 0xFF : 0x00);\n      byte[] unscaled = value.unscaledValue().toByteArray();\n      byte[] bytes = new byte[schema.getFixedSize()];\n      int offset = bytes.length - unscaled.length;\n\n      // Fill the front of the array and copy remaining with unscaled values\n      Arrays.fill(bytes, 0, offset, fillByte);\n      System.arraycopy(unscaled, 0, bytes, offset, bytes.length - offset);\n\n      return new GenericData.Fixed(schema, bytes);\n    }\n\n    private static BigDecimal validate(final LogicalTypes.Decimal decimal, BigDecimal value) {\n      final int scale = decimal.getScale();\n      final int valueScale = value.scale();\n\n      boolean scaleAdjusted = false;\n      if (valueScale != scale) {\n        try {\n          value = value.setScale(scale, RoundingMode.UNNECESSARY);\n          scaleAdjusted = true;\n        } catch (ArithmeticException aex) {\n          throw new AvroTypeException(\n              \"Cannot encode decimal with scale \" + valueScale + \" as scale \" + scale + \" without rounding\");\n        }\n      }\n\n      int precision = decimal.getPrecision();\n      int valuePrecision = value.precision();\n      if (valuePrecision > precision) {\n        if (scaleAdjusted) {\n          throw new AvroTypeException(\"Cannot encode decimal with precision \" + valuePrecision + \" as max precision \"\n              + precision + \". This is after safely adjusting scale from \" + valueScale + \" to required \" + scale);\n        } else {\n          throw new AvroTypeException(\n              \"Cannot encode decimal with precision \" + valuePrecision + \" as max precision \" + precision);\n        }\n      }\n\n      return value;\n    }\n  }\n\n  /**\n   * Convert a underlying representation of a logical type (such as a ByteBuffer)\n   * to a higher level object (such as a BigDecimal).\n   *\n   * @param datum      The object to be converted.\n   * @param schema     The schema of datum. Cannot be null if datum is not null.\n   * @param type       The {@link org.apache.avro.LogicalType} of datum. Cannot be\n   *                   null if datum is not null.\n   * @param conversion The tool used to finish the conversion. Cannot be null if\n   *                   datum is not null.\n   * @return The result object, which is a high level object of the logical type.\n   *         If a null datum is passed in, a null value will be returned.\n   * @throws IllegalArgumentException if a null schema, type or conversion is\n   *                                  passed in while datum is not null.\n   */\n  public static Object convertToLogicalType(Object datum, Schema schema, LogicalType type, Conversion<?> conversion) {\n    if (datum == null) {\n      return null;\n    }\n\n    if (schema == null || type == null || conversion == null) {\n      throw new IllegalArgumentException(\"Parameters cannot be null! Parameter values:\"\n          + Arrays.deepToString(new Object[] { datum, schema, type, conversion }));\n    }\n\n    try {\n      switch (schema.getType()) {\n      case RECORD:\n        return conversion.fromRecord((IndexedRecord) datum, schema, type);\n      case ENUM:\n        return conversion.fromEnumSymbol((GenericEnumSymbol) datum, schema, type);\n      case ARRAY:\n        return conversion.fromArray((Collection) datum, schema, type);\n      case MAP:\n        return conversion.fromMap((Map<?, ?>) datum, schema, type);\n      case FIXED:\n        return conversion.fromFixed((GenericFixed) datum, schema, type);\n      case STRING:\n        return conversion.fromCharSequence((CharSequence) datum, schema, type);\n      case BYTES:\n        return conversion.fromBytes((ByteBuffer) datum, schema, type);\n      case INT:\n        return conversion.fromInt((Integer) datum, schema, type);\n      case LONG:\n        return conversion.fromLong((Long) datum, schema, type);\n      case FLOAT:\n        return conversion.fromFloat((Float) datum, schema, type);\n      case DOUBLE:\n        return conversion.fromDouble((Double) datum, schema, type);\n      case BOOLEAN:\n        return conversion.fromBoolean((Boolean) datum, schema, type);\n      }\n      return datum;\n    } catch (ClassCastException e) {\n      throw new AvroRuntimeException(\n          \"Cannot convert \" + datum + \":\" + datum.getClass().getSimpleName() + \": expected generic type\", e);\n    }\n  }\n\n  /**\n   * Convert a high level representation of a logical type (such as a BigDecimal)\n   * to the its underlying representation object (such as a ByteBuffer)\n   *\n   * @param datum      The object to be converted.\n   * @param schema     The schema of datum. Cannot be null if datum is not null.\n   * @param type       The {@link org.apache.avro.LogicalType} of datum. Cannot be\n   *                   null if datum is not null.\n   * @param conversion The tool used to finish the conversion. Cannot be null if\n   *                   datum is not null.\n   * @return The result object, which is an underlying representation object of\n   *         the logical type. If the input param datum is null, a null value will\n   *         be returned.\n   * @throws IllegalArgumentException if a null schema, type or conversion is\n   *                                  passed in while datum is not null.\n   */\n  public static <T> Object convertToRawType(Object datum, Schema schema, LogicalType type, Conversion<T> conversion) {\n    if (datum == null) {\n      return null;\n    }\n\n    if (schema == null || type == null || conversion == null) {\n      throw new IllegalArgumentException(\"Parameters cannot be null! Parameter values:\"\n          + Arrays.deepToString(new Object[] { datum, schema, type, conversion }));\n    }\n\n    try {\n      Class<T> fromClass = conversion.getConvertedType();\n      switch (schema.getType()) {\n      case RECORD:\n        return conversion.toRecord(fromClass.cast(datum), schema, type);\n      case ENUM:\n        return conversion.toEnumSymbol(fromClass.cast(datum), schema, type);\n      case ARRAY:\n        return conversion.toArray(fromClass.cast(datum), schema, type);\n      case MAP:\n        return conversion.toMap(fromClass.cast(datum), schema, type);\n      case FIXED:\n        return conversion.toFixed(fromClass.cast(datum), schema, type);\n      case STRING:\n        return conversion.toCharSequence(fromClass.cast(datum), schema, type);\n      case BYTES:\n        return conversion.toBytes(fromClass.cast(datum), schema, type);\n      case INT:\n        return conversion.toInt(fromClass.cast(datum), schema, type);\n      case LONG:\n        return conversion.toLong(fromClass.cast(datum), schema, type);\n      case FLOAT:\n        return conversion.toFloat(fromClass.cast(datum), schema, type);\n      case DOUBLE:\n        return conversion.toDouble(fromClass.cast(datum), schema, type);\n      case BOOLEAN:\n        return conversion.toBoolean(fromClass.cast(datum), schema, type);\n      }\n      return datum;\n    } catch (ClassCastException e) {\n      throw new AvroRuntimeException(\n          \"Cannot convert \" + datum + \":\" + datum.getClass().getSimpleName() + \": expected logical type\", e);\n    }\n  }\n\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.avro;\n\nimport java.math.RoundingMode;\nimport org.apache.avro.generic.GenericData;\nimport org.apache.avro.generic.GenericEnumSymbol;\nimport org.apache.avro.generic.GenericFixed;\nimport org.apache.avro.generic.IndexedRecord;\n\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.nio.ByteBuffer;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.UUID;\n\npublic class Conversions {\n\n  public static class UUIDConversion extends Conversion<UUID> {\n    @Override\n    public Class<UUID> getConvertedType() {\n      return UUID.class;\n    }\n\n    @Override\n    public Schema getRecommendedSchema() {\n      return LogicalTypes.uuid().addToSchema(Schema.create(Schema.Type.STRING));\n    }\n\n    @Override\n    public String getLogicalTypeName() {\n      return \"uuid\";\n    }\n\n    @Override\n    public UUID fromCharSequence(CharSequence value, Schema schema, LogicalType type) {\n      return UUID.fromString(value.toString());\n    }\n\n    @Override\n    public CharSequence toCharSequence(UUID value, Schema schema, LogicalType type) {\n      return value.toString();\n    }\n  }\n\n  public static class DecimalConversion extends Conversion<BigDecimal> {\n    @Override\n    public Class<BigDecimal> getConvertedType() {\n      return BigDecimal.class;\n    }\n\n    @Override\n    public Schema getRecommendedSchema() {\n      throw new UnsupportedOperationException(\"No recommended schema for decimal (scale is required)\");\n    }\n\n    @Override\n    public String getLogicalTypeName() {\n      return \"decimal\";\n    }\n\n    @Override\n    public BigDecimal fromBytes(ByteBuffer value, Schema schema, LogicalType type) {\n      int scale = ((LogicalTypes.Decimal) type).getScale();\n      // always copy the bytes out because BigInteger has no offset/length ctor\n      byte[] bytes = new byte[value.remaining()];\n      value.duplicate().get(bytes);\n      return new BigDecimal(new BigInteger(bytes), scale);\n    }\n\n    @Override\n    public ByteBuffer toBytes(BigDecimal value, Schema schema, LogicalType type) {\n      value = validate((LogicalTypes.Decimal) type, value);\n\n      return ByteBuffer.wrap(value.unscaledValue().toByteArray());\n    }\n\n    @Override\n    public BigDecimal fromFixed(GenericFixed value, Schema schema, LogicalType type) {\n      int scale = ((LogicalTypes.Decimal) type).getScale();\n      return new BigDecimal(new BigInteger(value.bytes()), scale);\n    }\n\n    @Override\n    public GenericFixed toFixed(BigDecimal value, Schema schema, LogicalType type) {\n      value = validate((LogicalTypes.Decimal) type, value);\n\n      byte fillByte = (byte) (value.signum() < 0 ? 0xFF : 0x00);\n      byte[] unscaled = value.unscaledValue().toByteArray();\n      byte[] bytes = new byte[schema.getFixedSize()];\n      int unscaledLength = unscaled.length;\n      int offset = bytes.length - unscaledLength;\n\n      // Fill the front with the filler and copy the unscaled value into the remainder\n      Arrays.fill(bytes, 0, offset, fillByte);\n      System.arraycopy(unscaled, 0, bytes, offset, unscaledLength);\n\n      return new GenericData.Fixed(schema, bytes);\n    }\n\n    private static BigDecimal validate(final LogicalTypes.Decimal decimal, BigDecimal value) {\n      final int scale = decimal.getScale();\n      final int valueScale = value.scale();\n\n      boolean scaleAdjusted = false;\n      if (valueScale != scale) {\n        try {\n          value = value.setScale(scale, RoundingMode.UNNECESSARY);\n          scaleAdjusted = true;\n        } catch (ArithmeticException aex) {\n          throw new AvroTypeException(\n              \"Cannot encode decimal with scale \" + valueScale + \" as scale \" + scale + \" without rounding\");\n        }\n      }\n\n      int precision = decimal.getPrecision();\n      int valuePrecision = value.precision();\n      if (valuePrecision > precision) {\n        if (scaleAdjusted) {\n          throw new AvroTypeException(\"Cannot encode decimal with precision \" + valuePrecision + \" as max precision \"\n              + precision + \". This is after safely adjusting scale from \" + valueScale + \" to required \" + scale);\n        } else {\n          throw new AvroTypeException(\n              \"Cannot encode decimal with precision \" + valuePrecision + \" as max precision \" + precision);\n        }\n      }\n\n      return value;\n    }\n  }\n\n  /**\n   * Convert an underlying representation of a logical type (such as a ByteBuffer)\n   * to a higher level object (such as a BigDecimal).\n   *\n   * @param datum      The object to be converted.\n   * @param schema     The schema of datum. Cannot be null if datum is not null.\n   * @param type       The {@link org.apache.avro.LogicalType} of datum. Cannot be\n   *                   null if datum is not null.\n   * @param conversion The tool used to finish the conversion. Cannot be null if\n   *                   datum is not null.\n   * @return The result object, which is a high level object of the logical type.\n   *         The null datum always converts to a null value.\n   * @throws IllegalArgumentException if datum is not null, but schema, type or\n   *                                  conversion is.\n   */\n  public static Object convertToLogicalType(Object datum, Schema schema, LogicalType type, Conversion<?> conversion) {\n    if (datum == null) {\n      return null;\n    }\n\n    if (schema == null || type == null || conversion == null) {\n      throw new IllegalArgumentException(\"Parameters cannot be null! Parameter values:\"\n          + Arrays.deepToString(new Object[] { datum, schema, type, conversion }));\n    }\n\n    try {\n      switch (schema.getType()) {\n      case RECORD:\n        return conversion.fromRecord((IndexedRecord) datum, schema, type);\n      case ENUM:\n        return conversion.fromEnumSymbol((GenericEnumSymbol<?>) datum, schema, type);\n      case ARRAY:\n        return conversion.fromArray((Collection<?>) datum, schema, type);\n      case MAP:\n        return conversion.fromMap((Map<?, ?>) datum, schema, type);\n      case FIXED:\n        return conversion.fromFixed((GenericFixed) datum, schema, type);\n      case STRING:\n        return conversion.fromCharSequence((CharSequence) datum, schema, type);\n      case BYTES:\n        return conversion.fromBytes((ByteBuffer) datum, schema, type);\n      case INT:\n        return conversion.fromInt((Integer) datum, schema, type);\n      case LONG:\n        return conversion.fromLong((Long) datum, schema, type);\n      case FLOAT:\n        return conversion.fromFloat((Float) datum, schema, type);\n      case DOUBLE:\n        return conversion.fromDouble((Double) datum, schema, type);\n      case BOOLEAN:\n        return conversion.fromBoolean((Boolean) datum, schema, type);\n      }\n      return datum;\n    } catch (ClassCastException e) {\n      throw new AvroRuntimeException(\n          \"Cannot convert \" + datum + ':' + datum.getClass().getSimpleName() + \": expected generic type\", e);\n    }\n  }\n\n  /**\n   * Convert a high level representation of a logical type (such as a BigDecimal)\n   * to its underlying representation object (such as a ByteBuffer)\n   *\n   * @param datum      The object to be converted.\n   * @param schema     The schema of datum. Cannot be null if datum is not null.\n   * @param type       The {@link org.apache.avro.LogicalType} of datum. Cannot be\n   *                   null if datum is not null.\n   * @param conversion The tool used to finish the conversion. Cannot be null if\n   *                   datum is not null.\n   * @return The result object, which is an underlying representation object of\n   *         the logical type. If the input param datum is null, a null value will\n   *         be returned.\n   * @throws IllegalArgumentException if datum is not null, but schema, type or\n   *                                  conversion is.\n   */\n  public static <T> Object convertToRawType(Object datum, Schema schema, LogicalType type, Conversion<T> conversion) {\n    if (datum == null) {\n      return null;\n    }\n\n    if (schema == null || type == null || conversion == null) {\n      throw new IllegalArgumentException(\"Parameters cannot be null! Parameter values:\"\n          + Arrays.deepToString(new Object[] { datum, schema, type, conversion }));\n    }\n\n    try {\n      Class<T> fromClass = conversion.getConvertedType();\n      switch (schema.getType()) {\n      case RECORD:\n        return conversion.toRecord(fromClass.cast(datum), schema, type);\n      case ENUM:\n        return conversion.toEnumSymbol(fromClass.cast(datum), schema, type);\n      case ARRAY:\n        return conversion.toArray(fromClass.cast(datum), schema, type);\n      case MAP:\n        return conversion.toMap(fromClass.cast(datum), schema, type);\n      case FIXED:\n        return conversion.toFixed(fromClass.cast(datum), schema, type);\n      case STRING:\n        return conversion.toCharSequence(fromClass.cast(datum), schema, type);\n      case BYTES:\n        return conversion.toBytes(fromClass.cast(datum), schema, type);\n      case INT:\n        return conversion.toInt(fromClass.cast(datum), schema, type);\n      case LONG:\n        return conversion.toLong(fromClass.cast(datum), schema, type);\n      case FLOAT:\n        return conversion.toFloat(fromClass.cast(datum), schema, type);\n      case DOUBLE:\n        return conversion.toDouble(fromClass.cast(datum), schema, type);\n      case BOOLEAN:\n        return conversion.toBoolean(fromClass.cast(datum), schema, type);\n      }\n      return datum;\n    } catch (ClassCastException e) {\n      throw new AvroRuntimeException(\n          \"Cannot convert \" + datum + ':' + datum.getClass().getSimpleName() + \": expected logical type\", e);\n    }\n  }\n\n}\n","lineNo":109}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.avro;\n\nimport com.fasterxml.jackson.core.JsonFactory;\nimport com.fasterxml.jackson.core.JsonGenerator;\nimport com.fasterxml.jackson.core.JsonParseException;\nimport com.fasterxml.jackson.core.JsonParser;\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.node.DoubleNode;\nimport com.fasterxml.jackson.databind.node.NullNode;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.Serializable;\nimport java.io.StringWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.IdentityHashMap;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport org.apache.avro.util.internal.Accessor;\nimport org.apache.avro.util.internal.Accessor.FieldAccessor;\nimport org.apache.avro.util.internal.JacksonUtils;\nimport org.apache.avro.util.internal.ThreadLocalWithInitial;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport static org.apache.avro.LogicalType.LOGICAL_TYPE_PROP;\n\n/**\n * An abstract data type.\n * <p>\n * A schema may be one of:\n * <ul>\n * <li>A <i>record<\/i>, mapping field names to field value data;\n * <li>An <i>enum<\/i>, containing one of a small set of symbols;\n * <li>An <i>array<\/i> of values, all of the same schema;\n * <li>A <i>map<\/i>, containing string/value pairs, of a declared schema;\n * <li>A <i>union<\/i> of other schemas;\n * <li>A <i>fixed<\/i> sized binary object;\n * <li>A unicode <i>string<\/i>;\n * <li>A sequence of <i>bytes<\/i>;\n * <li>A 32-bit signed <i>int<\/i>;\n * <li>A 64-bit signed <i>long<\/i>;\n * <li>A 32-bit IEEE single-<i>float<\/i>; or\n * <li>A 64-bit IEEE <i>double<\/i>-float; or\n * <li>A <i>boolean<\/i>; or\n * <li><i>null<\/i>.\n * <\/ul>\n *\n * A schema can be constructed using one of its static <tt>createXXX<\/tt>\n * methods, or more conveniently using {@link SchemaBuilder}. The schema objects\n * are <i>logically<\/i> immutable. There are only two mutating methods -\n * {@link #setFields(List)} and {@link #addProp(String, String)}. The following\n * restrictions apply on these two methods.\n * <ul>\n * <li>{@link #setFields(List)}, can be called at most once. This method exists\n * in order to enable clients to build recursive schemas.\n * <li>{@link #addProp(String, String)} can be called with property names that\n * are not present already. It is not possible to change or delete an existing\n * property.\n * <\/ul>\n */\npublic abstract class Schema extends JsonProperties implements Serializable {\n\n  private static final long serialVersionUID = 1L;\n\n  protected Object writeReplace() {\n    SerializableSchema ss = new SerializableSchema();\n    ss.schemaString = toString();\n    return ss;\n  }\n\n  private static final class SerializableSchema implements Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    private String schemaString;\n\n    private Object readResolve() {\n      return new Schema.Parser().parse(schemaString);\n    }\n  }\n\n  static final JsonFactory FACTORY = new JsonFactory();\n  static final Logger LOG = LoggerFactory.getLogger(Schema.class);\n  static final ObjectMapper MAPPER = new ObjectMapper(FACTORY);\n\n  private static final int NO_HASHCODE = Integer.MIN_VALUE;\n\n  static {\n    FACTORY.enable(JsonParser.Feature.ALLOW_COMMENTS);\n    FACTORY.setCodec(MAPPER);\n  }\n\n  /** The type of a schema. */\n  public enum Type {\n    RECORD, ENUM, ARRAY, MAP, UNION, FIXED, STRING, BYTES, INT, LONG, FLOAT, DOUBLE, BOOLEAN, NULL;\n\n    private final String name;\n\n    private Type() {\n      this.name = this.name().toLowerCase(Locale.ENGLISH);\n    }\n\n    public String getName() {\n      return name;\n    }\n  };\n\n  private final Type type;\n  private LogicalType logicalType = null;\n\n  Schema(Type type) {\n    super(type == Type.ENUM ? ENUM_RESERVED : SCHEMA_RESERVED);\n    this.type = type;\n  }\n\n  /** Create a schema for a primitive type. */\n  public static Schema create(Type type) {\n    switch (type) {\n    case STRING:\n      return new StringSchema();\n    case BYTES:\n      return new BytesSchema();\n    case INT:\n      return new IntSchema();\n    case LONG:\n      return new LongSchema();\n    case FLOAT:\n      return new FloatSchema();\n    case DOUBLE:\n      return new DoubleSchema();\n    case BOOLEAN:\n      return new BooleanSchema();\n    case NULL:\n      return new NullSchema();\n    default:\n      throw new AvroRuntimeException(\"Can't create a: \" + type);\n    }\n  }\n\n  private static final Set<String> SCHEMA_RESERVED = new HashSet<>(\n      Arrays.asList(\"doc\", \"fields\", \"items\", \"name\", \"namespace\", \"size\", \"symbols\", \"values\", \"type\", \"aliases\"));\n\n  private static final Set<String> ENUM_RESERVED = new HashSet<>(SCHEMA_RESERVED);\n  static {\n    ENUM_RESERVED.add(\"default\");\n  }\n\n  int hashCode = NO_HASHCODE;\n\n  @Override\n  public void addProp(String name, String value) {\n    super.addProp(name, value);\n    hashCode = NO_HASHCODE;\n  }\n\n  @Override\n  public void addProp(String name, Object value) {\n    super.addProp(name, value);\n    hashCode = NO_HASHCODE;\n  }\n\n  public LogicalType getLogicalType() {\n    return logicalType;\n  }\n\n  void setLogicalType(LogicalType logicalType) {\n    this.logicalType = logicalType;\n  }\n\n  /**\n   * Create an anonymous record schema.\n   *\n   * @deprecated This method allows to create Schema objects that cannot be parsed\n   *             by {@link Schema.Parser#parse(String)}. It will be removed in a\n   *             future version of Avro. Better use\n   *             i{@link #createRecord(String, String, String, boolean, List)} to\n   *             produce a fully qualified Schema.\n   */\n  @Deprecated\n  public static Schema createRecord(List<Field> fields) {\n    Schema result = createRecord(null, null, null, false);\n    result.setFields(fields);\n    return result;\n  }\n\n  /** Create a named record schema. */\n  public static Schema createRecord(String name, String doc, String namespace, boolean isError) {\n    return new RecordSchema(new Name(name, namespace), doc, isError);\n  }\n\n  /** Create a named record schema with fields already set. */\n  public static Schema createRecord(String name, String doc, String namespace, boolean isError, List<Field> fields) {\n    return new RecordSchema(new Name(name, namespace), doc, isError, fields);\n  }\n\n  /** Create an enum schema. */\n  public static Schema createEnum(String name, String doc, String namespace, List<String> values) {\n    return new EnumSchema(new Name(name, namespace), doc, new LockableArrayList<>(values), null);\n  }\n\n  /** Create an enum schema. */\n  public static Schema createEnum(String name, String doc, String namespace, List<String> values, String enumDefault) {\n    return new EnumSchema(new Name(name, namespace), doc, new LockableArrayList<>(values), enumDefault);\n  }\n\n  /** Create an array schema. */\n  public static Schema createArray(Schema elementType) {\n    return new ArraySchema(elementType);\n  }\n\n  /** Create a map schema. */\n  public static Schema createMap(Schema valueType) {\n    return new MapSchema(valueType);\n  }\n\n  /** Create a union schema. */\n  public static Schema createUnion(List<Schema> types) {\n    return new UnionSchema(new LockableArrayList<>(types));\n  }\n\n  /** Create a union schema. */\n  public static Schema createUnion(Schema... types) {\n    return createUnion(new LockableArrayList<>(types));\n  }\n\n  /** Create a fixed schema. */\n  public static Schema createFixed(String name, String doc, String space, int size) {\n    return new FixedSchema(new Name(name, space), doc, size);\n  }\n\n  /** Return the type of this schema. */\n  public Type getType() {\n    return type;\n  }\n\n  /**\n   * If this is a record, returns the Field with the given name\n   * <tt>fieldName<\/tt>. If there is no field by that name, a <tt>null<\/tt> is\n   * returned.\n   */\n  public Field getField(String fieldname) {\n    throw new AvroRuntimeException(\"Not a record: \" + this);\n  }\n\n  /**\n   * If this is a record, returns the fields in it. The returned list is in the\n   * order of their positions.\n   */\n  public List<Field> getFields() {\n    throw new AvroRuntimeException(\"Not a record: \" + this);\n  }\n\n  /**\n   * If this is a record, returns whether the fields have been set.\n   */\n  public boolean hasFields() {\n    throw new AvroRuntimeException(\"Not a record: \" + this);\n  }\n\n  /**\n   * If this is a record, set its fields. The fields can be set only once in a\n   * schema.\n   */\n  public void setFields(List<Field> fields) {\n    throw new AvroRuntimeException(\"Not a record: \" + this);\n  }\n\n  /** If this is an enum, return its symbols. */\n  public List<String> getEnumSymbols() {\n    throw new AvroRuntimeException(\"Not an enum: \" + this);\n  }\n\n  /** If this is an enum, return its default value. */\n  public String getEnumDefault() {\n    throw new AvroRuntimeException(\"Not an enum: \" + this);\n  }\n\n  /** If this is an enum, return a symbol's ordinal value. */\n  public int getEnumOrdinal(String symbol) {\n    throw new AvroRuntimeException(\"Not an enum: \" + this);\n  }\n\n  /** If this is an enum, returns true if it contains given symbol. */\n  public boolean hasEnumSymbol(String symbol) {\n    throw new AvroRuntimeException(\"Not an enum: \" + this);\n  }\n\n  /**\n   * If this is a record, enum or fixed, returns its name, otherwise the name of\n   * the primitive type.\n   */\n  public String getName() {\n    return type.name;\n  }\n\n  /**\n   * If this is a record, enum, or fixed, returns its docstring, if available.\n   * Otherwise, returns null.\n   */\n  public String getDoc() {\n    return null;\n  }\n\n  /** If this is a record, enum or fixed, returns its namespace, if any. */\n  public String getNamespace() {\n    throw new AvroRuntimeException(\"Not a named type: \" + this);\n  }\n\n  /**\n   * If this is a record, enum or fixed, returns its namespace-qualified name,\n   * otherwise returns the name of the primitive type.\n   */\n  public String getFullName() {\n    return getName();\n  }\n\n  /** If this is a record, enum or fixed, add an alias. */\n  public void addAlias(String alias) {\n    throw new AvroRuntimeException(\"Not a named type: \" + this);\n  }\n\n  /** If this is a record, enum or fixed, add an alias. */\n  public void addAlias(String alias, String space) {\n    throw new AvroRuntimeException(\"Not a named type: \" + this);\n  }\n\n  /** If this is a record, enum or fixed, return its aliases, if any. */\n  public Set<String> getAliases() {\n    throw new AvroRuntimeException(\"Not a named type: \" + this);\n  }\n\n  /** Returns true if this record is an error type. */\n  public boolean isError() {\n    throw new AvroRuntimeException(\"Not a record: \" + this);\n  }\n\n  /** If this is an array, returns its element type. */\n  public Schema getElementType() {\n    throw new AvroRuntimeException(\"Not an array: \" + this);\n  }\n\n  /** If this is a map, returns its value type. */\n  public Schema getValueType() {\n    throw new AvroRuntimeException(\"Not a map: \" + this);\n  }\n\n  /** If this is a union, returns its types. */\n  public List<Schema> getTypes() {\n    throw new AvroRuntimeException(\"Not a union: \" + this);\n  }\n\n  /** If this is a union, return the branch with the provided full name. */\n  public Integer getIndexNamed(String name) {\n    throw new AvroRuntimeException(\"Not a union: \" + this);\n  }\n\n  /** If this is fixed, returns its size. */\n  public int getFixedSize() {\n    throw new AvroRuntimeException(\"Not fixed: \" + this);\n  }\n\n  /** Render this as <a href=\"https://json.org/\">JSON<\/a>. */\n  @Override\n  public String toString() {\n    return toString(false);\n  }\n\n  /**\n   * Render this as <a href=\"https://json.org/\">JSON<\/a>.\n   *\n   * @param pretty if true, pretty-print JSON.\n   */\n  public String toString(boolean pretty) {\n    return toString(new Names(), pretty);\n  }\n\n  /**\n   * Render this as <a href=\"https://json.org/\">JSON<\/a>, but without inlining the\n   * referenced schemas.\n   *\n   * @param referencedSchemas referenced schemas\n   * @param pretty            if true, pretty-print JSON.\n   */\n  // Use at your own risk. This method should be removed with AVRO-2832.\n  @Deprecated\n  public String toString(Collection<Schema> referencedSchemas, boolean pretty) {\n    Schema.Names names = new Schema.Names();\n    if (referencedSchemas != null) {\n      for (Schema s : referencedSchemas) {\n        names.add(s);\n      }\n    }\n    return toString(names, pretty);\n  }\n\n  String toString(Names names, boolean pretty) {\n    try {\n      StringWriter writer = new StringWriter();\n      JsonGenerator gen = FACTORY.createGenerator(writer);\n      if (pretty)\n        gen.useDefaultPrettyPrinter();\n      toJson(names, gen);\n      gen.flush();\n      return writer.toString();\n    } catch (IOException e) {\n      throw new AvroRuntimeException(e);\n    }\n  }\n\n  void toJson(Names names, JsonGenerator gen) throws IOException {\n    if (!hasProps()) { // no props defined\n      gen.writeString(getName()); // just write name\n    } else {\n      gen.writeStartObject();\n      gen.writeStringField(\"type\", getName());\n      writeProps(gen);\n      gen.writeEndObject();\n    }\n  }\n\n  void fieldsToJson(Names names, JsonGenerator gen) throws IOException {\n    throw new AvroRuntimeException(\"Not a record: \" + this);\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (o == this)\n      return true;\n    if (!(o instanceof Schema))\n      return false;\n    Schema that = (Schema) o;\n    if (!(this.type == that.type))\n      return false;\n    return equalCachedHash(that) && propsEqual(that);\n  }\n\n  @Override\n  public final int hashCode() {\n    if (hashCode == NO_HASHCODE)\n      hashCode = computeHash();\n    return hashCode;\n  }\n\n  int computeHash() {\n    return getType().hashCode() + propsHashCode();\n  }\n\n  final boolean equalCachedHash(Schema other) {\n    return (hashCode == other.hashCode) || (hashCode == NO_HASHCODE) || (other.hashCode == NO_HASHCODE);\n  }\n\n  private static final Set<String> FIELD_RESERVED = Collections\n      .unmodifiableSet(new HashSet<>(Arrays.asList(\"default\", \"doc\", \"name\", \"order\", \"type\", \"aliases\")));\n\n  /** Returns true if this record is an union type. */\n  public boolean isUnion() {\n    return this instanceof UnionSchema;\n  }\n\n  /** Returns true if this record is an union type containing null. */\n  public boolean isNullable() {\n    if (!isUnion()) {\n      return getType().equals(Schema.Type.NULL);\n    }\n\n    for (Schema schema : getTypes()) {\n      if (schema.isNullable()) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /** A field within a record. */\n  public static class Field extends JsonProperties {\n\n    static {\n      Accessor.setAccessor(new FieldAccessor() {\n        @Override\n        protected JsonNode defaultValue(Field field) {\n          return field.defaultValue();\n        }\n\n        @Override\n        protected Field createField(String name, Schema schema, String doc, JsonNode defaultValue) {\n          return new Field(name, schema, doc, defaultValue, true, Order.ASCENDING);\n        }\n\n        @Override\n        protected Field createField(String name, Schema schema, String doc, JsonNode defaultValue, boolean validate,\n            Order order) {\n          return new Field(name, schema, doc, defaultValue, validate, order);\n        }\n      });\n    }\n\n    /** How values of this field should be ordered when sorting records. */\n    public enum Order {\n      ASCENDING, DESCENDING, IGNORE;\n\n      private final String name;\n\n      Order() {\n        this.name = this.name().toLowerCase(Locale.ENGLISH);\n      }\n    }\n\n    /**\n     * For Schema unions with a \"null\" type as the first entry, this can be used to\n     * specify that the default for the union is null.\n     */\n    public static final Object NULL_DEFAULT_VALUE = new Object();\n\n    private final String name; // name of the field.\n    private int position = -1;\n    private final Schema schema;\n    private final String doc;\n    private final JsonNode defaultValue;\n    private final Order order;\n    private Set<String> aliases;\n\n    Field(String name, Schema schema, String doc, JsonNode defaultValue, boolean validateDefault, Order order) {\n      super(FIELD_RESERVED);\n      this.name = validateName(name);\n      this.schema = Objects.requireNonNull(schema, \"schema is required and cannot be null\");\n      this.doc = doc;\n      this.defaultValue = validateDefault ? validateDefault(name, schema, defaultValue) : defaultValue;\n      this.order = Objects.requireNonNull(order, \"Order cannot be null\");\n    }\n\n    /**\n     * Constructs a new Field instance with the same {@code name}, {@code doc},\n     * {@code defaultValue}, and {@code order} as {@code field} has with changing\n     * the schema to the specified one. It also copies all the {@code props} and\n     * {@code aliases}.\n     */\n    public Field(Field field, Schema schema) {\n      this(field.name, schema, field.doc, field.defaultValue, true, field.order);\n      putAll(field);\n      if (field.aliases != null)\n        aliases = new LinkedHashSet<>(field.aliases);\n    }\n\n    /**\n     *\n     */\n    public Field(String name, Schema schema) {\n      this(name, schema, (String) null, (JsonNode) null, true, Order.ASCENDING);\n    }\n\n    /**\n     *\n     */\n    public Field(String name, Schema schema, String doc) {\n      this(name, schema, doc, (JsonNode) null, true, Order.ASCENDING);\n    }\n\n    /**\n     * @param defaultValue the default value for this field specified using the\n     *                     mapping in {@link JsonProperties}\n     */\n    public Field(String name, Schema schema, String doc, Object defaultValue) {\n      this(name, schema, doc,\n          defaultValue == NULL_DEFAULT_VALUE ? NullNode.getInstance() : JacksonUtils.toJsonNode(defaultValue), true,\n          Order.ASCENDING);\n    }\n\n    /**\n     * @param defaultValue the default value for this field specified using the\n     *                     mapping in {@link JsonProperties}\n     */\n    public Field(String name, Schema schema, String doc, Object defaultValue, Order order) {\n      this(name, schema, doc,\n          defaultValue == NULL_DEFAULT_VALUE ? NullNode.getInstance() : JacksonUtils.toJsonNode(defaultValue), true,\n          Objects.requireNonNull(order));\n    }\n\n    public String name() {\n      return name;\n    };\n\n    /** The position of this field within the record. */\n    public int pos() {\n      return position;\n    }\n\n    /** This field's {@link Schema}. */\n    public Schema schema() {\n      return schema;\n    }\n\n    /** Field's documentation within the record, if set. May return null. */\n    public String doc() {\n      return doc;\n    }\n\n    /**\n     * @return true if this Field has a default value set. Can be used to determine\n     *         if a \"null\" return from defaultVal() is due to that being the default\n     *         value or just not set.\n     */\n    public boolean hasDefaultValue() {\n      return defaultValue != null;\n    }\n\n    JsonNode defaultValue() {\n      return defaultValue;\n    }\n\n    /**\n     * @return the default value for this field specified using the mapping in\n     *         {@link JsonProperties}\n     */\n    public Object defaultVal() {\n      return JacksonUtils.toObject(defaultValue, schema);\n    }\n\n    public Order order() {\n      return order;\n    }\n\n    public void addAlias(String alias) {\n      if (aliases == null)\n        this.aliases = new LinkedHashSet<>();\n      aliases.add(alias);\n    }\n\n    /** Return the defined aliases as an unmodifiable Set. */\n    public Set<String> aliases() {\n      if (aliases == null)\n        return Collections.emptySet();\n      return Collections.unmodifiableSet(aliases);\n    }\n\n    @Override\n    public boolean equals(Object other) {\n      if (other == this)\n        return true;\n      if (!(other instanceof Field))\n        return false;\n      Field that = (Field) other;\n      return (name.equals(that.name)) && (schema.equals(that.schema)) && defaultValueEquals(that.defaultValue)\n          && (order == that.order) && propsEqual(that);\n    }\n\n    @Override\n    public int hashCode() {\n      return name.hashCode() + schema.computeHash();\n    }\n\n    private boolean defaultValueEquals(JsonNode thatDefaultValue) {\n      if (defaultValue == null)\n        return thatDefaultValue == null;\n      if (thatDefaultValue == null)\n        return false;\n      if (Double.isNaN(defaultValue.doubleValue()))\n        return Double.isNaN(thatDefaultValue.doubleValue());\n      return defaultValue.equals(thatDefaultValue);\n    }\n\n    @Override\n    public String toString() {\n      return name + \" type:\" + schema.type + \" pos:\" + position;\n    }\n  }\n\n  static class Name {\n    private final String name;\n    private final String space;\n    private final String full;\n\n    public Name(String name, String space) {\n      if (name == null) { // anonymous\n        this.name = this.space = this.full = null;\n        return;\n      }\n      int lastDot = name.lastIndexOf('.');\n      if (lastDot < 0) { // unqualified name\n        this.name = validateName(name);\n      } else { // qualified name\n        space = name.substring(0, lastDot); // get space from name\n        this.name = validateName(name.substring(lastDot + 1));\n      }\n      if (\"\".equals(space))\n        space = null;\n      this.space = space;\n      this.full = (this.space == null) ? this.name : this.space + \".\" + this.name;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (o == this)\n        return true;\n      if (!(o instanceof Name))\n        return false;\n      Name that = (Name) o;\n      return Objects.equals(full, that.full);\n    }\n\n    @Override\n    public int hashCode() {\n      return full == null ? 0 : full.hashCode();\n    }\n\n    @Override\n    public String toString() {\n      return full;\n    }\n\n    public void writeName(Names names, JsonGenerator gen) throws IOException {\n      if (name != null)\n        gen.writeStringField(\"name\", name);\n      if (space != null) {\n        if (!space.equals(names.space()))\n          gen.writeStringField(\"namespace\", space);\n      } else if (names.space() != null) { // null within non-null\n        gen.writeStringField(\"namespace\", \"\");\n      }\n    }\n\n    public String getQualified(String defaultSpace) {\n      return this.shouldWriteFull(defaultSpace) ? full : name;\n    }\n\n    /**\n     * Determine if full name must be written. There are 2 cases for true :\n     * defaultSpace != from this.space or name is already a Schema.Type (int, array\n     * ...)\n     *\n     * @param defaultSpace : default name space.\n     * @return true if full name must be written.\n     */\n    private boolean shouldWriteFull(String defaultSpace) {\n      if (space != null && space.equals(defaultSpace)) {\n        for (Type schemaType : Type.values()) {\n          if (schemaType.name.equals(name)) {\n            // name is a 'Type', so namespace must be written\n            return true;\n          }\n        }\n        // this.space == defaultSpace\n        return false;\n      }\n      // this.space != defaultSpace, so namespace must be written.\n      return true;\n    }\n\n  }\n\n  private static abstract class NamedSchema extends Schema {\n    final Name name;\n    final String doc;\n    Set<Name> aliases;\n\n    public NamedSchema(Type type, Name name, String doc) {\n      super(type);\n      this.name = name;\n      this.doc = doc;\n      if (PRIMITIVES.containsKey(name.full)) {\n        throw new AvroTypeException(\"Schemas may not be named after primitives: \" + name.full);\n      }\n    }\n\n    @Override\n    public String getName() {\n      return name.name;\n    }\n\n    @Override\n    public String getDoc() {\n      return doc;\n    }\n\n    @Override\n    public String getNamespace() {\n      return name.space;\n    }\n\n    @Override\n    public String getFullName() {\n      return name.full;\n    }\n\n    @Override\n    public void addAlias(String alias) {\n      addAlias(alias, null);\n    }\n\n    @Override\n    public void addAlias(String name, String space) {\n      if (aliases == null)\n        this.aliases = new LinkedHashSet<>();\n      if (space == null)\n        space = this.name.space;\n      aliases.add(new Name(name, space));\n    }\n\n    @Override\n    public Set<String> getAliases() {\n      Set<String> result = new LinkedHashSet<>();\n      if (aliases != null)\n        for (Name alias : aliases)\n          result.add(alias.full);\n      return result;\n    }\n\n    public boolean writeNameRef(Names names, JsonGenerator gen) throws IOException {\n      if (this.equals(names.get(name))) {\n        gen.writeString(name.getQualified(names.space()));\n        return true;\n      } else if (name.name != null) {\n        names.put(name, this);\n      }\n      return false;\n    }\n\n    public void writeName(Names names, JsonGenerator gen) throws IOException {\n      name.writeName(names, gen);\n    }\n\n    public boolean equalNames(NamedSchema that) {\n      return this.name.equals(that.name);\n    }\n\n    @Override\n    int computeHash() {\n      return super.computeHash() + name.hashCode();\n    }\n\n    public void aliasesToJson(JsonGenerator gen) throws IOException {\n      if (aliases == null || aliases.isEmpty())\n        return;\n      gen.writeFieldName(\"aliases\");\n      gen.writeStartArray();\n      for (Name alias : aliases)\n        gen.writeString(alias.getQualified(name.space));\n      gen.writeEndArray();\n    }\n\n  }\n\n  /**\n   * Useful as key of {@link Map}s when traversing two schemas at the same time\n   * and need to watch for recursion.\n   */\n  public static class SeenPair {\n    private Object s1;\n    private Object s2;\n\n    public SeenPair(Object s1, Object s2) {\n      this.s1 = s1;\n      this.s2 = s2;\n    }\n\n    public boolean equals(Object o) {\n      if (!(o instanceof SeenPair))\n        return false;\n      return this.s1 == ((SeenPair) o).s1 && this.s2 == ((SeenPair) o).s2;\n    }\n\n    @Override\n    public int hashCode() {\n      return System.identityHashCode(s1) + System.identityHashCode(s2);\n    }\n  }\n\n  private static final ThreadLocal<Set> SEEN_EQUALS = ThreadLocalWithInitial.of(HashSet::new);\n  private static final ThreadLocal<Map> SEEN_HASHCODE = ThreadLocalWithInitial.of(IdentityHashMap::new);\n\n  @SuppressWarnings(value = \"unchecked\")\n  private static class RecordSchema extends NamedSchema {\n    private List<Field> fields;\n    private Map<String, Field> fieldMap;\n    private final boolean isError;\n\n    public RecordSchema(Name name, String doc, boolean isError) {\n      super(Type.RECORD, name, doc);\n      this.isError = isError;\n    }\n\n    public RecordSchema(Name name, String doc, boolean isError, List<Field> fields) {\n      super(Type.RECORD, name, doc);\n      this.isError = isError;\n      setFields(fields);\n    }\n\n    @Override\n    public boolean isError() {\n      return isError;\n    }\n\n    @Override\n    public Field getField(String fieldname) {\n      if (fieldMap == null)\n        throw new AvroRuntimeException(\"Schema fields not set yet\");\n      return fieldMap.get(fieldname);\n    }\n\n    @Override\n    public List<Field> getFields() {\n      if (fields == null)\n        throw new AvroRuntimeException(\"Schema fields not set yet\");\n      return fields;\n    }\n\n    @Override\n    public boolean hasFields() {\n      return fields != null;\n    }\n\n    @Override\n    public void setFields(List<Field> fields) {\n      if (this.fields != null) {\n        throw new AvroRuntimeException(\"Fields are already set\");\n      }\n      int i = 0;\n      fieldMap = new HashMap<>(Math.multiplyExact(2, fields.size()));\n      LockableArrayList<Field> ff = new LockableArrayList<>(fields.size());\n      for (Field f : fields) {\n        if (f.position != -1) {\n          throw new AvroRuntimeException(\"Field already used: \" + f);\n        }\n        f.position = i++;\n        final Field existingField = fieldMap.put(f.name(), f);\n        if (existingField != null) {\n          throw new AvroRuntimeException(\n              String.format(\"Duplicate field %s in record %s: %s and %s.\", f.name(), name, f, existingField));\n        }\n        ff.add(f);\n      }\n      this.fields = ff.lock();\n      this.hashCode = NO_HASHCODE;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (o == this)\n        return true;\n      if (!(o instanceof RecordSchema))\n        return false;\n      RecordSchema that = (RecordSchema) o;\n      if (!equalCachedHash(that))\n        return false;\n      if (!equalNames(that))\n        return false;\n      if (!propsEqual(that))\n        return false;\n      Set seen = SEEN_EQUALS.get();\n      SeenPair here = new SeenPair(this, o);\n      if (seen.contains(here))\n        return true; // prevent stack overflow\n      boolean first = seen.isEmpty();\n      try {\n        seen.add(here);\n        return Objects.equals(fields, that.fields);\n      } finally {\n        if (first)\n          seen.clear();\n      }\n    }\n\n    @Override\n    int computeHash() {\n      Map seen = SEEN_HASHCODE.get();\n      if (seen.containsKey(this))\n        return 0; // prevent stack overflow\n      boolean first = seen.isEmpty();\n      try {\n        seen.put(this, this);\n        return super.computeHash() + fields.hashCode();\n      } finally {\n        if (first)\n          seen.clear();\n      }\n    }\n\n    @Override\n    void toJson(Names names, JsonGenerator gen) throws IOException {\n      if (writeNameRef(names, gen))\n        return;\n      String savedSpace = names.space; // save namespace\n      gen.writeStartObject();\n      gen.writeStringField(\"type\", isError ? \"error\" : \"record\");\n      writeName(names, gen);\n      names.space = name.space; // set default namespace\n      if (getDoc() != null)\n        gen.writeStringField(\"doc\", getDoc());\n\n      if (fields != null) {\n        gen.writeFieldName(\"fields\");\n        fieldsToJson(names, gen);\n      }\n\n      writeProps(gen);\n      aliasesToJson(gen);\n      gen.writeEndObject();\n      names.space = savedSpace; // restore namespace\n    }\n\n    @Override\n    void fieldsToJson(Names names, JsonGenerator gen) throws IOException {\n      gen.writeStartArray();\n      for (Field f : fields) {\n        gen.writeStartObject();\n        gen.writeStringField(\"name\", f.name());\n        gen.writeFieldName(\"type\");\n        f.schema().toJson(names, gen);\n        if (f.doc() != null)\n          gen.writeStringField(\"doc\", f.doc());\n        if (f.hasDefaultValue()) {\n          gen.writeFieldName(\"default\");\n          gen.writeTree(f.defaultValue());\n        }\n        if (f.order() != Field.Order.ASCENDING)\n          gen.writeStringField(\"order\", f.order().name);\n        if (f.aliases != null && f.aliases.size() != 0) {\n          gen.writeFieldName(\"aliases\");\n          gen.writeStartArray();\n          for (String alias : f.aliases)\n            gen.writeString(alias);\n          gen.writeEndArray();\n        }\n        f.writeProps(gen);\n        gen.writeEndObject();\n      }\n      gen.writeEndArray();\n    }\n  }\n\n  private static class EnumSchema extends NamedSchema {\n    private final List<String> symbols;\n    private final Map<String, Integer> ordinals;\n    private final String enumDefault;\n\n    public EnumSchema(Name name, String doc, LockableArrayList<String> symbols, String enumDefault) {\n      super(Type.ENUM, name, doc);\n      this.symbols = symbols.lock();\n      this.ordinals = new HashMap<>(Math.multiplyExact(2, symbols.size()));\n      this.enumDefault = enumDefault;\n      int i = 0;\n      for (String symbol : symbols) {\n        if (ordinals.put(validateName(symbol), i++) != null) {\n          throw new SchemaParseException(\"Duplicate enum symbol: \" + symbol);\n        }\n      }\n      if (enumDefault != null && !symbols.contains(enumDefault)) {\n        throw new SchemaParseException(\n            \"The Enum Default: \" + enumDefault + \" is not in the enum symbol set: \" + symbols);\n      }\n    }\n\n    @Override\n    public List<String> getEnumSymbols() {\n      return symbols;\n    }\n\n    @Override\n    public boolean hasEnumSymbol(String symbol) {\n      return ordinals.containsKey(symbol);\n    }\n\n    @Override\n    public int getEnumOrdinal(String symbol) {\n      return ordinals.get(symbol);\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (o == this)\n        return true;\n      if (!(o instanceof EnumSchema))\n        return false;\n      EnumSchema that = (EnumSchema) o;\n      return equalCachedHash(that) && equalNames(that) && symbols.equals(that.symbols) && propsEqual(that);\n    }\n\n    @Override\n    public String getEnumDefault() {\n      return enumDefault;\n    }\n\n    @Override\n    int computeHash() {\n      return super.computeHash() + symbols.hashCode();\n    }\n\n    @Override\n    void toJson(Names names, JsonGenerator gen) throws IOException {\n      if (writeNameRef(names, gen))\n        return;\n      gen.writeStartObject();\n      gen.writeStringField(\"type\", \"enum\");\n      writeName(names, gen);\n      if (getDoc() != null)\n        gen.writeStringField(\"doc\", getDoc());\n      gen.writeArrayFieldStart(\"symbols\");\n      for (String symbol : symbols)\n        gen.writeString(symbol);\n      gen.writeEndArray();\n      if (getEnumDefault() != null)\n        gen.writeStringField(\"default\", getEnumDefault());\n      writeProps(gen);\n      aliasesToJson(gen);\n      gen.writeEndObject();\n    }\n  }\n\n  private static class ArraySchema extends Schema {\n    private final Schema elementType;\n\n    public ArraySchema(Schema elementType) {\n      super(Type.ARRAY);\n      this.elementType = elementType;\n    }\n\n    @Override\n    public Schema getElementType() {\n      return elementType;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (o == this)\n        return true;\n      if (!(o instanceof ArraySchema))\n        return false;\n      ArraySchema that = (ArraySchema) o;\n      return equalCachedHash(that) && elementType.equals(that.elementType) && propsEqual(that);\n    }\n\n    @Override\n    int computeHash() {\n      return super.computeHash() + elementType.computeHash();\n    }\n\n    @Override\n    void toJson(Names names, JsonGenerator gen) throws IOException {\n      gen.writeStartObject();\n      gen.writeStringField(\"type\", \"array\");\n      gen.writeFieldName(\"items\");\n      elementType.toJson(names, gen);\n      writeProps(gen);\n      gen.writeEndObject();\n    }\n  }\n\n  private static class MapSchema extends Schema {\n    private final Schema valueType;\n\n    public MapSchema(Schema valueType) {\n      super(Type.MAP);\n      this.valueType = valueType;\n    }\n\n    @Override\n    public Schema getValueType() {\n      return valueType;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (o == this)\n        return true;\n      if (!(o instanceof MapSchema))\n        return false;\n      MapSchema that = (MapSchema) o;\n      return equalCachedHash(that) && valueType.equals(that.valueType) && propsEqual(that);\n    }\n\n    @Override\n    int computeHash() {\n      return super.computeHash() + valueType.computeHash();\n    }\n\n    @Override\n    void toJson(Names names, JsonGenerator gen) throws IOException {\n      gen.writeStartObject();\n      gen.writeStringField(\"type\", \"map\");\n      gen.writeFieldName(\"values\");\n      valueType.toJson(names, gen);\n      writeProps(gen);\n      gen.writeEndObject();\n    }\n  }\n\n  private static class UnionSchema extends Schema {\n    private final List<Schema> types;\n    private final Map<String, Integer> indexByName;\n\n    public UnionSchema(LockableArrayList<Schema> types) {\n      super(Type.UNION);\n      this.indexByName = new HashMap<>(Math.multiplyExact(2, types.size()));\n      this.types = types.lock();\n      int index = 0;\n      for (Schema type : types) {\n        if (type.getType() == Type.UNION) {\n          throw new AvroRuntimeException(\"Nested union: \" + this);\n        }\n        String name = type.getFullName();\n        if (name == null) {\n          throw new AvroRuntimeException(\"Nameless in union:\" + this);\n        }\n        if (indexByName.put(name, index++) != null) {\n          throw new AvroRuntimeException(\"Duplicate in union:\" + name);\n        }\n      }\n    }\n\n    @Override\n    public List<Schema> getTypes() {\n      return types;\n    }\n\n    @Override\n    public Integer getIndexNamed(String name) {\n      return indexByName.get(name);\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (o == this)\n        return true;\n      if (!(o instanceof UnionSchema))\n        return false;\n      UnionSchema that = (UnionSchema) o;\n      return equalCachedHash(that) && types.equals(that.types) && propsEqual(that);\n    }\n\n    @Override\n    int computeHash() {\n      int hash = super.computeHash();\n      for (Schema type : types)\n        hash += type.computeHash();\n      return hash;\n    }\n\n    @Override\n    public void addProp(String name, String value) {\n      throw new AvroRuntimeException(\"Can't set properties on a union: \" + this);\n    }\n\n    @Override\n    void toJson(Names names, JsonGenerator gen) throws IOException {\n      gen.writeStartArray();\n      for (Schema type : types)\n        type.toJson(names, gen);\n      gen.writeEndArray();\n    }\n  }\n\n  private static class FixedSchema extends NamedSchema {\n    private final int size;\n\n    public FixedSchema(Name name, String doc, int size) {\n      super(Type.FIXED, name, doc);\n      if (size < 0)\n        throw new IllegalArgumentException(\"Invalid fixed size: \" + size);\n      this.size = size;\n    }\n\n    @Override\n    public int getFixedSize() {\n      return size;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (o == this)\n        return true;\n      if (!(o instanceof FixedSchema))\n        return false;\n      FixedSchema that = (FixedSchema) o;\n      return equalCachedHash(that) && equalNames(that) && size == that.size && propsEqual(that);\n    }\n\n    @Override\n    int computeHash() {\n      return super.computeHash() + size;\n    }\n\n    @Override\n    void toJson(Names names, JsonGenerator gen) throws IOException {\n      if (writeNameRef(names, gen))\n        return;\n      gen.writeStartObject();\n      gen.writeStringField(\"type\", \"fixed\");\n      writeName(names, gen);\n      if (getDoc() != null)\n        gen.writeStringField(\"doc\", getDoc());\n      gen.writeNumberField(\"size\", size);\n      writeProps(gen);\n      aliasesToJson(gen);\n      gen.writeEndObject();\n    }\n  }\n\n  private static class StringSchema extends Schema {\n    public StringSchema() {\n      super(Type.STRING);\n    }\n  }\n\n  private static class BytesSchema extends Schema {\n    public BytesSchema() {\n      super(Type.BYTES);\n    }\n  }\n\n  private static class IntSchema extends Schema {\n    public IntSchema() {\n      super(Type.INT);\n    }\n  }\n\n  private static class LongSchema extends Schema {\n    public LongSchema() {\n      super(Type.LONG);\n    }\n  }\n\n  private static class FloatSchema extends Schema {\n    public FloatSchema() {\n      super(Type.FLOAT);\n    }\n  }\n\n  private static class DoubleSchema extends Schema {\n    public DoubleSchema() {\n      super(Type.DOUBLE);\n    }\n  }\n\n  private static class BooleanSchema extends Schema {\n    public BooleanSchema() {\n      super(Type.BOOLEAN);\n    }\n  }\n\n  private static class NullSchema extends Schema {\n    public NullSchema() {\n      super(Type.NULL);\n    }\n  }\n\n  /**\n   * A parser for JSON-format schemas. Each named schema parsed with a parser is\n   * added to the names known to the parser so that subsequently parsed schemas\n   * may refer to it by name.\n   */\n  public static class Parser {\n    private Names names = new Names();\n    private boolean validate = true;\n    private boolean validateDefaults = true;\n\n    /**\n     * Adds the provided types to the set of defined, named types known to this\n     * parser.\n     */\n    public Parser addTypes(Map<String, Schema> types) {\n      for (Schema s : types.values())\n        names.add(s);\n      return this;\n    }\n\n    /** Returns the set of defined, named types known to this parser. */\n    public Map<String, Schema> getTypes() {\n      Map<String, Schema> result = new LinkedHashMap<>();\n      for (Schema s : names.values())\n        result.put(s.getFullName(), s);\n      return result;\n    }\n\n    /** Enable or disable name validation. */\n    public Parser setValidate(boolean validate) {\n      this.validate = validate;\n      return this;\n    }\n\n    /** True iff names are validated. True by default. */\n    public boolean getValidate() {\n      return this.validate;\n    }\n\n    /** Enable or disable default value validation. */\n    public Parser setValidateDefaults(boolean validateDefaults) {\n      this.validateDefaults = validateDefaults;\n      return this;\n    }\n\n    /** True iff default values are validated. False by default. */\n    public boolean getValidateDefaults() {\n      return this.validateDefaults;\n    }\n\n    /**\n     * Parse a schema from the provided file. If named, the schema is added to the\n     * names known to this parser.\n     */\n    public Schema parse(File file) throws IOException {\n      return parse(FACTORY.createParser(file));\n    }\n\n    /**\n     * Parse a schema from the provided stream. If named, the schema is added to the\n     * names known to this parser. The input stream stays open after the parsing.\n     */\n    public Schema parse(InputStream in) throws IOException {\n      return parse(FACTORY.createParser(in).disable(JsonParser.Feature.AUTO_CLOSE_SOURCE));\n    }\n\n    /** Read a schema from one or more json strings */\n    public Schema parse(String s, String... more) {\n      StringBuilder b = new StringBuilder(s);\n      for (String part : more)\n        b.append(part);\n      return parse(b.toString());\n    }\n\n    /**\n     * Parse a schema from the provided string. If named, the schema is added to the\n     * names known to this parser.\n     */\n    public Schema parse(String s) {\n      try {\n        return parse(FACTORY.createParser(s));\n      } catch (IOException e) {\n        throw new SchemaParseException(e);\n      }\n    }\n\n    private Schema parse(JsonParser parser) throws IOException {\n      boolean saved = validateNames.get();\n      boolean savedValidateDefaults = VALIDATE_DEFAULTS.get();\n      try {\n        validateNames.set(validate);\n        VALIDATE_DEFAULTS.set(validateDefaults);\n        return Schema.parse(MAPPER.readTree(parser), names);\n      } catch (JsonParseException e) {\n        throw new SchemaParseException(e);\n      } finally {\n        parser.close();\n        validateNames.set(saved);\n        VALIDATE_DEFAULTS.set(savedValidateDefaults);\n      }\n    }\n  }\n\n  /**\n   * Constructs a Schema object from JSON schema file <tt>file<\/tt>. The contents\n   * of <tt>file<\/tt> is expected to be in UTF-8 format.\n   *\n   * @param file The file to read the schema from.\n   * @return The freshly built Schema.\n   * @throws IOException if there was trouble reading the contents or they are\n   *                     invalid\n   * @deprecated use {@link Schema.Parser} instead.\n   */\n  @Deprecated\n  public static Schema parse(File file) throws IOException {\n    return new Parser().parse(file);\n  }\n\n  /**\n   * Constructs a Schema object from JSON schema stream <tt>in<\/tt>. The contents\n   * of <tt>in<\/tt> is expected to be in UTF-8 format.\n   *\n   * @param in The input stream to read the schema from.\n   * @return The freshly built Schema.\n   * @throws IOException if there was trouble reading the contents or they are\n   *                     invalid\n   * @deprecated use {@link Schema.Parser} instead.\n   */\n  @Deprecated\n  public static Schema parse(InputStream in) throws IOException {\n    return new Parser().parse(in);\n  }\n\n  /**\n   * Construct a schema from <a href=\"https://json.org/\">JSON<\/a> text.\n   *\n   * @deprecated use {@link Schema.Parser} instead.\n   */\n  @Deprecated\n  public static Schema parse(String jsonSchema) {\n    return new Parser().parse(jsonSchema);\n  }\n\n  /**\n   * Construct a schema from <a href=\"https://json.org/\">JSON<\/a> text.\n   *\n   * @param validate true if names should be validated, false if not.\n   * @deprecated use {@link Schema.Parser} instead.\n   */\n  @Deprecated\n  public static Schema parse(String jsonSchema, boolean validate) {\n    return new Parser().setValidate(validate).parse(jsonSchema);\n  }\n\n  static final Map<String, Type> PRIMITIVES = new HashMap<>();\n  static {\n    PRIMITIVES.put(\"string\", Type.STRING);\n    PRIMITIVES.put(\"bytes\", Type.BYTES);\n    PRIMITIVES.put(\"int\", Type.INT);\n    PRIMITIVES.put(\"long\", Type.LONG);\n    PRIMITIVES.put(\"float\", Type.FLOAT);\n    PRIMITIVES.put(\"double\", Type.DOUBLE);\n    PRIMITIVES.put(\"boolean\", Type.BOOLEAN);\n    PRIMITIVES.put(\"null\", Type.NULL);\n  }\n\n  static class Names extends LinkedHashMap<Name, Schema> {\n    private static final long serialVersionUID = 1L;\n    private String space; // default namespace\n\n    public Names() {\n    }\n\n    public Names(String space) {\n      this.space = space;\n    }\n\n    public String space() {\n      return space;\n    }\n\n    public void space(String space) {\n      this.space = space;\n    }\n\n    public Schema get(String o) {\n      Type primitive = PRIMITIVES.get(o);\n      if (primitive != null) {\n        return Schema.create(primitive);\n      }\n      Name name = new Name(o, space);\n      if (!containsKey(name)) {\n        // if not in default try anonymous\n        name = new Name(o, \"\");\n      }\n      return super.get(name);\n    }\n\n    public boolean contains(Schema schema) {\n      return get(((NamedSchema) schema).name) != null;\n    }\n\n    public void add(Schema schema) {\n      put(((NamedSchema) schema).name, schema);\n    }\n\n    @Override\n    public Schema put(Name name, Schema schema) {\n      if (containsKey(name))\n        throw new SchemaParseException(\"Can't redefine: \" + name);\n      return super.put(name, schema);\n    }\n  }\n\n  private static ThreadLocal<Boolean> validateNames = ThreadLocalWithInitial.of(() -> true);\n\n  private static String validateName(String name) {\n    if (!validateNames.get())\n      return name; // not validating names\n    if (name == null)\n      throw new SchemaParseException(\"Null name\");\n    int length = name.length();\n    if (length == 0)\n      throw new SchemaParseException(\"Empty name\");\n    char first = name.charAt(0);\n    if (!(Character.isLetter(first) || first == '_'))\n      throw new SchemaParseException(\"Illegal initial character: \" + name);\n    for (int i = 1; i < length; i++) {\n      char c = name.charAt(i);\n      if (!(Character.isLetterOrDigit(c) || c == '_'))\n        throw new SchemaParseException(\"Illegal character in: \" + name);\n    }\n    return name;\n  }\n\n  private static final ThreadLocal<Boolean> VALIDATE_DEFAULTS = ThreadLocalWithInitial.of(() -> true);\n\n  private static JsonNode validateDefault(String fieldName, Schema schema, JsonNode defaultValue) {\n    if (VALIDATE_DEFAULTS.get() && (defaultValue != null) && !isValidDefault(schema, defaultValue)) { // invalid default\n      String message = \"Invalid default for field \" + fieldName + \": \" + defaultValue + \" not a \" + schema;\n      throw new AvroTypeException(message); // throw exception\n    }\n    return defaultValue;\n  }\n\n  private static boolean isValidDefault(Schema schema, JsonNode defaultValue) {\n    if (defaultValue == null)\n      return false;\n    switch (schema.getType()) {\n    case STRING:\n    case BYTES:\n    case ENUM:\n    case FIXED:\n      return defaultValue.isTextual();\n    case INT:\n      return defaultValue.isIntegralNumber() && defaultValue.canConvertToInt();\n    case LONG:\n      return defaultValue.isIntegralNumber() && defaultValue.canConvertToLong();\n    case FLOAT:\n    case DOUBLE:\n      return defaultValue.isNumber();\n    case BOOLEAN:\n      return defaultValue.isBoolean();\n    case NULL:\n      return defaultValue.isNull();\n    case ARRAY:\n      if (!defaultValue.isArray())\n        return false;\n      for (JsonNode element : defaultValue)\n        if (!isValidDefault(schema.getElementType(), element))\n          return false;\n      return true;\n    case MAP:\n      if (!defaultValue.isObject())\n        return false;\n      for (JsonNode value : defaultValue)\n        if (!isValidDefault(schema.getValueType(), value))\n          return false;\n      return true;\n    case UNION: // union default: first branch\n      return isValidDefault(schema.getTypes().get(0), defaultValue);\n    case RECORD:\n      if (!defaultValue.isObject())\n        return false;\n      for (Field field : schema.getFields())\n        if (!isValidDefault(field.schema(),\n            defaultValue.has(field.name()) ? defaultValue.get(field.name()) : field.defaultValue()))\n          return false;\n      return true;\n    default:\n      return false;\n    }\n  }\n\n  /** @see #parse(String) */\n  static Schema parse(JsonNode schema, Names names) {\n    if (schema == null) {\n      throw new SchemaParseException(\"Cannot parse <null> schema\");\n    }\n    if (schema.isTextual()) { // name\n      Schema result = names.get(schema.textValue());\n      if (result == null)\n        throw new SchemaParseException(\"Undefined name: \" + schema);\n      return result;\n    } else if (schema.isObject()) {\n      Schema result;\n      String type = getRequiredText(schema, \"type\", \"No type\");\n      Name name = null;\n      String savedSpace = names.space();\n      String doc = null;\n      final boolean isTypeError = \"error\".equals(type);\n      final boolean isTypeRecord = \"record\".equals(type);\n      final boolean isTypeEnum = \"enum\".equals(type);\n      final boolean isTypeFixed = \"fixed\".equals(type);\n      if (isTypeRecord || isTypeError || isTypeEnum || isTypeFixed) {\n        String space = getOptionalText(schema, \"namespace\");\n        doc = getOptionalText(schema, \"doc\");\n        if (space == null)\n          space = savedSpace;\n        name = new Name(getRequiredText(schema, \"name\", \"No name in schema\"), space);\n        names.space(name.space); // set default namespace\n      }\n      if (PRIMITIVES.containsKey(type)) { // primitive\n        result = create(PRIMITIVES.get(type));\n      } else if (isTypeRecord || isTypeError) { // record\n        List<Field> fields = new ArrayList<>();\n        result = new RecordSchema(name, doc, isTypeError);\n        if (name != null)\n          names.add(result);\n        JsonNode fieldsNode = schema.get(\"fields\");\n        if (fieldsNode == null || !fieldsNode.isArray())\n          throw new SchemaParseException(\"Record has no fields: \" + schema);\n        for (JsonNode field : fieldsNode) {\n          String fieldName = getRequiredText(field, \"name\", \"No field name\");\n          String fieldDoc = getOptionalText(field, \"doc\");\n          JsonNode fieldTypeNode = field.get(\"type\");\n          if (fieldTypeNode == null)\n            throw new SchemaParseException(\"No field type: \" + field);\n          if (fieldTypeNode.isTextual() && names.get(fieldTypeNode.textValue()) == null)\n            throw new SchemaParseException(fieldTypeNode + \" is not a defined name.\" + \" The type of the \\\"\" + fieldName\n                + \"\\\" field must be a defined name or a {\\\"type\\\": ...} expression.\");\n          Schema fieldSchema = parse(fieldTypeNode, names);\n          Field.Order order = Field.Order.ASCENDING;\n          JsonNode orderNode = field.get(\"order\");\n          if (orderNode != null)\n            order = Field.Order.valueOf(orderNode.textValue().toUpperCase(Locale.ENGLISH));\n          JsonNode defaultValue = field.get(\"default\");\n          if (defaultValue != null\n              && (Type.FLOAT.equals(fieldSchema.getType()) || Type.DOUBLE.equals(fieldSchema.getType()))\n              && defaultValue.isTextual())\n            defaultValue = new DoubleNode(Double.valueOf(defaultValue.textValue()));\n          Field f = new Field(fieldName, fieldSchema, fieldDoc, defaultValue, true, order);\n          Iterator<String> i = field.fieldNames();\n          while (i.hasNext()) { // add field props\n            String prop = i.next();\n            if (!FIELD_RESERVED.contains(prop))\n              f.addProp(prop, field.get(prop));\n          }\n          f.aliases = parseAliases(field);\n          fields.add(f);\n          if (fieldSchema.getLogicalType() == null && getOptionalText(field, LOGICAL_TYPE_PROP) != null)\n            LOG.warn(\n                \"Ignored the {}.{}.logicalType property (\\\"{}\\\"). It should probably be nested inside the \\\"type\\\" for the field.\",\n                name, fieldName, getOptionalText(field, \"logicalType\"));\n        }\n        result.setFields(fields);\n      } else if (isTypeEnum) { // enum\n        JsonNode symbolsNode = schema.get(\"symbols\");\n        if (symbolsNode == null || !symbolsNode.isArray())\n          throw new SchemaParseException(\"Enum has no symbols: \" + schema);\n        LockableArrayList<String> symbols = new LockableArrayList<>(symbolsNode.size());\n        for (JsonNode n : symbolsNode)\n          symbols.add(n.textValue());\n        JsonNode enumDefault = schema.get(\"default\");\n        String defaultSymbol = null;\n        if (enumDefault != null)\n          defaultSymbol = enumDefault.textValue();\n        result = new EnumSchema(name, doc, symbols, defaultSymbol);\n        if (name != null)\n          names.add(result);\n      } else if (type.equals(\"array\")) { // array\n        JsonNode itemsNode = schema.get(\"items\");\n        if (itemsNode == null)\n          throw new SchemaParseException(\"Array has no items type: \" + schema);\n        result = new ArraySchema(parse(itemsNode, names));\n      } else if (type.equals(\"map\")) { // map\n        JsonNode valuesNode = schema.get(\"values\");\n        if (valuesNode == null)\n          throw new SchemaParseException(\"Map has no values type: \" + schema);\n        result = new MapSchema(parse(valuesNode, names));\n      } else if (isTypeFixed) { // fixed\n        JsonNode sizeNode = schema.get(\"size\");\n        if (sizeNode == null || !sizeNode.isInt())\n          throw new SchemaParseException(\"Invalid or no size: \" + schema);\n        result = new FixedSchema(name, doc, sizeNode.intValue());\n        if (name != null)\n          names.add(result);\n      } else { // For unions with self reference\n        Name nameFromType = new Name(type, names.space);\n        if (names.containsKey(nameFromType)) {\n          return names.get(nameFromType);\n        }\n        throw new SchemaParseException(\"Type not supported: \" + type);\n      }\n      Iterator<String> i = schema.fieldNames();\n\n      Set reserved = SCHEMA_RESERVED;\n      if (isTypeEnum) {\n        reserved = ENUM_RESERVED;\n      }\n      while (i.hasNext()) { // add properties\n        String prop = i.next();\n        if (!reserved.contains(prop)) // ignore reserved\n          result.addProp(prop, schema.get(prop));\n      }\n      // parse logical type if present\n      result.logicalType = LogicalTypes.fromSchemaIgnoreInvalid(result);\n      names.space(savedSpace); // restore space\n      if (result instanceof NamedSchema) {\n        Set<String> aliases = parseAliases(schema);\n        if (aliases != null) // add aliases\n          for (String alias : aliases)\n            result.addAlias(alias);\n      }\n      return result;\n    } else if (schema.isArray()) { // union\n      LockableArrayList<Schema> types = new LockableArrayList<>(schema.size());\n      for (JsonNode typeNode : schema)\n        types.add(parse(typeNode, names));\n      return new UnionSchema(types);\n    } else {\n      throw new SchemaParseException(\"Schema not yet supported: \" + schema);\n    }\n  }\n\n  static Set<String> parseAliases(JsonNode node) {\n    JsonNode aliasesNode = node.get(\"aliases\");\n    if (aliasesNode == null)\n      return null;\n    if (!aliasesNode.isArray())\n      throw new SchemaParseException(\"aliases not an array: \" + node);\n    Set<String> aliases = new LinkedHashSet<>();\n    for (JsonNode aliasNode : aliasesNode) {\n      if (!aliasNode.isTextual())\n        throw new SchemaParseException(\"alias not a string: \" + aliasNode);\n      aliases.add(aliasNode.textValue());\n    }\n    return aliases;\n  }\n\n  /**\n   * Extracts text value associated to key from the container JsonNode, and throws\n   * {@link SchemaParseException} if it doesn't exist.\n   *\n   * @param container Container where to find key.\n   * @param key       Key to look for in container.\n   * @param error     String to prepend to the SchemaParseException.\n   */\n  private static String getRequiredText(JsonNode container, String key, String error) {\n    String out = getOptionalText(container, key);\n    if (null == out) {\n      throw new SchemaParseException(error + \": \" + container);\n    }\n    return out;\n  }\n\n  /** Extracts text value associated to key from the container JsonNode. */\n  private static String getOptionalText(JsonNode container, String key) {\n    JsonNode jsonNode = container.get(key);\n    return jsonNode != null ? jsonNode.textValue() : null;\n  }\n\n  static JsonNode parseJson(String s) {\n    try {\n      return MAPPER.readTree(FACTORY.createParser(s));\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /**\n   * Parses the specified json string to an object.\n   */\n  public static Object parseJsonToObject(String s) {\n    return JacksonUtils.toObject(parseJson(s));\n  }\n\n  /**\n   * Rewrite a writer's schema using the aliases from a reader's schema. This\n   * permits reading records, enums and fixed schemas whose names have changed,\n   * and records whose field names have changed. The returned schema always\n   * contains the same data elements in the same order, but with possibly\n   * different names.\n   */\n  public static Schema applyAliases(Schema writer, Schema reader) {\n    if (writer.equals(reader))\n      return writer; // same schema\n\n    // create indexes of names\n    Map<Schema, Schema> seen = new IdentityHashMap<>(1);\n    Map<Name, Name> aliases = new HashMap<>(1);\n    Map<Name, Map<String, String>> fieldAliases = new HashMap<>(1);\n    getAliases(reader, seen, aliases, fieldAliases);\n\n    if (aliases.size() == 0 && fieldAliases.size() == 0)\n      return writer; // no aliases\n\n    seen.clear();\n    return applyAliases(writer, seen, aliases, fieldAliases);\n  }\n\n  private static Schema applyAliases(Schema s, Map<Schema, Schema> seen, Map<Name, Name> aliases,\n      Map<Name, Map<String, String>> fieldAliases) {\n\n    Name name = s instanceof NamedSchema ? ((NamedSchema) s).name : null;\n    Schema result = s;\n    switch (s.getType()) {\n    case RECORD:\n      if (seen.containsKey(s))\n        return seen.get(s); // break loops\n      if (aliases.containsKey(name))\n        name = aliases.get(name);\n      result = Schema.createRecord(name.full, s.getDoc(), null, s.isError());\n      seen.put(s, result);\n      List<Field> newFields = new ArrayList<>();\n      for (Field f : s.getFields()) {\n        Schema fSchema = applyAliases(f.schema, seen, aliases, fieldAliases);\n        String fName = getFieldAlias(name, f.name, fieldAliases);\n        Field newF = new Field(fName, fSchema, f.doc, f.defaultValue, true, f.order);\n        newF.putAll(f); // copy props\n        newFields.add(newF);\n      }\n      result.setFields(newFields);\n      break;\n    case ENUM:\n      if (aliases.containsKey(name))\n        result = Schema.createEnum(aliases.get(name).full, s.getDoc(), null, s.getEnumSymbols(), s.getEnumDefault());\n      break;\n    case ARRAY:\n      Schema e = applyAliases(s.getElementType(), seen, aliases, fieldAliases);\n      if (!e.equals(s.getElementType()))\n        result = Schema.createArray(e);\n      break;\n    case MAP:\n      Schema v = applyAliases(s.getValueType(), seen, aliases, fieldAliases);\n      if (!v.equals(s.getValueType()))\n        result = Schema.createMap(v);\n      break;\n    case UNION:\n      List<Schema> types = new ArrayList<>();\n      for (Schema branch : s.getTypes())\n        types.add(applyAliases(branch, seen, aliases, fieldAliases));\n      result = Schema.createUnion(types);\n      break;\n    case FIXED:\n      if (aliases.containsKey(name))\n        result = Schema.createFixed(aliases.get(name).full, s.getDoc(), null, s.getFixedSize());\n      break;\n    default:\n      // NO-OP\n    }\n    if (!result.equals(s))\n      result.putAll(s); // copy props\n    return result;\n  }\n\n  private static void getAliases(Schema schema, Map<Schema, Schema> seen, Map<Name, Name> aliases,\n      Map<Name, Map<String, String>> fieldAliases) {\n    if (schema instanceof NamedSchema) {\n      NamedSchema namedSchema = (NamedSchema) schema;\n      if (namedSchema.aliases != null)\n        for (Name alias : namedSchema.aliases)\n          aliases.put(alias, namedSchema.name);\n    }\n    switch (schema.getType()) {\n    case RECORD:\n      if (seen.containsKey(schema))\n        return; // break loops\n      seen.put(schema, schema);\n      RecordSchema record = (RecordSchema) schema;\n      for (Field field : schema.getFields()) {\n        if (field.aliases != null)\n          for (String fieldAlias : field.aliases) {\n            Map<String, String> recordAliases = fieldAliases.computeIfAbsent(record.name, k -> new HashMap<>());\n            recordAliases.put(fieldAlias, field.name);\n          }\n        getAliases(field.schema, seen, aliases, fieldAliases);\n      }\n      if (record.aliases != null && fieldAliases.containsKey(record.name))\n        for (Name recordAlias : record.aliases)\n          fieldAliases.put(recordAlias, fieldAliases.get(record.name));\n      break;\n    case ARRAY:\n      getAliases(schema.getElementType(), seen, aliases, fieldAliases);\n      break;\n    case MAP:\n      getAliases(schema.getValueType(), seen, aliases, fieldAliases);\n      break;\n    case UNION:\n      for (Schema s : schema.getTypes())\n        getAliases(s, seen, aliases, fieldAliases);\n      break;\n    }\n  }\n\n  private static String getFieldAlias(Name record, String field, Map<Name, Map<String, String>> fieldAliases) {\n    Map<String, String> recordAliases = fieldAliases.get(record);\n    if (recordAliases == null)\n      return field;\n    String alias = recordAliases.get(field);\n    if (alias == null)\n      return field;\n    return alias;\n  }\n\n  /**\n   * No change is permitted on LockableArrayList once lock() has been called on\n   * it.\n   *\n   * @param <E>\n   */\n\n  /*\n   * This class keeps a boolean variable <tt>locked<\/tt> which is set to\n   * <tt>true<\/tt> in the lock() method. It's legal to call lock() any number of\n   * times. Any lock() other than the first one is a no-op.\n   *\n   * This class throws <tt>IllegalStateException<\/tt> if a mutating operation is\n   * performed after being locked. Since modifications through iterator also use\n   * the list's mutating operations, this effectively blocks all modifications.\n   */\n  static class LockableArrayList<E> extends ArrayList<E> {\n    private static final long serialVersionUID = 1L;\n    private boolean locked = false;\n\n    public LockableArrayList() {\n    }\n\n    public LockableArrayList(int size) {\n      super(size);\n    }\n\n    public LockableArrayList(List<E> types) {\n      super(types);\n    }\n\n    public LockableArrayList(E... types) {\n      super(types.length);\n      Collections.addAll(this, types);\n    }\n\n    public List<E> lock() {\n      locked = true;\n      return this;\n    }\n\n    private void ensureUnlocked() {\n      if (locked) {\n        throw new IllegalStateException();\n      }\n    }\n\n    @Override\n    public boolean add(E e) {\n      ensureUnlocked();\n      return super.add(e);\n    }\n\n    @Override\n    public boolean remove(Object o) {\n      ensureUnlocked();\n      return super.remove(o);\n    }\n\n    @Override\n    public E remove(int index) {\n      ensureUnlocked();\n      return super.remove(index);\n    }\n\n    @Override\n    public boolean addAll(Collection<? extends E> c) {\n      ensureUnlocked();\n      return super.addAll(c);\n    }\n\n    @Override\n    public boolean addAll(int index, Collection<? extends E> c) {\n      ensureUnlocked();\n      return super.addAll(index, c);\n    }\n\n    @Override\n    public boolean removeAll(Collection<?> c) {\n      ensureUnlocked();\n      return super.removeAll(c);\n    }\n\n    @Override\n    public boolean retainAll(Collection<?> c) {\n      ensureUnlocked();\n      return super.retainAll(c);\n    }\n\n    @Override\n    public void clear() {\n      ensureUnlocked();\n      super.clear();\n    }\n  }\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.avro;\n\nimport com.fasterxml.jackson.core.JsonFactory;\nimport com.fasterxml.jackson.core.JsonGenerator;\nimport com.fasterxml.jackson.core.JsonParseException;\nimport com.fasterxml.jackson.core.JsonParser;\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.node.DoubleNode;\nimport com.fasterxml.jackson.databind.node.NullNode;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.Serializable;\nimport java.io.StringWriter;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.IdentityHashMap;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport org.apache.avro.util.internal.Accessor;\nimport org.apache.avro.util.internal.Accessor.FieldAccessor;\nimport org.apache.avro.util.internal.JacksonUtils;\nimport org.apache.avro.util.internal.ThreadLocalWithInitial;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport static org.apache.avro.LogicalType.LOGICAL_TYPE_PROP;\n\n/**\n * An abstract data type.\n * <p>\n * A schema may be one of:\n * <ul>\n * <li>A <i>record<\/i>, mapping field names to field value data;\n * <li>An <i>enum<\/i>, containing one of a small set of symbols;\n * <li>An <i>array<\/i> of values, all of the same schema;\n * <li>A <i>map<\/i>, containing string/value pairs, of a declared schema;\n * <li>A <i>union<\/i> of other schemas;\n * <li>A <i>fixed<\/i> sized binary object;\n * <li>A unicode <i>string<\/i>;\n * <li>A sequence of <i>bytes<\/i>;\n * <li>A 32-bit signed <i>int<\/i>;\n * <li>A 64-bit signed <i>long<\/i>;\n * <li>A 32-bit IEEE single-<i>float<\/i>; or\n * <li>A 64-bit IEEE <i>double<\/i>-float; or\n * <li>A <i>boolean<\/i>; or\n * <li><i>null<\/i>.\n * <\/ul>\n *\n * A schema can be constructed using one of its static <tt>createXXX<\/tt>\n * methods, or more conveniently using {@link SchemaBuilder}. The schema objects\n * are <i>logically<\/i> immutable. There are only two mutating methods -\n * {@link #setFields(List)} and {@link #addProp(String, String)}. The following\n * restrictions apply on these two methods.\n * <ul>\n * <li>{@link #setFields(List)}, can be called at most once. This method exists\n * in order to enable clients to build recursive schemas.\n * <li>{@link #addProp(String, String)} can be called with property names that\n * are not present already. It is not possible to change or delete an existing\n * property.\n * <\/ul>\n */\npublic abstract class Schema extends JsonProperties implements Serializable {\n\n  private static final long serialVersionUID = 1L;\n\n  protected Object writeReplace() {\n    SerializableSchema ss = new SerializableSchema();\n    ss.schemaString = toString();\n    return ss;\n  }\n\n  private static final class SerializableSchema implements Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    private String schemaString;\n\n    private Object readResolve() {\n      return new Schema.Parser().parse(schemaString);\n    }\n  }\n\n  static final JsonFactory FACTORY = new JsonFactory();\n  static final Logger LOG = LoggerFactory.getLogger(Schema.class);\n  static final ObjectMapper MAPPER = new ObjectMapper(FACTORY);\n\n  private static final int NO_HASHCODE = Integer.MIN_VALUE;\n\n  static {\n    FACTORY.enable(JsonParser.Feature.ALLOW_COMMENTS);\n    FACTORY.setCodec(MAPPER);\n  }\n\n  /** The type of a schema. */\n  public enum Type {\n    RECORD, ENUM, ARRAY, MAP, UNION, FIXED, STRING, BYTES, INT, LONG, FLOAT, DOUBLE, BOOLEAN, NULL;\n\n    private final String name;\n\n    private Type() {\n      this.name = this.name().toLowerCase(Locale.ENGLISH);\n    }\n\n    public String getName() {\n      return name;\n    }\n  };\n\n  private final Type type;\n  private LogicalType logicalType = null;\n\n  Schema(Type type) {\n    super(type == Type.ENUM ? ENUM_RESERVED : SCHEMA_RESERVED);\n    this.type = type;\n  }\n\n  /** Create a schema for a primitive type. */\n  public static Schema create(Type type) {\n    switch (type) {\n    case STRING:\n      return new StringSchema();\n    case BYTES:\n      return new BytesSchema();\n    case INT:\n      return new IntSchema();\n    case LONG:\n      return new LongSchema();\n    case FLOAT:\n      return new FloatSchema();\n    case DOUBLE:\n      return new DoubleSchema();\n    case BOOLEAN:\n      return new BooleanSchema();\n    case NULL:\n      return new NullSchema();\n    default:\n      throw new AvroRuntimeException(\"Can't create a: \" + type);\n    }\n  }\n\n  private static final Set<String> SCHEMA_RESERVED = new HashSet<>(\n      Arrays.asList(\"doc\", \"fields\", \"items\", \"name\", \"namespace\", \"size\", \"symbols\", \"values\", \"type\", \"aliases\"));\n\n  private static final Set<String> ENUM_RESERVED = new HashSet<>(SCHEMA_RESERVED);\n  static {\n    ENUM_RESERVED.add(\"default\");\n  }\n\n  int hashCode = NO_HASHCODE;\n\n  @Override\n  public void addProp(String name, String value) {\n    super.addProp(name, value);\n    hashCode = NO_HASHCODE;\n  }\n\n  @Override\n  public void addProp(String name, Object value) {\n    super.addProp(name, value);\n    hashCode = NO_HASHCODE;\n  }\n\n  public LogicalType getLogicalType() {\n    return logicalType;\n  }\n\n  void setLogicalType(LogicalType logicalType) {\n    this.logicalType = logicalType;\n  }\n\n  /**\n   * Create an anonymous record schema.\n   *\n   * @deprecated This method allows to create Schema objects that cannot be parsed\n   *             by {@link Schema.Parser#parse(String)}. It will be removed in a\n   *             future version of Avro. Better use\n   *             i{@link #createRecord(String, String, String, boolean, List)} to\n   *             produce a fully qualified Schema.\n   */\n  @Deprecated\n  public static Schema createRecord(List<Field> fields) {\n    Schema result = createRecord(null, null, null, false);\n    result.setFields(fields);\n    return result;\n  }\n\n  /** Create a named record schema. */\n  public static Schema createRecord(String name, String doc, String namespace, boolean isError) {\n    return new RecordSchema(new Name(name, namespace), doc, isError);\n  }\n\n  /** Create a named record schema with fields already set. */\n  public static Schema createRecord(String name, String doc, String namespace, boolean isError, List<Field> fields) {\n    return new RecordSchema(new Name(name, namespace), doc, isError, fields);\n  }\n\n  /** Create an enum schema. */\n  public static Schema createEnum(String name, String doc, String namespace, List<String> values) {\n    return new EnumSchema(new Name(name, namespace), doc, new LockableArrayList<>(values), null);\n  }\n\n  /** Create an enum schema. */\n  public static Schema createEnum(String name, String doc, String namespace, List<String> values, String enumDefault) {\n    return new EnumSchema(new Name(name, namespace), doc, new LockableArrayList<>(values), enumDefault);\n  }\n\n  /** Create an array schema. */\n  public static Schema createArray(Schema elementType) {\n    return new ArraySchema(elementType);\n  }\n\n  /** Create a map schema. */\n  public static Schema createMap(Schema valueType) {\n    return new MapSchema(valueType);\n  }\n\n  /** Create a union schema. */\n  public static Schema createUnion(List<Schema> types) {\n    return new UnionSchema(new LockableArrayList<>(types));\n  }\n\n  /** Create a union schema. */\n  public static Schema createUnion(Schema... types) {\n    return createUnion(new LockableArrayList<>(types));\n  }\n\n  /** Create a fixed schema. */\n  public static Schema createFixed(String name, String doc, String space, int size) {\n    return new FixedSchema(new Name(name, space), doc, size);\n  }\n\n  /** Return the type of this schema. */\n  public Type getType() {\n    return type;\n  }\n\n  /**\n   * If this is a record, returns the Field with the given name\n   * <tt>fieldName<\/tt>. If there is no field by that name, a <tt>null<\/tt> is\n   * returned.\n   */\n  public Field getField(String fieldname) {\n    throw new AvroRuntimeException(\"Not a record: \" + this);\n  }\n\n  /**\n   * If this is a record, returns the fields in it. The returned list is in the\n   * order of their positions.\n   */\n  public List<Field> getFields() {\n    throw new AvroRuntimeException(\"Not a record: \" + this);\n  }\n\n  /**\n   * If this is a record, returns whether the fields have been set.\n   */\n  public boolean hasFields() {\n    throw new AvroRuntimeException(\"Not a record: \" + this);\n  }\n\n  /**\n   * If this is a record, set its fields. The fields can be set only once in a\n   * schema.\n   */\n  public void setFields(List<Field> fields) {\n    throw new AvroRuntimeException(\"Not a record: \" + this);\n  }\n\n  /** If this is an enum, return its symbols. */\n  public List<String> getEnumSymbols() {\n    throw new AvroRuntimeException(\"Not an enum: \" + this);\n  }\n\n  /** If this is an enum, return its default value. */\n  public String getEnumDefault() {\n    throw new AvroRuntimeException(\"Not an enum: \" + this);\n  }\n\n  /** If this is an enum, return a symbol's ordinal value. */\n  public int getEnumOrdinal(String symbol) {\n    throw new AvroRuntimeException(\"Not an enum: \" + this);\n  }\n\n  /** If this is an enum, returns true if it contains given symbol. */\n  public boolean hasEnumSymbol(String symbol) {\n    throw new AvroRuntimeException(\"Not an enum: \" + this);\n  }\n\n  /**\n   * If this is a record, enum or fixed, returns its name, otherwise the name of\n   * the primitive type.\n   */\n  public String getName() {\n    return type.name;\n  }\n\n  /**\n   * If this is a record, enum, or fixed, returns its docstring, if available.\n   * Otherwise, returns null.\n   */\n  public String getDoc() {\n    return null;\n  }\n\n  /** If this is a record, enum or fixed, returns its namespace, if any. */\n  public String getNamespace() {\n    throw new AvroRuntimeException(\"Not a named type: \" + this);\n  }\n\n  /**\n   * If this is a record, enum or fixed, returns its namespace-qualified name,\n   * otherwise returns the name of the primitive type.\n   */\n  public String getFullName() {\n    return getName();\n  }\n\n  /** If this is a record, enum or fixed, add an alias. */\n  public void addAlias(String alias) {\n    throw new AvroRuntimeException(\"Not a named type: \" + this);\n  }\n\n  /** If this is a record, enum or fixed, add an alias. */\n  public void addAlias(String alias, String space) {\n    throw new AvroRuntimeException(\"Not a named type: \" + this);\n  }\n\n  /** If this is a record, enum or fixed, return its aliases, if any. */\n  public Set<String> getAliases() {\n    throw new AvroRuntimeException(\"Not a named type: \" + this);\n  }\n\n  /** Returns true if this record is an error type. */\n  public boolean isError() {\n    throw new AvroRuntimeException(\"Not a record: \" + this);\n  }\n\n  /** If this is an array, returns its element type. */\n  public Schema getElementType() {\n    throw new AvroRuntimeException(\"Not an array: \" + this);\n  }\n\n  /** If this is a map, returns its value type. */\n  public Schema getValueType() {\n    throw new AvroRuntimeException(\"Not a map: \" + this);\n  }\n\n  /** If this is a union, returns its types. */\n  public List<Schema> getTypes() {\n    throw new AvroRuntimeException(\"Not a union: \" + this);\n  }\n\n  /** If this is a union, return the branch with the provided full name. */\n  public Integer getIndexNamed(String name) {\n    throw new AvroRuntimeException(\"Not a union: \" + this);\n  }\n\n  /** If this is fixed, returns its size. */\n  public int getFixedSize() {\n    throw new AvroRuntimeException(\"Not fixed: \" + this);\n  }\n\n  /** Render this as <a href=\"https://json.org/\">JSON<\/a>. */\n  @Override\n  public String toString() {\n    return toString(false);\n  }\n\n  /**\n   * Render this as <a href=\"https://json.org/\">JSON<\/a>.\n   *\n   * @param pretty if true, pretty-print JSON.\n   */\n  public String toString(boolean pretty) {\n    return toString(new Names(), pretty);\n  }\n\n  /**\n   * Render this as <a href=\"https://json.org/\">JSON<\/a>, but without inlining the\n   * referenced schemas.\n   *\n   * @param referencedSchemas referenced schemas\n   * @param pretty            if true, pretty-print JSON.\n   */\n  // Use at your own risk. This method should be removed with AVRO-2832.\n  @Deprecated\n  public String toString(Collection<Schema> referencedSchemas, boolean pretty) {\n    Schema.Names names = new Schema.Names();\n    if (referencedSchemas != null) {\n      for (Schema s : referencedSchemas) {\n        names.add(s);\n      }\n    }\n    return toString(names, pretty);\n  }\n\n  String toString(Names names, boolean pretty) {\n    try {\n      StringWriter writer = new StringWriter();\n      JsonGenerator gen = FACTORY.createGenerator(writer);\n      if (pretty)\n        gen.useDefaultPrettyPrinter();\n      toJson(names, gen);\n      gen.flush();\n      return writer.toString();\n    } catch (IOException e) {\n      throw new AvroRuntimeException(e);\n    }\n  }\n\n  void toJson(Names names, JsonGenerator gen) throws IOException {\n    if (!hasProps()) { // no props defined\n      gen.writeString(getName()); // just write name\n    } else {\n      gen.writeStartObject();\n      gen.writeStringField(\"type\", getName());\n      writeProps(gen);\n      gen.writeEndObject();\n    }\n  }\n\n  void fieldsToJson(Names names, JsonGenerator gen) throws IOException {\n    throw new AvroRuntimeException(\"Not a record: \" + this);\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (o == this)\n      return true;\n    if (!(o instanceof Schema))\n      return false;\n    Schema that = (Schema) o;\n    if (!(this.type == that.type))\n      return false;\n    return equalCachedHash(that) && propsEqual(that);\n  }\n\n  @Override\n  public final int hashCode() {\n    if (hashCode == NO_HASHCODE)\n      hashCode = computeHash();\n    return hashCode;\n  }\n\n  int computeHash() {\n    return getType().hashCode() + propsHashCode();\n  }\n\n  final boolean equalCachedHash(Schema other) {\n    return (hashCode == other.hashCode) || (hashCode == NO_HASHCODE) || (other.hashCode == NO_HASHCODE);\n  }\n\n  private static final Set<String> FIELD_RESERVED = Collections\n      .unmodifiableSet(new HashSet<>(Arrays.asList(\"default\", \"doc\", \"name\", \"order\", \"type\", \"aliases\")));\n\n  /** Returns true if this record is an union type. */\n  public boolean isUnion() {\n    return this instanceof UnionSchema;\n  }\n\n  /** Returns true if this record is an union type containing null. */\n  public boolean isNullable() {\n    if (!isUnion()) {\n      return getType().equals(Schema.Type.NULL);\n    }\n\n    for (Schema schema : getTypes()) {\n      if (schema.isNullable()) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /** A field within a record. */\n  public static class Field extends JsonProperties {\n\n    static {\n      Accessor.setAccessor(new FieldAccessor() {\n        @Override\n        protected JsonNode defaultValue(Field field) {\n          return field.defaultValue();\n        }\n\n        @Override\n        protected Field createField(String name, Schema schema, String doc, JsonNode defaultValue) {\n          return new Field(name, schema, doc, defaultValue, true, Order.ASCENDING);\n        }\n\n        @Override\n        protected Field createField(String name, Schema schema, String doc, JsonNode defaultValue, boolean validate,\n            Order order) {\n          return new Field(name, schema, doc, defaultValue, validate, order);\n        }\n      });\n    }\n\n    /** How values of this field should be ordered when sorting records. */\n    public enum Order {\n      ASCENDING, DESCENDING, IGNORE;\n\n      private final String name;\n\n      Order() {\n        this.name = this.name().toLowerCase(Locale.ENGLISH);\n      }\n    }\n\n    /**\n     * For Schema unions with a \"null\" type as the first entry, this can be used to\n     * specify that the default for the union is null.\n     */\n    public static final Object NULL_DEFAULT_VALUE = new Object();\n\n    private final String name; // name of the field.\n    private int position = -1;\n    private final Schema schema;\n    private final String doc;\n    private final JsonNode defaultValue;\n    private final Order order;\n    private Set<String> aliases;\n\n    Field(String name, Schema schema, String doc, JsonNode defaultValue, boolean validateDefault, Order order) {\n      super(FIELD_RESERVED);\n      this.name = validateName(name);\n      this.schema = Objects.requireNonNull(schema, \"schema is required and cannot be null\");\n      this.doc = doc;\n      this.defaultValue = validateDefault ? validateDefault(name, schema, defaultValue) : defaultValue;\n      this.order = Objects.requireNonNull(order, \"Order cannot be null\");\n    }\n\n    /**\n     * Constructs a new Field instance with the same {@code name}, {@code doc},\n     * {@code defaultValue}, and {@code order} as {@code field} has with changing\n     * the schema to the specified one. It also copies all the {@code props} and\n     * {@code aliases}.\n     */\n    public Field(Field field, Schema schema) {\n      this(field.name, schema, field.doc, field.defaultValue, true, field.order);\n      putAll(field);\n      if (field.aliases != null)\n        aliases = new LinkedHashSet<>(field.aliases);\n    }\n\n    /**\n     *\n     */\n    public Field(String name, Schema schema) {\n      this(name, schema, (String) null, (JsonNode) null, true, Order.ASCENDING);\n    }\n\n    /**\n     *\n     */\n    public Field(String name, Schema schema, String doc) {\n      this(name, schema, doc, (JsonNode) null, true, Order.ASCENDING);\n    }\n\n    /**\n     * @param defaultValue the default value for this field specified using the\n     *                     mapping in {@link JsonProperties}\n     */\n    public Field(String name, Schema schema, String doc, Object defaultValue) {\n      this(name, schema, doc,\n          defaultValue == NULL_DEFAULT_VALUE ? NullNode.getInstance() : JacksonUtils.toJsonNode(defaultValue), true,\n          Order.ASCENDING);\n    }\n\n    /**\n     * @param defaultValue the default value for this field specified using the\n     *                     mapping in {@link JsonProperties}\n     */\n    public Field(String name, Schema schema, String doc, Object defaultValue, Order order) {\n      this(name, schema, doc,\n          defaultValue == NULL_DEFAULT_VALUE ? NullNode.getInstance() : JacksonUtils.toJsonNode(defaultValue), true,\n          Objects.requireNonNull(order));\n    }\n\n    public String name() {\n      return name;\n    };\n\n    /** The position of this field within the record. */\n    public int pos() {\n      return position;\n    }\n\n    /** This field's {@link Schema}. */\n    public Schema schema() {\n      return schema;\n    }\n\n    /** Field's documentation within the record, if set. May return null. */\n    public String doc() {\n      return doc;\n    }\n\n    /**\n     * @return true if this Field has a default value set. Can be used to determine\n     *         if a \"null\" return from defaultVal() is due to that being the default\n     *         value or just not set.\n     */\n    public boolean hasDefaultValue() {\n      return defaultValue != null;\n    }\n\n    JsonNode defaultValue() {\n      return defaultValue;\n    }\n\n    /**\n     * @return the default value for this field specified using the mapping in\n     *         {@link JsonProperties}\n     */\n    public Object defaultVal() {\n      return JacksonUtils.toObject(defaultValue, schema);\n    }\n\n    public Order order() {\n      return order;\n    }\n\n    public void addAlias(String alias) {\n      if (aliases == null)\n        this.aliases = new LinkedHashSet<>();\n      aliases.add(alias);\n    }\n\n    /** Return the defined aliases as an unmodifiable Set. */\n    public Set<String> aliases() {\n      if (aliases == null)\n        return Collections.emptySet();\n      return Collections.unmodifiableSet(aliases);\n    }\n\n    @Override\n    public boolean equals(Object other) {\n      if (other == this)\n        return true;\n      if (!(other instanceof Field))\n        return false;\n      Field that = (Field) other;\n      return (name.equals(that.name)) && (schema.equals(that.schema)) && defaultValueEquals(that.defaultValue)\n          && (order == that.order) && propsEqual(that);\n    }\n\n    @Override\n    public int hashCode() {\n      return name.hashCode() + schema.computeHash();\n    }\n\n    private boolean defaultValueEquals(JsonNode thatDefaultValue) {\n      if (defaultValue == null)\n        return thatDefaultValue == null;\n      if (thatDefaultValue == null)\n        return false;\n      if (Double.isNaN(defaultValue.doubleValue()))\n        return Double.isNaN(thatDefaultValue.doubleValue());\n      return defaultValue.equals(thatDefaultValue);\n    }\n\n    @Override\n    public String toString() {\n      return name + \" type:\" + schema.type + \" pos:\" + position;\n    }\n  }\n\n  static class Name {\n    private final String name;\n    private final String space;\n    private final String full;\n\n    public Name(String name, String space) {\n      if (name == null) { // anonymous\n        this.name = this.space = this.full = null;\n        return;\n      }\n      int lastDot = name.lastIndexOf('.');\n      if (lastDot < 0) { // unqualified name\n        this.name = validateName(name);\n      } else { // qualified name\n        space = name.substring(0, lastDot); // get space from name\n        this.name = validateName(name.substring(lastDot + 1));\n      }\n      if (\"\".equals(space))\n        space = null;\n      this.space = space;\n      this.full = (this.space == null) ? this.name : this.space + \".\" + this.name;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (o == this)\n        return true;\n      if (!(o instanceof Name))\n        return false;\n      Name that = (Name) o;\n      return Objects.equals(full, that.full);\n    }\n\n    @Override\n    public int hashCode() {\n      return full == null ? 0 : full.hashCode();\n    }\n\n    @Override\n    public String toString() {\n      return full;\n    }\n\n    public void writeName(Names names, JsonGenerator gen) throws IOException {\n      if (name != null)\n        gen.writeStringField(\"name\", name);\n      if (space != null) {\n        if (!space.equals(names.space()))\n          gen.writeStringField(\"namespace\", space);\n      } else if (names.space() != null) { // null within non-null\n        gen.writeStringField(\"namespace\", \"\");\n      }\n    }\n\n    public String getQualified(String defaultSpace) {\n      return this.shouldWriteFull(defaultSpace) ? full : name;\n    }\n\n    /**\n     * Determine if full name must be written. There are 2 cases for true :\n     * defaultSpace != from this.space or name is already a Schema.Type (int, array\n     * ...)\n     *\n     * @param defaultSpace : default name space.\n     * @return true if full name must be written.\n     */\n    private boolean shouldWriteFull(String defaultSpace) {\n      if (space != null && space.equals(defaultSpace)) {\n        for (Type schemaType : Type.values()) {\n          if (schemaType.name.equals(name)) {\n            // name is a 'Type', so namespace must be written\n            return true;\n          }\n        }\n        // this.space == defaultSpace\n        return false;\n      }\n      // this.space != defaultSpace, so namespace must be written.\n      return true;\n    }\n\n  }\n\n  private static abstract class NamedSchema extends Schema {\n    final Name name;\n    final String doc;\n    Set<Name> aliases;\n\n    public NamedSchema(Type type, Name name, String doc) {\n      super(type);\n      this.name = name;\n      this.doc = doc;\n      if (PRIMITIVES.containsKey(name.full)) {\n        throw new AvroTypeException(\"Schemas may not be named after primitives: \" + name.full);\n      }\n    }\n\n    @Override\n    public String getName() {\n      return name.name;\n    }\n\n    @Override\n    public String getDoc() {\n      return doc;\n    }\n\n    @Override\n    public String getNamespace() {\n      return name.space;\n    }\n\n    @Override\n    public String getFullName() {\n      return name.full;\n    }\n\n    @Override\n    public void addAlias(String alias) {\n      addAlias(alias, null);\n    }\n\n    @Override\n    public void addAlias(String name, String space) {\n      if (aliases == null)\n        this.aliases = new LinkedHashSet<>();\n      if (space == null)\n        space = this.name.space;\n      aliases.add(new Name(name, space));\n    }\n\n    @Override\n    public Set<String> getAliases() {\n      Set<String> result = new LinkedHashSet<>();\n      if (aliases != null)\n        for (Name alias : aliases)\n          result.add(alias.full);\n      return result;\n    }\n\n    public boolean writeNameRef(Names names, JsonGenerator gen) throws IOException {\n      if (this.equals(names.get(name))) {\n        gen.writeString(name.getQualified(names.space()));\n        return true;\n      } else if (name.name != null) {\n        names.put(name, this);\n      }\n      return false;\n    }\n\n    public void writeName(Names names, JsonGenerator gen) throws IOException {\n      name.writeName(names, gen);\n    }\n\n    public boolean equalNames(NamedSchema that) {\n      return this.name.equals(that.name);\n    }\n\n    @Override\n    int computeHash() {\n      return super.computeHash() + name.hashCode();\n    }\n\n    public void aliasesToJson(JsonGenerator gen) throws IOException {\n      if (aliases == null || aliases.isEmpty())\n        return;\n      gen.writeFieldName(\"aliases\");\n      gen.writeStartArray();\n      for (Name alias : aliases)\n        gen.writeString(alias.getQualified(name.space));\n      gen.writeEndArray();\n    }\n\n  }\n\n  /**\n   * Useful as key of {@link Map}s when traversing two schemas at the same time\n   * and need to watch for recursion.\n   */\n  public static class SeenPair {\n    private Object s1;\n    private Object s2;\n\n    public SeenPair(Object s1, Object s2) {\n      this.s1 = s1;\n      this.s2 = s2;\n    }\n\n    public boolean equals(Object o) {\n      if (!(o instanceof SeenPair))\n        return false;\n      return this.s1 == ((SeenPair) o).s1 && this.s2 == ((SeenPair) o).s2;\n    }\n\n    @Override\n    public int hashCode() {\n      return System.identityHashCode(s1) + System.identityHashCode(s2);\n    }\n  }\n\n  private static final ThreadLocal<Set> SEEN_EQUALS = ThreadLocalWithInitial.of(HashSet::new);\n  private static final ThreadLocal<Map> SEEN_HASHCODE = ThreadLocalWithInitial.of(IdentityHashMap::new);\n\n  @SuppressWarnings(value = \"unchecked\")\n  private static class RecordSchema extends NamedSchema {\n    private List<Field> fields;\n    private Map<String, Field> fieldMap;\n    private final boolean isError;\n\n    public RecordSchema(Name name, String doc, boolean isError) {\n      super(Type.RECORD, name, doc);\n      this.isError = isError;\n    }\n\n    public RecordSchema(Name name, String doc, boolean isError, List<Field> fields) {\n      super(Type.RECORD, name, doc);\n      this.isError = isError;\n      setFields(fields);\n    }\n\n    @Override\n    public boolean isError() {\n      return isError;\n    }\n\n    @Override\n    public Field getField(String fieldname) {\n      if (fieldMap == null)\n        throw new AvroRuntimeException(\"Schema fields not set yet\");\n      return fieldMap.get(fieldname);\n    }\n\n    @Override\n    public List<Field> getFields() {\n      if (fields == null)\n        throw new AvroRuntimeException(\"Schema fields not set yet\");\n      return fields;\n    }\n\n    @Override\n    public boolean hasFields() {\n      return fields != null;\n    }\n\n    @Override\n    public void setFields(List<Field> fields) {\n      if (this.fields != null) {\n        throw new AvroRuntimeException(\"Fields are already set\");\n      }\n      int i = 0;\n      fieldMap = new HashMap<>(Math.multiplyExact(2, fields.size()));\n      LockableArrayList<Field> ff = new LockableArrayList<>(fields.size());\n      for (Field f : fields) {\n        if (f.position != -1) {\n          throw new AvroRuntimeException(\"Field already used: \" + f);\n        }\n        f.position = i++;\n        final Field existingField = fieldMap.put(f.name(), f);\n        if (existingField != null) {\n          throw new AvroRuntimeException(\n              String.format(\"Duplicate field %s in record %s: %s and %s.\", f.name(), name, f, existingField));\n        }\n        ff.add(f);\n      }\n      this.fields = ff.lock();\n      this.hashCode = NO_HASHCODE;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (o == this)\n        return true;\n      if (!(o instanceof RecordSchema))\n        return false;\n      RecordSchema that = (RecordSchema) o;\n      if (!equalCachedHash(that))\n        return false;\n      if (!equalNames(that))\n        return false;\n      if (!propsEqual(that))\n        return false;\n      Set seen = SEEN_EQUALS.get();\n      SeenPair here = new SeenPair(this, o);\n      if (seen.contains(here))\n        return true; // prevent stack overflow\n      boolean first = seen.isEmpty();\n      try {\n        seen.add(here);\n        return Objects.equals(fields, that.fields);\n      } finally {\n        if (first)\n          seen.clear();\n      }\n    }\n\n    @Override\n    int computeHash() {\n      Map seen = SEEN_HASHCODE.get();\n      if (seen.containsKey(this))\n        return 0; // prevent stack overflow\n      boolean first = seen.isEmpty();\n      try {\n        seen.put(this, this);\n        return super.computeHash() + fields.hashCode();\n      } finally {\n        if (first)\n          seen.clear();\n      }\n    }\n\n    @Override\n    void toJson(Names names, JsonGenerator gen) throws IOException {\n      if (writeNameRef(names, gen))\n        return;\n      String savedSpace = names.space; // save namespace\n      gen.writeStartObject();\n      gen.writeStringField(\"type\", isError ? \"error\" : \"record\");\n      writeName(names, gen);\n      names.space = name.space; // set default namespace\n      if (getDoc() != null)\n        gen.writeStringField(\"doc\", getDoc());\n\n      if (fields != null) {\n        gen.writeFieldName(\"fields\");\n        fieldsToJson(names, gen);\n      }\n\n      writeProps(gen);\n      aliasesToJson(gen);\n      gen.writeEndObject();\n      names.space = savedSpace; // restore namespace\n    }\n\n    @Override\n    void fieldsToJson(Names names, JsonGenerator gen) throws IOException {\n      gen.writeStartArray();\n      for (Field f : fields) {\n        gen.writeStartObject();\n        gen.writeStringField(\"name\", f.name());\n        gen.writeFieldName(\"type\");\n        f.schema().toJson(names, gen);\n        if (f.doc() != null)\n          gen.writeStringField(\"doc\", f.doc());\n        if (f.hasDefaultValue()) {\n          gen.writeFieldName(\"default\");\n          gen.writeTree(f.defaultValue());\n        }\n        if (f.order() != Field.Order.ASCENDING)\n          gen.writeStringField(\"order\", f.order().name);\n        if (f.aliases != null && f.aliases.size() != 0) {\n          gen.writeFieldName(\"aliases\");\n          gen.writeStartArray();\n          for (String alias : f.aliases)\n            gen.writeString(alias);\n          gen.writeEndArray();\n        }\n        f.writeProps(gen);\n        gen.writeEndObject();\n      }\n      gen.writeEndArray();\n    }\n  }\n\n  private static class EnumSchema extends NamedSchema {\n    private final List<String> symbols;\n    private final Map<String, Integer> ordinals;\n    private final String enumDefault;\n\n    public EnumSchema(Name name, String doc, LockableArrayList<String> symbols, String enumDefault) {\n      super(Type.ENUM, name, doc);\n      this.symbols = symbols.lock();\n      this.ordinals = new HashMap<>(Math.multiplyExact(2, symbols.size()));\n      this.enumDefault = enumDefault;\n      int i = 0;\n      for (String symbol : symbols) {\n        if (ordinals.put(validateName(symbol), i++) != null) {\n          throw new SchemaParseException(\"Duplicate enum symbol: \" + symbol);\n        }\n      }\n      if (enumDefault != null && !symbols.contains(enumDefault)) {\n        throw new SchemaParseException(\n            \"The Enum Default: \" + enumDefault + \" is not in the enum symbol set: \" + symbols);\n      }\n    }\n\n    @Override\n    public List<String> getEnumSymbols() {\n      return symbols;\n    }\n\n    @Override\n    public boolean hasEnumSymbol(String symbol) {\n      return ordinals.containsKey(symbol);\n    }\n\n    @Override\n    public int getEnumOrdinal(String symbol) {\n      return ordinals.get(symbol);\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (o == this)\n        return true;\n      if (!(o instanceof EnumSchema))\n        return false;\n      EnumSchema that = (EnumSchema) o;\n      return equalCachedHash(that) && equalNames(that) && symbols.equals(that.symbols) && propsEqual(that);\n    }\n\n    @Override\n    public String getEnumDefault() {\n      return enumDefault;\n    }\n\n    @Override\n    int computeHash() {\n      return super.computeHash() + symbols.hashCode();\n    }\n\n    @Override\n    void toJson(Names names, JsonGenerator gen) throws IOException {\n      if (writeNameRef(names, gen))\n        return;\n      gen.writeStartObject();\n      gen.writeStringField(\"type\", \"enum\");\n      writeName(names, gen);\n      if (getDoc() != null)\n        gen.writeStringField(\"doc\", getDoc());\n      gen.writeArrayFieldStart(\"symbols\");\n      for (String symbol : symbols)\n        gen.writeString(symbol);\n      gen.writeEndArray();\n      if (getEnumDefault() != null)\n        gen.writeStringField(\"default\", getEnumDefault());\n      writeProps(gen);\n      aliasesToJson(gen);\n      gen.writeEndObject();\n    }\n  }\n\n  private static class ArraySchema extends Schema {\n    private final Schema elementType;\n\n    public ArraySchema(Schema elementType) {\n      super(Type.ARRAY);\n      this.elementType = elementType;\n    }\n\n    @Override\n    public Schema getElementType() {\n      return elementType;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (o == this)\n        return true;\n      if (!(o instanceof ArraySchema))\n        return false;\n      ArraySchema that = (ArraySchema) o;\n      return equalCachedHash(that) && elementType.equals(that.elementType) && propsEqual(that);\n    }\n\n    @Override\n    int computeHash() {\n      return super.computeHash() + elementType.computeHash();\n    }\n\n    @Override\n    void toJson(Names names, JsonGenerator gen) throws IOException {\n      gen.writeStartObject();\n      gen.writeStringField(\"type\", \"array\");\n      gen.writeFieldName(\"items\");\n      elementType.toJson(names, gen);\n      writeProps(gen);\n      gen.writeEndObject();\n    }\n  }\n\n  private static class MapSchema extends Schema {\n    private final Schema valueType;\n\n    public MapSchema(Schema valueType) {\n      super(Type.MAP);\n      this.valueType = valueType;\n    }\n\n    @Override\n    public Schema getValueType() {\n      return valueType;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (o == this)\n        return true;\n      if (!(o instanceof MapSchema))\n        return false;\n      MapSchema that = (MapSchema) o;\n      return equalCachedHash(that) && valueType.equals(that.valueType) && propsEqual(that);\n    }\n\n    @Override\n    int computeHash() {\n      return super.computeHash() + valueType.computeHash();\n    }\n\n    @Override\n    void toJson(Names names, JsonGenerator gen) throws IOException {\n      gen.writeStartObject();\n      gen.writeStringField(\"type\", \"map\");\n      gen.writeFieldName(\"values\");\n      valueType.toJson(names, gen);\n      writeProps(gen);\n      gen.writeEndObject();\n    }\n  }\n\n  private static class UnionSchema extends Schema {\n    private final List<Schema> types;\n    private final Map<String, Integer> indexByName;\n\n    public UnionSchema(LockableArrayList<Schema> types) {\n      super(Type.UNION);\n      this.indexByName = new HashMap<>(Math.multiplyExact(2, types.size()));\n      this.types = types.lock();\n      int index = 0;\n      for (Schema type : types) {\n        if (type.getType() == Type.UNION) {\n          throw new AvroRuntimeException(\"Nested union: \" + this);\n        }\n        String name = type.getFullName();\n        if (name == null) {\n          throw new AvroRuntimeException(\"Nameless in union:\" + this);\n        }\n        if (indexByName.put(name, index++) != null) {\n          throw new AvroRuntimeException(\"Duplicate in union:\" + name);\n        }\n      }\n    }\n\n    @Override\n    public List<Schema> getTypes() {\n      return types;\n    }\n\n    @Override\n    public Integer getIndexNamed(String name) {\n      return indexByName.get(name);\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (o == this)\n        return true;\n      if (!(o instanceof UnionSchema))\n        return false;\n      UnionSchema that = (UnionSchema) o;\n      return equalCachedHash(that) && types.equals(that.types) && propsEqual(that);\n    }\n\n    @Override\n    int computeHash() {\n      int hash = super.computeHash();\n      for (Schema type : types)\n        hash += type.computeHash();\n      return hash;\n    }\n\n    @Override\n    public void addProp(String name, String value) {\n      throw new AvroRuntimeException(\"Can't set properties on a union: \" + this);\n    }\n\n    @Override\n    void toJson(Names names, JsonGenerator gen) throws IOException {\n      gen.writeStartArray();\n      for (Schema type : types)\n        type.toJson(names, gen);\n      gen.writeEndArray();\n    }\n  }\n\n  private static class FixedSchema extends NamedSchema {\n    private final int size;\n\n    public FixedSchema(Name name, String doc, int size) {\n      super(Type.FIXED, name, doc);\n      if (size < 0)\n        throw new IllegalArgumentException(\"Invalid fixed size: \" + size);\n      this.size = size;\n    }\n\n    @Override\n    public int getFixedSize() {\n      return size;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (o == this)\n        return true;\n      if (!(o instanceof FixedSchema))\n        return false;\n      FixedSchema that = (FixedSchema) o;\n      return equalCachedHash(that) && equalNames(that) && size == that.size && propsEqual(that);\n    }\n\n    @Override\n    int computeHash() {\n      return super.computeHash() + size;\n    }\n\n    @Override\n    void toJson(Names names, JsonGenerator gen) throws IOException {\n      if (writeNameRef(names, gen))\n        return;\n      gen.writeStartObject();\n      gen.writeStringField(\"type\", \"fixed\");\n      writeName(names, gen);\n      if (getDoc() != null)\n        gen.writeStringField(\"doc\", getDoc());\n      gen.writeNumberField(\"size\", size);\n      writeProps(gen);\n      aliasesToJson(gen);\n      gen.writeEndObject();\n    }\n  }\n\n  private static class StringSchema extends Schema {\n    public StringSchema() {\n      super(Type.STRING);\n    }\n  }\n\n  private static class BytesSchema extends Schema {\n    public BytesSchema() {\n      super(Type.BYTES);\n    }\n  }\n\n  private static class IntSchema extends Schema {\n    public IntSchema() {\n      super(Type.INT);\n    }\n  }\n\n  private static class LongSchema extends Schema {\n    public LongSchema() {\n      super(Type.LONG);\n    }\n  }\n\n  private static class FloatSchema extends Schema {\n    public FloatSchema() {\n      super(Type.FLOAT);\n    }\n  }\n\n  private static class DoubleSchema extends Schema {\n    public DoubleSchema() {\n      super(Type.DOUBLE);\n    }\n  }\n\n  private static class BooleanSchema extends Schema {\n    public BooleanSchema() {\n      super(Type.BOOLEAN);\n    }\n  }\n\n  private static class NullSchema extends Schema {\n    public NullSchema() {\n      super(Type.NULL);\n    }\n  }\n\n  /**\n   * A parser for JSON-format schemas. Each named schema parsed with a parser is\n   * added to the names known to the parser so that subsequently parsed schemas\n   * may refer to it by name.\n   */\n  public static class Parser {\n    private Names names = new Names();\n    private boolean validate = true;\n    private boolean validateDefaults = true;\n\n    /**\n     * Adds the provided types to the set of defined, named types known to this\n     * parser.\n     */\n    public Parser addTypes(Map<String, Schema> types) {\n      for (Schema s : types.values())\n        names.add(s);\n      return this;\n    }\n\n    /** Returns the set of defined, named types known to this parser. */\n    public Map<String, Schema> getTypes() {\n      Map<String, Schema> result = new LinkedHashMap<>();\n      for (Schema s : names.values())\n        result.put(s.getFullName(), s);\n      return result;\n    }\n\n    /** Enable or disable name validation. */\n    public Parser setValidate(boolean validate) {\n      this.validate = validate;\n      return this;\n    }\n\n    /** True iff names are validated. True by default. */\n    public boolean getValidate() {\n      return this.validate;\n    }\n\n    /** Enable or disable default value validation. */\n    public Parser setValidateDefaults(boolean validateDefaults) {\n      this.validateDefaults = validateDefaults;\n      return this;\n    }\n\n    /** True iff default values are validated. False by default. */\n    public boolean getValidateDefaults() {\n      return this.validateDefaults;\n    }\n\n    /**\n     * Parse a schema from the provided file. If named, the schema is added to the\n     * names known to this parser.\n     */\n    public Schema parse(File file) throws IOException {\n      return parse(FACTORY.createParser(file), false);\n    }\n\n    /**\n     * Parse a schema from the provided stream. If named, the schema is added to the\n     * names known to this parser. The input stream stays open after the parsing.\n     */\n    public Schema parse(InputStream in) throws IOException {\n      return parse(FACTORY.createParser(in).disable(JsonParser.Feature.AUTO_CLOSE_SOURCE), true);\n    }\n\n    /** Read a schema from one or more json strings */\n    public Schema parse(String s, String... more) {\n      StringBuilder b = new StringBuilder(s);\n      for (String part : more)\n        b.append(part);\n      return parse(b.toString());\n    }\n\n    /**\n     * Parse a schema from the provided string. If named, the schema is added to the\n     * names known to this parser.\n     */\n    public Schema parse(String s) {\n      try {\n        return parse(FACTORY.createParser(s), false);\n      } catch (IOException e) {\n        throw new SchemaParseException(e);\n      }\n    }\n\n    private Schema parse(JsonParser parser, boolean allowDanglingContent) throws IOException {\n      boolean saved = validateNames.get();\n      boolean savedValidateDefaults = VALIDATE_DEFAULTS.get();\n      try {\n        validateNames.set(validate);\n        VALIDATE_DEFAULTS.set(validateDefaults);\n        JsonNode jsonNode = MAPPER.readTree(parser);\n        Schema schema = Schema.parse(jsonNode, names);\n        if (!allowDanglingContent) {\n          String dangling;\n          StringWriter danglingWriter = new StringWriter();\n          int numCharsReleased = parser.releaseBuffered(danglingWriter);\n          if (numCharsReleased == -1) {\n            ByteArrayOutputStream danglingOutputStream = new ByteArrayOutputStream();\n            parser.releaseBuffered(danglingOutputStream); // if input isnt chars above it must be bytes\n            dangling = new String(danglingOutputStream.toByteArray(), StandardCharsets.UTF_8).trim();\n          } else {\n            dangling = danglingWriter.toString().trim();\n          }\n          if (!dangling.isEmpty()) {\n            throw new SchemaParseException(\"dangling content after end of schema: \" + dangling);\n          }\n        }\n        return schema;\n      } catch (JsonParseException e) {\n        throw new SchemaParseException(e);\n      } finally {\n        parser.close();\n        validateNames.set(saved);\n        VALIDATE_DEFAULTS.set(savedValidateDefaults);\n      }\n    }\n  }\n\n  /**\n   * Constructs a Schema object from JSON schema file <tt>file<\/tt>. The contents\n   * of <tt>file<\/tt> is expected to be in UTF-8 format.\n   *\n   * @param file The file to read the schema from.\n   * @return The freshly built Schema.\n   * @throws IOException if there was trouble reading the contents or they are\n   *                     invalid\n   * @deprecated use {@link Schema.Parser} instead.\n   */\n  @Deprecated\n  public static Schema parse(File file) throws IOException {\n    return new Parser().parse(file);\n  }\n\n  /**\n   * Constructs a Schema object from JSON schema stream <tt>in<\/tt>. The contents\n   * of <tt>in<\/tt> is expected to be in UTF-8 format.\n   *\n   * @param in The input stream to read the schema from.\n   * @return The freshly built Schema.\n   * @throws IOException if there was trouble reading the contents or they are\n   *                     invalid\n   * @deprecated use {@link Schema.Parser} instead.\n   */\n  @Deprecated\n  public static Schema parse(InputStream in) throws IOException {\n    return new Parser().parse(in);\n  }\n\n  /**\n   * Construct a schema from <a href=\"https://json.org/\">JSON<\/a> text.\n   *\n   * @deprecated use {@link Schema.Parser} instead.\n   */\n  @Deprecated\n  public static Schema parse(String jsonSchema) {\n    return new Parser().parse(jsonSchema);\n  }\n\n  /**\n   * Construct a schema from <a href=\"https://json.org/\">JSON<\/a> text.\n   *\n   * @param validate true if names should be validated, false if not.\n   * @deprecated use {@link Schema.Parser} instead.\n   */\n  @Deprecated\n  public static Schema parse(String jsonSchema, boolean validate) {\n    return new Parser().setValidate(validate).parse(jsonSchema);\n  }\n\n  static final Map<String, Type> PRIMITIVES = new HashMap<>();\n  static {\n    PRIMITIVES.put(\"string\", Type.STRING);\n    PRIMITIVES.put(\"bytes\", Type.BYTES);\n    PRIMITIVES.put(\"int\", Type.INT);\n    PRIMITIVES.put(\"long\", Type.LONG);\n    PRIMITIVES.put(\"float\", Type.FLOAT);\n    PRIMITIVES.put(\"double\", Type.DOUBLE);\n    PRIMITIVES.put(\"boolean\", Type.BOOLEAN);\n    PRIMITIVES.put(\"null\", Type.NULL);\n  }\n\n  static class Names extends LinkedHashMap<Name, Schema> {\n    private static final long serialVersionUID = 1L;\n    private String space; // default namespace\n\n    public Names() {\n    }\n\n    public Names(String space) {\n      this.space = space;\n    }\n\n    public String space() {\n      return space;\n    }\n\n    public void space(String space) {\n      this.space = space;\n    }\n\n    public Schema get(String o) {\n      Type primitive = PRIMITIVES.get(o);\n      if (primitive != null) {\n        return Schema.create(primitive);\n      }\n      Name name = new Name(o, space);\n      if (!containsKey(name)) {\n        // if not in default try anonymous\n        name = new Name(o, \"\");\n      }\n      return super.get(name);\n    }\n\n    public boolean contains(Schema schema) {\n      return get(((NamedSchema) schema).name) != null;\n    }\n\n    public void add(Schema schema) {\n      put(((NamedSchema) schema).name, schema);\n    }\n\n    @Override\n    public Schema put(Name name, Schema schema) {\n      if (containsKey(name))\n        throw new SchemaParseException(\"Can't redefine: \" + name);\n      return super.put(name, schema);\n    }\n  }\n\n  private static ThreadLocal<Boolean> validateNames = ThreadLocalWithInitial.of(() -> true);\n\n  private static String validateName(String name) {\n    if (!validateNames.get())\n      return name; // not validating names\n    if (name == null)\n      throw new SchemaParseException(\"Null name\");\n    int length = name.length();\n    if (length == 0)\n      throw new SchemaParseException(\"Empty name\");\n    char first = name.charAt(0);\n    if (!(Character.isLetter(first) || first == '_'))\n      throw new SchemaParseException(\"Illegal initial character: \" + name);\n    for (int i = 1; i < length; i++) {\n      char c = name.charAt(i);\n      if (!(Character.isLetterOrDigit(c) || c == '_'))\n        throw new SchemaParseException(\"Illegal character in: \" + name);\n    }\n    return name;\n  }\n\n  private static final ThreadLocal<Boolean> VALIDATE_DEFAULTS = ThreadLocalWithInitial.of(() -> true);\n\n  private static JsonNode validateDefault(String fieldName, Schema schema, JsonNode defaultValue) {\n    if (VALIDATE_DEFAULTS.get() && (defaultValue != null) && !isValidDefault(schema, defaultValue)) { // invalid default\n      String message = \"Invalid default for field \" + fieldName + \": \" + defaultValue + \" not a \" + schema;\n      throw new AvroTypeException(message); // throw exception\n    }\n    return defaultValue;\n  }\n\n  private static boolean isValidDefault(Schema schema, JsonNode defaultValue) {\n    if (defaultValue == null)\n      return false;\n    switch (schema.getType()) {\n    case STRING:\n    case BYTES:\n    case ENUM:\n    case FIXED:\n      return defaultValue.isTextual();\n    case INT:\n      return defaultValue.isIntegralNumber() && defaultValue.canConvertToInt();\n    case LONG:\n      return defaultValue.isIntegralNumber() && defaultValue.canConvertToLong();\n    case FLOAT:\n    case DOUBLE:\n      return defaultValue.isNumber();\n    case BOOLEAN:\n      return defaultValue.isBoolean();\n    case NULL:\n      return defaultValue.isNull();\n    case ARRAY:\n      if (!defaultValue.isArray())\n        return false;\n      for (JsonNode element : defaultValue)\n        if (!isValidDefault(schema.getElementType(), element))\n          return false;\n      return true;\n    case MAP:\n      if (!defaultValue.isObject())\n        return false;\n      for (JsonNode value : defaultValue)\n        if (!isValidDefault(schema.getValueType(), value))\n          return false;\n      return true;\n    case UNION: // union default: first branch\n      return isValidDefault(schema.getTypes().get(0), defaultValue);\n    case RECORD:\n      if (!defaultValue.isObject())\n        return false;\n      for (Field field : schema.getFields())\n        if (!isValidDefault(field.schema(),\n            defaultValue.has(field.name()) ? defaultValue.get(field.name()) : field.defaultValue()))\n          return false;\n      return true;\n    default:\n      return false;\n    }\n  }\n\n  /** @see #parse(String) */\n  static Schema parse(JsonNode schema, Names names) {\n    if (schema == null) {\n      throw new SchemaParseException(\"Cannot parse <null> schema\");\n    }\n    if (schema.isTextual()) { // name\n      Schema result = names.get(schema.textValue());\n      if (result == null)\n        throw new SchemaParseException(\"Undefined name: \" + schema);\n      return result;\n    } else if (schema.isObject()) {\n      Schema result;\n      String type = getRequiredText(schema, \"type\", \"No type\");\n      Name name = null;\n      String savedSpace = names.space();\n      String doc = null;\n      final boolean isTypeError = \"error\".equals(type);\n      final boolean isTypeRecord = \"record\".equals(type);\n      final boolean isTypeEnum = \"enum\".equals(type);\n      final boolean isTypeFixed = \"fixed\".equals(type);\n      if (isTypeRecord || isTypeError || isTypeEnum || isTypeFixed) {\n        String space = getOptionalText(schema, \"namespace\");\n        doc = getOptionalText(schema, \"doc\");\n        if (space == null)\n          space = savedSpace;\n        name = new Name(getRequiredText(schema, \"name\", \"No name in schema\"), space);\n        names.space(name.space); // set default namespace\n      }\n      if (PRIMITIVES.containsKey(type)) { // primitive\n        result = create(PRIMITIVES.get(type));\n      } else if (isTypeRecord || isTypeError) { // record\n        List<Field> fields = new ArrayList<>();\n        result = new RecordSchema(name, doc, isTypeError);\n        if (name != null)\n          names.add(result);\n        JsonNode fieldsNode = schema.get(\"fields\");\n        if (fieldsNode == null || !fieldsNode.isArray())\n          throw new SchemaParseException(\"Record has no fields: \" + schema);\n        for (JsonNode field : fieldsNode) {\n          String fieldName = getRequiredText(field, \"name\", \"No field name\");\n          String fieldDoc = getOptionalText(field, \"doc\");\n          JsonNode fieldTypeNode = field.get(\"type\");\n          if (fieldTypeNode == null)\n            throw new SchemaParseException(\"No field type: \" + field);\n          if (fieldTypeNode.isTextual() && names.get(fieldTypeNode.textValue()) == null)\n            throw new SchemaParseException(fieldTypeNode + \" is not a defined name.\" + \" The type of the \\\"\" + fieldName\n                + \"\\\" field must be a defined name or a {\\\"type\\\": ...} expression.\");\n          Schema fieldSchema = parse(fieldTypeNode, names);\n          Field.Order order = Field.Order.ASCENDING;\n          JsonNode orderNode = field.get(\"order\");\n          if (orderNode != null)\n            order = Field.Order.valueOf(orderNode.textValue().toUpperCase(Locale.ENGLISH));\n          JsonNode defaultValue = field.get(\"default\");\n          if (defaultValue != null\n              && (Type.FLOAT.equals(fieldSchema.getType()) || Type.DOUBLE.equals(fieldSchema.getType()))\n              && defaultValue.isTextual())\n            defaultValue = new DoubleNode(Double.valueOf(defaultValue.textValue()));\n          Field f = new Field(fieldName, fieldSchema, fieldDoc, defaultValue, true, order);\n          Iterator<String> i = field.fieldNames();\n          while (i.hasNext()) { // add field props\n            String prop = i.next();\n            if (!FIELD_RESERVED.contains(prop))\n              f.addProp(prop, field.get(prop));\n          }\n          f.aliases = parseAliases(field);\n          fields.add(f);\n          if (fieldSchema.getLogicalType() == null && getOptionalText(field, LOGICAL_TYPE_PROP) != null)\n            LOG.warn(\n                \"Ignored the {}.{}.logicalType property (\\\"{}\\\"). It should probably be nested inside the \\\"type\\\" for the field.\",\n                name, fieldName, getOptionalText(field, \"logicalType\"));\n        }\n        result.setFields(fields);\n      } else if (isTypeEnum) { // enum\n        JsonNode symbolsNode = schema.get(\"symbols\");\n        if (symbolsNode == null || !symbolsNode.isArray())\n          throw new SchemaParseException(\"Enum has no symbols: \" + schema);\n        LockableArrayList<String> symbols = new LockableArrayList<>(symbolsNode.size());\n        for (JsonNode n : symbolsNode)\n          symbols.add(n.textValue());\n        JsonNode enumDefault = schema.get(\"default\");\n        String defaultSymbol = null;\n        if (enumDefault != null)\n          defaultSymbol = enumDefault.textValue();\n        result = new EnumSchema(name, doc, symbols, defaultSymbol);\n        if (name != null)\n          names.add(result);\n      } else if (type.equals(\"array\")) { // array\n        JsonNode itemsNode = schema.get(\"items\");\n        if (itemsNode == null)\n          throw new SchemaParseException(\"Array has no items type: \" + schema);\n        result = new ArraySchema(parse(itemsNode, names));\n      } else if (type.equals(\"map\")) { // map\n        JsonNode valuesNode = schema.get(\"values\");\n        if (valuesNode == null)\n          throw new SchemaParseException(\"Map has no values type: \" + schema);\n        result = new MapSchema(parse(valuesNode, names));\n      } else if (isTypeFixed) { // fixed\n        JsonNode sizeNode = schema.get(\"size\");\n        if (sizeNode == null || !sizeNode.isInt())\n          throw new SchemaParseException(\"Invalid or no size: \" + schema);\n        result = new FixedSchema(name, doc, sizeNode.intValue());\n        if (name != null)\n          names.add(result);\n      } else { // For unions with self reference\n        Name nameFromType = new Name(type, names.space);\n        if (names.containsKey(nameFromType)) {\n          return names.get(nameFromType);\n        }\n        throw new SchemaParseException(\"Type not supported: \" + type);\n      }\n      Iterator<String> i = schema.fieldNames();\n\n      Set reserved = SCHEMA_RESERVED;\n      if (isTypeEnum) {\n        reserved = ENUM_RESERVED;\n      }\n      while (i.hasNext()) { // add properties\n        String prop = i.next();\n        if (!reserved.contains(prop)) // ignore reserved\n          result.addProp(prop, schema.get(prop));\n      }\n      // parse logical type if present\n      result.logicalType = LogicalTypes.fromSchemaIgnoreInvalid(result);\n      names.space(savedSpace); // restore space\n      if (result instanceof NamedSchema) {\n        Set<String> aliases = parseAliases(schema);\n        if (aliases != null) // add aliases\n          for (String alias : aliases)\n            result.addAlias(alias);\n      }\n      return result;\n    } else if (schema.isArray()) { // union\n      LockableArrayList<Schema> types = new LockableArrayList<>(schema.size());\n      for (JsonNode typeNode : schema)\n        types.add(parse(typeNode, names));\n      return new UnionSchema(types);\n    } else {\n      throw new SchemaParseException(\"Schema not yet supported: \" + schema);\n    }\n  }\n\n  static Set<String> parseAliases(JsonNode node) {\n    JsonNode aliasesNode = node.get(\"aliases\");\n    if (aliasesNode == null)\n      return null;\n    if (!aliasesNode.isArray())\n      throw new SchemaParseException(\"aliases not an array: \" + node);\n    Set<String> aliases = new LinkedHashSet<>();\n    for (JsonNode aliasNode : aliasesNode) {\n      if (!aliasNode.isTextual())\n        throw new SchemaParseException(\"alias not a string: \" + aliasNode);\n      aliases.add(aliasNode.textValue());\n    }\n    return aliases;\n  }\n\n  /**\n   * Extracts text value associated to key from the container JsonNode, and throws\n   * {@link SchemaParseException} if it doesn't exist.\n   *\n   * @param container Container where to find key.\n   * @param key       Key to look for in container.\n   * @param error     String to prepend to the SchemaParseException.\n   */\n  private static String getRequiredText(JsonNode container, String key, String error) {\n    String out = getOptionalText(container, key);\n    if (null == out) {\n      throw new SchemaParseException(error + \": \" + container);\n    }\n    return out;\n  }\n\n  /** Extracts text value associated to key from the container JsonNode. */\n  private static String getOptionalText(JsonNode container, String key) {\n    JsonNode jsonNode = container.get(key);\n    return jsonNode != null ? jsonNode.textValue() : null;\n  }\n\n  static JsonNode parseJson(String s) {\n    try {\n      return MAPPER.readTree(FACTORY.createParser(s));\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /**\n   * Parses the specified json string to an object.\n   */\n  public static Object parseJsonToObject(String s) {\n    return JacksonUtils.toObject(parseJson(s));\n  }\n\n  /**\n   * Rewrite a writer's schema using the aliases from a reader's schema. This\n   * permits reading records, enums and fixed schemas whose names have changed,\n   * and records whose field names have changed. The returned schema always\n   * contains the same data elements in the same order, but with possibly\n   * different names.\n   */\n  public static Schema applyAliases(Schema writer, Schema reader) {\n    if (writer.equals(reader))\n      return writer; // same schema\n\n    // create indexes of names\n    Map<Schema, Schema> seen = new IdentityHashMap<>(1);\n    Map<Name, Name> aliases = new HashMap<>(1);\n    Map<Name, Map<String, String>> fieldAliases = new HashMap<>(1);\n    getAliases(reader, seen, aliases, fieldAliases);\n\n    if (aliases.size() == 0 && fieldAliases.size() == 0)\n      return writer; // no aliases\n\n    seen.clear();\n    return applyAliases(writer, seen, aliases, fieldAliases);\n  }\n\n  private static Schema applyAliases(Schema s, Map<Schema, Schema> seen, Map<Name, Name> aliases,\n      Map<Name, Map<String, String>> fieldAliases) {\n\n    Name name = s instanceof NamedSchema ? ((NamedSchema) s).name : null;\n    Schema result = s;\n    switch (s.getType()) {\n    case RECORD:\n      if (seen.containsKey(s))\n        return seen.get(s); // break loops\n      if (aliases.containsKey(name))\n        name = aliases.get(name);\n      result = Schema.createRecord(name.full, s.getDoc(), null, s.isError());\n      seen.put(s, result);\n      List<Field> newFields = new ArrayList<>();\n      for (Field f : s.getFields()) {\n        Schema fSchema = applyAliases(f.schema, seen, aliases, fieldAliases);\n        String fName = getFieldAlias(name, f.name, fieldAliases);\n        Field newF = new Field(fName, fSchema, f.doc, f.defaultValue, true, f.order);\n        newF.putAll(f); // copy props\n        newFields.add(newF);\n      }\n      result.setFields(newFields);\n      break;\n    case ENUM:\n      if (aliases.containsKey(name))\n        result = Schema.createEnum(aliases.get(name).full, s.getDoc(), null, s.getEnumSymbols(), s.getEnumDefault());\n      break;\n    case ARRAY:\n      Schema e = applyAliases(s.getElementType(), seen, aliases, fieldAliases);\n      if (!e.equals(s.getElementType()))\n        result = Schema.createArray(e);\n      break;\n    case MAP:\n      Schema v = applyAliases(s.getValueType(), seen, aliases, fieldAliases);\n      if (!v.equals(s.getValueType()))\n        result = Schema.createMap(v);\n      break;\n    case UNION:\n      List<Schema> types = new ArrayList<>();\n      for (Schema branch : s.getTypes())\n        types.add(applyAliases(branch, seen, aliases, fieldAliases));\n      result = Schema.createUnion(types);\n      break;\n    case FIXED:\n      if (aliases.containsKey(name))\n        result = Schema.createFixed(aliases.get(name).full, s.getDoc(), null, s.getFixedSize());\n      break;\n    default:\n      // NO-OP\n    }\n    if (!result.equals(s))\n      result.putAll(s); // copy props\n    return result;\n  }\n\n  private static void getAliases(Schema schema, Map<Schema, Schema> seen, Map<Name, Name> aliases,\n      Map<Name, Map<String, String>> fieldAliases) {\n    if (schema instanceof NamedSchema) {\n      NamedSchema namedSchema = (NamedSchema) schema;\n      if (namedSchema.aliases != null)\n        for (Name alias : namedSchema.aliases)\n          aliases.put(alias, namedSchema.name);\n    }\n    switch (schema.getType()) {\n    case RECORD:\n      if (seen.containsKey(schema))\n        return; // break loops\n      seen.put(schema, schema);\n      RecordSchema record = (RecordSchema) schema;\n      for (Field field : schema.getFields()) {\n        if (field.aliases != null)\n          for (String fieldAlias : field.aliases) {\n            Map<String, String> recordAliases = fieldAliases.computeIfAbsent(record.name, k -> new HashMap<>());\n            recordAliases.put(fieldAlias, field.name);\n          }\n        getAliases(field.schema, seen, aliases, fieldAliases);\n      }\n      if (record.aliases != null && fieldAliases.containsKey(record.name))\n        for (Name recordAlias : record.aliases)\n          fieldAliases.put(recordAlias, fieldAliases.get(record.name));\n      break;\n    case ARRAY:\n      getAliases(schema.getElementType(), seen, aliases, fieldAliases);\n      break;\n    case MAP:\n      getAliases(schema.getValueType(), seen, aliases, fieldAliases);\n      break;\n    case UNION:\n      for (Schema s : schema.getTypes())\n        getAliases(s, seen, aliases, fieldAliases);\n      break;\n    }\n  }\n\n  private static String getFieldAlias(Name record, String field, Map<Name, Map<String, String>> fieldAliases) {\n    Map<String, String> recordAliases = fieldAliases.get(record);\n    if (recordAliases == null)\n      return field;\n    String alias = recordAliases.get(field);\n    if (alias == null)\n      return field;\n    return alias;\n  }\n\n  /**\n   * No change is permitted on LockableArrayList once lock() has been called on\n   * it.\n   *\n   * @param <E>\n   */\n\n  /*\n   * This class keeps a boolean variable <tt>locked<\/tt> which is set to\n   * <tt>true<\/tt> in the lock() method. It's legal to call lock() any number of\n   * times. Any lock() other than the first one is a no-op.\n   *\n   * This class throws <tt>IllegalStateException<\/tt> if a mutating operation is\n   * performed after being locked. Since modifications through iterator also use\n   * the list's mutating operations, this effectively blocks all modifications.\n   */\n  static class LockableArrayList<E> extends ArrayList<E> {\n    private static final long serialVersionUID = 1L;\n    private boolean locked = false;\n\n    public LockableArrayList() {\n    }\n\n    public LockableArrayList(int size) {\n      super(size);\n    }\n\n    public LockableArrayList(List<E> types) {\n      super(types);\n    }\n\n    public LockableArrayList(E... types) {\n      super(types.length);\n      Collections.addAll(this, types);\n    }\n\n    public List<E> lock() {\n      locked = true;\n      return this;\n    }\n\n    private void ensureUnlocked() {\n      if (locked) {\n        throw new IllegalStateException();\n      }\n    }\n\n    @Override\n    public boolean add(E e) {\n      ensureUnlocked();\n      return super.add(e);\n    }\n\n    @Override\n    public boolean remove(Object o) {\n      ensureUnlocked();\n      return super.remove(o);\n    }\n\n    @Override\n    public E remove(int index) {\n      ensureUnlocked();\n      return super.remove(index);\n    }\n\n    @Override\n    public boolean addAll(Collection<? extends E> c) {\n      ensureUnlocked();\n      return super.addAll(c);\n    }\n\n    @Override\n    public boolean addAll(int index, Collection<? extends E> c) {\n      ensureUnlocked();\n      return super.addAll(index, c);\n    }\n\n    @Override\n    public boolean removeAll(Collection<?> c) {\n      ensureUnlocked();\n      return super.removeAll(c);\n    }\n\n    @Override\n    public boolean retainAll(Collection<?> c) {\n      ensureUnlocked();\n      return super.retainAll(c);\n    }\n\n    @Override\n    public void clear() {\n      ensureUnlocked();\n      super.clear();\n    }\n  }\n}\n","lineNo":1471}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.avro;\n\nimport static org.junit.Assert.assertArrayEquals;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotEquals;\nimport static org.junit.Assert.assertNotNull;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Objects;\n\nimport org.apache.avro.file.DataFileReader;\nimport org.apache.avro.generic.GenericDatumReader;\nimport org.apache.avro.io.DatumReader;\nimport org.apache.avro.specific.SpecificDatumReader;\nimport org.junit.BeforeClass;\nimport org.junit.Test;\n\npublic class DataFileInteropTest {\n\n  private static final File DATAFILE_DIR = new File(System.getProperty(\"test.dir\", \"/tmp\"));\n\n  @BeforeClass\n  public static void printDir() {\n    System.out.println(\"Reading data files from directory: \" + DATAFILE_DIR.getAbsolutePath());\n  }\n\n  @Test\n  public void testGeneratedGeneric() throws IOException {\n    System.out.println(\"Reading with generic:\");\n    DatumReaderProvider<Object> provider = GenericDatumReader::new;\n    readFiles(provider);\n  }\n\n  @Test\n  public void testGeneratedSpecific() throws IOException {\n    System.out.println(\"Reading with specific:\");\n    DatumReaderProvider<Interop> provider = SpecificDatumReader::new;\n    readFiles(provider);\n  }\n\n  // Can't use same Interop.java as specific for reflect.\n  // This used to be the case because one used Utf8 and the other String, but\n  // we use CharSequence now.\n  // The current incompatibility is now that one uses byte[] and the other\n  // ByteBuffer\n\n  // We could\n  // fix this by defining a reflect-specific version of Interop.java, but we'd\n  // need to put it on a different classpath than the specific one.\n  // I think changing Specific to generate more flexible code would help too --\n  // it could convert ByteBuffer to byte[] or vice/versa.\n  // Additionally, some complication arises because of IndexedRecord's simplicity\n\n//   @Test\n//   public void testGeneratedReflect() throws IOException {\n//     DatumReaderProvider<Interop> provider = new DatumReaderProvider<Interop>() {\n//       @Override public DatumReader<Interop> get() {\n//         return new ReflectDatumReader<Interop>(Interop.class);\n//         }\n//       };\n//     readFiles(provider);\n//   }\n\n  private <T extends Object> void readFiles(DatumReaderProvider<T> provider) throws IOException {\n    for (File f : Objects.requireNonNull(DATAFILE_DIR.listFiles())) {\n      System.out.println(\"Reading: \" + f.getName());\n      try (DataFileReader<? extends Object> reader = (DataFileReader<? extends Object>) DataFileReader.openReader(f,\n          provider.get())) {\n\n        // Ignore avro.schema & avro.codec. Some SDKs do not support user metadata.\n        if (reader.getMetaKeys().size() > 2) {\n          assertEquals(\"stringValue\", reader.getMetaString(\"stringKey\"));\n          assertArrayEquals(\"bytesValue\".getBytes(StandardCharsets.UTF_8), reader.getMeta(\"bytesKey\"));\n        }\n\n        int i = 0;\n        for (Object datum : reader) {\n          i++;\n          assertNotNull(datum);\n        }\n        assertNotEquals(0, i);\n      }\n    }\n  }\n\n  interface DatumReaderProvider<T extends Object> {\n    DatumReader<T> get();\n  }\n\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.avro;\n\nimport static org.junit.Assert.assertArrayEquals;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotEquals;\nimport static org.junit.Assert.assertNotNull;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Objects;\n\nimport org.apache.avro.file.DataFileReader;\nimport org.apache.avro.generic.GenericDatumReader;\nimport org.apache.avro.io.DatumReader;\nimport org.apache.avro.specific.SpecificDatumReader;\nimport org.junit.BeforeClass;\nimport org.junit.Test;\n\npublic class DataFileInteropTest {\n\n  private static final File DATAFILE_DIR = new File(System.getProperty(\"test.dir\", \"/tmp\"));\n\n  @BeforeClass\n  public static void printDir() {\n    System.out.println(\"Reading data files from directory: \" + DATAFILE_DIR.getAbsolutePath());\n  }\n\n  @Test\n  public void testGeneratedGeneric() throws IOException {\n    System.out.println(\"Reading with generic:\");\n    DatumReaderProvider<Object> provider = GenericDatumReader::new;\n    readFiles(provider);\n  }\n\n  @Test\n  public void testGeneratedSpecific() throws IOException {\n    System.out.println(\"Reading with specific:\");\n    DatumReaderProvider<Interop> provider = SpecificDatumReader::new;\n    readFiles(provider);\n  }\n\n  // Can't use same Interop.java as specific for reflect.\n  // This used to be the case because one used Utf8 and the other String, but\n  // we use CharSequence now.\n  // The current incompatibility is now that one uses byte[] and the other\n  // ByteBuffer\n\n  // We could\n  // fix this by defining a reflect-specific version of Interop.java, but we'd\n  // need to put it on a different classpath than the specific one.\n  // I think changing Specific to generate more flexible code would help too --\n  // it could convert ByteBuffer to byte[] or vice/versa.\n  // Additionally, some complication arises because of IndexedRecord's simplicity\n\n//   @Test\n//   public void testGeneratedReflect() throws IOException {\n//     DatumReaderProvider<Interop> provider = new DatumReaderProvider<Interop>() {\n//       @Override public DatumReader<Interop> get() {\n//         return new ReflectDatumReader<Interop>(Interop.class);\n//         }\n//       };\n//     readFiles(provider);\n//   }\n\n  private <T extends Object> void readFiles(DatumReaderProvider<T> provider) throws IOException {\n    for (File f : Objects.requireNonNull(DATAFILE_DIR.listFiles())) {\n      System.out.println(\"Reading: \" + f.getName());\n      try (DataFileReader<? extends Object> reader = (DataFileReader<? extends Object>) DataFileReader.openReader(f,\n          provider.get())) {\n\n        byte[] user_metadata = reader.getMeta(\"user_metadata\");\n        if (user_metadata != null) {\n          assertArrayEquals(\"someByteArray\".getBytes(StandardCharsets.UTF_8), user_metadata);\n        }\n\n        int i = 0;\n        for (Object datum : reader) {\n          i++;\n          assertNotNull(datum);\n        }\n        assertNotEquals(0, i);\n      }\n    }\n  }\n\n  interface DatumReaderProvider<T extends Object> {\n    DatumReader<T> get();\n  }\n\n}\n","lineNo":89}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.avro.generic;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.util.ConcurrentModificationException;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Collection;\n\nimport org.apache.avro.AvroRuntimeException;\nimport org.apache.avro.AvroTypeException;\nimport org.apache.avro.Conversion;\nimport org.apache.avro.Conversions;\nimport org.apache.avro.LogicalType;\nimport org.apache.avro.Schema;\nimport org.apache.avro.Schema.Field;\nimport org.apache.avro.UnresolvedUnionException;\nimport org.apache.avro.io.DatumWriter;\nimport org.apache.avro.io.Encoder;\n\n/** {@link DatumWriter} for generic Java objects. */\npublic class GenericDatumWriter<D> implements DatumWriter<D> {\n  private final GenericData data;\n  private Schema root;\n\n  public GenericDatumWriter() {\n    this(GenericData.get());\n  }\n\n  protected GenericDatumWriter(GenericData data) {\n    this.data = data;\n  }\n\n  public GenericDatumWriter(Schema root) {\n    this();\n    setSchema(root);\n  }\n\n  public GenericDatumWriter(Schema root, GenericData data) {\n    this(data);\n    setSchema(root);\n  }\n\n  /** Return the {@link GenericData} implementation. */\n  public GenericData getData() {\n    return data;\n  }\n\n  public void setSchema(Schema root) {\n    this.root = root;\n  }\n\n  public void write(D datum, Encoder out) throws IOException {\n    Objects.requireNonNull(out, \"Encoder cannot be null\");\n    write(root, datum, out);\n  }\n\n  /** Called to write data. */\n  protected void write(Schema schema, Object datum, Encoder out) throws IOException {\n    LogicalType logicalType = schema.getLogicalType();\n    if (datum != null && logicalType != null) {\n      Conversion<?> conversion = getData().getConversionByClass(datum.getClass(), logicalType);\n      writeWithoutConversion(schema, convert(schema, logicalType, conversion, datum), out);\n    } else {\n      writeWithoutConversion(schema, datum, out);\n    }\n  }\n\n  /**\n   * Convert a high level representation of a logical type (such as a BigDecimal)\n   * to its underlying representation object (such as a ByteBuffer).\n   *\n   * @throws IllegalArgumentException if a null schema or logicalType is passed in\n   *                                  while datum and conversion are not null.\n   *                                  Please be noticed that the exception type\n   *                                  has changed. With version 1.8.0 and earlier,\n   *                                  in above circumstance, the exception thrown\n   *                                  out depends on the implementation of\n   *                                  conversion (most likely a\n   *                                  NullPointerException). Now, an\n   *                                  IllegalArgumentException will be thrown out\n   *                                  instead.\n   */\n  protected <T> Object convert(Schema schema, LogicalType logicalType, Conversion<T> conversion, Object datum) {\n    try {\n      if (conversion == null) {\n        return datum;\n      } else {\n        return Conversions.convertToRawType(datum, schema, logicalType, conversion);\n      }\n    } catch (AvroRuntimeException e) {\n      Throwable cause = e.getCause();\n      if (cause != null && cause.getClass() == ClassCastException.class) {\n        // This is to keep backwards compatibility. The convert function here used to\n        // throw CCE. After being moved to Conversions, it throws AvroRuntimeException\n        // instead. To keep as much same behaviour as before, this function checks if\n        // the cause is a CCE. If yes, rethrow it in case any child class checks it.\n        // This\n        // behaviour can be changed later in future versions to make it consistent with\n        // reading path, which throws AvroRuntimeException\n        throw (ClassCastException) cause;\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  /** Called to write data. */\n  protected void writeWithoutConversion(Schema schema, Object datum, Encoder out) throws IOException {\n    try {\n      switch (schema.getType()) {\n      case RECORD:\n        writeRecord(schema, datum, out);\n        break;\n      case ENUM:\n        writeEnum(schema, datum, out);\n        break;\n      case ARRAY:\n        writeArray(schema, datum, out);\n        break;\n      case MAP:\n        writeMap(schema, datum, out);\n        break;\n      case UNION:\n        int index = resolveUnion(schema, datum);\n        out.writeIndex(index);\n        write(schema.getTypes().get(index), datum, out);\n        break;\n      case FIXED:\n        writeFixed(schema, datum, out);\n        break;\n      case STRING:\n        writeString(schema, datum, out);\n        break;\n      case BYTES:\n        writeBytes(datum, out);\n        break;\n      case INT:\n        out.writeInt(((Number) datum).intValue());\n        break;\n      case LONG:\n        out.writeLong(((Number) datum).longValue());\n        break;\n      case FLOAT:\n        out.writeFloat(((Number) datum).floatValue());\n        break;\n      case DOUBLE:\n        out.writeDouble(((Number) datum).doubleValue());\n        break;\n      case BOOLEAN:\n        out.writeBoolean((Boolean) datum);\n        break;\n      case NULL:\n        out.writeNull();\n        break;\n      default:\n        error(schema, datum);\n      }\n    } catch (NullPointerException e) {\n      throw npe(e, \" of \" + schema.getFullName());\n    }\n  }\n\n  /** Helper method for adding a message to an NPE . */\n  protected NullPointerException npe(NullPointerException e, String s) {\n    NullPointerException result = new NullPointerException(e.getMessage() + s);\n    result.initCause(e.getCause() == null ? e : e.getCause());\n    return result;\n  }\n\n  /** Helper method for adding a message to an Class Cast Exception . */\n  protected ClassCastException addClassCastMsg(ClassCastException e, String s) {\n    ClassCastException result = new ClassCastException(e.getMessage() + s);\n    result.initCause(e.getCause() == null ? e : e.getCause());\n    return result;\n  }\n\n  /** Helper method for adding a message to an Avro Type Exception . */\n  protected AvroTypeException addAvroTypeMsg(AvroTypeException e, String s) {\n    AvroTypeException result = new AvroTypeException(e.getMessage() + s);\n    result.initCause(e.getCause() == null ? e : e.getCause());\n    return result;\n  }\n\n  /**\n   * Called to write a record. May be overridden for alternate record\n   * representations.\n   */\n  protected void writeRecord(Schema schema, Object datum, Encoder out) throws IOException {\n    Object state = data.getRecordState(datum, schema);\n    for (Field f : schema.getFields()) {\n      writeField(datum, f, out, state);\n    }\n  }\n\n  /**\n   * Called to write a single field of a record. May be overridden for more\n   * efficient or alternate implementations.\n   */\n  protected void writeField(Object datum, Field f, Encoder out, Object state) throws IOException {\n    Object value = data.getField(datum, f.name(), f.pos(), state);\n    try {\n      write(f.schema(), value, out);\n    } catch (final UnresolvedUnionException uue) { // recreate it with the right field info\n      final UnresolvedUnionException unresolvedUnionException = new UnresolvedUnionException(f.schema(), f, value);\n      unresolvedUnionException.addSuppressed(uue);\n      throw unresolvedUnionException;\n    } catch (NullPointerException e) {\n      throw npe(e, \" in field \" + f.name());\n    } catch (ClassCastException cce) {\n      throw addClassCastMsg(cce, \" in field \" + f.name());\n    } catch (AvroTypeException ate) {\n      throw addAvroTypeMsg(ate, \" in field \" + f.name());\n    }\n  }\n\n  /**\n   * Called to write an enum value. May be overridden for alternate enum\n   * representations.\n   */\n  protected void writeEnum(Schema schema, Object datum, Encoder out) throws IOException {\n    if (!data.isEnum(datum))\n      throw new AvroTypeException(\"Not an enum: \" + datum + \" for schema: \" + schema);\n    out.writeEnum(schema.getEnumOrdinal(datum.toString()));\n  }\n\n  /**\n   * Called to write a array. May be overridden for alternate array\n   * representations.\n   */\n  protected void writeArray(Schema schema, Object datum, Encoder out) throws IOException {\n    Schema element = schema.getElementType();\n    long size = getArraySize(datum);\n    long actualSize = 0;\n    out.writeArrayStart();\n    out.setItemCount(size);\n    for (Iterator<? extends Object> it = getArrayElements(datum); it.hasNext();) {\n      out.startItem();\n      write(element, it.next(), out);\n      actualSize++;\n    }\n    out.writeArrayEnd();\n    if (actualSize != size) {\n      throw new ConcurrentModificationException(\n          \"Size of array written was \" + size + \", but number of elements written was \" + actualSize + \". \");\n    }\n  }\n\n  /**\n   * Called to find the index for a datum within a union. By default calls\n   * {@link GenericData#resolveUnion(Schema,Object)}.\n   */\n  protected int resolveUnion(Schema union, Object datum) {\n    return data.resolveUnion(union, datum);\n  }\n\n  /**\n   * Called by the default implementation of {@link #writeArray} to get the size\n   * of an array. The default implementation is for {@link Collection}.\n   */\n  @SuppressWarnings(\"unchecked\")\n  protected long getArraySize(Object array) {\n    return ((Collection) array).size();\n  }\n\n  /**\n   * Called by the default implementation of {@link #writeArray} to enumerate\n   * array elements. The default implementation is for {@link Collection}.\n   */\n  @SuppressWarnings(\"unchecked\")\n  protected Iterator<? extends Object> getArrayElements(Object array) {\n    return ((Collection) array).iterator();\n  }\n\n  /**\n   * Called to write a map. May be overridden for alternate map representations.\n   */\n  protected void writeMap(Schema schema, Object datum, Encoder out) throws IOException {\n    Schema value = schema.getValueType();\n    int size = getMapSize(datum);\n    int actualSize = 0;\n    out.writeMapStart();\n    out.setItemCount(size);\n    for (Map.Entry<Object, Object> entry : getMapEntries(datum)) {\n      out.startItem();\n      writeString(entry.getKey().toString(), out);\n      write(value, entry.getValue(), out);\n      actualSize++;\n    }\n    out.writeMapEnd();\n    if (actualSize != size) {\n      throw new ConcurrentModificationException(\n          \"Size of map written was \" + size + \", but number of entries written was \" + actualSize + \". \");\n    }\n  }\n\n  /**\n   * Called by the default implementation of {@link #writeMap} to get the size of\n   * a map. The default implementation is for {@link Map}.\n   */\n  @SuppressWarnings(\"unchecked\")\n  protected int getMapSize(Object map) {\n    return ((Map) map).size();\n  }\n\n  /**\n   * Called by the default implementation of {@link #writeMap} to enumerate map\n   * elements. The default implementation is for {@link Map}.\n   */\n  @SuppressWarnings(\"unchecked\")\n  protected Iterable<Map.Entry<Object, Object>> getMapEntries(Object map) {\n    return ((Map) map).entrySet();\n  }\n\n  /**\n   * Called to write a string. May be overridden for alternate string\n   * representations.\n   */\n  protected void writeString(Schema schema, Object datum, Encoder out) throws IOException {\n    writeString(datum, out);\n  }\n\n  /**\n   * Called to write a string. May be overridden for alternate string\n   * representations.\n   */\n  protected void writeString(Object datum, Encoder out) throws IOException {\n    out.writeString((CharSequence) datum);\n  }\n\n  /**\n   * Called to write a bytes. May be overridden for alternate bytes\n   * representations.\n   */\n  protected void writeBytes(Object datum, Encoder out) throws IOException {\n    out.writeBytes((ByteBuffer) datum);\n  }\n\n  /**\n   * Called to write a fixed value. May be overridden for alternate fixed\n   * representations.\n   */\n  protected void writeFixed(Schema schema, Object datum, Encoder out) throws IOException {\n    out.writeFixed(((GenericFixed) datum).bytes(), 0, schema.getFixedSize());\n  }\n\n  private void error(Schema schema, Object datum) {\n    throw new AvroTypeException(\"Not a \" + schema + \": \" + datum);\n  }\n\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.avro.generic;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.util.ConcurrentModificationException;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Collection;\n\nimport org.apache.avro.AvroRuntimeException;\nimport org.apache.avro.AvroTypeException;\nimport org.apache.avro.Conversion;\nimport org.apache.avro.Conversions;\nimport org.apache.avro.LogicalType;\nimport org.apache.avro.Schema;\nimport org.apache.avro.Schema.Field;\nimport org.apache.avro.path.TracingAvroTypeException;\nimport org.apache.avro.UnresolvedUnionException;\nimport org.apache.avro.io.DatumWriter;\nimport org.apache.avro.io.Encoder;\nimport org.apache.avro.path.ArrayPositionPredicate;\nimport org.apache.avro.path.LocationStep;\nimport org.apache.avro.path.MapKeyPredicate;\nimport org.apache.avro.path.TracingClassCastException;\nimport org.apache.avro.path.TracingNullPointException;\nimport org.apache.avro.path.UnionTypePredicate;\nimport org.apache.avro.util.SchemaUtil;\n\n/** {@link DatumWriter} for generic Java objects. */\npublic class GenericDatumWriter<D> implements DatumWriter<D> {\n  private final GenericData data;\n  private Schema root;\n\n  public GenericDatumWriter() {\n    this(GenericData.get());\n  }\n\n  protected GenericDatumWriter(GenericData data) {\n    this.data = data;\n  }\n\n  public GenericDatumWriter(Schema root) {\n    this();\n    setSchema(root);\n  }\n\n  public GenericDatumWriter(Schema root, GenericData data) {\n    this(data);\n    setSchema(root);\n  }\n\n  /** Return the {@link GenericData} implementation. */\n  public GenericData getData() {\n    return data;\n  }\n\n  public void setSchema(Schema root) {\n    this.root = root;\n  }\n\n  public void write(D datum, Encoder out) throws IOException {\n    Objects.requireNonNull(out, \"Encoder cannot be null\");\n    try {\n      write(root, datum, out);\n    } catch (TracingNullPointException | TracingClassCastException | TracingAvroTypeException e) {\n      throw e.summarize(root);\n    }\n  }\n\n  /** Called to write data. */\n  protected void write(Schema schema, Object datum, Encoder out) throws IOException {\n    LogicalType logicalType = schema.getLogicalType();\n    if (datum != null && logicalType != null) {\n      Conversion<?> conversion = getData().getConversionByClass(datum.getClass(), logicalType);\n      writeWithoutConversion(schema, convert(schema, logicalType, conversion, datum), out);\n    } else {\n      writeWithoutConversion(schema, datum, out);\n    }\n  }\n\n  /**\n   * Convert a high level representation of a logical type (such as a BigDecimal)\n   * to its underlying representation object (such as a ByteBuffer).\n   *\n   * @throws IllegalArgumentException if a null schema or logicalType is passed in\n   *                                  while datum and conversion are not null.\n   *                                  Please be noticed that the exception type\n   *                                  has changed. With version 1.8.0 and earlier,\n   *                                  in above circumstance, the exception thrown\n   *                                  out depends on the implementation of\n   *                                  conversion (most likely a\n   *                                  NullPointerException). Now, an\n   *                                  IllegalArgumentException will be thrown out\n   *                                  instead.\n   */\n  protected <T> Object convert(Schema schema, LogicalType logicalType, Conversion<T> conversion, Object datum) {\n    try {\n      if (conversion == null) {\n        return datum;\n      } else {\n        return Conversions.convertToRawType(datum, schema, logicalType, conversion);\n      }\n    } catch (AvroRuntimeException e) {\n      Throwable cause = e.getCause();\n      if (cause != null && cause.getClass() == ClassCastException.class) {\n        // This is to keep backwards compatibility. The convert function here used to\n        // throw CCE. After being moved to Conversions, it throws AvroRuntimeException\n        // instead. To keep as much same behaviour as before, this function checks if\n        // the cause is a CCE. If yes, rethrow it in case any child class checks it.\n        // This\n        // behaviour can be changed later in future versions to make it consistent with\n        // reading path, which throws AvroRuntimeException\n        throw (ClassCastException) cause;\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  /** Called to write data. */\n  protected void writeWithoutConversion(Schema schema, Object datum, Encoder out) throws IOException {\n    int unionIndex = -1;\n    Schema.Type schemaType = schema.getType();\n    try {\n      switch (schemaType) {\n      case RECORD:\n        writeRecord(schema, datum, out);\n        break;\n      case ENUM:\n        writeEnum(schema, datum, out);\n        break;\n      case ARRAY:\n        writeArray(schema, datum, out);\n        break;\n      case MAP:\n        writeMap(schema, datum, out);\n        break;\n      case UNION:\n        unionIndex = resolveUnion(schema, datum);\n        out.writeIndex(unionIndex);\n        write(schema.getTypes().get(unionIndex), datum, out);\n        break;\n      case FIXED:\n        writeFixed(schema, datum, out);\n        break;\n      case STRING:\n        writeString(schema, datum, out);\n        break;\n      case BYTES:\n        writeBytes(datum, out);\n        break;\n      case INT:\n        out.writeInt(((Number) datum).intValue());\n        break;\n      case LONG:\n        out.writeLong(((Number) datum).longValue());\n        break;\n      case FLOAT:\n        out.writeFloat(((Number) datum).floatValue());\n        break;\n      case DOUBLE:\n        out.writeDouble(((Number) datum).doubleValue());\n        break;\n      case BOOLEAN:\n        out.writeBoolean((Boolean) datum);\n        break;\n      case NULL:\n        out.writeNull();\n        break;\n      default:\n        error(schema, datum);\n      }\n    } catch (TracingNullPointException | TracingClassCastException | TracingAvroTypeException e) {\n      if (schemaType == Schema.Type.UNION) {\n        e.tracePath(new UnionTypePredicate(schema.getTypes().get(unionIndex).getName()));\n      }\n      // writeArray() and writeMap() have their own handling\n      throw e;\n    } catch (NullPointerException e) {\n      throw new TracingNullPointException(e, schema, false);\n    } catch (ClassCastException e) {\n      throw new TracingClassCastException(e, datum, schema, false);\n    } catch (AvroTypeException e) {\n      throw new TracingAvroTypeException(e);\n    }\n  }\n\n  /** Helper method for adding a message to an NPE . */\n  protected NullPointerException npe(NullPointerException e, String s) {\n    NullPointerException result = new NullPointerException(e.getMessage() + s);\n    result.initCause(e.getCause() == null ? e : e.getCause());\n    return result;\n  }\n\n  /** Helper method for adding a message to an Class Cast Exception . */\n  protected ClassCastException addClassCastMsg(ClassCastException e, String s) {\n    ClassCastException result = new ClassCastException(e.getMessage() + s);\n    result.initCause(e.getCause() == null ? e : e.getCause());\n    return result;\n  }\n\n  /** Helper method for adding a message to an Avro Type Exception . */\n  protected AvroTypeException addAvroTypeMsg(AvroTypeException e, String s) {\n    AvroTypeException result = new AvroTypeException(e.getMessage() + s);\n    result.initCause(e.getCause() == null ? e : e.getCause());\n    return result;\n  }\n\n  /**\n   * Called to write a record. May be overridden for alternate record\n   * representations.\n   */\n  protected void writeRecord(Schema schema, Object datum, Encoder out) throws IOException {\n    Object state = data.getRecordState(datum, schema);\n    for (Field f : schema.getFields()) {\n      writeField(datum, f, out, state);\n    }\n  }\n\n  /**\n   * Called to write a single field of a record. May be overridden for more\n   * efficient or alternate implementations.\n   */\n  protected void writeField(Object datum, Field f, Encoder out, Object state) throws IOException {\n    Object value = data.getField(datum, f.name(), f.pos(), state);\n    try {\n      write(f.schema(), value, out);\n    } catch (final UnresolvedUnionException uue) { // recreate it with the right field info\n      final UnresolvedUnionException unresolvedUnionException = new UnresolvedUnionException(f.schema(), f, value);\n      unresolvedUnionException.addSuppressed(uue);\n      throw unresolvedUnionException;\n    } catch (TracingNullPointException | TracingClassCastException | TracingAvroTypeException e) {\n      e.tracePath(new LocationStep(\".\", f.name()));\n      throw e;\n    } catch (NullPointerException e) {\n      throw npe(e, \" in field \" + f.name());\n    } catch (ClassCastException cce) {\n      throw addClassCastMsg(cce, \" in field \" + f.name());\n    } catch (AvroTypeException ate) {\n      throw addAvroTypeMsg(ate, \" in field \" + f.name());\n    }\n  }\n\n  /**\n   * Called to write an enum value. May be overridden for alternate enum\n   * representations.\n   */\n  protected void writeEnum(Schema schema, Object datum, Encoder out) throws IOException {\n    if (!data.isEnum(datum)) {\n      AvroTypeException cause = new AvroTypeException(\n          \"value \" + SchemaUtil.describe(datum) + \" is not a \" + SchemaUtil.describe(schema));\n      throw new TracingAvroTypeException(cause);\n    }\n    out.writeEnum(schema.getEnumOrdinal(datum.toString()));\n  }\n\n  /**\n   * Called to write a array. May be overridden for alternate array\n   * representations.\n   */\n  protected void writeArray(Schema schema, Object datum, Encoder out) throws IOException {\n    Schema element = schema.getElementType();\n    long size = getArraySize(datum);\n    long actualSize = 0;\n    out.writeArrayStart();\n    out.setItemCount(size);\n    for (Iterator<? extends Object> it = getArrayElements(datum); it.hasNext();) {\n      out.startItem();\n      try {\n        write(element, it.next(), out);\n      } catch (TracingNullPointException | TracingClassCastException | TracingAvroTypeException e) {\n        e.tracePath(new ArrayPositionPredicate(actualSize));\n        throw e;\n      }\n      actualSize++;\n    }\n    out.writeArrayEnd();\n    if (actualSize != size) {\n      throw new ConcurrentModificationException(\n          \"Size of array written was \" + size + \", but number of elements written was \" + actualSize + \". \");\n    }\n  }\n\n  /**\n   * Called to find the index for a datum within a union. By default calls\n   * {@link GenericData#resolveUnion(Schema,Object)}.\n   */\n  protected int resolveUnion(Schema union, Object datum) {\n    return data.resolveUnion(union, datum);\n  }\n\n  /**\n   * Called by the default implementation of {@link #writeArray} to get the size\n   * of an array. The default implementation is for {@link Collection}.\n   */\n  protected long getArraySize(Object array) {\n    return ((Collection<?>) array).size();\n  }\n\n  /**\n   * Called by the default implementation of {@link #writeArray} to enumerate\n   * array elements. The default implementation is for {@link Collection}.\n   */\n  protected Iterator<?> getArrayElements(Object array) {\n    return ((Collection<?>) array).iterator();\n  }\n\n  /**\n   * Called to write a map. May be overridden for alternate map representations.\n   */\n  protected void writeMap(Schema schema, Object datum, Encoder out) throws IOException {\n    Schema value = schema.getValueType();\n    int size = getMapSize(datum);\n    int actualSize = 0;\n    out.writeMapStart();\n    out.setItemCount(size);\n    for (Map.Entry<Object, Object> entry : getMapEntries(datum)) {\n      out.startItem();\n      String key;\n      try {\n        key = entry.getKey().toString();\n      } catch (NullPointerException npe) {\n        TracingNullPointException tnpe = new TracingNullPointException(npe, Schema.create(Schema.Type.STRING), false);\n        tnpe.tracePath(new MapKeyPredicate(null));\n        throw tnpe;\n      }\n      writeString(key, out);\n      try {\n        write(value, entry.getValue(), out);\n      } catch (TracingNullPointException | TracingClassCastException | TracingAvroTypeException e) {\n        e.tracePath(new MapKeyPredicate(key));\n        throw e;\n      }\n      actualSize++;\n    }\n    out.writeMapEnd();\n    if (actualSize != size) {\n      throw new ConcurrentModificationException(\n          \"Size of map written was \" + size + \", but number of entries written was \" + actualSize + \". \");\n    }\n  }\n\n  /**\n   * Called by the default implementation of {@link #writeMap} to get the size of\n   * a map. The default implementation is for {@link Map}.\n   */\n  @SuppressWarnings(\"unchecked\")\n  protected int getMapSize(Object map) {\n    return ((Map) map).size();\n  }\n\n  /**\n   * Called by the default implementation of {@link #writeMap} to enumerate map\n   * elements. The default implementation is for {@link Map}.\n   */\n  @SuppressWarnings(\"unchecked\")\n  protected Iterable<Map.Entry<Object, Object>> getMapEntries(Object map) {\n    return ((Map) map).entrySet();\n  }\n\n  /**\n   * Called to write a string. May be overridden for alternate string\n   * representations.\n   */\n  protected void writeString(Schema schema, Object datum, Encoder out) throws IOException {\n    writeString(datum, out);\n  }\n\n  /**\n   * Called to write a string. May be overridden for alternate string\n   * representations.\n   */\n  protected void writeString(Object datum, Encoder out) throws IOException {\n    out.writeString((CharSequence) datum);\n  }\n\n  /**\n   * Called to write a bytes. May be overridden for alternate bytes\n   * representations.\n   */\n  protected void writeBytes(Object datum, Encoder out) throws IOException {\n    out.writeBytes((ByteBuffer) datum);\n  }\n\n  /**\n   * Called to write a fixed value. May be overridden for alternate fixed\n   * representations.\n   */\n  protected void writeFixed(Schema schema, Object datum, Encoder out) throws IOException {\n    out.writeFixed(((GenericFixed) datum).bytes(), 0, schema.getFixedSize());\n  }\n\n  private void error(Schema schema, Object datum) {\n    throw new AvroTypeException(\"value \" + SchemaUtil.describe(datum) + \" is not a \" + SchemaUtil.describe(schema));\n  }\n\n}\n","lineNo":141}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.avro.generic;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.util.ConcurrentModificationException;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Collection;\n\nimport org.apache.avro.AvroRuntimeException;\nimport org.apache.avro.AvroTypeException;\nimport org.apache.avro.Conversion;\nimport org.apache.avro.Conversions;\nimport org.apache.avro.LogicalType;\nimport org.apache.avro.Schema;\nimport org.apache.avro.Schema.Field;\nimport org.apache.avro.UnresolvedUnionException;\nimport org.apache.avro.io.DatumWriter;\nimport org.apache.avro.io.Encoder;\n\n/** {@link DatumWriter} for generic Java objects. */\npublic class GenericDatumWriter<D> implements DatumWriter<D> {\n  private final GenericData data;\n  private Schema root;\n\n  public GenericDatumWriter() {\n    this(GenericData.get());\n  }\n\n  protected GenericDatumWriter(GenericData data) {\n    this.data = data;\n  }\n\n  public GenericDatumWriter(Schema root) {\n    this();\n    setSchema(root);\n  }\n\n  public GenericDatumWriter(Schema root, GenericData data) {\n    this(data);\n    setSchema(root);\n  }\n\n  /** Return the {@link GenericData} implementation. */\n  public GenericData getData() {\n    return data;\n  }\n\n  public void setSchema(Schema root) {\n    this.root = root;\n  }\n\n  public void write(D datum, Encoder out) throws IOException {\n    Objects.requireNonNull(out, \"Encoder cannot be null\");\n    write(root, datum, out);\n  }\n\n  /** Called to write data. */\n  protected void write(Schema schema, Object datum, Encoder out) throws IOException {\n    LogicalType logicalType = schema.getLogicalType();\n    if (datum != null && logicalType != null) {\n      Conversion<?> conversion = getData().getConversionByClass(datum.getClass(), logicalType);\n      writeWithoutConversion(schema, convert(schema, logicalType, conversion, datum), out);\n    } else {\n      writeWithoutConversion(schema, datum, out);\n    }\n  }\n\n  /**\n   * Convert a high level representation of a logical type (such as a BigDecimal)\n   * to its underlying representation object (such as a ByteBuffer).\n   *\n   * @throws IllegalArgumentException if a null schema or logicalType is passed in\n   *                                  while datum and conversion are not null.\n   *                                  Please be noticed that the exception type\n   *                                  has changed. With version 1.8.0 and earlier,\n   *                                  in above circumstance, the exception thrown\n   *                                  out depends on the implementation of\n   *                                  conversion (most likely a\n   *                                  NullPointerException). Now, an\n   *                                  IllegalArgumentException will be thrown out\n   *                                  instead.\n   */\n  protected <T> Object convert(Schema schema, LogicalType logicalType, Conversion<T> conversion, Object datum) {\n    try {\n      if (conversion == null) {\n        return datum;\n      } else {\n        return Conversions.convertToRawType(datum, schema, logicalType, conversion);\n      }\n    } catch (AvroRuntimeException e) {\n      Throwable cause = e.getCause();\n      if (cause != null && cause.getClass() == ClassCastException.class) {\n        // This is to keep backwards compatibility. The convert function here used to\n        // throw CCE. After being moved to Conversions, it throws AvroRuntimeException\n        // instead. To keep as much same behaviour as before, this function checks if\n        // the cause is a CCE. If yes, rethrow it in case any child class checks it.\n        // This\n        // behaviour can be changed later in future versions to make it consistent with\n        // reading path, which throws AvroRuntimeException\n        throw (ClassCastException) cause;\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  /** Called to write data. */\n  protected void writeWithoutConversion(Schema schema, Object datum, Encoder out) throws IOException {\n    try {\n      switch (schema.getType()) {\n      case RECORD:\n        writeRecord(schema, datum, out);\n        break;\n      case ENUM:\n        writeEnum(schema, datum, out);\n        break;\n      case ARRAY:\n        writeArray(schema, datum, out);\n        break;\n      case MAP:\n        writeMap(schema, datum, out);\n        break;\n      case UNION:\n        int index = resolveUnion(schema, datum);\n        out.writeIndex(index);\n        write(schema.getTypes().get(index), datum, out);\n        break;\n      case FIXED:\n        writeFixed(schema, datum, out);\n        break;\n      case STRING:\n        writeString(schema, datum, out);\n        break;\n      case BYTES:\n        writeBytes(datum, out);\n        break;\n      case INT:\n        out.writeInt(((Number) datum).intValue());\n        break;\n      case LONG:\n        out.writeLong(((Number) datum).longValue());\n        break;\n      case FLOAT:\n        out.writeFloat(((Number) datum).floatValue());\n        break;\n      case DOUBLE:\n        out.writeDouble(((Number) datum).doubleValue());\n        break;\n      case BOOLEAN:\n        out.writeBoolean((Boolean) datum);\n        break;\n      case NULL:\n        out.writeNull();\n        break;\n      default:\n        error(schema, datum);\n      }\n    } catch (NullPointerException e) {\n      throw npe(e, \" of \" + schema.getFullName());\n    }\n  }\n\n  /** Helper method for adding a message to an NPE . */\n  protected NullPointerException npe(NullPointerException e, String s) {\n    NullPointerException result = new NullPointerException(e.getMessage() + s);\n    result.initCause(e.getCause() == null ? e : e.getCause());\n    return result;\n  }\n\n  /** Helper method for adding a message to an Class Cast Exception . */\n  protected ClassCastException addClassCastMsg(ClassCastException e, String s) {\n    ClassCastException result = new ClassCastException(e.getMessage() + s);\n    result.initCause(e.getCause() == null ? e : e.getCause());\n    return result;\n  }\n\n  /** Helper method for adding a message to an Avro Type Exception . */\n  protected AvroTypeException addAvroTypeMsg(AvroTypeException e, String s) {\n    AvroTypeException result = new AvroTypeException(e.getMessage() + s);\n    result.initCause(e.getCause() == null ? e : e.getCause());\n    return result;\n  }\n\n  /**\n   * Called to write a record. May be overridden for alternate record\n   * representations.\n   */\n  protected void writeRecord(Schema schema, Object datum, Encoder out) throws IOException {\n    Object state = data.getRecordState(datum, schema);\n    for (Field f : schema.getFields()) {\n      writeField(datum, f, out, state);\n    }\n  }\n\n  /**\n   * Called to write a single field of a record. May be overridden for more\n   * efficient or alternate implementations.\n   */\n  protected void writeField(Object datum, Field f, Encoder out, Object state) throws IOException {\n    Object value = data.getField(datum, f.name(), f.pos(), state);\n    try {\n      write(f.schema(), value, out);\n    } catch (final UnresolvedUnionException uue) { // recreate it with the right field info\n      final UnresolvedUnionException unresolvedUnionException = new UnresolvedUnionException(f.schema(), f, value);\n      unresolvedUnionException.addSuppressed(uue);\n      throw unresolvedUnionException;\n    } catch (NullPointerException e) {\n      throw npe(e, \" in field \" + f.name());\n    } catch (ClassCastException cce) {\n      throw addClassCastMsg(cce, \" in field \" + f.name());\n    } catch (AvroTypeException ate) {\n      throw addAvroTypeMsg(ate, \" in field \" + f.name());\n    }\n  }\n\n  /**\n   * Called to write an enum value. May be overridden for alternate enum\n   * representations.\n   */\n  protected void writeEnum(Schema schema, Object datum, Encoder out) throws IOException {\n    if (!data.isEnum(datum))\n      throw new AvroTypeException(\"Not an enum: \" + datum + \" for schema: \" + schema);\n    out.writeEnum(schema.getEnumOrdinal(datum.toString()));\n  }\n\n  /**\n   * Called to write a array. May be overridden for alternate array\n   * representations.\n   */\n  protected void writeArray(Schema schema, Object datum, Encoder out) throws IOException {\n    Schema element = schema.getElementType();\n    long size = getArraySize(datum);\n    long actualSize = 0;\n    out.writeArrayStart();\n    out.setItemCount(size);\n    for (Iterator<? extends Object> it = getArrayElements(datum); it.hasNext();) {\n      out.startItem();\n      write(element, it.next(), out);\n      actualSize++;\n    }\n    out.writeArrayEnd();\n    if (actualSize != size) {\n      throw new ConcurrentModificationException(\n          \"Size of array written was \" + size + \", but number of elements written was \" + actualSize + \". \");\n    }\n  }\n\n  /**\n   * Called to find the index for a datum within a union. By default calls\n   * {@link GenericData#resolveUnion(Schema,Object)}.\n   */\n  protected int resolveUnion(Schema union, Object datum) {\n    return data.resolveUnion(union, datum);\n  }\n\n  /**\n   * Called by the default implementation of {@link #writeArray} to get the size\n   * of an array. The default implementation is for {@link Collection}.\n   */\n  @SuppressWarnings(\"unchecked\")\n  protected long getArraySize(Object array) {\n    return ((Collection) array).size();\n  }\n\n  /**\n   * Called by the default implementation of {@link #writeArray} to enumerate\n   * array elements. The default implementation is for {@link Collection}.\n   */\n  @SuppressWarnings(\"unchecked\")\n  protected Iterator<? extends Object> getArrayElements(Object array) {\n    return ((Collection) array).iterator();\n  }\n\n  /**\n   * Called to write a map. May be overridden for alternate map representations.\n   */\n  protected void writeMap(Schema schema, Object datum, Encoder out) throws IOException {\n    Schema value = schema.getValueType();\n    int size = getMapSize(datum);\n    int actualSize = 0;\n    out.writeMapStart();\n    out.setItemCount(size);\n    for (Map.Entry<Object, Object> entry : getMapEntries(datum)) {\n      out.startItem();\n      writeString(entry.getKey().toString(), out);\n      write(value, entry.getValue(), out);\n      actualSize++;\n    }\n    out.writeMapEnd();\n    if (actualSize != size) {\n      throw new ConcurrentModificationException(\n          \"Size of map written was \" + size + \", but number of entries written was \" + actualSize + \". \");\n    }\n  }\n\n  /**\n   * Called by the default implementation of {@link #writeMap} to get the size of\n   * a map. The default implementation is for {@link Map}.\n   */\n  @SuppressWarnings(\"unchecked\")\n  protected int getMapSize(Object map) {\n    return ((Map) map).size();\n  }\n\n  /**\n   * Called by the default implementation of {@link #writeMap} to enumerate map\n   * elements. The default implementation is for {@link Map}.\n   */\n  @SuppressWarnings(\"unchecked\")\n  protected Iterable<Map.Entry<Object, Object>> getMapEntries(Object map) {\n    return ((Map) map).entrySet();\n  }\n\n  /**\n   * Called to write a string. May be overridden for alternate string\n   * representations.\n   */\n  protected void writeString(Schema schema, Object datum, Encoder out) throws IOException {\n    writeString(datum, out);\n  }\n\n  /**\n   * Called to write a string. May be overridden for alternate string\n   * representations.\n   */\n  protected void writeString(Object datum, Encoder out) throws IOException {\n    out.writeString((CharSequence) datum);\n  }\n\n  /**\n   * Called to write a bytes. May be overridden for alternate bytes\n   * representations.\n   */\n  protected void writeBytes(Object datum, Encoder out) throws IOException {\n    out.writeBytes((ByteBuffer) datum);\n  }\n\n  /**\n   * Called to write a fixed value. May be overridden for alternate fixed\n   * representations.\n   */\n  protected void writeFixed(Schema schema, Object datum, Encoder out) throws IOException {\n    out.writeFixed(((GenericFixed) datum).bytes(), 0, schema.getFixedSize());\n  }\n\n  private void error(Schema schema, Object datum) {\n    throw new AvroTypeException(\"Not a \" + schema + \": \" + datum);\n  }\n\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.avro.generic;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.util.ConcurrentModificationException;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Collection;\n\nimport org.apache.avro.AvroRuntimeException;\nimport org.apache.avro.AvroTypeException;\nimport org.apache.avro.Conversion;\nimport org.apache.avro.Conversions;\nimport org.apache.avro.LogicalType;\nimport org.apache.avro.Schema;\nimport org.apache.avro.Schema.Field;\nimport org.apache.avro.path.TracingAvroTypeException;\nimport org.apache.avro.UnresolvedUnionException;\nimport org.apache.avro.io.DatumWriter;\nimport org.apache.avro.io.Encoder;\nimport org.apache.avro.path.ArrayPositionPredicate;\nimport org.apache.avro.path.LocationStep;\nimport org.apache.avro.path.MapKeyPredicate;\nimport org.apache.avro.path.TracingClassCastException;\nimport org.apache.avro.path.TracingNullPointException;\nimport org.apache.avro.path.UnionTypePredicate;\nimport org.apache.avro.util.SchemaUtil;\n\n/** {@link DatumWriter} for generic Java objects. */\npublic class GenericDatumWriter<D> implements DatumWriter<D> {\n  private final GenericData data;\n  private Schema root;\n\n  public GenericDatumWriter() {\n    this(GenericData.get());\n  }\n\n  protected GenericDatumWriter(GenericData data) {\n    this.data = data;\n  }\n\n  public GenericDatumWriter(Schema root) {\n    this();\n    setSchema(root);\n  }\n\n  public GenericDatumWriter(Schema root, GenericData data) {\n    this(data);\n    setSchema(root);\n  }\n\n  /** Return the {@link GenericData} implementation. */\n  public GenericData getData() {\n    return data;\n  }\n\n  public void setSchema(Schema root) {\n    this.root = root;\n  }\n\n  public void write(D datum, Encoder out) throws IOException {\n    Objects.requireNonNull(out, \"Encoder cannot be null\");\n    try {\n      write(root, datum, out);\n    } catch (TracingNullPointException | TracingClassCastException | TracingAvroTypeException e) {\n      throw e.summarize(root);\n    }\n  }\n\n  /** Called to write data. */\n  protected void write(Schema schema, Object datum, Encoder out) throws IOException {\n    LogicalType logicalType = schema.getLogicalType();\n    if (datum != null && logicalType != null) {\n      Conversion<?> conversion = getData().getConversionByClass(datum.getClass(), logicalType);\n      writeWithoutConversion(schema, convert(schema, logicalType, conversion, datum), out);\n    } else {\n      writeWithoutConversion(schema, datum, out);\n    }\n  }\n\n  /**\n   * Convert a high level representation of a logical type (such as a BigDecimal)\n   * to its underlying representation object (such as a ByteBuffer).\n   *\n   * @throws IllegalArgumentException if a null schema or logicalType is passed in\n   *                                  while datum and conversion are not null.\n   *                                  Please be noticed that the exception type\n   *                                  has changed. With version 1.8.0 and earlier,\n   *                                  in above circumstance, the exception thrown\n   *                                  out depends on the implementation of\n   *                                  conversion (most likely a\n   *                                  NullPointerException). Now, an\n   *                                  IllegalArgumentException will be thrown out\n   *                                  instead.\n   */\n  protected <T> Object convert(Schema schema, LogicalType logicalType, Conversion<T> conversion, Object datum) {\n    try {\n      if (conversion == null) {\n        return datum;\n      } else {\n        return Conversions.convertToRawType(datum, schema, logicalType, conversion);\n      }\n    } catch (AvroRuntimeException e) {\n      Throwable cause = e.getCause();\n      if (cause != null && cause.getClass() == ClassCastException.class) {\n        // This is to keep backwards compatibility. The convert function here used to\n        // throw CCE. After being moved to Conversions, it throws AvroRuntimeException\n        // instead. To keep as much same behaviour as before, this function checks if\n        // the cause is a CCE. If yes, rethrow it in case any child class checks it.\n        // This\n        // behaviour can be changed later in future versions to make it consistent with\n        // reading path, which throws AvroRuntimeException\n        throw (ClassCastException) cause;\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  /** Called to write data. */\n  protected void writeWithoutConversion(Schema schema, Object datum, Encoder out) throws IOException {\n    int unionIndex = -1;\n    Schema.Type schemaType = schema.getType();\n    try {\n      switch (schemaType) {\n      case RECORD:\n        writeRecord(schema, datum, out);\n        break;\n      case ENUM:\n        writeEnum(schema, datum, out);\n        break;\n      case ARRAY:\n        writeArray(schema, datum, out);\n        break;\n      case MAP:\n        writeMap(schema, datum, out);\n        break;\n      case UNION:\n        unionIndex = resolveUnion(schema, datum);\n        out.writeIndex(unionIndex);\n        write(schema.getTypes().get(unionIndex), datum, out);\n        break;\n      case FIXED:\n        writeFixed(schema, datum, out);\n        break;\n      case STRING:\n        writeString(schema, datum, out);\n        break;\n      case BYTES:\n        writeBytes(datum, out);\n        break;\n      case INT:\n        out.writeInt(((Number) datum).intValue());\n        break;\n      case LONG:\n        out.writeLong(((Number) datum).longValue());\n        break;\n      case FLOAT:\n        out.writeFloat(((Number) datum).floatValue());\n        break;\n      case DOUBLE:\n        out.writeDouble(((Number) datum).doubleValue());\n        break;\n      case BOOLEAN:\n        out.writeBoolean((Boolean) datum);\n        break;\n      case NULL:\n        out.writeNull();\n        break;\n      default:\n        error(schema, datum);\n      }\n    } catch (TracingNullPointException | TracingClassCastException | TracingAvroTypeException e) {\n      if (schemaType == Schema.Type.UNION) {\n        e.tracePath(new UnionTypePredicate(schema.getTypes().get(unionIndex).getName()));\n      }\n      // writeArray() and writeMap() have their own handling\n      throw e;\n    } catch (NullPointerException e) {\n      throw new TracingNullPointException(e, schema, false);\n    } catch (ClassCastException e) {\n      throw new TracingClassCastException(e, datum, schema, false);\n    } catch (AvroTypeException e) {\n      throw new TracingAvroTypeException(e);\n    }\n  }\n\n  /** Helper method for adding a message to an NPE . */\n  protected NullPointerException npe(NullPointerException e, String s) {\n    NullPointerException result = new NullPointerException(e.getMessage() + s);\n    result.initCause(e.getCause() == null ? e : e.getCause());\n    return result;\n  }\n\n  /** Helper method for adding a message to an Class Cast Exception . */\n  protected ClassCastException addClassCastMsg(ClassCastException e, String s) {\n    ClassCastException result = new ClassCastException(e.getMessage() + s);\n    result.initCause(e.getCause() == null ? e : e.getCause());\n    return result;\n  }\n\n  /** Helper method for adding a message to an Avro Type Exception . */\n  protected AvroTypeException addAvroTypeMsg(AvroTypeException e, String s) {\n    AvroTypeException result = new AvroTypeException(e.getMessage() + s);\n    result.initCause(e.getCause() == null ? e : e.getCause());\n    return result;\n  }\n\n  /**\n   * Called to write a record. May be overridden for alternate record\n   * representations.\n   */\n  protected void writeRecord(Schema schema, Object datum, Encoder out) throws IOException {\n    Object state = data.getRecordState(datum, schema);\n    for (Field f : schema.getFields()) {\n      writeField(datum, f, out, state);\n    }\n  }\n\n  /**\n   * Called to write a single field of a record. May be overridden for more\n   * efficient or alternate implementations.\n   */\n  protected void writeField(Object datum, Field f, Encoder out, Object state) throws IOException {\n    Object value = data.getField(datum, f.name(), f.pos(), state);\n    try {\n      write(f.schema(), value, out);\n    } catch (final UnresolvedUnionException uue) { // recreate it with the right field info\n      final UnresolvedUnionException unresolvedUnionException = new UnresolvedUnionException(f.schema(), f, value);\n      unresolvedUnionException.addSuppressed(uue);\n      throw unresolvedUnionException;\n    } catch (TracingNullPointException | TracingClassCastException | TracingAvroTypeException e) {\n      e.tracePath(new LocationStep(\".\", f.name()));\n      throw e;\n    } catch (NullPointerException e) {\n      throw npe(e, \" in field \" + f.name());\n    } catch (ClassCastException cce) {\n      throw addClassCastMsg(cce, \" in field \" + f.name());\n    } catch (AvroTypeException ate) {\n      throw addAvroTypeMsg(ate, \" in field \" + f.name());\n    }\n  }\n\n  /**\n   * Called to write an enum value. May be overridden for alternate enum\n   * representations.\n   */\n  protected void writeEnum(Schema schema, Object datum, Encoder out) throws IOException {\n    if (!data.isEnum(datum)) {\n      AvroTypeException cause = new AvroTypeException(\n          \"value \" + SchemaUtil.describe(datum) + \" is not a \" + SchemaUtil.describe(schema));\n      throw new TracingAvroTypeException(cause);\n    }\n    out.writeEnum(schema.getEnumOrdinal(datum.toString()));\n  }\n\n  /**\n   * Called to write a array. May be overridden for alternate array\n   * representations.\n   */\n  protected void writeArray(Schema schema, Object datum, Encoder out) throws IOException {\n    Schema element = schema.getElementType();\n    long size = getArraySize(datum);\n    long actualSize = 0;\n    out.writeArrayStart();\n    out.setItemCount(size);\n    for (Iterator<? extends Object> it = getArrayElements(datum); it.hasNext();) {\n      out.startItem();\n      try {\n        write(element, it.next(), out);\n      } catch (TracingNullPointException | TracingClassCastException | TracingAvroTypeException e) {\n        e.tracePath(new ArrayPositionPredicate(actualSize));\n        throw e;\n      }\n      actualSize++;\n    }\n    out.writeArrayEnd();\n    if (actualSize != size) {\n      throw new ConcurrentModificationException(\n          \"Size of array written was \" + size + \", but number of elements written was \" + actualSize + \". \");\n    }\n  }\n\n  /**\n   * Called to find the index for a datum within a union. By default calls\n   * {@link GenericData#resolveUnion(Schema,Object)}.\n   */\n  protected int resolveUnion(Schema union, Object datum) {\n    return data.resolveUnion(union, datum);\n  }\n\n  /**\n   * Called by the default implementation of {@link #writeArray} to get the size\n   * of an array. The default implementation is for {@link Collection}.\n   */\n  protected long getArraySize(Object array) {\n    return ((Collection<?>) array).size();\n  }\n\n  /**\n   * Called by the default implementation of {@link #writeArray} to enumerate\n   * array elements. The default implementation is for {@link Collection}.\n   */\n  protected Iterator<?> getArrayElements(Object array) {\n    return ((Collection<?>) array).iterator();\n  }\n\n  /**\n   * Called to write a map. May be overridden for alternate map representations.\n   */\n  protected void writeMap(Schema schema, Object datum, Encoder out) throws IOException {\n    Schema value = schema.getValueType();\n    int size = getMapSize(datum);\n    int actualSize = 0;\n    out.writeMapStart();\n    out.setItemCount(size);\n    for (Map.Entry<Object, Object> entry : getMapEntries(datum)) {\n      out.startItem();\n      String key;\n      try {\n        key = entry.getKey().toString();\n      } catch (NullPointerException npe) {\n        TracingNullPointException tnpe = new TracingNullPointException(npe, Schema.create(Schema.Type.STRING), false);\n        tnpe.tracePath(new MapKeyPredicate(null));\n        throw tnpe;\n      }\n      writeString(key, out);\n      try {\n        write(value, entry.getValue(), out);\n      } catch (TracingNullPointException | TracingClassCastException | TracingAvroTypeException e) {\n        e.tracePath(new MapKeyPredicate(key));\n        throw e;\n      }\n      actualSize++;\n    }\n    out.writeMapEnd();\n    if (actualSize != size) {\n      throw new ConcurrentModificationException(\n          \"Size of map written was \" + size + \", but number of entries written was \" + actualSize + \". \");\n    }\n  }\n\n  /**\n   * Called by the default implementation of {@link #writeMap} to get the size of\n   * a map. The default implementation is for {@link Map}.\n   */\n  @SuppressWarnings(\"unchecked\")\n  protected int getMapSize(Object map) {\n    return ((Map) map).size();\n  }\n\n  /**\n   * Called by the default implementation of {@link #writeMap} to enumerate map\n   * elements. The default implementation is for {@link Map}.\n   */\n  @SuppressWarnings(\"unchecked\")\n  protected Iterable<Map.Entry<Object, Object>> getMapEntries(Object map) {\n    return ((Map) map).entrySet();\n  }\n\n  /**\n   * Called to write a string. May be overridden for alternate string\n   * representations.\n   */\n  protected void writeString(Schema schema, Object datum, Encoder out) throws IOException {\n    writeString(datum, out);\n  }\n\n  /**\n   * Called to write a string. May be overridden for alternate string\n   * representations.\n   */\n  protected void writeString(Object datum, Encoder out) throws IOException {\n    out.writeString((CharSequence) datum);\n  }\n\n  /**\n   * Called to write a bytes. May be overridden for alternate bytes\n   * representations.\n   */\n  protected void writeBytes(Object datum, Encoder out) throws IOException {\n    out.writeBytes((ByteBuffer) datum);\n  }\n\n  /**\n   * Called to write a fixed value. May be overridden for alternate fixed\n   * representations.\n   */\n  protected void writeFixed(Schema schema, Object datum, Encoder out) throws IOException {\n    out.writeFixed(((GenericFixed) datum).bytes(), 0, schema.getFixedSize());\n  }\n\n  private void error(Schema schema, Object datum) {\n    throw new AvroTypeException(\"value \" + SchemaUtil.describe(datum) + \" is not a \" + SchemaUtil.describe(schema));\n  }\n\n}\n","lineNo":337}
