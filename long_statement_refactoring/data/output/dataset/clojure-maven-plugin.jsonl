{"Smelly Sample":"/*\n * Copyright (c) Mark Derricutt 2010.\n *\n * The use and distribution terms for this software are covered by the Eclipse Public License 1.0\n * (http://opensource.org/licenses/eclipse-1.0.php) which can be found in the file epl-v10.html\n * at the root of this distribution.\n *\n * By using this software in any fashion, you are agreeing to be bound by the terms of this license.\n *\n * You must not remove this notice, or any other, from this software.\n */\n\npackage com.theoryinpractise.clojure;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang.SystemUtils;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.plugins.annotations.ResolutionScope;\n\n@Mojo(name = \"nrepl\", requiresDependencyResolution = ResolutionScope.TEST)\npublic class ClojureNReplMojo extends AbstractClojureCompilerMojo {\n\n  /**\n   * The clojure script to preceding the switch to the repl\n   */\n  @Parameter private String replScript;\n\n  @Parameter(defaultValue = \"4005\", property = \"clojure.nrepl.port\")\n  protected int port;\n\n  @Parameter(defaultValue = \"localhost\", property = \"clojure.nrepl.host\")\n  protected String nreplHost;\n\n  @Parameter protected String[] nreplMiddlewares;\n\n  public void execute() throws MojoExecutionException {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"(do \");\n    sb.append(\"(clojure.tools.nrepl.server/start-server\");\n    sb.append(\" :bind \\\"\").append(nreplHost).append(\"\\\"\");\n    sb.append(\" :port \");\n    sb.append(Integer.toString(port));\n    if (nreplMiddlewares != null) {\n      sb.append(\" :handler (clojure.tools.nrepl.server/default-handler \");\n      for (String mw : nreplMiddlewares) {\n        sb.append(\" (resolve (quote \").append(mw).append(\")) \");\n      }\n      sb.append(\")\");\n    }\n    sb.append(\"))\");\n    String nreplLoader = sb.toString();\n\n    if (SystemUtils.IS_OS_WINDOWS) {\n      nreplLoader = windowsEscapeCommandLineArg(nreplLoader);\n    }\n\n    List<String> args = new ArrayList<String>();\n    if (replScript != null && new File(replScript).exists()) {\n      args.add(\"-i\");\n      args.add(replScript);\n    }\n\n    args.add(\"-e\");\n    args.add(\"(require (quote clojure.tools.nrepl.server))\");\n    if (nreplMiddlewares != null) {\n      for (String mw : nreplMiddlewares) {\n        // there has to be a better way of doing this\n        // using Clojure or EDN reader perhaps\n        String[] ns_sym = mw.split(\"/\");\n        if (ns_sym.length == 2) {\n          String ns = ns_sym[0];\n          args.add(\"-e\");\n          args.add(\"(require (quote \" + ns + \"))\");\n        }\n      }\n    }\n    args.add(\"-e\");\n    args.add(nreplLoader);\n\n    callClojureWith(\n        getSourceDirectories(SourceDirectory.TEST, SourceDirectory.COMPILE),\n        outputDirectory,\n        getRunWithClasspathElements(),\n        \"clojure.main\",\n        args.toArray(new String[args.size()]));\n  }\n\n  @Parameter(property = \"clojure.nrepl.handler\")\n  private String nreplHandler;\n\n  public void execute() throws MojoExecutionException {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"(do \");\n    sb.append(\"(clojure.tools.nrepl.server/start-server\");\n    sb.append(\" :bind \\\"\").append(nreplHost).append(\"\\\"\");\n    sb.append(\" :port \");\n    sb.append(Integer.toString(port));\n    appendNreplHandler(sb);\n    sb.append(\"))\");\n    String nreplLoader = sb.toString();\n\n    if (SystemUtils.IS_OS_WINDOWS) {\n      nreplLoader = windowsEscapeCommandLineArg(nreplLoader);\n    }\n\n    List<String> args = new ArrayList<String>();\n    if (replScript != null && new File(replScript).exists()) {\n      args.add(\"-i\");\n      args.add(replScript);\n    }\n\n    args.add(\"-e\");\n    args.add(\"(require (quote clojure.tools.nrepl.server))\");\n    requireNreplHandlerNs(args);\n    args.add(\"-e\");\n    args.add(nreplLoader);\n\n    callClojureWith(\n        getSourceDirectories(SourceDirectory.TEST, SourceDirectory.COMPILE),\n        outputDirectory,\n        getRunWithClasspathElements(),\n        \"clojure.main\",\n        args.toArray(new String[args.size()]));\n  }\n\n  private void requireNreplHandlerNs(List<String> args) {\n    if (noNreplHandlerAvailable()) {\n      return;\n    }\n    args.add(\"-e\");\n    String nreplHandlerNs = nreplHandler.split(\"/\")[0];\n    args.add(\"(require (quote \" + nreplHandlerNs + \"))\");\n  }\n\n  private boolean noNreplHandlerAvailable() {\n    return nreplHandler == null || nreplHandler.trim().isEmpty();\n  }\n\n  private void appendNreplHandler(StringBuilder sb) {\n    if (noNreplHandlerAvailable()) {\n      return;\n    }\n    sb.append(\" :handler \").append(nreplHandler);\n  }\n\n  private String windowsEscapeCommandLineArg(String arg) {\n    return \"\\\"\" + arg.replace(\"\\\"\", \"\\\\\\\"\") + \"\\\"\";\n  }\n}\n","Method after Refactoring":"/*\n * Copyright (c) Mark Derricutt 2010.\n *\n * The use and distribution terms for this software are covered by the Eclipse Public License 1.0\n * (http://opensource.org/licenses/eclipse-1.0.php) which can be found in the file epl-v10.html\n * at the root of this distribution.\n *\n * By using this software in any fashion, you are agreeing to be bound by the terms of this license.\n *\n * You must not remove this notice, or any other, from this software.\n */\n\npackage com.theoryinpractise.clojure;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang.SystemUtils;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.plugins.annotations.ResolutionScope;\n\n@Mojo(name = \"nrepl\", requiresDependencyResolution = ResolutionScope.TEST)\npublic class ClojureNReplMojo extends AbstractClojureCompilerMojo {\n\n  /**\n   * The clojure script to preceding the switch to the repl\n   */\n  @Parameter private String replScript;\n\n  @Parameter(defaultValue = \"4005\", property = \"clojure.nrepl.port\")\n  protected int port;\n\n  @Parameter(defaultValue = \"localhost\", property = \"clojure.nrepl.host\")\n  protected String nreplHost;\n\n  @Parameter protected String[] nreplMiddlewares;\n\n  public void execute() throws MojoExecutionException {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"(do \");\n    sb.append(\"(clojure.tools.nrepl.server/start-server\");\n    sb.append(\" :bind \\\"\").append(nreplHost).append(\"\\\"\");\n    sb.append(\" :port \");\n    sb.append(Integer.toString(port));\n    if (nreplMiddlewares != null) {\n      sb.append(\" :handler (clojure.tools.nrepl.server/default-handler \");\n      for (String mw : nreplMiddlewares) {\n        sb.append(\" (resolve (quote \").append(mw).append(\")) \");\n      }\n      sb.append(\")\");\n    }\n    sb.append(\"))\");\n    String nreplLoader = sb.toString();\n\n    if (SystemUtils.IS_OS_WINDOWS) {\n      nreplLoader = windowsEscapeCommandLineArg(nreplLoader);\n    }\n\n    List<String> args = new ArrayList<String>();\n    if (replScript != null && new File(replScript).exists()) {\n      args.add(\"-i\");\n      args.add(replScript);\n    }\n\n    args.add(\"-e\");\n    args.add(\"(require (quote clojure.tools.nrepl.server))\");\n    if (nreplMiddlewares != null) {\n      for (String mw : nreplMiddlewares) {\n        // there has to be a better way of doing this\n        // using Clojure or EDN reader perhaps\n        String[] ns_sym = mw.split(\"/\");\n        if (ns_sym.length == 2) {\n          String ns = ns_sym[0];\n          args.add(\"-e\");\n          args.add(\"(require (quote \" + ns + \"))\");\n        }\n      }\n    }\n    args.add(\"-e\");\n    args.add(nreplLoader);\n\n    callClojureWith(\n        getSourceDirectories(SourceDirectory.TEST, SourceDirectory.COMPILE),\n        outputDirectory,\n        getRunWithClasspathElements(),\n        \"clojure.main\",\n        args.toArray(new String[args.size()]));\n  }\n\n  private String windowsEscapeCommandLineArg(String arg) {\n    return \"\\\"\" + arg.replace(\"\\\"\", \"\\\\\\\"\") + \"\\\"\";\n  }\n}\n","lineNo":74}
{"Smelly Sample":"/*\n * Copyright (c) Mark Derricutt 2010.\n *\n * The use and distribution terms for this software are covered by the Eclipse Public License 1.0\n * (http://opensource.org/licenses/eclipse-1.0.php) which can be found in the file epl-v10.html\n * at the root of this distribution.\n *\n * By using this software in any fashion, you are agreeing to be bound by the terms of this license.\n *\n * You must not remove this notice, or any other, from this software.\n */\n\npackage com.theoryinpractise.clojure;\n\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugins.annotations.LifecyclePhase;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.plugins.annotations.ResolutionScope;\n\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.util.Properties;\n\nimport static org.apache.commons.io.IOUtils.copy;\n\n@Mojo(name = \"test\", defaultPhase = LifecyclePhase.TEST, requiresDependencyResolution = ResolutionScope.TEST)\npublic class ClojureRunTestMojo extends AbstractClojureCompilerMojo {\n\n  /**\n   * Flag to allow test compiliation to be skipped.\n   *\n   * @noinspection UnusedDeclaration\n   */\n  @Parameter(required = true, property = \"maven.test.skip\", defaultValue = \"false\")\n  private boolean skip;\n\n  /**\n   * Flag to allow test execution to be skipped.\n   *\n   * @noinspection UnusedDeclaration\n   */\n  @Parameter(required = true, property = \"skipTests\", defaultValue = \"false\")\n  private boolean skipTests;\n\n  /**\n   * The main clojure script to run\n   */\n  @Parameter\n  private String testScript;\n\n  public void execute() throws MojoExecutionException {\n    if (skip || skipTests) {\n      getLog().info(\"Test execution is skipped\");\n    } else {\n      try {\n        final File[] testSourceDirectories = getSourceDirectories(SourceDirectory.TEST);\n        final File[] allSourceDirectories = getSourceDirectories(SourceDirectory.TEST, SourceDirectory.COMPILE);\n        final NamespaceInFile[] ns = new NamespaceDiscovery(getLog(), testOutputDirectory, charset, testDeclaredNamespaceOnly).discoverNamespacesIn(testNamespaces, testSourceDirectories);\n        File confFile = File.createTempFile(\"run-test\", \".txt\");\n        final PrintWriter confWriter = new PrintWriter(new FileWriter(confFile));\n        generateConfig(confWriter, ns);\n        confWriter.close();\n        String testConf = confFile.getPath();\n\n        if (!isClasspathResource(testScript)) {\n          if (!isExistingTestScriptFile(testScript)) {\n            // Generate test script\n            File testFile = File.createTempFile(\"run-test\", \".clj\");\n            final PrintWriter writer = new PrintWriter(new FileWriter(testFile));\n\n            generateTestScript(writer, ns);\n\n            writer.close();\n\n            testScript = testFile.getPath();\n\n          // throw new MojoExecutionException(\"testScript is empty or does not exist!\");\n          } else {\n            File testFile = new File(testScript);\n\n            if (!testFile.exists()) {\n              testFile = new File(getWorkingDirectory(), testScript);\n            }\n\n            if (!(testFile.exists())) {\n              throw new MojoExecutionException(\"testScript \" + testFile.getPath() + \" does not exist.\");\n            }\n          }\n        }\n\n        getLog().debug(\"Running clojure:test against \" + testScript);\n        callClojureWith(allSourceDirectories, outputDirectory, testClasspathElements, \"clojure.main\", new String[] {testScript, testConf});\n      } catch (IOException e) {\n        throw new MojoExecutionException(e.getMessage(), e);\n      }\n    }\n  }\n\n  protected void generateConfig(PrintWriter writer, NamespaceInFile[] ns) throws IOException {\n    Properties props = new Properties();\n    for(int i = 0; i < ns.length; i++) {\n      props.put(\"ns.\"+i, ns[i].getName());\n    }\n    props.put(\"junit\", \"false\");\n    props.put(\"outputDir\", \"/tmp/\");//TODO fix this\n    props.put(\"xmlEscape\", \"false\");//TODO fix this\n    props.store(writer,\"Test Run Properties\");\n  }\n\n  protected void generateTestScript(PrintWriter writer, NamespaceInFile[] ns) throws IOException {\n    copy(ClojureRunTestMojo.class.getResourceAsStream(\"/default_test_script.clj\"), writer);\n  }\n\n}\n","Method after Refactoring":"/*\n * Copyright (c) Mark Derricutt 2010.\n *\n * The use and distribution terms for this software are covered by the Eclipse Public License 1.0\n * (http://opensource.org/licenses/eclipse-1.0.php) which can be found in the file epl-v10.html\n * at the root of this distribution.\n *\n * By using this software in any fashion, you are agreeing to be bound by the terms of this license.\n *\n * You must not remove this notice, or any other, from this software.\n */\n\npackage com.theoryinpractise.clojure;\n\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugins.annotations.LifecyclePhase;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.plugins.annotations.ResolutionScope;\n\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.util.Properties;\n\nimport static org.apache.commons.io.IOUtils.copy;\n\n@Mojo(name = \"test\", defaultPhase = LifecyclePhase.TEST, requiresDependencyResolution = ResolutionScope.TEST)\npublic class ClojureRunTestMojo extends AbstractClojureCompilerMojo {\n\n  /**\n   * Flag to allow test compiliation to be skipped.\n   *\n   * @noinspection UnusedDeclaration\n   */\n  @Parameter(required = true, property = \"maven.test.skip\", defaultValue = \"false\")\n  private boolean skip;\n\n  /**\n   * Flag to allow test execution to be skipped.\n   *\n   * @noinspection UnusedDeclaration\n   */\n  @Parameter(required = true, property = \"skipTests\", defaultValue = \"false\")\n  private boolean skipTests;\n\n  /**\n   * The main clojure script to run\n   */\n  @Parameter\n  private String testScript;\n\n  /**\n   * Output directory for test results\n   *\n   * @noinspection UnusedDeclaration\n   */\n  @Parameter(defaultValue = \"${project.build.directory}/test-reports\", property = \"clojure.testOutputDirectory\")\n  private String testOutputDirectory;\n\n  /**\n   * Whether to XML escape non-report output sent to *out*\n   *\n   * @noinspection UnusedDeclaration\n   */\n  @Parameter(defaultValue = \"true\", property = \"clojure.xmlEscapeOutput\")\n  private boolean xmlEscapeOutput;\n\n  /**\n   * Whether to produce junit output or not\n   *\n   * @noinspection UnusedDeclaration\n   */\n  @Parameter(defaultValue = \"false\", property = \"clojure.junitOutput\")\n  private boolean junitOutput;\n\n  public void execute() throws MojoExecutionException {\n    if (skip || skipTests) {\n      getLog().info(\"Test execution is skipped\");\n    } else {\n      try {\n        final File[] testSourceDirectories = getSourceDirectories(SourceDirectory.TEST);\n        final File[] allSourceDirectories = getSourceDirectories(SourceDirectory.TEST, SourceDirectory.COMPILE);\n        final File outputFile = new File(testOutputDirectory);\n        final NamespaceInFile[] ns = new NamespaceDiscovery(getLog(), outputFile, charset, testDeclaredNamespaceOnly).discoverNamespacesIn(testNamespaces, testSourceDirectories);\n        File confFile = File.createTempFile(\"run-test\", \".txt\");\n        confFile.deleteOnExit();\n        final PrintWriter confWriter = new PrintWriter(new FileWriter(confFile));\n        generateConfig(confWriter, ns);\n        confWriter.close();\n        String testConf = confFile.getPath();\n\n        if (!isClasspathResource(testScript)) {\n          if (!isExistingTestScriptFile(testScript)) {\n            // Generate test script\n            outputFile.mkdir();\n\n            File testFile = File.createTempFile(\"run-test\", \".clj\");\n            testFile.deleteOnExit();\n            final PrintWriter writer = new PrintWriter(new FileWriter(testFile));\n\n            generateTestScript(writer, ns);\n\n            writer.close();\n\n            testScript = testFile.getPath();\n\n          // throw new MojoExecutionException(\"testScript is empty or does not exist!\");\n          } else {\n            File testFile = new File(testScript);\n\n            if (!testFile.exists()) {\n              testFile = new File(getWorkingDirectory(), testScript);\n            }\n\n            if (!(testFile.exists())) {\n              throw new MojoExecutionException(\"testScript \" + testFile.getPath() + \" does not exist.\");\n            }\n          }\n        }\n\n        getLog().debug(\"Running clojure:test against \" + testScript);\n        callClojureWith(allSourceDirectories, outputDirectory, testClasspathElements, \"clojure.main\", new String[] {testScript, testConf});\n      } catch (IOException e) {\n        throw new MojoExecutionException(e.getMessage(), e);\n      }\n    }\n  }\n\n  protected void generateConfig(PrintWriter writer, NamespaceInFile[] ns) throws IOException {\n    Properties props = new Properties();\n    for(int i = 0; i < ns.length; i++) {\n      props.put(\"ns.\"+i, ns[i].getName());\n    }\n    props.put(\"junit\", String.valueOf(junitOutput));\n    props.put(\"outputDir\", testOutputDirectory);\n    props.put(\"xmlEscape\", String.valueOf(xmlEscapeOutput));\n    props.store(writer,\"Test Run Properties\");\n  }\n\n  protected void generateTestScript(PrintWriter writer, NamespaceInFile[] ns) throws IOException {\n    copy(ClojureRunTestMojo.class.getResourceAsStream(\"/default_test_script.clj\"), writer);\n  }\n\n}\n","lineNo":86}
{"Smelly Sample":"/*\n * Copyright (c) Antony Blakey 2010.\n *\n * The use and distribution terms for this software are covered by the Eclipse Public License 1.0\n * (http://opensource.org/licenses/eclipse-1.0.php) which can be found in the file epl-v10.html\n * at the root of this distribution.\n *\n * By using this software in any fashion, you are agreeing to be bound by the terms of this license.\n *\n * You must not remove this notice, or any other, from this software.\n */\n\npackage com.theoryinpractise.clojure;\n\nimport java.io.File;\n\npublic class NamespaceInFile {\n\n    private String namespace;\n    private File sourceFile;\n\n    public NamespaceInFile(String namespace, File sourceFile) {\n        this.namespace = namespace;\n        this.sourceFile = sourceFile;\n    }\n\n    public String getName() {\n        return namespace;\n    }\n\n    public String getFilename() {\n        return namespace.replace('.', File.separatorChar).replace('-', '_') + \".clj\";\n    }\n\n    public File getSourceFile() {\n        return sourceFile;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        NamespaceInFile that = (NamespaceInFile) o;\n\n        if (!namespace.equals(that.namespace)) return false;\n        if (!sourceFile.equals(that.sourceFile)) return false;\n\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        int result = namespace.hashCode();\n        result = 31 * result + sourceFile.hashCode();\n        return result;\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (c) Antony Blakey 2010.\n *\n * The use and distribution terms for this software are covered by the Eclipse Public License 1.0\n * (http://opensource.org/licenses/eclipse-1.0.php) which can be found in the file epl-v10.html\n * at the root of this distribution.\n *\n * By using this software in any fashion, you are agreeing to be bound by the terms of this license.\n *\n * You must not remove this notice, or any other, from this software.\n */\n\npackage com.theoryinpractise.clojure;\n\nimport java.io.File;\n\npublic class NamespaceInFile {\n\n    private String namespace;\n    private File sourceFile;\n\n    public NamespaceInFile(String namespace, File sourceFile) {\n        this.namespace = namespace;\n        this.sourceFile = sourceFile;\n    }\n\n    public String getName() {\n        return namespace;\n    }\n\n    public String getFilename() {\n        String base = namespace.replace('.', File.separatorChar).replace('-', '_');\n        String sourceName = sourceFile.getName();\n        String suffix = sourceName.substring(sourceName.lastIndexOf(\".\"));\n        return base + suffix;\n    }\n\n    public File getSourceFile() {\n        return sourceFile;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        NamespaceInFile that = (NamespaceInFile) o;\n\n        if (!namespace.equals(that.namespace)) return false;\n        if (!sourceFile.equals(that.sourceFile)) return false;\n\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        int result = namespace.hashCode();\n        result = 31 * result + sourceFile.hashCode();\n        return result;\n    }\n}\n","lineNo":32}
{"Smelly Sample":"/*\n * Copyright (c) Mark Derricutt 2010.\n *\n * The use and distribution terms for this software are covered by the Eclipse Public License 1.0\n * (http://opensource.org/licenses/eclipse-1.0.php) which can be found in the file epl-v10.html\n * at the root of this distribution.\n *\n * By using this software in any fashion, you are agreeing to be bound by the terms of this license.\n *\n * You must not remove this notice, or any other, from this software.\n */\n\npackage com.theoryinpractise.clojure;\n\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugins.annotations.LifecyclePhase;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.plugins.annotations.ResolutionScope;\n\nimport java.io.File;\nimport java.io.IOException;\n\n@Mojo(name = \"compile\", defaultPhase = LifecyclePhase.COMPILE, requiresDependencyResolution = ResolutionScope.COMPILE)\npublic class ClojureCompilerMojo extends AbstractClojureCompilerMojo {\n\n    /**\n     * Should the compile phase create a temporary output directory for .class files?\n     */\n    @Parameter(required = true, defaultValue = \"false\")\n    protected Boolean temporaryOutputDirectory;\n\n    public void execute() throws MojoExecutionException {\n\n        File outputPath = outputDirectory;\n        if (temporaryOutputDirectory) {\n            try {\n                outputPath = File.createTempFile(\"classes\", \".dir\");\n                getLog().debug(\"Compiling clojure sources to \" + outputPath.getPath());\n            } catch (IOException e) {\n                throw new MojoExecutionException(\"Unable to create temporary output directory: \" + e.getMessage());\n            }\n            outputPath.delete();\n            outputPath.mkdir();\n        }\n\n        callClojureWith(\n                getSourceDirectories(SourceDirectory.COMPILE),\n                outputPath, classpathElements, \"clojure.lang.Compile\",\n                discoverNamespaces());\n\n        copyNamespaceSourceFilesToOutput(outputDirectory, discoverNamespacesToCopy());\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright (c) Mark Derricutt 2010.\n *\n * The use and distribution terms for this software are covered by the Eclipse Public License 1.0\n * (http://opensource.org/licenses/eclipse-1.0.php) which can be found in the file epl-v10.html\n * at the root of this distribution.\n *\n * By using this software in any fashion, you are agreeing to be bound by the terms of this license.\n *\n * You must not remove this notice, or any other, from this software.\n */\n\npackage com.theoryinpractise.clojure;\n\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugins.annotations.LifecyclePhase;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.plugins.annotations.ResolutionScope;\n\nimport java.io.File;\n\n@Mojo(name = \"compile\", defaultPhase = LifecyclePhase.COMPILE, requiresDependencyResolution = ResolutionScope.COMPILE)\npublic class ClojureCompilerMojo extends AbstractClojureCompilerMojo {\n\n    /**\n     * Should the compile phase create a temporary output directory for .class files?\n     */\n    @Parameter(required = true, defaultValue = \"false\")\n    protected Boolean temporaryOutputDirectory;\n\n    public void execute() throws MojoExecutionException {\n\n    \tFile outputPath = (temporaryOutputDirectory)\n    \t\t\t? createTemporaryDirectory(\"classes\")\n                : outputDirectory;\n\n    \tcallClojureWith(\n                getSourceDirectories(SourceDirectory.COMPILE),\n                outputPath, classpathElements, \"clojure.lang.Compile\",\n                discoverNamespaces());\n\n        copyNamespaceSourceFilesToOutput(outputPath, discoverNamespacesToCopy());\n    }\n\n}\n","lineNo":34}
{"Smelly Sample":"/*\n * Copyright (c) Mark Derricutt 2010.\n *\n * The use and distribution terms for this software are covered by the Eclipse Public License 1.0\n * (http://opensource.org/licenses/eclipse-1.0.php) which can be found in the file epl-v10.html\n * at the root of this distribution.\n *\n * By using this software in any fashion, you are agreeing to be bound by the terms of this license.\n *\n * You must not remove this notice, or any other, from this software.\n */\n\npackage com.theoryinpractise.clojure;\n\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugins.annotations.LifecyclePhase;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.plugins.annotations.ResolutionScope;\n\nimport java.io.File;\n\n@Mojo(name = \"testCompile\", defaultPhase = LifecyclePhase.TEST_COMPILE, requiresDependencyResolution = ResolutionScope.TEST)\npublic class TestClojureCompilerMojo extends AbstractClojureCompilerMojo {\n\n    /**\n     * Flag to allow test compiliation to be skipped.\n     */\n    @Parameter(required = true, property = \"maven.test.skip\", defaultValue = \"false\")\n    private boolean skip;\n\n    public void execute() throws MojoExecutionException {\n        if (skip) {\n            getLog().info(\"Test compilation is skipped\");\n        } else {\n            final File[] testSourceDirectories = getSourceDirectories(SourceDirectory.TEST);\n            callClojureWith(testSourceDirectories, testOutputDirectory, testClasspathElements, \"clojure.lang.Compile\",\n                            new NamespaceDiscovery(getLog(), testOutputDirectory, charset, testDeclaredNamespaceOnly, true).discoverNamespacesIn(testNamespaces, testSourceDirectories));\n        }\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright (c) Mark Derricutt 2010.\n *\n * The use and distribution terms for this software are covered by the Eclipse Public License 1.0\n * (http://opensource.org/licenses/eclipse-1.0.php) which can be found in the file epl-v10.html\n * at the root of this distribution.\n *\n * By using this software in any fashion, you are agreeing to be bound by the terms of this license.\n *\n * You must not remove this notice, or any other, from this software.\n */\n\npackage com.theoryinpractise.clojure;\n\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugins.annotations.LifecyclePhase;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.plugins.annotations.ResolutionScope;\n\nimport java.io.File;\n\n@Mojo(name = \"testCompile\", defaultPhase = LifecyclePhase.TEST_COMPILE, requiresDependencyResolution = ResolutionScope.TEST)\npublic class TestClojureCompilerMojo extends AbstractClojureCompilerMojo {\n\n    /**\n     * Flag to allow test compiliation to be skipped.\n     */\n    @Parameter(required = true, property = \"maven.test.skip\", defaultValue = \"false\")\n    private boolean skip;\n\n    /**\n     * Should the test-compile phase create a temporary output directory for .class files?\n     */\n    @Parameter(required = true, defaultValue = \"false\")\n    protected Boolean temporaryTestOutputDirectory;\n\n    public void execute() throws MojoExecutionException {\n    \tif (skip) {\n            getLog().info(\"Test compilation is skipped\");\n        } else {\n        \tFile outputPath = (temporaryTestOutputDirectory)\n        \t\t\t? createTemporaryDirectory(\"test-classes\")\n                    : testOutputDirectory;\n\n            final File[] testSourceDirectories = getSourceDirectories(SourceDirectory.TEST);\n            callClojureWith(testSourceDirectories, outputPath, testClasspathElements, \"clojure.lang.Compile\",\n                            new NamespaceDiscovery(getLog(), outputPath, charset, testDeclaredNamespaceOnly, true).discoverNamespacesIn(testNamespaces, testSourceDirectories));\n        }\n    }\n\n}\n","lineNo":42}
{"Smelly Sample":"/*\n * Copyright (c) Mark Derricutt 2010.\n *\n * The use and distribution terms for this software are covered by the Eclipse Public License 1.0\n * (http://opensource.org/licenses/eclipse-1.0.php) which can be found in the file epl-v10.html\n * at the root of this distribution.\n *\n * By using this software in any fashion, you are agreeing to be bound by the terms of this license.\n *\n * You must not remove this notice, or any other, from this software.\n */\n\npackage com.theoryinpractise.clojure;\n\nimport org.apache.maven.plugin.MojoExecutionException;\n\nimport java.io.*;\n\nimport static org.apache.commons.io.IOUtils.copy;\n\n/**\n * @goal test-with-junit\n * @phase test\n * @requiresDependencyResolution test\n */\npublic class ClojureRunTestWithJUnitMojo extends AbstractClojureCompilerMojo {\n\n    /**\n     * Flag to allow test compiliation to be skipped.\n     *\n     * @parameter expression=\"${maven.test.skip}\" default-value=\"false\"\n     * @noinspection UnusedDeclaration\n     */\n    private boolean skip;\n\n    /**\n     * The main clojure script to run\n     *\n     * @parameter\n     */\n    private String testScript;\n\n    /**\n     * Output directory for test results\n     *\n     * @parameter default-value=\"${project.build.directory}/test-reports\"\n     */\n    private String testOutputDirectory;\n\n    /**\n     * Whether to XML escape non-report output sent to *out*\n     *\n     * @parameter default-value=\"true\"\n     */\n    private boolean xmlEscapeOutput;\n\n    public void execute() throws MojoExecutionException {\n        if (skip) {\n            getLog().info(\"Test execution is skipped\");\n        } else {\n            final File[] testSourceDirectories = getSourceDirectories(SourceDirectory.TEST);\n            final File[] allSourceDirectories = getSourceDirectories(SourceDirectory.TEST, SourceDirectory.COMPILE);\n\n            if (testScript == null || \"\".equals(testScript) || !(new File(testScript).exists())) {\n                // Generate test script\n                try {\n                    new File(testOutputDirectory).mkdir();\n\n                    NamespaceInFile[] ns = new NamespaceDiscovery(getLog(), testDeclaredNamespaceOnly).discoverNamespacesIn(testNamespaces, testSourceDirectories);\n\n                    File testFile = File.createTempFile(\"run-test\", \".clj\");\n                    final PrintWriter writer = new PrintWriter(new FileWriter(testFile));\n\n                    for (NamespaceInFile namespace : ns) {\n                        writer.println(\"(require '\" + namespace.getName() + \")\");\n                    }\n\n                    StringWriter testCljWriter = new StringWriter();\n                    copy(ClojureRunTestWithJUnitMojo.class.getResourceAsStream(\"/default_test_script.clj\"), testCljWriter);\n\n                    StringBuilder runTestLine = new StringBuilder();\n                    for (NamespaceInFile namespace : ns) {\n                        if (xmlEscapeOutput) {\n                            // Assumes with-junit-output uses with-test-out internally when necessary.  xml escape anything sent to *out*.\n                            runTestLine.append(\"(with-open [writer (clojure.java.io/writer \\\"\" + escapeFilePath(testOutputDirectory, namespace.getName() + \".xml\") + \"\\\") \");\n                            runTestLine.append(\"            escaped (xml-escaping-writer writer)] \");\n                            runTestLine.append(\"(binding [*test-out* writer *out* escaped] (with-junit-output \");\n                            runTestLine.append(\"(run-tests\");\n                            runTestLine.append(\" '\" + namespace.getName());\n                            runTestLine.append(\"))))\");\n                        } else {\n                            // Use with-test-out to fix with-junit-output until clojure #431 is fixed\n                            runTestLine.append(\"(with-open [writer (clojure.java.io/writer \\\"\" + escapeFilePath(testOutputDirectory, namespace.getName() + \".xml\") + \"\\\")] \");\n                            runTestLine.append(\"(binding [*test-out* writer] (with-test-out (with-junit-output \");\n                            runTestLine.append(\"(run-tests\");\n                            runTestLine.append(\" '\" + namespace.getName());\n                            runTestLine.append(\")))))\");\n                        }\n                    }\n\n                    String testClj = testCljWriter.toString().replace(\"(run-tests)\", runTestLine.toString());\n\n                    writer.println(testClj);\n\n                    writer.close();\n\n                    testScript = testFile.getPath();\n\n                } catch (IOException e) {\n                    throw new MojoExecutionException(e.getMessage(), e);\n                }\n            } else {\n                File testFile = new File(testScript);\n\n                if (!testFile.exists()) {\n                    testFile = new File(getWorkingDirectory(), testScript);\n                }\n\n                if (!(testFile.exists())) {\n                    throw new MojoExecutionException(\"testScript \" + testFile.getPath() + \" does not exist.\");\n                }\n            }\n\n            getLog().debug(\"Running clojure:test-with-junit against \" + testScript);\n\n            callClojureWith(allSourceDirectories, outputDirectory, testClasspathElements, \"clojure.main\", new String[]{testScript});\n        }\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright (c) Mark Derricutt 2010.\n *\n * The use and distribution terms for this software are covered by the Eclipse Public License 1.0\n * (http://opensource.org/licenses/eclipse-1.0.php) which can be found in the file epl-v10.html\n * at the root of this distribution.\n *\n * By using this software in any fashion, you are agreeing to be bound by the terms of this license.\n *\n * You must not remove this notice, or any other, from this software.\n */\n\npackage com.theoryinpractise.clojure;\n\nimport org.apache.maven.plugin.MojoExecutionException;\n\nimport java.io.*;\n\nimport static org.apache.commons.io.IOUtils.copy;\n\n/**\n * @goal test-with-junit\n * @phase test\n * @requiresDependencyResolution test\n */\npublic class ClojureRunTestWithJUnitMojo extends AbstractClojureCompilerMojo {\n\n    /**\n     * Flag to allow test compiliation to be skipped.\n     *\n     * @parameter expression=\"${maven.test.skip}\" default-value=\"false\"\n     * @noinspection UnusedDeclaration\n     */\n    private boolean skip;\n\n    /**\n     * The main clojure script to run\n     *\n     * @parameter\n     */\n    private String testScript;\n\n    /**\n     * Output directory for test results\n     *\n     * @parameter default-value=\"${project.build.directory}/test-reports\"\n     */\n    private String testOutputDirectory;\n\n    /**\n     * Whether to XML escape non-report output sent to *out*\n     *\n     * @parameter default-value=\"true\"\n     */\n    private boolean xmlEscapeOutput;\n\n    public void execute() throws MojoExecutionException {\n        if (skip) {\n            getLog().info(\"Test execution is skipped\");\n        } else {\n            final File[] testSourceDirectories = getSourceDirectories(SourceDirectory.TEST);\n            final File[] allSourceDirectories = getSourceDirectories(SourceDirectory.TEST, SourceDirectory.COMPILE);\n\n            if (testScript == null || \"\".equals(testScript) || !(new File(testScript).exists())) {\n                // Generate test script\n                try {\n                    File outputFile = new File(testOutputDirectory);\n                    outputFile.mkdir();\n\n                    NamespaceInFile[] ns = new NamespaceDiscovery(getLog(), outputFile, testDeclaredNamespaceOnly).discoverNamespacesIn(testNamespaces, testSourceDirectories);\n\n                    File testFile = File.createTempFile(\"run-test\", \".clj\");\n                    final PrintWriter writer = new PrintWriter(new FileWriter(testFile));\n\n                    for (NamespaceInFile namespace : ns) {\n                        writer.println(\"(require '\" + namespace.getName() + \")\");\n                    }\n\n                    StringWriter testCljWriter = new StringWriter();\n                    copy(ClojureRunTestWithJUnitMojo.class.getResourceAsStream(\"/default_test_script.clj\"), testCljWriter);\n\n                    StringBuilder runTestLine = new StringBuilder();\n                    for (NamespaceInFile namespace : ns) {\n                        if (xmlEscapeOutput) {\n                            // Assumes with-junit-output uses with-test-out internally when necessary.  xml escape anything sent to *out*.\n                            runTestLine.append(\"(with-open [writer (clojure.java.io/writer \\\"\" + escapeFilePath(testOutputDirectory, namespace.getName() + \".xml\") + \"\\\") \");\n                            runTestLine.append(\"            escaped (xml-escaping-writer writer)] \");\n                            runTestLine.append(\"(binding [*test-out* writer *out* escaped] (with-junit-output \");\n                            runTestLine.append(\"(run-tests\");\n                            runTestLine.append(\" '\" + namespace.getName());\n                            runTestLine.append(\"))))\");\n                        } else {\n                            // Use with-test-out to fix with-junit-output until clojure #431 is fixed\n                            runTestLine.append(\"(with-open [writer (clojure.java.io/writer \\\"\" + escapeFilePath(testOutputDirectory, namespace.getName() + \".xml\") + \"\\\")] \");\n                            runTestLine.append(\"(binding [*test-out* writer] (with-test-out (with-junit-output \");\n                            runTestLine.append(\"(run-tests\");\n                            runTestLine.append(\" '\" + namespace.getName());\n                            runTestLine.append(\")))))\");\n                        }\n                    }\n\n                    String testClj = testCljWriter.toString().replace(\"(run-tests)\", runTestLine.toString());\n\n                    writer.println(testClj);\n\n                    writer.close();\n\n                    testScript = testFile.getPath();\n\n                } catch (IOException e) {\n                    throw new MojoExecutionException(e.getMessage(), e);\n                }\n            } else {\n                File testFile = new File(testScript);\n\n                if (!testFile.exists()) {\n                    testFile = new File(getWorkingDirectory(), testScript);\n                }\n\n                if (!(testFile.exists())) {\n                    throw new MojoExecutionException(\"testScript \" + testFile.getPath() + \" does not exist.\");\n                }\n            }\n\n            getLog().debug(\"Running clojure:test-with-junit against \" + testScript);\n\n            callClojureWith(allSourceDirectories, outputDirectory, testClasspathElements, \"clojure.main\", new String[]{testScript});\n        }\n    }\n\n}\n","lineNo":67}
{"Smelly Sample":"/*\n * Copyright (c) Mark Derricutt 2010.\n *\n * The use and distribution terms for this software are covered by the Eclipse Public License 1.0\n * (http://opensource.org/licenses/eclipse-1.0.php) which can be found in the file epl-v10.html\n * at the root of this distribution.\n *\n * By using this software in any fashion, you are agreeing to be bound by the terms of this license.\n *\n * You must not remove this notice, or any other, from this software.\n */\n\npackage com.theoryinpractise.clojure;\n\nimport org.apache.commons.exec.*;\nimport org.apache.commons.lang.SystemUtils;\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.toolchain.Toolchain;\nimport org.apache.maven.toolchain.ToolchainManager;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.*;\n\npublic abstract class AbstractClojureCompilerMojo extends AbstractMojo {\n\n\n    /**\n     * The current toolchain maanager instance\n     *\n     * @component\n     */\n    private ToolchainManager toolchainManager;\n\n    /**\n     * The current build session instance. This is used for\n     * toolchain manager API calls.\n     *\n     * @parameter expression=\"${session}\"\n     * @required\n     * @readonly\n     */\n    private MavenSession session;\n\n\n    /**\n     * Base directory of the project.\n     *\n     * @parameter expression=\"${basedir}\"\n     * @required\n     * @readonly\n     */\n    protected File baseDirectory;\n\n    /**\n     * Project classpath.\n     *\n     * @parameter default-value=\"${project.compileClasspathElements}\"\n     * @required\n     * @readonly\n     */\n    protected List<String> classpathElements;\n\n    /**\n     * Project test classpath.\n     *\n     * @parameter default-value=\"${project.testClasspathElements}\"\n     * @required\n     * @readonly\n     */\n    protected List<String> testClasspathElements;\n\n    /**\n     * Location of the file.\n     *\n     * @parameter default-value=\"${project.build.outputDirectory}\"\n     * @required\n     */\n    protected File outputDirectory;\n\n    /**\n     * Location of the file.\n     *\n     * @parameter default-value=\"${project.build.testOutputDirectory}\"\n     * @required\n     */\n    protected File testOutputDirectory;\n\n    /**\n     * Location of the source files.\n     *\n     * @parameter\n     */\n    private String[] sourceDirectories = new String[]{\"src/main/clojure\"};\n\n    /**\n     * Location of the source files.\n     *\n     * @parameter\n     */\n    private String[] testSourceDirectories = new String[]{\"src/test/clojure\"};\n\n    /**\n     * Location of the source files.\n     *\n     * @parameter default-value=\"${project.build.testSourceDirectory}\"\n     * @required\n     */\n    protected File baseTestSourceDirectory;\n\n    /**\n     * Location of the generated source files.\n     *\n     * @parameter default-value=\"${project.build.outputDirectory}/../generated-sources\"\n     * @required\n     */\n    protected File generatedSourceDirectory;\n\n    /**\n     * Working directory for forked java clojure process.\n     *\n     * @parameter\n     */\n    protected File workingDirectory;\n\n    /**\n     * Should we compile all namespaces or only those defined?\n     *\n     * @parameter default-value=\"false\"\n     */\n    protected boolean compileDeclaredNamespaceOnly;\n\n    /**\n     * A list of namespaces to compile\n     *\n     * @parameter\n     */\n    protected String[] namespaces;\n\n    /**\n     * Should we test all namespaces or only those defined?\n     *\n     * @parameter default-value=\"false\"\n     */\n    protected boolean testDeclaredNamespaceOnly;\n\n    /**\n     * A list of test namespaces to compile\n     *\n     * @parameter\n     */\n    protected String[] testNamespaces;\n\n    /**\n     * Classes to put onto the command line before the main class\n     *\n     * @parameter\n     */\n    private List<String> prependClasses;\n\n    /**\n     * Clojure/Java command-line options\n     *\n     * @parameter expression=\"${clojure.options}\"\n     */\n    private String clojureOptions = \"\";\n\n    /**\n     * Run with test-classpath or compile-classpath?\n     *\n     * @parameter expression=\"${clojure.runwith.test}\" default-value=\"true\"\n     */\n    private boolean runWithTests;\n\n    /**\n     * A list of namespaces whose source files will be copied to the output.\n     *\n     * @parameter\n     */\n    protected String[] copiedNamespaces;\n\n    /**\n     * Should we copy the source of all namespaces or only those defined?\n     *\n     * @parameter default-value=\"false\"\n     */\n    protected boolean copyDeclaredNamespaceOnly;\n\n    /**\n     * Should the source files of all compiled namespaces be copied to the output?\n     * This overrides copiedNamespaces and copyDeclaredNamespaceOnly.\n     *\n     * @parameter default-value=\"false\"\n     */\n    private boolean copyAllCompiledNamespaces;\n\n    /**\n     * Should reflective invocations in Clojure source emit warnings?  Corresponds with\n     * the *warn-on-reflection* var and the clojure.compile.warn-on-reflection system property.\n     *\n     * @parameter default-value=\"false\"\n     */\n    private boolean warnOnReflection;\n\n    /**\n     * Specify additional vmargs to use when running clojure or swank.\n     *\n     * @parameter expression=\"${clojure.vmargs}\"\n     */\n    private String vmargs;\n\n    private String getJavaExecutable() throws MojoExecutionException {\n\n        Toolchain tc = toolchainManager.getToolchainFromBuildContext(\"jdk\", //NOI18N\n                session);\n        if (tc != null) {\n            getLog().info(\"Toolchain in clojure-maven-plugin: \" + tc);\n            String foundExecutable = tc.findTool(\"java\");\n            if (foundExecutable != null) {\n                return foundExecutable;\n            } else {\n                throw new MojoExecutionException(\"Unable to find 'java' executable for toolchain: \" + tc);\n            }\n        }\n\n        return \"java\";\n    }\n\n    protected File getWorkingDirectory() throws MojoExecutionException {\n        if (workingDirectory != null) {\n            if (workingDirectory.exists()) {\n                return workingDirectory;\n            } else {\n                throw new MojoExecutionException(\"Directory specified in <workingDirectory/> does not exists: \" + workingDirectory.getPath());\n            }\n        } else {\n            return session.getCurrentProject().getBasedir();\n        }\n    }\n\n    private File[] translatePaths(String[] paths) {\n        File[] files = new File[paths.length];\n        for (int i = 0; i < paths.length; i++) {\n            files[i] = new File(baseDirectory, paths[i]);\n        }\n        return files;\n    }\n\n    protected NamespaceInFile[] discoverNamespaces() throws MojoExecutionException {\n        return new NamespaceDiscovery(getLog(), compileDeclaredNamespaceOnly).discoverNamespacesIn(namespaces, translatePaths(sourceDirectories));\n    }\n\n    protected NamespaceInFile[] discoverNamespacesToCopy() throws MojoExecutionException {\n        if (copyAllCompiledNamespaces)\n            return discoverNamespaces();\n        else\n            return new NamespaceDiscovery(getLog(), copyDeclaredNamespaceOnly).discoverNamespacesIn(copiedNamespaces, translatePaths(sourceDirectories));\n    }\n\n    public enum SourceDirectory {\n        COMPILE, TEST\n    }\n\n    ;\n\n    public File[] getSourceDirectories(SourceDirectory... sourceDirectoryTypes) {\n        List<File> dirs = new ArrayList<File>();\n\n        if (Arrays.asList(sourceDirectoryTypes).contains(SourceDirectory.COMPILE)) {\n            dirs.add(generatedSourceDirectory);\n            dirs.addAll(Arrays.asList(translatePaths(sourceDirectories)));\n        }\n        if (Arrays.asList(sourceDirectoryTypes).contains(SourceDirectory.TEST)) {\n            dirs.add(baseTestSourceDirectory);\n            dirs.addAll(Arrays.asList(translatePaths(testSourceDirectories)));\n        }\n\n        return dirs.toArray(new File[]{});\n\n    }\n\n    public List<String> getRunWithClasspathElements() {\n        return runWithTests ? testClasspathElements : classpathElements;\n    }\n\n    protected void copyNamespaceSourceFilesToOutput(File outputDirectory, NamespaceInFile[] discoveredNamespaces) throws MojoExecutionException {\n        for (NamespaceInFile ns : discoveredNamespaces) {\n            File outputFile = new File(outputDirectory, ns.getFilename());\n            outputFile.getParentFile().mkdirs();\n            try {\n                FileInputStream is = new FileInputStream(ns.getSourceFile());\n                try {\n                    FileOutputStream os = new FileOutputStream(outputFile);\n                    try {\n                        int amountRead;\n                        byte[] buffer = new byte[4096];\n                        while ((amountRead = is.read(buffer)) >= 0) {\n                            os.write(buffer, 0, amountRead);\n                        }\n                        is.close();\n                    } finally {\n                        is.close();\n                    }\n                } finally {\n                    is.close();\n                }\n            } catch (IOException ex) {\n                throw new MojoExecutionException(\"Couldn't copy the clojure source files to the output\", ex);\n            }\n        }\n    }\n\n    protected void callClojureWith(\n            File[] sourceDirectory,\n            File outputDirectory,\n            List<String> compileClasspathElements,\n            String mainClass,\n            NamespaceInFile[] namespaceArgs) throws MojoExecutionException {\n        callClojureWith(ExecutionMode.BATCH, sourceDirectory, outputDirectory, compileClasspathElements, mainClass, namespaceArgs);\n    }\n\n    protected void callClojureWith(\n            File[] sourceDirectory,\n            File outputDirectory,\n            List<String> compileClasspathElements,\n            String mainClass,\n            String[] clojureArgs) throws MojoExecutionException {\n        callClojureWith(ExecutionMode.BATCH, sourceDirectory, outputDirectory, compileClasspathElements, mainClass, clojureArgs);\n    }\n\n    protected void callClojureWith(\n            ExecutionMode executionMode,\n            File[] sourceDirectory,\n            File outputDirectory,\n            List<String> compileClasspathElements,\n            String mainClass,\n            NamespaceInFile[] namespaceArgs) throws MojoExecutionException {\n        String[] stringArgs = new String[namespaceArgs.length];\n        for (int i = 0; i < namespaceArgs.length; i++) {\n            stringArgs[i] = namespaceArgs[i].getName();\n        }\n        callClojureWith(executionMode, sourceDirectory, outputDirectory, compileClasspathElements, mainClass, stringArgs);\n    }\n\n    protected void callClojureWith(\n            ExecutionMode executionMode,\n            File[] sourceDirectory,\n            File outputDirectory,\n            List<String> compileClasspathElements,\n            String mainClass,\n            String[] clojureArgs) throws MojoExecutionException {\n\n        outputDirectory.mkdirs();\n\n        String cp = \"\";\n        for (File directory : sourceDirectory) {\n            cp = cp + directory.getPath() + File.pathSeparator;\n        }\n\n        cp = cp + outputDirectory.getPath() + File.pathSeparator;\n\n        for (Object classpathElement : compileClasspathElements) {\n            cp = cp + File.pathSeparator + classpathElement;\n        }\n\n        cp = cp.replaceAll(\"\\\\s\", \"\\\\ \");\n\n        final String javaExecutable = getJavaExecutable();\n        getLog().debug(\"Java exectuable used:  \" + javaExecutable);\n        getLog().debug(\"Clojure classpath: \" + cp);\n        CommandLine cl = null;\n\n        if (ExecutionMode.INTERACTIVE == executionMode && SystemUtils.IS_OS_WINDOWS) {\n            cl = new CommandLine(\"cmd\");\n            cl.addArgument(\"/c\");\n            cl.addArgument(\"start\");\n            cl.addArgument(javaExecutable);\n        } else {\n            cl = new CommandLine(javaExecutable);\n        }\n\n        if (vmargs != null) {\n            cl.addArguments(vmargs, false);\n        }\n\n        cl.addArgument(\"-cp\");\n        cl.addArgument(cp, false);\n        cl.addArgument(\"-Dclojure.compile.path=\" + outputDirectory.getPath(), false);\n\n        if (warnOnReflection) cl.addArgument(\"-Dclojure.compile.warn-on-reflection=true\");\n\n        cl.addArguments(clojureOptions, false);\n\n        if (prependClasses != null) {\n            cl.addArguments(prependClasses.toArray(new String[prependClasses.size()]));\n        }\n\n        cl.addArgument(mainClass);\n\n        if (clojureArgs != null) {\n            cl.addArguments(clojureArgs, false);\n        }\n\n        getLog().debug(\"Command line: \" + cl.toString());\n\n        Executor exec = new DefaultExecutor();\n        Map<String, String> env = new HashMap<String, String>(System.getenv());\n//        env.put(\"path\", \";\");\n//        env.put(\"path\", System.getProperty(\"java.home\"));\n\n        ExecuteStreamHandler handler = new PumpStreamHandler(System.out, System.err, System.in);\n        exec.setStreamHandler(handler);\n        exec.setWorkingDirectory(getWorkingDirectory());\n\n        int status;\n        try {\n            status = exec.execute(cl, env);\n        } catch (ExecuteException e) {\n            status = e.getExitValue();\n        } catch (IOException e) {\n            status = 1;\n        }\n\n        if (status != 0) {\n            throw new MojoExecutionException(\"Clojure failed.\");\n        }\n\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright (c) Mark Derricutt 2010.\n *\n * The use and distribution terms for this software are covered by the Eclipse Public License 1.0\n * (http://opensource.org/licenses/eclipse-1.0.php) which can be found in the file epl-v10.html\n * at the root of this distribution.\n *\n * By using this software in any fashion, you are agreeing to be bound by the terms of this license.\n *\n * You must not remove this notice, or any other, from this software.\n */\n\npackage com.theoryinpractise.clojure;\n\nimport org.apache.commons.exec.*;\nimport org.apache.commons.lang.SystemUtils;\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.toolchain.Toolchain;\nimport org.apache.maven.toolchain.ToolchainManager;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.*;\n\npublic abstract class AbstractClojureCompilerMojo extends AbstractMojo {\n\n\n    /**\n     * The current toolchain maanager instance\n     *\n     * @component\n     */\n    private ToolchainManager toolchainManager;\n\n    /**\n     * The current build session instance. This is used for\n     * toolchain manager API calls.\n     *\n     * @parameter expression=\"${session}\"\n     * @required\n     * @readonly\n     */\n    private MavenSession session;\n\n\n    /**\n     * Base directory of the project.\n     *\n     * @parameter expression=\"${basedir}\"\n     * @required\n     * @readonly\n     */\n    protected File baseDirectory;\n\n    /**\n     * Project classpath.\n     *\n     * @parameter default-value=\"${project.compileClasspathElements}\"\n     * @required\n     * @readonly\n     */\n    protected List<String> classpathElements;\n\n    /**\n     * Project test classpath.\n     *\n     * @parameter default-value=\"${project.testClasspathElements}\"\n     * @required\n     * @readonly\n     */\n    protected List<String> testClasspathElements;\n\n    /**\n     * Location of the file.\n     *\n     * @parameter default-value=\"${project.build.outputDirectory}\"\n     * @required\n     */\n    protected File outputDirectory;\n\n    /**\n     * Location of the file.\n     *\n     * @parameter default-value=\"${project.build.testOutputDirectory}\"\n     * @required\n     */\n    protected File testOutputDirectory;\n\n    /**\n     * Location of the source files.\n     *\n     * @parameter\n     */\n    private String[] sourceDirectories = new String[]{\"src/main/clojure\"};\n\n    /**\n     * Location of the source files.\n     *\n     * @parameter\n     */\n    private String[] testSourceDirectories = new String[]{\"src/test/clojure\"};\n\n    /**\n     * Location of the source files.\n     *\n     * @parameter default-value=\"${project.build.testSourceDirectory}\"\n     * @required\n     */\n    protected File baseTestSourceDirectory;\n\n    /**\n     * Location of the generated source files.\n     *\n     * @parameter default-value=\"${project.build.outputDirectory}/../generated-sources\"\n     * @required\n     */\n    protected File generatedSourceDirectory;\n\n    /**\n     * Working directory for forked java clojure process.\n     *\n     * @parameter\n     */\n    protected File workingDirectory;\n\n    /**\n     * Should we compile all namespaces or only those defined?\n     *\n     * @parameter default-value=\"false\"\n     */\n    protected boolean compileDeclaredNamespaceOnly;\n\n    /**\n     * A list of namespaces to compile\n     *\n     * @parameter\n     */\n    protected String[] namespaces;\n\n    /**\n     * Should we test all namespaces or only those defined?\n     *\n     * @parameter default-value=\"false\"\n     */\n    protected boolean testDeclaredNamespaceOnly;\n\n    /**\n     * A list of test namespaces to compile\n     *\n     * @parameter\n     */\n    protected String[] testNamespaces;\n\n    /**\n     * Classes to put onto the command line before the main class\n     *\n     * @parameter\n     */\n    private List<String> prependClasses;\n\n    /**\n     * Clojure/Java command-line options\n     *\n     * @parameter expression=\"${clojure.options}\"\n     */\n    private String clojureOptions = \"\";\n\n    /**\n     * Run with test-classpath or compile-classpath?\n     *\n     * @parameter expression=\"${clojure.runwith.test}\" default-value=\"true\"\n     */\n    private boolean runWithTests;\n\n    /**\n     * A list of namespaces whose source files will be copied to the output.\n     *\n     * @parameter\n     */\n    protected String[] copiedNamespaces;\n\n    /**\n     * Should we copy the source of all namespaces or only those defined?\n     *\n     * @parameter default-value=\"false\"\n     */\n    protected boolean copyDeclaredNamespaceOnly;\n\n    /**\n     * Should the source files of all compiled namespaces be copied to the output?\n     * This overrides copiedNamespaces and copyDeclaredNamespaceOnly.\n     *\n     * @parameter default-value=\"false\"\n     */\n    private boolean copyAllCompiledNamespaces;\n\n    /**\n     * Should reflective invocations in Clojure source emit warnings?  Corresponds with\n     * the *warn-on-reflection* var and the clojure.compile.warn-on-reflection system property.\n     *\n     * @parameter default-value=\"false\"\n     */\n    private boolean warnOnReflection;\n\n    /**\n     * Specify additional vmargs to use when running clojure or swank.\n     *\n     * @parameter expression=\"${clojure.vmargs}\"\n     */\n    private String vmargs;\n\n    private String getJavaExecutable() throws MojoExecutionException {\n\n        Toolchain tc = toolchainManager.getToolchainFromBuildContext(\"jdk\", //NOI18N\n                session);\n        if (tc != null) {\n            getLog().info(\"Toolchain in clojure-maven-plugin: \" + tc);\n            String foundExecutable = tc.findTool(\"java\");\n            if (foundExecutable != null) {\n                return foundExecutable;\n            } else {\n                throw new MojoExecutionException(\"Unable to find 'java' executable for toolchain: \" + tc);\n            }\n        }\n\n        return \"java\";\n    }\n\n    protected File getWorkingDirectory() throws MojoExecutionException {\n        if (workingDirectory != null) {\n            if (workingDirectory.exists()) {\n                return workingDirectory;\n            } else {\n                throw new MojoExecutionException(\"Directory specified in <workingDirectory/> does not exists: \" + workingDirectory.getPath());\n            }\n        } else {\n            return session.getCurrentProject().getBasedir();\n        }\n    }\n\n    private File[] translatePaths(String[] paths) {\n        File[] files = new File[paths.length];\n        for (int i = 0; i < paths.length; i++) {\n            files[i] = new File(baseDirectory, paths[i]);\n        }\n        return files;\n    }\n\n    protected NamespaceInFile[] discoverNamespaces() throws MojoExecutionException {\n        return new NamespaceDiscovery(getLog(), compileDeclaredNamespaceOnly).discoverNamespacesIn(namespaces, translatePaths(sourceDirectories));\n    }\n\n    protected NamespaceInFile[] discoverNamespacesToCopy() throws MojoExecutionException {\n        if (copyAllCompiledNamespaces)\n            return discoverNamespaces();\n        else\n            return new NamespaceDiscovery(getLog(), copyDeclaredNamespaceOnly).discoverNamespacesIn(copiedNamespaces, translatePaths(sourceDirectories));\n    }\n\n    public enum SourceDirectory {\n        COMPILE, TEST\n    }\n\n    public String getSourcePath(SourceDirectory... sourceDirectoryTypes) {\n        return getPath(getSourceDirectories(sourceDirectoryTypes));\n    }\n\n    public File[] getSourceDirectories(SourceDirectory... sourceDirectoryTypes) {\n        List<File> dirs = new ArrayList<File>();\n\n        if (Arrays.asList(sourceDirectoryTypes).contains(SourceDirectory.COMPILE)) {\n            dirs.add(generatedSourceDirectory);\n            dirs.addAll(Arrays.asList(translatePaths(sourceDirectories)));\n        }\n        if (Arrays.asList(sourceDirectoryTypes).contains(SourceDirectory.TEST)) {\n            dirs.add(baseTestSourceDirectory);\n            dirs.addAll(Arrays.asList(translatePaths(testSourceDirectories)));\n        }\n\n        return dirs.toArray(new File[]{});\n\n    }\n\n    private String getPath(File[] sourceDirectory) {\n        String cp = \"\";\n        for (File directory : sourceDirectory) {\n            cp = cp + directory.getPath() + File.pathSeparator;\n        }\n        return cp.substring(0, cp.length() - 1);\n    }\n\n    public List<String> getRunWithClasspathElements() {\n        return runWithTests ? testClasspathElements : classpathElements;\n    }\n\n    protected void copyNamespaceSourceFilesToOutput(File outputDirectory, NamespaceInFile[] discoveredNamespaces) throws MojoExecutionException {\n        for (NamespaceInFile ns : discoveredNamespaces) {\n            File outputFile = new File(outputDirectory, ns.getFilename());\n            outputFile.getParentFile().mkdirs();\n            try {\n                FileInputStream is = new FileInputStream(ns.getSourceFile());\n                try {\n                    FileOutputStream os = new FileOutputStream(outputFile);\n                    try {\n                        int amountRead;\n                        byte[] buffer = new byte[4096];\n                        while ((amountRead = is.read(buffer)) >= 0) {\n                            os.write(buffer, 0, amountRead);\n                        }\n                        is.close();\n                    } finally {\n                        is.close();\n                    }\n                } finally {\n                    is.close();\n                }\n            } catch (IOException ex) {\n                throw new MojoExecutionException(\"Couldn't copy the clojure source files to the output\", ex);\n            }\n        }\n    }\n\n    protected void callClojureWith(\n            File[] sourceDirectory,\n            File outputDirectory,\n            List<String> compileClasspathElements,\n            String mainClass,\n            NamespaceInFile[] namespaceArgs) throws MojoExecutionException {\n        callClojureWith(ExecutionMode.BATCH, sourceDirectory, outputDirectory, compileClasspathElements, mainClass, namespaceArgs);\n    }\n\n    protected void callClojureWith(\n            File[] sourceDirectory,\n            File outputDirectory,\n            List<String> compileClasspathElements,\n            String mainClass,\n            String[] clojureArgs) throws MojoExecutionException {\n        callClojureWith(ExecutionMode.BATCH, sourceDirectory, outputDirectory, compileClasspathElements, mainClass, clojureArgs);\n    }\n\n    protected void callClojureWith(\n            ExecutionMode executionMode,\n            File[] sourceDirectory,\n            File outputDirectory,\n            List<String> compileClasspathElements,\n            String mainClass,\n            NamespaceInFile[] namespaceArgs) throws MojoExecutionException {\n        String[] stringArgs = new String[namespaceArgs.length];\n        for (int i = 0; i < namespaceArgs.length; i++) {\n            stringArgs[i] = namespaceArgs[i].getName();\n        }\n        callClojureWith(executionMode, sourceDirectory, outputDirectory, compileClasspathElements, mainClass, stringArgs);\n    }\n\n    protected void callClojureWith(\n            ExecutionMode executionMode,\n            File[] sourceDirectory,\n            File outputDirectory,\n            List<String> compileClasspathElements,\n            String mainClass,\n            String[] clojureArgs) throws MojoExecutionException {\n\n        outputDirectory.mkdirs();\n\n        String cp = getPath(sourceDirectory);\n\n        cp = cp + outputDirectory.getPath() + File.pathSeparator;\n\n        for (Object classpathElement : compileClasspathElements) {\n            cp = cp + File.pathSeparator + classpathElement;\n        }\n\n        cp = cp.replaceAll(\"\\\\s\", \"\\\\ \");\n\n        final String javaExecutable = getJavaExecutable();\n        getLog().debug(\"Java exectuable used:  \" + javaExecutable);\n        getLog().debug(\"Clojure classpath: \" + cp);\n        CommandLine cl = null;\n\n        if (ExecutionMode.INTERACTIVE == executionMode && SystemUtils.IS_OS_WINDOWS) {\n            cl = new CommandLine(\"cmd\");\n            cl.addArgument(\"/c\");\n            cl.addArgument(\"start\");\n            cl.addArgument(javaExecutable);\n        } else {\n            cl = new CommandLine(javaExecutable);\n        }\n\n        if (vmargs != null) {\n            cl.addArguments(vmargs, false);\n        }\n\n        cl.addArgument(\"-cp\");\n        cl.addArgument(cp, false);\n        cl.addArgument(\"-Dclojure.compile.path=\" + outputDirectory.getPath(), false);\n\n        if (warnOnReflection) cl.addArgument(\"-Dclojure.compile.warn-on-reflection=true\");\n\n        cl.addArguments(clojureOptions, false);\n\n        if (prependClasses != null) {\n            cl.addArguments(prependClasses.toArray(new String[prependClasses.size()]));\n        }\n\n        cl.addArgument(mainClass);\n\n        if (clojureArgs != null) {\n            cl.addArguments(clojureArgs, false);\n        }\n\n        getLog().debug(\"Command line: \" + cl.toString());\n\n        Executor exec = new DefaultExecutor();\n        Map<String, String> env = new HashMap<String, String>(System.getenv());\n//        env.put(\"path\", \";\");\n//        env.put(\"path\", System.getProperty(\"java.home\"));\n\n        ExecuteStreamHandler handler = new PumpStreamHandler(System.out, System.err, System.in);\n        exec.setStreamHandler(handler);\n        exec.setWorkingDirectory(getWorkingDirectory());\n\n        int status;\n        try {\n            status = exec.execute(cl, env);\n        } catch (ExecuteException e) {\n            status = e.getExitValue();\n        } catch (IOException e) {\n            status = 1;\n        }\n\n        if (status != 0) {\n            throw new MojoExecutionException(\"Clojure failed.\");\n        }\n\n    }\n\n}\n","lineNo":369}
{"Smelly Sample":"/*\n * Copyright (c) Mark Derricutt 2010.\n *\n * The use and distribution terms for this software are covered by the Eclipse Public License 1.0\n * (http://opensource.org/licenses/eclipse-1.0.php) which can be found in the file epl-v10.html\n * at the root of this distribution.\n *\n * By using this software in any fashion, you are agreeing to be bound by the terms of this license.\n *\n * You must not remove this notice, or any other, from this software.\n */\n\npackage com.theoryinpractise.clojure;\n\nimport org.apache.maven.plugin.MojoExecutionException;\n\n/**\n * @goal compile\n * @phase compile\n * @requiresDependencyResolution compile\n */\npublic class ClojureCompilerMojo extends AbstractClojureCompilerMojo {\n\n    public void execute() throws MojoExecutionException {\n        callClojureWith(\n                getSourceDirectories(SourceDirectory.COMPILE),\n                outputDirectory, classpathElements, \"clojure.lang.Compile\",\n                discoverNamespaces());\n        copyNamespaceSourceFilesToOutput(outputDirectory, discoverNamespacesToCopy());\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright (c) Mark Derricutt 2010.\n *\n * The use and distribution terms for this software are covered by the Eclipse Public License 1.0\n * (http://opensource.org/licenses/eclipse-1.0.php) which can be found in the file epl-v10.html\n * at the root of this distribution.\n *\n * By using this software in any fashion, you are agreeing to be bound by the terms of this license.\n *\n * You must not remove this notice, or any other, from this software.\n */\n\npackage com.theoryinpractise.clojure;\n\nimport org.apache.maven.plugin.MojoExecutionException;\n\nimport java.io.File;\nimport java.io.IOException;\n\n/**\n * @goal compile\n * @phase compile\n * @requiresDependencyResolution compile\n */\npublic class ClojureCompilerMojo extends AbstractClojureCompilerMojo {\n\n    /**\n     * Should the compile phase create a temporary output directory for .class files?\n     *\n     * @parameter default-value=\"false\"\n     * @required\n     */\n    protected Boolean temporyOutputDirectory;\n\n    public void execute() throws MojoExecutionException {\n\n        File outputPath = outputDirectory;\n        if (temporyOutputDirectory) {\n            try {\n                outputPath = File.createTempFile(\"classes\", \".dir\");\n                getLog().debug(\"Compiling clojure sources to \" + outputPath.getPath());\n            } catch (IOException e) {\n                throw new MojoExecutionException(\"Unable to create tempory output directory: \" + e.getMessage());\n            }\n            outputPath.delete();\n            outputPath.mkdir();\n        }\n\n        callClojureWith(\n                getSourceDirectories(SourceDirectory.COMPILE),\n                outputPath, classpathElements, \"clojure.lang.Compile\",\n                discoverNamespaces());\n\n        copyNamespaceSourceFilesToOutput(outputDirectory, discoverNamespacesToCopy());\n    }\n\n}\n","lineNo":37}
{"Smelly Sample":"package com.theoryinpractise.clojure;\n\nimport org.apache.maven.plugin.MojoExecutionException;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * Plugin for Clojure source compiling.\n * <p/>\n * (C) Copyright Tim Dysinger   (tim -on- dysinger.net)\n * Mark Derricutt (mark -on- talios.com)\n * Dimitry Gashinsky (dimitry -on- gashinsky.com)\n * <p/>\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * @goal test\n * @phase test\n * @requiresDependencyResolution test\n */\npublic class ClojureRunTestMojo extends AbstractClojureCompilerMojo {\n    /**\n     * Location of the file.\n     *\n     * @parameter default-value=\"${project.build.testOutputDirectory}\"\n     * @required\n     */\n    private File outputDirectory;\n\n    /**\n     * Flag to allow test compiliation to be skipped.\n     *\n     * @parameter expression=\"${maven.test.skip}\" default-value=\"false\"\n     * @noinspection UnusedDeclaration\n     */\n    private boolean skip;\n\n    /**\n     * Location of the source files.\n     *\n     * @parameter default-value=\"${project.build.testSourceDirectory}\"\n     * @required\n     */\n    private File baseTestSourceDirectory;\n\n    /**\n     * Location of the source files.\n     *\n     * @parameter\n     */\n    private File[] sourceDirectories = new File[] {new File(\"src/main/clojure\")};\n\n    /**\n     * Location of the source files.\n     *\n     * @parameter\n     */\n    private File[] testSourceDirectories = new File[] {new File(\"src/test/clojure\")};\n\n    /**\n     * Project classpath.\n     *\n     * @parameter default-value=\"${project.testClasspathElements}\"\n     * @required\n     * @readonly\n     */\n    private List<String> classpathElements;\n\n    /**\n     * The main clojure script to run\n     *\n     * @parameter\n     */\n    private String testScript;\n\n    public void execute() throws MojoExecutionException {\n        if (skip) {\n            getLog().info(\"Test execution is skipped\");\n        } else {\n            if (testScript == null || \"\".equals(testScript) || !(new File(testScript).exists())) {\n                throw new MojoExecutionException(\"testScript is empty or does not exist!\");\n            } else {\n                List<File> dirs = new ArrayList<File>();\n                if (baseTestSourceDirectory != null) {\n                    dirs.add(baseTestSourceDirectory);\n                }\n                if (testSourceDirectories != null) {\n                    dirs.addAll(Arrays.asList(testSourceDirectories));\n                }\n                if (sourceDirectories != null) {\n                    dirs.addAll(Arrays.asList(sourceDirectories));\n                }\n\n                callClojureWith(dirs.toArray(new File[]{}), outputDirectory, classpathElements, \"clojure.main\", new String[]{testScript});\n            }\n        }\n    }\n\n}\n","Method after Refactoring":"package com.theoryinpractise.clojure;\n\nimport org.apache.maven.plugin.MojoExecutionException;\n\nimport java.io.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport static org.apache.commons.io.IOUtils.copy;\n\n/**\n * Plugin for Clojure source compiling.\n * <p/>\n * (C) Copyright Tim Dysinger   (tim -on- dysinger.net)\n * Mark Derricutt (mark -on- talios.com)\n * Dimitry Gashinsky (dimitry -on- gashinsky.com)\n * <p/>\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * @goal test\n * @phase test\n * @requiresDependencyResolution test\n */\npublic class ClojureRunTestMojo extends AbstractClojureCompilerMojo {\n\n    /**\n     * Flag to allow test compiliation to be skipped.\n     *\n     * @parameter expression=\"${maven.test.skip}\" default-value=\"false\"\n     * @noinspection UnusedDeclaration\n     */\n    private boolean skip;\n\n    /**\n     * The main clojure script to run\n     *\n     * @parameter\n     */\n    private String testScript;\n\n    public void execute() throws MojoExecutionException {\n        if (skip) {\n            getLog().info(\"Test execution is skipped\");\n        } else {\n\n            List<File> dirs = new ArrayList<File>();\n            if (baseTestSourceDirectory != null) {\n                dirs.add(baseTestSourceDirectory);\n            }\n            if (testSourceDirectories != null) {\n                dirs.addAll(Arrays.asList(testSourceDirectories));\n            }\n            if (sourceDirectories != null) {\n                dirs.addAll(Arrays.asList(sourceDirectories));\n            }\n            final File[] allSourceDirectories = dirs.toArray(new File[]{});\n\n            if (testScript == null || \"\".equals(testScript) || !(new File(testScript).exists())) {\n\n                // Generate test script\n\n                try {\n                    String[] ns = new NamespaceDiscovery(getLog(), compileDeclaredNamespaceOnly).discoverNamespacesIn(namespaces, allSourceDirectories);\n\n\n                    File testFile = File.createTempFile(\"run-test\", \".clj\");\n                    final PrintWriter writer = new PrintWriter(new FileWriter(testFile));\n\n                    for (String namespace : ns) {\n                        writer.println(\"(require '\" + namespace + \")\");\n                    }\n\n                    copy(ClojureRunTestMojo.class.getResourceAsStream(\"/default_test_script.clj\"), writer);\n\n                    writer.close();\n\n                    testScript = testFile.getPath();\n\n                } catch (IOException e) {\n                    e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.\n                }\n\n\n                // throw new MojoExecutionException(\"testScript is empty or does not exist!\");\n            }\n\n\n            getLog().debug(\"Running clojure:test against \" + testScript);\n\n            callClojureWith(allSourceDirectories, outputDirectory, classpathElements, \"clojure.main\", new String[]{testScript});\n        }\n    }\n\n}\n","lineNo":57}
{"Smelly Sample":"package com.theoryinpractise.clojure;\n\nimport org.apache.maven.plugin.MojoExecutionException;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * Mojo to start a clojure repl\n * <p/>\n * (C) Copyright Tim Dysinger   (tim -on- dysinger.net)\n * Mark Derricutt (mark -on- talios.com)\n * Dimitry Gashinsky (dimitry -on- gashinsky.com)\n * Scott Fleckenstein (nullstyle -on- gmail.com)\n * <p/>\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * @goal repl\n * @execute phase=\"compile\"\n * @requiresDependencyResolution compile\n */\npublic class ClojureReplMojo extends AbstractClojureCompilerMojo {\n    /**\n     * Location of the file.\n     *\n     * @parameter default-value=\"${project.build.outputDirectory}\"\n     * @required\n     */\n    private File outputDirectory;\n\n    /**\n     * Location of the source files.\n     *\n     * @parameter\n     */\n    private File[] sourceDirectories = new File[] {new File(\"src/main/clojure\")};\n\n    /**\n     * Location of the test source files.\n     *\n     * @parameter\n     */\n    private File[] testSourceDirectories = new File[] {new File(\"src/test/clojure\")};\n\n    /**\n     * Location of the generated source files.\n     *\n     * @parameter default-value=\"${project.build.outputDirectory}/../generated-sources\"\n     * @required\n     */\n    private File generatedSourceDirectory;\n\n    /**\n     * Project classpath.\n     *\n     * @parameter default-value=\"${project.compileClasspathElements}\"\n     * @required\n     * @readonly\n     */\n    private List<String> classpathElements;\n    \n    \n    /**\n     * The clojure script to preceding the switch to the repl\n     *\n     * @parameter\n     */\n    private String replScript;\n\n    public void execute() throws MojoExecutionException {\n\n        List<File> dirs = new ArrayList<File>();\n        if (sourceDirectories != null) {\n            dirs.addAll(Arrays.asList(sourceDirectories));\n        }\n        if (testSourceDirectories != null) {\n            dirs.addAll(Arrays.asList(testSourceDirectories));\n        }\n        dirs.add(generatedSourceDirectory);\n        \n        String[] args = new String[0];\n        \n        if (replScript != null && new File(replScript).exists()) {\n          args = new String[] { replScript };   \n        }\n        \n        callClojureWith(dirs.toArray(new File[]{}), outputDirectory, classpathElements, \"clojure.main\", args);\n        \n    }\n\n}\n","Method after Refactoring":"package com.theoryinpractise.clojure;\n\nimport java.io.File;\nimport java.util.ArrayList;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.regex.*;\nimport org.apache.maven.plugin.MojoExecutionException;\n\n/**\n * Mojo to start a clojure repl\n * <p/>\n * (C) Copyright Tim Dysinger   (tim -on- dysinger.net)\n * Mark Derricutt (mark -on- talios.com)\n * Dimitry Gashinsky (dimitry -on- gashinsky.com)\n * Scott Fleckenstein (nullstyle -on- gmail.com)\n * <p/>\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * @goal repl\n * @execute phase=\"compile\"\n * @requiresDependencyResolution compile\n */\npublic class ClojureReplMojo extends AbstractClojureCompilerMojo {\n    /**\n     * Location of the file.\n     *\n     * @parameter default-value=\"${project.build.outputDirectory}\"\n     * @required\n     */\n    private File outputDirectory;\n\n    /**\n     * Location of the source files.\n     *\n     * @parameter\n     */\n    private File[] sourceDirectories = new File[] {new File(\"src/main/clojure\")};\n\n    /**\n     * Location of the test source files.\n     *\n     * @parameter\n     */\n    private File[] testSourceDirectories = new File[] {new File(\"src/test/clojure\")};\n\n    /**\n     * Location of the generated source files.\n     *\n     * @parameter default-value=\"${project.build.outputDirectory}/../generated-sources\"\n     * @required\n     */\n    private File generatedSourceDirectory;\n\n    /**\n     * Project classpath.\n     *\n     * @parameter default-value=\"${project.compileClasspathElements}\"\n     * @required\n     * @readonly\n     */\n    private List<String> classpathElements;\n    \n    \n    /**\n     * The clojure script to preceding the switch to the repl\n     *\n     * @parameter\n     */\n    private String replScript;\n\n\tprivate static final Pattern JLINE = Pattern.compile(\"^.*/jline-[^/]+.jar$\");\n\n\tboolean isJLineAvailable(List<String> elements) {\n\t\tif(elements != null) {\n\t\t\tfor(String e: elements) {\n\t\t\t\tMatcher m = JLINE.matcher(e);\n\t\t\t\tif(m.matches()) \n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n    public void execute() throws MojoExecutionException {\n\n        List<File> dirs = new ArrayList<File>();\n        if (sourceDirectories != null) {\n            dirs.addAll(Arrays.asList(sourceDirectories));\n        }\n        if (testSourceDirectories != null) {\n            dirs.addAll(Arrays.asList(testSourceDirectories));\n        }\n        dirs.add(generatedSourceDirectory);\n\n\t\tList<String> args = new ArrayList<String>();\n\t\tString mainClass = \"clojure.main\";\n\n\t\tif (isJLineAvailable(classpathElements)) {\n\t\t\tgetLog().info(\"Enabling JLine support\");\n\t\t    args.add(\"clojure.main\");\n\t\t\tmainClass = \"jline.ConsoleRunner\";\n\t\t} \n\n        if (replScript != null && new File(replScript).exists()) {\n\t\t\targs.add(replScript);\n        }\n\n        callClojureWith(dirs.toArray(new File[]{}), outputDirectory, classpathElements, mainClass, \n\t\t\t\targs.toArray(new String[args.size()]));\n    }\n\n}\n","lineNo":98}
{"Smelly Sample":"package com.theoryinpractise.clojure;\n\nimport org.apache.maven.plugin.MojoExecutionException;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * Mojo to start a clojure repl\n * <p/>\n * (C) Copyright Tim Dysinger   (tim -on- dysinger.net)\n * Mark Derricutt (mark -on- talios.com)\n * Dimitry Gashinsky (dimitry -on- gashinsky.com)\n * Scott Fleckenstein (nullstyle -on- gmail.com)\n * <p/>\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * @goal repl\n * @execute phase=\"compile\"\n * @requiresDependencyResolution compile\n */\npublic class ClojureReplMojo extends AbstractClojureCompilerMojo {\n    /**\n     * Location of the file.\n     *\n     * @parameter default-value=\"${project.build.outputDirectory}\"\n     * @required\n     */\n    private File outputDirectory;\n\n    /**\n     * Location of the source files.\n     *\n     * @parameter\n     */\n    private File[] sourceDirectories = new File[] {new File(\"src/main/clojure\")};\n\n    /**\n     * Location of the generated source files.\n     *\n     * @parameter default-value=\"${project.build.outputDirectory}/../generated-sources\"\n     * @required\n     */\n    private File generatedSourceDirectory;\n\n    /**\n     * Project classpath.\n     *\n     * @parameter default-value=\"${project.compileClasspathElements}\"\n     * @required\n     * @readonly\n     */\n    private List<String> classpathElements;\n\n    public void execute() throws MojoExecutionException {\n\n        List<File> dirs = new ArrayList<File>();\n        if (sourceDirectories != null) {\n            dirs.addAll(Arrays.asList(sourceDirectories));\n        }\n        dirs.add(generatedSourceDirectory);\n        \n        callClojureWith(dirs.toArray(new File[]{}), outputDirectory, classpathElements, \"clojure.main\", new String[0]);\n        \n    }\n\n}\n","Method after Refactoring":"package com.theoryinpractise.clojure;\n\nimport org.apache.maven.plugin.MojoExecutionException;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * Mojo to start a clojure repl\n * <p/>\n * (C) Copyright Tim Dysinger   (tim -on- dysinger.net)\n * Mark Derricutt (mark -on- talios.com)\n * Dimitry Gashinsky (dimitry -on- gashinsky.com)\n * Scott Fleckenstein (nullstyle -on- gmail.com)\n * <p/>\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * @goal repl\n * @execute phase=\"compile\"\n * @requiresDependencyResolution compile\n */\npublic class ClojureReplMojo extends AbstractClojureCompilerMojo {\n    /**\n     * Location of the file.\n     *\n     * @parameter default-value=\"${project.build.outputDirectory}\"\n     * @required\n     */\n    private File outputDirectory;\n\n    /**\n     * Location of the source files.\n     *\n     * @parameter\n     */\n    private File[] sourceDirectories = new File[] {new File(\"src/main/clojure\")};\n\n    /**\n     * Location of the generated source files.\n     *\n     * @parameter default-value=\"${project.build.outputDirectory}/../generated-sources\"\n     * @required\n     */\n    private File generatedSourceDirectory;\n\n    /**\n     * Project classpath.\n     *\n     * @parameter default-value=\"${project.compileClasspathElements}\"\n     * @required\n     * @readonly\n     */\n    private List<String> classpathElements;\n    \n    \n    /**\n     * The clojure script to preceding the switch to the repl\n     *\n     * @parameter\n     */\n    private String replScript;\n\n    public void execute() throws MojoExecutionException {\n\n        List<File> dirs = new ArrayList<File>();\n        if (sourceDirectories != null) {\n            dirs.addAll(Arrays.asList(sourceDirectories));\n        }\n        dirs.add(generatedSourceDirectory);\n        \n        String[] args = new String[0];\n        \n        if (replScript != null && new File(replScript).exists()) {\n          args = new String[] { replScript };   \n        }\n        \n        callClojureWith(dirs.toArray(new File[]{}), outputDirectory, classpathElements, \"clojure.main\", args);\n        \n    }\n\n}\n","lineNo":73}
{"Smelly Sample":"package clojure;\n\nimport org.apache.maven.plugin.MojoExecutionException;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * Plugin for Clojure source compiling.\n * <p/>\n * (C) Copyright Tim Dysinger   (tim -on- dysinger.net)\n * Mark Derricutt (mark -on- talios.com)\n * Dimitry Gashinsky (dimitry -on- gashinsky.com)\n * <p/>\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * @goal gendoc\n * @phase package\n * @requiresDependencyResolution compile\n */\npublic class ClojureGenDocMojo extends AbstractClojureCompilerMojo {\n    /**\n     * Location of the file.\n     *\n     * @parameter default-value=\"${project.build.outputDirectory}\"\n     * @required\n     */\n    private File outputDirectory;\n\n    /**\n     * Location of the source files.\n     *\n     * @parameter default-value=\"${project.build.sourceDirectory}\"\n     * @required\n     */\n    private File baseSourceDirectory;\n\n    /**\n     * Location of the source files.\n     *\n     * @parameter\n     */\n    private File[] sourceDirectories;\n\n    /**\n     * Location of the generated source files.\n     *\n     * @parameter default-value=\"${project.build.outputDirectory}/../generated-sources\"\n     * @required\n     */\n    private File generatedSourceDirectory;\n\n    /**\n     * Project classpath.\n     *\n     * @parameter default-value=\"${project.compileClasspathElements}\"\n     * @required\n     * @readonly\n     */\n    private List<String> classpathElements;\n\n    /**\n     * Should we compile all namespaces or only those defined?\n     * @parameter defaut-value=\"false\"\n     */\n    private boolean compileDeclaredNamespaceOnly;\n\n    /**\n     * A list of namespaces to compile\n     *\n     * @parameter\n     */\n    private String[] namespaces;\n\n    public void execute() throws MojoExecutionException {\n        List<File> dirs = new ArrayList<File>();\n        dirs.add(baseSourceDirectory);\n        if (sourceDirectories != null) {\n            dirs.addAll(Arrays.asList(sourceDirectories));\n        }\n        dirs.add(generatedSourceDirectory);\n\n        File genDocClj;\n        File docsDir;\n        try {\n            genDocClj = File.createTempFile(\"generate-docs\", \".clj\");\n            docsDir = new File(outputDirectory.getPath(), \"../clojure\");\n            docsDir.mkdir();\n        } catch (IOException e) {\n            throw new MojoExecutionException(e.getMessage());\n        }\n\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"(use 'clojure.contrib.gen-html-docs)\\n\");\n        sb.append(\"(generate-documentation-to-file \\n\");\n        int count = 0;\n        sb.append(\"  \\\"\").append(docsDir.getPath()).append(\"/index.html\\\"\\n\");\n        sb.append(\"  [\");\n\n        for (String namespace : new NamespaceDiscovery(getLog(), compileDeclaredNamespaceOnly).discoverNamespacesIn(namespaces, dirs.toArray(new File[] {}))) {\n            sb.append(\"   '\").append(namespace);\n            if (count++ < namespaces.length) {\n                sb.append(\"\\n   \");\n            }\n        }\n        sb.append(\"])\\n\");\n        try {\n            final PrintWriter pw = new PrintWriter(genDocClj);\n            pw.print(sb.toString());\n            pw.close();\n            getLog().info(\"Generating docs to \" + docsDir.getCanonicalPath() + \" with \" + genDocClj.getPath());\n        } catch (IOException e) {\n            throw new MojoExecutionException(e.getMessage());\n        }\n\n        callClojureWith(dirs.toArray(new File[]{}), outputDirectory, classpathElements, \"clojure.main\", new String[]{genDocClj.getPath()});\n    }\n\n}\n","Method after Refactoring":"package clojure;\n\nimport org.apache.maven.plugin.MojoExecutionException;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * Plugin for Clojure source compiling.\n * <p/>\n * (C) Copyright Tim Dysinger   (tim -on- dysinger.net)\n * Mark Derricutt (mark -on- talios.com)\n * Dimitry Gashinsky (dimitry -on- gashinsky.com)\n * <p/>\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * @goal gendoc\n * @phase package\n * @requiresDependencyResolution test\n */\npublic class ClojureGenDocMojo extends AbstractClojureCompilerMojo {\n    /**\n     * Location of the file.\n     *\n     * @parameter default-value=\"${project.build.outputDirectory}\"\n     * @required\n     */\n    private File outputDirectory;\n\n    /**\n     * Location of the source files.\n     *\n     * @parameter default-value=\"${project.build.sourceDirectory}\"\n     * @required\n     */\n    private File baseSourceDirectory;\n\n    /**\n     * Location of the source files.\n     *\n     * @parameter\n     */\n    private File[] sourceDirectories;\n\n    /**\n     * Location of the source files.\n     *\n     * @parameter default-value=\"${project.build.testSourceDirectory}\"\n     * @required\n     */\n    private File baseTestSourceDirectory;\n\n    /**\n     * Location of the source files.\n     *\n     * @parameter\n     */\n    private File[] testSourceDirectories;\n\n    /**\n     * Location of the generated source files.\n     *\n     * @parameter default-value=\"${project.build.outputDirectory}/../generated-sources\"\n     * @required\n     */\n    private File generatedSourceDirectory;\n\n    /**\n     * Project classpath.\n     *\n     * @parameter default-value=\"${project.compileClasspathElements}\"\n     * @required\n     * @readonly\n     */\n    private List<String> classpathElements;\n\n    /**\n     * Should we compile all namespaces or only those defined?\n     *\n     * @parameter defaut-value=\"false\"\n     */\n    private boolean compileDeclaredNamespaceOnly;\n\n    /**\n     * Should we compile all namespaces or only those defined?\n     *\n     * @parameter defaut-value=\"false\"\n     */\n    private boolean generateTestDocumentation;\n\n    /**\n     * A list of namespaces to compile\n     *\n     * @parameter\n     */\n    private String[] namespaces;\n\n    public void execute() throws MojoExecutionException {\n        List<File> dirs = new ArrayList<File>();\n        dirs.add(baseSourceDirectory);\n\n        if (sourceDirectories != null) {\n            dirs.addAll(Arrays.asList(sourceDirectories));\n        }\n\n        if (generateTestDocumentation) {\n            dirs.add(baseTestSourceDirectory);\n            if (testSourceDirectories != null) {\n                dirs.addAll(Arrays.asList(testSourceDirectories));\n            }\n        }\n\n        dirs.add(generatedSourceDirectory);\n\n        File genDocClj;\n        File docsDir;\n        try {\n            genDocClj = File.createTempFile(\"generate-docs\", \".clj\");\n            if (!outputDirectory.getParentFile().exists()) {\n                outputDirectory.getParentFile().mkdir();\n            }\n            docsDir = new File(outputDirectory.getParentFile(), \"clojure\");\n            getLog().debug(\"Creating documentation directory \" + docsDir.getPath());\n            docsDir.mkdir();\n            System.out.println(docsDir.getPath() + \" exists \" + docsDir.exists());\n        } catch (IOException e) {\n            throw new MojoExecutionException(e.getMessage());\n        }\n\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"(use 'clojure.contrib.gen-html-docs)\\n\");\n        sb.append(\"(generate-documentation-to-file \\n\");\n        int count = 0;\n        sb.append(\"  \\\"\").append(docsDir.getPath()).append(\"/index.html\\\"\\n\");\n        sb.append(\"  [\");\n\n        final String[] allNamespaces = new NamespaceDiscovery(getLog(), compileDeclaredNamespaceOnly).discoverNamespacesIn(namespaces, dirs.toArray(new File[]{}));\n        for (String namespace : allNamespaces) {\n            sb.append(\"'\").append(namespace);\n            if (count++ < allNamespaces.length - 1) {\n                sb.append(\"\\n   \");\n            }\n        }\n        sb.append(\"])\\n\");\n        try {\n            final PrintWriter pw = new PrintWriter(genDocClj);\n            pw.print(sb.toString());\n            pw.close();\n            getLog().info(\"Generating docs to \" + docsDir.getCanonicalPath() + \" with \" + genDocClj.getPath());\n            getLog().debug(sb.toString());\n        } catch (IOException e) {\n            throw new MojoExecutionException(e.getMessage());\n        }\n\n        callClojureWith(dirs.toArray(new File[]{}), outputDirectory, classpathElements, \"clojure.main\", new String[]{genDocClj.getPath()});\n    }\n\n}\n","lineNo":141}
{"Smelly Sample":"package clojure;\n\nimport org.apache.maven.plugin.MojoExecutionException;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * Plugin for Clojure source compiling.\n * <p/>\n * (C) Copyright Tim Dysinger   (tim -on- dysinger.net)\n * Mark Derricutt (mark -on- talios.com)\n * Dimitry Gashinsky (dimitry -on- gashinsky.com)\n * <p/>\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * @goal testCompile\n * @phase test-compile\n * @requiresDependencyResolution test\n */\npublic class TestClojureCompilerMojo extends AbstractClojureCompilerMojo {\n\n    /**\n     * Location of the file.\n     *\n     * @parameter expression=\"${project.build.testOutputDirectory}\"\n     * @required\n     */\n    private File outputDirectory;\n\n    /**\n     * Flag to allow test compiliation to be skipped.\n     *\n     * @parameter expression=\"${maven.test.skip}\" default-value=\"false\"\n     * @noinspection UnusedDeclaration\n     */\n    private boolean skip;\n\n    /**\n     * Location of the source files.\n     *\n     * @parameter default-value=\"${project.build.testSourceDirectory}\"\n     * @required\n     */\n    private File baseTestSourceDirectory;\n\n    /**\n     * Location of the source files.\n     *\n     * @parameter\n     */\n    private File[] testSourceDirectories;\n\n    /**\n     * Project classpath.\n     *\n     * @parameter expression=\"${project.testClasspathElements}\"\n     * @required\n     * @readonly\n     */\n    private List classpathElements;\n\n    /**\n     * A list of namespaces to compile\n     *\n     * @parameter\n     */\n    private String[] namespaces;\n\n    public void execute() throws MojoExecutionException {\n        if (skip) {\n            getLog().info(\"Test compiliation is skipped\");\n        } else {\n            List<File> dirs = new ArrayList<File>();\n            if (baseTestSourceDirectory != null) {\n                dirs.add(baseTestSourceDirectory);\n            }\n            dirs.addAll(Arrays.asList(testSourceDirectories));\n\n            callClojureWith(dirs.toArray(new File[]{}), outputDirectory, classpathElements, \"clojure.lang.Compile\", namespaces);\n        }\n    }\n\n}\n","Method after Refactoring":"package clojure;\n\nimport org.apache.maven.plugin.MojoExecutionException;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * Plugin for Clojure source compiling.\n * <p/>\n * (C) Copyright Tim Dysinger   (tim -on- dysinger.net)\n * Mark Derricutt (mark -on- talios.com)\n * Dimitry Gashinsky (dimitry -on- gashinsky.com)\n * <p/>\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * @goal testCompile\n * @phase test-compile\n * @requiresDependencyResolution test\n */\npublic class TestClojureCompilerMojo extends AbstractClojureCompilerMojo {\n\n    /**\n     * Location of the file.\n     *\n     * @parameter expression=\"${project.build.testOutputDirectory}\"\n     * @required\n     */\n    private File outputDirectory;\n\n    /**\n     * Flag to allow test compiliation to be skipped.\n     *\n     * @parameter expression=\"${maven.test.skip}\" default-value=\"false\"\n     * @noinspection UnusedDeclaration\n     */\n    private boolean skip;\n\n    /**\n     * Location of the source files.\n     *\n     * @parameter default-value=\"${project.build.testSourceDirectory}\"\n     * @required\n     */\n    private File baseTestSourceDirectory;\n\n    /**\n     * Location of the source files.\n     *\n     * @parameter\n     */\n    private File[] testSourceDirectories;\n\n    /**\n     * Project classpath.\n     *\n     * @parameter expression=\"${project.testClasspathElements}\"\n     * @required\n     * @readonly\n     */\n    private List classpathElements;\n\n    /**\n     * A list of namespaces to compile\n     *\n     * @parameter\n     */\n    private String[] namespaces;\n\n    public void execute() throws MojoExecutionException {\n        if (skip) {\n            getLog().info(\"Test compiliation is skipped\");\n        } else {\n            List<File> dirs = new ArrayList<File>();\n            if (baseTestSourceDirectory != null) {\n                dirs.add(baseTestSourceDirectory);\n            }\n            dirs.addAll(Arrays.asList(testSourceDirectories));\n\n            final File[] allSourceDirectories = dirs.toArray(new File[]{});\n            callClojureWith(allSourceDirectories, outputDirectory, classpathElements, \"clojure.lang.Compile\",\n                    new NamespaceDiscovery(getLog()).discoverNamespacesIn(namespaces, allSourceDirectories));\n        }\n    }\n\n}\n","lineNo":82}
{"Smelly Sample":"package com.theoryinpractice.clojure;\n\n/*\n * Copyright 2001-2005 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\n\nimport java.io.*;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Enumeration;\nimport java.util.List;\n\n/**\n * Goal which touches a timestamp file.\n *\n * @goal compile\n * @phase compile\n */\npublic class ClojureCompilerMojo extends AbstractMojo {\n\n    /**\n     * Location of the file.\n     *\n     * @parameter expression=\"${project.build.directory}/classes\"\n     * @required\n     */\n    private File outputDirectory;\n\n    /**\n     * Location of the source files.\n     *\n     * @parameter expression=\"src/main/clojure\"\n     * @required\n     */\n    private File srcDirectory;\n\n    /**\n     * A list of namespaces to compile\n     *\n     * @parameter\n     */\n    private String[] namespaces;\n\n    public void execute() throws MojoExecutionException {\n\n        outputDirectory.mkdirs();\n\n        Enumeration<URL> path = null;\n        try {\n            path = Thread.currentThread().getContextClassLoader().getResources(\"clojure\");\n        } catch (IOException e) {\n            throw new MojoExecutionException(e.getMessage());\n        }\n        String cp = srcDirectory.getPath() + File.pathSeparator + outputDirectory.getPath();\n\n        while (path.hasMoreElements()) {\n            URL url = path.nextElement();\n\n            getLog().debug(url.getPath());\n            if (\"jar\".equals(url.getProtocol())) {\n                cp = cp + File.pathSeparator + url.getPath().replaceFirst(\"file:\", \"\").replaceFirst(\"jar.*\", \"jar\");\n            }\n        }\n\n        List<String> args = new ArrayList<String>();\n        args.add(\"java\");\n        args.add(\"-cp\");\n        args.add(cp);\n        args.add(\"-Dclojure.compile.path=\" + outputDirectory.getPath() + \"\");\n        args.add(\"clojure.lang.Compile\");\n        for (String namespace : namespaces) {\n            args.add(namespace);\n        }\n\n        ProcessBuilder pb = new ProcessBuilder(args);\n        pb.environment().put(\"path\", \";\");\n        pb.environment().put(\"path\", System.getProperty(\"java.home\"));\n\n        pb.redirectErrorStream(true);\n        try {\n            writeProcessOutput(pb.start());\n        } catch (IOException e) {\n            throw new MojoExecutionException(e.getMessage());\n        }\n\n    }\n\n    public void writeProcessOutput(Process process) throws IOException {\n        InputStreamReader tempReader = new InputStreamReader(new BufferedInputStream(process.getInputStream()));\n        BufferedReader reader = new BufferedReader(tempReader);\n        while (true) {\n            String line = reader.readLine();\n            if (line == null)\n                break;\n            getLog().info(line);\n        }\n    }\n\n}\n","Method after Refactoring":"package com.theoryinpractice.clojure;\n\n/*\n * Copyright 2001-2005 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\n\nimport java.io.*;\nimport java.net.URL;\nimport java.util.*;\n\n/**\n * Goal which touches a timestamp file.\n *\n * @goal compile\n * @phase compile\n */\npublic class ClojureCompilerMojo extends AbstractMojo {\n\n    /**\n     * Location of the file.\n     *\n     * @parameter expression=\"${project.build.directory}/classes\"\n     * @required\n     */\n    private File outputDirectory;\n\n    /**\n     * Location of the source files.\n     *\n     * @parameter expression=\"src/main/clojure\"\n     * @required\n     */\n    private File srcDirectory;\n\n    /**\n     * Project classpath.\n     *\n     * @parameter expression=\"${project.compileClasspathElements}\"\n     * @required\n     * @readonly\n     */\n    private List classpathElements;\n\n    /**\n     * A list of namespaces to compile\n     *\n     * @parameter\n     */\n    private String[] namespaces;\n\n    public void execute() throws MojoExecutionException {\n\n        outputDirectory.mkdirs();\n\n        String cp = srcDirectory.getPath() + File.pathSeparator + outputDirectory.getPath();\n        for (String jarResource : findJarsForPackages(\"clojure\")) {\n            cp = cp + File.pathSeparator + jarResource;\n        }\n\n        for (Object classpathElement : classpathElements) {\n            cp = cp + File.pathSeparator + classpathElement;\n        }\n\n        getLog().info(\"Compiling clojure sources with classpath: \" + cp.toString());\n\n        List<String> args = new ArrayList<String>();\n        args.add(\"java\");\n        args.add(\"-cp\");\n        args.add(cp);\n        args.add(\"-Dclojure.compile.path=\" + outputDirectory.getPath() + \"\");\n        args.add(\"clojure.lang.Compile\");\n        for (String namespace : namespaces) {\n            args.add(namespace);\n        }\n\n        ProcessBuilder pb = new ProcessBuilder(args);\n        pb.environment().put(\"path\", \";\");\n        pb.environment().put(\"path\", System.getProperty(\"java.home\"));\n\n        pb.redirectErrorStream(true);\n        try {\n            Process process = pb.start();\n            new OutputHandlder(process, getLog()).start();\n\n            int status;\n            try {\n                status = process.waitFor();\n            } catch (InterruptedException e) {\n                status = process.exitValue();\n            }\n\n            if (status != 0) {\n                throw new MojoExecutionException(\"Clojure compilation failed.\");\n            }\n\n\n        } catch (IOException e) {\n            throw new MojoExecutionException(e.getMessage());\n        }\n\n    }\n\n    private Set<String> findJarsForPackages(String packageName) throws MojoExecutionException {\n        Set<String> jarResources = new HashSet<String>();\n        Enumeration<URL> path = null;\n        try {\n\n            path = Thread.currentThread().getContextClassLoader().getResources(packageName.replaceAll(\"\\\\.\",\"/\"));\n        } catch (IOException e) {\n            throw new MojoExecutionException(e.getMessage());\n        }\n\n        while (path.hasMoreElements()) {\n            URL url = path.nextElement();\n\n            getLog().debug(url.getPath());\n            if (\"jar\".equals(url.getProtocol())) {\n                jarResources.add(url.getPath().replaceFirst(\"file:\", \"\").replaceFirst(\"jar.*\", \"jar\"));\n            }\n        }\n        return jarResources;\n    }\n\n\n}\n","lineNo":97}
{"Smelly Sample":"package com.theoryinpractice.clojure;\n\n/*\n * Copyright 2001-2005 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\n\nimport java.io.*;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Enumeration;\nimport java.util.List;\n\n/**\n * Goal which runs the clojure repl.\n *\n * @goal repl\n */\npublic class ClojureReplMojo extends AbstractMojo {\n\n    /**\n     * Location of the file.\n     *\n     * @parameter expression=\"${project.build.directory}/classes\"\n     * @required\n     */\n    private File outputDirectory;\n\n    /**\n     * Location of the source files.\n     *\n     * @parameter expression=\"src/main/clojure\"\n     * @required\n     */\n    private File srcDirectory;\n\n    /**\n     * A list of namespaces to compile\n     *\n     * @parameter\n     */\n    private String[] namespaces;\n\n    public void execute() throws MojoExecutionException {\n\n        outputDirectory.mkdirs();\n\n        Enumeration<URL> path = null;\n        try {\n            path = Thread.currentThread().getContextClassLoader().getResources(\"clojure\");\n        } catch (IOException e) {\n            throw new MojoExecutionException(e.getMessage());\n        }\n        String cp = srcDirectory.getPath() + File.pathSeparator + outputDirectory.getPath();\n\n        while (path.hasMoreElements()) {\n            URL url = path.nextElement();\n\n            getLog().debug(url.getPath());\n            if (\"jar\".equals(url.getProtocol())) {\n                cp = cp + File.pathSeparator + url.getPath().replaceFirst(\"file:\", \"\").replaceFirst(\"jar.*\", \"jar\");\n            }\n        }\n\n        List<String> args = new ArrayList<String>();\n        args.add(\"java\");\n        args.add(\"-cp\");\n        args.add(cp);\n        args.add(\"clojure.lang.Repl\");\n\n        ProcessBuilder pb = new ProcessBuilder(args);\n        pb.environment().put(\"path\", \";\");\n        pb.environment().put(\"path\", System.getProperty(\"java.home\"));\n\n        pb.redirectErrorStream(true);\n        try {\n            writeProcessOutput(pb.start());\n        } catch (IOException e) {\n            throw new MojoExecutionException(e.getMessage());\n        }\n\n    }\n\n    public void writeProcessOutput(Process process) throws IOException {\n        InputStreamReader tempReader = new InputStreamReader(new BufferedInputStream(process.getInputStream()));\n        BufferedReader reader = new BufferedReader(tempReader);\n        while (true) {\n            String line = reader.readLine();\n            if (line == null)\n                break;\n            getLog().info(line);\n        }\n    }\n\n}\n","Method after Refactoring":"package com.theoryinpractice.clojure;\n\n/*\n * Copyright 2001-2005 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\n\nimport java.io.*;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Enumeration;\nimport java.util.List;\n\n/**\n * Goal which runs the clojure repl.\n *\n * @goal repl\n */\npublic class ClojureReplMojo extends AbstractMojo {\n\n    /**\n     * Location of the file.\n     *\n     * @parameter expression=\"${project.build.directory}/classes\"\n     * @required\n     */\n    private File outputDirectory;\n\n    /**\n     * Location of the source files.\n     *\n     * @parameter expression=\"src/main/clojure\"\n     * @required\n     */\n    private File srcDirectory;\n\n    /**\n     * A list of namespaces to compile\n     *\n     * @parameter\n     */\n    private String[] namespaces;\n\n    public void execute() throws MojoExecutionException {\n\n        outputDirectory.mkdirs();\n\n        Enumeration<URL> path = null;\n        try {\n            path = Thread.currentThread().getContextClassLoader().getResources(\"clojure\");\n        } catch (IOException e) {\n            throw new MojoExecutionException(e.getMessage());\n        }\n        String cp = srcDirectory.getPath() + File.pathSeparator + outputDirectory.getPath();\n\n        while (path.hasMoreElements()) {\n            URL url = path.nextElement();\n\n            getLog().debug(url.getPath());\n            if (\"jar\".equals(url.getProtocol())) {\n                cp = cp + File.pathSeparator + url.getPath().replaceFirst(\"file:\", \"\").replaceFirst(\"jar.*\", \"jar\");\n            }\n        }\n\n        List<String> args = new ArrayList<String>();\n        args.add(\"java\");\n        args.add(\"-cp\");\n        args.add(cp);\n        args.add(\"clojure.lang.Repl\");\n\n        ProcessBuilder pb = new ProcessBuilder(args);\n        pb.environment().put(\"path\", \";\");\n        pb.environment().put(\"path\", System.getProperty(\"java.home\"));\n\n        pb.redirectErrorStream(true);\n        try {\n            final Process process = pb.start();\n            new OutputHandlder(process, getLog()).start();\n\n            new Thread() {\n                @Override\n                public void run() {\n                    try {\n                        InputStreamReader tempReader = new InputStreamReader(new BufferedInputStream(System.in));\n                        while (true) {\n                            int line = tempReader.read();\n                            if (line == -1)\n                                break;\n                            process.getOutputStream().write(line);\n//                            process.getOutputStream().write('\\n');\n                        }\n                    } catch (IOException e) {\n                        e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.\n                    }\n\n\n                }\n            }.start();\n\n\n            int status;\n            try {\n                status = process.waitFor();\n            } catch (InterruptedException e) {\n                status = process.exitValue();\n            }\n\n            if (status != 0) {\n                throw new MojoExecutionException(\"Repl failed.\");\n            }\n\n\n        } catch (IOException e) {\n            throw new MojoExecutionException(e.getMessage());\n        }\n\n    }\n\n}\n","lineNo":91}
