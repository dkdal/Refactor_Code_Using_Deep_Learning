{"Smelly Sample":"/*\n * Copyright 2008 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.constretto.internal;\n\nimport com.thoughtworks.paranamer.BytecodeReadingParanamer;\nimport com.thoughtworks.paranamer.Paranamer;\nimport org.constretto.ConfigurationDefaultValueFactory;\nimport org.constretto.ConstrettoConfiguration;\nimport org.constretto.GenericConverter;\nimport org.constretto.Property;\nimport org.constretto.annotation.Configuration;\nimport org.constretto.annotation.Configure;\nimport org.constretto.annotation.Tags;\nimport org.constretto.exception.ConstrettoConversionException;\nimport org.constretto.exception.ConstrettoException;\nimport org.constretto.exception.ConstrettoExpressionException;\nimport org.constretto.internal.converter.ValueConverterRegistry;\nimport org.constretto.model.CPrimitive;\nimport org.constretto.model.CValue;\nimport org.constretto.model.ConfigurationValue;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.ref.WeakReference;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.*;\nimport java.util.concurrent.CopyOnWriteArraySet;\n\nimport static java.util.Arrays.asList;\nimport static org.constretto.internal.GenericCollectionTypeResolver.*;\n\n/**\n * @author <a href=\"mailto:kaare.nilsen@gmail.com\">Kaare Nilsen<\/a>\n */\npublic class DefaultConstrettoConfiguration implements ConstrettoConfiguration {\n    private static final String NULL_STRING = \"![![Null]!]!\";\n\n    private final Paranamer paranamer = new BytecodeReadingParanamer();\n\n    protected final Map<String, List<ConfigurationValue>> configuration;\n    private Set<WeakReference<Object>> configuredObjects = new CopyOnWriteArraySet<WeakReference<Object>>();\n    private final List<String> originalTags = new ArrayList<String>();\n    protected final List<String> currentTags = new ArrayList<String>();\n\n    public DefaultConstrettoConfiguration(Map<String, List<ConfigurationValue>> configuration, List<String> originalTags) {\n        this.configuration = configuration;\n        this.originalTags.addAll(originalTags);\n        this.currentTags.addAll(originalTags);\n    }\n\n    public DefaultConstrettoConfiguration(Map<String, List<ConfigurationValue>> configuration) {\n        this.configuration = configuration;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public <K> K evaluateTo(String expression, K defaultValue) {\n        if (!hasValue(expression)) {\n            return defaultValue;\n        }\n        K value;\n        try {\n            value = (K) processAndConvert(defaultValue.getClass(), expression);\n        } catch (ConstrettoConversionException e) {\n            value = null;\n        }\n        return null != value ? value : defaultValue;\n    }\n\n    public <T> T evaluateWith(GenericConverter<T> converter, String expression) {\n        ConfigurationValue value = findElementOrThrowException(expression);\n        return converter.fromValue(value.value());\n    }\n\n    public CValue evaluate(String expression) throws ConstrettoExpressionException {\n        return findElementOrThrowException(expression).value();\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public <K> List<K> evaluateToList(Class<K> targetClass, String expression) {\n        ConfigurationValue value = findElementOrThrowException(expression);\n        return (List<K>) ValueConverterRegistry.convert(targetClass, targetClass, value.value());\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public <K, V> Map<K, V> evaluateToMap(Class<K> keyClass, Class<V> valueClass, String expression) {\n        ConfigurationValue value = findElementOrThrowException(expression);\n        return (Map<K, V>) ValueConverterRegistry.convert(valueClass, keyClass, value.value());\n    }\n\n    public <K> K evaluateTo(Class<K> targetClass, String expression) throws ConstrettoExpressionException {\n        return processAndConvert(targetClass, expression);\n    }\n\n    public String evaluateToString(String expression) throws ConstrettoExpressionException {\n        return processAndConvert(String.class, expression);\n    }\n\n    public Boolean evaluateToBoolean(String expression) throws ConstrettoExpressionException {\n        return processAndConvert(Boolean.class, expression);\n    }\n\n    public Double evaluateToDouble(String expression) throws ConstrettoExpressionException {\n        return processAndConvert(Double.class, expression);\n    }\n\n    public Long evaluateToLong(String expression) throws ConstrettoExpressionException {\n        return processAndConvert(Long.class, expression);\n    }\n\n    public Float evaluateToFloat(String expression) throws ConstrettoExpressionException {\n        return processAndConvert(Float.class, expression);\n    }\n\n    public Integer evaluateToInt(String expression) throws ConstrettoExpressionException {\n        return processAndConvert(Integer.class, expression);\n    }\n\n    public Short evaluateToShort(String expression) throws ConstrettoExpressionException {\n        return processAndConvert(Short.class, expression);\n    }\n\n    public Byte evaluateToByte(String expression) throws ConstrettoExpressionException {\n        return processAndConvert(Byte.class, expression);\n    }\n\n    public <T> T as(Class<T> configurationClass) throws ConstrettoException {\n        T objectToConfigure;\n        try {\n            objectToConfigure = configurationClass.newInstance();\n        } catch (Exception e) {\n            throw new ConstrettoException(\"Could not instansiate class of type: \" + configurationClass.getName()\n                    + \" when trying to inject it with configuration, It may be missing a default constructor\", e);\n        }\n        injectConfiguration(objectToConfigure);\n        return objectToConfigure;\n    }\n\n    public <T> T on(T objectToConfigure) throws ConstrettoException {\n        injectConfiguration(objectToConfigure);\n        return objectToConfigure;\n    }\n\n    public boolean hasValue(String expression) {\n        return findElementOrNull(expression) != null;\n    }\n\n    public void appendTag(String... newtags) {\n        currentTags.addAll(asList(newtags));\n        reconfigure();\n    }\n\n    public void prependTag(String... newtags) {\n        currentTags.addAll(0, asList(newtags));\n        reconfigure();\n    }\n\n    public void resetTags(boolean reconfigure) {\n        currentTags.clear();\n        currentTags.addAll(originalTags);\n        if (reconfigure)\n            reconfigure();\n    }\n\n    public void clearTags(boolean reconfigure) {\n        currentTags.clear();\n        originalTags.clear();\n        if (reconfigure)\n            reconfigure();\n    }\n\n    public void removeTag(String... newTags) {\n        for (String newTag : newTags) {\n            currentTags.remove(newTag);\n        }\n        reconfigure();\n    }\n\n    public List<String> getCurrentTags() {\n        return currentTags;\n    }\n\n    public Iterator<Property> iterator() {\n        List<Property> properties = new ArrayList<Property>();\n        Map<String, String> map = asMap();\n        for (Map.Entry<String, String> entry : map.entrySet()) {\n            properties.add(new Property(entry.getKey(), entry.getValue()));\n        }\n        return properties.iterator();\n    }\n\n    @Override\n    public void reconfigure() {\n        WeakReference[] references = configuredObjects.toArray(new WeakReference[configuredObjects.size()]);\n        for (WeakReference reference : references) {\n            if (reference != null && reference.get() != null) {\n                on(reference.get());\n            }\n        }\n    }\n\n    //\n    // Helper methods\n    //\n    private Map<String, String> asMap() {\n        Map<String, String> properties = new HashMap<String, String>();\n        for (Map.Entry<String, List<ConfigurationValue>> entry : configuration.entrySet()) {\n            ConfigurationValue value = findElementOrNull(entry.getKey());\n            if (value != null){\n                properties.put(entry.getKey(), value.value().toString());\n            }\n        }\n        return properties;\n    }\n\n    protected ConfigurationValue findElementOrThrowException(String expression) {\n        if (!configuration.containsKey(expression)) {\n            throw new ConstrettoExpressionException(expression, currentTags);\n        }\n        List<ConfigurationValue> values = configuration.get(expression);\n        ConfigurationValue resolvedNode = resolveMatch(values);\n        if (resolvedNode == null) {\n            throw new ConstrettoExpressionException(expression, currentTags);\n        }\n        if (resolvedNode.value().containsVariables()) {\n            for (String key : resolvedNode.value().referencedKeys()) {\n                resolvedNode.value().replace(key, evaluateToString(key));\n            }\n        }\n        return resolvedNode;\n    }\n\n\n    protected ConfigurationValue findElementOrNull(String expression) {\n        if (!configuration.containsKey(expression)) {\n            return null;\n        }\n        List<ConfigurationValue> values = configuration.get(expression);\n        ConfigurationValue resolvedNode = resolveMatch(values);\n        if (resolvedNode == null) {\n            return null;\n        }\n        if (resolvedNode.value().containsVariables()) {\n            for (String key : resolvedNode.value().referencedKeys()) {\n                resolvedNode.value().replace(key, evaluateToString(key));\n            }\n        }\n        return resolvedNode;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private <T> T processAndConvert(Class<T> clazz, String expression) throws ConstrettoException {\n        ConfigurationValue value = findElementOrThrowException(expression);\n        return (T) ValueConverterRegistry.convert(clazz, clazz, value.value());\n    }\n\n    private ConfigurationValue resolveMatch(List<ConfigurationValue> values) {\n        ConfigurationValue bestMatch = null;\n        for (ConfigurationValue configurationNode : values) {\n            if (ConfigurationValue.DEFAULT_TAG.equals(configurationNode.tag())) {\n                if (bestMatch == null || bestMatch.tag().equals(ConfigurationValue.DEFAULT_TAG)) {\n                    bestMatch = configurationNode;\n                }\n            } else if (currentTags.contains(configurationNode.tag())) {\n                if (bestMatch == null) {\n                    bestMatch = configurationNode;\n                } else {\n                    int previousFoundPriority =\n                            ConfigurationValue.DEFAULT_TAG.equals(bestMatch.tag()) ?\n                                    Integer.MAX_VALUE : currentTags.indexOf(bestMatch.tag());\n                    if (currentTags.indexOf(configurationNode.tag()) <= previousFoundPriority) {\n                        bestMatch = configurationNode;\n                    }\n                }\n            } else if (ConfigurationValue.ALL_TAG.equals(configurationNode.tag())) {\n                bestMatch = configurationNode;\n            }\n        }\n        return bestMatch;\n    }\n\n    private <T> void injectConfiguration(T objectToConfigure) {\n        injectFields(objectToConfigure);\n        injectMethods(objectToConfigure);\n        boolean found = false;\n        for (WeakReference<Object> configuredObject : configuredObjects) {\n            if (configuredObject.get() == objectToConfigure) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            this.configuredObjects.add(new WeakReference<Object>(objectToConfigure));\n        }\n    }\n\n    private <T> void injectMethods(T objectToConfigure) {\n        Method[] methods = objectToConfigure.getClass().getMethods();\n        for (Method method : methods) {\n            try {\n                if (method.isAnnotationPresent(Configure.class)) {\n                    Annotation[][] methodAnnotations = method.getParameterAnnotations();\n                    String[] parameterNames = paranamer.lookupParameterNames(method);\n                    Object[] resolvedArguments = new Object[methodAnnotations.length];\n                    int i = 0;\n                    for (Annotation[] parameterAnnotations : methodAnnotations) {\n                        Object defaultValue = null;\n                        boolean required = true;\n                        String expression = \"\";\n                        Class<?> parameterTargetClass = method.getParameterTypes()[i];\n                        if (parameterAnnotations.length != 0) {\n                            for (Annotation parameterAnnotation : parameterAnnotations) {\n                                if (parameterAnnotation.annotationType() == Configuration.class) {\n                                    Configuration configurationAnnotation = (Configuration) parameterAnnotation;\n                                    expression = configurationAnnotation.value();\n                                    required = configurationAnnotation.required();\n                                    if (hasAnnotationDefaults(configurationAnnotation)) {\n                                        if (configurationAnnotation.defaultValueFactory().equals(Configuration.EmptyValueFactory.class)) {\n                                            defaultValue = ValueConverterRegistry.convert(parameterTargetClass, parameterTargetClass, new CPrimitive(configurationAnnotation.defaultValue()));\n                                        } else {\n                                            ConfigurationDefaultValueFactory valueFactory = configurationAnnotation.defaultValueFactory().newInstance();\n                                            defaultValue = valueFactory.getDefaultValue();\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        if (expression.equals(\"\")) {\n                            if (parameterNames == null) {\n                                throw new ConstrettoException(\"Could not resolve the expression of the property to look up. \" +\n                                        \"The cause of this could be that the class is compiled without debug enabled. \" +\n                                        \"when a class is compiled without debug, the @Configuration with a value attribute is required \" +\n                                        \"to correctly resolve the property expression.\");\n                            } else {\n                                expression = parameterNames[i];\n                            }\n                        }\n                        if (hasValue(expression)) {\n                            if (parameterTargetClass.isAssignableFrom(List.class)) {\n                                Class<?> collectionParameterType = getCollectionParameterType(new MethodParameter(method, i));\n                                resolvedArguments[i] = evaluateToList(collectionParameterType, expression);\n                            } else if (parameterTargetClass.isAssignableFrom(Map.class)) {\n                                Class<?> mapKeyType = getMapKeyParameterType(new MethodParameter(method, i));\n                                Class<?> mapValueType = getMapValueParameterType(new MethodParameter(method, i));\n                                resolvedArguments[i] = evaluateToMap(mapKeyType, mapValueType, expression);\n                            } else {\n                                resolvedArguments[i] = processAndConvert(parameterTargetClass, expression);\n                            }\n\n                        } else {\n                            if (defaultValue != null || !required) {\n                                resolvedArguments[i] = defaultValue;\n                            } else {\n                                throw new ConstrettoException(\"Missing value or default value for expression [\" + expression + \"], in method [\" + method.getName() + \"], in class [\" + objectToConfigure.getClass().getName() + \"], with tags \" + currentTags + \".\");\n                            }\n                        }\n\n                        i++;\n                    }\n\n                    method.setAccessible(true);\n                    method.invoke(objectToConfigure, resolvedArguments);\n\n                }\n            } catch (IllegalAccessException e) {\n                throw new ConstrettoException(\"Cold not invoke method [\"\n                        + method.getName() + \"] annotated with @Configured,\", e);\n            } catch (InvocationTargetException e) {\n                throw new ConstrettoException(\"Cold not invoke method [\"\n                        + method.getName() + \"] annotated with @Configured,\", e);\n            } catch (InstantiationException e) {\n                throw new ConstrettoException(\"Cold not invoke method [\"\n                        + method.getName() + \"] annotated with @Configured,\", e);\n            }\n        }\n    }\n\n    private <T> void injectFields(T objectToConfigure) {\n\n        Class objectToConfigureClass = objectToConfigure.getClass();\n\n        do {\n            Field[] fields = objectToConfigureClass.getDeclaredFields();\n            for (Field field : fields) {\n                try {\n                    if (field.isAnnotationPresent(Configuration.class)) {\n                        Configuration configurationAnnotation = field.getAnnotation(Configuration.class);\n                        String expression = \"\".equals(configurationAnnotation.value()) ? field.getName() : configurationAnnotation.value();\n                        field.setAccessible(true);\n                        Class<?> fieldType = field.getType();\n                        if (hasValue(expression)) {\n                            ConfigurationValue node = findElementOrThrowException(expression);\n                            if (fieldType.isAssignableFrom(List.class)) {\n                                field.set(objectToConfigure, evaluateToList(getCollectionFieldType(field), expression));\n                            } else if (fieldType.isAssignableFrom(Map.class)) {\n                                field.set(objectToConfigure, evaluateToMap(getMapKeyFieldType(field), getMapValueFieldType(field), expression));\n                            } else {\n                                field.set(objectToConfigure, processAndConvert(fieldType, expression));\n                            }\n                        } else {\n                            if (hasAnnotationDefaults(configurationAnnotation)) {\n                                if (configurationAnnotation.defaultValueFactory().equals(Configuration.EmptyValueFactory.class)) {\n                                    field.set(objectToConfigure, ValueConverterRegistry.convert(fieldType, fieldType, new CPrimitive(configurationAnnotation.defaultValue())));\n                                } else {\n                                    ConfigurationDefaultValueFactory valueFactory = configurationAnnotation.defaultValueFactory().newInstance();\n                                    field.set(objectToConfigure, valueFactory.getDefaultValue());\n                                }\n                            } else if (configurationAnnotation.required()) {\n                                throw new ConstrettoException(\"Missing value or default value for expression [\" + expression + \"] for field [\" + field.getName() + \"], in class [\" + objectToConfigure.getClass().getName() + \"] with tags \" + currentTags + \".\");\n                            }\n                        }\n                    } else if (field.isAnnotationPresent(Tags.class)) {\n                        field.setAccessible(true);\n                        field.set(objectToConfigure, currentTags);\n                    }\n                } catch (IllegalAccessException e) {\n                    throw new ConstrettoException(\"Cold not inject configuration into field [\"\n                            + field.getName() + \"] annotated with @Configuration, in class [\" + objectToConfigure.getClass().getName() + \"] with tags \" + currentTags, e);\n                } catch (InstantiationException e) {\n                    throw new ConstrettoException(\"Cold not inject configuration into field [\"\n                            + field.getName() + \"] annotated with @Configuration, in class [\" + objectToConfigure.getClass().getName() + \"] with tags \" + currentTags, e);\n                }\n            }\n        } while ((objectToConfigureClass = objectToConfigureClass.getSuperclass()) != null);\n    }\n\n    private boolean hasAnnotationDefaults(Configuration configurationAnnotation) {\n        return !(\"N/A\".equals(configurationAnnotation.defaultValue()) && configurationAnnotation.defaultValueFactory().equals(Configuration.EmptyValueFactory.class));\n    }\n}\n","Method after Refactoring":"/*\n * Copyright 2008 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.constretto.internal;\n\nimport com.thoughtworks.paranamer.BytecodeReadingParanamer;\nimport com.thoughtworks.paranamer.Paranamer;\nimport org.constretto.ConfigurationDefaultValueFactory;\nimport org.constretto.ConstrettoConfiguration;\nimport org.constretto.GenericConverter;\nimport org.constretto.Property;\nimport org.constretto.annotation.Configuration;\nimport org.constretto.annotation.Configure;\nimport org.constretto.annotation.Tags;\nimport org.constretto.exception.ConstrettoConversionException;\nimport org.constretto.exception.ConstrettoException;\nimport org.constretto.exception.ConstrettoExpressionException;\nimport org.constretto.internal.converter.ValueConverterRegistry;\nimport org.constretto.model.CPrimitive;\nimport org.constretto.model.CValue;\nimport org.constretto.model.ConfigurationValue;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.ref.WeakReference;\nimport java.lang.reflect.*;\nimport java.util.*;\nimport java.util.concurrent.CopyOnWriteArraySet;\n\nimport static java.util.Arrays.asList;\nimport static org.constretto.internal.GenericCollectionTypeResolver.*;\n\n/**\n * @author <a href=\"mailto:kaare.nilsen@gmail.com\">Kaare Nilsen<\/a>\n */\npublic class DefaultConstrettoConfiguration implements ConstrettoConfiguration {\n    private static final String NULL_STRING = \"![![Null]!]!\";\n\n    private final Paranamer paranamer = new BytecodeReadingParanamer();\n\n    protected final Map<String, List<ConfigurationValue>> configuration;\n    private Set<WeakReference<Object>> configuredObjects = new CopyOnWriteArraySet<WeakReference<Object>>();\n    private final List<String> originalTags = new ArrayList<String>();\n    protected final List<String> currentTags = new ArrayList<String>();\n\n    public DefaultConstrettoConfiguration(Map<String, List<ConfigurationValue>> configuration, List<String> originalTags) {\n        this.configuration = configuration;\n        this.originalTags.addAll(originalTags);\n        this.currentTags.addAll(originalTags);\n    }\n\n    public DefaultConstrettoConfiguration(Map<String, List<ConfigurationValue>> configuration) {\n        this.configuration = configuration;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public <K> K evaluateTo(String expression, K defaultValue) {\n        if (!hasValue(expression)) {\n            return defaultValue;\n        }\n        K value;\n        try {\n            value = (K) processAndConvert(defaultValue.getClass(), expression);\n        } catch (ConstrettoConversionException e) {\n            value = null;\n        }\n        return null != value ? value : defaultValue;\n    }\n\n    public <T> T evaluateWith(GenericConverter<T> converter, String expression) {\n        ConfigurationValue value = findElementOrThrowException(expression);\n        return converter.fromValue(value.value());\n    }\n\n    public CValue evaluate(String expression) throws ConstrettoExpressionException {\n        return findElementOrThrowException(expression).value();\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public <K> List<K> evaluateToList(Class<K> targetClass, String expression) {\n        ConfigurationValue value = findElementOrThrowException(expression);\n        return (List<K>) ValueConverterRegistry.convert(targetClass, targetClass, value.value());\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public <K, V> Map<K, V> evaluateToMap(Class<K> keyClass, Class<V> valueClass, String expression) {\n        ConfigurationValue value = findElementOrThrowException(expression);\n        return (Map<K, V>) ValueConverterRegistry.convert(valueClass, keyClass, value.value());\n    }\n\n    public <K> K evaluateTo(Class<K> targetClass, String expression) throws ConstrettoExpressionException {\n        return processAndConvert(targetClass, expression);\n    }\n\n    public String evaluateToString(String expression) throws ConstrettoExpressionException {\n        return processAndConvert(String.class, expression);\n    }\n\n    public Boolean evaluateToBoolean(String expression) throws ConstrettoExpressionException {\n        return processAndConvert(Boolean.class, expression);\n    }\n\n    public Double evaluateToDouble(String expression) throws ConstrettoExpressionException {\n        return processAndConvert(Double.class, expression);\n    }\n\n    public Long evaluateToLong(String expression) throws ConstrettoExpressionException {\n        return processAndConvert(Long.class, expression);\n    }\n\n    public Float evaluateToFloat(String expression) throws ConstrettoExpressionException {\n        return processAndConvert(Float.class, expression);\n    }\n\n    public Integer evaluateToInt(String expression) throws ConstrettoExpressionException {\n        return processAndConvert(Integer.class, expression);\n    }\n\n    public Short evaluateToShort(String expression) throws ConstrettoExpressionException {\n        return processAndConvert(Short.class, expression);\n    }\n\n    public Byte evaluateToByte(String expression) throws ConstrettoExpressionException {\n        return processAndConvert(Byte.class, expression);\n    }\n\n    public <T> T as(Class<T> configurationClass) throws ConstrettoException {\n        T objectToConfigure;\n        try {\n            objectToConfigure = createInstance(configurationClass);\n        } catch (ConstrettoException e) {\n            throw e;\n        }\n        catch (Exception e) {\n            throw new ConstrettoException(\"Could not instansiate class of type: \" + configurationClass.getName()\n                    + \" when trying to inject it with configuration, It may be missing a default or @Configure annotated constructor\", e);\n        }\n        injectConfiguration(objectToConfigure);\n        return objectToConfigure;\n    }\n\n    public <T> T on(T objectToConfigure) throws ConstrettoException {\n        injectConfiguration(objectToConfigure);\n        return objectToConfigure;\n    }\n\n    public boolean hasValue(String expression) {\n        return findElementOrNull(expression) != null;\n    }\n\n    public void appendTag(String... newtags) {\n        currentTags.addAll(asList(newtags));\n        reconfigure();\n    }\n\n    public void prependTag(String... newtags) {\n        currentTags.addAll(0, asList(newtags));\n        reconfigure();\n    }\n\n    public void resetTags(boolean reconfigure) {\n        currentTags.clear();\n        currentTags.addAll(originalTags);\n        if (reconfigure)\n            reconfigure();\n    }\n\n    public void clearTags(boolean reconfigure) {\n        currentTags.clear();\n        originalTags.clear();\n        if (reconfigure)\n            reconfigure();\n    }\n\n    public void removeTag(String... newTags) {\n        for (String newTag : newTags) {\n            currentTags.remove(newTag);\n        }\n        reconfigure();\n    }\n\n    public List<String> getCurrentTags() {\n        return currentTags;\n    }\n\n    public Iterator<Property> iterator() {\n        List<Property> properties = new ArrayList<Property>();\n        Map<String, String> map = asMap();\n        for (Map.Entry<String, String> entry : map.entrySet()) {\n            properties.add(new Property(entry.getKey(), entry.getValue()));\n        }\n        return properties.iterator();\n    }\n\n    @Override\n    public void reconfigure() {\n        WeakReference[] references = configuredObjects.toArray(new WeakReference[configuredObjects.size()]);\n        for (WeakReference reference : references) {\n            if (reference != null && reference.get() != null) {\n                on(reference.get());\n            }\n        }\n    }\n\n    //\n    // Helper methods\n    //\n    private <T> T createInstance(final Class<T> configurationClass) throws InstantiationException, IllegalAccessException {\n\n\n        if(configurationClass.isInterface()) {\n            throw new ConstrettoException(\"Can not instantiate interfaces. You need to create an concrete implementing class first\");\n        }\n        if (configurationClass.isAnonymousClass()) {\n            throw new ConstrettoException(\"Can not instantiate anonymous classes using as(Class<T>. To inject configuration in to inner or anonymous classes, \" +\n                                                  \"instantiate it first and call the on(T configuredObjecT) method\");\n        }\n        Constructor<T>[] annotatedConstructors = findAnnotatedConstructorsOnClass(configurationClass);\n        if(configurationClass.isMemberClass() && annotatedConstructors != null) {\n            throw new ConstrettoException(\"Can not instantiate inner classes using a @Configure annotated constructor. \" +\n                                                  \"To inject configuration, construct the instance yourself use the \\\"on(T configuredObject)\\\" method\");\n        }\n        if(annotatedConstructors == null) {\n            return configurationClass.newInstance();\n        } else {\n            if(annotatedConstructors.length > 1) {\n                throw new ConstrettoException(\"More than one @Configure annotated constructor defined for class \\\"\" + configurationClass.getName() + \"\\\". It can only be one\");\n            }\n            Constructor<T> constructor = annotatedConstructors[0];\n            final Object[] resolvedParameters = resolveParameters(constructor);\n            try {\n                constructor.setAccessible(true);\n                return constructor.newInstance(resolvedParameters);\n            } catch (InvocationTargetException e) {\n                throw new ConstrettoException(\"Could not instantiate class with @Configure annotated constructor\");\n            }\n\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private <T> Constructor<T>[] findAnnotatedConstructorsOnClass(final Class<T> configurationClass) {\n        Constructor<?>[] constructors = configurationClass.getConstructors();\n        List<Constructor<?>> annotatedConstructors = new ArrayList<Constructor<?>>();\n        for(Constructor<?> constructor: constructors) {\n            if(constructor.isAnnotationPresent(Configure.class)) {\n                annotatedConstructors.add(constructor);\n            }\n        }\n        return annotatedConstructors.isEmpty() ? null : annotatedConstructors.toArray(new Constructor[]{});\n    }\n\n    private Map<String, String> asMap() {\n        Map<String, String> properties = new HashMap<String, String>();\n        for (Map.Entry<String, List<ConfigurationValue>> entry : configuration.entrySet()) {\n            ConfigurationValue value = findElementOrNull(entry.getKey());\n            if (value != null){\n                properties.put(entry.getKey(), value.value().toString());\n            }\n        }\n        return properties;\n    }\n\n    protected ConfigurationValue findElementOrThrowException(String expression) {\n        if (!configuration.containsKey(expression)) {\n            throw new ConstrettoExpressionException(expression, currentTags);\n        }\n        List<ConfigurationValue> values = configuration.get(expression);\n        ConfigurationValue resolvedNode = resolveMatch(values);\n        if (resolvedNode == null) {\n            throw new ConstrettoExpressionException(expression, currentTags);\n        }\n        if (resolvedNode.value().containsVariables()) {\n            for (String key : resolvedNode.value().referencedKeys()) {\n                resolvedNode.value().replace(key, evaluateToString(key));\n            }\n        }\n        return resolvedNode;\n    }\n\n\n    protected ConfigurationValue findElementOrNull(String expression) {\n        if (!configuration.containsKey(expression)) {\n            return null;\n        }\n        List<ConfigurationValue> values = configuration.get(expression);\n        ConfigurationValue resolvedNode = resolveMatch(values);\n        if (resolvedNode == null) {\n            return null;\n        }\n        if (resolvedNode.value().containsVariables()) {\n            for (String key : resolvedNode.value().referencedKeys()) {\n                resolvedNode.value().replace(key, evaluateToString(key));\n            }\n        }\n        return resolvedNode;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private <T> T processAndConvert(Class<T> clazz, String expression) throws ConstrettoException {\n        ConfigurationValue value = findElementOrThrowException(expression);\n        return (T) ValueConverterRegistry.convert(clazz, clazz, value.value());\n    }\n\n    private ConfigurationValue resolveMatch(List<ConfigurationValue> values) {\n        ConfigurationValue bestMatch = null;\n        for (ConfigurationValue configurationNode : values) {\n            if (ConfigurationValue.DEFAULT_TAG.equals(configurationNode.tag())) {\n                if (bestMatch == null || bestMatch.tag().equals(ConfigurationValue.DEFAULT_TAG)) {\n                    bestMatch = configurationNode;\n                }\n            } else if (currentTags.contains(configurationNode.tag())) {\n                if (bestMatch == null) {\n                    bestMatch = configurationNode;\n                } else {\n                    int previousFoundPriority =\n                            ConfigurationValue.DEFAULT_TAG.equals(bestMatch.tag()) ?\n                                    Integer.MAX_VALUE : currentTags.indexOf(bestMatch.tag());\n                    if (currentTags.indexOf(configurationNode.tag()) <= previousFoundPriority) {\n                        bestMatch = configurationNode;\n                    }\n                }\n            } else if (ConfigurationValue.ALL_TAG.equals(configurationNode.tag())) {\n                bestMatch = configurationNode;\n            }\n        }\n        return bestMatch;\n    }\n\n    private <T> void injectConfiguration(T objectToConfigure) {\n        injectFields(objectToConfigure);\n        injectMethods(objectToConfigure);\n        boolean found = false;\n        for (WeakReference<Object> configuredObject : configuredObjects) {\n            if (configuredObject.get() == objectToConfigure) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            this.configuredObjects.add(new WeakReference<Object>(objectToConfigure));\n        }\n    }\n\n    private Object[] resolveParameters(AccessibleObject accessibleObject) throws IllegalAccessException, InstantiationException {\n        Annotation[][] methodAnnotations;\n        String[] parameterNames;\n        Class<?>[] parameterTargetTypes;\n\n        if(accessibleObject instanceof Method) {\n            Method method = (Method) accessibleObject;\n            methodAnnotations = method.getParameterAnnotations();\n            parameterNames = paranamer.lookupParameterNames(method);\n            parameterTargetTypes = method.getParameterTypes();\n        } else if(accessibleObject instanceof Constructor) {\n            Constructor constructor = (Constructor) accessibleObject;\n            methodAnnotations = constructor.getParameterAnnotations();\n            parameterNames = paranamer.lookupParameterNames(constructor);\n            parameterTargetTypes = constructor.getParameterTypes();\n        } else {\n            throw new ConstrettoException(\"Could not resolve parameter names \");\n        }\n\n        Object[] resolvedArguments = new Object[methodAnnotations.length];\n        int i = 0;\n        for (Annotation[] parameterAnnotations : methodAnnotations) {\n            Object defaultValue = null;\n            boolean required = true;\n            String expression = \"\";\n            Class<?> parameterTargetClass = parameterTargetTypes[i];\n            if (parameterAnnotations.length != 0) {\n                for (Annotation parameterAnnotation : parameterAnnotations) {\n                    if (parameterAnnotation.annotationType() == Configuration.class) {\n                        Configuration configurationAnnotation = (Configuration) parameterAnnotation;\n                        expression = configurationAnnotation.value();\n                        required = configurationAnnotation.required();\n                        if (hasAnnotationDefaults(configurationAnnotation)) {\n                            if (configurationAnnotation.defaultValueFactory().equals(Configuration.EmptyValueFactory.class)) {\n                                defaultValue = ValueConverterRegistry.convert(parameterTargetClass, parameterTargetClass, new CPrimitive(configurationAnnotation.defaultValue()));\n                            } else {\n                                ConfigurationDefaultValueFactory valueFactory = configurationAnnotation.defaultValueFactory().newInstance();\n                                defaultValue = valueFactory.getDefaultValue();\n                            }\n                        }\n                    }\n                }\n            }\n            if (expression.equals(\"\")) {\n                if (parameterNames == null) {\n                    throw new ConstrettoException(\"Could not resolve the expression of the property to look up. \" +\n                                                          \"The cause of this could be that the class is compiled without debug enabled. \" +\n                                                          \"when a class is compiled without debug, the @Configuration with a value attribute is required \" +\n                                                          \"to correctly resolve the property expression.\");\n                } else {\n                    expression = parameterNames[i];\n                }\n            }\n            if (hasValue(expression)) {\n                if (parameterTargetClass.isAssignableFrom(List.class)) {\n                    Class<?> collectionParameterType = getCollectionParameterType(createMethodParameter(accessibleObject, i));\n                    resolvedArguments[i] = evaluateToList(collectionParameterType, expression);\n                } else if (parameterTargetClass.isAssignableFrom(Map.class)) {\n                    Class<?> mapKeyType = getMapKeyParameterType(createMethodParameter(accessibleObject, i));\n                    Class<?> mapValueType = getMapValueParameterType(createMethodParameter(accessibleObject, i));\n                    resolvedArguments[i] = evaluateToMap(mapKeyType, mapValueType, expression);\n                } else {\n                    resolvedArguments[i] = processAndConvert(parameterTargetClass, expression);\n                }\n\n            } else {\n                if (defaultValue != null || !required) {\n                    resolvedArguments[i] = defaultValue;\n                } else {\n                    if(accessibleObject instanceof Constructor) {\n                        Constructor constructor = (Constructor) accessibleObject;\n                        throw new ConstrettoException(\"Missing value or default value for expression [\" + expression + \"], in annotated constructor in class [\" + constructor.getClass().getName() + \"], with tags \" + currentTags + \".\");\n\n                    }\n                    else {\n                        Method method = (Method) accessibleObject;\n                        throw new ConstrettoException(\"Missing value or default value for expression [\" + expression + \"], in method [\" + method.getName() + \"], in class [\" + method.getClass().getName() + \"], with tags \" + currentTags + \".\");\n\n                    }\n                }\n            }\n\n            i++;\n        }\n        return resolvedArguments;\n\n    }\n\n    private <T> void injectMethods(T objectToConfigure) {\n        Method[] methods = objectToConfigure.getClass().getMethods();\n        for (Method method : methods) {\n            try {\n                if (method.isAnnotationPresent(Configure.class)) {\n                    Object[] resolvedArguments = resolveParameters(method);\n                    method.setAccessible(true);\n                    method.invoke(objectToConfigure, resolvedArguments);\n\n                }\n            } catch (IllegalAccessException e) {\n                throw new ConstrettoException(\"Cold not invoke method [\"\n                                                      + method.getName() + \"] annotated with @Configured,\", e);\n            } catch (InvocationTargetException e) {\n                throw new ConstrettoException(\"Cold not invoke method [\"\n                                                      + method.getName() + \"] annotated with @Configured,\", e);\n            } catch (InstantiationException e) {\n                throw new ConstrettoException(\"Cold not invoke method [\"\n                                                      + method.getName() + \"] annotated with @Configured,\", e);\n            }\n        }\n    }\n\n    private <T extends AccessibleObject> MethodParameter createMethodParameter(T accessibleObject, final int parameterIndex) {\n        if(accessibleObject instanceof Constructor) {\n            return new MethodParameter((Constructor) accessibleObject, parameterIndex);\n        } else {\n            return new MethodParameter((Method) accessibleObject, parameterIndex);\n        }\n    }\n\n    private <T> void injectFields(T objectToConfigure) {\n\n        Class objectToConfigureClass = objectToConfigure.getClass();\n\n        do {\n            Field[] fields = objectToConfigureClass.getDeclaredFields();\n            for (Field field : fields) {\n                try {\n                    if (field.isAnnotationPresent(Configuration.class)) {\n                        Configuration configurationAnnotation = field.getAnnotation(Configuration.class);\n                        String expression = \"\".equals(configurationAnnotation.value()) ? field.getName() : configurationAnnotation.value();\n                        field.setAccessible(true);\n                        Class<?> fieldType = field.getType();\n                        if (hasValue(expression)) {\n                            ConfigurationValue node = findElementOrThrowException(expression);\n                            if (fieldType.isAssignableFrom(List.class)) {\n                                field.set(objectToConfigure, evaluateToList(getCollectionFieldType(field), expression));\n                            } else if (fieldType.isAssignableFrom(Map.class)) {\n                                field.set(objectToConfigure, evaluateToMap(getMapKeyFieldType(field), getMapValueFieldType(field), expression));\n                            } else {\n                                field.set(objectToConfigure, processAndConvert(fieldType, expression));\n                            }\n                        } else {\n                            if (hasAnnotationDefaults(configurationAnnotation)) {\n                                if (configurationAnnotation.defaultValueFactory().equals(Configuration.EmptyValueFactory.class)) {\n                                    field.set(objectToConfigure, ValueConverterRegistry.convert(fieldType, fieldType, new CPrimitive(configurationAnnotation.defaultValue())));\n                                } else {\n                                    ConfigurationDefaultValueFactory valueFactory = configurationAnnotation.defaultValueFactory().newInstance();\n                                    field.set(objectToConfigure, valueFactory.getDefaultValue());\n                                }\n                            } else if (configurationAnnotation.required()) {\n                                throw new ConstrettoException(\"Missing value or default value for expression [\" + expression + \"] for field [\" + field.getName() + \"], in class [\" + objectToConfigure.getClass().getName() + \"] with tags \" + currentTags + \".\");\n                            }\n                        }\n                    } else if (field.isAnnotationPresent(Tags.class)) {\n                        field.setAccessible(true);\n                        field.set(objectToConfigure, currentTags);\n                    }\n                } catch (IllegalAccessException e) {\n                    throw new ConstrettoException(\"Cold not inject configuration into field [\"\n                            + field.getName() + \"] annotated with @Configuration, in class [\" + objectToConfigure.getClass().getName() + \"] with tags \" + currentTags, e);\n                } catch (InstantiationException e) {\n                    throw new ConstrettoException(\"Cold not inject configuration into field [\"\n                            + field.getName() + \"] annotated with @Configuration, in class [\" + objectToConfigure.getClass().getName() + \"] with tags \" + currentTags, e);\n                }\n            }\n        } while ((objectToConfigureClass = objectToConfigureClass.getSuperclass()) != null);\n    }\n\n    private boolean hasAnnotationDefaults(Configuration configurationAnnotation) {\n        return !(\"N/A\".equals(configurationAnnotation.defaultValue()) && configurationAnnotation.defaultValueFactory().equals(Configuration.EmptyValueFactory.class));\n    }\n}\n","lineNo":359}
{"Smelly Sample":"package org.constretto.ldap;\n\nimport org.constretto.exception.ConstrettoException;\nimport org.constretto.model.ConfigurationValue;\nimport org.constretto.model.TaggedPropertySet;\nimport org.junit.After;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.Mock;\nimport org.mockito.runners.MockitoJUnitRunner;\n\nimport javax.naming.NamingEnumeration;\nimport javax.naming.NamingException;\nimport javax.naming.directory.Attribute;\nimport javax.naming.directory.Attributes;\nimport java.util.Collection;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.mockito.Mockito.*;\n\n/**\n * @author zapodot\n */\n@RunWith(MockitoJUnitRunner.class)\npublic class LdapConfigurationStoreTest {\n\n    @Mock\n    private Attributes attributes;\n    @Mock\n    private Attribute attribute;\n    @Mock\n    private NamingEnumeration attributesNamingEnumeration;\n    private LdapConfigurationStore parentLdapConfigurationStore = new LdapConfigurationStore();\n\n    @Test(expected = ConstrettoException.class)\n    public void testParseConfigurationAttributesReadFailed() throws Exception {\n\n        when(attributes.getAll()).thenReturn(attributesNamingEnumeration);\n        when(attributesNamingEnumeration.hasMore()).thenThrow(new NamingException());\n        try {\n            final LdapConfigurationStore ldapConfigurationStore = new LdapConfigurationStore(\n                    parentLdapConfigurationStore,\n                    attributes);\n            ldapConfigurationStore.parseConfiguration();\n\n        } finally {\n            verify(attributes).getAll();\n            verify(attributesNamingEnumeration).hasMore();\n        }\n    }\n\n    @Test\n    public void testParseConfigurationDefaultConstructor() throws Exception {\n        final Collection<TaggedPropertySet> taggedPropertySets = new LdapConfigurationStore().parseConfiguration();\n        assertEquals(1, taggedPropertySets.size());\n        assertEquals(ConfigurationValue.DEFAULT_TAG, taggedPropertySets.iterator().next().tag());\n\n    }\n\n    @Test\n    public void testParseConfigurationTagsNoValues() throws Exception {\n        when(attributes.getAll()).thenReturn(attributesNamingEnumeration);\n        when(attributesNamingEnumeration.hasMore()).thenReturn(false);\n\n        final Collection<TaggedPropertySet> taggedPropertySets = new LdapConfigurationStore(new LdapConfigurationStore(),\n                attributes).parseConfiguration();\n\n        assertEquals(1, taggedPropertySets.size());\n        assertEquals(ConfigurationValue.DEFAULT_TAG, taggedPropertySets.iterator().next().tag());\n\n        verify(attributes).getAll();\n        verify(attributesNamingEnumeration).hasMore();\n    }\n\n    @Test\n    public void testParseConfigurationDefaultTagPassword() throws Exception {\n        when(attributes.getAll()).thenReturn(attributesNamingEnumeration);\n        when(attributesNamingEnumeration.hasMore()).thenReturn(true, false);\n        when(attributesNamingEnumeration.next()).thenReturn(attribute);\n        when(attribute.getID()).thenReturn(\"password\");\n\n        final Collection<TaggedPropertySet> taggedPropertySets = new LdapConfigurationStore(new LdapConfigurationStore(),\n                attributes).parseConfiguration();\n        assertEquals(1, taggedPropertySets.size());\n        assertEquals(ConfigurationValue.DEFAULT_TAG, taggedPropertySets.iterator().next().tag());\n\n        verify(attributes).getAll();\n        verify(attributesNamingEnumeration, times(2)).hasMore();\n        verify(attributesNamingEnumeration).next();\n        verify(attribute).getID();\n    }\n\n    @Test\n    public void testParseConfigurationTagsPassword() throws Exception {\n        when(attributes.getAll()).thenReturn(attributesNamingEnumeration);\n        when(attributesNamingEnumeration.hasMore()).thenReturn(true, false);\n        when(attributesNamingEnumeration.next()).thenReturn(attribute);\n        when(attribute.getID()).thenReturn(\"password\");\n\n        final String tag = \"tag\";\n        final Collection<TaggedPropertySet> taggedPropertySets = new LdapConfigurationStore(new LdapConfigurationStore(),\n                attributes, tag).parseConfiguration();\n        assertEquals(1, taggedPropertySets.size());\n        final TaggedPropertySet taggedPropertySet = taggedPropertySets.iterator().next();\n        assertEquals(tag, taggedPropertySet.tag());\n        assertEquals(0, taggedPropertySet.getProperties().size());\n\n        verify(attributes).getAll();\n        verify(attributesNamingEnumeration, times(2)).hasMore();\n        verify(attributesNamingEnumeration).next();\n        verify(attribute).getID();\n    }\n\n    @Test\n    public void testParseConfigurationTags() throws Exception {\n        when(attributes.getAll()).thenReturn(attributesNamingEnumeration);\n        when(attributesNamingEnumeration.hasMore()).thenReturn(true, false);\n        when(attributesNamingEnumeration.next()).thenReturn(attribute);\n        when(attribute.getID()).thenReturn(\"uid\");\n        when(attribute.get()).thenReturn(\"some value\");\n\n        final String tag = \"tag\";\n        final Collection<TaggedPropertySet> taggedPropertySets = new LdapConfigurationStore(new LdapConfigurationStore(),\n                attributes, tag).parseConfiguration();\n        assertEquals(1, taggedPropertySets.size());\n        assertEquals(tag, taggedPropertySets.iterator().next().tag());\n\n        verify(attributes).getAll();\n        verify(attributesNamingEnumeration, times(2)).hasMore();\n        verify(attributesNamingEnumeration).next();\n        verify(attribute, times(2)).getID();\n        verify(attribute).get();\n    }\n\n    @After\n    public void tearDown() throws Exception {\n        verifyNoMoreInteractions(attributes, attributesNamingEnumeration, attribute);\n\n    }\n}\n","Method after Refactoring":"package org.constretto.ldap;\n\nimport org.constretto.ConstrettoBuilder;\nimport org.constretto.ConstrettoConfiguration;\nimport org.constretto.exception.ConstrettoException;\nimport org.constretto.model.ConfigurationValue;\nimport org.constretto.model.TaggedPropertySet;\nimport org.junit.After;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.Mock;\nimport org.mockito.runners.MockitoJUnitRunner;\n\nimport javax.naming.NamingEnumeration;\nimport javax.naming.NamingException;\nimport javax.naming.directory.Attribute;\nimport javax.naming.directory.Attributes;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.List;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\nimport static org.mockito.Mockito.*;\n\n/**\n * @author zapodot\n */\n@RunWith(MockitoJUnitRunner.class)\npublic class LdapConfigurationStoreTest {\n\n    @Mock\n    private Attributes attributes;\n    @Mock\n    private Attribute attribute;\n    @Mock\n    private NamingEnumeration attributesNamingEnumeration;\n    private LdapConfigurationStore parentLdapConfigurationStore = new LdapConfigurationStore();\n\n    @Test(expected = ConstrettoException.class)\n    public void testParseConfigurationAttributesReadFailed() throws Exception {\n\n        when(attributes.getAll()).thenReturn(attributesNamingEnumeration);\n        when(attributesNamingEnumeration.hasMore()).thenThrow(new NamingException());\n        try {\n            final LdapConfigurationStore ldapConfigurationStore = new LdapConfigurationStore(\n                    parentLdapConfigurationStore,\n                    attributes);\n            ldapConfigurationStore.parseConfiguration();\n\n        } finally {\n            verify(attributes).getAll();\n            verify(attributesNamingEnumeration).hasMore();\n        }\n    }\n\n    @Test\n    public void testParseConfigurationDefaultConstructor() throws Exception {\n        final Collection<TaggedPropertySet> taggedPropertySets = new LdapConfigurationStore().parseConfiguration();\n        assertEquals(1, taggedPropertySets.size());\n        assertEquals(ConfigurationValue.DEFAULT_TAG, taggedPropertySets.iterator().next().tag());\n\n    }\n\n    @Test\n    public void testParseConfigurationTagsNoValues() throws Exception {\n        when(attributes.getAll()).thenReturn(attributesNamingEnumeration);\n        when(attributesNamingEnumeration.hasMore()).thenReturn(false);\n\n        final Collection<TaggedPropertySet> taggedPropertySets = new LdapConfigurationStore(new LdapConfigurationStore(),\n                attributes).parseConfiguration();\n\n        assertEquals(1, taggedPropertySets.size());\n        assertEquals(ConfigurationValue.DEFAULT_TAG, taggedPropertySets.iterator().next().tag());\n\n        verify(attributes).getAll();\n        verify(attributesNamingEnumeration).hasMore();\n    }\n\n    @Test\n    public void testParseConfigurationDefaultTagPassword() throws Exception {\n        when(attributes.getAll()).thenReturn(attributesNamingEnumeration);\n        when(attributesNamingEnumeration.hasMore()).thenReturn(true, false);\n        when(attributesNamingEnumeration.next()).thenReturn(attribute);\n        when(attribute.getID()).thenReturn(\"password\");\n\n        final Collection<TaggedPropertySet> taggedPropertySets = new LdapConfigurationStore(new LdapConfigurationStore(),\n                attributes).parseConfiguration();\n        assertEquals(1, taggedPropertySets.size());\n        assertEquals(ConfigurationValue.DEFAULT_TAG, taggedPropertySets.iterator().next().tag());\n\n        verify(attributes).getAll();\n        verify(attributesNamingEnumeration, times(2)).hasMore();\n        verify(attributesNamingEnumeration).next();\n        verify(attribute).getID();\n    }\n\n    @Test\n    public void testParseConfigurationTagsPassword() throws Exception {\n        when(attributes.getAll()).thenReturn(attributesNamingEnumeration);\n        when(attributesNamingEnumeration.hasMore()).thenReturn(true, false);\n        when(attributesNamingEnumeration.next()).thenReturn(attribute);\n        when(attribute.getID()).thenReturn(\"password\");\n\n        final String tag = \"tag\";\n        final Collection<TaggedPropertySet> taggedPropertySets = new LdapConfigurationStore(new LdapConfigurationStore(),\n                attributes, tag).parseConfiguration();\n        assertEquals(1, taggedPropertySets.size());\n        final TaggedPropertySet taggedPropertySet = taggedPropertySets.iterator().next();\n        assertEquals(tag, taggedPropertySet.tag());\n        assertEquals(0, taggedPropertySet.getProperties().size());\n\n        verify(attributes).getAll();\n        verify(attributesNamingEnumeration, times(2)).hasMore();\n        verify(attributesNamingEnumeration).next();\n        verify(attribute).getID();\n    }\n\n    @Test\n    public void testParseConfigurationTags() throws Exception {\n        when(attributes.getAll()).thenReturn(attributesNamingEnumeration);\n        when(attributesNamingEnumeration.hasMore()).thenReturn(true, false);\n        when(attributesNamingEnumeration.next()).thenReturn(attribute);\n        final String attributeId = \"uid\";\n        when(attribute.getID()).thenReturn(attributeId);\n        final String attributeValue = \"some value\";\n        when(attribute.get()).thenReturn(attributeValue);\n        when(attribute.size()).thenReturn(1);\n\n        final String tag = \"tag\";\n        final LdapConfigurationStore ldapConfigurationStore = new LdapConfigurationStore(new LdapConfigurationStore(),\n                attributes, tag);\n        final Collection<TaggedPropertySet> taggedPropertySets = ldapConfigurationStore.parseConfiguration();\n        assertEquals(1, taggedPropertySets.size());\n\n        final TaggedPropertySet taggedPropertySet = taggedPropertySets.iterator().next();\n        assertEquals(tag, taggedPropertySet.tag());\n\n        verify(attributes).getAll();\n        verify(attributesNamingEnumeration, times(2)).hasMore();\n        verify(attributesNamingEnumeration).next();\n        verify(attribute, times(2)).getID();\n        verify(attribute).get();\n        verify(attribute).size();\n    }\n\n    @Test\n    public void testParseConfigurationSimpleValue() throws Exception {\n        when(attributes.getAll()).thenReturn(attributesNamingEnumeration);\n        when(attributesNamingEnumeration.hasMore()).thenReturn(true, false);\n        when(attributesNamingEnumeration.next()).thenReturn(attribute);\n        final String attributeId = \"uid\";\n        when(attribute.getID()).thenReturn(attributeId);\n        final String attributeValue = \"some value\";\n        when(attribute.get()).thenReturn(attributeValue);\n        when(attribute.size()).thenReturn(1);\n\n        final LdapConfigurationStore ldapConfigurationStore = new LdapConfigurationStore(new LdapConfigurationStore(),\n                attributes);\n\n        final ConstrettoConfiguration constrettoConfiguration = createConfigurationForLdapConfigurationStore(ldapConfigurationStore);\n        assertTrue(constrettoConfiguration.hasValue(attributeId));\n        assertEquals(attributeValue, constrettoConfiguration.evaluateToString(attributeId));\n\n        verify(attributes).getAll();\n        verify(attributesNamingEnumeration, times(2)).hasMore();\n        verify(attributesNamingEnumeration).next();\n        verify(attribute, times(2)).getID();\n        verify(attribute).get();\n        verify(attribute).size();\n    }\n\n    @Test\n    public void testParseConfigurationMultiValue() throws Exception {\n        when(attributes.getAll()).thenReturn(attributesNamingEnumeration);\n        when(attributesNamingEnumeration.hasMore()).thenReturn(true, false);\n        when(attributesNamingEnumeration.next()).thenReturn(attribute);\n        final String attributeName = \"uniqueMember\";\n        when(attribute.getID()).thenReturn(attributeName);\n        final List<String> attributeValues = Arrays.asList(\"cn=Kaare Nilsen,dc=constretto,dc=org\",\n                \"cn=Jon-Anders Teigen,dc=constretto,dc=org\");\n        when(attribute.get()).thenReturn(attributeValues);\n        when(attribute.size()).thenReturn(attributeValues.size());\n        when(attribute.get(anyInt())).thenReturn(attributeValues.get(0), attributeValues.get(1));\n\n        final LdapConfigurationStore ldapConfigurationStore = new LdapConfigurationStore(new LdapConfigurationStore(),\n                attributes);\n        final ConstrettoConfiguration constrettoConfiguration = createConfigurationForLdapConfigurationStore(ldapConfigurationStore);\n        assertTrue(constrettoConfiguration.hasValue(attributeName));\n        assertEquals(2, constrettoConfiguration.evaluateToList(String.class, attributeName).size());\n\n        verify(attributes).getAll();\n        verify(attributesNamingEnumeration, times(2)).hasMore();\n        verify(attributesNamingEnumeration).next();\n        verify(attribute, times(2)).getID();\n        verify(attribute).size();\n        verify(attribute).get(eq(0));\n        verify(attribute).get(eq(1));\n    }\n\n    private ConstrettoConfiguration createConfigurationForLdapConfigurationStore(LdapConfigurationStore ldapConfigurationStore) {\n        return new ConstrettoBuilder(false)\n                    .addConfigurationStore(ldapConfigurationStore)\n                    .getConfiguration();\n    }\n\n    @After\n    public void tearDown() throws Exception {\n        verifyNoMoreInteractions(attributes, attributesNamingEnumeration, attribute);\n\n    }\n}\n","lineNo":124}
{"Smelly Sample":"package org.constretto.ldap;\n\nimport org.constretto.exception.ConstrettoException;\nimport org.constretto.model.ConfigurationValue;\nimport org.constretto.model.TaggedPropertySet;\nimport org.junit.After;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.Mock;\nimport org.mockito.runners.MockitoJUnitRunner;\n\nimport javax.naming.NamingEnumeration;\nimport javax.naming.NamingException;\nimport javax.naming.directory.Attribute;\nimport javax.naming.directory.Attributes;\nimport java.util.Collection;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.mockito.Mockito.*;\n\n/**\n * @author zapodot\n */\n@RunWith(MockitoJUnitRunner.class)\npublic class LdapConfigurationStoreTest {\n\n    @Mock\n    private Attributes attributes;\n    @Mock\n    private Attribute attribute;\n    @Mock\n    private NamingEnumeration attributesNamingEnumeration;\n    private LdapConfigurationStore parentLdapConfigurationStore = new LdapConfigurationStore();\n\n    @Test(expected = ConstrettoException.class)\n    public void testParseConfigurationAttributesReadFailed() throws Exception {\n\n        when(attributes.getAll()).thenReturn(attributesNamingEnumeration);\n        when(attributesNamingEnumeration.hasMore()).thenThrow(new NamingException());\n        try {\n            final LdapConfigurationStore ldapConfigurationStore = new LdapConfigurationStore(\n                    parentLdapConfigurationStore,\n                    attributes);\n            ldapConfigurationStore.parseConfiguration();\n\n        } finally {\n            verify(attributes).getAll();\n            verify(attributesNamingEnumeration).hasMore();\n        }\n    }\n\n    @Test\n    public void testParseConfigurationDefaultConstructor() throws Exception {\n        final Collection<TaggedPropertySet> taggedPropertySets = new LdapConfigurationStore().parseConfiguration();\n        assertEquals(1, taggedPropertySets.size());\n        assertEquals(ConfigurationValue.DEFAULT_TAG, taggedPropertySets.iterator().next().tag());\n\n    }\n\n    @Test\n    public void testParseConfigurationTagsNoValues() throws Exception {\n        when(attributes.getAll()).thenReturn(attributesNamingEnumeration);\n        when(attributesNamingEnumeration.hasMore()).thenReturn(false);\n\n        final Collection<TaggedPropertySet> taggedPropertySets = new LdapConfigurationStore(new LdapConfigurationStore(),\n                attributes).parseConfiguration();\n\n        assertEquals(1, taggedPropertySets.size());\n        assertEquals(ConfigurationValue.DEFAULT_TAG, taggedPropertySets.iterator().next().tag());\n\n        verify(attributes).getAll();\n        verify(attributesNamingEnumeration).hasMore();\n    }\n\n    @Test\n    public void testParseConfigurationDefaultTagPassword() throws Exception {\n        when(attributes.getAll()).thenReturn(attributesNamingEnumeration);\n        when(attributesNamingEnumeration.hasMore()).thenReturn(true, false);\n        when(attributesNamingEnumeration.next()).thenReturn(attribute);\n        when(attribute.getID()).thenReturn(\"password\");\n\n        final Collection<TaggedPropertySet> taggedPropertySets = new LdapConfigurationStore(new LdapConfigurationStore(),\n                attributes).parseConfiguration();\n        assertEquals(1, taggedPropertySets.size());\n        assertEquals(ConfigurationValue.DEFAULT_TAG, taggedPropertySets.iterator().next().tag());\n\n        verify(attributes).getAll();\n        verify(attributesNamingEnumeration, times(2)).hasMore();\n        verify(attributesNamingEnumeration).next();\n        verify(attribute).getID();\n    }\n\n    @Test\n    public void testParseConfigurationTagsPassword() throws Exception {\n        when(attributes.getAll()).thenReturn(attributesNamingEnumeration);\n        when(attributesNamingEnumeration.hasMore()).thenReturn(true, false);\n        when(attributesNamingEnumeration.next()).thenReturn(attribute);\n        when(attribute.getID()).thenReturn(\"password\");\n\n        final String tag = \"tag\";\n        final Collection<TaggedPropertySet> taggedPropertySets = new LdapConfigurationStore(new LdapConfigurationStore(),\n                attributes, tag).parseConfiguration();\n        assertEquals(1, taggedPropertySets.size());\n        final TaggedPropertySet taggedPropertySet = taggedPropertySets.iterator().next();\n        assertEquals(tag, taggedPropertySet.tag());\n        assertEquals(0, taggedPropertySet.getProperties().size());\n\n        verify(attributes).getAll();\n        verify(attributesNamingEnumeration, times(2)).hasMore();\n        verify(attributesNamingEnumeration).next();\n        verify(attribute).getID();\n    }\n\n    @Test\n    public void testParseConfigurationTags() throws Exception {\n        when(attributes.getAll()).thenReturn(attributesNamingEnumeration);\n        when(attributesNamingEnumeration.hasMore()).thenReturn(true, false);\n        when(attributesNamingEnumeration.next()).thenReturn(attribute);\n        when(attribute.getID()).thenReturn(\"uid\");\n        when(attribute.get()).thenReturn(\"some value\");\n\n        final String tag = \"tag\";\n        final Collection<TaggedPropertySet> taggedPropertySets = new LdapConfigurationStore(new LdapConfigurationStore(),\n                attributes, tag).parseConfiguration();\n        assertEquals(1, taggedPropertySets.size());\n        assertEquals(tag, taggedPropertySets.iterator().next().tag());\n\n        verify(attributes).getAll();\n        verify(attributesNamingEnumeration, times(2)).hasMore();\n        verify(attributesNamingEnumeration).next();\n        verify(attribute, times(2)).getID();\n        verify(attribute).get();\n    }\n\n    @After\n    public void tearDown() throws Exception {\n        verifyNoMoreInteractions(attributes, attributesNamingEnumeration, attribute);\n\n    }\n}\n","Method after Refactoring":"package org.constretto.ldap;\n\nimport org.constretto.ConstrettoBuilder;\nimport org.constretto.ConstrettoConfiguration;\nimport org.constretto.exception.ConstrettoException;\nimport org.constretto.model.ConfigurationValue;\nimport org.constretto.model.TaggedPropertySet;\nimport org.junit.After;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.Mock;\nimport org.mockito.runners.MockitoJUnitRunner;\n\nimport javax.naming.NamingEnumeration;\nimport javax.naming.NamingException;\nimport javax.naming.directory.Attribute;\nimport javax.naming.directory.Attributes;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.List;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\nimport static org.mockito.Mockito.*;\n\n/**\n * @author zapodot\n */\n@RunWith(MockitoJUnitRunner.class)\npublic class LdapConfigurationStoreTest {\n\n    @Mock\n    private Attributes attributes;\n    @Mock\n    private Attribute attribute;\n    @Mock\n    private NamingEnumeration attributesNamingEnumeration;\n    private LdapConfigurationStore parentLdapConfigurationStore = new LdapConfigurationStore();\n\n    @Test(expected = ConstrettoException.class)\n    public void testParseConfigurationAttributesReadFailed() throws Exception {\n\n        when(attributes.getAll()).thenReturn(attributesNamingEnumeration);\n        when(attributesNamingEnumeration.hasMore()).thenThrow(new NamingException());\n        try {\n            final LdapConfigurationStore ldapConfigurationStore = new LdapConfigurationStore(\n                    parentLdapConfigurationStore,\n                    attributes);\n            ldapConfigurationStore.parseConfiguration();\n\n        } finally {\n            verify(attributes).getAll();\n            verify(attributesNamingEnumeration).hasMore();\n        }\n    }\n\n    @Test\n    public void testParseConfigurationDefaultConstructor() throws Exception {\n        final Collection<TaggedPropertySet> taggedPropertySets = new LdapConfigurationStore().parseConfiguration();\n        assertEquals(1, taggedPropertySets.size());\n        assertEquals(ConfigurationValue.DEFAULT_TAG, taggedPropertySets.iterator().next().tag());\n\n    }\n\n    @Test\n    public void testParseConfigurationTagsNoValues() throws Exception {\n        when(attributes.getAll()).thenReturn(attributesNamingEnumeration);\n        when(attributesNamingEnumeration.hasMore()).thenReturn(false);\n\n        final Collection<TaggedPropertySet> taggedPropertySets = new LdapConfigurationStore(new LdapConfigurationStore(),\n                attributes).parseConfiguration();\n\n        assertEquals(1, taggedPropertySets.size());\n        assertEquals(ConfigurationValue.DEFAULT_TAG, taggedPropertySets.iterator().next().tag());\n\n        verify(attributes).getAll();\n        verify(attributesNamingEnumeration).hasMore();\n    }\n\n    @Test\n    public void testParseConfigurationDefaultTagPassword() throws Exception {\n        when(attributes.getAll()).thenReturn(attributesNamingEnumeration);\n        when(attributesNamingEnumeration.hasMore()).thenReturn(true, false);\n        when(attributesNamingEnumeration.next()).thenReturn(attribute);\n        when(attribute.getID()).thenReturn(\"password\");\n\n        final Collection<TaggedPropertySet> taggedPropertySets = new LdapConfigurationStore(new LdapConfigurationStore(),\n                attributes).parseConfiguration();\n        assertEquals(1, taggedPropertySets.size());\n        assertEquals(ConfigurationValue.DEFAULT_TAG, taggedPropertySets.iterator().next().tag());\n\n        verify(attributes).getAll();\n        verify(attributesNamingEnumeration, times(2)).hasMore();\n        verify(attributesNamingEnumeration).next();\n        verify(attribute).getID();\n    }\n\n    @Test\n    public void testParseConfigurationTagsPassword() throws Exception {\n        when(attributes.getAll()).thenReturn(attributesNamingEnumeration);\n        when(attributesNamingEnumeration.hasMore()).thenReturn(true, false);\n        when(attributesNamingEnumeration.next()).thenReturn(attribute);\n        when(attribute.getID()).thenReturn(\"password\");\n\n        final String tag = \"tag\";\n        final Collection<TaggedPropertySet> taggedPropertySets = new LdapConfigurationStore(new LdapConfigurationStore(),\n                attributes, tag).parseConfiguration();\n        assertEquals(1, taggedPropertySets.size());\n        final TaggedPropertySet taggedPropertySet = taggedPropertySets.iterator().next();\n        assertEquals(tag, taggedPropertySet.tag());\n        assertEquals(0, taggedPropertySet.getProperties().size());\n\n        verify(attributes).getAll();\n        verify(attributesNamingEnumeration, times(2)).hasMore();\n        verify(attributesNamingEnumeration).next();\n        verify(attribute).getID();\n    }\n\n    @Test\n    public void testParseConfigurationTags() throws Exception {\n        when(attributes.getAll()).thenReturn(attributesNamingEnumeration);\n        when(attributesNamingEnumeration.hasMore()).thenReturn(true, false);\n        when(attributesNamingEnumeration.next()).thenReturn(attribute);\n        final String attributeId = \"uid\";\n        when(attribute.getID()).thenReturn(attributeId);\n        final String attributeValue = \"some value\";\n        when(attribute.get()).thenReturn(attributeValue);\n        when(attribute.size()).thenReturn(1);\n\n        final String tag = \"tag\";\n        final LdapConfigurationStore ldapConfigurationStore = new LdapConfigurationStore(new LdapConfigurationStore(),\n                attributes, tag);\n        final Collection<TaggedPropertySet> taggedPropertySets = ldapConfigurationStore.parseConfiguration();\n        assertEquals(1, taggedPropertySets.size());\n\n        final TaggedPropertySet taggedPropertySet = taggedPropertySets.iterator().next();\n        assertEquals(tag, taggedPropertySet.tag());\n\n        verify(attributes).getAll();\n        verify(attributesNamingEnumeration, times(2)).hasMore();\n        verify(attributesNamingEnumeration).next();\n        verify(attribute, times(2)).getID();\n        verify(attribute).get();\n        verify(attribute).size();\n    }\n\n    @Test\n    public void testParseConfigurationSimpleValue() throws Exception {\n        when(attributes.getAll()).thenReturn(attributesNamingEnumeration);\n        when(attributesNamingEnumeration.hasMore()).thenReturn(true, false);\n        when(attributesNamingEnumeration.next()).thenReturn(attribute);\n        final String attributeId = \"uid\";\n        when(attribute.getID()).thenReturn(attributeId);\n        final String attributeValue = \"some value\";\n        when(attribute.get()).thenReturn(attributeValue);\n        when(attribute.size()).thenReturn(1);\n\n        final LdapConfigurationStore ldapConfigurationStore = new LdapConfigurationStore(new LdapConfigurationStore(),\n                attributes);\n\n        final ConstrettoConfiguration constrettoConfiguration = createConfigurationForLdapConfigurationStore(ldapConfigurationStore);\n        assertTrue(constrettoConfiguration.hasValue(attributeId));\n        assertEquals(attributeValue, constrettoConfiguration.evaluateToString(attributeId));\n\n        verify(attributes).getAll();\n        verify(attributesNamingEnumeration, times(2)).hasMore();\n        verify(attributesNamingEnumeration).next();\n        verify(attribute, times(2)).getID();\n        verify(attribute).get();\n        verify(attribute).size();\n    }\n\n    @Test\n    public void testParseConfigurationMultiValue() throws Exception {\n        when(attributes.getAll()).thenReturn(attributesNamingEnumeration);\n        when(attributesNamingEnumeration.hasMore()).thenReturn(true, false);\n        when(attributesNamingEnumeration.next()).thenReturn(attribute);\n        final String attributeName = \"uniqueMember\";\n        when(attribute.getID()).thenReturn(attributeName);\n        final List<String> attributeValues = Arrays.asList(\"cn=Kaare Nilsen,dc=constretto,dc=org\",\n                \"cn=Jon-Anders Teigen,dc=constretto,dc=org\");\n        when(attribute.get()).thenReturn(attributeValues);\n        when(attribute.size()).thenReturn(attributeValues.size());\n        when(attribute.get(anyInt())).thenReturn(attributeValues.get(0), attributeValues.get(1));\n\n        final LdapConfigurationStore ldapConfigurationStore = new LdapConfigurationStore(new LdapConfigurationStore(),\n                attributes);\n        final ConstrettoConfiguration constrettoConfiguration = createConfigurationForLdapConfigurationStore(ldapConfigurationStore);\n        assertTrue(constrettoConfiguration.hasValue(attributeName));\n        assertEquals(2, constrettoConfiguration.evaluateToList(String.class, attributeName).size());\n\n        verify(attributes).getAll();\n        verify(attributesNamingEnumeration, times(2)).hasMore();\n        verify(attributesNamingEnumeration).next();\n        verify(attribute, times(2)).getID();\n        verify(attribute).size();\n        verify(attribute).get(eq(0));\n        verify(attribute).get(eq(1));\n    }\n\n    private ConstrettoConfiguration createConfigurationForLdapConfigurationStore(LdapConfigurationStore ldapConfigurationStore) {\n        return new ConstrettoBuilder(false)\n                    .addConfigurationStore(ldapConfigurationStore)\n                    .getConfiguration();\n    }\n\n    @After\n    public void tearDown() throws Exception {\n        verifyNoMoreInteractions(attributes, attributesNamingEnumeration, attribute);\n\n    }\n}\n","lineNo":126}
{"Smelly Sample":"package org.constretto.ldap;\n\nimport org.constretto.exception.ConstrettoException;\nimport org.constretto.model.ConfigurationValue;\nimport org.constretto.model.TaggedPropertySet;\nimport org.junit.After;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.Mock;\nimport org.mockito.runners.MockitoJUnitRunner;\n\nimport javax.naming.NamingEnumeration;\nimport javax.naming.NamingException;\nimport javax.naming.directory.Attribute;\nimport javax.naming.directory.Attributes;\nimport java.util.Collection;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.mockito.Mockito.*;\n\n/**\n * @author zapodot\n */\n@RunWith(MockitoJUnitRunner.class)\npublic class LdapConfigurationStoreTest {\n\n    @Mock\n    private Attributes attributes;\n    @Mock\n    private Attribute attribute;\n    @Mock\n    private NamingEnumeration attributesNamingEnumeration;\n    private LdapConfigurationStore parentLdapConfigurationStore = new LdapConfigurationStore();\n\n    @Test(expected = ConstrettoException.class)\n    public void testParseConfigurationAttributesReadFailed() throws Exception {\n\n        when(attributes.getAll()).thenReturn(attributesNamingEnumeration);\n        when(attributesNamingEnumeration.hasMore()).thenThrow(new NamingException());\n        try {\n            final LdapConfigurationStore ldapConfigurationStore = new LdapConfigurationStore(\n                    parentLdapConfigurationStore,\n                    attributes);\n            ldapConfigurationStore.parseConfiguration();\n\n        } finally {\n            verify(attributes).getAll();\n            verify(attributesNamingEnumeration).hasMore();\n        }\n    }\n\n    @Test\n    public void testParseConfigurationDefaultConstructor() throws Exception {\n        final Collection<TaggedPropertySet> taggedPropertySets = new LdapConfigurationStore().parseConfiguration();\n        assertEquals(1, taggedPropertySets.size());\n        assertEquals(ConfigurationValue.DEFAULT_TAG, taggedPropertySets.iterator().next().tag());\n\n    }\n\n    @Test\n    public void testParseConfigurationTagsNoValues() throws Exception {\n        when(attributes.getAll()).thenReturn(attributesNamingEnumeration);\n        when(attributesNamingEnumeration.hasMore()).thenReturn(false);\n\n        final Collection<TaggedPropertySet> taggedPropertySets = new LdapConfigurationStore(new LdapConfigurationStore(),\n                attributes).parseConfiguration();\n\n        assertEquals(1, taggedPropertySets.size());\n        assertEquals(ConfigurationValue.DEFAULT_TAG, taggedPropertySets.iterator().next().tag());\n\n        verify(attributes).getAll();\n        verify(attributesNamingEnumeration).hasMore();\n    }\n\n    @Test\n    public void testParseConfigurationDefaultTagPassword() throws Exception {\n        when(attributes.getAll()).thenReturn(attributesNamingEnumeration);\n        when(attributesNamingEnumeration.hasMore()).thenReturn(true, false);\n        when(attributesNamingEnumeration.next()).thenReturn(attribute);\n        when(attribute.getID()).thenReturn(\"password\");\n\n        final Collection<TaggedPropertySet> taggedPropertySets = new LdapConfigurationStore(new LdapConfigurationStore(),\n                attributes).parseConfiguration();\n        assertEquals(1, taggedPropertySets.size());\n        assertEquals(ConfigurationValue.DEFAULT_TAG, taggedPropertySets.iterator().next().tag());\n\n        verify(attributes).getAll();\n        verify(attributesNamingEnumeration, times(2)).hasMore();\n        verify(attributesNamingEnumeration).next();\n        verify(attribute).getID();\n    }\n\n    @Test\n    public void testParseConfigurationTagsPassword() throws Exception {\n        when(attributes.getAll()).thenReturn(attributesNamingEnumeration);\n        when(attributesNamingEnumeration.hasMore()).thenReturn(true, false);\n        when(attributesNamingEnumeration.next()).thenReturn(attribute);\n        when(attribute.getID()).thenReturn(\"password\");\n\n        final String tag = \"tag\";\n        final Collection<TaggedPropertySet> taggedPropertySets = new LdapConfigurationStore(new LdapConfigurationStore(),\n                attributes, tag).parseConfiguration();\n        assertEquals(1, taggedPropertySets.size());\n        final TaggedPropertySet taggedPropertySet = taggedPropertySets.iterator().next();\n        assertEquals(tag, taggedPropertySet.tag());\n        assertEquals(0, taggedPropertySet.getProperties().size());\n\n        verify(attributes).getAll();\n        verify(attributesNamingEnumeration, times(2)).hasMore();\n        verify(attributesNamingEnumeration).next();\n        verify(attribute).getID();\n    }\n\n    @Test\n    public void testParseConfigurationTags() throws Exception {\n        when(attributes.getAll()).thenReturn(attributesNamingEnumeration);\n        when(attributesNamingEnumeration.hasMore()).thenReturn(true, false);\n        when(attributesNamingEnumeration.next()).thenReturn(attribute);\n        when(attribute.getID()).thenReturn(\"uid\");\n        when(attribute.get()).thenReturn(\"some value\");\n\n        final String tag = \"tag\";\n        final Collection<TaggedPropertySet> taggedPropertySets = new LdapConfigurationStore(new LdapConfigurationStore(),\n                attributes, tag).parseConfiguration();\n        assertEquals(1, taggedPropertySets.size());\n        assertEquals(tag, taggedPropertySets.iterator().next().tag());\n\n        verify(attributes).getAll();\n        verify(attributesNamingEnumeration, times(2)).hasMore();\n        verify(attributesNamingEnumeration).next();\n        verify(attribute, times(2)).getID();\n        verify(attribute).get();\n    }\n\n    @After\n    public void tearDown() throws Exception {\n        verifyNoMoreInteractions(attributes, attributesNamingEnumeration, attribute);\n\n    }\n}\n","Method after Refactoring":"package org.constretto.ldap;\n\nimport org.constretto.ConstrettoBuilder;\nimport org.constretto.ConstrettoConfiguration;\nimport org.constretto.exception.ConstrettoException;\nimport org.constretto.model.ConfigurationValue;\nimport org.constretto.model.TaggedPropertySet;\nimport org.junit.After;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.Mock;\nimport org.mockito.runners.MockitoJUnitRunner;\n\nimport javax.naming.NamingEnumeration;\nimport javax.naming.NamingException;\nimport javax.naming.directory.Attribute;\nimport javax.naming.directory.Attributes;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.List;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\nimport static org.mockito.Mockito.*;\n\n/**\n * @author zapodot\n */\n@RunWith(MockitoJUnitRunner.class)\npublic class LdapConfigurationStoreTest {\n\n    @Mock\n    private Attributes attributes;\n    @Mock\n    private Attribute attribute;\n    @Mock\n    private NamingEnumeration attributesNamingEnumeration;\n    private LdapConfigurationStore parentLdapConfigurationStore = new LdapConfigurationStore();\n\n    @Test(expected = ConstrettoException.class)\n    public void testParseConfigurationAttributesReadFailed() throws Exception {\n\n        when(attributes.getAll()).thenReturn(attributesNamingEnumeration);\n        when(attributesNamingEnumeration.hasMore()).thenThrow(new NamingException());\n        try {\n            final LdapConfigurationStore ldapConfigurationStore = new LdapConfigurationStore(\n                    parentLdapConfigurationStore,\n                    attributes);\n            ldapConfigurationStore.parseConfiguration();\n\n        } finally {\n            verify(attributes).getAll();\n            verify(attributesNamingEnumeration).hasMore();\n        }\n    }\n\n    @Test\n    public void testParseConfigurationDefaultConstructor() throws Exception {\n        final Collection<TaggedPropertySet> taggedPropertySets = new LdapConfigurationStore().parseConfiguration();\n        assertEquals(1, taggedPropertySets.size());\n        assertEquals(ConfigurationValue.DEFAULT_TAG, taggedPropertySets.iterator().next().tag());\n\n    }\n\n    @Test\n    public void testParseConfigurationTagsNoValues() throws Exception {\n        when(attributes.getAll()).thenReturn(attributesNamingEnumeration);\n        when(attributesNamingEnumeration.hasMore()).thenReturn(false);\n\n        final Collection<TaggedPropertySet> taggedPropertySets = new LdapConfigurationStore(new LdapConfigurationStore(),\n                attributes).parseConfiguration();\n\n        assertEquals(1, taggedPropertySets.size());\n        assertEquals(ConfigurationValue.DEFAULT_TAG, taggedPropertySets.iterator().next().tag());\n\n        verify(attributes).getAll();\n        verify(attributesNamingEnumeration).hasMore();\n    }\n\n    @Test\n    public void testParseConfigurationDefaultTagPassword() throws Exception {\n        when(attributes.getAll()).thenReturn(attributesNamingEnumeration);\n        when(attributesNamingEnumeration.hasMore()).thenReturn(true, false);\n        when(attributesNamingEnumeration.next()).thenReturn(attribute);\n        when(attribute.getID()).thenReturn(\"password\");\n\n        final Collection<TaggedPropertySet> taggedPropertySets = new LdapConfigurationStore(new LdapConfigurationStore(),\n                attributes).parseConfiguration();\n        assertEquals(1, taggedPropertySets.size());\n        assertEquals(ConfigurationValue.DEFAULT_TAG, taggedPropertySets.iterator().next().tag());\n\n        verify(attributes).getAll();\n        verify(attributesNamingEnumeration, times(2)).hasMore();\n        verify(attributesNamingEnumeration).next();\n        verify(attribute).getID();\n    }\n\n    @Test\n    public void testParseConfigurationTagsPassword() throws Exception {\n        when(attributes.getAll()).thenReturn(attributesNamingEnumeration);\n        when(attributesNamingEnumeration.hasMore()).thenReturn(true, false);\n        when(attributesNamingEnumeration.next()).thenReturn(attribute);\n        when(attribute.getID()).thenReturn(\"password\");\n\n        final String tag = \"tag\";\n        final Collection<TaggedPropertySet> taggedPropertySets = new LdapConfigurationStore(new LdapConfigurationStore(),\n                attributes, tag).parseConfiguration();\n        assertEquals(1, taggedPropertySets.size());\n        final TaggedPropertySet taggedPropertySet = taggedPropertySets.iterator().next();\n        assertEquals(tag, taggedPropertySet.tag());\n        assertEquals(0, taggedPropertySet.getProperties().size());\n\n        verify(attributes).getAll();\n        verify(attributesNamingEnumeration, times(2)).hasMore();\n        verify(attributesNamingEnumeration).next();\n        verify(attribute).getID();\n    }\n\n    @Test\n    public void testParseConfigurationTags() throws Exception {\n        when(attributes.getAll()).thenReturn(attributesNamingEnumeration);\n        when(attributesNamingEnumeration.hasMore()).thenReturn(true, false);\n        when(attributesNamingEnumeration.next()).thenReturn(attribute);\n        final String attributeId = \"uid\";\n        when(attribute.getID()).thenReturn(attributeId);\n        final String attributeValue = \"some value\";\n        when(attribute.get()).thenReturn(attributeValue);\n        when(attribute.size()).thenReturn(1);\n\n        final String tag = \"tag\";\n        final LdapConfigurationStore ldapConfigurationStore = new LdapConfigurationStore(new LdapConfigurationStore(),\n                attributes, tag);\n        final Collection<TaggedPropertySet> taggedPropertySets = ldapConfigurationStore.parseConfiguration();\n        assertEquals(1, taggedPropertySets.size());\n\n        final TaggedPropertySet taggedPropertySet = taggedPropertySets.iterator().next();\n        assertEquals(tag, taggedPropertySet.tag());\n\n        verify(attributes).getAll();\n        verify(attributesNamingEnumeration, times(2)).hasMore();\n        verify(attributesNamingEnumeration).next();\n        verify(attribute, times(2)).getID();\n        verify(attribute).get();\n        verify(attribute).size();\n    }\n\n    @Test\n    public void testParseConfigurationSimpleValue() throws Exception {\n        when(attributes.getAll()).thenReturn(attributesNamingEnumeration);\n        when(attributesNamingEnumeration.hasMore()).thenReturn(true, false);\n        when(attributesNamingEnumeration.next()).thenReturn(attribute);\n        final String attributeId = \"uid\";\n        when(attribute.getID()).thenReturn(attributeId);\n        final String attributeValue = \"some value\";\n        when(attribute.get()).thenReturn(attributeValue);\n        when(attribute.size()).thenReturn(1);\n\n        final LdapConfigurationStore ldapConfigurationStore = new LdapConfigurationStore(new LdapConfigurationStore(),\n                attributes);\n\n        final ConstrettoConfiguration constrettoConfiguration = createConfigurationForLdapConfigurationStore(ldapConfigurationStore);\n        assertTrue(constrettoConfiguration.hasValue(attributeId));\n        assertEquals(attributeValue, constrettoConfiguration.evaluateToString(attributeId));\n\n        verify(attributes).getAll();\n        verify(attributesNamingEnumeration, times(2)).hasMore();\n        verify(attributesNamingEnumeration).next();\n        verify(attribute, times(2)).getID();\n        verify(attribute).get();\n        verify(attribute).size();\n    }\n\n    @Test\n    public void testParseConfigurationMultiValue() throws Exception {\n        when(attributes.getAll()).thenReturn(attributesNamingEnumeration);\n        when(attributesNamingEnumeration.hasMore()).thenReturn(true, false);\n        when(attributesNamingEnumeration.next()).thenReturn(attribute);\n        final String attributeName = \"uniqueMember\";\n        when(attribute.getID()).thenReturn(attributeName);\n        final List<String> attributeValues = Arrays.asList(\"cn=Kaare Nilsen,dc=constretto,dc=org\",\n                \"cn=Jon-Anders Teigen,dc=constretto,dc=org\");\n        when(attribute.get()).thenReturn(attributeValues);\n        when(attribute.size()).thenReturn(attributeValues.size());\n        when(attribute.get(anyInt())).thenReturn(attributeValues.get(0), attributeValues.get(1));\n\n        final LdapConfigurationStore ldapConfigurationStore = new LdapConfigurationStore(new LdapConfigurationStore(),\n                attributes);\n        final ConstrettoConfiguration constrettoConfiguration = createConfigurationForLdapConfigurationStore(ldapConfigurationStore);\n        assertTrue(constrettoConfiguration.hasValue(attributeName));\n        assertEquals(2, constrettoConfiguration.evaluateToList(String.class, attributeName).size());\n\n        verify(attributes).getAll();\n        verify(attributesNamingEnumeration, times(2)).hasMore();\n        verify(attributesNamingEnumeration).next();\n        verify(attribute, times(2)).getID();\n        verify(attribute).size();\n        verify(attribute).get(eq(0));\n        verify(attribute).get(eq(1));\n    }\n\n    private ConstrettoConfiguration createConfigurationForLdapConfigurationStore(LdapConfigurationStore ldapConfigurationStore) {\n        return new ConstrettoBuilder(false)\n                    .addConfigurationStore(ldapConfigurationStore)\n                    .getConfiguration();\n    }\n\n    @After\n    public void tearDown() throws Exception {\n        verifyNoMoreInteractions(attributes, attributesNamingEnumeration, attribute);\n\n    }\n}\n","lineNo":131}
{"Smelly Sample":"package org.constretto.ldap;\n\nimport org.constretto.exception.ConstrettoException;\nimport org.constretto.model.ConfigurationValue;\nimport org.constretto.model.TaggedPropertySet;\nimport org.junit.After;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.Mock;\nimport org.mockito.runners.MockitoJUnitRunner;\n\nimport javax.naming.NamingEnumeration;\nimport javax.naming.NamingException;\nimport javax.naming.directory.Attribute;\nimport javax.naming.directory.Attributes;\nimport java.util.Collection;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.mockito.Mockito.*;\n\n/**\n * @author zapodot\n */\n@RunWith(MockitoJUnitRunner.class)\npublic class LdapConfigurationStoreTest {\n\n    @Mock\n    private Attributes attributes;\n    @Mock\n    private Attribute attribute;\n    @Mock\n    private NamingEnumeration attributesNamingEnumeration;\n    private LdapConfigurationStore parentLdapConfigurationStore = new LdapConfigurationStore();\n\n    @Test(expected = ConstrettoException.class)\n    public void testParseConfigurationAttributesReadFailed() throws Exception {\n\n        when(attributes.getAll()).thenReturn(attributesNamingEnumeration);\n        when(attributesNamingEnumeration.hasMore()).thenThrow(new NamingException());\n        try {\n            final LdapConfigurationStore ldapConfigurationStore = new LdapConfigurationStore(\n                    parentLdapConfigurationStore,\n                    attributes);\n            ldapConfigurationStore.parseConfiguration();\n\n        } finally {\n            verify(attributes).getAll();\n            verify(attributesNamingEnumeration).hasMore();\n        }\n    }\n\n    @Test\n    public void testParseConfigurationDefaultConstructor() throws Exception {\n        final Collection<TaggedPropertySet> taggedPropertySets = new LdapConfigurationStore().parseConfiguration();\n        assertEquals(1, taggedPropertySets.size());\n        assertEquals(ConfigurationValue.DEFAULT_TAG, taggedPropertySets.iterator().next().tag());\n\n    }\n\n    @Test\n    public void testParseConfigurationTagsNoValues() throws Exception {\n        when(attributes.getAll()).thenReturn(attributesNamingEnumeration);\n        when(attributesNamingEnumeration.hasMore()).thenReturn(false);\n\n        final Collection<TaggedPropertySet> taggedPropertySets = new LdapConfigurationStore(new LdapConfigurationStore(),\n                attributes).parseConfiguration();\n\n        assertEquals(1, taggedPropertySets.size());\n        assertEquals(ConfigurationValue.DEFAULT_TAG, taggedPropertySets.iterator().next().tag());\n\n        verify(attributes).getAll();\n        verify(attributesNamingEnumeration).hasMore();\n    }\n\n    @Test\n    public void testParseConfigurationDefaultTagPassword() throws Exception {\n        when(attributes.getAll()).thenReturn(attributesNamingEnumeration);\n        when(attributesNamingEnumeration.hasMore()).thenReturn(true, false);\n        when(attributesNamingEnumeration.next()).thenReturn(attribute);\n        when(attribute.getID()).thenReturn(\"password\");\n\n        final Collection<TaggedPropertySet> taggedPropertySets = new LdapConfigurationStore(new LdapConfigurationStore(),\n                attributes).parseConfiguration();\n        assertEquals(1, taggedPropertySets.size());\n        assertEquals(ConfigurationValue.DEFAULT_TAG, taggedPropertySets.iterator().next().tag());\n\n        verify(attributes).getAll();\n        verify(attributesNamingEnumeration, times(2)).hasMore();\n        verify(attributesNamingEnumeration).next();\n        verify(attribute).getID();\n    }\n\n    @Test\n    public void testParseConfigurationTagsPassword() throws Exception {\n        when(attributes.getAll()).thenReturn(attributesNamingEnumeration);\n        when(attributesNamingEnumeration.hasMore()).thenReturn(true, false);\n        when(attributesNamingEnumeration.next()).thenReturn(attribute);\n        when(attribute.getID()).thenReturn(\"password\");\n\n        final String tag = \"tag\";\n        final Collection<TaggedPropertySet> taggedPropertySets = new LdapConfigurationStore(new LdapConfigurationStore(),\n                attributes, tag).parseConfiguration();\n        assertEquals(1, taggedPropertySets.size());\n        final TaggedPropertySet taggedPropertySet = taggedPropertySets.iterator().next();\n        assertEquals(tag, taggedPropertySet.tag());\n        assertEquals(0, taggedPropertySet.getProperties().size());\n\n        verify(attributes).getAll();\n        verify(attributesNamingEnumeration, times(2)).hasMore();\n        verify(attributesNamingEnumeration).next();\n        verify(attribute).getID();\n    }\n\n    @Test\n    public void testParseConfigurationTags() throws Exception {\n        when(attributes.getAll()).thenReturn(attributesNamingEnumeration);\n        when(attributesNamingEnumeration.hasMore()).thenReturn(true, false);\n        when(attributesNamingEnumeration.next()).thenReturn(attribute);\n        when(attribute.getID()).thenReturn(\"uid\");\n        when(attribute.get()).thenReturn(\"some value\");\n\n        final String tag = \"tag\";\n        final Collection<TaggedPropertySet> taggedPropertySets = new LdapConfigurationStore(new LdapConfigurationStore(),\n                attributes, tag).parseConfiguration();\n        assertEquals(1, taggedPropertySets.size());\n        assertEquals(tag, taggedPropertySets.iterator().next().tag());\n\n        verify(attributes).getAll();\n        verify(attributesNamingEnumeration, times(2)).hasMore();\n        verify(attributesNamingEnumeration).next();\n        verify(attribute, times(2)).getID();\n        verify(attribute).get();\n    }\n\n    @After\n    public void tearDown() throws Exception {\n        verifyNoMoreInteractions(attributes, attributesNamingEnumeration, attribute);\n\n    }\n}\n","Method after Refactoring":"package org.constretto.ldap;\n\nimport org.constretto.ConstrettoBuilder;\nimport org.constretto.ConstrettoConfiguration;\nimport org.constretto.exception.ConstrettoException;\nimport org.constretto.model.ConfigurationValue;\nimport org.constretto.model.TaggedPropertySet;\nimport org.junit.After;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.Mock;\nimport org.mockito.runners.MockitoJUnitRunner;\n\nimport javax.naming.NamingEnumeration;\nimport javax.naming.NamingException;\nimport javax.naming.directory.Attribute;\nimport javax.naming.directory.Attributes;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.List;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\nimport static org.mockito.Mockito.*;\n\n/**\n * @author zapodot\n */\n@RunWith(MockitoJUnitRunner.class)\npublic class LdapConfigurationStoreTest {\n\n    @Mock\n    private Attributes attributes;\n    @Mock\n    private Attribute attribute;\n    @Mock\n    private NamingEnumeration attributesNamingEnumeration;\n    private LdapConfigurationStore parentLdapConfigurationStore = new LdapConfigurationStore();\n\n    @Test(expected = ConstrettoException.class)\n    public void testParseConfigurationAttributesReadFailed() throws Exception {\n\n        when(attributes.getAll()).thenReturn(attributesNamingEnumeration);\n        when(attributesNamingEnumeration.hasMore()).thenThrow(new NamingException());\n        try {\n            final LdapConfigurationStore ldapConfigurationStore = new LdapConfigurationStore(\n                    parentLdapConfigurationStore,\n                    attributes);\n            ldapConfigurationStore.parseConfiguration();\n\n        } finally {\n            verify(attributes).getAll();\n            verify(attributesNamingEnumeration).hasMore();\n        }\n    }\n\n    @Test\n    public void testParseConfigurationDefaultConstructor() throws Exception {\n        final Collection<TaggedPropertySet> taggedPropertySets = new LdapConfigurationStore().parseConfiguration();\n        assertEquals(1, taggedPropertySets.size());\n        assertEquals(ConfigurationValue.DEFAULT_TAG, taggedPropertySets.iterator().next().tag());\n\n    }\n\n    @Test\n    public void testParseConfigurationTagsNoValues() throws Exception {\n        when(attributes.getAll()).thenReturn(attributesNamingEnumeration);\n        when(attributesNamingEnumeration.hasMore()).thenReturn(false);\n\n        final Collection<TaggedPropertySet> taggedPropertySets = new LdapConfigurationStore(new LdapConfigurationStore(),\n                attributes).parseConfiguration();\n\n        assertEquals(1, taggedPropertySets.size());\n        assertEquals(ConfigurationValue.DEFAULT_TAG, taggedPropertySets.iterator().next().tag());\n\n        verify(attributes).getAll();\n        verify(attributesNamingEnumeration).hasMore();\n    }\n\n    @Test\n    public void testParseConfigurationDefaultTagPassword() throws Exception {\n        when(attributes.getAll()).thenReturn(attributesNamingEnumeration);\n        when(attributesNamingEnumeration.hasMore()).thenReturn(true, false);\n        when(attributesNamingEnumeration.next()).thenReturn(attribute);\n        when(attribute.getID()).thenReturn(\"password\");\n\n        final Collection<TaggedPropertySet> taggedPropertySets = new LdapConfigurationStore(new LdapConfigurationStore(),\n                attributes).parseConfiguration();\n        assertEquals(1, taggedPropertySets.size());\n        assertEquals(ConfigurationValue.DEFAULT_TAG, taggedPropertySets.iterator().next().tag());\n\n        verify(attributes).getAll();\n        verify(attributesNamingEnumeration, times(2)).hasMore();\n        verify(attributesNamingEnumeration).next();\n        verify(attribute).getID();\n    }\n\n    @Test\n    public void testParseConfigurationTagsPassword() throws Exception {\n        when(attributes.getAll()).thenReturn(attributesNamingEnumeration);\n        when(attributesNamingEnumeration.hasMore()).thenReturn(true, false);\n        when(attributesNamingEnumeration.next()).thenReturn(attribute);\n        when(attribute.getID()).thenReturn(\"password\");\n\n        final String tag = \"tag\";\n        final Collection<TaggedPropertySet> taggedPropertySets = new LdapConfigurationStore(new LdapConfigurationStore(),\n                attributes, tag).parseConfiguration();\n        assertEquals(1, taggedPropertySets.size());\n        final TaggedPropertySet taggedPropertySet = taggedPropertySets.iterator().next();\n        assertEquals(tag, taggedPropertySet.tag());\n        assertEquals(0, taggedPropertySet.getProperties().size());\n\n        verify(attributes).getAll();\n        verify(attributesNamingEnumeration, times(2)).hasMore();\n        verify(attributesNamingEnumeration).next();\n        verify(attribute).getID();\n    }\n\n    @Test\n    public void testParseConfigurationTags() throws Exception {\n        when(attributes.getAll()).thenReturn(attributesNamingEnumeration);\n        when(attributesNamingEnumeration.hasMore()).thenReturn(true, false);\n        when(attributesNamingEnumeration.next()).thenReturn(attribute);\n        final String attributeId = \"uid\";\n        when(attribute.getID()).thenReturn(attributeId);\n        final String attributeValue = \"some value\";\n        when(attribute.get()).thenReturn(attributeValue);\n        when(attribute.size()).thenReturn(1);\n\n        final String tag = \"tag\";\n        final LdapConfigurationStore ldapConfigurationStore = new LdapConfigurationStore(new LdapConfigurationStore(),\n                attributes, tag);\n        final Collection<TaggedPropertySet> taggedPropertySets = ldapConfigurationStore.parseConfiguration();\n        assertEquals(1, taggedPropertySets.size());\n\n        final TaggedPropertySet taggedPropertySet = taggedPropertySets.iterator().next();\n        assertEquals(tag, taggedPropertySet.tag());\n\n        verify(attributes).getAll();\n        verify(attributesNamingEnumeration, times(2)).hasMore();\n        verify(attributesNamingEnumeration).next();\n        verify(attribute, times(2)).getID();\n        verify(attribute).get();\n        verify(attribute).size();\n    }\n\n    @Test\n    public void testParseConfigurationSimpleValue() throws Exception {\n        when(attributes.getAll()).thenReturn(attributesNamingEnumeration);\n        when(attributesNamingEnumeration.hasMore()).thenReturn(true, false);\n        when(attributesNamingEnumeration.next()).thenReturn(attribute);\n        final String attributeId = \"uid\";\n        when(attribute.getID()).thenReturn(attributeId);\n        final String attributeValue = \"some value\";\n        when(attribute.get()).thenReturn(attributeValue);\n        when(attribute.size()).thenReturn(1);\n\n        final LdapConfigurationStore ldapConfigurationStore = new LdapConfigurationStore(new LdapConfigurationStore(),\n                attributes);\n\n        final ConstrettoConfiguration constrettoConfiguration = createConfigurationForLdapConfigurationStore(ldapConfigurationStore);\n        assertTrue(constrettoConfiguration.hasValue(attributeId));\n        assertEquals(attributeValue, constrettoConfiguration.evaluateToString(attributeId));\n\n        verify(attributes).getAll();\n        verify(attributesNamingEnumeration, times(2)).hasMore();\n        verify(attributesNamingEnumeration).next();\n        verify(attribute, times(2)).getID();\n        verify(attribute).get();\n        verify(attribute).size();\n    }\n\n    @Test\n    public void testParseConfigurationMultiValue() throws Exception {\n        when(attributes.getAll()).thenReturn(attributesNamingEnumeration);\n        when(attributesNamingEnumeration.hasMore()).thenReturn(true, false);\n        when(attributesNamingEnumeration.next()).thenReturn(attribute);\n        final String attributeName = \"uniqueMember\";\n        when(attribute.getID()).thenReturn(attributeName);\n        final List<String> attributeValues = Arrays.asList(\"cn=Kaare Nilsen,dc=constretto,dc=org\",\n                \"cn=Jon-Anders Teigen,dc=constretto,dc=org\");\n        when(attribute.get()).thenReturn(attributeValues);\n        when(attribute.size()).thenReturn(attributeValues.size());\n        when(attribute.get(anyInt())).thenReturn(attributeValues.get(0), attributeValues.get(1));\n\n        final LdapConfigurationStore ldapConfigurationStore = new LdapConfigurationStore(new LdapConfigurationStore(),\n                attributes);\n        final ConstrettoConfiguration constrettoConfiguration = createConfigurationForLdapConfigurationStore(ldapConfigurationStore);\n        assertTrue(constrettoConfiguration.hasValue(attributeName));\n        assertEquals(2, constrettoConfiguration.evaluateToList(String.class, attributeName).size());\n\n        verify(attributes).getAll();\n        verify(attributesNamingEnumeration, times(2)).hasMore();\n        verify(attributesNamingEnumeration).next();\n        verify(attribute, times(2)).getID();\n        verify(attribute).size();\n        verify(attribute).get(eq(0));\n        verify(attribute).get(eq(1));\n    }\n\n    private ConstrettoConfiguration createConfigurationForLdapConfigurationStore(LdapConfigurationStore ldapConfigurationStore) {\n        return new ConstrettoBuilder(false)\n                    .addConfigurationStore(ldapConfigurationStore)\n                    .getConfiguration();\n    }\n\n    @After\n    public void tearDown() throws Exception {\n        verifyNoMoreInteractions(attributes, attributesNamingEnumeration, attribute);\n\n    }\n}\n","lineNo":136}
{"Smelly Sample":"/*\n * Copyright 2008 the original author or authors. Licensed under the Apache\n * License, Version 2.0 (the \"License\"); you may not use this file except in\n * compliance with the License. You may obtain a copy of the License at\n * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law\n * or agreed to in writing, software distributed under the License is\n * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\npackage org.constretto.model;\n\nimport java.io.InputStream;\n\n/**\n * @author <a href=\"mailto:kaare.nilsen@gmail.com\">Kaare Nilsen<\/a>\n */\npublic class ClassPathResource extends Resource {\n    public ClassPathResource(String path) {\n        super(path);\n    }\n\n    @Override\n    public InputStream getInputStream() {\n        ClassLoader classLoader = this.getClass().getClassLoader();\n        String location;\n        if (path.startsWith(CLASSPATH_PREFIX)) {\n            location = path.substring(CLASSPATH_PREFIX.length(), path.length());\n        } else {\n            location = path;\n        }\n        return classLoader.getResourceAsStream(location);\n    }\n\n    @Override\n    public boolean exists() {\n        return getInputStream() != null;\n    }\n}\n","Method after Refactoring":"/*\n * Copyright 2008 the original author or authors. Licensed under the Apache\n * License, Version 2.0 (the \"License\"); you may not use this file except in\n * compliance with the License. You may obtain a copy of the License at\n * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law\n * or agreed to in writing, software distributed under the License is\n * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\npackage org.constretto.model;\n\nimport java.io.InputStream;\n\n/**\n * @author <a href=\"mailto:kaare.nilsen@gmail.com\">Kaare Nilsen<\/a>\n */\npublic class ClassPathResource extends Resource {\n    public ClassPathResource(String path) {\n        super(path);\n    }\n\n    @Override\n    public InputStream getInputStream() {\n        ClassLoader classLoader = this.getClass().getClassLoader();\n        String location;\n        if (path.startsWith(CLASSPATH_PREFIX)) {\n            location = path.substring(CLASSPATH_PREFIX.length(), path.length());\n        } else {\n            location = path;\n        }\n        return classLoader.getResourceAsStream(location);\n    }\n\n    @Override\n    public boolean exists() {\n        InputStream is = getInputStream();\n        boolean result = is != null;\n        try{\n            is.close();\n        } catch (Exception e) {\n        }\n        return result;\n    }\n}\n","lineNo":37}
{"Smelly Sample":"/*\n * Copyright 2008 the original author or authors. Licensed under the Apache\n * License, Version 2.0 (the \"License\"); you may not use this file except in\n * compliance with the License. You may obtain a copy of the License at\n * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law\n * or agreed to in writing, software distributed under the License is\n * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\npackage org.constretto.model;\n\nimport java.io.InputStream;\n\n/**\n * @author <a href=\"mailto:kaare.nilsen@gmail.com\">Kaare Nilsen<\/a>\n */\npublic class ClassPathResource extends Resource {\n    public ClassPathResource(String path) {\n        super(path);\n    }\n\n    @Override\n    public InputStream getInputStream() {\n        ClassLoader classLoader = this.getClass().getClassLoader();\n        String location;\n        if (path.startsWith(CLASSPATH_PREFIX)) {\n            location = path.substring(CLASSPATH_PREFIX.length(), path.length());\n        } else {\n            location = path;\n        }\n        return classLoader.getResourceAsStream(location);\n    }\n\n    @Override\n    public boolean exists() {\n        return getInputStream() != null;\n    }\n}\n","Method after Refactoring":"/*\n * Copyright 2008 the original author or authors. Licensed under the Apache\n * License, Version 2.0 (the \"License\"); you may not use this file except in\n * compliance with the License. You may obtain a copy of the License at\n * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law\n * or agreed to in writing, software distributed under the License is\n * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\npackage org.constretto.model;\n\nimport java.io.InputStream;\n\n/**\n * @author <a href=\"mailto:kaare.nilsen@gmail.com\">Kaare Nilsen<\/a>\n */\npublic class ClassPathResource extends Resource {\n    public ClassPathResource(String path) {\n        super(path);\n    }\n\n    @Override\n    public InputStream getInputStream() {\n        ClassLoader classLoader = this.getClass().getClassLoader();\n        String location;\n        if (path.startsWith(CLASSPATH_PREFIX)) {\n            location = path.substring(CLASSPATH_PREFIX.length(), path.length());\n        } else {\n            location = path;\n        }\n        return classLoader.getResourceAsStream(location);\n    }\n\n    @Override\n    public boolean exists() {\n        InputStream is = getInputStream();\n        boolean result = is != null;\n        try{\n            is.close();\n        } catch (Exception e) {\n        }\n        return result;\n    }\n}\n","lineNo":37}
{"Smelly Sample":"/*\n * Copyright 2008 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.constretto.internal;\n\nimport org.constretto.ConfigurationDefaultValueFactory;\nimport org.constretto.ConstrettoConfiguration;\nimport org.constretto.Property;\nimport org.constretto.annotation.Configuration;\nimport org.constretto.annotation.Configure;\nimport org.constretto.annotation.Tags;\nimport org.constretto.exception.ConstrettoConversionException;\nimport org.constretto.exception.ConstrettoException;\nimport org.constretto.exception.ConstrettoExpressionException;\nimport org.constretto.internal.converter.ValueConverterRegistry;\nimport org.constretto.model.ConfigurationNode;\nimport org.springframework.core.LocalVariableTableParameterNameDiscoverer;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.*;\n\n/**\n * @author <a href=\"mailto:kaare.nilsen@gmail.com\">Kaare Nilsen<\/a>\n */\npublic class DefaultConstrettoConfiguration implements ConstrettoConfiguration {\n    private static final String NULL_STRING = \"![![Null]!]!\";\n    private static final String VARIABLE_PREFIX = \"#{\";\n    private static final String VARIABLE_SUFFIX = \"}\";\n    private List<String> currentTags;\n    private final ConfigurationNode configuration;\n    private LocalVariableTableParameterNameDiscoverer nameDiscoverer = new LocalVariableTableParameterNameDiscoverer();\n\n    public DefaultConstrettoConfiguration(ConfigurationNode configuration, List<String> currentTags) {\n        this.configuration = configuration;\n        this.currentTags = currentTags;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public <K> K evaluateTo(String expression, K defaultValue) {\n        if (!hasValue(expression)) {\n            return defaultValue;\n        }\n        K value;\n        try {\n            value = (K) processAndConvert(defaultValue.getClass(), expression);\n        } catch (ConstrettoConversionException e) {\n            value = null;\n        }\n        return null != value ? value : defaultValue;\n    }\n\n    public <K> K evaluateTo(Class<K> targetClass, String expression) throws ConstrettoExpressionException {\n        return processAndConvert(targetClass, expression);\n    }\n\n    public String evaluateToString(String expression) throws ConstrettoExpressionException {\n        return processAndConvert(String.class, expression);\n    }\n\n    public Boolean evaluateToBoolean(String expression) throws ConstrettoExpressionException {\n        return processAndConvert(Boolean.class, expression);\n    }\n\n    public Double evaluateToDouble(String expression) throws ConstrettoExpressionException {\n        return processAndConvert(Double.class, expression);\n    }\n\n    public Long evaluateToLong(String expression) throws ConstrettoExpressionException {\n        return processAndConvert(Long.class, expression);\n    }\n\n    public Float evaluateToFloat(String expression) throws ConstrettoExpressionException {\n        return processAndConvert(Float.class, expression);\n    }\n\n    public Integer evaluateToInt(String expression) throws ConstrettoExpressionException {\n        return processAndConvert(Integer.class, expression);\n    }\n\n    public Short evaluateToShort(String expression) throws ConstrettoExpressionException {\n        return processAndConvert(Short.class, expression);\n    }\n\n    public Byte evaluateToByte(String expression) throws ConstrettoExpressionException {\n        return processAndConvert(Byte.class, expression);\n    }\n\n    public <T> T as(Class<T> configurationClass) throws ConstrettoException {\n        T objectToConfigure;\n        try {\n            objectToConfigure = configurationClass.newInstance();\n        } catch (Exception e) {\n            throw new ConstrettoException(\"Could not instansiate class of type: \" + configurationClass.getName()\n                    + \" when trying to inject it with configuration, It may be missing a default constructor\", e);\n        }\n\n        injectConfiguration(objectToConfigure);\n\n        return objectToConfigure;\n    }\n\n    public <T> T on(T objectToConfigure) throws ConstrettoException {\n        injectConfiguration(objectToConfigure);\n        return objectToConfigure;\n    }\n\n    public ConstrettoConfiguration at(String expression) throws ConstrettoException {\n        ConfigurationNode currentConfigurationNode = findElementOrThrowException(expression);\n        ConfigurationNode.createRootElementOf(currentConfigurationNode);\n        return new DefaultConstrettoConfiguration(currentConfigurationNode, currentTags);\n    }\n\n    public ConstrettoConfiguration from(String expression) throws ConstrettoException {\n        return at(expression);\n    }\n\n    public boolean hasValue(String expression) {\n        ConfigurationNode node = findElementOrNull(expression);\n        return null != node;\n    }\n\n    public Iterator<Property> iterator() {\n        List<Property> properties = new ArrayList<Property>();\n        Map<String,String> map = asMap();\n        for (Map.Entry<String, String> entry : map.entrySet()) {\n            properties.add(new Property(entry.getKey(),entry.getValue()));                        \n        }\n        return properties.iterator();\n    }\n\n     private Map<String,String> asMap(){\n        Map<String,String> properties = new HashMap<String,String>();\n        extractProperties(configuration,properties);\n        return properties;\n    }\n\n    private void extractProperties(ConfigurationNode currentNode, Map<String, String> properties) {\n        String value = evaluateTo(currentNode.getExpression(),NULL_STRING);\n        if (!value.equals(NULL_STRING)){\n            properties.put(currentNode.getExpression(),value);\n        }\n        if (currentNode.hasChildren()){\n            for (ConfigurationNode child : currentNode.children()) {\n                extractProperties(child,properties);\n            }\n        }\n    }\n\n    //\n    // Helper methods\n    //\n    private ConfigurationNode findElementOrThrowException(String expression) {\n        List<ConfigurationNode> node = configuration.findAllBy(expression);\n        ConfigurationNode resolvedNode = resolveMatch(node);\n        if (resolvedNode == null) {\n            throw new ConstrettoExpressionException(expression, currentTags);\n        }\n        return resolvedNode;\n    }\n\n    private <T> T processAndConvert(Class<T> clazz, String expression) throws ConstrettoException {\n        String parsedValue = processVariablesInProperty(expression, new ArrayList<String>());\n        return ValueConverterRegistry.convert(clazz, parsedValue);\n    }\n\n    private ConfigurationNode findElementOrNull(String expression) {\n        List<ConfigurationNode> node = configuration.findAllBy(expression);\n        return resolveMatch(node);\n    }\n\n    private ConfigurationNode resolveMatch(List<ConfigurationNode> node) {\n        ConfigurationNode bestMatch = null;\n        for (ConfigurationNode configurationNode : node) {\n            if (ConfigurationNode.DEFAULT_TAG.equals(configurationNode.getTag())) {\n                if (bestMatch == null || bestMatch.getTag().equals(ConfigurationNode.DEFAULT_TAG)) {\n                    bestMatch = configurationNode;\n                }\n            } else if (currentTags.contains(configurationNode.getTag())) {\n                if (bestMatch == null) {\n                    bestMatch = configurationNode;\n                } else {\n                    int previousFoundPriority =\n                            ConfigurationNode.DEFAULT_TAG.equals(bestMatch.getTag()) ?\n                                    Integer.MAX_VALUE : currentTags.indexOf(bestMatch.getTag());\n                    if (currentTags.indexOf(configurationNode.getTag()) <= previousFoundPriority) {\n                        bestMatch = configurationNode;\n                    }\n                }\n            } else if (ConfigurationNode.ALL_TAG.equals(configurationNode.getTag())) {\n                bestMatch = configurationNode;\n            }\n        }\n        return bestMatch;\n    }\n\n    private <T> void injectConfiguration(T objectToConfigure) {\n        injectFields(objectToConfigure);\n        injectMethods(objectToConfigure);\n    }\n\n    private <T> void injectMethods(T objectToConfigure) {\n        Method[] methods = objectToConfigure.getClass().getMethods();\n        for (Method method : methods) {\n            try {\n                if (method.isAnnotationPresent(Configure.class)) {\n                    Annotation[][] methodAnnotations = method.getParameterAnnotations();\n                    String[] parameterNames = nameDiscoverer.getParameterNames(method);\n                    Object[] resolvedArguments = new Object[methodAnnotations.length];\n                    int i = 0;\n                    Object defaultValue = null;\n                    boolean required = true;\n                    for (Annotation[] parameterAnnotations : methodAnnotations) {\n                        String expression = \"\";\n                        Class<?> parameterTargetClass = method.getParameterTypes()[i];\n                        if (parameterAnnotations.length != 0) {\n                            for (Annotation parameterAnnotation : parameterAnnotations) {\n                                if (parameterAnnotation.annotationType() == Configuration.class) {\n                                    Configuration configurationAnnotation = (Configuration) parameterAnnotation;\n                                    expression = configurationAnnotation.expression();\n                                    required = configurationAnnotation.required();\n                                    if (hasAnnotationDefaults(configurationAnnotation)) {\n                                        if (configurationAnnotation.defaultValueFactory().equals(Configuration.EmptyValueFactory.class)) {\n                                            defaultValue = ValueConverterRegistry.convert(parameterTargetClass, configurationAnnotation.defaultValue());\n                                        } else {\n                                            ConfigurationDefaultValueFactory valueFactory = configurationAnnotation.defaultValueFactory().newInstance();\n                                            defaultValue = valueFactory.getDefaultValue();\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        if (expression.equals(\"\")) {\n                            if (parameterNames == null) {\n                                throw new ConstrettoException(\"Could not resolve the expression of the property to look up. \" +\n                                        \"The cause of this could be that the class is compiled without debug enabled. \" +\n                                        \"when a class is compiled without debug, the @Configuration with a expression attribute is required \" +\n                                        \"to correctly resolve the property expression.\");\n                            } else {\n                                expression = parameterNames[i];\n                            }\n                        }\n                        if (hasValue(expression)) {\n                            ConfigurationNode node = findElementOrThrowException(expression);\n                            resolvedArguments[i] = processAndConvert(parameterTargetClass, node.getExpression());\n                        } else {\n                            if (defaultValue != null || !required) {\n                                resolvedArguments[i] = defaultValue;\n                            } else {\n                                throw new ConstrettoException(\"Missing value or default value for expression [\" + expression + \"], in method [\" + method.getName() + \"], in class [\" + objectToConfigure.getClass().getName() + \"], with tags \" + currentTags + \".\");\n                            }\n                        }\n\n                        i++;\n                    }\n\n                    method.setAccessible(true);\n                    method.invoke(objectToConfigure, resolvedArguments);\n\n                }\n            } catch (IllegalAccessException e) {\n                throw new ConstrettoException(\"Cold not invoke method [\"\n                        + method.getName() + \"] annotated with @Configured,\", e);\n            } catch (InvocationTargetException e) {\n                throw new ConstrettoException(\"Cold not invoke method [\"\n                        + method.getName() + \"] annotated with @Configured,\", e);\n            } catch (InstantiationException e) {\n                throw new ConstrettoException(\"Cold not invoke method [\"\n                        + method.getName() + \"] annotated with @Configured,\", e);\n            }\n        }\n    }\n\n    private <T> void injectFields(T objectToConfigure) {\n\n        Field[] fields = objectToConfigure.getClass().getDeclaredFields();\n        for (Field field : fields) {\n            try {\n                if (field.isAnnotationPresent(Configuration.class)) {\n                    Configuration configurationAnnotation = field.getAnnotation(Configuration.class);\n                    String expression = \"\".equals(configurationAnnotation.expression()) ? field.getName() : configurationAnnotation.expression();\n                    field.setAccessible(true);\n                    Class<?> fieldType = field.getType();\n                    if (hasValue(expression)) {\n                        ConfigurationNode node = findElementOrThrowException(expression);\n                        field.set(objectToConfigure, processAndConvert(fieldType, node.getExpression()));\n                    } else {\n                        if (hasAnnotationDefaults(configurationAnnotation)) {\n                            if (configurationAnnotation.defaultValueFactory().equals(Configuration.EmptyValueFactory.class)) {\n                                field.set(objectToConfigure, ValueConverterRegistry.convert(fieldType, configurationAnnotation.defaultValue()));\n                            } else {\n                                ConfigurationDefaultValueFactory valueFactory = configurationAnnotation.defaultValueFactory().newInstance();\n                                field.set(objectToConfigure, valueFactory.getDefaultValue());\n                            }\n                        } else if (configurationAnnotation.required()) {\n                            throw new ConstrettoException(\"Missing value or default value for expression [\" + expression + \"] for field [\" + field.getName() + \"], in class [\" + objectToConfigure.getClass().getName() + \"] with tags \" + currentTags + \".\");\n                        }\n                    }\n                } else if (field.isAnnotationPresent(Tags.class)) {\n                    field.setAccessible(true);\n                    field.set(objectToConfigure, currentTags);\n                }\n            } catch (IllegalAccessException e) {\n                throw new ConstrettoException(\"Cold not inject configuration into field [\"\n                        + field.getName() + \"] annotated with @Configuration, in class [\" + objectToConfigure.getClass().getName() + \"] with tags \" + currentTags, e);\n            } catch (InstantiationException e) {\n                throw new ConstrettoException(\"Cold not inject configuration into field [\"\n                        + field.getName() + \"] annotated with @Configuration, in class [\" + objectToConfigure.getClass().getName() + \"] with tags \" + currentTags, e);\n            }\n        }\n\n    }\n\n    private boolean hasAnnotationDefaults(Configuration configurationAnnotation) {\n        return !(\"N/A\".equals(configurationAnnotation.defaultValue()) && configurationAnnotation.defaultValueFactory().equals(Configuration.EmptyValueFactory.class));\n    }\n\n    private String processVariablesInProperty(final String expression, final Collection<String> visitedPlaceholders) {\n        visitedPlaceholders.add(expression);\n        ConfigurationNode currentNode = findElementOrThrowException(expression);\n\n        String value = currentNode.getValue();\n        if (valueNeedsVariableResolving(value)) {\n            value = substituteVariablesinValue(value, visitedPlaceholders);\n        }\n        return value;\n    }\n\n    private String substituteVariablesinValue(String value, final Collection<String> visitedPlaceholders) {\n        while (valueNeedsVariableResolving(value)) {\n            ConfigurationVariable expresionToLookup = extractConfigurationVariable(value);\n            if (visitedPlaceholders.contains(expresionToLookup.expression)) {\n                throw new ConstrettoException(\n                        \"A cyclic dependency found in a property\");\n            }\n            DefaultConstrettoConfiguration rootConfig = new DefaultConstrettoConfiguration(configuration.root(), currentTags);\n\n            value = value.substring(0, expresionToLookup.startIndex)\n                    + rootConfig.processVariablesInProperty(expresionToLookup.expression, visitedPlaceholders)\n                    + value.subSequence(expresionToLookup.endIndex + 1, value.length());\n        }\n        return value;\n    }\n\n    private ConfigurationVariable extractConfigurationVariable(String expression) {\n        int startIndex = expression.indexOf(VARIABLE_PREFIX);\n        int endindex = expression.indexOf(VARIABLE_SUFFIX, startIndex);\n        String parsedExpression = expression.substring(startIndex + 2, endindex);\n        return new ConfigurationVariable(startIndex, endindex, parsedExpression);\n    }\n\n    private boolean valueNeedsVariableResolving(String value) {\n        return null != value && value.contains(VARIABLE_PREFIX) && value.contains(VARIABLE_SUFFIX);\n    }\n\n    private static class ConfigurationVariable {\n        private final int startIndex;\n        private final int endIndex;\n        private final String expression;\n\n        public ConfigurationVariable(int startIndex, int endIndex, String expression) {\n            this.startIndex = startIndex;\n            this.endIndex = endIndex;\n            this.expression = expression;\n        }\n\n        @Override\n        public String toString() {\n            return expression + \", at: \" + startIndex + \" to: \" + endIndex;\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Copyright 2008 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.constretto.internal;\n\nimport org.constretto.ConfigurationDefaultValueFactory;\nimport org.constretto.ConstrettoConfiguration;\nimport org.constretto.Property;\nimport org.constretto.annotation.Configuration;\nimport org.constretto.annotation.Configure;\nimport org.constretto.annotation.Tags;\nimport org.constretto.exception.ConstrettoConversionException;\nimport org.constretto.exception.ConstrettoException;\nimport org.constretto.exception.ConstrettoExpressionException;\nimport org.constretto.internal.converter.ValueConverterRegistry;\nimport org.constretto.model.ConfigurationNode;\nimport org.springframework.core.LocalVariableTableParameterNameDiscoverer;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.*;\n\n/**\n * @author <a href=\"mailto:kaare.nilsen@gmail.com\">Kaare Nilsen<\/a>\n */\npublic class DefaultConstrettoConfiguration implements ConstrettoConfiguration {\n    private static final String NULL_STRING = \"![![Null]!]!\";\n    private static final String VARIABLE_PREFIX = \"#{\";\n    private static final String VARIABLE_SUFFIX = \"}\";\n    private List<String> currentTags;\n    private final ConfigurationNode configuration;\n    private LocalVariableTableParameterNameDiscoverer nameDiscoverer = new LocalVariableTableParameterNameDiscoverer();\n\n    public DefaultConstrettoConfiguration(ConfigurationNode configuration, List<String> currentTags) {\n        this.configuration = configuration;\n        this.currentTags = currentTags;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public <K> K evaluateTo(String expression, K defaultValue) {\n        if (!hasValue(expression)) {\n            return defaultValue;\n        }\n        K value;\n        try {\n            value = (K) processAndConvert(defaultValue.getClass(), expression);\n        } catch (ConstrettoConversionException e) {\n            value = null;\n        }\n        return null != value ? value : defaultValue;\n    }\n\n    public <K> K evaluateTo(Class<K> targetClass, String expression) throws ConstrettoExpressionException {\n        return processAndConvert(targetClass, expression);\n    }\n\n    public String evaluateToString(String expression) throws ConstrettoExpressionException {\n        return processAndConvert(String.class, expression);\n    }\n\n    public Boolean evaluateToBoolean(String expression) throws ConstrettoExpressionException {\n        return processAndConvert(Boolean.class, expression);\n    }\n\n    public Double evaluateToDouble(String expression) throws ConstrettoExpressionException {\n        return processAndConvert(Double.class, expression);\n    }\n\n    public Long evaluateToLong(String expression) throws ConstrettoExpressionException {\n        return processAndConvert(Long.class, expression);\n    }\n\n    public Float evaluateToFloat(String expression) throws ConstrettoExpressionException {\n        return processAndConvert(Float.class, expression);\n    }\n\n    public Integer evaluateToInt(String expression) throws ConstrettoExpressionException {\n        return processAndConvert(Integer.class, expression);\n    }\n\n    public Short evaluateToShort(String expression) throws ConstrettoExpressionException {\n        return processAndConvert(Short.class, expression);\n    }\n\n    public Byte evaluateToByte(String expression) throws ConstrettoExpressionException {\n        return processAndConvert(Byte.class, expression);\n    }\n\n    public <T> T as(Class<T> configurationClass) throws ConstrettoException {\n        T objectToConfigure;\n        try {\n            objectToConfigure = configurationClass.newInstance();\n        } catch (Exception e) {\n            throw new ConstrettoException(\"Could not instansiate class of type: \" + configurationClass.getName()\n                    + \" when trying to inject it with configuration, It may be missing a default constructor\", e);\n        }\n\n        injectConfiguration(objectToConfigure);\n\n        return objectToConfigure;\n    }\n\n    public <T> T on(T objectToConfigure) throws ConstrettoException {\n        injectConfiguration(objectToConfigure);\n        return objectToConfigure;\n    }\n\n    public ConstrettoConfiguration at(String expression) throws ConstrettoException {\n        ConfigurationNode currentConfigurationNode = findElementOrThrowException(expression);\n        ConfigurationNode.createRootElementOf(currentConfigurationNode);\n        return new DefaultConstrettoConfiguration(currentConfigurationNode, currentTags);\n    }\n\n    public ConstrettoConfiguration from(String expression) throws ConstrettoException {\n        return at(expression);\n    }\n\n    public boolean hasValue(String expression) {\n        ConfigurationNode node = findElementOrNull(expression);\n        return null != node;\n    }\n\n    public Iterator<Property> iterator() {\n        List<Property> properties = new ArrayList<Property>();\n        Map<String,String> map = asMap();\n        for (Map.Entry<String, String> entry : map.entrySet()) {\n            properties.add(new Property(entry.getKey(),entry.getValue()));\n        }\n        return properties.iterator();\n    }\n\n     private Map<String,String> asMap(){\n        Map<String,String> properties = new HashMap<String,String>();\n        extractProperties(configuration,properties);\n        return properties;\n    }\n\n    private void extractProperties(ConfigurationNode currentNode, Map<String, String> properties) {\n        String value = evaluateTo(currentNode.getExpression(),NULL_STRING);\n        if (!value.equals(NULL_STRING)){\n            properties.put(currentNode.getExpression(),value);\n        }\n        if (currentNode.hasChildren()){\n            for (ConfigurationNode child : currentNode.children()) {\n                extractProperties(child,properties);\n            }\n        }\n    }\n\n    //\n    // Helper methods\n    //\n    private ConfigurationNode findElementOrThrowException(String expression) {\n        List<ConfigurationNode> node = configuration.findAllBy(expression);\n        ConfigurationNode resolvedNode = resolveMatch(node);\n        if (resolvedNode == null) {\n            throw new ConstrettoExpressionException(expression, currentTags);\n        }\n        return resolvedNode;\n    }\n\n    private <T> T processAndConvert(Class<T> clazz, String expression) throws ConstrettoException {\n        String parsedValue = processVariablesInProperty(expression, new ArrayList<String>());\n        return ValueConverterRegistry.convert(clazz, parsedValue);\n    }\n\n    private ConfigurationNode findElementOrNull(String expression) {\n        List<ConfigurationNode> node = configuration.findAllBy(expression);\n        return resolveMatch(node);\n    }\n\n    private ConfigurationNode resolveMatch(List<ConfigurationNode> node) {\n        ConfigurationNode bestMatch = null;\n        for (ConfigurationNode configurationNode : node) {\n            if (ConfigurationNode.DEFAULT_TAG.equals(configurationNode.getTag())) {\n                if (bestMatch == null || bestMatch.getTag().equals(ConfigurationNode.DEFAULT_TAG)) {\n                    bestMatch = configurationNode;\n                }\n            } else if (currentTags.contains(configurationNode.getTag())) {\n                if (bestMatch == null) {\n                    bestMatch = configurationNode;\n                } else {\n                    int previousFoundPriority =\n                            ConfigurationNode.DEFAULT_TAG.equals(bestMatch.getTag()) ?\n                                    Integer.MAX_VALUE : currentTags.indexOf(bestMatch.getTag());\n                    if (currentTags.indexOf(configurationNode.getTag()) <= previousFoundPriority) {\n                        bestMatch = configurationNode;\n                    }\n                }\n            } else if (ConfigurationNode.ALL_TAG.equals(configurationNode.getTag())) {\n                bestMatch = configurationNode;\n            }\n        }\n        return bestMatch;\n    }\n\n    private <T> void injectConfiguration(T objectToConfigure) {\n        injectFields(objectToConfigure);\n        injectMethods(objectToConfigure);\n    }\n\n    private <T> void injectMethods(T objectToConfigure) {\n        Method[] methods = objectToConfigure.getClass().getMethods();\n        for (Method method : methods) {\n            try {\n                if (method.isAnnotationPresent(Configure.class)) {\n                    Annotation[][] methodAnnotations = method.getParameterAnnotations();\n                    String[] parameterNames = nameDiscoverer.getParameterNames(method);\n                    Object[] resolvedArguments = new Object[methodAnnotations.length];\n                    int i = 0;\n                    Object defaultValue = null;\n                    boolean required = true;\n                    for (Annotation[] parameterAnnotations : methodAnnotations) {\n                        String expression = \"\";\n                        Class<?> parameterTargetClass = method.getParameterTypes()[i];\n                        if (parameterAnnotations.length != 0) {\n                            for (Annotation parameterAnnotation : parameterAnnotations) {\n                                if (parameterAnnotation.annotationType() == Configuration.class) {\n                                    Configuration configurationAnnotation = (Configuration) parameterAnnotation;\n                                    expression = configurationAnnotation.expression();\n                                    required = configurationAnnotation.required();\n                                    if (hasAnnotationDefaults(configurationAnnotation)) {\n                                        if (configurationAnnotation.defaultValueFactory().equals(Configuration.EmptyValueFactory.class)) {\n                                            defaultValue = ValueConverterRegistry.convert(parameterTargetClass, configurationAnnotation.defaultValue());\n                                        } else {\n                                            ConfigurationDefaultValueFactory valueFactory = configurationAnnotation.defaultValueFactory().newInstance();\n                                            defaultValue = valueFactory.getDefaultValue();\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        if (expression.equals(\"\")) {\n                            if (parameterNames == null) {\n                                throw new ConstrettoException(\"Could not resolve the expression of the property to look up. \" +\n                                        \"The cause of this could be that the class is compiled without debug enabled. \" +\n                                        \"when a class is compiled without debug, the @Configuration with a expression attribute is required \" +\n                                        \"to correctly resolve the property expression.\");\n                            } else {\n                                expression = parameterNames[i];\n                            }\n                        }\n                        if (hasValue(expression)) {\n                            ConfigurationNode node = findElementOrThrowException(expression);\n                            resolvedArguments[i] = processAndConvert(parameterTargetClass, node.getExpression());\n                        } else {\n                            if (defaultValue != null || !required) {\n                                resolvedArguments[i] = defaultValue;\n                            } else {\n                                throw new ConstrettoException(\"Missing value or default value for expression [\" + expression + \"], in method [\" + method.getName() + \"], in class [\" + objectToConfigure.getClass().getName() + \"], with tags \" + currentTags + \".\");\n                            }\n                        }\n\n                        i++;\n                    }\n\n                    method.setAccessible(true);\n                    method.invoke(objectToConfigure, resolvedArguments);\n\n                }\n            } catch (IllegalAccessException e) {\n                throw new ConstrettoException(\"Cold not invoke method [\"\n                        + method.getName() + \"] annotated with @Configured,\", e);\n            } catch (InvocationTargetException e) {\n                throw new ConstrettoException(\"Cold not invoke method [\"\n                        + method.getName() + \"] annotated with @Configured,\", e);\n            } catch (InstantiationException e) {\n                throw new ConstrettoException(\"Cold not invoke method [\"\n                        + method.getName() + \"] annotated with @Configured,\", e);\n            }\n        }\n    }\n\n    private <T> void injectFields(T objectToConfigure) {\n\n        Class objectToConfigureClass = objectToConfigure.getClass();\n\n        do {\n            Field[] fields = objectToConfigureClass.getDeclaredFields();\n            for (Field field : fields) {\n                try {\n                    if (field.isAnnotationPresent(Configuration.class)) {\n                        Configuration configurationAnnotation = field.getAnnotation(Configuration.class);\n                        String expression = \"\".equals(configurationAnnotation.expression()) ? field.getName() : configurationAnnotation.expression();\n                        field.setAccessible(true);\n                        Class<?> fieldType = field.getType();\n                        if (hasValue(expression)) {\n                            ConfigurationNode node = findElementOrThrowException(expression);\n                            field.set(objectToConfigure, processAndConvert(fieldType, node.getExpression()));\n                        } else {\n                            if (hasAnnotationDefaults(configurationAnnotation)) {\n                                if (configurationAnnotation.defaultValueFactory().equals(Configuration.EmptyValueFactory.class)) {\n                                    field.set(objectToConfigure, ValueConverterRegistry.convert(fieldType, configurationAnnotation.defaultValue()));\n                                } else {\n                                    ConfigurationDefaultValueFactory valueFactory = configurationAnnotation.defaultValueFactory().newInstance();\n                                    field.set(objectToConfigure, valueFactory.getDefaultValue());\n                                }\n                            } else if (configurationAnnotation.required()) {\n                                throw new ConstrettoException(\"Missing value or default value for expression [\" + expression + \"] for field [\" + field.getName() + \"], in class [\" + objectToConfigure.getClass().getName() + \"] with tags \" + currentTags + \".\");\n                            }\n                        }\n                    } else if (field.isAnnotationPresent(Tags.class)) {\n                        field.setAccessible(true);\n                        field.set(objectToConfigure, currentTags);\n                    }\n                } catch (IllegalAccessException e) {\n                    throw new ConstrettoException(\"Cold not inject configuration into field [\"\n                            + field.getName() + \"] annotated with @Configuration, in class [\" + objectToConfigure.getClass().getName() + \"] with tags \" + currentTags, e);\n                } catch (InstantiationException e) {\n                    throw new ConstrettoException(\"Cold not inject configuration into field [\"\n                            + field.getName() + \"] annotated with @Configuration, in class [\" + objectToConfigure.getClass().getName() + \"] with tags \" + currentTags, e);\n                }\n            }\n        } while ((objectToConfigureClass = objectToConfigureClass.getSuperclass()) != null);\n    }\n\n    private boolean hasAnnotationDefaults(Configuration configurationAnnotation) {\n        return !(\"N/A\".equals(configurationAnnotation.defaultValue()) && configurationAnnotation.defaultValueFactory().equals(Configuration.EmptyValueFactory.class));\n    }\n\n    private String processVariablesInProperty(final String expression, final Collection<String> visitedPlaceholders) {\n        visitedPlaceholders.add(expression);\n        ConfigurationNode currentNode = findElementOrThrowException(expression);\n\n        String value = currentNode.getValue();\n        if (valueNeedsVariableResolving(value)) {\n            value = substituteVariablesinValue(value, visitedPlaceholders);\n        }\n        return value;\n    }\n\n    private String substituteVariablesinValue(String value, final Collection<String> visitedPlaceholders) {\n        while (valueNeedsVariableResolving(value)) {\n            ConfigurationVariable expresionToLookup = extractConfigurationVariable(value);\n            if (visitedPlaceholders.contains(expresionToLookup.expression)) {\n                throw new ConstrettoException(\n                        \"A cyclic dependency found in a property\");\n            }\n            DefaultConstrettoConfiguration rootConfig = new DefaultConstrettoConfiguration(configuration.root(), currentTags);\n\n            value = value.substring(0, expresionToLookup.startIndex)\n                    + rootConfig.processVariablesInProperty(expresionToLookup.expression, visitedPlaceholders)\n                    + value.subSequence(expresionToLookup.endIndex + 1, value.length());\n        }\n        return value;\n    }\n\n    private ConfigurationVariable extractConfigurationVariable(String expression) {\n        int startIndex = expression.indexOf(VARIABLE_PREFIX);\n        int endindex = expression.indexOf(VARIABLE_SUFFIX, startIndex);\n        String parsedExpression = expression.substring(startIndex + 2, endindex);\n        return new ConfigurationVariable(startIndex, endindex, parsedExpression);\n    }\n\n    private boolean valueNeedsVariableResolving(String value) {\n        return null != value && value.contains(VARIABLE_PREFIX) && value.contains(VARIABLE_SUFFIX);\n    }\n\n    private static class ConfigurationVariable {\n        private final int startIndex;\n        private final int endIndex;\n        private final String expression;\n\n        public ConfigurationVariable(int startIndex, int endIndex, String expression) {\n            this.startIndex = startIndex;\n            this.endIndex = endIndex;\n            this.expression = expression;\n        }\n\n        @Override\n        public String toString() {\n            return expression + \", at: \" + startIndex + \" to: \" + endIndex;\n        }\n    }\n}\n","lineNo":290}
{"Smelly Sample":"/*\n * Copyright 2008 the original author or authors. Licensed under the Apache\n * License, Version 2.0 (the \"License\"); you may not use this file except in\n * compliance with the License. You may obtain a copy of the License at\n * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law\n * or agreed to in writing, software distributed under the License is\n * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\npackage org.constretto.test;\n\nimport org.constretto.annotation.Tags;\nimport org.constretto.internal.resolver.DefaultConfigurationContextResolver;\nimport org.junit.internal.runners.InitializationError;\nimport org.junit.internal.runners.JUnit4ClassRunner;\nimport org.junit.runner.notification.RunNotifier;\n\n/**\n * @author <a href=\"mailto:kaare.nilsen@gmail.com\">Kaare Nilsen<\/a>\n * @author <a href=\"mailto:thor.aage.eldby@arktekk.no\">Thor &Aring;ge Eldby<\/a>\n */\npublic class ConstrettoJUnit4ClassRunner extends JUnit4ClassRunner {\n\n    public ConstrettoJUnit4ClassRunner(Class<?> clazz) throws InitializationError {\n        super(clazz);\n    }\n\n    private String changeTagsSystemProperty() {\n        Tags tags = getTestClass().getJavaClass().getAnnotation(Tags.class);\n        if (tags != null) {\n            StringBuffer tagcsv = new StringBuffer();\n            for (String tag : tags.value()) {\n                if (tagcsv.length() > 0) {\n                    tagcsv.append(\",\");\n                }\n                tagcsv.append(tag);\n            }\n            return System.setProperty(DefaultConfigurationContextResolver.TAGS, tagcsv.toString());\n        }\n        return System.getProperty(DefaultConfigurationContextResolver.TAGS);\n    }\n\n    @Override\n    public void run(RunNotifier notifier) {\n        String originalValue = changeTagsSystemProperty();\n        super.run(notifier);\n        if (originalValue == null) {\n            System.getProperties().remove(DefaultConfigurationContextResolver.TAGS);\n        } else {\n            System.setProperty(DefaultConfigurationContextResolver.TAGS, originalValue);\n        }\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2008 the original author or authors. Licensed under the Apache\n * License, Version 2.0 (the \"License\"); you may not use this file except in\n * compliance with the License. You may obtain a copy of the License at\n * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law\n * or agreed to in writing, software distributed under the License is\n * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\npackage org.constretto.test;\n\nimport org.constretto.annotation.Tags;\nimport org.constretto.internal.ConstrettoUtils;\nimport org.constretto.internal.resolver.DefaultConfigurationContextResolver;\nimport org.junit.internal.runners.InitializationError;\nimport org.junit.internal.runners.JUnit4ClassRunner;\nimport org.junit.runner.notification.RunNotifier;\n\n/**\n * @author <a href=\"mailto:kaare.nilsen@gmail.com\">Kaare Nilsen<\/a>\n * @author <a href=\"mailto:thor.aage.eldby@arktekk.no\">Thor &Aring;ge Eldby<\/a>\n */\npublic class ConstrettoJUnit4ClassRunner extends JUnit4ClassRunner {\n\n    public ConstrettoJUnit4ClassRunner(Class<?> clazz) throws InitializationError {\n        super(clazz);\n    }\n\n    private String changeTagsSystemProperty() {\n        Tags tags = getTestClass().getJavaClass().getAnnotation(Tags.class);\n        if (tags != null) {\n            String tagcsv = ConstrettoUtils.asCsv(tags.value());\n            return System.setProperty(DefaultConfigurationContextResolver.TAGS, tagcsv.toString());\n        }\n        return System.getProperty(DefaultConfigurationContextResolver.TAGS);\n    }\n\n    @Override\n    public void run(RunNotifier notifier) {\n        String originalValue = changeTagsSystemProperty();\n        super.run(notifier);\n        if (originalValue == null) {\n            System.getProperties().remove(DefaultConfigurationContextResolver.TAGS);\n        } else {\n            System.setProperty(DefaultConfigurationContextResolver.TAGS, originalValue);\n        }\n    }\n\n}\n","lineNo":33}
{"Smelly Sample":"/*\n * Copyright 2008 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.constretto.spring.internal;\n\nimport org.constretto.ConstrettoBuilder;\nimport org.constretto.ConstrettoConfiguration;\nimport org.constretto.internal.resolver.DefaultConfigurationContextResolver;\nimport org.constretto.resolver.ConfigurationContextResolver;\nimport org.constretto.spring.ConfigurationAnnotationConfigurer;\nimport org.constretto.spring.ConstrettoConfigurationFactoryBean;\nimport org.constretto.spring.ConstrettoPropertyPlaceholderConfigurer;\nimport org.constretto.spring.EnvironmentAnnotationConfigurer;\nimport org.constretto.spring.internal.resolver.DefaultAssemblyContextResolver;\nimport org.constretto.spring.resolver.AssemblyContextResolver;\nimport org.springframework.beans.factory.config.BeanDefinition;\nimport org.springframework.beans.factory.support.BeanDefinitionBuilder;\nimport org.springframework.beans.factory.xml.BeanDefinitionParser;\nimport org.springframework.beans.factory.xml.NamespaceHandlerSupport;\nimport org.springframework.beans.factory.xml.ParserContext;\nimport org.springframework.core.io.DefaultResourceLoader;\nimport org.springframework.util.Assert;\nimport org.springframework.util.xml.DomUtils;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * @author <a href=\"mailto:kaare.nilsen@gmail.com\">Kaare Nilsen<\/a>\n */\npublic class ConstrettoNamespaceHandler extends NamespaceHandlerSupport {\n    private static final String CONFIGURATION_CONTEXT_RESOLVER_NAME = \"constretto:configurationContextResolver\";\n    private static final String ENVIRONMENT_CONTEXT_RESOLVER_NAME = \"constretto:assemblyContextResolver\";\n    private static final String CONSTRETTO_CONFIGURATION_BEAN_NAME = \"constretto:constrettoConfiguration\";\n    private static final String CONSTRETTO_PLACEHOLDER_BEAN_NAME = \"constretto:constrettoPlaceholderConfigurer\";\n    private static final String CONSTRETTO_CONFIGURATION_ANNOTATION_BEAN_NAME = \"constretto:configurationAnnotationConfigurer\";\n    private static final String CONSTRETTO_ENVIRONMENT_ANNOTATION_BEAN_NAME = \"constretto:environmentAnnotationConfigurer\";\n\n    public void init() {\n        registerBeanDefinitionParser(\"configuration\", new ConfigurationDefinitionParser());\n        registerBeanDefinitionParser(\"import\", new ImportDefinitionParser());\n    }\n\n    private static class ConfigurationDefinitionParser implements BeanDefinitionParser {\n\n        public BeanDefinition parse(Element element, ParserContext parserContext) {\n            ConfigurationContextResolver configurationContextResolver = processConfigurationContextResolverTag(DomUtils.getChildElementByTagName(element, \"configuration-context-resolver\"), parserContext);\n            AssemblyContextResolver assemblyContextResolver = processAssemblyContextResolverTag(DomUtils.getChildElementByTagName(element, \"assembly-context-resolver\"), parserContext);\n\n            ConstrettoConfiguration configuration = buildConfig(element, configurationContextResolver);\n\n            processAnnotationConfig(element, configuration, assemblyContextResolver, parserContext);\n            processPropertyPlaceHolder(element, configuration, parserContext);\n\n            BeanDefinitionBuilder configurationFactoryBean = BeanDefinitionBuilder.rootBeanDefinition(ConstrettoConfigurationFactoryBean.class);\n            configurationFactoryBean.addConstructorArgValue(configuration);\n            parserContext.getRegistry().registerBeanDefinition(CONSTRETTO_CONFIGURATION_BEAN_NAME, configurationFactoryBean.getBeanDefinition());\n\n            return null;\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        private ConstrettoConfiguration buildConfig(Element element, ConfigurationContextResolver configurationContextResolver) {\n            ConstrettoBuilder builder = new ConstrettoBuilder(configurationContextResolver);\n            Element storeElement = DomUtils.getChildElementByTagName(element, \"stores\");\n            if (storeElement != null) {\n                List<Element> stores = getAllChildElements(storeElement);\n                for (Element store : stores) {\n                    String tagName = store.getLocalName();\n                    if (\"properties-store\".equals(tagName)) {\n                        ConstrettoBuilder.PropertiesStoreBuilder propertiesBuilder = builder.createPropertiesStore();\n                        List<Element> resources = DomUtils.getChildElementsByTagName(store, \"resource\");\n                        for (Element resource : resources) {\n                            String location = resource.getAttribute(\"location\");\n                            propertiesBuilder.addResource(new DefaultResourceLoader().getResource(location));\n                        }\n                        propertiesBuilder.done();\n                    } else if (\"ini-store\".equals(tagName)) {\n                        ConstrettoBuilder.IniFileConfigurationStoreBuilder iniBuilder = builder.createIniFileConfigurationStore();\n                        List<Element> resources = DomUtils.getChildElementsByTagName(store, \"resource\");\n                        for (Element resource : resources) {\n                            String location = resource.getAttribute(\"location\");\n                            iniBuilder.addResource(new DefaultResourceLoader().getResource(location));\n                        }\n                        iniBuilder.done();\n                    } else if (\"system-properties-store\".equals(tagName)) {\n                        builder.createSystemPropertiesStore();\n                    } else if (\"object-store\".equals(tagName)) {\n                        ConstrettoBuilder.ObjectConfigurationStoreBuilder objectBuilder = builder.createObjectConfigurationStore();\n                        List<Element> objects = DomUtils.getChildElementsByTagName(store, \"object\");\n                        for (Element object : objects) {\n                            String clazz = object.getAttribute(\"class\");\n                            try {\n                                objectBuilder.addObject(Class.forName(clazz).newInstance());\n                            } catch (Exception e) {\n                                throw new IllegalStateException(\"Could not instansiate configuration source object with class [\" + clazz + \"]\");\n                            }\n                        }\n                        objectBuilder.done();\n                    }\n                }\n            }\n\n            return builder.getConfiguration();\n        }\n\n        private void processPropertyPlaceHolder(Element element, ConstrettoConfiguration configuration, ParserContext parserContext) {\n            String propertyPlaceholderAttribute = element.getAttribute(\"property-placeholder\");\n            Element propertyPlaceholderElement = DomUtils.getChildElementByTagName(element, \"property-placeholder-configurer\");\n            boolean enabled = propertyPlaceholderAttribute != null ? Boolean.valueOf(propertyPlaceholderAttribute) : true;\n            if (enabled) {\n                BeanDefinitionBuilder placeHolderBean = BeanDefinitionBuilder.rootBeanDefinition(ConstrettoPropertyPlaceholderConfigurer.class);\n                placeHolderBean.addConstructorArgValue(configuration);\n                if (propertyPlaceholderElement != null) {\n                    boolean ignoreUnresolved = propertyPlaceholderElement.getAttribute(\"ignore-unresolved-placeholders\") != null ? Boolean.valueOf(propertyPlaceholderElement.getAttribute(\"ignore-unresolved-placeholders\")) : false;\n                    String prefix = propertyPlaceholderElement.getAttribute(\"prefix\") != null ? propertyPlaceholderElement.getAttribute(\"prefix\") : \"${\";\n                    String suffix = propertyPlaceholderElement.getAttribute(\"suffix\") != null ? propertyPlaceholderElement.getAttribute(\"suffix\") : \"}\";\n                    placeHolderBean.addPropertyValue(\"placeholderPrefix\", prefix);\n                    placeHolderBean.addPropertyValue(\"placeholderSuffix\", suffix);\n                    placeHolderBean.addPropertyValue(\"ignoreUnresolvedPlaceHolders\", ignoreUnresolved);\n\n                }\n                parserContext.getRegistry().registerBeanDefinition(CONSTRETTO_PLACEHOLDER_BEAN_NAME, placeHolderBean.getBeanDefinition());\n            }\n        }\n\n        private void processAnnotationConfig(Element element, ConstrettoConfiguration configuration, AssemblyContextResolver assemblyContextResolver, ParserContext parserContext) {\n            String annotationConfigAttribute = element.getAttribute(\"annotation-config\");\n            boolean enabled = annotationConfigAttribute != null ? Boolean.valueOf(annotationConfigAttribute) : true;\n            if (enabled) {\n                BeanDefinitionBuilder configurationAnnotationConfigurerBean = BeanDefinitionBuilder.rootBeanDefinition(ConfigurationAnnotationConfigurer.class);\n                configurationAnnotationConfigurerBean.addConstructorArgValue(configuration);\n                configurationAnnotationConfigurerBean.addConstructorArgValue(assemblyContextResolver);\n                parserContext.getRegistry().registerBeanDefinition(CONSTRETTO_CONFIGURATION_ANNOTATION_BEAN_NAME, configurationAnnotationConfigurerBean.getBeanDefinition());\n                BeanDefinitionBuilder environmentAnnotationConfigurerBean = BeanDefinitionBuilder.rootBeanDefinition(EnvironmentAnnotationConfigurer.class);\n                environmentAnnotationConfigurerBean.addConstructorArgValue(assemblyContextResolver);\n                parserContext.getRegistry().registerBeanDefinition(CONSTRETTO_ENVIRONMENT_ANNOTATION_BEAN_NAME, environmentAnnotationConfigurerBean.getBeanDefinition());\n            }\n        }\n\n        private ConfigurationContextResolver processConfigurationContextResolverTag(Element element, ParserContext parserContext) {\n            if (element == null) {\n                BeanDefinitionBuilder contextResolverBean;\n                contextResolverBean = BeanDefinitionBuilder.rootBeanDefinition(DefaultConfigurationContextResolver.class);\n                parserContext.getRegistry().registerBeanDefinition(CONFIGURATION_CONTEXT_RESOLVER_NAME, contextResolverBean.getBeanDefinition());\n                return new DefaultConfigurationContextResolver();\n            } else {\n                String clazz = element.getAttribute(\"class\");\n                BeanDefinitionBuilder contextResolverBean = BeanDefinitionBuilder.rootBeanDefinition(clazz);\n                parserContext.getRegistry().registerBeanDefinition(CONFIGURATION_CONTEXT_RESOLVER_NAME, contextResolverBean.getBeanDefinition());\n                try {\n                    return (ConfigurationContextResolver) Class.forName(clazz).newInstance();\n                } catch (Exception e) {\n                    throw new IllegalStateException(\"Could not instansiate configuration context resolver with class [\" + clazz + \"]\", e);\n                }\n            }\n        }\n\n        private AssemblyContextResolver processAssemblyContextResolverTag(Element element, ParserContext parserContext) {\n            if (element == null) {\n                BeanDefinitionBuilder contextResolverBean;\n                contextResolverBean = BeanDefinitionBuilder.rootBeanDefinition(DefaultAssemblyContextResolver.class);\n                parserContext.getRegistry().registerBeanDefinition(ENVIRONMENT_CONTEXT_RESOLVER_NAME, contextResolverBean.getBeanDefinition());\n                return new DefaultAssemblyContextResolver();\n            } else {\n                String clazz = element.getAttribute(\"class\");\n                BeanDefinitionBuilder contextResolverBean = BeanDefinitionBuilder.rootBeanDefinition(clazz);\n                parserContext.getRegistry().registerBeanDefinition(ENVIRONMENT_CONTEXT_RESOLVER_NAME, contextResolverBean.getBeanDefinition());\n                try {\n                    return (AssemblyContextResolver) Class.forName(clazz).newInstance();\n                } catch (Exception e) {\n                    throw new IllegalStateException(\"Could not instansiate assembly context resolver with class [\" + clazz + \"]\", e);\n                }\n            }\n        }\n\n        public static List<Element> getAllChildElements(Element element) {\n            Assert.notNull(element, \"Element must not be null\");\n            NodeList childNodes = element.getChildNodes();\n            List<Element> childElements = new ArrayList<Element>();\n            for (int i = 0; i < childNodes.getLength(); i++) {\n                Node node = childNodes.item(i);\n                if (node instanceof Element) {\n                    childElements.add((Element) node);\n                }\n            }\n            return childElements;\n        }\n    }\n\n    private static class ImportDefinitionParser implements BeanDefinitionParser {\n\n        public BeanDefinition parse(Element element, ParserContext parserContext) {\n            String targetEnvironmentsCsv = element.getAttribute(\"environments\");\n            List<String> targetEnvironments = parseCSV(targetEnvironmentsCsv);\n\n            AssemblyContextResolver assemblyContextResolver = null;\n\n            if (parserContext.getRegistry().containsBeanDefinition(ENVIRONMENT_CONTEXT_RESOLVER_NAME)) {\n                BeanDefinition environmentContextResolverBeanDefinition = parserContext.getRegistry().getBeanDefinition(ENVIRONMENT_CONTEXT_RESOLVER_NAME);\n                String environmentResolverClassName = environmentContextResolverBeanDefinition.getBeanClassName();\n                try {\n                    assemblyContextResolver = (AssemblyContextResolver) Class.forName(environmentResolverClassName).newInstance();\n                } catch (Exception e) {\n                    throw new IllegalStateException(\"Could not instansiate assembly context resolver with class [\" + environmentResolverClassName + \"]\", e);\n                }\n            } else {\n                assemblyContextResolver = new DefaultAssemblyContextResolver();\n            }\n\n            List<String> assemblyContext = parseCSV(assemblyContextResolver.getAssemblyContext());\n            targetEnvironments.retainAll(assemblyContext);\n            boolean include = !targetEnvironments.isEmpty();\n            if (include) {\n                parserContext.getReaderContext().getReader().loadBeanDefinitions(element.getAttribute(\"resource\"));\n            }\n            return null;\n        }\n\n        private List<String> parseCSV(String csv) {\n            List<String> elements = new ArrayList<String>();\n            for (String element : csv.split(\",\"))\n                elements.add(element);\n            return elements;\n        }\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2008 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.constretto.spring.internal;\n\nimport org.constretto.ConstrettoBuilder;\nimport org.constretto.ConstrettoConfiguration;\nimport org.constretto.internal.resolver.DefaultConfigurationContextResolver;\nimport org.constretto.resolver.ConfigurationContextResolver;\nimport org.constretto.spring.ConfigurationAnnotationConfigurer;\nimport org.constretto.spring.ConstrettoConfigurationFactoryBean;\nimport org.constretto.spring.ConstrettoPropertyPlaceholderConfigurer;\nimport org.constretto.spring.EnvironmentAnnotationConfigurer;\nimport org.constretto.spring.internal.resolver.DefaultAssemblyContextResolver;\nimport org.constretto.spring.resolver.AssemblyContextResolver;\nimport org.springframework.beans.factory.config.BeanDefinition;\nimport org.springframework.beans.factory.support.BeanDefinitionBuilder;\nimport org.springframework.beans.factory.xml.BeanDefinitionParser;\nimport org.springframework.beans.factory.xml.NamespaceHandlerSupport;\nimport org.springframework.beans.factory.xml.ParserContext;\nimport org.springframework.core.io.DefaultResourceLoader;\nimport org.springframework.util.Assert;\nimport org.springframework.util.xml.DomUtils;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * @author <a href=\"mailto:kaare.nilsen@gmail.com\">Kaare Nilsen<\/a>\n */\npublic class ConstrettoNamespaceHandler extends NamespaceHandlerSupport {\n    private static final String CONFIGURATION_CONTEXT_RESOLVER_NAME = \"constretto:configurationContextResolver\";\n    private static final String ENVIRONMENT_CONTEXT_RESOLVER_NAME = \"constretto:assemblyContextResolver\";\n    private static final String CONSTRETTO_CONFIGURATION_BEAN_NAME = \"constretto:constrettoConfiguration\";\n    private static final String CONSTRETTO_PLACEHOLDER_BEAN_NAME = \"constretto:constrettoPlaceholderConfigurer\";\n    private static final String CONSTRETTO_CONFIGURATION_ANNOTATION_BEAN_NAME = \"constretto:configurationAnnotationConfigurer\";\n    private static final String CONSTRETTO_ENVIRONMENT_ANNOTATION_BEAN_NAME = \"constretto:environmentAnnotationConfigurer\";\n\n    public void init() {\n        registerBeanDefinitionParser(\"configuration\", new ConfigurationDefinitionParser());\n        registerBeanDefinitionParser(\"import\", new ImportDefinitionParser());\n    }\n\n    private static class ConfigurationDefinitionParser implements BeanDefinitionParser {\n\n        public BeanDefinition parse(Element element, ParserContext parserContext) {\n            ConfigurationContextResolver configurationContextResolver = processConfigurationContextResolverTag(DomUtils.getChildElementByTagName(element, \"configuration-context-resolver\"), parserContext);\n            AssemblyContextResolver assemblyContextResolver = processAssemblyContextResolverTag(DomUtils.getChildElementByTagName(element, \"assembly-context-resolver\"), parserContext);\n\n            ConstrettoConfiguration configuration = buildConfig(element, configurationContextResolver);\n\n            processAnnotationConfig(element, configuration, assemblyContextResolver, parserContext);\n            processPropertyPlaceHolder(element, configuration, parserContext);\n\n            BeanDefinitionBuilder configurationFactoryBean = BeanDefinitionBuilder.rootBeanDefinition(ConstrettoConfigurationFactoryBean.class);\n            configurationFactoryBean.addConstructorArgValue(configuration);\n            parserContext.getRegistry().registerBeanDefinition(CONSTRETTO_CONFIGURATION_BEAN_NAME, configurationFactoryBean.getBeanDefinition());\n\n            return null;\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        private ConstrettoConfiguration buildConfig(Element element, ConfigurationContextResolver configurationContextResolver) {\n            ConstrettoBuilder builder = new ConstrettoBuilder(configurationContextResolver);\n            Element storeElement = DomUtils.getChildElementByTagName(element, \"stores\");\n            if (storeElement != null) {\n                List<Element> stores = getAllChildElements(storeElement);\n                for (Element store : stores) {\n                    String tagName = store.getLocalName();\n                    if (\"properties-store\".equals(tagName)) {\n                        ConstrettoBuilder.PropertiesStoreBuilder propertiesBuilder = builder.createPropertiesStore();\n                        List<Element> resources = DomUtils.getChildElementsByTagName(store, \"resource\");\n                        for (Element resource : resources) {\n                            String location = resource.getAttribute(\"location\");\n                            propertiesBuilder.addResource(new DefaultResourceLoader().getResource(location));\n                        }\n                        propertiesBuilder.done();\n                    } else if (\"ini-store\".equals(tagName)) {\n                        ConstrettoBuilder.IniFileConfigurationStoreBuilder iniBuilder = builder.createIniFileConfigurationStore();\n                        List<Element> resources = DomUtils.getChildElementsByTagName(store, \"resource\");\n                        for (Element resource : resources) {\n                            String location = resource.getAttribute(\"location\");\n                            iniBuilder.addResource(new DefaultResourceLoader().getResource(location));\n                        }\n                        iniBuilder.done();\n                    } else if (\"system-properties-store\".equals(tagName)) {\n                        builder.createSystemPropertiesStore();\n                    } else if (\"object-store\".equals(tagName)) {\n                        ConstrettoBuilder.ObjectConfigurationStoreBuilder objectBuilder = builder.createObjectConfigurationStore();\n                        List<Element> objects = DomUtils.getChildElementsByTagName(store, \"object\");\n                        for (Element object : objects) {\n                            String clazz = object.getAttribute(\"class\");\n                            try {\n                                objectBuilder.addObject(Class.forName(clazz).newInstance());\n                            } catch (Exception e) {\n                                throw new IllegalStateException(\"Could not instansiate configuration source object with class [\" + clazz + \"]\");\n                            }\n                        }\n                        objectBuilder.done();\n                    }\n                }\n            }\n\n            return builder.getConfiguration();\n        }\n\n        private void processPropertyPlaceHolder(Element element, ConstrettoConfiguration configuration, ParserContext parserContext) {\n            String propertyPlaceholderAttribute = element.getAttribute(\"property-placeholder\");\n            Element propertyPlaceholderElement = DomUtils.getChildElementByTagName(element, \"property-placeholder-configurer\");\n            boolean enabled = propertyPlaceholderAttribute != null ? Boolean.valueOf(propertyPlaceholderAttribute) : true;\n            if (enabled) {\n                BeanDefinitionBuilder placeHolderBean = BeanDefinitionBuilder.rootBeanDefinition(ConstrettoPropertyPlaceholderConfigurer.class);\n                placeHolderBean.addConstructorArgValue(configuration);\n                if (propertyPlaceholderElement != null) {\n                    boolean ignoreUnresolved = propertyPlaceholderElement.getAttribute(\"ignore-unresolved-placeholders\") != null ? Boolean.valueOf(propertyPlaceholderElement.getAttribute(\"ignore-unresolved-placeholders\")) : false;\n                    String prefix = propertyPlaceholderElement.getAttribute(\"prefix\") != null ? propertyPlaceholderElement.getAttribute(\"prefix\") : \"${\";\n                    String suffix = propertyPlaceholderElement.getAttribute(\"suffix\") != null ? propertyPlaceholderElement.getAttribute(\"suffix\") : \"}\";\n                    placeHolderBean.addPropertyValue(\"placeholderPrefix\", prefix);\n                    placeHolderBean.addPropertyValue(\"placeholderSuffix\", suffix);\n                    placeHolderBean.addPropertyValue(\"ignoreUnresolvedPlaceHolders\", ignoreUnresolved);\n\n                }\n                parserContext.getRegistry().registerBeanDefinition(CONSTRETTO_PLACEHOLDER_BEAN_NAME, placeHolderBean.getBeanDefinition());\n            }\n        }\n\n        private void processAnnotationConfig(Element element, ConstrettoConfiguration configuration, AssemblyContextResolver assemblyContextResolver, ParserContext parserContext) {\n            String annotationConfigAttribute = element.getAttribute(\"annotation-config\");\n            boolean enabled = annotationConfigAttribute != null ? Boolean.valueOf(annotationConfigAttribute) : true;\n            if (enabled) {\n                BeanDefinitionBuilder configurationAnnotationConfigurerBean = BeanDefinitionBuilder.rootBeanDefinition(ConfigurationAnnotationConfigurer.class);\n                configurationAnnotationConfigurerBean.addConstructorArgValue(configuration);\n                configurationAnnotationConfigurerBean.addConstructorArgValue(assemblyContextResolver);\n                parserContext.getRegistry().registerBeanDefinition(CONSTRETTO_CONFIGURATION_ANNOTATION_BEAN_NAME, configurationAnnotationConfigurerBean.getBeanDefinition());\n                BeanDefinitionBuilder environmentAnnotationConfigurerBean = BeanDefinitionBuilder.rootBeanDefinition(EnvironmentAnnotationConfigurer.class);\n                environmentAnnotationConfigurerBean.addConstructorArgValue(assemblyContextResolver);\n                parserContext.getRegistry().registerBeanDefinition(CONSTRETTO_ENVIRONMENT_ANNOTATION_BEAN_NAME, environmentAnnotationConfigurerBean.getBeanDefinition());\n            }\n        }\n\n        private ConfigurationContextResolver processConfigurationContextResolverTag(Element element, ParserContext parserContext) {\n            if (element == null) {\n                BeanDefinitionBuilder contextResolverBean;\n                contextResolverBean = BeanDefinitionBuilder.rootBeanDefinition(DefaultConfigurationContextResolver.class);\n                parserContext.getRegistry().registerBeanDefinition(CONFIGURATION_CONTEXT_RESOLVER_NAME, contextResolverBean.getBeanDefinition());\n                return new DefaultConfigurationContextResolver();\n            } else {\n                String clazz = element.getAttribute(\"class\");\n                BeanDefinitionBuilder contextResolverBean = BeanDefinitionBuilder.rootBeanDefinition(clazz);\n                parserContext.getRegistry().registerBeanDefinition(CONFIGURATION_CONTEXT_RESOLVER_NAME, contextResolverBean.getBeanDefinition());\n                try {\n                    return (ConfigurationContextResolver) Class.forName(clazz).newInstance();\n                } catch (Exception e) {\n                    throw new IllegalStateException(\"Could not instansiate configuration context resolver with class [\" + clazz + \"]\", e);\n                }\n            }\n        }\n\n        private AssemblyContextResolver processAssemblyContextResolverTag(Element element, ParserContext parserContext) {\n            if (element == null) {\n                BeanDefinitionBuilder contextResolverBean;\n                contextResolverBean = BeanDefinitionBuilder.rootBeanDefinition(DefaultAssemblyContextResolver.class);\n                parserContext.getRegistry().registerBeanDefinition(ENVIRONMENT_CONTEXT_RESOLVER_NAME, contextResolverBean.getBeanDefinition());\n                return new DefaultAssemblyContextResolver();\n            } else {\n                String clazz = element.getAttribute(\"class\");\n                BeanDefinitionBuilder contextResolverBean = BeanDefinitionBuilder.rootBeanDefinition(clazz);\n                parserContext.getRegistry().registerBeanDefinition(ENVIRONMENT_CONTEXT_RESOLVER_NAME, contextResolverBean.getBeanDefinition());\n                try {\n                    return (AssemblyContextResolver) Class.forName(clazz).newInstance();\n                } catch (Exception e) {\n                    throw new IllegalStateException(\"Could not instansiate assembly context resolver with class [\" + clazz + \"]\", e);\n                }\n            }\n        }\n\n        public static List<Element> getAllChildElements(Element element) {\n            Assert.notNull(element, \"Element must not be null\");\n            NodeList childNodes = element.getChildNodes();\n            List<Element> childElements = new ArrayList<Element>();\n            for (int i = 0; i < childNodes.getLength(); i++) {\n                Node node = childNodes.item(i);\n                if (node instanceof Element) {\n                    childElements.add((Element) node);\n                }\n            }\n            return childElements;\n        }\n    }\n\n    private static class ImportDefinitionParser implements BeanDefinitionParser {\n\n        public BeanDefinition parse(Element element, ParserContext parserContext) {\n            String targetEnvironmentsCsv = element.getAttribute(\"environments\");\n            String resourcePath = element.getAttribute(\"resource\");\n            List<String> targetEnvironments = parseCSV(targetEnvironmentsCsv);\n\n            AssemblyContextResolver assemblyContextResolver = null;\n\n            if (parserContext.getRegistry().containsBeanDefinition(ENVIRONMENT_CONTEXT_RESOLVER_NAME)) {\n                BeanDefinition environmentContextResolverBeanDefinition = parserContext.getRegistry().getBeanDefinition(ENVIRONMENT_CONTEXT_RESOLVER_NAME);\n                String environmentResolverClassName = environmentContextResolverBeanDefinition.getBeanClassName();\n                try {\n                    assemblyContextResolver = (AssemblyContextResolver) Class.forName(environmentResolverClassName).newInstance();\n                } catch (Exception e) {\n                    throw new IllegalStateException(\"Could not instansiate assembly context resolver with class [\" + environmentResolverClassName + \"]\", e);\n                }\n            } else {\n                assemblyContextResolver = new DefaultAssemblyContextResolver();\n            }\n\n            List<String> assemblyContext = parseCSV(assemblyContextResolver.getAssemblyContext());\n            targetEnvironments.retainAll(assemblyContext);\n            boolean include = !targetEnvironments.isEmpty();\n            if (include) {\n                parserContext.getReaderContext().getReader().loadBeanDefinitions(resourcePath);\n            }\n            return null;\n        }\n\n        private List<String> parseCSV(String csv) {\n            List<String> elements = new ArrayList<String>();\n            for (String element : csv.split(\",\"))\n                elements.add(element);\n            return elements;\n        }\n    }\n\n}\n","lineNo":210}
{"Smelly Sample":"/*\n * Copyright 2008 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.constretto.spring;\n\nimport org.constretto.ConfigurationStore;\nimport org.constretto.ConstrettoConfiguration;\nimport org.constretto.internal.provider.ConfigurationProvider;\nimport org.constretto.internal.resolver.DefaultConfigurationContextResolver;\nimport org.springframework.beans.factory.FactoryBean;\n\nimport java.util.List;\n\n/**\n * @author <a href=\"mailto:kaare.nilsen@gmail.com\">Kaare Nilsen<\/a>\n */\n\npublic class ConstrettoConfigurationFactoryBean implements FactoryBean {\n    private List<ConfigurationStore> stores;\n\n    public ConstrettoConfigurationFactoryBean(List<ConfigurationStore> stores) {\n        this.stores = stores;\n    }\n\n    public Object getObject() throws Exception {\n        ConfigurationProvider configurationProvider = new ConfigurationProvider(new DefaultConfigurationContextResolver(), stores);\n        return configurationProvider.getConfiguration();\n    }\n\n    public Class getObjectType() {\n        return ConstrettoConfiguration.class;\n    }\n\n    public boolean isSingleton() {\n        return true;\n    }\n}\n","Method after Refactoring":"/*\n * Copyright 2008 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.constretto.spring;\n\nimport org.constretto.ConfigurationStore;\nimport org.constretto.ConstrettoConfiguration;\nimport org.constretto.internal.provider.ConfigurationProvider;\nimport org.constretto.internal.resolver.DefaultConfigurationContextResolver;\nimport org.constretto.internal.store.SystemPropertiesStore;\nimport org.constretto.resolver.ConfigurationContextResolver;\nimport org.springframework.beans.factory.FactoryBean;\n\nimport java.util.List;\n\n/**\n * @author <a href=\"mailto:kaare.nilsen@gmail.com\">Kaare Nilsen<\/a>\n */\n\npublic class ConstrettoConfigurationFactoryBean implements FactoryBean {\n    private final List<ConfigurationStore> stores;\n    private ConfigurationContextResolver configurationContextResolver;\n    private boolean systemPropertiesOverrides = true;\n\n    public ConstrettoConfigurationFactoryBean(List<ConfigurationStore> stores) {\n        this.stores = stores;\n    }\n\n    public Object getObject() throws Exception {\n        ConfigurationContextResolver contextResolver = configurationContextResolver == null ? new DefaultConfigurationContextResolver() : configurationContextResolver;\n        if (systemPropertiesOverrides) {\n            stores.add(new SystemPropertiesStore());\n        }\n        ConfigurationProvider configurationProvider = new ConfigurationProvider(contextResolver, stores);\n        return configurationProvider.getConfiguration();\n    }\n\n    public Class getObjectType() {\n        return ConstrettoConfiguration.class;\n    }\n\n    public boolean isSingleton() {\n        return true;\n    }\n\n    public void setConfigurationContextResolver(ConfigurationContextResolver configurationContextResolver) {\n        this.configurationContextResolver = configurationContextResolver;\n    }\n\n    public void setSystemPropertiesOverrides(boolean systemPropertiesOverrides) {\n        this.systemPropertiesOverrides = systemPropertiesOverrides;\n    }\n}\n","lineNo":42}
{"Smelly Sample":"/*\n * Copyright 2008 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.constretto.model;\n\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.ToStringBuilder;\nimport org.constretto.exception.ConstrettoExpressionException;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * \n * @author <a href=\"mailto:kaare.nilsen@gmail.com\">Kaare Nilsen<\/a>\n */\npublic class ConfigurationElement {\n    private ConfigurationElement parent;\n    private final String name;\n    private String value;\n    private final List<ConfigurationElement> children = new ArrayList<ConfigurationElement>();\n\n    public ConfigurationElement(String name) {\n        this.name = name;\n    }\n\n    String getName() {\n        return name;\n    }\n\n    public String getValue() {\n        return value;\n    }\n\n    void setValue(String value) {\n        this.value = value;\n    }\n\n    public ConfigurationElement find(String expression) {\n        ConfigurationElement currentElement = this;\n        for (String subExpression : expression.split(\"\\\\.\")) {\n            if (currentElement.containsChild(subExpression)) {\n                currentElement = currentElement.getChild(subExpression);\n            } else {\n                return null;\n            }\n        }\n        return currentElement;\n    }\n\n    public void remove(String expression) throws ConstrettoExpressionException {\n        ConfigurationElement currentElement = this;\n        for (String subExpression : expression.split(\"\\\\.\")) {\n            if (currentElement.containsChild(subExpression)) {\n                currentElement = currentElement.getChild(subExpression);\n            } else {\n                throw new ConstrettoExpressionException(expression, \"not found\");\n            }\n        }\n        ConfigurationElement parentElement = currentElement.parent;\n        parentElement.getChildren().remove(currentElement);\n    }\n\n    public void update(String expression, String value) {\n        ConfigurationElement currentElement = this;\n        if (expression.contains(\".\")) {\n            for (String subExpression : expression.split(\"\\\\.\")) {\n                if (!currentElement.containsChild(subExpression)) {\n                    ConfigurationElement newElement = new ConfigurationElement(subExpression);\n                    currentElement.addChild(newElement);\n                    currentElement = newElement;\n                } else {\n                    currentElement = currentElement.getChild(subExpression);\n                }\n            }\n        } else {\n            ConfigurationElement newElement = new ConfigurationElement(expression);\n            currentElement.addChild(newElement);\n            currentElement = newElement;\n        }\n        currentElement.setValue(value);\n    }\n\n    @Override\n    public String toString() {\n        return ToStringBuilder.reflectionToString(this);\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        return EqualsBuilder.reflectionEquals(obj, this);\n    }\n\n    private boolean containsChild(String name) {\n        for (ConfigurationElement currentElement : children) {\n            if (currentElement.getName().equals(name)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private void addChild(ConfigurationElement configurationElement) {\n        children.add(configurationElement);\n        configurationElement.parent = this;\n    }\n\n    private List<ConfigurationElement> getChildren() {\n        return children;\n    }\n\n    private ConfigurationElement getChild(String name) {\n        for (ConfigurationElement currentElement : children) {\n            if (currentElement.getName().equals(name)) {\n                return currentElement;\n            }\n        }\n        return null;\n    }\n}\n","Method after Refactoring":"/*\n * Copyright 2008 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.constretto.model;\n\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.constretto.exception.ConstrettoExpressionException;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * @author <a href=\"mailto:kaare.nilsen@gmail.com\">Kaare Nilsen<\/a>\n */\npublic class ConfigurationElement {\n    private ConfigurationElement parent;\n    private final String name;\n    private String value;\n    private String tag;\n    private int priority;\n    private final List<ConfigurationElement> children = new ArrayList<ConfigurationElement>();\n\n    public ConfigurationElement(String name) {\n        this.name = name;\n    }\n\n    String getName() {\n        return name;\n    }\n\n    public String getValue() {\n        return value;\n    }\n\n    void setValue(String value) {\n        this.value = value;\n    }\n\n    public ConfigurationElement find(String expression) {\n        ConfigurationElement currentElement = this;\n        for (String subExpression : expression.split(\"\\\\.\")) {\n            if (currentElement.containsChild(subExpression)) {\n                currentElement = currentElement.getChild(subExpression);\n            } else {\n                return null;\n            }\n        }\n        return currentElement;\n    }\n\n    public void remove(String expression) throws ConstrettoExpressionException {\n        ConfigurationElement currentElement = this;\n        for (String subExpression : expression.split(\"\\\\.\")) {\n            if (currentElement.containsChild(subExpression)) {\n                currentElement = currentElement.getChild(subExpression);\n            } else {\n                throw new ConstrettoExpressionException(expression, \"not found\");\n            }\n        }\n        ConfigurationElement parentElement = currentElement.parent;\n        parentElement.getChildren().remove(currentElement);\n    }\n\n    public void update(String expression, String value, String tag, int priority) {\n        ConfigurationElement currentElement = this;\n        if (expression.contains(\".\")) {\n            for (String subExpression : expression.split(\"\\\\.\")) {\n                if (!currentElement.containsChild(subExpression)) {\n                    ConfigurationElement newElement = new ConfigurationElement(subExpression);\n                    currentElement.addChild(newElement);\n                    currentElement = newElement;\n                } else {\n                    currentElement = currentElement.getChild(subExpression);\n                }\n            }\n        } else {\n            ConfigurationElement newElement = new ConfigurationElement(expression);\n            currentElement.addChild(newElement);\n            currentElement = newElement;\n        }\n        currentElement.setValue(value);\n    }\n\n    @Override\n    public String toString() {\n        return \"ConfigurationElement{\" +\n                \"name='\" + name + '\\'' +\n                \", value='\" + value + '\\'' +\n                \", tag='\" + tag + '\\'' +\n                '}';\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        return EqualsBuilder.reflectionEquals(obj, this);\n    }\n\n    private boolean containsChild(String name) {\n        for (ConfigurationElement currentElement : children) {\n            if (currentElement.getName().equals(name)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private void addChild(ConfigurationElement configurationElement) {\n        children.add(configurationElement);\n        configurationElement.parent = this;\n    }\n\n    private List<ConfigurationElement> getChildren() {\n        return children;\n    }\n\n    private ConfigurationElement getChild(String name) {\n        ConfigurationElement foundElement = null;\n        for (ConfigurationElement currentElement : children) {\n            if (currentElement.getName().equals(name)) {\n                foundElement = currentElement;\n            }\n        }\n        return foundElement;\n    }\n\n\n}\n","lineNo":129}
{"Smelly Sample":"/*\n * Copyright 2008 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.constretto.internal.store;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertNull;\nimport static org.junit.Assert.fail;\n\nimport java.util.Collection;\n\nimport org.constretto.ConfigurationStore;\nimport org.constretto.model.PropertySet;\nimport org.junit.Test;\n\n/**\n * @author <a href=\"mailto:thor.aage.eldby@arktekk.no\">Thor &Aring;ge Eldby<\/a>\n */\npublic abstract class AbstractConfigurationStoreTest {\n\n    @Test\n    public void load() {\n        Collection<PropertySet> props = getStore().load();\n        assertNotNull(props);\n        assertEquals(\"Unexpected number of labels in ini file\", 3, props.size());\n        for (PropertySet prop : props) {\n            String value = prop.getProperties().get(\"somedb.username\");\n            if (prop.getLabel() == null) {\n                assertEquals(\"user0\", value);\n            } else if (prop.getLabel().equals(\"production\")) {\n                assertEquals(\"user1\", value);\n            } else if (prop.getLabel().equals(\"systest\")) {\n                assertEquals(\"user2\", value);\n            } else {\n                fail(\"Unexpected label \" + prop.getLabel());\n            }\n            assertNull(prop.getProperties().get(\"barekudd\"));\n        }\n    }\n\n    abstract protected ConfigurationStore getStore();\n\n}\n","Method after Refactoring":"/*\n * Copyright 2008 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.constretto.internal.store;\n\nimport org.constretto.ConfigurationStore;\nimport org.constretto.model.ConfigurationSet;\nimport static org.junit.Assert.*;\nimport org.junit.Test;\n\nimport java.util.Collection;\n\n/**\n * @author <a href=\"mailto:thor.aage.eldby@arktekk.no\">Thor &Aring;ge Eldby<\/a>\n */\npublic abstract class AbstractConfigurationStoreTest {\n\n    @Test\n    public void load() {\n        ConfigurationStore store = getStore();\n        Collection<ConfigurationSet> props = store.load();\n        assertNotNull(props);\n        assertEquals(\"Unexpected number of tags loaded for \" + store, 3, props.size());\n        for (ConfigurationSet prop : props) {\n            String value = prop.getProperties().get(\"somedb.username\");\n            if (prop.getTag() == null) {\n                assertEquals(\"user0\", value);\n            } else if (prop.getTag().equals(\"production\")) {\n                assertEquals(\"user1\", value);\n            } else if (prop.getTag().equals(\"systest\")) {\n                assertEquals(\"user2\", value);\n            } else {\n                fail(\"Unexpected tag \" + prop.getTag());\n            }\n            assertNull(prop.getProperties().get(\"barekudd\"));\n        }\n    }\n\n    abstract protected ConfigurationStore getStore();\n\n}\n","lineNo":32}
