{"Smelly Sample":"//Prevayler(TM) - The Free-Software Prevalence Layer.\n//Copyright (C) 2001-2003 Klaus Wuestefeld\n//This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\npackage org.prevayler.implementation.replication;\n\nimport org.prevayler.foundation.network.ObjectSocket;\nimport org.prevayler.implementation.Capsule;\nimport org.prevayler.implementation.TransactionCapsule;\nimport org.prevayler.implementation.TransactionTimestamp;\nimport org.prevayler.implementation.publishing.POBox;\nimport org.prevayler.implementation.publishing.TransactionPublisher;\nimport org.prevayler.implementation.publishing.TransactionSubscriber;\n\nimport java.io.IOException;\nimport java.util.Date;\n\n\n/** Reserved for future implementation.\n */\nclass ServerConnection extends Thread implements TransactionSubscriber {\n\n\tstatic final String SUBSCRIBER_UP_TO_DATE = \"SubscriberUpToDate\";\n\tstatic final String REMOTE_TRANSACTION = \"RemoteTransaction\";\n\tstatic final String CLOCK_TICK = \"ClockTick\";\n\n\tprivate final TransactionPublisher _publisher;\n\tprivate TransactionCapsule _remoteCapsule;\n\n\tprivate final ObjectSocket _remote;\n\tprivate Thread _clockTickSender = createClockTickSender();\n\tprivate boolean _isClosing = false;\n\n\n\tServerConnection(TransactionPublisher publisher, ObjectSocket remoteSocket) throws IOException {\n\t\t_publisher = publisher;\n\t\t_remote = remoteSocket;\n\t\tsetDaemon(true);\n\t\tstart();\n\t}\n\n\n\n\tpublic void run() {\n\t\ttry {\t\t\n\t\t\tlong initialTransaction = ((Long)_remote.readObject()).longValue();\n\t\t\t_publisher.subscribe(new POBox(this), initialTransaction);\n\t\t\tsend(SUBSCRIBER_UP_TO_DATE);\n\t\t\t\n\t\t\tsendClockTicks();\n\t\t\twhile (true) publishRemoteTransaction();\n\t\t} catch (Exception ex) {\n\t\t\tclose();\n\t\t}\n\t}\n\n\n\tprivate void sendClockTicks() {\n\t\t_clockTickSender.setDaemon(true);\n\t\t_clockTickSender.start();\n\t}\n\n\n\tprivate Thread createClockTickSender() {\n\t\treturn new Thread() { //TODO Create foundation.Daemon.\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\t\tsynchronized (_remote) {\n\t\t\t\t\t\t\t\t\t_remote.writeObject(CLOCK_TICK);\n\t\t\t\t\t\t\t\t\t_remote.writeObject(_publisher.clock().time());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (InterruptedException ix) {\n\t\t\t\t\t\t} catch (IOException iox) {\n\t\t\t\t\t\t\tclose();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t}\n\n\n\n\tvoid publishRemoteTransaction() throws IOException, ClassNotFoundException {\n\t\t_remoteCapsule = (TransactionCapsule)_remote.readObject();\n\t\ttry {\n\t\t\t_publisher.publish(_remoteCapsule);\n\t\t} catch (RuntimeException rx) {\n\t\t\tsend(rx);\n\t\t} catch (Error error) {\n\t\t\tsend(error);\n\t\t}\n\t}\n\n\n\tpublic void receive(TransactionTimestamp transactionTimestamp) {\n\t\tCapsule capsule = transactionTimestamp.capsule();\n\t\tlong systemVersion = transactionTimestamp.systemVersion();\n\t\tDate executionTime = transactionTimestamp.executionTime();\n\n\t\ttry {\n\t\t\tsynchronized (_remote) {\n\t\t\t\t_remote.writeObject(capsule == _remoteCapsule\n\t\t\t\t\t? (Object)REMOTE_TRANSACTION\n\t\t\t\t\t: capsule\n\t\t\t\t);\n\t\t\t\t_remote.writeObject(executionTime);\n\t\t\t\t_remote.writeObject(new Long(systemVersion));\n\t\t\t}\n\t\t} catch (IOException ex) {\n\t\t\tclose();\n\t\t}\n\t}\n\n\n\tprivate synchronized void close() {\n\t\t_clockTickSender.interrupt();\n\t\tthis.interrupt();\n\t\t_publisher.cancelSubscription(this);\n\t}\n\n\n\n\tprivate void send(Object object) {\n\t\tsynchronized (_remote) {\n\t\t\ttry {\n\t\t\t\t_remote.writeObject(object);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\n}\n","Method after Refactoring":"//Prevayler(TM) - The Free-Software Prevalence Layer.\n//Copyright (C) 2001-2003 Klaus Wuestefeld\n//This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\npackage org.prevayler.implementation.replication;\n\nimport org.prevayler.foundation.network.ObjectSocket;\nimport org.prevayler.implementation.Capsule;\nimport org.prevayler.implementation.TransactionCapsule;\nimport org.prevayler.implementation.TransactionTimestamp;\nimport org.prevayler.implementation.publishing.POBox;\nimport org.prevayler.implementation.publishing.TransactionPublisher;\nimport org.prevayler.implementation.publishing.TransactionSubscriber;\n\nimport java.io.IOException;\n\n\n/** Reserved for future implementation.\n */\nclass ServerConnection extends Thread implements TransactionSubscriber {\n\n\tstatic final String SUBSCRIBER_UP_TO_DATE = \"SubscriberUpToDate\";\n\tstatic final String REMOTE_TRANSACTION = \"RemoteTransaction\";\n\n\tprivate final TransactionPublisher _publisher;\n\tprivate Capsule _remoteCapsule;\n\n\tprivate final ObjectSocket _remote;\n\tprivate Thread _clockTickSender = createClockTickSender();\n\tprivate boolean _isClosing = false;\n\n\n\tServerConnection(TransactionPublisher publisher, ObjectSocket remoteSocket) throws IOException {\n\t\t_publisher = publisher;\n\t\t_remote = remoteSocket;\n\t\tsetDaemon(true);\n\t\tstart();\n\t}\n\n\n\n\tpublic void run() {\n\t\ttry {\t\t\n\t\t\tlong initialTransaction = ((Long)_remote.readObject()).longValue();\n\t\t\t\n\t\t\tPOBox poBox = new POBox(this);\n\t\t\t_publisher.subscribe(poBox, initialTransaction);\n\t\t\tpoBox.waitToEmpty();\n\t\t\t\n\t\t\tsend(SUBSCRIBER_UP_TO_DATE);\n\t\t\t\n\t\t\tsendClockTicks();\n\t\t\twhile (true) publishRemoteTransaction();\n\t\t} catch (Exception ex) {\n\t\t\tclose();\n\t\t}\n\t}\n\n\n\tprivate void sendClockTicks() {\n\t\t_clockTickSender.setDaemon(true);\n\t\t_clockTickSender.start();\n\t}\n\n\n\tprivate Thread createClockTickSender() {\n\t\treturn new Thread() { //TODO Create foundation.Daemon.\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\t\tsynchronized (_remote) {\n\t\t\t\t\t\t\t\t\t_remote.writeObject(_publisher.clock().time());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (InterruptedException ix) {\n\t\t\t\t\t\t} catch (IOException iox) {\n\t\t\t\t\t\t\tclose();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t}\n\n\n\n\tvoid publishRemoteTransaction() throws IOException, ClassNotFoundException {\n\t\t_remoteCapsule = (TransactionCapsule)_remote.readObject();\n\t\ttry {\n\t\t\t_publisher.publish(_remoteCapsule);\n\t\t} catch (RuntimeException rx) {\n\t\t\tsend(rx);\n\t\t} catch (Error error) {\n\t\t\tsend(error);\n\t\t}\n\t}\n\n\n\tpublic void receive(TransactionTimestamp tt) {\n\t\t\n\t\tif (tt.capsule() == _remoteCapsule)\n\t\t\ttt = new TransactionTimestamp(null, tt.systemVersion(), tt.executionTime()); //TODO This is really ugly. It is using a null capsule inside the TransactionTimestamp to signal that the remote Capsule should be executed.\n\t\t\n\t\ttry {\n\t\t\tsynchronized (_remote) {\n\t\t\t\t_remote.writeObject(tt);\n\t\t\t}\n\t\t} catch (IOException ex) {\n\t\t\tclose();\n\t\t}\n\t}\n\n\n\tprivate synchronized void close() {\n\t\t_clockTickSender.interrupt();\n\t\tthis.interrupt();\n\t\t_publisher.cancelSubscription(this);\n\t}\n\n\n\n\tprivate void send(Object object) {\n\t\tsynchronized (_remote) {\n\t\t\ttry {\n\t\t\t\t_remote.writeObject(object);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\n}\n","lineNo":46}