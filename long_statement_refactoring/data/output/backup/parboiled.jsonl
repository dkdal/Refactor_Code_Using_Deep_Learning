{"Refactored Sample":"/*\n * Copyright (C) 2009-2011 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.transform;\n\nimport org.parboiled.BaseParser;\nimport org.parboiled.Parboiled;\nimport org.parboiled.Rule;\nimport org.parboiled.annotations.BuildParseTree;\nimport org.parboiled.annotations.Cached;\nimport org.parboiled.annotations.MemoMismatches;\nimport org.parboiled.parserunners.ReportingParseRunner;\nimport org.testng.annotations.Test;\n\nimport static org.parboiled.transform.AsmTestUtils.getMethodInstructionList;\nimport static org.parboiled.transform.AsmTestUtils.verifyIntegrity;\nimport static org.testng.Assert.assertEquals;\n\npublic class BugIn101Test {\n\n    static class Parser extends BaseParser<Object> {\n        Rule A() {\n            Object a = new Object();\n            return Sequence(\"a\", push(a));\n        }\n        Rule B() {\n            String b = \"b\";\n            return Sequence(\"b\", push(b));\n        }\n        Rule Switch(int i) {\n            switch (i) {\n                case 0: return Sequence(EMPTY, push(1));\n            }\n            return null;\n        }\n    }\n\n    @Test\n    public void test() throws Exception {\n        // threw \"java.lang.RuntimeException: Error creating extended parser class:\n        // Execution can fall off end of the code\" in 1.0.1\n        Parser parser = Parboiled.createParser(Parser.class);\n\n        // threw \"java.lang.NoSuchFieldError: field$1\" in 1.0.1\n        new ReportingParseRunner<Object>(parser.B()).run(\"b\");\n    }\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009-2011 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.transform;\n\nimport org.parboiled.BaseParser;\nimport org.parboiled.Parboiled;\nimport org.parboiled.Rule;\nimport org.parboiled.annotations.BuildParseTree;\nimport org.parboiled.annotations.MemoMismatches;\nimport org.parboiled.parserunners.ReportingParseRunner;\nimport org.testng.annotations.Test;\n\nimport static org.parboiled.transform.AsmTestUtils.getMethodInstructionList;\nimport static org.parboiled.transform.AsmTestUtils.verifyIntegrity;\nimport static org.testng.Assert.assertEquals;\n\npublic class BugIn101Test {\n\n    static class Parser extends BaseParser<Object> {\n        public Rule A() {\n            Object a = new Object();\n            return Sequence(\"a\", push(a));\n        }\n        protected Rule B() {\n            String b = \"b\";\n            return Sequence(\"b\", push(b));\n        }\n    }\n\n    @Test\n    public void verifyTestParserHierarchyExtension() throws Exception {\n        // threw \"java.lang.NoSuchFieldError: field$1\" in 1.0.1\n        new ReportingParseRunner<Object>(Parboiled.createParser(Parser.class).B()).run(\"b\");\n    }\n}\n","lineNo":55}
{"Refactored Sample":"/*\n * Copyright (C) 2009-2010 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.errors;\n\nimport org.parboiled.common.Formatter;\nimport org.parboiled.common.StringUtils;\nimport org.parboiled.matchers.AnyOfMatcher;\nimport org.parboiled.matchers.Matcher;\nimport org.parboiled.support.MatcherPath;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * A {@link Formatter} for {@link InvalidInputError}s that automatically creates the correct \"expected\" text\n * for the error.\n */\npublic class DefaultInvalidInputErrorFormatter implements Formatter<InvalidInputError> {\n\n    public String format(InvalidInputError error) {\n        if (error == null) return \"\";\n\n        int len = error.getEndIndex() - error.getStartIndex();\n        StringBuilder sb = new StringBuilder(\"Invalid input\");\n        if (len > 0) {\n            sb.append(\" '\")\n                    .append(StringUtils.escape(String.valueOf(error.getInputBuffer().charAt(error.getStartIndex()))));\n            if (len > 1) sb.append(\"...\");\n            sb.append('\\'');\n        }\n        String expectedString = getExpectedString(error);\n        if (StringUtils.isNotEmpty(expectedString)) {\n            sb.append(\", expected \").append(expectedString);\n        }\n        return sb.toString();\n    }\n\n    public String getExpectedString(InvalidInputError error) {\n        // In non recovery-mode there is no complexity in the error and start indices since they are all stable.\n        // However, in recovery-mode the RecoveringParseRunner inserts characters into the InputBuffer, which requires\n        // for all indices taken before to be shifted. The RecoveringParseRunner does this by changing the indexDelta\n        // of the parse runner. All users of the ParseError will then automatically see shifted start and end indices\n        // matching the state of the underlying InputBuffer. However, since the failed MatcherPaths still carry the\n        // \"original\" indices we need to unapply the IndexDelta in order to be able to compare with them.\n        int pathStartIndex = error.getStartIndex() - error.getIndexDelta();\n\n        List<String> labelList = new ArrayList<String>();\n        for (MatcherPath path : error.getFailedMatchers()) {\n            Matcher labelMatcher = ErrorUtils.findProperLabelMatcher(path, pathStartIndex);\n            if (labelMatcher == null) continue;\n            String[] labels = getLabels(labelMatcher);\n            for (String label : labels) {\n                if (label != null && !labelList.contains(label)) {\n                    labelList.add(label);\n                }\n            }\n        }\n        return join(labelList);\n    }\n\n    /**\n     * Gets the labels corresponding to the given matcher, AnyOfMatchers are treated specially in that their\n     * label is constructed as a list of their contents\n     *\n     * @param matcher the matcher\n     * @return the labels\n     */\n    public String[] getLabels(Matcher matcher) {\n        if ((matcher instanceof AnyOfMatcher) && ((AnyOfMatcher)matcher).characters.toString().equals(matcher.getLabel())) {\n            AnyOfMatcher cMatcher = (AnyOfMatcher) matcher;\n            if (!cMatcher.characters.isSubtractive()) {\n                String[] labels = new String[cMatcher.characters.getChars().length];\n                for (int i = 0; i < labels.length; i++) {\n                    labels[i] = '\\'' + String.valueOf(cMatcher.characters.getChars()[i]) + '\\'';\n                }\n                return labels;\n            }\n        }\n        return new String[] {matcher.getLabel()};\n    }\n\n    public String join(List<String> labelList) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < labelList.size(); i++) {\n            if (i > 0) sb.append(i < labelList.size() - 1 ? \", \" : \" or \");\n            sb.append(labelList.get(i));\n        }\n        return StringUtils.escape(sb.toString());\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009-2010 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.errors;\n\nimport org.parboiled.common.Formatter;\nimport org.parboiled.common.StringUtils;\nimport org.parboiled.matchers.AnyOfMatcher;\nimport org.parboiled.matchers.Matcher;\nimport org.parboiled.support.MatcherPath;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * A {@link Formatter} for {@link InvalidInputError}s that automatically creates the correct \"expected\" text\n * for the error.\n */\npublic class DefaultInvalidInputErrorFormatter implements Formatter<InvalidInputError> {\n\n    public String format(InvalidInputError error) {\n        if (error == null) return \"\";\n\n        String errorMessage = String.format(\"Invalid input '%s%s'\", StringUtils.escape(String.valueOf(\n                error.getInputBuffer().charAt(error.getStartIndex()))),\n                error.getEndIndex() - error.getStartIndex() > 1 ? \"...\" : \"\"\n        );\n        String expectedString = getExpectedString(error);\n        return StringUtils.isEmpty(expectedString) ? errorMessage : errorMessage + \", expected \" + expectedString;\n    }\n\n    public String getExpectedString(InvalidInputError error) {\n        // In non recovery-mode there is no complexity in the error and start indices since they are all stable.\n        // However, in recovery-mode the RecoveringParseRunner inserts characters into the InputBuffer, which requires\n        // for all indices taken before to be shifted. The RecoveringParseRunner does this by changing the indexDelta\n        // of the parse runner. All users of the ParseError will then automatically see shifted start and end indices\n        // matching the state of the underlying InputBuffer. However, since the failed MatcherPaths still carry the\n        // \"original\" indices we need to unapply the IndexDelta in order to be able to compare with them.\n        int pathStartIndex = error.getStartIndex() - error.getIndexDelta();\n\n        List<String> labelList = new ArrayList<String>();\n        for (MatcherPath path : error.getFailedMatchers()) {\n            Matcher labelMatcher = ErrorUtils.findProperLabelMatcher(path, pathStartIndex);\n            if (labelMatcher == null) continue;\n            String[] labels = getLabels(labelMatcher);\n            for (String label : labels) {\n                if (label != null && !labelList.contains(label)) {\n                    labelList.add(label);\n                }\n            }\n        }\n        return join(labelList);\n    }\n\n    /**\n     * Gets the labels corresponding to the given matcher, AnyOfMatchers are treated specially in that their\n     * label is constructed as a list of their contents\n     *\n     * @param matcher the matcher\n     * @return the labels\n     */\n    public String[] getLabels(Matcher matcher) {\n        if ((matcher instanceof AnyOfMatcher) && ((AnyOfMatcher)matcher).characters.toString().equals(matcher.getLabel())) {\n            AnyOfMatcher cMatcher = (AnyOfMatcher) matcher;\n            if (!cMatcher.characters.isSubtractive()) {\n                String[] labels = new String[cMatcher.characters.getChars().length];\n                for (int i = 0; i < labels.length; i++) {\n                    labels[i] = '\\'' + String.valueOf(cMatcher.characters.getChars()[i]) + '\\'';\n                }\n                return labels;\n            }\n        }\n        return new String[] {matcher.getLabel()};\n    }\n\n    public String join(List<String> labelList) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < labelList.size(); i++) {\n            if (i > 0) sb.append(i < labelList.size() - 1 ? \", \" : \" or \");\n            sb.append(labelList.get(i));\n        }\n        return StringUtils.escape(sb.toString());\n    }\n\n}\n","lineNo":37}
{"Refactored Sample":"/*\n * Copyright (C) 2009-2010 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.parserunners;\n\nimport org.parboiled.MatchHandler;\nimport org.parboiled.MatcherContext;\nimport org.parboiled.Rule;\nimport org.parboiled.buffers.InputBuffer;\nimport org.parboiled.buffers.MutableInputBuffer;\nimport org.parboiled.common.ImmutableLinkedList;\nimport org.parboiled.common.ImmutableList;\nimport org.parboiled.common.Preconditions;\nimport org.parboiled.errors.InvalidInputError;\nimport org.parboiled.matchers.*;\nimport org.parboiled.matchervisitors.*;\nimport org.parboiled.support.Checks;\nimport org.parboiled.support.MatcherPath;\nimport org.parboiled.support.ParsingResult;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.parboiled.common.Preconditions.checkArgNotNull;\nimport static org.parboiled.common.Preconditions.checkState;\nimport static org.parboiled.matchers.MatcherUtils.unwrap;\nimport static org.parboiled.support.Chars.*;\n\n/**\n * A {@link org.parboiled.parserunners.ParseRunner} implementation that is able to recover from {@link org.parboiled.errors.InvalidInputError}s in the input and therefore\n * report more than just the first {@link org.parboiled.errors.InvalidInputError} if the input does not conform to the rule grammar.\n * Error recovery is done by attempting to either delete an error character, insert a potentially missing character\n * or do both at once (which is equivalent to a one char replace) whereby this implementation is able to determine\n * itself which of these options is the best strategy.\n * If the parse error cannot be overcome by either deleting, inserting or replacing one character a resynchronization\n * rule is determined and the parsing process resynchronized, so that parsing can still continue.\n * In this way the RecoveringParseRunner is able to completely parse all input texts (This ParseRunner never returns\n * an unmatched {@link org.parboiled.support.ParsingResult}).\n * If the input is error free this {@link org.parboiled.parserunners.ParseRunner} implementation will only perform one parsing run, with the same\n * speed as the {@link org.parboiled.parserunners.BasicParseRunner}. However, if there are {@link org.parboiled.errors.InvalidInputError}s in the input potentially\n * many more runs are performed to properly report all errors and test the various recovery strategies.\n */\npublic class RecoveringParseRunner<V> extends AbstractParseRunner<V> {\n    private int errorIndex;\n    private InvalidInputError currentError;\n    private MutableInputBuffer buffer;\n    private ParsingResult<V> lastParsingResult;\n    private Matcher rootMatcherWithoutPTB; // the root matcher with parse tree building disabled\n\n    /**\n     * Create a new RecoveringParseRunner instance with the given rule and input text and returns the result of\n     * its {@link #run(String)} method invocation.\n     *\n     * @param rule  the parser rule to run\n     * @param input the input text to run on\n     * @return the ParsingResult for the parsing run\n     * @deprecated As of 0.11.0 you should use the \"regular\" constructor and one of the \"run\" methods rather than\n     *             this static method. This method will be removed in one of the coming releases.\n     */\n    @Deprecated\n    public static <V> ParsingResult<V> run(Rule rule, String input) {\n        checkArgNotNull(rule, \"rule\");\n        checkArgNotNull(input, \"input\");\n        return new RecoveringParseRunner<V>(rule).run(input);\n    }\n\n    /**\n     * Creates a new RecoveringParseRunner instance for the given rule.\n     *\n     * @param rule the parser rule\n     */\n    public RecoveringParseRunner(Rule rule) {\n        super(rule);\n    }\n\n    public ParsingResult<V> run(InputBuffer inputBuffer) {\n        checkArgNotNull(inputBuffer, \"inputBuffer\");\n        resetValueStack();\n\n        // first, run a basic match\n        ParseRunner<V> basicRunner = new BasicParseRunner<V>(getRootMatcher())\n                .withParseErrors(getParseErrors())\n                .withValueStack(getValueStack());\n        lastParsingResult = basicRunner.run(inputBuffer);\n\n        if (!lastParsingResult.matched) {\n            // for better performance disable parse tree building during the recovery runs\n            rootMatcherWithoutPTB = (Matcher) getRootMatcher().suppressNode();\n\n            // locate first error\n            performLocatingRun(inputBuffer);\n            checkState(errorIndex >= 0); // we failed before so we must fail again\n\n            // in order to be able to apply fixes we need to wrap the input buffer with a mutability wrapper\n            buffer = new MutableInputBuffer(inputBuffer);\n\n            // report first error\n            performReportingRun();\n\n            // fix and report until done\n            while (!fixError(errorIndex)) {\n                performReportingRun();\n            }\n\n            // rerun once more with parse tree building enabled to create a parse tree for the fixed input\n            if (!getRootMatcher().isNodeSuppressed()) {\n                performFinalRun();\n                checkState(lastParsingResult.matched);\n            }\n        }\n        return lastParsingResult;\n    }\n\n    private boolean performLocatingRun(InputBuffer inputBuffer) {\n        resetValueStack();\n        ParseRunner<V> locatingRunner = new ErrorLocatingParseRunner<V>(rootMatcherWithoutPTB, getInnerHandler())\n                .withParseErrors(getParseErrors())\n                .withValueStack(getValueStack());\n        lastParsingResult = locatingRunner.run(inputBuffer);\n        errorIndex = lastParsingResult.matched ? -1 :\n                getParseErrors().remove(getParseErrors().size() - 1).getStartIndex();\n        return lastParsingResult.matched;\n    }\n\n    private void performReportingRun() {\n        resetValueStack();\n        ParseRunner<V> reportingRunner = new ErrorReportingParseRunner<V>(rootMatcherWithoutPTB, errorIndex,\n                getInnerHandler())\n                .withParseErrors(getParseErrors())\n                .withValueStack(getValueStack());\n        ParsingResult<V> result = reportingRunner.run(buffer);\n        Preconditions.checkState(!result.matched); // we failed before so we should really be failing again\n        currentError = (InvalidInputError) getParseErrors().get(getParseErrors().size() - 1);\n    }\n\n    private void performFinalRun() {\n        resetValueStack();\n        Handler handler = new Handler();\n        MatcherContext<V> rootContext = createRootContext(buffer, handler, false);\n        boolean matched = handler.match(rootContext);\n        lastParsingResult = createParsingResult(matched, rootContext);\n    }\n\n    private MatchHandler getInnerHandler() {\n        return errorIndex >= 0 ? new Handler() : null;\n    }\n\n    private boolean fixError(int fixIndex) {\n        if (tryFixBySingleCharDeletion(fixIndex)) return true;\n        int nextErrorAfterDeletion = errorIndex;\n\n        Character bestInsertionCharacter = findBestSingleCharInsertion(fixIndex);\n        if (bestInsertionCharacter == null) return true;\n        int nextErrorAfterBestInsertion = errorIndex;\n\n        Character bestReplacementCharacter = findBestSingleCharReplacement(fixIndex);\n        if (bestReplacementCharacter == null) return true;\n        int nextErrorAfterBestReplacement = errorIndex;\n\n        int nextErrorAfterBestSingleCharFix =\n                Math.max(Math.max(nextErrorAfterDeletion, nextErrorAfterBestInsertion), nextErrorAfterBestReplacement);\n        if (nextErrorAfterBestSingleCharFix > fixIndex) {\n            // we are able to overcome the error with a single char fix, so apply the best one found\n            if (nextErrorAfterBestSingleCharFix == nextErrorAfterDeletion) {\n                buffer.insertChar(fixIndex, DEL_ERROR);\n                errorIndex = nextErrorAfterDeletion + 1;\n                currentError.shiftIndexDeltaBy(1);\n            } else if (nextErrorAfterBestSingleCharFix == nextErrorAfterBestInsertion) {\n                // we need to insert the characters in reverse order, since we insert twice at the same location\n                buffer.insertChar(fixIndex, bestInsertionCharacter);\n                buffer.insertChar(fixIndex, INS_ERROR);\n                errorIndex = nextErrorAfterBestInsertion + 2;\n                currentError.shiftIndexDeltaBy(2);\n            } else {\n                // we need to insert the characters in reverse order, since we insert three times at the same location\n                buffer.insertChar(fixIndex + 1, bestReplacementCharacter);\n                buffer.insertChar(fixIndex + 1, INS_ERROR);\n                buffer.insertChar(fixIndex, DEL_ERROR);\n                errorIndex = nextErrorAfterBestReplacement + 5;\n                currentError.shiftIndexDeltaBy(1);\n            }\n        } else {\n            // we can't fix the error with a single char fix, so fall back to resynchronization\n            if (buffer.charAt(fixIndex) == EOI) {\n                buffer.insertChar(fixIndex, RESYNC_EOI);\n                currentError.shiftIndexDeltaBy(1);\n                return true;\n            }\n            buffer.insertChar(fixIndex, RESYNC);\n            currentError.shiftIndexDeltaBy(1);\n            performLocatingRun(buffer); // find the next parse error\n        }\n        return errorIndex == -1;\n    }\n\n    private boolean tryFixBySingleCharDeletion(int fixIndex) {\n        buffer.insertChar(fixIndex, DEL_ERROR);\n        boolean nowErrorFree = performLocatingRun(buffer);\n        if (nowErrorFree) {\n            currentError.shiftIndexDeltaBy(1); // compensate for the inserted DEL_ERROR char\n        } else {\n            buffer.undoCharInsertion(fixIndex);\n            errorIndex = Math.max(errorIndex - 1, 0);\n        }\n        return nowErrorFree;\n    }\n\n    @SuppressWarnings( {\"ConstantConditions\"})\n    private Character findBestSingleCharInsertion(int fixIndex) {\n        GetStarterCharVisitor getStarterCharVisitor = new GetStarterCharVisitor();\n        int bestNextErrorIndex = -1;\n        Character bestChar = null;\n        for (MatcherPath failedMatcherPath : currentError.getFailedMatchers()) {\n            Character starterChar = failedMatcherPath.element.matcher.accept(getStarterCharVisitor);\n            checkState(starterChar != null); // we should only have single character matchers\n            if (starterChar == EOI) {\n                continue; // we should never conjure up an EOI character (that would be cheating :)\n            }\n            buffer.insertChar(fixIndex, starterChar);\n            buffer.insertChar(fixIndex, INS_ERROR);\n            if (performLocatingRun(buffer)) {\n                currentError.shiftIndexDeltaBy(2); // compensate for the inserted chars\n                return null; // success, exit immediately\n            }\n            buffer.undoCharInsertion(fixIndex);\n            buffer.undoCharInsertion(fixIndex);\n            errorIndex = Math.max(errorIndex - 2, 0);\n\n            if (bestNextErrorIndex < errorIndex) {\n                bestNextErrorIndex = errorIndex;\n                bestChar = starterChar;\n            }\n        }\n        errorIndex = bestNextErrorIndex;\n        return bestChar;\n    }\n\n    private Character findBestSingleCharReplacement(int fixIndex) {\n        buffer.insertChar(fixIndex, DEL_ERROR);\n        Character bestChar = findBestSingleCharInsertion(fixIndex + 2);\n        if (bestChar == null) { // success, we found a fix that renders the complete input error free\n            currentError\n                    .shiftIndexDeltaBy(-1); // delta from DEL_ERROR char insertion and index shift by insertion method\n        } else {\n            buffer.undoCharInsertion(fixIndex);\n            errorIndex = Math.max(errorIndex - 3, 0);\n        }\n        return bestChar;\n    }\n\n    /**\n     * A {@link org.parboiled.MatchHandler} implementation that recognizes the special\n     * {@link org.parboiled.support.Chars#RESYNC} character to overcome {@link InvalidInputError}s at the respective\n     * error indices.\n     */\n    private class Handler implements MatchHandler {\n        private final IsSingleCharMatcherVisitor isSingleCharMatcherVisitor = new IsSingleCharMatcherVisitor();\n        private int fringeIndex;\n        private MatcherPath lastMatchPath;\n\n        public boolean match(MatcherContext<?> context) {\n            Matcher matcher = context.getMatcher();\n            if (matcher.accept(isSingleCharMatcherVisitor)) {\n                if (prepareErrorLocation(context) && matcher.match(context)) {\n                    if (fringeIndex < context.getCurrentIndex()) {\n                        fringeIndex = context.getCurrentIndex();\n                        lastMatchPath = context.getPath();\n                    }\n                    return true;\n                }\n                return false;\n            }\n\n            if (matcher.match(context)) {\n                return true;\n            }\n\n            // if we didn't match we might have to resynchronize\n            if (matcher instanceof SequenceMatcher) {\n                char fringeChar = context.getInputBuffer().charAt(fringeIndex);\n                switch(fringeChar) {\n                    case RESYNC:\n                    case RESYNC_START:\n                    case RESYNC_EOI:\n                        // however we only resynchronize if we are at a RESYNC location and the matcher is a SequenceMatcher\n                        // that has already matched at least one character and that is a parent of the last match\n                        return qualifiesForResync(context, matcher) && resynchronize(context, fringeChar);\n                }\n            }\n            return false;\n        }\n\n        @SuppressWarnings( {\"SimplifiableIfStatement\"})\n        private boolean qualifiesForResync(MatcherContext context, Matcher matcher) {\n            if (context.getCurrentIndex() == context.getStartIndex() || !context.getPath().isPrefixOf(lastMatchPath)) {\n                // if we have a sequence that hasn't match anything yet or is not a prefix we might still have to\n                // resync on it if there is no other sequence parent anymore\n                MatcherContext parent = context.getParent();\n                while (parent != null) {\n                    if (parent.getMatcher() instanceof SequenceMatcher) return false;\n                    parent = parent.getParent();\n                }\n            }            \n            return true;\n        }\n\n        private boolean prepareErrorLocation(MatcherContext context) {\n            switch (context.getCurrentChar()) {\n                case DEL_ERROR:\n                    return willMatchDelError(context);\n                case INS_ERROR:\n                    return willMatchInsError(context);\n                case RESYNC:\n                case RESYNC_START:\n                case RESYNC_EOI:\n                    return false;\n                default:\n                    return true;\n            }\n        }\n\n        private boolean willMatchDelError(MatcherContext context) {\n            int preSkipIndex = context.getCurrentIndex();\n            context.advanceIndex(2); // skip del marker char and illegal char\n            if (!runTestMatch(context)) {\n                // if we wouldn't succeed with the match do not swallow the ERROR char & Co\n                context.setCurrentIndex(preSkipIndex);\n                return false;\n            }\n            context.setStartIndex(context.getCurrentIndex());\n            if (context.getParent() != null) context.getParent().markError();\n            return true;\n        }\n\n        private boolean willMatchInsError(MatcherContext context) {\n            int preSkipIndex = context.getCurrentIndex();\n            context.advanceIndex(1); // skip ins marker char\n            if (!runTestMatch(context)) {\n                // if we wouldn't succeed with the match do not swallow the ERROR char\n                context.setCurrentIndex(preSkipIndex);\n                return false;\n            }\n            context.setStartIndex(context.getCurrentIndex());\n            context.markError();\n            return true;\n        }\n\n        private boolean runTestMatch(MatcherContext context) {\n            TestMatcher testMatcher = new TestMatcher(context.getMatcher());\n            MatcherContext testContext = testMatcher.getSubContext(context);\n            return prepareErrorLocation(testContext) && testContext.runMatcher();\n        }\n\n        private boolean resynchronize(MatcherContext context, char fringeChar) {\n            context.markError();\n\n            // create a node for the failed Sequence, taking ownership of all sub nodes created so far\n            context.createNode();\n\n            // by resyncing we flip an unmatched sequence to a matched one, so in order to keep the value stack\n            // consistent we go into a special \"error action mode\" and execute the minimal set of actions underneath\n            // the resync sequence\n            rerunAndExecuteErrorActions(context);\n            \n            // \n            checkState(context.getCurrentChar() == fringeChar);\n\n            // skip over all characters that are not legal followers of the failed Sequence\n            switch (fringeChar) {\n                case RESYNC:\n                    // this RESYNC error is the last error, we establish the length of the bad sequence and\n                    // change this RESYNC marker to a RESYNC_START / RESYNC_END block\n                    context.advanceIndex(1); // gobble RESYNC marker\n                    List<Matcher> followMatchers = new FollowMatchersVisitor().getFollowMatchers(context);\n                    int endIndex = gobbleIllegalCharacters(context, followMatchers);\n                    currentError.setEndIndex(endIndex);\n                    buffer.replaceInsertedChar(currentError.getStartIndex() - 1, RESYNC_START);\n                    buffer.insertChar(endIndex, RESYNC_END);\n                    context.advanceIndex(1); // gobble RESYNC_END marker\n                    break;\n\n                case RESYNC_START:\n                    // a RESYNC error we have already recovered from before\n                    context.advanceIndex(1); // gobble RESYNC_START\n                    while (context.getCurrentChar() != RESYNC_END) {\n                        context.advanceIndex(1); // skip all characters up to the RESYNC_END\n                        checkState(context.getCurrentChar() != EOI); // we MUST find a RESYNC_END before EOI\n                    }\n                    context.advanceIndex(1); // gobble RESYNC_END marker\n                    break;\n                \n                case RESYNC_EOI:\n                    // if we are resyncing on EOI we don't swallow anything\n                    // we also do not have to update the currentError since we only hit this code here\n                    // in the final run\n                    break;\n\n                default:\n                    throw new IllegalStateException();\n            }\n\n            fringeIndex = context.getCurrentIndex();\n            return true;\n        }\n\n        @SuppressWarnings( {\"ConstantConditions\"})\n        private void rerunAndExecuteErrorActions(MatcherContext context) {\n            // the context is for the resync action, which at this point has FAILED, i.e. ALL its sub actions haven't\n            // had a chance to change the value stack, even the ones having run before the actual parse error matcher\n            // so we need to rerun all sub matchers of the resync sequence up to the point of the parse error\n            // and then run the minimal set of action in \"error action mode\"\n\n            int savedCurrentIndex = context.getCurrentIndex();\n            context.setCurrentIndex(context.getStartIndex()); // restart matching the resync sequence\n\n            boolean preError = true;\n            for (Matcher child : context.getMatcher().getChildren()) {\n                if (preError && !child.getSubContext(context).runMatcher()) {\n                    // run what will be the preceding matcher of all error actions\n                    new EmptyMatcher().getSubContext(context).runMatcher();\n                    context.setIntTag(1); // signal that at least one rule has run before the error actions\n                    preError = false;\n                }\n                if (!preError) {\n                    context.setInErrorRecovery(true);\n                    List<ActionMatcher> errorActions = child.accept(new CollectResyncActionsVisitor());\n                    checkState(errorActions != null);\n                    for (ActionMatcher errorAction : errorActions) {\n                        // execute the error actions without looking at their boolean results !!!\n                        errorAction.getSubContext(context).runMatcher();\n                    }\n                    context.setInErrorRecovery(false);\n                }\n            }\n\n            context.setCurrentIndex(savedCurrentIndex);\n        }\n\n        private int gobbleIllegalCharacters(MatcherContext context, List<Matcher> followMatchers) {\n            while_loop:\n            while (true) {\n                char currentChar = context.getCurrentChar();\n                if (currentChar == EOI) break;\n                for (Matcher followMatcher : followMatchers) {\n                    if (followMatcher.accept(new IsStarterCharVisitor(currentChar))) {\n                        break while_loop;\n                    }\n                }\n                context.advanceIndex(1);\n            }\n            return context.getCurrentIndex();\n        }\n    }\n\n    /**\n     * This MatcherVisitor collects the minimal set of actions that has to run underneath a resyncronization sequence\n     * in order to maintain a consistent Value Stack state.\n     */\n    private static class CollectResyncActionsVisitor extends DefaultMatcherVisitor<List<ActionMatcher>> {\n        private ImmutableLinkedList<SequenceMatcher> path = ImmutableLinkedList.nil();\n\n        @Override\n        public List<ActionMatcher> visit(ActionMatcher matcher) {\n            return ImmutableList.of(matcher);\n        }\n\n        @Override\n        public List<ActionMatcher> visit(FirstOfMatcher matcher) {\n            for (Matcher child : matcher.getChildren()) {\n                List<ActionMatcher> actions = child.accept(this);\n                if (actions != null) return actions;\n            }\n            return null;\n        }\n\n        @Override\n        public List<ActionMatcher> visit(OneOrMoreMatcher matcher) {\n            return matcher.subMatcher.accept(this);\n        }\n\n        @Override\n        public List<ActionMatcher> visit(SequenceMatcher matcher) {\n            if (path.contains(matcher)) {\n                return null;\n            }\n\n            ImmutableLinkedList<SequenceMatcher> previousPath = path;\n            path = path.prepend(matcher);\n\n            List<ActionMatcher> actions = new ArrayList<ActionMatcher>();\n            for (Matcher sub : matcher.getChildren()) {\n                List<ActionMatcher> subActions = sub.accept(this);\n                if (subActions == null) return null;\n                actions.addAll(subActions);\n            }\n\n            path = previousPath;\n            return actions;\n        }\n\n        @Override\n        public List<ActionMatcher> defaultValue(AbstractMatcher matcher) {\n            return ImmutableList.of();\n        }\n    }\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009-2010 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.parserunners;\n\nimport org.parboiled.MatchHandler;\nimport org.parboiled.MatcherContext;\nimport org.parboiled.Rule;\nimport org.parboiled.buffers.InputBuffer;\nimport org.parboiled.buffers.MutableInputBuffer;\nimport org.parboiled.common.ImmutableLinkedList;\nimport org.parboiled.common.ImmutableList;\nimport org.parboiled.common.Preconditions;\nimport org.parboiled.errors.InvalidInputError;\nimport org.parboiled.matchers.*;\nimport org.parboiled.matchervisitors.*;\nimport org.parboiled.support.Checks;\nimport org.parboiled.support.MatcherPath;\nimport org.parboiled.support.ParsingResult;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.parboiled.common.Preconditions.checkArgNotNull;\nimport static org.parboiled.common.Preconditions.checkState;\nimport static org.parboiled.matchers.MatcherUtils.unwrap;\nimport static org.parboiled.support.Chars.*;\n\n/**\n * A {@link org.parboiled.parserunners.ParseRunner} implementation that is able to recover from {@link org.parboiled.errors.InvalidInputError}s in the input and therefore\n * report more than just the first {@link org.parboiled.errors.InvalidInputError} if the input does not conform to the rule grammar.\n * Error recovery is done by attempting to either delete an error character, insert a potentially missing character\n * or do both at once (which is equivalent to a one char replace) whereby this implementation is able to determine\n * itself which of these options is the best strategy.\n * If the parse error cannot be overcome by either deleting, inserting or replacing one character a resynchronization\n * rule is determined and the parsing process resynchronized, so that parsing can still continue.\n * In this way the RecoveringParseRunner is able to completely parse all input texts (This ParseRunner never returns\n * an unmatched {@link org.parboiled.support.ParsingResult}).\n * If the input is error free this {@link org.parboiled.parserunners.ParseRunner} implementation will only perform one parsing run, with the same\n * speed as the {@link org.parboiled.parserunners.BasicParseRunner}. However, if there are {@link org.parboiled.errors.InvalidInputError}s in the input potentially\n * many more runs are performed to properly report all errors and test the various recovery strategies.\n */\npublic class RecoveringParseRunner<V> extends AbstractParseRunner<V> {\n    private int errorIndex;\n    private InvalidInputError currentError;\n    private MutableInputBuffer buffer;\n    private ParsingResult<V> lastParsingResult;\n    private Matcher rootMatcherWithoutPTB; // the root matcher with parse tree building disabled\n\n    /**\n     * Create a new RecoveringParseRunner instance with the given rule and input text and returns the result of\n     * its {@link #run(String)} method invocation.\n     *\n     * @param rule  the parser rule to run\n     * @param input the input text to run on\n     * @return the ParsingResult for the parsing run\n     * @deprecated As of 0.11.0 you should use the \"regular\" constructor and one of the \"run\" methods rather than\n     *             this static method. This method will be removed in one of the coming releases.\n     */\n    @Deprecated\n    public static <V> ParsingResult<V> run(Rule rule, String input) {\n        checkArgNotNull(rule, \"rule\");\n        checkArgNotNull(input, \"input\");\n        return new RecoveringParseRunner<V>(rule).run(input);\n    }\n\n    /**\n     * Creates a new RecoveringParseRunner instance for the given rule.\n     *\n     * @param rule the parser rule\n     */\n    public RecoveringParseRunner(Rule rule) {\n        super(rule);\n    }\n\n    public ParsingResult<V> run(InputBuffer inputBuffer) {\n        checkArgNotNull(inputBuffer, \"inputBuffer\");\n        resetValueStack();\n\n        // first, run a basic match\n        ParseRunner<V> basicRunner = new BasicParseRunner<V>(getRootMatcher())\n                .withParseErrors(getParseErrors())\n                .withValueStack(getValueStack());\n        lastParsingResult = basicRunner.run(inputBuffer);\n\n        if (!lastParsingResult.matched) {\n            // for better performance disable parse tree building during the recovery runs\n            rootMatcherWithoutPTB = (Matcher) getRootMatcher().suppressNode();\n\n            // locate first error\n            performLocatingRun(inputBuffer);\n            checkState(errorIndex >= 0); // we failed before so we must fail again\n\n            // in order to be able to apply fixes we need to wrap the input buffer with a mutability wrapper\n            buffer = new MutableInputBuffer(inputBuffer);\n\n            // report first error\n            performReportingRun();\n\n            // fix and report until done\n            while (!fixError(errorIndex)) {\n                performReportingRun();\n            }\n\n            // rerun once more with parse tree building enabled to create a parse tree for the fixed input\n            if (!getRootMatcher().isNodeSuppressed()) {\n                performFinalRun();\n                checkState(lastParsingResult.matched);\n            }\n        }\n        return lastParsingResult;\n    }\n\n    private boolean performLocatingRun(InputBuffer inputBuffer) {\n        resetValueStack();\n        ParseRunner<V> locatingRunner = new ErrorLocatingParseRunner<V>(rootMatcherWithoutPTB, getInnerHandler())\n                .withParseErrors(getParseErrors())\n                .withValueStack(getValueStack());\n        lastParsingResult = locatingRunner.run(inputBuffer);\n        errorIndex = lastParsingResult.matched ? -1 :\n                getParseErrors().remove(getParseErrors().size() - 1).getStartIndex();\n        return lastParsingResult.matched;\n    }\n\n    private void performReportingRun() {\n        resetValueStack();\n        ParseRunner<V> reportingRunner = new ErrorReportingParseRunner<V>(rootMatcherWithoutPTB, errorIndex,\n                getInnerHandler())\n                .withParseErrors(getParseErrors())\n                .withValueStack(getValueStack());\n        ParsingResult<V> result = reportingRunner.run(buffer);\n        Preconditions.checkState(!result.matched); // we failed before so we should really be failing again\n        currentError = (InvalidInputError) getParseErrors().get(getParseErrors().size() - 1);\n    }\n\n    private void performFinalRun() {\n        resetValueStack();\n        Handler handler = new Handler();\n        MatcherContext<V> rootContext = createRootContext(buffer, handler, false);\n        boolean matched = handler.match(rootContext);\n        lastParsingResult = createParsingResult(matched, rootContext);\n    }\n\n    private MatchHandler getInnerHandler() {\n        return errorIndex >= 0 ? new Handler() : null;\n    }\n\n    private boolean fixError(int fixIndex) {\n        if (tryFixBySingleCharDeletion(fixIndex)) return true;\n        int nextErrorAfterDeletion = errorIndex;\n\n        Character bestInsertionCharacter = findBestSingleCharInsertion(fixIndex);\n        if (bestInsertionCharacter == null) return true;\n        int nextErrorAfterBestInsertion = errorIndex;\n\n        Character bestReplacementCharacter = findBestSingleCharReplacement(fixIndex);\n        if (bestReplacementCharacter == null) return true;\n        int nextErrorAfterBestReplacement = errorIndex;\n\n        int nextErrorAfterBestSingleCharFix =\n                Math.max(Math.max(nextErrorAfterDeletion, nextErrorAfterBestInsertion), nextErrorAfterBestReplacement);\n        if (nextErrorAfterBestSingleCharFix > fixIndex) {\n            // we are able to overcome the error with a single char fix, so apply the best one found\n            if (nextErrorAfterBestSingleCharFix == nextErrorAfterDeletion) {\n                buffer.insertChar(fixIndex, DEL_ERROR);\n                errorIndex = nextErrorAfterDeletion + 1;\n                currentError.shiftIndexDeltaBy(1);\n            } else if (nextErrorAfterBestSingleCharFix == nextErrorAfterBestInsertion) {\n                // we need to insert the characters in reverse order, since we insert twice at the same location\n                buffer.insertChar(fixIndex, bestInsertionCharacter);\n                buffer.insertChar(fixIndex, INS_ERROR);\n                errorIndex = nextErrorAfterBestInsertion + 2;\n                currentError.shiftIndexDeltaBy(2);\n            } else {\n                // we need to insert the characters in reverse order, since we insert three times at the same location\n                buffer.insertChar(fixIndex + 1, bestReplacementCharacter);\n                buffer.insertChar(fixIndex + 1, INS_ERROR);\n                buffer.insertChar(fixIndex, DEL_ERROR);\n                errorIndex = nextErrorAfterBestReplacement + 5;\n                currentError.shiftIndexDeltaBy(1);\n            }\n        } else {\n            // we can't fix the error with a single char fix, so fall back to resynchronization\n            if (buffer.charAt(fixIndex) == EOI) {\n                buffer.insertChar(fixIndex, RESYNC_EOI);\n                currentError.shiftIndexDeltaBy(1);\n                return true;\n            }\n            buffer.insertChar(fixIndex, RESYNC);\n            currentError.shiftIndexDeltaBy(1);\n            performLocatingRun(buffer); // find the next parse error\n        }\n        return errorIndex == -1;\n    }\n\n    private boolean tryFixBySingleCharDeletion(int fixIndex) {\n        buffer.insertChar(fixIndex, DEL_ERROR);\n        boolean nowErrorFree = performLocatingRun(buffer);\n        if (nowErrorFree) {\n            currentError.shiftIndexDeltaBy(1); // compensate for the inserted DEL_ERROR char\n        } else {\n            buffer.undoCharInsertion(fixIndex);\n            errorIndex = Math.max(errorIndex - 1, 0);\n        }\n        return nowErrorFree;\n    }\n\n    @SuppressWarnings( {\"ConstantConditions\"})\n    private Character findBestSingleCharInsertion(int fixIndex) {\n        GetStarterCharVisitor getStarterCharVisitor = new GetStarterCharVisitor();\n        int bestNextErrorIndex = -1;\n        Character bestChar = null;\n        for (MatcherPath failedMatcherPath : currentError.getFailedMatchers()) {\n            Character starterChar = failedMatcherPath.element.matcher.accept(getStarterCharVisitor);\n            checkState(starterChar != null); // we should only have single character matchers\n            if (starterChar == EOI) {\n                continue; // we should never conjure up an EOI character (that would be cheating :)\n            }\n            buffer.insertChar(fixIndex, starterChar);\n            buffer.insertChar(fixIndex, INS_ERROR);\n            if (performLocatingRun(buffer)) {\n                currentError.shiftIndexDeltaBy(2); // compensate for the inserted chars\n                return null; // success, exit immediately\n            }\n            buffer.undoCharInsertion(fixIndex);\n            buffer.undoCharInsertion(fixIndex);\n            errorIndex = Math.max(errorIndex - 2, 0);\n\n            if (bestNextErrorIndex < errorIndex) {\n                bestNextErrorIndex = errorIndex;\n                bestChar = starterChar;\n            }\n        }\n        errorIndex = bestNextErrorIndex;\n        return bestChar;\n    }\n\n    private Character findBestSingleCharReplacement(int fixIndex) {\n        buffer.insertChar(fixIndex, DEL_ERROR);\n        Character bestChar = findBestSingleCharInsertion(fixIndex + 2);\n        if (bestChar == null) { // success, we found a fix that renders the complete input error free\n            currentError\n                    .shiftIndexDeltaBy(-1); // delta from DEL_ERROR char insertion and index shift by insertion method\n        } else {\n            buffer.undoCharInsertion(fixIndex);\n            errorIndex = Math.max(errorIndex - 3, 0);\n        }\n        return bestChar;\n    }\n\n    /**\n     * A {@link org.parboiled.MatchHandler} implementation that recognizes the special\n     * {@link org.parboiled.support.Chars#RESYNC} character to overcome {@link InvalidInputError}s at the respective\n     * error indices.\n     */\n    private class Handler implements MatchHandler {\n        private final IsSingleCharMatcherVisitor isSingleCharMatcherVisitor = new IsSingleCharMatcherVisitor();\n        private int fringeIndex;\n        private MatcherPath lastMatchPath;\n\n        public boolean match(MatcherContext<?> context) {\n            Matcher matcher = context.getMatcher();\n            if (matcher.accept(isSingleCharMatcherVisitor)) {\n                if (prepareErrorLocation(context) && matcher.match(context)) {\n                    if (fringeIndex < context.getCurrentIndex()) {\n                        fringeIndex = context.getCurrentIndex();\n                        lastMatchPath = context.getPath();\n                    }\n                    return true;\n                }\n                return false;\n            }\n\n            if (matcher.match(context)) {\n                return true;\n            }\n\n            // if we didn't match we might have to resynchronize\n            char fringeChar = context.getInputBuffer().charAt(fringeIndex);\n            switch(fringeChar) {\n                case RESYNC:\n                case RESYNC_START:\n                case RESYNC_EOI:\n                    // however we only resynchronize if we are at a RESYNC location and the matcher is a SequenceMatcher\n                    // that has already matched at least one character and that is a parent of the last match\n                    return qualifiesForResync(context, matcher) && resynchronize(context, fringeChar);\n                default:\n                    return false;\n            }\n        }\n\n        @SuppressWarnings( {\"SimplifiableIfStatement\"})\n        private boolean qualifiesForResync(MatcherContext context, Matcher matcher) {\n            if (matcher instanceof SequenceMatcher && context.getCurrentIndex() > context.getStartIndex() &&\n                    context.getPath().isPrefixOf(lastMatchPath)) {\n                return true;\n            }\n            return context.getParent() == null; // always resync on the root if there is nothing else\n        }\n\n        private boolean prepareErrorLocation(MatcherContext context) {\n            switch (context.getCurrentChar()) {\n                case DEL_ERROR:\n                    return willMatchDelError(context);\n                case INS_ERROR:\n                    return willMatchInsError(context);\n                case RESYNC:\n                case RESYNC_START:\n                case RESYNC_EOI:\n                    return false;\n                default:\n                    return true;\n            }\n        }\n\n        private boolean willMatchDelError(MatcherContext context) {\n            int preSkipIndex = context.getCurrentIndex();\n            context.advanceIndex(2); // skip del marker char and illegal char\n            if (!runTestMatch(context)) {\n                // if we wouldn't succeed with the match do not swallow the ERROR char & Co\n                context.setCurrentIndex(preSkipIndex);\n                return false;\n            }\n            context.setStartIndex(context.getCurrentIndex());\n            if (context.getParent() != null) context.getParent().markError();\n            return true;\n        }\n\n        private boolean willMatchInsError(MatcherContext context) {\n            int preSkipIndex = context.getCurrentIndex();\n            context.advanceIndex(1); // skip ins marker char\n            if (!runTestMatch(context)) {\n                // if we wouldn't succeed with the match do not swallow the ERROR char\n                context.setCurrentIndex(preSkipIndex);\n                return false;\n            }\n            context.setStartIndex(context.getCurrentIndex());\n            context.markError();\n            return true;\n        }\n\n        private boolean runTestMatch(MatcherContext context) {\n            TestMatcher testMatcher = new TestMatcher(context.getMatcher());\n            MatcherContext testContext = testMatcher.getSubContext(context);\n            return prepareErrorLocation(testContext) && testContext.runMatcher();\n        }\n\n        private boolean resynchronize(MatcherContext context, char fringeChar) {\n            context.markError();\n\n            // create a node for the failed Sequence, taking ownership of all sub nodes created so far\n            context.createNode();\n\n            // by resyncing we flip an unmatched sequence to a matched one, so in order to keep the value stack\n            // consistent we go into a special \"error action mode\" and execute the minimal set of actions underneath\n            // the resync sequence\n            rerunAndExecuteErrorActions(context);\n\n            // skip over all characters that are not legal followers of the failed Sequence\n            switch (fringeChar) {\n                case RESYNC:\n                    // this RESYNC error is the last error, we establish the length of the bad sequence and\n                    // change this RESYNC marker to a RESYNC_START / RESYNC_END block\n                    context.advanceIndex(1); // gobble RESYNC marker\n                    List<Matcher> followMatchers = new FollowMatchersVisitor().getFollowMatchers(context);\n                    int endIndex = gobbleIllegalCharacters(context, followMatchers);\n                    currentError.setEndIndex(endIndex);\n                    buffer.replaceInsertedChar(currentError.getStartIndex() - 1, RESYNC_START);\n                    buffer.insertChar(endIndex, RESYNC_END);\n                    context.advanceIndex(1); // gobble RESYNC_END marker\n                    break;\n\n                case RESYNC_START:\n                    // a RESYNC error we have already recovered from before\n                    context.advanceIndex(1); // gobble RESYNC marker\n                    while (context.getCurrentChar() != RESYNC_END) {\n                        context.advanceIndex(1); // skip all characters up to the RESYNC_END\n                        checkState(context.getCurrentChar() != EOI); // we MUST find a RESYNC_END before EOI\n                    }\n                    context.advanceIndex(1); // gobble RESYNC_END marker\n                    break;\n                \n                case RESYNC_EOI:\n                    // if we are resyncing on EOI we don't swall anything\n                    // we also do not have to update the currentError since we only hit this code here\n                    // in the final run\n                    break;\n\n                default:\n                    throw new IllegalStateException();\n            }\n\n            fringeIndex = context.getCurrentIndex();\n            return true;\n        }\n\n        @SuppressWarnings( {\"ConstantConditions\"})\n        private void rerunAndExecuteErrorActions(MatcherContext context) {\n            // the context is for the resync action, which at this point has FAILED, i.e. ALL its sub actions haven't\n            // had a chance to change the value stack, even the ones having run before the actual parse error matcher\n            // so we need to rerun all sub matchers of the resync sequence up to the point of the parse error\n            // and then run the minimal set of action in \"error action mode\"\n\n            int savedCurrentIndex = context.getCurrentIndex();\n            context.setCurrentIndex(context.getStartIndex()); // restart matching the resync sequence\n\n            boolean preError = true;\n            for (Matcher child : context.getMatcher().getChildren()) {\n                if (preError && !child.getSubContext(context).runMatcher()) {\n                    // run what will be the preceding matcher of all error actions\n                    new EmptyMatcher().getSubContext(context).runMatcher();\n                    context.setIntTag(1); // signal that at least one rule has run before the error actions\n                    preError = false;\n                }\n                if (!preError) {\n                    context.setInErrorRecovery(true);\n                    List<ActionMatcher> errorActions = child.accept(new CollectResyncActionsVisitor());\n                    checkState(errorActions != null);\n                    for (ActionMatcher errorAction : errorActions) {\n                        // execute the error actions without looking at their boolean results !!!\n                        errorAction.getSubContext(context).runMatcher();\n                    }\n                    context.setInErrorRecovery(false);\n                }\n            }\n\n            context.setCurrentIndex(savedCurrentIndex);\n        }\n\n        private int gobbleIllegalCharacters(MatcherContext context, List<Matcher> followMatchers) {\n            while_loop:\n            while (true) {\n                char currentChar = context.getCurrentChar();\n                if (currentChar == EOI) break;\n                for (Matcher followMatcher : followMatchers) {\n                    if (followMatcher.accept(new IsStarterCharVisitor(currentChar))) {\n                        break while_loop;\n                    }\n                }\n                context.advanceIndex(1);\n            }\n            return context.getCurrentIndex();\n        }\n    }\n\n    /**\n     * This MatcherVisitor collects the minimal set of actions that has to run underneath a resyncronization sequence\n     * in order to maintain a consistent Value Stack state.\n     */\n    private static class CollectResyncActionsVisitor extends DefaultMatcherVisitor<List<ActionMatcher>> {\n        private ImmutableLinkedList<SequenceMatcher> path = ImmutableLinkedList.nil();\n\n        @Override\n        public List<ActionMatcher> visit(ActionMatcher matcher) {\n            return ImmutableList.of(matcher);\n        }\n\n        @Override\n        public List<ActionMatcher> visit(FirstOfMatcher matcher) {\n            for (Matcher child : matcher.getChildren()) {\n                List<ActionMatcher> actions = child.accept(this);\n                if (actions != null) return actions;\n            }\n            return null;\n        }\n\n        @Override\n        public List<ActionMatcher> visit(OneOrMoreMatcher matcher) {\n            return matcher.subMatcher.accept(this);\n        }\n\n        @Override\n        public List<ActionMatcher> visit(SequenceMatcher matcher) {\n            if (path.contains(matcher)) {\n                return null;\n            }\n\n            ImmutableLinkedList<SequenceMatcher> previousPath = path;\n            path = path.prepend(matcher);\n\n            List<ActionMatcher> actions = new ArrayList<ActionMatcher>();\n            for (Matcher sub : matcher.getChildren()) {\n                List<ActionMatcher> subActions = sub.accept(this);\n                if (subActions == null) return null;\n                actions.addAll(subActions);\n            }\n\n            path = previousPath;\n            return actions;\n        }\n\n        @Override\n        public List<ActionMatcher> defaultValue(AbstractMatcher matcher) {\n            return ImmutableList.of();\n        }\n    }\n}\n","lineNo":311}
{"Refactored Sample":"/*\n * Copyright (C) 2009-2010 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.parserunners;\n\nimport org.parboiled.MatchHandler;\nimport org.parboiled.MatcherContext;\nimport org.parboiled.Rule;\nimport org.parboiled.buffers.InputBuffer;\nimport org.parboiled.buffers.MutableInputBuffer;\nimport org.parboiled.common.ImmutableLinkedList;\nimport org.parboiled.common.ImmutableList;\nimport org.parboiled.common.Preconditions;\nimport org.parboiled.errors.InvalidInputError;\nimport org.parboiled.matchers.*;\nimport org.parboiled.matchervisitors.*;\nimport org.parboiled.support.Chars;\nimport org.parboiled.support.MatcherPath;\nimport org.parboiled.support.ParsingResult;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.parboiled.common.Preconditions.checkArgNotNull;\nimport static org.parboiled.common.Preconditions.checkState;\nimport static org.parboiled.matchers.MatcherUtils.unwrap;\nimport static org.parboiled.support.Chars.*;\n\n/**\n * A {@link org.parboiled.parserunners.ParseRunner} implementation that is able to recover from {@link org.parboiled.errors.InvalidInputError}s in the input and therefore\n * report more than just the first {@link org.parboiled.errors.InvalidInputError} if the input does not conform to the rule grammar.\n * Error recovery is done by attempting to either delete an error character, insert a potentially missing character\n * or do both at once (which is equivalent to a one char replace) whereby this implementation is able to determine\n * itself which of these options is the best strategy.\n * If the parse error cannot be overcome by either deleting, inserting or replacing one character a resynchronization\n * rule is determined and the parsing process resynchronized, so that parsing can still continue.\n * In this way the RecoveringParseRunner is able to completely parse all input texts (This ParseRunner never returns\n * an unmatched {@link org.parboiled.support.ParsingResult}).\n * If the input is error free this {@link org.parboiled.parserunners.ParseRunner} implementation will only perform one parsing run, with the same\n * speed as the {@link org.parboiled.parserunners.BasicParseRunner}. However, if there are {@link org.parboiled.errors.InvalidInputError}s in the input potentially\n * many more runs are performed to properly report all errors and test the various recovery strategies.\n */\npublic class RecoveringParseRunner<V> extends AbstractParseRunner<V> {\n    private int errorIndex;\n    private InvalidInputError currentError;\n    private MutableInputBuffer buffer;\n    private ParsingResult<V> lastParsingResult;\n    private Matcher rootMatcherWithoutPTB; // the root matcher with parse tree building disabled\n\n    /**\n     * Create a new RecoveringParseRunner instance with the given rule and input text and returns the result of\n     * its {@link #run(String)} method invocation.\n     *\n     * @param rule  the parser rule to run\n     * @param input the input text to run on\n     * @return the ParsingResult for the parsing run\n     * @deprecated As of 0.11.0 you should use the \"regular\" constructor and one of the \"run\" methods rather than\n     *             this static method. This method will be removed in one of the coming releases.\n     */\n    @Deprecated\n    public static <V> ParsingResult<V> run(Rule rule, String input) {\n        checkArgNotNull(rule, \"rule\");\n        checkArgNotNull(input, \"input\");\n        return new RecoveringParseRunner<V>(rule).run(input);\n    }\n\n    /**\n     * Creates a new RecoveringParseRunner instance for the given rule.\n     *\n     * @param rule the parser rule\n     */\n    public RecoveringParseRunner(Rule rule) {\n        super(rule);\n    }\n\n    public ParsingResult<V> run(InputBuffer inputBuffer) {\n        checkArgNotNull(inputBuffer, \"inputBuffer\");\n        resetValueStack();\n\n        // first, run a basic match\n        ParseRunner<V> basicRunner = new BasicParseRunner<V>(getRootMatcher())\n                .withParseErrors(getParseErrors())\n                .withValueStack(getValueStack());\n        lastParsingResult = basicRunner.run(inputBuffer);\n\n        if (!lastParsingResult.matched) {\n            // for better performance disable parse tree building during the recovery runs\n            rootMatcherWithoutPTB = (Matcher) getRootMatcher().suppressNode();\n\n            // locate first error\n            performLocatingRun(inputBuffer);\n            checkState(errorIndex >= 0); // we failed before so we must fail again\n\n            // in order to be able to apply fixes we need to wrap the input buffer with a mutability wrapper\n            buffer = new MutableInputBuffer(inputBuffer);\n\n            // report first error\n            performReportingRun();\n\n            // fix and report until done\n            while (!fixError(errorIndex)) {\n                performReportingRun();\n            }\n\n            // rerun once more with parse tree building enabled to create a parse tree for the fixed input\n            if (!getRootMatcher().isNodeSuppressed()) {\n                performFinalRun();\n                checkState(lastParsingResult.matched);\n            }\n        }\n        return lastParsingResult;\n    }\n\n    private boolean performLocatingRun(InputBuffer inputBuffer) {\n        resetValueStack();\n        ParseRunner<V> locatingRunner = new ErrorLocatingParseRunner<V>(rootMatcherWithoutPTB, getInnerHandler())\n                .withParseErrors(getParseErrors())\n                .withValueStack(getValueStack());\n        lastParsingResult = locatingRunner.run(inputBuffer);\n        errorIndex = lastParsingResult.matched ? -1 :\n                getParseErrors().remove(getParseErrors().size() - 1).getStartIndex();\n        return lastParsingResult.matched;\n    }\n\n    private void performReportingRun() {\n        resetValueStack();\n        ParseRunner<V> reportingRunner = new ErrorReportingParseRunner<V>(rootMatcherWithoutPTB, errorIndex,\n                getInnerHandler())\n                .withParseErrors(getParseErrors())\n                .withValueStack(getValueStack());\n        ParsingResult<V> result = reportingRunner.run(buffer);\n        Preconditions.checkState(!result.matched); // we failed before so we should really be failing again\n        currentError = (InvalidInputError) getParseErrors().get(getParseErrors().size() - 1);\n    }\n\n    private void performFinalRun() {\n        resetValueStack();\n        Handler handler = new Handler();\n        MatcherContext<V> rootContext = createRootContext(buffer, handler, false);\n        boolean matched = handler.match(rootContext);\n        lastParsingResult = createParsingResult(matched, rootContext);\n    }\n\n    private MatchHandler getInnerHandler() {\n        return errorIndex >= 0 ? new Handler() : null;\n    }\n\n    private boolean fixError(int fixIndex) {\n        if (tryFixBySingleCharDeletion(fixIndex)) return true;\n        int nextErrorAfterDeletion = errorIndex;\n\n        Character bestInsertionCharacter = findBestSingleCharInsertion(fixIndex);\n        if (bestInsertionCharacter == null) return true;\n        int nextErrorAfterBestInsertion = errorIndex;\n\n        Character bestReplacementCharacter = findBestSingleCharReplacement(fixIndex);\n        if (bestReplacementCharacter == null) return true;\n        int nextErrorAfterBestReplacement = errorIndex;\n\n        int nextErrorAfterBestSingleCharFix =\n                Math.max(Math.max(nextErrorAfterDeletion, nextErrorAfterBestInsertion), nextErrorAfterBestReplacement);\n        if (nextErrorAfterBestSingleCharFix > fixIndex) {\n            // we are able to overcome the error with a single char fix, so apply the best one found\n            if (nextErrorAfterBestSingleCharFix == nextErrorAfterDeletion) {\n                buffer.insertChar(fixIndex, DEL_ERROR);\n                errorIndex = nextErrorAfterDeletion + 1;\n                currentError.shiftIndexDeltaBy(1);\n            } else if (nextErrorAfterBestSingleCharFix == nextErrorAfterBestInsertion) {\n                // we need to insert the characters in reverse order, since we insert twice at the same location\n                buffer.insertChar(fixIndex, bestInsertionCharacter);\n                buffer.insertChar(fixIndex, INS_ERROR);\n                errorIndex = nextErrorAfterBestInsertion + 2;\n                currentError.shiftIndexDeltaBy(2);\n            } else {\n                // we need to insert the characters in reverse order, since we insert three times at the same location\n                buffer.insertChar(fixIndex + 1, bestReplacementCharacter);\n                buffer.insertChar(fixIndex + 1, INS_ERROR);\n                buffer.insertChar(fixIndex, DEL_ERROR);\n                errorIndex = nextErrorAfterBestReplacement + 5;\n                currentError.shiftIndexDeltaBy(1);\n            }\n        } else {\n            // we can't fix the error with a single char fix, so fall back to resynchronization\n            buffer.insertChar(fixIndex, RESYNC);\n            currentError.shiftIndexDeltaBy(1);\n            performLocatingRun(buffer); // find the next parse error\n        }\n        return errorIndex == -1;\n    }\n\n    private boolean tryFixBySingleCharDeletion(int fixIndex) {\n        buffer.insertChar(fixIndex, DEL_ERROR);\n        boolean nowErrorFree = performLocatingRun(buffer);\n        if (nowErrorFree) {\n            currentError.shiftIndexDeltaBy(1); // compensate for the inserted DEL_ERROR char\n        } else {\n            buffer.undoCharInsertion(fixIndex);\n            errorIndex = Math.max(errorIndex - 1, 0);\n        }\n        return nowErrorFree;\n    }\n\n    @SuppressWarnings( {\"ConstantConditions\"})\n    private Character findBestSingleCharInsertion(int fixIndex) {\n        GetStarterCharVisitor getStarterCharVisitor = new GetStarterCharVisitor();\n        int bestNextErrorIndex = -1;\n        Character bestChar = null;\n        for (MatcherPath failedMatcherPath : currentError.getFailedMatchers()) {\n            Character starterChar = failedMatcherPath.element.matcher.accept(getStarterCharVisitor);\n            checkState(starterChar != null); // we should only have single character matchers\n            if (starterChar == EOI) {\n                continue; // we should never conjure up an EOI character (that would be cheating :)\n            }\n            buffer.insertChar(fixIndex, starterChar);\n            buffer.insertChar(fixIndex, INS_ERROR);\n            if (performLocatingRun(buffer)) {\n                currentError.shiftIndexDeltaBy(2); // compensate for the inserted chars\n                return null; // success, exit immediately\n            }\n            buffer.undoCharInsertion(fixIndex);\n            buffer.undoCharInsertion(fixIndex);\n            errorIndex = Math.max(errorIndex - 2, 0);\n\n            if (bestNextErrorIndex < errorIndex) {\n                bestNextErrorIndex = errorIndex;\n                bestChar = starterChar;\n            }\n        }\n        errorIndex = bestNextErrorIndex;\n        return bestChar;\n    }\n\n    private Character findBestSingleCharReplacement(int fixIndex) {\n        buffer.insertChar(fixIndex, DEL_ERROR);\n        Character bestChar = findBestSingleCharInsertion(fixIndex + 2);\n        if (bestChar == null) { // success, we found a fix that renders the complete input error free\n            currentError\n                    .shiftIndexDeltaBy(-1); // delta from DEL_ERROR char insertion and index shift by insertion method\n        } else {\n            buffer.undoCharInsertion(fixIndex);\n            errorIndex = Math.max(errorIndex - 3, 0);\n        }\n        return bestChar;\n    }\n\n    /**\n     * A {@link org.parboiled.MatchHandler} implementation that recognizes the special\n     * {@link org.parboiled.support.Chars#RESYNC} character to overcome {@link InvalidInputError}s at the respective\n     * error indices.\n     */\n    private class Handler implements MatchHandler {\n        private final IsSingleCharMatcherVisitor isSingleCharMatcherVisitor = new IsSingleCharMatcherVisitor();\n        private int fringeIndex;\n        private MatcherPath lastMatchPath;\n\n        public boolean match(MatcherContext<?> context) {\n            Matcher matcher = context.getMatcher();\n            if (matcher.accept(isSingleCharMatcherVisitor)) {\n                if (prepareErrorLocation(context) && matcher.match(context)) {\n                    if (fringeIndex < context.getCurrentIndex()) {\n                        fringeIndex = context.getCurrentIndex();\n                        lastMatchPath = context.getPath();\n                    }\n                    return true;\n                }\n                return false;\n            }\n\n            if (matcher.match(context)) {\n                return true;\n            }\n\n            // if we didn't match we might have to resynchronize, however we only resynchronize\n            // if we are at a RESYNC location and the matcher is a SequenceMatchers that has already\n            // matched at least one character and that is a parent of the last match\n            char fringeChar = context.getInputBuffer().charAt(fringeIndex);\n            return (fringeChar == RESYNC || fringeChar == RESYNC_START) &&\n                    qualifiesForResync(context, matcher) &&\n                    resynchronize(context, fringeChar);\n        }\n\n        @SuppressWarnings( {\"SimplifiableIfStatement\"})\n        private boolean qualifiesForResync(MatcherContext context, Matcher matcher) {\n            if (matcher instanceof SequenceMatcher && context.getCurrentIndex() > context.getStartIndex() &&\n                    context.getPath().isPrefixOf(lastMatchPath)) {\n                return true;\n            }\n            return context.getParent() == null; // always resync on the root if there is nothing else\n        }\n\n        private boolean prepareErrorLocation(MatcherContext context) {\n            switch (context.getCurrentChar()) {\n                case DEL_ERROR:\n                    return willMatchDelError(context);\n                case INS_ERROR:\n                    return willMatchInsError(context);\n            }\n            return true;\n        }\n\n        private boolean willMatchDelError(MatcherContext context) {\n            int preSkipIndex = context.getCurrentIndex();\n            context.advanceIndex(2); // skip del marker char and illegal char\n            if (!runTestMatch(context)) {\n                // if we wouldn't succeed with the match do not swallow the ERROR char & Co\n                context.setCurrentIndex(preSkipIndex);\n                return false;\n            }\n            context.setStartIndex(context.getCurrentIndex());\n            if (context.getParent() != null) context.getParent().markError();\n            return true;\n        }\n\n        private boolean willMatchInsError(MatcherContext context) {\n            int preSkipIndex = context.getCurrentIndex();\n            context.advanceIndex(1); // skip ins marker char\n            if (!runTestMatch(context)) {\n                // if we wouldn't succeed with the match do not swallow the ERROR char\n                context.setCurrentIndex(preSkipIndex);\n                return false;\n            }\n            context.setStartIndex(context.getCurrentIndex());\n            context.markError();\n            return true;\n        }\n\n        private boolean runTestMatch(MatcherContext context) {\n            TestMatcher testMatcher = new TestMatcher(context.getMatcher());\n            MatcherContext testContext = testMatcher.getSubContext(context);\n            return prepareErrorLocation(testContext) && testContext.runMatcher();\n        }\n\n        private boolean resynchronize(MatcherContext context, char fringeChar) {\n            context.markError();\n\n            // create a node for the failed Sequence, taking ownership of all sub nodes created so far\n            context.createNode();\n\n            // by resyncing we flip an unmatched sequence to a matched one, so in order to keep the value stack\n            // consistent we go into a special \"error action mode\" and execute the minimal set of actions underneath\n            // the resync sequence\n            rerunAndExecuteErrorActions(context);\n\n            // skip over all characters that are not legal followers of the failed Sequence\n            context.advanceIndex(1); // gobble RESYNC or RESYNC_START marker\n\n            switch (fringeChar) {\n                case RESYNC:\n                    // this RESYNC error is the last error, we establish the length of the bad sequence and\n                    // change this RESYNC marker to a RESYNC_START / RESYNC_END block\n                    buffer.replaceInsertedChar(currentError.getStartIndex() - 1, RESYNC_START);\n                    if (context.getCurrentChar() != Chars.EOI) {\n                        List<Matcher> followMatchers = new FollowMatchersVisitor().getFollowMatchers(context);\n                        int endIndex = gobbleIllegalCharacters(context, followMatchers);\n                        currentError.setEndIndex(endIndex);\n                        buffer.insertChar(endIndex, RESYNC_END);\n                    }\n                    break;\n\n                case RESYNC_START:\n                    if (context.getCurrentChar() != Chars.EOI) {\n                        // a RESYNC error we have already recovered from before\n                        // simply skip all characters up to the RESYNC_END\n                        while (context.getCurrentChar() != RESYNC_END) {\n                            context.advanceIndex(1);\n                            checkState(context.getCurrentChar() != EOI); // we MUST find a RESYNC_END before EOI\n                        }\n                    }\n                    break;\n\n                default:\n                    throw new IllegalStateException();\n            }\n\n            context.advanceIndex(1); // also gobble the RESYNC_END itself\n            fringeIndex = context.getCurrentIndex();\n\n            return true;\n        }\n\n        @SuppressWarnings( {\"ConstantConditions\"})\n        private void rerunAndExecuteErrorActions(MatcherContext context) {\n            // the context is for the resync action, which at this point has FAILED, i.e. ALL its sub actions haven't\n            // had a chance to change the value stack, even the ones having run before the actual parse error matcher\n            // so we need to rerun all sub matchers of the resync sequence up to the point of the parse error\n            // and then run the minimal set of action in \"error action mode\"\n\n            int savedCurrentIndex = context.getCurrentIndex();\n            context.setCurrentIndex(context.getStartIndex()); // restart matching the resync sequence\n\n            List<Matcher> children = context.getMatcher().getChildren();\n            List<Matcher> subs = new ArrayList<Matcher>();\n            int errorIx = 0;\n            if (lastMatchPath != null) {\n                Matcher lastGoodSub = unwrap(lastMatchPath.getElementAtLevel(context.getLevel() + 1).matcher);\n                for (int i = 0; i < children.size(); i++) {\n                    if (unwrap(children.get(i)) == lastGoodSub) {\n                        errorIx = i+1;\n                        break;\n                    }\n                }\n                checkState(errorIx > 0);\n            }\n            subs.addAll(children.subList(0, errorIx)); // queue all subs that have run before the error\n            subs.add(new EmptyMatcher()); // queue what will be the preceding matcher of all error actions\n            \n            // queue all error actions underneath the error matchers\n            for (Matcher child : children.subList(errorIx, children.size())) {\n                List<ActionMatcher> errorActions = child.accept(new CollectResyncActionsVisitor());\n                checkState(errorActions != null);\n                subs.addAll(errorActions);\n            }\n            \n            // run all queued matchers in a sequence\n            context.getSubContext(new SequenceMatcher(subs.toArray(new Rule[subs.size()]))).runMatcher();\n            \n            context.setCurrentIndex(savedCurrentIndex);\n        }\n\n        private int gobbleIllegalCharacters(MatcherContext context, List<Matcher> followMatchers) {\n            while_loop:\n            while (true) {\n                char currentChar = context.getCurrentChar();\n                if (currentChar == EOI) break;\n                for (Matcher followMatcher : followMatchers) {\n                    if (followMatcher.accept(new IsStarterCharVisitor(currentChar))) {\n                        break while_loop;\n                    }\n                }\n                context.advanceIndex(1);\n            }\n            return context.getCurrentIndex();\n        }\n    }\n\n    /**\n     * This MatcherVisitor collects the minimal set of actions that has to run underneath a resyncronization sequence\n     * in order to maintain a consistent Value Stack state.\n     */\n    private static class CollectResyncActionsVisitor extends DefaultMatcherVisitor<List<ActionMatcher>> {\n        private ImmutableLinkedList<SequenceMatcher> path = ImmutableLinkedList.nil();\n\n        @Override\n        public List<ActionMatcher> visit(ActionMatcher matcher) {\n            return ImmutableList.of(matcher);\n        }\n\n        @Override\n        public List<ActionMatcher> visit(FirstOfMatcher matcher) {\n            for (Matcher child : matcher.getChildren()) {\n                List<ActionMatcher> actions = child.accept(this);\n                if (actions != null) return actions;\n            }\n            return null;\n        }\n\n        @Override\n        public List<ActionMatcher> visit(OneOrMoreMatcher matcher) {\n            return matcher.subMatcher.accept(this);\n        }\n\n        @Override\n        public List<ActionMatcher> visit(SequenceMatcher matcher) {\n            if (path.contains(matcher)) {\n                return null;\n            }\n\n            ImmutableLinkedList<SequenceMatcher> previousPath = path;\n            path = path.prepend(matcher);\n\n            List<ActionMatcher> actions = new ArrayList<ActionMatcher>();\n            for (Matcher sub : matcher.getChildren()) {\n                List<ActionMatcher> subActions = sub.accept(this);\n                if (subActions == null) return null;\n                actions.addAll(subActions);\n            }\n\n            path = previousPath;\n            return actions;\n        }\n\n        @Override\n        public List<ActionMatcher> defaultValue(AbstractMatcher matcher) {\n            return ImmutableList.of();\n        }\n    }\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009-2010 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.parserunners;\n\nimport org.parboiled.MatchHandler;\nimport org.parboiled.MatcherContext;\nimport org.parboiled.Rule;\nimport org.parboiled.buffers.InputBuffer;\nimport org.parboiled.buffers.MutableInputBuffer;\nimport org.parboiled.common.ImmutableLinkedList;\nimport org.parboiled.common.ImmutableList;\nimport org.parboiled.common.Preconditions;\nimport org.parboiled.errors.InvalidInputError;\nimport org.parboiled.matchers.*;\nimport org.parboiled.matchervisitors.*;\nimport org.parboiled.support.Chars;\nimport org.parboiled.support.MatcherPath;\nimport org.parboiled.support.ParsingResult;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.parboiled.common.Preconditions.checkArgNotNull;\nimport static org.parboiled.common.Preconditions.checkState;\nimport static org.parboiled.support.Chars.*;\n\n/**\n * A {@link org.parboiled.parserunners.ParseRunner} implementation that is able to recover from {@link org.parboiled.errors.InvalidInputError}s in the input and therefore\n * report more than just the first {@link org.parboiled.errors.InvalidInputError} if the input does not conform to the rule grammar.\n * Error recovery is done by attempting to either delete an error character, insert a potentially missing character\n * or do both at once (which is equivalent to a one char replace) whereby this implementation is able to determine\n * itself which of these options is the best strategy.\n * If the parse error cannot be overcome by either deleting, inserting or replacing one character a resynchronization\n * rule is determined and the parsing process resynchronized, so that parsing can still continue.\n * In this way the RecoveringParseRunner is able to completely parse all input texts (This ParseRunner never returns\n * an unmatched {@link org.parboiled.support.ParsingResult}).\n * If the input is error free this {@link org.parboiled.parserunners.ParseRunner} implementation will only perform one parsing run, with the same\n * speed as the {@link org.parboiled.parserunners.BasicParseRunner}. However, if there are {@link org.parboiled.errors.InvalidInputError}s in the input potentially\n * many more runs are performed to properly report all errors and test the various recovery strategies.\n */\npublic class RecoveringParseRunner<V> extends AbstractParseRunner<V> {\n    private int errorIndex;\n    private InvalidInputError currentError;\n    private MutableInputBuffer buffer;\n    private ParsingResult<V> lastParsingResult;\n    private Matcher rootMatcherWithoutPTB; // the root matcher with parse tree building disabled\n\n    /**\n     * Create a new RecoveringParseRunner instance with the given rule and input text and returns the result of\n     * its {@link #run(String)} method invocation.\n     *\n     * @param rule  the parser rule to run\n     * @param input the input text to run on\n     * @return the ParsingResult for the parsing run\n     * @deprecated As of 0.11.0 you should use the \"regular\" constructor and one of the \"run\" methods rather than\n     *             this static method. This method will be removed in one of the coming releases.\n     */\n    @Deprecated\n    public static <V> ParsingResult<V> run(Rule rule, String input) {\n        checkArgNotNull(rule, \"rule\");\n        checkArgNotNull(input, \"input\");\n        return new RecoveringParseRunner<V>(rule).run(input);\n    }\n\n    /**\n     * Creates a new RecoveringParseRunner instance for the given rule.\n     *\n     * @param rule the parser rule\n     */\n    public RecoveringParseRunner(Rule rule) {\n        super(rule);\n    }\n\n    public ParsingResult<V> run(InputBuffer inputBuffer) {\n        checkArgNotNull(inputBuffer, \"inputBuffer\");\n        resetValueStack();\n\n        // first, run a basic match\n        ParseRunner<V> basicRunner = new BasicParseRunner<V>(getRootMatcher())\n                .withParseErrors(getParseErrors())\n                .withValueStack(getValueStack());\n        lastParsingResult = basicRunner.run(inputBuffer);\n        \n        if (!lastParsingResult.matched) {\n            // for better performance disable parse tree building during the recovery runs\n            rootMatcherWithoutPTB = (Matcher) getRootMatcher().suppressNode();\n\n            // locate first error\n            performLocatingRun(inputBuffer);\n            checkState(errorIndex >= 0); // we failed before so we must fail again\n\n            // in order to be able to apply fixes we need to wrap the input buffer with a mutability wrapper\n            buffer = new MutableInputBuffer(inputBuffer);\n\n            // report first error\n            performReportingRun();\n\n            // fix and report until done\n            while (!fixError(errorIndex)) {\n                performReportingRun();\n            }\n\n            // rerun once more with parse tree building enabled to create a parse tree for the fixed input\n            if (!getRootMatcher().isNodeSuppressed()) {\n                performFinalRun();\n                checkState(lastParsingResult.matched);\n            }\n        }\n        return lastParsingResult;\n    }\n\n    private boolean performLocatingRun(InputBuffer inputBuffer) {\n        resetValueStack();\n        ParseRunner<V> locatingRunner = new ErrorLocatingParseRunner<V>(rootMatcherWithoutPTB, getInnerHandler())\n                .withParseErrors(getParseErrors())\n                .withValueStack(getValueStack());\n        lastParsingResult = locatingRunner.run(inputBuffer);\n        errorIndex = lastParsingResult.matched ? -1 :\n                getParseErrors().remove(getParseErrors().size() - 1).getStartIndex();\n        return lastParsingResult.matched;\n    }\n    \n    private void performReportingRun() {\n        resetValueStack();\n        ParseRunner<V> reportingRunner = new ErrorReportingParseRunner<V>(rootMatcherWithoutPTB, errorIndex, getInnerHandler())\n                .withParseErrors(getParseErrors())\n                .withValueStack(getValueStack());\n        ParsingResult<V> result = reportingRunner.run(buffer);\n        Preconditions.checkState(!result.matched); // we failed before so we should really be failing again\n        currentError = (InvalidInputError) getParseErrors().get(getParseErrors().size() - 1);\n    }\n    \n    private void performFinalRun() {\n        resetValueStack();\n        Handler handler = new Handler();\n        MatcherContext<V> rootContext = createRootContext(buffer, handler, false);\n        boolean matched = handler.match(rootContext);\n        lastParsingResult = createParsingResult(matched, rootContext);\n    }\n\n    private MatchHandler getInnerHandler() {\n        return errorIndex >= 0 ? new Handler() : null;\n    }\n    \n    private boolean fixError(int fixIndex) {\n        if (tryFixBySingleCharDeletion(fixIndex)) return true;\n        int nextErrorAfterDeletion = errorIndex;\n\n        Character bestInsertionCharacter = findBestSingleCharInsertion(fixIndex);\n        if (bestInsertionCharacter == null) return true;\n        int nextErrorAfterBestInsertion = errorIndex;\n\n        Character bestReplacementCharacter = findBestSingleCharReplacement(fixIndex);\n        if (bestReplacementCharacter == null) return true;\n        int nextErrorAfterBestReplacement = errorIndex;\n\n        int nextErrorAfterBestSingleCharFix =\n                Math.max(Math.max(nextErrorAfterDeletion, nextErrorAfterBestInsertion), nextErrorAfterBestReplacement);\n        if (nextErrorAfterBestSingleCharFix > fixIndex) {\n            // we are able to overcome the error with a single char fix, so apply the best one found\n            if (nextErrorAfterBestSingleCharFix == nextErrorAfterDeletion) {\n                buffer.insertChar(fixIndex, DEL_ERROR);\n                errorIndex = nextErrorAfterDeletion + 1;\n                currentError.shiftIndexDeltaBy(1);\n            } else if (nextErrorAfterBestSingleCharFix == nextErrorAfterBestInsertion) {\n                // we need to insert the characters in reverse order, since we insert twice at the same location\n                buffer.insertChar(fixIndex, bestInsertionCharacter);\n                buffer.insertChar(fixIndex, INS_ERROR);\n                errorIndex = nextErrorAfterBestInsertion + 2;\n                currentError.shiftIndexDeltaBy(2);\n            } else {\n                // we need to insert the characters in reverse order, since we insert three times at the same location\n                buffer.insertChar(fixIndex + 1, bestReplacementCharacter);\n                buffer.insertChar(fixIndex + 1, INS_ERROR);\n                buffer.insertChar(fixIndex, DEL_ERROR);\n                errorIndex = nextErrorAfterBestReplacement + 5;\n                currentError.shiftIndexDeltaBy(1);\n            }\n        } else {\n            // we can't fix the error with a single char fix, so fall back to resynchronization\n            buffer.insertChar(fixIndex, RESYNC);\n            currentError.shiftIndexDeltaBy(1);\n            performLocatingRun(buffer); // find the next parse error\n        }\n        return errorIndex == -1;\n    }\n    \n    private boolean tryFixBySingleCharDeletion(int fixIndex) {\n        buffer.insertChar(fixIndex, DEL_ERROR);\n        boolean nowErrorFree = performLocatingRun(buffer);\n        if (nowErrorFree) {\n            currentError.shiftIndexDeltaBy(1); // compensate for the inserted DEL_ERROR char\n        } else {\n            buffer.undoCharInsertion(fixIndex);\n            errorIndex = Math.max(errorIndex - 1, 0);\n        }\n        return nowErrorFree;\n    }\n\n    @SuppressWarnings({\"ConstantConditions\"})\n    private Character findBestSingleCharInsertion(int fixIndex) {\n        GetStarterCharVisitor getStarterCharVisitor = new GetStarterCharVisitor();\n        int bestNextErrorIndex = -1;\n        Character bestChar = null;\n        for (MatcherPath failedMatcherPath : currentError.getFailedMatchers()) {\n            Character starterChar = failedMatcherPath.element.matcher.accept(getStarterCharVisitor);\n            checkState(starterChar != null); // we should only have single character matchers\n            if (starterChar == EOI) {\n                continue; // we should never conjure up an EOI character (that would be cheating :)\n            }\n            buffer.insertChar(fixIndex, starterChar);\n            buffer.insertChar(fixIndex, INS_ERROR);\n            if (performLocatingRun(buffer)) {\n                currentError.shiftIndexDeltaBy(2); // compensate for the inserted chars\n                return null; // success, exit immediately\n            }\n            buffer.undoCharInsertion(fixIndex);\n            buffer.undoCharInsertion(fixIndex);\n            errorIndex = Math.max(errorIndex - 2, 0);\n\n            if (bestNextErrorIndex < errorIndex) {\n                bestNextErrorIndex = errorIndex;\n                bestChar = starterChar;\n            }\n        }\n        errorIndex = bestNextErrorIndex;\n        return bestChar;\n    }\n\n    private Character findBestSingleCharReplacement(int fixIndex) {\n        buffer.insertChar(fixIndex, DEL_ERROR);\n        Character bestChar = findBestSingleCharInsertion(fixIndex + 2);\n        if (bestChar == null) { // success, we found a fix that renders the complete input error free\n            currentError.shiftIndexDeltaBy(-1); // delta from DEL_ERROR char insertion and index shift by insertion method\n        } else {\n            buffer.undoCharInsertion(fixIndex);\n            errorIndex = Math.max(errorIndex - 3, 0);\n        }\n        return bestChar;\n    }\n    \n    /**\n     * A {@link org.parboiled.MatchHandler} implementation that recognizes the special\n     * {@link org.parboiled.support.Chars#RESYNC} character to overcome {@link InvalidInputError}s at the respective\n     * error indices.\n     */\n    private class Handler implements MatchHandler {\n        private final IsSingleCharMatcherVisitor isSingleCharMatcherVisitor = new IsSingleCharMatcherVisitor();\n        private int fringeIndex;\n        private MatcherPath lastMatchPath;\n\n        public boolean match(MatcherContext<?> context) {\n            Matcher matcher = context.getMatcher();\n            if (matcher.accept(isSingleCharMatcherVisitor)) {\n                if (prepareErrorLocation(context) && matcher.match(context)) {\n                    if (fringeIndex < context.getCurrentIndex()) {\n                        fringeIndex = context.getCurrentIndex();\n                        lastMatchPath = context.getPath();\n                    }\n                    return true;\n                }\n                return false;\n            }\n\n            if (matcher.match(context)) {\n                return true;\n            }\n\n            // if we didn't match we might have to resynchronize, however we only resynchronize\n            // if we are at a RESYNC location and the matcher is a SequenceMatchers that has already\n            // matched at least one character and that is a parent of the last match\n            char fringeChar = context.getInputBuffer().charAt(fringeIndex);\n            return (fringeChar == RESYNC || fringeChar == RESYNC_START) &&\n                    qualifiesForResync(context, matcher) &&\n                    resynchronize(context, fringeChar);\n        }\n\n        @SuppressWarnings({\"SimplifiableIfStatement\"})\n        private boolean qualifiesForResync(MatcherContext context, Matcher matcher) {\n            if (matcher instanceof SequenceMatcher && context.getCurrentIndex() > context.getStartIndex() &&\n                    context.getPath().isPrefixOf(lastMatchPath)) {\n                return true;\n            }\n            return context.getParent() == null; // always resync on the root if there is nothing else\n        }\n\n        private boolean prepareErrorLocation(MatcherContext context) {\n            switch (context.getCurrentChar()) {\n                case DEL_ERROR:\n                    return willMatchDelError(context);\n                case INS_ERROR:\n                    return willMatchInsError(context);\n            }\n            return true;\n        }\n\n        private boolean willMatchDelError(MatcherContext context) {\n            int preSkipIndex = context.getCurrentIndex();\n            context.advanceIndex(2); // skip del marker char and illegal char\n            if (!runTestMatch(context)) {\n                // if we wouldn't succeed with the match do not swallow the ERROR char & Co\n                context.setCurrentIndex(preSkipIndex);\n                return false;\n            }\n            context.setStartIndex(context.getCurrentIndex());\n            if (context.getParent() != null) context.getParent().markError();\n            return true;\n        }\n\n        private boolean willMatchInsError(MatcherContext context) {\n            int preSkipIndex = context.getCurrentIndex();\n            context.advanceIndex(1); // skip ins marker char\n            if (!runTestMatch(context)) {\n                // if we wouldn't succeed with the match do not swallow the ERROR char\n                context.setCurrentIndex(preSkipIndex);\n                return false;\n            }\n            context.setStartIndex(context.getCurrentIndex());\n            context.markError();\n            return true;\n        }\n\n        private boolean runTestMatch(MatcherContext context) {\n            TestMatcher testMatcher = new TestMatcher(context.getMatcher());\n            MatcherContext testContext = testMatcher.getSubContext(context);\n            return prepareErrorLocation(testContext) && testContext.runMatcher();\n        }\n\n        private boolean resynchronize(MatcherContext context, char fringeChar) {\n            context.markError();\n\n            // create a node for the failed Sequence, taking ownership of all sub nodes created so far\n            context.createNode();\n\n            // by resyncing we flip an unmatched sequence to a matched one, so in order to keep the value stack\n            // consistent we go into a special \"error action mode\" and execute the minimal set of actions underneath\n            // the resync sequence\n            rerunAndExecuteErrorActions(context);\n\n            // skip over all characters that are not legal followers of the failed Sequence\n            context.advanceIndex(1); // gobble RESYNC or RESYNC_START marker\n            \n            switch (fringeChar) {\n                case RESYNC:\n                    // this RESYNC error is the last error, we establish the length of the bad sequence and\n                    // change this RESYNC marker to a RESYNC_START / RESYNC_END block\n                    buffer.replaceInsertedChar(currentError.getStartIndex() - 1, RESYNC_START);\n                    if (context.getCurrentChar() != Chars.EOI) {\n                        List<Matcher> followMatchers = new FollowMatchersVisitor().getFollowMatchers(context);\n                        int endIndex = gobbleIllegalCharacters(context, followMatchers);\n                        currentError.setEndIndex(endIndex);\n                        buffer.insertChar(endIndex, RESYNC_END);\n                    }\n                    break;\n                \n                case RESYNC_START:\n                    if (context.getCurrentChar() != Chars.EOI) {\n                        // a RESYNC error we have already recovered from before\n                        // simply skip all characters up to the RESYNC_END\n                        while (context.getCurrentChar() != RESYNC_END) {\n                            context.advanceIndex(1);\n                            checkState(context.getCurrentChar() != EOI); // we MUST find a RESYNC_END before EOI\n                        }\n                    }\n                    break;\n                \n                default:\n                    throw new IllegalStateException();\n            }\n            \n            context.advanceIndex(1); // also gobble the RESYNC_END itself\n            fringeIndex = context.getCurrentIndex();\n            \n            return true;\n        }\n\n        @SuppressWarnings({\"ConstantConditions\"})\n        private void rerunAndExecuteErrorActions(MatcherContext context) {\n            // the context is for the resync action, which at this point has FAILED, i.e. ALL its sub actions haven't\n            // had a chance to change the value stack, even the ones having run before the actual parse error matcher\n            // so we need to rerun all sub matchers of the resync sequence up to the point of the parse error\n            // and then run the minimal set of action in \"error action mode\"\n\n            int savedCurrentIndex = context.getCurrentIndex();\n            context.setCurrentIndex(context.getStartIndex()); // restart matching the resync sequence\n\n            Matcher lastGoodSub = lastMatchPath == null ? null :\n                    lastMatchPath.getElementAtLevel(context.getLevel() + 1).matcher;\n            boolean errorMode = false;\n\n            for (Matcher sub : context.getMatcher().getChildren()) {\n                if (errorMode) {\n                    List<ActionMatcher> errorActions = sub.accept(new CollectResyncActionsVisitor());\n                    checkState(errorActions != null);\n                    for (ActionMatcher action : errorActions) {\n                        action.getSubContext(context).runMatcher();\n                    }\n                    continue;\n                }\n                // as long as we are before the error matcher we simply execute normally\n                sub.getSubContext(context).runMatcher();\n                \n                if (sub == lastGoodSub) {\n                    // run an empty matcher which all error actions will see as the immediately preceding rule\n                    context.getSubContext(new EmptyMatcher()).runMatcher();\n                    errorMode = true;\n                }\n            }\n            context.setCurrentIndex(savedCurrentIndex);\n        }\n\n        private int gobbleIllegalCharacters(MatcherContext context, List<Matcher> followMatchers) {\n            while_loop:\n            while (true) {\n                char currentChar = context.getCurrentChar();\n                if (currentChar == EOI) break;\n                for (Matcher followMatcher : followMatchers) {\n                    if (followMatcher.accept(new IsStarterCharVisitor(currentChar))) {\n                        break while_loop;\n                    }\n                }\n                context.advanceIndex(1);\n            }\n            return context.getCurrentIndex();\n        }\n    }\n\n    /**\n     * This MatcherVisitor collects the minimal set of actions that has to run underneath a resyncronization sequence\n     * in order to maintain a consistent Value Stack state.\n     */\n    private static class CollectResyncActionsVisitor extends DefaultMatcherVisitor<List<ActionMatcher>> {\n        private ImmutableLinkedList<SequenceMatcher> path = ImmutableLinkedList.nil();\n\n        @Override\n        public List<ActionMatcher> visit(ActionMatcher matcher) {\n            return ImmutableList.of(matcher);\n        }\n \n        @Override\n        public List<ActionMatcher> visit(FirstOfMatcher matcher) {\n            for (Matcher child : matcher.getChildren()) {\n                List<ActionMatcher> actions = child.accept(this);\n                if (actions != null) return actions;\n            }\n            return null;\n        }\n \n        @Override\n        public List<ActionMatcher> visit(OneOrMoreMatcher matcher) {\n            return matcher.subMatcher.accept(this);\n        }\n \n        @Override\n        public List<ActionMatcher> visit(SequenceMatcher matcher) {\n            if (path.contains(matcher)) {\n                return null;\n            }\n \n            ImmutableLinkedList<SequenceMatcher> previousPath = path;\n            path = path.prepend(matcher);\n            \n            List<ActionMatcher> actions = new ArrayList<ActionMatcher>(); \n            for (Matcher sub : matcher.getChildren()) {\n                List<ActionMatcher> subActions = sub.accept(this);\n                if (subActions == null) return null;\n                actions.addAll(subActions);\n            }\n            \n            path = previousPath; \n            return actions;\n        }\n \n        @Override\n        public List<ActionMatcher> defaultValue(AbstractMatcher matcher) {\n            return ImmutableList.of();\n        }\n    }\n}\n","lineNo":404}
{"Refactored Sample":"/*\n * Copyright (C) 2009-2010 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.parserunners;\n\nimport org.parboiled.MatchHandler;\nimport org.parboiled.MatcherContext;\nimport org.parboiled.Rule;\nimport org.parboiled.buffers.InputBuffer;\nimport org.parboiled.buffers.MutableInputBuffer;\nimport org.parboiled.common.ImmutableLinkedList;\nimport org.parboiled.common.ImmutableList;\nimport org.parboiled.common.Preconditions;\nimport org.parboiled.errors.InvalidInputError;\nimport org.parboiled.matchers.*;\nimport org.parboiled.matchervisitors.*;\nimport org.parboiled.support.Chars;\nimport org.parboiled.support.MatcherPath;\nimport org.parboiled.support.ParsingResult;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.parboiled.common.Preconditions.checkArgNotNull;\nimport static org.parboiled.common.Preconditions.checkState;\nimport static org.parboiled.support.Chars.*;\n\n/**\n * A {@link org.parboiled.parserunners.ParseRunner} implementation that is able to recover from {@link org.parboiled.errors.InvalidInputError}s in the input and therefore\n * report more than just the first {@link org.parboiled.errors.InvalidInputError} if the input does not conform to the rule grammar.\n * Error recovery is done by attempting to either delete an error character, insert a potentially missing character\n * or do both at once (which is equivalent to a one char replace) whereby this implementation is able to determine\n * itself which of these options is the best strategy.\n * If the parse error cannot be overcome by either deleting, inserting or replacing one character a resynchronization\n * rule is determined and the parsing process resynchronized, so that parsing can still continue.\n * In this way the RecoveringParseRunner is able to completely parse all input texts (This ParseRunner never returns\n * an unmatched {@link org.parboiled.support.ParsingResult}).\n * If the input is error free this {@link org.parboiled.parserunners.ParseRunner} implementation will only perform one parsing run, with the same\n * speed as the {@link org.parboiled.parserunners.BasicParseRunner}. However, if there are {@link org.parboiled.errors.InvalidInputError}s in the input potentially\n * many more runs are performed to properly report all errors and test the various recovery strategies.\n */\npublic class RecoveringParseRunner<V> extends AbstractParseRunner<V> {\n    private int errorIndex;\n    private InvalidInputError currentError;\n    private MutableInputBuffer buffer;\n    private ParsingResult<V> lastParsingResult;\n    private Matcher rootMatcherWithoutPTB; // the root matcher with parse tree building disabled\n\n    /**\n     * Create a new RecoveringParseRunner instance with the given rule and input text and returns the result of\n     * its {@link #run(String)} method invocation.\n     *\n     * @param rule  the parser rule to run\n     * @param input the input text to run on\n     * @return the ParsingResult for the parsing run\n     * @deprecated As of 0.11.0 you should use the \"regular\" constructor and one of the \"run\" methods rather than\n     *             this static method. This method will be removed in one of the coming releases.\n     */\n    @Deprecated\n    public static <V> ParsingResult<V> run(Rule rule, String input) {\n        checkArgNotNull(rule, \"rule\");\n        checkArgNotNull(input, \"input\");\n        return new RecoveringParseRunner<V>(rule).run(input);\n    }\n\n    /**\n     * Creates a new RecoveringParseRunner instance for the given rule.\n     *\n     * @param rule the parser rule\n     */\n    public RecoveringParseRunner(Rule rule) {\n        super(rule);\n    }\n\n    public ParsingResult<V> run(InputBuffer inputBuffer) {\n        checkArgNotNull(inputBuffer, \"inputBuffer\");\n        resetValueStack();\n\n        // first, run a basic match\n        ParseRunner<V> basicRunner = new BasicParseRunner<V>(getRootMatcher())\n                .withParseErrors(getParseErrors())\n                .withValueStack(getValueStack());\n        lastParsingResult = basicRunner.run(inputBuffer);\n        \n        if (!lastParsingResult.matched) {\n            // for better performance disable parse tree building during the recovery runs\n            rootMatcherWithoutPTB = (Matcher) getRootMatcher().suppressNode();\n\n            // locate first error\n            performLocatingRun(inputBuffer);\n            checkState(errorIndex >= 0); // we failed before so we must fail again\n\n            // in order to be able to apply fixes we need to wrap the input buffer with a mutability wrapper\n            buffer = new MutableInputBuffer(inputBuffer);\n\n            // report first error\n            performReportingRun();\n\n            // fix and report until done\n            while (!fixError(errorIndex)) {\n                performReportingRun();\n            }\n\n            // rerun once more with parse tree building enabled to create a parse tree for the fixed input\n            if (!getRootMatcher().isNodeSuppressed()) {\n                performFinalRun();\n                checkState(lastParsingResult.matched);\n            }\n        }\n        return lastParsingResult;\n    }\n\n    private boolean performLocatingRun(InputBuffer inputBuffer) {\n        resetValueStack();\n        ParseRunner<V> locatingRunner = new ErrorLocatingParseRunner<V>(rootMatcherWithoutPTB, getInnerHandler())\n                .withParseErrors(getParseErrors())\n                .withValueStack(getValueStack());\n        lastParsingResult = locatingRunner.run(inputBuffer);\n        errorIndex = lastParsingResult.matched ? -1 :\n                getParseErrors().remove(getParseErrors().size() - 1).getStartIndex();\n        return lastParsingResult.matched;\n    }\n    \n    private void performReportingRun() {\n        resetValueStack();\n        ParseRunner<V> reportingRunner = new ErrorReportingParseRunner<V>(rootMatcherWithoutPTB, errorIndex, getInnerHandler())\n                .withParseErrors(getParseErrors())\n                .withValueStack(getValueStack());\n        ParsingResult<V> result = reportingRunner.run(buffer);\n        Preconditions.checkState(!result.matched); // we failed before so we should really be failing again\n        currentError = (InvalidInputError) getParseErrors().get(getParseErrors().size() - 1);\n    }\n    \n    private void performFinalRun() {\n        resetValueStack();\n        Handler handler = new Handler();\n        MatcherContext<V> rootContext = createRootContext(buffer, handler, false);\n        boolean matched = handler.match(rootContext);\n        lastParsingResult = createParsingResult(matched, rootContext);\n    }\n\n    private MatchHandler getInnerHandler() {\n        return errorIndex >= 0 ? new Handler() : null;\n    }\n    \n    private boolean fixError(int fixIndex) {\n        if (tryFixBySingleCharDeletion(fixIndex)) return true;\n        int nextErrorAfterDeletion = errorIndex;\n\n        Character bestInsertionCharacter = findBestSingleCharInsertion(fixIndex);\n        if (bestInsertionCharacter == null) return true;\n        int nextErrorAfterBestInsertion = errorIndex;\n\n        Character bestReplacementCharacter = findBestSingleCharReplacement(fixIndex);\n        if (bestReplacementCharacter == null) return true;\n        int nextErrorAfterBestReplacement = errorIndex;\n\n        int nextErrorAfterBestSingleCharFix =\n                Math.max(Math.max(nextErrorAfterDeletion, nextErrorAfterBestInsertion), nextErrorAfterBestReplacement);\n        if (nextErrorAfterBestSingleCharFix > fixIndex) {\n            // we are able to overcome the error with a single char fix, so apply the best one found\n            if (nextErrorAfterBestSingleCharFix == nextErrorAfterDeletion) {\n                buffer.insertChar(fixIndex, DEL_ERROR);\n                errorIndex = nextErrorAfterDeletion + 1;\n                currentError.shiftIndexDeltaBy(1);\n            } else if (nextErrorAfterBestSingleCharFix == nextErrorAfterBestInsertion) {\n                // we need to insert the characters in reverse order, since we insert twice at the same location\n                buffer.insertChar(fixIndex, bestInsertionCharacter);\n                buffer.insertChar(fixIndex, INS_ERROR);\n                errorIndex = nextErrorAfterBestInsertion + 2;\n                currentError.shiftIndexDeltaBy(2);\n            } else {\n                // we need to insert the characters in reverse order, since we insert three times at the same location\n                buffer.insertChar(fixIndex + 1, bestReplacementCharacter);\n                buffer.insertChar(fixIndex + 1, INS_ERROR);\n                buffer.insertChar(fixIndex, DEL_ERROR);\n                errorIndex = nextErrorAfterBestReplacement + 5;\n                currentError.shiftIndexDeltaBy(1);\n            }\n        } else {\n            // we can't fix the error with a single char fix, so fall back to resynchronization\n            buffer.insertChar(fixIndex, RESYNC);\n            currentError.shiftIndexDeltaBy(1);\n            performLocatingRun(buffer); // find the next parse error\n        }\n        return errorIndex == -1;\n    }\n    \n    private boolean tryFixBySingleCharDeletion(int fixIndex) {\n        buffer.insertChar(fixIndex, DEL_ERROR);\n        boolean nowErrorFree = performLocatingRun(buffer);\n        if (nowErrorFree) {\n            currentError.shiftIndexDeltaBy(1); // compensate for the inserted DEL_ERROR char\n        } else {\n            buffer.undoCharInsertion(fixIndex);\n            errorIndex = Math.max(errorIndex - 1, 0);\n        }\n        return nowErrorFree;\n    }\n\n    @SuppressWarnings({\"ConstantConditions\"})\n    private Character findBestSingleCharInsertion(int fixIndex) {\n        GetStarterCharVisitor getStarterCharVisitor = new GetStarterCharVisitor();\n        int bestNextErrorIndex = -1;\n        Character bestChar = null;\n        for (MatcherPath failedMatcherPath : currentError.getFailedMatchers()) {\n            Character starterChar = failedMatcherPath.element.matcher.accept(getStarterCharVisitor);\n            checkState(starterChar != null); // we should only have single character matchers\n            if (starterChar == EOI) {\n                continue; // we should never conjure up an EOI character (that would be cheating :)\n            }\n            buffer.insertChar(fixIndex, starterChar);\n            buffer.insertChar(fixIndex, INS_ERROR);\n            if (performLocatingRun(buffer)) {\n                currentError.shiftIndexDeltaBy(2); // compensate for the inserted chars\n                return null; // success, exit immediately\n            }\n            buffer.undoCharInsertion(fixIndex);\n            buffer.undoCharInsertion(fixIndex);\n            errorIndex = Math.max(errorIndex - 2, 0);\n\n            if (bestNextErrorIndex < errorIndex) {\n                bestNextErrorIndex = errorIndex;\n                bestChar = starterChar;\n            }\n        }\n        errorIndex = bestNextErrorIndex;\n        return bestChar;\n    }\n\n    private Character findBestSingleCharReplacement(int fixIndex) {\n        buffer.insertChar(fixIndex, DEL_ERROR);\n        Character bestChar = findBestSingleCharInsertion(fixIndex + 2);\n        if (bestChar == null) { // success, we found a fix that renders the complete input error free\n            currentError.shiftIndexDeltaBy(-1); // delta from DEL_ERROR char insertion and index shift by insertion method\n        } else {\n            buffer.undoCharInsertion(fixIndex);\n            errorIndex = Math.max(errorIndex - 3, 0);\n        }\n        return bestChar;\n    }\n    \n    /**\n     * A {@link org.parboiled.MatchHandler} implementation that recognizes the special\n     * {@link org.parboiled.support.Chars#RESYNC} character to overcome {@link InvalidInputError}s at the respective\n     * error indices.\n     */\n    private class Handler implements MatchHandler {\n        private final IsSingleCharMatcherVisitor isSingleCharMatcherVisitor = new IsSingleCharMatcherVisitor();\n        private int fringeIndex;\n        private MatcherPath lastMatchPath;\n\n        public boolean match(MatcherContext<?> context) {\n            Matcher matcher = context.getMatcher();\n            if (matcher.accept(isSingleCharMatcherVisitor)) {\n                if (prepareErrorLocation(context) && matcher.match(context)) {\n                    if (fringeIndex < context.getCurrentIndex()) {\n                        fringeIndex = context.getCurrentIndex();\n                        lastMatchPath = context.getPath();\n                    }\n                    return true;\n                }\n                return false;\n            }\n\n            if (matcher.match(context)) {\n                return true;\n            }\n\n            // if we didn't match we might have to resynchronize, however we only resynchronize\n            // if we are at a RESYNC location and the matcher is a SequenceMatchers that has already\n            // matched at least one character and that is a parent of the last match\n            char fringeChar = context.getInputBuffer().charAt(fringeIndex);\n            return (fringeChar == RESYNC || fringeChar == RESYNC_START) &&\n                    qualifiesForResync(context, matcher) &&\n                    resynchronize(context, fringeChar);\n        }\n\n        @SuppressWarnings({\"SimplifiableIfStatement\"})\n        private boolean qualifiesForResync(MatcherContext context, Matcher matcher) {\n            if (matcher instanceof SequenceMatcher && context.getCurrentIndex() > context.getStartIndex() &&\n                    context.getPath().isPrefixOf(lastMatchPath)) {\n                return true;\n            }\n            return context.getParent() == null; // always resync on the root if there is nothing else\n        }\n\n        private boolean prepareErrorLocation(MatcherContext context) {\n            switch (context.getCurrentChar()) {\n                case DEL_ERROR:\n                    return willMatchDelError(context);\n                case INS_ERROR:\n                    return willMatchInsError(context);\n            }\n            return true;\n        }\n\n        private boolean willMatchDelError(MatcherContext context) {\n            int preSkipIndex = context.getCurrentIndex();\n            context.advanceIndex(2); // skip del marker char and illegal char\n            if (!runTestMatch(context)) {\n                // if we wouldn't succeed with the match do not swallow the ERROR char & Co\n                context.setCurrentIndex(preSkipIndex);\n                return false;\n            }\n            context.setStartIndex(context.getCurrentIndex());\n            if (context.getParent() != null) context.getParent().markError();\n            return true;\n        }\n\n        private boolean willMatchInsError(MatcherContext context) {\n            int preSkipIndex = context.getCurrentIndex();\n            context.advanceIndex(1); // skip ins marker char\n            if (!runTestMatch(context)) {\n                // if we wouldn't succeed with the match do not swallow the ERROR char\n                context.setCurrentIndex(preSkipIndex);\n                return false;\n            }\n            context.setStartIndex(context.getCurrentIndex());\n            context.markError();\n            return true;\n        }\n\n        private boolean runTestMatch(MatcherContext context) {\n            TestMatcher testMatcher = new TestMatcher(context.getMatcher());\n            MatcherContext testContext = testMatcher.getSubContext(context);\n            return prepareErrorLocation(testContext) && testContext.runMatcher();\n        }\n\n        private boolean resynchronize(MatcherContext context, char fringeChar) {\n            context.markError();\n\n            // create a node for the failed Sequence, taking ownership of all sub nodes created so far\n            context.createNode();\n\n            // by resyncing we flip an unmatched sequence to a matched one, so in order to keep the value stack\n            // consistent we go into a special \"error action mode\" and execute the minimal set of actions underneath\n            // the resync sequence\n            rerunAndExecuteErrorActions(context);\n\n            // skip over all characters that are not legal followers of the failed Sequence\n            context.advanceIndex(1); // gobble RESYNC or RESYNC_START marker\n            \n            switch (fringeChar) {\n                case RESYNC:\n                    // this RESYNC error is the last error, we establish the length of the bad sequence and\n                    // change this RESYNC marker to a RESYNC_START / RESYNC_END block\n                    buffer.replaceInsertedChar(currentError.getStartIndex() - 1, RESYNC_START);\n                    if (context.getCurrentChar() != Chars.EOI) {\n                        List<Matcher> followMatchers = new FollowMatchersVisitor().getFollowMatchers(context);\n                        int endIndex = gobbleIllegalCharacters(context, followMatchers);\n                        currentError.setEndIndex(endIndex);\n                        buffer.insertChar(endIndex, RESYNC_END);\n                    }\n                    break;\n                \n                case RESYNC_START:\n                    if (context.getCurrentChar() != Chars.EOI) {\n                        // a RESYNC error we have already recovered from before\n                        // simply skip all characters up to the RESYNC_END\n                        while (context.getCurrentChar() != RESYNC_END) {\n                            context.advanceIndex(1);\n                            checkState(context.getCurrentChar() != EOI); // we MUST find a RESYNC_END before EOI\n                        }\n                    }\n                    break;\n                \n                default:\n                    throw new IllegalStateException();\n            }\n            \n            context.advanceIndex(1); // also gobble the RESYNC_END itself\n            fringeIndex = context.getCurrentIndex();\n            \n            return true;\n        }\n\n        @SuppressWarnings({\"ConstantConditions\"})\n        private void rerunAndExecuteErrorActions(MatcherContext context) {\n            // the context is for the resync action, which at this point has FAILED, i.e. ALL its sub actions haven't\n            // had a chance to change the value stack, even the ones having run before the actual parse error matcher\n            // so we need to rerun all sub matchers of the resync sequence up to the point of the parse error\n            // and then run the minimal set of action in \"error action mode\"\n\n            int savedCurrentIndex = context.getCurrentIndex();\n            context.setCurrentIndex(context.getStartIndex()); // restart matching the resync sequence\n\n            Matcher lastGoodSub = lastMatchPath == null ? null :\n                    lastMatchPath.getElementAtLevel(context.getLevel() + 1).matcher;\n            boolean errorMode = false;\n\n            for (Matcher sub : context.getMatcher().getChildren()) {\n                if (errorMode) {\n                    List<ActionMatcher> errorActions = sub.accept(new CollectResyncActionsVisitor());\n                    checkState(errorActions != null);\n                    for (ActionMatcher action : errorActions) {\n                        action.getSubContext(context).runMatcher();\n                    }\n                    continue;\n                }\n                // as long as we are before the error matcher we simply execute normally\n                sub.getSubContext(context).runMatcher();\n                \n                if (sub == lastGoodSub) {\n                    // run an empty matcher which all error actions will see as the immediately preceding rule\n                    context.getSubContext(new EmptyMatcher()).runMatcher();\n                    errorMode = true;\n                }\n            }\n            context.setCurrentIndex(savedCurrentIndex);\n        }\n\n        private int gobbleIllegalCharacters(MatcherContext context, List<Matcher> followMatchers) {\n            while_loop:\n            while (true) {\n                char currentChar = context.getCurrentChar();\n                if (currentChar == EOI) break;\n                for (Matcher followMatcher : followMatchers) {\n                    if (followMatcher.accept(new IsStarterCharVisitor(currentChar))) {\n                        break while_loop;\n                    }\n                }\n                context.advanceIndex(1);\n            }\n            return context.getCurrentIndex();\n        }\n    }\n\n    /**\n     * This MatcherVisitor collects the minimal set of actions that has to run underneath a resyncronization sequence\n     * in order to maintain a consistent Value Stack state.\n     */\n    private static class CollectResyncActionsVisitor extends DefaultMatcherVisitor<List<ActionMatcher>> {\n        private ImmutableLinkedList<SequenceMatcher> path = ImmutableLinkedList.nil();\n\n        @Override\n        public List<ActionMatcher> visit(ActionMatcher matcher) {\n            return ImmutableList.of(matcher);\n        }\n \n        @Override\n        public List<ActionMatcher> visit(FirstOfMatcher matcher) {\n            for (Matcher child : matcher.getChildren()) {\n                List<ActionMatcher> actions = child.accept(this);\n                if (actions != null) return actions;\n            }\n            return null;\n        }\n \n        @Override\n        public List<ActionMatcher> visit(OneOrMoreMatcher matcher) {\n            return matcher.subMatcher.accept(this);\n        }\n \n        @Override\n        public List<ActionMatcher> visit(SequenceMatcher matcher) {\n            if (path.contains(matcher)) {\n                return null;\n            }\n \n            ImmutableLinkedList<SequenceMatcher> previousPath = path;\n            path = path.prepend(matcher);\n            \n            List<ActionMatcher> actions = new ArrayList<ActionMatcher>(); \n            for (Matcher sub : matcher.getChildren()) {\n                List<ActionMatcher> subActions = sub.accept(this);\n                if (subActions == null) return null;\n                actions.addAll(subActions);\n            }\n            \n            path = previousPath; \n            return actions;\n        }\n \n        @Override\n        public List<ActionMatcher> defaultValue(AbstractMatcher matcher) {\n            return ImmutableList.of();\n        }\n    }\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009-2010 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.parserunners;\n\nimport org.parboiled.MatchHandler;\nimport org.parboiled.MatcherContext;\nimport org.parboiled.Rule;\nimport org.parboiled.buffers.InputBuffer;\nimport org.parboiled.buffers.MutableInputBuffer;\nimport org.parboiled.common.Preconditions;\nimport org.parboiled.errors.InvalidInputError;\nimport org.parboiled.matchers.*;\nimport org.parboiled.matchervisitors.*;\nimport org.parboiled.support.Chars;\nimport org.parboiled.support.MatcherPath;\nimport org.parboiled.support.ParsingResult;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport static org.parboiled.common.Preconditions.checkArgNotNull;\nimport static org.parboiled.common.Preconditions.checkState;\nimport static org.parboiled.support.Chars.*;\n\n/**\n * A {@link org.parboiled.parserunners.ParseRunner} implementation that is able to recover from {@link org.parboiled.errors.InvalidInputError}s in the input and therefore\n * report more than just the first {@link org.parboiled.errors.InvalidInputError} if the input does not conform to the rule grammar.\n * Error recovery is done by attempting to either delete an error character, insert a potentially missing character\n * or do both at once (which is equivalent to a one char replace) whereby this implementation is able to determine\n * itself which of these options is the best strategy.\n * If the parse error cannot be overcome by either deleting, inserting or replacing one character a resynchronization\n * rule is determined and the parsing process resynchronized, so that parsing can still continue.\n * In this way the RecoveringParseRunner is able to completely parse all input texts (This ParseRunner never returns\n * an unmatched {@link org.parboiled.support.ParsingResult}).\n * If the input is error free this {@link org.parboiled.parserunners.ParseRunner} implementation will only perform one parsing run, with the same\n * speed as the {@link org.parboiled.parserunners.BasicParseRunner}. However, if there are {@link org.parboiled.errors.InvalidInputError}s in the input potentially\n * many more runs are performed to properly report all errors and test the various recovery strategies.\n */\npublic class RecoveringParseRunner<V> extends AbstractParseRunner<V> {\n    private int errorIndex;\n    private InvalidInputError currentError;\n    private MutableInputBuffer buffer;\n    private ParsingResult<V> lastParsingResult;\n    private Matcher rootMatcherWithoutPTB; // the root matcher with parse tree building disabled\n\n    /**\n     * Create a new RecoveringParseRunner instance with the given rule and input text and returns the result of\n     * its {@link #run(String)} method invocation.\n     *\n     * @param rule  the parser rule to run\n     * @param input the input text to run on\n     * @return the ParsingResult for the parsing run\n     * @deprecated As of 0.11.0 you should use the \"regular\" constructor and one of the \"run\" methods rather than\n     *             this static method. This method will be removed in one of the coming releases.\n     */\n    @Deprecated\n    public static <V> ParsingResult<V> run(Rule rule, String input) {\n        checkArgNotNull(rule, \"rule\");\n        checkArgNotNull(input, \"input\");\n        return new RecoveringParseRunner<V>(rule).run(input);\n    }\n\n    /**\n     * Creates a new RecoveringParseRunner instance for the given rule.\n     *\n     * @param rule the parser rule\n     */\n    public RecoveringParseRunner(Rule rule) {\n        super(rule);\n    }\n\n    public ParsingResult<V> run(InputBuffer inputBuffer) {\n        checkArgNotNull(inputBuffer, \"inputBuffer\");\n        resetValueStack();\n\n        // first, run a basic match\n        ParseRunner<V> basicRunner = new BasicParseRunner<V>(getRootMatcher())\n                .withParseErrors(getParseErrors())\n                .withValueStack(getValueStack());\n        lastParsingResult = basicRunner.run(inputBuffer);\n        \n        if (!lastParsingResult.matched) {\n            // for better performance disable parse tree building during the recovery runs\n            rootMatcherWithoutPTB = (Matcher) getRootMatcher().suppressNode();\n\n            // locate first error\n            performLocatingRun(inputBuffer);\n            checkState(errorIndex >= 0); // we failed before so we must fail again\n\n            // in order to be able to apply fixes we need to wrap the input buffer with a mutability wrapper\n            buffer = new MutableInputBuffer(inputBuffer);\n\n            // report first error\n            performReportingRun();\n\n            // fix and report until done\n            while (!fixError(errorIndex)) {\n                performReportingRun();\n            }\n\n            // rerun once more with parse tree building enabled to create a parse tree for the fixed input\n            if (!getRootMatcher().isNodeSuppressed()) {\n                performFinalRun();\n                checkState(lastParsingResult.matched);\n            }\n        }\n        return lastParsingResult;\n    }\n\n    private boolean performLocatingRun(InputBuffer inputBuffer) {\n        resetValueStack();\n        ParseRunner<V> locatingRunner = new ErrorLocatingParseRunner<V>(rootMatcherWithoutPTB, getInnerHandler())\n                .withParseErrors(getParseErrors())\n                .withValueStack(getValueStack());\n        lastParsingResult = locatingRunner.run(inputBuffer);\n        errorIndex = lastParsingResult.matched ? -1 :\n                getParseErrors().remove(getParseErrors().size() - 1).getStartIndex();\n        return lastParsingResult.matched;\n    }\n    \n    private void performReportingRun() {\n        resetValueStack();\n        ParseRunner<V> reportingRunner = new ErrorReportingParseRunner<V>(rootMatcherWithoutPTB, errorIndex, getInnerHandler())\n                .withParseErrors(getParseErrors())\n                .withValueStack(getValueStack());\n        ParsingResult<V> result = reportingRunner.run(buffer);\n        Preconditions.checkState(!result.matched); // we failed before so we should really be failing again\n        currentError = (InvalidInputError) getParseErrors().get(getParseErrors().size() - 1);\n    }\n    \n    private void performFinalRun() {\n        resetValueStack();\n        Handler handler = new Handler();\n        MatcherContext<V> rootContext = createRootContext(buffer, handler, false);\n        boolean matched = handler.match(rootContext);\n        lastParsingResult = createParsingResult(matched, rootContext);\n    }\n\n    private MatchHandler getInnerHandler() {\n        return errorIndex >= 0 ? new Handler() : null;\n    }\n    \n    private boolean fixError(int fixIndex) {\n        if (tryFixBySingleCharDeletion(fixIndex)) return true;\n        int nextErrorAfterDeletion = errorIndex;\n\n        Character bestInsertionCharacter = findBestSingleCharInsertion(fixIndex);\n        if (bestInsertionCharacter == null) return true;\n        int nextErrorAfterBestInsertion = errorIndex;\n\n        Character bestReplacementCharacter = findBestSingleCharReplacement(fixIndex);\n        if (bestReplacementCharacter == null) return true;\n        int nextErrorAfterBestReplacement = errorIndex;\n\n        int nextErrorAfterBestSingleCharFix =\n                Math.max(Math.max(nextErrorAfterDeletion, nextErrorAfterBestInsertion), nextErrorAfterBestReplacement);\n        if (nextErrorAfterBestSingleCharFix > fixIndex) {\n            // we are able to overcome the error with a single char fix, so apply the best one found\n            if (nextErrorAfterBestSingleCharFix == nextErrorAfterDeletion) {\n                buffer.insertChar(fixIndex, DEL_ERROR);\n                errorIndex = nextErrorAfterDeletion + 1;\n                currentError.shiftIndexDeltaBy(1);\n            } else if (nextErrorAfterBestSingleCharFix == nextErrorAfterBestInsertion) {\n                // we need to insert the characters in reverse order, since we insert twice at the same location\n                buffer.insertChar(fixIndex, bestInsertionCharacter);\n                buffer.insertChar(fixIndex, INS_ERROR);\n                errorIndex = nextErrorAfterBestInsertion + 2;\n                currentError.shiftIndexDeltaBy(2);\n            } else {\n                // we need to insert the characters in reverse order, since we insert three times at the same location\n                buffer.insertChar(fixIndex + 1, bestReplacementCharacter);\n                buffer.insertChar(fixIndex + 1, INS_ERROR);\n                buffer.insertChar(fixIndex, DEL_ERROR);\n                errorIndex = nextErrorAfterBestReplacement + 5;\n                currentError.shiftIndexDeltaBy(1);\n            }\n        } else {\n            // we can't fix the error with a single char fix, so fall back to resynchronization\n            buffer.insertChar(fixIndex, RESYNC);\n            currentError.shiftIndexDeltaBy(1);\n            performLocatingRun(buffer); // find the next parse error\n        }\n        return errorIndex == -1;\n    }\n    \n    private boolean tryFixBySingleCharDeletion(int fixIndex) {\n        buffer.insertChar(fixIndex, DEL_ERROR);\n        boolean nowErrorFree = performLocatingRun(buffer);\n        if (nowErrorFree) {\n            currentError.shiftIndexDeltaBy(1); // compensate for the inserted DEL_ERROR char\n        } else {\n            buffer.undoCharInsertion(fixIndex);\n            errorIndex = Math.max(errorIndex - 1, 0);\n        }\n        return nowErrorFree;\n    }\n\n    @SuppressWarnings({\"ConstantConditions\"})\n    private Character findBestSingleCharInsertion(int fixIndex) {\n        GetStarterCharVisitor getStarterCharVisitor = new GetStarterCharVisitor();\n        int bestNextErrorIndex = -1;\n        Character bestChar = null;\n        for (MatcherPath failedMatcherPath : currentError.getFailedMatchers()) {\n            Character starterChar = failedMatcherPath.element.matcher.accept(getStarterCharVisitor);\n            checkState(starterChar != null); // we should only have single character matchers\n            if (starterChar == EOI) {\n                continue; // we should never conjure up an EOI character (that would be cheating :)\n            }\n            buffer.insertChar(fixIndex, starterChar);\n            buffer.insertChar(fixIndex, INS_ERROR);\n            if (performLocatingRun(buffer)) {\n                currentError.shiftIndexDeltaBy(2); // compensate for the inserted chars\n                return null; // success, exit immediately\n            }\n            buffer.undoCharInsertion(fixIndex);\n            buffer.undoCharInsertion(fixIndex);\n            errorIndex = Math.max(errorIndex - 2, 0);\n\n            if (bestNextErrorIndex < errorIndex) {\n                bestNextErrorIndex = errorIndex;\n                bestChar = starterChar;\n            }\n        }\n        errorIndex = bestNextErrorIndex;\n        return bestChar;\n    }\n\n    private Character findBestSingleCharReplacement(int fixIndex) {\n        buffer.insertChar(fixIndex, DEL_ERROR);\n        Character bestChar = findBestSingleCharInsertion(fixIndex + 2);\n        if (bestChar == null) { // success, we found a fix that renders the complete input error free\n            currentError.shiftIndexDeltaBy(-1); // delta from DEL_ERROR char insertion and index shift by insertion method\n        } else {\n            buffer.undoCharInsertion(fixIndex);\n            errorIndex = Math.max(errorIndex - 3, 0);\n        }\n        return bestChar;\n    }\n    \n    /**\n     * A {@link org.parboiled.MatchHandler} implementation that recognizes the special\n     * {@link org.parboiled.support.Chars#RESYNC} character to overcome {@link InvalidInputError}s at the respective\n     * error indices.\n     */\n    private class Handler implements MatchHandler {\n        private final IsSingleCharMatcherVisitor isSingleCharMatcherVisitor = new IsSingleCharMatcherVisitor();\n        private int fringeIndex;\n        private MatcherPath lastMatchPath;\n\n        public boolean match(MatcherContext<?> context) {\n            Matcher matcher = context.getMatcher();\n            if (matcher.accept(isSingleCharMatcherVisitor)) {\n                if (prepareErrorLocation(context) && matcher.match(context)) {\n                    if (fringeIndex < context.getCurrentIndex()) {\n                        fringeIndex = context.getCurrentIndex();\n                        lastMatchPath = context.getPath();\n                    }\n                    return true;\n                }\n                return false;\n            }\n\n            if (matcher.match(context)) {\n                return true;\n            }\n\n            // if we didn't match we might have to resynchronize, however we only resynchronize\n            // if we are at a RESYNC location and the matcher is a SequenceMatchers that has already\n            // matched at least one character and that is a parent of the last match\n            char fringeChar = context.getInputBuffer().charAt(fringeIndex);\n            return (fringeChar == RESYNC || fringeChar == RESYNC_START) &&\n                    qualifiesForResync(context, matcher) &&\n                    resynchronize(context, fringeChar);\n        }\n\n        @SuppressWarnings({\"SimplifiableIfStatement\"})\n        private boolean qualifiesForResync(MatcherContext context, Matcher matcher) {\n            if (matcher instanceof SequenceMatcher && context.getCurrentIndex() > context.getStartIndex() &&\n                    context.getPath().isPrefixOf(lastMatchPath)) {\n                return true;\n            }\n            return context.getParent() == null; // always resync on the root if there is nothing else\n        }\n\n        private boolean prepareErrorLocation(MatcherContext context) {\n            switch (context.getCurrentChar()) {\n                case DEL_ERROR:\n                    return willMatchDelError(context);\n                case INS_ERROR:\n                    return willMatchInsError(context);\n            }\n            return true;\n        }\n\n        private boolean willMatchDelError(MatcherContext context) {\n            int preSkipIndex = context.getCurrentIndex();\n            context.advanceIndex(2); // skip del marker char and illegal char\n            if (!runTestMatch(context)) {\n                // if we wouldn't succeed with the match do not swallow the ERROR char & Co\n                context.setCurrentIndex(preSkipIndex);\n                return false;\n            }\n            context.setStartIndex(context.getCurrentIndex());\n            if (context.getParent() != null) context.getParent().markError();\n            return true;\n        }\n\n        private boolean willMatchInsError(MatcherContext context) {\n            int preSkipIndex = context.getCurrentIndex();\n            context.advanceIndex(1); // skip ins marker char\n            if (!runTestMatch(context)) {\n                // if we wouldn't succeed with the match do not swallow the ERROR char\n                context.setCurrentIndex(preSkipIndex);\n                return false;\n            }\n            context.setStartIndex(context.getCurrentIndex());\n            context.markError();\n            return true;\n        }\n\n        private boolean runTestMatch(MatcherContext context) {\n            TestMatcher testMatcher = new TestMatcher(context.getMatcher());\n            MatcherContext testContext = testMatcher.getSubContext(context);\n            return prepareErrorLocation(testContext) && testContext.runMatcher();\n        }\n\n        private boolean resynchronize(MatcherContext context, char fringeChar) {\n            context.markError();\n\n            // create a node for the failed Sequence, taking ownership of all sub nodes created so far\n            context.createNode();\n\n            // by resyncing we flip an unmatched sequence to a matched one, so in order to keep the value stack\n            // consistent we go into a special \"error action mode\" and execute the minimal set of actions underneath\n            // the resync sequence\n            rerunAndExecuteErrorActions(context);\n\n            // skip over all characters that are not legal followers of the failed Sequence\n            context.advanceIndex(1); // gobble RESYNC or RESYNC_START marker\n            \n            switch (fringeChar) {\n                case RESYNC:\n                    // this RESYNC error is the last error, we establish the length of the bad sequence and\n                    // change this RESYNC marker to a RESYNC_START / RESYNC_END block\n                    buffer.replaceInsertedChar(currentError.getStartIndex() - 1, RESYNC_START);\n                    if (context.getCurrentChar() != Chars.EOI) {\n                        List<Matcher> followMatchers = new FollowMatchersVisitor().getFollowMatchers(context);\n                        int endIndex = gobbleIllegalCharacters(context, followMatchers);\n                        currentError.setEndIndex(endIndex);\n                        buffer.insertChar(endIndex, RESYNC_END);\n                    }\n                    break;\n                \n                case RESYNC_START:\n                    if (context.getCurrentChar() != Chars.EOI) {\n                        // a RESYNC error we have already recovered from before\n                        // simply skip all characters up to the RESYNC_END\n                        while (context.getCurrentChar() != RESYNC_END) {\n                            context.advanceIndex(1);\n                            checkState(context.getCurrentChar() != EOI); // we MUST find a RESYNC_END before EOI\n                        }\n                    }\n                    break;\n                \n                default:\n                    throw new IllegalStateException();\n            }\n            \n            context.advanceIndex(1); // also gobble the RESYNC_END itself\n            fringeIndex = context.getCurrentIndex();\n            \n            return true;\n        }\n\n        private void rerunAndExecuteErrorActions(MatcherContext context) {\n            // the context is for the resync action, which at this point has FAILED, i.e. ALL its sub actions haven't\n            // had a chance to change the value stack, even the ones having run before the actual parse error matcher\n            // so we need to rerun all sub matchers of the resync sequence up to the point of the parse error\n            // and then run the minimal set of action in \"error action mode\"\n\n            int savedCurrentIndex = context.getCurrentIndex();\n            context.setCurrentIndex(context.getStartIndex()); // restart matching the resync sequence\n\n            Matcher lastGoodSub = lastMatchPath == null ? null :\n                    lastMatchPath.getElementAtLevel(context.getLevel() + 1).matcher;\n            boolean errorMode = false;\n\n            for (Matcher sub : context.getMatcher().getChildren()) {\n                if (errorMode) {\n                    for (ActionMatcher action : sub.accept(new CollectResyncActionsVisitor())) {\n                        action.getSubContext(context).runMatcher();\n                    }\n                    continue;\n                }\n                // as long as we are before the error matcher we simply execute normally\n                sub.getSubContext(context).runMatcher();\n                \n                if (sub == lastGoodSub) {\n                    // run an empty matcher which all error actions will see as the immediately preceding rule\n                    context.getSubContext(new EmptyMatcher()).runMatcher();\n                    errorMode = true;\n                }\n            }\n            context.setCurrentIndex(savedCurrentIndex);\n        }\n\n        private int gobbleIllegalCharacters(MatcherContext context, List<Matcher> followMatchers) {\n            while_loop:\n            while (true) {\n                char currentChar = context.getCurrentChar();\n                if (currentChar == EOI) break;\n                for (Matcher followMatcher : followMatchers) {\n                    if (followMatcher.accept(new IsStarterCharVisitor(currentChar))) {\n                        break while_loop;\n                    }\n                }\n                context.advanceIndex(1);\n            }\n            return context.getCurrentIndex();\n        }\n    }\n\n    /**\n     * This MatcherVisitor collects the minimal set of actions that has to run underneath a resyncronization sequence\n     * in order to maintain a consistent Value Stack state.\n     */\n    private static class CollectResyncActionsVisitor extends DefaultMatcherVisitor<List<ActionMatcher>> {\n        private final Set<Matcher> visited = new HashSet<Matcher>();\n        private final List<ActionMatcher> actions = new ArrayList<ActionMatcher>();\n\n        @Override\n        public List<ActionMatcher> visit(ActionMatcher matcher) {\n            actions.add(matcher);\n            return actions;\n        }\n\n        @Override\n        public List<ActionMatcher> visit(FirstOfMatcher matcher) {\n            // go through all subs in reverse order (because the simplest fall-back cases are often in last position)\n            // and try all of them until we hit a path that does not lead to a recursion\n            List<Matcher> children = matcher.getChildren();\n            for (int i = children.size() - 1; i >= 0; i--) {\n                if (children.get(i).accept(this) != null) return actions;\n            }\n            // a FirstOf where all subs lead to recursions,\n            // so go up one level and try another branch of the next FirstOf one level up\n            return null;\n        }\n\n        @Override\n        public List<ActionMatcher> visit(OneOrMoreMatcher matcher) {\n            return matcher.subMatcher.accept(this);\n        }\n\n        @Override\n        public List<ActionMatcher> visit(SequenceMatcher matcher) {\n            if (visited.contains(matcher)) {\n                // we hit a recursion, so signal to the next FirstOf parent that we need to take another path in order\n                // to collect all actions\n                return null;\n            }\n\n            visited.add(matcher);\n            for (Matcher sub : matcher.getChildren()) {\n                sub.accept(this);\n            }\n            return actions;\n        }\n\n        @Override\n        public List<ActionMatcher> defaultValue(AbstractMatcher matcher) {\n            return actions;\n        }\n    }\n}\n","lineNo":407}
{"Refactored Sample":"/*\n * Copyright (C) 2009-2010 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.parserunners;\n\nimport org.parboiled.MatchHandler;\nimport org.parboiled.MatcherContext;\nimport org.parboiled.Rule;\nimport org.parboiled.buffers.InputBuffer;\nimport org.parboiled.buffers.MutableInputBuffer;\nimport org.parboiled.common.ImmutableLinkedList;\nimport org.parboiled.common.ImmutableList;\nimport org.parboiled.common.Preconditions;\nimport org.parboiled.errors.InvalidInputError;\nimport org.parboiled.matchers.*;\nimport org.parboiled.matchervisitors.*;\nimport org.parboiled.support.Chars;\nimport org.parboiled.support.MatcherPath;\nimport org.parboiled.support.ParsingResult;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.parboiled.common.Preconditions.checkArgNotNull;\nimport static org.parboiled.common.Preconditions.checkState;\nimport static org.parboiled.support.Chars.*;\n\n/**\n * A {@link org.parboiled.parserunners.ParseRunner} implementation that is able to recover from {@link org.parboiled.errors.InvalidInputError}s in the input and therefore\n * report more than just the first {@link org.parboiled.errors.InvalidInputError} if the input does not conform to the rule grammar.\n * Error recovery is done by attempting to either delete an error character, insert a potentially missing character\n * or do both at once (which is equivalent to a one char replace) whereby this implementation is able to determine\n * itself which of these options is the best strategy.\n * If the parse error cannot be overcome by either deleting, inserting or replacing one character a resynchronization\n * rule is determined and the parsing process resynchronized, so that parsing can still continue.\n * In this way the RecoveringParseRunner is able to completely parse all input texts (This ParseRunner never returns\n * an unmatched {@link org.parboiled.support.ParsingResult}).\n * If the input is error free this {@link org.parboiled.parserunners.ParseRunner} implementation will only perform one parsing run, with the same\n * speed as the {@link org.parboiled.parserunners.BasicParseRunner}. However, if there are {@link org.parboiled.errors.InvalidInputError}s in the input potentially\n * many more runs are performed to properly report all errors and test the various recovery strategies.\n */\npublic class RecoveringParseRunner<V> extends AbstractParseRunner<V> {\n    private int errorIndex;\n    private InvalidInputError currentError;\n    private MutableInputBuffer buffer;\n    private ParsingResult<V> lastParsingResult;\n    private Matcher rootMatcherWithoutPTB; // the root matcher with parse tree building disabled\n\n    /**\n     * Create a new RecoveringParseRunner instance with the given rule and input text and returns the result of\n     * its {@link #run(String)} method invocation.\n     *\n     * @param rule  the parser rule to run\n     * @param input the input text to run on\n     * @return the ParsingResult for the parsing run\n     * @deprecated As of 0.11.0 you should use the \"regular\" constructor and one of the \"run\" methods rather than\n     *             this static method. This method will be removed in one of the coming releases.\n     */\n    @Deprecated\n    public static <V> ParsingResult<V> run(Rule rule, String input) {\n        checkArgNotNull(rule, \"rule\");\n        checkArgNotNull(input, \"input\");\n        return new RecoveringParseRunner<V>(rule).run(input);\n    }\n\n    /**\n     * Creates a new RecoveringParseRunner instance for the given rule.\n     *\n     * @param rule the parser rule\n     */\n    public RecoveringParseRunner(Rule rule) {\n        super(rule);\n    }\n\n    public ParsingResult<V> run(InputBuffer inputBuffer) {\n        checkArgNotNull(inputBuffer, \"inputBuffer\");\n        resetValueStack();\n\n        // first, run a basic match\n        ParseRunner<V> basicRunner = new BasicParseRunner<V>(getRootMatcher())\n                .withParseErrors(getParseErrors())\n                .withValueStack(getValueStack());\n        lastParsingResult = basicRunner.run(inputBuffer);\n        \n        if (!lastParsingResult.matched) {\n            // for better performance disable parse tree building during the recovery runs\n            rootMatcherWithoutPTB = (Matcher) getRootMatcher().suppressNode();\n\n            // locate first error\n            performLocatingRun(inputBuffer);\n            checkState(errorIndex >= 0); // we failed before so we must fail again\n\n            // in order to be able to apply fixes we need to wrap the input buffer with a mutability wrapper\n            buffer = new MutableInputBuffer(inputBuffer);\n\n            // report first error\n            performReportingRun();\n\n            // fix and report until done\n            while (!fixError(errorIndex)) {\n                performReportingRun();\n            }\n\n            // rerun once more with parse tree building enabled to create a parse tree for the fixed input\n            if (!getRootMatcher().isNodeSuppressed()) {\n                performFinalRun();\n                checkState(lastParsingResult.matched);\n            }\n        }\n        return lastParsingResult;\n    }\n\n    private boolean performLocatingRun(InputBuffer inputBuffer) {\n        resetValueStack();\n        ParseRunner<V> locatingRunner = new ErrorLocatingParseRunner<V>(rootMatcherWithoutPTB, getInnerHandler())\n                .withParseErrors(getParseErrors())\n                .withValueStack(getValueStack());\n        lastParsingResult = locatingRunner.run(inputBuffer);\n        errorIndex = lastParsingResult.matched ? -1 :\n                getParseErrors().remove(getParseErrors().size() - 1).getStartIndex();\n        return lastParsingResult.matched;\n    }\n    \n    private void performReportingRun() {\n        resetValueStack();\n        ParseRunner<V> reportingRunner = new ErrorReportingParseRunner<V>(rootMatcherWithoutPTB, errorIndex, getInnerHandler())\n                .withParseErrors(getParseErrors())\n                .withValueStack(getValueStack());\n        ParsingResult<V> result = reportingRunner.run(buffer);\n        Preconditions.checkState(!result.matched); // we failed before so we should really be failing again\n        currentError = (InvalidInputError) getParseErrors().get(getParseErrors().size() - 1);\n    }\n    \n    private void performFinalRun() {\n        resetValueStack();\n        Handler handler = new Handler();\n        MatcherContext<V> rootContext = createRootContext(buffer, handler, false);\n        boolean matched = handler.match(rootContext);\n        lastParsingResult = createParsingResult(matched, rootContext);\n    }\n\n    private MatchHandler getInnerHandler() {\n        return errorIndex >= 0 ? new Handler() : null;\n    }\n    \n    private boolean fixError(int fixIndex) {\n        if (tryFixBySingleCharDeletion(fixIndex)) return true;\n        int nextErrorAfterDeletion = errorIndex;\n\n        Character bestInsertionCharacter = findBestSingleCharInsertion(fixIndex);\n        if (bestInsertionCharacter == null) return true;\n        int nextErrorAfterBestInsertion = errorIndex;\n\n        Character bestReplacementCharacter = findBestSingleCharReplacement(fixIndex);\n        if (bestReplacementCharacter == null) return true;\n        int nextErrorAfterBestReplacement = errorIndex;\n\n        int nextErrorAfterBestSingleCharFix =\n                Math.max(Math.max(nextErrorAfterDeletion, nextErrorAfterBestInsertion), nextErrorAfterBestReplacement);\n        if (nextErrorAfterBestSingleCharFix > fixIndex) {\n            // we are able to overcome the error with a single char fix, so apply the best one found\n            if (nextErrorAfterBestSingleCharFix == nextErrorAfterDeletion) {\n                buffer.insertChar(fixIndex, DEL_ERROR);\n                errorIndex = nextErrorAfterDeletion + 1;\n                currentError.shiftIndexDeltaBy(1);\n            } else if (nextErrorAfterBestSingleCharFix == nextErrorAfterBestInsertion) {\n                // we need to insert the characters in reverse order, since we insert twice at the same location\n                buffer.insertChar(fixIndex, bestInsertionCharacter);\n                buffer.insertChar(fixIndex, INS_ERROR);\n                errorIndex = nextErrorAfterBestInsertion + 2;\n                currentError.shiftIndexDeltaBy(2);\n            } else {\n                // we need to insert the characters in reverse order, since we insert three times at the same location\n                buffer.insertChar(fixIndex + 1, bestReplacementCharacter);\n                buffer.insertChar(fixIndex + 1, INS_ERROR);\n                buffer.insertChar(fixIndex, DEL_ERROR);\n                errorIndex = nextErrorAfterBestReplacement + 5;\n                currentError.shiftIndexDeltaBy(1);\n            }\n        } else {\n            // we can't fix the error with a single char fix, so fall back to resynchronization\n            buffer.insertChar(fixIndex, RESYNC);\n            currentError.shiftIndexDeltaBy(1);\n            performLocatingRun(buffer); // find the next parse error\n        }\n        return errorIndex == -1;\n    }\n    \n    private boolean tryFixBySingleCharDeletion(int fixIndex) {\n        buffer.insertChar(fixIndex, DEL_ERROR);\n        boolean nowErrorFree = performLocatingRun(buffer);\n        if (nowErrorFree) {\n            currentError.shiftIndexDeltaBy(1); // compensate for the inserted DEL_ERROR char\n        } else {\n            buffer.undoCharInsertion(fixIndex);\n            errorIndex = Math.max(errorIndex - 1, 0);\n        }\n        return nowErrorFree;\n    }\n\n    @SuppressWarnings({\"ConstantConditions\"})\n    private Character findBestSingleCharInsertion(int fixIndex) {\n        GetStarterCharVisitor getStarterCharVisitor = new GetStarterCharVisitor();\n        int bestNextErrorIndex = -1;\n        Character bestChar = null;\n        for (MatcherPath failedMatcherPath : currentError.getFailedMatchers()) {\n            Character starterChar = failedMatcherPath.element.matcher.accept(getStarterCharVisitor);\n            checkState(starterChar != null); // we should only have single character matchers\n            if (starterChar == EOI) {\n                continue; // we should never conjure up an EOI character (that would be cheating :)\n            }\n            buffer.insertChar(fixIndex, starterChar);\n            buffer.insertChar(fixIndex, INS_ERROR);\n            if (performLocatingRun(buffer)) {\n                currentError.shiftIndexDeltaBy(2); // compensate for the inserted chars\n                return null; // success, exit immediately\n            }\n            buffer.undoCharInsertion(fixIndex);\n            buffer.undoCharInsertion(fixIndex);\n            errorIndex = Math.max(errorIndex - 2, 0);\n\n            if (bestNextErrorIndex < errorIndex) {\n                bestNextErrorIndex = errorIndex;\n                bestChar = starterChar;\n            }\n        }\n        errorIndex = bestNextErrorIndex;\n        return bestChar;\n    }\n\n    private Character findBestSingleCharReplacement(int fixIndex) {\n        buffer.insertChar(fixIndex, DEL_ERROR);\n        Character bestChar = findBestSingleCharInsertion(fixIndex + 2);\n        if (bestChar == null) { // success, we found a fix that renders the complete input error free\n            currentError.shiftIndexDeltaBy(-1); // delta from DEL_ERROR char insertion and index shift by insertion method\n        } else {\n            buffer.undoCharInsertion(fixIndex);\n            errorIndex = Math.max(errorIndex - 3, 0);\n        }\n        return bestChar;\n    }\n    \n    /**\n     * A {@link org.parboiled.MatchHandler} implementation that recognizes the special\n     * {@link org.parboiled.support.Chars#RESYNC} character to overcome {@link InvalidInputError}s at the respective\n     * error indices.\n     */\n    private class Handler implements MatchHandler {\n        private final IsSingleCharMatcherVisitor isSingleCharMatcherVisitor = new IsSingleCharMatcherVisitor();\n        private int fringeIndex;\n        private MatcherPath lastMatchPath;\n\n        public boolean match(MatcherContext<?> context) {\n            Matcher matcher = context.getMatcher();\n            if (matcher.accept(isSingleCharMatcherVisitor)) {\n                if (prepareErrorLocation(context) && matcher.match(context)) {\n                    if (fringeIndex < context.getCurrentIndex()) {\n                        fringeIndex = context.getCurrentIndex();\n                        lastMatchPath = context.getPath();\n                    }\n                    return true;\n                }\n                return false;\n            }\n\n            if (matcher.match(context)) {\n                return true;\n            }\n\n            // if we didn't match we might have to resynchronize, however we only resynchronize\n            // if we are at a RESYNC location and the matcher is a SequenceMatchers that has already\n            // matched at least one character and that is a parent of the last match\n            char fringeChar = context.getInputBuffer().charAt(fringeIndex);\n            return (fringeChar == RESYNC || fringeChar == RESYNC_START) &&\n                    qualifiesForResync(context, matcher) &&\n                    resynchronize(context, fringeChar);\n        }\n\n        @SuppressWarnings({\"SimplifiableIfStatement\"})\n        private boolean qualifiesForResync(MatcherContext context, Matcher matcher) {\n            if (matcher instanceof SequenceMatcher && context.getCurrentIndex() > context.getStartIndex() &&\n                    context.getPath().isPrefixOf(lastMatchPath)) {\n                return true;\n            }\n            return context.getParent() == null; // always resync on the root if there is nothing else\n        }\n\n        private boolean prepareErrorLocation(MatcherContext context) {\n            switch (context.getCurrentChar()) {\n                case DEL_ERROR:\n                    return willMatchDelError(context);\n                case INS_ERROR:\n                    return willMatchInsError(context);\n            }\n            return true;\n        }\n\n        private boolean willMatchDelError(MatcherContext context) {\n            int preSkipIndex = context.getCurrentIndex();\n            context.advanceIndex(2); // skip del marker char and illegal char\n            if (!runTestMatch(context)) {\n                // if we wouldn't succeed with the match do not swallow the ERROR char & Co\n                context.setCurrentIndex(preSkipIndex);\n                return false;\n            }\n            context.setStartIndex(context.getCurrentIndex());\n            if (context.getParent() != null) context.getParent().markError();\n            return true;\n        }\n\n        private boolean willMatchInsError(MatcherContext context) {\n            int preSkipIndex = context.getCurrentIndex();\n            context.advanceIndex(1); // skip ins marker char\n            if (!runTestMatch(context)) {\n                // if we wouldn't succeed with the match do not swallow the ERROR char\n                context.setCurrentIndex(preSkipIndex);\n                return false;\n            }\n            context.setStartIndex(context.getCurrentIndex());\n            context.markError();\n            return true;\n        }\n\n        private boolean runTestMatch(MatcherContext context) {\n            TestMatcher testMatcher = new TestMatcher(context.getMatcher());\n            MatcherContext testContext = testMatcher.getSubContext(context);\n            return prepareErrorLocation(testContext) && testContext.runMatcher();\n        }\n\n        private boolean resynchronize(MatcherContext context, char fringeChar) {\n            context.markError();\n\n            // create a node for the failed Sequence, taking ownership of all sub nodes created so far\n            context.createNode();\n\n            // by resyncing we flip an unmatched sequence to a matched one, so in order to keep the value stack\n            // consistent we go into a special \"error action mode\" and execute the minimal set of actions underneath\n            // the resync sequence\n            rerunAndExecuteErrorActions(context);\n\n            // skip over all characters that are not legal followers of the failed Sequence\n            context.advanceIndex(1); // gobble RESYNC or RESYNC_START marker\n            \n            switch (fringeChar) {\n                case RESYNC:\n                    // this RESYNC error is the last error, we establish the length of the bad sequence and\n                    // change this RESYNC marker to a RESYNC_START / RESYNC_END block\n                    buffer.replaceInsertedChar(currentError.getStartIndex() - 1, RESYNC_START);\n                    if (context.getCurrentChar() != Chars.EOI) {\n                        List<Matcher> followMatchers = new FollowMatchersVisitor().getFollowMatchers(context);\n                        int endIndex = gobbleIllegalCharacters(context, followMatchers);\n                        currentError.setEndIndex(endIndex);\n                        buffer.insertChar(endIndex, RESYNC_END);\n                    }\n                    break;\n                \n                case RESYNC_START:\n                    if (context.getCurrentChar() != Chars.EOI) {\n                        // a RESYNC error we have already recovered from before\n                        // simply skip all characters up to the RESYNC_END\n                        while (context.getCurrentChar() != RESYNC_END) {\n                            context.advanceIndex(1);\n                            checkState(context.getCurrentChar() != EOI); // we MUST find a RESYNC_END before EOI\n                        }\n                    }\n                    break;\n                \n                default:\n                    throw new IllegalStateException();\n            }\n            \n            context.advanceIndex(1); // also gobble the RESYNC_END itself\n            fringeIndex = context.getCurrentIndex();\n            \n            return true;\n        }\n\n        @SuppressWarnings({\"ConstantConditions\"})\n        private void rerunAndExecuteErrorActions(MatcherContext context) {\n            // the context is for the resync action, which at this point has FAILED, i.e. ALL its sub actions haven't\n            // had a chance to change the value stack, even the ones having run before the actual parse error matcher\n            // so we need to rerun all sub matchers of the resync sequence up to the point of the parse error\n            // and then run the minimal set of action in \"error action mode\"\n\n            int savedCurrentIndex = context.getCurrentIndex();\n            context.setCurrentIndex(context.getStartIndex()); // restart matching the resync sequence\n\n            Matcher lastGoodSub = lastMatchPath == null ? null :\n                    lastMatchPath.getElementAtLevel(context.getLevel() + 1).matcher;\n            boolean errorMode = false;\n\n            for (Matcher sub : context.getMatcher().getChildren()) {\n                if (errorMode) {\n                    List<ActionMatcher> errorActions = sub.accept(new CollectResyncActionsVisitor());\n                    checkState(errorActions != null);\n                    for (ActionMatcher action : errorActions) {\n                        action.getSubContext(context).runMatcher();\n                    }\n                    continue;\n                }\n                // as long as we are before the error matcher we simply execute normally\n                sub.getSubContext(context).runMatcher();\n                \n                if (sub == lastGoodSub) {\n                    // run an empty matcher which all error actions will see as the immediately preceding rule\n                    context.getSubContext(new EmptyMatcher()).runMatcher();\n                    errorMode = true;\n                }\n            }\n            context.setCurrentIndex(savedCurrentIndex);\n        }\n\n        private int gobbleIllegalCharacters(MatcherContext context, List<Matcher> followMatchers) {\n            while_loop:\n            while (true) {\n                char currentChar = context.getCurrentChar();\n                if (currentChar == EOI) break;\n                for (Matcher followMatcher : followMatchers) {\n                    if (followMatcher.accept(new IsStarterCharVisitor(currentChar))) {\n                        break while_loop;\n                    }\n                }\n                context.advanceIndex(1);\n            }\n            return context.getCurrentIndex();\n        }\n    }\n\n    /**\n     * This MatcherVisitor collects the minimal set of actions that has to run underneath a resyncronization sequence\n     * in order to maintain a consistent Value Stack state.\n     */\n    private static class CollectResyncActionsVisitor extends DefaultMatcherVisitor<List<ActionMatcher>> {\n        private ImmutableLinkedList<SequenceMatcher> path = ImmutableLinkedList.nil();\n\n        @Override\n        public List<ActionMatcher> visit(ActionMatcher matcher) {\n            return ImmutableList.of(matcher);\n        }\n \n        @Override\n        public List<ActionMatcher> visit(FirstOfMatcher matcher) {\n            for (Matcher child : matcher.getChildren()) {\n                List<ActionMatcher> actions = child.accept(this);\n                if (actions != null) return actions;\n            }\n            return null;\n        }\n \n        @Override\n        public List<ActionMatcher> visit(OneOrMoreMatcher matcher) {\n            return matcher.subMatcher.accept(this);\n        }\n \n        @Override\n        public List<ActionMatcher> visit(SequenceMatcher matcher) {\n            if (path.contains(matcher)) {\n                return null;\n            }\n \n            ImmutableLinkedList<SequenceMatcher> previousPath = path;\n            path = path.prepend(matcher);\n            \n            List<ActionMatcher> actions = new ArrayList<ActionMatcher>(); \n            for (Matcher sub : matcher.getChildren()) {\n                List<ActionMatcher> subActions = sub.accept(this);\n                if (subActions == null) return null;\n                actions.addAll(subActions);\n            }\n            \n            path = previousPath; \n            return actions;\n        }\n \n        @Override\n        public List<ActionMatcher> defaultValue(AbstractMatcher matcher) {\n            return ImmutableList.of();\n        }\n    }\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009-2010 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.parserunners;\n\nimport org.parboiled.MatchHandler;\nimport org.parboiled.MatcherContext;\nimport org.parboiled.Rule;\nimport org.parboiled.buffers.InputBuffer;\nimport org.parboiled.buffers.MutableInputBuffer;\nimport org.parboiled.common.Preconditions;\nimport org.parboiled.errors.InvalidInputError;\nimport org.parboiled.matchers.*;\nimport org.parboiled.matchervisitors.*;\nimport org.parboiled.support.Chars;\nimport org.parboiled.support.MatcherPath;\nimport org.parboiled.support.ParsingResult;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport static org.parboiled.common.Preconditions.checkArgNotNull;\nimport static org.parboiled.common.Preconditions.checkState;\nimport static org.parboiled.support.Chars.*;\n\n/**\n * A {@link org.parboiled.parserunners.ParseRunner} implementation that is able to recover from {@link org.parboiled.errors.InvalidInputError}s in the input and therefore\n * report more than just the first {@link org.parboiled.errors.InvalidInputError} if the input does not conform to the rule grammar.\n * Error recovery is done by attempting to either delete an error character, insert a potentially missing character\n * or do both at once (which is equivalent to a one char replace) whereby this implementation is able to determine\n * itself which of these options is the best strategy.\n * If the parse error cannot be overcome by either deleting, inserting or replacing one character a resynchronization\n * rule is determined and the parsing process resynchronized, so that parsing can still continue.\n * In this way the RecoveringParseRunner is able to completely parse all input texts (This ParseRunner never returns\n * an unmatched {@link org.parboiled.support.ParsingResult}).\n * If the input is error free this {@link org.parboiled.parserunners.ParseRunner} implementation will only perform one parsing run, with the same\n * speed as the {@link org.parboiled.parserunners.BasicParseRunner}. However, if there are {@link org.parboiled.errors.InvalidInputError}s in the input potentially\n * many more runs are performed to properly report all errors and test the various recovery strategies.\n */\npublic class RecoveringParseRunner<V> extends AbstractParseRunner<V> {\n    private int errorIndex;\n    private InvalidInputError currentError;\n    private MutableInputBuffer buffer;\n    private ParsingResult<V> lastParsingResult;\n    private Matcher rootMatcherWithoutPTB; // the root matcher with parse tree building disabled\n\n    /**\n     * Create a new RecoveringParseRunner instance with the given rule and input text and returns the result of\n     * its {@link #run(String)} method invocation.\n     *\n     * @param rule  the parser rule to run\n     * @param input the input text to run on\n     * @return the ParsingResult for the parsing run\n     * @deprecated As of 0.11.0 you should use the \"regular\" constructor and one of the \"run\" methods rather than\n     *             this static method. This method will be removed in one of the coming releases.\n     */\n    @Deprecated\n    public static <V> ParsingResult<V> run(Rule rule, String input) {\n        checkArgNotNull(rule, \"rule\");\n        checkArgNotNull(input, \"input\");\n        return new RecoveringParseRunner<V>(rule).run(input);\n    }\n\n    /**\n     * Creates a new RecoveringParseRunner instance for the given rule.\n     *\n     * @param rule the parser rule\n     */\n    public RecoveringParseRunner(Rule rule) {\n        super(rule);\n    }\n\n    public ParsingResult<V> run(InputBuffer inputBuffer) {\n        checkArgNotNull(inputBuffer, \"inputBuffer\");\n        resetValueStack();\n\n        // first, run a basic match\n        ParseRunner<V> basicRunner = new BasicParseRunner<V>(getRootMatcher())\n                .withParseErrors(getParseErrors())\n                .withValueStack(getValueStack());\n        lastParsingResult = basicRunner.run(inputBuffer);\n        \n        if (!lastParsingResult.matched) {\n            // for better performance disable parse tree building during the recovery runs\n            rootMatcherWithoutPTB = (Matcher) getRootMatcher().suppressNode();\n\n            // locate first error\n            performLocatingRun(inputBuffer);\n            checkState(errorIndex >= 0); // we failed before so we must fail again\n\n            // in order to be able to apply fixes we need to wrap the input buffer with a mutability wrapper\n            buffer = new MutableInputBuffer(inputBuffer);\n\n            // report first error\n            performReportingRun();\n\n            // fix and report until done\n            while (!fixError(errorIndex)) {\n                performReportingRun();\n            }\n\n            // rerun once more with parse tree building enabled to create a parse tree for the fixed input\n            if (!getRootMatcher().isNodeSuppressed()) {\n                performFinalRun();\n                checkState(lastParsingResult.matched);\n            }\n        }\n        return lastParsingResult;\n    }\n\n    private boolean performLocatingRun(InputBuffer inputBuffer) {\n        resetValueStack();\n        ParseRunner<V> locatingRunner = new ErrorLocatingParseRunner<V>(rootMatcherWithoutPTB, getInnerHandler())\n                .withParseErrors(getParseErrors())\n                .withValueStack(getValueStack());\n        lastParsingResult = locatingRunner.run(inputBuffer);\n        errorIndex = lastParsingResult.matched ? -1 :\n                getParseErrors().remove(getParseErrors().size() - 1).getStartIndex();\n        return lastParsingResult.matched;\n    }\n    \n    private void performReportingRun() {\n        resetValueStack();\n        ParseRunner<V> reportingRunner = new ErrorReportingParseRunner<V>(rootMatcherWithoutPTB, errorIndex, getInnerHandler())\n                .withParseErrors(getParseErrors())\n                .withValueStack(getValueStack());\n        ParsingResult<V> result = reportingRunner.run(buffer);\n        Preconditions.checkState(!result.matched); // we failed before so we should really be failing again\n        currentError = (InvalidInputError) getParseErrors().get(getParseErrors().size() - 1);\n    }\n    \n    private void performFinalRun() {\n        resetValueStack();\n        Handler handler = new Handler();\n        MatcherContext<V> rootContext = createRootContext(buffer, handler, false);\n        boolean matched = handler.match(rootContext);\n        lastParsingResult = createParsingResult(matched, rootContext);\n    }\n\n    private MatchHandler getInnerHandler() {\n        return errorIndex >= 0 ? new Handler() : null;\n    }\n    \n    private boolean fixError(int fixIndex) {\n        if (tryFixBySingleCharDeletion(fixIndex)) return true;\n        int nextErrorAfterDeletion = errorIndex;\n\n        Character bestInsertionCharacter = findBestSingleCharInsertion(fixIndex);\n        if (bestInsertionCharacter == null) return true;\n        int nextErrorAfterBestInsertion = errorIndex;\n\n        Character bestReplacementCharacter = findBestSingleCharReplacement(fixIndex);\n        if (bestReplacementCharacter == null) return true;\n        int nextErrorAfterBestReplacement = errorIndex;\n\n        int nextErrorAfterBestSingleCharFix =\n                Math.max(Math.max(nextErrorAfterDeletion, nextErrorAfterBestInsertion), nextErrorAfterBestReplacement);\n        if (nextErrorAfterBestSingleCharFix > fixIndex) {\n            // we are able to overcome the error with a single char fix, so apply the best one found\n            if (nextErrorAfterBestSingleCharFix == nextErrorAfterDeletion) {\n                buffer.insertChar(fixIndex, DEL_ERROR);\n                errorIndex = nextErrorAfterDeletion + 1;\n                currentError.shiftIndexDeltaBy(1);\n            } else if (nextErrorAfterBestSingleCharFix == nextErrorAfterBestInsertion) {\n                // we need to insert the characters in reverse order, since we insert twice at the same location\n                buffer.insertChar(fixIndex, bestInsertionCharacter);\n                buffer.insertChar(fixIndex, INS_ERROR);\n                errorIndex = nextErrorAfterBestInsertion + 2;\n                currentError.shiftIndexDeltaBy(2);\n            } else {\n                // we need to insert the characters in reverse order, since we insert three times at the same location\n                buffer.insertChar(fixIndex + 1, bestReplacementCharacter);\n                buffer.insertChar(fixIndex + 1, INS_ERROR);\n                buffer.insertChar(fixIndex, DEL_ERROR);\n                errorIndex = nextErrorAfterBestReplacement + 5;\n                currentError.shiftIndexDeltaBy(1);\n            }\n        } else {\n            // we can't fix the error with a single char fix, so fall back to resynchronization\n            buffer.insertChar(fixIndex, RESYNC);\n            currentError.shiftIndexDeltaBy(1);\n            performLocatingRun(buffer); // find the next parse error\n        }\n        return errorIndex == -1;\n    }\n    \n    private boolean tryFixBySingleCharDeletion(int fixIndex) {\n        buffer.insertChar(fixIndex, DEL_ERROR);\n        boolean nowErrorFree = performLocatingRun(buffer);\n        if (nowErrorFree) {\n            currentError.shiftIndexDeltaBy(1); // compensate for the inserted DEL_ERROR char\n        } else {\n            buffer.undoCharInsertion(fixIndex);\n            errorIndex = Math.max(errorIndex - 1, 0);\n        }\n        return nowErrorFree;\n    }\n\n    @SuppressWarnings({\"ConstantConditions\"})\n    private Character findBestSingleCharInsertion(int fixIndex) {\n        GetStarterCharVisitor getStarterCharVisitor = new GetStarterCharVisitor();\n        int bestNextErrorIndex = -1;\n        Character bestChar = null;\n        for (MatcherPath failedMatcherPath : currentError.getFailedMatchers()) {\n            Character starterChar = failedMatcherPath.element.matcher.accept(getStarterCharVisitor);\n            checkState(starterChar != null); // we should only have single character matchers\n            if (starterChar == EOI) {\n                continue; // we should never conjure up an EOI character (that would be cheating :)\n            }\n            buffer.insertChar(fixIndex, starterChar);\n            buffer.insertChar(fixIndex, INS_ERROR);\n            if (performLocatingRun(buffer)) {\n                currentError.shiftIndexDeltaBy(2); // compensate for the inserted chars\n                return null; // success, exit immediately\n            }\n            buffer.undoCharInsertion(fixIndex);\n            buffer.undoCharInsertion(fixIndex);\n            errorIndex = Math.max(errorIndex - 2, 0);\n\n            if (bestNextErrorIndex < errorIndex) {\n                bestNextErrorIndex = errorIndex;\n                bestChar = starterChar;\n            }\n        }\n        errorIndex = bestNextErrorIndex;\n        return bestChar;\n    }\n\n    private Character findBestSingleCharReplacement(int fixIndex) {\n        buffer.insertChar(fixIndex, DEL_ERROR);\n        Character bestChar = findBestSingleCharInsertion(fixIndex + 2);\n        if (bestChar == null) { // success, we found a fix that renders the complete input error free\n            currentError.shiftIndexDeltaBy(-1); // delta from DEL_ERROR char insertion and index shift by insertion method\n        } else {\n            buffer.undoCharInsertion(fixIndex);\n            errorIndex = Math.max(errorIndex - 3, 0);\n        }\n        return bestChar;\n    }\n    \n    /**\n     * A {@link org.parboiled.MatchHandler} implementation that recognizes the special\n     * {@link org.parboiled.support.Chars#RESYNC} character to overcome {@link InvalidInputError}s at the respective\n     * error indices.\n     */\n    private class Handler implements MatchHandler {\n        private final IsSingleCharMatcherVisitor isSingleCharMatcherVisitor = new IsSingleCharMatcherVisitor();\n        private int fringeIndex;\n        private MatcherPath lastMatchPath;\n\n        public boolean match(MatcherContext<?> context) {\n            Matcher matcher = context.getMatcher();\n            if (matcher.accept(isSingleCharMatcherVisitor)) {\n                if (prepareErrorLocation(context) && matcher.match(context)) {\n                    if (fringeIndex < context.getCurrentIndex()) {\n                        fringeIndex = context.getCurrentIndex();\n                        lastMatchPath = context.getPath();\n                    }\n                    return true;\n                }\n                return false;\n            }\n\n            if (matcher.match(context)) {\n                return true;\n            }\n\n            // if we didn't match we might have to resynchronize, however we only resynchronize\n            // if we are at a RESYNC location and the matcher is a SequenceMatchers that has already\n            // matched at least one character and that is a parent of the last match\n            char fringeChar = context.getInputBuffer().charAt(fringeIndex);\n            return (fringeChar == RESYNC || fringeChar == RESYNC_START) &&\n                    qualifiesForResync(context, matcher) &&\n                    resynchronize(context, fringeChar);\n        }\n\n        @SuppressWarnings({\"SimplifiableIfStatement\"})\n        private boolean qualifiesForResync(MatcherContext context, Matcher matcher) {\n            if (matcher instanceof SequenceMatcher && context.getCurrentIndex() > context.getStartIndex() &&\n                    context.getPath().isPrefixOf(lastMatchPath)) {\n                return true;\n            }\n            return context.getParent() == null; // always resync on the root if there is nothing else\n        }\n\n        private boolean prepareErrorLocation(MatcherContext context) {\n            switch (context.getCurrentChar()) {\n                case DEL_ERROR:\n                    return willMatchDelError(context);\n                case INS_ERROR:\n                    return willMatchInsError(context);\n            }\n            return true;\n        }\n\n        private boolean willMatchDelError(MatcherContext context) {\n            int preSkipIndex = context.getCurrentIndex();\n            context.advanceIndex(2); // skip del marker char and illegal char\n            if (!runTestMatch(context)) {\n                // if we wouldn't succeed with the match do not swallow the ERROR char & Co\n                context.setCurrentIndex(preSkipIndex);\n                return false;\n            }\n            context.setStartIndex(context.getCurrentIndex());\n            if (context.getParent() != null) context.getParent().markError();\n            return true;\n        }\n\n        private boolean willMatchInsError(MatcherContext context) {\n            int preSkipIndex = context.getCurrentIndex();\n            context.advanceIndex(1); // skip ins marker char\n            if (!runTestMatch(context)) {\n                // if we wouldn't succeed with the match do not swallow the ERROR char\n                context.setCurrentIndex(preSkipIndex);\n                return false;\n            }\n            context.setStartIndex(context.getCurrentIndex());\n            context.markError();\n            return true;\n        }\n\n        private boolean runTestMatch(MatcherContext context) {\n            TestMatcher testMatcher = new TestMatcher(context.getMatcher());\n            MatcherContext testContext = testMatcher.getSubContext(context);\n            return prepareErrorLocation(testContext) && testContext.runMatcher();\n        }\n\n        private boolean resynchronize(MatcherContext context, char fringeChar) {\n            context.markError();\n\n            // create a node for the failed Sequence, taking ownership of all sub nodes created so far\n            context.createNode();\n\n            // by resyncing we flip an unmatched sequence to a matched one, so in order to keep the value stack\n            // consistent we go into a special \"error action mode\" and execute the minimal set of actions underneath\n            // the resync sequence\n            rerunAndExecuteErrorActions(context);\n\n            // skip over all characters that are not legal followers of the failed Sequence\n            context.advanceIndex(1); // gobble RESYNC or RESYNC_START marker\n            \n            switch (fringeChar) {\n                case RESYNC:\n                    // this RESYNC error is the last error, we establish the length of the bad sequence and\n                    // change this RESYNC marker to a RESYNC_START / RESYNC_END block\n                    buffer.replaceInsertedChar(currentError.getStartIndex() - 1, RESYNC_START);\n                    if (context.getCurrentChar() != Chars.EOI) {\n                        List<Matcher> followMatchers = new FollowMatchersVisitor().getFollowMatchers(context);\n                        int endIndex = gobbleIllegalCharacters(context, followMatchers);\n                        currentError.setEndIndex(endIndex);\n                        buffer.insertChar(endIndex, RESYNC_END);\n                    }\n                    break;\n                \n                case RESYNC_START:\n                    if (context.getCurrentChar() != Chars.EOI) {\n                        // a RESYNC error we have already recovered from before\n                        // simply skip all characters up to the RESYNC_END\n                        while (context.getCurrentChar() != RESYNC_END) {\n                            context.advanceIndex(1);\n                            checkState(context.getCurrentChar() != EOI); // we MUST find a RESYNC_END before EOI\n                        }\n                    }\n                    break;\n                \n                default:\n                    throw new IllegalStateException();\n            }\n            \n            context.advanceIndex(1); // also gobble the RESYNC_END itself\n            fringeIndex = context.getCurrentIndex();\n            \n            return true;\n        }\n\n        private void rerunAndExecuteErrorActions(MatcherContext context) {\n            // the context is for the resync action, which at this point has FAILED, i.e. ALL its sub actions haven't\n            // had a chance to change the value stack, even the ones having run before the actual parse error matcher\n            // so we need to rerun all sub matchers of the resync sequence up to the point of the parse error\n            // and then run the minimal set of action in \"error action mode\"\n\n            int savedCurrentIndex = context.getCurrentIndex();\n            context.setCurrentIndex(context.getStartIndex()); // restart matching the resync sequence\n\n            Matcher lastGoodSub = lastMatchPath == null ? null :\n                    lastMatchPath.getElementAtLevel(context.getLevel() + 1).matcher;\n            boolean errorMode = false;\n\n            for (Matcher sub : context.getMatcher().getChildren()) {\n                if (errorMode) {\n                    for (ActionMatcher action : sub.accept(new CollectResyncActionsVisitor())) {\n                        action.getSubContext(context).runMatcher();\n                    }\n                    continue;\n                }\n                // as long as we are before the error matcher we simply execute normally\n                sub.getSubContext(context).runMatcher();\n                \n                if (sub == lastGoodSub) {\n                    // run an empty matcher which all error actions will see as the immediately preceding rule\n                    context.getSubContext(new EmptyMatcher()).runMatcher();\n                    errorMode = true;\n                }\n            }\n            context.setCurrentIndex(savedCurrentIndex);\n        }\n\n        private int gobbleIllegalCharacters(MatcherContext context, List<Matcher> followMatchers) {\n            while_loop:\n            while (true) {\n                char currentChar = context.getCurrentChar();\n                if (currentChar == EOI) break;\n                for (Matcher followMatcher : followMatchers) {\n                    if (followMatcher.accept(new IsStarterCharVisitor(currentChar))) {\n                        break while_loop;\n                    }\n                }\n                context.advanceIndex(1);\n            }\n            return context.getCurrentIndex();\n        }\n    }\n\n    /**\n     * This MatcherVisitor collects the minimal set of actions that has to run underneath a resyncronization sequence\n     * in order to maintain a consistent Value Stack state.\n     */\n    private static class CollectResyncActionsVisitor extends DefaultMatcherVisitor<List<ActionMatcher>> {\n        private final Set<Matcher> visited = new HashSet<Matcher>();\n        private final List<ActionMatcher> actions = new ArrayList<ActionMatcher>();\n\n        @Override\n        public List<ActionMatcher> visit(ActionMatcher matcher) {\n            actions.add(matcher);\n            return actions;\n        }\n\n        @Override\n        public List<ActionMatcher> visit(FirstOfMatcher matcher) {\n            // go through all subs in reverse order (because the simplest fall-back cases are often in last position)\n            // and try all of them until we hit a path that does not lead to a recursion\n            List<Matcher> children = matcher.getChildren();\n            for (int i = children.size() - 1; i >= 0; i--) {\n                if (children.get(i).accept(this) != null) return actions;\n            }\n            // a FirstOf where all subs lead to recursions,\n            // so go up one level and try another branch of the next FirstOf one level up\n            return null;\n        }\n\n        @Override\n        public List<ActionMatcher> visit(OneOrMoreMatcher matcher) {\n            return matcher.subMatcher.accept(this);\n        }\n\n        @Override\n        public List<ActionMatcher> visit(SequenceMatcher matcher) {\n            if (visited.contains(matcher)) {\n                // we hit a recursion, so signal to the next FirstOf parent that we need to take another path in order\n                // to collect all actions\n                return null;\n            }\n\n            visited.add(matcher);\n            for (Matcher sub : matcher.getChildren()) {\n                sub.accept(this);\n            }\n            return actions;\n        }\n\n        @Override\n        public List<ActionMatcher> defaultValue(AbstractMatcher matcher) {\n            return actions;\n        }\n    }\n}\n","lineNo":457}
{"Refactored Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.support;\n\nimport org.parboiled.Node;\nimport org.parboiled.buffers.InputBuffer;\nimport org.parboiled.common.Predicate;\nimport org.parboiled.common.Predicates;\nimport org.parboiled.common.StringUtils;\n\nimport java.util.Collection;\nimport java.util.List;\n\nimport static org.parboiled.common.Preconditions.checkArgNotNull;\nimport static org.parboiled.trees.GraphUtils.hasChildren;\nimport static org.parboiled.trees.GraphUtils.printTree;\n\n/**\n * General utility methods for operating on parse trees.\n */\npublic final class ParseTreeUtils {\n\n    private ParseTreeUtils() {}\n\n    /**\n     * <p>Returns the parse tree node underneath the given parent that matches the given path.<\/p>\n     * <p>The path is a '/' separated list of node label prefixes describing the ancestor chain of the node to look for\n     * relative to the given parent node. If there are several nodes that match the given path the method\n     * returns the first one unless the respective path segments has the special prefix \"last:\". In this case the\n     * last matching node is returned.\n     * <p><b>Example:<\/b> \"per/last:so/fix\" will return the first node, whose label starts with \"fix\" under the last\n     * node, whose label starts with \"so\" under the first node, whose label starts with \"per\".<\/p>\n     * If parent is null or no node is found the method returns null.\n     *\n     * @param parent the parent Node\n     * @param path   the path to the Node being searched for\n     * @return the Node if found or null if not found\n     */\n    public static <V> Node<V> findNodeByPath(Node<V> parent, String path) {\n        checkArgNotNull(path, \"path\");\n        return parent != null && hasChildren(parent) ? findNodeByPath(parent.getChildren(), path) : null;\n    }\n\n    /**\n     * Returns the node underneath the given parents that matches the given path.\n     * See {@link #findNodeByPath(org.parboiled.Node, String)} )} for a description of the path argument.\n     * If the given collections of parents is null or empty or no node is found the method returns null.\n     *\n     * @param parents the parent Nodes to look through\n     * @param path    the path to the Node being searched for\n     * @return the Node if found or null if not found\n     */\n    public static <V> Node<V> findNodeByPath(List<Node<V>> parents, String path) {\n        checkArgNotNull(path, \"path\");\n        if (parents != null && !parents.isEmpty()) {\n            int separatorIndex = path.indexOf('/');\n            String prefix = separatorIndex != -1 ? path.substring(0, separatorIndex) : path;\n            int start = 0, step = 1;\n            if (prefix.startsWith(\"last:\")) {\n                prefix = prefix.substring(5);\n                start = parents.size() - 1;\n                step = -1;\n            }\n            for (int i = start; 0 <= i && i < parents.size(); i += step) {\n                Node<V> child = parents.get(i);\n                if (StringUtils.startsWith(child.getLabel(), prefix)) {\n                    return separatorIndex == -1 ? child : findNodeByPath(child, path.substring(separatorIndex + 1));\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Collects all nodes underneath the given parent that match the given path.\n     * The path is a '/' separated list of node label prefixes describing the ancestor chain of the node to look for\n     * relative to the given parent node.\n     *\n     * @param parent     the parent Node\n     * @param path       the path to the Nodes being searched for\n     * @param collection the collection to collect the found Nodes into\n     * @return the same collection instance passed as a parameter\n     */\n    public static <V, C extends Collection<Node<V>>> C collectNodesByPath(Node<V> parent, String path, C collection) {\n        checkArgNotNull(path, \"path\");\n        checkArgNotNull(collection, \"collection\");\n        return parent != null && hasChildren(parent) ?\n                collectNodesByPath(parent.getChildren(), path, collection) : collection;\n    }\n\n    /**\n     * Collects all nodes underneath the given parents that match the given path.\n     * The path is a '/' separated list of node label prefixes describing the ancestor chain of the node to look for\n     * relative to the given parent nodes.\n     *\n     * @param parents    the parent Nodes to look through\n     * @param path       the path to the Nodes being searched for\n     * @param collection the collection to collect the found Nodes into\n     * @return the same collection instance passed as a parameter\n     */\n    public static <V, C extends Collection<Node<V>>> C collectNodesByPath(List<Node<V>> parents, String path,\n                                                                          C collection) {\n        checkArgNotNull(path, \"path\");\n        checkArgNotNull(collection, \"collection\");\n        if (parents != null && !parents.isEmpty()) {\n            int separatorIndex = path.indexOf('/');\n            String prefix = separatorIndex != -1 ? path.substring(0, separatorIndex) : path;\n            for (Node<V> child : parents) {\n                if (StringUtils.startsWith(child.getLabel(), prefix)) {\n                    if (separatorIndex == -1) {\n                        collection.add(child);\n                    } else {\n                        collectNodesByPath(child, path.substring(separatorIndex + 1), collection);\n                    }\n                }\n            }\n        }\n        return collection;\n    }\n\n    /**\n     * Returns the first node underneath the given parent for which the given predicate evaluates to true.\n     * If parent is null or no node is found the method returns null.\n     *\n     * @param parent    the parent Node\n     * @param predicate the predicate\n     * @return the Node if found or null if not found\n     */\n    public static <V> Node<V> findNode(Node<V> parent, Predicate<Node<V>> predicate) {\n        checkArgNotNull(predicate, \"predicate\");\n        if (parent != null) {\n            if (predicate.apply(parent)) return parent;\n            if (hasChildren(parent)) {\n                Node<V> found = findNode(parent.getChildren(), predicate);\n                if (found != null) return found;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Returns the first node underneath the given parents for which the given predicate evaluates to true.\n     * If parents is null or empty or no node is found the method returns null.\n     *\n     * @param parents   the parent Nodes to look through\n     * @param predicate the predicate\n     * @return the Node if found or null if not found\n     */\n    public static <V> Node<V> findNode(List<Node<V>> parents, Predicate<Node<V>> predicate) {\n        checkArgNotNull(predicate, \"predicate\");\n        if (parents != null && !parents.isEmpty()) {\n            for (Node<V> child : parents) {\n                Node<V> found = findNode(child, predicate);\n                if (found != null) return found;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Returns the first node underneath the given parent for which matches the given label prefix.\n     * If parents is null or empty or no node is found the method returns null.\n     *\n     * @param parent      the parent node\n     * @param labelPrefix the label prefix to look for\n     * @return the Node if found or null if not found\n     */\n    public static <V> Node<V> findNodeByLabel(Node<V> parent, String labelPrefix) {\n        return findNode(parent, new LabelPrefixPredicate<V>(labelPrefix));\n    }\n\n    /**\n     * Returns the first node underneath the given parents which matches the given label prefix.\n     * If parents is null or empty or no node is found the method returns null.\n     *\n     * @param parents     the parent Nodes to look through\n     * @param labelPrefix the label prefix to look for\n     * @return the Node if found or null if not found\n     */\n    public static <V> Node<V> findNodeByLabel(List<Node<V>> parents, String labelPrefix) {\n        return findNode(parents, new LabelPrefixPredicate<V>(labelPrefix));\n    }\n\n    /**\n     * Returns the last node underneath the given parent for which the given predicate evaluates to true.\n     * If parent is null or no node is found the method returns null.\n     *\n     * @param parent    the parent Node\n     * @param predicate the predicate\n     * @return the Node if found or null if not found\n     */\n    public static <V> Node<V> findLastNode(Node<V> parent, Predicate<Node<V>> predicate) {\n        checkArgNotNull(predicate, \"predicate\");\n        if (parent != null) {\n            if (predicate.apply(parent)) return parent;\n            if (hasChildren(parent)) {\n                Node<V> found = findLastNode(parent.getChildren(), predicate);\n                if (found != null) return found;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Returns the last node underneath the given parents for which the given predicate evaluates to true.\n     * If parents is null or empty or no node is found the method returns null.\n     *\n     * @param parents   the parent Nodes to look through\n     * @param predicate the predicate\n     * @return the Node if found or null if not found\n     */\n    public static <V> Node<V> findLastNode(List<Node<V>> parents, Predicate<Node<V>> predicate) {\n        checkArgNotNull(predicate, \"predicate\");\n        if (parents != null && !parents.isEmpty()) {\n            int parentsSize = parents.size();\n            for (int i = parentsSize - 1; i >= 0; i--) {\n                Node<V> found = findLastNode(parents.get(i), predicate);\n                if (found != null) return found;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Collects all nodes underneath the given parent for which the given predicate evaluates to true.\n     *\n     * @param parent     the parent Node\n     * @param predicate  the predicate\n     * @param collection the collection to collect the found Nodes into\n     * @return the same collection instance passed as a parameter\n     */\n    public static <V, C extends Collection<Node<V>>> C collectNodes(Node<V> parent,\n                                                                    Predicate<Node<V>> predicate,\n                                                                    C collection) {\n        checkArgNotNull(predicate, \"predicate\");\n        checkArgNotNull(collection, \"collection\");\n        return parent != null && hasChildren(parent) ?\n                collectNodes(parent.getChildren(), predicate, collection) : collection;\n    }\n\n    /**\n     * Returns the input text matched by the given node, with error correction.\n     *\n     * @param node        the node\n     * @param inputBuffer the underlying inputBuffer\n     * @return null if node is null otherwise a string with the matched input text (which can be empty)\n     */\n    public static String getNodeText(Node<?> node, InputBuffer inputBuffer) {\n        checkArgNotNull(node, \"node\");\n        checkArgNotNull(inputBuffer, \"inputBuffer\");\n        if (node.hasError()) {\n            // if the node has a parse error we cannot simply cut a string out of the underlying input buffer, since we\n            // would also include illegal characters, so we need to build it constructively\n            StringBuilder sb = new StringBuilder();\n            for (int i = node.getStartIndex(); i < node.getEndIndex(); i++) {\n                char c = inputBuffer.charAt(i);\n                switch (c) {\n                    case Chars.DEL_ERROR:\n                        i++;\n                        break;\n                    case Chars.INS_ERROR:\n                    case Chars.EOI:\n                        break;\n                    case Chars.RESYNC_START:\n                        do {\n                            i++;\n                            c = inputBuffer.charAt(i); \n                        } while (c != Chars.RESYNC_END && c != Chars.EOI);\n                        break;\n                    case Chars.RESYNC_END:\n                    case Chars.RESYNC:\n                        // we should only see proper RESYNC_START / RESYNC_END blocks\n                        throw new IllegalStateException();\n                    default:\n                        sb.append(c);\n                }\n            }\n            return sb.toString();\n        }        \n        return inputBuffer.extract(node.getStartIndex(), node.getEndIndex());\n    }\n\n    /**\n     * Collects all nodes underneath the given parents for which the given predicate evaluates to true.\n     *\n     * @param parents    the parent Nodes to look through\n     * @param predicate  the predicate\n     * @param collection the collection to collect the found Nodes into\n     * @return the same collection instance passed as a parameter\n     */\n    public static <V, C extends Collection<Node<V>>> C collectNodes(List<Node<V>> parents,\n                                                                    Predicate<Node<V>> predicate,\n                                                                    C collection) {\n        checkArgNotNull(predicate, \"predicate\");\n        checkArgNotNull(collection, \"collection\");\n        if (parents != null && !parents.isEmpty()) {\n            for (Node<V> child : parents) {\n                if (predicate.apply(child)) {\n                    collection.add(child);\n                }\n                collectNodes(child, predicate, collection);\n            }\n        }\n        return collection;\n    }\n\n    /**\n     * Creates a readable string represenation of the parse tree in the given {@link ParsingResult} object.\n     *\n     * @param parsingResult the parsing result containing the parse tree\n     * @return a new String\n     */\n    public static <V> String printNodeTree(ParsingResult<V> parsingResult) {\n        checkArgNotNull(parsingResult, \"parsingResult\");\n        return printNodeTree(parsingResult, Predicates.<Node<V>>alwaysTrue(), Predicates.<Node<V>>alwaysTrue());\n    }\n\n    /**\n     * Creates a readable string represenation of the parse tree in thee given {@link ParsingResult} object.\n     * The given filter predicate determines whether a particular node (incl. its subtree) is printed or not.\n     *\n     * @param parsingResult the parsing result containing the parse tree\n     * @param nodeFilter    the predicate selecting the nodes to print\n     * @param subTreeFilter the predicate determining whether to descend into a given nodes subtree or not\n     * @return a new String\n     */\n    public static <V> String printNodeTree(ParsingResult<V> parsingResult, Predicate<Node<V>> nodeFilter,\n                                           Predicate<Node<V>> subTreeFilter) {\n        checkArgNotNull(parsingResult, \"parsingResult\");\n        checkArgNotNull(nodeFilter, \"nodeFilter\");\n        checkArgNotNull(subTreeFilter, \"subTreeFilter\");\n        return printTree(parsingResult.parseTreeRoot, new NodeFormatter<V>(parsingResult.inputBuffer), nodeFilter,\n                subTreeFilter);\n    }\n\n}\n\n","Smelly Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.support;\n\nimport org.parboiled.Node;\nimport org.parboiled.buffers.InputBuffer;\nimport org.parboiled.common.Predicate;\nimport org.parboiled.common.Predicates;\nimport org.parboiled.common.StringUtils;\n\nimport java.util.Collection;\nimport java.util.List;\n\nimport static org.parboiled.common.Preconditions.checkArgNotNull;\nimport static org.parboiled.trees.GraphUtils.hasChildren;\nimport static org.parboiled.trees.GraphUtils.printTree;\n\n/**\n * General utility methods for operating on parse trees.\n */\npublic final class ParseTreeUtils {\n\n    private ParseTreeUtils() {}\n\n    /**\n     * <p>Returns the parse tree node underneath the given parent that matches the given path.<\/p>\n     * <p>The path is a '/' separated list of node label prefixes describing the ancestor chain of the node to look for\n     * relative to the given parent node. If there are several nodes that match the given path the method\n     * returns the first one unless the respective path segments has the special prefix \"last:\". In this case the\n     * last matching node is returned.\n     * <p><b>Example:<\/b> \"per/last:so/fix\" will return the first node, whose label starts with \"fix\" under the last\n     * node, whose label starts with \"so\" under the first node, whose label starts with \"per\".<\/p>\n     * If parent is null or no node is found the method returns null.\n     *\n     * @param parent the parent Node\n     * @param path   the path to the Node being searched for\n     * @return the Node if found or null if not found\n     */\n    public static <V> Node<V> findNodeByPath(Node<V> parent, String path) {\n        checkArgNotNull(path, \"path\");\n        return parent != null && hasChildren(parent) ? findNodeByPath(parent.getChildren(), path) : null;\n    }\n\n    /**\n     * Returns the node underneath the given parents that matches the given path.\n     * See {@link #findNodeByPath(org.parboiled.Node, String)} )} for a description of the path argument.\n     * If the given collections of parents is null or empty or no node is found the method returns null.\n     *\n     * @param parents the parent Nodes to look through\n     * @param path    the path to the Node being searched for\n     * @return the Node if found or null if not found\n     */\n    public static <V> Node<V> findNodeByPath(List<Node<V>> parents, String path) {\n        checkArgNotNull(path, \"path\");\n        if (parents != null && !parents.isEmpty()) {\n            int separatorIndex = path.indexOf('/');\n            String prefix = separatorIndex != -1 ? path.substring(0, separatorIndex) : path;\n            int start = 0, step = 1;\n            if (prefix.startsWith(\"last:\")) {\n                prefix = prefix.substring(5);\n                start = parents.size() - 1;\n                step = -1;\n            }\n            for (int i = start; 0 <= i && i < parents.size(); i += step) {\n                Node<V> child = parents.get(i);\n                if (StringUtils.startsWith(child.getLabel(), prefix)) {\n                    return separatorIndex == -1 ? child : findNodeByPath(child, path.substring(separatorIndex + 1));\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Collects all nodes underneath the given parent that match the given path.\n     * The path is a '/' separated list of node label prefixes describing the ancestor chain of the node to look for\n     * relative to the given parent node.\n     *\n     * @param parent     the parent Node\n     * @param path       the path to the Nodes being searched for\n     * @param collection the collection to collect the found Nodes into\n     * @return the same collection instance passed as a parameter\n     */\n    public static <V, C extends Collection<Node<V>>> C collectNodesByPath(Node<V> parent, String path, C collection) {\n        checkArgNotNull(path, \"path\");\n        checkArgNotNull(collection, \"collection\");\n        return parent != null && hasChildren(parent) ?\n                collectNodesByPath(parent.getChildren(), path, collection) : collection;\n    }\n\n    /**\n     * Collects all nodes underneath the given parents that match the given path.\n     * The path is a '/' separated list of node label prefixes describing the ancestor chain of the node to look for\n     * relative to the given parent nodes.\n     *\n     * @param parents    the parent Nodes to look through\n     * @param path       the path to the Nodes being searched for\n     * @param collection the collection to collect the found Nodes into\n     * @return the same collection instance passed as a parameter\n     */\n    public static <V, C extends Collection<Node<V>>> C collectNodesByPath(List<Node<V>> parents, String path,\n                                                                          C collection) {\n        checkArgNotNull(path, \"path\");\n        checkArgNotNull(collection, \"collection\");\n        if (parents != null && !parents.isEmpty()) {\n            int separatorIndex = path.indexOf('/');\n            String prefix = separatorIndex != -1 ? path.substring(0, separatorIndex) : path;\n            for (Node<V> child : parents) {\n                if (StringUtils.startsWith(child.getLabel(), prefix)) {\n                    if (separatorIndex == -1) {\n                        collection.add(child);\n                    } else {\n                        collectNodesByPath(child, path.substring(separatorIndex + 1), collection);\n                    }\n                }\n            }\n        }\n        return collection;\n    }\n\n    /**\n     * Returns the first node underneath the given parent for which the given predicate evaluates to true.\n     * If parent is null or no node is found the method returns null.\n     *\n     * @param parent    the parent Node\n     * @param predicate the predicate\n     * @return the Node if found or null if not found\n     */\n    public static <V> Node<V> findNode(Node<V> parent, Predicate<Node<V>> predicate) {\n        checkArgNotNull(predicate, \"predicate\");\n        if (parent != null) {\n            if (predicate.apply(parent)) return parent;\n            if (hasChildren(parent)) {\n                Node<V> found = findNode(parent.getChildren(), predicate);\n                if (found != null) return found;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Returns the first node underneath the given parents for which the given predicate evaluates to true.\n     * If parents is null or empty or no node is found the method returns null.\n     *\n     * @param parents   the parent Nodes to look through\n     * @param predicate the predicate\n     * @return the Node if found or null if not found\n     */\n    public static <V> Node<V> findNode(List<Node<V>> parents, Predicate<Node<V>> predicate) {\n        checkArgNotNull(predicate, \"predicate\");\n        if (parents != null && !parents.isEmpty()) {\n            for (Node<V> child : parents) {\n                Node<V> found = findNode(child, predicate);\n                if (found != null) return found;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Returns the first node underneath the given parent for which matches the given label prefix.\n     * If parents is null or empty or no node is found the method returns null.\n     *\n     * @param parent      the parent node\n     * @param labelPrefix the label prefix to look for\n     * @return the Node if found or null if not found\n     */\n    public static <V> Node<V> findNodeByLabel(Node<V> parent, String labelPrefix) {\n        return findNode(parent, new LabelPrefixPredicate<V>(labelPrefix));\n    }\n\n    /**\n     * Returns the first node underneath the given parents which matches the given label prefix.\n     * If parents is null or empty or no node is found the method returns null.\n     *\n     * @param parents     the parent Nodes to look through\n     * @param labelPrefix the label prefix to look for\n     * @return the Node if found or null if not found\n     */\n    public static <V> Node<V> findNodeByLabel(List<Node<V>> parents, String labelPrefix) {\n        return findNode(parents, new LabelPrefixPredicate<V>(labelPrefix));\n    }\n\n    /**\n     * Returns the last node underneath the given parent for which the given predicate evaluates to true.\n     * If parent is null or no node is found the method returns null.\n     *\n     * @param parent    the parent Node\n     * @param predicate the predicate\n     * @return the Node if found or null if not found\n     */\n    public static <V> Node<V> findLastNode(Node<V> parent, Predicate<Node<V>> predicate) {\n        checkArgNotNull(predicate, \"predicate\");\n        if (parent != null) {\n            if (predicate.apply(parent)) return parent;\n            if (hasChildren(parent)) {\n                Node<V> found = findLastNode(parent.getChildren(), predicate);\n                if (found != null) return found;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Returns the last node underneath the given parents for which the given predicate evaluates to true.\n     * If parents is null or empty or no node is found the method returns null.\n     *\n     * @param parents   the parent Nodes to look through\n     * @param predicate the predicate\n     * @return the Node if found or null if not found\n     */\n    public static <V> Node<V> findLastNode(List<Node<V>> parents, Predicate<Node<V>> predicate) {\n        checkArgNotNull(predicate, \"predicate\");\n        if (parents != null && !parents.isEmpty()) {\n            int parentsSize = parents.size();\n            for (int i = parentsSize - 1; i >= 0; i--) {\n                Node<V> found = findLastNode(parents.get(i), predicate);\n                if (found != null) return found;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Collects all nodes underneath the given parent for which the given predicate evaluates to true.\n     *\n     * @param parent     the parent Node\n     * @param predicate  the predicate\n     * @param collection the collection to collect the found Nodes into\n     * @return the same collection instance passed as a parameter\n     */\n    public static <V, C extends Collection<Node<V>>> C collectNodes(Node<V> parent,\n                                                                    Predicate<Node<V>> predicate,\n                                                                    C collection) {\n        checkArgNotNull(predicate, \"predicate\");\n        checkArgNotNull(collection, \"collection\");\n        return parent != null && hasChildren(parent) ?\n                collectNodes(parent.getChildren(), predicate, collection) : collection;\n    }\n\n    /**\n     * Returns the input text matched by the given node, with error correction.\n     *\n     * @param node        the node\n     * @param inputBuffer the underlying inputBuffer\n     * @return null if node is null otherwise a string with the matched input text (which can be empty)\n     */\n    public static String getNodeText(Node<?> node, InputBuffer inputBuffer) {\n        checkArgNotNull(node, \"node\");\n        checkArgNotNull(inputBuffer, \"inputBuffer\");\n        if (node.hasError()) {\n            // if the node has a parse error we cannot simply cut a string out of the underlying input buffer, since we\n            // would also include illegal characters, so we need to build it constructively\n            StringBuilder sb = new StringBuilder();\n            for (int i = node.getStartIndex(); i < node.getEndIndex(); i++) {\n                char c = inputBuffer.charAt(i);\n                switch (c) {\n                    case Chars.DEL_ERROR:\n                        i++;\n                        break;\n                    case Chars.INS_ERROR:\n                        break;\n                    case Chars.RESYNC_START:\n                        i++;\n                        while (inputBuffer.charAt(i) != Chars.RESYNC_END) i++;\n                        break;\n                    case Chars.RESYNC_END:\n                    case Chars.RESYNC:\n                        // we should only see proper RESYNC_START / RESYNC_END blocks\n                        throw new IllegalStateException();\n                    default:\n                        sb.append(c);\n                }\n            }\n            return sb.toString();\n        }        \n        return inputBuffer.extract(node.getStartIndex(), node.getEndIndex());\n    }\n\n    /**\n     * Collects all nodes underneath the given parents for which the given predicate evaluates to true.\n     *\n     * @param parents    the parent Nodes to look through\n     * @param predicate  the predicate\n     * @param collection the collection to collect the found Nodes into\n     * @return the same collection instance passed as a parameter\n     */\n    public static <V, C extends Collection<Node<V>>> C collectNodes(List<Node<V>> parents,\n                                                                    Predicate<Node<V>> predicate,\n                                                                    C collection) {\n        checkArgNotNull(predicate, \"predicate\");\n        checkArgNotNull(collection, \"collection\");\n        if (parents != null && !parents.isEmpty()) {\n            for (Node<V> child : parents) {\n                if (predicate.apply(child)) {\n                    collection.add(child);\n                }\n                collectNodes(child, predicate, collection);\n            }\n        }\n        return collection;\n    }\n\n    /**\n     * Creates a readable string represenation of the parse tree in the given {@link ParsingResult} object.\n     *\n     * @param parsingResult the parsing result containing the parse tree\n     * @return a new String\n     */\n    public static <V> String printNodeTree(ParsingResult<V> parsingResult) {\n        checkArgNotNull(parsingResult, \"parsingResult\");\n        return printNodeTree(parsingResult, Predicates.<Node<V>>alwaysTrue(), Predicates.<Node<V>>alwaysTrue());\n    }\n\n    /**\n     * Creates a readable string represenation of the parse tree in thee given {@link ParsingResult} object.\n     * The given filter predicate determines whether a particular node (incl. its subtree) is printed or not.\n     *\n     * @param parsingResult the parsing result containing the parse tree\n     * @param nodeFilter    the predicate selecting the nodes to print\n     * @param subTreeFilter the predicate determining whether to descend into a given nodes subtree or not\n     * @return a new String\n     */\n    public static <V> String printNodeTree(ParsingResult<V> parsingResult, Predicate<Node<V>> nodeFilter,\n                                           Predicate<Node<V>> subTreeFilter) {\n        checkArgNotNull(parsingResult, \"parsingResult\");\n        checkArgNotNull(nodeFilter, \"nodeFilter\");\n        checkArgNotNull(subTreeFilter, \"subTreeFilter\");\n        return printTree(parsingResult.parseTreeRoot, new NodeFormatter<V>(parsingResult.inputBuffer), nodeFilter,\n                subTreeFilter);\n    }\n\n}\n\n","lineNo":270}
{"Refactored Sample":"/*\n * Copyright (C) 2009-2010 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.parserunners;\n\nimport org.parboiled.MatchHandler;\nimport org.parboiled.MatcherContext;\nimport org.parboiled.Rule;\nimport org.parboiled.buffers.InputBuffer;\nimport org.parboiled.buffers.MutableInputBuffer;\nimport org.parboiled.common.Preconditions;\nimport org.parboiled.errors.InvalidInputError;\nimport org.parboiled.matchers.*;\nimport org.parboiled.matchervisitors.*;\nimport org.parboiled.support.MatcherPath;\nimport org.parboiled.support.ParsingResult;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport static org.parboiled.common.Preconditions.checkArgNotNull;\nimport static org.parboiled.common.Preconditions.checkState;\nimport static org.parboiled.support.Chars.*;\n\n/**\n * A {@link org.parboiled.parserunners.ParseRunner} implementation that is able to recover from {@link org.parboiled.errors.InvalidInputError}s in the input and therefore\n * report more than just the first {@link org.parboiled.errors.InvalidInputError} if the input does not conform to the rule grammar.\n * Error recovery is done by attempting to either delete an error character, insert a potentially missing character\n * or do both at once (which is equivalent to a one char replace) whereby this implementation is able to determine\n * itself which of these options is the best strategy.\n * If the parse error cannot be overcome by either deleting, inserting or replacing one character a resynchronization\n * rule is determined and the parsing process resynchronized, so that parsing can still continue.\n * In this way the RecoveringParseRunner is able to completely parse all input texts (This ParseRunner never returns\n * an unmatched {@link org.parboiled.support.ParsingResult}).\n * If the input is error free this {@link org.parboiled.parserunners.ParseRunner} implementation will only perform one parsing run, with the same\n * speed as the {@link org.parboiled.parserunners.BasicParseRunner}. However, if there are {@link org.parboiled.errors.InvalidInputError}s in the input potentially\n * many more runs are performed to properly report all errors and test the various recovery strategies.\n */\npublic class RecoveringParseRunner<V> extends AbstractParseRunner<V> {\n    private int errorIndex;\n    private InvalidInputError currentError;\n    private MutableInputBuffer buffer;\n    private ParsingResult<V> lastParsingResult;\n\n    /**\n     * Create a new RecoveringParseRunner instance with the given rule and input text and returns the result of\n     * its {@link #run(String)} method invocation.\n     *\n     * @param rule  the parser rule to run\n     * @param input the input text to run on\n     * @return the ParsingResult for the parsing run\n     * @deprecated  As of 0.11.0 you should use the \"regular\" constructor and one of the \"run\" methods rather than\n     * this static method. This method will be removed in one of the coming releases.\n     */\n    @Deprecated\n    public static <V> ParsingResult<V> run(Rule rule, String input) {\n        checkArgNotNull(rule, \"rule\");\n        checkArgNotNull(input, \"input\");\n        return new RecoveringParseRunner<V>(rule).run(input);\n    }\n\n    /**\n     * Creates a new RecoveringParseRunner instance for the given rule.\n     *\n     * @param rule the parser rule\n     */\n    public RecoveringParseRunner(Rule rule) {\n        super(rule);\n    }\n\n    public ParsingResult<V> run(InputBuffer inputBuffer) {\n        checkArgNotNull(inputBuffer, \"inputBuffer\");\n        resetValueStack();\n\n        // first, run a basic match\n        ParseRunner<V> basicRunner = new BasicParseRunner<V>(getRootMatcher())\n                .withParseErrors(getParseErrors())\n                .withValueStack(getValueStack());\n        lastParsingResult = basicRunner.run(inputBuffer);\n        \n        if (!lastParsingResult.matched) {\n            // locate first error\n            performLocatingRun(inputBuffer);\n            checkState(errorIndex >= 0); // we failed before so we must fail again\n\n            // in order to be able to apply fixes we need to wrap the input buffer with a mutability wrapper\n            buffer = new MutableInputBuffer(inputBuffer);\n            \n            // report first error\n            performReportingRun();\n\n            // fix and report until done\n            while (!fixError(errorIndex)) {\n                performReportingRun();\n            }\n        }\n        return lastParsingResult;\n    }\n\n    private boolean performLocatingRun(InputBuffer inputBuffer) {\n        resetValueStack();\n        ParseRunner<V> locatingRunner = new ErrorLocatingParseRunner<V>(getRootMatcher(), getInnerHandler())\n                .withParseErrors(getParseErrors())\n                .withValueStack(getValueStack());\n        lastParsingResult = locatingRunner.run(inputBuffer);\n        errorIndex = lastParsingResult.matched ? -1 :\n                getParseErrors().remove(getParseErrors().size() - 1).getStartIndex();\n        return lastParsingResult.matched;\n    }\n    \n    private void performReportingRun() {\n        resetValueStack();\n        ParseRunner<V> reportingRunner = new ErrorReportingParseRunner<V>(getRootMatcher(), errorIndex, getInnerHandler())\n                .withParseErrors(getParseErrors())\n                .withValueStack(getValueStack());\n        ParsingResult<V> result = reportingRunner.run(buffer);\n        Preconditions.checkState(!result.matched); // we failed before so we should really be failing again\n        currentError = (InvalidInputError) getParseErrors().get(getParseErrors().size() - 1);\n    }\n    \n    private MatchHandler getInnerHandler() {\n        return errorIndex >= 0 ? new Handler() : null;\n    }\n    \n    private boolean fixError(int fixIndex) {\n        if (tryFixBySingleCharDeletion(fixIndex)) return true;\n        int nextErrorAfterDeletion = errorIndex;\n\n        Character bestInsertionCharacter = findBestSingleCharInsertion(fixIndex);\n        if (bestInsertionCharacter == null) return true;\n        int nextErrorAfterBestInsertion = errorIndex;\n\n        Character bestReplacementCharacter = findBestSingleCharReplacement(fixIndex);\n        if (bestReplacementCharacter == null) return true;\n        int nextErrorAfterBestReplacement = errorIndex;\n\n        int nextErrorAfterBestSingleCharFix =\n                Math.max(Math.max(nextErrorAfterDeletion, nextErrorAfterBestInsertion), nextErrorAfterBestReplacement);\n        if (nextErrorAfterBestSingleCharFix > fixIndex) {\n            // we are able to overcome the error with a single char fix, so apply the best one found\n            if (nextErrorAfterBestSingleCharFix == nextErrorAfterDeletion) {\n                buffer.insertChar(fixIndex, DEL_ERROR);\n                errorIndex = nextErrorAfterDeletion + 1;\n                currentError.shiftIndexDeltaBy(1);\n            } else if (nextErrorAfterBestSingleCharFix == nextErrorAfterBestInsertion) {\n                // we need to insert the characters in reverse order, since we insert twice at the same location\n                buffer.insertChar(fixIndex, bestInsertionCharacter);\n                buffer.insertChar(fixIndex, INS_ERROR);\n                errorIndex = nextErrorAfterBestInsertion + 2;\n                currentError.shiftIndexDeltaBy(2);\n            } else {\n                // we need to insert the characters in reverse order, since we insert three times at the same location\n                buffer.insertChar(fixIndex + 1, bestReplacementCharacter);\n                buffer.insertChar(fixIndex + 1, INS_ERROR);\n                buffer.insertChar(fixIndex, DEL_ERROR);\n                errorIndex = nextErrorAfterBestReplacement + 5;\n                currentError.shiftIndexDeltaBy(1);\n            }\n        } else {\n            // we can't fix the error with a single char fix, so fall back to resynchronization\n            // however, if we are already at EOI there is not much more we can do\n            if (buffer.charAt(fixIndex) == EOI) return true;\n            buffer.insertChar(fixIndex, RESYNC);\n            currentError.shiftIndexDeltaBy(1);\n            performLocatingRun(buffer); // find the next parse error\n        }\n        return errorIndex == -1;\n    }\n    \n    private boolean tryFixBySingleCharDeletion(int fixIndex) {\n        buffer.insertChar(fixIndex, DEL_ERROR);\n        boolean nowErrorFree = performLocatingRun(buffer);\n        if (nowErrorFree) {\n            currentError.shiftIndexDeltaBy(1); // compensate for the inserted DEL_ERROR char\n        } else {\n            buffer.undoCharInsertion(fixIndex);\n            errorIndex = Math.max(errorIndex - 1, 0);\n        }\n        return nowErrorFree;\n    }\n\n    @SuppressWarnings({\"ConstantConditions\"})\n    private Character findBestSingleCharInsertion(int fixIndex) {\n        GetStarterCharVisitor getStarterCharVisitor = new GetStarterCharVisitor();\n        int bestNextErrorIndex = -1;\n        Character bestChar = null;\n        for (MatcherPath failedMatcherPath : currentError.getFailedMatchers()) {\n            Character starterChar = failedMatcherPath.element.matcher.accept(getStarterCharVisitor);\n            checkState(starterChar != null); // we should only have single character matchers\n            if (starterChar == EOI) {\n                continue; // we should never conjure up an EOI character (that would be cheating :)\n            }\n            buffer.insertChar(fixIndex, starterChar);\n            buffer.insertChar(fixIndex, INS_ERROR);\n            if (performLocatingRun(buffer)) {\n                currentError.shiftIndexDeltaBy(2); // compensate for the inserted chars\n                return null; // success, exit immediately\n            }\n            buffer.undoCharInsertion(fixIndex);\n            buffer.undoCharInsertion(fixIndex);\n            errorIndex = Math.max(errorIndex - 2, 0);\n\n            if (bestNextErrorIndex < errorIndex) {\n                bestNextErrorIndex = errorIndex;\n                bestChar = starterChar;\n            }\n        }\n        errorIndex = bestNextErrorIndex;\n        return bestChar;\n    }\n\n    private Character findBestSingleCharReplacement(int fixIndex) {\n        buffer.insertChar(fixIndex, DEL_ERROR);\n        Character bestChar = findBestSingleCharInsertion(fixIndex + 2);\n        if (bestChar == null) { // success, we found a fix that renders the complete input error free\n            currentError.shiftIndexDeltaBy(-1); // delta from DEL_ERROR char insertion and index shift by insertion method\n        } else {\n            buffer.undoCharInsertion(fixIndex);\n            errorIndex = Math.max(errorIndex - 3, 0);\n        }\n        return bestChar;\n    }\n    \n    /**\n     * A {@link org.parboiled.MatchHandler} implementation that recognizes the special\n     * {@link org.parboiled.support.Chars#RESYNC} character to overcome {@link InvalidInputError}s at the respective\n     * error indices.\n     */\n    private class Handler implements MatchHandler {\n        private final IsSingleCharMatcherVisitor isSingleCharMatcherVisitor = new IsSingleCharMatcherVisitor();\n        private int fringeIndex;\n        private MatcherPath lastMatchPath;\n\n        public boolean match(MatcherContext<?> context) {\n            Matcher matcher = context.getMatcher();\n            if (matcher.accept(isSingleCharMatcherVisitor)) {\n                if (prepareErrorLocation(context) && matcher.match(context)) {\n                    if (fringeIndex < context.getCurrentIndex()) {\n                        fringeIndex = context.getCurrentIndex();\n                        lastMatchPath = context.getPath();\n                    }\n                    return true;\n                }\n                return false;\n            }\n\n            if (matcher.match(context)) {\n                return true;\n            }\n\n            // if we didn't match we might have to resynchronize, however we only resynchronize\n            // if we are at a RESYNC location and the matcher is a SequenceMatchers that has already\n            // matched at least one character and that is a parent of the last match\n            char fringeChar = context.getInputBuffer().charAt(fringeIndex);\n            return (fringeChar == RESYNC || fringeChar == RESYNC_START) &&\n                    qualifiesForResync(context, matcher) &&\n                    resynchronize(context, fringeChar);\n        }\n\n        @SuppressWarnings({\"SimplifiableIfStatement\"})\n        private boolean qualifiesForResync(MatcherContext context, Matcher matcher) {\n            if (matcher instanceof SequenceMatcher && context.getCurrentIndex() > context.getStartIndex() &&\n                    context.getPath().isPrefixOf(lastMatchPath)) {\n                return true;\n            }\n            return context.getParent() == null; // always resync on the root if there is nothing else\n        }\n\n        private boolean prepareErrorLocation(MatcherContext context) {\n            switch (context.getCurrentChar()) {\n                case DEL_ERROR:\n                    return willMatchDelError(context);\n                case INS_ERROR:\n                    return willMatchInsError(context);\n            }\n            return true;\n        }\n\n        private boolean willMatchDelError(MatcherContext context) {\n            int preSkipIndex = context.getCurrentIndex();\n            context.advanceIndex(2); // skip del marker char and illegal char\n            if (!runTestMatch(context)) {\n                // if we wouldn't succeed with the match do not swallow the ERROR char & Co\n                context.setCurrentIndex(preSkipIndex);\n                return false;\n            }\n            context.setStartIndex(context.getCurrentIndex());\n            if (context.getParent() != null) context.getParent().markError();\n            return true;\n        }\n\n        private boolean willMatchInsError(MatcherContext context) {\n            int preSkipIndex = context.getCurrentIndex();\n            context.advanceIndex(1); // skip ins marker char\n            if (!runTestMatch(context)) {\n                // if we wouldn't succeed with the match do not swallow the ERROR char\n                context.setCurrentIndex(preSkipIndex);\n                return false;\n            }\n            context.setStartIndex(context.getCurrentIndex());\n            context.markError();\n            return true;\n        }\n\n        private boolean runTestMatch(MatcherContext context) {\n            TestMatcher testMatcher = new TestMatcher(context.getMatcher());\n            MatcherContext testContext = testMatcher.getSubContext(context);\n            return prepareErrorLocation(testContext) && testContext.runMatcher();\n        }\n\n        private boolean resynchronize(MatcherContext context, char fringeChar) {\n            context.markError();\n\n            // create a node for the failed Sequence, taking ownership of all sub nodes created so far\n            context.createNode();\n\n            // by resyncing we flip an unmatched sequence to a matched one, so in order to keep the value stack\n            // consistent we go into a special \"error action mode\" and execute the minimal set of actions underneath\n            // the resync sequence\n            rerunAndExecuteErrorActions(context);\n\n            // skip over all characters that are not legal followers of the failed Sequence\n            context.advanceIndex(1); // gobble RESYNC or RESYNC_START marker\n            \n            switch(fringeChar) {\n                case RESYNC:\n                    // this RESYNC error is the last error, we establish the length of the bad sequence and\n                    // change this RESYNC marker to a RESYNC_START / RESYNC_END block\n                    List<Matcher> followMatchers = new FollowMatchersVisitor().getFollowMatchers(context);\n                    int endIndex = gobbleIllegalCharacters(context, followMatchers);\n                    currentError.setEndIndex(endIndex);\n                    buffer.replaceInsertedChar(currentError.getStartIndex() - 1, RESYNC_START);\n                    buffer.insertChar(endIndex, RESYNC_END);\n                    context.setCurrentIndex(endIndex + 1);\n                    break;\n                \n                case RESYNC_START:\n                    // a RESYNC error we have already recovered from before\n                    // simply skip all characters up to the RESYNC_END\n                    while (context.getCurrentChar() != RESYNC_END) {\n                        context.advanceIndex(1);\n                        checkState(context.getCurrentChar() != EOI); // we MUST find a RESYNC_END before EOI\n                    }\n                    context.advanceIndex(1); // also gobble the RESYNC_END itself\n                    break;\n                \n                default:\n                    throw new IllegalStateException();\n            }\n            \n            fringeIndex = context.getCurrentIndex();\n            return true;\n        }\n\n        private void rerunAndExecuteErrorActions(MatcherContext context) {\n            // the context is for the resync action, which at this point has FAILED, i.e. ALL its sub actions haven't\n            // had a chance to change the value stack, even the ones having run before the actual parse error matcher\n            // so we need to rerun all sub matchers of the resync sequence up to the point of the parse error\n            // and then run the minimal set of action in \"error action mode\"\n\n            context.setCurrentIndex(context.getStartIndex()); // restart matching the resync sequence\n\n            Matcher lastGoodSub = lastMatchPath == null ? null :\n                    lastMatchPath.getElementAtLevel(context.getLevel() + 1).matcher;\n            boolean errorMode = false;\n\n            for (Matcher sub : context.getMatcher().getChildren()) {\n                if (errorMode) {\n                    for (ActionMatcher action : sub.accept(new CollectResyncActionsVisitor())) {\n                        action.getSubContext(context).runMatcher();\n                    }\n                    continue;\n                }\n                // as long as we are before the error matcher we simply execute normally\n                sub.getSubContext(context).runMatcher();\n                \n                if (sub == lastGoodSub) {\n                    // run an empty matcher which all error actions will see as the immediately preceding rule\n                    context.getSubContext(new EmptyMatcher()).runMatcher();\n                    errorMode = true;\n                }\n            }\n        }\n\n        private int gobbleIllegalCharacters(MatcherContext context, List<Matcher> followMatchers) {\n            while_loop:\n            while (true) {\n                char currentChar = context.getCurrentChar();\n                if (currentChar == EOI) break;\n                for (Matcher followMatcher : followMatchers) {\n                    if (followMatcher.accept(new IsStarterCharVisitor(currentChar))) {\n                        break while_loop;\n                    }\n                }\n                context.advanceIndex(1);\n            }\n            return context.getCurrentIndex();\n        }\n    }\n\n    /**\n     * This MatcherVisitor collects the minimal set of actions that has to run underneath a resyncronization sequence\n     * in order to maintain a consistent Value Stack state.\n     */\n    private static class CollectResyncActionsVisitor extends DefaultMatcherVisitor<List<ActionMatcher>> {\n        private final Set<Matcher> visited = new HashSet<Matcher>();\n        private final List<ActionMatcher> actions = new ArrayList<ActionMatcher>();\n\n        @Override\n        public List<ActionMatcher> visit(ActionMatcher matcher) {\n            actions.add(matcher);\n            return actions;\n        }\n\n        @Override\n        public List<ActionMatcher> visit(FirstOfMatcher matcher) {\n            // go through all subs in reverse order (because the simplest fall-back cases are often in last position)\n            // and try all of them until we hit a path that does not lead to a recursion\n            List<Matcher> children = matcher.getChildren();\n            for (int i = children.size() - 1; i >= 0; i--) {\n                if (children.get(i).accept(this) != null) return actions;\n            }\n            // a FirstOf where all subs lead to recursions,\n            // so go up one level and try another branch of the next FirstOf one level up\n            return null;\n        }\n\n        @Override\n        public List<ActionMatcher> visit(OneOrMoreMatcher matcher) {\n            return matcher.subMatcher.accept(this);\n        }\n\n        @Override\n        public List<ActionMatcher> visit(SequenceMatcher matcher) {\n            if (visited.contains(matcher)) {\n                // we hit a recursion, so signal to the next FirstOf parent that we need to take another path in order\n                // to collect all actions\n                return null;\n            }\n\n            visited.add(matcher);\n            for (Matcher sub : matcher.getChildren()) {\n                sub.accept(this);\n            }\n            return actions;\n        }\n\n        @Override\n        public List<ActionMatcher> defaultValue(AbstractMatcher matcher) {\n            return actions;\n        }\n    }\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009-2010 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.parserunners;\n\nimport org.parboiled.MatchHandler;\nimport org.parboiled.MatcherContext;\nimport org.parboiled.Rule;\nimport org.parboiled.buffers.InputBuffer;\nimport org.parboiled.buffers.MutableInputBuffer;\nimport org.parboiled.common.Preconditions;\nimport org.parboiled.errors.InvalidInputError;\nimport org.parboiled.matchers.*;\nimport org.parboiled.matchervisitors.*;\nimport org.parboiled.support.MatcherPath;\nimport org.parboiled.support.ParsingResult;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport static org.parboiled.common.Preconditions.checkArgNotNull;\nimport static org.parboiled.common.Preconditions.checkState;\nimport static org.parboiled.support.Chars.*;\n\n/**\n * A {@link org.parboiled.parserunners.ParseRunner} implementation that is able to recover from {@link org.parboiled.errors.InvalidInputError}s in the input and therefore\n * report more than just the first {@link org.parboiled.errors.InvalidInputError} if the input does not conform to the rule grammar.\n * Error recovery is done by attempting to either delete an error character, insert a potentially missing character\n * or do both at once (which is equivalent to a one char replace) whereby this implementation is able to determine\n * itself which of these options is the best strategy.\n * If the parse error cannot be overcome by either deleting, inserting or replacing one character a resynchronization\n * rule is determined and the parsing process resynchronized, so that parsing can still continue.\n * In this way the RecoveringParseRunner is able to completely parse all input texts (This ParseRunner never returns\n * an unmatched {@link org.parboiled.support.ParsingResult}).\n * If the input is error free this {@link org.parboiled.parserunners.ParseRunner} implementation will only perform one parsing run, with the same\n * speed as the {@link org.parboiled.parserunners.BasicParseRunner}. However, if there are {@link org.parboiled.errors.InvalidInputError}s in the input potentially\n * many more runs are performed to properly report all errors and test the various recovery strategies.\n */\npublic class RecoveringParseRunner<V> extends AbstractParseRunner<V> {\n    private int errorIndex;\n    private InvalidInputError currentError;\n    private MutableInputBuffer buffer;\n    private ParsingResult<V> lastParsingResult;\n\n    /**\n     * Create a new RecoveringParseRunner instance with the given rule and input text and returns the result of\n     * its {@link #run(String)} method invocation.\n     *\n     * @param rule  the parser rule to run\n     * @param input the input text to run on\n     * @return the ParsingResult for the parsing run\n     * @deprecated  As of 0.11.0 you should use the \"regular\" constructor and one of the \"run\" methods rather than\n     * this static method. This method will be removed in one of the coming releases.\n     */\n    @Deprecated\n    public static <V> ParsingResult<V> run(Rule rule, String input) {\n        checkArgNotNull(rule, \"rule\");\n        checkArgNotNull(input, \"input\");\n        return new RecoveringParseRunner<V>(rule).run(input);\n    }\n\n    /**\n     * Creates a new RecoveringParseRunner instance for the given rule.\n     *\n     * @param rule the parser rule\n     */\n    public RecoveringParseRunner(Rule rule) {\n        super(rule);\n    }\n\n    public ParsingResult<V> run(InputBuffer inputBuffer) {\n        checkArgNotNull(inputBuffer, \"inputBuffer\");\n        resetValueStack();\n\n        // first, run a basic match\n        ParseRunner<V> basicRunner = new BasicParseRunner<V>(getRootMatcher())\n                .withParseErrors(getParseErrors())\n                .withValueStack(getValueStack());\n        lastParsingResult = basicRunner.run(inputBuffer);\n        \n        if (!lastParsingResult.matched) {\n            // locate first error\n            performLocatingRun(inputBuffer);\n            checkState(errorIndex >= 0); // we failed before so we must fail again\n\n            // in order to be able to apply fixes we need to wrap the input buffer with a mutability wrapper\n            buffer = new MutableInputBuffer(inputBuffer);\n            \n            // report first error\n            performReportingRun();\n\n            // fix and report until done\n            while (!fixError(errorIndex)) {\n                performReportingRun();\n            }\n        }\n        return lastParsingResult;\n    }\n\n    private boolean performLocatingRun(InputBuffer inputBuffer) {\n        resetValueStack();\n        ParseRunner<V> locatingRunner = new ErrorLocatingParseRunner<V>(getRootMatcher(), getInnerHandler())\n                .withParseErrors(getParseErrors())\n                .withValueStack(getValueStack());\n        lastParsingResult = locatingRunner.run(inputBuffer);\n        errorIndex = lastParsingResult.matched ? -1 :\n                getParseErrors().remove(getParseErrors().size() - 1).getStartIndex();\n        return lastParsingResult.matched;\n    }\n    \n    private void performReportingRun() {\n        resetValueStack();\n        ParseRunner<V> reportingRunner = new ErrorReportingParseRunner<V>(getRootMatcher(), errorIndex, getInnerHandler())\n                .withParseErrors(getParseErrors())\n                .withValueStack(getValueStack());\n        ParsingResult<V> result = reportingRunner.run(buffer);\n        Preconditions.checkState(!result.matched); // we failed before so we should really be failing again\n        currentError = (InvalidInputError) getParseErrors().get(getParseErrors().size() - 1);\n    }\n    \n    private MatchHandler getInnerHandler() {\n        return errorIndex >= 0 ? new Handler(currentError) : null;\n    }\n    \n    private boolean fixError(int fixIndex) {\n        if (tryFixBySingleCharDeletion(fixIndex)) return true;\n        int nextErrorAfterDeletion = errorIndex;\n\n        Character bestInsertionCharacter = findBestSingleCharInsertion(fixIndex);\n        if (bestInsertionCharacter == null) return true;\n        int nextErrorAfterBestInsertion = errorIndex;\n\n        Character bestReplacementCharacter = findBestSingleCharReplacement(fixIndex);\n        if (bestReplacementCharacter == null) return true;\n        int nextErrorAfterBestReplacement = errorIndex;\n\n        int nextErrorAfterBestSingleCharFix =\n                Math.max(Math.max(nextErrorAfterDeletion, nextErrorAfterBestInsertion), nextErrorAfterBestReplacement);\n        if (nextErrorAfterBestSingleCharFix > fixIndex) {\n            // we are able to overcome the error with a single char fix, so apply the best one found\n            if (nextErrorAfterBestSingleCharFix == nextErrorAfterDeletion) {\n                buffer.insertChar(fixIndex, DEL_ERROR);\n                errorIndex = nextErrorAfterDeletion + 1;\n                currentError.shiftIndexDeltaBy(1);\n            } else if (nextErrorAfterBestSingleCharFix == nextErrorAfterBestInsertion) {\n                // we need to insert the characters in reverse order, since we insert twice at the same location\n                buffer.insertChar(fixIndex, bestInsertionCharacter);\n                buffer.insertChar(fixIndex, INS_ERROR);\n                errorIndex = nextErrorAfterBestInsertion + 2;\n                currentError.shiftIndexDeltaBy(2);\n            } else {\n                // we need to insert the characters in reverse order, since we insert three times at the same location\n                buffer.insertChar(fixIndex + 1, bestReplacementCharacter);\n                buffer.insertChar(fixIndex + 1, INS_ERROR);\n                buffer.insertChar(fixIndex, DEL_ERROR);\n                errorIndex = nextErrorAfterBestReplacement + 5;\n                currentError.shiftIndexDeltaBy(1);\n            }\n        } else {\n            // we can't fix the error with a single char fix, so fall back to resynchronization\n            // however, if we are already at EOI there is not much more we can do\n            if (buffer.charAt(fixIndex) == EOI) return true;\n            buffer.insertChar(fixIndex, RESYNC);\n            currentError.shiftIndexDeltaBy(1);\n            performLocatingRun(buffer); // find the next parse error\n        }\n        return errorIndex == -1;\n    }\n    \n    private boolean tryFixBySingleCharDeletion(int fixIndex) {\n        buffer.insertChar(fixIndex, DEL_ERROR);\n        boolean nowErrorFree = performLocatingRun(buffer);\n        if (nowErrorFree) {\n            currentError.shiftIndexDeltaBy(1); // compensate for the inserted DEL_ERROR char\n        } else {\n            buffer.undoCharInsertion(fixIndex);\n            errorIndex = Math.max(errorIndex - 1, 0);\n        }\n        return nowErrorFree;\n    }\n\n    @SuppressWarnings({\"ConstantConditions\"})\n    private Character findBestSingleCharInsertion(int fixIndex) {\n        GetStarterCharVisitor getStarterCharVisitor = new GetStarterCharVisitor();\n        int bestNextErrorIndex = -1;\n        Character bestChar = null;\n        for (MatcherPath failedMatcherPath : currentError.getFailedMatchers()) {\n            Character starterChar = failedMatcherPath.element.matcher.accept(getStarterCharVisitor);\n            checkState(starterChar != null); // we should only have single character matchers\n            if (starterChar == EOI) {\n                continue; // we should never conjure up an EOI character (that would be cheating :)\n            }\n            buffer.insertChar(fixIndex, starterChar);\n            buffer.insertChar(fixIndex, INS_ERROR);\n            if (performLocatingRun(buffer)) {\n                currentError.shiftIndexDeltaBy(2); // compensate for the inserted chars\n                return null; // success, exit immediately\n            }\n            buffer.undoCharInsertion(fixIndex);\n            buffer.undoCharInsertion(fixIndex);\n            errorIndex = Math.max(errorIndex - 2, 0);\n\n            if (bestNextErrorIndex < errorIndex) {\n                bestNextErrorIndex = errorIndex;\n                bestChar = starterChar;\n            }\n        }\n        errorIndex = bestNextErrorIndex;\n        return bestChar;\n    }\n\n    private Character findBestSingleCharReplacement(int fixIndex) {\n        buffer.insertChar(fixIndex, DEL_ERROR);\n        Character bestChar = findBestSingleCharInsertion(fixIndex + 2);\n        if (bestChar == null) { // success, we found a fix that renders the complete input error free\n            currentError.shiftIndexDeltaBy(-1); // delta from DEL_ERROR char insertion and index shift by insertion method\n        } else {\n            buffer.undoCharInsertion(fixIndex);\n            errorIndex = Math.max(errorIndex - 3, 0);\n        }\n        return bestChar;\n    }\n    \n    /**\n     * A {@link org.parboiled.MatchHandler} implementation that recognizes the special\n     * {@link org.parboiled.support.Chars#RESYNC} character to overcome {@link InvalidInputError}s at the respective\n     * error indices.\n     */\n    private static class Handler implements MatchHandler {\n        private final IsSingleCharMatcherVisitor isSingleCharMatcherVisitor = new IsSingleCharMatcherVisitor();\n        private final InvalidInputError currentError;\n        private int fringeIndex;\n        private MatcherPath lastMatchPath;\n\n        /**\n         * Creates a new Handler. If a non-null InvalidInputError is given the handler will set its endIndex\n         * to the correct index if the error corresponds to an error that can only be overcome by resynchronizing.\n         *\n         * @param currentError an optional InvalidInputError whose endIndex is to set during resyncing\n         */\n        public Handler(InvalidInputError currentError) {\n            this.currentError = currentError;\n        }\n\n        public boolean match(MatcherContext<?> context) {\n            Matcher matcher = context.getMatcher();\n            if (matcher.accept(isSingleCharMatcherVisitor)) {\n                if (prepareErrorLocation(context) && matcher.match(context)) {\n                    if (fringeIndex < context.getCurrentIndex()) {\n                        fringeIndex = context.getCurrentIndex();\n                        lastMatchPath = context.getPath();\n                    }\n                    return true;\n                }\n                return false;\n            }\n\n            if (matcher.match(context)) {\n                return true;\n            }\n\n            // if we didn't match we might have to resynchronize, however we only resynchronize\n            // if we are at a RESYNC location and the matcher is a SequenceMatchers that has already\n            // matched at least one character and that is a parent of the last match\n            return context.getInputBuffer().charAt(fringeIndex) == RESYNC &&\n                    qualifiesForResync(context, matcher) &&\n                    resynchronize(context);\n        }\n\n        @SuppressWarnings({\"SimplifiableIfStatement\"})\n        private boolean qualifiesForResync(MatcherContext context, Matcher matcher) {\n            if (matcher instanceof SequenceMatcher && context.getCurrentIndex() > context.getStartIndex() &&\n                    context.getPath().isPrefixOf(lastMatchPath)) {\n                return true;\n            }\n            return context.getParent() == null; // always resync on the root if there is nothing else\n        }\n\n        private boolean prepareErrorLocation(MatcherContext context) {\n            switch (context.getCurrentChar()) {\n                case DEL_ERROR:\n                    return willMatchDelError(context);\n                case INS_ERROR:\n                    return willMatchInsError(context);\n            }\n            return true;\n        }\n\n        private boolean willMatchDelError(MatcherContext context) {\n            int preSkipIndex = context.getCurrentIndex();\n            context.advanceIndex(2); // skip del marker char and illegal char\n            if (!runTestMatch(context)) {\n                // if we wouldn't succeed with the match do not swallow the ERROR char & Co\n                context.setCurrentIndex(preSkipIndex);\n                return false;\n            }\n            context.setStartIndex(context.getCurrentIndex());\n            context.clearNodeSuppression();\n            if (context.getParent() != null) context.getParent().markError();\n            return true;\n        }\n\n        private boolean willMatchInsError(MatcherContext context) {\n            int preSkipIndex = context.getCurrentIndex();\n            context.advanceIndex(1); // skip ins marker char\n            if (!runTestMatch(context)) {\n                // if we wouldn't succeed with the match do not swallow the ERROR char\n                context.setCurrentIndex(preSkipIndex);\n                return false;\n            }\n            context.setStartIndex(context.getCurrentIndex());\n            context.clearNodeSuppression();\n            context.markError();\n            return true;\n        }\n\n        private boolean runTestMatch(MatcherContext context) {\n            TestMatcher testMatcher = new TestMatcher(context.getMatcher());\n            MatcherContext testContext = testMatcher.getSubContext(context);\n            return prepareErrorLocation(testContext) && testContext.runMatcher();\n        }\n\n        private boolean resynchronize(MatcherContext context) {\n            context.clearNodeSuppression();\n            context.markError();\n\n            // create a node for the failed Sequence, taking ownership of all sub nodes created so far\n            context.createNode();\n\n            // by resyncing we flip an unmatched sequence to a matched one, so in order to keep the value stack\n            // consistent we go into a special \"error action mode\" and execute the minimal set of actions underneath\n            // the resync sequence\n            executeErrorActions(context);\n\n            // skip over all characters that are not legal followers of the failed Sequence\n            context.advanceIndex(1); // gobble RESYNC marker\n            fringeIndex++;\n            List<Matcher> followMatchers = new FollowMatchersVisitor().getFollowMatchers(context);\n            int endIndex = gobbleIllegalCharacters(context, followMatchers);\n\n            if (currentError != null && currentError.getStartIndex() == fringeIndex && endIndex - fringeIndex > 1) {\n                currentError.setEndIndex(endIndex);\n            }\n\n            return true;\n        }\n\n        private void executeErrorActions(MatcherContext context) {\n            // the context is for the resync action, which at this point has FAILED, i.e. ALL its sub actions haven't\n            // had a chance to change the value stack, even the ones having run before the actual parse error matcher\n            // so we need to rerun all sub matchers of the resync sequence up to the point of the parse error\n            // and then run the minimal set of action in \"error action mode\"\n\n            context.setCurrentIndex(context.getStartIndex()); // restart matching the resync sequence\n\n            Matcher lastGoodSub = lastMatchPath == null ? null :\n                    lastMatchPath.getElementAtLevel(context.getLevel() + 1).matcher;\n            boolean errorMode = false;\n\n            for (Matcher sub : context.getMatcher().getChildren()) {\n                if (errorMode) {\n                    for (ActionMatcher action : sub.accept(new CollectResyncActionsVisitor())) {\n                        action.getSubContext(context).runMatcher();\n                    }\n                    continue;\n                }\n                // as long as we are before the error matcher we simply execute normally\n                sub.getSubContext(context).runMatcher();\n                \n                if (sub == lastGoodSub) {\n                    // run an empty matcher which all error actions will see as the immediately preceding rule\n                    context.getSubContext(new EmptyMatcher()).runMatcher();\n                    errorMode = true;\n                }\n            }\n        }\n\n        private int gobbleIllegalCharacters(MatcherContext context, List<Matcher> followMatchers) {\n            while_loop:\n            while (true) {\n                char currentChar = context.getCurrentChar();\n                if (currentChar == EOI) break;\n                for (Matcher followMatcher : followMatchers) {\n                    if (followMatcher.accept(new IsStarterCharVisitor(currentChar))) {\n                        break while_loop;\n                    }\n                }\n                context.advanceIndex(1);\n            }\n            return context.getCurrentIndex();\n        }\n    }\n\n    /**\n     * This MatcherVisitor collects the minimal set of actions that has to run underneath a resyncronization sequence\n     * in order to maintain a consistent Value Stack state.\n     */\n    private static class CollectResyncActionsVisitor extends DefaultMatcherVisitor<List<ActionMatcher>> {\n        private final Set<Matcher> visited = new HashSet<Matcher>();\n        private final List<ActionMatcher> actions = new ArrayList<ActionMatcher>();\n\n        @Override\n        public List<ActionMatcher> visit(ActionMatcher matcher) {\n            actions.add(matcher);\n            return actions;\n        }\n\n        @Override\n        public List<ActionMatcher> visit(FirstOfMatcher matcher) {\n            // go through all subs in reverse order (because the simplest fall-back cases are often in last position)\n            // and try all of them until we hit a path that does not lead to a recursion\n            List<Matcher> children = matcher.getChildren();\n            for (int i = children.size() - 1; i >= 0; i--) {\n                if (children.get(i).accept(this) != null) return actions;\n            }\n            // a FirstOf where all subs lead to recursions,\n            // so go up one level and try another branch of the next FirstOf one level up\n            return null;\n        }\n\n        @Override\n        public List<ActionMatcher> visit(OneOrMoreMatcher matcher) {\n            return matcher.subMatcher.accept(this);\n        }\n\n        @Override\n        public List<ActionMatcher> visit(SequenceMatcher matcher) {\n            if (visited.contains(matcher)) {\n                // we hit a recursion, so signal to the next FirstOf parent that we need to take another path in order\n                // to collect all actions\n                return null;\n            }\n\n            visited.add(matcher);\n            for (Matcher sub : matcher.getChildren()) {\n                sub.accept(this);\n            }\n            return actions;\n        }\n\n        @Override\n        public List<ActionMatcher> defaultValue(AbstractMatcher matcher) {\n            return actions;\n        }\n    }\n}\n","lineNo":269}
{"Refactored Sample":"/*\n * Copyright (C) 2009-2010 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.support;\n\nimport static org.parboiled.common.Preconditions.*;\nimport java.util.Iterator;\n\n/**\n * An implementation of a stack of value objects providing an efficient snapshot capability and a number of convenience\n * methods. The current state of the stack can be saved and restored in small constant time with the methods\n * {@link #takeSnapshot()} and {@link #restoreSnapshot(Object)} ()}. The implementation also serves as an Iterable\n * over the current stack values (the values are being provided with the last value (on top of the stack) first).\n *\n * @param <V> the type of the value objects\n */\n@SuppressWarnings({\"ConstantConditions\"})\npublic class DefaultValueStack<V> implements ValueStack<V> {\n\n    protected static class Element {\n        protected final Object value;\n        protected final Element tail;\n\n        protected Element(Object value, Element tail) {\n            this.value = value;\n            this.tail = tail;\n        }\n    }\n\n    protected Element head;\n    protected V tempValue;\n\n    /**\n     * Initializes an empty value stack.\n     */\n    public DefaultValueStack() {\n    }\n\n    /**\n     * Initializes a value stack containing the given values with the last value being at the top of the stack.\n     *\n     * @param values the initial stack values\n     */\n    public DefaultValueStack(Iterable<V> values) {\n        pushAll(values);\n    }\n\n    public boolean isEmpty() {\n        return head == null;\n    }\n\n    public int size() {\n        Element cursor = head;\n        int size = 0;\n        while (cursor != null) {\n            size++;\n            cursor = cursor.tail;\n        }\n        return size;\n    }\n\n    public void clear() {\n        head = null;\n    }\n\n    public Object takeSnapshot() {\n        return head;\n    }\n\n    public void restoreSnapshot(Object snapshot) {\n        try {\n            head = (Element) snapshot;\n        } catch (ClassCastException e) {\n            throw new IllegalArgumentException(\"Given argument '\" + snapshot + \"' is not a valid snapshot element\");\n        }\n    }\n\n    public void push(V value) {\n        head = new Element(value, head);\n    }\n\n    public void push(int down, V value) {\n        head = push(down, value, head);\n    }\n\n    private static Element push(int down, Object value, Element head) {\n        if (down == 0) return new Element(value, head);\n        checkArgument(head != null, \"Cannot push beyond the bottom of the stack\");\n        if (down > 0) return new Element(head.value, push(down - 1, value, head.tail));\n        throw new IllegalArgumentException(\"Argument 'down' must not be negative\");\n    }\n\n    public void pushAll(V firstValue, V... moreValues) {\n        push(firstValue);\n        for (V value : moreValues) push(value);\n    }\n\n    public void pushAll(Iterable<V> values) {\n        head = null;\n        for (V value : values) push(value);\n    }\n\n    public V pop() {\n        return pop(0);\n    }\n\n    public V pop(int down) {\n        head = pop(down, head);\n        V result = tempValue;\n        tempValue = null; // avoid memory leak\n        return result;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private Element pop(int down, Element head) {\n        checkArgument(head != null, \"Cannot pop from beyond the bottom of the stack\");\n        if (down == 0) {\n            tempValue = (V) head.value;\n            return head.tail;\n        }\n        if (down > 0) return new Element(head.value, pop(down - 1, head.tail));\n        throw new IllegalArgumentException(\"Argument 'down' must not be negative\");\n    }\n\n    public V peek() {\n        return peek(0);\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    public V peek(int down) {\n        return (V) peek(down, head);\n    }\n\n    @SuppressWarnings({\"ConstantConditions\"})\n    private static Object peek(int down, Element head) {\n        checkArgument(head != null, \"Cannot peek beyond the bottom of the stack\");\n        if (down == 0) return head.value;\n        if (down > 0) return peek(down - 1, head.tail);\n        throw new IllegalArgumentException(\"Argument 'down' must not be negative\");\n    }\n\n    public void poke(V value) {\n        poke(0, value);\n    }\n\n    public void poke(int down, V value) {\n        head = poke(down, value, head);\n    }\n\n    private static Element poke(int down, Object value, Element head) {\n        checkArgument(head != null, \"Cannot poke beyond the bottom of the stack\");\n        if (down == 0) return new Element(value, head.tail);\n        if (down > 0) return new Element(head.value, poke(down - 1, value, head.tail));\n        throw new IllegalArgumentException(\"Argument 'down' must not be negative\");\n    }\n\n    public void dup() {\n        push(peek());\n    }\n\n    public void swap() {\n        Checks.ensure(isSizeGTE(2, head), \"Swap not allowed on stack with less than two elements\");\n        Element down1 = head.tail;\n        head = new Element(down1.value, new Element(head.value, down1.tail));\n    }\n\n    public void swap3() {\n        Checks.ensure(isSizeGTE(3, head), \"Swap3 not allowed on stack with less than 3 elements\");\n        Element down1 = head.tail;\n        Element down2 = down1.tail;\n        head = new Element(down2.value, new Element(down1.value, new Element(head.value, down2.tail)));\n    }\n\n    public void swap4() {\n        Checks.ensure(isSizeGTE(4, head), \"Swap4 not allowed on stack with less than 4 elements\");\n        Element down1 = head.tail;\n        Element down2 = down1.tail;\n        Element down3 = down2.tail;\n        head = new Element(down3.value, new Element(down2.value, new Element(down1.value, new Element(head.value,\n                down3.tail))));\n    }\n\n    public void swap5() {\n        Checks.ensure(isSizeGTE(5, head), \"Swap5 not allowed on stack with less than 5 elements\");\n        Element down1 = head.tail;\n        Element down2 = down1.tail;\n        Element down3 = down2.tail;\n        Element down4 = down3.tail;\n        head = new Element(down4.value, new Element(down3.value, new Element(down2.value, new Element(down1.value,\n                new Element(head.value, down4.tail)))));\n    }\n\n    public void swap6() {\n        Checks.ensure(isSizeGTE(6, head), \"Swap6 not allowed on stack with less than 6 elements\");\n        Element down1 = head.tail;\n        Element down2 = down1.tail;\n        Element down3 = down2.tail;\n        Element down4 = down3.tail;\n        Element down5 = down4.tail;\n        head = new Element(down5.value, new Element(down4.value, new Element(down3.value, new Element(down2.value,\n                new Element(down1.value, new Element(head.value, down5.tail))))));\n    }\n\n    private static boolean isSizeGTE(int minSize, Element head) {\n        return minSize == 1 ? head != null : isSizeGTE(minSize - 1, head.tail);\n    }\n\n    public Iterator<V> iterator() {\n        return new Iterator<V>() {\n            private Element next = head;\n            public boolean hasNext() {\n                return next != null;\n            }\n            @SuppressWarnings({\"unchecked\"})\n            public V next() {\n                V value = (V) next.value;\n                next = next.tail;\n                return value;\n            }\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        };\n    }\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009-2010 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.support;\n\nimport static org.parboiled.common.Preconditions.*;\nimport java.util.Iterator;\n\n/**\n * An implementation of a stack of value objects providing an efficient snapshot capability and a number of convenience\n * methods. The current state of the stack can be saved and restored in small constant time with the methods\n * {@link #takeSnapshot()} and {@link #restoreSnapshot(Object)} ()}. The implementation also serves as an Iterable\n * over the current stack values (the values are being provided with the last value (on top of the stack) first).\n *\n * @param <V> the type of the value objects\n */\n@SuppressWarnings({\"ConstantConditions\"})\npublic class DefaultValueStack<V> implements ValueStack<V> {\n\n    protected static class Element {\n        protected final Object value;\n        protected final Element tail;\n\n        protected Element(Object value, Element tail) {\n            this.value = value;\n            this.tail = tail;\n        }\n    }\n\n    protected Element head;\n    protected V tempValue;\n\n    /**\n     * Initializes an empty value stack.\n     */\n    public DefaultValueStack() {\n    }\n\n    /**\n     * Initializes a value stack containing the given values with the last value being at the top of the stack.\n     *\n     * @param values the initial stack values\n     */\n    public DefaultValueStack(Iterable<V> values) {\n        pushAll(values);\n    }\n\n    public boolean isEmpty() {\n        return head == null;\n    }\n\n    public int size() {\n        Element cursor = head;\n        int size = 0;\n        while (cursor != null) {\n            size++;\n            cursor = cursor.tail;\n        }\n        return size;\n    }\n\n    public void clear() {\n        head = null;\n    }\n\n    public Object takeSnapshot() {\n        return head;\n    }\n\n    public void restoreSnapshot(Object snapshot) {\n        try {\n            head = (Element) snapshot;\n        } catch (ClassCastException e) {\n            throw new IllegalArgumentException(\"Given argument '\" + snapshot + \"' is not a valid snapshot element\");\n        }\n    }\n\n    public void push(V value) {\n        head = new Element(value, head);\n    }\n\n    public void push(int down, V value) {\n        head = push(down, value, head);\n    }\n\n    private static Element push(int down, Object value, Element head) {\n        if (down == 0) return new Element(value, head);\n        checkArgument(head != null, \"Cannot push beyond the bottom of the stack\");\n        if (down > 0) return new Element(head.value, push(down - 1, value, head.tail));\n        throw new IllegalArgumentException(\"Argument 'down' must not be negative\");\n    }\n\n    public void pushAll(V firstValue, V... moreValues) {\n        push(firstValue);\n        for (V value : moreValues) push(value);\n    }\n\n    public void pushAll(Iterable<V> values) {\n        head = null;\n        for (V value : values) push(value);\n    }\n\n    public V pop() {\n        return pop(0);\n    }\n\n    public V pop(int down) {\n        head = pop(down, head);\n        return tempValue;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private Element pop(int down, Element head) {\n        checkArgument(head != null, \"Cannot pop from beyond the bottom of the stack\");\n        if (down == 0) {\n            tempValue = (V) head.value;\n            return head.tail;\n        }\n        if (down > 0) return new Element(head.value, pop(down - 1, head.tail));\n        throw new IllegalArgumentException(\"Argument 'down' must not be negative\");\n    }\n\n    public V peek() {\n        return peek(0);\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    public V peek(int down) {\n        return (V) peek(down, head);\n    }\n\n    @SuppressWarnings({\"ConstantConditions\"})\n    private static Object peek(int down, Element head) {\n        checkArgument(head != null, \"Cannot peek beyond the bottom of the stack\");\n        if (down == 0) return head.value;\n        if (down > 0) return peek(down - 1, head.tail);\n        throw new IllegalArgumentException(\"Argument 'down' must not be negative\");\n    }\n\n    public void poke(V value) {\n        poke(0, value);\n    }\n\n    public void poke(int down, V value) {\n        head = poke(down, value, head);\n    }\n\n    private static Element poke(int down, Object value, Element head) {\n        checkArgument(head != null, \"Cannot poke beyond the bottom of the stack\");\n        if (down == 0) return new Element(value, head.tail);\n        if (down > 0) return new Element(head.value, poke(down - 1, value, head.tail));\n        throw new IllegalArgumentException(\"Argument 'down' must not be negative\");\n    }\n\n    public void dup() {\n        push(peek());\n    }\n\n    public void swap() {\n        Checks.ensure(isSizeGTE(2, head), \"Swap not allowed on stack with less than two elements\");\n        Element down1 = head.tail;\n        head = new Element(down1.value, new Element(head.value, down1.tail));\n    }\n\n    public void swap3() {\n        Checks.ensure(isSizeGTE(3, head), \"Swap3 not allowed on stack with less than 3 elements\");\n        Element down1 = head.tail;\n        Element down2 = down1.tail;\n        head = new Element(down2.value, new Element(down1.value, new Element(head.value, down2.tail)));\n    }\n\n    public void swap4() {\n        Checks.ensure(isSizeGTE(4, head), \"Swap4 not allowed on stack with less than 4 elements\");\n        Element down1 = head.tail;\n        Element down2 = down1.tail;\n        Element down3 = down2.tail;\n        head = new Element(down3.value, new Element(down2.value, new Element(down1.value, new Element(head.value,\n                down3.tail))));\n    }\n\n    public void swap5() {\n        Checks.ensure(isSizeGTE(5, head), \"Swap5 not allowed on stack with less than 5 elements\");\n        Element down1 = head.tail;\n        Element down2 = down1.tail;\n        Element down3 = down2.tail;\n        Element down4 = down3.tail;\n        head = new Element(down4.value, new Element(down3.value, new Element(down2.value, new Element(down1.value,\n                new Element(head.value, down4.tail)))));\n    }\n\n    public void swap6() {\n        Checks.ensure(isSizeGTE(6, head), \"Swap6 not allowed on stack with less than 6 elements\");\n        Element down1 = head.tail;\n        Element down2 = down1.tail;\n        Element down3 = down2.tail;\n        Element down4 = down3.tail;\n        Element down5 = down4.tail;\n        head = new Element(down5.value, new Element(down4.value, new Element(down3.value, new Element(down2.value,\n                new Element(down1.value, new Element(head.value, down5.tail))))));\n    }\n\n    private static boolean isSizeGTE(int minSize, Element head) {\n        return minSize == 1 ? head != null : isSizeGTE(minSize - 1, head.tail);\n    }\n\n    public Iterator<V> iterator() {\n        return new Iterator<V>() {\n            private Element next = head;\n            public boolean hasNext() {\n                return next != null;\n            }\n            @SuppressWarnings({\"unchecked\"})\n            public V next() {\n                V value = (V) next.value;\n                next = next.tail;\n                return value;\n            }\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        };\n    }\n}\n","lineNo":122}
{"Refactored Sample":"/*\n * Copyright (C) 2009-2010 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.buffers;\n\nimport org.parboiled.common.FileUtils;\nimport org.parboiled.errors.IllegalIndentationException;\nimport org.testng.Assert;\nimport org.testng.annotations.Test;\n\nimport static org.parboiled.buffers.InputBufferUtils.collectContent;\nimport static org.testng.Assert.assertEquals;\n\npublic class IndentDedentInputBufferTest {\n\n    @Test\n    public void testIndentDedentInputBuffer() {\n        InputBuffer buf = new IndentDedentInputBuffer((\"\" +\n                \"level 1\\n\" +\n                \"  \\tlevel 2\\n\" +\n                \"    still level 2\\n\" +\n                \"\\t    level 3\\n\" +\n                \"      also 3\\n\" +\n                \"    2 again\\n\" +\n                \"        another 3\\n\" +\n                \"and back to 1\\n\" +\n                \"  another level 2 again\").toCharArray(), 2, null);\n        \n        String bufContent = collectContent(buf);\n        assertEquals(bufContent, \"\" +\n                \"level 1\\n\" +\n                \"level 2\\n\" +\n                \"still level 2\\n\" +\n                \"level 3\\n\" +\n                \"also 3\\n\" +\n                \"2 again\\n\" +\n                \"another 3\\n\" +\n                \"and back to 1\\n\" +\n                \"another level 2 again\\n\" +\n                \"\");\n        \n        String text = \"another 3\";\n        int start = bufContent.indexOf(text);\n        assertEquals(buf.extract(start, start + text.length()), text);  \n\n        text = \"back to 1\";\n        start = bufContent.indexOf(text);\n        assertEquals(buf.extract(start, start + text.length()), text);\n    }\n    \n    @Test\n    public void testIndentDedentInputBuffer1() {\n        String input = FileUtils.readAllTextFromResource(\"IndentDedentBuffer1.test\");\n        InputBuffer buf = new IndentDedentInputBuffer(input.toCharArray(), 4, \"#\");\n        \n        String bufContent = collectContent(buf);\n        assertEquals(bufContent, FileUtils.readAllTextFromResource(\"IndentDedentBuffer1.converted.test\"));\n        assertEquals(buf.extractLine(6), \"    Level 2      # another coment\");\n        \n        String text = \"go deep\";\n        int start = bufContent.indexOf(text);\n        assertEquals(buf.extract(start, start + text.length()), text);        \n    }\n\n    @Test\n    public void testIndentDedentInputBuffer2() {\n        String input = FileUtils.readAllTextFromResource(\"IndentDedentBuffer2.test\");\n        InputBuffer buf = new IndentDedentInputBuffer(input.toCharArray(), 4, \"//\");\n        String bufContent = collectContent(buf);\n        assertEquals(bufContent, FileUtils.readAllTextFromResource(\"IndentDedentBuffer2.converted.test\"));        \n        assertEquals(buf.extract(0, bufContent.length()), input);\n    }\n    \n    @Test\n    public void testIndentDedentInputBuffeIllegalIndent() {\n        try {\n            new IndentDedentInputBuffer((\"\" +\n                    \"level 1\\n\" +\n                    \"  \\tlevel 2\\n\" +\n                    \"    still level 2\\n\" +\n                    \"\\t    level 3\\n\" +\n                    \"     illegal!!\\n\" +\n                    \"    2 again\\n\" +\n                    \"        another 3\\n\" +\n                    \"and back to 1\\n\" +\n                    \"  another level 2 again\").toCharArray(), 2, null);\n        } catch(IllegalIndentationException e) {\n            assertEquals(e.getMessage(), \"Illegal indentation in line 5:\\n\" +\n            \"     illegal!!\\n\" +\n            \"^^^^^\\n\");\n            return;\n        }\n        Assert.fail(\"Incorrect or no IllegalIndentationException thrown\");\n    }\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009-2010 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.buffers;\n\nimport org.testng.annotations.Test;\n\nimport static org.parboiled.support.Chars.*;\nimport static org.testng.Assert.assertEquals;\n\npublic class IndentDedentInputBufferTest {\n\n    @Test\n    public void testIndentDedentInputBuffer() {\n        InputBuffer buf = new IndentDedentInputBuffer((\"\" +\n                \"level 1\\n\" +\n                \"  \\tlevel 2\\n\" +\n                \"    still level 2\\n\" +\n                \"\\t    level 3\\n\" +\n                \"     also 3\\n\" +\n                \"    2 again\\n\" +\n                \"        another 3\\n\" +\n                \"and back to 1\\n\" +\n                \"  another level 2 again\").toCharArray(), 2);\n        String bufContent = getContent(buf);\n        assertEquals(bufContent, \"\" +\n                \"level 1\\n\" +\n                \">level 2\\n\" +\n                \"still level 2\\n\" +\n                \">level 3\\n\" +\n                \"also 3\\n\" +\n                \"<2 again\\n\" +\n                \">another 3\\n\" +\n                \"<<and back to 1\\n\" +\n                \">another level 2 again\\n\" +\n                \"<\");\n\n        assertEquals(buf.charAt(13), 'l');\n        assertEquals(buf.extract(9, 16), \"level 2\");\n        assertEquals(buf.extract(69, 105), \"and back to 1\\n  another level 2 again\");\n        assertEquals(buf.getPosition(12), new InputBuffer.Position(2, 7));\n        assertEquals(buf.extractLine(2), \"  \\tlevel 2\");\n        assertEquals(buf.getPosition(bufContent.length() - 1), new InputBuffer.Position(10, 1));\n    }\n\n    @Test\n    public void testIndentDedentInputBuffer2() {\n        InputBuffer buf = new IndentDedentInputBuffer((\"\" +\n                \"level 1\\n\" +\n                \"   \\tlevel 2\\n\" +\n                \"back to 1\\n\" +\n                \"and one more\").toCharArray(), 2);\n        assertEquals(getContent(buf), \"\" +\n                \"level 1\\n\" +\n                \">level 2\\n\" +\n                \"<back to 1\\n\" +\n                \"and one more\");\n\n        assertEquals(buf.extract(0, 30), \"\" +\n                \"level 1\\n\" +\n                \"   \\tlevel 2\\n\" +\n                \"back to 1\\n\" +\n                \"and one more\");\n        assertEquals(buf.extract(18, 30), \"back to 1\\nand one more\");\n    }\n\n    private String getContent(InputBuffer buf) {\n        StringBuilder sb = new StringBuilder();\n        int ix = 0;\n        while (true) {\n            char c = buf.charAt(ix++);\n            if (c == EOI) break;\n            sb.append(c);\n        }\n\n        return sb.toString().replace(INDENT, '>').replace(DEDENT, '<');\n    }\n\n}\n","lineNo":55}
{"Refactored Sample":"/*\n * Copyright (C) 2009-2010 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.transform;\n\nimport static org.parboiled.common.Preconditions.*;\nimport org.objectweb.asm.ClassWriter;\nimport org.objectweb.asm.MethodVisitor;\nimport org.objectweb.asm.Type;\nimport org.objectweb.asm.tree.*;\n\nimport static org.objectweb.asm.Opcodes.*;\nimport static org.parboiled.transform.AsmUtils.findLoadedClass;\nimport static org.parboiled.transform.AsmUtils.loadClass;\n\nabstract class GroupClassGenerator implements RuleMethodProcessor {\n\n    private static final Object lock = new Object();\n\n    private final boolean forceCodeBuilding;\n    protected ParserClassNode classNode;\n    protected RuleMethod method;\n\n    protected GroupClassGenerator(boolean forceCodeBuilding) {\n        this.forceCodeBuilding = forceCodeBuilding;\n    }\n\n    public void process(ParserClassNode classNode, RuleMethod method) {\n        this.classNode = checkArgNotNull(classNode, \"classNode\");\n        this.method = checkArgNotNull(method, \"method\");\n\n        for (InstructionGroup group : method.getGroups()) {\n            if (appliesTo(group.getRoot())) {\n                loadGroupClass(group);\n            }\n        }\n    }\n\n    protected abstract boolean appliesTo(InstructionGraphNode group);\n\n    private void loadGroupClass(InstructionGroup group) {\n        createGroupClassType(group);\n        String className = group.getGroupClassType().getClassName();\n        ClassLoader classLoader = classNode.getParentClass().getClassLoader();\n\n        Class<?> groupClass;\n        synchronized (lock) {\n            groupClass = findLoadedClass(className, classLoader);\n            if (groupClass == null || forceCodeBuilding) {\n                byte[] groupClassCode = generateGroupClassCode(group);\n                group.setGroupClassCode(groupClassCode);\n                if (groupClass == null) {\n                    loadClass(className, groupClassCode, classLoader);\n                }\n            }\n        }\n    }\n\n    private void createGroupClassType(InstructionGroup group) {\n        String s = classNode.name;\n        int lastSlash = classNode.name.lastIndexOf('/');\n        String groupClassInternalName = (lastSlash >= 0 ? s.substring(0, lastSlash) : s)+ '/' + group.getName();\n        group.setGroupClassType(Type.getObjectType(groupClassInternalName));\n    }\n\n    protected byte[] generateGroupClassCode(InstructionGroup group) {\n        ClassWriter classWriter = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n        generateClassBasics(group, classWriter);\n        generateFields(group, classWriter);\n        generateConstructor(classWriter);\n        generateMethod(group, classWriter);\n        return classWriter.toByteArray();\n    }\n\n    private void generateClassBasics(InstructionGroup group, ClassWriter cw) {\n        cw.visit(V1_5, ACC_PUBLIC + ACC_FINAL + ACC_SYNTHETIC, group.getGroupClassType().getInternalName(), null,\n                getBaseType().getInternalName(), null);\n        cw.visitSource(classNode.sourceFile, null);\n    }\n\n    protected abstract Type getBaseType();\n\n    private void generateFields(InstructionGroup group, ClassWriter cw) {\n        for (FieldNode field : group.getFields()) {\n            // CAUTION: the FieldNode has illegal access flags and an illegal value field since these two members\n            // are reused for other purposes, so we need to write out the field \"manually\" here rather than\n            // just call \"field.accept(cw)\"\n            cw.visitField(ACC_PUBLIC + ACC_SYNTHETIC, field.name, field.desc, null, null);\n        }\n    }\n\n    private void generateConstructor(ClassWriter cw) {\n        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"(Ljava/lang/String;)V\", null, null);\n        mv.visitVarInsn(ALOAD, 0);\n        mv.visitVarInsn(ALOAD, 1);\n        mv.visitMethodInsn(INVOKESPECIAL, getBaseType().getInternalName(), \"<init>\", \"(Ljava/lang/String;)V\");\n        mv.visitInsn(RETURN);\n        mv.visitMaxs(0, 0); // trigger automatic computing\n    }\n\n    protected abstract void generateMethod(InstructionGroup group, ClassWriter cw);\n\n    protected void insertSetContextCalls(InstructionGroup group, int localVarIx) {\n        InsnList instructions = group.getInstructions();\n        for (InstructionGraphNode node : group.getNodes()) {\n            if (node.isCallOnContextAware()) {\n                AbstractInsnNode insn = node.getInstruction();\n\n                if (node.getPredecessors().size() > 1) {\n                    // store the target of the call in a new local variable\n                    AbstractInsnNode loadTarget = node.getPredecessors().get(0).getInstruction();\n                    instructions.insert(loadTarget, new VarInsnNode(ASTORE, ++localVarIx));\n                    instructions.insert(loadTarget, new InsnNode(DUP)); // the DUP is inserted BEFORE the ASTORE\n\n                    // immediately before the call get the target from the local var and set the context on it\n                    instructions.insertBefore(insn, new VarInsnNode(ALOAD, localVarIx));\n                } else {\n                    // if we have only one predecessor the call does not take any parameters and we can\n                    // skip the storing and loading of the invocation target\n                    instructions.insertBefore(insn, new InsnNode(DUP));\n                }\n                instructions.insertBefore(insn, new VarInsnNode(ALOAD, 1));\n                instructions.insertBefore(insn, new MethodInsnNode(INVOKEINTERFACE,\n                        Types.CONTEXT_AWARE.getInternalName(), \"setContext\", \"(\" + Types.CONTEXT_DESC + \")V\"));\n            }\n        }\n    }\n\n    protected void convertXLoads(InstructionGroup group) {\n        String owner = group.getGroupClassType().getInternalName();\n        for (InstructionGraphNode node : group.getNodes()) {\n            if (!node.isXLoad()) continue;\n\n            VarInsnNode insn = (VarInsnNode) node.getInstruction();\n            FieldNode field = group.getFields().get(insn.var);\n\n            // insert the correct GETFIELD after the xLoad\n            group.getInstructions().insert(insn, new FieldInsnNode(GETFIELD, owner, field.name, field.desc));\n\n            // change the load to ALOAD 0\n            group.getInstructions().set(insn, new VarInsnNode(ALOAD, 0));\n        }\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009-2010 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.transform;\n\nimport static org.parboiled.common.Preconditions.*;\nimport org.objectweb.asm.ClassWriter;\nimport org.objectweb.asm.MethodVisitor;\nimport org.objectweb.asm.Type;\nimport org.objectweb.asm.tree.*;\n\nimport static org.objectweb.asm.Opcodes.*;\nimport static org.parboiled.transform.AsmUtils.findLoadedClass;\nimport static org.parboiled.transform.AsmUtils.loadClass;\n\nabstract class GroupClassGenerator implements RuleMethodProcessor {\n\n    private static final Object lock = new Object();\n\n    private final boolean forceCodeBuilding;\n    protected ParserClassNode classNode;\n    protected RuleMethod method;\n\n    protected GroupClassGenerator(boolean forceCodeBuilding) {\n        this.forceCodeBuilding = forceCodeBuilding;\n    }\n\n    public void process(ParserClassNode classNode, RuleMethod method) {\n        this.classNode = checkArgNotNull(classNode, \"classNode\");\n        this.method = checkArgNotNull(method, \"method\");\n\n        for (InstructionGroup group : method.getGroups()) {\n            if (appliesTo(group.getRoot())) {\n                loadGroupClass(group);\n            }\n        }\n    }\n\n    protected abstract boolean appliesTo(InstructionGraphNode group);\n\n    private void loadGroupClass(InstructionGroup group) {\n        createGroupClassType(group);\n        String className = group.getGroupClassType().getClassName();\n        ClassLoader classLoader = classNode.getParentClass().getClassLoader();\n\n        Class<?> groupClass;\n        synchronized (lock) {\n            groupClass = findLoadedClass(className, classLoader);\n            if (groupClass == null || forceCodeBuilding) {\n                byte[] groupClassCode = generateGroupClassCode(group);\n                group.setGroupClassCode(groupClassCode);\n                if (groupClass == null) {\n                    loadClass(className, groupClassCode, classLoader);\n                }\n            }\n        }\n    }\n\n    private void createGroupClassType(InstructionGroup group) {\n        String s = classNode.name;\n        String groupClassInternalName = s.substring(0, classNode.name.lastIndexOf('/')) + '/' + group.getName();\n        group.setGroupClassType(Type.getObjectType(groupClassInternalName));\n    }\n\n    protected byte[] generateGroupClassCode(InstructionGroup group) {\n        ClassWriter classWriter = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n        generateClassBasics(group, classWriter);\n        generateFields(group, classWriter);\n        generateConstructor(classWriter);\n        generateMethod(group, classWriter);\n        return classWriter.toByteArray();\n    }\n\n    private void generateClassBasics(InstructionGroup group, ClassWriter cw) {\n        cw.visit(V1_5, ACC_PUBLIC + ACC_FINAL + ACC_SYNTHETIC, group.getGroupClassType().getInternalName(), null,\n                getBaseType().getInternalName(), null);\n        cw.visitSource(classNode.sourceFile, null);\n    }\n\n    protected abstract Type getBaseType();\n\n    private void generateFields(InstructionGroup group, ClassWriter cw) {\n        for (FieldNode field : group.getFields()) {\n            // CAUTION: the FieldNode has illegal access flags and an illegal value field since these two members\n            // are reused for other purposes, so we need to write out the field \"manually\" here rather than\n            // just call \"field.accept(cw)\"\n            cw.visitField(ACC_PUBLIC + ACC_SYNTHETIC, field.name, field.desc, null, null);\n        }\n    }\n\n    private void generateConstructor(ClassWriter cw) {\n        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"(Ljava/lang/String;)V\", null, null);\n        mv.visitVarInsn(ALOAD, 0);\n        mv.visitVarInsn(ALOAD, 1);\n        mv.visitMethodInsn(INVOKESPECIAL, getBaseType().getInternalName(), \"<init>\", \"(Ljava/lang/String;)V\");\n        mv.visitInsn(RETURN);\n        mv.visitMaxs(0, 0); // trigger automatic computing\n    }\n\n    protected abstract void generateMethod(InstructionGroup group, ClassWriter cw);\n\n    protected void insertSetContextCalls(InstructionGroup group, int localVarIx) {\n        InsnList instructions = group.getInstructions();\n        for (InstructionGraphNode node : group.getNodes()) {\n            if (node.isCallOnContextAware()) {\n                AbstractInsnNode insn = node.getInstruction();\n\n                if (node.getPredecessors().size() > 1) {\n                    // store the target of the call in a new local variable\n                    AbstractInsnNode loadTarget = node.getPredecessors().get(0).getInstruction();\n                    instructions.insert(loadTarget, new VarInsnNode(ASTORE, ++localVarIx));\n                    instructions.insert(loadTarget, new InsnNode(DUP)); // the DUP is inserted BEFORE the ASTORE\n\n                    // immediately before the call get the target from the local var and set the context on it\n                    instructions.insertBefore(insn, new VarInsnNode(ALOAD, localVarIx));\n                } else {\n                    // if we have only one predecessor the call does not take any parameters and we can\n                    // skip the storing and loading of the invocation target\n                    instructions.insertBefore(insn, new InsnNode(DUP));\n                }\n                instructions.insertBefore(insn, new VarInsnNode(ALOAD, 1));\n                instructions.insertBefore(insn, new MethodInsnNode(INVOKEINTERFACE,\n                        Types.CONTEXT_AWARE.getInternalName(), \"setContext\", \"(\" + Types.CONTEXT_DESC + \")V\"));\n            }\n        }\n    }\n\n    protected void convertXLoads(InstructionGroup group) {\n        String owner = group.getGroupClassType().getInternalName();\n        for (InstructionGraphNode node : group.getNodes()) {\n            if (!node.isXLoad()) continue;\n\n            VarInsnNode insn = (VarInsnNode) node.getInstruction();\n            FieldNode field = group.getFields().get(insn.var);\n\n            // insert the correct GETFIELD after the xLoad\n            group.getInstructions().insert(insn, new FieldInsnNode(GETFIELD, owner, field.name, field.desc));\n\n            // change the load to ALOAD 0\n            group.getInstructions().set(insn, new VarInsnNode(ALOAD, 0));\n        }\n    }\n\n}\n","lineNo":74}
{"Refactored Sample":"/*\n * Copyright (C) 2009-2010 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.matchervisitors;\n\nimport org.parboiled.matchers.*;\n\n/**\n * A simple matcher visitor determining whether a matcher has a custom label.\n */\npublic class HasCustomLabelVisitor extends DefaultMatcherVisitor<Boolean> {\n\n    @Override\n    public Boolean visit(ActionMatcher matcher) {\n        return true;\n    }\n\n    @Override\n    public Boolean visit(FirstOfMatcher matcher) {\n        return !\"FirstOf\".equals(matcher.getLabel());\n    }\n\n    @Override\n    public Boolean visit(OneOrMoreMatcher matcher) {\n        return !\"OneOrMore\".equals(matcher.getLabel());\n    }\n\n    @Override\n    public Boolean visit(OptionalMatcher matcher) {\n        return !\"Optional\".equals(matcher.getLabel());\n    }\n\n    @Override\n    public Boolean visit(SequenceMatcher matcher) {\n        String label = matcher.getLabel();\n        return !(\"Sequence\".equals(label) || \"<group>\".equals(label) || \"nTimes\".equals(label));\n    }\n\n    @Override\n    public Boolean visit(TestMatcher matcher) {\n        return !\"Test\".equals(matcher.getLabel());\n    }\n\n    @Override\n    public Boolean visit(TestNotMatcher matcher) {\n        return !\"TestNot\".equals(matcher.getLabel());\n    }\n\n    @Override\n    public Boolean visit(ZeroOrMoreMatcher matcher) {\n        return !\"ZeroOrMore\".equals(matcher.getLabel());\n    }\n\n    @Override\n    public Boolean defaultValue(AbstractMatcher matcher) {\n        return true;\n    }\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009-2010 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.matchervisitors;\n\nimport org.parboiled.matchers.*;\n\n/**\n * A simple matcher visitor determining whether a matcher has a custom label.\n */\npublic class HasCustomLabelVisitor extends DefaultMatcherVisitor<Boolean> {\n\n    @Override\n    public Boolean visit(ActionMatcher matcher) {\n        return true;\n    }\n\n    @Override\n    public Boolean visit(FirstOfMatcher matcher) {\n        return !\"FirstOf\".equals(matcher.getLabel());\n    }\n\n    @Override\n    public Boolean visit(OneOrMoreMatcher matcher) {\n        return !\"OneOrMore\".equals(matcher.getLabel());\n    }\n\n    @Override\n    public Boolean visit(OptionalMatcher matcher) {\n        return !\"Optional\".equals(matcher.getLabel());\n    }\n\n    @Override\n    public Boolean visit(SequenceMatcher matcher) {\n        return !\"Sequence\".equals(matcher.getLabel()) && !\"<group>\".equals(matcher.getLabel());\n    }\n\n    @Override\n    public Boolean visit(TestMatcher matcher) {\n        return !\"Test\".equals(matcher.getLabel());\n    }\n\n    @Override\n    public Boolean visit(TestNotMatcher matcher) {\n        return !\"TestNot\".equals(matcher.getLabel());\n    }\n\n    @Override\n    public Boolean visit(ZeroOrMoreMatcher matcher) {\n        return !\"ZeroOrMore\".equals(matcher.getLabel());\n    }\n\n    @Override\n    public Boolean defaultValue(AbstractMatcher matcher) {\n        return true;\n    }\n}\n","lineNo":48}
{"Refactored Sample":"/*\n * Copyright (C) 2009-2010 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.buffers;\n\nimport org.testng.annotations.Test;\n\nimport static org.parboiled.support.Chars.*;\nimport static org.testng.Assert.assertEquals;\n\npublic class IndentDedentInputBufferTest {\n\n    @Test\n    public void testIndentDedentInputBuffer() {\n        InputBuffer buf = new IndentDedentInputBuffer((\"\" +\n                \"level 1\\n\" +\n                \"  \\tlevel 2\\n\" +\n                \"    still level 2\\n\" +\n                \"\\t    level 3\\n\" +\n                \"     also 3\\n\" +\n                \"    2 again\\n\" +\n                \"        another 3\\n\" +\n                \"and back to 1\\n\" +\n                \"  another level 2 again\").toCharArray(), 2);\n        String bufContent = getContent(buf);\n        assertEquals(bufContent, \"\" +\n                \"level 1\\n\" +\n                \"\u2020\u2019level 2\\n\" +\n                \"still level 2\\n\" +\n                \"\u2020\u2019level 3\\n\" +\n                \"also 3\\n\" +\n                \"\u2020?2 again\\n\" +\n                \"\u2020\u2019another 3\\n\" +\n                \"\u2020?\u2020?and back to 1\\n\" +\n                \"\u2020\u2019another level 2 again\\n\" +\n                \"\u2020?\");\n\n        assertEquals(buf.charAt(13), 'l');\n        assertEquals(buf.extract(9, 16), \"level 2\");\n        assertEquals(buf.extract(69, 105), \"and back to 1\\n  another level 2 again\");\n        assertEquals(buf.getPosition(12), new InputBuffer.Position(2, 7));\n        assertEquals(buf.extractLine(2), \"  \\tlevel 2\");\n        assertEquals(buf.getPosition(bufContent.length() - 1), new InputBuffer.Position(10, 1));\n    }\n\n    @Test\n    public void testIndentDedentInputBuffer2() {\n        InputBuffer buf = new IndentDedentInputBuffer((\"\" +\n                \"level 1\\n\" +\n                \"   \\tlevel 2\\n\" +\n                \"back to 1\\n\" +\n                \"and one more\").toCharArray(), 2);\n        assertEquals(getContent(buf), \"\" +\n                \"level 1\\n\" +\n                \"\u2020\u2019level 2\\n\" +\n                \"\u2020?back to 1\\n\" +\n                \"and one more\");\n\n        assertEquals(buf.extract(0, 30), \"\" +\n                \"level 1\\n\" +\n                \"   \\tlevel 2\\n\" +\n                \"back to 1\\n\" +\n                \"and one more\");\n        assertEquals(buf.extract(18, 30), \"back to 1\\nand one more\");\n    }\n\n    private String getContent(InputBuffer buf) {\n        StringBuilder sb = new StringBuilder();\n        int ix = 0;\n        while (true) {\n            char c = buf.charAt(ix++);\n            if (c == EOI) break;\n            sb.append(c);\n        }\n\n        return sb.toString().replace(INDENT, '\u2020\u2019').replace(DEDENT, '\u2020?');\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009-2010 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.buffers;\n\nimport org.testng.annotations.Test;\n\nimport static org.parboiled.support.Chars.*;\nimport static org.testng.Assert.assertEquals;\n\npublic class IndentDedentInputBufferTest {\n\n    @Test\n    public void testIndentDedentInputBuffer() {\n        InputBuffer buf = new IndentDedentInputBuffer((\"\" +\n                \"level 1\\n\" +\n                \"  \\tlevel 2\\n\" +\n                \"    still level 2\\n\" +\n                \"\\t    level 3\\n\" +\n                \"     also 3\\n\" +\n                \"    2 again\\n\" +\n                \"        another 3\\n\" +\n                \"and back to 1\\n\" +\n                \"  another level 2 again\").toCharArray(), 2);\n        assertEquals(getContent(buf), \"\" +\n                \"level 1\\n\" +\n                \"\u2020\u2019level 2\\n\" +\n                \"still level 2\\n\" +\n                \"\u2020\u2019level 3\\n\" +\n                \"also 3\\n\" +\n                \"\u2020?2 again\\n\" +\n                \"\u2020\u2019another 3\\n\" +\n                \"\u2020?\u2020?and back to 1\\n\" +\n                \"\u2020\u2019another level 2 again\\n\" +\n                \"\u2020?\");\n\n        assertEquals(buf.extract(9, 16), \"level 2\");\n        assertEquals(buf.extract(69, 105), \"and back to 1\\n  another level 2 again\");\n        assertEquals(buf.getPosition(12), new InputBuffer.Position(2, 7));\n        assertEquals(buf.extractLine(2), \"  \\tlevel 2\");\n    }\n\n    @Test\n    public void testIndentDedentInputBuffer2() {\n        InputBuffer buf = new IndentDedentInputBuffer((\"\" +\n                \"level 1\\n\" +\n                \"   \\tlevel 2\\n\" +\n                \"back to 1\\n\" +\n                \"and one more\").toCharArray(), 2);\n        assertEquals(getContent(buf), \"\" +\n                \"level 1\\n\" +\n                \"\u2020\u2019level 2\\n\" +\n                \"\u2020?back to 1\\n\" +\n                \"and one more\");\n\n        assertEquals(buf.extract(0, 30), \"\" +\n                \"level 1\\n\" +\n                \"   \\tlevel 2\\n\" +\n                \"back to 1\\n\" +\n                \"and one more\");\n        assertEquals(buf.extract(18, 30), \"back to 1\\nand one more\");\n    }\n\n    private String getContent(InputBuffer buf) {\n        StringBuilder sb = new StringBuilder();\n        int ix = 0;\n        while (true) {\n            char c = buf.charAt(ix++);\n            if (c == EOI) break;\n            sb.append(c);\n        }\n\n        return sb.toString().replace(INDENT, '\u2020\u2019').replace(DEDENT, '\u2020?');\n    }\n\n}\n","lineNo":38}
{"Refactored Sample":"/*\n * Copyright (C) 2009-2010 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.matchers;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.MatcherContext;\nimport org.parboiled.Rule;\nimport org.parboiled.support.InputBuffer;\n\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * A specialized FirstOfMatcher that handles FirstOf(string, string, ...) rules much faster that the regular\n * FirstOfMatcher. If fast string matching is enabled this matcher uses a prebuilt character tree to efficiently\n * determine whether the next input characters match the rule expression.\n */\npublic class FirstOfStringsMatcher extends FirstOfMatcher {\n\n    // a node in the character tree\n    static class Record {\n        final char[] chars; // the sub characters of this node\n        final Record[] subs; // the sub records corresponding to the respective character\n\n        private Record(char[] chars, Record[] subs) {\n            this.chars = chars;\n            this.subs = subs;\n        }\n    }\n\n    private final Record root; // the root of the character tree\n\n    public FirstOfStringsMatcher(@NotNull Rule[] subRules, char[][] strings) {\n        super(subRules);\n        root = createRecord(0, strings);\n    }\n\n    @Override\n    public boolean match(@NotNull MatcherContext context) {\n        if (!context.fastStringMatching()) {\n            return super.match(context);\n        }\n\n        Record rec = root;\n        int endIx = context.getCurrentIndex();\n        InputBuffer buffer = context.getInputBuffer();\n        char c = context.getCurrentChar();\n\n        loop:\n        while (true) {\n            char[] chars = rec.chars;\n            for (int i = 0; i < chars.length; i++) {\n                if (c == chars[i]) {\n                    endIx++;\n                    Record sub = rec.subs[i];\n                    if (sub == null) {\n                        break loop; // success, we complected a tree path to a leave\n                    }\n                    rec = sub;\n                    c = buffer.charAt(endIx);\n                    continue loop;\n                }\n            }\n            // we checked all sub branches of the current node, none matched, therefore fail\n            return false;\n        }\n\n        context.advanceIndex(endIx - context.getCurrentIndex());\n        context.createNode();\n        return true;\n    }\n\n    static Record createRecord(int pos, char[][] strings) {\n        Map<Character, Set<char[]>> map = new HashMap<Character, Set<char[]>>();\n        for (char[] s : strings) {\n            if (s == null || s.length <= pos) continue;\n            char c = s[pos];\n            Set<char[]> charStrings = map.get(c);\n            if (charStrings == null) {\n                charStrings = new HashSet<char[]>();\n                map.put(c, charStrings);\n            }\n            charStrings.add(s);\n        }\n\n        if (map.isEmpty()) return null;\n\n        char[] chars = new char[map.size()];\n        Record[] subs = new Record[map.size()];\n        int i = 0;\n        for (Map.Entry<Character, Set<char[]>> entry : map.entrySet()) {\n            chars[i] = entry.getKey();\n            subs[i++] = createRecord(pos + 1, entry.getValue().toArray(new char[entry.getValue().size()][]));\n        }\n        return new Record(chars, subs);\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009-2010 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.matchers;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.MatcherContext;\nimport org.parboiled.Rule;\nimport org.parboiled.support.InputBuffer;\n\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class FirstOfStringsMatcher extends FirstOfMatcher {\n\n    static class Record {\n        final char[] chars;\n        final Record[] subs;\n\n        private Record(char[] chars, Record[] subs) {\n            this.chars = chars;\n            this.subs = subs;\n        }\n    }\n\n    private final Record root;\n\n    public FirstOfStringsMatcher(@NotNull Rule[] subRules, char[][] strings) {\n        super(subRules);\n        root = createRecord(0, strings);\n    }\n\n    @Override\n    public boolean match(@NotNull MatcherContext context) {\n        if (!context.fastStringMatching()) {\n            return super.match(context);\n        }\n\n        int endIx = test(root, context.getCurrentChar(), context.getInputBuffer(), context.getCurrentIndex());\n        if (endIx == -1) {\n            return false;\n        }\n\n        context.advanceIndex(endIx - context.getCurrentIndex());\n        context.createNode();\n        return true;\n    }\n\n    static Record createRecord(int pos, char[][] strings) {\n        Map<Character, Set<char[]>> map = new HashMap<Character, Set<char[]>>();\n        for (char[] s : strings) {\n            if (s == null || s.length <= pos) continue;\n            char c = s[pos];\n            Set<char[]> charStrings = map.get(c);\n            if (charStrings == null) {\n                charStrings = new HashSet<char[]>();\n                map.put(c, charStrings);\n            }\n            charStrings.add(s);\n        }\n        \n        if (map.isEmpty()) return null;\n\n        char[] chars = new char[map.size()];\n        Record[] subs = new Record[map.size()];\n        int i = 0;\n        for (Map.Entry<Character, Set<char[]>> entry : map.entrySet()) {\n            chars[i] = entry.getKey();\n            subs[i++] = createRecord(pos + 1, entry.getValue().toArray(new char[entry.getValue().size()][]));\n        }\n        return new Record(chars, subs);\n    }\n\n    private static int test(Record rec, char c, InputBuffer buffer, int ix) {\n        char[] chars = rec.chars;\n        for (int i = 0; i < chars.length; i++) {\n            if (c == chars[i]) {\n                Record sub = rec.subs[i];\n                ix++;\n                if (sub == null) {\n                    return ix;\n                } else {\n                    return test(sub, buffer.charAt(ix), buffer, ix);\n                }\n            }\n        }\n        return -1;\n    }\n\n}\n","lineNo":60}
{"Refactored Sample":"/*\n * Copyright (C) 2009-2010 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.matchers;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.MatcherContext;\nimport org.parboiled.Rule;\nimport org.parboiled.support.InputBuffer;\n\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * A specialized FirstOfMatcher that handles FirstOf(string, string, ...) rules much faster that the regular\n * FirstOfMatcher. If fast string matching is enabled this matcher uses a prebuilt character tree to efficiently\n * determine whether the next input characters match the rule expression.\n */\npublic class FirstOfStringsMatcher extends FirstOfMatcher {\n\n    // a node in the character tree\n    static class Record {\n        final char[] chars; // the sub characters of this node\n        final Record[] subs; // the sub records corresponding to the respective character\n\n        private Record(char[] chars, Record[] subs) {\n            this.chars = chars;\n            this.subs = subs;\n        }\n    }\n\n    private final Record root; // the root of the character tree\n\n    public FirstOfStringsMatcher(@NotNull Rule[] subRules, char[][] strings) {\n        super(subRules);\n        root = createRecord(0, strings);\n    }\n\n    @Override\n    public boolean match(@NotNull MatcherContext context) {\n        if (!context.fastStringMatching()) {\n            return super.match(context);\n        }\n\n        Record rec = root;\n        int endIx = context.getCurrentIndex();\n        InputBuffer buffer = context.getInputBuffer();\n        char c = context.getCurrentChar();\n\n        loop:\n        while (true) {\n            char[] chars = rec.chars;\n            for (int i = 0; i < chars.length; i++) {\n                if (c == chars[i]) {\n                    endIx++;\n                    Record sub = rec.subs[i];\n                    if (sub == null) {\n                        break loop; // success, we complected a tree path to a leave\n                    }\n                    rec = sub;\n                    c = buffer.charAt(endIx);\n                    continue loop;\n                }\n            }\n            // we checked all sub branches of the current node, none matched, therefore fail\n            return false;\n        }\n\n        context.advanceIndex(endIx - context.getCurrentIndex());\n        context.createNode();\n        return true;\n    }\n\n    static Record createRecord(int pos, char[][] strings) {\n        Map<Character, Set<char[]>> map = new HashMap<Character, Set<char[]>>();\n        for (char[] s : strings) {\n            if (s == null || s.length <= pos) continue;\n            char c = s[pos];\n            Set<char[]> charStrings = map.get(c);\n            if (charStrings == null) {\n                charStrings = new HashSet<char[]>();\n                map.put(c, charStrings);\n            }\n            charStrings.add(s);\n        }\n\n        if (map.isEmpty()) return null;\n\n        char[] chars = new char[map.size()];\n        Record[] subs = new Record[map.size()];\n        int i = 0;\n        for (Map.Entry<Character, Set<char[]>> entry : map.entrySet()) {\n            chars[i] = entry.getKey();\n            subs[i++] = createRecord(pos + 1, entry.getValue().toArray(new char[entry.getValue().size()][]));\n        }\n        return new Record(chars, subs);\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009-2010 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.matchers;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.MatcherContext;\nimport org.parboiled.Rule;\nimport org.parboiled.support.InputBuffer;\n\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class FirstOfStringsMatcher extends FirstOfMatcher {\n\n    static class Record {\n        final char[] chars;\n        final Record[] subs;\n\n        private Record(char[] chars, Record[] subs) {\n            this.chars = chars;\n            this.subs = subs;\n        }\n    }\n\n    private final Record root;\n\n    public FirstOfStringsMatcher(@NotNull Rule[] subRules, char[][] strings) {\n        super(subRules);\n        root = createRecord(0, strings);\n    }\n\n    @Override\n    public boolean match(@NotNull MatcherContext context) {\n        if (!context.fastStringMatching()) {\n            return super.match(context);\n        }\n\n        int endIx = test(root, context.getCurrentChar(), context.getInputBuffer(), context.getCurrentIndex());\n        if (endIx == -1) {\n            return false;\n        }\n\n        context.advanceIndex(endIx - context.getCurrentIndex());\n        context.createNode();\n        return true;\n    }\n\n    static Record createRecord(int pos, char[][] strings) {\n        Map<Character, Set<char[]>> map = new HashMap<Character, Set<char[]>>();\n        for (char[] s : strings) {\n            if (s == null || s.length <= pos) continue;\n            char c = s[pos];\n            Set<char[]> charStrings = map.get(c);\n            if (charStrings == null) {\n                charStrings = new HashSet<char[]>();\n                map.put(c, charStrings);\n            }\n            charStrings.add(s);\n        }\n        \n        if (map.isEmpty()) return null;\n\n        char[] chars = new char[map.size()];\n        Record[] subs = new Record[map.size()];\n        int i = 0;\n        for (Map.Entry<Character, Set<char[]>> entry : map.entrySet()) {\n            chars[i] = entry.getKey();\n            subs[i++] = createRecord(pos + 1, entry.getValue().toArray(new char[entry.getValue().size()][]));\n        }\n        return new Record(chars, subs);\n    }\n\n    private static int test(Record rec, char c, InputBuffer buffer, int ix) {\n        char[] chars = rec.chars;\n        for (int i = 0; i < chars.length; i++) {\n            if (c == chars[i]) {\n                Record sub = rec.subs[i];\n                ix++;\n                if (sub == null) {\n                    return ix;\n                } else {\n                    return test(sub, buffer.charAt(ix), buffer, ix);\n                }\n            }\n        }\n        return -1;\n    }\n\n}\n","lineNo":62}
{"Refactored Sample":"/*\n * Copyright (C) 2009-2010 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.matchers;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.MatcherContext;\nimport org.parboiled.Rule;\nimport org.parboiled.support.InputBuffer;\n\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * A specialized FirstOfMatcher that handles FirstOf(string, string, ...) rules much faster that the regular\n * FirstOfMatcher. If fast string matching is enabled this matcher uses a prebuilt character tree to efficiently\n * determine whether the next input characters match the rule expression.\n */\npublic class FirstOfStringsMatcher extends FirstOfMatcher {\n\n    // a node in the character tree\n    static class Record {\n        final char[] chars; // the sub characters of this node\n        final Record[] subs; // the sub records corresponding to the respective character\n\n        private Record(char[] chars, Record[] subs) {\n            this.chars = chars;\n            this.subs = subs;\n        }\n    }\n\n    private final Record root; // the root of the character tree\n\n    public FirstOfStringsMatcher(@NotNull Rule[] subRules, char[][] strings) {\n        super(subRules);\n        root = createRecord(0, strings);\n    }\n\n    @Override\n    public boolean match(@NotNull MatcherContext context) {\n        if (!context.fastStringMatching()) {\n            return super.match(context);\n        }\n\n        Record rec = root;\n        int endIx = context.getCurrentIndex();\n        InputBuffer buffer = context.getInputBuffer();\n        char c = context.getCurrentChar();\n\n        loop:\n        while (true) {\n            char[] chars = rec.chars;\n            for (int i = 0; i < chars.length; i++) {\n                if (c == chars[i]) {\n                    endIx++;\n                    Record sub = rec.subs[i];\n                    if (sub == null) {\n                        break loop; // success, we complected a tree path to a leave\n                    }\n                    rec = sub;\n                    c = buffer.charAt(endIx);\n                    continue loop;\n                }\n            }\n            // we checked all sub branches of the current node, none matched, therefore fail\n            return false;\n        }\n\n        context.advanceIndex(endIx - context.getCurrentIndex());\n        context.createNode();\n        return true;\n    }\n\n    static Record createRecord(int pos, char[][] strings) {\n        Map<Character, Set<char[]>> map = new HashMap<Character, Set<char[]>>();\n        for (char[] s : strings) {\n            if (s == null || s.length <= pos) continue;\n            char c = s[pos];\n            Set<char[]> charStrings = map.get(c);\n            if (charStrings == null) {\n                charStrings = new HashSet<char[]>();\n                map.put(c, charStrings);\n            }\n            charStrings.add(s);\n        }\n\n        if (map.isEmpty()) return null;\n\n        char[] chars = new char[map.size()];\n        Record[] subs = new Record[map.size()];\n        int i = 0;\n        for (Map.Entry<Character, Set<char[]>> entry : map.entrySet()) {\n            chars[i] = entry.getKey();\n            subs[i++] = createRecord(pos + 1, entry.getValue().toArray(new char[entry.getValue().size()][]));\n        }\n        return new Record(chars, subs);\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009-2010 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.matchers;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.MatcherContext;\nimport org.parboiled.Rule;\nimport org.parboiled.support.InputBuffer;\n\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class FirstOfStringsMatcher extends FirstOfMatcher {\n\n    static class Record {\n        final char[] chars;\n        final Record[] subs;\n\n        private Record(char[] chars, Record[] subs) {\n            this.chars = chars;\n            this.subs = subs;\n        }\n    }\n\n    private final Record root;\n\n    public FirstOfStringsMatcher(@NotNull Rule[] subRules, char[][] strings) {\n        super(subRules);\n        root = createRecord(0, strings);\n    }\n\n    @Override\n    public boolean match(@NotNull MatcherContext context) {\n        if (!context.fastStringMatching()) {\n            return super.match(context);\n        }\n\n        int endIx = test(root, context.getCurrentChar(), context.getInputBuffer(), context.getCurrentIndex());\n        if (endIx == -1) {\n            return false;\n        }\n\n        context.advanceIndex(endIx - context.getCurrentIndex());\n        context.createNode();\n        return true;\n    }\n\n    static Record createRecord(int pos, char[][] strings) {\n        Map<Character, Set<char[]>> map = new HashMap<Character, Set<char[]>>();\n        for (char[] s : strings) {\n            if (s == null || s.length <= pos) continue;\n            char c = s[pos];\n            Set<char[]> charStrings = map.get(c);\n            if (charStrings == null) {\n                charStrings = new HashSet<char[]>();\n                map.put(c, charStrings);\n            }\n            charStrings.add(s);\n        }\n        \n        if (map.isEmpty()) return null;\n\n        char[] chars = new char[map.size()];\n        Record[] subs = new Record[map.size()];\n        int i = 0;\n        for (Map.Entry<Character, Set<char[]>> entry : map.entrySet()) {\n            chars[i] = entry.getKey();\n            subs[i++] = createRecord(pos + 1, entry.getValue().toArray(new char[entry.getValue().size()][]));\n        }\n        return new Record(chars, subs);\n    }\n\n    private static int test(Record rec, char c, InputBuffer buffer, int ix) {\n        char[] chars = rec.chars;\n        for (int i = 0; i < chars.length; i++) {\n            if (c == chars[i]) {\n                Record sub = rec.subs[i];\n                ix++;\n                if (sub == null) {\n                    return ix;\n                } else {\n                    return test(sub, buffer.charAt(ix), buffer, ix);\n                }\n            }\n        }\n        return -1;\n    }\n\n}\n","lineNo":63}
{"Refactored Sample":"/*\n * Copyright (C) 2009-2010 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.examples.java;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.Parboiled;\nimport org.parboiled.ReportingParseRunner;\nimport org.parboiled.Rule;\nimport org.parboiled.support.ParsingResult;\n\nimport java.io.*;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.parboiled.errors.ErrorUtils.printParseErrors;\n\npublic class Main {\n\n    @SuppressWarnings({\"ConstantConditions\"})\n    public static void main(String[] args) {\n        System.out.println(\"parboiled Java parser, performance test\");\n        System.out.println(\"---------------------------------------\");\n\n        System.out.print(\"Creating parser... :\");\n        long start = System.currentTimeMillis();\n        Parboiled.createParser(JavaParser.class);\n        time(start);\n\n        System.out.print(\"Creating 100 more parser instances... :\");\n        JavaParser parser = null;\n        start = System.currentTimeMillis();\n        for (int i = 0; i < 100; i++) {\n            parser = Parboiled.createParser(JavaParser.class);\n        }\n        time(start);\n\n        System.out.print(\"Creating 100 more parser instances using BaseParser.newInstance() ... :\");\n        start = System.currentTimeMillis();\n        for (int i = 0; i < 100; i++) {\n            parser = parser.newInstance();\n        }\n        time(start);\n\n        start = System.currentTimeMillis();\n        File baseDir = args.length == 1 ? new File(args[0]) : null;\n        if (baseDir == null || !baseDir.exists()) baseDir = new File(\".\");\n        System.out.printf(\"Retrieving file list from '%s'\", baseDir);\n        List<File> sources = recursiveGetAllJavaSources(baseDir, new ArrayList<File>());\n        time(start);\n\n        System.out.printf(\"Parsing all %s given java sources\", sources.size());\n        Rule rootRule = parser.CompilationUnit().suppressNode(); // we want to see the parse-tree-less performance\n        start = System.currentTimeMillis();\n        long lines = 0, characters = 0;\n        for (File sourceFile : sources) {\n            long dontCountStart = System.currentTimeMillis();\n            String sourceText = readAllText(sourceFile);\n            start += System.currentTimeMillis() - dontCountStart; // do not count the time for reading the text file\n\n            ParsingResult<?> result = null;\n            try {\n                result = ReportingParseRunner.run(rootRule, sourceText);\n            } catch (Exception e) {\n                System.out.printf(\"\\nException while parsing file '%s':\\n%s\", sourceFile, e);\n                System.exit(1);\n            }\n            if (!result.matched) {\n                System.out.printf(\"\\nParse error(s) in file '%s':\\n%s\", sourceFile, printParseErrors(result));\n                System.exit(1);\n            } else {\n                System.out.print('.');\n            }\n            lines += result.inputBuffer.getPosition(sourceText.length() - 1).line;\n            characters += sourceText.length();\n        }\n        long time = time(start);\n\n        System.out.println(\"Parsing statistics:\");\n        System.out.printf(\"    %6d Files -> %6.2f Files/sec\\n\", sources.size(), sources.size() * 1000.0 / time);\n        System.out.printf(\"    %6d Lines -> %6d Lines/sec\\n\", lines, lines * 1000 / time);\n        System.out.printf(\"    %6d Chars -> %6d Chars/sec\\n\", characters, characters * 1000 / time);\n    }\n\n    private static long time(long start) {\n        long end = System.currentTimeMillis();\n        System.out.printf(\" %s ms\\n\", end - start);\n        return end - start;\n    }\n\n    private static final FileFilter fileFilter = new FileFilter() {\n        public boolean accept(File file) {\n            return file.isDirectory() || file.getName().endsWith(\".java\");\n        }\n    };\n\n    private static List<File> recursiveGetAllJavaSources(File file, ArrayList<File> list) {\n        if (file.isDirectory()) {\n            for (File f : file.listFiles(fileFilter)) {\n                recursiveGetAllJavaSources(f, list);\n            }\n        } else {\n            list.add(file);\n        }\n        return list;\n    }\n\n    public static String readAllText(@NotNull File file) {\n        return readAllText(file, Charset.forName(\"UTF8\"));\n    }\n\n    public static String readAllText(@NotNull File file, @NotNull Charset charset) {\n        try {\n            return readAllText(new FileInputStream(file), charset);\n        }\n        catch (FileNotFoundException e) {\n            return null;\n        }\n    }\n\n    public static String readAllText(InputStream stream, @NotNull Charset charset) {\n        if (stream == null) return null;\n        BufferedReader reader = new BufferedReader(new InputStreamReader(stream, charset));\n        StringWriter writer = new StringWriter();\n        copyAll(reader, writer);\n        return writer.toString();\n    }\n\n    public static void copyAll(@NotNull Reader reader, @NotNull Writer writer) {\n        try {\n            char[] data = new char[4096]; // copy in chunks of 4K\n            int count;\n            while ((count = reader.read(data)) >= 0) writer.write(data, 0, count);\n\n            reader.close();\n            writer.close();\n        }\n        catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009-2010 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.examples.java;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.Parboiled;\nimport org.parboiled.ReportingParseRunner;\nimport org.parboiled.Rule;\nimport org.parboiled.support.ParsingResult;\n\nimport java.io.*;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.parboiled.errors.ErrorUtils.printParseErrors;\n\npublic class Main {\n\n    @SuppressWarnings({\"ConstantConditions\"})\n    public static void main(String[] args) {\n        System.out.println(\"parboiled Java parser, performance test\");\n        System.out.println(\"---------------------------------------\");\n\n        System.out.print(\"Creating parser... :\");\n        long start = System.currentTimeMillis();\n        Parboiled.createParser(JavaParser.class);\n        time(start);\n\n        System.out.print(\"Creating 100 more parser instances... :\");\n        JavaParser parser = null;\n        start = System.currentTimeMillis();\n        for (int i = 0; i < 100; i++) {\n            parser = Parboiled.createParser(JavaParser.class);\n        }\n        time(start);\n\n        System.out.print(\"Creating 100 more parser instances using BaseParser.newInstance() ... :\");\n        start = System.currentTimeMillis();\n        for (int i = 0; i < 100; i++) {\n            parser = parser.newInstance();\n        }\n        time(start);\n\n        start = System.currentTimeMillis();\n        System.out.print(\"Retrieving file list...\");\n        List<File> sources = recursiveGetAllJavaSources(new File(\".\"), new ArrayList<File>());\n        time(start);\n\n        System.out.printf(\"Parsing all %s parboiled java sources\", sources.size());\n        Rule rootRule = parser.CompilationUnit().suppressNode(); // we want to see the parse-tree-less performance\n        start = System.currentTimeMillis();\n        int lines = 0, characters = 0;\n        for (File sourceFile : sources) {\n            long dontCountStart = System.currentTimeMillis();\n            String sourceText = readAllText(sourceFile);\n            start += System.currentTimeMillis() - dontCountStart; // do not count the time for reading the text file\n\n            ParsingResult<?> result = ReportingParseRunner.run(rootRule, sourceText);\n            if (!result.matched) {\n                System.out.printf(\"\\nParse error(s) in file '%s':\\n%s\", sourceFile, printParseErrors(result));\n                System.exit(1);\n            } else {\n                System.out.print('.');\n            }\n            lines += result.inputBuffer.getPosition(sourceText.length() - 1).line;\n            characters += sourceText.length();\n        }\n        long time = time(start);\n\n        System.out.println(\"Parsing statistics:\");\n        System.out.printf(\"    %6d Files -> %6.2f Files/sec\\n\", sources.size(), sources.size() * 1000.0 / time);\n        System.out.printf(\"    %6d Lines -> %6d Lines/sec\\n\", lines, lines * 1000 / time);\n        System.out.printf(\"    %6d Chars -> %6d Chars/sec\\n\", characters, characters * 1000 / time);\n    }\n\n    private static long time(long start) {\n        long end = System.currentTimeMillis();\n        System.out.printf(\" %s ms\\n\", end - start);\n        return end - start;\n    }\n\n    private static final FileFilter fileFilter = new FileFilter() {\n        public boolean accept(File file) {\n            return file.isDirectory() || file.getName().endsWith(\".java\");\n        }\n    };\n\n    private static List<File> recursiveGetAllJavaSources(File file, ArrayList<File> list) {\n        File[] files = file.listFiles(fileFilter);\n        for (File f : files) {\n            if (f.isDirectory()) {\n                recursiveGetAllJavaSources(f, list);\n            } else {\n                list.add(f);\n            }\n        }\n        return list;\n    }\n\n    public static String readAllText(@NotNull File file) {\n        return readAllText(file, Charset.forName(\"UTF8\"));\n    }\n\n    public static String readAllText(@NotNull File file, @NotNull Charset charset) {\n        try {\n            return readAllText(new FileInputStream(file), charset);\n        }\n        catch (FileNotFoundException e) {\n            return null;\n        }\n    }\n\n    public static String readAllText(InputStream stream, @NotNull Charset charset) {\n        if (stream == null) return null;\n        BufferedReader reader = new BufferedReader(new InputStreamReader(stream, charset));\n        StringWriter writer = new StringWriter();\n        copyAll(reader, writer);\n        return writer.toString();\n    }\n\n    public static void copyAll(@NotNull Reader reader, @NotNull Writer writer) {\n        try {\n            char[] data = new char[4096]; // copy in chunks of 4K\n            int count;\n            while ((count = reader.read(data)) >= 0) writer.write(data, 0, count);\n\n            reader.close();\n            writer.close();\n        }\n        catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n}\n","lineNo":60}
{"Refactored Sample":"/*\n * Copyright (C) 2009-2010 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled;\n\nimport com.google.common.base.Preconditions;\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.errors.InvalidInputError;\nimport org.parboiled.matchers.Matcher;\nimport org.parboiled.matchers.SequenceMatcher;\nimport org.parboiled.matchers.TestMatcher;\nimport org.parboiled.support.*;\n\nimport java.util.List;\n\n/**\n * A {@link ParseRunner} implementation that is able to recover from {@link InvalidInputError}s in the input and therefore\n * report more than just the first {@link InvalidInputError} if the input does not conform to the rule grammar.\n * Error recovery is done by attempting to either delete an error character, insert a potentially missing character\n * or do both at once (which is equivalent to a one char replace) whereby this implementation is able to determine\n * itself which of these options is the best strategy.\n * If the parse error cannot be overcome by either deleting, inserting or replacing one character a resynchronization\n * rule is determined and the parsing process resynchronized, so that parsing can still continue.\n * In this way the RecoveringParseRunner is able to completely parse all input texts (This ParseRunner never returns\n * an unmatched {@link ParsingResult}.\n * If the input is error free this {@link ParseRunner} implementation will only perform one parsing run, with the same\n * speed as the {@link BasicParseRunner}. However, if there are {@link InvalidInputError}s in the input potentially\n * many more runs are performed to properly report all errors and test the various recovery strategies.\n *\n * @param <V> the type of the value field of a parse tree node\n */\npublic class RecoveringParseRunner<V> extends BasicParseRunner<V> {\n\n    private int errorIndex;\n    private InvalidInputError<V> currentError;\n    private MutableInputBuffer buffer;\n\n    /**\n     * Create a new RecoveringParseRunner instance with the given rule and input text and returns the result of\n     * its {@link #run()} method invocation.\n     *\n     * @param rule  the parser rule to run\n     * @param input the input text to run on\n     * @return the ParsingResult for the parsing run\n     */\n    public static <V> ParsingResult<V> run(@NotNull Rule rule, @NotNull String input) {\n        return new RecoveringParseRunner<V>(rule, input).run();\n    }\n\n    /**\n     * Creates a new RecoveringParseRunner instance for the given rule and input text.\n     *\n     * @param rule  the parser rule\n     * @param input the input text\n     */\n    public RecoveringParseRunner(@NotNull Rule rule, @NotNull String input) {\n        super(rule, input);\n    }\n\n    /**\n     * Creates a new RecoveringParseRunner instance for the given rule and input buffer.\n     *\n     * @param rule        the parser rule\n     * @param inputBuffer the input buffer\n     */\n    public RecoveringParseRunner(@NotNull Rule rule, @NotNull InputBuffer inputBuffer) {\n        super(rule, inputBuffer);\n    }\n\n    @Override\n    protected boolean runRootContext() {\n        // run a basic match\n        if (super.runRootContext()) {\n            return true;\n        }\n\n        if (attemptRecordingMatch()) {\n            throw new IllegalStateException(); // we failed before so we must fail again\n        }\n\n        // in order to be able to apply fixes we need to wrap the input buffer with a mutability wrapper\n        inputBuffer = buffer = new MutableInputBuffer(inputBuffer);\n\n        do {\n            performErrorReportingRun();\n        } while (!fixError(errorIndex));\n\n        return true;\n    }\n\n    protected boolean attemptRecordingMatch() {\n        RecordingParseRunner.Handler<V> handler = new RecordingParseRunner.Handler<V>(getInnerHandler());\n        boolean matched = runRootContext(handler, false);\n        errorIndex = handler.getErrorIndex();\n        return matched;\n    }\n\n    protected void performErrorReportingRun() {\n        ReportingParseRunner.Handler<V> handler = new ReportingParseRunner.Handler<V>(errorIndex, getInnerHandler());\n        if (runRootContext(handler, false)) {\n            throw new IllegalStateException(); // we failed before so we should really be failing again\n        }\n        currentError = handler.getParseError();\n    }\n\n    protected MatchHandler<V> getInnerHandler() {\n        return errorIndex >= 0 ? new Handler<V>(currentError) : new BasicParseRunner.Handler<V>();\n    }\n\n    protected boolean fixError(int fixIndex) {\n        if (tryFixBySingleCharDeletion(fixIndex)) return true;\n        int nextErrorAfterDeletion = errorIndex;\n\n        Character bestInsertionCharacter = findBestSingleCharInsertion(fixIndex);\n        if (bestInsertionCharacter == null) return true;\n        int nextErrorAfterBestInsertion = errorIndex;\n\n        Character bestReplacementCharacter = findBestSingleCharReplacement(fixIndex);\n        if (bestReplacementCharacter == null) return true;\n        int nextErrorAfterBestReplacement = errorIndex;\n\n        int nextErrorAfterBestSingleCharFix =\n                Math.max(Math.max(nextErrorAfterDeletion, nextErrorAfterBestInsertion), nextErrorAfterBestReplacement);\n        if (nextErrorAfterBestSingleCharFix > fixIndex) {\n            // we are able to overcome the error with a single char fix, so apply the best one found\n            if (nextErrorAfterBestSingleCharFix == nextErrorAfterDeletion) {\n                buffer.insertChar(fixIndex, Characters.DEL_ERROR);\n                errorIndex = nextErrorAfterDeletion + 1;\n                shiftCurrentErrorIndicesBy(1);\n            } else if (nextErrorAfterBestSingleCharFix == nextErrorAfterBestInsertion) {\n                // we need to insert the characters in reverse order, since we insert twice on the same location\n                buffer.insertChar(fixIndex, bestInsertionCharacter);\n                buffer.insertChar(fixIndex, Characters.INS_ERROR);\n                errorIndex = nextErrorAfterBestInsertion + 2;\n                shiftCurrentErrorIndicesBy(2);\n            } else {\n                // we need to insert the characters in reverse order, since we insert twice on the same location\n                buffer.insertChar(fixIndex + 1, bestReplacementCharacter);\n                buffer.insertChar(fixIndex + 1, Characters.INS_ERROR);\n                buffer.insertChar(fixIndex, Characters.DEL_ERROR);\n                errorIndex = nextErrorAfterBestReplacement + 5;\n                shiftCurrentErrorIndicesBy(1);\n            }\n        } else {\n            // we can't fix the error with a single char fix, so fall back to resynchronization\n            // however, if we are already at EOI there is not much more we can do\n            if (buffer.charAt(fixIndex) == Characters.EOI) return true;\n            buffer.insertChar(fixIndex, Characters.RESYNC);\n            shiftCurrentErrorIndicesBy(1);\n            attemptRecordingMatch(); // find the next parse error\n        }\n        return errorIndex == -1;\n    }\n\n    protected boolean tryFixBySingleCharDeletion(int fixIndex) {\n        buffer.insertChar(fixIndex, Characters.DEL_ERROR);\n        boolean nowErrorFree = attemptRecordingMatch();\n        if (nowErrorFree) {\n            shiftCurrentErrorIndicesBy(1); // compensate for the inserted DEL_ERROR char\n        } else {\n            buffer.undoCharInsertion(fixIndex);\n            errorIndex = Math.max(errorIndex - 1, 0);\n        }\n        return nowErrorFree;\n    }\n\n    @SuppressWarnings({\"ConstantConditions\"})\n    protected Character findBestSingleCharInsertion(int fixIndex) {\n        GetAStarterCharVisitor<V> getAStarterCharVisitor = new GetAStarterCharVisitor<V>();\n        int bestNextErrorIndex = -1;\n        Character bestChar = null;\n        for (MatcherPath<V> failedMatcherPath : currentError.getFailedMatchers()) {\n            Character starterChar = failedMatcherPath.getHead().accept(getAStarterCharVisitor);\n            Preconditions.checkState(starterChar != null); // we should only have single character matchers\n            if (starterChar == Characters.EOI) {\n                continue; // we should never conjure up an EOI character (that would be cheating :)\n            }\n            buffer.insertChar(fixIndex, starterChar);\n            buffer.insertChar(fixIndex, Characters.INS_ERROR);\n            if (attemptRecordingMatch()) {\n                shiftCurrentErrorIndicesBy(2); // compensate for the inserted chars\n                return null; // success, exit immediately\n            }\n            buffer.undoCharInsertion(fixIndex);\n            buffer.undoCharInsertion(fixIndex);\n            errorIndex = Math.max(errorIndex - 2, 0);\n\n            if (bestNextErrorIndex < errorIndex) {\n                bestNextErrorIndex = errorIndex;\n                bestChar = starterChar;\n            }\n        }\n        errorIndex = bestNextErrorIndex;\n        return bestChar;\n    }\n\n    protected Character findBestSingleCharReplacement(int fixIndex) {\n        /*errorIndex = fixIndex;\n        return 'x';*/\n\n        buffer.insertChar(fixIndex, Characters.DEL_ERROR);\n        Character bestChar = findBestSingleCharInsertion(fixIndex + 2);\n        if (bestChar == null) { // success, we found a fix that renders the complete input error free\n            shiftCurrentErrorIndicesBy(-1); // delta from DEL_ERROR char insertion and index shift by insertion method\n        } else {\n            buffer.undoCharInsertion(fixIndex);\n            errorIndex = Math.max(errorIndex - 3, 0);\n        }\n        return bestChar;\n    }\n\n    private void shiftCurrentErrorIndicesBy(int delta) {\n        currentError.setStartIndex(currentError.getStartIndex() + delta);\n        currentError.setEndIndex(currentError.getEndIndex() + delta);\n    }\n\n    /**\n     * A {@link MatchHandler} implementation that recognizes the special {@link Characters#RESYNC} character\n     * to overcome {@link InvalidInputError}s at the respective error indices.\n     *\n     * @param <V> the type of the value field of a parse tree node\n     */\n    public static class Handler<V> implements MatchHandler<V> {\n        private final IsSingleCharMatcherVisitor<V> isSingleCharMatcherVisitor = new IsSingleCharMatcherVisitor<V>();\n        private final InvalidInputError<V> currentError;\n        private int fringeIndex;\n        private MatcherPath<V> lastMatchPath;\n\n        /**\n         * Creates a new Handler. If a non-null InvalidInputError is given the handler will set its endIndex\n         * to the correct index if the error corresponds to an error that can only be overcome by resynchronizing.\n         *\n         * @param currentError an optional InvalidInputError whose endIndex is to set during resyncing\n         */\n        public Handler(InvalidInputError<V> currentError) {\n            this.currentError = currentError;\n        }\n\n        public boolean matchRoot(MatcherContext<V> rootContext) {\n            return rootContext.runMatcher();\n        }\n\n        public boolean match(MatcherContext<V> context) {\n            Matcher<V> matcher = context.getMatcher();\n            if (matcher.accept(isSingleCharMatcherVisitor)) {\n                if (prepareErrorLocation(context) && matcher.match(context)) {\n                    if (fringeIndex < context.getCurrentIndex()) {\n                        fringeIndex = context.getCurrentIndex();\n                        lastMatchPath = context.getPath();\n                    }\n                    return true;\n                }\n                return false;\n            }\n\n            if (matcher.match(context)) {\n                return true;\n            }\n\n            // if we didn't match we might have to resynchronize, however we only resynchronize\n            // if we are at a RESYNC location and the matcher is a SequenceMatchers that has already\n            // matched at least one character and that is a parent of the last match\n            return context.getInputBuffer().charAt(fringeIndex) == Characters.RESYNC &&\n                    qualifiesForResync(context, matcher) &&\n                    resynchronize(context);\n        }\n\n        @SuppressWarnings({\"SimplifiableIfStatement\"})\n        private boolean qualifiesForResync(MatcherContext<V> context, Matcher<V> matcher) {\n            if (matcher instanceof SequenceMatcher && context.getCurrentIndex() > context.getStartIndex() &&\n                    context.getPath().isPrefixOf(lastMatchPath)) {\n                return true;\n            }\n            return context.getParent() == null; // always resync on the root if there is nothing else\n        }\n\n        protected boolean prepareErrorLocation(MatcherContext<V> context) {\n            switch (context.getCurrentChar()) {\n                case Characters.DEL_ERROR:\n                    return willMatchDelError(context);\n                case Characters.INS_ERROR:\n                    return willMatchInsError(context);\n            }\n            return true;\n        }\n\n        protected boolean willMatchDelError(MatcherContext<V> context) {\n            int preSkipIndex = context.getCurrentIndex();\n            context.advanceIndex(2); // skip del marker char and illegal char\n            if (!runTestMatch(context)) {\n                // if we wouldn't succeed with the match do not swallow the ERROR char & Co\n                context.setCurrentIndex(preSkipIndex);\n                return false;\n            }\n            context.setStartIndex(context.getCurrentIndex());\n            context.clearNodeSuppression();\n            if (context.getParent() != null) context.getParent().markError();\n            return true;\n        }\n\n        protected boolean willMatchInsError(MatcherContext<V> context) {\n            int preSkipIndex = context.getCurrentIndex();\n            context.advanceIndex(1); // skip ins marker char\n            if (!runTestMatch(context)) {\n                // if we wouldn't succeed with the match do not swallow the ERROR char\n                context.setCurrentIndex(preSkipIndex);\n                return false;\n            }\n            context.setStartIndex(context.getCurrentIndex());\n            context.clearNodeSuppression();\n            context.markError();\n            return true;\n        }\n\n        protected boolean runTestMatch(MatcherContext<V> context) {\n            TestMatcher<V> testMatcher = new TestMatcher<V>(context.getMatcher());\n            MatcherContext<V> testContext = testMatcher.getSubContext(context);\n            return prepareErrorLocation(testContext) && testContext.runMatcher();\n        }\n\n        protected boolean resynchronize(MatcherContext<V> context) {\n            context.clearNodeSuppression();\n            context.markError();\n\n            // create a node for the failed Sequence, taking ownership of all sub nodes created so far\n            context.createNode();\n\n            // skip over all characters that are not legal followers of the failed Sequence\n            context.advanceIndex(1); // gobble RESYNC marker\n            fringeIndex++;\n            List<Matcher<V>> followMatchers = new FollowMatchersVisitor<V>().getFollowMatchers(context);\n            int endIndex = gobbleIllegalCharacters(context, followMatchers);\n\n            if (currentError != null && currentError.getStartIndex() == fringeIndex && endIndex - fringeIndex > 1) {\n                currentError.setEndIndex(endIndex);\n            }\n\n            return true;\n        }\n\n        protected int gobbleIllegalCharacters(MatcherContext<V> context, List<Matcher<V>> followMatchers) {\n            while_loop:\n            while (true) {\n                char currentChar = context.getCurrentChar();\n                if (currentChar == Characters.EOI) break;\n                for (Matcher<V> followMatcher : followMatchers) {\n                    if (followMatcher.accept(new IsStarterCharVisitor<V>(currentChar))) {\n                        break while_loop;\n                    }\n                }\n                context.advanceIndex(1);\n            }\n            return context.getCurrentIndex();\n        }\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009-2010 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled;\n\nimport com.google.common.base.Preconditions;\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.errors.InvalidInputError;\nimport org.parboiled.matchers.Matcher;\nimport org.parboiled.matchers.SequenceMatcher;\nimport org.parboiled.matchers.TestMatcher;\nimport org.parboiled.support.*;\n\nimport java.util.List;\n\n/**\n * A {@link ParseRunner} implementation that is able to recover from {@link InvalidInputError}s in the input and therefore\n * report more than just the first {@link InvalidInputError} if the input does not conform to the rule grammar.\n * Error recovery is done by attempting to either delete an error character or insert a potentially missing character,\n * whereby this implementation is able to determine itself which of these options is the best strategy.\n * If the parse error cannot be overcome by either deleting or inserting one character a resynchronization rule is\n * determined and the parsing process resynchronized, so that parsing can still continue.\n * In this way the RecoveringParseRunner is able to completely parse most input texts. Only if the parser cannot even\n * start matching the root rule will it return an unmatched {@link ParsingResult}.\n * If the input is error free this {@link ParseRunner} implementation will only perform one parsing run, with the same\n * speed as the {@link BasicParseRunner}. However, if there are {@link InvalidInputError}s in the input potentially\n * many more runs are performed to properly report all errors and test the various recovery strategies.\n *\n * @param <V> the type of the value field of a parse tree node\n */\npublic class RecoveringParseRunner<V> extends BasicParseRunner<V> {\n\n    private int errorIndex;\n    private InvalidInputError<V> currentError;\n    private MutableInputBuffer buffer;\n\n    /**\n     * Create a new RecoveringParseRunner instance with the given rule and input text and returns the result of\n     * its {@link #run()} method invocation.\n     *\n     * @param rule  the parser rule to run\n     * @param input the input text to run on\n     * @return the ParsingResult for the parsing run\n     */\n    public static <V> ParsingResult<V> run(@NotNull Rule rule, @NotNull String input) {\n        return new RecoveringParseRunner<V>(rule, input).run();\n    }\n\n    /**\n     * Creates a new RecoveringParseRunner instance for the given rule and input text.\n     *\n     * @param rule  the parser rule\n     * @param input the input text\n     */\n    public RecoveringParseRunner(@NotNull Rule rule, @NotNull String input) {\n        super(rule, input);\n    }\n\n    /**\n     * Creates a new RecoveringParseRunner instance for the given rule and input buffer.\n     *\n     * @param rule        the parser rule\n     * @param inputBuffer the input buffer\n     */\n    public RecoveringParseRunner(@NotNull Rule rule, @NotNull InputBuffer inputBuffer) {\n        super(rule, inputBuffer);\n    }\n\n    @Override\n    protected boolean runRootContext() {\n        // run a basic match\n        if (super.runRootContext()) {\n            return true;\n        }\n\n        if (attemptRecordingMatch()) {\n            throw new IllegalStateException(); // we failed before so we must fail again\n        }\n\n        // in order to be able to apply fixes we need to wrap the input buffer with a mutability wrapper\n        Preconditions.checkState(inputBuffer instanceof DefaultInputBuffer);\n        inputBuffer = buffer = new MutableInputBuffer(inputBuffer);\n\n        do {\n            performErrorReportingRun();\n            if (!fixError(errorIndex)) {\n                return false;\n            }\n        } while (errorIndex >= 0);\n        return true;\n    }\n\n    protected boolean attemptRecordingMatch() {\n        RecordingParseRunner.Handler<V> handler = new RecordingParseRunner.Handler<V>(getInnerHandler());\n        boolean matched = runRootContext(handler, false);\n        errorIndex = handler.getErrorIndex();\n        return matched;\n    }\n\n    protected void performErrorReportingRun() {\n        ReportingParseRunner.Handler<V> handler = new ReportingParseRunner.Handler<V>(errorIndex, getInnerHandler());\n        if (runRootContext(handler, false)) {\n            throw new IllegalStateException(); // we failed before so we should really be failing again\n        }\n        currentError = handler.getParseError();\n    }\n\n    protected MatchHandler<V> getInnerHandler() {\n        return errorIndex >= 0 ? new Handler<V>(currentError) : new BasicParseRunner.Handler<V>();\n    }\n\n    protected boolean fixError(int fixIndex) {\n        if (tryFixBySingleCharDeletion(fixIndex)) return true;\n        int nextErrorAfterDeletion = errorIndex;\n\n        Character bestInsertionCharacter = findBestSingleCharInsertion(fixIndex);\n        if (bestInsertionCharacter == null) return true;\n        int nextErrorAfterBestInsertion = errorIndex;\n\n        int nextErrorAfterBestSingleCharFix = Math.max(nextErrorAfterDeletion, nextErrorAfterBestInsertion);\n        if (nextErrorAfterBestSingleCharFix > fixIndex) {\n            // we are able to overcome the error with a single char fix, so apply the best one found\n            if (nextErrorAfterDeletion >= nextErrorAfterBestInsertion) {\n                buffer.insertChar(fixIndex, Characters.DEL_ERROR);\n                errorIndex = nextErrorAfterDeletion + 1;\n                shiftCurrentErrorIndicesBy(1);\n            } else {\n                // we need to insert the characters in reverse order, since we insert twice on the same location\n                buffer.insertChar(fixIndex, bestInsertionCharacter);\n                buffer.insertChar(fixIndex, Characters.INS_ERROR);\n                errorIndex = nextErrorAfterBestInsertion + 2;\n                shiftCurrentErrorIndicesBy(2);\n            }\n        } else {\n            // we can't fix the error with a single char fix, so fall back to resynchronization\n            buffer.insertChar(fixIndex, Characters.RESYNC);\n            shiftCurrentErrorIndicesBy(1);\n            attemptRecordingMatch(); // find the next parse error\n        }\n        return true;\n    }\n\n    protected boolean tryFixBySingleCharDeletion(int fixIndex) {\n        buffer.insertChar(fixIndex, Characters.DEL_ERROR);\n        boolean nowErrorFree = attemptRecordingMatch();\n        if (nowErrorFree) {\n            shiftCurrentErrorIndicesBy(1);\n        } else {\n            buffer.undoCharInsertion(fixIndex);\n            errorIndex = Math.max(errorIndex - 1, 0);\n        }\n        return nowErrorFree;\n    }\n\n    @SuppressWarnings({\"ConstantConditions\"})\n    protected Character findBestSingleCharInsertion(int fixIndex) {\n        GetAStarterCharVisitor<V> getAStarterCharVisitor = new GetAStarterCharVisitor<V>();\n        int bestNextErrorIndex = -1;\n        Character bestChar = null;\n        for (MatcherPath<V> failedMatcherPath : currentError.getFailedMatchers()) {\n            Character starterChar = failedMatcherPath.getHead().accept(getAStarterCharVisitor);\n            Preconditions.checkState(starterChar != null); // we should only have single character matchers\n            if (starterChar == Characters.EOI) {\n                continue; // we should never conjure up an EOI character (that would be cheating :)\n            }\n            buffer.insertChar(fixIndex, starterChar);\n            buffer.insertChar(fixIndex, Characters.INS_ERROR);\n            if (attemptRecordingMatch()) {\n                shiftCurrentErrorIndicesBy(2);\n                return null; // success, exit immediately\n            }\n            buffer.undoCharInsertion(fixIndex);\n            buffer.undoCharInsertion(fixIndex);\n            errorIndex = Math.max(errorIndex - 2, 0);\n\n            if (bestNextErrorIndex < errorIndex) {\n                bestNextErrorIndex = errorIndex;\n                bestChar = starterChar;\n            }\n        }\n        errorIndex = bestNextErrorIndex;\n        return bestChar;\n    }\n\n    private void shiftCurrentErrorIndicesBy(int delta) {\n        currentError.setStartIndex(currentError.getStartIndex() + delta);\n        currentError.setEndIndex(currentError.getEndIndex() + delta);\n    }\n\n    /**\n     * A {@link MatchHandler} implementation that recognizes the special {@link Characters#RESYNC} character\n     * to overcome {@link InvalidInputError}s at the respective error indices.\n     *\n     * @param <V> the type of the value field of a parse tree node\n     */\n    public static class Handler<V> implements MatchHandler<V> {\n        private final IsSingleCharMatcherVisitor<V> isSingleCharMatcherVisitor = new IsSingleCharMatcherVisitor<V>();\n        private final InvalidInputError<V> currentError;\n        private int fringeIndex;\n        private MatcherPath<V> lastMatchPath;\n\n        /**\n         * Creates a new Handler. If a non-null InvalidInputError is given the handler will set its endIndex\n         * to the correct index if the error corresponds to an error that can only be overcome by resynchronizing.\n         *\n         * @param currentError an optional InvalidInputError whose endIndex is to set during resyncing\n         */\n        public Handler(InvalidInputError<V> currentError) {\n            this.currentError = currentError;\n        }\n\n        public boolean matchRoot(MatcherContext<V> rootContext) {\n            return rootContext.runMatcher();\n        }\n\n        public boolean match(MatcherContext<V> context) {\n            Matcher<V> matcher = context.getMatcher();\n            if (matcher.accept(isSingleCharMatcherVisitor)) {\n                if (prepareErrorLocation(context) && matcher.match(context)) {\n                    if (fringeIndex < context.getCurrentIndex()) {\n                        fringeIndex = context.getCurrentIndex();\n                        lastMatchPath = context.getPath();\n                    }\n                    return true;\n                }\n                return false;\n            }\n\n            if (matcher.match(context)) {\n                return true;\n            }\n\n            // if we didn't match we might have to resynchronize, however we only resynchronize\n            // if we are at a RESYNC location and the matcher is a SequenceMatchers that has already\n            // matched at least one character and that is a parent of the last match\n            return context.getInputBuffer().charAt(fringeIndex) == Characters.RESYNC &&\n                    qualifiesForResync(context, matcher) &&\n                    resynchronize(context);\n        }\n\n        @SuppressWarnings({\"SimplifiableIfStatement\"})\n        private boolean qualifiesForResync(MatcherContext<V> context, Matcher<V> matcher) {\n            if (matcher instanceof SequenceMatcher && context.getCurrentIndex() > context.getStartIndex() &&\n                    context.getPath().isPrefixOf(lastMatchPath)) {\n                return true;\n            }\n            return context.getParent() == null; // always resync on the root if there is nothing else\n        }\n\n        protected boolean prepareErrorLocation(MatcherContext<V> context) {\n            switch (context.getCurrentChar()) {\n                case Characters.DEL_ERROR:\n                    return willMatchDelError(context);\n                case Characters.INS_ERROR:\n                    return willMatchInsError(context);\n            }\n            return true;\n        }\n\n        protected boolean willMatchDelError(MatcherContext<V> context) {\n            int preSkipIndex = context.getCurrentIndex();\n            context.advanceIndex(2); // skip del marker char and illegal char\n            if (!runTestMatch(context)) {\n                // if we wouldn't succeed with the match do not swallow the ERROR char & Co\n                context.setCurrentIndex(preSkipIndex);\n                return false;\n            }\n            context.setStartIndex(context.getCurrentIndex());\n            context.clearNodeSuppression();\n            if (context.getParent() != null) context.getParent().markError();\n            return true;\n        }\n\n        protected boolean willMatchInsError(MatcherContext<V> context) {\n            int preSkipIndex = context.getCurrentIndex();\n            context.advanceIndex(1); // skip ins marker char\n            if (!runTestMatch(context)) {\n                // if we wouldn't succeed with the match do not swallow the ERROR char\n                context.setCurrentIndex(preSkipIndex);\n                return false;\n            }\n            context.setStartIndex(context.getCurrentIndex());\n            context.clearNodeSuppression();\n            context.markError();\n            return true;\n        }\n\n        protected boolean runTestMatch(MatcherContext<V> context) {\n            TestMatcher<V> testMatcher = new TestMatcher<V>(context.getMatcher());\n            return testMatcher.getSubContext(context).runMatcher();\n        }\n\n        protected boolean resynchronize(MatcherContext<V> context) {\n            context.clearNodeSuppression();\n            context.markError();\n\n            // create a node for the failed Sequence, taking ownership of all sub nodes created so far\n            context.createNode();\n\n            // skip over all characters that are not legal followers of the failed Sequence\n            context.advanceIndex(1); // gobble RESYNC marker\n            fringeIndex++;\n            List<Matcher<V>> followMatchers = new FollowMatchersVisitor<V>().getFollowMatchers(context);\n            int endIndex = gobbleIllegalCharacters(context, followMatchers);\n\n            if (currentError != null && currentError.getStartIndex() == fringeIndex && endIndex - fringeIndex > 1) {\n                currentError.setEndIndex(endIndex);\n            }\n\n            return true;\n        }\n\n        protected int gobbleIllegalCharacters(MatcherContext<V> context, List<Matcher<V>> followMatchers) {\n            while_loop:\n            while (true) {\n                char currentChar = context.getCurrentChar();\n                if (currentChar == Characters.EOI) break;\n                for (Matcher<V> followMatcher : followMatchers) {\n                    if (followMatcher.accept(new IsStarterCharVisitor<V>(currentChar))) {\n                        break while_loop;\n                    }\n                }\n                context.advanceIndex(1);\n            }\n            return context.getCurrentIndex();\n        }\n    }\n\n}\n","lineNo":330}
{"Refactored Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled;\n\nimport org.parboiled.support.ParsingResult;\nimport org.parboiled.test.AbstractTest;\nimport org.testng.annotations.Test;\n\nimport static org.testng.Assert.assertEquals;\n\npublic class IndentDedentTest extends AbstractTest {\n\n    public static class IndentDedentParser extends BaseParser<Object> {\n        public int currentIndent;\n        public int indents;\n        public int dedents;\n\n        public Rule File() {\n            return ZeroOrMore(Line());\n        }\n\n        public Rule Line() {\n            return Sequence(\n                    ZeroOrMore(' '),\n                    countIndentOrDedent(text(lastNode())),\n                    ZeroOrMore(LineChar()),\n                    Newline()\n            );\n        }\n\n        public Rule LineChar() {\n            return Sequence(TestNot(Newline()), Any());\n        }\n\n        public Rule Newline() {\n            return FirstOf(\"\\r\\n\", '\\r', '\\n');\n        }\n\n        public boolean countIndentOrDedent(String lineStartWhiteSpace) {\n            if (lineStartWhiteSpace.length() > currentIndent) indents++;\n            if (lineStartWhiteSpace.length() < currentIndent) dedents++;\n            currentIndent = lineStartWhiteSpace.length();\n            return true;\n        }\n\n    }\n\n    @Test\n    public void test() {\n        IndentDedentParser parser = Parboiled.createParser(IndentDedentParser.class);\n        Rule rule = parser.File();\n        String source = \"\" +\n                \"a file containing\\n\" +\n                \"  some\\n\" +\n                \"     indents\\n\" +\n                \"     some lines\\n\" +\n                \"     that do not indent\\n\" +\n                \"  they might dedent\\n\" +\n                \"  stay there\\n\" +\n                \"          go back big time\\n\" +\n                \" and return\";\n        ParsingResult<?> result = RecoveringParseRunner.run(rule, source\n        );\n        assertEquals(parser.indents, 3);\n        assertEquals(parser.dedents, 2);\n        assertEquals(parser.currentIndent, 1);\n        assertEquals(result.inputBuffer.getPosition(source.length() - 1).line, 9);\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled;\n\nimport org.parboiled.support.ParsingResult;\nimport org.parboiled.test.AbstractTest;\nimport org.testng.annotations.Test;\n\nimport static org.testng.Assert.assertEquals;\n\npublic class IndentDedentTest extends AbstractTest {\n\n    public static class IndentDedentParser extends BaseParser<Object> {\n        public int currentIndent;\n        public int indents;\n        public int dedents;\n\n        public Rule File() {\n            return ZeroOrMore(Line());\n        }\n\n        public Rule Line() {\n            return Sequence(\n                    ZeroOrMore(' '),\n                    countIndentOrDedent(text(lastNode())),\n                    ZeroOrMore(LineChar()),\n                    Newline()\n            );\n        }\n\n        public Rule LineChar() {\n            return Sequence(TestNot(Newline()), Any());\n        }\n\n        public Rule Newline() {\n            return FirstOf(\"\\r\\n\", '\\r', '\\n');\n        }\n\n        public boolean countIndentOrDedent(String lineStartWhiteSpace) {\n            if (lineStartWhiteSpace.length() > currentIndent) indents++;\n            if (lineStartWhiteSpace.length() < currentIndent) dedents++;\n            currentIndent = lineStartWhiteSpace.length();\n            return true;\n        }\n\n    }\n\n    @Test\n    public void test() {\n        IndentDedentParser parser = Parboiled.createParser(IndentDedentParser.class);\n        Rule rule = parser.File();\n        ParsingResult<?> result = RecoveringParseRunner.run(rule, \"\" +\n                \"a file containing\\n\" +\n                \"  some\\n\" +\n                \"     indents\\n\" +\n                \"     some lines\\n\" +\n                \"     that do not indent\\n\" +\n                \"  they might dedent\\n\" +\n                \"  stay there\\n\" +\n                \"          go back big time\\n\" +\n                \" and return\"\n        );\n        assertEquals(parser.indents, 3);\n        assertEquals(parser.dedents, 2);\n        assertEquals(parser.currentIndent, 1);\n        assertEquals(result.inputBuffer.getPosition(result.inputBuffer.getLength() - 1).line, 9);\n    }\n\n}\n","lineNo":66}
{"Refactored Sample":"/*\n * Copyright (C) 2009-2010 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.errors;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.common.Formatter;\nimport org.parboiled.common.StringUtils;\nimport org.parboiled.matchers.*;\nimport org.parboiled.support.*;\n\nimport java.util.List;\n\n/**\n * General utility methods regarding parse errors.\n */\npublic final class ErrorUtils {\n\n    private ErrorUtils() {}\n\n    /**\n     * Finds the Matcher in the given failedMatcherPath whose label is best for presentation in \"expected\" strings\n     * of parse error messages, given the provided lastMatchPath.\n     *\n     * @param failedMatcherPath the path to the failed matcher\n     * @param lastMatchPath     the path of the last match\n     * @param <V>               the type of the value field of a parse tree node\n     * @return the matcher whose label is best for presentation in \"expected\" strings\n     */\n    public static <V> Matcher<V> findProperLabelMatcher(@NotNull MatcherPath<V> failedMatcherPath,\n                                                        MatcherPath<V> lastMatchPath) {\n        int commonPrefixLength = failedMatcherPath.getCommonPrefixLength(lastMatchPath);\n        if (lastMatchPath != null && commonPrefixLength == lastMatchPath.length()) {\n            return failedMatcherPath.getHead();\n        }\n\n        DefaultMatcherVisitor<V, Boolean> hasProperLabelVisitor = new DefaultMatcherVisitor<V, Boolean>() {\n            @Override\n            public Boolean visit(ActionMatcher<V> matcher) {\n                return false;\n            }\n\n            @Override\n            public Boolean visit(EmptyMatcher<V> matcher) {\n                return false;\n            }\n\n            @Override\n            public Boolean visit(FirstOfMatcher<V> matcher) {\n                String label = matcher.getLabel();\n                return !\"FirstOf\".equals(label);\n            }\n\n            @Override\n            public Boolean visit(OneOrMoreMatcher<V> matcher) {\n                return !\"OneOrMore\".equals(matcher.getLabel());\n            }\n\n            @Override\n            public Boolean visit(OptionalMatcher<V> matcher) {\n                return !\"Optional\".equals(matcher.getLabel());\n            }\n\n            @Override\n            public Boolean visit(SequenceMatcher<V> matcher) {\n                return !\"Sequence\".equals(matcher.getLabel());\n            }\n\n            @Override\n            public Boolean visit(ZeroOrMoreMatcher<V> matcher) {\n                return !\"ZeroOrMore\".equals(matcher.getLabel());\n            }\n\n            @Override\n            public Boolean defaultValue(AbstractMatcher<V> matcher) {\n                return true;\n            }\n        };\n\n        for (int i = commonPrefixLength; i < failedMatcherPath.length(); i++) {\n            Matcher<V> matcher = failedMatcherPath.get(i);\n            if (matcher.accept(hasProperLabelVisitor)) {\n                return matcher;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Pretty prints the given parse error showing its location in the given input buffer.\n     *\n     * @param error       the parse error\n     * @param inputBuffer the input buffer\n     * @return the pretty print text\n     */\n    public static <V> String printParseError(@NotNull ParseError error, @NotNull InputBuffer inputBuffer) {\n        return printParseError(error, inputBuffer, new DefaultInvalidInputErrorFormatter<V>());\n    }\n\n    /**\n     * Pretty prints the given parse error showing its location in the given input buffer.\n     *\n     * @param error       the parse error\n     * @param inputBuffer the input buffer\n     * @param formatter   the formatter for InvalidInputErrors\n     * @return the pretty print text\n     */\n    @SuppressWarnings({\"unchecked\"})\n    public static <V> String printParseError(@NotNull ParseError error, @NotNull InputBuffer inputBuffer,\n                                             @NotNull Formatter<InvalidInputError<V>> formatter) {\n        int start = error.getStartIndex();\n        String message = error.getErrorMessage() != null ? error.getErrorMessage() :\n                error instanceof InvalidInputError ?\n                        formatter.format((InvalidInputError<V>) error) : error.getClass().getSimpleName();\n\n        DefaultInputBuffer.Position pos = inputBuffer.getPosition(start);\n        StringBuilder sb = new StringBuilder(message);\n        sb.append(String.format(\" (line %s, pos %s):\", pos.line, pos.column));\n        sb.append('\\n');\n\n        String line = inputBuffer.extractLine(pos.line);\n        sb.append(line);\n        sb.append('\\n');\n\n        int charCount = Math.min(\n                error.getEndIndex() - error.getStartIndex(),\n                StringUtils.length(line) - pos.column + 2\n        );\n        for (int i = 0; i < pos.column - 1; i++) sb.append(' ');\n        for (int i = 0; i < charCount; i++) sb.append('^');\n        sb.append(\"\\n\");\n\n        return sb.toString();\n    }\n\n    /**\n     * Pretty prints the given parse errors showing their location in the given input buffer.\n     *\n     * @param parsingResult the parsing result\n     * @return the pretty print text\n     */\n    public static String printParseErrors(@NotNull ParsingResult<?> parsingResult) {\n        return printParseErrors(parsingResult.parseErrors, parsingResult.inputBuffer);\n    }\n\n    /**\n     * Pretty prints the given parse errors showing their location in the given input buffer.\n     *\n     * @param errors      the parse errors\n     * @param inputBuffer the input buffer\n     * @return the pretty print text\n     */\n    public static String printParseErrors(@NotNull List<ParseError> errors, @NotNull InputBuffer inputBuffer) {\n        StringBuilder sb = new StringBuilder();\n        for (ParseError error : errors) {\n            if (sb.length() > 0) sb.append(\"---\\n\");\n            sb.append(printParseError(error, inputBuffer));\n        }\n        return sb.toString();\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009-2010 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.errors;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.common.Formatter;\nimport org.parboiled.common.StringUtils;\nimport org.parboiled.matchers.*;\nimport org.parboiled.support.*;\n\nimport java.util.List;\n\n/**\n * General utility methods regarding parse errors.\n */\npublic final class ErrorUtils {\n\n    private ErrorUtils() {}\n\n    /**\n     * Finds the Matcher in the given failedMatcherPath whose label is best for presentation in \"expected\" strings\n     * of parse error messages, given the provided lastMatchPath.\n     *\n     * @param failedMatcherPath the path to the failed matcher\n     * @param lastMatchPath     the path of the last match\n     * @param <V>               the type of the value field of a parse tree node\n     * @return the matcher whose label is best for presentation in \"expected\" strings\n     */\n    public static <V> Matcher<V> findProperLabelMatcher(@NotNull MatcherPath<V> failedMatcherPath,\n                                                        MatcherPath<V> lastMatchPath) {\n        int commonPrefixLength = failedMatcherPath.getCommonPrefixLength(lastMatchPath);\n        if (lastMatchPath != null && commonPrefixLength == lastMatchPath.length()) {\n            return failedMatcherPath.getHead();\n        }\n\n        DefaultMatcherVisitor<V, Boolean> hasProperLabelVisitor = new DefaultMatcherVisitor<V, Boolean>() {\n            @Override\n            public Boolean visit(ActionMatcher<V> matcher) {\n                return false;\n            }\n\n            @Override\n            public Boolean visit(EmptyMatcher<V> matcher) {\n                return false;\n            }\n\n            @Override\n            public Boolean visit(FirstOfMatcher<V> matcher) {\n                String label = matcher.getLabel();\n                return !\"FirstOf\".equals(label);\n            }\n\n            @Override\n            public Boolean visit(OneOrMoreMatcher<V> matcher) {\n                return !\"OneOrMore\".equals(matcher.getLabel());\n            }\n\n            @Override\n            public Boolean visit(OptionalMatcher<V> matcher) {\n                return !\"Optional\".equals(matcher.getLabel());\n            }\n\n            @Override\n            public Boolean visit(SequenceMatcher<V> matcher) {\n                return !\"Sequence\".equals(matcher.getLabel());\n            }\n\n            @Override\n            public Boolean visit(ZeroOrMoreMatcher<V> matcher) {\n                return !\"ZeroOrMore\".equals(matcher.getLabel());\n            }\n\n            @Override\n            public Boolean defaultValue(AbstractMatcher<V> matcher) {\n                return true;\n            }\n        };\n\n        for (int i = commonPrefixLength; i < failedMatcherPath.length(); i++) {\n            Matcher<V> matcher = failedMatcherPath.get(i);\n            if (matcher.accept(hasProperLabelVisitor)) {\n                return matcher;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Pretty prints the given parse error showing its location in the given input buffer.\n     *\n     * @param error       the parse error\n     * @param inputBuffer the input buffer\n     * @return the pretty print text\n     */\n    public static <V> String printParseError(@NotNull ParseError error, @NotNull InputBuffer inputBuffer) {\n        return printParseError(error, inputBuffer, new DefaultInvalidInputErrorFormatter<V>());\n    }\n\n    /**\n     * Pretty prints the given parse error showing its location in the given input buffer.\n     *\n     * @param error       the parse error\n     * @param inputBuffer the input buffer\n     * @param formatter   the formatter for InvalidInputErrors\n     * @return the pretty print text\n     */\n    @SuppressWarnings({\"unchecked\"})\n    public static <V> String printParseError(@NotNull ParseError error, @NotNull InputBuffer inputBuffer,\n                                             @NotNull Formatter<InvalidInputError<V>> formatter) {\n        InputLocation start = error.getErrorLocation();\n        String message = error.getErrorMessage() != null ? error.getErrorMessage() :\n                error instanceof InvalidInputError ?\n                        formatter.format((InvalidInputError<V>) error) : error.getClass().getSimpleName();\n\n        StringBuilder sb = new StringBuilder(message);\n        sb.append(String.format(\" (line %s, pos %s):\", start.getRow() + 1, start.getColumn() + 1));\n        sb.append('\\n');\n\n        String line = StringUtils.getLine(inputBuffer.getBuffer(), start.getRow());\n        sb.append(line);\n        sb.append('\\n');\n\n        int charCount = Math.min(error.getErrorCharCount(), StringUtils.length(line) - start.getColumn() + 1);\n        for (int i = 0; i < start.getColumn(); i++) sb.append(' ');\n        for (int i = 0; i < charCount; i++) sb.append('^');\n        sb.append(\"\\n\");\n\n        return sb.toString();\n    }\n\n    /**\n     * Pretty prints the given parse errors showing their location in the given input buffer.\n     *\n     * @param parsingResult the parsing result\n     * @return the pretty print text\n     */\n    public static String printParseErrors(@NotNull ParsingResult<?> parsingResult) {\n        return printParseErrors(parsingResult.parseErrors, parsingResult.inputBuffer);\n    }\n\n    /**\n     * Pretty prints the given parse errors showing their location in the given input buffer.\n     *\n     * @param errors      the parse errors\n     * @param inputBuffer the input buffer\n     * @return the pretty print text\n     */\n    public static String printParseErrors(@NotNull List<ParseError> errors, @NotNull InputBuffer inputBuffer) {\n        StringBuilder sb = new StringBuilder();\n        for (ParseError error : errors) {\n            if (sb.length() > 0) sb.append(\"---\\n\");\n            sb.append(printParseError(error, inputBuffer));\n        }\n        return sb.toString();\n    }\n\n}\n","lineNo":129}
{"Refactored Sample":"/*\n * Copyright (c) 2009-2010 Ken Wenzel and Mathias Doenitz\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\npackage org.parboiled.transform;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.objectweb.asm.Opcodes;\nimport org.objectweb.asm.Type;\nimport org.objectweb.asm.tree.*;\nimport org.parboiled.support.Checks;\n\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n\nimport static org.parboiled.transform.AsmUtils.getLoadingOpcode;\n\n/**\n * Inserts action group class and capture group call instantiation code at the groups respective placeholders.\n */\nclass RuleMethodRewriter implements RuleMethodProcessor, Opcodes, Types {\n\n    private RuleMethod method;\n    private InstructionGroup group;\n    private int actionNr;\n    private int captureNr;\n    private int varInitNr;\n    private Map<InstructionGraphNode, Integer> captureVarIndices;\n\n    public boolean appliesTo(@NotNull ParserClassNode classNode, @NotNull RuleMethod method) {\n        return method.containsExplicitActions() || method.containsCaptures() || method.containsVars();\n    }\n\n    public void process(@NotNull ParserClassNode classNode, @NotNull RuleMethod method) throws Exception {\n        this.method = method;\n        actionNr = 0;\n        captureNr = 0;\n        varInitNr = 0;\n        captureVarIndices = null;\n\n        for (InstructionGroup group : method.getGroups()) {\n            this.group = group;\n            createNewGroupClassInstance();\n            initializeFields();\n\n            InstructionGraphNode root = group.getRoot();\n            if (root.isActionRoot()) {\n                removeGroupRootInstruction();\n            } else if (root.isCaptureRoot()) {\n                insertStoreCapture();\n                removeGroupRootInstruction();\n            } else { // if (root.isVarInitRoot())\n                ((MethodInsnNode)root.getInstruction()).desc = \"(Lorg/parboiled/common/Factory;)V\";\n            }\n        }\n\n        if (method.containsCaptures()) {\n            finalizeCaptureSetup();\n        }\n\n        method.setBodyRewritten();\n    }\n\n    private void createNewGroupClassInstance() {\n        String internalName = group.getGroupClassType().getInternalName();\n        InstructionGraphNode root = group.getRoot();\n        insert(new TypeInsnNode(NEW, internalName));\n        insert(new InsnNode(DUP));\n        insert(new LdcInsnNode(method.name +\n                (root.isActionRoot() ? \"_Action\" + ++actionNr :\n                        root.isCaptureRoot() ? \"_Capture\" + ++captureNr : \"_VarInit\" + ++varInitNr))\n        );\n        insert(new MethodInsnNode(INVOKESPECIAL, internalName, \"<init>\", \"(Ljava/lang/String;)V\"));\n\n        if ((root.isActionRoot() || root.isCaptureRoot()) && method.hasSkipActionsInPredicatesAnnotation()) {\n            insert(new InsnNode(DUP));\n            insert(new MethodInsnNode(INVOKEVIRTUAL, internalName, \"setSkipInPredicates\", \"()V\"));\n        }\n    }\n\n    private void initializeFields() {\n        String internalName = group.getGroupClassType().getInternalName();\n        for (FieldNode field : group.getFields()) {\n            insert(new InsnNode(DUP));\n            // the FieldNodes access and value members have been reused for the var index / Type respectively!\n            insert(new VarInsnNode(getLoadingOpcode((Type) field.value), field.access));\n            insert(new FieldInsnNode(PUTFIELD, internalName, field.name, field.desc));\n        }\n    }\n\n    private void insertStoreCapture() {\n        if (captureVarIndices == null) {\n            captureVarIndices = new HashMap<InstructionGraphNode, Integer>();\n        }\n        int index = method.maxLocals++;\n        captureVarIndices.put(group.getRoot(), index);\n\n        insert(new InsnNode(DUP));\n        insert(new VarInsnNode(ASTORE, index));\n    }\n\n    private void insert(AbstractInsnNode insn) {\n        method.instructions.insertBefore(group.getRoot().getInstruction(), insn);\n    }\n\n    private void removeGroupRootInstruction() {\n        method.instructions.remove(group.getRoot().getInstruction());\n    }\n\n    private void finalizeCaptureSetup() {\n        Set<InstructionGroup> finalizedCaptureGroups = new HashSet<InstructionGroup>();\n        for (InstructionGraphNode node : method.getGraphNodes()) {\n            if (AsmUtils.isCallToRuleCreationMethod(node.getInstruction())) {\n                insertSetContextRuleOnCaptureArguments(node, finalizedCaptureGroups);\n            }\n        }\n        Checks.ensure(finalizedCaptureGroups.size() == captureVarIndices.size(), \"Method '%s' contains illegal \" +\n                \"CAPTURE(...) constructs that are not direct arguments to rule creating methods\", method.name);\n    }\n\n    private void insertSetContextRuleOnCaptureArguments(InstructionGraphNode ruleCreationCall,\n                                                        Set<InstructionGroup> finalizedCaptureGroups) {\n        for (InstructionGraphNode predecessor : ruleCreationCall.getPredecessors()) {\n            if (predecessor.isCaptureRoot()) {\n                insertSetContextRule(ruleCreationCall, predecessor);\n                finalizedCaptureGroups.add(predecessor.getGroup());\n            }\n        }\n    }\n\n    private void insertSetContextRule(InstructionGraphNode ruleCreationCall, InstructionGraphNode argument) {\n        String internalName = argument.getGroup().getGroupClassType().getInternalName();\n        AbstractInsnNode location = ruleCreationCall.getInstruction().getNext();\n        // stack: <Rule>\n        method.instructions.insertBefore(location, new InsnNode(DUP));\n        // stack: <Rule> :: <Rule>\n        method.instructions.insertBefore(location, new VarInsnNode(ALOAD, captureVarIndices.get(argument)));\n        // stack: <Rule> :: <Rule> :: <Capture>\n        method.instructions.insertBefore(location, new InsnNode(SWAP));\n        // stack: <Rule> :: <Capture> :: <Rule>\n        method.instructions.insertBefore(location, new FieldInsnNode(PUTFIELD, internalName, \"contextRule\", RULE_DESC));\n        // stack: <Rule>\n    }\n\n}\n\n","Smelly Sample":"/*\n * Copyright (c) 2009-2010 Ken Wenzel and Mathias Doenitz\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\npackage org.parboiled.transform;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.objectweb.asm.Opcodes;\nimport org.objectweb.asm.Type;\nimport org.objectweb.asm.tree.*;\nimport org.parboiled.support.Checks;\n\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n\nimport static org.parboiled.transform.AsmUtils.getLoadingOpcode;\n\n/**\n * Inserts action group class and capture group call instantiation code at the groups respective placeholders.\n */\nclass RuleMethodRewriter implements RuleMethodProcessor, Opcodes, Types {\n\n    private RuleMethod method;\n    private InstructionGroup group;\n    private int actionNr;\n    private int captureNr;\n    private Map<InstructionGraphNode, Integer> captureVarIndices;\n\n    public boolean appliesTo(@NotNull ParserClassNode classNode, @NotNull RuleMethod method) {\n        return method.containsExplicitActions() || method.containsCaptures();\n    }\n\n    public void process(@NotNull ParserClassNode classNode, @NotNull RuleMethod method) throws Exception {\n        this.method = method;\n        actionNr = 0;\n        captureNr = 0;\n        captureVarIndices = null;\n\n        for (InstructionGroup group : method.getGroups()) {\n            this.group = group;\n            createNewGroupClassInstance();\n            initializeFields();\n            if (group.getRoot().isCaptureRoot()) {\n                insertStoreCapture();\n            }\n            removeGroupRootInstruction();\n        }\n\n        if (method.containsCaptures()) {\n            finalizeCaptureSetup();\n        }\n\n        method.setBodyRewritten();\n    }\n\n    private void createNewGroupClassInstance() {\n        String internalName = group.getGroupClassType().getInternalName();\n        insert(new TypeInsnNode(NEW, internalName));\n        insert(new InsnNode(DUP));\n        insert(new LdcInsnNode(method.name +\n                (group.getRoot().isActionRoot() ? \"_Action\" + ++actionNr : \"_Capture\" + ++captureNr))\n        );\n        insert(new MethodInsnNode(INVOKESPECIAL, internalName, \"<init>\", \"(Ljava/lang/String;)V\"));\n\n        if (method.hasSkipActionsInPredicatesAnnotation()) {\n            insert(new InsnNode(DUP));\n            insert(new MethodInsnNode(INVOKEVIRTUAL, internalName, \"setSkipInPredicates\", \"()V\"));\n        }\n    }\n\n    private void initializeFields() {\n        String internalName = group.getGroupClassType().getInternalName();\n        for (FieldNode field : group.getFields()) {\n            insert(new InsnNode(DUP));\n            // the FieldNodes access and value members have been reused for the var index / Type respectively!\n            insert(new VarInsnNode(getLoadingOpcode((Type) field.value), field.access));\n            insert(new FieldInsnNode(PUTFIELD, internalName, field.name, field.desc));\n        }\n    }\n\n    private void insertStoreCapture() {\n        if (captureVarIndices == null) {\n            captureVarIndices = new HashMap<InstructionGraphNode, Integer>();\n        }\n        int index = method.maxLocals++;\n        captureVarIndices.put(group.getRoot(), index);\n\n        insert(new InsnNode(DUP));\n        insert(new VarInsnNode(ASTORE, index));\n    }\n\n    private void insert(AbstractInsnNode insn) {\n        method.instructions.insertBefore(group.getRoot().getInstruction(), insn);\n    }\n\n    private void removeGroupRootInstruction() {\n        method.instructions.remove(group.getRoot().getInstruction());\n    }\n\n    private void finalizeCaptureSetup() {\n        Set<InstructionGroup> finalizedCaptureGroups = new HashSet<InstructionGroup>();\n        for (InstructionGraphNode node : method.getGraphNodes()) {\n            if (AsmUtils.isCallToRuleCreationMethod(node.getInstruction())) {\n                insertSetContextRuleOnCaptureArguments(node, finalizedCaptureGroups);\n            }\n        }\n        Checks.ensure(finalizedCaptureGroups.size() == captureVarIndices.size(), \"Method '%s' contains illegal \" +\n                \"CAPTURE(...) constructs that are not direct arguments to rule creating methods\", method.name);\n    }\n\n    private void insertSetContextRuleOnCaptureArguments(InstructionGraphNode ruleCreationCall,\n                                                        Set<InstructionGroup> finalizedCaptureGroups) {\n        for (InstructionGraphNode predecessor : ruleCreationCall.getPredecessors()) {\n            if (predecessor.isCaptureRoot()) {\n                insertSetContextRule(ruleCreationCall, predecessor);\n                finalizedCaptureGroups.add(predecessor.getGroup());\n            }\n        }\n    }\n\n    private void insertSetContextRule(InstructionGraphNode ruleCreationCall, InstructionGraphNode argument) {\n        String internalName = argument.getGroup().getGroupClassType().getInternalName();\n        AbstractInsnNode location = ruleCreationCall.getInstruction().getNext();\n        // stack: <Rule>\n        method.instructions.insertBefore(location, new InsnNode(DUP));\n        // stack: <Rule> :: <Rule>\n        method.instructions.insertBefore(location, new VarInsnNode(ALOAD, captureVarIndices.get(argument)));\n        // stack: <Rule> :: <Rule> :: <Capture>\n        method.instructions.insertBefore(location, new InsnNode(SWAP));\n        // stack: <Rule> :: <Capture> :: <Rule>\n        method.instructions.insertBefore(location, new FieldInsnNode(PUTFIELD, internalName, \"contextRule\", RULE_DESC));\n        // stack: <Rule>\n    }\n\n}\n\n","lineNo":66}
{"Refactored Sample":"/*\n * Copyright (c) 2009-2010 Ken Wenzel and Mathias Doenitz\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\npackage org.parboiled.transform;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.objectweb.asm.Opcodes;\nimport org.objectweb.asm.Type;\nimport org.objectweb.asm.tree.*;\nimport org.parboiled.support.Checks;\n\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n\nimport static org.parboiled.transform.AsmUtils.getLoadingOpcode;\n\n/**\n * Inserts action group class and capture group call instantiation code at the groups respective placeholders.\n */\nclass RuleMethodRewriter implements RuleMethodProcessor, Opcodes, Types {\n\n    private RuleMethod method;\n    private InstructionGroup group;\n    private int actionNr;\n    private int captureNr;\n    private int varInitNr;\n    private Map<InstructionGraphNode, Integer> captureVarIndices;\n\n    public boolean appliesTo(@NotNull ParserClassNode classNode, @NotNull RuleMethod method) {\n        return method.containsExplicitActions() || method.containsCaptures() || method.containsVars();\n    }\n\n    public void process(@NotNull ParserClassNode classNode, @NotNull RuleMethod method) throws Exception {\n        this.method = method;\n        actionNr = 0;\n        captureNr = 0;\n        varInitNr = 0;\n        captureVarIndices = null;\n\n        for (InstructionGroup group : method.getGroups()) {\n            this.group = group;\n            createNewGroupClassInstance();\n            initializeFields();\n\n            InstructionGraphNode root = group.getRoot();\n            if (root.isActionRoot()) {\n                removeGroupRootInstruction();\n            } else if (root.isCaptureRoot()) {\n                insertStoreCapture();\n                removeGroupRootInstruction();\n            } else { // if (root.isVarInitRoot())\n                ((MethodInsnNode)root.getInstruction()).desc = \"(Lorg/parboiled/common/Factory;)V\";\n            }\n        }\n\n        if (method.containsCaptures()) {\n            finalizeCaptureSetup();\n        }\n\n        method.setBodyRewritten();\n    }\n\n    private void createNewGroupClassInstance() {\n        String internalName = group.getGroupClassType().getInternalName();\n        InstructionGraphNode root = group.getRoot();\n        insert(new TypeInsnNode(NEW, internalName));\n        insert(new InsnNode(DUP));\n        insert(new LdcInsnNode(method.name +\n                (root.isActionRoot() ? \"_Action\" + ++actionNr :\n                        root.isCaptureRoot() ? \"_Capture\" + ++captureNr : \"_VarInit\" + ++varInitNr))\n        );\n        insert(new MethodInsnNode(INVOKESPECIAL, internalName, \"<init>\", \"(Ljava/lang/String;)V\"));\n\n        if ((root.isActionRoot() || root.isCaptureRoot()) && method.hasSkipActionsInPredicatesAnnotation()) {\n            insert(new InsnNode(DUP));\n            insert(new MethodInsnNode(INVOKEVIRTUAL, internalName, \"setSkipInPredicates\", \"()V\"));\n        }\n    }\n\n    private void initializeFields() {\n        String internalName = group.getGroupClassType().getInternalName();\n        for (FieldNode field : group.getFields()) {\n            insert(new InsnNode(DUP));\n            // the FieldNodes access and value members have been reused for the var index / Type respectively!\n            insert(new VarInsnNode(getLoadingOpcode((Type) field.value), field.access));\n            insert(new FieldInsnNode(PUTFIELD, internalName, field.name, field.desc));\n        }\n    }\n\n    private void insertStoreCapture() {\n        if (captureVarIndices == null) {\n            captureVarIndices = new HashMap<InstructionGraphNode, Integer>();\n        }\n        int index = method.maxLocals++;\n        captureVarIndices.put(group.getRoot(), index);\n\n        insert(new InsnNode(DUP));\n        insert(new VarInsnNode(ASTORE, index));\n    }\n\n    private void insert(AbstractInsnNode insn) {\n        method.instructions.insertBefore(group.getRoot().getInstruction(), insn);\n    }\n\n    private void removeGroupRootInstruction() {\n        method.instructions.remove(group.getRoot().getInstruction());\n    }\n\n    private void finalizeCaptureSetup() {\n        Set<InstructionGroup> finalizedCaptureGroups = new HashSet<InstructionGroup>();\n        for (InstructionGraphNode node : method.getGraphNodes()) {\n            if (AsmUtils.isCallToRuleCreationMethod(node.getInstruction())) {\n                insertSetContextRuleOnCaptureArguments(node, finalizedCaptureGroups);\n            }\n        }\n        Checks.ensure(finalizedCaptureGroups.size() == captureVarIndices.size(), \"Method '%s' contains illegal \" +\n                \"CAPTURE(...) constructs that are not direct arguments to rule creating methods\", method.name);\n    }\n\n    private void insertSetContextRuleOnCaptureArguments(InstructionGraphNode ruleCreationCall,\n                                                        Set<InstructionGroup> finalizedCaptureGroups) {\n        for (InstructionGraphNode predecessor : ruleCreationCall.getPredecessors()) {\n            if (predecessor.isCaptureRoot()) {\n                insertSetContextRule(ruleCreationCall, predecessor);\n                finalizedCaptureGroups.add(predecessor.getGroup());\n            }\n        }\n    }\n\n    private void insertSetContextRule(InstructionGraphNode ruleCreationCall, InstructionGraphNode argument) {\n        String internalName = argument.getGroup().getGroupClassType().getInternalName();\n        AbstractInsnNode location = ruleCreationCall.getInstruction().getNext();\n        // stack: <Rule>\n        method.instructions.insertBefore(location, new InsnNode(DUP));\n        // stack: <Rule> :: <Rule>\n        method.instructions.insertBefore(location, new VarInsnNode(ALOAD, captureVarIndices.get(argument)));\n        // stack: <Rule> :: <Rule> :: <Capture>\n        method.instructions.insertBefore(location, new InsnNode(SWAP));\n        // stack: <Rule> :: <Capture> :: <Rule>\n        method.instructions.insertBefore(location, new FieldInsnNode(PUTFIELD, internalName, \"contextRule\", RULE_DESC));\n        // stack: <Rule>\n    }\n\n}\n\n","Smelly Sample":"/*\n * Copyright (c) 2009-2010 Ken Wenzel and Mathias Doenitz\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\npackage org.parboiled.transform;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.objectweb.asm.Opcodes;\nimport org.objectweb.asm.Type;\nimport org.objectweb.asm.tree.*;\nimport org.parboiled.support.Checks;\n\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n\nimport static org.parboiled.transform.AsmUtils.getLoadingOpcode;\n\n/**\n * Inserts action group class and capture group call instantiation code at the groups respective placeholders.\n */\nclass RuleMethodRewriter implements RuleMethodProcessor, Opcodes, Types {\n\n    private RuleMethod method;\n    private InstructionGroup group;\n    private int actionNr;\n    private int captureNr;\n    private Map<InstructionGraphNode, Integer> captureVarIndices;\n\n    public boolean appliesTo(@NotNull ParserClassNode classNode, @NotNull RuleMethod method) {\n        return method.containsExplicitActions() || method.containsCaptures();\n    }\n\n    public void process(@NotNull ParserClassNode classNode, @NotNull RuleMethod method) throws Exception {\n        this.method = method;\n        actionNr = 0;\n        captureNr = 0;\n        captureVarIndices = null;\n\n        for (InstructionGroup group : method.getGroups()) {\n            this.group = group;\n            createNewGroupClassInstance();\n            initializeFields();\n            if (group.getRoot().isCaptureRoot()) {\n                insertStoreCapture();\n            }\n            removeGroupRootInstruction();\n        }\n\n        if (method.containsCaptures()) {\n            finalizeCaptureSetup();\n        }\n\n        method.setBodyRewritten();\n    }\n\n    private void createNewGroupClassInstance() {\n        String internalName = group.getGroupClassType().getInternalName();\n        insert(new TypeInsnNode(NEW, internalName));\n        insert(new InsnNode(DUP));\n        insert(new LdcInsnNode(method.name +\n                (group.getRoot().isActionRoot() ? \"_Action\" + ++actionNr : \"_Capture\" + ++captureNr))\n        );\n        insert(new MethodInsnNode(INVOKESPECIAL, internalName, \"<init>\", \"(Ljava/lang/String;)V\"));\n\n        if (method.hasSkipActionsInPredicatesAnnotation()) {\n            insert(new InsnNode(DUP));\n            insert(new MethodInsnNode(INVOKEVIRTUAL, internalName, \"setSkipInPredicates\", \"()V\"));\n        }\n    }\n\n    private void initializeFields() {\n        String internalName = group.getGroupClassType().getInternalName();\n        for (FieldNode field : group.getFields()) {\n            insert(new InsnNode(DUP));\n            // the FieldNodes access and value members have been reused for the var index / Type respectively!\n            insert(new VarInsnNode(getLoadingOpcode((Type) field.value), field.access));\n            insert(new FieldInsnNode(PUTFIELD, internalName, field.name, field.desc));\n        }\n    }\n\n    private void insertStoreCapture() {\n        if (captureVarIndices == null) {\n            captureVarIndices = new HashMap<InstructionGraphNode, Integer>();\n        }\n        int index = method.maxLocals++;\n        captureVarIndices.put(group.getRoot(), index);\n\n        insert(new InsnNode(DUP));\n        insert(new VarInsnNode(ASTORE, index));\n    }\n\n    private void insert(AbstractInsnNode insn) {\n        method.instructions.insertBefore(group.getRoot().getInstruction(), insn);\n    }\n\n    private void removeGroupRootInstruction() {\n        method.instructions.remove(group.getRoot().getInstruction());\n    }\n\n    private void finalizeCaptureSetup() {\n        Set<InstructionGroup> finalizedCaptureGroups = new HashSet<InstructionGroup>();\n        for (InstructionGraphNode node : method.getGraphNodes()) {\n            if (AsmUtils.isCallToRuleCreationMethod(node.getInstruction())) {\n                insertSetContextRuleOnCaptureArguments(node, finalizedCaptureGroups);\n            }\n        }\n        Checks.ensure(finalizedCaptureGroups.size() == captureVarIndices.size(), \"Method '%s' contains illegal \" +\n                \"CAPTURE(...) constructs that are not direct arguments to rule creating methods\", method.name);\n    }\n\n    private void insertSetContextRuleOnCaptureArguments(InstructionGraphNode ruleCreationCall,\n                                                        Set<InstructionGroup> finalizedCaptureGroups) {\n        for (InstructionGraphNode predecessor : ruleCreationCall.getPredecessors()) {\n            if (predecessor.isCaptureRoot()) {\n                insertSetContextRule(ruleCreationCall, predecessor);\n                finalizedCaptureGroups.add(predecessor.getGroup());\n            }\n        }\n    }\n\n    private void insertSetContextRule(InstructionGraphNode ruleCreationCall, InstructionGraphNode argument) {\n        String internalName = argument.getGroup().getGroupClassType().getInternalName();\n        AbstractInsnNode location = ruleCreationCall.getInstruction().getNext();\n        // stack: <Rule>\n        method.instructions.insertBefore(location, new InsnNode(DUP));\n        // stack: <Rule> :: <Rule>\n        method.instructions.insertBefore(location, new VarInsnNode(ALOAD, captureVarIndices.get(argument)));\n        // stack: <Rule> :: <Rule> :: <Capture>\n        method.instructions.insertBefore(location, new InsnNode(SWAP));\n        // stack: <Rule> :: <Capture> :: <Rule>\n        method.instructions.insertBefore(location, new FieldInsnNode(PUTFIELD, internalName, \"contextRule\", RULE_DESC));\n        // stack: <Rule>\n    }\n\n}\n\n","lineNo":86}
{"Refactored Sample":"/*\n * Copyright (c) 2009-2010 Ken Wenzel and Mathias Doenitz\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\npackage org.parboiled.transform;\n\nimport com.google.common.base.Preconditions;\nimport org.jetbrains.annotations.NotNull;\nimport org.objectweb.asm.Opcodes;\nimport org.objectweb.asm.tree.FieldInsnNode;\nimport org.objectweb.asm.tree.InsnList;\nimport org.objectweb.asm.tree.MethodInsnNode;\nimport org.parboiled.support.Checks;\n\nimport java.lang.reflect.Modifier;\nimport java.util.*;\n\nimport static org.parboiled.transform.AsmUtils.*;\n\nclass InstructionGroupCreator implements RuleMethodProcessor, Opcodes {\n\n    private final Map<String, Integer> memberModifiers = new HashMap<String, Integer>();\n    private RuleMethod method;\n\n    public boolean appliesTo(@NotNull RuleMethod method) {\n        return method.containsExplicitActions() || method.containsCaptures();\n    }\n\n    public void process(@NotNull ParserClassNode classNode, @NotNull RuleMethod method) {\n        this.method = method;\n\n        // create groups\n        createActionAndCaptureGroups();\n\n        // prepare groups for later stages\n        for (InstructionGroup group : method.getGroups()) {\n            sort(group);\n            markUngroupedEnclosedNodes(group);\n            verify(group);\n        }\n\n        // check all non-group node for illegal accesses\n        for (InstructionGraphNode node : method.getGraphNodes()) {\n            if (node.getGroup() == null) {\n                verifyAccess(node);\n            }\n        }\n    }\n\n    private void createActionAndCaptureGroups() {\n        for (InstructionGraphNode node : method.getGraphNodes()) {\n            if (node.isActionRoot() || node.isCaptureRoot()) {\n                InstructionGroup group = new InstructionGroup(node);\n                markGroup(node, group);\n                method.getGroups().add(group);\n            }\n        }\n    }\n\n    private void markGroup(InstructionGraphNode node, InstructionGroup group) {\n        Checks.ensure(node == group.getRoot() || (!node.isCaptureRoot() && !node.isActionRoot()),\n                \"Method '%s' contains illegal nesting of ACTION(...) and/or CAPTURE(...) constructs\", method.name);\n\n        if (node.getGroup() != null) return; // already visited\n\n        node.setGroup(group);\n        if (!node.isXLoad()) {\n            for (InstructionGraphNode pred : node.getPredecessors()) {\n                markGroup(pred, group);\n            }\n        }\n    }\n\n    // sort the group instructions according to their method index\n    private void sort(InstructionGroup group) {\n        final InsnList instructions = method.instructions;\n        Collections.sort(group.getNodes(), new Comparator<InstructionGraphNode>() {\n            public int compare(InstructionGraphNode a, InstructionGraphNode b) {\n                return Integer.valueOf(instructions.indexOf(a.getInstruction()))\n                        .compareTo(instructions.indexOf(b.getInstruction()));\n            }\n        });\n    }\n\n    // also capture all group nodes \"hidden\" behind xLoads\n    private void markUngroupedEnclosedNodes(InstructionGroup group) {\n        while_:\n        while (true) {\n            for (int i = getIndexOfFirstInsn(group), max = getIndexOfLastInsn(group); i < max; i++) {\n                InstructionGraphNode node = method.getGraphNodes().get(i);\n                if (node.getGroup() == null) {\n                    markGroup(node, group);\n                    sort(group);\n                    continue while_;\n                }\n            }\n            break;\n        }\n    }\n\n    private void verify(InstructionGroup group) {\n        List<InstructionGraphNode> nodes = group.getNodes();\n        int sizeMinus1 = nodes.size() - 1;\n\n        // verify all instruction except for the last one (which must be the root)\n        Preconditions.checkState(nodes.get(sizeMinus1) == group.getRoot());\n        for (int i = 0; i < sizeMinus1; i++) {\n            InstructionGraphNode node = nodes.get(i);\n            Checks.ensure(!node.isXStore(), \"An ACTION or CAPTURE in rule method '%s' contains illegal writes to a \" +\n                    \"local variable or parameter\", method.name);\n            verifyAccess(node);\n        }\n\n        Checks.ensure(getIndexOfLastInsn(group) - getIndexOfFirstInsn(group) == sizeMinus1,\n                \"Error during bytecode analysis of rule method '%s': Incontinuous group block\", method.name);\n    }\n\n    private void verifyAccess(InstructionGraphNode node) {\n        switch (node.getInstruction().getOpcode()) {\n            case GETFIELD:\n            case GETSTATIC:\n                FieldInsnNode field = (FieldInsnNode) node.getInstruction();\n                Checks.ensure(!isPrivateField(field.owner, field.name),\n                        \"Rule method '%s' contains an illegal access to private field '%s'.\\n\" +\n                                \"Mark the field protected or package-private if you want to prevent public access!\",\n                        method.name, field.name);\n                break;\n\n            case INVOKEVIRTUAL:\n            case INVOKESTATIC:\n            case INVOKESPECIAL:\n            case INVOKEINTERFACE:\n                MethodInsnNode calledMethod = (MethodInsnNode) node.getInstruction();\n                Checks.ensure(!isPrivate(calledMethod.owner, calledMethod.name, calledMethod.desc),\n                        \"Rule method '%s' contains an illegal call to private method '%s'.\\nMark '%s' protected or \" +\n                                \"package-private if you want to prevent public access!\",\n                        method.name, calledMethod.name, calledMethod.name);\n                break;\n        }\n    }\n\n    private int getIndexOfFirstInsn(InstructionGroup group) {\n        return method.instructions.indexOf(group.getNodes().get(0).getInstruction());\n    }\n\n    private int getIndexOfLastInsn(InstructionGroup group) {\n        List<InstructionGraphNode> graphNodes = group.getNodes();\n        return method.instructions.indexOf(graphNodes.get(graphNodes.size() - 1).getInstruction());\n    }\n\n    private boolean isPrivateField(String owner, String name) {\n        String key = owner + '#' + name;\n        Integer modifiers = memberModifiers.get(key);\n        if (modifiers == null) {\n            modifiers = getClassField(owner, name).getModifiers();\n            memberModifiers.put(key, modifiers);\n        }\n        return Modifier.isPrivate(modifiers);\n    }\n\n    private boolean isPrivate(String owner, String name, String desc) {\n        return \"<init>\".equals(name) ? isPrivateInstantiation(owner, desc) : isPrivateMethod(owner, name, desc);\n    }\n\n    private boolean isPrivateMethod(String owner, String name, String desc) {\n        String key = owner + '#' + name + '#' + desc;\n        Integer modifiers = memberModifiers.get(key);\n        if (modifiers == null) {\n            modifiers = getClassMethod(owner, name, desc).getModifiers();\n            memberModifiers.put(key, modifiers);\n        }\n        return Modifier.isPrivate(modifiers);\n    }\n\n    private boolean isPrivateInstantiation(String owner, String desc) {\n        // first check whether the class is private\n        Integer modifiers = memberModifiers.get(owner);\n        if (modifiers == null) {\n            modifiers = getClassForInternalName(owner).getModifiers();\n            memberModifiers.put(owner, modifiers);\n        }\n        if (Modifier.isPrivate(modifiers)) return true;\n\n        // then check whether the selected constructor is private\n        String key = owner + \"#<init>#\" + desc;\n        modifiers = memberModifiers.get(key);\n        if (modifiers == null) {\n            modifiers = getClassConstructor(owner, desc).getModifiers();\n            memberModifiers.put(key, modifiers);\n        }\n        return Modifier.isPrivate(modifiers);\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (c) 2009-2010 Ken Wenzel and Mathias Doenitz\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\npackage org.parboiled.transform;\n\nimport com.google.common.base.Preconditions;\nimport org.jetbrains.annotations.NotNull;\nimport org.objectweb.asm.Opcodes;\nimport org.objectweb.asm.tree.FieldInsnNode;\nimport org.objectweb.asm.tree.InsnList;\nimport org.objectweb.asm.tree.MethodInsnNode;\nimport org.parboiled.support.Checks;\n\nimport java.lang.reflect.Modifier;\nimport java.util.*;\n\nimport static org.parboiled.transform.AsmUtils.*;\n\nclass InstructionGroupCreator implements RuleMethodProcessor, Opcodes {\n\n    private final Map<String, Integer> memberModifiers = new HashMap<String, Integer>();\n    private RuleMethod method;\n\n    public boolean appliesTo(@NotNull RuleMethod method) {\n        return method.containsExplicitActions() || method.containsCaptures();\n    }\n\n    public void process(@NotNull ParserClassNode classNode, @NotNull RuleMethod method) {\n        this.method = method;\n\n        // create groups\n        createActionAndCaptureGroups();\n\n        // prepare groups for later stages\n        for (InstructionGroup group : method.getGroups()) {\n            sort(group);\n            markUngroupedEnclosedNodes(group);\n            verify(group);\n        }\n    }\n\n    private void createActionAndCaptureGroups() {\n        for (InstructionGraphNode node : method.getGraphNodes()) {\n            if (node.isActionRoot() || node.isCaptureRoot()) {\n                InstructionGroup group = new InstructionGroup(node);\n                markGroup(node, group);\n                method.getGroups().add(group);\n            }\n        }\n    }\n\n    private void markGroup(InstructionGraphNode node, InstructionGroup group) {\n        Checks.ensure(node == group.getRoot() || (!node.isCaptureRoot() && !node.isActionRoot()),\n                \"Method '%s' contains illegal nesting of ACTION(...) and/or CAPTURE(...) constructs\", method.name);\n\n        if (node.getGroup() != null) return; // already visited\n\n        node.setGroup(group);\n        if (!node.isXLoad()) {\n            for (InstructionGraphNode pred : node.getPredecessors()) {\n                markGroup(pred, group);\n            }\n        }\n    }\n\n    // sort the group instructions according to their method index\n    private void sort(InstructionGroup group) {\n        final InsnList instructions = method.instructions;\n        Collections.sort(group.getNodes(), new Comparator<InstructionGraphNode>() {\n            public int compare(InstructionGraphNode a, InstructionGraphNode b) {\n                return Integer.valueOf(instructions.indexOf(a.getInstruction()))\n                        .compareTo(instructions.indexOf(b.getInstruction()));\n            }\n        });\n    }\n\n    // also capture all group nodes \"hidden\" behind xLoads\n    private void markUngroupedEnclosedNodes(InstructionGroup group) {\n        while_:\n        while (true) {\n            for (int i = getIndexOfFirstInsn(group), max = getIndexOfLastInsn(group); i < max; i++) {\n                InstructionGraphNode node = method.getGraphNodes().get(i);\n                if (node.getGroup() == null) {\n                    markGroup(node, group);\n                    sort(group);\n                    continue while_;\n                }\n            }\n            break;\n        }\n    }\n\n    private void verify(InstructionGroup group) {\n        List<InstructionGraphNode> nodes = group.getNodes();\n        int sizeMinus1 = nodes.size() - 1;\n\n        // verify all instruction except for the last one (which must be the root)\n        Preconditions.checkState(nodes.get(sizeMinus1) == group.getRoot());\n        for (int i = 0; i < sizeMinus1; i++) {\n            verify(nodes.get(i));\n        }\n\n        Checks.ensure(getIndexOfLastInsn(group) - getIndexOfFirstInsn(group) == sizeMinus1,\n                \"Error during bytecode analysis of rule method '%s': Incontinuous group block\", method.name);\n    }\n\n    private void verify(InstructionGraphNode node) {\n        Checks.ensure(!node.isXStore(), \"An ACTION or CAPTURE in rule method '%s' contains illegal writes to a \" +\n                \"local variable or parameter\", method.name);\n\n        switch (node.getInstruction().getOpcode()) {\n            case GETFIELD:\n            case GETSTATIC:\n                FieldInsnNode field = (FieldInsnNode) node.getInstruction();\n                Checks.ensure(!isPrivateField(field.owner, field.name),\n                        \"Rule method '%s' contains an illegal access to private field '%s'.\\n\" +\n                                \"Mark the field protected or package-private if you want to prevent public access!\",\n                        method.name, field.name);\n                break;\n\n            case INVOKEVIRTUAL:\n            case INVOKESTATIC:\n            case INVOKESPECIAL:\n            case INVOKEINTERFACE:\n                MethodInsnNode calledMethod = (MethodInsnNode) node.getInstruction();\n                Checks.ensure(!isPrivate(calledMethod.owner, calledMethod.name, calledMethod.desc),\n                        \"Rule method '%s' contains an illegal call to private method '%s'.\\nMark '%s' protected or \" +\n                                \"package-private if you want to prevent public access!\",\n                        method.name, calledMethod.name, calledMethod.name);\n                break;\n        }\n    }\n\n    private int getIndexOfFirstInsn(InstructionGroup group) {\n        return method.instructions.indexOf(group.getNodes().get(0).getInstruction());\n    }\n\n    private int getIndexOfLastInsn(InstructionGroup group) {\n        List<InstructionGraphNode> graphNodes = group.getNodes();\n        return method.instructions.indexOf(graphNodes.get(graphNodes.size() - 1).getInstruction());\n    }\n\n    private boolean isPrivateField(String owner, String name) {\n        String key = owner + '#' + name;\n        Integer modifiers = memberModifiers.get(key);\n        if (modifiers == null) {\n            modifiers = getClassField(owner, name).getModifiers();\n            memberModifiers.put(key, modifiers);\n        }\n        return Modifier.isPrivate(modifiers);\n    }\n\n    private boolean isPrivate(String owner, String name, String desc) {\n        return \"<init>\".equals(name) ? isPrivateInstantiation(owner, desc) : isPrivateMethod(owner, name, desc);\n    }\n\n    private boolean isPrivateMethod(String owner, String name, String desc) {\n        String key = owner + '#' + name + '#' + desc;\n        Integer modifiers = memberModifiers.get(key);\n        if (modifiers == null) {\n            modifiers = getClassMethod(owner, name, desc).getModifiers();\n            memberModifiers.put(key, modifiers);\n        }\n        return Modifier.isPrivate(modifiers);\n    }\n\n    private boolean isPrivateInstantiation(String owner, String desc) {\n        // first check whether the class is private\n        Integer modifiers = memberModifiers.get(owner);\n        if (modifiers == null) {\n            modifiers = getClassForInternalName(owner).getModifiers();\n            memberModifiers.put(owner, modifiers);\n        }\n        if (Modifier.isPrivate(modifiers)) return true;\n\n        // then check whether the selected constructor is private\n        String key = owner + \"#<init>#\" + desc;\n        modifiers = memberModifiers.get(key);\n        if (modifiers == null) {\n            modifiers = getClassConstructor(owner, desc).getModifiers();\n            memberModifiers.put(key, modifiers);\n        }\n        return Modifier.isPrivate(modifiers);\n    }\n\n}\n","lineNo":126}
{"Refactored Sample":"/*\n * Copyright (C) 2009-2010 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.examples.java;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.Parboiled;\nimport org.parboiled.ReportingParseRunner;\nimport org.parboiled.Rule;\nimport org.parboiled.support.ParsingResult;\n\nimport java.io.*;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.parboiled.errors.ErrorUtils.printParseErrors;\n\npublic class Main {\n\n    @SuppressWarnings({\"ConstantConditions\"})\n    public static void main(String[] args) {\n        System.out.println(\"parboiled Java parser, performance test\");\n        System.out.println(\"---------------------------------------\");\n\n        System.out.print(\"Creating parser... :\");\n        long start = System.currentTimeMillis();\n        Parboiled.createParser(JavaParser.class);\n        time(start);\n\n        System.out.print(\"Creating 100 more parser instances... :\");\n        JavaParser parser = null;\n        start = System.currentTimeMillis();\n        for (int i = 0; i < 100; i++) {\n            parser = Parboiled.createParser(JavaParser.class);\n        }\n        time(start);\n\n        System.out.print(\"Creating 100 more parser instances using BaseParser.newInstance() ... :\");\n        start = System.currentTimeMillis();\n        for (int i = 0; i < 100; i++) {\n            parser = parser.newInstance();\n        }\n        time(start);\n\n        start = System.currentTimeMillis();\n        System.out.print(\"Retrieving file list...\");\n        List<File> sources = recursiveGetAllJavaSources(new File(\".\"), new ArrayList<File>());\n        time(start);\n\n        System.out.printf(\"Parsing all %s parboiled java sources\", sources.size());\n        Rule rootRule = parser.CompilationUnit().suppressSubnodes(); // we want to see the parse-tree-less performance\n        start = System.currentTimeMillis();\n        int lines = 0, characters = 0;\n        for (File sourceFile : sources) {\n            long dontCountStart = System.currentTimeMillis();\n            String sourceText = readAllText(sourceFile);\n            start += System.currentTimeMillis() - dontCountStart; // do not count the time for reading the text file\n            \n            ParsingResult<Object> result = ReportingParseRunner.run(rootRule, sourceText);\n            if (!result.matched) {\n                System.out.printf(\"\\nParse error(s) in file '%s':\\n%s\",\n                        sourceFile,\n                        printParseErrors(result.parseErrors, result.inputBuffer));\n                System.exit(1);\n            } else {\n                System.out.print('.');\n            }\n            lines += result.totalRows;\n            characters += result.inputBuffer.getBuffer().length;\n        }\n        long time = time(start);\n\n        System.out.println(\"Parsing statistics:\");\n        System.out.printf(\"    %6d Files -> %6.2f Files/sec\\n\", sources.size(), sources.size() * 1000.0 / time);\n        System.out.printf(\"    %6d Lines -> %6d Lines/sec\\n\", lines, lines * 1000 / time);\n        System.out.printf(\"    %6d Chars -> %6d Chars/sec\\n\", characters, characters * 1000 / time);\n    }\n\n    private static long time(long start) {\n        long end = System.currentTimeMillis();\n        System.out.printf(\" %s ms\\n\", end - start);\n        return end - start;\n    }\n\n    private static final FileFilter fileFilter = new FileFilter() {\n        public boolean accept(File file) {\n            return file.isDirectory() || file.getName().endsWith(\".java\");\n        }\n    };\n\n    private static List<File> recursiveGetAllJavaSources(File file, ArrayList<File> list) {\n        File[] files = file.listFiles(fileFilter);\n        for (File f : files) {\n            if (f.isDirectory()) {\n                recursiveGetAllJavaSources(f, list);\n            } else {\n                list.add(f);\n            }\n        }\n        return list;\n    }\n\n    public static String readAllText(@NotNull File file) {\n        return readAllText(file, Charset.forName(\"UTF8\"));\n    }\n\n    public static String readAllText(@NotNull File file, @NotNull Charset charset) {\n        try {\n            return readAllText(new FileInputStream(file), charset);\n        }\n        catch (FileNotFoundException e) {\n            return null;\n        }\n    }\n\n    public static String readAllText(InputStream stream, @NotNull Charset charset) {\n        if (stream == null) return null;\n        BufferedReader reader = new BufferedReader(new InputStreamReader(stream, charset));\n        StringWriter writer = new StringWriter();\n        copyAll(reader, writer);\n        return writer.toString();\n    }\n\n    public static void copyAll(@NotNull Reader reader, @NotNull Writer writer) {\n        try {\n            char[] data = new char[4096]; // copy in chunks of 4K\n            int count;\n            while ((count = reader.read(data)) >= 0) writer.write(data, 0, count);\n\n            reader.close();\n            writer.close();\n        }\n        catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009-2010 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.examples.java;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.Parboiled;\nimport org.parboiled.ReportingParseRunner;\nimport org.parboiled.support.ParsingResult;\n\nimport java.io.*;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.parboiled.errors.ErrorUtils.printParseErrors;\n\npublic class Main {\n\n    @SuppressWarnings({\"ConstantConditions\"})\n    public static void main(String[] args) {\n        System.out.println(\"parboiled Java parser, performance test\");\n        System.out.println(\"---------------------------------------\");\n\n        System.out.print(\"Creating parser... :\");\n        long start = System.currentTimeMillis();\n        Parboiled.createParser(JavaParser.class);\n        time(start);\n\n        System.out.print(\"Creating 100 more parser instances... :\");\n        JavaParser parser = null;\n        start = System.currentTimeMillis();\n        for (int i = 0; i < 100; i++) {\n            parser = Parboiled.createParser(JavaParser.class);\n        }\n        time(start);\n\n        System.out.print(\"Creating 100 more parser instances using BaseParser.newInstance() ... :\");\n        start = System.currentTimeMillis();\n        for (int i = 0; i < 100; i++) {\n            parser = parser.newInstance();\n        }\n        time(start);\n\n        start = System.currentTimeMillis();\n        System.out.print(\"Retrieving file list...\");\n        List<File> sources = recursiveGetAllJavaSources(new File(\".\"), new ArrayList<File>());\n        time(start);\n\n        System.out.printf(\"Parsing all %s parboiled java sources\", sources.size());\n        start = System.currentTimeMillis();\n        int lines = 0, characters = 0;\n        for (File sourceFile : sources) {\n            long dontCountStart = System.currentTimeMillis();\n            String sourceText = readAllText(sourceFile);\n            start += System.currentTimeMillis() - dontCountStart; // do not count the time for reading the text file\n\n            ParsingResult<Object> result = ReportingParseRunner.run(parser.CompilationUnit(), sourceText);\n            if (!result.matched) {\n                System.out.printf(\"\\nParse error(s) in file '%s':\\n%s\",\n                        sourceFile,\n                        printParseErrors(result.parseErrors, result.inputBuffer));\n                System.exit(1);\n            } else {\n                System.out.print('.');\n            }\n            lines += result.totalRows;\n            characters += result.inputBuffer.getBuffer().length;\n        }\n        long time = time(start);\n\n        System.out.println(\"Parsing statistics:\");\n        System.out.printf(\"    %6d Files -> %6.2f Files/sec\\n\", sources.size(), sources.size() * 1000.0 / time);\n        System.out.printf(\"    %6d Lines -> %6d Lines/sec\\n\", lines, lines * 1000 / time);\n        System.out.printf(\"    %6d Chars -> %6d Chars/sec\\n\", characters, characters * 1000 / time);\n    }\n\n    private static long time(long start) {\n        long end = System.currentTimeMillis();\n        System.out.printf(\" %s ms\\n\", end - start);\n        return end - start;\n    }\n\n    private static final FileFilter fileFilter = new FileFilter() {\n        public boolean accept(File file) {\n            return file.isDirectory() || file.getName().endsWith(\".java\");\n        }\n    };\n\n    private static List<File> recursiveGetAllJavaSources(File file, ArrayList<File> list) {\n        File[] files = file.listFiles(fileFilter);\n        for (File f : files) {\n            if (f.isDirectory()) {\n                recursiveGetAllJavaSources(f, list);\n            } else {\n                list.add(f);\n            }\n        }\n        return list;\n    }\n\n    public static String readAllText(@NotNull File file) {\n        return readAllText(file, Charset.forName(\"UTF8\"));\n    }\n\n    public static String readAllText(@NotNull File file, @NotNull Charset charset) {\n        try {\n            return readAllText(new FileInputStream(file), charset);\n        }\n        catch (FileNotFoundException e) {\n            return null;\n        }\n    }\n\n    public static String readAllText(InputStream stream, @NotNull Charset charset) {\n        if (stream == null) return null;\n        BufferedReader reader = new BufferedReader(new InputStreamReader(stream, charset));\n        StringWriter writer = new StringWriter();\n        copyAll(reader, writer);\n        return writer.toString();\n    }\n\n    public static void copyAll(@NotNull Reader reader, @NotNull Writer writer) {\n        try {\n            char[] data = new char[4096]; // copy in chunks of 4K\n            int count;\n            while ((count = reader.read(data)) >= 0) writer.write(data, 0, count);\n\n            reader.close();\n            writer.close();\n        }\n        catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n}\n","lineNo":65}
{"Refactored Sample":"/*\n * Copyright (C) 2009-2010 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled;\n\nimport org.parboiled.test.AbstractTest;\nimport org.testng.annotations.Test;\n\npublic class ParserInheritanceTest extends AbstractTest {\n\n    public static class Actions extends BaseActions<Object> {\n        public boolean dummyAction() {\n            return true;\n        }\n    }\n\n    public static class ParentParser extends BaseParser<Object> {\n        public Actions actions = new Actions();\n\n        public Rule Abcd() {\n            return Sequence(\"ab\", \"cd\", actions.dummyAction());\n        }\n\n    }\n\n    public static class DerivedParser extends ParentParser {\n        public Rule Abcds() {\n            return Sequence(OneOrMore(Abcd()), actions.dummyAction());\n        }\n    }\n\n    @Test\n    public void test() {\n        ParentParser parentParser = Parboiled.createParser(ParentParser.class);\n        test(parentParser.Abcd(), \"abcd\", \"\" +\n                \"[Abcd] 'abcd'\\n\" +\n                \"    [\\\"ab\\\"] 'ab'\\n\" +\n                \"    [\\\"cd\\\"] 'cd'\\n\");\n        \n        DerivedParser derivedParser = Parboiled.createParser(DerivedParser.class);\n        Rule rule = derivedParser.Abcds();\n        test(rule, \"abcdabcd\", \"\" +\n                \"[Abcds] 'abcdabcd'\\n\" +\n                \"    [OneOrMore] 'abcdabcd'\\n\" +\n                \"        [Abcd] 'abcd'\\n\" +\n                \"            [\\\"ab\\\"] 'ab'\\n\" +\n                \"            [\\\"cd\\\"] 'cd'\\n\" +\n                \"        [Abcd] 'abcd'\\n\" +\n                \"            [\\\"ab\\\"] 'ab'\\n\" +\n                \"            [\\\"cd\\\"] 'cd'\\n\");\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009-2010 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled;\n\nimport org.parboiled.test.AbstractTest;\nimport org.testng.annotations.Test;\n\npublic class ParserInheritanceTest extends AbstractTest {\n\n    public static class Actions extends BaseActions<Object> {\n        public boolean dummyAction() {\n            System.out.println(\"Dummy New node action\");\n            return true;\n        }\n    }\n\n    public static class ParentParser extends BaseParser<Object> {\n        public Actions actions = new Actions();\n\n        public Rule Abcd() {\n            return Sequence(\"ab\", \"cd\", actions.dummyAction());\n        }\n\n    }\n\n    public static class DerivedParser extends ParentParser {\n        public Rule Abcds() {\n            return Sequence(OneOrMore(Abcd()), actions.dummyAction());\n        }\n    }\n\n    @Test\n    public void test() {\n        ParentParser parentParser = Parboiled.createParser(ParentParser.class);\n        test(parentParser.Abcd(), \"abcd\", \"\" +\n                \"[Abcd] 'abcd'\\n\" +\n                \"    [\\\"ab\\\"] 'ab'\\n\" +\n                \"    [\\\"cd\\\"] 'cd'\\n\");\n        \n        DerivedParser derivedParser = Parboiled.createParser(DerivedParser.class);\n        test(derivedParser.Abcds(), \"abcdabcd\", \"\" +\n                \"[Clause] '1+5'\\n\" +\n                \"    [Digit] '1'\\n\" +\n                \"    [Operator] '+'\\n\" +\n                \"        ['+'] '+'\\n\" +\n                \"    [Digit] '5'\\n\" +\n                \"    [EOI]\\n\");\n    }\n\n}\n","lineNo":54}
{"Refactored Sample":"/*\n * Copyright (c) 2009-2010 Ken Wenzel and Mathias Doenitz\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\npackage org.parboiled.transform;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.objectweb.asm.ClassReader;\nimport org.objectweb.asm.Opcodes;\nimport org.objectweb.asm.Type;\nimport org.objectweb.asm.tree.AbstractInsnNode;\nimport org.objectweb.asm.tree.InsnList;\nimport org.objectweb.asm.tree.MethodInsnNode;\nimport org.objectweb.asm.tree.VarInsnNode;\nimport org.parboiled.BaseParser;\nimport org.parboiled.Capture;\nimport org.parboiled.ContextAware;\nimport org.parboiled.Rule;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\nclass AsmUtils {\n\n    private static final ConcurrentMap<String, Class<?>> classForDesc = new ConcurrentHashMap<String, Class<?>>();\n\n    public static ClassReader createClassReader(@NotNull Class<?> clazz) throws IOException {\n        String classFilename = clazz.getName().replace('.', '/') + \".class\";\n        InputStream inputStream = clazz.getClassLoader().getResourceAsStream(classFilename);\n        return new ClassReader(inputStream);\n    }\n\n    public static String getExtendedParserClassName(@NotNull String parserClassName) {\n        return parserClassName + \"$$parboiled\";\n    }\n\n    public static Class<?> getClassForInternalName(@NotNull String classDesc) {\n        Class<?> clazz = classForDesc.get(classDesc);\n        if (clazz == null) {\n            String className = classDesc.replace('/', '.');\n            try {\n                clazz = Class.forName(className);\n            } catch (ClassNotFoundException e) {\n                throw new RuntimeException(\"Error loading class '\" + className + \"' for rule method analysis\", e);\n            }\n            classForDesc.put(classDesc, clazz);\n        }\n        return clazz;\n    }\n\n    public static Class<?> getClassForType(@NotNull Type type) {\n        switch (type.getSort()) {\n            case Type.BOOLEAN:\n                return boolean.class;\n            case Type.BYTE:\n                return byte.class;\n            case Type.CHAR:\n                return char.class;\n            case Type.DOUBLE:\n                return double.class;\n            case Type.FLOAT:\n                return float.class;\n            case Type.INT:\n                return int.class;\n            case Type.LONG:\n                return long.class;\n            case Type.SHORT:\n                return short.class;\n            case Type.VOID:\n                return void.class;\n            case Type.OBJECT:\n            case Type.ARRAY:\n                return getClassForInternalName(type.getInternalName());\n        }\n        throw new IllegalStateException(); // should be unreachable\n    }\n\n    public static Field getClassField(@NotNull String classInternalName, @NotNull String fieldName) {\n        Class<?> clazz = getClassForInternalName(classInternalName);\n        Class<?> current = clazz;\n        while (true) {\n            try {\n                return current.getDeclaredField(fieldName);\n            } catch (NoSuchFieldException e) {\n                current = current.getSuperclass();\n                if (Object.class.equals(current)) {\n                    throw new RuntimeException(\n                            \"Field '\" + fieldName + \"' not found in '\" + clazz + \"\\' or any superclass\", e);\n                }\n            }\n        }\n    }\n\n    public static Method getClassMethod(@NotNull String classInternalName, @NotNull String methodName,\n                                        @NotNull String methodDesc) {\n        Class<?> clazz = getClassForInternalName(classInternalName);\n        Type[] types = Type.getArgumentTypes(methodDesc);\n        Class<?>[] argTypes = new Class<?>[types.length];\n        for (int i = 0; i < types.length; i++) {\n            argTypes[i] = getClassForType(types[i]);\n        }\n        Class<?> current = clazz;\n        while (true) {\n            try {\n                return current.getDeclaredMethod(methodName, argTypes);\n            } catch (NoSuchMethodException e) {\n                current = current.getSuperclass();\n                if (Object.class.equals(current)) {\n                    throw new RuntimeException(\"Method '\" + methodName + \"' with descriptor '\" +\n                            methodDesc + \"' not found in '\" + clazz + \"\\' or any superclass\", e);\n                }\n            }\n        }\n    }\n\n    public static Constructor getClassConstructor(@NotNull String classInternalName, @NotNull String constructorDesc) {\n        Class<?> clazz = getClassForInternalName(classInternalName);\n        Type[] types = Type.getArgumentTypes(constructorDesc);\n        Class<?>[] argTypes = new Class<?>[types.length];\n        for (int i = 0; i < types.length; i++) {\n            argTypes[i] = getClassForType(types[i]);\n        }\n        try {\n            return clazz.getConstructor(argTypes);\n        } catch (NoSuchMethodException e) {\n            throw new RuntimeException(\"Constructor with descriptor '\" + constructorDesc + \"' not found in '\" +\n                    clazz, e);\n        }\n    }\n\n    /**\n     * Returns the class with the given name if it has already been loaded by the given class loader.\n     * Otherwise the method returns null.\n     *\n     * @param className   the full name of the class to be loaded\n     * @param classLoader the class loader to use\n     * @return the class instance or null\n     */\n    public static Class<?> findLoadedClass(@NotNull String className, @NotNull ClassLoader classLoader) {\n        try {\n            Class<?> classLoaderBaseClass = Class.forName(\"java.lang.ClassLoader\");\n            Method findLoadedClassMethod = classLoaderBaseClass.getDeclaredMethod(\"findLoadedClass\", String.class);\n\n            // protected method invocation\n            findLoadedClassMethod.setAccessible(true);\n            try {\n                return (Class<?>) findLoadedClassMethod.invoke(classLoader, className);\n            } finally {\n                findLoadedClassMethod.setAccessible(false);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not determine whether class '\" + className +\n                    \"' has already been loaded\", e);\n        }\n    }\n\n    /**\n     * Loads the class defined with the given name and bytecode using the given class loader.\n     * Since package and class idendity includes the ClassLoader instance used to load a class we use reflection\n     * on the given class loader to define generated classes. If we used our own class loader (in order to be able\n     * to access the protected \"defineClass\" method) we would likely still be able to load generated classes,\n     * however, they would not have access to package-private classes and members of their super classes.\n     *\n     * @param className   the full name of the class to be loaded\n     * @param code        the bytecode of the class to load\n     * @param classLoader the class loader to use\n     * @return the class instance\n     */\n    public static Class<?> loadClass(@NotNull String className, @NotNull byte[] code,\n                                     @NotNull ClassLoader classLoader) {\n        try {\n            Class<?> classLoaderBaseClass = Class.forName(\"java.lang.ClassLoader\");\n            Method defineClassMethod = classLoaderBaseClass.getDeclaredMethod(\"defineClass\",\n                    String.class, byte[].class, int.class, int.class);\n\n            // protected method invocation\n            defineClassMethod.setAccessible(true);\n            try {\n                return (Class<?>) defineClassMethod.invoke(classLoader, className, code, 0, code.length);\n            } finally {\n                defineClassMethod.setAccessible(false);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load class '\" + className + '\\'', e);\n        }\n    }\n\n    public static InsnList createArgumentLoaders(@NotNull String methodDescriptor) {\n        InsnList instructions = new InsnList();\n        Type[] types = Type.getArgumentTypes(methodDescriptor);\n        for (int i = 0; i < types.length; i++) {\n            instructions.add(new VarInsnNode(getLoadingOpcode(types[i]), i + 1));\n        }\n        return instructions;\n    }\n\n    public static int getLoadingOpcode(@NotNull Type argType) {\n        switch (argType.getSort()) {\n            case Type.BOOLEAN:\n            case Type.BYTE:\n            case Type.CHAR:\n            case Type.SHORT:\n            case Type.INT:\n                return Opcodes.ILOAD;\n            case Type.DOUBLE:\n                return Opcodes.DLOAD;\n            case Type.FLOAT:\n                return Opcodes.FLOAD;\n            case Type.LONG:\n                return Opcodes.LLOAD;\n            case Type.OBJECT:\n            case Type.ARRAY:\n                return Opcodes.ALOAD;\n            default:\n                throw new IllegalStateException();\n        }\n    }\n\n    /**\n     * Determines whether the class with the given descriptor is assignable to the given type.\n     *\n     * @param classInternalName the class descriptor\n     * @param type              the type\n     * @return true if the class with the given descriptor is assignable to the given type\n     */\n    public static boolean isAssignableTo(@NotNull String classInternalName, @NotNull Class<?> type) {\n        return type.isAssignableFrom(getClassForInternalName(classInternalName));\n    }\n\n    public static boolean isBooleanValueOfZ(@NotNull AbstractInsnNode insn) {\n        if (insn.getOpcode() != Opcodes.INVOKESTATIC) return false;\n        MethodInsnNode mi = (MethodInsnNode) insn;\n        return isBooleanValueOfZ(mi.owner, mi.name, mi.desc);\n    }\n\n    public static boolean isBooleanValueOfZ(@NotNull String methodOwner, @NotNull String methodName,\n                                            @NotNull String methodDesc) {\n        return \"java/lang/Boolean\".equals(methodOwner) && \"valueOf\".equals(methodName) &&\n                \"(Z)Ljava/lang/Boolean;\".equals(methodDesc);\n    }\n\n    public static boolean isActionRoot(@NotNull AbstractInsnNode insn) {\n        if (insn.getOpcode() != Opcodes.INVOKESTATIC) return false;\n        MethodInsnNode mi = (MethodInsnNode) insn;\n        return isActionRoot(mi.owner, mi.name);\n    }\n\n    public static boolean isActionRoot(@NotNull String methodOwner, @NotNull String methodName) {\n        return \"ACTION\".equals(methodName) && isAssignableTo(methodOwner, BaseParser.class);\n    }\n\n    public static boolean isCaptureRoot(@NotNull AbstractInsnNode insn) {\n        if (insn.getOpcode() != Opcodes.INVOKESTATIC) return false;\n        MethodInsnNode mi = (MethodInsnNode) insn;\n        return isCaptureRoot(mi.owner, mi.name);\n    }\n\n    public static boolean isCaptureRoot(@NotNull String methodOwner, @NotNull String methodName) {\n        return \"CAPTURE\".equals(methodName) && isAssignableTo(methodOwner, BaseParser.class);\n    }\n\n    public static boolean isContextSwitch(@NotNull AbstractInsnNode insn) {\n        if (insn.getOpcode() != Opcodes.INVOKESTATIC) return false;\n        MethodInsnNode mi = (MethodInsnNode) insn;\n        return isContextSwitch(mi.owner, mi.name);\n    }\n\n    public static boolean isContextSwitch(@NotNull String methodOwner, @NotNull String methodName) {\n        return isAssignableTo(methodOwner, BaseParser.class) &&\n                \"UP/UP2/UP3/UP4/UP5/UP6/DOWN/DOWN2/DOWN3/DOWN4/DOWN5/DOWN6\".contains(methodName);\n    }\n\n    public static boolean isCallOnContextAware(@NotNull AbstractInsnNode insn) {\n        if (insn.getOpcode() != Opcodes.INVOKEVIRTUAL && insn.getOpcode() != Opcodes.INVOKEINTERFACE) return false;\n        MethodInsnNode mi = (MethodInsnNode) insn;\n        return isAssignableTo(mi.owner, ContextAware.class);\n    }\n\n    public static boolean isCaptureGet(@NotNull AbstractInsnNode insn) {\n        if (insn.getOpcode() != Opcodes.INVOKEVIRTUAL && insn.getOpcode() != Opcodes.INVOKEINTERFACE) return false;\n        MethodInsnNode mi = (MethodInsnNode) insn;\n        return \"get\".equals(mi.name) && \"()Ljava/lang/Object;\".equals(mi.desc) &&\n                isAssignableTo(mi.owner, Capture.class);\n    }\n\n    public static boolean isCallToRuleCreationMethod(@NotNull AbstractInsnNode insn) {\n        if (insn.getType() != AbstractInsnNode.METHOD_INSN) return false;\n        MethodInsnNode mi = (MethodInsnNode) insn;\n        Type type = Type.getReturnType(mi.desc);\n        return type.getSort() == Type.OBJECT && isAssignableTo(type.getInternalName(), Rule.class);\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (c) 2009-2010 Ken Wenzel and Mathias Doenitz\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\npackage org.parboiled.transform;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.objectweb.asm.ClassReader;\nimport org.objectweb.asm.Opcodes;\nimport org.objectweb.asm.Type;\nimport org.objectweb.asm.tree.AbstractInsnNode;\nimport org.objectweb.asm.tree.InsnList;\nimport org.objectweb.asm.tree.MethodInsnNode;\nimport org.objectweb.asm.tree.VarInsnNode;\nimport org.parboiled.BaseParser;\nimport org.parboiled.Capture;\nimport org.parboiled.ContextAware;\nimport org.parboiled.Rule;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\nclass AsmUtils {\n\n    private static final ConcurrentMap<String, Class<?>> classForDesc = new ConcurrentHashMap<String, Class<?>>();\n\n    public static ClassReader createClassReader(@NotNull Class<?> clazz) throws IOException {\n        String classFilename = clazz.getName().replace('.', '/') + \".class\";\n        InputStream inputStream = clazz.getClassLoader().getResourceAsStream(classFilename);\n        return new ClassReader(inputStream);\n    }\n\n    public static String getExtendedParserClassName(@NotNull String parserClassName) {\n        return parserClassName + \"$$parboiled\";\n    }\n\n    public static Class<?> getClassForInternalName(@NotNull String classDesc) {\n        Class<?> clazz = classForDesc.get(classDesc);\n        if (clazz == null) {\n            String className = classDesc.replace('/', '.');\n            try {\n                clazz = Class.forName(className);\n            } catch (ClassNotFoundException e) {\n                throw new RuntimeException(\"Error loading class '\" + className + \"' for rule method analysis\", e);\n            }\n            classForDesc.put(classDesc, clazz);\n        }\n        return clazz;\n    }\n\n    public static Class<?> getClassForType(@NotNull Type type) {\n        switch (type.getSort()) {\n            case Type.BOOLEAN:\n                return boolean.class;\n            case Type.BYTE:\n                return byte.class;\n            case Type.CHAR:\n                return char.class;\n            case Type.DOUBLE:\n                return double.class;\n            case Type.FLOAT:\n                return float.class;\n            case Type.INT:\n                return int.class;\n            case Type.LONG:\n                return long.class;\n            case Type.SHORT:\n                return short.class;\n            case Type.VOID:\n                return void.class;\n            case Type.OBJECT:\n            case Type.ARRAY:\n                return getClassForInternalName(type.getInternalName());\n        }\n        throw new IllegalStateException(); // should be unreachable\n    }\n\n    public static Field getClassField(@NotNull String classInternalName, @NotNull String fieldName) {\n        Class<?> clazz = getClassForInternalName(classInternalName);\n        try {\n            return clazz.getDeclaredField(fieldName);\n        } catch (NoSuchFieldException e) {\n            throw new RuntimeException(\"Could not get field '\" + fieldName + \"' of class '\" + clazz + '\\'', e);\n        }\n    }\n\n    public static Method getClassMethod(@NotNull String classInternalName, @NotNull String methodName,\n                                        @NotNull String methodDesc) {\n        Class<?> clazz = getClassForInternalName(classInternalName);\n        Type[] types = Type.getArgumentTypes(methodDesc);\n        Class<?>[] argTypes = new Class<?>[types.length];\n        for (int i = 0; i < types.length; i++) {\n            argTypes[i] = getClassForType(types[i]);\n        }\n        Class<?> current = clazz;\n        while (true) {\n            try {\n                return current.getDeclaredMethod(methodName, argTypes);\n            } catch (NoSuchMethodException e) {\n                current = current.getSuperclass();\n                if (Object.class.equals(current)) {\n                    throw new RuntimeException(\"Method '\" + methodName + \"' with descriptor '\" +\n                            methodDesc + \"' not found in '\" + clazz + \"\\' or any superclass\", e);\n                }\n            }\n        }\n    }\n\n    public static Constructor getClassConstructor(@NotNull String classInternalName, @NotNull String constructorDesc) {\n        Class<?> clazz = getClassForInternalName(classInternalName);\n        Type[] types = Type.getArgumentTypes(constructorDesc);\n        Class<?>[] argTypes = new Class<?>[types.length];\n        for (int i = 0; i < types.length; i++) {\n            argTypes[i] = getClassForType(types[i]);\n        }\n        try {\n            return clazz.getConstructor(argTypes);\n        } catch (NoSuchMethodException e) {\n            throw new RuntimeException(\"Constructor with descriptor '\" + constructorDesc + \"' not found in '\" +\n                    clazz, e);\n        }\n    }\n\n    /**\n     * Returns the class with the given name if it has already been loaded by the given class loader.\n     * Otherwise the method returns null.\n     *\n     * @param className   the full name of the class to be loaded\n     * @param classLoader the class loader to use\n     * @return the class instance or null\n     */\n    public static Class<?> findLoadedClass(@NotNull String className, @NotNull ClassLoader classLoader) {\n        try {\n            Class<?> classLoaderBaseClass = Class.forName(\"java.lang.ClassLoader\");\n            Method findLoadedClassMethod = classLoaderBaseClass.getDeclaredMethod(\"findLoadedClass\", String.class);\n\n            // protected method invocation\n            findLoadedClassMethod.setAccessible(true);\n            try {\n                return (Class<?>) findLoadedClassMethod.invoke(classLoader, className);\n            } finally {\n                findLoadedClassMethod.setAccessible(false);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not determine whether class '\" + className +\n                    \"' has already been loaded\", e);\n        }\n    }\n\n    /**\n     * Loads the class defined with the given name and bytecode using the given class loader.\n     * Since package and class idendity includes the ClassLoader instance used to load a class we use reflection\n     * on the given class loader to define generated classes. If we used our own class loader (in order to be able\n     * to access the protected \"defineClass\" method) we would likely still be able to load generated classes,\n     * however, they would not have access to package-private classes and members of their super classes.\n     *\n     * @param className   the full name of the class to be loaded\n     * @param code        the bytecode of the class to load\n     * @param classLoader the class loader to use\n     * @return the class instance\n     */\n    public static Class<?> loadClass(@NotNull String className, @NotNull byte[] code,\n                                     @NotNull ClassLoader classLoader) {\n        try {\n            Class<?> classLoaderBaseClass = Class.forName(\"java.lang.ClassLoader\");\n            Method defineClassMethod = classLoaderBaseClass.getDeclaredMethod(\"defineClass\",\n                    String.class, byte[].class, int.class, int.class);\n\n            // protected method invocation\n            defineClassMethod.setAccessible(true);\n            try {\n                return (Class<?>) defineClassMethod.invoke(classLoader, className, code, 0, code.length);\n            } finally {\n                defineClassMethod.setAccessible(false);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load class '\" + className + '\\'', e);\n        }\n    }\n\n    public static InsnList createArgumentLoaders(@NotNull String methodDescriptor) {\n        InsnList instructions = new InsnList();\n        Type[] types = Type.getArgumentTypes(methodDescriptor);\n        for (int i = 0; i < types.length; i++) {\n            instructions.add(new VarInsnNode(getLoadingOpcode(types[i]), i + 1));\n        }\n        return instructions;\n    }\n\n    public static int getLoadingOpcode(@NotNull Type argType) {\n        switch (argType.getSort()) {\n            case Type.BOOLEAN:\n            case Type.BYTE:\n            case Type.CHAR:\n            case Type.SHORT:\n            case Type.INT:\n                return Opcodes.ILOAD;\n            case Type.DOUBLE:\n                return Opcodes.DLOAD;\n            case Type.FLOAT:\n                return Opcodes.FLOAD;\n            case Type.LONG:\n                return Opcodes.LLOAD;\n            case Type.OBJECT:\n            case Type.ARRAY:\n                return Opcodes.ALOAD;\n            default:\n                throw new IllegalStateException();\n        }\n    }\n\n    /**\n     * Determines whether the class with the given descriptor is assignable to the given type.\n     *\n     * @param classInternalName the class descriptor\n     * @param type              the type\n     * @return true if the class with the given descriptor is assignable to the given type\n     */\n    public static boolean isAssignableTo(@NotNull String classInternalName, @NotNull Class<?> type) {\n        return type.isAssignableFrom(getClassForInternalName(classInternalName));\n    }\n\n    public static boolean isBooleanValueOfZ(@NotNull AbstractInsnNode insn) {\n        if (insn.getOpcode() != Opcodes.INVOKESTATIC) return false;\n        MethodInsnNode mi = (MethodInsnNode) insn;\n        return isBooleanValueOfZ(mi.owner, mi.name, mi.desc);\n    }\n\n    public static boolean isBooleanValueOfZ(@NotNull String methodOwner, @NotNull String methodName,\n                                            @NotNull String methodDesc) {\n        return \"java/lang/Boolean\".equals(methodOwner) && \"valueOf\".equals(methodName) &&\n                \"(Z)Ljava/lang/Boolean;\".equals(methodDesc);\n    }\n\n    public static boolean isActionRoot(@NotNull AbstractInsnNode insn) {\n        if (insn.getOpcode() != Opcodes.INVOKESTATIC) return false;\n        MethodInsnNode mi = (MethodInsnNode) insn;\n        return isActionRoot(mi.owner, mi.name);\n    }\n\n    public static boolean isActionRoot(@NotNull String methodOwner, @NotNull String methodName) {\n        return \"ACTION\".equals(methodName) && isAssignableTo(methodOwner, BaseParser.class);\n    }\n\n    public static boolean isCaptureRoot(@NotNull AbstractInsnNode insn) {\n        if (insn.getOpcode() != Opcodes.INVOKESTATIC) return false;\n        MethodInsnNode mi = (MethodInsnNode) insn;\n        return isCaptureRoot(mi.owner, mi.name);\n    }\n\n    public static boolean isCaptureRoot(@NotNull String methodOwner, @NotNull String methodName) {\n        return \"CAPTURE\".equals(methodName) && isAssignableTo(methodOwner, BaseParser.class);\n    }\n\n    public static boolean isContextSwitch(@NotNull AbstractInsnNode insn) {\n        if (insn.getOpcode() != Opcodes.INVOKESTATIC) return false;\n        MethodInsnNode mi = (MethodInsnNode) insn;\n        return isContextSwitch(mi.owner, mi.name);\n    }\n\n    public static boolean isContextSwitch(@NotNull String methodOwner, @NotNull String methodName) {\n        return isAssignableTo(methodOwner, BaseParser.class) &&\n                \"UP/UP2/UP3/UP4/UP5/UP6/DOWN/DOWN2/DOWN3/DOWN4/DOWN5/DOWN6\".contains(methodName);\n    }\n\n    public static boolean isCallOnContextAware(@NotNull AbstractInsnNode insn) {\n        if (insn.getOpcode() != Opcodes.INVOKEVIRTUAL && insn.getOpcode() != Opcodes.INVOKEINTERFACE) return false;\n        MethodInsnNode mi = (MethodInsnNode) insn;\n        return isAssignableTo(mi.owner, ContextAware.class);\n    }\n\n    public static boolean isCaptureGet(@NotNull AbstractInsnNode insn) {\n        if (insn.getOpcode() != Opcodes.INVOKEVIRTUAL && insn.getOpcode() != Opcodes.INVOKEINTERFACE) return false;\n        MethodInsnNode mi = (MethodInsnNode) insn;\n        return \"get\".equals(mi.name) && \"()Ljava/lang/Object;\".equals(mi.desc) &&\n                isAssignableTo(mi.owner, Capture.class);\n    }\n\n    public static boolean isCallToRuleCreationMethod(@NotNull AbstractInsnNode insn) {\n        if (insn.getType() != AbstractInsnNode.METHOD_INSN) return false;\n        MethodInsnNode mi = (MethodInsnNode) insn;\n        Type type = Type.getReturnType(mi.desc);\n        return type.getSort() == Type.OBJECT && isAssignableTo(type.getInternalName(), Rule.class);\n    }\n\n}\n","lineNo":103}
{"Refactored Sample":"/*\n * Copyright (C) 2009-2010 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.common.StringUtils;\nimport org.parboiled.matchers.*;\n\nimport java.util.*;\n\npublic class ParserStatistics<V> implements MatcherVisitor<V, ParserStatistics> {\n\n    private final Matcher<V> root;\n    private int totalRules;\n    private final Set<AnyMatcher<V>> anyMatchers = new HashSet<AnyMatcher<V>>();\n    private final Set<CharIgnoreCaseMatcher<V>> charIgnoreCaseMatchers = new HashSet<CharIgnoreCaseMatcher<V>>();\n    private final Set<CharMatcher<V>> charMatchers = new HashSet<CharMatcher<V>>();\n    private final Set<CustomMatcher<V>> customMatchers = new HashSet<CustomMatcher<V>>();\n    private final Set<CharRangeMatcher<V>> charRangeMatchers = new HashSet<CharRangeMatcher<V>>();\n    private final Set<CharSetMatcher<V>> charSetMatchers = new HashSet<CharSetMatcher<V>>();\n    private final Set<EmptyMatcher<V>> emptyMatchers = new HashSet<EmptyMatcher<V>>();\n    private final Set<FirstOfMatcher<V>> firstOfMatchers = new HashSet<FirstOfMatcher<V>>();\n    private final Set<OneOrMoreMatcher<V>> oneOrMoreMatchers = new HashSet<OneOrMoreMatcher<V>>();\n    private final Set<OptionalMatcher<V>> optionalMatchers = new HashSet<OptionalMatcher<V>>();\n    private final Set<SequenceMatcher<V>> sequenceMatchers = new HashSet<SequenceMatcher<V>>();\n    private final Set<TestMatcher<V>> testMatchers = new HashSet<TestMatcher<V>>();\n    private final Set<TestNotMatcher<V>> testNotMatchers = new HashSet<TestNotMatcher<V>>();\n    private final Set<ZeroOrMoreMatcher<V>> zeroOrMoreMatchers = new HashSet<ZeroOrMoreMatcher<V>>();\n\n    private final Set<Action<V>> actions = new HashSet<Action<V>>();\n    private final Set<Class<?>> actionClasses = new HashSet<Class<?>>();\n    private final Set<ProxyMatcher<V>> proxyMatchers = new HashSet<ProxyMatcher<V>>();\n    private final Set<VarFramingMatcher<V>> varFramingMatchers = new HashSet<VarFramingMatcher<V>>();\n\n    @SuppressWarnings({\"unchecked\"})\n    public static <V> ParserStatistics<V> generateFor(@NotNull Rule rule) {\n        Matcher<V> matcher = (Matcher<V>) rule;\n        return matcher.accept(new ParserStatistics<V>(matcher));\n    }\n\n    private ParserStatistics(Matcher<V> root) {\n        this.root = root;\n        countSpecials(root);\n    }\n\n    public Rule getRootRule() {\n        return root;\n    }\n\n    public int getTotalRules() {\n        return totalRules;\n    }\n\n    public Set<AnyMatcher<V>> getAnyMatchers() {\n        return anyMatchers;\n    }\n\n    public Set<CharIgnoreCaseMatcher<V>> getCharIgnoreCaseMatchers() {\n        return charIgnoreCaseMatchers;\n    }\n\n    public Set<CharMatcher<V>> getCharMatchers() {\n        return charMatchers;\n    }\n\n    public Set<CustomMatcher<V>> getCustomMatchers() {\n        return customMatchers;\n    }\n\n    public Set<CharRangeMatcher<V>> getCharRangeMatchers() {\n        return charRangeMatchers;\n    }\n\n    public Set<CharSetMatcher<V>> getCharSetMatchers() {\n        return charSetMatchers;\n    }\n\n    public Set<EmptyMatcher<V>> getEmptyMatchers() {\n        return emptyMatchers;\n    }\n\n    public Set<FirstOfMatcher<V>> getFirstOfMatchers() {\n        return firstOfMatchers;\n    }\n\n    public Set<OneOrMoreMatcher<V>> getOneOrMoreMatchers() {\n        return oneOrMoreMatchers;\n    }\n\n    public Set<OptionalMatcher<V>> getOptionalMatchers() {\n        return optionalMatchers;\n    }\n\n    public Set<SequenceMatcher<V>> getSequenceMatchers() {\n        return sequenceMatchers;\n    }\n\n    public Set<TestMatcher<V>> getTestMatchers() {\n        return testMatchers;\n    }\n\n    public Set<TestNotMatcher<V>> getTestNotMatchers() {\n        return testNotMatchers;\n    }\n\n    public Set<ZeroOrMoreMatcher<V>> getZeroOrMoreMatchers() {\n        return zeroOrMoreMatchers;\n    }\n\n    public Set<Action<V>> getActions() {\n        return actions;\n    }\n\n    public Set<Class<?>> getActionClasses() {\n        return actionClasses;\n    }\n\n    public Set<ProxyMatcher<V>> getProxyMatchers() {\n        return proxyMatchers;\n    }\n\n    public Set<VarFramingMatcher<V>> getVarFramingMatchers() {\n        return varFramingMatchers;\n    }\n\n    // MatcherVisitor interface\n\n    public ParserStatistics<V> visit(ActionMatcher<V> matcher) {\n        if (!actions.contains(matcher.action)) {\n            totalRules++;\n            actions.add(matcher.action);\n            actionClasses.add(matcher.action.getClass());\n        }\n        return this;\n    }\n\n    public ParserStatistics<V> visit(AnyMatcher<V> matcher) {\n        return visit(matcher, anyMatchers);\n    }\n\n    public ParserStatistics<V> visit(CharIgnoreCaseMatcher<V> matcher) {\n        return visit(matcher, charIgnoreCaseMatchers);\n    }\n\n    public ParserStatistics<V> visit(CharMatcher<V> matcher) {\n        return visit(matcher, charMatchers);\n    }\n\n    public ParserStatistics<V> visit(CustomMatcher<V> matcher) {\n        return visit(matcher, customMatchers);\n    }\n\n    public ParserStatistics<V> visit(CharRangeMatcher<V> matcher) {\n        return visit(matcher, charRangeMatchers);\n    }\n\n    public ParserStatistics<V> visit(CharSetMatcher<V> matcher) {\n        return visit(matcher, charSetMatchers);\n    }\n\n    public ParserStatistics<V> visit(EmptyMatcher<V> matcher) {\n        return visit(matcher, emptyMatchers);\n    }\n\n    public ParserStatistics<V> visit(FirstOfMatcher<V> matcher) {\n        return visit(matcher, firstOfMatchers);\n    }\n\n    public ParserStatistics<V> visit(OneOrMoreMatcher<V> matcher) {\n        return visit(matcher, oneOrMoreMatchers);\n    }\n\n    public ParserStatistics<V> visit(OptionalMatcher<V> matcher) {\n        return visit(matcher, optionalMatchers);\n    }\n\n    public ParserStatistics<V> visit(SequenceMatcher<V> matcher) {\n        return visit(matcher, sequenceMatchers);\n    }\n\n    public ParserStatistics<V> visit(TestMatcher<V> matcher) {\n        return visit(matcher, testMatchers);\n    }\n\n    public ParserStatistics<V> visit(TestNotMatcher<V> matcher) {\n        return visit(matcher, testNotMatchers);\n    }\n\n    public ParserStatistics<V> visit(ZeroOrMoreMatcher<V> matcher) {\n        return visit(matcher, zeroOrMoreMatchers);\n    }\n\n    private <M extends Matcher<V>> ParserStatistics<V> visit(M matcher, Set<M> set) {\n        if (!set.contains(matcher)) {\n            totalRules++;\n            set.add(matcher);\n            for (Matcher<V> child : matcher.getChildren()) {\n                countSpecials(child);\n                child.accept(this);\n            }\n        }\n        return this;\n    }\n\n    private void countSpecials(Matcher<V> matcher) {\n        if (matcher instanceof ProxyMatcher) {\n            proxyMatchers.add((ProxyMatcher<V>) matcher);\n        } else if (matcher instanceof VarFramingMatcher) {\n            varFramingMatchers.add((VarFramingMatcher<V>) matcher);\n        }\n    }\n\n    @Override\n    public String toString() {\n        return new StringBuilder(\"Parser statistics for rule '\").append(root).append(\"':\\n\")\n                .append(\"    Total rules       : \").append(totalRules).append('\\n')\n                .append(\"        Actions       : \").append(actions.size()).append('\\n')\n                .append(\"        Any           : \").append(anyMatchers.size()).append('\\n')\n                .append(\"        CharIgnoreCase: \").append(charIgnoreCaseMatchers.size()).append('\\n')\n                .append(\"        Char          : \").append(charMatchers.size()).append('\\n')\n                .append(\"        Custom        : \").append(customMatchers.size()).append('\\n')\n                .append(\"        CharRange     : \").append(charRangeMatchers.size()).append('\\n')\n                .append(\"        CharSet       : \").append(charSetMatchers.size()).append('\\n')\n                .append(\"        Empty         : \").append(emptyMatchers.size()).append('\\n')\n                .append(\"        FirstOf       : \").append(firstOfMatchers.size()).append('\\n')\n                .append(\"        OneOrMore     : \").append(oneOrMoreMatchers.size()).append('\\n')\n                .append(\"        Optional      : \").append(optionalMatchers.size()).append('\\n')\n                .append(\"        Sequence      : \").append(sequenceMatchers.size()).append('\\n')\n                .append(\"        Test          : \").append(testMatchers.size()).append('\\n')\n                .append(\"        TestNot       : \").append(testNotMatchers.size()).append('\\n')\n                .append(\"        ZeroOrMore    : \").append(zeroOrMoreMatchers.size()).append('\\n')\n                .append('\\n')\n                .append(\"    Action Classes    : \").append(actionClasses.size()).append('\\n')\n                .append(\"    ProxyMatchers     : \").append(proxyMatchers.size()).append('\\n')\n                .append(\"    VarFramingMatchers: \").append(varFramingMatchers.size()).append('\\n')\n                .toString();\n    }\n\n    public String printActionClassInstances() {\n        StringBuilder sb = new StringBuilder(\"Action classes and their instances for rule '\")\n                .append(root).append(\"':\\n\");\n\n        for (String line : printActionClassLines()) {\n            sb.append(\"    \").append(line).append('\\n');\n        }\n        return sb.toString();\n    }\n\n    private List<String> printActionClassLines() {\n        List<String> lines = new ArrayList<String>();\n        int anonymous = 0;\n        for (Class<?> actionClass : actionClasses) {\n            String name = actionClass.getSimpleName();\n            if (StringUtils.isEmpty(name)) {\n                anonymous++;\n            } else {\n                lines.add(name + \" : \" + StringUtils.join(printActionClassInstances(actionClass), \", \"));\n            }\n        }\n        Collections.sort(lines);\n        if (anonymous > 0) lines.add(\"and \" + anonymous + \" anonymous instance(s)\");\n        return lines;\n    }\n\n    private List<String> printActionClassInstances(Class<?> actionClass) {\n        List<String> actionNames = new ArrayList<String>();\n        for (Action<V> action : actions) {\n            if (action.getClass().equals(actionClass)) {\n                actionNames.add(action.toString());\n            }\n        }\n        Collections.sort(actionNames);\n        return actionNames;\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009-2010 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.common.StringUtils;\nimport org.parboiled.matchers.*;\n\nimport java.util.*;\n\npublic class ParserStatistics<V> implements MatcherVisitor<V, ParserStatistics> {\n\n    private final Rule rootRule;\n    private int totalRules;\n    private final Set<AnyMatcher<V>> anyMatchers = new HashSet<AnyMatcher<V>>();\n    private final Set<CharIgnoreCaseMatcher<V>> charIgnoreCaseMatchers = new HashSet<CharIgnoreCaseMatcher<V>>();\n    private final Set<CharMatcher<V>> charMatchers = new HashSet<CharMatcher<V>>();\n    private final Set<CustomMatcher<V>> customMatchers = new HashSet<CustomMatcher<V>>();\n    private final Set<CharRangeMatcher<V>> charRangeMatchers = new HashSet<CharRangeMatcher<V>>();\n    private final Set<CharSetMatcher<V>> charSetMatchers = new HashSet<CharSetMatcher<V>>();\n    private final Set<EmptyMatcher<V>> emptyMatchers = new HashSet<EmptyMatcher<V>>();\n    private final Set<FirstOfMatcher<V>> firstOfMatchers = new HashSet<FirstOfMatcher<V>>();\n    private final Set<OneOrMoreMatcher<V>> oneOrMoreMatchers = new HashSet<OneOrMoreMatcher<V>>();\n    private final Set<OptionalMatcher<V>> optionalMatchers = new HashSet<OptionalMatcher<V>>();\n    private final Set<SequenceMatcher<V>> sequenceMatchers = new HashSet<SequenceMatcher<V>>();\n    private final Set<TestMatcher<V>> testMatchers = new HashSet<TestMatcher<V>>();\n    private final Set<TestNotMatcher<V>> testNotMatchers = new HashSet<TestNotMatcher<V>>();\n    private final Set<ZeroOrMoreMatcher<V>> zeroOrMoreMatchers = new HashSet<ZeroOrMoreMatcher<V>>();\n\n    private final Set<Action<V>> actions = new HashSet<Action<V>>();\n    private final Set<Class<?>> actionClasses = new HashSet<Class<?>>();\n    private final Set<ProxyMatcher<V>> proxyMatchers = new HashSet<ProxyMatcher<V>>();\n\n    @SuppressWarnings({\"unchecked\"})\n    public static <V> ParserStatistics<V> generateFor(@NotNull Rule rule) {\n        return ((Matcher<V>) rule).accept(new ParserStatistics<V>(rule));\n    }\n\n    private ParserStatistics(Rule rootRule) {\n        this.rootRule = rootRule;\n    }\n\n    public Rule getRootRule() {\n        return rootRule;\n    }\n\n    public int getTotalRules() {\n        return totalRules;\n    }\n\n    public Set<AnyMatcher<V>> getAnyMatchers() {\n        return anyMatchers;\n    }\n\n    public Set<CharIgnoreCaseMatcher<V>> getCharIgnoreCaseMatchers() {\n        return charIgnoreCaseMatchers;\n    }\n\n    public Set<CharMatcher<V>> getCharMatchers() {\n        return charMatchers;\n    }\n\n    public Set<CustomMatcher<V>> getCustomMatchers() {\n        return customMatchers;\n    }\n\n    public Set<CharRangeMatcher<V>> getCharRangeMatchers() {\n        return charRangeMatchers;\n    }\n\n    public Set<CharSetMatcher<V>> getCharSetMatchers() {\n        return charSetMatchers;\n    }\n\n    public Set<EmptyMatcher<V>> getEmptyMatchers() {\n        return emptyMatchers;\n    }\n\n    public Set<FirstOfMatcher<V>> getFirstOfMatchers() {\n        return firstOfMatchers;\n    }\n\n    public Set<OneOrMoreMatcher<V>> getOneOrMoreMatchers() {\n        return oneOrMoreMatchers;\n    }\n\n    public Set<OptionalMatcher<V>> getOptionalMatchers() {\n        return optionalMatchers;\n    }\n\n    public Set<SequenceMatcher<V>> getSequenceMatchers() {\n        return sequenceMatchers;\n    }\n\n    public Set<TestMatcher<V>> getTestMatchers() {\n        return testMatchers;\n    }\n\n    public Set<TestNotMatcher<V>> getTestNotMatchers() {\n        return testNotMatchers;\n    }\n\n    public Set<ZeroOrMoreMatcher<V>> getZeroOrMoreMatchers() {\n        return zeroOrMoreMatchers;\n    }\n\n    public Set<Action<V>> getActions() {\n        return actions;\n    }\n\n    public Set<Class<?>> getActionClasses() {\n        return actionClasses;\n    }\n\n    public Set<ProxyMatcher<V>> getProxyMatchers() {\n        return proxyMatchers;\n    }\n\n    // MatcherVisitor interface\n\n    public ParserStatistics<V> visit(ActionMatcher<V> matcher) {\n        if (!actions.contains(matcher.action)) {\n            totalRules++;\n            actions.add(matcher.action);\n            actionClasses.add(matcher.action.getClass());\n        }\n        return this;\n    }\n\n    public ParserStatistics<V> visit(AnyMatcher<V> matcher) {\n        return visit(matcher, anyMatchers);\n    }\n\n    public ParserStatistics<V> visit(CharIgnoreCaseMatcher<V> matcher) {\n        return visit(matcher, charIgnoreCaseMatchers);\n    }\n\n    public ParserStatistics<V> visit(CharMatcher<V> matcher) {\n        return visit(matcher, charMatchers);\n    }\n\n    public ParserStatistics<V> visit(CustomMatcher<V> matcher) {\n        return visit(matcher, customMatchers);\n    }\n\n    public ParserStatistics<V> visit(CharRangeMatcher<V> matcher) {\n        return visit(matcher, charRangeMatchers);\n    }\n\n    public ParserStatistics<V> visit(CharSetMatcher<V> matcher) {\n        return visit(matcher, charSetMatchers);\n    }\n\n    public ParserStatistics<V> visit(EmptyMatcher<V> matcher) {\n        return visit(matcher, emptyMatchers);\n    }\n\n    public ParserStatistics<V> visit(FirstOfMatcher<V> matcher) {\n        return visit(matcher, firstOfMatchers);\n    }\n\n    public ParserStatistics<V> visit(OneOrMoreMatcher<V> matcher) {\n        return visit(matcher, oneOrMoreMatchers);\n    }\n\n    public ParserStatistics<V> visit(OptionalMatcher<V> matcher) {\n        return visit(matcher, optionalMatchers);\n    }\n\n    public ParserStatistics<V> visit(SequenceMatcher<V> matcher) {\n        return visit(matcher, sequenceMatchers);\n    }\n\n    public ParserStatistics<V> visit(TestMatcher<V> matcher) {\n        return visit(matcher, testMatchers);\n    }\n\n    public ParserStatistics<V> visit(TestNotMatcher<V> matcher) {\n        return visit(matcher, testNotMatchers);\n    }\n\n    public ParserStatistics<V> visit(ZeroOrMoreMatcher<V> matcher) {\n        return visit(matcher, zeroOrMoreMatchers);\n    }\n\n    private <M extends Matcher<V>> ParserStatistics<V> visit(M matcher, Set<M> set) {\n        if (!set.contains(matcher)) {\n            totalRules++;\n            set.add(matcher);\n            for (Matcher<V> child : matcher.getChildren()) {\n                if (child instanceof ProxyMatcher) {\n                    proxyMatchers.add((ProxyMatcher<V>) child);\n                }\n                child.accept(this);\n            }\n        }\n        return this;\n    }\n\n    @Override\n    public String toString() {\n        return new StringBuilder(\"Parser statistics for rule '\").append(rootRule).append(\"':\\n\")\n                .append(\"    Total rules       : \").append(totalRules).append('\\n')\n                .append(\"        Actions       : \").append(actions.size()).append('\\n')\n                .append(\"        Any           : \").append(anyMatchers.size()).append('\\n')\n                .append(\"        CharIgnoreCase: \").append(charIgnoreCaseMatchers.size()).append('\\n')\n                .append(\"        Char          : \").append(charMatchers.size()).append('\\n')\n                .append(\"        Custom        : \").append(customMatchers.size()).append('\\n')\n                .append(\"        CharRange     : \").append(charRangeMatchers.size()).append('\\n')\n                .append(\"        CharSet       : \").append(charSetMatchers.size()).append('\\n')\n                .append(\"        Empty         : \").append(emptyMatchers.size()).append('\\n')\n                .append(\"        FirstOf       : \").append(firstOfMatchers.size()).append('\\n')\n                .append(\"        OneOrMore     : \").append(oneOrMoreMatchers.size()).append('\\n')\n                .append(\"        Optional      : \").append(optionalMatchers.size()).append('\\n')\n                .append(\"        Sequence      : \").append(sequenceMatchers.size()).append('\\n')\n                .append(\"        Test          : \").append(testMatchers.size()).append('\\n')\n                .append(\"        TestNot       : \").append(testNotMatchers.size()).append('\\n')\n                .append(\"        ZeroOrMore    : \").append(zeroOrMoreMatchers.size()).append('\\n')\n                .append('\\n')\n                .append(\"    Action Classes    : \").append(actionClasses.size()).append('\\n')\n                .append(\"    Proxy Matchers    : \").append(proxyMatchers.size()).append('\\n')\n                .toString();\n    }\n\n    public String printActionClassInstances() {\n        StringBuilder sb = new StringBuilder(\"Action classes and their instances for rule '\")\n                .append(rootRule).append(\"':\\n\");\n\n        for (String line : printActionClassLines()) {\n            sb.append(\"    \").append(line).append('\\n');\n        }\n        return sb.toString();\n    }\n\n    private List<String> printActionClassLines() {\n        List<String> lines = new ArrayList<String>();\n        int anonymous = 0;\n        for (Class<?> actionClass : actionClasses) {\n            String name = actionClass.getSimpleName();\n            if (StringUtils.isEmpty(name)) {\n                anonymous++;\n            } else {\n                lines.add(name + \" : \" + StringUtils.join(printActionClassInstances(actionClass), \", \"));\n            }\n        }\n        Collections.sort(lines);\n        if (anonymous > 0) lines.add(\"and \" + anonymous + \" anonymous instance(s)\");\n        return lines;\n    }\n\n    private List<String> printActionClassInstances(Class<?> actionClass) {\n        List<String> actionNames = new ArrayList<String>();\n        for (Action<V> action : actions) {\n            if (action.getClass().equals(actionClass)) {\n                actionNames.add(action.toString());\n            }\n        }\n        Collections.sort(actionNames);\n        return actionNames;\n    }\n\n}\n","lineNo":51}
{"Refactored Sample":"/*\n * Copyright (C) 2009-2010 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.transform;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.objectweb.asm.ClassWriter;\nimport org.objectweb.asm.MethodVisitor;\nimport org.objectweb.asm.Opcodes;\nimport org.objectweb.asm.Type;\nimport org.objectweb.asm.tree.*;\n\nimport java.util.HashSet;\nimport java.util.List;\n\nimport static org.parboiled.transform.AsmUtils.findLoadedClass;\nimport static org.parboiled.transform.AsmUtils.loadClass;\n\nabstract class GroupClassGenerator implements RuleMethodProcessor, Opcodes, Types {\n\n    private static final Object lock = new Object();\n\n    private final boolean forceCodeBuilding;\n    protected ParserClassNode classNode;\n    protected RuleMethod method;\n\n    protected GroupClassGenerator(boolean forceCodeBuilding) {\n        this.forceCodeBuilding = forceCodeBuilding;\n    }\n\n    public void process(@NotNull ParserClassNode classNode, @NotNull RuleMethod method) {\n        this.classNode = classNode;\n        this.method = method;\n\n        for (InstructionGroup group : method.getGroups()) {\n            if (appliesTo(group.getRoot())) {\n                loadGroupClass(group);\n            }\n        }\n    }\n\n    protected abstract boolean appliesTo(InstructionGraphNode group);\n\n    private void loadGroupClass(InstructionGroup group) {\n        createGroupClassType(group);\n        String className = group.getGroupClassType().getClassName();\n        ClassLoader classLoader = classNode.getParentClass().getClassLoader();\n\n        Class<?> groupClass;\n        synchronized (lock) {\n            groupClass = findLoadedClass(className, classLoader);\n            if (groupClass == null || forceCodeBuilding) {\n                byte[] groupClassCode = generateGroupClassCode(group);\n                group.setGroupClassCode(groupClassCode);\n                if (groupClass == null) {\n                    loadClass(className, groupClassCode, classLoader);\n                }\n            }\n        }\n    }\n\n    private void createGroupClassType(InstructionGroup group) {\n        String s = classNode.name;\n        String groupClassInternalName = s.substring(0, classNode.name.lastIndexOf('/')) + '/' + group.getName();\n        group.setGroupClassType(Type.getObjectType(groupClassInternalName));\n    }\n\n    protected byte[] generateGroupClassCode(InstructionGroup group) {\n        ClassWriter classWriter = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n        generateClassBasics(group, classWriter);\n        generateFields(group, classWriter);\n        generateConstructor(classWriter);\n        generateMethod(group, classWriter);\n        return classWriter.toByteArray();\n    }\n\n    private void generateClassBasics(InstructionGroup group, ClassWriter cw) {\n        cw.visit(V1_5, ACC_PUBLIC + ACC_FINAL, group.getGroupClassType().getInternalName(), null,\n                getBaseType().getInternalName(), null);\n        cw.visitSource(classNode.sourceFile, null);\n    }\n\n    protected abstract Type getBaseType();\n\n    private void generateFields(InstructionGroup group, ClassWriter cw) {\n        for (FieldNode field : group.getFields()) {\n            // CAUTION: the FieldNode has illegal access flags and an illegal value field since these two members\n            // are reused for other purposes, so we need to write out the field \"manually\" here rather than\n            // just call \"field.accept(cw)\"\n            cw.visitField(ACC_PUBLIC + ACC_SYNTHETIC, field.name, field.desc, null, null);\n        }\n    }\n\n    private void generateConstructor(ClassWriter cw) {\n        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"(Ljava/lang/String;)V\", null, null);\n        mv.visitVarInsn(ALOAD, 0);\n        mv.visitVarInsn(ALOAD, 1);\n        mv.visitMethodInsn(INVOKESPECIAL, getBaseType().getInternalName(), \"<init>\", \"(Ljava/lang/String;)V\");\n        mv.visitInsn(RETURN);\n        mv.visitMaxs(0, 0); // trigger automatic computing\n    }\n\n    protected abstract void generateMethod(InstructionGroup group, ClassWriter cw);\n\n    protected void fixContextSwitches(InstructionGroup group) {\n        List<InstructionGraphNode> nodes = group.getNodes();\n        InsnList instructions = group.getInstructions();\n        for (int i = nodes.size() - 1; i >= 0; i--) {\n            InstructionGraphNode node = nodes.get(i);\n            if (!node.isContextSwitch()) continue;\n\n            // insert context switch\n            String contextSwitchType = ((MethodInsnNode) node.getInstruction()).name;\n            insertContextSwitch(instructions, getFirstOfSubtree(instructions, node, new HashSet<InstructionGraphNode>())\n                    .getInstruction(), contextSwitchType);\n\n            // insert inverse context switch, reversing the context switch done before\n            String reverse = contextSwitchType.startsWith(\"UP\") ?\n                    contextSwitchType.replace(\"UP\", \"DOWN\") : contextSwitchType.replace(\"DOWN\", \"UP\");\n            insertContextSwitch(instructions, node.getInstruction(), reverse);\n\n            // remove original call\n            instructions.remove(node.getInstruction());\n        }\n    }\n\n    private void insertContextSwitch(InsnList instructions, AbstractInsnNode firstInsn, String contextSwitchType) {\n        instructions.insertBefore(firstInsn, new VarInsnNode(ALOAD, 0));\n        instructions.insertBefore(firstInsn, new VarInsnNode(ALOAD, 1));\n        instructions.insertBefore(firstInsn, new MethodInsnNode(INVOKEVIRTUAL,\n                getBaseType().getInternalName(), contextSwitchType, CONTEXT_SWITCH_DESC));\n        instructions.insertBefore(firstInsn, new VarInsnNode(ASTORE, 1));\n    }\n\n    protected void insertSetContextCalls(InstructionGroup group, int localVarIx) {\n        InsnList instructions = group.getInstructions();\n        for (InstructionGraphNode node : group.getNodes()) {\n            if (node.isCallOnContextAware()) {\n                AbstractInsnNode insn = node.getInstruction();\n\n                if (node.getPredecessors().size() > 1) {\n                    // store the target of the call in a new local variable\n                    AbstractInsnNode loadTarget = node.getPredecessors().get(0).getInstruction();\n                    instructions.insert(loadTarget, new VarInsnNode(ASTORE, ++localVarIx));\n                    instructions.insert(loadTarget, new InsnNode(DUP)); // the DUP is inserted BEFORE the ASTORE\n\n                    // immediately before the call get the target from the local var and set the context on it\n                    instructions.insertBefore(insn, new VarInsnNode(ALOAD, localVarIx));\n                } else {\n                    // if we have only one predecessor the call does not take any parameters and we can\n                    // skip the storing and loading of the invocation target\n                    instructions.insertBefore(insn, new InsnNode(DUP));\n                }\n                instructions.insertBefore(insn, new VarInsnNode(ALOAD, 1));\n                instructions.insertBefore(insn, new MethodInsnNode(INVOKEINTERFACE,\n                        CONTEXT_AWARE.getInternalName(), \"setContext\", \"(\" + CONTEXT_DESC + \")V\"));\n            } else if (node.isCaptureGet()) {\n                // calls to Capture.get() are easier to fix:\n                // we simply change to call to Capture.get() to a call to Capture.get(Context)\n                MethodInsnNode insn = (MethodInsnNode) node.getInstruction();\n                instructions.insertBefore(insn, new VarInsnNode(ALOAD, 1));\n                insn.desc = '(' + CONTEXT_DESC + \")Ljava/lang/Object;\";\n            }\n        }\n    }\n\n    protected void convertXLoads(InstructionGroup group) {\n        String owner = group.getGroupClassType().getInternalName();\n        for (InstructionGraphNode node : group.getNodes()) {\n            if (!node.isXLoad()) continue;\n\n            VarInsnNode insn = (VarInsnNode) node.getInstruction();\n            FieldNode field = group.getFields().get(insn.var);\n\n            // insert the correct GETFIELD after the xLoad\n            group.getInstructions().insert(insn, new FieldInsnNode(GETFIELD, owner, field.name, field.desc));\n\n            // change the load to ALOAD 0\n            group.getInstructions().set(insn, new VarInsnNode(ALOAD, 0));\n        }\n    }\n\n    public static InstructionGraphNode getFirstOfSubtree(InsnList instructions, InstructionGraphNode node,\n                                                         HashSet<InstructionGraphNode> covered) {\n        InstructionGraphNode first = node;\n        if (!covered.contains(node)) {\n            covered.add(node);\n            for (InstructionGraphNode predecessor : node.getPredecessors()) {\n                InstructionGraphNode firstOfPred = getFirstOfSubtree(instructions, predecessor, covered);\n                if (instructions.indexOf(first.getInstruction()) > instructions.indexOf(firstOfPred.getInstruction())) {\n                    first = firstOfPred;\n                }\n            }\n        }\n        return first;\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009-2010 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.transform;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.objectweb.asm.ClassWriter;\nimport org.objectweb.asm.MethodVisitor;\nimport org.objectweb.asm.Opcodes;\nimport org.objectweb.asm.Type;\nimport org.objectweb.asm.tree.*;\n\nimport java.util.HashSet;\nimport java.util.List;\n\nimport static org.parboiled.transform.AsmUtils.findLoadedClass;\nimport static org.parboiled.transform.AsmUtils.loadClass;\n\nabstract class GroupClassGenerator implements RuleMethodProcessor, Opcodes, Types {\n\n    private static final Object lock = new Object();\n\n    private final boolean forceCodeBuilding;\n    protected ParserClassNode classNode;\n    protected RuleMethod method;\n\n    protected GroupClassGenerator(boolean forceCodeBuilding) {\n        this.forceCodeBuilding = forceCodeBuilding;\n    }\n\n    public void process(@NotNull ParserClassNode classNode, @NotNull RuleMethod method) {\n        this.classNode = classNode;\n        this.method = method;\n\n        for (InstructionGroup group : method.getGroups()) {\n            if (appliesTo(group.getRoot())) {\n                loadGroupClass(group);\n            }\n        }\n    }\n\n    protected abstract boolean appliesTo(InstructionGraphNode group);\n\n    private void loadGroupClass(InstructionGroup group) {\n        createGroupClassType(group);\n        String className = group.getGroupClassType().getClassName();\n        ClassLoader classLoader = classNode.getParentClass().getClassLoader();\n\n        Class<?> groupClass;\n        synchronized (lock) {\n            groupClass = findLoadedClass(className, classLoader);\n            if (groupClass == null || forceCodeBuilding) {\n                byte[] groupClassCode = generateGroupClassCode(group);\n                group.setGroupClassCode(groupClassCode);\n                if (groupClass == null) {\n                    loadClass(className, groupClassCode, classLoader);\n                }\n            }\n        }\n    }\n\n    private void createGroupClassType(InstructionGroup group) {\n        String s = classNode.name;\n        String groupClassInternalName = s.substring(0, classNode.name.lastIndexOf('/')) + '/' + group.getName();\n        group.setGroupClassType(Type.getObjectType(groupClassInternalName));\n    }\n\n    protected byte[] generateGroupClassCode(InstructionGroup group) {\n        ClassWriter classWriter = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n        generateClassBasics(group, classWriter);\n        generateFields(group, classWriter);\n        generateConstructor(classWriter);\n        generateMethod(group, classWriter);\n        return classWriter.toByteArray();\n    }\n\n    private void generateClassBasics(InstructionGroup group, ClassWriter cw) {\n        cw.visit(V1_5, ACC_PUBLIC + ACC_FINAL, group.getGroupClassType().getInternalName(), null,\n                getBaseType().getInternalName(), null);\n        cw.visitSource(classNode.sourceFile, null);\n    }\n\n    protected abstract Type getBaseType();\n\n    private void generateFields(InstructionGroup group, ClassWriter cw) {\n        for (FieldNode field : group.getFields()) {\n            // CAUTION: the FieldNode has illegal access flags and an illegal value field since these two members\n            // are reused for other purposes, so we need to write out the field \"manually\" here rather than\n            // just call \"field.accept(cw)\"\n            cw.visitField(ACC_PUBLIC + ACC_SYNTHETIC, field.name, field.desc, null, null);\n        }\n    }\n\n    private void generateConstructor(ClassWriter cw) {\n        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"(Ljava/lang/String;)V\", null, null);\n        mv.visitVarInsn(ALOAD, 0);\n        mv.visitVarInsn(ALOAD, 1);\n        mv.visitMethodInsn(INVOKESPECIAL, getBaseType().getInternalName(), \"<init>\", \"(Ljava/lang/String;)V\");\n        mv.visitInsn(RETURN);\n        mv.visitMaxs(0, 0); // trigger automatic computing\n    }\n\n    protected abstract void generateMethod(InstructionGroup group, ClassWriter cw);\n\n    protected void fixContextSwitches(InstructionGroup group) {\n        List<InstructionGraphNode> nodes = group.getNodes();\n        InsnList instructions = group.getInstructions();\n        for (int i = nodes.size() - 1; i >= 0; i--) {\n            InstructionGraphNode node = nodes.get(i);\n            if (!node.isContextSwitch()) continue;\n\n            // insert context switch\n            String contextSwitchType = ((MethodInsnNode) node.getInstruction()).name;\n            AbstractInsnNode firstInsn = getFirstOfSubtree(instructions, node, new HashSet<InstructionGraphNode>())\n                    .getInstruction();\n            instructions.insertBefore(firstInsn, new VarInsnNode(ALOAD, 0));\n            instructions.insertBefore(firstInsn, new MethodInsnNode(INVOKEVIRTUAL,\n                    getBaseType().getInternalName(), contextSwitchType, \"()V\"));\n\n            // replace original context-switching call with the opposite one, reversing the context switch done before\n            instructions.insertBefore(node.getInstruction(), new VarInsnNode(ALOAD, 0));\n            instructions.set(node.getInstruction(), new MethodInsnNode(INVOKEVIRTUAL,\n                    getBaseType().getInternalName(), contextSwitchType.startsWith(\"UP\") ? contextSwitchType\n                            .replace(\"UP\", \"DOWN\") : contextSwitchType.replace(\"DOWN\", \"UP\"), \"()V\"));\n        }\n    }\n\n    protected void insertSetContextCalls(InstructionGroup group, int localVarIx) {\n        InsnList instructions = group.getInstructions();\n        for (InstructionGraphNode node : group.getNodes()) {\n            if (node.isCallOnContextAware()) {\n                AbstractInsnNode insn = node.getInstruction();\n\n                if (node.getPredecessors().size() > 1) {\n                    // store the target of the call in a new local variable\n                    AbstractInsnNode loadTarget = node.getPredecessors().get(0).getInstruction();\n                    instructions.insert(loadTarget, new VarInsnNode(ASTORE, ++localVarIx));\n                    instructions.insert(loadTarget, new InsnNode(DUP)); // the DUP is inserted BEFORE the ASTORE\n\n                    // immediately before the call get the target from the local var and set the context on it\n                    instructions.insertBefore(insn, new VarInsnNode(ALOAD, localVarIx));\n                } else {\n                    // if we have only one predecessor the call does not take any parameters and we can\n                    // skip the storing and loading of the invocation target\n                    instructions.insertBefore(insn, new InsnNode(DUP));\n                }\n                instructions.insertBefore(insn, new VarInsnNode(ALOAD, 0));\n                instructions.insertBefore(insn, new FieldInsnNode(GETFIELD,\n                        group.getGroupClassType().getInternalName(), \"context\", CONTEXT_DESC));\n                instructions.insertBefore(insn, new MethodInsnNode(INVOKEINTERFACE,\n                        CONTEXT_AWARE.getInternalName(), \"setContext\", \"(\" + CONTEXT_DESC + \")V\"));\n            } else if (node.isCaptureGet()) {\n                // calls to Capture.get() are easier to fix:\n                // we simply change to call to Capture.get() to a call to Capture.get(Context)\n                MethodInsnNode insn = (MethodInsnNode) node.getInstruction();\n                instructions.insertBefore(insn, new VarInsnNode(ALOAD, 0));\n                instructions.insertBefore(insn, new FieldInsnNode(GETFIELD,\n                        group.getGroupClassType().getInternalName(), \"context\", CONTEXT_DESC));\n                insn.desc = '(' + CONTEXT_DESC + \")Ljava/lang/Object;\";\n            }\n        }\n    }\n\n    protected void convertXLoads(InstructionGroup group) {\n        String owner = group.getGroupClassType().getInternalName();\n        for (InstructionGraphNode node : group.getNodes()) {\n            if (!node.isXLoad()) continue;\n\n            VarInsnNode insn = (VarInsnNode) node.getInstruction();\n            FieldNode field = group.getFields().get(insn.var);\n\n            // insert the correct GETFIELD after the xLoad\n            group.getInstructions().insert(insn, new FieldInsnNode(GETFIELD, owner, field.name, field.desc));\n\n            // change the load to ALOAD 0\n            group.getInstructions().set(insn, new VarInsnNode(ALOAD, 0));\n        }\n    }\n\n    public static InstructionGraphNode getFirstOfSubtree(InsnList instructions, InstructionGraphNode node,\n                                                         HashSet<InstructionGraphNode> covered) {\n        InstructionGraphNode first = node;\n        if (!covered.contains(node)) {\n            covered.add(node);\n            for (InstructionGraphNode predecessor : node.getPredecessors()) {\n                InstructionGraphNode firstOfPred = getFirstOfSubtree(instructions, predecessor, covered);\n                if (instructions.indexOf(first.getInstruction()) > instructions.indexOf(firstOfPred.getInstruction())) {\n                    first = firstOfPred;\n                }\n            }\n        }\n        return first;\n    }\n\n}\n","lineNo":131}
{"Refactored Sample":"/*\n * Copyright (C) 2009-2010 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.transform;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.objectweb.asm.Opcodes;\nimport org.objectweb.asm.tree.*;\nimport org.parboiled.support.Checks;\n\nimport static org.parboiled.transform.AsmUtils.createArgumentLoaders;\n\n/**\n * Adds one constructor for each of the ParserClassNode.constructors,\n * which simply delegates to the respective super constructor.\n */\nclass ConstructorGenerator implements Opcodes, Types {\n\n    public void process(@NotNull ParserClassNode classNode) {\n        Checks.ensure(!classNode.getConstructors().isEmpty(),\n                \"Could not extend parser class '%s', no constructor visible to derived classes found\",\n                classNode.getParentType().getClassName());\n        for (MethodNode constructor : classNode.getConstructors()) {\n            createConstuctor(classNode, constructor);\n        }\n\n        createNewInstanceMethod(classNode);\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    private void createConstuctor(ParserClassNode classNode, MethodNode constructor) {\n        MethodNode newConstructor =\n                new MethodNode(ACC_PUBLIC, constructor.name, constructor.desc, constructor.signature,\n                        (String[]) constructor.exceptions.toArray(new String[constructor.exceptions.size()]));\n\n        InsnList instructions = newConstructor.instructions;\n        instructions.add(new VarInsnNode(ALOAD, 0));\n        instructions.add(createArgumentLoaders(constructor.desc));\n        instructions.add(new MethodInsnNode(INVOKESPECIAL,\n                classNode.getParentType().getInternalName(), \"<init>\", constructor.desc));\n        instructions.add(new InsnNode(RETURN));\n\n        classNode.methods.add(newConstructor);\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    private void createNewInstanceMethod(ParserClassNode classNode) {\n        MethodNode method = new MethodNode(ACC_PUBLIC, \"newInstance\", \"()L\" + BASE_PARSER.getInternalName() + ';',\n                null, null);\n        InsnList instructions = method.instructions;\n        instructions.add(new TypeInsnNode(NEW, classNode.name));\n        instructions.add(new InsnNode(DUP));\n        instructions.add(new MethodInsnNode(INVOKESPECIAL, classNode.name, \"<init>\", \"()V\"));\n        instructions.add(new InsnNode(ARETURN));\n\n        classNode.methods.add(method);\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009-2010 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.transform;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.objectweb.asm.Opcodes;\nimport org.objectweb.asm.tree.InsnNode;\nimport org.objectweb.asm.tree.MethodInsnNode;\nimport org.objectweb.asm.tree.MethodNode;\nimport org.objectweb.asm.tree.VarInsnNode;\nimport org.parboiled.support.Checks;\n\nimport static org.parboiled.transform.AsmUtils.createArgumentLoaders;\n\n/**\n * Adds one constructor for each of the ParserClassNode.constructors,\n * which simply delegates to the respective super constructor.\n */\nclass ConstructorGenerator implements Opcodes, Types {\n\n    public void process(@NotNull ParserClassNode classNode) {\n        Checks.ensure(!classNode.getConstructors().isEmpty(),\n                \"Could not extend parser class '%s', no constructor visible to derived classes found\",\n                classNode.getParentType().getClassName());\n        for (MethodNode constructor : classNode.getConstructors()) {\n            createConstuctor(classNode, constructor);\n        }\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    private void createConstuctor(ParserClassNode classNode, MethodNode constructor) {\n        MethodNode newConstructor =\n                new MethodNode(ACC_PUBLIC, constructor.name, constructor.desc, constructor.signature,\n                        (String[]) constructor.exceptions.toArray(new String[constructor.exceptions.size()]));\n\n        newConstructor.instructions.add(new VarInsnNode(ALOAD, 0));\n        newConstructor.instructions.add(createArgumentLoaders(constructor.desc));\n        newConstructor.instructions.add(new MethodInsnNode(INVOKESPECIAL,\n                classNode.getParentType().getInternalName(), \"<init>\", constructor.desc));\n        newConstructor.instructions.add(new InsnNode(RETURN));\n\n        classNode.methods.add(newConstructor);\n    }\n\n}\n","lineNo":49}
{"Refactored Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled;\n\nimport com.google.common.collect.ImmutableList;\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.common.Reference;\nimport org.parboiled.common.StringUtils;\nimport org.parboiled.errors.BasicParseError;\nimport org.parboiled.errors.ParseError;\nimport org.parboiled.errors.ParserRuntimeException;\nimport org.parboiled.matchers.ActionMatcher;\nimport org.parboiled.matchers.Matcher;\nimport org.parboiled.matchers.ProxyMatcher;\nimport org.parboiled.matchers.TestMatcher;\nimport org.parboiled.support.*;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.parboiled.errors.ErrorUtils.printParseError;\nimport static org.parboiled.support.ParseTreeUtils.findNode;\nimport static org.parboiled.support.ParseTreeUtils.findNodeByPath;\n\n/**\n * <p>The Context implementation orchestrating most of the matching process.<\/p>\n * <p>The parsing process works as following:<\/br>\n * After the rule tree (which is in fact a directed and potentially even cyclic graph of {@link Matcher} instances)\n * has been created a root MatcherContext is instantiated for the root rule (Matcher).\n * A subsequent call to {@link #runMatcher()} starts the parsing process.<\/p>\n * <p>The MatcherContext delegates to a given {@link MatchHandler} to call {@link Matcher#match(MatcherContext)},\n * passing itself to the Matcher which executes its logic, potentially calling sub matchers.\n * For each sub matcher the matcher creates/initializes a sub context with {@link #getSubContext(org.parboiled.matchers.Matcher)}\n * and then calls {@link #runMatcher()} on it.<\/p>\n * <p>This basically creates a stack of MatcherContexts, each corresponding to their rule matchers. The MatcherContext\n * instances serve as companion objects to the matchers, providing them with support for building the\n * parse tree nodes, keeping track of input locations and error recovery.<\/p>\n * <p>At each point during the parsing process the matchers and action expressions have access to the current\n * MatcherContext and all \"open\" parent MatcherContexts through the {@link #getParent()} chain.<\/p>\n * <p>For performance reasons sub context instances are reused instead of being recreated. If a MatcherContext instance\n * returns null on a {@link #getMatcher()} call it has been retired (is invalid) and is waiting to be reinitialized\n * with a new Matcher by its parent<\/p>\n *\n * @param <V> the node value type\n */\npublic class MatcherContext<V> implements Context<V> {\n\n    private final InputBuffer inputBuffer;\n    private final List<ParseError> parseErrors;\n    private final MatchHandler<V> matchHandler;\n    private final Reference<Node<V>> lastNodeRef;\n    private final MatcherContext<V> parent;\n    private final int level;\n\n    private MatcherContext<V> subContext;\n    private InputLocation startLocation;\n    private InputLocation currentLocation;\n    private Matcher<V> matcher;\n    private Node<V> node;\n    private List<Node<V>> subNodes = ImmutableList.of();\n    private V nodeValue;\n    private boolean hasError;\n    private int intTag;\n    private boolean nodeSuppressed;\n\n    public MatcherContext(@NotNull InputBuffer inputBuffer, @NotNull InputLocation startLocation,\n                          @NotNull List<ParseError> parseErrors, @NotNull MatchHandler<V> matchHandler,\n                          @NotNull Matcher<V> matcher) {\n        this(inputBuffer, parseErrors, matchHandler, new Reference<Node<V>>(), null, 0);\n        this.startLocation = startLocation;\n        this.currentLocation = startLocation;\n        this.matcher = ProxyMatcher.unwrap(matcher);\n        this.nodeSuppressed = matcher.isNodeSuppressed();\n    }\n\n    private MatcherContext(@NotNull InputBuffer inputBuffer, @NotNull List<ParseError> parseErrors,\n                           @NotNull MatchHandler<V> matchHandler, @NotNull Reference<Node<V>> lastNodeRef,\n                           MatcherContext<V> parent, int level) {\n        this.inputBuffer = inputBuffer;\n        this.parseErrors = parseErrors;\n        this.matchHandler = matchHandler;\n        this.lastNodeRef = lastNodeRef;\n        this.parent = parent;\n        this.level = level;\n    }\n\n    @Override\n    public String toString() {\n        return getPath().toString();\n    }\n\n    //////////////////////////////// CONTEXT INTERFACE ////////////////////////////////////\n\n    public MatcherContext<V> getParent() {\n        return parent;\n    }\n\n    public MatcherContext<V> getSubContext() {\n        // if the subContext has a null matcher it has been retired and is invalid\n        return subContext != null && subContext.matcher != null ? subContext : null;\n    }\n\n    @NotNull\n    public InputBuffer getInputBuffer() {\n        return inputBuffer;\n    }\n\n    public InputLocation getStartLocation() {\n        return startLocation;\n    }\n\n    public Matcher<V> getMatcher() {\n        return matcher;\n    }\n\n    @NotNull\n    public List<ParseError> getParseErrors() {\n        return parseErrors;\n    }\n\n    public InputLocation getCurrentLocation() {\n        return currentLocation;\n    }\n\n    public String getNodeText(Node<V> node) {\n        return ParseTreeUtils.getNodeText(node, inputBuffer);\n    }\n\n    @NotNull\n    public MatcherPath<V> getPath() {\n        return new MatcherPath<V>(this);\n    }\n\n    public int getLevel() {\n        return level;\n    }\n\n    public V getNodeValue() {\n        return nodeValue;\n    }\n\n    public void setNodeValue(V value) {\n        this.nodeValue = value;\n    }\n\n    public V getTreeValue() {\n        V treeValue = nodeValue;\n        int i = subNodes.size();\n        while (treeValue == null && i-- > 0) {\n            treeValue = subNodes.get(i).getValue();\n        }\n        return treeValue;\n    }\n\n    public Node<V> getNodeByPath(String path) {\n        return findNodeByPath(subNodes, path);\n    }\n\n    public Node<V> getNodeByLabel(String labelPrefix) {\n        return findNode(subNodes, new LabelPrefixPredicate<V>(labelPrefix));\n    }\n\n    public Node<V> getLastNode() {\n        return lastNodeRef.getTarget();\n    }\n\n    @NotNull\n    public List<Node<V>> getSubNodes() {\n        return subNodes;\n    }\n\n    public char lookAhead(int delta) {\n        return currentLocation.lookAhead(inputBuffer, delta);\n    }\n\n    public boolean inPredicate() {\n        return matcher instanceof TestMatcher || parent != null && parent.inPredicate();\n    }\n\n    public boolean isNodeSuppressed() {\n        return nodeSuppressed;\n    }\n\n    public boolean hasError() {\n        return hasError;\n    }\n\n    //////////////////////////////// PUBLIC ////////////////////////////////////\n\n    public void setStartLocation(InputLocation startLocation) {\n        this.startLocation = startLocation;\n    }\n\n    public void setCurrentLocation(InputLocation currentLocation) {\n        this.currentLocation = currentLocation;\n    }\n\n    public void advanceInputLocation() {\n        setCurrentLocation(currentLocation.advance(inputBuffer));\n    }\n\n    public Node<V> getNode() {\n        return node;\n    }\n\n    public int getIntTag() {\n        return intTag;\n    }\n\n    public void setIntTag(int intTag) {\n        this.intTag = intTag;\n    }\n\n    public void markError() {\n        if (!hasError) {\n            hasError = true;\n            if (parent != null) parent.markError();\n        }\n    }\n\n    public void clearNodeSuppression() {\n        if (nodeSuppressed) {\n            nodeSuppressed = false;\n            if (parent != null) parent.clearNodeSuppression();\n        }\n    }\n\n    @SuppressWarnings({\"ConstantConditions\"})\n    public void createNode() {\n        if (!nodeSuppressed && !matcher.isNodeSkipped()) {\n            node = new NodeImpl<V>(matcher, subNodes, startLocation, currentLocation, getTreeValue(), hasError);\n\n            MatcherContext<V> nodeParentContext = parent;\n            if (nodeParentContext != null) {\n                while (nodeParentContext.getMatcher().isNodeSkipped()) {\n                    nodeParentContext = nodeParentContext.getParent();\n                    Checks.ensure(nodeParentContext != null, \"Root rule must not be marked @SkipNode\");\n                }\n                nodeParentContext.addChildNode(node);\n            }\n            lastNodeRef.setTarget(node);\n        }\n    }\n\n    public MatcherContext<V> getSubContext(Matcher<V> matcher) {\n        if (subContext == null) {\n            // introduce a new level\n            subContext = new MatcherContext<V>(inputBuffer, parseErrors, matchHandler, lastNodeRef, this, level + 1);\n        }\n\n        // normally just reuse the existing subContext instance\n        MatcherContext<V> sc = subContext;\n        sc.matcher = ProxyMatcher.unwrap(matcher);\n        sc.startLocation = sc.currentLocation = currentLocation;\n        sc.node = null;\n        sc.subNodes = ImmutableList.of();\n        sc.nodeValue = null;\n        sc.nodeSuppressed = nodeSuppressed || this.matcher.areSubnodesSuppressed() || matcher.isNodeSuppressed();\n        sc.hasError = false;\n        return sc;\n    }\n\n    public boolean runMatcher() {\n        try {\n            if (matchHandler.match(this)) {\n                if (parent != null) parent.setCurrentLocation(currentLocation);\n                matcher = null; // \"retire\" this context\n                return true;\n            }\n            matcher = null; // \"retire\" this context until is \"activated\" again by a getSubContext(...) on the parent\n            return false;\n        } catch (ParserRuntimeException e) {\n            throw e; // don't wrap, just bubble up\n        } catch (Throwable e) {\n            throw new ParserRuntimeException(e,\n                    printParseError(new BasicParseError(currentLocation,\n                            StringUtils.escape(String.format(\"Error while parsing %s '%s' at input position\",\n                                    matcher instanceof ActionMatcher ? \"action\" : \"rule\", getPath()))), inputBuffer));\n        }\n    }\n\n    //////////////////////////////// PRIVATE ////////////////////////////////////\n\n    @SuppressWarnings({\"fallthrough\"})\n    private void addChildNode(@NotNull Node<V> node) {\n        int size = subNodes.size();\n        if (size == 0) {\n            subNodes = ImmutableList.of(node);\n            return;\n        }\n        if (size == 1) {\n            Node<V> node0 = subNodes.get(0);\n            subNodes = new ArrayList<Node<V>>(4);\n            subNodes.add(node0);\n        }\n        subNodes.add(node);\n    }\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled;\n\nimport com.google.common.collect.ImmutableList;\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.common.Reference;\nimport org.parboiled.common.StringUtils;\nimport org.parboiled.errors.BasicParseError;\nimport org.parboiled.errors.ParseError;\nimport org.parboiled.errors.ParserRuntimeException;\nimport org.parboiled.matchers.ActionMatcher;\nimport org.parboiled.matchers.Matcher;\nimport org.parboiled.matchers.ProxyMatcher;\nimport org.parboiled.matchers.TestMatcher;\nimport org.parboiled.support.*;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.parboiled.errors.ErrorUtils.printParseError;\nimport static org.parboiled.support.ParseTreeUtils.findNode;\nimport static org.parboiled.support.ParseTreeUtils.findNodeByPath;\n\n/**\n * <p>The Context implementation orchestrating most of the matching process.<\/p>\n * <p>The parsing process works as following:<\/br>\n * After the rule tree (which is in fact a directed and potentially even cyclic graph of {@link Matcher} instances)\n * has been created a root MatcherContext is instantiated for the root rule (Matcher).\n * A subsequent call to {@link #runMatcher()} starts the parsing process.<\/p>\n * <p>The MatcherContext delegates to a given {@link MatchHandler} to call {@link Matcher#match(MatcherContext)},\n * passing itself to the Matcher which executes its logic, potentially calling sub matchers.\n * For each sub matcher the matcher creates/initializes a sub context with {@link #getSubContext(org.parboiled.matchers.Matcher)}\n * and then calls {@link #runMatcher()} on it.<\/p>\n * <p>This basically creates a stack of MatcherContexts, each corresponding to their rule matchers. The MatcherContext\n * instances serve as companion objects to the matchers, providing them with support for building the\n * parse tree nodes, keeping track of input locations and error recovery.<\/p>\n * <p>At each point during the parsing process the matchers and action expressions have access to the current\n * MatcherContext and all \"open\" parent MatcherContexts through the {@link #getParent()} chain.<\/p>\n * <p>For performance reasons sub context instances are reused instead of being recreated. If a MatcherContext instance\n * returns null on a {@link #getMatcher()} call it has been retired (is invalid) and is waiting to be reinitialized\n * with a new Matcher by its parent<\/p>\n *\n * @param <V> the node value type\n */\npublic class MatcherContext<V> implements Context<V> {\n\n    private final InputBuffer inputBuffer;\n    private final List<ParseError> parseErrors;\n    private final MatchHandler<V> matchHandler;\n    private final Reference<Node<V>> lastNodeRef;\n    private final MatcherContext<V> parent;\n    private final int level;\n\n    private MatcherContext<V> subContext;\n    private InputLocation startLocation;\n    private InputLocation currentLocation;\n    private Matcher<V> matcher;\n    private Node<V> node;\n    private List<Node<V>> subNodes = ImmutableList.of();\n    private V nodeValue;\n    private boolean hasError;\n    private int intTag;\n    private boolean nodeSuppressed;\n\n    public MatcherContext(@NotNull InputBuffer inputBuffer, @NotNull InputLocation startLocation,\n                          @NotNull List<ParseError> parseErrors, @NotNull MatchHandler<V> matchHandler,\n                          @NotNull Matcher<V> matcher) {\n        this(inputBuffer, parseErrors, matchHandler, new Reference<Node<V>>(), null, 0);\n        this.startLocation = startLocation;\n        this.currentLocation = startLocation;\n        this.matcher = ProxyMatcher.unwrap(matcher);\n        this.nodeSuppressed = matcher.isNodeSuppressed();\n    }\n\n    private MatcherContext(@NotNull InputBuffer inputBuffer, @NotNull List<ParseError> parseErrors,\n                           @NotNull MatchHandler<V> matchHandler, @NotNull Reference<Node<V>> lastNodeRef,\n                           MatcherContext<V> parent, int level) {\n        this.inputBuffer = inputBuffer;\n        this.parseErrors = parseErrors;\n        this.matchHandler = matchHandler;\n        this.lastNodeRef = lastNodeRef;\n        this.parent = parent;\n        this.level = level;\n    }\n\n    @Override\n    public String toString() {\n        return getPath().toString();\n    }\n\n    //////////////////////////////// CONTEXT INTERFACE ////////////////////////////////////\n\n    public MatcherContext<V> getParent() {\n        return parent;\n    }\n\n    public MatcherContext<V> getSubContext() {\n        // if the subContext has a null matcher it has been retired and is invalid\n        return subContext != null && subContext.matcher != null ? subContext : null;\n    }\n\n    @NotNull\n    public InputBuffer getInputBuffer() {\n        return inputBuffer;\n    }\n\n    public InputLocation getStartLocation() {\n        return startLocation;\n    }\n\n    public Matcher<V> getMatcher() {\n        return matcher;\n    }\n\n    @NotNull\n    public List<ParseError> getParseErrors() {\n        return parseErrors;\n    }\n\n    public InputLocation getCurrentLocation() {\n        return currentLocation;\n    }\n\n    public String getNodeText(Node<V> node) {\n        return ParseTreeUtils.getNodeText(node, inputBuffer);\n    }\n\n    @NotNull\n    public MatcherPath<V> getPath() {\n        return new MatcherPath<V>(this);\n    }\n\n    public int getLevel() {\n        return level;\n    }\n\n    public V getNodeValue() {\n        return nodeValue;\n    }\n\n    public void setNodeValue(V value) {\n        this.nodeValue = value;\n    }\n\n    public V getTreeValue() {\n        V treeValue = nodeValue;\n        int i = subNodes.size();\n        while (treeValue == null && i-- > 0) {\n            treeValue = subNodes.get(i).getValue();\n        }\n        return treeValue;\n    }\n\n    public Node<V> getNodeByPath(String path) {\n        return findNodeByPath(subNodes, path);\n    }\n\n    public Node<V> getNodeByLabel(String labelPrefix) {\n        return findNode(subNodes, new LabelPrefixPredicate<V>(labelPrefix));\n    }\n\n    public Node<V> getLastNode() {\n        return lastNodeRef.getTarget();\n    }\n\n    @NotNull\n    public List<Node<V>> getSubNodes() {\n        return subNodes;\n    }\n\n    public char lookAhead(int delta) {\n        return currentLocation.lookAhead(inputBuffer, delta);\n    }\n\n    public boolean inPredicate() {\n        return matcher instanceof TestMatcher || parent != null && parent.inPredicate();\n    }\n\n    public boolean isNodeSuppressed() {\n        return nodeSuppressed;\n    }\n\n    public boolean hasError() {\n        return hasError;\n    }\n\n    //////////////////////////////// PUBLIC ////////////////////////////////////\n\n    public void setStartLocation(InputLocation startLocation) {\n        this.startLocation = startLocation;\n    }\n\n    public void setCurrentLocation(InputLocation currentLocation) {\n        this.currentLocation = currentLocation;\n    }\n\n    public void advanceInputLocation() {\n        setCurrentLocation(currentLocation.advance(inputBuffer));\n    }\n\n    public Node<V> getNode() {\n        return node;\n    }\n\n    public int getIntTag() {\n        return intTag;\n    }\n\n    public void setIntTag(int intTag) {\n        this.intTag = intTag;\n    }\n\n    public void markError() {\n        hasError = true;\n        if (parent != null) parent.markError();\n    }\n\n    public void clearNodeSuppression() {\n        nodeSuppressed = false;\n        if (parent != null) parent.clearNodeSuppression();\n    }\n\n    public void createNode() {\n        if (!nodeSuppressed) {\n            node = new NodeImpl<V>(matcher, subNodes, startLocation, currentLocation, getTreeValue(), hasError);\n            if (parent != null) parent.addChildNode(node);\n            lastNodeRef.setTarget(node);\n        }\n    }\n\n    @SuppressWarnings({\"fallthrough\"})\n    public void addChildNode(@NotNull Node<V> node) {\n        int size = subNodes.size();\n        if (size == 0) {\n            subNodes = ImmutableList.of(node);\n            return;\n        }\n        if (size == 1) {\n            Node<V> node0 = subNodes.get(0);\n            subNodes = new ArrayList<Node<V>>(4);\n            subNodes.add(node0);\n        }\n        subNodes.add(node);\n    }\n\n    public MatcherContext<V> getSubContext(Matcher<V> matcher) {\n        if (subContext == null) {\n            // introduce a new level\n            subContext = new MatcherContext<V>(inputBuffer, parseErrors, matchHandler, lastNodeRef, this, level + 1);\n        }\n\n        // normally just reuse the existing subContext instance\n        MatcherContext<V> sc = subContext;\n        sc.matcher = ProxyMatcher.unwrap(matcher);\n        sc.startLocation = sc.currentLocation = currentLocation;\n        sc.node = null;\n        sc.subNodes = ImmutableList.of();\n        sc.nodeValue = null;\n        sc.nodeSuppressed = nodeSuppressed || this.matcher.areSubnodesSuppressed() || matcher.isNodeSuppressed();\n        sc.hasError = false;\n        return sc;\n    }\n\n    public boolean runMatcher() {\n        try {\n            if (matchHandler.match(this)) {\n                if (parent != null) parent.setCurrentLocation(currentLocation);\n                matcher = null; // \"retire\" this context\n                return true;\n            }\n            matcher = null; // \"retire\" this context until is \"activated\" again by a getSubContext(...) on the parent\n            return false;\n        } catch (ParserRuntimeException e) {\n            throw e; // don't wrap, just bubble up\n        } catch (Throwable e) {\n            throw new ParserRuntimeException(e,\n                    printParseError(new BasicParseError(currentLocation,\n                            StringUtils.escape(String.format(\"Error while parsing %s '%s' at input position\",\n                                    matcher instanceof ActionMatcher ? \"action\" : \"rule\", getPath()))), inputBuffer));\n        }\n    }\n}\n","lineNo":247}
{"Refactored Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled;\n\nimport com.google.common.collect.ImmutableList;\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.common.Reference;\nimport org.parboiled.common.StringUtils;\nimport org.parboiled.errors.BasicParseError;\nimport org.parboiled.errors.ParseError;\nimport org.parboiled.errors.ParserRuntimeException;\nimport org.parboiled.matchers.ActionMatcher;\nimport org.parboiled.matchers.Matcher;\nimport org.parboiled.matchers.ProxyMatcher;\nimport org.parboiled.matchers.TestMatcher;\nimport org.parboiled.support.*;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.parboiled.errors.ErrorUtils.printParseError;\nimport static org.parboiled.support.ParseTreeUtils.findNode;\nimport static org.parboiled.support.ParseTreeUtils.findNodeByPath;\n\n/**\n * <p>The Context implementation orchestrating most of the matching process.<\/p>\n * <p>The parsing process works as following:<\/br>\n * After the rule tree (which is in fact a directed and potentially even cyclic graph of {@link Matcher} instances)\n * has been created a root MatcherContext is instantiated for the root rule (Matcher).\n * A subsequent call to {@link #runMatcher()} starts the parsing process.<\/p>\n * <p>The MatcherContext delegates to a given {@link MatchHandler} to call {@link Matcher#match(MatcherContext)},\n * passing itself to the Matcher which executes its logic, potentially calling sub matchers.\n * For each sub matcher the matcher creates/initializes a sub context with {@link #getSubContext(org.parboiled.matchers.Matcher)}\n * and then calls {@link #runMatcher()} on it.<\/p>\n * <p>This basically creates a stack of MatcherContexts, each corresponding to their rule matchers. The MatcherContext\n * instances serve as companion objects to the matchers, providing them with support for building the\n * parse tree nodes, keeping track of input locations and error recovery.<\/p>\n * <p>At each point during the parsing process the matchers and action expressions have access to the current\n * MatcherContext and all \"open\" parent MatcherContexts through the {@link #getParent()} chain.<\/p>\n * <p>For performance reasons sub context instances are reused instead of being recreated. If a MatcherContext instance\n * returns null on a {@link #getMatcher()} call it has been retired (is invalid) and is waiting to be reinitialized\n * with a new Matcher by its parent<\/p>\n *\n * @param <V> the node value type\n */\npublic class MatcherContext<V> implements Context<V> {\n\n    private final InputBuffer inputBuffer;\n    private final List<ParseError> parseErrors;\n    private final MatchHandler<V> matchHandler;\n    private final Reference<Node<V>> lastNodeRef;\n    private final MatcherContext<V> parent;\n    private final int level;\n\n    private MatcherContext<V> subContext;\n    private InputLocation startLocation;\n    private InputLocation currentLocation;\n    private Matcher<V> matcher;\n    private Node<V> node;\n    private List<Node<V>> subNodes = ImmutableList.of();\n    private V nodeValue;\n    private boolean hasError;\n    private int intTag;\n    private boolean nodeSuppressed;\n\n    public MatcherContext(@NotNull InputBuffer inputBuffer, @NotNull InputLocation startLocation,\n                          @NotNull List<ParseError> parseErrors, @NotNull MatchHandler<V> matchHandler,\n                          @NotNull Matcher<V> matcher) {\n        this(inputBuffer, parseErrors, matchHandler, new Reference<Node<V>>(), null, 0);\n        this.startLocation = startLocation;\n        this.currentLocation = startLocation;\n        this.matcher = ProxyMatcher.unwrap(matcher);\n        this.nodeSuppressed = matcher.isNodeSuppressed();\n    }\n\n    private MatcherContext(@NotNull InputBuffer inputBuffer, @NotNull List<ParseError> parseErrors,\n                           @NotNull MatchHandler<V> matchHandler, @NotNull Reference<Node<V>> lastNodeRef,\n                           MatcherContext<V> parent, int level) {\n        this.inputBuffer = inputBuffer;\n        this.parseErrors = parseErrors;\n        this.matchHandler = matchHandler;\n        this.lastNodeRef = lastNodeRef;\n        this.parent = parent;\n        this.level = level;\n    }\n\n    @Override\n    public String toString() {\n        return getPath().toString();\n    }\n\n    //////////////////////////////// CONTEXT INTERFACE ////////////////////////////////////\n\n    public MatcherContext<V> getParent() {\n        return parent;\n    }\n\n    public MatcherContext<V> getSubContext() {\n        // if the subContext has a null matcher it has been retired and is invalid\n        return subContext != null && subContext.matcher != null ? subContext : null;\n    }\n\n    @NotNull\n    public InputBuffer getInputBuffer() {\n        return inputBuffer;\n    }\n\n    public InputLocation getStartLocation() {\n        return startLocation;\n    }\n\n    public Matcher<V> getMatcher() {\n        return matcher;\n    }\n\n    @NotNull\n    public List<ParseError> getParseErrors() {\n        return parseErrors;\n    }\n\n    public InputLocation getCurrentLocation() {\n        return currentLocation;\n    }\n\n    public String getNodeText(Node<V> node) {\n        return ParseTreeUtils.getNodeText(node, inputBuffer);\n    }\n\n    @NotNull\n    public MatcherPath<V> getPath() {\n        return new MatcherPath<V>(this);\n    }\n\n    public int getLevel() {\n        return level;\n    }\n\n    public V getNodeValue() {\n        return nodeValue;\n    }\n\n    public void setNodeValue(V value) {\n        this.nodeValue = value;\n    }\n\n    public V getTreeValue() {\n        V treeValue = nodeValue;\n        int i = subNodes.size();\n        while (treeValue == null && i-- > 0) {\n            treeValue = subNodes.get(i).getValue();\n        }\n        return treeValue;\n    }\n\n    public Node<V> getNodeByPath(String path) {\n        return findNodeByPath(subNodes, path);\n    }\n\n    public Node<V> getNodeByLabel(String labelPrefix) {\n        return findNode(subNodes, new LabelPrefixPredicate<V>(labelPrefix));\n    }\n\n    public Node<V> getLastNode() {\n        return lastNodeRef.getTarget();\n    }\n\n    @NotNull\n    public List<Node<V>> getSubNodes() {\n        return subNodes;\n    }\n\n    public char lookAhead(int delta) {\n        return currentLocation.lookAhead(inputBuffer, delta);\n    }\n\n    public boolean inPredicate() {\n        return matcher instanceof TestMatcher || parent != null && parent.inPredicate();\n    }\n\n    public boolean isNodeSuppressed() {\n        return nodeSuppressed;\n    }\n\n    public boolean hasError() {\n        return hasError;\n    }\n\n    //////////////////////////////// PUBLIC ////////////////////////////////////\n\n    public void setStartLocation(InputLocation startLocation) {\n        this.startLocation = startLocation;\n    }\n\n    public void setCurrentLocation(InputLocation currentLocation) {\n        this.currentLocation = currentLocation;\n    }\n\n    public void advanceInputLocation() {\n        setCurrentLocation(currentLocation.advance(inputBuffer));\n    }\n\n    public Node<V> getNode() {\n        return node;\n    }\n\n    public int getIntTag() {\n        return intTag;\n    }\n\n    public void setIntTag(int intTag) {\n        this.intTag = intTag;\n    }\n\n    public void markError() {\n        hasError = true;\n        if (parent != null) parent.markError();\n    }\n\n    public void clearNodeSuppression() {\n        nodeSuppressed = false;\n        if (parent != null) parent.clearNodeSuppression();\n    }\n\n    public void createNode() {\n        if (!nodeSuppressed) {\n            node = new NodeImpl<V>(matcher, subNodes, startLocation, currentLocation, getTreeValue(), hasError);\n            if (parent != null) parent.addChildNode(node);\n            lastNodeRef.setTarget(node);\n        }\n    }\n\n    @SuppressWarnings({\"fallthrough\"})\n    public void addChildNode(@NotNull Node<V> node) {\n        int size = subNodes.size();\n        if (size == 0) {\n            subNodes = ImmutableList.of(node);\n            return;\n        }\n        if (size == 1) {\n            Node<V> node0 = subNodes.get(0);\n            subNodes = new ArrayList<Node<V>>(4);\n            subNodes.add(node0);\n        }\n        subNodes.add(node);\n    }\n\n    public MatcherContext<V> getSubContext(Matcher<V> matcher) {\n        if (subContext == null) {\n            // introduce a new level\n            subContext = new MatcherContext<V>(inputBuffer, parseErrors, matchHandler, lastNodeRef, this, level + 1);\n        }\n\n        // normally just reuse the existing subContext instance\n        MatcherContext<V> sc = subContext;\n        sc.matcher = ProxyMatcher.unwrap(matcher);\n        sc.startLocation = sc.currentLocation = currentLocation;\n        sc.node = null;\n        sc.subNodes = ImmutableList.of();\n        sc.nodeValue = null;\n        sc.nodeSuppressed = nodeSuppressed || this.matcher.areSubnodesSuppressed() || matcher.isNodeSuppressed();\n        sc.hasError = false;\n        return sc;\n    }\n\n    public boolean runMatcher() {\n        try {\n            if (matchHandler.match(this)) {\n                if (parent != null) parent.setCurrentLocation(currentLocation);\n                matcher = null; // \"retire\" this context\n                return true;\n            }\n            matcher = null; // \"retire\" this context until is \"activated\" again by a getSubContext(...) on the parent\n            return false;\n        } catch (ParserRuntimeException e) {\n            throw e; // don't wrap, just bubble up\n        } catch (Throwable e) {\n            throw new ParserRuntimeException(e,\n                    printParseError(new BasicParseError(currentLocation,\n                            StringUtils.escape(String.format(\"Error while parsing %s '%s' at input position\",\n                                    matcher instanceof ActionMatcher ? \"action\" : \"rule\", getPath()))), inputBuffer));\n        }\n    }\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled;\n\nimport com.google.common.collect.ImmutableList;\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.common.Reference;\nimport org.parboiled.common.StringUtils;\nimport org.parboiled.errors.BasicParseError;\nimport org.parboiled.errors.ParseError;\nimport org.parboiled.errors.ParserRuntimeException;\nimport org.parboiled.matchers.ActionMatcher;\nimport org.parboiled.matchers.Matcher;\nimport org.parboiled.matchers.ProxyMatcher;\nimport org.parboiled.matchers.TestMatcher;\nimport org.parboiled.support.*;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.parboiled.errors.ErrorUtils.printParseError;\nimport static org.parboiled.support.ParseTreeUtils.findNode;\nimport static org.parboiled.support.ParseTreeUtils.findNodeByPath;\n\n/**\n * <p>The Context implementation orchestrating most of the matching process.<\/p>\n * <p>The parsing process works as following:<\/br>\n * After the rule tree (which is in fact a directed and potentially even cyclic graph of {@link Matcher} instances)\n * has been created a root MatcherContext is instantiated for the root rule (Matcher).\n * A subsequent call to {@link #runMatcher()} starts the parsing process.<\/p>\n * <p>The MatcherContext delegates to a given {@link MatchHandler} to call {@link Matcher#match(MatcherContext)},\n * passing itself to the Matcher which executes its logic, potentially calling sub matchers.\n * For each sub matcher the matcher creates/initializes a sub context with {@link #getSubContext(org.parboiled.matchers.Matcher)}\n * and then calls {@link #runMatcher()} on it.<\/p>\n * <p>This basically creates a stack of MatcherContexts, each corresponding to their rule matchers. The MatcherContext\n * instances serve as companion objects to the matchers, providing them with support for building the\n * parse tree nodes, keeping track of input locations and error recovery.<\/p>\n * <p>At each point during the parsing process the matchers and action expressions have access to the current\n * MatcherContext and all \"open\" parent MatcherContexts through the {@link #getParent()} chain.<\/p>\n * <p>For performance reasons sub context instances are reused instead of being recreated. If a MatcherContext instance\n * returns null on a {@link #getMatcher()} call it has been retired (is invalid) and is waiting to be reinitialized\n * with a new Matcher by its parent<\/p>\n *\n * @param <V> the node value type\n */\npublic class MatcherContext<V> implements Context<V> {\n\n    private final InputBuffer inputBuffer;\n    private final List<ParseError> parseErrors;\n    private final MatchHandler<V> matchHandler;\n    private final Reference<Node<V>> lastNodeRef;\n    private final MatcherContext<V> parent;\n    private final int level;\n\n    private MatcherContext<V> subContext;\n    private InputLocation startLocation;\n    private InputLocation currentLocation;\n    private Matcher<V> matcher;\n    private Node<V> node;\n    private List<Node<V>> subNodes = ImmutableList.of();\n    private V nodeValue;\n    private boolean hasError;\n    private int intTag;\n    private boolean belowLeafLevel;\n\n    public MatcherContext(@NotNull InputBuffer inputBuffer, @NotNull InputLocation startLocation,\n                          @NotNull List<ParseError> parseErrors, @NotNull MatchHandler<V> matchHandler,\n                          @NotNull Matcher<V> matcher) {\n        this(inputBuffer, parseErrors, matchHandler, new Reference<Node<V>>(), null, 0);\n        this.startLocation = startLocation;\n        this.currentLocation = startLocation;\n        this.matcher = ProxyMatcher.unwrap(matcher);\n    }\n\n    private MatcherContext(@NotNull InputBuffer inputBuffer, @NotNull List<ParseError> parseErrors,\n                           @NotNull MatchHandler<V> matchHandler, @NotNull Reference<Node<V>> lastNodeRef,\n                           MatcherContext<V> parent, int level) {\n        this.inputBuffer = inputBuffer;\n        this.parseErrors = parseErrors;\n        this.matchHandler = matchHandler;\n        this.lastNodeRef = lastNodeRef;\n        this.parent = parent;\n        this.level = level;\n    }\n\n    @Override\n    public String toString() {\n        return getPath().toString();\n    }\n\n    //////////////////////////////// CONTEXT INTERFACE ////////////////////////////////////\n\n    public MatcherContext<V> getParent() {\n        return parent;\n    }\n\n    public MatcherContext<V> getSubContext() {\n        // if the subContext has a null matcher it has been retired and is invalid\n        return subContext != null && subContext.matcher != null ? subContext : null;\n    }\n\n    @NotNull\n    public InputBuffer getInputBuffer() {\n        return inputBuffer;\n    }\n\n    public InputLocation getStartLocation() {\n        return startLocation;\n    }\n\n    public Matcher<V> getMatcher() {\n        return matcher;\n    }\n\n    @NotNull\n    public List<ParseError> getParseErrors() {\n        return parseErrors;\n    }\n\n    public InputLocation getCurrentLocation() {\n        return currentLocation;\n    }\n\n    public String getNodeText(Node<V> node) {\n        return ParseTreeUtils.getNodeText(node, inputBuffer);\n    }\n\n    @NotNull\n    public MatcherPath<V> getPath() {\n        return new MatcherPath<V>(this);\n    }\n\n    public int getLevel() {\n        return level;\n    }\n\n    public V getNodeValue() {\n        return nodeValue;\n    }\n\n    public void setNodeValue(V value) {\n        this.nodeValue = value;\n    }\n\n    public V getTreeValue() {\n        V treeValue = nodeValue;\n        int i = subNodes.size();\n        while (treeValue == null && i-- > 0) {\n            treeValue = subNodes.get(i).getValue();\n        }\n        return treeValue;\n    }\n\n    public Node<V> getNodeByPath(String path) {\n        return findNodeByPath(subNodes, path);\n    }\n\n    public Node<V> getNodeByLabel(String labelPrefix) {\n        return findNode(subNodes, new LabelPrefixPredicate<V>(labelPrefix));\n    }\n\n    public Node<V> getLastNode() {\n        return lastNodeRef.getTarget();\n    }\n\n    @NotNull\n    public List<Node<V>> getSubNodes() {\n        return subNodes;\n    }\n\n    public char lookAhead(int delta) {\n        return currentLocation.lookAhead(inputBuffer, delta);\n    }\n\n    public boolean inPredicate() {\n        return matcher instanceof TestMatcher || parent != null && parent.inPredicate();\n    }\n\n    public boolean isBelowLeafLevel() {\n        return belowLeafLevel;\n    }\n\n    public boolean hasError() {\n        return hasError;\n    }\n\n    //////////////////////////////// PUBLIC ////////////////////////////////////\n\n    public void setStartLocation(InputLocation startLocation) {\n        this.startLocation = startLocation;\n    }\n\n    public void setCurrentLocation(InputLocation currentLocation) {\n        this.currentLocation = currentLocation;\n    }\n\n    public void advanceInputLocation() {\n        setCurrentLocation(currentLocation.advance(inputBuffer));\n    }\n\n    public Node<V> getNode() {\n        return node;\n    }\n\n    public int getIntTag() {\n        return intTag;\n    }\n\n    public void setIntTag(int intTag) {\n        this.intTag = intTag;\n    }\n\n    public void markError() {\n        hasError = true;\n        if (parent != null) parent.markError();\n    }\n\n    public void clearBelowLeafLevelMarker() {\n        belowLeafLevel = false;\n        if (parent != null) parent.clearBelowLeafLevelMarker();\n    }\n\n    public void createNode() {\n        if (belowLeafLevel || matcher instanceof TestMatcher) {\n            return;\n        }\n        node = new NodeImpl<V>(matcher, subNodes, startLocation, currentLocation, getTreeValue(), hasError);\n        if (parent != null) parent.addChildNode(node);\n        lastNodeRef.setTarget(node);\n    }\n\n    @SuppressWarnings({\"fallthrough\"})\n    public void addChildNode(@NotNull Node<V> node) {\n        switch (subNodes.size()) {\n            case 0:\n                subNodes = ImmutableList.of(node);\n                break;\n            case 1:\n                subNodes = ImmutableList.of(subNodes.get(0), node);\n                break;\n            case 2:\n                subNodes = ImmutableList.of(subNodes.get(0), subNodes.get(1), node);\n                break;\n            case 3:\n                subNodes = ImmutableList.of(subNodes.get(0), subNodes.get(1), subNodes.get(2), node);\n                break;\n            case 4:\n                Node<V> node0 = subNodes.get(0);\n                Node<V> node1 = subNodes.get(1);\n                Node<V> node2 = subNodes.get(2);\n                Node<V> node3 = subNodes.get(3);\n                subNodes = new ArrayList<Node<V>>();\n                subNodes.add(node0);\n                subNodes.add(node1);\n                subNodes.add(node2);\n                subNodes.add(node3);\n                // fall-through\n            default:\n                subNodes.add(node);\n                break;\n        }\n    }\n\n    public MatcherContext<V> getSubContext(Matcher<V> matcher) {\n        if (subContext == null) {\n            // introduce a new level\n            subContext = new MatcherContext<V>(inputBuffer, parseErrors, matchHandler, lastNodeRef, this, level + 1);\n        }\n\n        // normally just reuse the existing subContext instance\n        subContext.matcher = ProxyMatcher.unwrap(matcher);\n        subContext.startLocation = currentLocation;\n        subContext.currentLocation = currentLocation;\n        subContext.node = null;\n        subContext.subNodes = ImmutableList.of();\n        subContext.nodeValue = null;\n        subContext.belowLeafLevel = belowLeafLevel || this.matcher.isLeaf();\n        subContext.hasError = false;\n        return subContext;\n    }\n\n    public boolean runMatcher() {\n        try {\n            if (matchHandler.match(this)) {\n                if (parent != null) parent.setCurrentLocation(currentLocation);\n                matcher = null; // \"retire\" this context\n                return true;\n            }\n            matcher = null; // \"retire\" this context until is \"activated\" again by a getSubContext(...) on the parent\n            return false;\n        } catch (ParserRuntimeException e) {\n            throw e; // don't wrap, just bubble up\n        } catch (Throwable e) {\n            throw new ParserRuntimeException(e,\n                    printParseError(new BasicParseError(currentLocation,\n                            StringUtils.escape(String.format(\"Error while parsing %s '%s' at input position\",\n                                    matcher instanceof ActionMatcher ? \"action\" : \"rule\", getPath()))), inputBuffer));\n        }\n    }\n}\n","lineNo":248}
{"Refactored Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled;\n\nimport com.google.common.collect.ImmutableList;\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.common.Reference;\nimport org.parboiled.common.StringUtils;\nimport org.parboiled.errors.BasicParseError;\nimport org.parboiled.errors.ParseError;\nimport org.parboiled.errors.ParserRuntimeException;\nimport org.parboiled.matchers.ActionMatcher;\nimport org.parboiled.matchers.Matcher;\nimport org.parboiled.matchers.ProxyMatcher;\nimport org.parboiled.matchers.TestMatcher;\nimport org.parboiled.support.*;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.parboiled.errors.ErrorUtils.printParseError;\nimport static org.parboiled.support.ParseTreeUtils.findNode;\nimport static org.parboiled.support.ParseTreeUtils.findNodeByPath;\n\n/**\n * <p>The Context implementation orchestrating most of the matching process.<\/p>\n * <p>The parsing process works as following:<\/br>\n * After the rule tree (which is in fact a directed and potentially even cyclic graph of {@link Matcher} instances)\n * has been created a root MatcherContext is instantiated for the root rule (Matcher).\n * A subsequent call to {@link #runMatcher()} starts the parsing process.<\/p>\n * <p>The MatcherContext delegates to a given {@link MatchHandler} to call {@link Matcher#match(MatcherContext)},\n * passing itself to the Matcher which executes its logic, potentially calling sub matchers.\n * For each sub matcher the matcher creates/initializes a sub context with {@link #getSubContext(org.parboiled.matchers.Matcher)}\n * and then calls {@link #runMatcher()} on it.<\/p>\n * <p>This basically creates a stack of MatcherContexts, each corresponding to their rule matchers. The MatcherContext\n * instances serve as companion objects to the matchers, providing them with support for building the\n * parse tree nodes, keeping track of input locations and error recovery.<\/p>\n * <p>At each point during the parsing process the matchers and action expressions have access to the current\n * MatcherContext and all \"open\" parent MatcherContexts through the {@link #getParent()} chain.<\/p>\n * <p>For performance reasons sub context instances are reused instead of being recreated. If a MatcherContext instance\n * returns null on a {@link #getMatcher()} call it has been retired (is invalid) and is waiting to be reinitialized\n * with a new Matcher by its parent<\/p>\n *\n * @param <V> the node value type\n */\npublic class MatcherContext<V> implements Context<V> {\n\n    private final InputBuffer inputBuffer;\n    private final List<ParseError> parseErrors;\n    private final MatchHandler<V> matchHandler;\n    private final Reference<Node<V>> lastNodeRef;\n    private final MatcherContext<V> parent;\n    private final int level;\n\n    private MatcherContext<V> subContext;\n    private InputLocation startLocation;\n    private InputLocation currentLocation;\n    private Matcher<V> matcher;\n    private Node<V> node;\n    private List<Node<V>> subNodes = ImmutableList.of();\n    private V nodeValue;\n    private boolean hasError;\n    private int intTag;\n    private boolean nodeSuppressed;\n\n    public MatcherContext(@NotNull InputBuffer inputBuffer, @NotNull InputLocation startLocation,\n                          @NotNull List<ParseError> parseErrors, @NotNull MatchHandler<V> matchHandler,\n                          @NotNull Matcher<V> matcher) {\n        this(inputBuffer, parseErrors, matchHandler, new Reference<Node<V>>(), null, 0);\n        this.startLocation = startLocation;\n        this.currentLocation = startLocation;\n        this.matcher = ProxyMatcher.unwrap(matcher);\n        this.nodeSuppressed = matcher.isNodeSuppressed();\n    }\n\n    private MatcherContext(@NotNull InputBuffer inputBuffer, @NotNull List<ParseError> parseErrors,\n                           @NotNull MatchHandler<V> matchHandler, @NotNull Reference<Node<V>> lastNodeRef,\n                           MatcherContext<V> parent, int level) {\n        this.inputBuffer = inputBuffer;\n        this.parseErrors = parseErrors;\n        this.matchHandler = matchHandler;\n        this.lastNodeRef = lastNodeRef;\n        this.parent = parent;\n        this.level = level;\n    }\n\n    @Override\n    public String toString() {\n        return getPath().toString();\n    }\n\n    //////////////////////////////// CONTEXT INTERFACE ////////////////////////////////////\n\n    public MatcherContext<V> getParent() {\n        return parent;\n    }\n\n    public MatcherContext<V> getSubContext() {\n        // if the subContext has a null matcher it has been retired and is invalid\n        return subContext != null && subContext.matcher != null ? subContext : null;\n    }\n\n    @NotNull\n    public InputBuffer getInputBuffer() {\n        return inputBuffer;\n    }\n\n    public InputLocation getStartLocation() {\n        return startLocation;\n    }\n\n    public Matcher<V> getMatcher() {\n        return matcher;\n    }\n\n    @NotNull\n    public List<ParseError> getParseErrors() {\n        return parseErrors;\n    }\n\n    public InputLocation getCurrentLocation() {\n        return currentLocation;\n    }\n\n    public String getNodeText(Node<V> node) {\n        return ParseTreeUtils.getNodeText(node, inputBuffer);\n    }\n\n    @NotNull\n    public MatcherPath<V> getPath() {\n        return new MatcherPath<V>(this);\n    }\n\n    public int getLevel() {\n        return level;\n    }\n\n    public V getNodeValue() {\n        return nodeValue;\n    }\n\n    public void setNodeValue(V value) {\n        this.nodeValue = value;\n    }\n\n    public V getTreeValue() {\n        V treeValue = nodeValue;\n        int i = subNodes.size();\n        while (treeValue == null && i-- > 0) {\n            treeValue = subNodes.get(i).getValue();\n        }\n        return treeValue;\n    }\n\n    public Node<V> getNodeByPath(String path) {\n        return findNodeByPath(subNodes, path);\n    }\n\n    public Node<V> getNodeByLabel(String labelPrefix) {\n        return findNode(subNodes, new LabelPrefixPredicate<V>(labelPrefix));\n    }\n\n    public Node<V> getLastNode() {\n        return lastNodeRef.getTarget();\n    }\n\n    @NotNull\n    public List<Node<V>> getSubNodes() {\n        return subNodes;\n    }\n\n    public char lookAhead(int delta) {\n        return currentLocation.lookAhead(inputBuffer, delta);\n    }\n\n    public boolean inPredicate() {\n        return matcher instanceof TestMatcher || parent != null && parent.inPredicate();\n    }\n\n    public boolean isNodeSuppressed() {\n        return nodeSuppressed;\n    }\n\n    public boolean hasError() {\n        return hasError;\n    }\n\n    //////////////////////////////// PUBLIC ////////////////////////////////////\n\n    public void setStartLocation(InputLocation startLocation) {\n        this.startLocation = startLocation;\n    }\n\n    public void setCurrentLocation(InputLocation currentLocation) {\n        this.currentLocation = currentLocation;\n    }\n\n    public void advanceInputLocation() {\n        setCurrentLocation(currentLocation.advance(inputBuffer));\n    }\n\n    public Node<V> getNode() {\n        return node;\n    }\n\n    public int getIntTag() {\n        return intTag;\n    }\n\n    public void setIntTag(int intTag) {\n        this.intTag = intTag;\n    }\n\n    public void markError() {\n        hasError = true;\n        if (parent != null) parent.markError();\n    }\n\n    public void clearNodeSuppression() {\n        nodeSuppressed = false;\n        if (parent != null) parent.clearNodeSuppression();\n    }\n\n    public void createNode() {\n        if (!nodeSuppressed) {\n            node = new NodeImpl<V>(matcher, subNodes, startLocation, currentLocation, getTreeValue(), hasError);\n            if (parent != null) parent.addChildNode(node);\n            lastNodeRef.setTarget(node);\n        }\n    }\n\n    @SuppressWarnings({\"fallthrough\"})\n    public void addChildNode(@NotNull Node<V> node) {\n        int size = subNodes.size();\n        if (size == 0) {\n            subNodes = ImmutableList.of(node);\n            return;\n        }\n        if (size == 1) {\n            Node<V> node0 = subNodes.get(0);\n            subNodes = new ArrayList<Node<V>>(4);\n            subNodes.add(node0);\n        }\n        subNodes.add(node);\n    }\n\n    public MatcherContext<V> getSubContext(Matcher<V> matcher) {\n        if (subContext == null) {\n            // introduce a new level\n            subContext = new MatcherContext<V>(inputBuffer, parseErrors, matchHandler, lastNodeRef, this, level + 1);\n        }\n\n        // normally just reuse the existing subContext instance\n        MatcherContext<V> sc = subContext;\n        sc.matcher = ProxyMatcher.unwrap(matcher);\n        sc.startLocation = sc.currentLocation = currentLocation;\n        sc.node = null;\n        sc.subNodes = ImmutableList.of();\n        sc.nodeValue = null;\n        sc.nodeSuppressed = nodeSuppressed || this.matcher.areSubnodesSuppressed() || matcher.isNodeSuppressed();\n        sc.hasError = false;\n        return sc;\n    }\n\n    public boolean runMatcher() {\n        try {\n            if (matchHandler.match(this)) {\n                if (parent != null) parent.setCurrentLocation(currentLocation);\n                matcher = null; // \"retire\" this context\n                return true;\n            }\n            matcher = null; // \"retire\" this context until is \"activated\" again by a getSubContext(...) on the parent\n            return false;\n        } catch (ParserRuntimeException e) {\n            throw e; // don't wrap, just bubble up\n        } catch (Throwable e) {\n            throw new ParserRuntimeException(e,\n                    printParseError(new BasicParseError(currentLocation,\n                            StringUtils.escape(String.format(\"Error while parsing %s '%s' at input position\",\n                                    matcher instanceof ActionMatcher ? \"action\" : \"rule\", getPath()))), inputBuffer));\n        }\n    }\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled;\n\nimport com.google.common.collect.ImmutableList;\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.common.Reference;\nimport org.parboiled.common.StringUtils;\nimport org.parboiled.errors.BasicParseError;\nimport org.parboiled.errors.ParseError;\nimport org.parboiled.errors.ParserRuntimeException;\nimport org.parboiled.matchers.ActionMatcher;\nimport org.parboiled.matchers.Matcher;\nimport org.parboiled.matchers.ProxyMatcher;\nimport org.parboiled.matchers.TestMatcher;\nimport org.parboiled.support.*;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.parboiled.errors.ErrorUtils.printParseError;\nimport static org.parboiled.support.ParseTreeUtils.findNode;\nimport static org.parboiled.support.ParseTreeUtils.findNodeByPath;\n\n/**\n * <p>The Context implementation orchestrating most of the matching process.<\/p>\n * <p>The parsing process works as following:<\/br>\n * After the rule tree (which is in fact a directed and potentially even cyclic graph of {@link Matcher} instances)\n * has been created a root MatcherContext is instantiated for the root rule (Matcher).\n * A subsequent call to {@link #runMatcher()} starts the parsing process.<\/p>\n * <p>The MatcherContext delegates to a given {@link MatchHandler} to call {@link Matcher#match(MatcherContext)},\n * passing itself to the Matcher which executes its logic, potentially calling sub matchers.\n * For each sub matcher the matcher creates/initializes a sub context with {@link #getSubContext(org.parboiled.matchers.Matcher)}\n * and then calls {@link #runMatcher()} on it.<\/p>\n * <p>This basically creates a stack of MatcherContexts, each corresponding to their rule matchers. The MatcherContext\n * instances serve as companion objects to the matchers, providing them with support for building the\n * parse tree nodes, keeping track of input locations and error recovery.<\/p>\n * <p>At each point during the parsing process the matchers and action expressions have access to the current\n * MatcherContext and all \"open\" parent MatcherContexts through the {@link #getParent()} chain.<\/p>\n * <p>For performance reasons sub context instances are reused instead of being recreated. If a MatcherContext instance\n * returns null on a {@link #getMatcher()} call it has been retired (is invalid) and is waiting to be reinitialized\n * with a new Matcher by its parent<\/p>\n *\n * @param <V> the node value type\n */\npublic class MatcherContext<V> implements Context<V> {\n\n    private final InputBuffer inputBuffer;\n    private final List<ParseError> parseErrors;\n    private final MatchHandler<V> matchHandler;\n    private final Reference<Node<V>> lastNodeRef;\n    private final MatcherContext<V> parent;\n    private final int level;\n\n    private MatcherContext<V> subContext;\n    private InputLocation startLocation;\n    private InputLocation currentLocation;\n    private Matcher<V> matcher;\n    private Node<V> node;\n    private List<Node<V>> subNodes = ImmutableList.of();\n    private V nodeValue;\n    private boolean hasError;\n    private int intTag;\n    private boolean belowLeafLevel;\n\n    public MatcherContext(@NotNull InputBuffer inputBuffer, @NotNull InputLocation startLocation,\n                          @NotNull List<ParseError> parseErrors, @NotNull MatchHandler<V> matchHandler,\n                          @NotNull Matcher<V> matcher) {\n        this(inputBuffer, parseErrors, matchHandler, new Reference<Node<V>>(), null, 0);\n        this.startLocation = startLocation;\n        this.currentLocation = startLocation;\n        this.matcher = ProxyMatcher.unwrap(matcher);\n    }\n\n    private MatcherContext(@NotNull InputBuffer inputBuffer, @NotNull List<ParseError> parseErrors,\n                           @NotNull MatchHandler<V> matchHandler, @NotNull Reference<Node<V>> lastNodeRef,\n                           MatcherContext<V> parent, int level) {\n        this.inputBuffer = inputBuffer;\n        this.parseErrors = parseErrors;\n        this.matchHandler = matchHandler;\n        this.lastNodeRef = lastNodeRef;\n        this.parent = parent;\n        this.level = level;\n    }\n\n    @Override\n    public String toString() {\n        return getPath().toString();\n    }\n\n    //////////////////////////////// CONTEXT INTERFACE ////////////////////////////////////\n\n    public MatcherContext<V> getParent() {\n        return parent;\n    }\n\n    public MatcherContext<V> getSubContext() {\n        // if the subContext has a null matcher it has been retired and is invalid\n        return subContext != null && subContext.matcher != null ? subContext : null;\n    }\n\n    @NotNull\n    public InputBuffer getInputBuffer() {\n        return inputBuffer;\n    }\n\n    public InputLocation getStartLocation() {\n        return startLocation;\n    }\n\n    public Matcher<V> getMatcher() {\n        return matcher;\n    }\n\n    @NotNull\n    public List<ParseError> getParseErrors() {\n        return parseErrors;\n    }\n\n    public InputLocation getCurrentLocation() {\n        return currentLocation;\n    }\n\n    public String getNodeText(Node<V> node) {\n        return ParseTreeUtils.getNodeText(node, inputBuffer);\n    }\n\n    @NotNull\n    public MatcherPath<V> getPath() {\n        return new MatcherPath<V>(this);\n    }\n\n    public int getLevel() {\n        return level;\n    }\n\n    public V getNodeValue() {\n        return nodeValue;\n    }\n\n    public void setNodeValue(V value) {\n        this.nodeValue = value;\n    }\n\n    public V getTreeValue() {\n        V treeValue = nodeValue;\n        int i = subNodes.size();\n        while (treeValue == null && i-- > 0) {\n            treeValue = subNodes.get(i).getValue();\n        }\n        return treeValue;\n    }\n\n    public Node<V> getNodeByPath(String path) {\n        return findNodeByPath(subNodes, path);\n    }\n\n    public Node<V> getNodeByLabel(String labelPrefix) {\n        return findNode(subNodes, new LabelPrefixPredicate<V>(labelPrefix));\n    }\n\n    public Node<V> getLastNode() {\n        return lastNodeRef.getTarget();\n    }\n\n    @NotNull\n    public List<Node<V>> getSubNodes() {\n        return subNodes;\n    }\n\n    public char lookAhead(int delta) {\n        return currentLocation.lookAhead(inputBuffer, delta);\n    }\n\n    public boolean inPredicate() {\n        return matcher instanceof TestMatcher || parent != null && parent.inPredicate();\n    }\n\n    public boolean isBelowLeafLevel() {\n        return belowLeafLevel;\n    }\n\n    public boolean hasError() {\n        return hasError;\n    }\n\n    //////////////////////////////// PUBLIC ////////////////////////////////////\n\n    public void setStartLocation(InputLocation startLocation) {\n        this.startLocation = startLocation;\n    }\n\n    public void setCurrentLocation(InputLocation currentLocation) {\n        this.currentLocation = currentLocation;\n    }\n\n    public void advanceInputLocation() {\n        setCurrentLocation(currentLocation.advance(inputBuffer));\n    }\n\n    public Node<V> getNode() {\n        return node;\n    }\n\n    public int getIntTag() {\n        return intTag;\n    }\n\n    public void setIntTag(int intTag) {\n        this.intTag = intTag;\n    }\n\n    public void markError() {\n        hasError = true;\n        if (parent != null) parent.markError();\n    }\n\n    public void clearBelowLeafLevelMarker() {\n        belowLeafLevel = false;\n        if (parent != null) parent.clearBelowLeafLevelMarker();\n    }\n\n    public void createNode() {\n        if (belowLeafLevel || matcher instanceof TestMatcher) {\n            return;\n        }\n        node = new NodeImpl<V>(matcher, subNodes, startLocation, currentLocation, getTreeValue(), hasError);\n        if (parent != null) parent.addChildNode(node);\n        lastNodeRef.setTarget(node);\n    }\n\n    @SuppressWarnings({\"fallthrough\"})\n    public void addChildNode(@NotNull Node<V> node) {\n        switch (subNodes.size()) {\n            case 0:\n                subNodes = ImmutableList.of(node);\n                break;\n            case 1:\n                subNodes = ImmutableList.of(subNodes.get(0), node);\n                break;\n            case 2:\n                subNodes = ImmutableList.of(subNodes.get(0), subNodes.get(1), node);\n                break;\n            case 3:\n                subNodes = ImmutableList.of(subNodes.get(0), subNodes.get(1), subNodes.get(2), node);\n                break;\n            case 4:\n                Node<V> node0 = subNodes.get(0);\n                Node<V> node1 = subNodes.get(1);\n                Node<V> node2 = subNodes.get(2);\n                Node<V> node3 = subNodes.get(3);\n                subNodes = new ArrayList<Node<V>>();\n                subNodes.add(node0);\n                subNodes.add(node1);\n                subNodes.add(node2);\n                subNodes.add(node3);\n                // fall-through\n            default:\n                subNodes.add(node);\n                break;\n        }\n    }\n\n    public MatcherContext<V> getSubContext(Matcher<V> matcher) {\n        if (subContext == null) {\n            // introduce a new level\n            subContext = new MatcherContext<V>(inputBuffer, parseErrors, matchHandler, lastNodeRef, this, level + 1);\n        }\n\n        // normally just reuse the existing subContext instance\n        subContext.matcher = ProxyMatcher.unwrap(matcher);\n        subContext.startLocation = currentLocation;\n        subContext.currentLocation = currentLocation;\n        subContext.node = null;\n        subContext.subNodes = ImmutableList.of();\n        subContext.nodeValue = null;\n        subContext.belowLeafLevel = belowLeafLevel || this.matcher.isLeaf();\n        subContext.hasError = false;\n        return subContext;\n    }\n\n    public boolean runMatcher() {\n        try {\n            if (matchHandler.match(this)) {\n                if (parent != null) parent.setCurrentLocation(currentLocation);\n                matcher = null; // \"retire\" this context\n                return true;\n            }\n            matcher = null; // \"retire\" this context until is \"activated\" again by a getSubContext(...) on the parent\n            return false;\n        } catch (ParserRuntimeException e) {\n            throw e; // don't wrap, just bubble up\n        } catch (Throwable e) {\n            throw new ParserRuntimeException(e,\n                    printParseError(new BasicParseError(currentLocation,\n                            StringUtils.escape(String.format(\"Error while parsing %s '%s' at input position\",\n                                    matcher instanceof ActionMatcher ? \"action\" : \"rule\", getPath()))), inputBuffer));\n        }\n    }\n}\n","lineNo":268}
{"Refactored Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.examples.calculators;\n\nimport org.parboiled.BaseParser;\nimport org.parboiled.Parboiled;\nimport org.parboiled.RecoveringParseRunner;\nimport org.parboiled.Rule;\nimport org.parboiled.common.StringUtils;\nimport org.parboiled.support.ParsingResult;\nimport org.parboiled.support.ToStringFormatter;\nimport org.parboiled.trees.GraphNode;\n\nimport java.util.Scanner;\n\nimport static org.parboiled.errors.ErrorUtils.printParseErrors;\nimport static org.parboiled.support.ParseTreeUtils.printNodeTree;\nimport static org.parboiled.trees.GraphUtils.printTree;\n\n/**\n * Base class of all calculator parsers in the org.parboiled.examples.calculators package.\n * Simply add the public static main entry point.\n *\n * @param <V>\n */\npublic abstract class CalculatorParser<V> extends BaseParser<V> {\n\n    public abstract Rule InputLine();\n\n    @SuppressWarnings({\"unchecked\"})\n    public static <V, P extends CalculatorParser<V>> void main(Class<P> parserClass) {\n        CalculatorParser<V> parser = Parboiled.createParser(parserClass);\n\n        while (true) {\n            System.out.print(\"Enter a calculators expression (single RETURN to exit)!\\n\");\n            String input = new Scanner(System.in).nextLine();\n            if (StringUtils.isEmpty(input)) break;\n\n            ParsingResult<?> result = RecoveringParseRunner.run(parser.InputLine(), input);\n\n            if (result.hasErrors()) {\n                System.out.println(\"\\nParse Errors:\\n\" + printParseErrors(result.parseErrors, result.inputBuffer));\n            }\n\n            Object value = result.parseTreeRoot.getValue();\n            if (value != null) {\n                String str = value.toString();\n                int ix = str.indexOf('|');\n                if (ix >= 0) str = str.substring(ix + 2); // extract value part of AST node toString()\n                System.out.println(input + \" = \" + str + '\\n');\n            }\n            if (value instanceof GraphNode) {\n                System.out.println(\"\\nAbstract Syntax Tree:\\n\" +\n                        printTree((GraphNode) value, new ToStringFormatter(null)) + '\\n');\n            } else {\n                System.out.println(\"\\nParse Tree:\\n\" + printNodeTree(result) + '\\n');\n            }\n        }\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.examples.calculators;\n\nimport org.parboiled.BaseParser;\nimport org.parboiled.Parboiled;\nimport org.parboiled.RecoveringParseRunner;\nimport org.parboiled.Rule;\nimport org.parboiled.common.StringUtils;\nimport org.parboiled.support.ParsingResult;\n\nimport java.util.Scanner;\n\nimport static org.parboiled.support.ParseTreeUtils.printNodeTree;\n\n/**\n * Base class of all calculator parsers in the org.parboiled.examples.calculators package.\n * Simply add the public static main entry point.\n *\n * @param <V>\n */\npublic abstract class CalculatorParser<V> extends BaseParser<V> {\n\n    public abstract Rule InputLine();\n\n    public static <V, P extends CalculatorParser<V>> void main(Class<P> parserClass) {\n        CalculatorParser<V> parser = Parboiled.createParser(parserClass);\n\n        while (true) {\n            System.out.print(\"Enter a calculators expression (single RETURN to exit)!\\n\");\n            String input = new Scanner(System.in).nextLine();\n            if (StringUtils.isEmpty(input)) break;\n\n            ParsingResult<?> result = RecoveringParseRunner.run(parser.InputLine(), input);\n\n            System.out.println(input + \" = \" + result.parseTreeRoot.getValue() + '\\n');\n            System.out.println(\"Parse Tree:\\n\" + printNodeTree(result) + '\\n');\n\n            if (!result.matched) {\n                System.out.println(StringUtils.join(result.parseErrors, \"---\\n\"));\n            }\n        }\n    }\n\n}\n","lineNo":59}
{"Refactored Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.examples.calculators;\n\nimport org.parboiled.BaseParser;\nimport org.parboiled.Parboiled;\nimport org.parboiled.RecoveringParseRunner;\nimport org.parboiled.Rule;\nimport org.parboiled.common.StringUtils;\nimport org.parboiled.support.ParsingResult;\nimport org.parboiled.support.ToStringFormatter;\nimport org.parboiled.trees.GraphNode;\n\nimport java.util.Scanner;\n\nimport static org.parboiled.errors.ErrorUtils.printParseErrors;\nimport static org.parboiled.support.ParseTreeUtils.printNodeTree;\nimport static org.parboiled.trees.GraphUtils.printTree;\n\n/**\n * Base class of all calculator parsers in the org.parboiled.examples.calculators package.\n * Simply add the public static main entry point.\n *\n * @param <V>\n */\npublic abstract class CalculatorParser<V> extends BaseParser<V> {\n\n    public abstract Rule InputLine();\n\n    @SuppressWarnings({\"unchecked\"})\n    public static <V, P extends CalculatorParser<V>> void main(Class<P> parserClass) {\n        CalculatorParser<V> parser = Parboiled.createParser(parserClass);\n\n        while (true) {\n            System.out.print(\"Enter a calculators expression (single RETURN to exit)!\\n\");\n            String input = new Scanner(System.in).nextLine();\n            if (StringUtils.isEmpty(input)) break;\n\n            ParsingResult<?> result = RecoveringParseRunner.run(parser.InputLine(), input);\n\n            if (result.hasErrors()) {\n                System.out.println(\"\\nParse Errors:\\n\" + printParseErrors(result.parseErrors, result.inputBuffer));\n            }\n\n            Object value = result.parseTreeRoot.getValue();\n            if (value != null) {\n                String str = value.toString();\n                int ix = str.indexOf('|');\n                if (ix >= 0) str = str.substring(ix + 2); // extract value part of AST node toString()\n                System.out.println(input + \" = \" + str + '\\n');\n            }\n            if (value instanceof GraphNode) {\n                System.out.println(\"\\nAbstract Syntax Tree:\\n\" +\n                        printTree((GraphNode) value, new ToStringFormatter(null)) + '\\n');\n            } else {\n                System.out.println(\"\\nParse Tree:\\n\" + printNodeTree(result) + '\\n');\n            }\n        }\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.examples.calculators;\n\nimport org.parboiled.BaseParser;\nimport org.parboiled.Parboiled;\nimport org.parboiled.RecoveringParseRunner;\nimport org.parboiled.Rule;\nimport org.parboiled.common.StringUtils;\nimport org.parboiled.support.ParsingResult;\n\nimport java.util.Scanner;\n\nimport static org.parboiled.support.ParseTreeUtils.printNodeTree;\n\n/**\n * Base class of all calculator parsers in the org.parboiled.examples.calculators package.\n * Simply add the public static main entry point.\n *\n * @param <V>\n */\npublic abstract class CalculatorParser<V> extends BaseParser<V> {\n\n    public abstract Rule InputLine();\n\n    public static <V, P extends CalculatorParser<V>> void main(Class<P> parserClass) {\n        CalculatorParser<V> parser = Parboiled.createParser(parserClass);\n\n        while (true) {\n            System.out.print(\"Enter a calculators expression (single RETURN to exit)!\\n\");\n            String input = new Scanner(System.in).nextLine();\n            if (StringUtils.isEmpty(input)) break;\n\n            ParsingResult<?> result = RecoveringParseRunner.run(parser.InputLine(), input);\n\n            System.out.println(input + \" = \" + result.parseTreeRoot.getValue() + '\\n');\n            System.out.println(\"Parse Tree:\\n\" + printNodeTree(result) + '\\n');\n\n            if (!result.matched) {\n                System.out.println(StringUtils.join(result.parseErrors, \"---\\n\"));\n            }\n        }\n    }\n\n}\n","lineNo":61}
{"Refactored Sample":"/*\n * Copyright (C) 2009-2010 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.transform;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.objectweb.asm.ClassWriter;\nimport org.objectweb.asm.MethodVisitor;\nimport org.objectweb.asm.Opcodes;\nimport org.objectweb.asm.Type;\nimport org.objectweb.asm.tree.*;\nimport org.parboiled.support.Checks;\n\nimport java.util.HashSet;\nimport java.util.List;\n\nimport static org.parboiled.transform.AsmUtils.findLoadedClass;\nimport static org.parboiled.transform.AsmUtils.loadClass;\n\nabstract class GroupClassGenerator implements RuleMethodProcessor, Opcodes, Types {\n\n    private static final Object lock = new Object();\n\n    protected ParserClassNode classNode;\n    protected RuleMethod method;\n\n    public void process(@NotNull ParserClassNode classNode, @NotNull RuleMethod method) {\n        this.classNode = classNode;\n        this.method = method;\n\n        for (InstructionGroup group : method.getGroups()) {\n            if (appliesTo(group.getRoot())) {\n                loadGroupClass(group);\n            }\n        }\n    }\n\n    protected abstract boolean appliesTo(InstructionGraphNode group);\n\n    private void loadGroupClass(InstructionGroup group) {\n        createGroupClassType(group);\n        String className = group.getGroupClassType().getClassName();\n        ClassLoader classLoader = classNode.getParentClass().getClassLoader();\n\n        Class<?> groupClass;\n        synchronized (lock) {\n            groupClass = findLoadedClass(className, classLoader);\n            if (groupClass == null) {\n                byte[] groupClassCode = generateGroupClassCode(group);\n                group.setGroupClassCode(groupClassCode);\n                groupClass = loadClass(className, groupClassCode, classLoader);\n            }\n        }\n        group.setGroupClass(groupClass);\n    }\n\n    private void createGroupClassType(InstructionGroup group) {\n        String s = classNode.name;\n        String groupClassInternalName = s.substring(0, classNode.name.lastIndexOf('/')) + '/' + group.getName();\n        group.setGroupClassType(Type.getObjectType(groupClassInternalName));\n    }\n\n    protected byte[] generateGroupClassCode(InstructionGroup group) {\n        ClassWriter classWriter = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n        generateClassBasics(group, classWriter);\n        generateFields(group, classWriter);\n        generateConstructor(classWriter);\n        generateMethod(group, classWriter);\n        return classWriter.toByteArray();\n    }\n\n    private void generateClassBasics(InstructionGroup group, ClassWriter cw) {\n        cw.visit(V1_5, ACC_PUBLIC + ACC_FINAL, group.getGroupClassType().getInternalName(), null,\n                getBaseType().getInternalName(), null);\n        cw.visitSource(classNode.sourceFile, null);\n    }\n\n    protected abstract Type getBaseType();\n\n    private void generateFields(InstructionGroup group, ClassWriter cw) {\n        for (FieldNode field : group.getFields()) {\n            // CAUTION: the FieldNode has illegal access flags and an illegal value field since these two members\n            // are reused for other purposes, so we need to write out the field \"manually\" here rather than\n            // just call \"field.accept(cw)\"\n            cw.visitField(ACC_PUBLIC + ACC_SYNTHETIC, field.name, field.desc, null, null);\n        }\n    }\n\n    private void generateConstructor(ClassWriter cw) {\n        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"(Ljava/lang/String;)V\", null, null);\n        mv.visitVarInsn(ALOAD, 0);\n        mv.visitVarInsn(ALOAD, 1);\n        mv.visitMethodInsn(INVOKESPECIAL, getBaseType().getInternalName(), \"<init>\", \"(Ljava/lang/String;)V\");\n        mv.visitInsn(RETURN);\n        mv.visitMaxs(0, 0); // trigger automatic computing\n    }\n\n    protected abstract void generateMethod(InstructionGroup group, ClassWriter cw);\n\n    protected void fixContextSwitches(InstructionGroup group) {\n        List<InstructionGraphNode> nodes = group.getNodes();\n        InsnList instructions = group.getInstructions();\n        for (int i = 0, nodesSize = nodes.size(); i < nodesSize; i++) {\n            InstructionGraphNode node = nodes.get(i);\n            if (!node.isContextSwitch()) continue;\n\n            // insert context switch\n            String contextSwitchType = ((MethodInsnNode) node.getInstruction()).name;\n            AbstractInsnNode firstInsn = getFirstOfSubtree(node, new HashSet<InstructionGraphNode>()).getInstruction();\n            instructions.insertBefore(firstInsn, new VarInsnNode(ALOAD, 0));\n            instructions.insertBefore(firstInsn, new MethodInsnNode(INVOKEVIRTUAL,\n                    getBaseType().getInternalName(), contextSwitchType, \"()V\"));\n\n            // replace original context-switching call with the opposite one, reversing the context switch done before\n            instructions.insertBefore(node.getInstruction(), new VarInsnNode(ALOAD, 0));\n            instructions.set(node.getInstruction(), new MethodInsnNode(INVOKEVIRTUAL,\n                    getBaseType().getInternalName(), contextSwitchType.startsWith(\"UP\") ? contextSwitchType\n                            .replace(\"UP\", \"DOWN\") : contextSwitchType.replace(\"DOWN\", \"UP\"), \"()V\"));\n        }\n    }\n\n    protected void insertSetContextCalls(InstructionGroup group) {\n        InsnList instructions = group.getInstructions();\n        for (InstructionGraphNode node : group.getNodes()) {\n            if (!node.isCallOnContextAware()) continue;\n\n            AbstractInsnNode loadTarget = node.getPredecessors().get(0).getInstruction();\n            Checks.ensure(loadTarget.getOpcode() == ALOAD, \"Error during bytecode analysis of rule method '%s': \" +\n                    \"Unusual call on ContextAware\", method.name);\n            AbstractInsnNode afterFirstInsn = loadTarget.getNext();\n            instructions.insertBefore(afterFirstInsn, new InsnNode(DUP));\n            instructions.insertBefore(afterFirstInsn, new VarInsnNode(ALOAD, 0));\n            instructions.insertBefore(afterFirstInsn, new FieldInsnNode(GETFIELD,\n                    group.getGroupClassType().getInternalName(), \"context\", CONTEXT_DESC));\n            instructions.insertBefore(afterFirstInsn, new MethodInsnNode(INVOKEINTERFACE,\n                    CONTEXT_AWARE.getInternalName(), \"setContext\", \"(\" + CONTEXT_DESC + \")V\"));\n        }\n    }\n\n    protected void convertXLoads(InstructionGroup group) {\n        String owner = group.getGroupClassType().getInternalName();\n        for (InstructionGraphNode node : group.getNodes()) {\n            if (!node.isXLoad()) continue;\n\n            VarInsnNode insn = (VarInsnNode) node.getInstruction();\n            FieldNode field = group.getFields().get(insn.var);\n\n            // insert the correct GETFIELD after the xLoad\n            group.getInstructions().insert(insn, new FieldInsnNode(GETFIELD, owner, field.name, field.desc));\n\n            // change the load to ALOAD 0\n            group.getInstructions().set(insn, new VarInsnNode(ALOAD, 0));\n        }\n    }\n\n    public static InstructionGraphNode getFirstOfSubtree(InstructionGraphNode node,\n                                                         HashSet<InstructionGraphNode> covered) {\n        InstructionGraphNode first = node;\n        if (!covered.contains(node)) {\n            covered.add(node);\n            for (InstructionGraphNode predecessor : node.getPredecessors()) {\n                InstructionGraphNode firstOfPred = getFirstOfSubtree(predecessor, covered);\n                if (first.getOriginalIndex() > firstOfPred.getOriginalIndex()) {\n                    first = firstOfPred;\n                }\n            }\n        }\n        return first;\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009-2010 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.transform;\n\nimport com.google.common.base.Preconditions;\nimport org.jetbrains.annotations.NotNull;\nimport org.objectweb.asm.ClassWriter;\nimport org.objectweb.asm.MethodVisitor;\nimport org.objectweb.asm.Opcodes;\nimport org.objectweb.asm.Type;\nimport org.objectweb.asm.tree.*;\nimport org.parboiled.support.Checks;\n\nimport java.util.List;\n\nimport static org.parboiled.transform.AsmUtils.findLoadedClass;\nimport static org.parboiled.transform.AsmUtils.loadClass;\n\nabstract class GroupClassGenerator implements RuleMethodProcessor, Opcodes, Types {\n\n    private static final Object lock = new Object();\n\n    protected ParserClassNode classNode;\n    protected RuleMethod method;\n\n    public void process(@NotNull ParserClassNode classNode, @NotNull RuleMethod method) {\n        this.classNode = classNode;\n        this.method = method;\n\n        for (InstructionGroup group : method.getGroups()) {\n            if (appliesTo(group.getRoot())) {\n                loadGroupClass(group);\n            }\n        }\n    }\n\n    protected abstract boolean appliesTo(InstructionGraphNode group);\n\n    private void loadGroupClass(InstructionGroup group) {\n        createGroupClassType(group);\n        String className = group.getGroupClassType().getClassName();\n        ClassLoader classLoader = classNode.parentClass.getClassLoader();\n\n        Class<?> groupClass;\n        synchronized (lock) {\n            groupClass = findLoadedClass(className, classLoader);\n            if (groupClass == null) {\n                byte[] groupClassCode = generateGroupClassCode(group);\n                groupClass = loadClass(className, groupClassCode, classLoader);\n            }\n        }\n        group.setGroupClass(groupClass);\n    }\n\n    private void createGroupClassType(InstructionGroup group) {\n        String s = classNode.name;\n        String groupClassInternalName = s.substring(0, classNode.name.lastIndexOf('/')) + '/' + group.getName();\n        group.setGroupClassType(Type.getObjectType(groupClassInternalName));\n    }\n\n    protected byte[] generateGroupClassCode(InstructionGroup group) {\n        ClassWriter classWriter = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n        generateClassBasics(group, classWriter);\n        generateFields(group, classWriter);\n        generateConstructor(classWriter);\n        generateMethod(group, classWriter);\n        return classWriter.toByteArray();\n    }\n\n    private void generateClassBasics(InstructionGroup group, ClassWriter cw) {\n        cw.visit(V1_5, ACC_PUBLIC + ACC_FINAL, group.getGroupClassType().getInternalName(), null,\n                getBaseType().getInternalName(), null);\n        cw.visitSource(classNode.sourceFile, null);\n    }\n\n    protected abstract Type getBaseType();\n\n    private void generateFields(InstructionGroup group, ClassWriter cw) {\n        FieldNode[] fields = group.getFields();\n        for (InstructionGraphNode node : group.getNodes()) {\n            if (node.isXLoad()) {\n                VarInsnNode insn = (VarInsnNode) node.getInstruction();\n                if (fields[insn.var] == null) {\n                    FieldNode field = new FieldNode(ACC_PUBLIC + ACC_SYNTHETIC, \"field$\" + insn.var,\n                            node.getResultValue().getType().getDescriptor(), null, null);\n                    field.accept(cw);\n                    fields[insn.var] = field;\n                }\n            }\n        }\n    }\n\n    private void generateConstructor(ClassWriter cw) {\n        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"(Ljava/lang/String;)V\", null, null);\n        mv.visitVarInsn(ALOAD, 0);\n        mv.visitVarInsn(ALOAD, 1);\n        mv.visitMethodInsn(INVOKESPECIAL, getBaseType().getInternalName(), \"<init>\", \"(Ljava/lang/String;)V\");\n        mv.visitInsn(RETURN);\n        mv.visitMaxs(0, 0); // trigger automatic computing\n    }\n\n    protected abstract void generateMethod(InstructionGroup group, ClassWriter cw);\n\n    protected void fixContextSwitches(InstructionGroup group) {\n        List<InstructionGraphNode> nodes = group.getNodes();\n        InsnList instructions = group.getInstructions();\n        for (int i = 0, nodesSize = nodes.size(); i < nodesSize; i++) {\n            InstructionGraphNode node = nodes.get(i);\n            if (!node.isContextSwitch()) continue;\n\n            // insert context switch\n            String contextSwitchType = ((MethodInsnNode) node.getInstruction()).name;\n            InstructionGraphNode firstNode = getFirstOfSubtree(node);\n            AbstractInsnNode firstInsn = firstNode.getInstruction();\n            Checks.ensure(firstInsn == node.getPredecessors().get(0).getInstruction() &&\n                    firstInsn.getOpcode() == ALOAD, \"Error during bytecode analysis of rule method '%s': \" +\n                    \"Unusual context switch call\", method.name);\n            instructions.insertBefore(firstInsn, new VarInsnNode(ALOAD, 0));\n            instructions.insertBefore(firstInsn, new MethodInsnNode(INVOKEVIRTUAL,\n                    getBaseType().getInternalName(), contextSwitchType, \"()V\"));\n\n            // remove the target loading instruction\n            instructions.remove(firstInsn);\n            nodes.remove(firstNode);\n            i--; // correct current index since the removed node always has a lower index\n\n            // replace original context-switching call with the opposite one, reversing the context switch done before\n            instructions.insertBefore(node.getInstruction(), new VarInsnNode(ALOAD, 0));\n            instructions.set(node.getInstruction(), new MethodInsnNode(INVOKEVIRTUAL,\n                    getBaseType().getInternalName(), contextSwitchType.startsWith(\"UP\") ? contextSwitchType\n                            .replace(\"UP\", \"DOWN\") : contextSwitchType.replace(\"DOWN\", \"UP\"), \"()V\"));\n        }\n    }\n\n    protected void insertSetContextCalls(InstructionGroup group) {\n        InsnList instructions = group.getInstructions();\n        for (InstructionGraphNode node : group.getNodes()) {\n            if (!node.isCallOnContextAware()) continue;\n\n            AbstractInsnNode firstInsn = getFirstOfSubtree(node).getInstruction();\n            Checks.ensure(firstInsn == node.getPredecessors().get(0).getInstruction() &&\n                    firstInsn.getOpcode() == ALOAD, \"Error during bytecode analysis of rule method '%s': \" +\n                    \"Unusual call on ContextAware\", method.name);\n            AbstractInsnNode afterFirstInsn = firstInsn.getNext();\n            instructions.insertBefore(afterFirstInsn, new InsnNode(DUP));\n            instructions.insertBefore(afterFirstInsn, new VarInsnNode(ALOAD, 0));\n            instructions.insertBefore(afterFirstInsn, new FieldInsnNode(GETFIELD,\n                    group.getGroupClassType().getInternalName(), \"context\", CONTEXT_DESC));\n            instructions.insertBefore(afterFirstInsn, new MethodInsnNode(INVOKEINTERFACE,\n                    CONTEXT_AWARE.getInternalName(), \"setContext\", \"(\" + CONTEXT_DESC + \")V\"));\n        }\n    }\n\n    protected void convertXLoads(InstructionGroup group) {\n        for (InstructionGraphNode node : group.getNodes()) {\n            if (!node.isXLoad()) continue;\n\n            VarInsnNode insn = (VarInsnNode) node.getInstruction();\n            FieldNode field = group.getFields()[insn.var];\n\n            // change the load to ALOAD 0\n            group.getInstructions().set(insn, new VarInsnNode(ALOAD, 0));\n\n            // insert the correct GETFIELD after the xLoad\n            group.getInstructions().insert(insn, new FieldInsnNode(GETFIELD,\n                    group.getGroupClassType().getInternalName(), field.name, field.desc));\n\n        }\n    }\n\n    protected void removeWrapper(InstructionGroup group) {\n        InstructionGraphNode node = group.getRoot();\n        AbstractInsnNode insn = group.getInstructions().getLast();\n        Preconditions.checkState(node.getInstruction() == insn);\n\n        if (insn.getPrevious().getOpcode() == SWAP && insn.getPrevious().getPrevious().getOpcode() == ALOAD) {\n            group.getInstructions().remove(insn.getPrevious().getPrevious());\n            group.getInstructions().remove(insn.getPrevious());\n        } else {\n            AbstractInsnNode firstInsn = getFirstOfSubtree(node).getInstruction();\n            Checks.ensure(firstInsn == node.getPredecessors().get(0).getInstruction() &&\n                    firstInsn.getOpcode() == ALOAD, \"Error during bytecode analysis of rule method '%s': \" +\n                    \"Unusual explicit action or capture\", method.name);\n            group.getInstructions().remove(firstInsn);\n        }\n        group.getInstructions().remove(insn);\n    }\n\n    public static InstructionGraphNode getFirstOfSubtree(InstructionGraphNode node) {\n        InstructionGraphNode first = node;\n        for (InstructionGraphNode predecessor : node.getPredecessors()) {\n            InstructionGraphNode firstOfPred = getFirstOfSubtree(predecessor);\n            if (first.getOriginalIndex() > firstOfPred.getOriginalIndex()) {\n                first = firstOfPred;\n            }\n        }\n        return first;\n    }\n\n}\n","lineNo":154}
{"Refactored Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled;\n\nimport com.google.common.base.Preconditions;\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.errors.ParserRuntimeException;\nimport org.parboiled.matchers.*;\nimport org.parboiled.support.Cached;\nimport org.parboiled.support.Characters;\n\nimport static com.google.common.collect.ObjectArrays.concat;\nimport static org.parboiled.common.StringUtils.escape;\n\n/**\n * Base class of all parboiled parsers. Defines the basic rule creation methods.\n *\n * @param <V> the type of the value field of the parse tree nodes created by this parser\n */\npublic abstract class BaseParser<V> extends BaseActions<V> {\n\n    /**\n     * Explicitly creates a rule matching the given character. Normally you can just specify the character literal\n     * directly in you rule description. However, if you don't want to go through {@link #fromCharLiteral(char)},\n     * e.g. because you redefined it, you can also use this wrapper.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param c the char to match\n     * @return a new rule\n     */\n    @Cached\n    public Rule ch(char c) {\n        return new CharMatcher(c).defaultLabel(\"\\'\" + escape(c) + '\\'');\n    }\n\n    /**\n     * Explicitly creates a rule matching the given character case-independently.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param c the char to match independently of its case\n     * @return a new rule\n     */\n    @Cached\n    public Rule charIgnoreCase(char c) {\n        if (Character.isLowerCase(c) == Character.isUpperCase(c)) {\n            return ch(c);\n        }\n        CharIgnoreCaseMatcher matcher = new CharIgnoreCaseMatcher(c);\n        return matcher.defaultLabel(\"\\'\" + escape(matcher.charLow) + '/' + escape(matcher.charUp) + '\\'');\n    }\n\n    /**\n     * Creates a rule matching a range of characters from cLow to cHigh (both inclusively).\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * arguments will yield the same rule instance.<\/p>\n     *\n     * @param cLow  the start char of the range (inclusively)\n     * @param cHigh the end char of the range (inclusively)\n     * @return a new rule\n     */\n    @Cached\n    public Rule charRange(char cLow, char cHigh) {\n        return cLow == cHigh ? ch(cLow) :\n                new CharRangeMatcher(cLow, cHigh).defaultLabel(escape(cLow) + \"..\" + escape(cHigh));\n    }\n\n    /**\n     * Creates a new rule that matches any of the characters in the given string.\n     * <p>Note: This methods provides caching, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param characters the characters\n     * @return a new rule\n     */\n    public Rule charSet(@NotNull String characters) {\n        return charSet(characters.toCharArray());\n    }\n\n    /**\n     * Creates a new rule that matches any of the characters in the given char array.\n     * <p>Note: This methods provides caching, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param characters the characters\n     * @return a new rule\n     */\n    public Rule charSet(@NotNull char... characters) {\n        Preconditions.checkArgument(characters.length > 0);\n        return characters.length == 1 ? ch(characters[0]) : charSet(Characters.of(characters));\n    }\n\n    /**\n     * Creates a new rule that matches any of the given characters.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param characters the characters\n     * @return a new rule\n     */\n    @Cached\n    public Rule charSet(@NotNull Characters characters) {\n        if (!characters.isSubtractive() && characters.getChars().length == 1) {\n            return ch(characters.getChars()[0]);\n        }\n        return new CharactersMatcher<V>(characters).defaultLabel(characters.toString());\n    }\n\n    /**\n     * Explicitly creates a rule matching the given string. Normally you can just specify the string literal\n     * directly in you rule description. However, if you want to not go through {@link #fromStringLiteral(String)},\n     * e.g. because you redefined it, you can also use this wrapper.\n     * <p>Note: This methods provides caching, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param string the string to match\n     * @return a new rule\n     */\n    public Rule string(@NotNull String string) {\n        return string(string.toCharArray());\n    }\n\n    /**\n     * Explicitly creates a rule matching the given string. Normally you can just specify the string literal\n     * directly in you rule description. However, if you want to not go through {@link #fromStringLiteral(String)},\n     * e.g. because you redefined it, you can also use this wrapper.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param characters the characters of the string to match\n     * @return a new rule\n     */\n    @Cached\n    public Rule string(char... characters) {\n        if (characters.length == 1) return ch(characters[0]); // optimize one-char strings\n        Rule[] matchers = new Rule[characters.length];\n        for (int i = 0; i < characters.length; i++) {\n            matchers[i] = ch(characters[i]);\n        }\n        return ((SequenceMatcher)sequence(matchers)).defaultLabel('\"' + String.valueOf(characters) + '\"').asLeaf();\n    }\n\n    /**\n     * Explicitly creates a rule matching the given string in a case-independent fashion.\n     * <p>Note: This methods provides caching, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param string the string to match\n     * @return a new rule\n     */\n    public Rule stringIgnoreCase(@NotNull String string) {\n        return stringIgnoreCase(string.toCharArray());\n    }\n\n    /**\n     * Explicitly creates a rule matching the given string in a case-independent fashion.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param characters the characters of the string to match\n     * @return a new rule\n     */\n    @Cached\n    public Rule stringIgnoreCase(char... characters) {\n        if (characters.length == 1) return charIgnoreCase(characters[0]); // optimize one-char strings\n        Rule[] matchers = new Rule[characters.length];\n        for (int i = 0; i < characters.length; i++) {\n            matchers[i] = charIgnoreCase(characters[i]);\n        }\n        return ((SequenceMatcher)sequence(matchers)).defaultLabel('\"' + String.valueOf(characters) + '\"').asLeaf();\n    }\n\n    /**\n     * Creates a new rule that successively tries all of the given subrules and succeeds when the first one of\n     * its subrules matches. If all subrules fail this rule fails as well.\n     * <p>Note: This methods provides caching, which means that multiple invocations with the same\n     * arguments will yield the same rule instance.<\/p>\n     *\n     * @param rule      the first subrule\n     * @param rule2     the second subrule\n     * @param moreRules the other subrules\n     * @return a new rule\n     */\n    public Rule firstOf(Object rule, Object rule2, @NotNull Object... moreRules) {\n        return firstOf(concat(rule, concat(rule2, moreRules)));\n    }\n\n    /**\n     * Creates a new rule that successively tries all of the given subrules and succeeds when the first one of\n     * its subrules matches. If all subrules fail this rule fails as well.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param rules the subrules\n     * @return a new rule\n     */\n    @Cached\n    public Rule firstOf(@NotNull Object[] rules) {\n        return rules.length == 1 ? toRule(rules[0]) : new FirstOfMatcher(toRules(rules)).defaultLabel(\"firstOf\");\n    }\n\n    /**\n     * Creates a new rule that tries repeated matches of its subrule and succeeds if the subrule matches at least once.\n     * If the subrule does not match at least once this rule fails.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    @Cached\n    public Rule oneOrMore(Object rule) {\n        return new OneOrMoreMatcher(toRule(rule)).defaultLabel(\"oneOrMore\");\n    }\n\n    /**\n     * Creates a new rule that tries a match on its subrule and always succeeds, independently of the matching\n     * success of its subrule.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    @Cached\n    public Rule optional(Object rule) {\n        return new OptionalMatcher(toRule(rule)).defaultLabel(\"optional\");\n    }\n\n    /**\n     * Creates a new rule that only succeeds if all of its subrule succeed, one after the other.\n     * <p>Note: This methods provides caching, which means that multiple invocations with the same\n     * arguments will yield the same rule instance.<\/p>\n     *\n     * @param rule      the first subrule\n     * @param rule2     the second subrule\n     * @param moreRules the other subrules\n     * @return a new rule\n     */\n    public Rule sequence(Object rule, Object rule2, @NotNull Object... moreRules) {\n        return sequence(concat(rule, concat(rule2, moreRules)));\n    }\n\n    /**\n     * Creates a new rule that only succeeds if all of its subrule succeed, one after the other.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * arguments will yield the same rule instance.<\/p>\n     *\n     * @param rules the sub rules\n     * @return a new rule\n     */\n    @Cached\n    public Rule sequence(@NotNull Object[] rules) {\n        return rules.length == 1 ? toRule(rules[0]) : new SequenceMatcher(toRules(rules)).defaultLabel(\"sequence\");\n    }\n\n    /**\n     * Creates a new rule that acts as a syntactic predicate, i.e. tests the given subrule against the current\n     * input position without actually matching any characters. Succeeds if the subrule succeeds and fails if the\n     * subrule rails. Since this rule does not actually consume any input it will never create a parse tree node.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    @Cached\n    public Rule test(Object rule) {\n        Rule subMatcher = toRule(rule);\n        return new TestMatcher(subMatcher).defaultLabel(\"&(\" + subMatcher + \")\");\n    }\n\n    /**\n     * Creates a new rule that acts as an inverse syntactic predicate, i.e. tests the given subrule against the current\n     * input position without actually matching any characters. Succeeds if the subrule fails and fails if the\n     * subrule succeeds. Since this rule does not actually consume any input it will never create a parse tree node.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    @Cached\n    public Rule testNot(Object rule) {\n        Rule subMatcher = toRule(rule);\n        return new TestNotMatcher(subMatcher).defaultLabel(\"!(\" + subMatcher + \")\");\n    }\n\n    /**\n     * Creates a new rule that tries repeated matches of its subrule.\n     * Succeeds always, even if the subrule doesn't match even once.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    @Cached\n    public Rule zeroOrMore(Object rule) {\n        return new ZeroOrMoreMatcher(toRule(rule)).defaultLabel(\"zeroOrMore\");\n    }\n\n    /**\n     * Matches the EOI (end of input) character.\n     *\n     * @return a new rule\n     */\n    public Rule eoi() {\n        return ch(Characters.EOI).label(\"EOI\");\n    }\n\n    /**\n     * Matches any character except {@link Characters#EOI}.\n     *\n     * @return a new rule\n     */\n    public Rule any() {\n        return new CharactersMatcher<V>(Characters.allBut(Characters.EOI)).label(\"ANY\");\n    }\n\n    /**\n     * Matches nothing and therefore always succeeds.\n     *\n     * @return a new rule\n     */\n    public Rule empty() {\n        return new EmptyMatcher<V>().label(\"EMPTY\");\n    }\n\n    ///************************* \"MAGIC\" METHODS ***************************///\n\n    /**\n     * Changes the context scope of the wrapped expression to the current parent scope.\n     *\n     * @param expression the expression to change the context for\n     * @return the result of the expression\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public final <T> T UP(T expression) {\n        throw new UnsupportedOperationException(\"UP(...) calls can only be used in rule defining parser methods\");\n    }\n\n    /**\n     * Changes the context scope of the wrapped expression to the parent scope two levels up.\n     * Equivalent to UP(UP(...))\n     *\n     * @param expression the expression to change the context for\n     * @return the result of the expression\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public final <T> T UP2(T expression) {\n        return UP(expression); // will always throw an UnsupportedOperationException\n    }\n\n    /**\n     * Changes the context scope of the wrapped expression to the parent scope three levels up.\n     * Equivalent to UP(UP(UP(...)))\n     *\n     * @param expression the expression to change the context for\n     * @return the result of the expression\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public final <T> T UP3(T expression) {\n        return UP(expression); // will always throw an UnsupportedOperationException\n    }\n\n    /**\n     * Changes the context scope of the wrapped expression to the parent scope four levels up.\n     * Equivalent to UP(UP(UP(UP(...))))\n     *\n     * @param expression the expression to change the context for\n     * @return the result of the expression\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public final <T> T UP4(T expression) {\n        return UP(expression); // will always throw an UnsupportedOperationException\n    }\n\n    /**\n     * Changes the context scope of the wrapped expression to the parent scope five levels up.\n     * Equivalent to UP(UP(UP(UP(UP(...)))))\n     *\n     * @param expression the expression to change the context for\n     * @return the result of the expression\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public final <T> T UP5(T expression) {\n        return UP(expression); // will always throw an UnsupportedOperationException\n    }\n\n    /**\n     * Changes the context scope of the wrapped expression to the parent scope six levels up.\n     * Equivalent to UP(UP(UP(UP(UP(UP(...))))))\n     *\n     * @param expression the expression to change the context for\n     * @return the result of the expression\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public final <T> T UP6(T expression) {\n        return UP(expression); // will always throw an UnsupportedOperationException\n    }\n\n    /**\n     * Changes the context scope of the wrapped expression to the current sub scope. This is only valid if this call\n     * is at some outer level wrapped with one or more {@link #UP(Object)} calls, since the default scope is always at\n     * the bottom of the context chain.\n     *\n     * @param expression the expression to change the context for\n     * @return the result of the expression\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public final <T> T DOWN(T expression) {\n        throw new UnsupportedOperationException(\"DOWN(...) calls can only be used in rule defining parser methods\");\n    }\n\n    /**\n     * Changes the context scope of the wrapped expression to the sub scope two levels down. This is only valid if this\n     * call is at some outer level wrapped with one or more {@link #UP(Object)} calls, since the default scope is always\n     * at the bottom of the context chain.\n     * Equivalent to DOWN(DOWN(...))\n     *\n     * @param expression the expression to change the context for\n     * @return the result of the expression\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public final <T> T DOWN2(T expression) {\n        return DOWN(expression); // will always throw an UnsupportedOperationException\n    }\n\n    /**\n     * Changes the context scope of the wrapped expression to the sub scope three levels down. This is only valid if\n     * this call is at some outer level wrapped with one or more {@link #UP(Object)} calls, since the default scope is\n     * always at the bottom of the context chain.\n     * Equivalent to DOWN(DOWN(DOWN(...)))\n     *\n     * @param expression the expression to change the context for\n     * @return the result of the expression\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public final <T> T DOWN3(T expression) {\n        return DOWN(expression); // will always throw an UnsupportedOperationException\n    }\n\n    /**\n     * Changes the context scope of the wrapped expression to the sub scope four levels down. This is only valid if\n     * this call is at some outer level wrapped with one or more {@link #UP(Object)} calls, since the default scope is\n     * always at the bottom of the context chain.\n     * Equivalent to DOWN(DOWN(DOWN(DOWN(...))))\n     *\n     * @param expression the expression to change the context for\n     * @return the result of the expression\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public final <T> T DOWN4(T expression) {\n        return DOWN(expression); // will always throw an UnsupportedOperationException\n    }\n\n    /**\n     * Changes the context scope of the wrapped expression to the sub scope five levels down. This is only valid if\n     * this call is at some outer level wrapped with one or more {@link #UP(Object)} calls, since the default scope is\n     * always at the bottom of the context chain.\n     * Equivalent to DOWN(DOWN(DOWN(DOWN(DOWN(...)))))\n     *\n     * @param expression the expression to change the context for\n     * @return the result of the expression\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public final <T> T DOWN5(T expression) {\n        return DOWN(expression); // will always throw an UnsupportedOperationException\n    }\n\n    /**\n     * Changes the context scope of the wrapped expression to the sub scope six levels down. This is only valid if\n     * this call is at some outer level wrapped with one or more {@link #UP(Object)} calls, since the default scope is\n     * always at the bottom of the context chain.\n     * Equivalent to DOWN(DOWN(DOWN(DOWN(DOWN(DOWN(...))))))\n     *\n     * @param expression the expression to change the context for\n     * @return the result of the expression\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public final <T> T DOWN6(T expression) {\n        return DOWN(expression); // will always throw an UnsupportedOperationException\n    }\n\n    /**\n     * Explicitly marks the wrapped expression as an action expression.\n     * parboiled transforms the wrapped expression into an {@link Action} instance during parser construction.\n     *\n     * @param expression the expression to turn into an Action\n     * @return the Action wrapping the given expression\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public final Action ACTION(boolean expression) {\n        throw new UnsupportedOperationException(\"ACTION(...) calls can only be used in rule defining parser methods\");\n    }\n\n    /**\n     * Explicitly marks the wrapped expression as an capture expression.\n     * parboiled transforms the wrapped expression into a {@link Capture} instance during parser construction.\n     *\n     * @param expression the expression to turn into a Capture\n     * @return the Capture wrapping the given expression\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public final <T> Capture<T> CAPTURE(T expression) {\n        throw new UnsupportedOperationException(\"CAPTURE(...) calls can only be used in rule defining parser methods\");\n    }\n\n    ///************************* HELPER METHODS ***************************///\n\n    /**\n     * Used internally to convert the given character literal to a parser rule.\n     * You can override this method, e.g. for specifying a sequence that automatically matches all trailing\n     * whitespace after the character.\n     *\n     * @param c the character\n     * @return the rule\n     */\n    protected Rule fromCharLiteral(char c) {\n        return ch(c);\n    }\n\n    /**\n     * Used internally to convert the given string literal to a parser rule.\n     * You can override this method, e.g. for specifying a sequence that automatically matches all trailing\n     * whitespace after the string.\n     *\n     * @param string the string\n     * @return the rule\n     */\n    protected Rule fromStringLiteral(@NotNull String string) {\n        return fromCharArray(string.toCharArray());\n    }\n\n    /**\n     * Used internally to convert the given char array to a parser rule.\n     * You can override this method, e.g. for specifying a sequence that automatically matches all trailing\n     * whitespace after the characters.\n     *\n     * @param array the char array\n     * @return the rule\n     */\n    protected Rule fromCharArray(@NotNull char[] array) {\n        return string(array);\n    }\n\n    /**\n     * Converts the given object array to an array of rules.\n     *\n     * @param objects the objects to convert\n     * @return the rules corresponding to the given objects\n     */\n    public Rule[] toRules(@NotNull Object... objects) {\n        Rule[] rules = new Rule[objects.length];\n        for (int i = 0; i < objects.length; i++) {\n            rules[i] = toRule(objects[i]);\n        }\n        return rules;\n    }\n\n    /**\n     * Converts the given object to a rule.\n     * This method can be overriden to enable the use of custom objects directly in rule specifications.\n     *\n     * @param obj the object to convert\n     * @return the rule corresponding to the given object\n     */\n    @SuppressWarnings({\"unchecked\"})\n    public Rule toRule(Object obj) {\n        if (obj instanceof Rule) return (Rule) obj;\n        if (obj instanceof Character) return fromCharLiteral((Character) obj);\n        if (obj instanceof String) return fromStringLiteral((String) obj);\n        if (obj instanceof char[]) return fromCharArray((char[]) obj);\n        if (obj instanceof Action) {\n            Action<V> action = (Action<V>) obj;\n            return new ActionMatcher<V>(action).defaultLabel(action.toString());\n        }\n\n        throw new ParserRuntimeException(\"'\" + obj + \"' cannot be automatically converted to a parser Rule\");\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled;\n\nimport com.google.common.base.Preconditions;\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.errors.ParserRuntimeException;\nimport org.parboiled.matchers.*;\nimport org.parboiled.support.*;\n\nimport static com.google.common.collect.ObjectArrays.concat;\n\n/**\n * Base class of all parboiled parsers. Defines the basic rule creation methods.\n *\n * @param <V> the type of the value field of the parse tree nodes created by this parser\n */\npublic abstract class BaseParser<V> extends BaseActions<V> {\n\n    /**\n     * Explicitly creates a rule matching the given character. Normally you can just specify the character literal\n     * directly in you rule description. However, if you don't want to go through {@link #fromCharLiteral(char)},\n     * e.g. because you redefined it, you can also use this wrapper.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param c the char to match\n     * @return a new rule\n     */\n    @Cached\n    public Rule ch(char c) {\n        return new CharMatcher(c);\n    }\n\n    /**\n     * Explicitly creates a rule matching the given character case-independently.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param c the char to match independently of its case\n     * @return a new rule\n     */\n    @Cached\n    public Rule charIgnoreCase(char c) {\n        return Character.isLowerCase(c) == Character.isUpperCase(c) ? ch(c) : new CharIgnoreCaseMatcher(c);\n    }\n\n    /**\n     * Creates a rule matching a range of characters from cLow to cHigh (both inclusively).\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * arguments will yield the same rule instance.<\/p>\n     *\n     * @param cLow  the start char of the range (inclusively)\n     * @param cHigh the end char of the range (inclusively)\n     * @return a new rule\n     */\n    @Cached\n    public Rule charRange(char cLow, char cHigh) {\n        return cLow == cHigh ? ch(cLow) : new CharRangeMatcher(cLow, cHigh);\n    }\n\n    /**\n     * Creates a new rule that matches any of the characters in the given string.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param characters the characters\n     * @return a new rule\n     */\n    public Rule charSet(@NotNull String characters) {\n        return charSet(characters.toCharArray());\n    }\n\n    /**\n     * Creates a new rule that matches any of the characters in the given char array.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param characters the characters\n     * @return a new rule\n     */\n    @Cached\n    public Rule charSet(@NotNull char... characters) {\n        Preconditions.checkArgument(characters.length > 0);\n        return characters.length == 1 ? ch(characters[0]) : charSet(Characters.of(characters));\n    }\n\n    /**\n     * Creates a new rule that matches any of the given characters.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param characters the characters\n     * @return a new rule\n     */\n    @Cached\n    public Rule charSet(@NotNull Characters characters) {\n        return !characters.isSubtractive() && characters.getChars().length == 1 ?\n                ch(characters.getChars()[0]) : new CharactersMatcher<V>(characters);\n    }\n\n    /**\n     * Explicitly creates a rule matching the given string. Normally you can just specify the string literal\n     * directly in you rule description. However, if you want to not go through {@link #fromStringLiteral(String)},\n     * e.g. because you redefined it, you can also use this wrapper.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param string the string to match\n     * @return a new rule\n     */\n    public Rule string(@NotNull String string) {\n        return string(string.toCharArray());\n    }\n\n    /**\n     * Explicitly creates a rule matching the given string. Normally you can just specify the string literal\n     * directly in you rule description. However, if you want to not go through {@link #fromStringLiteral(String)},\n     * e.g. because you redefined it, you can also use this wrapper.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param characters the characters of the string to match\n     * @return a new rule\n     */\n    @Cached\n    @Leaf\n    public Rule string(char... characters) {\n        if (characters.length == 1) return ch(characters[0]); // optimize one-char strings\n        Rule[] matchers = new Rule[characters.length];\n        for (int i = 0; i < characters.length; i++) {\n            matchers[i] = ch(characters[i]);\n        }\n        return sequence(matchers).label(\n                new StringBuilder(characters.length + 2).append('\"').append(characters).append('\"').toString()\n        );\n    }\n\n    /**\n     * Explicitly creates a rule matching the given string in a case-independent fashion.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param string the string to match\n     * @return a new rule\n     */\n    public Rule stringIgnoreCase(@NotNull String string) {\n        return stringIgnoreCase(string.toCharArray());\n    }\n\n    /**\n     * Explicitly creates a rule matching the given string in a case-independent fashion.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param characters the characters of the string to match\n     * @return a new rule\n     */\n    @Cached\n    @Leaf\n    public Rule stringIgnoreCase(char... characters) {\n        if (characters.length == 1) return charIgnoreCase(characters[0]); // optimize one-char strings\n        Rule[] matchers = new Rule[characters.length];\n        for (int i = 0; i < characters.length; i++) {\n            matchers[i] = charIgnoreCase(characters[i]);\n        }\n        return sequence(matchers).label(\n                new StringBuilder(characters.length + 2).append('\"').append(characters).append('\"').toString()\n        );\n    }\n\n    /**\n     * Creates a new rule that successively tries all of the given subrules and succeeds when the first one of\n     * its subrules matches. If all subrules fail this rule fails as well.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * arguments will yield the same rule instance.<\/p>\n     *\n     * @param rule      the first subrule\n     * @param rule2     the second subrule\n     * @param moreRules the other subrules\n     * @return a new rule\n     */\n    public Rule firstOf(Object rule, Object rule2, @NotNull Object... moreRules) {\n        return firstOf(concat(rule, concat(rule2, moreRules)));\n    }\n\n    /**\n     * Creates a new rule that successively tries all of the given subrules and succeeds when the first one of\n     * its subrules matches. If all subrules fail this rule fails as well.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param rules the subrules\n     * @return a new rule\n     */\n    @Cached\n    @Label\n    public Rule firstOf(@NotNull Object[] rules) {\n        return rules.length == 1 ? toRule(rules[0]) : new FirstOfMatcher(toRules(rules));\n    }\n\n    /**\n     * Creates a new rule that tries repeated matches of its subrule and succeeds if the subrule matches at least once.\n     * If the subrule does not match at least once this rule fails.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    @Cached\n    @Label\n    public Rule oneOrMore(Object rule) {\n        return new OneOrMoreMatcher(toRule(rule));\n    }\n\n    /**\n     * Creates a new rule that tries a match on its subrule and always succeeds, independently of the matching\n     * success of its subrule.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    @Cached\n    @Label\n    public Rule optional(Object rule) {\n        return new OptionalMatcher(toRule(rule));\n    }\n\n    /**\n     * Creates a new rule that only succeeds if all of its subrule succeed, one after the other.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * arguments will yield the same rule instance.<\/p>\n     *\n     * @param rule      the first subrule\n     * @param rule2     the second subrule\n     * @param moreRules the other subrules\n     * @return a new rule\n     */\n    public Rule sequence(Object rule, Object rule2, @NotNull Object... moreRules) {\n        return sequence(concat(rule, concat(rule2, moreRules)));\n    }\n\n    /**\n     * Creates a new rule that only succeeds if all of its subrule succeed, one after the other.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * arguments will yield the same rule instance.<\/p>\n     *\n     * @param rules the sub rules\n     * @return a new rule\n     */\n    @Cached\n    @Label\n    public Rule sequence(@NotNull Object[] rules) {\n        return rules.length == 1 ? toRule(rules[0]) : new SequenceMatcher(toRules(rules));\n    }\n\n    /**\n     * Creates a new rule that acts as a syntactic predicate, i.e. tests the given subrule against the current\n     * input position without actually matching any characters. Succeeds if the subrule succeeds and fails if the\n     * subrule rails. Since this rule does not actually consume any input it will never create a parse tree node.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    @Cached\n    public Rule test(Object rule) {\n        return new TestMatcher(toRule(rule));\n    }\n\n    /**\n     * Creates a new rule that acts as an inverse syntactic predicate, i.e. tests the given subrule against the current\n     * input position without actually matching any characters. Succeeds if the subrule fails and fails if the\n     * subrule succeeds. Since this rule does not actually consume any input it will never create a parse tree node.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    @Cached\n    public Rule testNot(Object rule) {\n        return new TestNotMatcher(toRule(rule));\n    }\n\n    /**\n     * Creates a new rule that tries repeated matches of its subrule.\n     * Succeeds always, even if the subrule doesn't match even once.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    @Cached\n    @Label\n    public Rule zeroOrMore(Object rule) {\n        return new ZeroOrMoreMatcher(toRule(rule));\n    }\n\n    /**\n     * Matches the EOI (end of input) character.\n     *\n     * @return a new rule\n     */\n    public Rule eoi() {\n        return ch(Characters.EOI).label(\"EOI\");\n    }\n\n    /**\n     * Matches any character except {@link Characters#EOI}.\n     *\n     * @return a new rule\n     */\n    public Rule any() {\n        return new CharactersMatcher<V>(Characters.allBut(Characters.EOI)).label(\"ANY\");\n    }\n\n    /**\n     * Matches nothing and therefore always succeeds.\n     *\n     * @return a new rule\n     */\n    public Rule empty() {\n        return new EmptyMatcher<V>();\n    }\n\n    ///************************* \"MAGIC\" METHODS ***************************///\n\n    /**\n     * Changes the context scope of the wrapped expression to the current parent scope.\n     *\n     * @param expression the expression to change the context for\n     * @return the result of the expression\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public final <T> T UP(T expression) {\n        throw new UnsupportedOperationException(\"UP(...) calls can only be used in rule defining parser methods\");\n    }\n\n    /**\n     * Changes the context scope of the wrapped expression to the parent scope two levels up.\n     * Equivalent to UP(UP(...))\n     *\n     * @param expression the expression to change the context for\n     * @return the result of the expression\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public final <T> T UP2(T expression) {\n        return UP(expression); // will always throw an UnsupportedOperationException\n    }\n\n    /**\n     * Changes the context scope of the wrapped expression to the parent scope three levels up.\n     * Equivalent to UP(UP(UP(...)))\n     *\n     * @param expression the expression to change the context for\n     * @return the result of the expression\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public final <T> T UP3(T expression) {\n        return UP(expression); // will always throw an UnsupportedOperationException\n    }\n\n    /**\n     * Changes the context scope of the wrapped expression to the parent scope four levels up.\n     * Equivalent to UP(UP(UP(UP(...))))\n     *\n     * @param expression the expression to change the context for\n     * @return the result of the expression\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public final <T> T UP4(T expression) {\n        return UP(expression); // will always throw an UnsupportedOperationException\n    }\n    \n    /**\n     * Changes the context scope of the wrapped expression to the parent scope five levels up.\n     * Equivalent to UP(UP(UP(UP(UP(...)))))\n     *\n     * @param expression the expression to change the context for\n     * @return the result of the expression\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public final <T> T UP5(T expression) {\n        return UP(expression); // will always throw an UnsupportedOperationException\n    }\n\n    /**\n     * Changes the context scope of the wrapped expression to the parent scope six levels up.\n     * Equivalent to UP(UP(UP(UP(UP(UP(...))))))\n     *\n     * @param expression the expression to change the context for\n     * @return the result of the expression\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public final <T> T UP6(T expression) {\n        return UP(expression); // will always throw an UnsupportedOperationException\n    }\n\n    /**\n     * Changes the context scope of the wrapped expression to the current sub scope. This is only valid if this call\n     * is at some outer level wrapped with one or more {@link #UP(Object)} calls, since the default scope is always at\n     * the bottom of the context chain.\n     *\n     * @param expression the expression to change the context for\n     * @return the result of the expression\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public final <T> T DOWN(T expression) {\n        throw new UnsupportedOperationException(\"DOWN(...) calls can only be used in rule defining parser methods\");\n    }\n\n    /**\n     * Changes the context scope of the wrapped expression to the sub scope two levels down. This is only valid if this\n     * call is at some outer level wrapped with one or more {@link #UP(Object)} calls, since the default scope is always\n     * at the bottom of the context chain.\n     * Equivalent to DOWN(DOWN(...))\n     *\n     * @param expression the expression to change the context for\n     * @return the result of the expression\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public final <T> T DOWN2(T expression) {\n        return DOWN(expression); // will always throw an UnsupportedOperationException\n    }\n\n    /**\n     * Changes the context scope of the wrapped expression to the sub scope three levels down. This is only valid if\n     * this call is at some outer level wrapped with one or more {@link #UP(Object)} calls, since the default scope is\n     * always at the bottom of the context chain.\n     * Equivalent to DOWN(DOWN(DOWN(...)))\n     *\n     * @param expression the expression to change the context for\n     * @return the result of the expression\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public final <T> T DOWN3(T expression) {\n        return DOWN(expression); // will always throw an UnsupportedOperationException\n    }\n\n    /**\n     * Changes the context scope of the wrapped expression to the sub scope four levels down. This is only valid if\n     * this call is at some outer level wrapped with one or more {@link #UP(Object)} calls, since the default scope is\n     * always at the bottom of the context chain.\n     * Equivalent to DOWN(DOWN(DOWN(DOWN(...))))\n     *\n     * @param expression the expression to change the context for\n     * @return the result of the expression\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public final <T> T DOWN4(T expression) {\n        return DOWN(expression); // will always throw an UnsupportedOperationException\n    }\n\n    /**\n     * Changes the context scope of the wrapped expression to the sub scope five levels down. This is only valid if\n     * this call is at some outer level wrapped with one or more {@link #UP(Object)} calls, since the default scope is\n     * always at the bottom of the context chain.\n     * Equivalent to DOWN(DOWN(DOWN(DOWN(DOWN(...)))))\n     *\n     * @param expression the expression to change the context for\n     * @return the result of the expression\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public final <T> T DOWN5(T expression) {\n        return DOWN(expression); // will always throw an UnsupportedOperationException\n    }\n\n    /**\n     * Changes the context scope of the wrapped expression to the sub scope six levels down. This is only valid if\n     * this call is at some outer level wrapped with one or more {@link #UP(Object)} calls, since the default scope is\n     * always at the bottom of the context chain.\n     * Equivalent to DOWN(DOWN(DOWN(DOWN(DOWN(DOWN(...))))))\n     *\n     * @param expression the expression to change the context for\n     * @return the result of the expression\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public final <T> T DOWN6(T expression) {\n        return DOWN(expression); // will always throw an UnsupportedOperationException\n    }\n\n    /**\n     * Explicitly marks the wrapped expression as an action expression.\n     * parboiled transforms the wrapped expression into an {@link Action} instance during parser construction.\n     * @param expression the expression to turn into an Action\n     * @return the Action wrapping the given expression\n     */\n    public final Action ACTION(boolean expression) {\n        throw new UnsupportedOperationException(\"ACTION(...) calls can only be used in rule defining parser methods\");\n    }\n\n    /**\n     * Explicitly marks the wrapped expression as an capture expression.\n     * parboiled transforms the wrapped expression into a {@link Capture} instance during parser construction.\n     * @param expression the expression to turn into a Capture\n     * @return the Capture wrapping the given expression\n     */\n    public final <T> Capture<T> CAPTURE(T expression) {\n        throw new UnsupportedOperationException(\"CAPTURE(...) calls can only be used in rule defining parser methods\");\n    }\n\n    ///************************* HELPER METHODS ***************************///\n\n    /**\n     * Used internally to convert the given character literal to a parser rule.\n     * You can override this method, e.g. for specifying a sequence that automatically matches all trailing\n     * whitespace after the character.\n     *\n     * @param c the character\n     * @return the rule\n     */\n    protected Rule fromCharLiteral(char c) {\n        return ch(c);\n    }\n\n    /**\n     * Used internally to convert the given string literal to a parser rule.\n     * You can override this method, e.g. for specifying a sequence that automatically matches all trailing\n     * whitespace after the string.\n     *\n     * @param string the string\n     * @return the rule\n     */\n    protected Rule fromStringLiteral(@NotNull String string) {\n        return fromCharArray(string.toCharArray());\n    }\n\n    /**\n     * Used internally to convert the given char array to a parser rule.\n     * You can override this method, e.g. for specifying a sequence that automatically matches all trailing\n     * whitespace after the characters.\n     *\n     * @param array the char array\n     * @return the rule\n     */\n    protected Rule fromCharArray(@NotNull char[] array) {\n        return string(array);\n    }\n\n    /**\n     * Converts the given object array to an array of rules.\n     *\n     * @param objects the objects to convert\n     * @return the rules corresponding to the given objects\n     */\n    public Rule[] toRules(@NotNull Object... objects) {\n        Rule[] rules = new Rule[objects.length];\n        for (int i = 0; i < objects.length; i++) {\n            rules[i] = toRule(objects[i]);\n        }\n        return rules;\n    }\n\n    /**\n     * Converts the given object to a rule.\n     * This method can be overriden to enable the use of custom objects directly in rule specifications.\n     *\n     * @param obj the object to convert\n     * @return the rule corresponding to the given object\n     */\n    @SuppressWarnings({\"unchecked\"})\n    public Rule toRule(Object obj) {\n        if (obj instanceof Rule) return (Rule) obj;\n        if (obj instanceof Character) return fromCharLiteral((Character) obj);\n        if (obj instanceof String) return fromStringLiteral((String) obj);\n        if (obj instanceof char[]) return fromCharArray((char[]) obj);\n        if (obj instanceof Action) return new ActionMatcher<V>((Action<V>) obj);\n\n        throw new ParserRuntimeException(\"'\" + obj + \"' cannot be automatically converted to a parser Rule\");\n    }\n\n}\n","lineNo":284}
{"Refactored Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled;\n\nimport com.google.common.base.Preconditions;\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.errors.ParserRuntimeException;\nimport org.parboiled.matchers.*;\nimport org.parboiled.support.Cached;\nimport org.parboiled.support.Characters;\n\nimport static com.google.common.collect.ObjectArrays.concat;\nimport static org.parboiled.common.StringUtils.escape;\n\n/**\n * Base class of all parboiled parsers. Defines the basic rule creation methods.\n *\n * @param <V> the type of the value field of the parse tree nodes created by this parser\n */\npublic abstract class BaseParser<V> extends BaseActions<V> {\n\n    /**\n     * Explicitly creates a rule matching the given character. Normally you can just specify the character literal\n     * directly in you rule description. However, if you don't want to go through {@link #fromCharLiteral(char)},\n     * e.g. because you redefined it, you can also use this wrapper.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param c the char to match\n     * @return a new rule\n     */\n    @Cached\n    public Rule ch(char c) {\n        return new CharMatcher(c).defaultLabel(\"\\'\" + escape(c) + '\\'');\n    }\n\n    /**\n     * Explicitly creates a rule matching the given character case-independently.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param c the char to match independently of its case\n     * @return a new rule\n     */\n    @Cached\n    public Rule charIgnoreCase(char c) {\n        if (Character.isLowerCase(c) == Character.isUpperCase(c)) {\n            return ch(c);\n        }\n        CharIgnoreCaseMatcher matcher = new CharIgnoreCaseMatcher(c);\n        return matcher.defaultLabel(\"\\'\" + escape(matcher.charLow) + '/' + escape(matcher.charUp) + '\\'');\n    }\n\n    /**\n     * Creates a rule matching a range of characters from cLow to cHigh (both inclusively).\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * arguments will yield the same rule instance.<\/p>\n     *\n     * @param cLow  the start char of the range (inclusively)\n     * @param cHigh the end char of the range (inclusively)\n     * @return a new rule\n     */\n    @Cached\n    public Rule charRange(char cLow, char cHigh) {\n        return cLow == cHigh ? ch(cLow) :\n                new CharRangeMatcher(cLow, cHigh).defaultLabel(escape(cLow) + \"..\" + escape(cHigh));\n    }\n\n    /**\n     * Creates a new rule that matches any of the characters in the given string.\n     * <p>Note: This methods provides caching, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param characters the characters\n     * @return a new rule\n     */\n    public Rule charSet(@NotNull String characters) {\n        return charSet(characters.toCharArray());\n    }\n\n    /**\n     * Creates a new rule that matches any of the characters in the given char array.\n     * <p>Note: This methods provides caching, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param characters the characters\n     * @return a new rule\n     */\n    public Rule charSet(@NotNull char... characters) {\n        Preconditions.checkArgument(characters.length > 0);\n        return characters.length == 1 ? ch(characters[0]) : charSet(Characters.of(characters));\n    }\n\n    /**\n     * Creates a new rule that matches any of the given characters.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param characters the characters\n     * @return a new rule\n     */\n    @Cached\n    public Rule charSet(@NotNull Characters characters) {\n        if (!characters.isSubtractive() && characters.getChars().length == 1) {\n            return ch(characters.getChars()[0]);\n        }\n        return new CharactersMatcher<V>(characters).defaultLabel(characters.toString());\n    }\n\n    /**\n     * Explicitly creates a rule matching the given string. Normally you can just specify the string literal\n     * directly in you rule description. However, if you want to not go through {@link #fromStringLiteral(String)},\n     * e.g. because you redefined it, you can also use this wrapper.\n     * <p>Note: This methods provides caching, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param string the string to match\n     * @return a new rule\n     */\n    public Rule string(@NotNull String string) {\n        return string(string.toCharArray());\n    }\n\n    /**\n     * Explicitly creates a rule matching the given string. Normally you can just specify the string literal\n     * directly in you rule description. However, if you want to not go through {@link #fromStringLiteral(String)},\n     * e.g. because you redefined it, you can also use this wrapper.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param characters the characters of the string to match\n     * @return a new rule\n     */\n    @Cached\n    public Rule string(char... characters) {\n        if (characters.length == 1) return ch(characters[0]); // optimize one-char strings\n        Rule[] matchers = new Rule[characters.length];\n        for (int i = 0; i < characters.length; i++) {\n            matchers[i] = ch(characters[i]);\n        }\n        return ((SequenceMatcher)sequence(matchers)).defaultLabel('\"' + String.valueOf(characters) + '\"').asLeaf();\n    }\n\n    /**\n     * Explicitly creates a rule matching the given string in a case-independent fashion.\n     * <p>Note: This methods provides caching, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param string the string to match\n     * @return a new rule\n     */\n    public Rule stringIgnoreCase(@NotNull String string) {\n        return stringIgnoreCase(string.toCharArray());\n    }\n\n    /**\n     * Explicitly creates a rule matching the given string in a case-independent fashion.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param characters the characters of the string to match\n     * @return a new rule\n     */\n    @Cached\n    public Rule stringIgnoreCase(char... characters) {\n        if (characters.length == 1) return charIgnoreCase(characters[0]); // optimize one-char strings\n        Rule[] matchers = new Rule[characters.length];\n        for (int i = 0; i < characters.length; i++) {\n            matchers[i] = charIgnoreCase(characters[i]);\n        }\n        return ((SequenceMatcher)sequence(matchers)).defaultLabel('\"' + String.valueOf(characters) + '\"').asLeaf();\n    }\n\n    /**\n     * Creates a new rule that successively tries all of the given subrules and succeeds when the first one of\n     * its subrules matches. If all subrules fail this rule fails as well.\n     * <p>Note: This methods provides caching, which means that multiple invocations with the same\n     * arguments will yield the same rule instance.<\/p>\n     *\n     * @param rule      the first subrule\n     * @param rule2     the second subrule\n     * @param moreRules the other subrules\n     * @return a new rule\n     */\n    public Rule firstOf(Object rule, Object rule2, @NotNull Object... moreRules) {\n        return firstOf(concat(rule, concat(rule2, moreRules)));\n    }\n\n    /**\n     * Creates a new rule that successively tries all of the given subrules and succeeds when the first one of\n     * its subrules matches. If all subrules fail this rule fails as well.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param rules the subrules\n     * @return a new rule\n     */\n    @Cached\n    public Rule firstOf(@NotNull Object[] rules) {\n        return rules.length == 1 ? toRule(rules[0]) : new FirstOfMatcher(toRules(rules)).defaultLabel(\"firstOf\");\n    }\n\n    /**\n     * Creates a new rule that tries repeated matches of its subrule and succeeds if the subrule matches at least once.\n     * If the subrule does not match at least once this rule fails.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    @Cached\n    public Rule oneOrMore(Object rule) {\n        return new OneOrMoreMatcher(toRule(rule)).defaultLabel(\"oneOrMore\");\n    }\n\n    /**\n     * Creates a new rule that tries a match on its subrule and always succeeds, independently of the matching\n     * success of its subrule.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    @Cached\n    public Rule optional(Object rule) {\n        return new OptionalMatcher(toRule(rule)).defaultLabel(\"optional\");\n    }\n\n    /**\n     * Creates a new rule that only succeeds if all of its subrule succeed, one after the other.\n     * <p>Note: This methods provides caching, which means that multiple invocations with the same\n     * arguments will yield the same rule instance.<\/p>\n     *\n     * @param rule      the first subrule\n     * @param rule2     the second subrule\n     * @param moreRules the other subrules\n     * @return a new rule\n     */\n    public Rule sequence(Object rule, Object rule2, @NotNull Object... moreRules) {\n        return sequence(concat(rule, concat(rule2, moreRules)));\n    }\n\n    /**\n     * Creates a new rule that only succeeds if all of its subrule succeed, one after the other.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * arguments will yield the same rule instance.<\/p>\n     *\n     * @param rules the sub rules\n     * @return a new rule\n     */\n    @Cached\n    public Rule sequence(@NotNull Object[] rules) {\n        return rules.length == 1 ? toRule(rules[0]) : new SequenceMatcher(toRules(rules)).defaultLabel(\"sequence\");\n    }\n\n    /**\n     * Creates a new rule that acts as a syntactic predicate, i.e. tests the given subrule against the current\n     * input position without actually matching any characters. Succeeds if the subrule succeeds and fails if the\n     * subrule rails. Since this rule does not actually consume any input it will never create a parse tree node.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    @Cached\n    public Rule test(Object rule) {\n        Rule subMatcher = toRule(rule);\n        return new TestMatcher(subMatcher).defaultLabel(\"&(\" + subMatcher + \")\");\n    }\n\n    /**\n     * Creates a new rule that acts as an inverse syntactic predicate, i.e. tests the given subrule against the current\n     * input position without actually matching any characters. Succeeds if the subrule fails and fails if the\n     * subrule succeeds. Since this rule does not actually consume any input it will never create a parse tree node.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    @Cached\n    public Rule testNot(Object rule) {\n        Rule subMatcher = toRule(rule);\n        return new TestNotMatcher(subMatcher).defaultLabel(\"!(\" + subMatcher + \")\");\n    }\n\n    /**\n     * Creates a new rule that tries repeated matches of its subrule.\n     * Succeeds always, even if the subrule doesn't match even once.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    @Cached\n    public Rule zeroOrMore(Object rule) {\n        return new ZeroOrMoreMatcher(toRule(rule)).defaultLabel(\"zeroOrMore\");\n    }\n\n    /**\n     * Matches the EOI (end of input) character.\n     *\n     * @return a new rule\n     */\n    public Rule eoi() {\n        return ch(Characters.EOI).label(\"EOI\");\n    }\n\n    /**\n     * Matches any character except {@link Characters#EOI}.\n     *\n     * @return a new rule\n     */\n    public Rule any() {\n        return new CharactersMatcher<V>(Characters.allBut(Characters.EOI)).label(\"ANY\");\n    }\n\n    /**\n     * Matches nothing and therefore always succeeds.\n     *\n     * @return a new rule\n     */\n    public Rule empty() {\n        return new EmptyMatcher<V>().label(\"EMPTY\");\n    }\n\n    ///************************* \"MAGIC\" METHODS ***************************///\n\n    /**\n     * Changes the context scope of the wrapped expression to the current parent scope.\n     *\n     * @param expression the expression to change the context for\n     * @return the result of the expression\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public final <T> T UP(T expression) {\n        throw new UnsupportedOperationException(\"UP(...) calls can only be used in rule defining parser methods\");\n    }\n\n    /**\n     * Changes the context scope of the wrapped expression to the parent scope two levels up.\n     * Equivalent to UP(UP(...))\n     *\n     * @param expression the expression to change the context for\n     * @return the result of the expression\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public final <T> T UP2(T expression) {\n        return UP(expression); // will always throw an UnsupportedOperationException\n    }\n\n    /**\n     * Changes the context scope of the wrapped expression to the parent scope three levels up.\n     * Equivalent to UP(UP(UP(...)))\n     *\n     * @param expression the expression to change the context for\n     * @return the result of the expression\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public final <T> T UP3(T expression) {\n        return UP(expression); // will always throw an UnsupportedOperationException\n    }\n\n    /**\n     * Changes the context scope of the wrapped expression to the parent scope four levels up.\n     * Equivalent to UP(UP(UP(UP(...))))\n     *\n     * @param expression the expression to change the context for\n     * @return the result of the expression\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public final <T> T UP4(T expression) {\n        return UP(expression); // will always throw an UnsupportedOperationException\n    }\n\n    /**\n     * Changes the context scope of the wrapped expression to the parent scope five levels up.\n     * Equivalent to UP(UP(UP(UP(UP(...)))))\n     *\n     * @param expression the expression to change the context for\n     * @return the result of the expression\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public final <T> T UP5(T expression) {\n        return UP(expression); // will always throw an UnsupportedOperationException\n    }\n\n    /**\n     * Changes the context scope of the wrapped expression to the parent scope six levels up.\n     * Equivalent to UP(UP(UP(UP(UP(UP(...))))))\n     *\n     * @param expression the expression to change the context for\n     * @return the result of the expression\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public final <T> T UP6(T expression) {\n        return UP(expression); // will always throw an UnsupportedOperationException\n    }\n\n    /**\n     * Changes the context scope of the wrapped expression to the current sub scope. This is only valid if this call\n     * is at some outer level wrapped with one or more {@link #UP(Object)} calls, since the default scope is always at\n     * the bottom of the context chain.\n     *\n     * @param expression the expression to change the context for\n     * @return the result of the expression\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public final <T> T DOWN(T expression) {\n        throw new UnsupportedOperationException(\"DOWN(...) calls can only be used in rule defining parser methods\");\n    }\n\n    /**\n     * Changes the context scope of the wrapped expression to the sub scope two levels down. This is only valid if this\n     * call is at some outer level wrapped with one or more {@link #UP(Object)} calls, since the default scope is always\n     * at the bottom of the context chain.\n     * Equivalent to DOWN(DOWN(...))\n     *\n     * @param expression the expression to change the context for\n     * @return the result of the expression\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public final <T> T DOWN2(T expression) {\n        return DOWN(expression); // will always throw an UnsupportedOperationException\n    }\n\n    /**\n     * Changes the context scope of the wrapped expression to the sub scope three levels down. This is only valid if\n     * this call is at some outer level wrapped with one or more {@link #UP(Object)} calls, since the default scope is\n     * always at the bottom of the context chain.\n     * Equivalent to DOWN(DOWN(DOWN(...)))\n     *\n     * @param expression the expression to change the context for\n     * @return the result of the expression\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public final <T> T DOWN3(T expression) {\n        return DOWN(expression); // will always throw an UnsupportedOperationException\n    }\n\n    /**\n     * Changes the context scope of the wrapped expression to the sub scope four levels down. This is only valid if\n     * this call is at some outer level wrapped with one or more {@link #UP(Object)} calls, since the default scope is\n     * always at the bottom of the context chain.\n     * Equivalent to DOWN(DOWN(DOWN(DOWN(...))))\n     *\n     * @param expression the expression to change the context for\n     * @return the result of the expression\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public final <T> T DOWN4(T expression) {\n        return DOWN(expression); // will always throw an UnsupportedOperationException\n    }\n\n    /**\n     * Changes the context scope of the wrapped expression to the sub scope five levels down. This is only valid if\n     * this call is at some outer level wrapped with one or more {@link #UP(Object)} calls, since the default scope is\n     * always at the bottom of the context chain.\n     * Equivalent to DOWN(DOWN(DOWN(DOWN(DOWN(...)))))\n     *\n     * @param expression the expression to change the context for\n     * @return the result of the expression\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public final <T> T DOWN5(T expression) {\n        return DOWN(expression); // will always throw an UnsupportedOperationException\n    }\n\n    /**\n     * Changes the context scope of the wrapped expression to the sub scope six levels down. This is only valid if\n     * this call is at some outer level wrapped with one or more {@link #UP(Object)} calls, since the default scope is\n     * always at the bottom of the context chain.\n     * Equivalent to DOWN(DOWN(DOWN(DOWN(DOWN(DOWN(...))))))\n     *\n     * @param expression the expression to change the context for\n     * @return the result of the expression\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public final <T> T DOWN6(T expression) {\n        return DOWN(expression); // will always throw an UnsupportedOperationException\n    }\n\n    /**\n     * Explicitly marks the wrapped expression as an action expression.\n     * parboiled transforms the wrapped expression into an {@link Action} instance during parser construction.\n     *\n     * @param expression the expression to turn into an Action\n     * @return the Action wrapping the given expression\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public final Action ACTION(boolean expression) {\n        throw new UnsupportedOperationException(\"ACTION(...) calls can only be used in rule defining parser methods\");\n    }\n\n    /**\n     * Explicitly marks the wrapped expression as an capture expression.\n     * parboiled transforms the wrapped expression into a {@link Capture} instance during parser construction.\n     *\n     * @param expression the expression to turn into a Capture\n     * @return the Capture wrapping the given expression\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public final <T> Capture<T> CAPTURE(T expression) {\n        throw new UnsupportedOperationException(\"CAPTURE(...) calls can only be used in rule defining parser methods\");\n    }\n\n    ///************************* HELPER METHODS ***************************///\n\n    /**\n     * Used internally to convert the given character literal to a parser rule.\n     * You can override this method, e.g. for specifying a sequence that automatically matches all trailing\n     * whitespace after the character.\n     *\n     * @param c the character\n     * @return the rule\n     */\n    protected Rule fromCharLiteral(char c) {\n        return ch(c);\n    }\n\n    /**\n     * Used internally to convert the given string literal to a parser rule.\n     * You can override this method, e.g. for specifying a sequence that automatically matches all trailing\n     * whitespace after the string.\n     *\n     * @param string the string\n     * @return the rule\n     */\n    protected Rule fromStringLiteral(@NotNull String string) {\n        return fromCharArray(string.toCharArray());\n    }\n\n    /**\n     * Used internally to convert the given char array to a parser rule.\n     * You can override this method, e.g. for specifying a sequence that automatically matches all trailing\n     * whitespace after the characters.\n     *\n     * @param array the char array\n     * @return the rule\n     */\n    protected Rule fromCharArray(@NotNull char[] array) {\n        return string(array);\n    }\n\n    /**\n     * Converts the given object array to an array of rules.\n     *\n     * @param objects the objects to convert\n     * @return the rules corresponding to the given objects\n     */\n    public Rule[] toRules(@NotNull Object... objects) {\n        Rule[] rules = new Rule[objects.length];\n        for (int i = 0; i < objects.length; i++) {\n            rules[i] = toRule(objects[i]);\n        }\n        return rules;\n    }\n\n    /**\n     * Converts the given object to a rule.\n     * This method can be overriden to enable the use of custom objects directly in rule specifications.\n     *\n     * @param obj the object to convert\n     * @return the rule corresponding to the given object\n     */\n    @SuppressWarnings({\"unchecked\"})\n    public Rule toRule(Object obj) {\n        if (obj instanceof Rule) return (Rule) obj;\n        if (obj instanceof Character) return fromCharLiteral((Character) obj);\n        if (obj instanceof String) return fromStringLiteral((String) obj);\n        if (obj instanceof char[]) return fromCharArray((char[]) obj);\n        if (obj instanceof Action) {\n            Action<V> action = (Action<V>) obj;\n            return new ActionMatcher<V>(action).defaultLabel(action.toString());\n        }\n\n        throw new ParserRuntimeException(\"'\" + obj + \"' cannot be automatically converted to a parser Rule\");\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled;\n\nimport com.google.common.base.Preconditions;\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.errors.ParserRuntimeException;\nimport org.parboiled.matchers.*;\nimport org.parboiled.support.*;\n\nimport static com.google.common.collect.ObjectArrays.concat;\n\n/**\n * Base class of all parboiled parsers. Defines the basic rule creation methods.\n *\n * @param <V> the type of the value field of the parse tree nodes created by this parser\n */\npublic abstract class BaseParser<V> extends BaseActions<V> {\n\n    /**\n     * Explicitly creates a rule matching the given character. Normally you can just specify the character literal\n     * directly in you rule description. However, if you don't want to go through {@link #fromCharLiteral(char)},\n     * e.g. because you redefined it, you can also use this wrapper.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param c the char to match\n     * @return a new rule\n     */\n    @Cached\n    public Rule ch(char c) {\n        return new CharMatcher(c);\n    }\n\n    /**\n     * Explicitly creates a rule matching the given character case-independently.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param c the char to match independently of its case\n     * @return a new rule\n     */\n    @Cached\n    public Rule charIgnoreCase(char c) {\n        return Character.isLowerCase(c) == Character.isUpperCase(c) ? ch(c) : new CharIgnoreCaseMatcher(c);\n    }\n\n    /**\n     * Creates a rule matching a range of characters from cLow to cHigh (both inclusively).\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * arguments will yield the same rule instance.<\/p>\n     *\n     * @param cLow  the start char of the range (inclusively)\n     * @param cHigh the end char of the range (inclusively)\n     * @return a new rule\n     */\n    @Cached\n    public Rule charRange(char cLow, char cHigh) {\n        return cLow == cHigh ? ch(cLow) : new CharRangeMatcher(cLow, cHigh);\n    }\n\n    /**\n     * Creates a new rule that matches any of the characters in the given string.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param characters the characters\n     * @return a new rule\n     */\n    public Rule charSet(@NotNull String characters) {\n        return charSet(characters.toCharArray());\n    }\n\n    /**\n     * Creates a new rule that matches any of the characters in the given char array.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param characters the characters\n     * @return a new rule\n     */\n    @Cached\n    public Rule charSet(@NotNull char... characters) {\n        Preconditions.checkArgument(characters.length > 0);\n        return characters.length == 1 ? ch(characters[0]) : charSet(Characters.of(characters));\n    }\n\n    /**\n     * Creates a new rule that matches any of the given characters.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param characters the characters\n     * @return a new rule\n     */\n    @Cached\n    public Rule charSet(@NotNull Characters characters) {\n        return !characters.isSubtractive() && characters.getChars().length == 1 ?\n                ch(characters.getChars()[0]) : new CharactersMatcher<V>(characters);\n    }\n\n    /**\n     * Explicitly creates a rule matching the given string. Normally you can just specify the string literal\n     * directly in you rule description. However, if you want to not go through {@link #fromStringLiteral(String)},\n     * e.g. because you redefined it, you can also use this wrapper.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param string the string to match\n     * @return a new rule\n     */\n    public Rule string(@NotNull String string) {\n        return string(string.toCharArray());\n    }\n\n    /**\n     * Explicitly creates a rule matching the given string. Normally you can just specify the string literal\n     * directly in you rule description. However, if you want to not go through {@link #fromStringLiteral(String)},\n     * e.g. because you redefined it, you can also use this wrapper.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param characters the characters of the string to match\n     * @return a new rule\n     */\n    @Cached\n    @Leaf\n    public Rule string(char... characters) {\n        if (characters.length == 1) return ch(characters[0]); // optimize one-char strings\n        Rule[] matchers = new Rule[characters.length];\n        for (int i = 0; i < characters.length; i++) {\n            matchers[i] = ch(characters[i]);\n        }\n        return sequence(matchers).label(\n                new StringBuilder(characters.length + 2).append('\"').append(characters).append('\"').toString()\n        );\n    }\n\n    /**\n     * Explicitly creates a rule matching the given string in a case-independent fashion.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param string the string to match\n     * @return a new rule\n     */\n    public Rule stringIgnoreCase(@NotNull String string) {\n        return stringIgnoreCase(string.toCharArray());\n    }\n\n    /**\n     * Explicitly creates a rule matching the given string in a case-independent fashion.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param characters the characters of the string to match\n     * @return a new rule\n     */\n    @Cached\n    @Leaf\n    public Rule stringIgnoreCase(char... characters) {\n        if (characters.length == 1) return charIgnoreCase(characters[0]); // optimize one-char strings\n        Rule[] matchers = new Rule[characters.length];\n        for (int i = 0; i < characters.length; i++) {\n            matchers[i] = charIgnoreCase(characters[i]);\n        }\n        return sequence(matchers).label(\n                new StringBuilder(characters.length + 2).append('\"').append(characters).append('\"').toString()\n        );\n    }\n\n    /**\n     * Creates a new rule that successively tries all of the given subrules and succeeds when the first one of\n     * its subrules matches. If all subrules fail this rule fails as well.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * arguments will yield the same rule instance.<\/p>\n     *\n     * @param rule      the first subrule\n     * @param rule2     the second subrule\n     * @param moreRules the other subrules\n     * @return a new rule\n     */\n    public Rule firstOf(Object rule, Object rule2, @NotNull Object... moreRules) {\n        return firstOf(concat(rule, concat(rule2, moreRules)));\n    }\n\n    /**\n     * Creates a new rule that successively tries all of the given subrules and succeeds when the first one of\n     * its subrules matches. If all subrules fail this rule fails as well.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param rules the subrules\n     * @return a new rule\n     */\n    @Cached\n    @Label\n    public Rule firstOf(@NotNull Object[] rules) {\n        return rules.length == 1 ? toRule(rules[0]) : new FirstOfMatcher(toRules(rules));\n    }\n\n    /**\n     * Creates a new rule that tries repeated matches of its subrule and succeeds if the subrule matches at least once.\n     * If the subrule does not match at least once this rule fails.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    @Cached\n    @Label\n    public Rule oneOrMore(Object rule) {\n        return new OneOrMoreMatcher(toRule(rule));\n    }\n\n    /**\n     * Creates a new rule that tries a match on its subrule and always succeeds, independently of the matching\n     * success of its subrule.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    @Cached\n    @Label\n    public Rule optional(Object rule) {\n        return new OptionalMatcher(toRule(rule));\n    }\n\n    /**\n     * Creates a new rule that only succeeds if all of its subrule succeed, one after the other.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * arguments will yield the same rule instance.<\/p>\n     *\n     * @param rule      the first subrule\n     * @param rule2     the second subrule\n     * @param moreRules the other subrules\n     * @return a new rule\n     */\n    public Rule sequence(Object rule, Object rule2, @NotNull Object... moreRules) {\n        return sequence(concat(rule, concat(rule2, moreRules)));\n    }\n\n    /**\n     * Creates a new rule that only succeeds if all of its subrule succeed, one after the other.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * arguments will yield the same rule instance.<\/p>\n     *\n     * @param rules the sub rules\n     * @return a new rule\n     */\n    @Cached\n    @Label\n    public Rule sequence(@NotNull Object[] rules) {\n        return rules.length == 1 ? toRule(rules[0]) : new SequenceMatcher(toRules(rules));\n    }\n\n    /**\n     * Creates a new rule that acts as a syntactic predicate, i.e. tests the given subrule against the current\n     * input position without actually matching any characters. Succeeds if the subrule succeeds and fails if the\n     * subrule rails. Since this rule does not actually consume any input it will never create a parse tree node.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    @Cached\n    public Rule test(Object rule) {\n        return new TestMatcher(toRule(rule));\n    }\n\n    /**\n     * Creates a new rule that acts as an inverse syntactic predicate, i.e. tests the given subrule against the current\n     * input position without actually matching any characters. Succeeds if the subrule fails and fails if the\n     * subrule succeeds. Since this rule does not actually consume any input it will never create a parse tree node.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    @Cached\n    public Rule testNot(Object rule) {\n        return new TestNotMatcher(toRule(rule));\n    }\n\n    /**\n     * Creates a new rule that tries repeated matches of its subrule.\n     * Succeeds always, even if the subrule doesn't match even once.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    @Cached\n    @Label\n    public Rule zeroOrMore(Object rule) {\n        return new ZeroOrMoreMatcher(toRule(rule));\n    }\n\n    /**\n     * Matches the EOI (end of input) character.\n     *\n     * @return a new rule\n     */\n    public Rule eoi() {\n        return ch(Characters.EOI).label(\"EOI\");\n    }\n\n    /**\n     * Matches any character except {@link Characters#EOI}.\n     *\n     * @return a new rule\n     */\n    public Rule any() {\n        return new CharactersMatcher<V>(Characters.allBut(Characters.EOI)).label(\"ANY\");\n    }\n\n    /**\n     * Matches nothing and therefore always succeeds.\n     *\n     * @return a new rule\n     */\n    public Rule empty() {\n        return new EmptyMatcher<V>();\n    }\n\n    ///************************* \"MAGIC\" METHODS ***************************///\n\n    /**\n     * Changes the context scope of the wrapped expression to the current parent scope.\n     *\n     * @param expression the expression to change the context for\n     * @return the result of the expression\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public final <T> T UP(T expression) {\n        throw new UnsupportedOperationException(\"UP(...) calls can only be used in rule defining parser methods\");\n    }\n\n    /**\n     * Changes the context scope of the wrapped expression to the parent scope two levels up.\n     * Equivalent to UP(UP(...))\n     *\n     * @param expression the expression to change the context for\n     * @return the result of the expression\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public final <T> T UP2(T expression) {\n        return UP(expression); // will always throw an UnsupportedOperationException\n    }\n\n    /**\n     * Changes the context scope of the wrapped expression to the parent scope three levels up.\n     * Equivalent to UP(UP(UP(...)))\n     *\n     * @param expression the expression to change the context for\n     * @return the result of the expression\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public final <T> T UP3(T expression) {\n        return UP(expression); // will always throw an UnsupportedOperationException\n    }\n\n    /**\n     * Changes the context scope of the wrapped expression to the parent scope four levels up.\n     * Equivalent to UP(UP(UP(UP(...))))\n     *\n     * @param expression the expression to change the context for\n     * @return the result of the expression\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public final <T> T UP4(T expression) {\n        return UP(expression); // will always throw an UnsupportedOperationException\n    }\n    \n    /**\n     * Changes the context scope of the wrapped expression to the parent scope five levels up.\n     * Equivalent to UP(UP(UP(UP(UP(...)))))\n     *\n     * @param expression the expression to change the context for\n     * @return the result of the expression\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public final <T> T UP5(T expression) {\n        return UP(expression); // will always throw an UnsupportedOperationException\n    }\n\n    /**\n     * Changes the context scope of the wrapped expression to the parent scope six levels up.\n     * Equivalent to UP(UP(UP(UP(UP(UP(...))))))\n     *\n     * @param expression the expression to change the context for\n     * @return the result of the expression\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public final <T> T UP6(T expression) {\n        return UP(expression); // will always throw an UnsupportedOperationException\n    }\n\n    /**\n     * Changes the context scope of the wrapped expression to the current sub scope. This is only valid if this call\n     * is at some outer level wrapped with one or more {@link #UP(Object)} calls, since the default scope is always at\n     * the bottom of the context chain.\n     *\n     * @param expression the expression to change the context for\n     * @return the result of the expression\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public final <T> T DOWN(T expression) {\n        throw new UnsupportedOperationException(\"DOWN(...) calls can only be used in rule defining parser methods\");\n    }\n\n    /**\n     * Changes the context scope of the wrapped expression to the sub scope two levels down. This is only valid if this\n     * call is at some outer level wrapped with one or more {@link #UP(Object)} calls, since the default scope is always\n     * at the bottom of the context chain.\n     * Equivalent to DOWN(DOWN(...))\n     *\n     * @param expression the expression to change the context for\n     * @return the result of the expression\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public final <T> T DOWN2(T expression) {\n        return DOWN(expression); // will always throw an UnsupportedOperationException\n    }\n\n    /**\n     * Changes the context scope of the wrapped expression to the sub scope three levels down. This is only valid if\n     * this call is at some outer level wrapped with one or more {@link #UP(Object)} calls, since the default scope is\n     * always at the bottom of the context chain.\n     * Equivalent to DOWN(DOWN(DOWN(...)))\n     *\n     * @param expression the expression to change the context for\n     * @return the result of the expression\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public final <T> T DOWN3(T expression) {\n        return DOWN(expression); // will always throw an UnsupportedOperationException\n    }\n\n    /**\n     * Changes the context scope of the wrapped expression to the sub scope four levels down. This is only valid if\n     * this call is at some outer level wrapped with one or more {@link #UP(Object)} calls, since the default scope is\n     * always at the bottom of the context chain.\n     * Equivalent to DOWN(DOWN(DOWN(DOWN(...))))\n     *\n     * @param expression the expression to change the context for\n     * @return the result of the expression\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public final <T> T DOWN4(T expression) {\n        return DOWN(expression); // will always throw an UnsupportedOperationException\n    }\n\n    /**\n     * Changes the context scope of the wrapped expression to the sub scope five levels down. This is only valid if\n     * this call is at some outer level wrapped with one or more {@link #UP(Object)} calls, since the default scope is\n     * always at the bottom of the context chain.\n     * Equivalent to DOWN(DOWN(DOWN(DOWN(DOWN(...)))))\n     *\n     * @param expression the expression to change the context for\n     * @return the result of the expression\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public final <T> T DOWN5(T expression) {\n        return DOWN(expression); // will always throw an UnsupportedOperationException\n    }\n\n    /**\n     * Changes the context scope of the wrapped expression to the sub scope six levels down. This is only valid if\n     * this call is at some outer level wrapped with one or more {@link #UP(Object)} calls, since the default scope is\n     * always at the bottom of the context chain.\n     * Equivalent to DOWN(DOWN(DOWN(DOWN(DOWN(DOWN(...))))))\n     *\n     * @param expression the expression to change the context for\n     * @return the result of the expression\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public final <T> T DOWN6(T expression) {\n        return DOWN(expression); // will always throw an UnsupportedOperationException\n    }\n\n    /**\n     * Explicitly marks the wrapped expression as an action expression.\n     * parboiled transforms the wrapped expression into an {@link Action} instance during parser construction.\n     * @param expression the expression to turn into an Action\n     * @return the Action wrapping the given expression\n     */\n    public final Action ACTION(boolean expression) {\n        throw new UnsupportedOperationException(\"ACTION(...) calls can only be used in rule defining parser methods\");\n    }\n\n    /**\n     * Explicitly marks the wrapped expression as an capture expression.\n     * parboiled transforms the wrapped expression into a {@link Capture} instance during parser construction.\n     * @param expression the expression to turn into a Capture\n     * @return the Capture wrapping the given expression\n     */\n    public final <T> Capture<T> CAPTURE(T expression) {\n        throw new UnsupportedOperationException(\"CAPTURE(...) calls can only be used in rule defining parser methods\");\n    }\n\n    ///************************* HELPER METHODS ***************************///\n\n    /**\n     * Used internally to convert the given character literal to a parser rule.\n     * You can override this method, e.g. for specifying a sequence that automatically matches all trailing\n     * whitespace after the character.\n     *\n     * @param c the character\n     * @return the rule\n     */\n    protected Rule fromCharLiteral(char c) {\n        return ch(c);\n    }\n\n    /**\n     * Used internally to convert the given string literal to a parser rule.\n     * You can override this method, e.g. for specifying a sequence that automatically matches all trailing\n     * whitespace after the string.\n     *\n     * @param string the string\n     * @return the rule\n     */\n    protected Rule fromStringLiteral(@NotNull String string) {\n        return fromCharArray(string.toCharArray());\n    }\n\n    /**\n     * Used internally to convert the given char array to a parser rule.\n     * You can override this method, e.g. for specifying a sequence that automatically matches all trailing\n     * whitespace after the characters.\n     *\n     * @param array the char array\n     * @return the rule\n     */\n    protected Rule fromCharArray(@NotNull char[] array) {\n        return string(array);\n    }\n\n    /**\n     * Converts the given object array to an array of rules.\n     *\n     * @param objects the objects to convert\n     * @return the rules corresponding to the given objects\n     */\n    public Rule[] toRules(@NotNull Object... objects) {\n        Rule[] rules = new Rule[objects.length];\n        for (int i = 0; i < objects.length; i++) {\n            rules[i] = toRule(objects[i]);\n        }\n        return rules;\n    }\n\n    /**\n     * Converts the given object to a rule.\n     * This method can be overriden to enable the use of custom objects directly in rule specifications.\n     *\n     * @param obj the object to convert\n     * @return the rule corresponding to the given object\n     */\n    @SuppressWarnings({\"unchecked\"})\n    public Rule toRule(Object obj) {\n        if (obj instanceof Rule) return (Rule) obj;\n        if (obj instanceof Character) return fromCharLiteral((Character) obj);\n        if (obj instanceof String) return fromStringLiteral((String) obj);\n        if (obj instanceof char[]) return fromCharArray((char[]) obj);\n        if (obj instanceof Action) return new ActionMatcher<V>((Action<V>) obj);\n\n        throw new ParserRuntimeException(\"'\" + obj + \"' cannot be automatically converted to a parser Rule\");\n    }\n\n}\n","lineNo":300}
{"Refactored Sample":"/*\n * Copyright (c) 2009-2010 Ken Wenzel and Mathias Doenitz\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\npackage org.parboiled.transform;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.Lists;\nimport org.objectweb.asm.Opcodes;\nimport org.objectweb.asm.Type;\nimport org.objectweb.asm.tree.AbstractInsnNode;\nimport org.objectweb.asm.tree.analysis.AnalyzerException;\nimport org.objectweb.asm.tree.analysis.BasicInterpreter;\nimport org.objectweb.asm.tree.analysis.BasicValue;\nimport org.objectweb.asm.tree.analysis.Value;\n\nimport java.util.Arrays;\nimport java.util.List;\n\nclass RuleMethodInterpreter extends BasicInterpreter implements Types {\n\n    private final RuleMethod method;\n    private final List<Edge> additionalEdges = Lists.newArrayList();\n\n    public RuleMethodInterpreter(RuleMethod method) {\n        this.method = method;\n    }\n\n    @Override\n    public Value newValue(Type type) {\n        BasicValue basicValue = (BasicValue) super.newValue(type);\n        if (basicValue == BasicValue.REFERENCE_VALUE) {\n            basicValue = new BasicValue(type); // record the exact type and not just \"Ljava/lang/Object\"\n        }\n        return basicValue;\n    }\n\n    @Override\n    public Value newOperation(AbstractInsnNode insn) throws AnalyzerException {\n        return createNode(insn, super.newOperation(insn));\n    }\n\n    @Override\n    public Value copyOperation(AbstractInsnNode insn, Value value) throws AnalyzerException {\n        return createNode(insn, super.copyOperation(insn, value), value);\n    }\n\n    @Override\n    public Value unaryOperation(AbstractInsnNode insn, Value value) throws AnalyzerException {\n        return createNode(insn, super.unaryOperation(insn, null), value);\n    }\n\n    @Override\n    public Value binaryOperation(AbstractInsnNode insn, Value value1, Value value2) throws AnalyzerException {\n        return createNode(insn, super.binaryOperation(insn, null, null), value1, value2);\n    }\n\n    @Override\n    public Value ternaryOperation(AbstractInsnNode insn, Value v1, Value v2, Value v3) throws AnalyzerException {\n        return createNode(insn, super.ternaryOperation(insn, null, null, null), v1, v2, v3);\n    }\n\n    @Override\n    @SuppressWarnings({\"unchecked\"})\n    public Value naryOperation(AbstractInsnNode insn, List values) throws AnalyzerException {\n        return createNode(insn, super.naryOperation(insn, null), (Value[]) values.toArray(new Value[values.size()]));\n    }\n\n    @Override\n    public void returnOperation(AbstractInsnNode insn, Value value, Value expected) throws AnalyzerException {\n        Preconditions.checkState(insn.getOpcode() == Opcodes.ARETURN);\n        Preconditions.checkState(unwrap(value).getType().equals(RULE));\n        Preconditions.checkState(unwrap(expected).getType().equals(RULE));\n        Preconditions.checkState(method.getReturnInstructionNode() == null);\n        method.setReturnInstructionNode(createNode(insn, null, value));\n    }\n\n    private InstructionGraphNode createNode(AbstractInsnNode insn, Value resultValue, Value... prevNodes) {\n        return method.setGraphNode(insn, unwrap(resultValue), Arrays.asList(prevNodes));\n    }\n\n    @Override\n    public Value merge(Value v, Value w) {\n        // we don't actually merge values but use the control flow detection to deal with conditionals\n        return v;\n    }\n\n    public void newControlFlowEdge(int instructionIndex, int successorIndex) {\n        AbstractInsnNode fromInsn = method.instructions.get(instructionIndex);\n        AbstractInsnNode toInsn = method.instructions.get(successorIndex);\n        switch (fromInsn.getType()) {\n            case AbstractInsnNode.LABEL:\n            case AbstractInsnNode.JUMP_INSN:\n                additionalEdges.add(new Edge(fromInsn, toInsn));\n                return;\n        }\n\n        switch (toInsn.getType()) {\n            case AbstractInsnNode.JUMP_INSN:\n                additionalEdges.add(new Edge(fromInsn, toInsn));\n        }\n    }\n\n    public void finish() {\n        // finally add all edges so far not included\n        for (Edge edge : additionalEdges) {\n            InstructionGraphNode node = method.getGraphNode(edge.from);\n            if (node == null) node = createNode(edge.from, null);\n            InstructionGraphNode succ = method.getGraphNode(edge.to);\n            if (succ == null) succ = createNode(edge.to, null);\n            if (!succ.getPredecessors().contains(node)) succ.getPredecessors().add(node);\n        }\n    }\n\n    private BasicValue unwrap(Value resultValue) {\n        return resultValue == null || resultValue instanceof BasicValue ?\n                (BasicValue) resultValue : ((InstructionGraphNode) resultValue).getResultValue();\n    }\n\n    private class Edge {\n        public final AbstractInsnNode from;\n        public final AbstractInsnNode to;\n\n        public Edge(AbstractInsnNode from, AbstractInsnNode to) {\n            this.from = from;\n            this.to = to;\n        }\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (c) 2009-2010 Ken Wenzel and Mathias Doenitz\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\npackage org.parboiled.transform;\n\nimport com.google.common.base.Preconditions;\nimport org.objectweb.asm.Opcodes;\nimport org.objectweb.asm.Type;\nimport org.objectweb.asm.tree.AbstractInsnNode;\nimport org.objectweb.asm.tree.FieldInsnNode;\nimport org.objectweb.asm.tree.MethodInsnNode;\nimport org.objectweb.asm.tree.analysis.AnalyzerException;\nimport org.objectweb.asm.tree.analysis.BasicInterpreter;\nimport org.objectweb.asm.tree.analysis.BasicValue;\nimport org.objectweb.asm.tree.analysis.Value;\nimport org.parboiled.errors.GrammarException;\nimport org.parboiled.support.Checks;\n\nimport java.lang.reflect.Modifier;\nimport java.util.*;\n\nimport static org.parboiled.transform.AsmUtils.getOwnerField;\nimport static org.parboiled.transform.AsmUtils.getOwnerMethod;\n\nclass RuleMethodInterpreter extends BasicInterpreter {\n\n    private final ParserClassNode classNode;\n    private final RuleMethod method;\n    private final List<int[]> additionalEdges = new ArrayList<int[]>();\n    private final Map<String, Integer> memberModifiers = new HashMap<String, Integer>();\n\n    public RuleMethodInterpreter(ParserClassNode classNode, RuleMethod method) {\n        this.classNode = classNode;\n        this.method = method;\n    }\n\n    @Override\n    public Value newValue(Type type) {\n        BasicValue basicValue = (BasicValue) super.newValue(type);\n        if (basicValue == BasicValue.REFERENCE_VALUE) {\n            basicValue = new BasicValue(type); // record the exact type and not just \"Ljava/lang/Object\"\n        }\n        return basicValue;\n    }\n\n    @Override\n    public Value newOperation(AbstractInsnNode insn) throws AnalyzerException {\n        return createNode(insn, super.newOperation(insn));\n    }\n\n    @Override\n    public Value copyOperation(AbstractInsnNode insn, Value value) throws AnalyzerException {\n        return createNode(insn, super.copyOperation(insn, value), value);\n    }\n\n    @Override\n    public Value unaryOperation(AbstractInsnNode insn, Value value) throws AnalyzerException {\n        verifyInstruction(insn);\n        return createNode(insn, super.unaryOperation(insn, null), value);\n    }\n\n    @Override\n    public Value binaryOperation(AbstractInsnNode insn, Value value1, Value value2) throws AnalyzerException {\n        return createNode(insn, super.binaryOperation(insn, null, null), value1, value2);\n    }\n\n    @Override\n    public Value ternaryOperation(AbstractInsnNode insn, Value v1, Value v2, Value v3) throws AnalyzerException {\n        return createNode(insn, super.ternaryOperation(insn, null, null, null), v1, v2, v3);\n    }\n\n    @Override\n    @SuppressWarnings({\"unchecked\"})\n    public Value naryOperation(AbstractInsnNode insn, List values) throws AnalyzerException {\n        verifyInstruction(insn);\n        return createNode(insn, super.naryOperation(insn, null), (Value[]) values.toArray(new Value[values.size()]));\n    }\n\n    @Override\n    public void returnOperation(AbstractInsnNode insn, Value value, Value expected) throws AnalyzerException {\n        Preconditions.checkState(insn.getOpcode() == Opcodes.ARETURN); // we return a Rule which is a reference type\n        Checks.ensure(insn.getNext() == null ||\n                insn.getNext().getType() == AbstractInsnNode.LABEL && insn.getNext().getNext() == null,\n                \"Illegal parser rule definition '\" + method.name + \"':\\n\" +\n                        \"Rule definition methods must contain exactly one return statement\");\n    }\n\n    @Override\n    public Value merge(Value v, Value w) {\n        // we don't actually merge values but use the control flow detection to deal with conditionals\n        return v;\n    }\n\n    public void newControlFlowEdge(int instructionIndex, int successorIndex) {\n        switch (method.instructions.get(instructionIndex).getType()) {\n            case AbstractInsnNode.LABEL:\n            case AbstractInsnNode.JUMP_INSN:\n                additionalEdges.add(new int[] {instructionIndex, successorIndex});\n                return;\n        }\n\n        switch (method.instructions.get(successorIndex).getType()) {\n            case AbstractInsnNode.JUMP_INSN:\n                additionalEdges.add(new int[] {instructionIndex, successorIndex});\n        }\n    }\n\n    public void finish() {\n        // finally add all edges so far not included\n        InstructionGraphNode[] instructionGraphNodes = method.getInstructionGraphNodes();\n        for (int[] edge : additionalEdges) {\n            InstructionGraphNode node = instructionGraphNodes[edge[0]];\n            if (node == null) node = createNode(method.instructions.get(edge[0]), null);\n            InstructionGraphNode succ = instructionGraphNodes[edge[1]];\n            if (succ == null) succ = createNode(method.instructions.get(edge[1]), null);\n            if (!succ.predecessors.contains(node)) succ.predecessors.add(node);\n        }\n\n        // set the finishing label, if existing\n        int lastIndex = instructionGraphNodes.length - 1;\n        AbstractInsnNode lastInstruction = method.instructions.get(lastIndex);\n        if (instructionGraphNodes[lastIndex] == null) {\n            Preconditions.checkState(lastInstruction.getType() == AbstractInsnNode.LABEL);\n            createNode(lastInstruction, null);\n        }\n    }\n\n    private InstructionGraphNode createNode(AbstractInsnNode insn, Value resultValue, Value... prevNodes) {\n        int index = method.instructions.indexOf(insn);\n        BasicValue resultBasicValue = getBasicValue(resultValue);\n        InstructionGraphNode node =\n                new InstructionGraphNode(classNode, insn, index, resultBasicValue, Arrays.asList(prevNodes));\n        method.getInstructionGraphNodes()[index] = node;\n        return node;\n    }\n\n    private BasicValue getBasicValue(Value resultValue) {\n        return resultValue == null || resultValue instanceof BasicValue ?\n                (BasicValue) resultValue : ((InstructionGraphNode) resultValue).basicValue;\n    }\n\n    private void verifyInstruction(AbstractInsnNode insn) {\n        try {\n            switch (insn.getOpcode()) {\n                case PUTFIELD:\n                case PUTSTATIC:\n                    throw new GrammarException(\"Writing to a field is not allowed from within a parser rule method\");\n\n                case GETFIELD:\n                case GETSTATIC:\n                    FieldInsnNode field = (FieldInsnNode) insn;\n                    Checks.ensure(isNoPrivateField(field.owner, field.name),\n                            \"Accessing a private field from within a parser rule method is not allowed.\\n\" +\n                                    \"Mark the field protected or package-private if you want to prevent public access!\");\n                    break;\n\n                case INVOKEVIRTUAL:\n                case INVOKESTATIC:\n                case INVOKESPECIAL:\n                case INVOKEINTERFACE:\n                    MethodInsnNode method = (MethodInsnNode) insn;\n                    Checks.ensure(\"<init>\".equals(method.name) ||\n                            isNoPrivateMethod(method.owner, method.name, method.desc),\n                            \"Calling a private method from within a parser rule method is not allowed.\\n\" +\n                                    \"Mark the method protected or package-private if you want to prevent public access!\");\n                    break;\n            }\n        } catch (GrammarException e) {\n            throw new GrammarException(\n                    \"Illegal parser rule definition '\" + method.name + \"':\\n\" + e.getMessage());\n        }\n    }\n\n    private boolean isNoPrivateField(String owner, String name) {\n        String key = owner + '#' + name;\n        Integer modifiers = memberModifiers.get(key);\n        if (modifiers == null) {\n            modifiers = getOwnerField(owner, name).getModifiers();\n            memberModifiers.put(key, modifiers);\n        }\n        return !Modifier.isPrivate(modifiers);\n    }\n\n    private boolean isNoPrivateMethod(String owner, String name, String desc) {\n        String key = owner + '#' + name + '#' + desc;\n        Integer modifiers = memberModifiers.get(key);\n        if (modifiers == null) {\n            modifiers = getOwnerMethod(owner, name, desc).getModifiers();\n            memberModifiers.put(key, modifiers);\n        }\n        return !Modifier.isPrivate(modifiers);\n    }\n\n}\n","lineNo":107}
{"Refactored Sample":"/*\n * Copyright (c) 2009-2010 Ken Wenzel and Mathias Doenitz\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\npackage org.parboiled.transform;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.Lists;\nimport org.objectweb.asm.Opcodes;\nimport org.objectweb.asm.Type;\nimport org.objectweb.asm.tree.AbstractInsnNode;\nimport org.objectweb.asm.tree.analysis.AnalyzerException;\nimport org.objectweb.asm.tree.analysis.BasicInterpreter;\nimport org.objectweb.asm.tree.analysis.BasicValue;\nimport org.objectweb.asm.tree.analysis.Value;\n\nimport java.util.Arrays;\nimport java.util.List;\n\nclass RuleMethodInterpreter extends BasicInterpreter implements Types {\n\n    private final RuleMethod method;\n    private final List<Edge> additionalEdges = Lists.newArrayList();\n\n    public RuleMethodInterpreter(RuleMethod method) {\n        this.method = method;\n    }\n\n    @Override\n    public Value newValue(Type type) {\n        BasicValue basicValue = (BasicValue) super.newValue(type);\n        if (basicValue == BasicValue.REFERENCE_VALUE) {\n            basicValue = new BasicValue(type); // record the exact type and not just \"Ljava/lang/Object\"\n        }\n        return basicValue;\n    }\n\n    @Override\n    public Value newOperation(AbstractInsnNode insn) throws AnalyzerException {\n        return createNode(insn, super.newOperation(insn));\n    }\n\n    @Override\n    public Value copyOperation(AbstractInsnNode insn, Value value) throws AnalyzerException {\n        return createNode(insn, super.copyOperation(insn, value), value);\n    }\n\n    @Override\n    public Value unaryOperation(AbstractInsnNode insn, Value value) throws AnalyzerException {\n        return createNode(insn, super.unaryOperation(insn, null), value);\n    }\n\n    @Override\n    public Value binaryOperation(AbstractInsnNode insn, Value value1, Value value2) throws AnalyzerException {\n        return createNode(insn, super.binaryOperation(insn, null, null), value1, value2);\n    }\n\n    @Override\n    public Value ternaryOperation(AbstractInsnNode insn, Value v1, Value v2, Value v3) throws AnalyzerException {\n        return createNode(insn, super.ternaryOperation(insn, null, null, null), v1, v2, v3);\n    }\n\n    @Override\n    @SuppressWarnings({\"unchecked\"})\n    public Value naryOperation(AbstractInsnNode insn, List values) throws AnalyzerException {\n        return createNode(insn, super.naryOperation(insn, null), (Value[]) values.toArray(new Value[values.size()]));\n    }\n\n    @Override\n    public void returnOperation(AbstractInsnNode insn, Value value, Value expected) throws AnalyzerException {\n        Preconditions.checkState(insn.getOpcode() == Opcodes.ARETURN);\n        Preconditions.checkState(unwrap(value).getType().equals(RULE));\n        Preconditions.checkState(unwrap(expected).getType().equals(RULE));\n        Preconditions.checkState(method.getReturnInstructionNode() == null);\n        method.setReturnInstructionNode(createNode(insn, null, value));\n    }\n\n    private InstructionGraphNode createNode(AbstractInsnNode insn, Value resultValue, Value... prevNodes) {\n        return method.setGraphNode(insn, unwrap(resultValue), Arrays.asList(prevNodes));\n    }\n\n    @Override\n    public Value merge(Value v, Value w) {\n        // we don't actually merge values but use the control flow detection to deal with conditionals\n        return v;\n    }\n\n    public void newControlFlowEdge(int instructionIndex, int successorIndex) {\n        AbstractInsnNode fromInsn = method.instructions.get(instructionIndex);\n        AbstractInsnNode toInsn = method.instructions.get(successorIndex);\n        switch (fromInsn.getType()) {\n            case AbstractInsnNode.LABEL:\n            case AbstractInsnNode.JUMP_INSN:\n                additionalEdges.add(new Edge(fromInsn, toInsn));\n                return;\n        }\n\n        switch (toInsn.getType()) {\n            case AbstractInsnNode.JUMP_INSN:\n                additionalEdges.add(new Edge(fromInsn, toInsn));\n        }\n    }\n\n    public void finish() {\n        // finally add all edges so far not included\n        for (Edge edge : additionalEdges) {\n            InstructionGraphNode node = method.getGraphNode(edge.from);\n            if (node == null) node = createNode(edge.from, null);\n            InstructionGraphNode succ = method.getGraphNode(edge.to);\n            if (succ == null) succ = createNode(edge.to, null);\n            if (!succ.getPredecessors().contains(node)) succ.getPredecessors().add(node);\n        }\n    }\n\n    private BasicValue unwrap(Value resultValue) {\n        return resultValue == null || resultValue instanceof BasicValue ?\n                (BasicValue) resultValue : ((InstructionGraphNode) resultValue).getResultValue();\n    }\n\n    private class Edge {\n        public final AbstractInsnNode from;\n        public final AbstractInsnNode to;\n\n        public Edge(AbstractInsnNode from, AbstractInsnNode to) {\n            this.from = from;\n            this.to = to;\n        }\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (c) 2009-2010 Ken Wenzel and Mathias Doenitz\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\npackage org.parboiled.transform;\n\nimport com.google.common.base.Preconditions;\nimport org.objectweb.asm.Opcodes;\nimport org.objectweb.asm.Type;\nimport org.objectweb.asm.tree.AbstractInsnNode;\nimport org.objectweb.asm.tree.FieldInsnNode;\nimport org.objectweb.asm.tree.MethodInsnNode;\nimport org.objectweb.asm.tree.analysis.AnalyzerException;\nimport org.objectweb.asm.tree.analysis.BasicInterpreter;\nimport org.objectweb.asm.tree.analysis.BasicValue;\nimport org.objectweb.asm.tree.analysis.Value;\nimport org.parboiled.errors.GrammarException;\nimport org.parboiled.support.Checks;\n\nimport java.lang.reflect.Modifier;\nimport java.util.*;\n\nimport static org.parboiled.transform.AsmUtils.getOwnerField;\nimport static org.parboiled.transform.AsmUtils.getOwnerMethod;\n\nclass RuleMethodInterpreter extends BasicInterpreter {\n\n    private final ParserClassNode classNode;\n    private final RuleMethod method;\n    private final List<int[]> additionalEdges = new ArrayList<int[]>();\n    private final Map<String, Integer> memberModifiers = new HashMap<String, Integer>();\n\n    public RuleMethodInterpreter(ParserClassNode classNode, RuleMethod method) {\n        this.classNode = classNode;\n        this.method = method;\n    }\n\n    @Override\n    public Value newValue(Type type) {\n        BasicValue basicValue = (BasicValue) super.newValue(type);\n        if (basicValue == BasicValue.REFERENCE_VALUE) {\n            basicValue = new BasicValue(type); // record the exact type and not just \"Ljava/lang/Object\"\n        }\n        return basicValue;\n    }\n\n    @Override\n    public Value newOperation(AbstractInsnNode insn) throws AnalyzerException {\n        return createNode(insn, super.newOperation(insn));\n    }\n\n    @Override\n    public Value copyOperation(AbstractInsnNode insn, Value value) throws AnalyzerException {\n        return createNode(insn, super.copyOperation(insn, value), value);\n    }\n\n    @Override\n    public Value unaryOperation(AbstractInsnNode insn, Value value) throws AnalyzerException {\n        verifyInstruction(insn);\n        return createNode(insn, super.unaryOperation(insn, null), value);\n    }\n\n    @Override\n    public Value binaryOperation(AbstractInsnNode insn, Value value1, Value value2) throws AnalyzerException {\n        return createNode(insn, super.binaryOperation(insn, null, null), value1, value2);\n    }\n\n    @Override\n    public Value ternaryOperation(AbstractInsnNode insn, Value v1, Value v2, Value v3) throws AnalyzerException {\n        return createNode(insn, super.ternaryOperation(insn, null, null, null), v1, v2, v3);\n    }\n\n    @Override\n    @SuppressWarnings({\"unchecked\"})\n    public Value naryOperation(AbstractInsnNode insn, List values) throws AnalyzerException {\n        verifyInstruction(insn);\n        return createNode(insn, super.naryOperation(insn, null), (Value[]) values.toArray(new Value[values.size()]));\n    }\n\n    @Override\n    public void returnOperation(AbstractInsnNode insn, Value value, Value expected) throws AnalyzerException {\n        Preconditions.checkState(insn.getOpcode() == Opcodes.ARETURN); // we return a Rule which is a reference type\n        Checks.ensure(insn.getNext() == null ||\n                insn.getNext().getType() == AbstractInsnNode.LABEL && insn.getNext().getNext() == null,\n                \"Illegal parser rule definition '\" + method.name + \"':\\n\" +\n                        \"Rule definition methods must contain exactly one return statement\");\n    }\n\n    @Override\n    public Value merge(Value v, Value w) {\n        // we don't actually merge values but use the control flow detection to deal with conditionals\n        return v;\n    }\n\n    public void newControlFlowEdge(int instructionIndex, int successorIndex) {\n        switch (method.instructions.get(instructionIndex).getType()) {\n            case AbstractInsnNode.LABEL:\n            case AbstractInsnNode.JUMP_INSN:\n                additionalEdges.add(new int[] {instructionIndex, successorIndex});\n                return;\n        }\n\n        switch (method.instructions.get(successorIndex).getType()) {\n            case AbstractInsnNode.JUMP_INSN:\n                additionalEdges.add(new int[] {instructionIndex, successorIndex});\n        }\n    }\n\n    public void finish() {\n        // finally add all edges so far not included\n        InstructionGraphNode[] instructionGraphNodes = method.getInstructionGraphNodes();\n        for (int[] edge : additionalEdges) {\n            InstructionGraphNode node = instructionGraphNodes[edge[0]];\n            if (node == null) node = createNode(method.instructions.get(edge[0]), null);\n            InstructionGraphNode succ = instructionGraphNodes[edge[1]];\n            if (succ == null) succ = createNode(method.instructions.get(edge[1]), null);\n            if (!succ.predecessors.contains(node)) succ.predecessors.add(node);\n        }\n\n        // set the finishing label, if existing\n        int lastIndex = instructionGraphNodes.length - 1;\n        AbstractInsnNode lastInstruction = method.instructions.get(lastIndex);\n        if (instructionGraphNodes[lastIndex] == null) {\n            Preconditions.checkState(lastInstruction.getType() == AbstractInsnNode.LABEL);\n            createNode(lastInstruction, null);\n        }\n    }\n\n    private InstructionGraphNode createNode(AbstractInsnNode insn, Value resultValue, Value... prevNodes) {\n        int index = method.instructions.indexOf(insn);\n        BasicValue resultBasicValue = getBasicValue(resultValue);\n        InstructionGraphNode node =\n                new InstructionGraphNode(classNode, insn, index, resultBasicValue, Arrays.asList(prevNodes));\n        method.getInstructionGraphNodes()[index] = node;\n        return node;\n    }\n\n    private BasicValue getBasicValue(Value resultValue) {\n        return resultValue == null || resultValue instanceof BasicValue ?\n                (BasicValue) resultValue : ((InstructionGraphNode) resultValue).basicValue;\n    }\n\n    private void verifyInstruction(AbstractInsnNode insn) {\n        try {\n            switch (insn.getOpcode()) {\n                case PUTFIELD:\n                case PUTSTATIC:\n                    throw new GrammarException(\"Writing to a field is not allowed from within a parser rule method\");\n\n                case GETFIELD:\n                case GETSTATIC:\n                    FieldInsnNode field = (FieldInsnNode) insn;\n                    Checks.ensure(isNoPrivateField(field.owner, field.name),\n                            \"Accessing a private field from within a parser rule method is not allowed.\\n\" +\n                                    \"Mark the field protected or package-private if you want to prevent public access!\");\n                    break;\n\n                case INVOKEVIRTUAL:\n                case INVOKESTATIC:\n                case INVOKESPECIAL:\n                case INVOKEINTERFACE:\n                    MethodInsnNode method = (MethodInsnNode) insn;\n                    Checks.ensure(\"<init>\".equals(method.name) ||\n                            isNoPrivateMethod(method.owner, method.name, method.desc),\n                            \"Calling a private method from within a parser rule method is not allowed.\\n\" +\n                                    \"Mark the method protected or package-private if you want to prevent public access!\");\n                    break;\n            }\n        } catch (GrammarException e) {\n            throw new GrammarException(\n                    \"Illegal parser rule definition '\" + method.name + \"':\\n\" + e.getMessage());\n        }\n    }\n\n    private boolean isNoPrivateField(String owner, String name) {\n        String key = owner + '#' + name;\n        Integer modifiers = memberModifiers.get(key);\n        if (modifiers == null) {\n            modifiers = getOwnerField(owner, name).getModifiers();\n            memberModifiers.put(key, modifiers);\n        }\n        return !Modifier.isPrivate(modifiers);\n    }\n\n    private boolean isNoPrivateMethod(String owner, String name, String desc) {\n        String key = owner + '#' + name + '#' + desc;\n        Integer modifiers = memberModifiers.get(key);\n        if (modifiers == null) {\n            modifiers = getOwnerMethod(owner, name, desc).getModifiers();\n            memberModifiers.put(key, modifiers);\n        }\n        return !Modifier.isPrivate(modifiers);\n    }\n\n}\n","lineNo":108}
{"Refactored Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.support;\n\nimport com.google.common.base.Preconditions;\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.common.StringUtils;\n\n/**\n * (Almost) immutable descriptor for a certain position in an {@link InputBuffer}.\n * The InputLocations corresponding to one input text form a simple linked list.\n */\npublic class InputLocation {\n    private final int index;\n    private final int row;\n    private final int column;\n    private final char character;\n    private InputLocation next;\n\n    public InputLocation(@NotNull InputBuffer inputBuffer) {\n        this(inputBuffer, 0, 0, 0);\n    }\n\n    private InputLocation(@NotNull InputBuffer inputBuffer, int index, int row, int column) {\n        this(index, row, column, inputBuffer.charAt(index));\n    }\n\n    private InputLocation(int index, int row, int column, char character) {\n        this.index = index;\n        this.row = row;\n        this.column = column;\n        this.character = character;\n    }\n\n    /**\n     * @return the index of this location in the underlying {@link InputBuffer}\n     */\n    public int getIndex() {\n        return index;\n    }\n\n    /**\n     * @return the row number of this location, starting at 0\n     */\n    public int getRow() {\n        return row;\n    }\n\n    /**\n     * @return the column number of this location, starting at 0\n     */\n    public int getColumn() {\n        return column;\n    }\n\n    /**\n     * @return the input character at this location\n     */\n    public char getChar() {\n        return character;\n    }\n\n    /**\n     * Returns the next input location if it has already been fetched, or null if this location is the last location\n     * in the underlying {@link InputBuffer} that was looked at during the current parsing run.\n     *\n     * @return the next input location or null\n     */\n    public InputLocation getNext() {\n        return next;\n    }\n\n    /**\n     * Fetches and returns the input location after this one in the given {@link InputBuffer}.\n     * If this is already the input location at EOI the method return this instance.\n     *\n     * @param inputBuffer the input buffer\n     * @return the following input location or this if already at EOI\n     */\n    public InputLocation advance(@NotNull InputBuffer inputBuffer) {\n        if (next != null) {\n            return next;\n        }\n        switch (character) {\n            case '\\n':\n                return next = new InputLocation(inputBuffer, index + 1, row + 1, 0);\n            case Characters.EOI:\n                return next = this;\n            default:\n                return next = new InputLocation(inputBuffer, index + 1, row, column + 1);\n        }\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\"#%s(%s,%s)'%s'\", index, row, column, StringUtils.escape(character));\n    }\n\n    /**\n     * \"Cuts out\" and returns the next input location from the chain of InputLocations.\n     * Neither this nor the next InputLocation must be the last InputLocation in the chain.\n     * This operation does not change the underlying {@link InputBuffer}.\n     *\n     * @return the InputLocation that was cut out.\n     */\n    @NotNull\n    public InputLocation removeNext() {\n        Preconditions.checkState(next != null && next.next != null,\n                \"removeNext() should not be called on a fringe location or its immediate predecessor\");\n        InputLocation oldNext = next;\n        next = next.next;\n        return oldNext;\n    }\n\n    /**\n     * Inserts the given InputLocation as the next input location into the chain.\n     * Useful for reversing a previous {@link #removeNext()} operation.\n     * This operation does not change the underlying {@link InputBuffer}.\n     *\n     * @param nextLocation the location to insert.\n     */\n    public void insertNext(@NotNull InputLocation nextLocation) {\n        nextLocation.next = next;\n        next = nextLocation;\n    }\n\n    /**\n     * Inserts a virtual character into the input stream without changing the underlying {@link InputBuffer}.\n     * This instance must not be the last InputLocation fetched so far.\n     *\n     * @param character the char to insert\n     */\n    public void insertNext(char character) {\n        Preconditions.checkState(next != null, \"insertNext(char) should not be called on a fringe location\");\n        InputLocation predecessor = new InputLocation(next.index, next.row, next.column, character);\n        predecessor.next = next;\n        insertNext(predecessor);\n    }\n\n}\n\n","Smelly Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.support;\n\nimport com.google.common.base.Preconditions;\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.common.StringUtils;\n\n/**\n * Value container identifying a certain position in an InputBuffer.\n */\npublic class InputLocation {\n    private final int index;\n    private final int row;\n    private final int column;\n    private final char character;\n    private InputLocation next;\n\n    public InputLocation(@NotNull InputBuffer inputBuffer) {\n        this(inputBuffer, 0, 0, 0);\n    }\n\n    private InputLocation(@NotNull InputBuffer inputBuffer, int index, int row, int column) {\n        this(index, row, column, inputBuffer.charAt(index));\n    }\n\n    private InputLocation(int index, int row, int column, char character) {\n        this.index = index;\n        this.row = row;\n        this.column = column;\n        this.character = character;\n    }\n\n    public int getIndex() {\n        return index;\n    }\n\n    public int getRow() {\n        return row;\n    }\n\n    public int getColumn() {\n        return column;\n    }\n\n    public char getChar() {\n        return character;\n    }\n\n    public InputLocation getNext() {\n        return next;\n    }\n\n    /**\n     * Returns the input location after this one in the given InputBuffer.\n     * If this is already the input location at EOI the method return this instance.\n     *\n     * @param inputBuffer the input buffer\n     * @return the following input location or this if already at EOI\n     */\n    public InputLocation advance(@NotNull InputBuffer inputBuffer) {\n        if (next != null) {\n            return next;\n        }\n        switch (character) {\n            case '\\n':\n                return next = new InputLocation(inputBuffer, index + 1, row + 1, 0);\n            case Characters.EOI:\n                return next = this;\n            default:\n                return next = new InputLocation(inputBuffer, index + 1, row, column + 1);\n        }\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\"#%s(%s,%s)'%s'\", index, row, column, StringUtils.escape(character));\n    }\n\n    @NotNull\n    public InputLocation removeNext() {\n        Preconditions.checkState(next != null && next.next != null,\n                \"removeNext() should not be called on a fringe location or its immediate predecessor\");\n        InputLocation oldNext = next;\n        next = next.next;\n        return oldNext;\n    }\n\n    public void insertNext(@NotNull InputLocation nextLocation) {\n        nextLocation.next = next;\n        next = nextLocation;\n    }\n\n    /**\n     * Inserts a virtual character into the input stream without changing the underlying InputBuffer.\n     *\n     * @param character the char to insert\n     */\n    public void insertNext(char character) {\n        Preconditions.checkState(next != null, \"insertNext(char) should not be called on a fringe location\");\n        insertNext(next.insertBefore(character));\n    }\n\n    public InputLocation insertBefore(char character) {\n        InputLocation predecessor = new InputLocation(index, row, column, character);\n        predecessor.next = this;\n        return predecessor;\n    }\n\n}\n\n","lineNo":149}
{"Refactored Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.trees;\n\nimport com.google.common.base.Preconditions;\nimport org.jetbrains.annotations.NotNull;\n\n/**\n * General utility methods for operating on tree, i.e. graphs consisting of {@link TreeNode}s.\n */\npublic class TreeUtils {\n\n    private TreeUtils() {}\n\n    /**\n     * Returns the root of the tree the given node is part of.\n     *\n     * @param node the node to get the root of\n     * @return the root or null if the given node is null\n     */\n    public static <T extends TreeNode<T>> T getRoot(T node) {\n        if (node == null) return null;\n        if (node.getParent() != null) return getRoot(node.getParent());\n        return node;\n    }\n\n    /**\n     * Adds a new child node to a given MutableTreeNode parent.\n     *\n     * @param parent the parent node\n     * @param child  the child node to add\n     */\n    public static <T extends MutableTreeNode<T>> void addChild(@NotNull T parent, T child) {\n        parent.addChild(parent.getChildren().size(), child);\n    }\n\n    /**\n     * Removes the given child from the given parent node.\n     *\n     * @param parent the parent node\n     * @param child  the child node\n     */\n    public static <T extends MutableTreeNode<T>> void removeChild(@NotNull T parent, T child) {\n        int index = parent.getChildren().indexOf(child);\n        Preconditions.checkElementIndex(index, parent.getChildren().size());\n        parent.removeChild(index);\n    }\n\n    /**\n     * Performs the following transformation on the given MutableBinaryTreeNode:\n     * <pre>\n     *        o1                    o2\n     *       / \\                   / \\\n     *      A   o2     ====>     o1   C\n     *         / \\              / \\\n     *        B   C            A   B\n     * <\/pre>\n     *\n     * @param node the node to transform\n     * @return the new root after the transformation, which is either the right sub node of the original root\n     *         or the original root, if the right sub node is null\n     */\n    public static <N extends MutableBinaryTreeNode<N>> N toLeftAssociativity(@NotNull N node) {\n        N right = node.right();\n        if (right == null) return node;\n\n        node.setRight(right.left());\n        right.setLeft(node);\n        return right;\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.trees;\n\nimport org.jetbrains.annotations.NotNull;\n\npublic class TreeUtils {\n\n    private TreeUtils() {}\n\n    public static <T extends TreeNode<T>> T getRoot(T node) {\n        if (node == null) return null;\n        if (node.getParent() != null) return getRoot(node.getParent());\n        return node;\n    }\n\n    public static <T extends MutableTreeNode<T>> void addChild(T parent, T child) {\n        if (parent != null) {\n            parent.addChild(parent.getChildren().size(), child);\n        }\n    }\n\n    public static <T extends MutableTreeNode<T>> void removeChild(T parent, @NotNull T child) {\n        if (parent != null) {\n            parent.removeChild(parent.getChildren().indexOf(child));\n        }\n    }\n\n    /**\n     * Performs the following transformation on the given MutableBinaryTreeNode:\n     * <pre>\n     *        o1                    o2\n     *       / \\                   / \\\n     *      A   o2     ====>     o1   C\n     *         / \\              / \\\n     *        B   C            A   B\n     * <\/pre>\n     *\n     * @param node the node to transform\n     * @return the new root after the transformation, which is either the right sub node of the original root\n     *         or the original root, if the right sub node is null\n     */\n    public static <N extends MutableBinaryTreeNode<N>> N toLeftAssociativity(@NotNull N node) {\n        N right = node.right();\n        if (right == null) return node;\n\n        node.setRight(right.left());\n        right.setLeft(node);\n        return right;\n    }\n\n}\n","lineNo":58}
{"Refactored Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.common.StringUtils;\nimport org.parboiled.support.Checks;\nimport org.parboiled.support.LabelPrefixPredicate;\nimport org.parboiled.support.ParseTreeUtils;\nimport static org.parboiled.support.ParseTreeUtils.collectNodes;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic abstract class BaseActions<V> implements ContextAware<V> {\n\n    /**\n     * Current context for use by action methods.\n     */\n    private Context<V> context;\n\n    /**\n     * The current context for use with action methods. Updated immediately before action calls.\n     *\n     * @return the current context\n     */\n    public Context<V> getContext() {\n        return context;\n    }\n\n    /**\n     * ContextAware interface implementation.\n     *\n     * @param context the context\n     */\n    public void setContext(@NotNull Context<V> context) {\n        this.context = context;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the first parse tree node found under the given prefix path.\n     * See {@link org.parboiled.support.ParseTreeUtils#findNodeByPath(org.parboiled.Node, String)} for a description of the path argument.\n     * The path is relative to the current context scope, which can be changed with {@link BaseParser#UP(Object)} or {@link BaseParser#DOWN(Object)}.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public Node<V> NODE(String path) {\n        check();\n        return context.getNodeByPath(path);\n    }\n\n    /**\n     * Creates an action parameter that evaluates to a list of all parse tree nodes found under the given prefix path.\n     * See {@link org.parboiled.support.ParseTreeUtils#findNodeByPath(org.parboiled.Node, String)} )} for a description of the path argument.\n     * The path is relative to the current context scope, which can be changed with {@link BaseParser#UP(Object)} or {@link BaseParser#DOWN(Object)}.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public List<Node<V>> NODES(String path) {\n        check();\n        return ParseTreeUtils.collectNodesByPath(context.getSubNodes(), path, new ArrayList<Node<V>>());\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the first parse tree node found with the given label prefix.\n     * See {@link org.parboiled.support.ParseTreeUtils#findNodeByPath(org.parboiled.Node, String)} for a description of the path argument.\n     * The path is relative to the current context scope, which can be changed with {@link BaseParser#UP(Object)} or {@link BaseParser#DOWN(Object)}.\n     *\n     * @param labelPrefix the label prefix\n     * @return the action parameter\n     */\n    public Node<V> NODE_BY_LABEL(String labelPrefix) {\n        check();\n        return context.getNodeByLabel(labelPrefix);\n    }\n\n    /**\n     * Creates an action parameter that evaluates to a list of all parse tree nodes found under the given prefix path.\n     * See {@link org.parboiled.support.ParseTreeUtils#findNodeByPath(org.parboiled.Node, String)} )} for a description of the path argument.\n     * The path is relative to the current context scope, which can be changed with {@link BaseParser#UP(Object)} or {@link BaseParser#DOWN(Object)}.\n     *\n     * @param labelPrefix the label prefix\n     * @return the action parameter\n     */\n    public List<Node<V>> NODES_BY_LABEL(String labelPrefix) {\n        check();\n        return collectNodes(context.getSubNodes(),\n                new LabelPrefixPredicate<V>(labelPrefix),\n                new ArrayList<Node<V>>()\n        );\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the last node created during this parsing run. This last node\n     * is independent of the current context scope, i.e. {@link BaseParser#UP(Object)} or {@link BaseParser#DOWN(Object)} have no influence\n     * on it.\n     *\n     * @return the action parameter\n     */\n    public Node<V> LAST_NODE() {\n        check();\n        return context.getLastNode();\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the tree value of the current context scope level, i.e.,\n     * if there is an explicitly set value it is returned. Otherwise the last non-null child value, or, if there\n     * is no such value, null.\n     *\n     * @return the action parameter\n     */\n    public V VALUE() {\n        check();\n        return context.getTreeValue();\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the value of the given node.\n     *\n     * @param node the node the get the value from\n     * @return the action parameter\n     */\n    public V VALUE(Node<V> node) {\n        return node == null ? null : node.getValue();\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the value of the node found under the given prefix path.\n     * Equivalent to <code>VALUE(NODE(path))<\/code>.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public V VALUE(String path) {\n        return VALUE(NODE(path));\n    }\n\n    /**\n     * Creates an action parameter that evaluates to a list of the values of all given nodes.\n     *\n     * @param nodes the nodes to get the values from\n     * @return the action parameter\n     */\n    public List<V> VALUES(List<Node<V>> nodes) {\n        List<V> values = new ArrayList<V>();\n        for (Node<V> node : nodes) {\n            values.add(node.getValue());\n        }\n        return values;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to a list of the values of all nodes found under the given prefix path.\n     * Equivalent to <code>VALUES(NODES(path))<\/code>.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public List<V> VALUES(String path) {\n        return VALUES(NODES(path));\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the value of the last node created during this parsing run.\n     * Equivalent to <code>VALUE(LAST_NODE())<\/code>.\n     *\n     * @return the action parameter\n     */\n    public V LAST_VALUE() {\n        return VALUE(LAST_NODE());\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the input text matched by the given parse tree node.\n     *\n     * @param node the parse tree node\n     * @return the action parameter\n     */\n    public String TEXT(Node<V> node) {\n        check();\n        return context.getNodeText(node);\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the input text matched by the node found under the given prefix path.\n     * Equivalent to <code>TEXT(NODE(path))<\/code>.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public String TEXT(String path) {\n        return TEXT(NODE(path));\n    }\n\n    /**\n     * Creates an action parameter that evaluates to a list of the input texts matched by all given nodes.\n     *\n     * @param nodes the nodes\n     * @return the action parameter\n     */\n    public List<String> TEXTS(List<Node<V>> nodes) {\n        check();\n        List<String> values = new ArrayList<String>();\n        for (Node<V> node : nodes) {\n            values.add(context.getNodeText(node));\n        }\n        return values;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to a list of the input texts matched by of all nodes found\n     * under the given prefix path.\n     * Equivalent to <code>TEXTS(NODES(path))<\/code>.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public List<String> TEXTS(String path) {\n        return TEXTS(NODES(path));\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the input text matched by the last node created during this parsing run.\n     * Equivalent to <code>TEXT(LAST_NODE())<\/code>.\n     *\n     * @return the action parameter\n     */\n    public String LAST_TEXT() {\n        return TEXT(LAST_NODE());\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the first character of the input text matched by the given parse tree node.\n     *\n     * @param node the parse tree node\n     * @return the action parameter\n     */\n    public Character CHAR(Node<V> node) {\n        String text = TEXT(node);\n        return StringUtils.isEmpty(text) ? null : text.charAt(0);\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the first character of the input text matched by the node found under the given prefix path.\n     * Equivalent to <code>CHAR(NODE(path))<\/code>.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public Character CHAR(String path) {\n        return CHAR(NODE(path));\n    }\n\n    /**\n     * Creates an action parameter that evaluates to a list of the first characters of the input texts matched by all given nodes.\n     *\n     * @param nodes the nodes\n     * @return the action parameter\n     */\n    public List<Character> CHARS(List<Node<V>> nodes) {\n        check();\n        List<Character> values = new ArrayList<Character>();\n        for (Node<V> node : nodes) {\n            values.add(CHAR(node));\n        }\n        return values;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to a list of the first characters of the input texts matched by of all nodes found\n     * under the given prefix path.\n     * Equivalent to <code>CHARS(NODES(path))<\/code>.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public List<Character> CHARS(String path) {\n        return CHARS(NODES(path));\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the first character of the input text matched by the last node created during this parsing run.\n     * Equivalent to <code>CHAR(LAST_NODE())<\/code>.\n     *\n     * @return the action parameter\n     */\n    public Character LAST_CHAR() {\n        return CHAR(LAST_NODE());\n    }\n\n    /**\n     * Creates a special action rule that sets the value of the parse tree node to be created for the current context\n     * scope to the value of the last node created during the current parsing run.\n     * Equivalent to <code>SET(LAST_VALUE())<\/code>.\n     *\n     * @return a new rule\n     */\n    public boolean SET() {\n        return SET(LAST_VALUE());\n    }\n\n    /**\n     * Creates a special action rule that sets the value of the parse tree node to be created for the current context\n     * scope to the given value.\n     *\n     * @param value the value to set\n     * @return a new rule\n     */\n    public boolean SET(V value) {\n        check();\n        context.setNodeValue(value);\n        return true;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the next input character about to be matched.\n     *\n     * @return the action parameter\n     */\n    public Character NEXT_CHAR() {\n        check();\n        return context.getCurrentLocation().getChar();\n    }\n\n    /**\n     * Returns true if the current rule is running somewhere underneath a test/testNot rule.\n     * Useful for example for making sure actions are not run inside of a predicate evaluation:\n     * <code>\n     * return sequence(\n     * ...,\n     * inPredicate() || actions.doSomething()\n     * );\n     * <\/code>\n     *\n     * @return true if in a predicate\n     */\n    public boolean IN_PREDICATE() {\n        check();\n        return context.inPredicate();\n    }\n\n    /**\n     * Returns true if neither the current rule, nor any sub rule has not recorded a parse error.\n     *\n     * @return true if neither the current rule, nor any sub rule has not recorded a parse error\n     */\n    public boolean NO_ERROR() {\n        check();\n        return !context.hasError();\n    }\n\n    private void check() {\n        Checks.ensure(context != null && context.getMatcher() != null,\n                \"Illegal rule definition: Unwrapped action expression!\");\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.support.Checks;\nimport org.parboiled.support.LabelPrefixPredicate;\nimport org.parboiled.support.ParseTreeUtils;\nimport static org.parboiled.support.ParseTreeUtils.collectNodes;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic abstract class BaseActions<V> implements ContextAware<V> {\n\n    /**\n     * Current context for use by action methods.\n     */\n    private Context<V> context;\n\n    /**\n     * The current context for use with action methods. Updated immediately before action calls.\n     *\n     * @return the current context\n     */\n    public Context<V> getContext() {\n        return context;\n    }\n\n    /**\n     * ContextAware interface implementation.\n     *\n     * @param context the context\n     */\n    public void setContext(@NotNull Context<V> context) {\n        this.context = context;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the first parse tree node found under the given prefix path.\n     * See {@link org.parboiled.support.ParseTreeUtils#findNodeByPath(org.parboiled.Node, String)} for a description of the path argument.\n     * The path is relative to the current context scope, which can be changed with {@link BaseParser#UP(Object)} or {@link BaseParser#DOWN(Object)}.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public Node<V> NODE(String path) {\n        check();\n        return context.getNodeByPath(path);\n    }\n\n    /**\n     * Creates an action parameter that evaluates to a list of all parse tree nodes found under the given prefix path.\n     * See {@link org.parboiled.support.ParseTreeUtils#findNodeByPath(org.parboiled.Node, String)} )} for a description of the path argument.\n     * The path is relative to the current context scope, which can be changed with {@link BaseParser#UP(Object)} or {@link BaseParser#DOWN(Object)}.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public List<Node<V>> NODES(String path) {\n        check();\n        return ParseTreeUtils.collectNodesByPath(context.getSubNodes(), path, new ArrayList<Node<V>>());\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the first parse tree node found with the given label prefix.\n     * See {@link org.parboiled.support.ParseTreeUtils#findNodeByPath(org.parboiled.Node, String)} for a description of the path argument.\n     * The path is relative to the current context scope, which can be changed with {@link BaseParser#UP(Object)} or {@link BaseParser#DOWN(Object)}.\n     *\n     * @param labelPrefix the label prefix\n     * @return the action parameter\n     */\n    public Node<V> NODE_BY_LABEL(String labelPrefix) {\n        check();\n        return context.getNodeByLabel(labelPrefix);\n    }\n\n    /**\n     * Creates an action parameter that evaluates to a list of all parse tree nodes found under the given prefix path.\n     * See {@link org.parboiled.support.ParseTreeUtils#findNodeByPath(org.parboiled.Node, String)} )} for a description of the path argument.\n     * The path is relative to the current context scope, which can be changed with {@link BaseParser#UP(Object)} or {@link BaseParser#DOWN(Object)}.\n     *\n     * @param labelPrefix the label prefix\n     * @return the action parameter\n     */\n    public List<Node<V>> NODES_BY_LABEL(String labelPrefix) {\n        check();\n        return collectNodes(context.getSubNodes(),\n                new LabelPrefixPredicate<V>(labelPrefix),\n                new ArrayList<Node<V>>()\n        );\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the last node created during this parsing run. This last node\n     * is independent of the current context scope, i.e. {@link BaseParser#UP(Object)} or {@link BaseParser#DOWN(Object)} have no influence\n     * on it.\n     *\n     * @return the action parameter\n     */\n    public Node<V> LAST_NODE() {\n        check();\n        return context.getLastNode();\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the tree value of the current context scope level, i.e.,\n     * if there is an explicitly set value it is returned. Otherwise the last non-null child value, or, if there\n     * is no such value, null.\n     *\n     * @return the action parameter\n     */\n    public V VALUE() {\n        check();\n        return context.getTreeValue();\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the value of the given node.\n     *\n     * @param node the node the get the value from\n     * @return the action parameter\n     */\n    public V VALUE(Node<V> node) {\n        return node == null ? null : node.getValue();\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the value of the node found under the given prefix path.\n     * Equivalent to <code>VALUE(NODE(path))<\/code>.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public V VALUE(String path) {\n        return VALUE(NODE(path));\n    }\n\n    /**\n     * Creates an action parameter that evaluates to a list of the values of all given nodes.\n     *\n     * @param nodes the nodes to get the values from\n     * @return the action parameter\n     */\n    public List<V> VALUES(List<Node<V>> nodes) {\n        List<V> values = new ArrayList<V>();\n        for (Node<V> node : nodes) {\n            values.add(node.getValue());\n        }\n        return values;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to a list of the values of all nodes found under the given prefix path.\n     * Equivalent to <code>VALUES(NODES(path))<\/code>.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public List<V> VALUES(String path) {\n        return VALUES(NODES(path));\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the value of the last node created during this parsing run.\n     * Equivalent to <code>VALUE(LAST_NODE())<\/code>.\n     *\n     * @return the action parameter\n     */\n    public V LAST_VALUE() {\n        return VALUE(LAST_NODE());\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the input text matched by the given parse tree node.\n     *\n     * @param node the parse tree node\n     * @return the action parameter\n     */\n    public String TEXT(Node<V> node) {\n        check();\n        return context.getNodeText(node);\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the input text matched by the node found under the given prefix path.\n     * Equivalent to <code>TEXT(NODE(path))<\/code>.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public String TEXT(String path) {\n        return TEXT(NODE(path));\n    }\n\n    /**\n     * Creates an action parameter that evaluates to a list of the input texts matched by all given nodes.\n     *\n     * @param nodes the nodes\n     * @return the action parameter\n     */\n    public List<String> TEXTS(List<Node<V>> nodes) {\n        check();\n        List<String> values = new ArrayList<String>();\n        for (Node<V> node : nodes) {\n            values.add(context.getNodeText(node));\n        }\n        return values;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to a list of the input texts matched by of all nodes found\n     * under the given prefix path.\n     * Equivalent to <code>TEXTS(NODES(path))<\/code>.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public List<String> TEXTS(String path) {\n        return TEXTS(NODES(path));\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the input text matched by the last node created during this parsing run.\n     * Equivalent to <code>TEXT(LAST_NODE())<\/code>.\n     *\n     * @return the action parameter\n     */\n    public String LAST_TEXT() {\n        return TEXT(LAST_NODE());\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the first character of the input text matched by the given parse tree node.\n     *\n     * @param node the parse tree node\n     * @return the action parameter\n     */\n    public Character CHAR(Node<V> node) {\n        check();\n        return context.getNodeChar(node);\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the first character of the input text matched by the node found under the given prefix path.\n     * Equivalent to <code>CHAR(NODE(path))<\/code>.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public Character CHAR(String path) {\n        return CHAR(NODE(path));\n    }\n\n    /**\n     * Creates an action parameter that evaluates to a list of the first characters of the input texts matched by all given nodes.\n     *\n     * @param nodes the nodes\n     * @return the action parameter\n     */\n    public List<Character> CHARS(List<Node<V>> nodes) {\n        check();\n        List<Character> values = new ArrayList<Character>();\n        for (Node<V> node : nodes) {\n            values.add(context.getNodeChar(node));\n        }\n        return values;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to a list of the first characters of the input texts matched by of all nodes found\n     * under the given prefix path.\n     * Equivalent to <code>CHARS(NODES(path))<\/code>.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public List<Character> CHARS(String path) {\n        return CHARS(NODES(path));\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the first character of the input text matched by the last node created during this parsing run.\n     * Equivalent to <code>CHAR(LAST_NODE())<\/code>.\n     *\n     * @return the action parameter\n     */\n    public Character LAST_CHAR() {\n        return CHAR(LAST_NODE());\n    }\n\n    /**\n     * Creates a special action rule that sets the value of the parse tree node to be created for the current context\n     * scope to the value of the last node created during the current parsing run.\n     * Equivalent to <code>SET(LAST_VALUE())<\/code>.\n     *\n     * @return a new rule\n     */\n    public boolean SET() {\n        return SET(LAST_VALUE());\n    }\n\n    /**\n     * Creates a special action rule that sets the value of the parse tree node to be created for the current context\n     * scope to the given value.\n     *\n     * @param value the value to set\n     * @return a new rule\n     */\n    public boolean SET(V value) {\n        check();\n        context.setNodeValue(value);\n        return true;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the next input character about to be matched.\n     *\n     * @return the action parameter\n     */\n    public Character NEXT_CHAR() {\n        check();\n        return context.getCurrentLocation().getChar();\n    }\n\n    /**\n     * Returns true if the current rule is running somewhere underneath a test/testNot rule.\n     * Useful for example for making sure actions are not run inside of a predicate evaluation:\n     * <code>\n     * return sequence(\n     * ...,\n     * inPredicate() || actions.doSomething()\n     * );\n     * <\/code>\n     *\n     * @return true if in a predicate\n     */\n    public boolean IN_PREDICATE() {\n        check();\n        return context.inPredicate();\n    }\n\n    private void check() {\n        Checks.ensure(context != null && context.getMatcher() != null,\n                \"Illegal rule definition: Unwrapped action expression!\");\n    }\n\n}\n","lineNo":255}
{"Refactored Sample":"/*\n * Copyright (C) 2009-2010 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.errorhandling;\n\nimport com.google.common.base.Supplier;\nimport com.google.common.collect.Lists;\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.MatcherContext;\nimport org.parboiled.Node;\nimport org.parboiled.common.Formatter;\nimport org.parboiled.matchers.Matcher;\nimport org.parboiled.matchers.TestMatcher;\nimport org.parboiled.support.InputLocation;\nimport org.parboiled.support.MatcherPath;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * A {@link ParseErrorHandler} that tries to recover from parse errors and is therefore capable of reporting all\n * errors found in the input. Since it needs to performs several parsing reruns in order to be able to report and\n * recover from parse errors it is considerable slower than the {@link BasicParseErrorHandler} and the\n * {@link ReportFirstParseErrorHandler} on invalid input.\n * It initiates at most one parsing rerun (in the case that the input is invalid) and is only a few percent slower\n * than the {@link BasicParseErrorHandler} on valid input. On valid input it performs about the same as the\n * {@link ReportFirstParseErrorHandler}.\n *\n * @param <V>\n */\npublic class RecoveringParseErrorHandler<V> implements ParseErrorHandler<V> {\n\n    private enum State {\n        Parsing,\n        SeekingToReport,\n        Reporting,\n        SeekingToRecover,\n        Recovering,\n        InRecovery\n    }\n\n    private final DefaultRecoveryRuleVisitor<V> defaultRecoveryVisitor;\n    private final Formatter<InvalidInputError<V>> invalidInputErrorFormatter;\n    private State state;\n    private MatcherContext<V> rootContext;\n    private RecoveryRecord<V> firstRecord;\n    private RecoveryRecord<V> currentRecord;\n\n    public RecoveringParseErrorHandler() {\n        this(new DefaultRecoveryRuleVisitorImpl<V>(), new DefaultInvalidInputErrorFormatter<V>());\n    }\n\n    public RecoveringParseErrorHandler(DefaultRecoveryRuleVisitor<V> defaultRecoveryVisitor) {\n        this(defaultRecoveryVisitor, new DefaultInvalidInputErrorFormatter<V>());\n    }\n\n    public RecoveringParseErrorHandler(Formatter<InvalidInputError<V>> invalidInputErrorFormatter) {\n        this(new DefaultRecoveryRuleVisitorImpl<V>(), invalidInputErrorFormatter);\n    }\n\n    public RecoveringParseErrorHandler(@NotNull DefaultRecoveryRuleVisitor<V> defaultRecoveryVisitor,\n                                       @NotNull Formatter<InvalidInputError<V>> invalidInputErrorFormatter) {\n        this.defaultRecoveryVisitor = defaultRecoveryVisitor;\n        this.invalidInputErrorFormatter = invalidInputErrorFormatter;\n    }\n\n    public boolean matchRoot(@NotNull Supplier<MatcherContext<V>> rootContextProvider) {\n        rootContext = rootContextProvider.get();\n        firstRecord = new RecoveryRecord<V>();\n        firstRecord.errorLocation = rootContext.getCurrentLocation();\n        state = State.Parsing;\n        do {\n            currentRecord = firstRecord;\n            if (rootContext.runMatcher()) {\n                return true;\n            }\n            handleRootMismatch();\n            rootContext = rootContextProvider.get();\n        } while (state != State.Parsing);\n        return false;\n    }\n\n    public boolean match(MatcherContext<V> context) throws Throwable {\n        if (context.getMatcher().match(context)) {\n            handleMatch(context);\n            return true;\n        }\n        return handleMismatch(context);\n    }\n\n    public void handleMatch(MatcherContext<V> context) {\n        switch (state) {\n            case Parsing:\n                currentRecord.advanceErrorLocation(context.getCurrentLocation());\n                break;\n\n            case SeekingToReport:\n                if (currentRecord.errorLocation == context.getCurrentLocation()) {\n                    currentRecord.lastMatch = context.getPath();\n                    state = State.Reporting;\n                }\n                break;\n\n            case SeekingToRecover:\n                if (currentRecord.errorLocation == context.getCurrentLocation()) {\n                    state = State.Recovering;\n                }\n                break;\n        }\n    }\n\n    public boolean handleMismatch(MatcherContext<V> context) {\n        switch (state) {\n            case Reporting:\n                if (currentRecord.errorLocation == context.getCurrentLocation()) {\n                    currentRecord.failedMatcherPaths.add(context.getPath());\n                }\n                break;\n\n            case Recovering:\n                if (recover(context)) {\n                    return true;\n                }\n                break;\n        }\n        return false;\n    }\n\n    private void handleRootMismatch() {\n        switch (state) {\n            case Parsing:\n                seekTo(currentRecord == firstRecord ? State.Reporting : State.Recovering);\n                break;\n\n            case SeekingToReport:\n            case SeekingToRecover:\n                throw new IllegalStateException();\n\n            case Reporting:\n                rootContext.getParseErrors().add(currentRecord.createParseError(invalidInputErrorFormatter));\n                seekTo(State.Recovering);\n                break;\n        }\n    }\n\n    public boolean recover(MatcherContext<V> failedMatcherContext) {\n        Matcher<V> recoveryRule = getRecoveryRule(failedMatcherContext);\n        state = State.InRecovery;\n        if (recoveryRule != null && runRecovery(recoveryRule, failedMatcherContext)) {\n            currentRecord = currentRecord.getNext();\n            if (currentRecord.errorLocation == null) {\n                // after recovery we don't have another error recorded, so continue with \"innocent\" parsing\n                currentRecord.errorLocation = failedMatcherContext.getCurrentLocation();\n                state = State.Parsing;\n            } else if (currentRecord.parseError == null) {\n                // after recovery we are now at an error that has not been reported so far\n                state = State.SeekingToReport;\n            } else {\n                // after recovery we are now at the next error we need to recover from\n                state = State.SeekingToRecover;\n            }\n            return true;\n        }\n        state = State.Recovering;\n        return false;\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    public Matcher<V> getRecoveryRule(MatcherContext<V> failedMatcherContext) {\n        Matcher<V> recoveryRule = failedMatcherContext.getMatcher().getRecoveryMatcher();\n        if (recoveryRule == null) {\n            if (failedMatcherContext != rootContext) {\n                defaultRecoveryVisitor.setContext(failedMatcherContext);\n                defaultRecoveryVisitor.setLastMatch(currentRecord.lastMatch);\n                defaultRecoveryVisitor.setErrorLocation(currentRecord.errorLocation);\n                recoveryRule = (Matcher<V>) failedMatcherContext.getMatcher().accept(defaultRecoveryVisitor);\n            } else {\n                recoveryRule = (Matcher<V>) rootContext.getParser().resynchronize(rootContext, Integer.MAX_VALUE);\n            }\n        }\n        return recoveryRule;\n    }\n\n    public boolean runRecovery(Matcher<V> recoveryRule, MatcherContext<V> failedContext) {\n        MatcherContext<V> recoveryContext = failedContext.getSubContext(recoveryRule);\n        recoveryContext.clearSubLeafNodeSuppression();\n        if (!recoveryContext.runMatcher()) return false;\n        if (failedContext == rootContext) {\n            postRootRecoveryFix();\n        } else if (!(failedContext.getMatcher() instanceof TestMatcher)) {\n            failedContext.getParent().addChildNodes(failedContext.getSubNodes());\n        }\n        return true;\n    }\n\n    // it was directly the root matcher that failed, we need some special treatment since in this case\n    // the illegal nodes must be INSIDE the node instead of outside\n    public void postRootRecoveryFix() {\n        Node<V> rootNode = rootContext.getNodeByPath(rootContext.getMatcher().getLabel());\n        if (rootNode != null) {\n            List<Node<V>> nodes = Lists.newArrayList(rootContext.getSubNodes());\n            nodes.remove(rootNode);\n            nodes.addAll(rootNode.getChildren());\n            rootContext.setSubNodes(nodes);\n        }\n        rootContext.createNode();\n    }\n\n    public void seekTo(State targetState) {\n        if (firstRecord.errorLocation.index == 0) {\n            state = targetState;\n        } else if (targetState == State.Reporting) {\n            state = State.SeekingToReport;\n        } else if (targetState == State.Recovering) {\n            state = State.SeekingToRecover;\n        } else {\n            throw new IllegalStateException();\n        }\n    }\n\n    public static class RecoveryRecord<V> {\n\n        public final List<MatcherPath<V>> failedMatcherPaths = new ArrayList<MatcherPath<V>>();\n        public InputLocation errorLocation;\n        public MatcherPath<V> lastMatch;\n        public InvalidInputError<V> parseError;\n        public RecoveryRecord<V> next;\n\n        public RecoveryRecord<V> getNext() {\n            if (next == null) {\n                next = new RecoveryRecord<V>();\n            }\n            return next;\n        }\n\n        public InvalidInputError<V> createParseError(Formatter<InvalidInputError<V>> invalidInputErrorFormatter) {\n            parseError = new InvalidInputError<V>(errorLocation, lastMatch, failedMatcherPaths,\n                    invalidInputErrorFormatter);\n            return parseError;\n        }\n\n        public void advanceErrorLocation(InputLocation currentLocation) {\n            if (errorLocation.index < currentLocation.index) {\n                errorLocation = currentLocation;\n            }\n        }\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009-2010 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.errorhandling;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.MatcherContext;\nimport org.parboiled.Node;\nimport org.parboiled.common.Formatter;\nimport org.parboiled.matchers.Matcher;\nimport org.parboiled.matchers.TestMatcher;\nimport org.parboiled.support.InputLocation;\nimport org.parboiled.support.MatcherPath;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport com.google.common.base.Supplier;\n\n/**\n * A {@link ParseErrorHandler} that tries to recover from parse errors and is therefore capable of reporting all\n * errors found in the input. Since it needs to performs several parsing reruns in order to be able to report and\n * recover from parse errors it is considerable slower than the {@link BasicParseErrorHandler} and the\n * {@link ReportFirstParseErrorHandler} on invalid input.\n * It initiates at most one parsing rerun (in the case that the input is invalid) and is only a few percent slower\n * than the {@link BasicParseErrorHandler} on valid input. On valid input it performs about the same as the\n * {@link ReportFirstParseErrorHandler}.\n *\n * @param <V>\n */\npublic class RecoveringParseErrorHandler<V> implements ParseErrorHandler<V> {\n\n    private enum State {\n        Parsing,\n        SeekingToReport,\n        Reporting,\n        SeekingToRecover,\n        Recovering,\n        InRecovery\n    }\n\n    private final DefaultRecoveryRuleVisitor<V> defaultRecoveryVisitor;\n    private final Formatter<InvalidInputError<V>> invalidInputErrorFormatter;\n    private State state;\n    private MatcherContext<V> rootContext;\n    private RecoveryRecord<V> firstRecord;\n    private RecoveryRecord<V> currentRecord;\n\n    public RecoveringParseErrorHandler() {\n        this(new DefaultRecoveryRuleVisitorImpl<V>(), new DefaultInvalidInputErrorFormatter<V>());\n    }\n\n    public RecoveringParseErrorHandler(DefaultRecoveryRuleVisitor<V> defaultRecoveryVisitor) {\n        this(defaultRecoveryVisitor, new DefaultInvalidInputErrorFormatter<V>());\n    }\n\n    public RecoveringParseErrorHandler(Formatter<InvalidInputError<V>> invalidInputErrorFormatter) {\n        this(new DefaultRecoveryRuleVisitorImpl<V>(), invalidInputErrorFormatter);\n    }\n\n    public RecoveringParseErrorHandler(@NotNull DefaultRecoveryRuleVisitor<V> defaultRecoveryVisitor,\n                                       @NotNull Formatter<InvalidInputError<V>> invalidInputErrorFormatter) {\n        this.defaultRecoveryVisitor = defaultRecoveryVisitor;\n        this.invalidInputErrorFormatter = invalidInputErrorFormatter;\n    }\n\n    public boolean matchRoot(@NotNull Supplier<MatcherContext<V>> rootContextProvider) {\n        rootContext = rootContextProvider.get();\n        firstRecord = new RecoveryRecord<V>();\n        firstRecord.errorLocation = rootContext.getCurrentLocation();\n        state = State.Parsing;\n        do {\n            currentRecord = firstRecord;\n            if (rootContext.runMatcher()) {\n                return true;\n            }\n            handleRootMismatch();\n            rootContext = rootContextProvider.get();\n        } while (state != State.Parsing);\n        return false;\n    }\n\n    public boolean match(MatcherContext<V> context) throws Throwable {\n        if (context.getMatcher().match(context)) {\n            handleMatch(context);\n            return true;\n        }\n        return handleMismatch(context);\n    }\n\n    public void handleMatch(MatcherContext<V> context) {\n        switch (state) {\n            case Parsing:\n                currentRecord.advanceErrorLocation(context.getCurrentLocation());\n                break;\n\n            case SeekingToReport:\n                if (currentRecord.errorLocation == context.getCurrentLocation()) {\n                    currentRecord.lastMatch = context.getPath();\n                    state = State.Reporting;\n                }\n                break;\n\n            case SeekingToRecover:\n                if (currentRecord.errorLocation == context.getCurrentLocation()) {\n                    state = State.Recovering;\n                }\n                break;\n        }\n    }\n\n    public boolean handleMismatch(MatcherContext<V> context) {\n        switch (state) {\n            case Reporting:\n                if (currentRecord.errorLocation == context.getCurrentLocation()) {\n                    currentRecord.failedMatcherPaths.add(context.getPath());\n                }\n                break;\n\n            case Recovering:\n                if (recover(context)) {\n                    return true;\n                }\n                break;\n        }\n        return false;\n    }\n\n    private void handleRootMismatch() {\n        switch (state) {\n            case Parsing:\n                seekTo(currentRecord == firstRecord ? State.Reporting : State.Recovering);\n                break;\n\n            case SeekingToReport:\n            case SeekingToRecover:\n                throw new IllegalStateException();\n\n            case Reporting:\n                rootContext.getParseErrors().add(currentRecord.createParseError(invalidInputErrorFormatter));\n                seekTo(State.Recovering);\n                break;\n        }\n    }\n\n    public boolean recover(MatcherContext<V> failedMatcherContext) {\n        Matcher<V> recoveryRule = getRecoveryRule(failedMatcherContext);\n        state = State.InRecovery;\n        if (recoveryRule != null && runRecovery(recoveryRule, failedMatcherContext)) {\n            currentRecord = currentRecord.getNext();\n            if (currentRecord.errorLocation == null) {\n                // after recovery we don't have another error recorded, so continue with \"innocent\" parsing\n                currentRecord.errorLocation = failedMatcherContext.getCurrentLocation();\n                state = State.Parsing;\n            } else if (currentRecord.parseError == null) {\n                // after recovery we are now at an error that has not been reported so far\n                state = State.SeekingToReport;\n            } else {\n                // after recovery we are now at the next error we need to recover from\n                state = State.SeekingToRecover;\n            }\n            return true;\n        }\n        state = State.Recovering;\n        return false;\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    public Matcher<V> getRecoveryRule(MatcherContext<V> failedMatcherContext) {\n        Matcher<V> recoveryRule = failedMatcherContext.getMatcher().getRecoveryMatcher();\n        if (recoveryRule == null) {\n            if (failedMatcherContext != rootContext) {\n                defaultRecoveryVisitor.setContext(failedMatcherContext);\n                defaultRecoveryVisitor.setLastMatch(currentRecord.lastMatch);\n                defaultRecoveryVisitor.setErrorLocation(currentRecord.errorLocation);\n                recoveryRule = (Matcher<V>) failedMatcherContext.getMatcher().accept(defaultRecoveryVisitor);\n            } else {\n                recoveryRule = (Matcher<V>) rootContext.getParser().resynchronize(rootContext, Integer.MAX_VALUE);\n            }\n        }\n        return recoveryRule;\n    }\n\n    public boolean runRecovery(Matcher<V> recoveryRule, MatcherContext<V> failedContext) {\n        MatcherContext<V> recoveryContext = failedContext.getSubContext(recoveryRule);\n        recoveryContext.clearSubLeafNodeSuppression();\n        if (!recoveryContext.runMatcher()) return false;\n        if (failedContext == rootContext) {\n            postRootRecoveryFix();\n        } else if (!(failedContext.getMatcher() instanceof TestMatcher) && failedContext.getSubNodes() != null) {\n            failedContext.getParent().addChildNodes(failedContext.getSubNodes());\n        }\n        return true;\n    }\n\n    // it was directly the root matcher that failed, we need some special treatment since in this case\n    // the illegal nodes must be INSIDE the node instead of outside\n    public void postRootRecoveryFix() {\n        Node<V> rootNode = rootContext.getNodeByPath(rootContext.getMatcher().getLabel());\n        if (rootNode != null) {\n            rootContext.getSubNodes().remove(rootNode);\n            rootContext.getSubNodes().addAll(rootNode.getChildren());\n        }\n        rootContext.createNode();\n    }\n\n    public void seekTo(State targetState) {\n        if (firstRecord.errorLocation.index == 0) {\n            state = targetState;\n        } else if (targetState == State.Reporting) {\n            state = State.SeekingToReport;\n        } else if (targetState == State.Recovering) {\n            state = State.SeekingToRecover;\n        } else {\n            throw new IllegalStateException();\n        }\n    }\n\n    public static class RecoveryRecord<V> {\n\n        public final List<MatcherPath<V>> failedMatcherPaths = new ArrayList<MatcherPath<V>>();\n        public InputLocation errorLocation;\n        public MatcherPath<V> lastMatch;\n        public InvalidInputError<V> parseError;\n        public RecoveryRecord<V> next;\n\n        public RecoveryRecord<V> getNext() {\n            if (next == null) {\n                next = new RecoveryRecord<V>();\n            }\n            return next;\n        }\n\n        public InvalidInputError<V> createParseError(Formatter<InvalidInputError<V>> invalidInputErrorFormatter) {\n            parseError = new InvalidInputError<V>(errorLocation, lastMatch, failedMatcherPaths,\n                    invalidInputErrorFormatter);\n            return parseError;\n        }\n\n        public void advanceErrorLocation(InputLocation currentLocation) {\n            if (errorLocation.index < currentLocation.index) {\n                errorLocation = currentLocation;\n            }\n        }\n    }\n\n}\n","lineNo":214}
{"Refactored Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.matchers;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.MatcherContext;\nimport org.parboiled.Rule;\n\nimport java.util.List;\n\n/**\n * A Matcher trying all of its submatchers in sequence and succeeding when the first submatcher succeeds.\n *\n * @param <V>\n */\npublic class FirstOfMatcher<V> extends AbstractMatcher<V> {\n\n    public FirstOfMatcher(@NotNull Rule[] subRules) {\n        super(subRules);\n    }\n\n    public boolean match(@NotNull MatcherContext<V> context) {\n        List<Matcher<V>> children = getChildren();\n        int size = children.size();\n        for (int i = 0; i < size; i++) {\n            Matcher<V> matcher = children.get(i);\n            if (context.getSubContext(matcher).runMatcher()) {\n                context.createNode();\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public <R> R accept(@NotNull MatcherVisitor<V, R> visitor) {\n        return visitor.visit(this);\n    }\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.matchers;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.MatcherContext;\nimport org.parboiled.Rule;\n\n/**\n * A Matcher trying all of its submatchers in sequence and succeeding when the first submatcher succeeds.\n *\n * @param <V>\n */\npublic class FirstOfMatcher<V> extends AbstractMatcher<V> {\n\n    public FirstOfMatcher(@NotNull Rule[] subRules) {\n        super(subRules);\n    }\n\n    public boolean match(@NotNull MatcherContext<V> context) {\n        for (Matcher<V> matcher : getChildren()) {\n            if (context.getSubContext(matcher).runMatcher()) {\n                context.createNode();\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public <R> R accept(@NotNull MatcherVisitor<V, R> visitor) {\n        return visitor.visit(this);\n    }\n}\n","lineNo":37}
{"Refactored Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.trees;\n\nimport java.util.List;\n\n/**\n * An ImmutableGraphNode specialization representing a tree node with a parent field linking back to the nodes\n * (only) parent.\n */\npublic class ImmutableTreeNode<T extends TreeNode<T>> extends ImmutableGraphNode<T> implements TreeNode<T> {\n\n    // we cannot make the parent field final since otherwise we can't create a tree hierarchy with parents linking to\n    // their children and vice versa. So we design this for a bottom up tree construction strategy were children\n    // are created first and then \"acquired\" by their parents\n    private T parent;\n\n    public ImmutableTreeNode() {\n    }\n\n    public ImmutableTreeNode(List<T> children) {\n        super(children);\n        acquireChildren();\n    }\n\n    public T getParent() {\n        return parent;\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    protected void acquireChildren() {\n        List<T> children = getChildren();\n        int size = children.size();\n        for (int i = 0; i < size; i++) {\n            ImmutableTreeNode node = (ImmutableTreeNode) children.get(i);\n            if (node != null) node.parent = this;\n        }\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.trees;\n\nimport java.util.List;\n\n/**\n * An ImmutableGraphNode specialization representing a tree node with a parent field linking back to the nodes\n * (only) parent.\n */\npublic class ImmutableTreeNode<T extends TreeNode<T>> extends ImmutableGraphNode<T> implements TreeNode<T> {\n\n    // we cannot make the parent field final since otherwise we can't create a tree hierarchy with parents linking to\n    // their children and vice versa. So we design this for a bottom up tree construction strategy were children\n    // are created first and then \"acquired\" by their parents\n    private T parent;\n\n    public ImmutableTreeNode() {\n    }\n\n    public ImmutableTreeNode(List<T> children) {\n        super(children);\n        acquireChildren();\n    }\n\n    public T getParent() {\n        return parent;\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    protected void acquireChildren() {\n        for (T child : getChildren()) {\n            ImmutableTreeNode node = (ImmutableTreeNode) child;\n            if (node != null) node.parent = this;\n        }\n    }\n\n}\n","lineNo":46}
{"Refactored Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.common.Preconditions;\nimport static org.parboiled.common.Utils.arrayOf;\nimport org.parboiled.errorhandling.*;\nimport org.parboiled.exceptions.ParserRuntimeException;\nimport org.parboiled.matchers.*;\nimport org.parboiled.support.*;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Base class for custom parsers. Defines basic methods for rule and action parameter creation.\n *\n * @param <V> The type of the value field of the parse tree nodes created by this parser.\n */\npublic abstract class BaseParser<V> extends BaseActions<V> {\n\n    /**\n     * Runs the given parser rule against the given input string.\n     *\n     * @param rule  the rule\n     * @param input the input string\n     * @return the ParsingResult for the run\n     */\n    @SuppressWarnings({\"unchecked\"})\n    public ParsingResult<V> parse(Rule rule, @NotNull String input) {\n        return parse(rule, input, new ReportFirstParseErrorHandler<V>());\n    }\n\n    /**\n     * Runs the given parser rule against the given input string using the given ParseErrorHandler during the\n     * parsing run.\n     *\n     * @param rule              the rule\n     * @param input             the input string\n     * @param parseErrorHandler the ParseErrorHandler to use\n     * @return the ParsingResult for the run\n     */\n    @SuppressWarnings({\"unchecked\"})\n    public ParsingResult<V> parse(Rule rule, @NotNull String input, @NotNull ParseErrorHandler<V> parseErrorHandler) {\n        InputBuffer inputBuffer = new InputBuffer(input);\n        List<ParseError> parseErrors = new ArrayList<ParseError>();\n        Matcher<V> matcher = (Matcher<V>) toRule(rule);\n        MatcherContext<V> context;\n        parseErrorHandler.initialize();\n\n        boolean matched;\n        do {\n            context = new MatcherContext<V>(inputBuffer, this, parseErrors, parseErrorHandler, matcher);\n            parseErrorHandler.initializeBeforeParsingRerun(context);\n            matched = context.runMatcher();\n        } while (!matched && parseErrorHandler.isRerunRequested(context));\n\n        return new ParsingResult<V>(matched, context.getNode(), parseErrors, inputBuffer,\n                context.getCurrentLocation().row + 1);\n    }\n\n    ////////////////////////////////// RULE CREATION ///////////////////////////////////\n\n    /**\n     * Explicitly creates a rule matching the given character. Normally you can just specify the character literal\n     * directly in you rule description. However, if you don't want to go through {@link #fromCharLiteral(char)},\n     * e.g. because you redefined it, you can also use this wrapper.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param c the char to match\n     * @return a new rule\n     */\n    @Cached\n    public Rule ch(char c) {\n        return new CharMatcher(c);\n    }\n\n    /**\n     * Explicitly creates a rule matching the given character ignoring the case.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param c the char to match independently of its case\n     * @return a new rule\n     */\n    @Cached\n    public Rule charIgnoreCase(char c) {\n        return Character.isLowerCase(c) != Character.isUpperCase(c) ?\n                new CharIgnoreCaseMatcher(c) : ch(c);\n    }\n\n    /**\n     * Creates a rule matching a range of characters from cLow to cHigh (both inclusively).\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * arguments will yield the same rule instance.<\/p>\n     *\n     * @param cLow  the start char of the range (inclusively)\n     * @param cHigh the end char of the range (inclusively)\n     * @return a new rule\n     */\n    @Cached\n    public Rule charRange(char cLow, char cHigh) {\n        return cLow == cHigh ? ch(cLow) : new CharRangeMatcher(cLow, cHigh);\n    }\n\n    /**\n     * Creates a new rule that matches the first of the given characters.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param characters the characters\n     * @return a new rule\n     */\n    @Cached\n    public Rule charSet(@NotNull String characters) {\n        Preconditions.checkArgument(characters.length() > 0);\n        if (characters.length() == 1) return ch(characters.charAt(0)); // optimize one-char sets\n        return charSet(Characters.of(characters));\n    }\n\n    /**\n     * Creates a new rule that matches the first of the given characters.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param characters the characters\n     * @return a new rule\n     */\n    @Cached\n    public Rule charSet(@NotNull Characters characters) {\n        if (!characters.isSubtractive() && characters.getChars().length == 1) {\n            return ch(characters.getChars()[0]); // optimize one-char sets\n        }\n        return new CharactersMatcher<V>(characters);\n    }\n\n    /**\n     * Explicitly creates a rule matching the given string. Normally you can just specify the string literal\n     * directly in you rule description. However, if you want to not go through {@link #fromStringLiteral(String)},\n     * e.g. because you redefined it, you can also use this wrapper.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param string the string to match\n     * @return a new rule\n     */\n    @Cached\n    @Leaf\n    public Rule string(@NotNull String string) {\n        if (string.length() == 1) return ch(string.charAt(0)); // optimize one-char strings\n        Rule[] matchers = new Rule[string.length()];\n        for (int i = 0; i < string.length(); i++) {\n            matchers[i] = ch(string.charAt(i));\n        }\n        return sequence(matchers).label('\"' + string + '\"');\n    }\n\n    /**\n     * Explicitly creates a rule matching the given string in a case-independent fashion.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param string the string to match\n     * @return a new rule\n     */\n    @Cached\n    @Leaf\n    public Rule stringIgnoreCase(@NotNull String string) {\n        if (string.length() == 1) return charIgnoreCase(string.charAt(0)); // optimize one-char strings\n        Rule[] matchers = new Rule[string.length()];\n        for (int i = 0; i < string.length(); i++) {\n            matchers[i] = charIgnoreCase(string.charAt(i));\n        }\n        return sequence(matchers).label('\"' + string + '\"');\n    }\n\n    /**\n     * Creates a new rule that successively tries all of the given subrules and succeeds when the first one of\n     * its subrules matches. If all subrules fail this rule fails as well.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * arguments will yield the same rule instance.<\/p>\n     *\n     * @param rule      the first subrule\n     * @param rule2     the second subrule\n     * @param moreRules the other subrules\n     * @return a new rule\n     */\n    public Rule firstOf(Object rule, Object rule2, @NotNull Object... moreRules) {\n        return firstOf(arrayOf(rule, arrayOf(rule2, moreRules)));\n    }\n\n    /**\n     * Creates a new rule that successively tries all of the given subrules and succeeds when the first one of\n     * its subrules matches. If all subrules fail this rule fails as well.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param rules the subrules\n     * @return a new rule\n     */\n    @Cached\n    @Label\n    public Rule firstOf(@NotNull Object[] rules) {\n        return rules.length == 1 ? toRule(rules[0]) : new FirstOfMatcher(toRules(rules));\n    }\n\n    /**\n     * Creates a new rule that tries repeated matches of its subrule and succeeds if the subrule matches at least once.\n     * If the subrule does not match at least once this rule fails.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    @Cached\n    @Label\n    public Rule oneOrMore(Object rule) {\n        return new OneOrMoreMatcher(toRule(rule));\n    }\n\n    /**\n     * Creates a new rule that tries a match on its subrule and always succeeds, independently of the matching\n     * success of its subrule.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    @Cached\n    @Label\n    public Rule optional(Object rule) {\n        return new OptionalMatcher(toRule(rule));\n    }\n\n    /**\n     * Creates a new rule that only succeeds if all of its subrule succeed, one after the other.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * arguments will yield the same rule instance.<\/p>\n     *\n     * @param rule      the first subrule\n     * @param rule2     the second subrule\n     * @param moreRules the other subrules\n     * @return a new rule\n     */\n    public Rule sequence(Object rule, Object rule2, @NotNull Object... moreRules) {\n        return sequence(arrayOf(rule, arrayOf(rule2, moreRules)));\n    }\n\n    /**\n     * Creates a new rule that only succeeds if all of its subrule succeed, one after the other.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * arguments will yield the same rule instance.<\/p>\n     *\n     * @param rules the sub rules\n     * @return a new rule\n     */\n    @Cached\n    @Label\n    public Rule sequence(@NotNull Object[] rules) {\n        return rules.length == 1 ? toRule(rules[0]) : new SequenceMatcher(toRules(rules));\n    }\n\n    /**\n     * Creates a new rule that acts as a syntactic predicate, i.e. tests the given subrule against the current\n     * input position without actually matching any characters. Succeeds if the subrule succeeds and fails if the\n     * subrule rails. Since this rule does not actually consume any input it will never create a parse tree node.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    @Cached\n    public Rule test(Object rule) {\n        return new TestMatcher(toRule(rule));\n    }\n\n    /**\n     * Creates a new rule that acts as an inverse syntactic predicate, i.e. tests the given subrule against the current\n     * input position without actually matching any characters. Succeeds if the subrule fails and fails if the\n     * subrule succeeds. Since this rule does not actually consume any input it will never create a parse tree node.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    @Cached\n    public Rule testNot(Object rule) {\n        return new TestNotMatcher(toRule(rule));\n    }\n\n    /**\n     * Creates a new rule that tries repeated matches of its subrule.\n     * Succeeds always, even if the subrule doesn't match even once.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    @Cached\n    public Rule zeroOrMore(Object rule) {\n        return new ZeroOrMoreMatcher(toRule(rule)).label(\"zeroOrMore\");\n    }\n\n    /**\n     * Matches the EOI (end of input) character.\n     *\n     * @return a new rule\n     */\n    @KeepAsIs\n    public Rule eoi() {\n        return ch(Parboiled.EOI).label(\"EOI\");\n    }\n\n    /**\n     * Matches any character except {@link org.parboiled.Parboiled#EOI}.\n     *\n     * @return a new rule\n     */\n    public Rule any() {\n        return new CharactersMatcher<V>(Characters.allBut(Parboiled.EOI)).label(\"ANY\");\n    }\n\n    /**\n     * Matches nothing and therefore always succeeds.\n     *\n     * @return a new rule\n     */\n    public Rule empty() {\n        return new EmptyMatcher<V>();\n    }\n\n    ///************************* \"MAGIC\" METHODS ***************************///\n\n    /**\n     * Changes the context scope of all arguments to the current parent scope.\n     *\n     * @param argument the arguments to change to context for\n     * @return the result of the argument\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public final <T> T UP(T argument) {\n        throw new UnsupportedOperationException(\"UP(...) calls can only be used in rule defining parser methods\");\n    }\n\n    /**\n     * Changes the context scope of all arguments to the current sub scope. This will only work if this call is\n     * at some level wrapped with one or more {@link #UP(Object)} calls, since the default scope is always at\n     * the bottom of the context chain.\n     *\n     * @param argument the arguments to change to context for\n     * @return the result of the argument\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public final <T> T DOWN(T argument) {\n        throw new UnsupportedOperationException(\"UP(...) calls can only be used in rule defining parser methods\");\n    }\n\n    ///************************* HELPER METHODS ***************************///\n\n    /**\n     * Used internally to convert the given character literal to a parser rule.\n     * You can override this method, e.g. for specifying a sequence that automatically matches all trailing\n     * whitespace after the character.\n     *\n     * @param c the character\n     * @return the rule\n     */\n    protected Rule fromCharLiteral(char c) {\n        return ch(c);\n    }\n\n    /**\n     * Used internally to convert the given string literal to a parser rule.\n     * You can override this method, e.g. for specifying a sequence that automatically matches all trailing\n     * whitespace after the string.\n     *\n     * @param string the string\n     * @return the rule\n     */\n    protected Rule fromStringLiteral(@NotNull String string) {\n        return string(string);\n    }\n\n    /**\n     * Converts the given object array to an array of rules.\n     *\n     * @param objects the objects to convert\n     * @return the rules corresponding to the given objects\n     */\n    public Rule[] toRules(@NotNull Object... objects) {\n        Rule[] rules = new Rule[objects.length];\n        for (int i = 0; i < objects.length; i++) {\n            rules[i] = toRule(objects[i]);\n        }\n        return rules;\n    }\n\n    /**\n     * Converts the given object to a rule.\n     * This method can be overriden to enable the use of custom objects directly in rule specifications.\n     *\n     * @param obj the object to convert\n     * @return the rule corresponding to the given object\n     */\n    @SuppressWarnings({\"unchecked\"})\n    public Rule toRule(Object obj) {\n        if (obj instanceof Rule) return (Rule) obj;\n        if (obj instanceof Character) return fromCharLiteral((Character) obj);\n        if (obj instanceof String) return fromStringLiteral((String) obj);\n        if (obj instanceof Action) return new ActionMatcher<V>((Action<V>) obj);\n\n        throw new ParserRuntimeException(\"'\" + obj + \"' cannot be automatically converted to a parser Rule\");\n    }\n\n    ///************************* RECOVERY RULES ***************************///\n\n    @Label\n    public Rule skipCharRecovery(@NotNull Matcher<V> failedMatcher) {\n        return sequence(\n                any().label(Parboiled.ILLEGAL), // match one illegal character\n                failedMatcher  // retry the failed matcher\n        ).withoutNode();\n    }\n\n    @Label\n    public Rule emptyMatchRecovery(@NotNull Context<V> failedMatcherContext) {\n        return sequence(\n                // if the current char is a legal follower starter char of the failed matcher\n                test(charSet(getStarterCharsOfFollowers(failedMatcherContext))),\n\n                // we match empty\n                empty().label(failedMatcherContext.getMatcher().getLabel())\n        ).withoutNode();\n    }\n\n    @Label\n    public Rule singleCharRecovery(@NotNull Context<V> failedMatcherContext) {\n        return firstOf(\n                skipCharRecovery(failedMatcherContext.getMatcher()),\n                emptyMatchRecovery(failedMatcherContext)\n        ).withoutNode();\n    }\n\n    @Label\n    public Rule resynchronize(@NotNull final Context<V> failedMatcherContext,\n                              @NotNull final InputLocation errorLocation) {\n        // we wrap the resynchronization sequence with an optional rule in order to be able to name it properly\n        // which simplifies debugging (the optional rule does not itself create a node)\n        return optional(\n\n                // recovery rules create nodes that will become sub nodes of the failed rules parent,\n                // this sequence becomes the replacement for the failed sequence we need to resynchronize on\n                sequence(\n                        // because there might already be nodes that have been matched in the failed sequence\n                        // before the parse error occurred we need to move over these nodes to this mock sequence\n                        new NamedAction<V>(\"includeAlreadyMatchedNodes\") {\n                            public boolean run(Context<V> context) {\n                                List<Node<V>> nodes = failedMatcherContext.getSubNodes();\n                                if (nodes != null) {\n                                    ((MatcherContext<V>) context).addChildNodes(nodes);\n                                    failedMatcherContext.getSubNodes().clear();\n                                }\n                                return true;\n                            }\n                        },\n                        // gooble up all illegal input up until a legal follower\n                        zeroOrMore(\n                                sequence(\n                                        firstOf(\n                                                // if we are still before the error location we definitily gobble\n                                                new NamedAction(\"testBeforeErrorLocation\") {\n                                                    public boolean run(Context context) {\n                                                        return context.getCurrentLocation().index < errorLocation.index;\n                                                    }\n                                                },\n                                                testNot(charSet(getStarterCharsOfFollowers(failedMatcherContext)))\n                                        ),\n                                        any()\n                                )\n                        ).asLeaf().label(Parboiled.ILLEGAL)\n                ).label(failedMatcherContext.getMatcher().getLabel())\n        ).withoutNode();\n    }\n\n    private Characters getStarterCharsOfFollowers(Context<V> failedMatcherContext) {\n        StarterCharsVisitor<V> starterCharsVisitor = new StarterCharsVisitor<V>();\n        FollowMatchersVisitor<V> followMatchersVisitor = new FollowMatchersVisitor<V>();\n        MatcherContext<V> context = (MatcherContext<V>) failedMatcherContext;\n        Characters starterChars = Characters.NONE;\n        for (Matcher<V> followMatcher : followMatchersVisitor.getFollowMatchers(context)) {\n            starterChars = starterChars.add(followMatcher.accept(starterCharsVisitor));\n        }\n        return starterChars;\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.common.Preconditions;\nimport static org.parboiled.common.Utils.arrayOf;\nimport org.parboiled.errorhandling.*;\nimport org.parboiled.exceptions.ParserRuntimeException;\nimport org.parboiled.matchers.*;\nimport org.parboiled.support.*;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Base class for custom parsers. Defines basic methods for rule and action parameter creation.\n *\n * @param <V> The type of the value field of the parse tree nodes created by this parser.\n */\npublic abstract class BaseParser<V> extends BaseActions<V> {\n\n    /**\n     * Runs the given parser rule against the given input string.\n     *\n     * @param rule  the rule\n     * @param input the input string\n     * @return the ParsingResult for the run\n     */\n    @SuppressWarnings({\"unchecked\"})\n    public ParsingResult<V> parse(Rule rule, @NotNull String input) {\n        return parse(rule, input, new ReportFirstParseErrorHandler<V>());\n    }\n\n    /**\n     * Runs the given parser rule against the given input string using the given ParseErrorHandler during the\n     * parsing run.\n     *\n     * @param rule              the rule\n     * @param input             the input string\n     * @param parseErrorHandler the ParseErrorHandler to use\n     * @return the ParsingResult for the run\n     */\n    @SuppressWarnings({\"unchecked\"})\n    public ParsingResult<V> parse(Rule rule, @NotNull String input, @NotNull ParseErrorHandler<V> parseErrorHandler) {\n        InputBuffer inputBuffer = new InputBuffer(input);\n        List<ParseError> parseErrors = new ArrayList<ParseError>();\n        Matcher<V> matcher = (Matcher<V>) toRule(rule);\n        MatcherContext<V> context;\n\n        boolean matched;\n        do {\n            context = new MatcherContext<V>(inputBuffer, this, parseErrors, parseErrorHandler, matcher);\n            parseErrorHandler.beforeParsingRun(context);\n            matched = context.runMatcher();\n        } while (!matched && parseErrorHandler.isRerunRequested(context));\n\n        return new ParsingResult<V>(matched, context.getNode(), parseErrors, inputBuffer,\n                context.getCurrentLocation().row + 1);\n    }\n\n    ////////////////////////////////// RULE CREATION ///////////////////////////////////\n\n    /**\n     * Explicitly creates a rule matching the given character. Normally you can just specify the character literal\n     * directly in you rule description. However, if you don't want to go through {@link #fromCharLiteral(char)},\n     * e.g. because you redefined it, you can also use this wrapper.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param c the char to match\n     * @return a new rule\n     */\n    @Cached\n    public Rule ch(char c) {\n        return new CharMatcher(c);\n    }\n\n    /**\n     * Explicitly creates a rule matching the given character ignoring the case.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param c the char to match independently of its case\n     * @return a new rule\n     */\n    @Cached\n    public Rule charIgnoreCase(char c) {\n        return Character.isLowerCase(c) != Character.isUpperCase(c) ?\n                new CharIgnoreCaseMatcher(c) : ch(c);\n    }\n\n    /**\n     * Creates a rule matching a range of characters from cLow to cHigh (both inclusively).\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * arguments will yield the same rule instance.<\/p>\n     *\n     * @param cLow  the start char of the range (inclusively)\n     * @param cHigh the end char of the range (inclusively)\n     * @return a new rule\n     */\n    @Cached\n    public Rule charRange(char cLow, char cHigh) {\n        return cLow == cHigh ? ch(cLow) : new CharRangeMatcher(cLow, cHigh);\n    }\n\n    /**\n     * Creates a new rule that matches the first of the given characters.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param characters the characters\n     * @return a new rule\n     */\n    @Cached\n    public Rule charSet(@NotNull String characters) {\n        Preconditions.checkArgument(characters.length() > 0);\n        if (characters.length() == 1) return ch(characters.charAt(0)); // optimize one-char sets\n        return charSet(Characters.of(characters));\n    }\n\n    /**\n     * Creates a new rule that matches the first of the given characters.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param characters the characters\n     * @return a new rule\n     */\n    @Cached\n    public Rule charSet(@NotNull Characters characters) {\n        if (!characters.isSubtractive() && characters.getChars().length == 1) {\n            return ch(characters.getChars()[0]); // optimize one-char sets\n        }\n        return new CharactersMatcher<V>(characters);\n    }\n\n    /**\n     * Explicitly creates a rule matching the given string. Normally you can just specify the string literal\n     * directly in you rule description. However, if you want to not go through {@link #fromStringLiteral(String)},\n     * e.g. because you redefined it, you can also use this wrapper.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param string the string to match\n     * @return a new rule\n     */\n    @Cached\n    @Leaf\n    public Rule string(@NotNull String string) {\n        if (string.length() == 1) return ch(string.charAt(0)); // optimize one-char strings\n        Rule[] matchers = new Rule[string.length()];\n        for (int i = 0; i < string.length(); i++) {\n            matchers[i] = ch(string.charAt(i));\n        }\n        return sequence(matchers).label('\"' + string + '\"');\n    }\n\n    /**\n     * Explicitly creates a rule matching the given string in a case-independent fashion.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param string the string to match\n     * @return a new rule\n     */\n    @Cached\n    @Leaf\n    public Rule stringIgnoreCase(@NotNull String string) {\n        if (string.length() == 1) return charIgnoreCase(string.charAt(0)); // optimize one-char strings\n        Rule[] matchers = new Rule[string.length()];\n        for (int i = 0; i < string.length(); i++) {\n            matchers[i] = charIgnoreCase(string.charAt(i));\n        }\n        return sequence(matchers).label('\"' + string + '\"');\n    }\n\n    /**\n     * Creates a new rule that successively tries all of the given subrules and succeeds when the first one of\n     * its subrules matches. If all subrules fail this rule fails as well.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * arguments will yield the same rule instance.<\/p>\n     *\n     * @param rule      the first subrule\n     * @param rule2     the second subrule\n     * @param moreRules the other subrules\n     * @return a new rule\n     */\n    public Rule firstOf(Object rule, Object rule2, @NotNull Object... moreRules) {\n        return firstOf(arrayOf(rule, arrayOf(rule2, moreRules)));\n    }\n\n    /**\n     * Creates a new rule that successively tries all of the given subrules and succeeds when the first one of\n     * its subrules matches. If all subrules fail this rule fails as well.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param rules the subrules\n     * @return a new rule\n     */\n    @Cached\n    @Label\n    public Rule firstOf(@NotNull Object[] rules) {\n        return rules.length == 1 ? toRule(rules[0]) : new FirstOfMatcher(toRules(rules));\n    }\n\n    /**\n     * Creates a new rule that tries repeated matches of its subrule and succeeds if the subrule matches at least once.\n     * If the subrule does not match at least once this rule fails.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    @Cached\n    @Label\n    public Rule oneOrMore(Object rule) {\n        return new OneOrMoreMatcher(toRule(rule));\n    }\n\n    /**\n     * Creates a new rule that tries a match on its subrule and always succeeds, independently of the matching\n     * success of its subrule.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    @Cached\n    @Label\n    public Rule optional(Object rule) {\n        return new OptionalMatcher(toRule(rule));\n    }\n\n    /**\n     * Creates a new rule that only succeeds if all of its subrule succeed, one after the other.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * arguments will yield the same rule instance.<\/p>\n     *\n     * @param rule      the first subrule\n     * @param rule2     the second subrule\n     * @param moreRules the other subrules\n     * @return a new rule\n     */\n    public Rule sequence(Object rule, Object rule2, @NotNull Object... moreRules) {\n        return sequence(arrayOf(rule, arrayOf(rule2, moreRules)));\n    }\n\n    /**\n     * Creates a new rule that only succeeds if all of its subrule succeed, one after the other.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * arguments will yield the same rule instance.<\/p>\n     *\n     * @param rules the sub rules\n     * @return a new rule\n     */\n    @Cached\n    @Label\n    public Rule sequence(@NotNull Object[] rules) {\n        return rules.length == 1 ? toRule(rules[0]) : new SequenceMatcher(toRules(rules));\n    }\n\n    /**\n     * Creates a new rule that acts as a syntactic predicate, i.e. tests the given subrule against the current\n     * input position without actually matching any characters. Succeeds if the subrule succeeds and fails if the\n     * subrule rails. Since this rule does not actually consume any input it will never create a parse tree node.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    @Cached\n    public Rule test(Object rule) {\n        return new TestMatcher(toRule(rule));\n    }\n\n    /**\n     * Creates a new rule that acts as an inverse syntactic predicate, i.e. tests the given subrule against the current\n     * input position without actually matching any characters. Succeeds if the subrule fails and fails if the\n     * subrule succeeds. Since this rule does not actually consume any input it will never create a parse tree node.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    @Cached\n    public Rule testNot(Object rule) {\n        return new TestNotMatcher(toRule(rule));\n    }\n\n    /**\n     * Creates a new rule that tries repeated matches of its subrule.\n     * Succeeds always, even if the subrule doesn't match even once.\n     * <p>Note: This methods carries a {@link Cached} annotation, which means that multiple invocations with the same\n     * argument will yield the same rule instance.<\/p>\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    @Cached\n    public Rule zeroOrMore(Object rule) {\n        return new ZeroOrMoreMatcher(toRule(rule)).label(\"zeroOrMore\");\n    }\n\n    /**\n     * Matches the EOI (end of input) character.\n     *\n     * @return a new rule\n     */\n    @KeepAsIs\n    public Rule eoi() {\n        return ch(Parboiled.EOI).label(\"EOI\");\n    }\n\n    /**\n     * Matches any character except {@link org.parboiled.Parboiled#EOI}.\n     *\n     * @return a new rule\n     */\n    public Rule any() {\n        return new CharactersMatcher<V>(Characters.allBut(Parboiled.EOI)).label(\"ANY\");\n    }\n\n    /**\n     * Matches nothing and therefore always succeeds.\n     *\n     * @return a new rule\n     */\n    public Rule empty() {\n        return new EmptyMatcher<V>();\n    }\n\n    ///************************* \"MAGIC\" METHODS ***************************///\n\n    /**\n     * Changes the context scope of all arguments to the current parent scope.\n     *\n     * @param argument the arguments to change to context for\n     * @return the result of the argument\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public final <T> T UP(T argument) {\n        throw new UnsupportedOperationException(\"UP(...) calls can only be used in rule defining parser methods\");\n    }\n\n    /**\n     * Changes the context scope of all arguments to the current sub scope. This will only work if this call is\n     * at some level wrapped with one or more {@link #UP(Object)} calls, since the default scope is always at\n     * the bottom of the context chain.\n     *\n     * @param argument the arguments to change to context for\n     * @return the result of the argument\n     */\n    @SuppressWarnings({\"UnusedDeclaration\"})\n    public final <T> T DOWN(T argument) {\n        throw new UnsupportedOperationException(\"UP(...) calls can only be used in rule defining parser methods\");\n    }\n\n    ///************************* HELPER METHODS ***************************///\n\n    /**\n     * Used internally to convert the given character literal to a parser rule.\n     * You can override this method, e.g. for specifying a sequence that automatically matches all trailing\n     * whitespace after the character.\n     *\n     * @param c the character\n     * @return the rule\n     */\n    protected Rule fromCharLiteral(char c) {\n        return ch(c);\n    }\n\n    /**\n     * Used internally to convert the given string literal to a parser rule.\n     * You can override this method, e.g. for specifying a sequence that automatically matches all trailing\n     * whitespace after the string.\n     *\n     * @param string the string\n     * @return the rule\n     */\n    protected Rule fromStringLiteral(@NotNull String string) {\n        return string(string);\n    }\n\n    /**\n     * Converts the given object array to an array of rules.\n     *\n     * @param objects the objects to convert\n     * @return the rules corresponding to the given objects\n     */\n    public Rule[] toRules(@NotNull Object... objects) {\n        Rule[] rules = new Rule[objects.length];\n        for (int i = 0; i < objects.length; i++) {\n            rules[i] = toRule(objects[i]);\n        }\n        return rules;\n    }\n\n    /**\n     * Converts the given object to a rule.\n     * This method can be overriden to enable the use of custom objects directly in rule specifications.\n     *\n     * @param obj the object to convert\n     * @return the rule corresponding to the given object\n     */\n    @SuppressWarnings({\"unchecked\"})\n    public Rule toRule(Object obj) {\n        if (obj instanceof Rule) return (Rule) obj;\n        if (obj instanceof Character) return fromCharLiteral((Character) obj);\n        if (obj instanceof String) return fromStringLiteral((String) obj);\n        if (obj instanceof Action) return new ActionMatcher<V>((Action<V>) obj);\n\n        throw new ParserRuntimeException(\"'\" + obj + \"' cannot be automatically converted to a parser Rule\");\n    }\n\n    ///************************* RECOVERY RULES ***************************///\n\n    @Label\n    public Rule skipCharRecovery(@NotNull Matcher<V> failedMatcher) {\n        return sequence(\n                any().label(Parboiled.ILLEGAL), // match one illegal character\n                failedMatcher  // retry the failed matcher\n        ).withoutNode();\n    }\n\n    @Label\n    public Rule emptyMatchRecovery(@NotNull Context<V> failedMatcherContext) {\n        return sequence(\n                // if the current char is a legal follower starter char of the failed matcher\n                test(charSet(getStarterCharsOfFollowers(failedMatcherContext))),\n\n                // we match empty\n                empty().label(failedMatcherContext.getMatcher().getLabel())\n        ).withoutNode();\n    }\n\n    @Label\n    public Rule singleCharRecovery(@NotNull Context<V> failedMatcherContext) {\n        return firstOf(\n                skipCharRecovery(failedMatcherContext.getMatcher()),\n                emptyMatchRecovery(failedMatcherContext)\n        ).withoutNode();\n    }\n\n    @Label\n    public Rule resynchronize(@NotNull final Context<V> failedMatcherContext,\n                              @NotNull final InputLocation errorLocation) {\n        // we wrap the resynchronization sequence with an optional rule in order to be able to name it properly\n        // which simplifies debugging (the optional rule does not itself create a node)\n        return optional(\n\n                // recovery rules create nodes that will become sub nodes of the failed rules parent,\n                // this sequence becomes the replacement for the failed sequence we need to resynchronize on\n                sequence(\n                        // because there might already be nodes that have been matched in the failed sequence\n                        // before the parse error occurred we need to move over these nodes to this mock sequence\n                        new NamedAction<V>(\"includeAlreadyMatchedNodes\") {\n                            public boolean run(Context<V> context) {\n                                ((MatcherContext<V>) context).addChildNodes(failedMatcherContext.getSubNodes());\n                                failedMatcherContext.getSubNodes().clear();\n                                return true;\n                            }\n                        },\n                        // gooble up all illegal input up until a legal follower\n                        zeroOrMore(\n                                sequence(\n                                        firstOf(\n                                                // if we are still before the error location we definitily gobble\n                                                new NamedAction(\"testBeforeErrorLocation\") {\n                                                    public boolean run(Context context) {\n                                                        return context.getCurrentLocation().index < errorLocation.index;\n                                                    }\n                                                },\n                                                testNot(charSet(getStarterCharsOfFollowers(failedMatcherContext)))\n                                        ),\n                                        any()\n                                )\n                        ).asLeaf().label(Parboiled.ILLEGAL)\n                ).label(failedMatcherContext.getMatcher().getLabel())\n        ).withoutNode();\n    }\n\n    private Characters getStarterCharsOfFollowers(Context<V> failedMatcherContext) {\n        StarterCharsVisitor<V> starterCharsVisitor = new StarterCharsVisitor<V>();\n        FollowMatchersVisitor<V> followMatchersVisitor = new FollowMatchersVisitor<V>();\n        MatcherContext<V> context = (MatcherContext<V>) failedMatcherContext;\n        Characters starterChars = Characters.NONE;\n        for (Matcher<V> followMatcher : followMatchersVisitor.getFollowMatchers(context)) {\n            starterChars = starterChars.add(followMatcher.accept(starterCharsVisitor));\n        }\n        return starterChars;\n    }\n\n}\n","lineNo":479}
{"Refactored Sample":"/*\n * Copyright (C) 2009-2010 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.errorhandling;\n\nimport org.parboiled.matchers.*;\n\nimport java.util.List;\n\n/**\n * MatcherVisitor that expands a matcher to the list of matcher labels that correspond to all \"non-labelled\"\n * matchers the given matcher can legally start a match with.\n *\n * @param <V>\n */\npublic class ToFirstLabelVisitor<V> extends DefaultMatcherVisitor<V, Void> {\n\n    private final CanMatchEmptyVisitor<V> canMatchEmptyVisitor = new CanMatchEmptyVisitor<V>();\n    private final List<String> stringList;\n\n    public ToFirstLabelVisitor(List<String> stringList) {\n        this.stringList = stringList;\n    }\n\n    @Override\n    public Void visit(ActionMatcher<V> matcher) {\n        // don't create a label string for action matchers\n        return null;\n    }\n\n    @Override\n    public Void visit(FirstOfMatcher<V> matcher) {\n        String label = matcher.getLabel();\n        if (!\"firstOf\".equals(label) && !label.startsWith(\"{\") && !label.endsWith(\"}\")) return add(matcher);\n\n        for (Matcher<V> child : matcher.getChildren()) {\n            child.accept(this);\n        }\n        return null;\n    }\n\n    @Override\n    public Void visit(OneOrMoreMatcher<V> matcher) {\n        if (!\"oneOrMore\".equals(matcher.getLabel())) return add(matcher);\n        return matcher.subMatcher.accept(this);\n    }\n\n    @Override\n    public Void visit(OptionalMatcher<V> matcher) {\n        if (!\"optional\".equals(matcher.getLabel())) return add(matcher);\n        return matcher.subMatcher.accept(this);\n    }\n\n    @Override\n    public Void visit(SequenceMatcher<V> matcher) {\n        if (!\"sequence\".equals(matcher.getLabel()) && !\"enforcedSequence\".equals(matcher.getLabel())) {\n            return add(matcher);\n        }\n        for (Matcher<V> child : matcher.getChildren()) {\n            child.accept(this);\n            if (!child.accept(canMatchEmptyVisitor)) break;\n        }\n        return null;\n    }\n\n    @Override\n    public Void visit(TestMatcher<V> matcher) {\n        if (!\"test\".equals(matcher.getLabel())) return add(matcher);\n        return matcher.subMatcher.accept(this);\n    }\n\n    @Override\n    public Void visit(TestNotMatcher<V> matcher) {\n        if (!\"testNot\".equals(matcher.getLabel())) return add(matcher);\n        int oldLen = stringList.size();\n        matcher.subMatcher.accept(this);\n        for (int i = oldLen; i < stringList.size(); i++) {\n            String string = stringList.get(i);\n            if (!string.startsWith(\"no \")) stringList.set(i, \"no \" + string);\n        }\n        return null;\n    }\n\n    @Override\n    public Void visit(ZeroOrMoreMatcher<V> matcher) {\n        if (!\"zeroOrMore\".equals(matcher.getLabel())) return add(matcher);\n        return matcher.subMatcher.accept(this);\n    }\n\n    @Override\n    public Void defaultValue(AbstractMatcher<V> matcher) {\n        return add(matcher);\n    }\n\n    private Void add(Matcher<V> matcher) {\n        String label = matcher.getLabel();\n        if (!stringList.contains(label)) {\n            // we don't use a set here since we need indexed access and will never have many list entries\n            stringList.add(label);\n        }\n        return null;\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009-2010 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.errorhandling;\n\nimport org.parboiled.matchers.*;\n\nimport java.util.List;\n\n/**\n * MatcherVisitor that expands a matcher to the list of matcher labels that correspond to all \"non-labelled\"\n * matchers the given matcher can legally start a match with.\n *\n * @param <V>\n */\npublic class ToFirstLabelVisitor<V> extends DefaultMatcherVisitor<V, Void> {\n\n    private final CanMatchEmptyVisitor<V> canMatchEmptyVisitor = new CanMatchEmptyVisitor<V>();\n    private final List<String> stringList;\n\n    public ToFirstLabelVisitor(List<String> stringList) {\n        this.stringList = stringList;\n    }\n\n    @Override\n    public Void visit(ActionMatcher<V> matcher) {\n        // don't create a label string for action matchers\n        return null;\n    }\n\n    @Override\n    public Void visit(FirstOfMatcher<V> matcher) {\n        String label = matcher.getLabel();\n        if (!\"firstOf\".equals(label) && !label.startsWith(\"{\") && !label.endsWith(\"}\")) return add(matcher);\n\n        for (Matcher<V> child : matcher.getChildren()) {\n            child.accept(this);\n        }\n        return null;\n    }\n\n    @Override\n    public Void visit(OneOrMoreMatcher<V> matcher) {\n        if (!\"oneOrMore\".equals(matcher.getLabel())) return add(matcher);\n        return matcher.subMatcher.accept(this);\n    }\n\n    @Override\n    public Void visit(OptionalMatcher<V> matcher) {\n        if (!\"optional\".equals(matcher.getLabel())) return add(matcher);\n        return matcher.subMatcher.accept(this);\n    }\n\n    @Override\n    public Void visit(SequenceMatcher<V> matcher) {\n        if (!\"sequence\".equals(matcher.getLabel()) && !\"enforcedSequence\".equals(matcher.getLabel())) {\n            return add(matcher);\n        }\n        for (Matcher<V> child : matcher.getChildren()) {\n            child.accept(this);\n            if (!child.accept(canMatchEmptyVisitor)) break;\n        }\n        return null;\n    }\n\n    @Override\n    public Void visit(TestMatcher<V> matcher) {\n        if (!\"test\".equals(matcher.getLabel())) return add(matcher);\n        return matcher.subMatcher.accept(this);\n    }\n\n    @Override\n    public Void visit(TestNotMatcher<V> matcher) {\n        if (!\"testNot\".equals(matcher.getLabel())) return add(matcher);\n        int oldLen = stringList.size();\n        matcher.subMatcher.accept(this);\n        for (int i = oldLen; i < stringList.size(); i++) {\n            String string = stringList.get(i);\n            if (!string.startsWith(\"no \")) stringList.set(i, \"no \" + string);\n        }\n        return null;\n    }\n\n    @Override\n    public Void visit(ZeroOrMoreMatcher<V> matcher) {\n        if (!\"zeroOrMore\".equals(matcher.getLabel())) return add(matcher);\n        return matcher.subMatcher.accept(this);\n    }\n\n    @Override\n    public Void defaultValue(AbstractMatcher<V> matcher) {\n        return add(matcher);\n    }\n\n    private Void add(Matcher<V> matcher) {\n        stringList.add(matcher.getLabel());\n        return null;\n    }\n\n}\n","lineNo":109}
{"Refactored Sample":"/*\n * Copyright (C) 2009-2010 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.asm;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.objectweb.asm.Opcodes;\nimport org.objectweb.asm.tree.*;\nimport org.parboiled.common.Preconditions;\nimport org.parboiled.common.StringUtils;\nimport static org.parboiled.common.Utils.merge;\n\nclass LabelApplicator implements ClassTransformer, Opcodes, Types {\n\n    private final ClassTransformer nextTransformer;\n\n    public LabelApplicator(ClassTransformer nextTransformer) {\n        this.nextTransformer = nextTransformer;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public ParserClassNode transform(@NotNull ParserClassNode classNode) throws Exception {\n        for (ParserMethod method : merge(classNode.ruleMethods, classNode.labelMethods)) {\n            createLabellingCode(method);\n        }\n\n        return nextTransformer != null ? nextTransformer.transform(classNode) : classNode;\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    private void createLabellingCode(ParserMethod method) {\n        InsnList instructions = method.instructions;\n        AbstractInsnNode current = instructions.getFirst();\n\n        while (current.getOpcode() != ARETURN) {\n            current = current.getNext();\n        }\n\n        // stack: <rule>\n        instructions.insertBefore(current, new LdcInsnNode(getLabelText(method)));\n        // stack: <rule> :: <labelText>\n        instructions.insertBefore(current, new MethodInsnNode(INVOKEINTERFACE, RULE_TYPE.getInternalName(),\n                \"label\", \"(Ljava/lang/String;)\" + RULE_TYPE.getDescriptor()));\n        // stack: <rule>\n    }\n\n    public String getLabelText(ParserMethod method) {\n        if (method.visibleAnnotations != null) {\n            for (Object annotationObj : method.visibleAnnotations) {\n                AnnotationNode annotation = (AnnotationNode) annotationObj;\n                if (annotation.desc.equals(LABEL_TYPE.getDescriptor()) && annotation.values != null) {\n                    Preconditions.checkState(\"value\".equals(annotation.values.get(0)));\n                    String labelValue = (String) annotation.values.get(1);\n                    return StringUtils.isEmpty(labelValue) ? method.name : labelValue;\n                }\n            }\n        }\n        return method.name;\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009-2010 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.asm;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.objectweb.asm.Opcodes;\nimport org.objectweb.asm.tree.*;\nimport org.parboiled.common.Preconditions;\nimport static org.parboiled.common.Utils.merge;\n\nclass LabelApplicator implements ClassTransformer, Opcodes, Types {\n\n    private final ClassTransformer nextTransformer;\n\n    public LabelApplicator(ClassTransformer nextTransformer) {\n        this.nextTransformer = nextTransformer;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public ParserClassNode transform(@NotNull ParserClassNode classNode) throws Exception {\n        for (ParserMethod method : merge(classNode.ruleMethods, classNode.labelMethods)) {\n            createLabellingCode(method);\n        }\n\n        return nextTransformer != null ? nextTransformer.transform(classNode) : classNode;\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    private void createLabellingCode(ParserMethod method) {\n        InsnList instructions = method.instructions;\n        AbstractInsnNode current = instructions.getFirst();\n\n        while (current.getOpcode() != ARETURN) {\n            current = current.getNext();\n        }\n\n        // stack: <rule>\n        instructions.insertBefore(current, new LdcInsnNode(getLabelText(method)));\n        // stack: <rule> :: <labelText>\n        instructions.insertBefore(current, new MethodInsnNode(INVOKEINTERFACE, RULE_TYPE.getInternalName(),\n                \"label\", \"(Ljava/lang/String;)\" + RULE_TYPE.getDescriptor()));\n        // stack: <rule>\n    }\n\n    public String getLabelText(ParserMethod method) {\n        if (method.visibleAnnotations != null) {\n            for (Object annotationObj : method.visibleAnnotations) {\n                AnnotationNode annotation = (AnnotationNode) annotationObj;\n                if (annotation.desc.equals(LABEL_TYPE.getDescriptor()) && annotation.values != null) {\n                    Preconditions.checkState(\"value\".equals(annotation.values.get(0)));\n                    return (String) annotation.values.get(1);\n                }\n            }\n        }\n        return method.name;\n    }\n\n}\n","lineNo":66}
{"Refactored Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.common.ImmutableList;\nimport org.parboiled.common.Preconditions;\nimport org.parboiled.exceptions.ActionException;\nimport org.parboiled.exceptions.ParserRuntimeException;\nimport org.parboiled.matchers.*;\nimport org.parboiled.support.*;\nimport static org.parboiled.support.ParseTreeUtils.*;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * <p>The Context implementation orchestrating most of the matching process.<\/p>\n * <p>The parsing process works as following:<\/br>\n * After the rule tree (which is in fact a directed and potentially even cyclic graph of Matcher instances) has been\n * created a root MatcherContext is instantiated for the root rule (Matcher).\n * A subsequent call to {@link #runMatcher()} starts the parsing process.<\/p>\n * <p>The MatcherContext essentially calls {@link Matcher#match(MatcherContext)} passing itself to the Matcher\n * which executes its logic, potentially calling sub matchers. For each sub matcher the matcher calls\n * {@link #runMatcher()} on its Context, which creates a sub context of the\n * current MatcherContext and runs the given sub matcher in it.<\/p>\n * <p>This basically creates a stack of MatcherContexts, each corresponding to their rule matchers. The MatcherContext\n * instances serve as a kind of companion objects to the matchers, providing them with support for building the\n * parse tree nodes, keeping track of input locations and error recovery.<\/p>\n * <p>At each point during the parsing process the matchers and action expressions have access to the current\n * MatcherContext and all \"open\" parent MatcherContexts through the {@link #getParent()} chain.<\/p>\n *\n * @param <V> the node value type\n */\npublic class MatcherContext<V> implements Context<V> {\n\n    public static class Globals<V> {\n        public final List<ParseError<V>> parseErrors = new ArrayList<ParseError<V>>();\n        public Node<V> lastNode;\n        public ParseErrorMarker<V> currentErrorMarker;\n        public ParsingState parsingState = ParsingState.Parsing;\n    }\n\n    // also global but kept in each MatcherContext instance for faster access\n    private final InputBuffer inputBuffer;\n    private final Globals<V> globals;\n    private final int level;\n\n    private MatcherContext<V> parent;\n    private MatcherContext<V> subContext;\n    private InputLocation startLocation;\n    private InputLocation currentLocation;\n    private Matcher<V> matcher;\n    private Node<V> node;\n    private List<Node<V>> subNodes;\n    private V nodeValue;\n    private int intTag;\n    private boolean belowLeafLevel;\n    private boolean recoveryCandidate;\n\n    public MatcherContext(@NotNull InputBuffer inputBuffer, @NotNull InputLocation startLocation,\n                          @NotNull Globals<V> globals, Matcher<V> matcher) {\n        this(inputBuffer, globals, 0);\n        setStartLocation(startLocation);\n        this.matcher = matcher;\n    }\n\n    private MatcherContext(InputBuffer inputBuffer, Globals<V> globals, int level) {\n        this.inputBuffer = inputBuffer;\n        this.globals = globals;\n        this.level = level;\n    }\n\n    @Override\n    public String toString() {\n        return getPath().toString();\n    }\n\n    //////////////////////////////// CONTEXT INTERFACE ////////////////////////////////////\n\n    public MatcherContext<V> getParent() {\n        return parent;\n    }\n\n    public MatcherContext<V> getSubContext() {\n        return subContext != null && subContext.matcher != null ? subContext : null;\n    }\n\n    @NotNull\n    public InputBuffer getInputBuffer() {\n        return inputBuffer;\n    }\n\n    public InputLocation getStartLocation() {\n        return startLocation;\n    }\n\n    public Matcher<V> getMatcher() {\n        return matcher;\n    }\n\n    @NotNull\n    public List<ParseError<V>> getParseErrors() {\n        return globals.parseErrors;\n    }\n\n    public void addParseError(@NotNull ParseError<V> error) {\n        globals.parseErrors.add(error);\n    }\n\n    public InputLocation getCurrentLocation() {\n        return currentLocation;\n    }\n\n    public String getNodeText(Node<?> node) {\n        return ParseTreeUtils.getNodeText(node, inputBuffer);\n    }\n\n    public Character getNodeChar(Node<?> node) {\n        return ParseTreeUtils.getNodeChar(node, inputBuffer);\n    }\n\n    @NotNull\n    public MatcherPath<V> getPath() {\n        return new MatcherPath<V>(this);\n    }\n\n    public int getLevel() {\n        return level;\n    }\n\n    public V getNodeValue() {\n        return nodeValue;\n    }\n\n    public void setNodeValue(V value) {\n        this.nodeValue = value;\n    }\n\n    public V getTreeValue() {\n        V treeValue = nodeValue;\n        if (subNodes != null) {\n            int i = subNodes.size();\n            while (treeValue == null && i-- > 0) {\n                treeValue = subNodes.get(i).getValue();\n            }\n        }\n        return treeValue;\n    }\n\n    public Node<V> getNodeByPath(String path) {\n        return findNodeByPath(subNodes, path);\n    }\n\n    public Node<V> getNodeByLabel(String labelPrefix) {\n        return subNodes != null ? findNode(subNodes, new LabelPrefixPredicate<V>(labelPrefix)) : null;\n    }\n\n    public Node<V> getLastNode() {\n        return globals.lastNode;\n    }\n\n    public List<Node<V>> getSubNodes() {\n        return subNodes != null ? ImmutableList.copyOf(subNodes) : ImmutableList.<Node<V>>of();\n    }\n\n    public boolean inPredicate() {\n        return matcher instanceof TestMatcher || parent != null && parent.inPredicate();\n    }\n\n    public ParsingState getParsingState() {\n        return globals.parsingState;\n    }\n\n    public boolean isBelowLeafLevel() {\n        return belowLeafLevel;\n    }\n\n    public InputLocation getCurrentParseErrorLocation() {\n        return globals.currentErrorMarker.getLocation();\n    }\n\n    public MatcherPath<V> getCurrentParseErrorPath() {\n        return globals.currentErrorMarker.getPath();\n    }\n\n    public Context<V> getCurrentRecoveryContext() {\n        MatcherContext<V> context = this;\n        while (context != null) {\n            if (context.recoveryCandidate) return context;\n            context = context.getParent();\n        }\n        return null;\n    }\n\n    public Matcher<V> getFailedMatcher() {\n        if (recoveryCandidate) {\n            Matcher<V>[] errorMatchers = getCurrentParseErrorPath().getMatchers();\n            Preconditions.checkState(errorMatchers[level] == this);\n            if (level + 1 < errorMatchers.length) return errorMatchers[level + 1];\n        }\n        return null;\n    }\n\n    public void injectVirtualInput(char virtualInputChar) {\n        currentLocation = currentLocation.insertVirtualInput(virtualInputChar);\n    }\n\n    public void injectVirtualInput(String virtualInputText) {\n        currentLocation = currentLocation.insertVirtualInput(virtualInputText);\n    }\n\n    //////////////////////////////// PUBLIC ////////////////////////////////////\n\n    public void setCurrentLocation(InputLocation currentLocation) {\n        this.currentLocation = currentLocation;\n    }\n\n    public void advanceInputLocation() {\n        setCurrentLocation(currentLocation.advance(inputBuffer));\n    }\n\n    public Node<V> getNode() {\n        return node;\n    }\n\n    public int getIntTag() {\n        return intTag;\n    }\n\n    public void setIntTag(int intTag) {\n        this.intTag = intTag;\n    }\n\n    public void createNode() {\n        if (belowLeafLevel) {\n            return;\n        }\n        node = new NodeImpl<V>(matcher.getLabel(), subNodes, startLocation, currentLocation, getTreeValue());\n        if (!(matcher instanceof TestMatcher)) { // special case: TestMatchers do not add nodes\n            if (parent != null) {\n                parent.addChildNode(node);\n            }\n            globals.lastNode = node;\n        }\n    }\n\n    public MatcherContext<V> getSubContext(Matcher<V> matcher) {\n        if (subContext == null) {\n            // we need to introduce a new level\n            subContext = new MatcherContext<V>(inputBuffer, globals, level + 1);\n            subContext.parent = this;\n        }\n\n        // normally we just reuse the existing subContext instance\n        subContext.matcher = ProxyMatcher.unwrap(matcher);\n        subContext.setStartLocation(currentLocation);\n        subContext.node = null;\n        subContext.subNodes = null;\n        subContext.nodeValue = null;\n        subContext.belowLeafLevel = belowLeafLevel || this.matcher.isLeaf();\n        subContext.recoveryCandidate = false;\n        return subContext;\n    }\n\n    /**\n     * Runs the contexts matcher.\n     *\n     * @return true if matched\n     */\n    @SuppressWarnings({\"unchecked\", \"fallthrough\"})\n    public boolean runMatcher() {\n        boolean matched = false;\n        try {\n            matched = matcher.match(this);\n            if (!matched) {\n                switch (globals.parsingState) {\n                    case Parsing:\n                        globals.currentErrorMarker.mark(this);\n                        break;\n\n                    case SeekingToParseError:\n                        if (!globals.currentErrorMarker.matchesState(this)) break;\n\n                        // we just failed the matcher causing the previously recorded parse error\n                        // so mark all contexts in the current stack as potential recovery candidates\n                        MatcherContext<V> context = this;\n                        while (context != null) {\n                            context.recoveryCandidate = true;\n                            context = context.getParent();\n                        }\n                        globals.parsingState = ParsingState.Recovering;\n                        // fall-through\n\n                    case Recovering:\n                        if (recoveryCandidate) {\n                            Matcher<V> recoveryRule = (Matcher<V>) matcher.getRecoveryRule();\n                            if (recoveryRule != null) {\n                                if (getSubContext(recoveryRule).runMatcher()) {\n                                    globals.currentErrorMarker = globals.currentErrorMarker.getNext();\n                                    globals.parsingState = globals.currentErrorMarker.isValid() ?\n                                            ParsingState.SeekingToParseError : ParsingState.Parsing;\n                                    matched = true;\n                                }\n                            }\n                        }\n                        break;\n                }\n            }\n\n        } catch (ActionException e) {\n            addParseError(new ParseError<V>(currentLocation, getPath(), e.getMessage()));\n        } catch (ParserRuntimeException e) {\n            throw e; // don't wrap, just bubble up\n\n        } catch (Throwable e) {\n            throw new ParserRuntimeException(e,\n                    printParseError(new ParseError<V>(currentLocation, getPath(),\n                            String.format(\"Error during execution of parsing %s '%s' at input position\",\n                                    matcher instanceof ActionMatcher ? \"action\" : \"rule\", getPath())), inputBuffer));\n        }\n\n        if (matched && parent != null) {\n            parent.setCurrentLocation(currentLocation);\n        }\n        matcher = null; // \"retire\" this context until is \"activated\" again by a getSubContext(...) on the parent\n        return matched;\n    }\n\n    //////////////////////////////// PRIVATE ////////////////////////////////////\n\n    private void setStartLocation(InputLocation location) {\n        startLocation = currentLocation = location;\n    }\n\n    private void addChildNode(Node<V> node) {\n        if (subNodes == null) subNodes = new ArrayList<Node<V>>();\n        subNodes.add(node);\n    }\n\n    private void recover() throws Throwable {\n        if (trySingleSymbolDeletion()) return;\n\n        Characters followerChars = getFollowerChars();\n        if (trySingleSymbolInsertion(followerChars)) return;\n        resynchronize(followerChars);\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    private Characters getFollowerChars() {\n        Characters chars = Characters.NONE;\n        MatcherContext<V> parent = this.parent;\n        while (parent != null) {\n            if (parent.getMatcher() instanceof FollowMatcher) {\n                FollowMatcher<V> followMatcher = (FollowMatcher<V>) parent.getMatcher();\n                chars = chars.add(followMatcher.getFollowerChars(parent));\n                if (!chars.contains(Chars.EMPTY)) return chars;\n            }\n            parent = parent.parent;\n        }\n        return chars.remove(Chars.EMPTY).add(Chars.EOI);\n    }\n\n    // check whether the current char is a junk char that we can simply discard to continue with the next char\n    private boolean trySingleSymbolDeletion() throws Throwable {\n        Characters starterChars = matcher.getStarterChars();\n        Preconditions.checkState(!starterChars.contains(Chars.EMPTY));\n        InputLocation locationBeforeError = currentLocation;\n        char lookAheadOne = locationBeforeError.lookAhead(inputBuffer, 1);\n        if (!starterChars.contains(lookAheadOne)) {\n            return false;\n        }\n\n        // success, we have to skip only one char in order to be able to start the match\n        // match the illegal char and create a node for it\n        advanceInputLocation();\n        (parent != null ? parent : this).addChildNode(\n                new NodeImpl<V>(\"ILLEGAL\", null, locationBeforeError, currentLocation, null)\n        );\n\n        startLocation = currentLocation;\n        // retry the original match\n        return matcher.match(this);\n    }\n\n    // check whether the current char is a legally following next char in the follower set\n    // if so, just virtually \"insert\" the missing expected character and continue\n    private boolean trySingleSymbolInsertion(Characters followerChars) {\n        char currentChar = currentLocation.currentChar;\n        if (!followerChars.contains(currentChar)) return false;\n\n        // success, the current mismatching character is a legal follower,\n        // so add a ParseError and still \"match\" (empty)\n        createNode();\n        return true;\n    }\n\n    // consume all characters until we see a legal follower\n    private void resynchronize(Characters followerChars) {\n        createNode(); // create an empty match node\n\n        InputLocation locationBeforeError = currentLocation;\n\n        // consume all illegal characters up until a char that we can continue parsing with\n        do {\n            advanceInputLocation();\n        } while (!followerChars.contains(currentLocation.currentChar) && currentLocation.currentChar != Chars.EOI);\n\n        (parent != null ? parent : this).addChildNode(\n                new NodeImpl<V>(\"ILLEGAL\", null, locationBeforeError, currentLocation, null)\n        );\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.common.ImmutableList;\nimport org.parboiled.common.Preconditions;\nimport org.parboiled.exceptions.ActionException;\nimport org.parboiled.exceptions.ParserRuntimeException;\nimport org.parboiled.matchers.*;\nimport org.parboiled.support.*;\nimport static org.parboiled.support.ParseTreeUtils.*;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * <p>The Context implementation orchestrating most of the matching process.<\/p>\n * <p>The parsing process works as following:<\/br>\n * After the rule tree (which is in fact a directed and potentially even cyclic graph of Matcher instances) has been\n * created a root MatcherContext is instantiated for the root rule (Matcher).\n * A subsequent call to {@link #runMatcher()} starts the parsing process.<\/p>\n * <p>The MatcherContext essentially calls {@link Matcher#match(MatcherContext)} passing itself to the Matcher\n * which executes its logic, potentially calling sub matchers. For each sub matcher the matcher calls\n * {@link #runMatcher()} on its Context, which creates a sub context of the\n * current MatcherContext and runs the given sub matcher in it.<\/p>\n * <p>This basically creates a stack of MatcherContexts, each corresponding to their rule matchers. The MatcherContext\n * instances serve as a kind of companion objects to the matchers, providing them with support for building the\n * parse tree nodes, keeping track of input locations and error recovery.<\/p>\n * <p>At each point during the parsing process the matchers and action expressions have access to the current\n * MatcherContext and all \"open\" parent MatcherContexts through the {@link #getParent()} chain.<\/p>\n *\n * @param <V> the node value type\n */\npublic class MatcherContext<V> implements Context<V> {\n\n    public static class Globals<V> {\n        public final List<ParseError<V>> parseErrors = new ArrayList<ParseError<V>>();\n        public Node<V> lastNode;\n        public ParseErrorMarker<V> currentErrorMarker;\n        public boolean replayToParseError;\n    }\n\n    // also global but kept in each MatcherContext instance for faster access\n    private final InputBuffer inputBuffer;\n    private final Globals<V> globals;\n\n    private MatcherContext<V> parent;\n    private MatcherContext<V> subContext;\n    private InputLocation startLocation;\n    private InputLocation currentLocation;\n    private Matcher<V> matcher;\n    private Node<V> node;\n    private List<Node<V>> subNodes;\n    private V nodeValue;\n    private int intTag;\n    private boolean belowLeafLevel;\n    private boolean enforced;\n\n    public MatcherContext(@NotNull InputBuffer inputBuffer, @NotNull InputLocation startLocation,\n                          @NotNull Globals<V> globals, Matcher<V> matcher) {\n        this(inputBuffer, globals);\n        setStartLocation(startLocation);\n        this.matcher = matcher;\n    }\n\n    private MatcherContext(InputBuffer inputBuffer, Globals<V> globals) {\n        this.inputBuffer = inputBuffer;\n        this.globals = globals;\n    }\n\n    @Override\n    public String toString() {\n        return getPath();\n    }\n\n    //////////////////////////////// CONTEXT INTERFACE ////////////////////////////////////\n\n    public MatcherContext<V> getParent() {\n        return parent;\n    }\n\n    public MatcherContext<V> getSubContext() {\n        return subContext != null && subContext.matcher != null ? subContext : null;\n    }\n\n    public InputBuffer getInputBuffer() {\n        return inputBuffer;\n    }\n\n    public InputLocation getStartLocation() {\n        return startLocation;\n    }\n\n    public Matcher<V> getMatcher() {\n        return matcher;\n    }\n\n    @NotNull\n    public List<ParseError<V>> getParseErrors() {\n        return globals.parseErrors;\n    }\n\n    public InputLocation getCurrentLocation() {\n        return currentLocation;\n    }\n\n    public String getNodeText(Node<?> node) {\n        return ParseTreeUtils.getNodeText(node, inputBuffer);\n    }\n\n    public Character getNodeChar(Node<?> node) {\n        return ParseTreeUtils.getNodeChar(node, inputBuffer);\n    }\n\n    @NotNull\n    public String getPath() {\n        return (parent == null ? \"\" : parent.getPath()) + '/' + (matcher == null ? \"?\" : matcher.getLabel());\n    }\n\n    public V getNodeValue() {\n        return nodeValue;\n    }\n\n    public void setNodeValue(V value) {\n        this.nodeValue = value;\n    }\n\n    public V getTreeValue() {\n        V treeValue = nodeValue;\n        if (subNodes != null) {\n            int i = subNodes.size();\n            while (treeValue == null && i-- > 0) {\n                treeValue = subNodes.get(i).getValue();\n            }\n        }\n        return treeValue;\n    }\n\n    public Node<V> getNodeByPath(String path) {\n        return findNodeByPath(subNodes, path);\n    }\n\n    public Node<V> getNodeByLabel(String labelPrefix) {\n        return subNodes != null ? findNode(subNodes, new LabelPrefixPredicate<V>(labelPrefix)) : null;\n    }\n\n    public Node<V> getLastNode() {\n        return globals.lastNode;\n    }\n\n    public List<Node<V>> getSubNodes() {\n        return subNodes != null ? ImmutableList.copyOf(subNodes) : ImmutableList.<Node<V>>of();\n    }\n\n    public boolean inPredicate() {\n        return matcher instanceof TestMatcher || parent != null && parent.inPredicate();\n    }\n\n    //////////////////////////////// PUBLIC ////////////////////////////////////\n\n    public void setCurrentLocation(InputLocation currentLocation) {\n        this.currentLocation = currentLocation;\n    }\n\n    public void advanceInputLocation() {\n        setCurrentLocation(currentLocation.advance(inputBuffer));\n    }\n\n    public Node<V> getNode() {\n        return node;\n    }\n\n    public Object getIntTag() {\n        return intTag;\n    }\n\n    public void setIntTag(int intTag) {\n        this.intTag = intTag;\n    }\n\n    public void createNode() {\n        if (belowLeafLevel) {\n            return;\n        }\n        node = new NodeImpl<V>(matcher.getLabel(), subNodes, startLocation, currentLocation, getTreeValue());\n        if (!(matcher instanceof TestMatcher)) { // special case: TestMatchers do not add nodes\n            if (parent != null) {\n                parent.addChildNode(node);\n            }\n            globals.lastNode = node;\n        }\n    }\n\n    public MatcherContext<V> getSubContext(Matcher<V> matcher) {\n        if (subContext == null) {\n            // we need to introduce a new level\n            subContext = new MatcherContext<V>(inputBuffer, globals);\n            subContext.parent = this;\n        }\n\n        // normally we just reuse the existing subContext instance\n        subContext.matcher = ProxyMatcher.unwrap(matcher);\n        subContext.setStartLocation(currentLocation);\n        subContext.node = null;\n        subContext.subNodes = null;\n        subContext.nodeValue = null;\n        subContext.belowLeafLevel = belowLeafLevel || this.matcher.isLeaf();\n        subContext.enforced = enforced;\n        return subContext;\n    }\n\n    /**\n     * Runs the contexts matcher.\n     *\n     * @return true if matched\n     */\n    public boolean runMatcher() {\n        try {\n            if (matcher.match(this)) {\n                if (parent != null) parent.setCurrentLocation(currentLocation);\n                matcher = null; // \"retire\" this context until is \"activated\" again by a getSubContext(...) on the parent\n                return true;\n            }\n\n            if (enforced) {\n                recover();\n                if (parent != null) parent.setCurrentLocation(currentLocation);\n                matcher = null; // \"retire\" this context until is \"activated\" again by a getSubContext(...) on the parent\n                return true;\n            }\n\n        } catch (ActionException e) {\n            globals.parseErrors.add(new ParseError<V>(currentLocation, new MatcherPath<V>(this), e.getMessage()));\n        } catch (ParserRuntimeException e) {\n            throw e; // don't wrap, just bubble up\n\n        } catch (Throwable e) {\n            throw new ParserRuntimeException(e,\n                    printParseError(new ParseError<V>(currentLocation, new MatcherPath<V>(this),\n                            String.format(\"Error during execution of parsing %s '%s' at input position\",\n                                    matcher instanceof ActionMatcher ? \"action\" : \"rule\", getPath())), inputBuffer));\n        }\n\n        matcher = null; // \"retire\" this context until is \"activated\" again by a getSubContext(...) on the parent\n        return false;\n    }\n\n    public void enforceMatch() {\n        enforced = true;\n        runMatcher();\n        enforced = false;\n    }\n\n    public void clearEnforcement() {\n        enforced = false;\n    }\n\n    // if the parser does not find another \"solution\" to the given input sometime later during the parsing process\n    // we might have a parse error\n    // so, we record the relevant parse error data right now, if\n    // - we have already matched some input in this sequence\n    // - no other recorded in-sequence-mismatch already happened further into the input\n    public boolean recoverFromInSequenceMismatch(Matcher<V> matcher) {\n        if (!enforced) {\n            if (globals.replayToParseError) {\n                if (globals.currentErrorMarker.matchesState(this, matcher)) {\n                    globals.currentErrorMarker = globals.currentErrorMarker.getNext();\n                    globals.replayToParseError = globals.currentErrorMarker.isValid();\n                    return true;\n                }\n            } else {\n                if (currentLocation != startLocation) {\n                    ParseErrorMarker<V> currentErrorMarker = globals.currentErrorMarker;\n                    if (currentErrorMarker.location == null || currentErrorMarker.location.index < currentLocation.index) {\n                        currentErrorMarker.mark(matcher, this);\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    //////////////////////////////// PRIVATE ////////////////////////////////////\n\n    private void setStartLocation(InputLocation location) {\n        startLocation = currentLocation = location;\n    }\n\n    private void addChildNode(Node<V> node) {\n        if (subNodes == null) subNodes = new ArrayList<Node<V>>();\n        subNodes.add(node);\n    }\n\n    private void recover() throws Throwable {\n        if (trySingleSymbolDeletion()) return;\n\n        Characters followerChars = getFollowerChars();\n        if (trySingleSymbolInsertion(followerChars)) return;\n        resynchronize(followerChars);\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    private Characters getFollowerChars() {\n        Characters chars = Characters.NONE;\n        MatcherContext<V> parent = this.parent;\n        while (parent != null) {\n            if (parent.getMatcher() instanceof FollowMatcher) {\n                FollowMatcher<V> followMatcher = (FollowMatcher<V>) parent.getMatcher();\n                chars = chars.add(followMatcher.getFollowerChars(parent));\n                if (!chars.contains(Chars.EMPTY)) return chars;\n            }\n            parent = parent.parent;\n        }\n        return chars.remove(Chars.EMPTY).add(Chars.EOI);\n    }\n\n    // check whether the current char is a junk char that we can simply discard to continue with the next char\n    private boolean trySingleSymbolDeletion() throws Throwable {\n        Characters starterChars = matcher.getStarterChars();\n        Preconditions.checkState(!starterChars.contains(Chars.EMPTY));\n        InputLocation locationBeforeError = currentLocation;\n        char lookAheadOne = locationBeforeError.lookAhead(inputBuffer, 1);\n        if (!starterChars.contains(lookAheadOne)) {\n            return false;\n        }\n\n        // success, we have to skip only one char in order to be able to start the match\n        // match the illegal char and create a node for it\n        advanceInputLocation();\n        (parent != null ? parent : this).addChildNode(\n                new NodeImpl<V>(\"ILLEGAL\", null, locationBeforeError, currentLocation, null)\n        );\n\n        startLocation = currentLocation;\n        // retry the original match\n        return matcher.match(this);\n    }\n\n    // check whether the current char is a legally following next char in the follower set\n    // if so, just virtually \"insert\" the missing expected character and continue\n    private boolean trySingleSymbolInsertion(Characters followerChars) {\n        char currentChar = currentLocation.currentChar;\n        if (!followerChars.contains(currentChar)) return false;\n\n        // success, the current mismatching character is a legal follower,\n        // so add a ParseError and still \"match\" (empty)\n        createNode();\n        return true;\n    }\n\n    // consume all characters until we see a legal follower\n    private void resynchronize(Characters followerChars) {\n        createNode(); // create an empty match node\n\n        InputLocation locationBeforeError = currentLocation;\n\n        // consume all illegal characters up until a char that we can continue parsing with\n        do {\n            advanceInputLocation();\n        } while (!followerChars.contains(currentLocation.currentChar) && currentLocation.currentChar != Chars.EOI);\n\n        (parent != null ? parent : this).addChildNode(\n                new NodeImpl<V>(\"ILLEGAL\", null, locationBeforeError, currentLocation, null)\n        );\n    }\n\n}\n","lineNo":287}
{"Refactored Sample":"/*\n * Copyright (C) 2009-2010 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.asm;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.objectweb.asm.Opcodes;\nimport org.objectweb.asm.tree.AbstractInsnNode;\nimport org.objectweb.asm.tree.JumpInsnNode;\nimport org.objectweb.asm.tree.LabelNode;\nimport static org.parboiled.common.Utils.merge;\n\nimport java.util.Set;\n\n/**\n * Transforms the ParserClassNode.cachedMethods:\n * If a method contains more than one return instruction, all \"non-last\" return instructions are replaced with goto\n * instructions to the last return instruction. Afterwards all cachedMethods will contain exactly one return instruction.\n */\nclass ReturnInstructionUnifier implements ClassTransformer, Opcodes {\n\n    private final ClassTransformer nextTransformer;\n\n    public ReturnInstructionUnifier(ClassTransformer nextTransformer) {\n        this.nextTransformer = nextTransformer;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public ParserClassNode transform(@NotNull ParserClassNode classNode) throws Exception {\n        Set<ParserMethod> methods = merge(classNode.cachedMethods, classNode.labelMethods, classNode.leafMethods);\n        for (ParserMethod method : methods) {\n            unifyReturnInstructions(method);\n        }\n\n        return nextTransformer != null ? nextTransformer.transform(classNode) : classNode;\n    }\n\n    private void unifyReturnInstructions(ParserMethod method) {\n        AbstractInsnNode current = method.instructions.getLast();\n\n        // find last return\n        while (current.getOpcode() != ARETURN) {\n            current = current.getPrevious();\n        }\n\n        AbstractInsnNode lastReturn = current;\n        LabelNode lastReturnLabel = null;\n\n        // iterate backwards up to first instructions\n        while ((current = current.getPrevious()) != null) {\n            if (current.getOpcode() == ARETURN) {\n                if (lastReturnLabel == null) {\n                    lastReturnLabel = new LabelNode();\n                    method.instructions.insertBefore(lastReturn, lastReturnLabel);\n                }\n                JumpInsnNode gotoInstruction = new JumpInsnNode(GOTO, lastReturnLabel);\n                method.instructions.set(current, gotoInstruction);\n                current = gotoInstruction;\n            }\n        }\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009-2010 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.asm;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.objectweb.asm.Opcodes;\nimport org.objectweb.asm.tree.AbstractInsnNode;\nimport org.objectweb.asm.tree.JumpInsnNode;\nimport org.objectweb.asm.tree.LabelNode;\n\n/**\n * Transforms the ParserClassNode.cachedMethods:\n * If a method contains more than one return instruction, all \"non-last\" return instructions are replaced with goto\n * instructions to the last return instruction. Afterwards all cachedMethods will contain exactly one return instruction.\n */\nclass ReturnInstructionUnifier implements ClassTransformer, Opcodes {\n\n    private final ClassTransformer nextTransformer;\n\n    public ReturnInstructionUnifier(ClassTransformer nextTransformer) {\n        this.nextTransformer = nextTransformer;\n    }\n\n    public ParserClassNode transform(@NotNull ParserClassNode classNode) throws Exception {\n        for (ParserMethod method : classNode.cachedMethods) {\n            unifyReturnInstructions(method);\n        }\n\n        return nextTransformer != null ? nextTransformer.transform(classNode) : classNode;\n    }\n\n    private void unifyReturnInstructions(ParserMethod method) {\n        AbstractInsnNode current = method.instructions.getLast();\n\n        // find last return\n        while (current.getOpcode() != ARETURN) {\n            current = current.getPrevious();\n        }\n\n        AbstractInsnNode lastReturn = current;\n        LabelNode lastReturnLabel = null;\n\n        // iterate backwards up to first instructions\n        while ((current = current.getPrevious()) != null) {\n            if (current.getOpcode() == ARETURN) {\n                if (lastReturnLabel == null) {\n                    lastReturnLabel = new LabelNode();\n                    method.instructions.insertBefore(lastReturn, lastReturnLabel);\n                }\n                JumpInsnNode gotoInstruction = new JumpInsnNode(GOTO, lastReturnLabel);\n                method.instructions.set(current, gotoInstruction);\n                current = gotoInstruction;\n            }\n        }\n    }\n\n}\n","lineNo":43}
{"Refactored Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.common.BitField;\nimport org.parboiled.common.ImmutableList;\nimport org.parboiled.common.Preconditions;\nimport org.parboiled.exceptions.ParserRuntimeException;\nimport org.parboiled.matchers.*;\nimport org.parboiled.support.*;\nimport static org.parboiled.support.ParseTreeUtils.findNode;\nimport static org.parboiled.support.ParseTreeUtils.findNodeByPath;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * <p>The Context implementation orchestrating most of the matching process.<\/p>\n * <p>The parsing process works as following:<\/br>\n * After the rule tree (which is in fact a directed and potentially even cyclic graph of Matcher instances) has been\n * created a root MatcherContext is instantiated for the root rule (Matcher).\n * A subsequent call to {@link #runMatcher()} starts the parsing process.<\/p>\n * <p>The MatcherContext essentially calls {@link Matcher#match(MatcherContext)} passing itself to the Matcher\n * which executes its logic, potentially calling sub matchers. For each sub matcher the matcher calls\n * {@link #runMatcher(org.parboiled.matchers.Matcher, boolean)} on its Context, which creates a sub context of the\n * current MatcherContext and runs the given sub matcher in it.<\/p>\n * <p>This basically creates a stack of MatcherContexts, each corresponding to their rule matchers. The MatcherContext\n * instances serve as a kind of companion objects to the matchers, providing them with support for building the\n * parse tree nodes, keeping track of input locations and error recovery.<\/p>\n * <p>At each point during the parsing process the matchers and action expressions have access to the current\n * MatcherContext and all \"open\" parent MatcherContexts through the {@link #getParent()} chain.<\/p>\n *\n * @param <V> the node value type\n */\npublic class MatcherContext<V> implements Context<V> {\n\n    // small helper class encapsulating all objects that do not change across Context levels\n    private static class Invariables<V> {\n        private final InputBuffer inputBuffer;\n        private final List<ParseError> parseErrors;\n        private final Reference<Node<V>> lastNodeRef;\n\n        private Invariables(@NotNull InputBuffer inputBuffer, @NotNull List<ParseError> parseErrors,\n                            @NotNull Reference<Node<V>> lastNodeRef) {\n            this.inputBuffer = inputBuffer;\n            this.parseErrors = parseErrors;\n            this.lastNodeRef = lastNodeRef;\n        }\n    }\n\n    private final Invariables<V> invariables;\n    private final MatcherContext<V> parent;\n    private final InputLocation startLocation;\n    private final Matcher<V> matcher;\n    private final boolean enforced;\n\n    private MatcherContext<V> subContext;\n    private InputLocation currentLocation;\n    private Node<V> node;\n    private List<Node<V>> subNodes;\n    private String errorMessage;\n    private V nodeValue;\n    private Object tag;\n\n    public MatcherContext(@NotNull InputBuffer inputBuffer, @NotNull InputLocation startLocation,\n                          @NotNull Matcher<V> matcher, @NotNull List<ParseError> parseErrors) {\n        this(null,\n                new Invariables<V>(inputBuffer, parseErrors, new Reference<Node<V>>()),\n                startLocation, matcher, true);\n    }\n\n    private MatcherContext(MatcherContext<V> parent, @NotNull Invariables<V> invariables,\n                           @NotNull InputLocation startLocation, @NotNull Matcher<V> matcher, boolean enforced) {\n\n        this.parent = parent;\n        this.startLocation = currentLocation = startLocation;\n        this.matcher = matcher;\n        this.invariables = invariables;\n        this.enforced = enforced;\n    }\n\n    @Override\n    public String toString() {\n        return getPath();\n    }\n\n    //////////////////////////////// CONTEXT INTERFACE ////////////////////////////////////\n\n    public MatcherContext<V> getParent() {\n        return parent;\n    }\n\n    public MatcherContext<V> getSubContext() {\n        return subContext;\n    }\n\n    public InputBuffer getInputBuffer() {\n        return invariables.inputBuffer;\n    }\n\n    @NotNull\n    public InputLocation getStartLocation() {\n        return startLocation;\n    }\n\n    @NotNull\n    public Matcher<V> getMatcher() {\n        return matcher;\n    }\n\n    @NotNull\n    public List<ParseError> getParseErrors() {\n        return invariables.parseErrors;\n    }\n\n    @NotNull\n    public InputLocation getCurrentLocation() {\n        return currentLocation;\n    }\n\n    public String getNodeText(Node<?> node) {\n        return ParseTreeUtils.getNodeText(node, invariables.inputBuffer);\n    }\n\n    public Character getNodeChar(Node<?> node) {\n        return ParseTreeUtils.getNodeChar(node, invariables.inputBuffer);\n    }\n\n    @NotNull\n    public String getPath() {\n        return (parent == null ? \"\" : parent.getPath()) + '/' + matcher.getLabel();\n    }\n\n    public V getNodeValue() {\n        return nodeValue;\n    }\n\n    public void setNodeValue(V value) {\n        this.nodeValue = value;\n    }\n\n    public V getTreeValue() {\n        V treeValue = nodeValue;\n        if (subNodes != null) {\n            int i = subNodes.size();\n            while (treeValue == null && i-- > 0) {\n                treeValue = subNodes.get(i).getValue();\n            }\n        }\n        return treeValue;\n    }\n\n    public Node<V> getNodeByPath(String path) {\n        return findNodeByPath(subNodes, path);\n    }\n\n    public Node<V> getNodeByLabel(String labelPrefix) {\n        return subNodes != null ? findNode(subNodes, new LabelPrefixPredicate<V>(labelPrefix)) : null;\n    }\n\n    public Node<V> getLastNode() {\n        return invariables.lastNodeRef.getTarget();\n    }\n\n    public List<Node<V>> getSubNodes() {\n        return subNodes != null ? ImmutableList.copyOf(subNodes) : ImmutableList.<Node<V>>of();\n    }\n\n    public boolean inPredicate() {\n        return ProxyMatcher.unwrap(matcher) instanceof TestMatcher || parent != null && parent.inPredicate();\n    }\n\n    public boolean isEnforced() {\n        return enforced;\n    }\n\n    //////////////////////////////// PUBLIC ////////////////////////////////////\n\n    public void setCurrentLocation(InputLocation currentLocation) {\n        this.currentLocation = currentLocation;\n    }\n\n    public void advanceInputLocation() {\n        setCurrentLocation(currentLocation.advance(invariables.inputBuffer));\n    }\n\n    public Node<V> getNode() {\n        return node;\n    }\n\n    public Object getTag() {\n        return tag;\n    }\n\n    public void setTag(Object tag) {\n        this.tag = tag;\n    }\n\n    public void addUnexpectedInputError(char illegalChar, @NotNull String expected) {\n        addError(new StringBuilder()\n                .append(\"Invalid input \").append(illegalChar != Chars.EOI ? \"\\'\" + illegalChar + '\\'' : \"EOI\")\n                .append(\", expected \").append(expected)\n                .append(ParseError.createMessageSuffix(invariables.inputBuffer, startLocation, currentLocation))\n                .toString());\n    }\n\n    public void addError(@NotNull String errorMessage) {\n        this.errorMessage = errorMessage;\n    }\n\n    public void createNode() {\n        node = new NodeImpl<V>(matcher.getLabel(), subNodes, startLocation, currentLocation, getTreeValue());\n        if (!(ProxyMatcher.unwrap(matcher) instanceof TestMatcher)) { // special case: TestMatchers do not add nodes\n            if (parent != null) parent.addChildNode(node);\n            invariables.lastNodeRef.setTarget(node);\n        }\n    }\n\n    public void addChildNode(@NotNull Node<V> node) {\n        if (subNodes == null) subNodes = new ArrayList<Node<V>>();\n        subNodes.add(node);\n    }\n\n    /**\n     * Runs the matcher of this context directly on this context.\n     *\n     * @return true if matched\n     */\n    public boolean runMatcher() {\n        try {\n            boolean matched = matcher.match(this);\n            if (!matched && enforced) {\n                recover();\n                matched = true;\n            }\n            if (errorMessage != null) {\n                addParserError(ParseError.create(this, node, errorMessage));\n            }\n            return matched;\n        } catch (ParserRuntimeException e) {\n            throw e; // don't wrap, just bubble up\n        } catch (Throwable e) {\n            throw new ParserRuntimeException(e, \"Error during execution of parsing rule '%s' at input position%s\",\n                    getPath(), ParseError.createMessageSuffix(invariables.inputBuffer, currentLocation,\n                            currentLocation));\n        }\n    }\n\n    /**\n     * Runs the given matcher in a sub context.\n     *\n     * @param matcher  the matcher to run or null, if the matcher of this context is to be run\n     * @param enforced true if enforced\n     * @return true if matched\n     */\n    public boolean runMatcher(@NotNull Matcher<V> matcher, boolean enforced) {\n        // special case: ActionMatchers need no sub context, error recovery and are always executed\n        if (ProxyMatcher.unwrap(matcher) instanceof ActionMatcher) {\n            try {\n                return matcher.match(this);\n            } catch (Throwable e) {\n                throw new ParserRuntimeException(e,\n                        \"Error during execution of parsing action '%s/%s' at input position%s\", getPath(), matcher,\n                        ParseError.createMessageSuffix(invariables.inputBuffer, currentLocation, currentLocation));\n            }\n        }\n\n        // skip the rematch if this matcher has already failed at least once at the current input location\n        // special case: IllegalCharactersMatchers are always run\n        BitField currentFailedRules = matcher instanceof IllegalCharactersMatcher ? null : currentLocation.failedRules;\n        if (currentFailedRules != null && currentFailedRules.get(matcher.getIndex())) return false;\n\n        // we execute the given matcher in a new sub context and store this sub context instance as a field\n        // in rare cases (error recovery) we might be recursing back into ourselves\n        // so we need to save and restore it\n        MatcherContext<V> oldSubContext = subContext;\n        subContext = new MatcherContext<V>(this, invariables, currentLocation, matcher, enforced);\n\n        try {\n            boolean matched = subContext.matcher.match(subContext);\n            if (!matched && enforced) {\n                subContext.recover();\n                matched = true;\n            }\n            if (subContext.errorMessage != null) {\n                subContext.addParserError(ParseError.create(subContext, subContext.node, subContext.errorMessage));\n            }\n            if (matched) {\n                setCurrentLocation(subContext.getCurrentLocation());\n            } else {\n                // memoize the mismatch\n                if (currentFailedRules != null) currentFailedRules.set(matcher.getIndex());\n            }\n            subContext = oldSubContext;\n            return matched;\n        } catch (ParserRuntimeException e) {\n            throw e; // don't wrap, just bubble up\n        } catch (Throwable e) {\n            throw new ParserRuntimeException(e, \"Error during execution of parsing rule '%s' at input position%s\",\n                    getPath(), ParseError.createMessageSuffix(invariables.inputBuffer, subContext.currentLocation,\n                            subContext.currentLocation));\n        }\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    public Characters getFollowerChars() {\n        Characters chars = Characters.NONE;\n        MatcherContext<V> parent = this.parent;\n        while (parent != null) {\n            Matcher<V> unwrappedMatcher = ProxyMatcher.unwrap(parent.getMatcher());\n            if (unwrappedMatcher instanceof FollowMatcher) {\n                FollowMatcher<V> followMatcher = (FollowMatcher<V>) unwrappedMatcher;\n                chars = chars.add(followMatcher.getFollowerChars(parent));\n                if (!chars.contains(Chars.EMPTY)) return chars;\n            }\n            parent = parent.parent;\n        }\n        return chars.remove(Chars.EMPTY).add(Chars.EOI);\n    }\n\n    //////////////////////////////// PRIVATE ////////////////////////////////////\n\n    private void recover() {\n        if (trySingleSymbolDeletion()) return;\n\n        Characters followerChars = getFollowerChars();\n        if (trySingleSymbolInsertion(followerChars)) return;\n        resynchronize(followerChars);\n    }\n\n    // check whether the current char is a junk char that we can simply discard to continue with the next char\n    private boolean trySingleSymbolDeletion() {\n        Characters starterChars = matcher.getStarterChars();\n        Preconditions.checkState(!starterChars.contains(Chars.EMPTY));\n        char lookAheadOne = getCurrentLocation().lookAhead(invariables.inputBuffer, 1);\n        if (!starterChars.contains(lookAheadOne)) {\n            return false;\n        }\n\n        // normally, we need to run the IllegalCharactersMatcher in our parent context so the created node\n        // appears on the same tree level, however if we are the root ourselves we run in this context\n        MatcherContext<V> parentContext = parent != null ? parent : this;\n\n        // success, we have to skip only one char in order to be able to start the match\n        // match the illegal char and create a node for it\n        IllegalCharactersMatcher<V> illegalCharsMatcher =\n                new IllegalCharactersMatcher<V>(matcher.getExpectedString(), Characters.of(lookAheadOne));\n        parentContext.runMatcher(illegalCharsMatcher, true);\n\n        // retry the original match\n        parentContext.runMatcher(matcher, true);\n\n        // catch up with the advanced location\n        setCurrentLocation(parentContext.getCurrentLocation());\n\n        return true;\n    }\n\n    // check whether the current char is a legally following next char in the follower set\n    // if so, just virtually \"insert\" the missing expected token and continue\n    private boolean trySingleSymbolInsertion(Characters followerChars) {\n        char currentChar = getCurrentLocation().currentChar;\n        if (!followerChars.contains(currentChar)) return false;\n\n        // success, the current mismatching token is a legal follower,\n        // so add a ParseError and still \"match\" (empty)\n        addUnexpectedInputError(currentChar, matcher.getExpectedString());\n        createNode();\n        return true;\n    }\n\n    // consume all characters until we see a legal follower\n    private void resynchronize(Characters followerChars) {\n        createNode(); // create an empty match node\n\n        // normally, we need to run the IllegalCharactersMatcher in our parent context so the created node\n        // appears on the same tree level, however if we are at the root ourselves we run in this context\n        MatcherContext<V> parentContext = parent != null ? parent : this;\n\n        // create a node for the illegal chars\n        parentContext.runMatcher(new IllegalCharactersMatcher<V>(matcher.getExpectedString(), followerChars), true);\n\n        // catch up with the advanced location\n        setCurrentLocation(parentContext.getCurrentLocation());\n    }\n\n    private void addParserError(ParseError error) {\n        // do not add the error if we already have one at the exact same input location\n        for (ParseError parseError : invariables.parseErrors) {\n            if (parseError.getErrorStart() == error.getErrorStart()) return;\n        }\n        invariables.parseErrors.add(error);\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.common.BitField;\nimport org.parboiled.common.ImmutableList;\nimport org.parboiled.common.Preconditions;\nimport org.parboiled.exceptions.ParserRuntimeException;\nimport org.parboiled.matchers.*;\nimport org.parboiled.support.*;\nimport static org.parboiled.support.ParseTreeUtils.findNode;\nimport static org.parboiled.support.ParseTreeUtils.findNodeByPath;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * <p>The Context implementation orchestrating most of the matching process.<\/p>\n * <p>The parsing process works as following:<\/br>\n * After the rule tree (which is in fact a directed and potentially even cyclic graph of Matcher instances) has been\n * created a root MatcherContext is instantiated for the root rule (Matcher).\n * A subsequent call to {@link #runMatcher()} starts the parsing process.<\/p>\n * <p>The MatcherContext essentially calls {@link Matcher#match(MatcherContext)} passing itself to the Matcher\n * which executes its logic, potentially calling sub matchers. For each sub matcher the matcher calls\n * {@link #runMatcher(org.parboiled.matchers.Matcher, boolean)} on its Context, which creates a sub context of the\n * current MatcherContext and runs the given sub matcher in it.<\/p>\n * <p>This basically creates a stack of MatcherContexts, each corresponding to their rule matchers. The MatcherContext\n * instances serve as a kind of companion objects to the matchers, providing them with support for building the\n * parse tree nodes, keeping track of input locations and error recovery.<\/p>\n * <p>At each point during the parsing process the matchers and action expressions have access to the current\n * MatcherContext and all \"open\" parent MatcherContexts through the {@link #getParent()} chain.<\/p>\n *\n * @param <V> the node value type\n */\npublic class MatcherContext<V> implements Context<V> {\n\n    // small helper class encapsulating all objects that do not change across Context levels\n    private static class Invariables<V> {\n        private final InputBuffer inputBuffer;\n        private final List<ParseError> parseErrors;\n        private final Reference<Node<V>> lastNodeRef;\n\n        private Invariables(@NotNull InputBuffer inputBuffer, @NotNull List<ParseError> parseErrors,\n                            @NotNull Reference<Node<V>> lastNodeRef) {\n            this.inputBuffer = inputBuffer;\n            this.parseErrors = parseErrors;\n            this.lastNodeRef = lastNodeRef;\n        }\n    }\n\n    private final Invariables<V> invariables;\n    private final MatcherContext<V> parent;\n    private final InputLocation startLocation;\n    private final Matcher<V> matcher;\n    private final boolean enforced;\n\n    private MatcherContext<V> subContext;\n    private InputLocation currentLocation;\n    private Node<V> node;\n    private List<Node<V>> subNodes;\n    private String errorMessage;\n    private V nodeValue;\n    private Object tag;\n\n    public MatcherContext(@NotNull InputBuffer inputBuffer, @NotNull InputLocation startLocation,\n                          @NotNull Matcher<V> matcher, @NotNull List<ParseError> parseErrors) {\n        this(null,\n                new Invariables<V>(inputBuffer, parseErrors, new Reference<Node<V>>()),\n                startLocation, matcher, true);\n    }\n\n    private MatcherContext(MatcherContext<V> parent, @NotNull Invariables<V> invariables,\n                           @NotNull InputLocation startLocation, @NotNull Matcher<V> matcher, boolean enforced) {\n\n        this.parent = parent;\n        this.startLocation = currentLocation = startLocation;\n        this.matcher = matcher;\n        this.invariables = invariables;\n        this.enforced = enforced;\n    }\n\n    @Override\n    public String toString() {\n        return getPath();\n    }\n\n    //////////////////////////////// CONTEXT INTERFACE ////////////////////////////////////\n\n    public MatcherContext<V> getParent() {\n        return parent;\n    }\n\n    public MatcherContext<V> getSubContext() {\n        return subContext;\n    }\n\n    public InputBuffer getInputBuffer() {\n        return invariables.inputBuffer;\n    }\n\n    @NotNull\n    public InputLocation getStartLocation() {\n        return startLocation;\n    }\n\n    @NotNull\n    public Matcher<V> getMatcher() {\n        return matcher;\n    }\n\n    @NotNull\n    public List<ParseError> getParseErrors() {\n        return invariables.parseErrors;\n    }\n\n    @NotNull\n    public InputLocation getCurrentLocation() {\n        return currentLocation;\n    }\n\n    public String getNodeText(Node<?> node) {\n        return ParseTreeUtils.getNodeText(node, invariables.inputBuffer);\n    }\n\n    public Character getNodeChar(Node<?> node) {\n        return ParseTreeUtils.getNodeChar(node, invariables.inputBuffer);\n    }\n\n    @NotNull\n    public String getPath() {\n        return (parent == null ? \"\" : parent.getPath()) + '/' + matcher.getLabel();\n    }\n\n    public V getNodeValue() {\n        return nodeValue;\n    }\n\n    public void setNodeValue(V value) {\n        this.nodeValue = value;\n    }\n\n    public V getTreeValue() {\n        V treeValue = nodeValue;\n        if (subNodes != null) {\n            int i = subNodes.size();\n            while (treeValue == null && i-- > 0) {\n                treeValue = subNodes.get(i).getValue();\n            }\n        }\n        return treeValue;\n    }\n\n    public Node<V> getNodeByPath(String path) {\n        return findNodeByPath(subNodes, path);\n    }\n\n    public Node<V> getNodeByLabel(String labelPrefix) {\n        return subNodes != null ? findNode(subNodes, new LabelPrefixPredicate<V>(labelPrefix)) : null;\n    }\n\n    public Node<V> getLastNode() {\n        return invariables.lastNodeRef.getTarget();\n    }\n\n    public List<Node<V>> getSubNodes() {\n        return subNodes != null ? ImmutableList.copyOf(subNodes) : ImmutableList.<Node<V>>of();\n    }\n\n    public boolean inPredicate() {\n        return ProxyMatcher.unwrap(matcher) instanceof TestMatcher || parent != null && parent.inPredicate();\n    }\n\n    public boolean isEnforced() {\n        return enforced;\n    }\n\n    //////////////////////////////// PUBLIC ////////////////////////////////////\n\n    public void setCurrentLocation(InputLocation currentLocation) {\n        this.currentLocation = currentLocation;\n    }\n\n    public void advanceInputLocation() {\n        setCurrentLocation(currentLocation.advance(invariables.inputBuffer));\n    }\n\n    public Node<V> getNode() {\n        return node;\n    }\n\n    public Object getTag() {\n        return tag;\n    }\n\n    public void setTag(Object tag) {\n        this.tag = tag;\n    }\n\n    public void addUnexpectedInputError(char illegalChar, @NotNull String expected) {\n        addError(new StringBuilder()\n                .append(\"Invalid input \").append(illegalChar != Chars.EOI ? \"\\'\" + illegalChar + '\\'' : \"EOI\")\n                .append(\", expected \").append(expected)\n                .append(ParseError.createMessageSuffix(invariables.inputBuffer, startLocation, currentLocation))\n                .toString());\n    }\n\n    public void addError(@NotNull String errorMessage) {\n        this.errorMessage = errorMessage;\n    }\n\n    public void createNode() {\n        node = new NodeImpl<V>(matcher.getLabel(), subNodes, startLocation, currentLocation, getTreeValue());\n        if (!(ProxyMatcher.unwrap(matcher) instanceof TestMatcher)) { // special case: TestMatchers do not add nodes\n            if (parent != null) parent.addChildNode(node);\n            invariables.lastNodeRef.setTarget(node);\n        }\n    }\n\n    public void addChildNode(@NotNull Node<V> node) {\n        if (subNodes == null) subNodes = new ArrayList<Node<V>>();\n        subNodes.add(node);\n    }\n\n    /**\n     * Runs the matcher of this context directly on this context.\n     *\n     * @return true if matched\n     */\n    public boolean runMatcher() {\n        try {\n            boolean matched = matcher.match(this);\n            if (!matched && enforced) {\n                recover();\n                matched = true;\n            }\n            if (errorMessage != null) {\n                addParserError(ParseError.create(this, node, errorMessage));\n            }\n            return matched;\n        } catch (ParserRuntimeException e) {\n            throw e; // don't wrap, just bubble up\n        } catch (Throwable e) {\n            throw new ParserRuntimeException(e, \"Error during execution of parsing rule '%s' at input position%s\",\n                    getPath(), ParseError.createMessageSuffix(invariables.inputBuffer, currentLocation,\n                            currentLocation));\n        }\n    }\n\n    /**\n     * Runs the given matcher in a sub context.\n     *\n     * @param matcher  the matcher to run or null, if the matcher of this context is to be run\n     * @param enforced true if enforced\n     * @return true if matched\n     */\n    public boolean runMatcher(@NotNull Matcher<V> matcher, boolean enforced) {\n        // special case: ActionMatchers need no sub context, error recovery and are always executed\n        if (ProxyMatcher.unwrap(matcher) instanceof ActionMatcher) {\n            try {\n                return matcher.match(this);\n            } catch (Throwable e) {\n                throw new ParserRuntimeException(e,\n                        \"Error during execution of parsing action '%s/%s' at input position%s\", getPath(), matcher,\n                        ParseError.createMessageSuffix(invariables.inputBuffer, currentLocation, currentLocation));\n            }\n        }\n\n        // skip the rematch if this matcher has already failed at least once at the current input location\n        // special case: IllegalCharactersMatchers are always run\n        BitField currentFailedRules = matcher instanceof IllegalCharactersMatcher ? null : currentLocation.failedRules;\n        if (currentFailedRules != null && currentFailedRules.get(matcher.getIndex())) return false;\n\n        // we execute the given matcher in a new sub context and store this sub context instance as a field\n        // in rare cases (error recovery) we might be recursing back into ourselves\n        // so we need to save and restore it\n        MatcherContext<V> oldSubContext = subContext;\n        subContext = new MatcherContext<V>(this, invariables, currentLocation, matcher, enforced);\n\n        try {\n            boolean matched = subContext.matcher.match(subContext);\n            if (!matched && enforced) {\n                subContext.recover();\n                matched = true;\n            }\n            if (subContext.errorMessage != null) {\n                subContext.addParserError(ParseError.create(subContext, subContext.node, subContext.errorMessage));\n            }\n            if (matched) {\n                setCurrentLocation(subContext.getCurrentLocation());\n            } else {\n                // memoize the mismatch\n                if (currentFailedRules != null) currentFailedRules.set(matcher.getIndex());\n            }\n            subContext = oldSubContext;\n            return matched;\n        } catch (ParserRuntimeException e) {\n            throw e; // don't wrap, just bubble up\n        } catch (Throwable e) {\n            throw new ParserRuntimeException(e, \"Error during execution of parsing rule '%s' at input position%s\",\n                    getPath(), ParseError.createMessageSuffix(invariables.inputBuffer, subContext.currentLocation,\n                            subContext.currentLocation));\n        }\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    public Characters getFollowerChars() {\n        Characters chars = Characters.NONE;\n        MatcherContext<V> parent = this.parent;\n        while (parent != null) {\n            if (ProxyMatcher.unwrap(parent.getMatcher()) instanceof FollowMatcher) {\n                FollowMatcher<V> followMatcher = (FollowMatcher<V>) parent.getMatcher();\n                chars = chars.add(followMatcher.getFollowerChars(parent));\n                if (!chars.contains(Chars.EMPTY)) return chars;\n            }\n            parent = parent.parent;\n        }\n        return chars.remove(Chars.EMPTY).add(Chars.EOI);\n    }\n\n    //////////////////////////////// PRIVATE ////////////////////////////////////\n\n    private void recover() {\n        if (trySingleSymbolDeletion()) return;\n\n        Characters followerChars = getFollowerChars();\n        if (trySingleSymbolInsertion(followerChars)) return;\n        resynchronize(followerChars);\n    }\n\n    // check whether the current char is a junk char that we can simply discard to continue with the next char\n    private boolean trySingleSymbolDeletion() {\n        Characters starterChars = matcher.getStarterChars();\n        Preconditions.checkState(!starterChars.contains(Chars.EMPTY));\n        char lookAheadOne = getCurrentLocation().lookAhead(invariables.inputBuffer, 1);\n        if (!starterChars.contains(lookAheadOne)) {\n            return false;\n        }\n\n        // normally, we need to run the IllegalCharactersMatcher in our parent context so the created node\n        // appears on the same tree level, however if we are the root ourselves we run in this context\n        MatcherContext<V> parentContext = parent != null ? parent : this;\n\n        // success, we have to skip only one char in order to be able to start the match\n        // match the illegal char and create a node for it\n        IllegalCharactersMatcher<V> illegalCharsMatcher =\n                new IllegalCharactersMatcher<V>(matcher.getExpectedString(), Characters.of(lookAheadOne));\n        parentContext.runMatcher(illegalCharsMatcher, true);\n\n        // retry the original match\n        parentContext.runMatcher(matcher, true);\n\n        // catch up with the advanced location\n        setCurrentLocation(parentContext.getCurrentLocation());\n\n        return true;\n    }\n\n    // check whether the current char is a legally following next char in the follower set\n    // if so, just virtually \"insert\" the missing expected token and continue\n    private boolean trySingleSymbolInsertion(Characters followerChars) {\n        char currentChar = getCurrentLocation().currentChar;\n        if (!followerChars.contains(currentChar)) return false;\n\n        // success, the current mismatching token is a legal follower,\n        // so add a ParseError and still \"match\" (empty)\n        addUnexpectedInputError(currentChar, matcher.getExpectedString());\n        createNode();\n        return true;\n    }\n\n    // consume all characters until we see a legal follower\n    private void resynchronize(Characters followerChars) {\n        createNode(); // create an empty match node\n\n        // normally, we need to run the IllegalCharactersMatcher in our parent context so the created node\n        // appears on the same tree level, however if we are at the root ourselves we run in this context\n        MatcherContext<V> parentContext = parent != null ? parent : this;\n\n        // create a node for the illegal chars\n        parentContext.runMatcher(new IllegalCharactersMatcher<V>(matcher.getExpectedString(), followerChars), true);\n\n        // catch up with the advanced location\n        setCurrentLocation(parentContext.getCurrentLocation());\n    }\n\n    private void addParserError(ParseError error) {\n        // do not add the error if we already have one at the exact same input location\n        for (ParseError parseError : invariables.parseErrors) {\n            if (parseError.getErrorStart() == error.getErrorStart()) return;\n        }\n        invariables.parseErrors.add(error);\n    }\n\n}\n","lineNo":325}
{"Refactored Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled;\n\nimport static org.testng.Assert.assertEquals;\nimport org.testng.annotations.Test;\nimport org.parboiled.test.AbstractTest;\n\npublic class IndentDedentTest extends AbstractTest {\n\n    public static class IndentDedentParser extends BaseParser<Object> {\n\n        public int currentIndent;\n        public int indents;\n        public int dedents;\n\n        public Rule file() {\n            return zeroOrMore(line());\n        }\n\n        public Rule line() {\n            return sequence(\n                    zeroOrMore(' '),\n                    countIndentOrDedent(TEXT(LAST_NODE())),\n                    zeroOrMore(lineChar()),\n                    newline()\n            );\n        }\n\n        public Rule lineChar() {\n            return sequence(testNot(newline()), any());\n        }\n\n        public Rule newline() {\n            return firstOf(\"\\r\\n\", '\\r', '\\n');\n        }\n\n        public boolean countIndentOrDedent(String lineStartWhiteSpace) {\n            if (lineStartWhiteSpace.length() > currentIndent) indents++;\n            if (lineStartWhiteSpace.length() < currentIndent) dedents++;\n            currentIndent = lineStartWhiteSpace.length();\n            return true;\n        }\n\n    }\n\n    @Test\n    public void test() {\n        IndentDedentParser parser = Parboiled.createParser(IndentDedentParser.class);\n        Rule rule = parser.file();\n        parser.parse(rule, \"\" +\n                \"a file containing\\n\" +\n                \"  some\\n\" +\n                \"     indents\\n\" +\n                \"     some lines\\n\" +\n                \"     that do not indent\\n\" +\n                \"  they might dedent\\n\" +\n                \"  stay there\\n\" +\n                \"          go back big time\\n\" +\n                \" and return\"\n        );\n        assertEquals(parser.indents, 3);\n        assertEquals(parser.dedents, 2);\n        assertEquals(parser.currentIndent, 1);\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled;\n\nimport static org.testng.Assert.assertEquals;\nimport org.testng.annotations.Test;\nimport org.parboiled.test.AbstractTest;\n\npublic class IndentDedentTest extends AbstractTest {\n\n    public static class IndentDedentActions extends BaseActions<Object> {\n\n        public int currentIndent;\n        public int indents;\n        public int dedents;\n\n        public boolean countIndentOrDedent(String lineStartWhiteSpace) {\n            if (lineStartWhiteSpace.length() > currentIndent) indents++;\n            if (lineStartWhiteSpace.length() < currentIndent) dedents++;\n            currentIndent = lineStartWhiteSpace.length();\n            return true;\n        }\n    }\n\n    public static class IndentDedentParser extends BaseParser<Object> {\n\n        protected final IndentDedentActions actions = new IndentDedentActions();\n\n        public Rule file() {\n            return zeroOrMore(line());\n        }\n\n        public Rule line() {\n            return sequence(\n                    zeroOrMore(' '),\n                    actions.countIndentOrDedent(TEXT(LAST_NODE())),\n                    zeroOrMore(lineChar()),\n                    newline()\n            );\n        }\n\n        public Rule lineChar() {\n            return sequence(testNot(newline()), any());\n        }\n\n        public Rule newline() {\n            return firstOf(\"\\r\\n\", '\\r', '\\n');\n        }\n\n    }\n\n    @Test\n    public void test() {\n        IndentDedentParser parser = Parboiled.createParser(IndentDedentParser.class);\n        parser.parse(parser.file(), \"\" +\n                \"a file containing\\n\" +\n                \"  some\\n\" +\n                \"     indents\\n\" +\n                \"     some lines\\n\" +\n                \"     that do not indent\\n\" +\n                \"  they might dedent\\n\" +\n                \"  stay there\\n\" +\n                \"          go back big time\\n\" +\n                \" and return\"\n        );\n        assertEquals(parser.actions.indents, 3);\n        assertEquals(parser.actions.dedents, 2);\n        assertEquals(parser.actions.currentIndent, 1);\n    }\n\n}\n","lineNo":64}
{"Refactored Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.support;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.common.BitField;\n\n/**\n * Immutable value container identifying a certain position in an InputBuffer.\n */\npublic class InputLocation {\n    public final int index;\n    public final int row;\n    public final int column;\n    public final char currentChar;\n    public final BitField failedRules;\n\n    public InputLocation(@NotNull InputBuffer inputBuffer, BitField failedRules) {\n        this(inputBuffer, 0, 0, 0, failedRules);\n    }\n\n    private InputLocation(@NotNull InputBuffer inputBuffer, int index, int row, int column, BitField failedRules) {\n        this.index = index;\n        this.row = row;\n        this.column = column;\n        this.failedRules = failedRules;\n        this.currentChar = inputBuffer.charAt(index);\n    }\n\n    public InputLocation advance(@NotNull InputBuffer inputBuffer) {\n        if (currentChar == Chars.EOI) return this;\n        int newRow, newColumn;\n        if (currentChar == '\\n') {\n            newRow = row + 1;\n            newColumn = 0;\n        } else {\n            newRow = row;\n            newColumn = column + 1;\n        }\n        return new InputLocation(inputBuffer, index + 1, newRow, newColumn,\n                failedRules != null ? new BitField(failedRules.getLength()) : null);\n    }\n\n    public char lookAhead(@NotNull InputBuffer inputBuffer, int delta) {\n        return inputBuffer.charAt(index + delta);\n    }\n\n}\n\n","Smelly Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.support;\n\nimport org.jetbrains.annotations.NotNull;\n\n/**\n * Immutable value container identifying a certain position in an InputBuffer.\n */\npublic class InputLocation {\n    public final int index;\n    public final int row;\n    public final int column;\n    public final char currentChar;\n\n    public InputLocation(@NotNull InputBuffer inputBuffer) {\n        this(inputBuffer, 0, 0, 0);\n    }\n\n    private InputLocation(@NotNull InputBuffer inputBuffer, int index, int row, int column) {\n        this.index = index;\n        this.row = row;\n        this.column = column;\n        this.currentChar = inputBuffer.charAt(index);\n    }\n\n    public InputLocation advance(@NotNull InputBuffer inputBuffer) {\n        switch (currentChar) {\n            case Chars.EOI:\n                return this;\n            case '\\n':\n                return new InputLocation(inputBuffer, index + 1, row + 1, 0);\n            default:\n                return new InputLocation(inputBuffer, index + 1, row, column + 1);\n        }\n    }\n\n    public char lookAhead(@NotNull InputBuffer inputBuffer, int delta) {\n        return inputBuffer.charAt(index + delta);\n    }\n\n}\n\n","lineNo":46}
{"Refactored Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled;\n\nimport org.testng.annotations.Test;\nimport org.parboiled.test.AbstractTest;\n\npublic class SimpleTest extends AbstractTest {\n\n    static class Parser extends BaseParser<Object> {\n\n        public Rule clause() {\n            return sequence(digit(), operator(), digit(), eoi());\n        }\n\n        public Rule operator() {\n            return firstOf('+', '-');\n        }\n\n        public Rule digit() {\n            return charRange('0', '9');\n        }\n\n    }\n\n    @Test\n    public void test() {\n        Parser parser = Parboiled.createParser(Parser.class);\n        Rule rule = parser.clause();\n        test(parser, rule, \"1+5\", \"\" +\n                \"[clause] '1+5'\\n\" +\n                \"    [digit] '1'\\n\" +\n                \"    [operator] '+'\\n\" +\n                \"        ['+'] '+'\\n\" +\n                \"    [digit] '5'\\n\" +\n                \"    [EOI]\\n\");\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled;\n\nimport org.testng.annotations.Test;\nimport org.parboiled.test.AbstractTest;\n\npublic class SimpleTest extends AbstractTest {\n\n    static class Parser extends BaseParser<Object> {\n\n        public Rule clause() {\n            return sequence(digit(), operator(), digit(), eoi());\n        }\n\n        public Rule operator() {\n            return firstOf('+', '-');\n        }\n\n        public Rule digit() {\n            return charRange('0', '9');\n        }\n\n    }\n\n    @Test\n    public void test() {\n        Parser parser = Parboiled.createParser(Parser.class);        \n        test(parser, parser.clause(), \"1+5\", \"\" +\n                \"[clause] '1+5'\\n\" +\n                \"    [digit] '1'\\n\" +\n                \"    [operator] '+'\\n\" +\n                \"        ['+'] '+'\\n\" +\n                \"    [digit] '5'\\n\" +\n                \"    [EOI]\\n\");\n    }\n\n}\n","lineNo":43}
{"Refactored Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.asm;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.objectweb.asm.Type;\nimport org.parboiled.BaseParser;\nimport org.parboiled.Context;\nimport org.parboiled.ContextAware;\nimport org.parboiled.Rule;\nimport org.parboiled.matchers.AbstractMatcher;\nimport org.parboiled.matchers.Matcher;\nimport org.parboiled.matchers.ProxyMatcher;\nimport org.parboiled.support.DontExtend;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\n\nclass AsmUtils {\n\n    public static final Type ABSTRACT_MATCHER_TYPE = Type.getType(AbstractMatcher.class);\n    public static final Type ACTION_WRAPPER_BASE_TYPE = Type.getType(ActionWrapperBase.class);\n    public static final Type BASE_PARSER_TYPE = Type.getType(BaseParser.class);\n    public static final Type BOOLEAN_TYPE = Type.getType(Boolean.class);\n    public static final Type CONTEXT_AWARE_TYPE = Type.getType(ContextAware.class);\n    public static final Type CONTEXT_TYPE = Type.getType(Context.class);\n    public static final Type DONT_EXTEND_ANNOTATION_TYPE = Type.getType(DontExtend.class);\n    public static final Type MATCHER_TYPE = Type.getType(Matcher.class);\n    public static final Type PROXY_MATCHER_TYPE = Type.getType(ProxyMatcher.class);\n    public static final Type RULE_TYPE = Type.getType(Rule.class);\n\n    public static Class<?> getClassForInternalName(@NotNull String internalName) {\n        String className = internalName.replace('/', '.');\n        try {\n            return Class.forName(className);\n        } catch (ClassNotFoundException e) {\n            throw new RuntimeException(\"Error loading class '\" + className + \"' for rule method analysis\", e);\n        }\n    }\n\n    public static Class<?> getClassForType(@NotNull Type type) {\n        switch (type.getSort()) {\n            case Type.BOOLEAN:\n                return boolean.class;\n            case Type.BYTE:\n                return byte.class;\n            case Type.CHAR:\n                return char.class;\n            case Type.DOUBLE:\n                return double.class;\n            case Type.FLOAT:\n                return float.class;\n            case Type.INT:\n                return int.class;\n            case Type.LONG:\n                return long.class;\n            case Type.SHORT:\n                return short.class;\n            case Type.VOID:\n                return void.class;\n            case Type.OBJECT:\n            case Type.ARRAY:\n                return getClassForInternalName(type.getInternalName());\n        }\n        throw new IllegalStateException(); // should be unreachable\n    }\n\n    public static Field getOwnerField(@NotNull String ownerInternalName, @NotNull String fieldName) {\n        Class<?> clazz = getClassForInternalName(ownerInternalName);\n        try {\n            return clazz.getDeclaredField(fieldName);\n        } catch (NoSuchFieldException e) {\n            throw new RuntimeException(\"Could not get field '\" + fieldName + \"' of class '\" + clazz + '\\'', e);\n        }\n    }\n\n    public static Method getOwnerMethod(@NotNull String ownerInternalName, @NotNull String methodName,\n                                        @NotNull String methodDesc) {\n        Class<?> clazz = getClassForInternalName(ownerInternalName);\n        Type[] types = Type.getArgumentTypes(methodDesc);\n        Class<?>[] argTypes = new Class<?>[types.length];\n        for (int i = 0; i < types.length; i++) {\n            argTypes[i] = getClassForType(types[i]);\n        }\n        Class<?> current = clazz;\n        while (true) {\n            try {\n                return current.getDeclaredMethod(methodName, argTypes);\n            } catch (NoSuchMethodException e) {\n                current = current.getSuperclass();\n                if (Object.class.equals(current)) {\n                    throw new RuntimeException(\"Method '\" + methodName + \"' with descriptor '\" +\n                            methodDesc + \"' not found in class '\" + clazz + \"\\' or any superclass\", e);\n                }\n            }\n        }\n    }\n\n    /**\n     * Loads the class defined with the given name and bytecode using the given class loader,\n     * if a class with the given name has not yet been loaded before.\n     * Since package and class idendity includes the ClassLoader instance used to load a class we use reflection\n     * on the given class loader to define generated classes. If we used our own class loader (in order to be able\n     * to access the protected \"defineClass\" method) we would likely still be able to load generated classes,\n     * however, they would not have access to package-private classes and members of their super classes.\n     *\n     * @param className   the full name of the class to be loaded\n     * @param code        the bytecode of the class to load\n     * @param classLoader the class loader to use\n     * @return the class instance\n     */\n    public static Class<?> loadClass(@NotNull String className, @NotNull byte[] code,\n                                     @NotNull ClassLoader classLoader) {\n        try {\n            Class<?> classLoaderBaseClass = Class.forName(\"java.lang.ClassLoader\");\n            Method findLoadedClassMethod = classLoaderBaseClass.getDeclaredMethod(\"findLoadedClass\", String.class);\n\n            // protected method invocation\n            findLoadedClassMethod.setAccessible(true);\n            try {\n                Class<?> clazz = (Class<?>) findLoadedClassMethod.invoke(classLoader, className);\n                if (clazz != null) return clazz;\n            } finally {\n                findLoadedClassMethod.setAccessible(false);\n            }\n\n            Method defineClassMethod = classLoaderBaseClass.getDeclaredMethod(\"defineClass\",\n                    String.class, byte[].class, int.class, int.class);\n\n            // protected method invocation\n            defineClassMethod.setAccessible(true);\n            try {\n                return (Class<?>) defineClassMethod.invoke(classLoader, className, code, 0, code.length);\n            } finally {\n                defineClassMethod.setAccessible(false);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load class '\" + className + '\\'', e);\n        }\n    }\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.asm;\n\nimport org.objectweb.asm.Type;\nimport org.parboiled.BaseParser;\nimport org.parboiled.Context;\nimport org.parboiled.ContextAware;\nimport org.parboiled.Rule;\nimport org.parboiled.matchers.AbstractMatcher;\nimport org.parboiled.matchers.Matcher;\nimport org.parboiled.matchers.ProxyMatcher;\nimport org.parboiled.support.DontExtend;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\n\nclass AsmUtils {\n\n    public static final Type ABSTRACT_MATCHER_TYPE = Type.getType(AbstractMatcher.class);\n    public static final Type ACTION_WRAPPER_BASE_TYPE = Type.getType(ActionWrapperBase.class);\n    public static final Type BASE_PARSER_TYPE = Type.getType(BaseParser.class);\n    public static final Type BOOLEAN_TYPE = Type.getType(Boolean.class);\n    public static final Type CONTEXT_AWARE_TYPE = Type.getType(ContextAware.class);\n    public static final Type CONTEXT_TYPE = Type.getType(Context.class);\n    public static final Type DONT_EXTEND_ANNOTATION_TYPE = Type.getType(DontExtend.class);\n    public static final Type MATCHER_TYPE = Type.getType(Matcher.class);\n    public static final Type PROXY_MATCHER_TYPE = Type.getType(ProxyMatcher.class);\n    public static final Type RULE_TYPE = Type.getType(Rule.class);\n\n    /**\n     * Get the class corresponding to the given internal name.\n     *\n     * @param internalName the internal name of the class to get\n     * @return the class\n     */\n    public static Class<?> getClassForInternalName(String internalName) {\n        String className = internalName.replace('/', '.');\n        try {\n            return Class.forName(className);\n        } catch (ClassNotFoundException e) {\n            throw new RuntimeException(\"Error loading class '\" + className + \"' for rule method analysis\", e);\n        }\n    }\n\n    public static Field getOwnerField(String ownerInternalName, String fieldName) {\n        Class<?> clazz = getClassForInternalName(ownerInternalName);\n        try {\n            return clazz.getDeclaredField(fieldName);\n        } catch (NoSuchFieldException e) {\n            throw new RuntimeException(\"Could not get field '\" + fieldName + \"' of class '\" + clazz + '\\'', e);\n        }\n    }\n\n    public static Method getOwnerMethod(String ownerInternalName, String methodName, String methodDesc) {\n        Class<?> clazz = getClassForInternalName(ownerInternalName);\n        try {\n            Type[] types = Type.getArgumentTypes(methodDesc);\n            Class<?>[] argTypes = new Class<?>[types.length];\n            for (int i = 0; i < types.length; i++) {\n                argTypes[i] = getClassForInternalName(types[i].getInternalName());\n            }\n            return clazz.getDeclaredMethod(methodName, argTypes);\n        } catch (NoSuchMethodException e) {\n            throw new RuntimeException(\"Could not get method '\" + methodName + \"' with descriptor '\" +\n                    methodDesc + \"' of class '\" + clazz + '\\'', e);\n        }\n    }\n\n    /**\n     * Loads the class defined with the given name and bytecode using the system class loader, provided it hasn't\n     * already been loaded before.\n     * Since package and class idendity includes the ClassLoader instance used to load a class we use reflection\n     * on the system class loader to define generated classes. If we subclassed our own class loader (in order to\n     * be able to access the protected \"defineClass\" method) we would still be able to load generated classes,\n     * however, they would not have access to package-private classes and members of their super classes.\n     *\n     * @param className the full name of the class to be loaded\n     * @param code      the bytecode of the class to load\n     * @return the class instance\n     */\n    public static Class<?> loadClass(String className, byte[] code) {\n        try {\n            ClassLoader loader = ClassLoader.getSystemClassLoader();\n            Class<?> classLoaderBaseClass = Class.forName(\"java.lang.ClassLoader\");\n            Method findLoadedClassMethod = classLoaderBaseClass.getDeclaredMethod(\"findLoadedClass\", String.class);\n\n            // protected method invocation\n            findLoadedClassMethod.setAccessible(true);\n            try {\n                Class<?> clazz = (Class<?>) findLoadedClassMethod.invoke(loader, className);\n                if (clazz != null) return clazz;\n            } finally {\n                findLoadedClassMethod.setAccessible(false);\n            }\n\n            Method defineClassMethod = classLoaderBaseClass.getDeclaredMethod(\"defineClass\",\n                    String.class, byte[].class, int.class, int.class);\n\n            // protected method invocation\n            defineClassMethod.setAccessible(true);\n            try {\n                return (Class<?>) defineClassMethod.invoke(loader, className, code, 0, code.length);\n            } finally {\n                defineClassMethod.setAccessible(false);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load generated class\", e);\n        }\n    }\n}\n","lineNo":99}
{"Refactored Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.asm;\n\nimport org.objectweb.asm.Opcodes;\nimport org.objectweb.asm.Type;\nimport org.objectweb.asm.tree.*;\n\npublic class RuleMethodTransformer implements ClassTransformer, Opcodes {\n\n    private final ClassTransformer nextTransformer;\n\n    public RuleMethodTransformer(ClassTransformer nextTransformer) {\n        this.nextTransformer = nextTransformer;\n    }\n\n    public ParserClassNode transform(ParserClassNode classNode) throws Exception {\n        for (RuleMethodInfo methodInfo : classNode.methodInfos) {\n            if (methodInfo.hasActions()) {\n                transformRuleMethodContainingActions(classNode, methodInfo);\n            } else {\n                transformRuleMethodWithoutActions(classNode, methodInfo);\n            }\n        }\n\n        return nextTransformer != null ? nextTransformer.transform(classNode) : classNode;\n    }\n\n    private void transformRuleMethodContainingActions(ParserClassNode classNode, RuleMethodInfo methodInfo) {\n        int actionNr = 1;\n        for (InstructionSubSet subSet : methodInfo.getInstructionSubSets()) {\n            if (subSet.isActionSet) {\n                ActionClassGenerator generator = new ActionClassGenerator(classNode, methodInfo, subSet, actionNr++);\n                generator.defineActionClass();\n                insertActionClassCreation(classNode, methodInfo, subSet, generator.actionType);\n                \n                classNode.actionClassGenerators.add(generator);\n            }\n        }\n    }\n\n    private void insertActionClassCreation(ParserClassNode classNode, RuleMethodInfo methodInfo,\n                                           InstructionSubSet subSet, Type actionType) {\n        InsnList methodInstructions = methodInfo.method.instructions;\n        AbstractInsnNode firstAfterAction = methodInfo.instructionGraphNodes[subSet.lastIndex + 1].instruction;\n\n        // we do not have to remove the action instructions from the rule method as this has already happened\n        // during action class creation, all we have to do is insert the action class creation instructions\n        methodInstructions.insertBefore(firstAfterAction, new TypeInsnNode(NEW, actionType.getInternalName()));\n        methodInstructions.insertBefore(firstAfterAction, new InsnNode(DUP));\n        methodInstructions.insertBefore(firstAfterAction, new VarInsnNode(ALOAD, 0));\n        methodInstructions.insertBefore(firstAfterAction,\n                new MethodInsnNode(INVOKESPECIAL, actionType.getInternalName(), \"<init>\",\n                        \"(\" + classNode.getDescriptor() + \")V\"));\n    }\n\n    private void transformRuleMethodWithoutActions(ParserClassNode classNode, RuleMethodInfo methodInfo) {\n        // replace all method code with a simple call to the super method\n        // we do not just delete the method because its code is later going to wrapped with the caching code\n        InsnList methodInstructions = methodInfo.method.instructions;\n        AbstractInsnNode returnInsn = methodInfo.getReturnNode().instruction;\n\n        // do not delete starting label and linenumber instructions\n        AbstractInsnNode current = methodInstructions.getFirst();\n        while (current.getType() == AbstractInsnNode.LABEL || current.getType() == AbstractInsnNode.LINE) {\n            current = current.getNext();\n        }\n\n        // delete all instructions before the return statement\n        while (current != returnInsn) {\n            AbstractInsnNode next = current.getNext();\n            methodInstructions.remove(current);\n            current = next;\n        }\n\n        // insert the call to the super method\n        methodInstructions.insertBefore(returnInsn, new VarInsnNode(ALOAD, 0));\n        methodInstructions.insertBefore(returnInsn, new MethodInsnNode(INVOKESPECIAL, classNode.getParentType()\n                .getInternalName(), methodInfo.method.name, \"()\" + AsmUtils.RULE_TYPE.getDescriptor()));\n    }\n\n}\n\n","Smelly Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.asm;\n\nimport org.objectweb.asm.Opcodes;\nimport org.objectweb.asm.Type;\nimport org.objectweb.asm.tree.*;\n\npublic class RuleMethodTransformer implements ClassTransformer, Opcodes {\n\n    private final ClassTransformer nextTransformer;\n\n    public RuleMethodTransformer(ClassTransformer nextTransformer) {\n        this.nextTransformer = nextTransformer;\n    }\n\n    public Class<?> transform(ParserClassNode classNode) throws Exception {\n        for (RuleMethodInfo methodInfo : classNode.methodInfos) {\n            if (methodInfo.hasActions()) {\n                transformRuleMethodContainingActions(classNode, methodInfo);\n            } else {\n                transformRuleMethodWithoutActions(classNode, methodInfo);\n            }\n        }\n\n        return nextTransformer != null ? nextTransformer.transform(classNode) : null;\n    }\n\n    private void transformRuleMethodContainingActions(ParserClassNode classNode, RuleMethodInfo methodInfo) {\n        int actionNr = 1;\n        for (InstructionSubSet subSet : methodInfo.getInstructionSubSets()) {\n            if (subSet.isActionSet) {\n                Type actionType =\n                        new ActionClassGenerator(classNode, methodInfo, subSet, actionNr++).defineActionClass();\n                insertActionClassCreation(classNode, methodInfo, subSet, actionType);\n            }\n        }\n    }\n\n    private void insertActionClassCreation(ParserClassNode classNode, RuleMethodInfo methodInfo,\n                                           InstructionSubSet subSet, Type actionType) {\n        InsnList methodInstructions = methodInfo.method.instructions;\n        AbstractInsnNode firstAfterAction = methodInfo.instructionGraphNodes[subSet.lastIndex + 1].instruction;\n\n        // we do not have to remove the action instructions from the rule method as this has already happened\n        // during action class creation, all we have to do is insert the action class creation instructions\n        methodInstructions.insertBefore(firstAfterAction, new TypeInsnNode(NEW, actionType.getInternalName()));\n        methodInstructions.insertBefore(firstAfterAction, new InsnNode(DUP));\n        methodInstructions.insertBefore(firstAfterAction, new VarInsnNode(ALOAD, 0));\n        methodInstructions.insertBefore(firstAfterAction,\n                new MethodInsnNode(INVOKESPECIAL, actionType.getInternalName(), \"<init>\",\n                        \"(\" + classNode.getParentType().getDescriptor() + \")V\"));\n    }\n\n    private void transformRuleMethodWithoutActions(ParserClassNode classNode, RuleMethodInfo methodInfo) {\n        // replace all method code with a simple call to the super method\n        // we do not just delete the method because its code is later going to wrapped with the caching code\n        InsnList methodInstructions = methodInfo.method.instructions;\n        AbstractInsnNode returnInsn = methodInfo.getReturnNode().instruction;\n\n        // do not delete starting label and linenumber instructions\n        AbstractInsnNode current = methodInstructions.getFirst();\n        while (current.getType() == AbstractInsnNode.LABEL || current.getType() == AbstractInsnNode.LINE) {\n            current = current.getNext();\n        }\n\n        // delete all instructions before the return statement\n        while (current != returnInsn) {\n            AbstractInsnNode next = current.getNext();\n            methodInstructions.remove(current);\n            current = next;\n        }\n\n        // insert the call to the super method\n        methodInstructions.insertBefore(returnInsn, new VarInsnNode(ALOAD, 0));\n        methodInstructions.insertBefore(returnInsn, new MethodInsnNode(INVOKESPECIAL, classNode.getParentType()\n                .getInternalName(), methodInfo.method.name, \"()\" + Types.RULE_TYPE.getDescriptor()));\n    }\n\n}\n\n","lineNo":47}
{"Refactored Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.asm;\n\nimport org.objectweb.asm.*;\nimport org.objectweb.asm.tree.*;\nimport org.parboiled.support.Checks;\n\npublic class ActionClassGenerator extends ClassLoader implements Opcodes, Types {\n\n    private final ParserClassNode classNode;\n    private final RuleMethodInfo methodInfo;\n    private final InstructionSubSet subSet;\n    private final String actionSimpleName;\n    private final Type actionType;\n    private final String classNodeTypeDesc;\n    private byte[] code;\n\n    public ActionClassGenerator(ParserClassNode classNode, RuleMethodInfo methodInfo, InstructionSubSet subSet,\n                                int actionNumber) {\n        this.classNode = classNode;\n        this.methodInfo = methodInfo;\n        this.subSet = subSet;\n        this.actionSimpleName = methodInfo.method.name + \"_Action\" + actionNumber;\n        this.actionType = Type.getObjectType(classNode.name + \"$\" + actionSimpleName);\n        this.classNodeTypeDesc = classNode.getType().getDescriptor();\n    }\n\n    public Type defineActionClass() {\n        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n        generateClassBasics(cw);\n        generateConstructor(cw);\n        generateRunMethod(cw);\n        cw.visitEnd();\n\n        code = cw.toByteArray();\n        defineClass(null, code, 0, code.length);\n\n        return actionType;\n    }\n\n    public byte[] getCode() {\n        return code;\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    private void generateClassBasics(ClassWriter cw) {\n        cw.visit(V1_5, ACC_PUBLIC + ACC_SUPER, actionType.getInternalName(), null,\n                ACTION_WRAPPER_BASE_TYPE.getInternalName(), null);\n        cw.visitSource(classNode.sourceFile, null);\n        cw.visitInnerClass(actionType.getInternalName(), classNode.name, actionSimpleName, ACC_PRIVATE);\n        classNode.innerClasses.add(new InnerClassNode(actionType.getInternalName(), classNode.name,\n                actionSimpleName, ACC_PRIVATE));\n        cw.visitField(ACC_FINAL + ACC_SYNTHETIC, \"this$0\", classNodeTypeDesc, null, null).visitEnd();\n    }\n\n    private void generateConstructor(ClassWriter cw) {\n        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"(\" + classNodeTypeDesc + \")V\", null, null);\n        mv.visitCode();\n        mv.visitVarInsn(ALOAD, 0);\n        mv.visitVarInsn(ALOAD, 1);\n        mv.visitFieldInsn(PUTFIELD, actionType.getInternalName(), \"this$0\", classNodeTypeDesc);\n        mv.visitVarInsn(ALOAD, 0);\n        mv.visitMethodInsn(INVOKESPECIAL, ACTION_WRAPPER_BASE_TYPE.getInternalName(), \"<init>\", \"()V\");\n        mv.visitInsn(RETURN);\n        mv.visitMaxs(0, 0); // trigger automatic computing\n        mv.visitEnd();\n    }\n\n    private void generateRunMethod(ClassWriter cw) {\n        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, \"run\", \"()Z\", null, null);\n        mv.visitCode();\n\n        Label l0 = new Label();\n        mv.visitLabel(l0);\n\n        generateRunMethodBody(mv);\n\n        Label l1 = new Label();\n        mv.visitLabel(l1);\n        mv.visitLocalVariable(\"this\", actionType.getDescriptor(), null, l0, l1, 0);\n        mv.visitMaxs(0, 0); // trigger automatic computing\n        mv.visitEnd();\n    }\n\n    @SuppressWarnings({\"UnnecessaryContinue\"})\n    private void generateRunMethodBody(MethodVisitor mv) {\n        InsnList runMethodInstructions = new InsnList();\n\n        // move action instructions from method instruction list into the list of runMethodInstructions\n        InsnList ruleMethodInstructions = methodInfo.method.instructions;\n        for (int i = subSet.firstIndex; i <= subSet.lastIndex; i++) {\n            AbstractInsnNode insn = methodInfo.instructionGraphNodes[i].instruction;\n            ruleMethodInstructions.remove(insn);\n            runMethodInstructions.add(insn);\n        }\n\n        // work backwards through the old instructions list and apply adaptations to the new list\n        for (int i = subSet.lastIndex; i >= subSet.firstIndex; i--) {\n            InstructionGraphNode node = methodInfo.instructionGraphNodes[i];\n            AbstractInsnNode insn = node.instruction;\n\n            if (insertContextSwitchCode(runMethodInstructions, node)) continue;\n            if (insertSetContextCallBeforeCallsOnContextAware(runMethodInstructions, node)) continue;\n            if (changeThisToInnerClassParent(runMethodInstructions, insn)) continue;\n        }\n\n        // make sure the method result is a \"boolean\" and not a \"Boolean\"\n        if (isBooleanValueOf(runMethodInstructions.getLast())) {\n            // if we are just converting a \"boolean\" into a \"Boolean\" at the end remove the conversion\n            runMethodInstructions.remove(runMethodInstructions.getLast());\n        } else {\n            // convert the \"Boolean\" into the primitive\n            runMethodInstructions.add(new MethodInsnNode(INVOKEVIRTUAL, \"java/lang/Boolean\", \"booleanValue\", \"()Z\"));\n        }\n\n        // write new instructions\n        runMethodInstructions.accept(mv);\n\n        mv.visitInsn(IRETURN);\n    }\n\n    private boolean isBooleanValueOf(AbstractInsnNode insn) {\n        if (insn.getOpcode() != INVOKESTATIC) return false;\n        MethodInsnNode mi = (MethodInsnNode) insn;\n        return \"java/lang/Boolean\".equals(mi.owner) && \"valueOf\".equals(mi.name) &&\n                \"(Z)Ljava/lang/Boolean;\".equals(mi.desc);\n    }\n\n    private boolean insertContextSwitchCode(InsnList newInstructions, InstructionGraphNode node) {\n        if (!node.isContextSwitch) return false;\n\n        String contextSwitchType = ((MethodInsnNode) node.instruction).name;\n\n        // insert context-switching call (UP/DOWN) before first instruction contributing to the argument\n        AbstractInsnNode targetSettingInsn = node.getEarlierstPredecessor().instruction;\n        Checks.ensure(targetSettingInsn.getOpcode() == ALOAD && ((VarInsnNode) targetSettingInsn).var == 0,\n                \"Illegal context switching construct in parser rule method '\" + methodInfo.method.name + \"': \" +\n                        \"UP(...) or DOWN(...) can only be called on the parser instance itself\");\n\n        newInstructions.insert(targetSettingInsn,\n                new MethodInsnNode(INVOKEVIRTUAL, ACTION_WRAPPER_BASE_TYPE.getInternalName(), contextSwitchType, \"()V\")\n        );\n\n        // replace original context-switching call with the opposite one, reversing the context switch done before\n        newInstructions.insertBefore(node.instruction, new VarInsnNode(ALOAD, 0));\n        newInstructions.insertBefore(node.instruction,\n                new MethodInsnNode(INVOKEVIRTUAL, ACTION_WRAPPER_BASE_TYPE.getInternalName(),\n                        \"UP\".equals(contextSwitchType) ? \"DOWN\" : \"UP\", \"()V\")\n        );\n        newInstructions.remove(node.instruction);\n\n        return true;\n    }\n\n    private boolean insertSetContextCallBeforeCallsOnContextAware(InsnList newInstructions, InstructionGraphNode node) {\n        if (!node.isCallOnContextAware) return false;\n\n        AbstractInsnNode firstAfterTargetSettingInsn = node.getEarlierstPredecessor().instruction.getNext();\n        newInstructions.insertBefore(firstAfterTargetSettingInsn, new InsnNode(DUP));\n        newInstructions.insertBefore(firstAfterTargetSettingInsn, new VarInsnNode(ALOAD, 0));\n        newInstructions.insertBefore(firstAfterTargetSettingInsn,\n                new FieldInsnNode(GETFIELD, actionType.getInternalName(), \"context\", CONTEXT_TYPE.getDescriptor()));\n        newInstructions.insertBefore(firstAfterTargetSettingInsn,\n                new MethodInsnNode(INVOKEINTERFACE, CONTEXT_AWARE_TYPE.getInternalName(),\n                        \"setContext\", \"(\" + CONTEXT_TYPE.getDescriptor() + \")V\"));\n\n        return true;\n    }\n\n    private boolean changeThisToInnerClassParent(InsnList newInstructions, AbstractInsnNode insn) {\n        if (insn.getOpcode() != ALOAD || ((VarInsnNode) insn).var != 0) return false;\n        if (insn.getNext() instanceof MethodInsnNode &&\n                ((MethodInsnNode) insn.getNext()).owner.equals(ACTION_WRAPPER_BASE_TYPE.getInternalName())) {\n            // do not change the \"ALOAD 0\" we left in place for a following context switch call\n            return false;\n        }\n\n        newInstructions.insert(insn,\n                new FieldInsnNode(GETFIELD, actionType.getInternalName(), \"this$0\", classNodeTypeDesc)\n        );\n        return true;\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.asm;\n\nimport org.objectweb.asm.*;\nimport org.objectweb.asm.tree.*;\n\npublic class ActionClassGenerator extends ClassLoader implements Opcodes, Types {\n\n    private final ParserClassNode classNode;\n    private final RuleMethodInfo methodInfo;\n    private final InstructionSubSet subSet;\n    private final String actionSimpleName;\n    private final Type actionType;\n    private final String classNodeTypeDesc;\n\n    public ActionClassGenerator(ParserClassNode classNode, RuleMethodInfo methodInfo, InstructionSubSet subSet,\n                                int actionNumber) {\n        this.classNode = classNode;\n        this.methodInfo = methodInfo;\n        this.subSet = subSet;\n        this.actionSimpleName = methodInfo.method.name + \"_Action\" + actionNumber;\n        this.actionType = Type.getObjectType(classNode.name + \"$\" + actionSimpleName);\n        this.classNodeTypeDesc = classNode.getType().getDescriptor();\n    }\n\n    public Type defineActionClass() {\n        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n        generateClassBasics(cw);\n        generateConstructor(cw);\n        generateRunMethod(cw);\n        cw.visitEnd();\n\n        byte[] code = cw.toByteArray();\n        Class<?> actionClass = defineClass(null, code, 0, code.length);\n\n        return actionType;\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    private void generateClassBasics(ClassWriter cw) {\n        cw.visit(V1_5, ACC_PUBLIC + ACC_SUPER, actionType.getInternalName(), null,\n                ACTION_WRAPPER_BASE_TYPE.getInternalName(), null);\n        cw.visitSource(classNode.sourceFile, null);\n        cw.visitInnerClass(actionType.getInternalName(), classNode.name, actionSimpleName, ACC_PRIVATE);\n        classNode.innerClasses.add(new InnerClassNode(actionType.getInternalName(), classNode.name,\n                actionSimpleName, ACC_PRIVATE));\n        cw.visitField(ACC_FINAL + ACC_SYNTHETIC, \"this$0\", classNodeTypeDesc, null, null).visitEnd();\n    }\n\n    private void generateConstructor(ClassWriter cw) {\n        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"(\" + classNodeTypeDesc + \")V\", null, null);\n        mv.visitCode();\n        mv.visitVarInsn(ALOAD, 0);\n        mv.visitVarInsn(ALOAD, 1);\n        mv.visitFieldInsn(PUTFIELD, actionType.getInternalName(), \"this$0\", classNodeTypeDesc);\n        mv.visitVarInsn(ALOAD, 0);\n        mv.visitMethodInsn(INVOKESPECIAL, ACTION_WRAPPER_BASE_TYPE.getInternalName(), \"<init>\", \"()V\");\n        mv.visitInsn(RETURN);\n        mv.visitMaxs(0, 0); // trigger automatic computing\n        mv.visitEnd();\n    }\n\n    private void generateRunMethod(ClassWriter cw) {\n        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, \"run\", Type.BOOLEAN_TYPE.getInternalName(), null, null);\n        mv.visitCode();\n\n        Label l0 = new Label();\n        mv.visitLabel(l0);\n\n        generateRunMethodBody(mv);\n\n        Label l1 = new Label();\n        mv.visitLabel(l1);\n        mv.visitLocalVariable(\"this\", actionType.getDescriptor(), null, l0, l1, 0);\n        mv.visitMaxs(0, 0);\n        mv.visitEnd();\n    }\n\n    private void generateRunMethodBody(MethodVisitor mv) {\n        InsnList newInstructions = new InsnList();\n\n        // initialize with the old instruction list\n        for (int i = subSet.firstIndex; i <= subSet.lastIndex; i++) {\n            newInstructions.add(methodInfo.instructionGraphNodes[i].instruction);\n        }\n\n        // work backwards through the old instructions list and apply adaptations to the new list\n        for (int i = subSet.lastIndex; i >= subSet.firstIndex; i--) {\n            InstructionGraphNode node = methodInfo.instructionGraphNodes[i];\n            AbstractInsnNode insn = node.instruction;\n\n            if (changeThisToInnerClassParent(newInstructions, insn)) continue;\n            if (insertMagicUpDownCode(newInstructions, node)) continue;\n            insertSetContextCallBeforeCallsOnContextAware(newInstructions, node);\n        }\n\n        // write new instructions\n        newInstructions.accept(mv);\n\n        mv.visitInsn(ARETURN);\n    }\n\n    private boolean changeThisToInnerClassParent(InsnList newInstructions, AbstractInsnNode insn) {\n        if (insn.getOpcode() != ALOAD || ((VarInsnNode) insn).var != 0) return false;\n        newInstructions.insertBefore(insn.getNext(),\n                new FieldInsnNode(GETFIELD, actionType.getInternalName(), \"this$0\", classNodeTypeDesc)\n        );\n        return true;\n    }\n\n    private boolean insertMagicUpDownCode(InsnList newInstructions, InstructionGraphNode node) {\n        if (!node.isContextSwitch) return false;\n\n        return true;\n    }\n\n    private boolean insertSetContextCallBeforeCallsOnContextAware(InsnList newInstructions, InstructionGraphNode node) {\n        if (!node.isCallOnContextAware) return false;\n\n        AbstractInsnNode earliestPredecessor = node.getEarlierstPredecessor().instruction;\n        InsnList inserts = new InsnList();\n        inserts.add(new InsnNode(DUP));\n        inserts.add(new VarInsnNode(ALOAD, 0));\n        inserts.add(new FieldInsnNode(GETFIELD, actionType.getInternalName(), \"context\",\n                CONTEXT_TYPE.getDescriptor()));\n        inserts.add(new MethodInsnNode(INVOKEINTERFACE, CONTEXT_AWARE_TYPE.getInternalName(),\n                \"setContext\", \"(\" + CONTEXT_TYPE.getDescriptor() + \")V\"));\n        newInstructions.insert(earliestPredecessor, inserts);\n        return true;\n    }\n\n}\n","lineNo":107}
{"Refactored Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.matchers;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.MatcherContext;\nimport org.parboiled.Rule;\nimport org.parboiled.common.StringUtils;\nimport org.parboiled.common.Utils;\nimport org.parboiled.support.Characters;\nimport org.parboiled.support.Chars;\nimport org.parboiled.support.Checks;\nimport org.parboiled.support.InputLocation;\n\nimport java.util.List;\n\n/**\n * A Matcher trying all of its submatchers in sequence and succeeding when the first submatcher succeeds.\n *\n * @param <V>\n */\npublic class FirstOfMatcher<V> extends AbstractMatcher<V> {\n\n    public FirstOfMatcher(@NotNull Rule[] subRules) {\n        super(subRules);\n    }\n\n    public boolean match(@NotNull MatcherContext<V> context, boolean enforced) {\n        List<Matcher<V>> children = getChildren();\n        int size = children.size();\n        for (int i = 0; i < size; i++) {\n            Matcher<V> matcher = children.get(i);\n\n            InputLocation lastLocation = context.getCurrentLocation();\n            boolean matched = context.runMatcher(matcher, false);\n            if (matched) {\n                if (context.getCurrentLocation() == lastLocation) {\n                    Checks.fail(\"The inner rule of FirstOf rule '%s' must not allow empty matches\", context.getPath());\n                }\n                context.createNode();\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public Characters getStarterChars() {\n        Characters chars = Characters.NONE;\n        for (Matcher matcher : getChildren()) {\n            chars = chars.add(matcher.getStarterChars());\n            Checks.ensure(!chars.contains(Chars.EMPTY),\n                    \"Rule '%s' allows empty matches, unlikely to be correct as a sub rule of a FirstOf-Rule\", matcher);\n        }\n        return chars;\n    }\n\n    public String getExpectedString() {\n        String label = super.getExpectedString();\n        if (!\"firstOf\".equals(label)) return label;\n\n        int count = getChildren().size();\n        if (count == 0) return \"\";\n        if (count == 1) return getChildren().get(0).toString();\n        return StringUtils.join(Utils.subarray(getChildren().toArray(), 0, count - 1), \", \") +\n                \" or \" + getChildren().get(count - 1);\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.matchers;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.support.Characters;\nimport org.parboiled.support.Checks;\nimport org.parboiled.support.Chars;\nimport org.parboiled.support.InputLocation;\nimport org.parboiled.common.StringUtils;\nimport org.parboiled.common.Utils;\nimport org.parboiled.Rule;\nimport org.parboiled.MatcherContext;\n\n/**\n * A Matcher trying all of its submatchers in sequence and succeeding when the first submatcher succeeds.\n * @param <V>\n */\npublic class FirstOfMatcher<V> extends AbstractMatcher<V> {\n\n    public FirstOfMatcher(@NotNull Rule[] subRules) {\n        super(subRules);\n    }\n\n    public boolean match(@NotNull MatcherContext<V> context, boolean enforced) {\n        for (int i = 0; i < getChildren().size(); i++) {\n            Matcher<V> matcher = getChildren().get(i);\n\n            InputLocation lastLocation = context.getCurrentLocation();\n            boolean matched = context.runMatcher(matcher, false);\n            if (matched) {\n                Checks.ensure(context.getCurrentLocation().index > lastLocation.index,\n                    \"The inner rule of FirstOf rule '%s' must not allow empty matches\", context.getPath());\n                context.createNode();\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public Characters getStarterChars() {\n        Characters chars = Characters.NONE;\n        for (Matcher matcher : getChildren()) {\n            chars = chars.add(matcher.getStarterChars());\n            Checks.ensure(!chars.contains(Chars.EMPTY),\n                    \"Rule '%s' allows empty matches, unlikely to be correct as a sub rule of a FirstOf-Rule\", matcher);\n        }\n        return chars;\n    }\n\n    public String getExpectedString() {\n        String label = super.getExpectedString();\n        if (!\"firstOf\".equals(label)) return label;\n        \n        int count = getChildren().size();\n        if (count == 0) return \"\";\n        if (count == 1) return getChildren().get(0).toString();\n        return StringUtils.join(Utils.subarray(getChildren().toArray(), 0, count - 1), \", \") +\n                \" or \" + getChildren().get(count - 1);\n    }\n\n}\n","lineNo":43}
{"Refactored Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.matchers;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.MatcherContext;\nimport org.parboiled.Rule;\nimport org.parboiled.common.StringUtils;\nimport org.parboiled.common.Utils;\nimport org.parboiled.support.Characters;\nimport org.parboiled.support.Chars;\nimport org.parboiled.support.Checks;\nimport org.parboiled.support.InputLocation;\n\nimport java.util.List;\n\n/**\n * A Matcher trying all of its submatchers in sequence and succeeding when the first submatcher succeeds.\n *\n * @param <V>\n */\npublic class FirstOfMatcher<V> extends AbstractMatcher<V> {\n\n    public FirstOfMatcher(@NotNull Rule[] subRules) {\n        super(subRules);\n    }\n\n    public boolean match(@NotNull MatcherContext<V> context, boolean enforced) {\n        List<Matcher<V>> children = getChildren();\n        int size = children.size();\n        for (int i = 0; i < size; i++) {\n            Matcher<V> matcher = children.get(i);\n\n            InputLocation lastLocation = context.getCurrentLocation();\n            boolean matched = context.runMatcher(matcher, false);\n            if (matched) {\n                if (context.getCurrentLocation() == lastLocation) {\n                    Checks.fail(\"The inner rule of FirstOf rule '%s' must not allow empty matches\", context.getPath());\n                }\n                context.createNode();\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public Characters getStarterChars() {\n        Characters chars = Characters.NONE;\n        for (Matcher matcher : getChildren()) {\n            chars = chars.add(matcher.getStarterChars());\n            Checks.ensure(!chars.contains(Chars.EMPTY),\n                    \"Rule '%s' allows empty matches, unlikely to be correct as a sub rule of a FirstOf-Rule\", matcher);\n        }\n        return chars;\n    }\n\n    public String getExpectedString() {\n        String label = super.getExpectedString();\n        if (!\"firstOf\".equals(label)) return label;\n\n        int count = getChildren().size();\n        if (count == 0) return \"\";\n        if (count == 1) return getChildren().get(0).toString();\n        return StringUtils.join(Utils.subarray(getChildren().toArray(), 0, count - 1), \", \") +\n                \" or \" + getChildren().get(count - 1);\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.matchers;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.support.Characters;\nimport org.parboiled.support.Checks;\nimport org.parboiled.support.Chars;\nimport org.parboiled.support.InputLocation;\nimport org.parboiled.common.StringUtils;\nimport org.parboiled.common.Utils;\nimport org.parboiled.Rule;\nimport org.parboiled.MatcherContext;\n\n/**\n * A Matcher trying all of its submatchers in sequence and succeeding when the first submatcher succeeds.\n * @param <V>\n */\npublic class FirstOfMatcher<V> extends AbstractMatcher<V> {\n\n    public FirstOfMatcher(@NotNull Rule[] subRules) {\n        super(subRules);\n    }\n\n    public boolean match(@NotNull MatcherContext<V> context, boolean enforced) {\n        for (int i = 0; i < getChildren().size(); i++) {\n            Matcher<V> matcher = getChildren().get(i);\n\n            InputLocation lastLocation = context.getCurrentLocation();\n            boolean matched = context.runMatcher(matcher, false);\n            if (matched) {\n                Checks.ensure(context.getCurrentLocation().index > lastLocation.index,\n                    \"The inner rule of FirstOf rule '%s' must not allow empty matches\", context.getPath());\n                context.createNode();\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public Characters getStarterChars() {\n        Characters chars = Characters.NONE;\n        for (Matcher matcher : getChildren()) {\n            chars = chars.add(matcher.getStarterChars());\n            Checks.ensure(!chars.contains(Chars.EMPTY),\n                    \"Rule '%s' allows empty matches, unlikely to be correct as a sub rule of a FirstOf-Rule\", matcher);\n        }\n        return chars;\n    }\n\n    public String getExpectedString() {\n        String label = super.getExpectedString();\n        if (!\"firstOf\".equals(label)) return label;\n        \n        int count = getChildren().size();\n        if (count == 0) return \"\";\n        if (count == 1) return getChildren().get(0).toString();\n        return StringUtils.join(Utils.subarray(getChildren().toArray(), 0, count - 1), \", \") +\n                \" or \" + getChildren().get(count - 1);\n    }\n\n}\n","lineNo":44}
{"Refactored Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.matchers;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.support.Characters;\nimport org.parboiled.support.Chars;\nimport org.parboiled.Rule;\nimport org.parboiled.MatcherContext;\n\nimport java.util.List;\n\n/**\n * A Matcher that executes all of its sub matcher in sequence and only succeeds, if all sub matchers succeed.\n * @param <V>\n */\npublic class SequenceMatcher<V> extends AbstractMatcher<V> implements FollowMatcher<V> {\n\n    private final boolean enforced;\n\n    public SequenceMatcher(@NotNull Rule[] subRules, boolean enforced) {\n        super(subRules);\n        this.enforced = enforced;\n    }\n\n    public boolean match(@NotNull MatcherContext<V> context, boolean enforced) {\n        List<Matcher<V>> children = getChildren();\n        int size = children.size();\n        for (int i = 0; i < size; i++) {\n            Matcher<V> matcher = children.get(i);\n\n            // remember the current index in the context, so we can access it for building the current follower set\n            context.setTag(i);\n\n            boolean matched = context.runMatcher(matcher, enforced || (this.enforced && i > 0));\n            if (!matched) return false;\n        }\n        context.createNode();\n        return true;\n    }\n\n    public Characters getStarterChars() {\n        return getStarterChars(0);\n    }\n\n    private Characters getStarterChars(int startIndex) {\n        Characters chars = Characters.ONLY_EMPTY;\n        for (int i = startIndex; i < getChildren().size(); i++) {\n            Characters matcherStarters = getChildren().get(i).getStarterChars();\n            chars = chars.add(matcherStarters);\n            if (!matcherStarters.contains(Chars.EMPTY)) return chars.remove(Chars.EMPTY);\n        }\n        return chars;\n    }\n\n    public Characters getFollowerChars(MatcherContext<V> context) {\n        int currentIndex = (Integer) context.getTag();\n        return getStarterChars(currentIndex + 1);\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.matchers;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.support.Characters;\nimport org.parboiled.support.Chars;\nimport org.parboiled.Rule;\nimport org.parboiled.MatcherContext;\n\nimport java.util.List;\n\n/**\n * A Matcher that executes all of its sub matcher in sequence and only succeeds, if all sub matchers succeed.\n * @param <V>\n */\npublic class SequenceMatcher<V> extends AbstractMatcher<V> implements FollowMatcher<V> {\n\n    private final boolean enforced;\n\n    public SequenceMatcher(@NotNull Rule[] subRules, boolean enforced) {\n        super(subRules);\n        this.enforced = enforced;\n    }\n\n    public boolean match(@NotNull MatcherContext<V> context, boolean enforced) {\n        List<Matcher<V>> children = getChildren();\n        for (int i = 0; i < children.size(); i++) {\n            Matcher<V> matcher = children.get(i);\n\n            // remember the current index in the context, so we can access it for building the current follower set\n            context.setTag(i);\n\n            boolean matched = context.runMatcher(matcher, enforced || (this.enforced && i > 0));\n            if (!matched) return false;\n        }\n        context.createNode();\n        return true;\n    }\n\n    public Characters getStarterChars() {\n        return getStarterChars(0);\n    }\n\n    private Characters getStarterChars(int startIndex) {\n        Characters chars = Characters.ONLY_EMPTY;\n        for (int i = startIndex; i < getChildren().size(); i++) {\n            Characters matcherStarters = getChildren().get(i).getStarterChars();\n            chars = chars.add(matcherStarters);\n            if (!matcherStarters.contains(Chars.EMPTY)) return chars.remove(Chars.EMPTY);\n        }\n        return chars;\n    }\n\n    public Characters getFollowerChars(MatcherContext<V> context) {\n        int currentIndex = (Integer) context.getTag();\n        return getStarterChars(currentIndex + 1);\n    }\n\n}\n","lineNo":42}
{"Refactored Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.trees;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.common.Formatter;\nimport org.parboiled.common.Function;\n\nimport java.util.Collection;\nimport java.util.HashSet;\n\n/**\n * General utility methods for operating on directed graphs (consisting of GraphNodes).\n */\npublic class GraphUtils {\n\n    private GraphUtils() {}\n\n    /**\n     * Returns true if this node is not null and has at least one child node.\n     *\n     * @param node a node\n     * @return true if this node is not null and has at least one child node.\n     */\n    public static boolean hasChildren(GraphNode<?> node) {\n        return node != null && !node.getChildren().isEmpty();\n    }\n\n    /**\n     * Returns the first child node of the given node or null if node is null or does not have any children.\n     *\n     * @param node a node\n     * @return the first child node of the given node or null if node is null or does not have any children\n     */\n    public static <T extends GraphNode<T>> T getFirstChild(T node) {\n        return hasChildren(node) ? node.getChildren().get(0) : null;\n    }\n\n    /**\n     * Returns the last child node of the given node or null if node is null or does not have any children.\n     *\n     * @param node a node\n     * @return the last child node of the given node or null if node is null or does not have any children\n     */\n    public static <T extends GraphNode<T>> T getLastChild(T node) {\n        return hasChildren(node) ? node.getChildren().get(node.getChildren().size() - 1) : null;\n    }\n\n    /**\n     * Counts all distinct nodes in the graph reachable from the given node.\n     * This method can properly deal with cycles in the graph.\n     *\n     * @param node the root node\n     * @return the number of distinct nodes\n     */\n    public static <T extends GraphNode<T>> int countAllDistinct(T node) {\n        if (node == null) return 0;\n        return collectAllNodes(node, new HashSet<T>()).size();\n    }\n\n    /**\n     * Collects all nodes from the graph reachable from the given node in the given collection.\n     * This method can properly deal with cycles in the graph.\n     *\n     * @param node       the root node\n     * @param collection the collection to collect into\n     * @return the same collection passed as a parameter\n     */\n    @NotNull\n    public static <T extends GraphNode<T>, C extends Collection<T>> C collectAllNodes(T node, @NotNull C collection) {\n        // we don't recurse if the collecion already contains the node\n        // this costs a bit of performance but prevents infinite recursion in the case of graph cycles\n        if (node != null && !collection.contains(node)) {\n            collection.add(node);\n            for (T child : node.getChildren()) {\n                collectAllNodes(child, collection);\n            }\n        }\n        return collection;\n    }\n\n    /**\n     * Creates a string representation of the graph reachable from the given node using the given formatter.\n     *\n     * @param node      the root node\n     * @param formatter the node formatter\n     * @return a new string\n     */\n    public static <T extends GraphNode<T>> String printTree(T node, @NotNull Formatter<T> formatter) {\n        return printTree(node, formatter, null);\n    }\n\n    /**\n     * Creates a string representation of the graph reachable from the given node using the given formatter.\n     * If a non-null filter function is given its result is used to determine whether a particular node is\n     * print and/or its subtree printed.\n     *\n     * @param node      the root node\n     * @param formatter the node formatter\n     * @param filter    optional node filter selecting the nodes to descend into for tree printing\n     * @return a new string\n     */\n    public static <T extends GraphNode<T>> String printTree(T node, @NotNull Formatter<T> formatter,\n                                                            Function<T, Printability> filter) {\n        return node == null ? \"\" : printTree(node, formatter, \"\", new StringBuilder(), filter).toString();\n    }\n\n    // private recursion helper\n    private static <T extends GraphNode<T>> StringBuilder printTree(T node, Formatter<T> formatter,\n                                                                    String indent, StringBuilder sb,\n                                                                    Function<T, Printability> filter) {\n        Printability printability = filter != null ? filter.apply(node) : Printability.PrintAndDescend;\n        if (printability == Printability.PrintAndDescend || printability == Printability.Print) {\n            String line = formatter.format(node);\n            if (line != null) {\n                sb.append(indent).append(line).append(\"\\n\");\n                indent += \"    \";\n            }\n        }\n        if ((printability == Printability.PrintAndDescend || printability == Printability.Descend) &&\n                hasChildren(node)) {\n            for (T sub : node.getChildren()) {\n                printTree(sub, formatter, indent, sb, filter);\n            }\n        }\n        return sb;\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.trees;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.common.Formatter;\nimport org.parboiled.common.Predicate;\n\nimport java.util.Collection;\nimport java.util.HashSet;\n\n/**\n * General utility methods for operating on directed graphs (consisting of GraphNodes).\n */\npublic class GraphUtils {\n\n    private GraphUtils() {}\n\n    /**\n     * Returns true if this node is not null and has at least one child node.\n     *\n     * @param node a node\n     * @return true if this node is not null and has at least one child node.\n     */\n    public static boolean hasChildren(GraphNode<?> node) {\n        return node != null && !node.getChildren().isEmpty();\n    }\n\n    /**\n     * Returns the first child node of the given node or null if node is null or does not have any children.\n     *\n     * @param node a node\n     * @return the first child node of the given node or null if node is null or does not have any children\n     */\n    public static <T extends GraphNode<T>> T getFirstChild(T node) {\n        return hasChildren(node) ? node.getChildren().get(0) : null;\n    }\n\n    /**\n     * Returns the last child node of the given node or null if node is null or does not have any children.\n     *\n     * @param node a node\n     * @return the last child node of the given node or null if node is null or does not have any children\n     */\n    public static <T extends GraphNode<T>> T getLastChild(T node) {\n        return hasChildren(node) ? node.getChildren().get(node.getChildren().size() - 1) : null;\n    }\n\n    /**\n     * Counts all distinct nodes in the graph reachable from the given node.\n     * This method can properly deal with cycles in the graph.\n     *\n     * @param node the root node\n     * @return the number of distinct nodes\n     */\n    public static <T extends GraphNode<T>> int countAllDistinct(T node) {\n        if (node == null) return 0;\n        return collectAllNodes(node, new HashSet<T>()).size();\n    }\n\n    /**\n     * Collects all nodes from the graph reachable from the given node in the given collection.\n     * This method can properly deal with cycles in the graph.\n     *\n     * @param node       the root node\n     * @param collection the collection to collect into\n     * @return the same collection passed as a parameter\n     */\n    @NotNull\n    public static <T extends GraphNode<T>, C extends Collection<T>> C collectAllNodes(T node, @NotNull C collection) {\n        // we don't recurse if the collecion already contains the node\n        // this costs a bit of performance but prevents infinite recursion in the case of graph cycles\n        if (node != null && !collection.contains(node)) {\n            collection.add(node);\n            for (T child : node.getChildren()) {\n                collectAllNodes(child, collection);\n            }\n        }\n        return collection;\n    }\n\n    /**\n     * Creates a string representation of the graph reachable from the given node using the given formatter.\n     *\n     * @param node      the root node\n     * @param formatter the node formatter\n     * @return a new string\n     */\n    public static <T extends GraphNode<T>> String printTree(T node, @NotNull Formatter<T> formatter) {\n        return printTree(node, formatter, null);\n    }\n\n    /**\n     * Creates a string representation of the graph reachable from the given node using the given formatter.\n     * If a non-null descendIntofilter is given only nodes the filter evaluates to true for are descended into.\n     * This is useful for preventing the printing of certain (e.g. trivial) tree branches at a certain height.\n     *\n     * @param node              the root node\n     * @param formatter         the node formatter\n     * @param descendIntofilter optional node filter selecting the nodes to descend into for tree printing\n     * @return a new string\n     */\n    public static <T extends GraphNode<T>> String printTree(T node, @NotNull Formatter<T> formatter,\n                                                            Predicate<GraphNode<T>> descendIntofilter) {\n        return node == null ? \"\" : printTree(node, formatter, \"\", new StringBuilder(), descendIntofilter).toString();\n    }\n\n    // private recursion helper\n    private static <T extends GraphNode<T>> StringBuilder printTree(T node, Formatter<T> formatter,\n                                                                    String indent, StringBuilder sb,\n                                                                    Predicate<GraphNode<T>> descendIntofilter) {\n        String line = formatter.format(node);\n        if (line != null) {\n            sb.append(indent).append(line).append(\"\\n\");\n            indent += \"    \";\n        }\n        if (hasChildren(node) && (descendIntofilter == null || descendIntofilter.apply(node))) {\n            for (T sub : node.getChildren()) {\n                printTree(sub, formatter, indent, sb, descendIntofilter);\n            }\n        }\n        return sb;\n    }\n\n}\n","lineNo":126}
{"Refactored Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.matchers;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.support.Characters;\nimport org.parboiled.support.Chars;\nimport org.parboiled.support.Checks;\nimport org.parboiled.support.InputLocation;\nimport org.parboiled.Rule;\nimport org.parboiled.MatcherContext;\n\n/**\n * A Matcher that repeatedly tries its sub matcher against the input. Succeeds if its sub matcher succeeds at least once.\n * @param <V>\n */\npublic class OneOrMoreMatcher<V> extends AbstractMatcher<V> implements FollowMatcher<V> {\n\n    public OneOrMoreMatcher(@NotNull Rule subRule) {\n        super(subRule);\n    }\n\n    public boolean match(@NotNull MatcherContext<V> context, boolean enforced) {\n        Matcher<V> matcher = getChildren().get(0);\n\n        boolean matched = context.runMatcher(matcher, enforced);\n        if (!matched) return false;\n\n        // collect all further matches as well\n        InputLocation lastLocation = context.getCurrentLocation();\n        while (context.runMatcher(matcher, false)) {\n            InputLocation currentLocation = context.getCurrentLocation();\n            Checks.ensure(currentLocation.index > lastLocation.index,\n                    \"The inner rule of OneOrMore rule '%s' must not allow empty matches\", context.getPath());\n            lastLocation = currentLocation;\n        }\n\n        context.createNode();\n        return true;\n    }\n\n    public Characters getStarterChars() {\n        Matcher<V> matcher = getChildren().get(0);\n        Characters chars = matcher.getStarterChars();\n        Checks.ensure(!chars.contains(Chars.EMPTY),\n                \"Rule '%s' must not allow empty matches as sub-rule of an OneOrMore-rule\", matcher);\n        return chars;\n    }\n\n    public Characters getFollowerChars(MatcherContext<V> context) {\n        // since this call is only legal when we are currently within a match of our sub matcher,\n        // i.e. the submatcher can either match once more or the repetition can legally terminate which means\n        // our follower set addition is incomplete -> add EMPTY\n        return getStarterChars().add(Chars.EMPTY);\n    }\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.matchers;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.support.Characters;\nimport org.parboiled.support.Chars;\nimport org.parboiled.support.Checks;\nimport org.parboiled.support.InputLocation;\nimport org.parboiled.Rule;\nimport org.parboiled.MatcherContext;\n\n/**\n * A Matcher that repeatedly tries its sub matcher against the input. Succeeds if its sub matcher succeeds at least once.\n * @param <V>\n */\npublic class OneOrMoreMatcher<V> extends AbstractMatcher<V> implements FollowMatcher<V> {\n\n    public OneOrMoreMatcher(@NotNull Rule subRule) {\n        super(subRule);\n    }\n\n    public boolean match(@NotNull MatcherContext<V> context, boolean enforced) {\n        Matcher<V> matcher = getChildren().get(0);\n\n        boolean matched = context.runMatcher(matcher, enforced);\n        if (!matched) return false;\n\n        // collect all further matches as well\n        InputLocation lastLocation = context.getCurrentLocation();\n        while (context.runMatcher(matcher, false)) {\n            InputLocation currentLocation = context.getCurrentLocation();\n            Checks.ensure(currentLocation.index > lastLocation.index,\n                    \"The inner rule of OneOrMore rule '%s' must not allow empty matches\", context.getPath());\n            lastLocation = currentLocation;\n        }\n\n        context.createNode();\n        return true;\n    }\n\n    public Characters getStarterChars() {\n        Characters chars = getChildren().get(0).getStarterChars();\n        Checks.ensure(!chars.contains(Chars.EMPTY), \"Sub rule of an OneOrMore-rule must not allow empty matches\");\n        return chars;\n    }\n\n    public Characters getFollowerChars(MatcherContext<V> context) {\n        // since this call is only legal when we are currently within a match of our sub matcher,\n        // i.e. the submatcher can either match once more or the repetition can legally terminate which means\n        // our follower set addition is incomplete -> add EMPTY\n        return getStarterChars().add(Chars.EMPTY);\n    }\n}\n","lineNo":57}
{"Refactored Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.matchers;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.MatcherContext;\nimport org.parboiled.Rule;\nimport org.parboiled.support.Characters;\nimport org.parboiled.support.Chars;\nimport org.parboiled.support.Checks;\nimport org.parboiled.support.InputLocation;\n\n/**\n * A special Matcher not actually matching any input but rather trying its sub matcher against the current input\n * position. Succeeds if the sub matcher would succeed (not inverted) or fail (inverted).\n *\n * @param <V>\n */\npublic class TestMatcher<V> extends AbstractMatcher<V> {\n\n    private final boolean inverted;\n\n    public TestMatcher(@NotNull Rule subRule, boolean inverted) {\n        super(subRule);\n        this.inverted = inverted;\n    }\n\n    @Override\n    public String getLabel() {\n        return hasLabel() ? super.getLabel() : (inverted ? \"!(\" : \"&(\") + getChildren().get(0) + \")\";\n    }\n\n    public boolean match(@NotNull MatcherContext<V> context, boolean enforced) {\n        Matcher<V> matcher = getChildren().get(0);\n\n        // we run the test matcher in a detached context as it is not to affect the parse tree being built\n        // i.e. the test matcher never generates a parse tree node\n        MatcherContext<V> tempContext = context.createCopy(null, matcher);\n        InputLocation lastLocation = tempContext.getCurrentLocation();\n        boolean matched = tempContext.runMatcher(matcher, enforced && !inverted);\n        Checks.ensure(!matched || tempContext.getCurrentLocation().index > lastLocation.index,\n                    \"The inner rule of Test/TestNot rule '%s' must not allow empty matches\", context.getPath());\n\n        return inverted ? !matched : matched;\n    }\n\n    public Characters getStarterChars() {\n        Matcher<V> matcher = getChildren().get(0);\n        Characters characters = matcher.getStarterChars();\n        Checks.ensure(!characters.contains(Chars.EMPTY),\n                \"Rule '%s' allows empty matches, unlikely to be correct as a sub rule of a Test/TestNot-Rule\", matcher);\n        return inverted ? Characters.ALL_EXCEPT_EMPTY.remove(characters) : characters;\n    }\n\n    @Override\n    public String getExpectedString() {\n        return (inverted ? \"not \" : \"\") + getChildren().get(0).getExpectedString();\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.matchers;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.support.Characters;\nimport org.parboiled.Rule;\nimport org.parboiled.MatcherContext;\n\n/**\n * A special Matcher not actually matching any input but rather trying its sub matcher against the current input\n * position. Succeeds if the sub matcher would succeed (not inverted) or fail (inverted).\n * @param <V>\n */\npublic class TestMatcher<V> extends AbstractMatcher<V> {\n\n    private final boolean inverted;\n\n    public TestMatcher(@NotNull Rule subRule, boolean inverted) {\n        super(subRule);\n        this.inverted = inverted;\n    }\n\n    @Override\n    public String getLabel() {\n        return hasLabel() ? super.getLabel() : (inverted ? \"!(\" : \"&(\") + getChildren().get(0) + \")\";\n    }\n\n    public boolean match(@NotNull MatcherContext<V> context, boolean enforced) {\n        Matcher<V> matcher = getChildren().get(0);\n\n        // we run the test matcher in a detached context as it is not to affect the parse tree being built\n        // i.e. the test matcher never generates a parse tree node\n        MatcherContext<V> tempContext = context.createCopy(null, matcher);\n        boolean matched = tempContext.runMatcher(matcher, enforced && !inverted);\n\n        return inverted ? !matched : matched;\n    }\n\n    public Characters getStarterChars() {\n        Characters characters = getChildren().get(0).getStarterChars();\n        return inverted ? Characters.ALL_EXCEPT_EMPTY.remove(characters) : characters;\n    }\n\n    @Override\n    public String getExpectedString() {\n        return (inverted ? \"not \" : \"\") + getChildren().get(0).getExpectedString();\n    }\n\n}\n","lineNo":62}
{"Refactored Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.matchers;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.support.Characters;\nimport org.parboiled.support.Chars;\nimport org.parboiled.support.Checks;\nimport org.parboiled.support.InputLocation;\nimport org.parboiled.Rule;\nimport org.parboiled.MatcherContext;\n\n/**\n * A Matcher that repeatedly tries its sub matcher against the input. Always succeeds.\n * @param <V>\n */\npublic class ZeroOrMoreMatcher<V> extends AbstractMatcher<V> implements FollowMatcher<V> {\n\n    public ZeroOrMoreMatcher(@NotNull Rule subRule) {\n        super(subRule);\n    }\n\n    public boolean match(@NotNull MatcherContext<V> context, boolean enforced) {\n        Matcher<V> matcher = getChildren().get(0);\n\n        InputLocation lastLocation = context.getCurrentLocation();\n        while (context.runMatcher(matcher, false)) {\n            InputLocation currentLocation = context.getCurrentLocation();\n            Checks.ensure(currentLocation.index > lastLocation.index,\n                    \"The inner rule of ZeroOrMore rule '%s' must not allow empty matches\", context.getPath());\n            lastLocation = currentLocation;\n        }\n\n        context.createNode();\n        return true;\n    }\n\n    public Characters getStarterChars() {\n        Matcher<V> matcher = getChildren().get(0);\n        Characters chars = matcher.getStarterChars();\n        Checks.ensure(!chars.contains(Chars.EMPTY),\n                \"Rule '%s' must not allow empty matches as sub-rule of a ZeroOrMore-rule\", matcher);\n        return chars;\n    }\n\n    public Characters getFollowerChars(MatcherContext<V> context) {\n        return getStarterChars().add(Chars.EMPTY);\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.matchers;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.support.Characters;\nimport org.parboiled.support.Chars;\nimport org.parboiled.support.Checks;\nimport org.parboiled.support.InputLocation;\nimport org.parboiled.Rule;\nimport org.parboiled.MatcherContext;\n\n/**\n * A Matcher that repeatedly tries its sub matcher against the input. Always succeeds.\n * @param <V>\n */\npublic class ZeroOrMoreMatcher<V> extends AbstractMatcher<V> implements FollowMatcher<V> {\n\n    public ZeroOrMoreMatcher(@NotNull Rule subRule) {\n        super(subRule);\n    }\n\n    public boolean match(@NotNull MatcherContext<V> context, boolean enforced) {\n        Matcher<V> matcher = getChildren().get(0);\n\n        InputLocation lastLocation = context.getCurrentLocation();\n        while (context.runMatcher(matcher, false)) {\n            InputLocation currentLocation = context.getCurrentLocation();\n            Checks.ensure(currentLocation.index > lastLocation.index,\n                    \"The inner rule of ZeroOrMore rule '%s' must not allow empty matches\", context.getPath());\n            lastLocation = currentLocation;\n        }\n\n        context.createNode();\n        return true;\n    }\n\n    public Characters getStarterChars() {\n        Characters chars = getChildren().get(0).getStarterChars();\n        Checks.ensure(!chars.contains(Chars.EMPTY), \"Sub rule of an ZeroOrMore-rule must not allow empty matches\");\n        return chars;\n    }\n\n    public Characters getFollowerChars(MatcherContext<V> context) {\n        return getStarterChars().add(Chars.EMPTY);\n    }\n\n}\n","lineNo":53}
{"Refactored Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled;\n\nimport net.sf.cglib.proxy.Callback;\nimport net.sf.cglib.proxy.Factory;\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.actionparameters.*;\nimport static org.parboiled.actionparameters.ActionParameterUtils.mixInParameter;\nimport org.parboiled.common.Converter;\nimport org.parboiled.common.Preconditions;\nimport org.parboiled.common.Utils;\nimport static org.parboiled.common.Utils.arrayOf;\nimport org.parboiled.matchers.*;\nimport org.parboiled.support.*;\n\nimport java.util.*;\n\n/**\n * Base class for custom parsers. Defines basic methods for rule and action parameter creation.\n *\n * @param <V> The type of the value field of the parse tree nodes created by this parser.\n * @param <A> The type of the parser Actions you would like to use in your rules. If you don't need any parser\n * actions (e.g. for very simple examples) you can just use the Actions<Object> interface directly.\n */\npublic abstract class BaseParser<V, A extends Actions<V>> {\n\n    /**\n     * Cache of frequently used, bottom level rules. Per default used for character and string matching rules.\n     */\n    private final Map<Object, Rule> ruleCache = new HashMap<Object, Rule>();\n\n    /**\n     * The actual type of the V type argument, i.e. the value field of the generated parse tree nodes.\n     */\n    private final Class<V> nodeValueType;\n\n    /**\n     * Stack for action parameters. Used for creation of actual arguments to action methods.\n     */\n    final Stack<ActionParameter> actionParameters = new Stack<ActionParameter>();\n\n    /**\n     * The immutable reference to your parser actions.\n     */\n    public final A actions;\n\n    /**\n     * Constructs a new parser instance without parser actions.\n     */\n    protected BaseParser() {\n        this(null);\n    }\n\n    /**\n     * Constructs a new parser instance using the given actions instance. Note that if the actions instance is not null\n     * it must have been created with {@link Parboiled#createActions(Class, Object[])} )}.\n     *\n     * @param actions the parser actions (can be null)\n     */\n    @SuppressWarnings({\"unchecked\"})\n    protected BaseParser(A actions) {\n        this.actions = actions;\n\n        List<Class<?>> typeArguments = Utils.getTypeArguments(BaseParser.class, getClass());\n        Preconditions.checkState(typeArguments.size() == 2);\n        nodeValueType = (Class<V>) typeArguments.get(0);\n\n        if (actions != null) {\n            verifyActionsObject();\n        }\n    }\n\n    private void verifyActionsObject() {\n        if (actions instanceof Factory) {\n            Callback actionsCallback = ((Factory) actions).getCallback(1);\n            if (actionsCallback instanceof ActionInterceptor) {\n                ActionInterceptor actionInterceptor = (ActionInterceptor) actionsCallback;\n                // signal to the ActionInterceptor that we are in the rule construction phase\n                // by informing it about the parser object instance\n                actionInterceptor.setParser(this);\n                return;\n            }\n        }\n        Checks.fail(\"Illegal Actions instance, please use Parboiled.createActions(...) \" +\n                \"for creating your parser actions object\");\n    }\n\n    /**\n     * Runs the given parser rule against the given input string. Note that the rule must have been created by\n     * a rule creation method of this parser object, which must have been created with\n     * {@link Parboiled#createParser(Class, Object[])}.\n     *\n     * @param rule  the rule\n     * @param input the input string\n     * @return the ParsingResult for the run\n     */\n    @SuppressWarnings({\"unchecked\"})\n    public ParsingResult<V> parse(Rule rule, @NotNull String input) {\n        Checks.ensure(this instanceof Factory && ((Factory) this).getCallback(1) instanceof RuleInterceptor,\n                \"Illegal parser instance, please use Parboiled.createParser(...) for creating this parser\");\n\n        // prepare\n        InputBuffer inputBuffer = new InputBuffer(input);\n        InputLocation startLocation = new InputLocation(inputBuffer);\n        List<ParseError> parseErrors = new ArrayList<ParseError>();\n        Matcher<V> matcher = (Matcher<V>) toRule(rule);\n        MatcherContext<V> context = new MatcherContext<V>(inputBuffer, startLocation, matcher, parseErrors);\n\n        // the matcher tree has already been built, usually immediately before the invocation of this method,\n        // we need to signal to the ActionInterceptor that rule construction is over and all further action\n        // calls should not continue to create ActionCallParameters but actually be \"routed through\" to the\n        // actual action method implementations\n        if (actions != null) {\n            ActionInterceptor actionInterceptor = (ActionInterceptor) ((Factory) actions).getCallback(1);\n            actionInterceptor.setParser(null);\n        }\n\n        // run the actual matcher tree\n        context.runMatcher(true);\n\n        return new ParsingResult<V>(context.getNode(), parseErrors, inputBuffer);\n    }\n\n    ////////////////////////////////// RULE CREATION ///////////////////////////////////\n\n    /**\n     * Explicitly creates a rule matching the given character. Normally you can just specify the character literal\n     * directly in you rule description. However, if you want to not go through {@link #fromCharLiteral(char)},\n     * e.g. because you redefined it, you can also use this wrapper.\n     *\n     * @param c the char to match\n     * @return a new rule\n     */\n    public Rule ch(char c) {\n        return new CharMatcher<V>(c);\n    }\n\n    /**\n     * Explicitly creates a rule matching the given character ignoring the case.\n     *\n     * @param c the char to match independently of its case\n     * @return a new rule\n     */\n    public Rule charIgnoreCase(char c) {\n        return Character.isLetter(c) ? new CharIgnoreCaseMatcher<V>(c) : ch(c);\n    }\n\n    /**\n     * Creates a rule matching a range of characters from cLow to cHigh (both inclusively).\n     *\n     * @param cLow  the start char of the range (inclusively)\n     * @param cHigh the end char of the range (inclusively)\n     * @return a new rule\n     */\n    public Rule charRange(char cLow, char cHigh) {\n        return cLow == cHigh ? ch(cLow) : new CharRangeMatcher<V>(cLow, cHigh);\n    }\n\n    /**\n     * Explicitly creates a rule matching the given string. Normally you can just specify the string literal\n     * directly in you rule description. However, if you want to not go through {@link #fromStringLiteral(String)},\n     * e.g. because you redefined it, you can also use this wrapper.\n     *\n     * @param string the string to match\n     * @return a new rule\n     */\n    public Rule string(String string) {\n        Rule[] matchers = new Rule[string.length()];\n        for (int i = 0; i < string.length(); i++) {\n            char c = string.charAt(i);\n            Rule rule = cached(c);\n            matchers[i] = rule != null ? rule : cache(c, ch(c));\n        }\n        return new SequenceMatcher(matchers, false).label(string);\n    }\n\n    /**\n     * Explicitly creates a rule matching the given string in a case-independent fashion.\n     *\n     * @param string the string to match\n     * @return a new rule\n     */\n    public Rule stringIgnoreCase(String string) {\n        Rule[] matchers = new Rule[string.length()];\n        for (int i = 0; i < string.length(); i++) {\n            char c = string.charAt(i);\n            boolean letter = Character.isLetter(c);\n            Object key = letter ? new IgnoreCaseWrapper(c) : c;\n            Rule rule = cached(key);\n            matchers[i] = rule != null ? rule : cache(key, letter ? charIgnoreCase(c) : ch(c));\n        }\n        return new SequenceMatcher(matchers, false).label(string);\n    }\n\n    /**\n     * Creates a new rule that successively tries all of the given subrules and succeeds when the first one of\n     * its subrules matches. If all subrules fail this rule fails as well.\n     *\n     * @param rule      the first subrule\n     * @param rule2     the second subrule\n     * @param moreRules the other subrules\n     * @return a new rule\n     */\n    public Rule firstOf(Object rule, Object rule2, Object... moreRules) {\n        return new FirstOfMatcher(toRules(arrayOf(rule, arrayOf(rule2, moreRules)))).label(\"firstOf\");\n    }\n\n    /**\n     * Creates a new rule that tries repeated matches of its subrule and succeeds if the subrule matches at least once.\n     * If the subrule does not match at least once this rule fails.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule oneOrMore(Object rule) {\n        return new OneOrMoreMatcher(toRule(rule)).label(\"oneOrMore\");\n    }\n\n    /**\n     * Creates a new rule that tries a match on its subrule and always succeeds, independently of the matching\n     * success of its subrule.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule optional(Object rule) {\n        return new OptionalMatcher(toRule(rule)).label(\"optional\");\n    }\n\n    /**\n     * Creates a new rule that only succeeds if all of its subrule succeed, one after the other.\n     *\n     * @param rule      the first subrule\n     * @param rule2     the second subrule\n     * @param moreRules the other subrules\n     * @return a new rule\n     */\n    public Rule sequence(Object rule, Object rule2, Object... moreRules) {\n        return new SequenceMatcher(toRules(arrayOf(rule, arrayOf(rule2, moreRules))), false).label(\"sequence\");\n    }\n\n    /**\n     * Creates a new rule that only succeeds if all of its subrules succeed, one after the other.\n     * However, after the first subrule has matched all further subrule matches are enforced, i.e. if one of them\n     * fails a ParseError will be created (and error recovery will be tried).\n     *\n     * @param rule      the first subrule\n     * @param rule2     the second subrule\n     * @param moreRules the other subrules\n     * @return a new rule\n     */\n    public Rule enforcedSequence(Object rule, Object rule2, Object... moreRules) {\n        return new SequenceMatcher(toRules(arrayOf(rule, arrayOf(rule2, moreRules))), true).label(\"enforcedSequence\");\n    }\n\n    /**\n     * Creates a new rule that acts as a syntactic predicate, i.e. tests the given subrule against the current\n     * input position without actually matching any characters. Succeeds if the subrule succeeds and fails if the\n     * subrule rails. Since this rule does not actually consume any input it will never create a parse tree node.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule test(Object rule) {\n        return new TestMatcher(toRule(rule), false);\n    }\n\n    /**\n     * Creates a new rule that acts as an inverse syntactic predicate, i.e. tests the given subrule against the current\n     * input position without actually matching any characters. Succeeds if the subrule fails and fails if the\n     * subrule succeeds. Since this rule does not actually consume any input it will never create a parse tree node.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule testNot(Object rule) {\n        return new TestMatcher(toRule(rule), true);\n    }\n\n    /**\n     * Creates a new rule that tries repeated matches of its subrule.\n     * Succeeds always, even if the subrule doesn't match even once.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule zeroOrMore(Object rule) {\n        return new ZeroOrMoreMatcher(toRule(rule)).label(\"zeroOrMore\");\n    }\n\n    /**\n     * Matches the EOI (end of input) character.\n     *\n     * @return a new rule\n     */\n    public Rule eoi() {\n        return ch(Chars.EOI);\n    }\n\n    /**\n     * Matches any character except {@link org.parboiled.support.Chars#EOI}.\n     *\n     * @return a new rule\n     */\n    public Rule any() {\n        return ch(Chars.ANY);\n    }\n\n    /**\n     * Matches nothing and therefore always succeeds.\n     *\n     * @return a new rule\n     */\n    public Rule empty() {\n        return ch(Chars.EMPTY);\n    }\n\n    ////////////////////////////////// ACTION PARAMETERS ///////////////////////////////////\n\n    /**\n     * Changes the context scope of all arguments to the current parent scope.\n     *\n     * @param argument the arguments to change to context for\n     * @return the result of the argument\n     */\n    public <T> T UP(T argument) {\n        actionParameters.add(new UpParameter(mixInParameter(actionParameters, argument)));\n        return null;\n    }\n\n    /**\n     * Changes the context scope of all arguments to the current sub scope. This will only work if this call is\n     * at some level wrapped with one or more {@link #UP(Object)} calls, since the default scope is always at\n     * the bottom of the context chain.\n     *\n     * @param argument the arguments to change to context for\n     * @return the result of the argument\n     */\n    public <T> T DOWN(T argument) {\n        actionParameters.add(new DownParameter(mixInParameter(actionParameters, argument)));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the parse tree node found under the given prefix path.\n     * See {@link ParseTreeUtils#findNodeByPath(org.parboiled.Node, String)} for a description of the path argument.\n     * The path is relative to the current context scope, which can be changed with {@link #UP(Object)} or {@link #DOWN(Object)}.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public Node<V> NODE(String path) {\n        actionParameters.add(new PathNodeParameter(mixInParameter(actionParameters, path)));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to a list of all parse tree nodes found under the given prefix path.\n     * See {@link ParseTreeUtils#findNodeByPath(org.parboiled.Node, String)} )} for a description of the path argument.\n     * The path is relative to the current context scope, which can be changed with {@link #UP(Object)} or {@link #DOWN(Object)}.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public List<Node<V>> NODES(String path) {\n        actionParameters.add(new PathNodesParameter(mixInParameter(actionParameters, path)));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the last node created during this parsing run. This last node\n     * is independent of the current context scope, i.e. {@link #UP(Object)} or {@link #DOWN(Object)} have no influence\n     * on it.\n     *\n     * @return the action parameter\n     */\n    public Node<V> LAST_NODE() {\n        actionParameters.add(new LastNodeParameter());\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the tree value of the current context scope level, i.e.,\n     * if there is an explicitly set value it is returned. Otherwise the last non-null child value, or, if there\n     * is no such value, null.\n     *\n     * @return the action parameter\n     */\n    public V VALUE() {\n        actionParameters.add(new TreeValueParameter<V>(nodeValueType));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the value of the given node.\n     *\n     * @param node the node the get the value from\n     * @return the action parameter\n     */\n    public V VALUE(Node<V> node) {\n        actionParameters.add(new ValueParameter<V>(nodeValueType, mixInParameter(actionParameters, node)));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the value of the node found under the given prefix path.\n     * Equivalent to <code>VALUE(NODE(path))<\/code>.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public V VALUE(String path) {\n        return VALUE(NODE(path));\n    }\n\n    /**\n     * Creates an action parameter that evaluates to a list of the values of all given nodes.\n     *\n     * @param nodes the nodes to get the values from\n     * @return the action parameter\n     */\n    public List<V> VALUES(List<Node<V>> nodes) {\n        actionParameters.add(new ValuesParameter<V>(mixInParameter(actionParameters, nodes)));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to a list of the values of all nodes found under the given prefix path.\n     * Equivalent to <code>VALUES(NODES(path))<\/code>.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public List<V> VALUES(String path) {\n        return VALUES(NODES(path));\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the value of the last node created during this parsing run.\n     * Equivalent to <code>VALUE(LAST_NODE())<\/code>.\n     *\n     * @return the action parameter\n     */\n    public V LAST_VALUE() {\n        return VALUE(LAST_NODE());\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the input text matched by the given parse tree node.\n     *\n     * @param node the parse tree node\n     * @return the action parameter\n     */\n    public String TEXT(Node<V> node) {\n        actionParameters.add(new TextParameter<V>(mixInParameter(actionParameters, node)));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the input text matched by the node found under the given prefix path.\n     * Equivalent to <code>TEXT(NODE(path))<\/code>.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public String TEXT(String path) {\n        return TEXT(NODE(path));\n    }\n\n    /**\n     * Creates an action parameter that evaluates to a list of the input texts matched by all given nodes.\n     *\n     * @param nodes the nodes\n     * @return the action parameter\n     */\n    public List<String> TEXTS(List<Node<V>> nodes) {\n        actionParameters.add(new TextsParameter<V>(mixInParameter(actionParameters, nodes)));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to a list of the input texts matched by of all nodes found\n     * under the given prefix path.\n     * Equivalent to <code>TEXTS(NODES(path))<\/code>.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public List<String> TEXTS(String path) {\n        return TEXTS(NODES(path));\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the input text matched by the last node created during this parsing run.\n     * Equivalent to <code>TEXT(LAST_NODE())<\/code>.\n     *\n     * @return the action parameter\n     */\n    public String LAST_TEXT() {\n        return TEXT(LAST_NODE());\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the first character of the input text matched by the given parse tree node.\n     *\n     * @param node the parse tree node\n     * @return the action parameter\n     */\n    public Character CHAR(Node<V> node) {\n        actionParameters.add(new CharParameter<V>(mixInParameter(actionParameters, node)));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the first character of the input text matched by the node found under the given prefix path.\n     * Equivalent to <code>CHAR(NODE(path))<\/code>.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public Character CHAR(String path) {\n        return CHAR(NODE(path));\n    }\n\n    /**\n     * Creates an action parameter that evaluates to a list of the first characters of the input texts matched by all given nodes.\n     *\n     * @param nodes the nodes\n     * @return the action parameter\n     */\n    public List<Character> CHARS(List<Node<V>> nodes) {\n        actionParameters.add(new CharsParameter<V>(mixInParameter(actionParameters, nodes)));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to a list of the first characters of the input texts matched by of all nodes found\n     * under the given prefix path.\n     * Equivalent to <code>CHARS(NODES(path))<\/code>.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public List<Character> CHARS(String path) {\n        return CHARS(NODES(path));\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the input text matched by the last node created during this parsing run.\n     * Equivalent to <code>CHAR(LAST_NODE())<\/code>.\n     *\n     * @return the action parameter\n     */\n    public Character LAST_CHAR() {\n        return CHAR(LAST_NODE());\n    }\n\n    /**\n     * Creates a special action rule that sets the value of the parse tree node to be created for the current context\n     * scope to the value of the last node created during the current parsing run.\n     * Equivalent to <code>SET(LAST_VALUE())<\/code>.\n     *\n     * @return a new rule\n     */\n    public ActionResult SET() {\n        return SET(LAST_VALUE());\n    }\n\n    /**\n     * Creates a special action rule that sets the value of the parse tree node to be created for the current context\n     * scope to the given value.\n     *\n     * @param value the value to set\n     * @return a new rule\n     */\n    public ActionResult SET(V value) {\n        actionParameters.add(new SetValueParameter<V>(mixInParameter(actionParameters, value), nodeValueType));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to null. You cannot use <b>null<\/b> directly in an action call\n     * expression. Use this method instead.\n     *\n     * @return the action parameter\n     */\n    public Object NULL() {\n        actionParameters.add(new NullParameter());\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to an object using the given converter.\n     *\n     * @param text      the text (parameter) to convert\n     * @param converter the converter to use\n     * @return the action parameter\n     */\n    public <T> T CONVERT(String text, Converter<T> converter) {\n        Object converterArg = mixInParameter(actionParameters, converter);\n        Object textArg = mixInParameter(actionParameters, text);\n        List<Class<?>> convertedTypes = Utils.getTypeArguments(Converter.class, converterArg.getClass());\n        Preconditions.checkArgument(convertedTypes.size() == 1, \"Illegal converter\");\n        actionParameters.add(new ConvertParameter(convertedTypes.get(0), textArg, converterArg));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to an Integer.\n     *\n     * @param text the text (parameter) to convert\n     * @return the action parameter\n     */\n    public Integer CONVERT_TO_INTEGER(String text) {\n        return CONVERT(text, new Converter<Integer>() {\n            public Integer parse(String string) {\n                return Integer.parseInt(string);\n            }\n        });\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to a Long.\n     *\n     * @param text the text (parameter) to convert\n     * @return the action parameter\n     */\n    public Long CONVERT_TO_LONG(String text) {\n        return CONVERT(text, new Converter<Long>() {\n            public Long parse(String string) {\n                return Long.parseLong(string);\n            }\n        });\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to a Float.\n     *\n     * @param text the text (parameter) to convert\n     * @return the action parameter\n     */\n    public Float CONVERT_TO_FLOAT(String text) {\n        return CONVERT(text, new Converter<Float>() {\n            public Float parse(String string) {\n                return Float.parseFloat(string);\n            }\n        });\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to a Double.\n     *\n     * @param text the text (parameter) to convert\n     * @return the action parameter\n     */\n    public Double CONVERT_TO_DOUBLE(String text) {\n        return CONVERT(text, new Converter<Double>() {\n            public Double parse(String string) {\n                return Double.parseDouble(string);\n            }\n        });\n    }\n\n    ///************************* HELPER METHODS ***************************///\n\n    /**\n     * Used internally to convert the given character literal to a parser rule.\n     * You can override this method, e.g. for specifying a sequence that automatically matches all trailing\n     * whitespace after the character.\n     *\n     * @param c the character\n     * @return the rule\n     */\n    protected Rule fromCharLiteral(char c) {\n        return ch(c);\n    }\n\n    /**\n     * Used internally to convert the given string literal to a parser rule.\n     * You can override this method, e.g. for specifying a sequence that automatically matches all trailing\n     * whitespace after the string.\n     *\n     * @param string the string\n     * @return the rule\n     */\n    protected Rule fromStringLiteral(String string) {\n        return string(string);\n    }\n\n    protected Rule cached(Object key) {\n        return ruleCache.get(key);\n    }\n\n    protected Rule cache(Object key, Rule rule) {\n        ruleCache.put(key, rule);\n        return rule;\n    }\n\n    private Rule[] toRules(@NotNull Object[] objects) {\n        Rule[] rules = new Rule[objects.length];\n        for (int i = 0; i < objects.length; i++) {\n            rules[i] = toRule(objects[i]);\n        }\n        return rules;\n    }\n\n    private Rule toRule(Object obj) {\n        obj = mixInParameter(actionParameters, obj);\n        if (obj instanceof Rule) {\n            return (Rule) obj;\n        }\n        if (obj instanceof Character) {\n            Rule rule = cached(obj);\n            return rule != null ? rule : cache(obj, fromCharLiteral((Character) obj));\n        }\n        if (obj instanceof String) {\n            Rule rule = cached(obj);\n            return rule != null ? rule : cache(obj, fromStringLiteral((String) obj));\n        }\n        if (obj instanceof ActionParameter) {\n            return new ActionMatcher((ActionParameter) obj);\n        }\n        throw new ParserConstructionException(\"\\'\" + obj + \"\\' is not a valid Rule or parser action\");\n    }\n\n    /**\n     * Wrapper for rule cache keys that are used for explicit \"ignore-case matchers\"\n     */\n    protected static class IgnoreCaseWrapper {\n        private final Object key;\n\n        public IgnoreCaseWrapper(Object key) {\n            this.key = key;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            return this == o || o instanceof IgnoreCaseWrapper && key.equals(((IgnoreCaseWrapper) o).key);\n        }\n\n        @Override\n        public int hashCode() {\n            return key.hashCode();\n        }\n    }\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled;\n\nimport net.sf.cglib.proxy.Callback;\nimport net.sf.cglib.proxy.Factory;\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.actionparameters.*;\nimport static org.parboiled.actionparameters.ActionParameterUtils.mixInParameter;\nimport org.parboiled.common.Converter;\nimport org.parboiled.common.Preconditions;\nimport org.parboiled.common.Utils;\nimport static org.parboiled.common.Utils.arrayOf;\nimport org.parboiled.matchers.*;\nimport org.parboiled.support.*;\n\nimport java.util.*;\n\n/**\n * Base class for custom parsers. Defines basic methods for rule and action parameter creation.\n *\n * @param <V> The type of the value field of the parse tree nodes created by this parser.\n * @param <A> The type of the parser Actions you would like to use in your rules. If you don't need any parser\n * actions (e.g. for very simple examples) you can just use the Actions<Object> interface directly.\n */\npublic abstract class BaseParser<V, A extends Actions<V>> {\n\n    /**\n     * Cache of frequently used, bottom level rules. Per default used for character and string matching rules.\n     */\n    private final Map<Object, Rule> ruleCache = new HashMap<Object, Rule>();\n\n    /**\n     * The actual type of the V type argument, i.e. the value field of the generated parse tree nodes.\n     */\n    private final Class<V> nodeValueType;\n\n    /**\n     * Stack for action parameters. Used for creation of actual arguments to action methods.\n     */\n    final Stack<ActionParameter> actionParameters = new Stack<ActionParameter>();\n\n    /**\n     * The immutable reference to your parser actions.\n     */\n    public final A actions;\n\n    /**\n     * Constructs a new parser instance without parser actions.\n     */\n    protected BaseParser() {\n        this(null);\n    }\n\n    /**\n     * Constructs a new parser instance using the given actions instance. Note that if the actions instance is not null\n     * it must have been created with {@link Parboiled#createActions(Class, Object[])} )}.\n     *\n     * @param actions the parser actions (can be null)\n     */\n    @SuppressWarnings({\"unchecked\"})\n    protected BaseParser(A actions) {\n        this.actions = actions;\n\n        List<Class<?>> typeArguments = Utils.getTypeArguments(BaseParser.class, getClass());\n        Preconditions.checkState(typeArguments.size() == 2);\n        nodeValueType = (Class<V>) typeArguments.get(0);\n\n        if (actions != null) {\n            verifyActionsObject();\n        }\n    }\n\n    private void verifyActionsObject() {\n        if (actions instanceof Factory) {\n            Callback actionsCallback = ((Factory) actions).getCallback(1);\n            if (actionsCallback instanceof ActionInterceptor) {\n                ActionInterceptor actionInterceptor = (ActionInterceptor) actionsCallback;\n                // signal to the ActionInterceptor that we are in the rule construction phase\n                // by informing it about the parser object instance\n                actionInterceptor.setParser(this);\n                return;\n            }\n        }\n        Checks.fail(\"Illegal Actions instance, please use Parboiled.createActions(...) \" +\n                \"for creating your parser actions object\");\n    }\n\n    /**\n     * Runs the given parser rule against the given input string. Note that the rule must have been created by\n     * a rule creation method of this parser object, which must have been created with\n     * {@link Parboiled#createParser(Class, Object[])}.\n     *\n     * @param rule  the rule\n     * @param input the input string\n     * @return the ParsingResult for the run\n     */\n    @SuppressWarnings({\"unchecked\"})\n    public ParsingResult<V> parse(Rule rule, @NotNull String input) {\n        Checks.ensure(this instanceof Factory && ((Factory) this).getCallback(1) instanceof RuleInterceptor,\n                \"Illegal parser instance, please use Parboiled.createParser(...) for creating this parser\");\n\n        // prepare\n        InputBuffer inputBuffer = new InputBuffer(input);\n        InputLocation startLocation = new InputLocation(inputBuffer);\n        List<ParseError> parseErrors = new ArrayList<ParseError>();\n        Matcher<V> matcher = (Matcher<V>) toRule(rule);\n        MatcherContext<V> context = new MatcherContext<V>(inputBuffer, startLocation, matcher, parseErrors);\n\n        // the matcher tree has already been built, usually immediately before the invocation of this method,\n        // we need to signal to the ActionInterceptor that rule construction is over and all further action\n        // calls should not continue to create ActionCallParameters but actually be \"routed through\" to the\n        // actual action method implementations\n        if (actions != null) {\n            ActionInterceptor actionInterceptor = (ActionInterceptor) ((Factory) actions).getCallback(1);\n            actionInterceptor.setParser(null);\n        }\n\n        // run the actual matcher tree\n        context.runMatcher(true);\n\n        return new ParsingResult<V>(context.getNode(), parseErrors, inputBuffer);\n    }\n\n    ////////////////////////////////// RULE CREATION ///////////////////////////////////\n\n    /**\n     * Explicitly creates a rule matching the given character. Normally you can just specify the character literal\n     * directly in you rule description. However, if you want to not go through {@link #fromCharLiteral(char)},\n     * e.g. because you redefined it, you can also use this wrapper.\n     *\n     * @param c the char to match\n     * @return a new rule\n     */\n    public Rule ch(char c) {\n        return new CharMatcher(c);\n    }\n\n    /**\n     * Creates a rule matching a range of characters from cLow to cHigh (both inclusively).\n     *\n     * @param cLow  the start char of the range (inclusively)\n     * @param cHigh the end char of the range (inclusively)\n     * @return a new rule\n     */\n    public Rule charRange(char cLow, char cHigh) {\n        return cLow == cHigh ? ch(cLow) : new CharRangeMatcher(cLow, cHigh);\n    }\n\n    /**\n     * Explicitly creates a rule matching the given string. Normally you can just specify the string literal\n     * directly in you rule description. However, if you want to not go through {@link #fromStringLiteral(String)},\n     * e.g. because you redefined it, you can also use this wrapper.\n     *\n     * @param string the string to match\n     * @return a new rule\n     */\n    public Rule string(String string) {\n        Rule[] matchers = new Rule[string.length()];\n        for (int i = 0; i < string.length(); i++) {\n            char c = string.charAt(i);\n            Rule rule = cached(c);\n            matchers[i] = rule != null ? rule : cache(c, ch(c));\n        }\n        return new SequenceMatcher(matchers, false).label(string);\n    }\n\n    /**\n     * Creates a new rule that successively tries all of the given subrules and succeeds when the first one of\n     * its subrules matches. If all subrules fail this rule fails as well.\n     *\n     * @param rule      the first subrule\n     * @param rule2     the second subrule\n     * @param moreRules the other subrules\n     * @return a new rule\n     */\n    public Rule firstOf(Object rule, Object rule2, Object... moreRules) {\n        return new FirstOfMatcher(toRules(arrayOf(rule, arrayOf(rule2, moreRules)))).label(\"firstOf\");\n    }\n\n    /**\n     * Creates a new rule that tries repeated matches of its subrule and succeeds if the subrule matches at least once.\n     * If the subrule does not match at least once this rule fails.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule oneOrMore(Object rule) {\n        return new OneOrMoreMatcher(toRule(rule)).label(\"oneOrMore\");\n    }\n\n    /**\n     * Creates a new rule that tries a match on its subrule and always succeeds, independently of the matching\n     * success of its subrule.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule optional(Object rule) {\n        return new OptionalMatcher(toRule(rule)).label(\"optional\");\n    }\n\n    /**\n     * Creates a new rule that only succeeds if all of its subrule succeed, one after the other.\n     *\n     * @param rule      the first subrule\n     * @param rule2     the second subrule\n     * @param moreRules the other subrules\n     * @return a new rule\n     */\n    public Rule sequence(Object rule, Object rule2, Object... moreRules) {\n        return new SequenceMatcher(toRules(arrayOf(rule, arrayOf(rule2, moreRules))), false).label(\"sequence\");\n    }\n\n    /**\n     * Creates a new rule that only succeeds if all of its subrules succeed, one after the other.\n     * However, after the first subrule has matched all further subrule matches are enforced, i.e. if one of them\n     * fails a ParseError will be created (and error recovery will be tried).\n     *\n     * @param rule      the first subrule\n     * @param rule2     the second subrule\n     * @param moreRules the other subrules\n     * @return a new rule\n     */\n    public Rule enforcedSequence(Object rule, Object rule2, Object... moreRules) {\n        return new SequenceMatcher(toRules(arrayOf(rule, arrayOf(rule2, moreRules))), true).label(\"enforcedSequence\");\n    }\n\n    /**\n     * Creates a new rule that acts as a syntactic predicate, i.e. tests the given subrule against the current\n     * input position without actually matching any characters. Succeeds if the subrule succeeds and fails if the\n     * subrule rails. Since this rule does not actually consume any input it will never create a parse tree node.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule test(Object rule) {\n        return new TestMatcher(toRule(rule), false);\n    }\n\n    /**\n     * Creates a new rule that acts as an inverse syntactic predicate, i.e. tests the given subrule against the current\n     * input position without actually matching any characters. Succeeds if the subrule fails and fails if the\n     * subrule succeeds. Since this rule does not actually consume any input it will never create a parse tree node.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule testNot(Object rule) {\n        return new TestMatcher(toRule(rule), true);\n    }\n\n    /**\n     * Creates a new rule that tries repeated matches of its subrule.\n     * Succeeds always, even if the subrule doesn't match even once.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule zeroOrMore(Object rule) {\n        return new ZeroOrMoreMatcher(toRule(rule)).label(\"zeroOrMore\");\n    }\n\n    /**\n     * Matches the EOI (end of input) character.\n     *\n     * @return a new rule\n     */\n    public Rule eoi() {\n        return ch(Chars.EOI);\n    }\n\n    /**\n     * Matches any character except {@link org.parboiled.support.Chars#EOI}.\n     *\n     * @return a new rule\n     */\n    public Rule any() {\n        return ch(Chars.ANY);\n    }\n\n    /**\n     * Matches nothing and therefore always succeeds.\n     *\n     * @return a new rule\n     */\n    public Rule empty() {\n        return ch(Chars.EMPTY);\n    }\n\n    ////////////////////////////////// ACTION PARAMETERS ///////////////////////////////////\n\n    /**\n     * Changes the context scope of all arguments to the current parent scope.\n     *\n     * @param argument the arguments to change to context for\n     * @return the result of the argument\n     */\n    public <T> T UP(T argument) {\n        actionParameters.add(new UpParameter(mixInParameter(actionParameters, argument)));\n        return null;\n    }\n\n    /**\n     * Changes the context scope of all arguments to the current sub scope. This will only work if this call is\n     * at some level wrapped with one or more {@link #UP(Object)} calls, since the default scope is always at\n     * the bottom of the context chain.\n     *\n     * @param argument the arguments to change to context for\n     * @return the result of the argument\n     */\n    public <T> T DOWN(T argument) {\n        actionParameters.add(new DownParameter(mixInParameter(actionParameters, argument)));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the parse tree node found under the given prefix path.\n     * See {@link ParseTreeUtils#findNodeByPath(org.parboiled.Node, String)} for a description of the path argument.\n     * The path is relative to the current context scope, which can be changed with {@link #UP(Object)} or {@link #DOWN(Object)}.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public Node<V> NODE(String path) {\n        actionParameters.add(new PathNodeParameter(mixInParameter(actionParameters, path)));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to a list of all parse tree nodes found under the given prefix path.\n     * See {@link ParseTreeUtils#findNodeByPath(org.parboiled.Node, String)} )} for a description of the path argument.\n     * The path is relative to the current context scope, which can be changed with {@link #UP(Object)} or {@link #DOWN(Object)}.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public List<Node<V>> NODES(String path) {\n        actionParameters.add(new PathNodesParameter(mixInParameter(actionParameters, path)));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the last node created during this parsing run. This last node\n     * is independent of the current context scope, i.e. {@link #UP(Object)} or {@link #DOWN(Object)} have no influence\n     * on it.\n     *\n     * @return the action parameter\n     */\n    public Node<V> LAST_NODE() {\n        actionParameters.add(new LastNodeParameter());\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the tree value of the current context scope level, i.e.,\n     * if there is an explicitly set value it is returned. Otherwise the last non-null child value, or, if there\n     * is no such value, null.\n     *\n     * @return the action parameter\n     */\n    public V VALUE() {\n        actionParameters.add(new TreeValueParameter<V>(nodeValueType));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the value of the given node.\n     *\n     * @param node the node the get the value from\n     * @return the action parameter\n     */\n    public V VALUE(Node<V> node) {\n        actionParameters.add(new ValueParameter<V>(nodeValueType, mixInParameter(actionParameters, node)));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the value of the node found under the given prefix path.\n     * Equivalent to <code>VALUE(NODE(path))<\/code>.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public V VALUE(String path) {\n        return VALUE(NODE(path));\n    }\n\n    /**\n     * Creates an action parameter that evaluates to a list of the values of all given nodes.\n     *\n     * @param nodes the nodes to get the values from\n     * @return the action parameter\n     */\n    public List<V> VALUES(List<Node<V>> nodes) {\n        actionParameters.add(new ValuesParameter<V>(mixInParameter(actionParameters, nodes)));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to a list of the values of all nodes found under the given prefix path.\n     * Equivalent to <code>VALUES(NODES(path))<\/code>.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public List<V> VALUES(String path) {\n        return VALUES(NODES(path));\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the value of the last node created during this parsing run.\n     * Equivalent to <code>VALUE(LAST_NODE())<\/code>.\n     *\n     * @return the action parameter\n     */\n    public V LAST_VALUE() {\n        return VALUE(LAST_NODE());\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the input text matched by the given parse tree node.\n     *\n     * @param node the parse tree node\n     * @return the action parameter\n     */\n    public String TEXT(Node<V> node) {\n        actionParameters.add(new TextParameter<V>(mixInParameter(actionParameters, node)));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the input text matched by the node found under the given prefix path.\n     * Equivalent to <code>TEXT(NODE(path))<\/code>.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public String TEXT(String path) {\n        return TEXT(NODE(path));\n    }\n\n    /**\n     * Creates an action parameter that evaluates to a list of the input texts matched by all given nodes.\n     *\n     * @param nodes the nodes\n     * @return the action parameter\n     */\n    public List<String> TEXTS(List<Node<V>> nodes) {\n        actionParameters.add(new TextsParameter<V>(mixInParameter(actionParameters, nodes)));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to a list of the input texts matched by of all nodes found\n     * under the given prefix path.\n     * Equivalent to <code>TEXTS(NODES(path))<\/code>.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public List<String> TEXTS(String path) {\n        return TEXTS(NODES(path));\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the input text matched by the last node created during this parsing run.\n     * Equivalent to <code>TEXT(LAST_NODE())<\/code>.\n     *\n     * @return the action parameter\n     */\n    public String LAST_TEXT() {\n        return TEXT(LAST_NODE());\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the first character of the input text matched by the given parse tree node.\n     *\n     * @param node the parse tree node\n     * @return the action parameter\n     */\n    public Character CHAR(Node<V> node) {\n        actionParameters.add(new CharParameter<V>(mixInParameter(actionParameters, node)));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the first character of the input text matched by the node found under the given prefix path.\n     * Equivalent to <code>CHAR(NODE(path))<\/code>.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public Character CHAR(String path) {\n        return CHAR(NODE(path));\n    }\n\n    /**\n     * Creates an action parameter that evaluates to a list of the first characters of the input texts matched by all given nodes.\n     *\n     * @param nodes the nodes\n     * @return the action parameter\n     */\n    public List<Character> CHARS(List<Node<V>> nodes) {\n        actionParameters.add(new CharsParameter<V>(mixInParameter(actionParameters, nodes)));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to a list of the first characters of the input texts matched by of all nodes found\n     * under the given prefix path.\n     * Equivalent to <code>CHARS(NODES(path))<\/code>.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public List<Character> CHARS(String path) {\n        return CHARS(NODES(path));\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the input text matched by the last node created during this parsing run.\n     * Equivalent to <code>CHAR(LAST_NODE())<\/code>.\n     *\n     * @return the action parameter\n     */\n    public Character LAST_CHAR() {\n        return CHAR(LAST_NODE());\n    }\n\n    /**\n     * Creates a special action rule that sets the value of the parse tree node to be created for the current context\n     * scope to the value of the last node created during the current parsing run.\n     * Equivalent to <code>SET(LAST_VALUE())<\/code>.\n     *\n     * @return a new rule\n     */\n    public ActionResult SET() {\n        return SET(LAST_VALUE());\n    }\n\n    /**\n     * Creates a special action rule that sets the value of the parse tree node to be created for the current context\n     * scope to the given value.\n     *\n     * @param value the value to set\n     * @return a new rule\n     */\n    public ActionResult SET(V value) {\n        actionParameters.add(new SetValueParameter<V>(mixInParameter(actionParameters, value), nodeValueType));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to null. You cannot use <b>null<\/b> directly in an action call\n     * expression. Use this method instead.\n     *\n     * @return the action parameter\n     */\n    public Object NULL() {\n        actionParameters.add(new NullParameter());\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to an object using the given converter.\n     *\n     * @param text      the text (parameter) to convert\n     * @param converter the converter to use\n     * @return the action parameter\n     */\n    public <T> T CONVERT(String text, Converter<T> converter) {\n        Object converterArg = mixInParameter(actionParameters, converter);\n        Object textArg = mixInParameter(actionParameters, text);\n        List<Class<?>> convertedTypes = Utils.getTypeArguments(Converter.class, converterArg.getClass());\n        Preconditions.checkArgument(convertedTypes.size() == 1, \"Illegal converter\");\n        actionParameters.add(new ConvertParameter(convertedTypes.get(0), textArg, converterArg));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to an Integer.\n     *\n     * @param text the text (parameter) to convert\n     * @return the action parameter\n     */\n    public Integer CONVERT_TO_INTEGER(String text) {\n        return CONVERT(text, new Converter<Integer>() {\n            public Integer parse(String string) {\n                return Integer.parseInt(string);\n            }\n        });\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to a Long.\n     *\n     * @param text the text (parameter) to convert\n     * @return the action parameter\n     */\n    public Long CONVERT_TO_LONG(String text) {\n        return CONVERT(text, new Converter<Long>() {\n            public Long parse(String string) {\n                return Long.parseLong(string);\n            }\n        });\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to a Float.\n     *\n     * @param text the text (parameter) to convert\n     * @return the action parameter\n     */\n    public Float CONVERT_TO_FLOAT(String text) {\n        return CONVERT(text, new Converter<Float>() {\n            public Float parse(String string) {\n                return Float.parseFloat(string);\n            }\n        });\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to a Double.\n     *\n     * @param text the text (parameter) to convert\n     * @return the action parameter\n     */\n    public Double CONVERT_TO_DOUBLE(String text) {\n        return CONVERT(text, new Converter<Double>() {\n            public Double parse(String string) {\n                return Double.parseDouble(string);\n            }\n        });\n    }\n\n    ///************************* HELPER METHODS ***************************///\n\n    /**\n     * Used internally to convert the given character literal to a parser rule.\n     * You can override this method, e.g. for specifying a sequence that automatically matches all trailing\n     * whitespace after the character.\n     *\n     * @param c the character\n     * @return the rule\n     */\n    protected Rule fromCharLiteral(char c) {\n        return ch(c);\n    }\n\n    /**\n     * Used internally to convert the given string literal to a parser rule.\n     * You can override this method, e.g. for specifying a sequence that automatically matches all trailing\n     * whitespace after the string.\n     *\n     * @param string the string\n     * @return the rule\n     */\n    protected Rule fromStringLiteral(String string) {\n        return string(string);\n    }\n\n    protected Rule cached(Object key) {\n        return ruleCache.get(key);\n    }\n\n    protected Rule cache(Object key, Rule rule) {\n        ruleCache.put(key, rule);\n        return rule;\n    }\n\n    private Rule[] toRules(@NotNull Object[] objects) {\n        Rule[] rules = new Rule[objects.length];\n        for (int i = 0; i < objects.length; i++) {\n            rules[i] = toRule(objects[i]);\n        }\n        return rules;\n    }\n\n    private Rule toRule(Object obj) {\n        obj = mixInParameter(actionParameters, obj);\n        if (obj instanceof Rule) {\n            return (Rule) obj;\n        }\n        if (obj instanceof Character) {\n            Rule rule = cached(obj);\n            return rule != null ? rule : cache(obj, fromCharLiteral((Character) obj));\n        }\n        if (obj instanceof String) {\n            Rule rule = cached(obj);\n            return rule != null ? rule : cache(obj, fromStringLiteral((String) obj));\n        }\n        if (obj instanceof ActionParameter) {\n            return new ActionMatcher((ActionParameter) obj);\n        }\n        throw new ParserConstructionException(\"\\'\" + obj + \"\\' is not a valid Rule or parser action\");\n    }\n\n}\n","lineNo":202}
{"Refactored Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled;\n\nimport net.sf.cglib.proxy.Callback;\nimport net.sf.cglib.proxy.Factory;\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.actionparameters.*;\nimport static org.parboiled.actionparameters.ActionParameterUtils.mixInParameter;\nimport org.parboiled.common.Converter;\nimport org.parboiled.common.Preconditions;\nimport org.parboiled.common.Utils;\nimport static org.parboiled.common.Utils.arrayOf;\nimport org.parboiled.matchers.*;\nimport org.parboiled.support.*;\n\nimport java.util.*;\n\n/**\n * Base class for custom parsers. Defines basic methods for rule and action parameter creation.\n *\n * @param <V> The type of the value field of the parse tree nodes created by this parser.\n * @param <A> The type of the parser Actions you would like to use in your rules. If you don't need any parser\n * actions (e.g. for very simple examples) you can just use the Actions<Object> interface directly.\n */\npublic abstract class BaseParser<V, A extends Actions<V>> {\n\n    /**\n     * Cache of frequently used, bottom level rules. Per default used for character and string matching rules.\n     */\n    private final Map<Object, Rule> ruleCache = new HashMap<Object, Rule>();\n\n    /**\n     * The actual type of the V type argument, i.e. the value field of the generated parse tree nodes.\n     */\n    private final Class<V> nodeValueType;\n\n    /**\n     * Stack for action parameters. Used for creation of actual arguments to action methods.\n     */\n    final Stack<ActionParameter> actionParameters = new Stack<ActionParameter>();\n\n    /**\n     * The immutable reference to your parser actions.\n     */\n    public final A actions;\n\n    /**\n     * Constructs a new parser instance without parser actions.\n     */\n    protected BaseParser() {\n        this(null);\n    }\n\n    /**\n     * Constructs a new parser instance using the given actions instance. Note that if the actions instance is not null\n     * it must have been created with {@link Parboiled#createActions(Class, Object[])} )}.\n     *\n     * @param actions the parser actions (can be null)\n     */\n    @SuppressWarnings({\"unchecked\"})\n    protected BaseParser(A actions) {\n        this.actions = actions;\n\n        List<Class<?>> typeArguments = Utils.getTypeArguments(BaseParser.class, getClass());\n        Preconditions.checkState(typeArguments.size() == 2);\n        nodeValueType = (Class<V>) typeArguments.get(0);\n\n        if (actions != null) {\n            verifyActionsObject();\n        }\n    }\n\n    private void verifyActionsObject() {\n        if (actions instanceof Factory) {\n            Callback actionsCallback = ((Factory) actions).getCallback(1);\n            if (actionsCallback instanceof ActionInterceptor) {\n                ActionInterceptor actionInterceptor = (ActionInterceptor) actionsCallback;\n                // signal to the ActionInterceptor that we are in the rule construction phase\n                // by informing it about the parser object instance\n                actionInterceptor.setParser(this);\n                return;\n            }\n        }\n        Checks.fail(\"Illegal Actions instance, please use Parboiled.createActions(...) \" +\n                \"for creating your parser actions object\");\n    }\n\n    /**\n     * Runs the given parser rule against the given input string. Note that the rule must have been created by\n     * a rule creation method of this parser object, which must have been created with\n     * {@link Parboiled#createParser(Class, Object[])}.\n     *\n     * @param rule  the rule\n     * @param input the input string\n     * @return the ParsingResult for the run\n     */\n    @SuppressWarnings({\"unchecked\"})\n    public ParsingResult<V> parse(Rule rule, @NotNull String input) {\n        Checks.ensure(this instanceof Factory && ((Factory) this).getCallback(1) instanceof RuleInterceptor,\n                \"Illegal parser instance, please use Parboiled.createParser(...) for creating this parser\");\n\n        // prepare\n        InputBuffer inputBuffer = new InputBuffer(input);\n        InputLocation startLocation = new InputLocation(inputBuffer);\n        List<ParseError> parseErrors = new ArrayList<ParseError>();\n        Matcher<V> matcher = (Matcher<V>) toRule(rule);\n        MatcherContext<V> context = new MatcherContext<V>(inputBuffer, startLocation, matcher, parseErrors);\n\n        // the matcher tree has already been built, usually immediately before the invocation of this method,\n        // we need to signal to the ActionInterceptor that rule construction is over and all further action\n        // calls should not continue to create ActionCallParameters but actually be \"routed through\" to the\n        // actual action method implementations\n        if (actions != null) {\n            ActionInterceptor actionInterceptor = (ActionInterceptor) ((Factory) actions).getCallback(1);\n            actionInterceptor.setParser(null);\n        }\n\n        // run the actual matcher tree\n        context.runMatcher(true);\n\n        return new ParsingResult<V>(context.getNode(), parseErrors, inputBuffer);\n    }\n\n    ////////////////////////////////// RULE CREATION ///////////////////////////////////\n\n    /**\n     * Explicitly creates a rule matching the given character. Normally you can just specify the character literal\n     * directly in you rule description. However, if you want to not go through {@link #fromCharLiteral(char)},\n     * e.g. because you redefined it, you can also use this wrapper.\n     *\n     * @param c the char to match\n     * @return a new rule\n     */\n    public Rule ch(char c) {\n        return new CharMatcher<V>(c);\n    }\n\n    /**\n     * Explicitly creates a rule matching the given character ignoring the case.\n     *\n     * @param c the char to match independently of its case\n     * @return a new rule\n     */\n    public Rule charIgnoreCase(char c) {\n        return Character.isLetter(c) ? new CharIgnoreCaseMatcher<V>(c) : ch(c);\n    }\n\n    /**\n     * Creates a rule matching a range of characters from cLow to cHigh (both inclusively).\n     *\n     * @param cLow  the start char of the range (inclusively)\n     * @param cHigh the end char of the range (inclusively)\n     * @return a new rule\n     */\n    public Rule charRange(char cLow, char cHigh) {\n        return cLow == cHigh ? ch(cLow) : new CharRangeMatcher<V>(cLow, cHigh);\n    }\n\n    /**\n     * Explicitly creates a rule matching the given string. Normally you can just specify the string literal\n     * directly in you rule description. However, if you want to not go through {@link #fromStringLiteral(String)},\n     * e.g. because you redefined it, you can also use this wrapper.\n     *\n     * @param string the string to match\n     * @return a new rule\n     */\n    public Rule string(String string) {\n        Rule[] matchers = new Rule[string.length()];\n        for (int i = 0; i < string.length(); i++) {\n            char c = string.charAt(i);\n            Rule rule = cached(c);\n            matchers[i] = rule != null ? rule : cache(c, ch(c));\n        }\n        return new SequenceMatcher(matchers, false).label(string);\n    }\n\n    /**\n     * Explicitly creates a rule matching the given string in a case-independent fashion.\n     *\n     * @param string the string to match\n     * @return a new rule\n     */\n    public Rule stringIgnoreCase(String string) {\n        Rule[] matchers = new Rule[string.length()];\n        for (int i = 0; i < string.length(); i++) {\n            char c = string.charAt(i);\n            boolean letter = Character.isLetter(c);\n            Object key = letter ? new IgnoreCaseWrapper(c) : c;\n            Rule rule = cached(key);\n            matchers[i] = rule != null ? rule : cache(key, letter ? charIgnoreCase(c) : ch(c));\n        }\n        return new SequenceMatcher(matchers, false).label(string);\n    }\n\n    /**\n     * Creates a new rule that successively tries all of the given subrules and succeeds when the first one of\n     * its subrules matches. If all subrules fail this rule fails as well.\n     *\n     * @param rule      the first subrule\n     * @param rule2     the second subrule\n     * @param moreRules the other subrules\n     * @return a new rule\n     */\n    public Rule firstOf(Object rule, Object rule2, Object... moreRules) {\n        return new FirstOfMatcher(toRules(arrayOf(rule, arrayOf(rule2, moreRules)))).label(\"firstOf\");\n    }\n\n    /**\n     * Creates a new rule that tries repeated matches of its subrule and succeeds if the subrule matches at least once.\n     * If the subrule does not match at least once this rule fails.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule oneOrMore(Object rule) {\n        return new OneOrMoreMatcher(toRule(rule)).label(\"oneOrMore\");\n    }\n\n    /**\n     * Creates a new rule that tries a match on its subrule and always succeeds, independently of the matching\n     * success of its subrule.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule optional(Object rule) {\n        return new OptionalMatcher(toRule(rule)).label(\"optional\");\n    }\n\n    /**\n     * Creates a new rule that only succeeds if all of its subrule succeed, one after the other.\n     *\n     * @param rule      the first subrule\n     * @param rule2     the second subrule\n     * @param moreRules the other subrules\n     * @return a new rule\n     */\n    public Rule sequence(Object rule, Object rule2, Object... moreRules) {\n        return new SequenceMatcher(toRules(arrayOf(rule, arrayOf(rule2, moreRules))), false).label(\"sequence\");\n    }\n\n    /**\n     * Creates a new rule that only succeeds if all of its subrules succeed, one after the other.\n     * However, after the first subrule has matched all further subrule matches are enforced, i.e. if one of them\n     * fails a ParseError will be created (and error recovery will be tried).\n     *\n     * @param rule      the first subrule\n     * @param rule2     the second subrule\n     * @param moreRules the other subrules\n     * @return a new rule\n     */\n    public Rule enforcedSequence(Object rule, Object rule2, Object... moreRules) {\n        return new SequenceMatcher(toRules(arrayOf(rule, arrayOf(rule2, moreRules))), true).label(\"enforcedSequence\");\n    }\n\n    /**\n     * Creates a new rule that acts as a syntactic predicate, i.e. tests the given subrule against the current\n     * input position without actually matching any characters. Succeeds if the subrule succeeds and fails if the\n     * subrule rails. Since this rule does not actually consume any input it will never create a parse tree node.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule test(Object rule) {\n        return new TestMatcher(toRule(rule), false);\n    }\n\n    /**\n     * Creates a new rule that acts as an inverse syntactic predicate, i.e. tests the given subrule against the current\n     * input position without actually matching any characters. Succeeds if the subrule fails and fails if the\n     * subrule succeeds. Since this rule does not actually consume any input it will never create a parse tree node.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule testNot(Object rule) {\n        return new TestMatcher(toRule(rule), true);\n    }\n\n    /**\n     * Creates a new rule that tries repeated matches of its subrule.\n     * Succeeds always, even if the subrule doesn't match even once.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule zeroOrMore(Object rule) {\n        return new ZeroOrMoreMatcher(toRule(rule)).label(\"zeroOrMore\");\n    }\n\n    /**\n     * Matches the EOI (end of input) character.\n     *\n     * @return a new rule\n     */\n    public Rule eoi() {\n        return ch(Chars.EOI);\n    }\n\n    /**\n     * Matches any character except {@link org.parboiled.support.Chars#EOI}.\n     *\n     * @return a new rule\n     */\n    public Rule any() {\n        return ch(Chars.ANY);\n    }\n\n    /**\n     * Matches nothing and therefore always succeeds.\n     *\n     * @return a new rule\n     */\n    public Rule empty() {\n        return ch(Chars.EMPTY);\n    }\n\n    ////////////////////////////////// ACTION PARAMETERS ///////////////////////////////////\n\n    /**\n     * Changes the context scope of all arguments to the current parent scope.\n     *\n     * @param argument the arguments to change to context for\n     * @return the result of the argument\n     */\n    public <T> T UP(T argument) {\n        actionParameters.add(new UpParameter(mixInParameter(actionParameters, argument)));\n        return null;\n    }\n\n    /**\n     * Changes the context scope of all arguments to the current sub scope. This will only work if this call is\n     * at some level wrapped with one or more {@link #UP(Object)} calls, since the default scope is always at\n     * the bottom of the context chain.\n     *\n     * @param argument the arguments to change to context for\n     * @return the result of the argument\n     */\n    public <T> T DOWN(T argument) {\n        actionParameters.add(new DownParameter(mixInParameter(actionParameters, argument)));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the parse tree node found under the given prefix path.\n     * See {@link ParseTreeUtils#findNodeByPath(org.parboiled.Node, String)} for a description of the path argument.\n     * The path is relative to the current context scope, which can be changed with {@link #UP(Object)} or {@link #DOWN(Object)}.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public Node<V> NODE(String path) {\n        actionParameters.add(new PathNodeParameter(mixInParameter(actionParameters, path)));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to a list of all parse tree nodes found under the given prefix path.\n     * See {@link ParseTreeUtils#findNodeByPath(org.parboiled.Node, String)} )} for a description of the path argument.\n     * The path is relative to the current context scope, which can be changed with {@link #UP(Object)} or {@link #DOWN(Object)}.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public List<Node<V>> NODES(String path) {\n        actionParameters.add(new PathNodesParameter(mixInParameter(actionParameters, path)));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the last node created during this parsing run. This last node\n     * is independent of the current context scope, i.e. {@link #UP(Object)} or {@link #DOWN(Object)} have no influence\n     * on it.\n     *\n     * @return the action parameter\n     */\n    public Node<V> LAST_NODE() {\n        actionParameters.add(new LastNodeParameter());\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the tree value of the current context scope level, i.e.,\n     * if there is an explicitly set value it is returned. Otherwise the last non-null child value, or, if there\n     * is no such value, null.\n     *\n     * @return the action parameter\n     */\n    public V VALUE() {\n        actionParameters.add(new TreeValueParameter<V>(nodeValueType));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the value of the given node.\n     *\n     * @param node the node the get the value from\n     * @return the action parameter\n     */\n    public V VALUE(Node<V> node) {\n        actionParameters.add(new ValueParameter<V>(nodeValueType, mixInParameter(actionParameters, node)));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the value of the node found under the given prefix path.\n     * Equivalent to <code>VALUE(NODE(path))<\/code>.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public V VALUE(String path) {\n        return VALUE(NODE(path));\n    }\n\n    /**\n     * Creates an action parameter that evaluates to a list of the values of all given nodes.\n     *\n     * @param nodes the nodes to get the values from\n     * @return the action parameter\n     */\n    public List<V> VALUES(List<Node<V>> nodes) {\n        actionParameters.add(new ValuesParameter<V>(mixInParameter(actionParameters, nodes)));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to a list of the values of all nodes found under the given prefix path.\n     * Equivalent to <code>VALUES(NODES(path))<\/code>.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public List<V> VALUES(String path) {\n        return VALUES(NODES(path));\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the value of the last node created during this parsing run.\n     * Equivalent to <code>VALUE(LAST_NODE())<\/code>.\n     *\n     * @return the action parameter\n     */\n    public V LAST_VALUE() {\n        return VALUE(LAST_NODE());\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the input text matched by the given parse tree node.\n     *\n     * @param node the parse tree node\n     * @return the action parameter\n     */\n    public String TEXT(Node<V> node) {\n        actionParameters.add(new TextParameter<V>(mixInParameter(actionParameters, node)));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the input text matched by the node found under the given prefix path.\n     * Equivalent to <code>TEXT(NODE(path))<\/code>.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public String TEXT(String path) {\n        return TEXT(NODE(path));\n    }\n\n    /**\n     * Creates an action parameter that evaluates to a list of the input texts matched by all given nodes.\n     *\n     * @param nodes the nodes\n     * @return the action parameter\n     */\n    public List<String> TEXTS(List<Node<V>> nodes) {\n        actionParameters.add(new TextsParameter<V>(mixInParameter(actionParameters, nodes)));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to a list of the input texts matched by of all nodes found\n     * under the given prefix path.\n     * Equivalent to <code>TEXTS(NODES(path))<\/code>.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public List<String> TEXTS(String path) {\n        return TEXTS(NODES(path));\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the input text matched by the last node created during this parsing run.\n     * Equivalent to <code>TEXT(LAST_NODE())<\/code>.\n     *\n     * @return the action parameter\n     */\n    public String LAST_TEXT() {\n        return TEXT(LAST_NODE());\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the first character of the input text matched by the given parse tree node.\n     *\n     * @param node the parse tree node\n     * @return the action parameter\n     */\n    public Character CHAR(Node<V> node) {\n        actionParameters.add(new CharParameter<V>(mixInParameter(actionParameters, node)));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the first character of the input text matched by the node found under the given prefix path.\n     * Equivalent to <code>CHAR(NODE(path))<\/code>.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public Character CHAR(String path) {\n        return CHAR(NODE(path));\n    }\n\n    /**\n     * Creates an action parameter that evaluates to a list of the first characters of the input texts matched by all given nodes.\n     *\n     * @param nodes the nodes\n     * @return the action parameter\n     */\n    public List<Character> CHARS(List<Node<V>> nodes) {\n        actionParameters.add(new CharsParameter<V>(mixInParameter(actionParameters, nodes)));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to a list of the first characters of the input texts matched by of all nodes found\n     * under the given prefix path.\n     * Equivalent to <code>CHARS(NODES(path))<\/code>.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public List<Character> CHARS(String path) {\n        return CHARS(NODES(path));\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the input text matched by the last node created during this parsing run.\n     * Equivalent to <code>CHAR(LAST_NODE())<\/code>.\n     *\n     * @return the action parameter\n     */\n    public Character LAST_CHAR() {\n        return CHAR(LAST_NODE());\n    }\n\n    /**\n     * Creates a special action rule that sets the value of the parse tree node to be created for the current context\n     * scope to the value of the last node created during the current parsing run.\n     * Equivalent to <code>SET(LAST_VALUE())<\/code>.\n     *\n     * @return a new rule\n     */\n    public ActionResult SET() {\n        return SET(LAST_VALUE());\n    }\n\n    /**\n     * Creates a special action rule that sets the value of the parse tree node to be created for the current context\n     * scope to the given value.\n     *\n     * @param value the value to set\n     * @return a new rule\n     */\n    public ActionResult SET(V value) {\n        actionParameters.add(new SetValueParameter<V>(mixInParameter(actionParameters, value), nodeValueType));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to null. You cannot use <b>null<\/b> directly in an action call\n     * expression. Use this method instead.\n     *\n     * @return the action parameter\n     */\n    public Object NULL() {\n        actionParameters.add(new NullParameter());\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to an object using the given converter.\n     *\n     * @param text      the text (parameter) to convert\n     * @param converter the converter to use\n     * @return the action parameter\n     */\n    public <T> T CONVERT(String text, Converter<T> converter) {\n        Object converterArg = mixInParameter(actionParameters, converter);\n        Object textArg = mixInParameter(actionParameters, text);\n        List<Class<?>> convertedTypes = Utils.getTypeArguments(Converter.class, converterArg.getClass());\n        Preconditions.checkArgument(convertedTypes.size() == 1, \"Illegal converter\");\n        actionParameters.add(new ConvertParameter(convertedTypes.get(0), textArg, converterArg));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to an Integer.\n     *\n     * @param text the text (parameter) to convert\n     * @return the action parameter\n     */\n    public Integer CONVERT_TO_INTEGER(String text) {\n        return CONVERT(text, new Converter<Integer>() {\n            public Integer parse(String string) {\n                return Integer.parseInt(string);\n            }\n        });\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to a Long.\n     *\n     * @param text the text (parameter) to convert\n     * @return the action parameter\n     */\n    public Long CONVERT_TO_LONG(String text) {\n        return CONVERT(text, new Converter<Long>() {\n            public Long parse(String string) {\n                return Long.parseLong(string);\n            }\n        });\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to a Float.\n     *\n     * @param text the text (parameter) to convert\n     * @return the action parameter\n     */\n    public Float CONVERT_TO_FLOAT(String text) {\n        return CONVERT(text, new Converter<Float>() {\n            public Float parse(String string) {\n                return Float.parseFloat(string);\n            }\n        });\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to a Double.\n     *\n     * @param text the text (parameter) to convert\n     * @return the action parameter\n     */\n    public Double CONVERT_TO_DOUBLE(String text) {\n        return CONVERT(text, new Converter<Double>() {\n            public Double parse(String string) {\n                return Double.parseDouble(string);\n            }\n        });\n    }\n\n    ///************************* HELPER METHODS ***************************///\n\n    /**\n     * Used internally to convert the given character literal to a parser rule.\n     * You can override this method, e.g. for specifying a sequence that automatically matches all trailing\n     * whitespace after the character.\n     *\n     * @param c the character\n     * @return the rule\n     */\n    protected Rule fromCharLiteral(char c) {\n        return ch(c);\n    }\n\n    /**\n     * Used internally to convert the given string literal to a parser rule.\n     * You can override this method, e.g. for specifying a sequence that automatically matches all trailing\n     * whitespace after the string.\n     *\n     * @param string the string\n     * @return the rule\n     */\n    protected Rule fromStringLiteral(String string) {\n        return string(string);\n    }\n\n    protected Rule cached(Object key) {\n        return ruleCache.get(key);\n    }\n\n    protected Rule cache(Object key, Rule rule) {\n        ruleCache.put(key, rule);\n        return rule;\n    }\n\n    private Rule[] toRules(@NotNull Object[] objects) {\n        Rule[] rules = new Rule[objects.length];\n        for (int i = 0; i < objects.length; i++) {\n            rules[i] = toRule(objects[i]);\n        }\n        return rules;\n    }\n\n    private Rule toRule(Object obj) {\n        obj = mixInParameter(actionParameters, obj);\n        if (obj instanceof Rule) {\n            return (Rule) obj;\n        }\n        if (obj instanceof Character) {\n            Rule rule = cached(obj);\n            return rule != null ? rule : cache(obj, fromCharLiteral((Character) obj));\n        }\n        if (obj instanceof String) {\n            Rule rule = cached(obj);\n            return rule != null ? rule : cache(obj, fromStringLiteral((String) obj));\n        }\n        if (obj instanceof ActionParameter) {\n            return new ActionMatcher((ActionParameter) obj);\n        }\n        throw new ParserConstructionException(\"\\'\" + obj + \"\\' is not a valid Rule or parser action\");\n    }\n\n    /**\n     * Wrapper for rule cache keys that are used for explicit \"ignore-case matchers\"\n     */\n    protected static class IgnoreCaseWrapper {\n        private final Object key;\n\n        public IgnoreCaseWrapper(Object key) {\n            this.key = key;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            return this == o || o instanceof IgnoreCaseWrapper && key.equals(((IgnoreCaseWrapper) o).key);\n        }\n\n        @Override\n        public int hashCode() {\n            return key.hashCode();\n        }\n    }\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled;\n\nimport net.sf.cglib.proxy.Callback;\nimport net.sf.cglib.proxy.Factory;\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.actionparameters.*;\nimport static org.parboiled.actionparameters.ActionParameterUtils.mixInParameter;\nimport org.parboiled.common.Converter;\nimport org.parboiled.common.Preconditions;\nimport org.parboiled.common.Utils;\nimport static org.parboiled.common.Utils.arrayOf;\nimport org.parboiled.matchers.*;\nimport org.parboiled.support.*;\n\nimport java.util.*;\n\n/**\n * Base class for custom parsers. Defines basic methods for rule and action parameter creation.\n *\n * @param <V> The type of the value field of the parse tree nodes created by this parser.\n * @param <A> The type of the parser Actions you would like to use in your rules. If you don't need any parser\n * actions (e.g. for very simple examples) you can just use the Actions<Object> interface directly.\n */\npublic abstract class BaseParser<V, A extends Actions<V>> {\n\n    /**\n     * Cache of frequently used, bottom level rules. Per default used for character and string matching rules.\n     */\n    private final Map<Object, Rule> ruleCache = new HashMap<Object, Rule>();\n\n    /**\n     * The actual type of the V type argument, i.e. the value field of the generated parse tree nodes.\n     */\n    private final Class<V> nodeValueType;\n\n    /**\n     * Stack for action parameters. Used for creation of actual arguments to action methods.\n     */\n    final Stack<ActionParameter> actionParameters = new Stack<ActionParameter>();\n\n    /**\n     * The immutable reference to your parser actions.\n     */\n    public final A actions;\n\n    /**\n     * Constructs a new parser instance without parser actions.\n     */\n    protected BaseParser() {\n        this(null);\n    }\n\n    /**\n     * Constructs a new parser instance using the given actions instance. Note that if the actions instance is not null\n     * it must have been created with {@link Parboiled#createActions(Class, Object[])} )}.\n     *\n     * @param actions the parser actions (can be null)\n     */\n    @SuppressWarnings({\"unchecked\"})\n    protected BaseParser(A actions) {\n        this.actions = actions;\n\n        List<Class<?>> typeArguments = Utils.getTypeArguments(BaseParser.class, getClass());\n        Preconditions.checkState(typeArguments.size() == 2);\n        nodeValueType = (Class<V>) typeArguments.get(0);\n\n        if (actions != null) {\n            verifyActionsObject();\n        }\n    }\n\n    private void verifyActionsObject() {\n        if (actions instanceof Factory) {\n            Callback actionsCallback = ((Factory) actions).getCallback(1);\n            if (actionsCallback instanceof ActionInterceptor) {\n                ActionInterceptor actionInterceptor = (ActionInterceptor) actionsCallback;\n                // signal to the ActionInterceptor that we are in the rule construction phase\n                // by informing it about the parser object instance\n                actionInterceptor.setParser(this);\n                return;\n            }\n        }\n        Checks.fail(\"Illegal Actions instance, please use Parboiled.createActions(...) \" +\n                \"for creating your parser actions object\");\n    }\n\n    /**\n     * Runs the given parser rule against the given input string. Note that the rule must have been created by\n     * a rule creation method of this parser object, which must have been created with\n     * {@link Parboiled#createParser(Class, Object[])}.\n     *\n     * @param rule  the rule\n     * @param input the input string\n     * @return the ParsingResult for the run\n     */\n    @SuppressWarnings({\"unchecked\"})\n    public ParsingResult<V> parse(Rule rule, @NotNull String input) {\n        Checks.ensure(this instanceof Factory && ((Factory) this).getCallback(1) instanceof RuleInterceptor,\n                \"Illegal parser instance, please use Parboiled.createParser(...) for creating this parser\");\n\n        // prepare\n        InputBuffer inputBuffer = new InputBuffer(input);\n        InputLocation startLocation = new InputLocation(inputBuffer);\n        List<ParseError> parseErrors = new ArrayList<ParseError>();\n        Matcher<V> matcher = (Matcher<V>) toRule(rule);\n        MatcherContext<V> context = new MatcherContext<V>(inputBuffer, startLocation, matcher, parseErrors);\n\n        // the matcher tree has already been built, usually immediately before the invocation of this method,\n        // we need to signal to the ActionInterceptor that rule construction is over and all further action\n        // calls should not continue to create ActionCallParameters but actually be \"routed through\" to the\n        // actual action method implementations\n        if (actions != null) {\n            ActionInterceptor actionInterceptor = (ActionInterceptor) ((Factory) actions).getCallback(1);\n            actionInterceptor.setParser(null);\n        }\n\n        // run the actual matcher tree\n        context.runMatcher(true);\n\n        return new ParsingResult<V>(context.getNode(), parseErrors, inputBuffer);\n    }\n\n    ////////////////////////////////// RULE CREATION ///////////////////////////////////\n\n    /**\n     * Explicitly creates a rule matching the given character. Normally you can just specify the character literal\n     * directly in you rule description. However, if you want to not go through {@link #fromCharLiteral(char)},\n     * e.g. because you redefined it, you can also use this wrapper.\n     *\n     * @param c the char to match\n     * @return a new rule\n     */\n    public Rule ch(char c) {\n        return new CharMatcher(c);\n    }\n\n    /**\n     * Creates a rule matching a range of characters from cLow to cHigh (both inclusively).\n     *\n     * @param cLow  the start char of the range (inclusively)\n     * @param cHigh the end char of the range (inclusively)\n     * @return a new rule\n     */\n    public Rule charRange(char cLow, char cHigh) {\n        return cLow == cHigh ? ch(cLow) : new CharRangeMatcher(cLow, cHigh);\n    }\n\n    /**\n     * Explicitly creates a rule matching the given string. Normally you can just specify the string literal\n     * directly in you rule description. However, if you want to not go through {@link #fromStringLiteral(String)},\n     * e.g. because you redefined it, you can also use this wrapper.\n     *\n     * @param string the string to match\n     * @return a new rule\n     */\n    public Rule string(String string) {\n        Rule[] matchers = new Rule[string.length()];\n        for (int i = 0; i < string.length(); i++) {\n            char c = string.charAt(i);\n            Rule rule = cached(c);\n            matchers[i] = rule != null ? rule : cache(c, ch(c));\n        }\n        return new SequenceMatcher(matchers, false).label(string);\n    }\n\n    /**\n     * Creates a new rule that successively tries all of the given subrules and succeeds when the first one of\n     * its subrules matches. If all subrules fail this rule fails as well.\n     *\n     * @param rule      the first subrule\n     * @param rule2     the second subrule\n     * @param moreRules the other subrules\n     * @return a new rule\n     */\n    public Rule firstOf(Object rule, Object rule2, Object... moreRules) {\n        return new FirstOfMatcher(toRules(arrayOf(rule, arrayOf(rule2, moreRules)))).label(\"firstOf\");\n    }\n\n    /**\n     * Creates a new rule that tries repeated matches of its subrule and succeeds if the subrule matches at least once.\n     * If the subrule does not match at least once this rule fails.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule oneOrMore(Object rule) {\n        return new OneOrMoreMatcher(toRule(rule)).label(\"oneOrMore\");\n    }\n\n    /**\n     * Creates a new rule that tries a match on its subrule and always succeeds, independently of the matching\n     * success of its subrule.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule optional(Object rule) {\n        return new OptionalMatcher(toRule(rule)).label(\"optional\");\n    }\n\n    /**\n     * Creates a new rule that only succeeds if all of its subrule succeed, one after the other.\n     *\n     * @param rule      the first subrule\n     * @param rule2     the second subrule\n     * @param moreRules the other subrules\n     * @return a new rule\n     */\n    public Rule sequence(Object rule, Object rule2, Object... moreRules) {\n        return new SequenceMatcher(toRules(arrayOf(rule, arrayOf(rule2, moreRules))), false).label(\"sequence\");\n    }\n\n    /**\n     * Creates a new rule that only succeeds if all of its subrules succeed, one after the other.\n     * However, after the first subrule has matched all further subrule matches are enforced, i.e. if one of them\n     * fails a ParseError will be created (and error recovery will be tried).\n     *\n     * @param rule      the first subrule\n     * @param rule2     the second subrule\n     * @param moreRules the other subrules\n     * @return a new rule\n     */\n    public Rule enforcedSequence(Object rule, Object rule2, Object... moreRules) {\n        return new SequenceMatcher(toRules(arrayOf(rule, arrayOf(rule2, moreRules))), true).label(\"enforcedSequence\");\n    }\n\n    /**\n     * Creates a new rule that acts as a syntactic predicate, i.e. tests the given subrule against the current\n     * input position without actually matching any characters. Succeeds if the subrule succeeds and fails if the\n     * subrule rails. Since this rule does not actually consume any input it will never create a parse tree node.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule test(Object rule) {\n        return new TestMatcher(toRule(rule), false);\n    }\n\n    /**\n     * Creates a new rule that acts as an inverse syntactic predicate, i.e. tests the given subrule against the current\n     * input position without actually matching any characters. Succeeds if the subrule fails and fails if the\n     * subrule succeeds. Since this rule does not actually consume any input it will never create a parse tree node.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule testNot(Object rule) {\n        return new TestMatcher(toRule(rule), true);\n    }\n\n    /**\n     * Creates a new rule that tries repeated matches of its subrule.\n     * Succeeds always, even if the subrule doesn't match even once.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule zeroOrMore(Object rule) {\n        return new ZeroOrMoreMatcher(toRule(rule)).label(\"zeroOrMore\");\n    }\n\n    /**\n     * Matches the EOI (end of input) character.\n     *\n     * @return a new rule\n     */\n    public Rule eoi() {\n        return ch(Chars.EOI);\n    }\n\n    /**\n     * Matches any character except {@link org.parboiled.support.Chars#EOI}.\n     *\n     * @return a new rule\n     */\n    public Rule any() {\n        return ch(Chars.ANY);\n    }\n\n    /**\n     * Matches nothing and therefore always succeeds.\n     *\n     * @return a new rule\n     */\n    public Rule empty() {\n        return ch(Chars.EMPTY);\n    }\n\n    ////////////////////////////////// ACTION PARAMETERS ///////////////////////////////////\n\n    /**\n     * Changes the context scope of all arguments to the current parent scope.\n     *\n     * @param argument the arguments to change to context for\n     * @return the result of the argument\n     */\n    public <T> T UP(T argument) {\n        actionParameters.add(new UpParameter(mixInParameter(actionParameters, argument)));\n        return null;\n    }\n\n    /**\n     * Changes the context scope of all arguments to the current sub scope. This will only work if this call is\n     * at some level wrapped with one or more {@link #UP(Object)} calls, since the default scope is always at\n     * the bottom of the context chain.\n     *\n     * @param argument the arguments to change to context for\n     * @return the result of the argument\n     */\n    public <T> T DOWN(T argument) {\n        actionParameters.add(new DownParameter(mixInParameter(actionParameters, argument)));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the parse tree node found under the given prefix path.\n     * See {@link ParseTreeUtils#findNodeByPath(org.parboiled.Node, String)} for a description of the path argument.\n     * The path is relative to the current context scope, which can be changed with {@link #UP(Object)} or {@link #DOWN(Object)}.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public Node<V> NODE(String path) {\n        actionParameters.add(new PathNodeParameter(mixInParameter(actionParameters, path)));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to a list of all parse tree nodes found under the given prefix path.\n     * See {@link ParseTreeUtils#findNodeByPath(org.parboiled.Node, String)} )} for a description of the path argument.\n     * The path is relative to the current context scope, which can be changed with {@link #UP(Object)} or {@link #DOWN(Object)}.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public List<Node<V>> NODES(String path) {\n        actionParameters.add(new PathNodesParameter(mixInParameter(actionParameters, path)));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the last node created during this parsing run. This last node\n     * is independent of the current context scope, i.e. {@link #UP(Object)} or {@link #DOWN(Object)} have no influence\n     * on it.\n     *\n     * @return the action parameter\n     */\n    public Node<V> LAST_NODE() {\n        actionParameters.add(new LastNodeParameter());\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the tree value of the current context scope level, i.e.,\n     * if there is an explicitly set value it is returned. Otherwise the last non-null child value, or, if there\n     * is no such value, null.\n     *\n     * @return the action parameter\n     */\n    public V VALUE() {\n        actionParameters.add(new TreeValueParameter<V>(nodeValueType));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the value of the given node.\n     *\n     * @param node the node the get the value from\n     * @return the action parameter\n     */\n    public V VALUE(Node<V> node) {\n        actionParameters.add(new ValueParameter<V>(nodeValueType, mixInParameter(actionParameters, node)));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the value of the node found under the given prefix path.\n     * Equivalent to <code>VALUE(NODE(path))<\/code>.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public V VALUE(String path) {\n        return VALUE(NODE(path));\n    }\n\n    /**\n     * Creates an action parameter that evaluates to a list of the values of all given nodes.\n     *\n     * @param nodes the nodes to get the values from\n     * @return the action parameter\n     */\n    public List<V> VALUES(List<Node<V>> nodes) {\n        actionParameters.add(new ValuesParameter<V>(mixInParameter(actionParameters, nodes)));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to a list of the values of all nodes found under the given prefix path.\n     * Equivalent to <code>VALUES(NODES(path))<\/code>.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public List<V> VALUES(String path) {\n        return VALUES(NODES(path));\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the value of the last node created during this parsing run.\n     * Equivalent to <code>VALUE(LAST_NODE())<\/code>.\n     *\n     * @return the action parameter\n     */\n    public V LAST_VALUE() {\n        return VALUE(LAST_NODE());\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the input text matched by the given parse tree node.\n     *\n     * @param node the parse tree node\n     * @return the action parameter\n     */\n    public String TEXT(Node<V> node) {\n        actionParameters.add(new TextParameter<V>(mixInParameter(actionParameters, node)));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the input text matched by the node found under the given prefix path.\n     * Equivalent to <code>TEXT(NODE(path))<\/code>.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public String TEXT(String path) {\n        return TEXT(NODE(path));\n    }\n\n    /**\n     * Creates an action parameter that evaluates to a list of the input texts matched by all given nodes.\n     *\n     * @param nodes the nodes\n     * @return the action parameter\n     */\n    public List<String> TEXTS(List<Node<V>> nodes) {\n        actionParameters.add(new TextsParameter<V>(mixInParameter(actionParameters, nodes)));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to a list of the input texts matched by of all nodes found\n     * under the given prefix path.\n     * Equivalent to <code>TEXTS(NODES(path))<\/code>.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public List<String> TEXTS(String path) {\n        return TEXTS(NODES(path));\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the input text matched by the last node created during this parsing run.\n     * Equivalent to <code>TEXT(LAST_NODE())<\/code>.\n     *\n     * @return the action parameter\n     */\n    public String LAST_TEXT() {\n        return TEXT(LAST_NODE());\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the first character of the input text matched by the given parse tree node.\n     *\n     * @param node the parse tree node\n     * @return the action parameter\n     */\n    public Character CHAR(Node<V> node) {\n        actionParameters.add(new CharParameter<V>(mixInParameter(actionParameters, node)));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the first character of the input text matched by the node found under the given prefix path.\n     * Equivalent to <code>CHAR(NODE(path))<\/code>.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public Character CHAR(String path) {\n        return CHAR(NODE(path));\n    }\n\n    /**\n     * Creates an action parameter that evaluates to a list of the first characters of the input texts matched by all given nodes.\n     *\n     * @param nodes the nodes\n     * @return the action parameter\n     */\n    public List<Character> CHARS(List<Node<V>> nodes) {\n        actionParameters.add(new CharsParameter<V>(mixInParameter(actionParameters, nodes)));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to a list of the first characters of the input texts matched by of all nodes found\n     * under the given prefix path.\n     * Equivalent to <code>CHARS(NODES(path))<\/code>.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public List<Character> CHARS(String path) {\n        return CHARS(NODES(path));\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the input text matched by the last node created during this parsing run.\n     * Equivalent to <code>CHAR(LAST_NODE())<\/code>.\n     *\n     * @return the action parameter\n     */\n    public Character LAST_CHAR() {\n        return CHAR(LAST_NODE());\n    }\n\n    /**\n     * Creates a special action rule that sets the value of the parse tree node to be created for the current context\n     * scope to the value of the last node created during the current parsing run.\n     * Equivalent to <code>SET(LAST_VALUE())<\/code>.\n     *\n     * @return a new rule\n     */\n    public ActionResult SET() {\n        return SET(LAST_VALUE());\n    }\n\n    /**\n     * Creates a special action rule that sets the value of the parse tree node to be created for the current context\n     * scope to the given value.\n     *\n     * @param value the value to set\n     * @return a new rule\n     */\n    public ActionResult SET(V value) {\n        actionParameters.add(new SetValueParameter<V>(mixInParameter(actionParameters, value), nodeValueType));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to null. You cannot use <b>null<\/b> directly in an action call\n     * expression. Use this method instead.\n     *\n     * @return the action parameter\n     */\n    public Object NULL() {\n        actionParameters.add(new NullParameter());\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to an object using the given converter.\n     *\n     * @param text      the text (parameter) to convert\n     * @param converter the converter to use\n     * @return the action parameter\n     */\n    public <T> T CONVERT(String text, Converter<T> converter) {\n        Object converterArg = mixInParameter(actionParameters, converter);\n        Object textArg = mixInParameter(actionParameters, text);\n        List<Class<?>> convertedTypes = Utils.getTypeArguments(Converter.class, converterArg.getClass());\n        Preconditions.checkArgument(convertedTypes.size() == 1, \"Illegal converter\");\n        actionParameters.add(new ConvertParameter(convertedTypes.get(0), textArg, converterArg));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to an Integer.\n     *\n     * @param text the text (parameter) to convert\n     * @return the action parameter\n     */\n    public Integer CONVERT_TO_INTEGER(String text) {\n        return CONVERT(text, new Converter<Integer>() {\n            public Integer parse(String string) {\n                return Integer.parseInt(string);\n            }\n        });\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to a Long.\n     *\n     * @param text the text (parameter) to convert\n     * @return the action parameter\n     */\n    public Long CONVERT_TO_LONG(String text) {\n        return CONVERT(text, new Converter<Long>() {\n            public Long parse(String string) {\n                return Long.parseLong(string);\n            }\n        });\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to a Float.\n     *\n     * @param text the text (parameter) to convert\n     * @return the action parameter\n     */\n    public Float CONVERT_TO_FLOAT(String text) {\n        return CONVERT(text, new Converter<Float>() {\n            public Float parse(String string) {\n                return Float.parseFloat(string);\n            }\n        });\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to a Double.\n     *\n     * @param text the text (parameter) to convert\n     * @return the action parameter\n     */\n    public Double CONVERT_TO_DOUBLE(String text) {\n        return CONVERT(text, new Converter<Double>() {\n            public Double parse(String string) {\n                return Double.parseDouble(string);\n            }\n        });\n    }\n\n    ///************************* HELPER METHODS ***************************///\n\n    /**\n     * Used internally to convert the given character literal to a parser rule.\n     * You can override this method, e.g. for specifying a sequence that automatically matches all trailing\n     * whitespace after the character.\n     *\n     * @param c the character\n     * @return the rule\n     */\n    protected Rule fromCharLiteral(char c) {\n        return ch(c);\n    }\n\n    /**\n     * Used internally to convert the given string literal to a parser rule.\n     * You can override this method, e.g. for specifying a sequence that automatically matches all trailing\n     * whitespace after the string.\n     *\n     * @param string the string\n     * @return the rule\n     */\n    protected Rule fromStringLiteral(String string) {\n        return string(string);\n    }\n\n    protected Rule cached(Object key) {\n        return ruleCache.get(key);\n    }\n\n    protected Rule cache(Object key, Rule rule) {\n        ruleCache.put(key, rule);\n        return rule;\n    }\n\n    private Rule[] toRules(@NotNull Object[] objects) {\n        Rule[] rules = new Rule[objects.length];\n        for (int i = 0; i < objects.length; i++) {\n            rules[i] = toRule(objects[i]);\n        }\n        return rules;\n    }\n\n    private Rule toRule(Object obj) {\n        obj = mixInParameter(actionParameters, obj);\n        if (obj instanceof Rule) {\n            return (Rule) obj;\n        }\n        if (obj instanceof Character) {\n            Rule rule = cached(obj);\n            return rule != null ? rule : cache(obj, fromCharLiteral((Character) obj));\n        }\n        if (obj instanceof String) {\n            Rule rule = cached(obj);\n            return rule != null ? rule : cache(obj, fromStringLiteral((String) obj));\n        }\n        if (obj instanceof ActionParameter) {\n            return new ActionMatcher((ActionParameter) obj);\n        }\n        throw new ParserConstructionException(\"\\'\" + obj + \"\\' is not a valid Rule or parser action\");\n    }\n\n}\n","lineNo":203}
{"Refactored Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled;\n\nimport net.sf.cglib.proxy.Factory;\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.actionparameters.*;\nimport static org.parboiled.actionparameters.ActionParameterUtils.mixInParameter;\nimport org.parboiled.common.Converter;\nimport org.parboiled.common.Preconditions;\nimport org.parboiled.common.Utils;\nimport static org.parboiled.common.Utils.arrayOf;\nimport org.parboiled.matchers.*;\nimport org.parboiled.support.*;\n\nimport java.util.*;\n\n/**\n * Base class for custom parsers. Defines basic methods for rule and action parameter creation.\n *\n * @param <V> The type of the value field of the parse tree nodes created by this parser.\n * @param <A> The type of the parser Actions you would like to use in your rules. If you don't need any parser\n * actions (e.g. for very simple examples) you can just use the Actions interface directly.\n */\npublic abstract class BaseParser<V, A extends Actions<V>> {\n\n    /**\n     * Cache of frequently used, bottom level rules. Per default used character and string matching rules.\n     */\n    private final Map<Object, Rule> ruleCache = new HashMap<Object, Rule>();\n\n    /**\n     * The actual type of the V type argument, i.e. the value field of the generated parse tree nodes.\n     */\n    private final Class<V> nodeValueType;\n\n    /**\n     * Stack for action parameters. Used for creation of actual arguments to action methods.\n     */\n    final Stack<ActionParameter> actionParameters = new Stack<ActionParameter>();\n\n    /**\n     * The immutable reference to your parser actions.\n     */\n    public final A actions;\n\n    /**\n     * Constructs a new parser object using the given actions.\n     *\n     * @param actions the parser actions (can be null)\n     */\n    @SuppressWarnings({\"unchecked\"})\n    public BaseParser(A actions) {\n        this.actions = actions;\n        List<Class<?>> typeArguments = Utils.getTypeArguments(BaseParser.class, getClass());\n        Preconditions.checkState(typeArguments.size() == 2);\n        nodeValueType = (Class<V>) typeArguments.get(0);\n    }\n\n    /**\n     * Runs the given parser rule against the given input string. Note that the rule must have been created by\n     * a rule creation method of this parser object, which must have been created with Parser.create(...).\n     *\n     * @param rule  the rule\n     * @param input the input string\n     * @return the ParsingResult for the run\n     */\n    @SuppressWarnings({\"unchecked\"})\n    public ParsingResult<V> parse(Rule rule, @NotNull String input) {\n        Checks.ensure(this instanceof Factory && ((Factory) this).getCallback(1) instanceof RuleInterceptor,\n                \"Illegal parser instance, please use Parboiled.createParser(...) for creating this parser\");\n\n        // prepare\n        InputBuffer inputBuffer = new InputBuffer(input);\n        InputLocation startLocation = new InputLocation(inputBuffer);\n        List<ParseError> parseErrors = new ArrayList<ParseError>();\n        Matcher<V> matcher = (Matcher<V>) toRule(rule);\n        MatcherContext<V> context = new MatcherContext<V>(startLocation, matcher, actions, parseErrors);\n\n        // the matcher tree has already been built during the call to Parboiled.parse(...), usually immediately\n        // before the invocation of this method, we need to signal to the ActionInterceptor that rule construction\n        // is over and all further action calls should not continue to createActions ActionMatchers but actually be\n        // \"routed through\" to the actual action method implementations\n        if (actions != null) {\n            ActionInterceptor actionInterceptor = (ActionInterceptor) ((Factory) actions).getCallback(1);\n            actionInterceptor.setParser(null);\n        }\n\n        // run the actual matcher tree\n        context.runMatcher(true);\n\n        return new ParsingResult<V>(context.getNode(), parseErrors, inputBuffer);\n    }\n\n    ////////////////////////////////// RULE CREATION ///////////////////////////////////\n\n    /**\n     * Explicitly creates a rule matching the given character.\n     * Normally you can just specify the character literal directly in you rule description.\n     * However, you can also use this wrapper.\n     *\n     * @param c the char to match\n     * @return a new rule\n     */\n    public Rule ch(char c) {\n        return new CharMatcher(c);\n    }\n\n    /**\n     * Creates a rule matching a range of characters from cLow to cHigh (both inclusively).\n     *\n     * @param cLow  the start char of the range (inclusively)\n     * @param cHigh the end char of the range (inclusively)\n     * @return a new rule\n     */\n    public Rule charRange(char cLow, char cHigh) {\n        return cLow == cHigh ? ch(cLow) : new CharRangeMatcher(cLow, cHigh);\n    }\n\n    /**\n     * Explicitly creates a rule matching the given string.\n     * Normally you can just specify the string literal directly in you rule description.\n     * However, you can also use this wrapper.\n     *\n     * @param string the string to match\n     * @return a new rule\n     */\n    public Rule string(String string) {\n        Rule[] matchers = new Rule[string.length()];\n        for (int i = 0; i < string.length(); i++) {\n            char c = string.charAt(i);\n            Rule rule = cached(c);\n            matchers[i] = rule != null ? rule : cache(c, ch(c));\n        }\n        return new SequenceMatcher(matchers, false).label(string);\n    }\n\n    /**\n     * Creates a new rule that successively tries all of the given subrules and succeeds when the first one of\n     * its subrules matches. If all subrules fail this rule fails as well.\n     *\n     * @param rule      the first subrule\n     * @param rule2     the second subrule\n     * @param moreRules the other subrules\n     * @return a new rule\n     */\n    public Rule firstOf(Object rule, Object rule2, Object... moreRules) {\n        return new FirstOfMatcher(toRules(arrayOf(rule, arrayOf(rule2, moreRules)))).label(\"firstOf\");\n    }\n\n    /**\n     * Creates a new rule that tries repeated matches of its subrule and succeeds if the subrule matches at least once.\n     * If the subrule does not match at least once this rule fails.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule oneOrMore(Object rule) {\n        return new OneOrMoreMatcher(toRule(rule)).label(\"oneOrMore\");\n    }\n\n    /**\n     * Creates a new rule that tries a match on its subrule and always succeeds, independently of the matching\n     * success of its subrule.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule optional(Object rule) {\n        return new OptionalMatcher(toRule(rule)).label(\"optional\");\n    }\n\n    /**\n     * Creates a new rule that only succeeds if all of its subrule succeed, one after the other.\n     *\n     * @param rule      the first subrule\n     * @param rule2     the second subrule\n     * @param moreRules the other subrules\n     * @return a new rule\n     */\n    public Rule sequence(Object rule, Object rule2, Object... moreRules) {\n        return new SequenceMatcher(toRules(arrayOf(rule, arrayOf(rule2, moreRules))), false).label(\"sequence\");\n    }\n\n    /**\n     * Creates a new rule that only succeeds if all of its subrules succeed, one after the other.\n     * However, after the first subrule has matched all further subrule matches are enforced, i.e. if one of them\n     * fails a ParseError will be created (and error recovery will be tried).\n     *\n     * @param rule      the first subrule\n     * @param rule2     the second subrule\n     * @param moreRules the other subrules\n     * @return a new rule\n     */\n    public Rule enforcedSequence(Object rule, Object rule2, Object... moreRules) {\n        return new SequenceMatcher(toRules(arrayOf(rule, arrayOf(rule2, moreRules))), true).label(\"enforcedSequence\");\n    }\n\n    /**\n     * Creates a new rule that acts as a syntactic predicate, i.e. tests the given subrule against the current\n     * input position without actually matching any characters. Succeeds if the subrule succeeds and fails if the\n     * subrule rails.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule test(Object rule) {\n        return new TestMatcher(toRule(rule), false);\n    }\n\n    /**\n     * Creates a new rule that acts as an inverse syntactic predicate, i.e. tests the given subrule against the current\n     * input position without actually matching any characters. Succeeds if the subrule fails and fails if the\n     * subrule succeeds.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule testNot(Object rule) {\n        return new TestMatcher(toRule(rule), true);\n    }\n\n    /**\n     * Creates a new rule that tries repeated matches of its subrule.\n     * Succeeds always, even if the subrule doesn't match even once.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule zeroOrMore(Object rule) {\n        return new ZeroOrMoreMatcher(toRule(rule)).label(\"zeroOrMore\");\n    }\n\n    /**\n     * Matches the EOI (end of input) character.\n     *\n     * @return a new rule\n     */\n    public Rule eoi() {\n        return ch(Chars.EOI);\n    }\n\n    /**\n     * Matches any character and therefore always succeeds.\n     *\n     * @return a new rule\n     */\n    public Rule any() {\n        return ch(Chars.ANY);\n    }\n\n    /**\n     * Matches nothing and therefore always succeeds.\n     *\n     * @return a new rule\n     */\n    public Rule empty() {\n        return ch(Chars.EMPTY);\n    }\n\n    ////////////////////////////////// ACTION PARAMETERS ///////////////////////////////////\n\n    /**\n     * Changes the context scope of all arguments to the current parent scope.\n     *\n     * @param argument the arguments to change to context for\n     * @return the result of the arguments\n     */\n    public <T> T UP(T argument) {\n        Object arg = mixInParameter(actionParameters, argument);\n        actionParameters.add(new UpParameter(arg));\n        return null;\n    }\n\n    /**\n     * Changes the context scope of all arguments to the current sub scope.\n     *\n     * @param argument the arguments to change to context for\n     * @return the result of the arguments\n     */\n    public <T> T DOWN(T argument) {\n        Object arg = mixInParameter(actionParameters, argument);\n        actionParameters.add(new DownParameter(arg));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the first Node found with the given prefix path.\n     * The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public Node<V> NODE(String path) {\n        Object arg = mixInParameter(actionParameters, path);\n        actionParameters.add(new PathNodeParameter(arg));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to an array of Nodes found with the given prefix path.\n     * The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public List<Node<V>> NODES(String path) {\n        Object pathArg = mixInParameter(actionParameters, path);\n        actionParameters.add(new PathNodesParameter(pathArg));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the last node created during this parsing run.\n     *\n     * @return the action parameter\n     */\n    public Node<V> LAST_NODE() {\n        actionParameters.add(new LastNodeParameter());\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the tree value of the current rule level, i.e.,\n     * If there is an explicitly set value it is returned. Otherwise the last non-null child value, or, if there\n     * is no such value, null.\n     *\n     * @return the action parameter\n     */\n    public V VALUE() {\n        actionParameters.add(new TreeValueParameter<V>(nodeValueType));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the value of the first Node found with the given prefix path.\n     * The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public V VALUE(String path) {\n        NODE(path);\n        actionParameters.add(new ValueParameter<V>(nodeValueType, actionParameters.pop()));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to an array of node value for the Nodes found with the\n     * given prefix path. The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public List<V> VALUES(String path) {\n        NODES(path);\n        actionParameters.add(new ValuesParameter<V>(actionParameters.pop()));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the value of the last node created during this parsing run.\n     *\n     * @return the action parameter\n     */\n    public V LAST_VALUE() {\n        LAST_NODE();\n        actionParameters.add(new ValueParameter<V>(nodeValueType, actionParameters.pop()));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the matched input text of the first Node found with the\n     * given prefix path. The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public String TEXT(String path) {\n        NODE(path);\n        actionParameters.add(new TextParameter<V>(actionParameters.pop()));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to an array of input texts matched by the Nodes found with the\n     * given prefix path. The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public List<String> TEXTS(String path) {\n        NODES(path);\n        actionParameters.add(new TextsParameter<V>(actionParameters.pop()));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the matched input text of the\n     * last node created during this parsing run.\n     *\n     * @return the action parameter\n     */\n    public String LAST_TEXT() {\n        LAST_NODE();\n        actionParameters.add(new TextParameter<V>(actionParameters.pop()));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the first character of the matched input text of the first Node\n     * found with the given prefix path.\n     * The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public Character CHAR(String path) {\n        NODE(path);\n        actionParameters.add(new CharParameter<V>(actionParameters.pop()));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to an array of the first characters of the input texts matched\n     * by the Nodes found with the given prefix path.\n     * The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public List<Character> CHARS(String path) {\n        NODES(path);\n        actionParameters.add(new CharsParameter<V>(actionParameters.pop()));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the first character of the matched input text of the\n     * last node created during this parsing run.\n     *\n     * @return the action parameter\n     */\n    public Character LAST_CHAR() {\n        LAST_NODE();\n        actionParameters.add(new CharParameter<V>(actionParameters.pop()));\n        return null;\n    }\n\n    /**\n     * Creates a special action rule that sets the value of the parse tree node to be created for the current rule\n     * to the value of the last node created during the current parsing run.\n     *\n     * @return a new rule\n     */\n    public ActionResult SET() {\n        LAST_VALUE();\n        actionParameters.add(new SetValueParameter<V>(actionParameters.pop(), nodeValueType));\n        return null;\n    }\n\n    /**\n     * Creates a special action rule that sets the value of the parse tree node to be created for the current rule\n     * to the given value.\n     *\n     * @param value the value to set\n     * @return a new rule\n     */\n    public ActionResult SET(V value) {\n        Object valueArg = mixInParameter(actionParameters, value);\n        actionParameters.add(new SetValueParameter<V>(valueArg, nodeValueType));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to null.\n     *\n     * @return the action parameter\n     */\n    public Object NULL() {\n        actionParameters.add(new NullParameter());\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to an object using the given converter.\n     *\n     * @param text      the text (parameter) to convert\n     * @param converter the converter to use\n     * @return the action parameter\n     */\n    public <T> T CONVERT(String text, Converter<T> converter) {\n        Object converterArg = mixInParameter(actionParameters, converter);\n        Object textArg = mixInParameter(actionParameters, text);\n        List<Class<?>> convertedTypes = Utils.getTypeArguments(Converter.class, converterArg.getClass());\n        Preconditions.checkArgument(convertedTypes.size() == 1, \"Illegal converter\");\n        actionParameters.add(new ConvertParameter(convertedTypes.get(0), textArg, converterArg));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to an Integer.\n     *\n     * @param text the text (parameter) to convert\n     * @return the action parameter\n     */\n    public Integer CONVERT_TO_INTEGER(String text) {\n        return CONVERT(text, new Converter<Integer>() {\n            public Integer parse(String string) {\n                return Integer.parseInt(string);\n            }\n        });\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to a Long.\n     *\n     * @param text the text (parameter) to convert\n     * @return the action parameter\n     */\n    public Long CONVERT_TO_LONG(String text) {\n        return CONVERT(text, new Converter<Long>() {\n            public Long parse(String string) {\n                return Long.parseLong(string);\n            }\n        });\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to a Float.\n     *\n     * @param text the text (parameter) to convert\n     * @return the action parameter\n     */\n    public Float CONVERT_TO_FLOAT(String text) {\n        return CONVERT(text, new Converter<Float>() {\n            public Float parse(String string) {\n                return Float.parseFloat(string);\n            }\n        });\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to an Double.\n     *\n     * @param text the text (parameter) to convert\n     * @return the action parameter\n     */\n    public Double CONVERT_TO_DOUBLE(String text) {\n        return CONVERT(text, new Converter<Double>() {\n            public Double parse(String string) {\n                return Double.parseDouble(string);\n            }\n        });\n    }\n\n    ///************************* HELPER METHODS ***************************///\n\n    protected Rule fromCharLiteral(char c) {\n        return ch(c);\n    }\n\n    protected Rule fromStringLiteral(String string) {\n        return string(string);\n    }\n\n    protected Rule cached(Object key) {\n        return ruleCache.get(key);\n    }\n\n    protected Rule cache(Object key, Rule rule) {\n        ruleCache.put(key, rule);\n        return rule;\n    }\n\n    private Rule[] toRules(@NotNull Object[] objects) {\n        Rule[] rules = new Rule[objects.length];\n        for (int i = 0; i < objects.length; i++) {\n            rules[i] = toRule(objects[i]);\n        }\n        return rules;\n    }\n\n    private Rule toRule(Object obj) {\n        obj = mixInParameter(actionParameters, obj);\n        if (obj instanceof Rule) {\n            return (Rule) obj;\n        }\n        if (obj instanceof Character) {\n            Rule rule = cached(obj);\n            return rule != null ? rule : cache(obj, fromCharLiteral((Character) obj));\n        }\n        if (obj instanceof String) {\n            Rule rule = cached(obj);\n            return rule != null ? rule : cache(obj, fromStringLiteral((String) obj));\n        }\n        if (obj instanceof ActionParameter) {\n            return new ActionMatcher((ActionParameter) obj);\n        }\n        throw new ParserConstructionException(\"\\'\" + obj + \"\\' is not a valid Rule or parser action\");\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled;\n\nimport net.sf.cglib.proxy.Factory;\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.actionparameters.*;\nimport static org.parboiled.actionparameters.ActionParameterUtils.mixInParameter;\nimport org.parboiled.common.Converter;\nimport org.parboiled.common.Preconditions;\nimport org.parboiled.common.Utils;\nimport static org.parboiled.common.Utils.arrayOf;\nimport org.parboiled.matchers.*;\nimport org.parboiled.support.*;\n\nimport java.util.*;\n\n/**\n * Base class for custom parsers. Defines basic methods for rule and action parameter creation.\n *\n * @param <V> The type of the value field of the parse tree nodes created by this parser.\n * @param <A> The type of the parser Actions you would like to use in your rules. If you don't need any parser\n * actions (e.g. for very simple examples) you can just use the Actions interface directly.\n */\npublic abstract class BaseParser<V, A extends Actions<V>> {\n\n    private final Map<Character, Rule> charMatchers = new HashMap<Character, Rule>();\n    private final Map<String, Rule> stringMatchers = new HashMap<String, Rule>();\n    private final Class<V> nodeValueType; // the type of V, i.e. the value field of the parse tree nodes\n    final Stack<ActionParameter> actionParameters = new Stack<ActionParameter>();\n\n    /**\n     * The immutable reference to your parser actions.\n     */\n    public final A actions;\n\n    /**\n     * Constructs a new parser object using the given actions.\n     *\n     * @param actions the parser actions (can be null)\n     */\n    @SuppressWarnings({\"unchecked\"})\n    public BaseParser(A actions) {\n        this.actions = actions;\n        List<Class<?>> typeArguments = Utils.getTypeArguments(BaseParser.class, getClass());\n        Preconditions.checkState(typeArguments.size() == 2);\n        nodeValueType = (Class<V>) typeArguments.get(0);\n    }\n\n    /**\n     * Runs the given parser rule against the given input string. Note that the rule must have been created by\n     * a rule creation method of this parser object, which must have been created with Parser.create(...).\n     *\n     * @param rule  the rule\n     * @param input the input string\n     * @return the ParsingResult for the run\n     */\n    @SuppressWarnings({\"unchecked\"})\n    public ParsingResult<V> parse(@NotNull Rule rule, @NotNull String input) {\n        Checks.ensure(this instanceof Factory && ((Factory) this).getCallback(1) instanceof RuleInterceptor,\n                \"Illegal parser instance, please use Parboiled.createParser(...) for creating this parser\");\n\n        // prepare\n        InputBuffer inputBuffer = new InputBuffer(input);\n        InputLocation startLocation = new InputLocation(inputBuffer);\n        List<ParseError> parseErrors = new ArrayList<ParseError>();\n        Matcher<V> matcher = (Matcher<V>) rule;\n        MatcherContext<V> context = new MatcherContext<V>(startLocation, matcher, actions, parseErrors);\n\n        // the matcher tree has already been built during the call to Parboiled.parse(...), usually immediately\n        // before the invocation of this method, we need to signal to the ActionInterceptor that rule construction\n        // is over and all further action calls should not continue to createActions ActionMatchers but actually be\n        // \"routed through\" to the actual action method implementations\n        if (actions != null) {\n            ActionInterceptor actionInterceptor = (ActionInterceptor) ((Factory) actions).getCallback(1);\n            actionInterceptor.setParser(null);\n        }\n\n        // run the actual matcher tree\n        context.runMatcher(true);\n\n        return new ParsingResult<V>(context.getNode(), parseErrors, inputBuffer);\n    }\n\n    ////////////////////////////////// RULE CREATION ///////////////////////////////////\n\n    /**\n     * Explicitly creates a rule matching the given character.\n     * Normally you can just specify the character literal directly in you rule description. However, if you want\n     * to specify special rule attributes (like a label) you can also use this wrapper.\n     *\n     * @param c the char to match\n     * @return a new rule\n     */\n    public Rule ch(char c) {\n        return new CharMatcher(c);\n    }\n\n    /**\n     * Creates a rule matching a range of characters from cLow to cHigh (both inclusively).\n     *\n     * @param cLow  the start char of the range (inclusively)\n     * @param cHigh the end char of the range (inclusively)\n     * @return a new rule\n     */\n    public Rule charRange(char cLow, char cHigh) {\n        return cLow == cHigh ? ch(cLow) : new CharRangeMatcher(cLow, cHigh);\n    }\n\n    /**\n     * Explicitly creates a rule matching the given string.\n     * Normally you can just specify the string literal directly in you rule description. However, if you want\n     * to specify special rule attributes (like a label) you can also use this wrapper.\n     *\n     * @param string the string to match\n     * @return a new rule\n     */\n    public Rule string(@NotNull String string) {\n        Rule[] matchers = new Rule[string.length()];\n        for (int i = 0; i < string.length(); i++) matchers[i] = cachedChar(string.charAt(i));\n        return new SequenceMatcher(matchers, false).label(string);\n    }\n\n    /**\n     * Creates a new rule that successively tries all of the given subrules and succeeds when the first one of\n     * its subrules matches. If all subrules fail this rule fails as well.\n     *\n     * @param rule      the first subrule\n     * @param rule2     the second subrule\n     * @param moreRules the other subrules\n     * @return a new rule\n     */\n    public Rule firstOf(@NotNull Object rule, Object rule2, Object... moreRules) {\n        return new FirstOfMatcher(toRules(arrayOf(rule, arrayOf(rule2, moreRules)))).label(\"firstOf\");\n    }\n\n    /**\n     * Creates a new rule that tries repeated matches of its subrule and succeeds if the subrule matches at least once.\n     * If the subrule does not match at least once this rule fails.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule oneOrMore(@NotNull Object rule) {\n        return new OneOrMoreMatcher(toRule(rule)).label(\"oneOrMore\");\n    }\n\n    /**\n     * Creates a new rule that tries a match on its subrule and always succeeds, independently of the matching\n     * success of its subrule.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule optional(@NotNull Object rule) {\n        return new OptionalMatcher(toRule(rule)).label(\"optional\");\n    }\n\n    /**\n     * Creates a new rule that only succeeds if all of its subrule succeed, one after the other.\n     *\n     * @param rule      the first subrule\n     * @param rule2     the second subrule\n     * @param moreRules the other subrules\n     * @return a new rule\n     */\n    public Rule sequence(@NotNull Object rule, Object rule2, Object... moreRules) {\n        return new SequenceMatcher(toRules(arrayOf(rule, arrayOf(rule2, moreRules))), false).label(\"sequence\");\n    }\n\n    /**\n     * Creates a new rule that only succeeds if all of its subrules succeed, one after the other.\n     * However, after the first subrule has matched all further subrule matches are enforced, i.e. if one of them\n     * fails a ParseError will be created (and error recovery will be tried).\n     *\n     * @param rule      the first subrule\n     * @param rule2     the second subrule\n     * @param moreRules the other subrules\n     * @return a new rule\n     */\n    public Rule enforcedSequence(@NotNull Object rule, Object rule2, Object... moreRules) {\n        return new SequenceMatcher(toRules(arrayOf(rule, arrayOf(rule2, moreRules))), true).label(\"enforcedSequence\");\n    }\n\n    /**\n     * Creates a new rule that acts as a syntactic predicate, i.e. tests the given subrule against the current\n     * input position without actually matching any characters. Succeeds if the subrule succeeds and fails if the\n     * subrule rails.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule test(@NotNull Object rule) {\n        return new TestMatcher(toRule(rule), false);\n    }\n\n    /**\n     * Creates a new rule that acts as an inverse syntactic predicate, i.e. tests the given subrule against the current\n     * input position without actually matching any characters. Succeeds if the subrule fails and fails if the\n     * subrule succeeds.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule testNot(@NotNull Object rule) {\n        return new TestMatcher(toRule(rule), true);\n    }\n\n    /**\n     * Creates a new rule that tries repeated matches of its subrule.\n     * Succeeds always, even if the subrule doesn't match even once.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule zeroOrMore(@NotNull Object rule) {\n        return new ZeroOrMoreMatcher(toRule(rule)).label(\"zeroOrMore\");\n    }\n\n    /**\n     * Matches the EOI (end of input) character.\n     *\n     * @return a new rule\n     */\n    public Rule eoi() {\n        return ch(Chars.EOI);\n    }\n\n    /**\n     * Matches any character and therefore always succeeds.\n     *\n     * @return a new rule\n     */\n    public Rule any() {\n        return ch(Chars.ANY);\n    }\n\n    /**\n     * Matches nothing and therefore always succeeds.\n     *\n     * @return a new rule\n     */\n    public Rule empty() {\n        return ch(Chars.EMPTY);\n    }\n\n    ////////////////////////////////// ACTION PARAMETERS ///////////////////////////////////\n\n    /**\n     * Changes the context scope of all arguments to the current parent scope.\n     *\n     * @param argument the arguments to change to context for\n     * @return the result of the arguments\n     */\n    public <T> T UP(T argument) {\n        Object arg = mixInParameter(actionParameters, argument);\n        actionParameters.add(new UpParameter(arg));\n        return null;\n    }\n\n    /**\n     * Changes the context scope of all arguments to the current sub scope.\n     *\n     * @param argument the arguments to change to context for\n     * @return the result of the arguments\n     */\n    public <T> T DOWN(T argument) {\n        Object arg = mixInParameter(actionParameters, argument);\n        actionParameters.add(new DownParameter(arg));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the first Node found with the given prefix path.\n     * The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public Node<V> NODE(@NotNull String path) {\n        Object arg = mixInParameter(actionParameters, path);\n        actionParameters.add(new PathNodeParameter(arg));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to an array of Nodes found with the given prefix path.\n     * The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public List<Node<V>> NODES(@NotNull String path) {\n        Object pathArg = mixInParameter(actionParameters, path);\n        actionParameters.add(new PathNodesParameter(pathArg));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the last node created during this parsing run.\n     *\n     * @return the action parameter\n     */\n    public Node<V> LAST_NODE() {\n        actionParameters.add(new LastNodeParameter());\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the tree value of the current rule level, i.e.,\n     * If there is an explicitly set value it is returned. Otherwise the last non-null child value, or, if there\n     * is no such value, null.\n     *\n     * @return the action parameter\n     */\n    public V VALUE() {\n        actionParameters.add(new TreeValueParameter<V>(nodeValueType));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the value of the first Node found with the given prefix path.\n     * The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public V VALUE(String path) {\n        NODE(path);\n        actionParameters.add(new ValueParameter<V>(nodeValueType, actionParameters.pop()));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to an array of node value for the Nodes found with the\n     * given prefix path. The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public List<V> VALUES(String path) {\n        NODES(path);\n        actionParameters.add(new ValuesParameter<V>(actionParameters.pop()));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the value of the last node created during this parsing run.\n     *\n     * @return the action parameter\n     */\n    public V LAST_VALUE() {\n        LAST_NODE();\n        actionParameters.add(new ValueParameter<V>(nodeValueType, actionParameters.pop()));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the matched input text of the first Node found with the\n     * given prefix path. The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public String TEXT(String path) {\n        NODE(path);\n        actionParameters.add(new TextParameter<V>(actionParameters.pop()));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to an array of input texts matched by the Nodes found with the\n     * given prefix path. The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public List<String> TEXTS(String path) {\n        NODES(path);\n        actionParameters.add(new TextsParameter<V>(actionParameters.pop()));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the matched input text of the\n     * last node created during this parsing run.\n     *\n     * @return the action parameter\n     */\n    public String LAST_TEXT() {\n        LAST_NODE();\n        actionParameters.add(new TextParameter<V>(actionParameters.pop()));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the first character of the matched input text of the first Node\n     * found with the given prefix path.\n     * The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public Character CHAR(String path) {\n        NODE(path);\n        actionParameters.add(new CharParameter<V>(actionParameters.pop()));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to an array of the first characters of the input texts matched\n     * by the Nodes found with the given prefix path.\n     * The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public List<Character> CHARS(String path) {\n        NODES(path);\n        actionParameters.add(new CharsParameter<V>(actionParameters.pop()));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the first character of the matched input text of the\n     * last node created during this parsing run.\n     *\n     * @return the action parameter\n     */\n    public Character LAST_CHAR() {\n        LAST_NODE();\n        actionParameters.add(new CharParameter<V>(actionParameters.pop()));\n        return null;\n    }\n\n    /**\n     * Creates a special action rule that sets the value of the parse tree node to be created for the current rule\n     * to the value of the last node created during the current parsing run.\n     *\n     * @return a new rule\n     */\n    public ActionResult SET() {\n        LAST_VALUE();\n        actionParameters.add(new SetValueParameter<V>(actionParameters.pop(), nodeValueType));\n        return null;\n    }\n\n    /**\n     * Creates a special action rule that sets the value of the parse tree node to be created for the current rule\n     * to the given value.\n     *\n     * @param value the value to set\n     * @return a new rule\n     */\n    public ActionResult SET(V value) {\n        Object valueArg = mixInParameter(actionParameters, value);\n        actionParameters.add(new SetValueParameter<V>(valueArg, nodeValueType));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to null.\n     *\n     * @return the action parameter\n     */\n    public Object NULL() {\n        actionParameters.add(new NullParameter());\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to an object using the given converter.\n     *\n     * @param text      the text (parameter) to convert\n     * @param converter the converter to use\n     * @return the action parameter\n     */\n    public <T> T CONVERT(String text, @NotNull Converter<T> converter) {\n        Object textArg = mixInParameter(actionParameters, text);\n        List<Class<?>> convertedTypes = Utils.getTypeArguments(Converter.class, converter.getClass());\n        Preconditions.checkArgument(convertedTypes.size() == 1, \"Illegal converter\");\n        actionParameters.add(new ConvertParameter<T>(convertedTypes.get(0), textArg, converter));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to an Integer.\n     *\n     * @param text the text (parameter) to convert\n     * @return the action parameter\n     */\n    public Integer CONVERT_TO_INTEGER(String text) {\n        return CONVERT(text, new Converter<Integer>() {\n            public Integer parse(String string) {\n                return Integer.parseInt(string);\n            }\n        });\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to a Long.\n     *\n     * @param text the text (parameter) to convert\n     * @return the action parameter\n     */\n    public Long CONVERT_TO_LONG(String text) {\n        return CONVERT(text, new Converter<Long>() {\n            public Long parse(String string) {\n                return Long.parseLong(string);\n            }\n        });\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to a Float.\n     *\n     * @param text the text (parameter) to convert\n     * @return the action parameter\n     */\n    public Float CONVERT_TO_FLOAT(String text) {\n        return CONVERT(text, new Converter<Float>() {\n            public Float parse(String string) {\n                return Float.parseFloat(string);\n            }\n        });\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to an Double.\n     *\n     * @param text the text (parameter) to convert\n     * @return the action parameter\n     */\n    public Double CONVERT_TO_DOUBLE(String text) {\n        return CONVERT(text, new Converter<Double>() {\n            public Double parse(String string) {\n                return Double.parseDouble(string);\n            }\n        });\n    }\n\n    ///************************* PRIVATE ***************************///\n\n    private Rule cachedChar(char c) {\n        Rule matcher = charMatchers.get(c);\n        if (matcher == null) {\n            matcher = ch(c);\n            charMatchers.put(c, matcher);\n        }\n        return matcher;\n    }\n\n    private Rule cachedString(String string) {\n        Rule matcher = stringMatchers.get(string);\n        if (matcher == null) {\n            matcher = string(string);\n            stringMatchers.put(string, matcher);\n        }\n        return matcher;\n    }\n\n    private Rule[] toRules(@NotNull Object[] objects) {\n        Rule[] rules = new Rule[objects.length];\n        for (int i = 0; i < objects.length; i++) {\n            rules[i] = toRule(objects[i]);\n        }\n        return rules;\n    }\n\n    private Rule toRule(Object obj) {\n        obj = mixInParameter(actionParameters, obj);\n        if (obj instanceof Rule) {\n            return (Rule) obj;\n        }\n        if (obj instanceof Character) {\n            return cachedChar((Character) obj);\n        }\n        if (obj instanceof String) {\n            return cachedString((String) obj);\n        }\n        if (obj instanceof ActionParameter) {\n            return new ActionMatcher((ActionParameter) obj);\n        }\n        throw new ParserConstructionException(\"\\'\" + obj + \"\\' is not a valid Rule or parser action\");\n    }\n\n}\n","lineNo":145}
{"Refactored Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled;\n\nimport net.sf.cglib.proxy.Factory;\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.actionparameters.*;\nimport static org.parboiled.actionparameters.ActionParameterUtils.mixInParameter;\nimport org.parboiled.common.Converter;\nimport org.parboiled.common.Preconditions;\nimport org.parboiled.common.Utils;\nimport static org.parboiled.common.Utils.arrayOf;\nimport org.parboiled.matchers.*;\nimport org.parboiled.support.*;\n\nimport java.util.*;\n\n/**\n * Base class for custom parsers. Defines basic methods for rule and action parameter creation.\n *\n * @param <V> The type of the value field of the parse tree nodes created by this parser.\n * @param <A> The type of the parser Actions you would like to use in your rules. If you don't need any parser\n * actions (e.g. for very simple examples) you can just use the Actions interface directly.\n */\npublic abstract class BaseParser<V, A extends Actions<V>> {\n\n    /**\n     * Cache of frequently used, bottom level rules. Per default used character and string matching rules.\n     */\n    private final Map<Object, Rule> ruleCache = new HashMap<Object, Rule>();\n\n    /**\n     * The actual type of the V type argument, i.e. the value field of the generated parse tree nodes.\n     */\n    private final Class<V> nodeValueType;\n\n    /**\n     * Stack for action parameters. Used for creation of actual arguments to action methods.\n     */\n    final Stack<ActionParameter> actionParameters = new Stack<ActionParameter>();\n\n    /**\n     * The immutable reference to your parser actions.\n     */\n    public final A actions;\n\n    /**\n     * Constructs a new parser object using the given actions.\n     *\n     * @param actions the parser actions (can be null)\n     */\n    @SuppressWarnings({\"unchecked\"})\n    public BaseParser(A actions) {\n        this.actions = actions;\n        List<Class<?>> typeArguments = Utils.getTypeArguments(BaseParser.class, getClass());\n        Preconditions.checkState(typeArguments.size() == 2);\n        nodeValueType = (Class<V>) typeArguments.get(0);\n    }\n\n    /**\n     * Runs the given parser rule against the given input string. Note that the rule must have been created by\n     * a rule creation method of this parser object, which must have been created with Parser.create(...).\n     *\n     * @param rule  the rule\n     * @param input the input string\n     * @return the ParsingResult for the run\n     */\n    @SuppressWarnings({\"unchecked\"})\n    public ParsingResult<V> parse(Rule rule, @NotNull String input) {\n        Checks.ensure(this instanceof Factory && ((Factory) this).getCallback(1) instanceof RuleInterceptor,\n                \"Illegal parser instance, please use Parboiled.createParser(...) for creating this parser\");\n\n        // prepare\n        InputBuffer inputBuffer = new InputBuffer(input);\n        InputLocation startLocation = new InputLocation(inputBuffer);\n        List<ParseError> parseErrors = new ArrayList<ParseError>();\n        Matcher<V> matcher = (Matcher<V>) toRule(rule);\n        MatcherContext<V> context = new MatcherContext<V>(startLocation, matcher, actions, parseErrors);\n\n        // the matcher tree has already been built during the call to Parboiled.parse(...), usually immediately\n        // before the invocation of this method, we need to signal to the ActionInterceptor that rule construction\n        // is over and all further action calls should not continue to createActions ActionMatchers but actually be\n        // \"routed through\" to the actual action method implementations\n        if (actions != null) {\n            ActionInterceptor actionInterceptor = (ActionInterceptor) ((Factory) actions).getCallback(1);\n            actionInterceptor.setParser(null);\n        }\n\n        // run the actual matcher tree\n        context.runMatcher(true);\n\n        return new ParsingResult<V>(context.getNode(), parseErrors, inputBuffer);\n    }\n\n    ////////////////////////////////// RULE CREATION ///////////////////////////////////\n\n    /**\n     * Explicitly creates a rule matching the given character.\n     * Normally you can just specify the character literal directly in you rule description.\n     * However, you can also use this wrapper.\n     *\n     * @param c the char to match\n     * @return a new rule\n     */\n    public Rule ch(char c) {\n        return new CharMatcher(c);\n    }\n\n    /**\n     * Creates a rule matching a range of characters from cLow to cHigh (both inclusively).\n     *\n     * @param cLow  the start char of the range (inclusively)\n     * @param cHigh the end char of the range (inclusively)\n     * @return a new rule\n     */\n    public Rule charRange(char cLow, char cHigh) {\n        return cLow == cHigh ? ch(cLow) : new CharRangeMatcher(cLow, cHigh);\n    }\n\n    /**\n     * Explicitly creates a rule matching the given string.\n     * Normally you can just specify the string literal directly in you rule description.\n     * However, you can also use this wrapper.\n     *\n     * @param string the string to match\n     * @return a new rule\n     */\n    public Rule string(String string) {\n        Rule[] matchers = new Rule[string.length()];\n        for (int i = 0; i < string.length(); i++) {\n            char c = string.charAt(i);\n            Rule rule = cached(c);\n            matchers[i] = rule != null ? rule : cache(c, ch(c));\n        }\n        return new SequenceMatcher(matchers, false).label(string);\n    }\n\n    /**\n     * Creates a new rule that successively tries all of the given subrules and succeeds when the first one of\n     * its subrules matches. If all subrules fail this rule fails as well.\n     *\n     * @param rule      the first subrule\n     * @param rule2     the second subrule\n     * @param moreRules the other subrules\n     * @return a new rule\n     */\n    public Rule firstOf(Object rule, Object rule2, Object... moreRules) {\n        return new FirstOfMatcher(toRules(arrayOf(rule, arrayOf(rule2, moreRules)))).label(\"firstOf\");\n    }\n\n    /**\n     * Creates a new rule that tries repeated matches of its subrule and succeeds if the subrule matches at least once.\n     * If the subrule does not match at least once this rule fails.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule oneOrMore(Object rule) {\n        return new OneOrMoreMatcher(toRule(rule)).label(\"oneOrMore\");\n    }\n\n    /**\n     * Creates a new rule that tries a match on its subrule and always succeeds, independently of the matching\n     * success of its subrule.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule optional(Object rule) {\n        return new OptionalMatcher(toRule(rule)).label(\"optional\");\n    }\n\n    /**\n     * Creates a new rule that only succeeds if all of its subrule succeed, one after the other.\n     *\n     * @param rule      the first subrule\n     * @param rule2     the second subrule\n     * @param moreRules the other subrules\n     * @return a new rule\n     */\n    public Rule sequence(Object rule, Object rule2, Object... moreRules) {\n        return new SequenceMatcher(toRules(arrayOf(rule, arrayOf(rule2, moreRules))), false).label(\"sequence\");\n    }\n\n    /**\n     * Creates a new rule that only succeeds if all of its subrules succeed, one after the other.\n     * However, after the first subrule has matched all further subrule matches are enforced, i.e. if one of them\n     * fails a ParseError will be created (and error recovery will be tried).\n     *\n     * @param rule      the first subrule\n     * @param rule2     the second subrule\n     * @param moreRules the other subrules\n     * @return a new rule\n     */\n    public Rule enforcedSequence(Object rule, Object rule2, Object... moreRules) {\n        return new SequenceMatcher(toRules(arrayOf(rule, arrayOf(rule2, moreRules))), true).label(\"enforcedSequence\");\n    }\n\n    /**\n     * Creates a new rule that acts as a syntactic predicate, i.e. tests the given subrule against the current\n     * input position without actually matching any characters. Succeeds if the subrule succeeds and fails if the\n     * subrule rails.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule test(Object rule) {\n        return new TestMatcher(toRule(rule), false);\n    }\n\n    /**\n     * Creates a new rule that acts as an inverse syntactic predicate, i.e. tests the given subrule against the current\n     * input position without actually matching any characters. Succeeds if the subrule fails and fails if the\n     * subrule succeeds.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule testNot(Object rule) {\n        return new TestMatcher(toRule(rule), true);\n    }\n\n    /**\n     * Creates a new rule that tries repeated matches of its subrule.\n     * Succeeds always, even if the subrule doesn't match even once.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule zeroOrMore(Object rule) {\n        return new ZeroOrMoreMatcher(toRule(rule)).label(\"zeroOrMore\");\n    }\n\n    /**\n     * Matches the EOI (end of input) character.\n     *\n     * @return a new rule\n     */\n    public Rule eoi() {\n        return ch(Chars.EOI);\n    }\n\n    /**\n     * Matches any character and therefore always succeeds.\n     *\n     * @return a new rule\n     */\n    public Rule any() {\n        return ch(Chars.ANY);\n    }\n\n    /**\n     * Matches nothing and therefore always succeeds.\n     *\n     * @return a new rule\n     */\n    public Rule empty() {\n        return ch(Chars.EMPTY);\n    }\n\n    ////////////////////////////////// ACTION PARAMETERS ///////////////////////////////////\n\n    /**\n     * Changes the context scope of all arguments to the current parent scope.\n     *\n     * @param argument the arguments to change to context for\n     * @return the result of the arguments\n     */\n    public <T> T UP(T argument) {\n        Object arg = mixInParameter(actionParameters, argument);\n        actionParameters.add(new UpParameter(arg));\n        return null;\n    }\n\n    /**\n     * Changes the context scope of all arguments to the current sub scope.\n     *\n     * @param argument the arguments to change to context for\n     * @return the result of the arguments\n     */\n    public <T> T DOWN(T argument) {\n        Object arg = mixInParameter(actionParameters, argument);\n        actionParameters.add(new DownParameter(arg));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the first Node found with the given prefix path.\n     * The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public Node<V> NODE(String path) {\n        Object arg = mixInParameter(actionParameters, path);\n        actionParameters.add(new PathNodeParameter(arg));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to an array of Nodes found with the given prefix path.\n     * The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public List<Node<V>> NODES(String path) {\n        Object pathArg = mixInParameter(actionParameters, path);\n        actionParameters.add(new PathNodesParameter(pathArg));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the last node created during this parsing run.\n     *\n     * @return the action parameter\n     */\n    public Node<V> LAST_NODE() {\n        actionParameters.add(new LastNodeParameter());\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the tree value of the current rule level, i.e.,\n     * If there is an explicitly set value it is returned. Otherwise the last non-null child value, or, if there\n     * is no such value, null.\n     *\n     * @return the action parameter\n     */\n    public V VALUE() {\n        actionParameters.add(new TreeValueParameter<V>(nodeValueType));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the value of the first Node found with the given prefix path.\n     * The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public V VALUE(String path) {\n        NODE(path);\n        actionParameters.add(new ValueParameter<V>(nodeValueType, actionParameters.pop()));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to an array of node value for the Nodes found with the\n     * given prefix path. The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public List<V> VALUES(String path) {\n        NODES(path);\n        actionParameters.add(new ValuesParameter<V>(actionParameters.pop()));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the value of the last node created during this parsing run.\n     *\n     * @return the action parameter\n     */\n    public V LAST_VALUE() {\n        LAST_NODE();\n        actionParameters.add(new ValueParameter<V>(nodeValueType, actionParameters.pop()));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the matched input text of the first Node found with the\n     * given prefix path. The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public String TEXT(String path) {\n        NODE(path);\n        actionParameters.add(new TextParameter<V>(actionParameters.pop()));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to an array of input texts matched by the Nodes found with the\n     * given prefix path. The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public List<String> TEXTS(String path) {\n        NODES(path);\n        actionParameters.add(new TextsParameter<V>(actionParameters.pop()));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the matched input text of the\n     * last node created during this parsing run.\n     *\n     * @return the action parameter\n     */\n    public String LAST_TEXT() {\n        LAST_NODE();\n        actionParameters.add(new TextParameter<V>(actionParameters.pop()));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the first character of the matched input text of the first Node\n     * found with the given prefix path.\n     * The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public Character CHAR(String path) {\n        NODE(path);\n        actionParameters.add(new CharParameter<V>(actionParameters.pop()));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to an array of the first characters of the input texts matched\n     * by the Nodes found with the given prefix path.\n     * The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public List<Character> CHARS(String path) {\n        NODES(path);\n        actionParameters.add(new CharsParameter<V>(actionParameters.pop()));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the first character of the matched input text of the\n     * last node created during this parsing run.\n     *\n     * @return the action parameter\n     */\n    public Character LAST_CHAR() {\n        LAST_NODE();\n        actionParameters.add(new CharParameter<V>(actionParameters.pop()));\n        return null;\n    }\n\n    /**\n     * Creates a special action rule that sets the value of the parse tree node to be created for the current rule\n     * to the value of the last node created during the current parsing run.\n     *\n     * @return a new rule\n     */\n    public ActionResult SET() {\n        LAST_VALUE();\n        actionParameters.add(new SetValueParameter<V>(actionParameters.pop(), nodeValueType));\n        return null;\n    }\n\n    /**\n     * Creates a special action rule that sets the value of the parse tree node to be created for the current rule\n     * to the given value.\n     *\n     * @param value the value to set\n     * @return a new rule\n     */\n    public ActionResult SET(V value) {\n        Object valueArg = mixInParameter(actionParameters, value);\n        actionParameters.add(new SetValueParameter<V>(valueArg, nodeValueType));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to null.\n     *\n     * @return the action parameter\n     */\n    public Object NULL() {\n        actionParameters.add(new NullParameter());\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to an object using the given converter.\n     *\n     * @param text      the text (parameter) to convert\n     * @param converter the converter to use\n     * @return the action parameter\n     */\n    public <T> T CONVERT(String text, Converter<T> converter) {\n        Object converterArg = mixInParameter(actionParameters, converter);\n        Object textArg = mixInParameter(actionParameters, text);\n        List<Class<?>> convertedTypes = Utils.getTypeArguments(Converter.class, converterArg.getClass());\n        Preconditions.checkArgument(convertedTypes.size() == 1, \"Illegal converter\");\n        actionParameters.add(new ConvertParameter(convertedTypes.get(0), textArg, converterArg));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to an Integer.\n     *\n     * @param text the text (parameter) to convert\n     * @return the action parameter\n     */\n    public Integer CONVERT_TO_INTEGER(String text) {\n        return CONVERT(text, new Converter<Integer>() {\n            public Integer parse(String string) {\n                return Integer.parseInt(string);\n            }\n        });\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to a Long.\n     *\n     * @param text the text (parameter) to convert\n     * @return the action parameter\n     */\n    public Long CONVERT_TO_LONG(String text) {\n        return CONVERT(text, new Converter<Long>() {\n            public Long parse(String string) {\n                return Long.parseLong(string);\n            }\n        });\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to a Float.\n     *\n     * @param text the text (parameter) to convert\n     * @return the action parameter\n     */\n    public Float CONVERT_TO_FLOAT(String text) {\n        return CONVERT(text, new Converter<Float>() {\n            public Float parse(String string) {\n                return Float.parseFloat(string);\n            }\n        });\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to an Double.\n     *\n     * @param text the text (parameter) to convert\n     * @return the action parameter\n     */\n    public Double CONVERT_TO_DOUBLE(String text) {\n        return CONVERT(text, new Converter<Double>() {\n            public Double parse(String string) {\n                return Double.parseDouble(string);\n            }\n        });\n    }\n\n    ///************************* HELPER METHODS ***************************///\n\n    protected Rule fromCharLiteral(char c) {\n        return ch(c);\n    }\n\n    protected Rule fromStringLiteral(String string) {\n        return string(string);\n    }\n\n    protected Rule cached(Object key) {\n        return ruleCache.get(key);\n    }\n\n    protected Rule cache(Object key, Rule rule) {\n        ruleCache.put(key, rule);\n        return rule;\n    }\n\n    private Rule[] toRules(@NotNull Object[] objects) {\n        Rule[] rules = new Rule[objects.length];\n        for (int i = 0; i < objects.length; i++) {\n            rules[i] = toRule(objects[i]);\n        }\n        return rules;\n    }\n\n    private Rule toRule(Object obj) {\n        obj = mixInParameter(actionParameters, obj);\n        if (obj instanceof Rule) {\n            return (Rule) obj;\n        }\n        if (obj instanceof Character) {\n            Rule rule = cached(obj);\n            return rule != null ? rule : cache(obj, fromCharLiteral((Character) obj));\n        }\n        if (obj instanceof String) {\n            Rule rule = cached(obj);\n            return rule != null ? rule : cache(obj, fromStringLiteral((String) obj));\n        }\n        if (obj instanceof ActionParameter) {\n            return new ActionMatcher((ActionParameter) obj);\n        }\n        throw new ParserConstructionException(\"\\'\" + obj + \"\\' is not a valid Rule or parser action\");\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled;\n\nimport net.sf.cglib.proxy.Factory;\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.actionparameters.*;\nimport static org.parboiled.actionparameters.ActionParameterUtils.mixInParameter;\nimport org.parboiled.common.Converter;\nimport org.parboiled.common.Preconditions;\nimport org.parboiled.common.Utils;\nimport static org.parboiled.common.Utils.arrayOf;\nimport org.parboiled.matchers.*;\nimport org.parboiled.support.*;\n\nimport java.util.*;\n\n/**\n * Base class for custom parsers. Defines basic methods for rule and action parameter creation.\n *\n * @param <V> The type of the value field of the parse tree nodes created by this parser.\n * @param <A> The type of the parser Actions you would like to use in your rules. If you don't need any parser\n * actions (e.g. for very simple examples) you can just use the Actions interface directly.\n */\npublic abstract class BaseParser<V, A extends Actions<V>> {\n\n    private final Map<Character, Rule> charMatchers = new HashMap<Character, Rule>();\n    private final Map<String, Rule> stringMatchers = new HashMap<String, Rule>();\n    private final Class<V> nodeValueType; // the type of V, i.e. the value field of the parse tree nodes\n    final Stack<ActionParameter> actionParameters = new Stack<ActionParameter>();\n\n    /**\n     * The immutable reference to your parser actions.\n     */\n    public final A actions;\n\n    /**\n     * Constructs a new parser object using the given actions.\n     *\n     * @param actions the parser actions (can be null)\n     */\n    @SuppressWarnings({\"unchecked\"})\n    public BaseParser(A actions) {\n        this.actions = actions;\n        List<Class<?>> typeArguments = Utils.getTypeArguments(BaseParser.class, getClass());\n        Preconditions.checkState(typeArguments.size() == 2);\n        nodeValueType = (Class<V>) typeArguments.get(0);\n    }\n\n    /**\n     * Runs the given parser rule against the given input string. Note that the rule must have been created by\n     * a rule creation method of this parser object, which must have been created with Parser.create(...).\n     *\n     * @param rule  the rule\n     * @param input the input string\n     * @return the ParsingResult for the run\n     */\n    @SuppressWarnings({\"unchecked\"})\n    public ParsingResult<V> parse(@NotNull Rule rule, @NotNull String input) {\n        Checks.ensure(this instanceof Factory && ((Factory) this).getCallback(1) instanceof RuleInterceptor,\n                \"Illegal parser instance, please use Parboiled.createParser(...) for creating this parser\");\n\n        // prepare\n        InputBuffer inputBuffer = new InputBuffer(input);\n        InputLocation startLocation = new InputLocation(inputBuffer);\n        List<ParseError> parseErrors = new ArrayList<ParseError>();\n        Matcher<V> matcher = (Matcher<V>) rule;\n        MatcherContext<V> context = new MatcherContext<V>(startLocation, matcher, actions, parseErrors);\n\n        // the matcher tree has already been built during the call to Parboiled.parse(...), usually immediately\n        // before the invocation of this method, we need to signal to the ActionInterceptor that rule construction\n        // is over and all further action calls should not continue to createActions ActionMatchers but actually be\n        // \"routed through\" to the actual action method implementations\n        if (actions != null) {\n            ActionInterceptor actionInterceptor = (ActionInterceptor) ((Factory) actions).getCallback(1);\n            actionInterceptor.setParser(null);\n        }\n\n        // run the actual matcher tree\n        context.runMatcher(true);\n\n        return new ParsingResult<V>(context.getNode(), parseErrors, inputBuffer);\n    }\n\n    ////////////////////////////////// RULE CREATION ///////////////////////////////////\n\n    /**\n     * Explicitly creates a rule matching the given character.\n     * Normally you can just specify the character literal directly in you rule description. However, if you want\n     * to specify special rule attributes (like a label) you can also use this wrapper.\n     *\n     * @param c the char to match\n     * @return a new rule\n     */\n    public Rule ch(char c) {\n        return new CharMatcher(c);\n    }\n\n    /**\n     * Creates a rule matching a range of characters from cLow to cHigh (both inclusively).\n     *\n     * @param cLow  the start char of the range (inclusively)\n     * @param cHigh the end char of the range (inclusively)\n     * @return a new rule\n     */\n    public Rule charRange(char cLow, char cHigh) {\n        return cLow == cHigh ? ch(cLow) : new CharRangeMatcher(cLow, cHigh);\n    }\n\n    /**\n     * Explicitly creates a rule matching the given string.\n     * Normally you can just specify the string literal directly in you rule description. However, if you want\n     * to specify special rule attributes (like a label) you can also use this wrapper.\n     *\n     * @param string the string to match\n     * @return a new rule\n     */\n    public Rule string(@NotNull String string) {\n        Rule[] matchers = new Rule[string.length()];\n        for (int i = 0; i < string.length(); i++) matchers[i] = cachedChar(string.charAt(i));\n        return new SequenceMatcher(matchers, false).label(string);\n    }\n\n    /**\n     * Creates a new rule that successively tries all of the given subrules and succeeds when the first one of\n     * its subrules matches. If all subrules fail this rule fails as well.\n     *\n     * @param rule      the first subrule\n     * @param rule2     the second subrule\n     * @param moreRules the other subrules\n     * @return a new rule\n     */\n    public Rule firstOf(@NotNull Object rule, Object rule2, Object... moreRules) {\n        return new FirstOfMatcher(toRules(arrayOf(rule, arrayOf(rule2, moreRules)))).label(\"firstOf\");\n    }\n\n    /**\n     * Creates a new rule that tries repeated matches of its subrule and succeeds if the subrule matches at least once.\n     * If the subrule does not match at least once this rule fails.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule oneOrMore(@NotNull Object rule) {\n        return new OneOrMoreMatcher(toRule(rule)).label(\"oneOrMore\");\n    }\n\n    /**\n     * Creates a new rule that tries a match on its subrule and always succeeds, independently of the matching\n     * success of its subrule.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule optional(@NotNull Object rule) {\n        return new OptionalMatcher(toRule(rule)).label(\"optional\");\n    }\n\n    /**\n     * Creates a new rule that only succeeds if all of its subrule succeed, one after the other.\n     *\n     * @param rule      the first subrule\n     * @param rule2     the second subrule\n     * @param moreRules the other subrules\n     * @return a new rule\n     */\n    public Rule sequence(@NotNull Object rule, Object rule2, Object... moreRules) {\n        return new SequenceMatcher(toRules(arrayOf(rule, arrayOf(rule2, moreRules))), false).label(\"sequence\");\n    }\n\n    /**\n     * Creates a new rule that only succeeds if all of its subrules succeed, one after the other.\n     * However, after the first subrule has matched all further subrule matches are enforced, i.e. if one of them\n     * fails a ParseError will be created (and error recovery will be tried).\n     *\n     * @param rule      the first subrule\n     * @param rule2     the second subrule\n     * @param moreRules the other subrules\n     * @return a new rule\n     */\n    public Rule enforcedSequence(@NotNull Object rule, Object rule2, Object... moreRules) {\n        return new SequenceMatcher(toRules(arrayOf(rule, arrayOf(rule2, moreRules))), true).label(\"enforcedSequence\");\n    }\n\n    /**\n     * Creates a new rule that acts as a syntactic predicate, i.e. tests the given subrule against the current\n     * input position without actually matching any characters. Succeeds if the subrule succeeds and fails if the\n     * subrule rails.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule test(@NotNull Object rule) {\n        return new TestMatcher(toRule(rule), false);\n    }\n\n    /**\n     * Creates a new rule that acts as an inverse syntactic predicate, i.e. tests the given subrule against the current\n     * input position without actually matching any characters. Succeeds if the subrule fails and fails if the\n     * subrule succeeds.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule testNot(@NotNull Object rule) {\n        return new TestMatcher(toRule(rule), true);\n    }\n\n    /**\n     * Creates a new rule that tries repeated matches of its subrule.\n     * Succeeds always, even if the subrule doesn't match even once.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule zeroOrMore(@NotNull Object rule) {\n        return new ZeroOrMoreMatcher(toRule(rule)).label(\"zeroOrMore\");\n    }\n\n    /**\n     * Matches the EOI (end of input) character.\n     *\n     * @return a new rule\n     */\n    public Rule eoi() {\n        return ch(Chars.EOI);\n    }\n\n    /**\n     * Matches any character and therefore always succeeds.\n     *\n     * @return a new rule\n     */\n    public Rule any() {\n        return ch(Chars.ANY);\n    }\n\n    /**\n     * Matches nothing and therefore always succeeds.\n     *\n     * @return a new rule\n     */\n    public Rule empty() {\n        return ch(Chars.EMPTY);\n    }\n\n    ////////////////////////////////// ACTION PARAMETERS ///////////////////////////////////\n\n    /**\n     * Changes the context scope of all arguments to the current parent scope.\n     *\n     * @param argument the arguments to change to context for\n     * @return the result of the arguments\n     */\n    public <T> T UP(T argument) {\n        Object arg = mixInParameter(actionParameters, argument);\n        actionParameters.add(new UpParameter(arg));\n        return null;\n    }\n\n    /**\n     * Changes the context scope of all arguments to the current sub scope.\n     *\n     * @param argument the arguments to change to context for\n     * @return the result of the arguments\n     */\n    public <T> T DOWN(T argument) {\n        Object arg = mixInParameter(actionParameters, argument);\n        actionParameters.add(new DownParameter(arg));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the first Node found with the given prefix path.\n     * The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public Node<V> NODE(@NotNull String path) {\n        Object arg = mixInParameter(actionParameters, path);\n        actionParameters.add(new PathNodeParameter(arg));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to an array of Nodes found with the given prefix path.\n     * The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public List<Node<V>> NODES(@NotNull String path) {\n        Object pathArg = mixInParameter(actionParameters, path);\n        actionParameters.add(new PathNodesParameter(pathArg));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the last node created during this parsing run.\n     *\n     * @return the action parameter\n     */\n    public Node<V> LAST_NODE() {\n        actionParameters.add(new LastNodeParameter());\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the tree value of the current rule level, i.e.,\n     * If there is an explicitly set value it is returned. Otherwise the last non-null child value, or, if there\n     * is no such value, null.\n     *\n     * @return the action parameter\n     */\n    public V VALUE() {\n        actionParameters.add(new TreeValueParameter<V>(nodeValueType));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the value of the first Node found with the given prefix path.\n     * The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public V VALUE(String path) {\n        NODE(path);\n        actionParameters.add(new ValueParameter<V>(nodeValueType, actionParameters.pop()));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to an array of node value for the Nodes found with the\n     * given prefix path. The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public List<V> VALUES(String path) {\n        NODES(path);\n        actionParameters.add(new ValuesParameter<V>(actionParameters.pop()));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the value of the last node created during this parsing run.\n     *\n     * @return the action parameter\n     */\n    public V LAST_VALUE() {\n        LAST_NODE();\n        actionParameters.add(new ValueParameter<V>(nodeValueType, actionParameters.pop()));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the matched input text of the first Node found with the\n     * given prefix path. The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public String TEXT(String path) {\n        NODE(path);\n        actionParameters.add(new TextParameter<V>(actionParameters.pop()));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to an array of input texts matched by the Nodes found with the\n     * given prefix path. The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public List<String> TEXTS(String path) {\n        NODES(path);\n        actionParameters.add(new TextsParameter<V>(actionParameters.pop()));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the matched input text of the\n     * last node created during this parsing run.\n     *\n     * @return the action parameter\n     */\n    public String LAST_TEXT() {\n        LAST_NODE();\n        actionParameters.add(new TextParameter<V>(actionParameters.pop()));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the first character of the matched input text of the first Node\n     * found with the given prefix path.\n     * The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public Character CHAR(String path) {\n        NODE(path);\n        actionParameters.add(new CharParameter<V>(actionParameters.pop()));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to an array of the first characters of the input texts matched\n     * by the Nodes found with the given prefix path.\n     * The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public List<Character> CHARS(String path) {\n        NODES(path);\n        actionParameters.add(new CharsParameter<V>(actionParameters.pop()));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the first character of the matched input text of the\n     * last node created during this parsing run.\n     *\n     * @return the action parameter\n     */\n    public Character LAST_CHAR() {\n        LAST_NODE();\n        actionParameters.add(new CharParameter<V>(actionParameters.pop()));\n        return null;\n    }\n\n    /**\n     * Creates a special action rule that sets the value of the parse tree node to be created for the current rule\n     * to the value of the last node created during the current parsing run.\n     *\n     * @return a new rule\n     */\n    public ActionResult SET() {\n        LAST_VALUE();\n        actionParameters.add(new SetValueParameter<V>(actionParameters.pop(), nodeValueType));\n        return null;\n    }\n\n    /**\n     * Creates a special action rule that sets the value of the parse tree node to be created for the current rule\n     * to the given value.\n     *\n     * @param value the value to set\n     * @return a new rule\n     */\n    public ActionResult SET(V value) {\n        Object valueArg = mixInParameter(actionParameters, value);\n        actionParameters.add(new SetValueParameter<V>(valueArg, nodeValueType));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to null.\n     *\n     * @return the action parameter\n     */\n    public Object NULL() {\n        actionParameters.add(new NullParameter());\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to an object using the given converter.\n     *\n     * @param text      the text (parameter) to convert\n     * @param converter the converter to use\n     * @return the action parameter\n     */\n    public <T> T CONVERT(String text, @NotNull Converter<T> converter) {\n        Object textArg = mixInParameter(actionParameters, text);\n        List<Class<?>> convertedTypes = Utils.getTypeArguments(Converter.class, converter.getClass());\n        Preconditions.checkArgument(convertedTypes.size() == 1, \"Illegal converter\");\n        actionParameters.add(new ConvertParameter<T>(convertedTypes.get(0), textArg, converter));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to an Integer.\n     *\n     * @param text the text (parameter) to convert\n     * @return the action parameter\n     */\n    public Integer CONVERT_TO_INTEGER(String text) {\n        return CONVERT(text, new Converter<Integer>() {\n            public Integer parse(String string) {\n                return Integer.parseInt(string);\n            }\n        });\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to a Long.\n     *\n     * @param text the text (parameter) to convert\n     * @return the action parameter\n     */\n    public Long CONVERT_TO_LONG(String text) {\n        return CONVERT(text, new Converter<Long>() {\n            public Long parse(String string) {\n                return Long.parseLong(string);\n            }\n        });\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to a Float.\n     *\n     * @param text the text (parameter) to convert\n     * @return the action parameter\n     */\n    public Float CONVERT_TO_FLOAT(String text) {\n        return CONVERT(text, new Converter<Float>() {\n            public Float parse(String string) {\n                return Float.parseFloat(string);\n            }\n        });\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to an Double.\n     *\n     * @param text the text (parameter) to convert\n     * @return the action parameter\n     */\n    public Double CONVERT_TO_DOUBLE(String text) {\n        return CONVERT(text, new Converter<Double>() {\n            public Double parse(String string) {\n                return Double.parseDouble(string);\n            }\n        });\n    }\n\n    ///************************* PRIVATE ***************************///\n\n    private Rule cachedChar(char c) {\n        Rule matcher = charMatchers.get(c);\n        if (matcher == null) {\n            matcher = ch(c);\n            charMatchers.put(c, matcher);\n        }\n        return matcher;\n    }\n\n    private Rule cachedString(String string) {\n        Rule matcher = stringMatchers.get(string);\n        if (matcher == null) {\n            matcher = string(string);\n            stringMatchers.put(string, matcher);\n        }\n        return matcher;\n    }\n\n    private Rule[] toRules(@NotNull Object[] objects) {\n        Rule[] rules = new Rule[objects.length];\n        for (int i = 0; i < objects.length; i++) {\n            rules[i] = toRule(objects[i]);\n        }\n        return rules;\n    }\n\n    private Rule toRule(Object obj) {\n        obj = mixInParameter(actionParameters, obj);\n        if (obj instanceof Rule) {\n            return (Rule) obj;\n        }\n        if (obj instanceof Character) {\n            return cachedChar((Character) obj);\n        }\n        if (obj instanceof String) {\n            return cachedString((String) obj);\n        }\n        if (obj instanceof ActionParameter) {\n            return new ActionMatcher((ActionParameter) obj);\n        }\n        throw new ParserConstructionException(\"\\'\" + obj + \"\\' is not a valid Rule or parser action\");\n    }\n\n}\n","lineNo":507}
{"Refactored Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.actionparameters;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.MatcherContext;\nimport org.parboiled.common.Converter;\n\npublic class ConvertParameter extends ActionParameterWithArgument<String> {\n\n    private final Object converter;\n\n    public ConvertParameter(@NotNull Class<?> returnType, Object arg, Object converter) {\n        super(returnType, arg, String.class);\n        this.converter = converter;\n    }\n\n    public Object resolve(@NotNull MatcherContext<?> context) {\n        Converter resolvedConverter = (Converter) ActionParameterUtils.resolve(converter, context);\n        return resolvedConverter.parse(resolveArgument(context));\n    }\n\n    @Override\n    public String toString() {\n        return \"CONVERT to \" + returnType.getSimpleName() + '(' + argument + ')';\n    }\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.actionparameters;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.MatcherContext;\nimport org.parboiled.common.Converter;\n\npublic class ConvertParameter<T> extends ActionParameterWithArgument<String> {\n\n    private final Converter<T> converter;\n\n    public ConvertParameter(@NotNull Class<?> returnType, Object arg, @NotNull Converter<T> converter) {\n        super(returnType, arg, String.class);\n        this.converter = converter;\n    }\n\n    public Object resolve(@NotNull MatcherContext<?> context) {\n        return converter.parse(resolveArgument(context));\n    }\n\n    @Override\n    public String toString() {\n        return \"CONVERT to \" + returnType.getSimpleName() + '(' + argument + ')';\n    }\n}\n","lineNo":33}
{"Refactored Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled;\n\nimport net.sf.cglib.proxy.Factory;\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.actionparameters.*;\nimport static org.parboiled.actionparameters.ActionParameterUtils.mixInParameter;\nimport org.parboiled.common.Converter;\nimport org.parboiled.common.Preconditions;\nimport org.parboiled.common.Utils;\nimport static org.parboiled.common.Utils.arrayOf;\nimport org.parboiled.support.*;\n\nimport java.util.*;\n\n/**\n * Base class for custom parsers. Defines basic methods for rule and action parameter creation.\n *\n * @param <V> The type of the value field of the parse tree nodes created by this parser.\n * @param <A> The type of the parser Actions you would like to use in your rules. If you don't need any parser\n * actions (e.g. for very simple examples) you can just use the Actions interface directly.\n */\npublic abstract class BaseParser<V, A extends Actions<V>> {\n\n    private final Map<Character, Rule> charMatchers = new HashMap<Character, Rule>();\n    private final Map<String, Rule> stringMatchers = new HashMap<String, Rule>();\n    private final Class<V> nodeValueType; // the type of V, i.e. the value field of the parse tree nodes\n    final Stack<ActionParameter> actionParameters = new Stack<ActionParameter>();\n\n    /**\n     * The immutable reference to your parser actions.\n     */\n    public final A actions;\n\n    /**\n     * Constructs a new parser object using the given actions.\n     *\n     * @param actions the parser actions (can be null)\n     */\n    @SuppressWarnings({\"unchecked\"})\n    public BaseParser(A actions) {\n        this.actions = actions;\n        List<Class<?>> typeArguments = Utils.getTypeArguments(BaseParser.class, getClass());\n        Preconditions.checkState(typeArguments.size() == 2);\n        nodeValueType = (Class<V>) typeArguments.get(0);\n    }\n\n    /**\n     * Runs the given parser rule against the given input string. Note that the rule must have been created by\n     * a rule creation method of this parser object, which must have been created with Parser.create(...).\n     *\n     * @param rule  the rule\n     * @param input the input string\n     * @return the ParsingResult for the run\n     */\n    @SuppressWarnings({\"unchecked\"})\n    public ParsingResult<V> parse(@NotNull Rule rule, @NotNull String input) {\n        Checks.ensure(rule instanceof StagingRule,\n                \"Illegal rule instance, please use Parboiled.createActions(...) for creating this parser\");\n        Checks.ensure(((StagingRule) rule).getParser() == this,\n                \"Illegal rule instance, it was not created by this parser\");\n\n        // prepare\n        InputBuffer inputBuffer = new InputBuffer(input);\n        InputLocation startLocation = new InputLocation(inputBuffer);\n        List<ParseError> parseErrors = new ArrayList<ParseError>();\n        Matcher<V> matcher = (Matcher<V>) rule.toMatcher();\n        MatcherContext<V> context = new MatcherContext<V>(startLocation, matcher, actions, parseErrors);\n\n        // the matcher tree has already been built during the call to Parboiled.parse(...), usually immediately\n        // before the invocation of this method, we need to signal to the ActionInterceptor that rule construction\n        // is over and all further action calls should not continue to createActions ActionMatchers but actually be\n        // \"routed through\" to the actual action method implementations\n        if (actions != null) {\n            ActionInterceptor actionInterceptor = (ActionInterceptor) ((Factory) actions).getCallback(1);\n            actionInterceptor.setParser(null);\n        }\n\n        // run the actual matcher tree\n        context.runMatcher(true);\n\n        return new ParsingResult<V>(context.getNode(), parseErrors, inputBuffer);\n    }\n\n    ////////////////////////////////// RULE CREATION ///////////////////////////////////\n\n    /**\n     * Explicitly creates a rule matching the given character.\n     * Normally you can just specify the character literal directly in you rule description. However, if you want\n     * to specify special rule attributes (like a label) you can also use this wrapper.\n     *\n     * @param c the char to match\n     * @return a new rule\n     */\n    public Rule ch(char c) {\n        return new CharMatcher(c);\n    }\n\n    /**\n     * Creates a rule matching a range of characters from cLow to cHigh (both inclusively).\n     *\n     * @param cLow  the start char of the range (inclusively)\n     * @param cHigh the end char of the range (inclusively)\n     * @return a new rule\n     */\n    public Rule charRange(char cLow, char cHigh) {\n        return cLow == cHigh ? ch(cLow) : new CharRangeMatcher(cLow, cHigh);\n    }\n\n    /**\n     * Explicitly creates a rule matching the given string.\n     * Normally you can just specify the string literal directly in you rule description. However, if you want\n     * to specify special rule attributes (like a label) you can also use this wrapper.\n     *\n     * @param string the string to match\n     * @return a new rule\n     */\n    public Rule string(@NotNull String string) {\n        Rule[] matchers = new Rule[string.length()];\n        for (int i = 0; i < string.length(); i++) matchers[i] = cachedChar(string.charAt(i));\n        return new SequenceMatcher(matchers, false).label(string);\n    }\n\n    /**\n     * Creates a new rule that successively tries all of the given subrules and succeeds when the first one of\n     * its subrules matches. If all subrules fail this rule fails as well.\n     *\n     * @param rule      the first subrule\n     * @param rule2     the second subrule\n     * @param moreRules the other subrules\n     * @return a new rule\n     */\n    public Rule firstOf(@NotNull Object rule, Object rule2, Object... moreRules) {\n        return new FirstOfMatcher(toRules(arrayOf(rule, arrayOf(rule2, moreRules)))).label(\"firstOf\");\n    }\n\n    /**\n     * Creates a new rule that tries repeated matches of its subrule and succeeds if the subrule matches at least once.\n     * If the subrule does not match at least once this rule fails.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule oneOrMore(@NotNull Object rule) {\n        return new OneOrMoreMatcher(toRule(rule)).label(\"oneOrMore\");\n    }\n\n    /**\n     * Creates a new rule that tries a match on its subrule and always succeeds, independently of the matching\n     * success of its subrule.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule optional(@NotNull Object rule) {\n        return new OptionalMatcher(toRule(rule)).label(\"optional\");\n    }\n\n    /**\n     * Creates a new rule that only succeeds if all of its subrule succeed, one after the other.\n     *\n     * @param rule      the first subrule\n     * @param rule2     the second subrule\n     * @param moreRules the other subrules\n     * @return a new rule\n     */\n    public Rule sequence(@NotNull Object rule, Object rule2, Object... moreRules) {\n        return new SequenceMatcher(toRules(arrayOf(rule, arrayOf(rule2, moreRules))), false).label(\"sequence\");\n    }\n\n    /**\n     * Creates a new rule that only succeeds if all of its subrules succeed, one after the other.\n     * However, after the first subrule has matched all further subrule matches are enforced, i.e. if one of them\n     * fails a ParseError will be created (and error recovery will be tried).\n     *\n     * @param rule      the first subrule\n     * @param rule2     the second subrule\n     * @param moreRules the other subrules\n     * @return a new rule\n     */\n    public Rule enforcedSequence(@NotNull Object rule, Object rule2, Object... moreRules) {\n        return new SequenceMatcher(toRules(arrayOf(rule, arrayOf(rule2, moreRules))), true).label(\"enforcedSequence\");\n    }\n\n    /**\n     * Creates a new rule that acts as a syntactic predicate, i.e. tests the given subrule against the current\n     * input position without actually matching any characters. Succeeds if the subrule succeeds and fails if the\n     * subrule rails.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule test(@NotNull Object rule) {\n        return new TestMatcher(toRule(rule), false);\n    }\n\n    /**\n     * Creates a new rule that acts as an inverse syntactic predicate, i.e. tests the given subrule against the current\n     * input position without actually matching any characters. Succeeds if the subrule fails and fails if the\n     * subrule succeeds.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule testNot(@NotNull Object rule) {\n        return new TestMatcher(toRule(rule), true);\n    }\n\n    /**\n     * Creates a new rule that tries repeated matches of its subrule.\n     * Succeeds always, even if the subrule doesn't match even once.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule zeroOrMore(@NotNull Object rule) {\n        return new ZeroOrMoreMatcher(toRule(rule)).label(\"zeroOrMore\");\n    }\n\n    /**\n     * Matches the EOI (end of input) character.\n     *\n     * @return a new rule\n     */\n    public Rule eoi() {\n        return ch(Chars.EOI);\n    }\n\n    /**\n     * Matches any character and therefore always succeeds.\n     *\n     * @return a new rule\n     */\n    public Rule any() {\n        return ch(Chars.ANY);\n    }\n\n    /**\n     * Matches nothing and therefore always succeeds.\n     *\n     * @return a new rule\n     */\n    public Rule empty() {\n        return ch(Chars.EMPTY);\n    }\n\n    ////////////////////////////////// ACTION PARAMETERS ///////////////////////////////////\n\n    /**\n     * Changes the context scope of all arguments to the current parent scope.\n     *\n     * @param argument the arguments to change to context for\n     * @return the result of the arguments\n     */\n    public <T> T up(T argument) {\n        Object arg = mixInParameter(actionParameters, argument);\n        actionParameters.add(new UpParameter(arg));\n        return null;\n    }\n\n    /**\n     * Changes the context scope of all arguments to the current sub scope.\n     *\n     * @param argument the arguments to change to context for\n     * @return the result of the arguments\n     */\n    public <T> T down(T argument) {\n        Object arg = mixInParameter(actionParameters, argument);\n        actionParameters.add(new DownParameter(arg));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the first Node found with the given prefix path.\n     * The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public Node<V> node(@NotNull String path) {\n        Object arg = mixInParameter(actionParameters, path);\n        actionParameters.add(new PathNodeParameter(arg));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to an array of Nodes found with the given prefix path.\n     * The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public List<Node<V>> nodes(@NotNull String path) {\n        Object pathArg = mixInParameter(actionParameters, path);\n        actionParameters.add(new PathNodesParameter(pathArg));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the last node created during this parsing run.\n     *\n     * @return the action parameter\n     */\n    public Node<V> lastNode() {\n        actionParameters.add(new LastNodeParameter());\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the tree value of the current rule level, i.e.,\n     * If there is an explicitly set value it is returned. Otherwise the last non-null child value, or, if there\n     * is no such value, null.\n     *\n     * @return the action parameter\n     */\n    public V value() {\n        actionParameters.add(new TreeValueParameter<V>(nodeValueType));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the value of the first Node found with the given prefix path.\n     * The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public V value(String path) {\n        node(path);\n        actionParameters.add(new ValueParameter<V>(nodeValueType, actionParameters.pop()));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to an array of node value for the Nodes found with the\n     * given prefix path. The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public List<V> values(String path) {\n        nodes(path);\n        actionParameters.add(new ValuesParameter<V>(actionParameters.pop()));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the value of the last node created during this parsing run.\n     *\n     * @return the action parameter\n     */\n    public V lastValue() {\n        lastNode();\n        actionParameters.add(new ValueParameter<V>(nodeValueType, actionParameters.pop()));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the matched input text of the first Node found with the\n     * given prefix path. The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public String text(String path) {\n        node(path);\n        actionParameters.add(new TextParameter<V>(actionParameters.pop()));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to an array of input texts matched by the Nodes found with the\n     * given prefix path. The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public List<String> texts(String path) {\n        nodes(path);\n        actionParameters.add(new TextsParameter<V>(actionParameters.pop()));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the matched input text of the\n     * last node created during this parsing run.\n     *\n     * @return the action parameter\n     */\n    public String lastText() {\n        lastNode();\n        actionParameters.add(new TextParameter<V>(actionParameters.pop()));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the first character of the matched input text of the first Node\n     * found with the given prefix path.\n     * The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public Character ch(String path) {\n        node(path);\n        actionParameters.add(new CharParameter<V>(actionParameters.pop()));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to an array of the first characters of the input texts matched\n     * by the Nodes found with the given prefix path.\n     * The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public List<Character> chars(String path) {\n        nodes(path);\n        actionParameters.add(new CharsParameter<V>(actionParameters.pop()));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the first character of the matched input text of the\n     * last node created during this parsing run.\n     *\n     * @return the action parameter\n     */\n    public Character lastChar() {\n        lastNode();\n        actionParameters.add(new CharParameter<V>(actionParameters.pop()));\n        return null;\n    }\n\n    /**\n     * Creates a special action rule that sets the value of the parse tree node to be created for the current rule\n     * to the value of the last node created during the current parsing run.\n     *\n     * @return a new rule\n     */\n    public ActionResult set() {\n        lastValue();\n        actionParameters.add(new SetValueParameter<V>(actionParameters.pop(), nodeValueType));\n        return null;\n    }\n\n    /**\n     * Creates a special action rule that sets the value of the parse tree node to be created for the current rule\n     * to the given value.\n     *\n     * @param value the value to set\n     * @return a new rule\n     */\n    public ActionResult set(V value) {\n        Object valueArg = mixInParameter(actionParameters, value);\n        actionParameters.add(new SetValueParameter<V>(valueArg, nodeValueType));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to null.\n     *\n     * @return the action parameter\n     */\n    public Object NULL() {\n        actionParameters.add(new NullParameter());\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to an object using the given converter.\n     *\n     * @param text      the text (parameter) to convert\n     * @param converter the converter to use\n     * @return the action parameter\n     */\n    public <T> T convert(String text, @NotNull Converter<T> converter) {\n        Object textArg = mixInParameter(actionParameters, text);\n        List<Class<?>> convertedTypes = Utils.getTypeArguments(Converter.class, converter.getClass());\n        Preconditions.checkArgument(convertedTypes.size() == 1, \"Illegal converter\");\n        actionParameters.add(new ConvertParameter<T>(convertedTypes.get(0), textArg, converter));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to an Integer.\n     *\n     * @param text the text (parameter) to convert\n     * @return the action parameter\n     */\n    public Integer convertToInteger(String text) {\n        return convert(text, new Converter<Integer>() {\n            public Integer parse(String string) {\n                return Integer.parseInt(string);\n            }\n        });\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to a Long.\n     *\n     * @param text the text (parameter) to convert\n     * @return the action parameter\n     */\n    public Long convertToLong(String text) {\n        return convert(text, new Converter<Long>() {\n            public Long parse(String string) {\n                return Long.parseLong(string);\n            }\n        });\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to a Float.\n     *\n     * @param text the text (parameter) to convert\n     * @return the action parameter\n     */\n    public Float convertToFloat(String text) {\n        return convert(text, new Converter<Float>() {\n            public Float parse(String string) {\n                return Float.parseFloat(string);\n            }\n        });\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to an Double.\n     *\n     * @param text the text (parameter) to convert\n     * @return the action parameter\n     */\n    public Double convertToDouble(String text) {\n        return convert(text, new Converter<Double>() {\n            public Double parse(String string) {\n                return Double.parseDouble(string);\n            }\n        });\n    }\n\n    ///************************* PRIVATE ***************************///\n\n    private Rule cachedChar(char c) {\n        Rule matcher = charMatchers.get(c);\n        if (matcher == null) {\n            matcher = ((AbstractMatcher) ch(c)).lock();\n            charMatchers.put(c, matcher);\n        }\n        return matcher;\n    }\n\n    private Rule cachedString(String string) {\n        Rule matcher = stringMatchers.get(string);\n        if (matcher == null) {\n            matcher = ((AbstractMatcher) string(string)).lock();\n            stringMatchers.put(string, matcher);\n        }\n        return matcher;\n    }\n\n    private Rule[] toRules(@NotNull Object[] objects) {\n        Rule[] rules = new Rule[objects.length];\n        for (int i = 0; i < objects.length; i++) {\n            rules[i] = toRule(objects[i]);\n        }\n        return rules;\n    }\n\n    private Rule toRule(Object obj) {\n        obj = mixInParameter(actionParameters, obj);\n        if (obj instanceof Rule) {\n            return (Rule) obj;\n        }\n        if (obj instanceof Character) {\n            return cachedChar((Character) obj);\n        }\n        if (obj instanceof String) {\n            return cachedString((String) obj);\n        }\n        if (obj instanceof ActionParameter) {\n            return new ActionMatcher((ActionParameter) obj);\n        }\n        throw new ParserConstructionException(\"\\'\" + obj + \"\\' is not a valid Rule or parser action\");\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled;\n\nimport net.sf.cglib.proxy.Factory;\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.actionparameters.*;\nimport static org.parboiled.actionparameters.ActionParameterUtils.mixInParameter;\nimport org.parboiled.common.Converter;\nimport org.parboiled.common.AbstractConverter;\nimport static org.parboiled.common.Utils.arrayOf;\nimport org.parboiled.support.*;\n\nimport java.util.*;\n\n/**\n * Base class for custom parsers. Defines basic methods for rule and action parameter creation.\n *\n * @param <V> The type of the value field of the parse tree nodes created by this parser.\n * @param <A> The type of the parser Actions you would like to use in your rules. If you don't need any parser\n * actions (e.g. for very simple examples) you can just use the Actions interface directly.\n */\npublic abstract class BaseParser<V, A extends Actions<V>> {\n\n    /**\n     * Special object to be used for null arguments to action methods.\n     */\n    public static final Object NULL = new Object();\n\n    protected final Map<Character, Rule> charMatchers = new HashMap<Character, Rule>();\n    protected final Map<String, Rule> stringMatchers = new HashMap<String, Rule>();\n    protected final Stack<ActionParameter> actionParameters = new Stack<ActionParameter>();\n\n    /**\n     * The immutable reference to your parser actions.\n     */\n    public final A actions;\n\n    /**\n     * Constructs a new parser object using the given actions.\n     *\n     * @param actions the parser actions (can be null)\n     */\n    public BaseParser(A actions) {\n        this.actions = actions;\n    }\n\n    /**\n     * Runs the given parser rule against the given input string. Note that the rule must have been created by\n     * a rule creation method of this parser object, which must have been created with Parser.create(...).\n     *\n     * @param rule  the rule\n     * @param input the input string\n     * @return the ParsingResult for the run\n     */\n    @SuppressWarnings({\"unchecked\"})\n    public ParsingResult<V> parse(@NotNull Rule rule, @NotNull String input) {\n        Checks.ensure(rule instanceof StagingRule,\n                \"Illegal rule instance, please use Parboiled.createActions(...) for creating this parser\");\n        Checks.ensure(((StagingRule) rule).getParser() == this,\n                \"Illegal rule instance, it was not created by this parser\");\n\n        // prepare\n        InputBuffer inputBuffer = new InputBuffer(input);\n        InputLocation startLocation = new InputLocation(inputBuffer);\n        List<ParseError> parseErrors = new ArrayList<ParseError>();\n        Matcher<V> matcher = (Matcher<V>) rule.toMatcher();\n        MatcherContext<V> context = new MatcherContext<V>(startLocation, matcher, actions, parseErrors);\n\n        // the matcher tree has already been built during the call to Parboiled.parse(...), usually immediately\n        // before the invocation of this method, we need to signal to the ActionInterceptor that rule construction\n        // is over and all further action calls should not continue to createActions ActionMatchers but actually be\n        // \"routed through\" to the actual action method implementations\n        if (actions != null) {\n            ActionInterceptor actionInterceptor = (ActionInterceptor) ((Factory) actions).getCallback(1);\n            actionInterceptor.setParser(null);\n        }\n\n        // run the actual matcher tree\n        context.runMatcher(true);\n\n        return new ParsingResult<V>(context.getNode(), parseErrors, inputBuffer);\n    }\n\n    ////////////////////////////////// RULE CREATION ///////////////////////////////////\n\n    /**\n     * Explicitly creates a rule matching the given character.\n     * Normally you can just specify the character literal directly in you rule description. However, if you want\n     * to specify special rule attributes (like a label) you can also use this wrapper.\n     *\n     * @param c the char to match\n     * @return a new rule\n     */\n    public Rule ch(char c) {\n        return new CharMatcher(c);\n    }\n\n    /**\n     * Creates a rule matching a range of characters from cLow to cHigh (both inclusively).\n     *\n     * @param cLow  the start char of the range (inclusively)\n     * @param cHigh the end char of the range (inclusively)\n     * @return a new rule\n     */\n    public Rule charRange(char cLow, char cHigh) {\n        return cLow == cHigh ? ch(cLow) : new CharRangeMatcher(cLow, cHigh);\n    }\n\n    /**\n     * Explicitly creates a rule matching the given string.\n     * Normally you can just specify the string literal directly in you rule description. However, if you want\n     * to specify special rule attributes (like a label) you can also use this wrapper.\n     *\n     * @param string the string to match\n     * @return a new rule\n     */\n    public Rule string(@NotNull String string) {\n        Rule[] matchers = new Rule[string.length()];\n        for (int i = 0; i < string.length(); i++) matchers[i] = cachedChar(string.charAt(i));\n        return new SequenceMatcher(matchers, false).label(string);\n    }\n\n    /**\n     * Creates a new rule that successively tries all of the given subrules and succeeds when the first one of\n     * its subrules matches. If all subrules fail this rule fails as well.\n     *\n     * @param rule      the first subrule\n     * @param rule2     the second subrule\n     * @param moreRules the other subrules\n     * @return a new rule\n     */\n    public Rule firstOf(@NotNull Object rule, Object rule2, Object... moreRules) {\n        return new FirstOfMatcher(toRules(arrayOf(rule, arrayOf(rule2, moreRules)))).label(\"firstOf\");\n    }\n\n    /**\n     * Creates a new rule that tries repeated matches of its subrule and succeeds if the subrule matches at least once.\n     * If the subrule does not match at least once this rule fails.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule oneOrMore(@NotNull Object rule) {\n        return new OneOrMoreMatcher(toRule(rule)).label(\"oneOrMore\");\n    }\n\n    /**\n     * Creates a new rule that tries a match on its subrule and always succeeds, independently of the matching\n     * success of its subrule.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule optional(@NotNull Object rule) {\n        return new OptionalMatcher(toRule(rule)).label(\"optional\");\n    }\n\n    /**\n     * Creates a new rule that only succeeds if all of its subrule succeed, one after the other.\n     *\n     * @param rule      the first subrule\n     * @param rule2     the second subrule\n     * @param moreRules the other subrules\n     * @return a new rule\n     */\n    public Rule sequence(@NotNull Object rule, Object rule2, Object... moreRules) {\n        return new SequenceMatcher(toRules(arrayOf(rule, arrayOf(rule2, moreRules))), false).label(\"sequence\");\n    }\n\n    /**\n     * Creates a new rule that only succeeds if all of its subrules succeed, one after the other.\n     * However, after the first subrule has matched all further subrule matches are enforced, i.e. if one of them\n     * fails a ParseError will be created (and error recovery will be tried).\n     *\n     * @param rule      the first subrule\n     * @param rule2     the second subrule\n     * @param moreRules the other subrules\n     * @return a new rule\n     */\n    public Rule enforcedSequence(@NotNull Object rule, Object rule2, Object... moreRules) {\n        return new SequenceMatcher(toRules(arrayOf(rule, arrayOf(rule2, moreRules))), true).label(\"enforcedSequence\");\n    }\n\n    /**\n     * Creates a new rule that acts as a syntactic predicate, i.e. tests the given subrule against the current\n     * input position without actually matching any characters. Succeeds if the subrule succeeds and fails if the\n     * subrule rails.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule test(@NotNull Object rule) {\n        return new TestMatcher(toRule(rule), false);\n    }\n\n    /**\n     * Creates a new rule that acts as an inverse syntactic predicate, i.e. tests the given subrule against the current\n     * input position without actually matching any characters. Succeeds if the subrule fails and fails if the\n     * subrule succeeds.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule testNot(@NotNull Object rule) {\n        return new TestMatcher(toRule(rule), true);\n    }\n\n    /**\n     * Creates a new rule that tries repeated matches of its subrule.\n     * Succeeds always, even if the subrule doesn't match even once.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule zeroOrMore(@NotNull Object rule) {\n        return new ZeroOrMoreMatcher(toRule(rule)).label(\"zeroOrMore\");\n    }\n\n    /**\n     * Matches the EOI (end of input) character.\n     *\n     * @return a new rule\n     */\n    public Rule eoi() {\n        return ch(Chars.EOI);\n    }\n\n    /**\n     * Matches any character and therefore always succeeds.\n     *\n     * @return a new rule\n     */\n    public Rule any() {\n        return ch(Chars.ANY);\n    }\n\n    /**\n     * Matches nothing and therefore always succeeds.\n     *\n     * @return a new rule\n     */\n    public Rule empty() {\n        return ch(Chars.EMPTY);\n    }\n\n    /**\n     * Creates a special action rule that sets the value of the parse tree node to be created for the current rule\n     * to the value of the last node created during the current parsing run.\n     *\n     * @return a new rule\n     */\n    public Rule set() {\n        return set(lastValue());\n    }\n\n    /**\n     * Creates a special action rule that sets the value of the parse tree node to be created for the current rule\n     * to the given value.\n     *\n     * @param value the value to set\n     * @return a new rule\n     */\n    public Rule set(V value) {\n        return new SetValueMatcher<V>(value);\n    }\n\n    ////////////////////////////////// ACTION PARAMETERS ///////////////////////////////////\n\n    /**\n     * Changes the context scope of all arguments to the current parent scope.\n     * @param argument the arguments to change to context for\n     * @return the result of the arguments\n     */\n    public <T> T up(T argument) {\n        actionParameters.add(new UpParameter(argument));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the first Node found with the given prefix path.\n     * The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public Node<V> node(@NotNull String path) {\n        Object pathArg = mixInParameter(actionParameters, path);\n        actionParameters.add(new PathNodeParameter(pathArg));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to an array of Nodes found with the given prefix path.\n     * The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public List<Node<V>> nodes(@NotNull String path) {\n        Object pathArg = mixInParameter(actionParameters, path);\n        actionParameters.add(new PathNodesParameter(pathArg));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the last node created during this parsing run.\n     *\n     * @return the action parameter\n     */\n    public Node<V> lastNode() {\n        actionParameters.add(new LastNodeParameter());\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the tree value of the current rule level, i.e.,\n     * If there is an explicitly set value it is returned. Otherwise the last non-null child value, or, if there\n     * is no such value, null.\n     *\n     * @return the action parameter\n     */\n    public V value() {\n        actionParameters.add(new TreeValueParameter());\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the value of the first Node found with the given prefix path.\n     * The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public V value(String path) {\n        actionParameters.add(new ValueParameter<V>(node(path)));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to an array of node value for the Nodes found with the\n     * given prefix path. The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public List<V> values(String path) {\n        actionParameters.add(new ValuesParameter<V>(nodes(path)));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the value of the last node created during this parsing run.\n     *\n     * @return the action parameter\n     */\n    public V lastValue() {\n        actionParameters.add(new ValueParameter<V>(lastNode()));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the matched input text of the first Node found with the\n     * given prefix path. The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public String text(String path) {\n        actionParameters.add(new TextParameter<V>(node(path)));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to an array of input texts matched by the Nodes found with the\n     * given prefix path. The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public List<String> texts(String path) {\n        actionParameters.add(new TextsParameter<V>(nodes(path)));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the matched input text of the\n     * last node created during this parsing run.\n     *\n     * @return the action parameter\n     */\n    public String lastText() {\n        actionParameters.add(new TextParameter<V>(lastNode()));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the first character of the matched input text of the first Node\n     * found with the given prefix path.\n     * The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public Character ch(String path) {\n        actionParameters.add(new CharParameter<V>(node(path)));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to an array of the first characters of the input texts matched\n     * by the Nodes found with the given prefix path.\n     * The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public List<Character> chars(String path) {\n        actionParameters.add(new CharsParameter<V>(nodes(path)));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the first character of the matched input text of the\n     * last node created during this parsing run.\n     *\n     * @return the action parameter\n     */\n    public Character lastChar() {\n        actionParameters.add(new CharParameter<V>(lastNode()));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to an object using the given converter.\n     *\n     * @param text      the text (parameter) to convert\n     * @param converter the converter to use\n     * @return the action parameter\n     */\n    public <T> T convert(String text, @NotNull Converter<T> converter) {\n        Object textArg = mixInParameter(actionParameters, text);\n        actionParameters.add(new ConvertParameter<T>(textArg, converter));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to an Integer.\n     *\n     * @param text the text (parameter) to convert\n     * @return the action parameter\n     */\n    public Integer convertToInteger(String text) {\n        return convert(text, new AbstractConverter<Integer>(Integer.class) {\n            public Integer parse(String string) {\n                return Integer.parseInt(string);\n            }\n        });\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to a Long.\n     *\n     * @param text the text (parameter) to convert\n     * @return the action parameter\n     */\n    public Long convertToLong(String text) {\n        return convert(text, new AbstractConverter<Long>(Long.class) {\n            public Long parse(String string) {\n                return Long.parseLong(string);\n            }\n        });\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to a Float.\n     *\n     * @param text the text (parameter) to convert\n     * @return the action parameter\n     */\n    public Float convertToFloat(String text) {\n        return convert(text, new AbstractConverter<Float>(Float.class) {\n            public Float parse(String string) {\n                return Float.parseFloat(string);\n            }\n        });\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to an Double.\n     *\n     * @param text the text (parameter) to convert\n     * @return the action parameter\n     */\n    public Double convertToDouble(String text) {\n        return convert(text, new AbstractConverter<Double>(Double.class) {\n            public Double parse(String string) {\n                return Double.parseDouble(string);\n            }\n        });\n    }\n\n    ///************************* PRIVATE ***************************///\n\n    private Rule cachedChar(char c) {\n        Rule matcher = charMatchers.get(c);\n        if (matcher == null) {\n            matcher = ((AbstractMatcher) ch(c)).lock();\n            charMatchers.put(c, matcher);\n        }\n        return matcher;\n    }\n\n    private Rule cachedString(String string) {\n        Rule matcher = stringMatchers.get(string);\n        if (matcher == null) {\n            matcher = ((AbstractMatcher) string(string)).lock();\n            stringMatchers.put(string, matcher);\n        }\n        return matcher;\n    }\n\n    private Rule[] toRules(@NotNull Object[] objects) {\n        Rule[] rules = new Rule[objects.length];\n        for (int i = 0; i < objects.length; i++) {\n            rules[i] = toRule(objects[i]);\n        }\n        return rules;\n    }\n\n    private Rule toRule(Object obj) {\n        if (obj instanceof Rule) {\n            return (Rule) obj;\n        }\n        if (obj instanceof Character) {\n            return cachedChar((Character) obj);\n        }\n        if (obj instanceof String) {\n            return cachedString((String) obj);\n        }\n        if (obj == null) {\n            return newActionMatcher();\n        }\n        throw new ParserConstructionException(\"\\'\" + obj + \"\\' is not a valid Rule\");\n    }\n\n    private Rule newActionMatcher() {\n        ActionParameter parameter = (ActionParameter) mixInParameter(actionParameters, null);\n        Checks.ensure(parameter instanceof ActionCallParameter,\n                \"Illegal parser action, don't you want to call a method on your actions object?\");\n        ActionCallParameter actionCall = (ActionCallParameter) parameter;\n        actionCall.verifyReturnType(ActionResult.class);\n        return new ActionMatcher(actionCall);\n    }\n\n}\n","lineNo":271}
{"Refactored Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.support;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.Node;\nimport org.parboiled.common.Predicate;\nimport org.parboiled.common.StringUtils;\nimport org.parboiled.common.Utils;\nimport static org.parboiled.trees.GraphUtils.hasChildren;\nimport static org.parboiled.trees.GraphUtils.printTree;\n\nimport java.util.Collection;\nimport java.util.List;\n\n/**\n * General utility methods for operating on parse trees.\n */\npublic class ParseTreeUtils {\n\n    private ParseTreeUtils() {}\n\n    /**\n     * Returns the first Node underneath the given parent that matches the given path.\n     * The path is a '/' separated list of Node label prefixes describing the ancestor chain of the sought for Node\n     * relative to the given parent.\n     * If parent is null or no node is found the method returns null.\n     *\n     * @param parent the parent Node\n     * @param path   the path to the Node being searched for\n     * @return the Node if found or null if not found\n     */\n    public static <V> Node<V> findNodeByPath(Node<V> parent, @NotNull String path) {\n        return parent != null && hasChildren(parent) ? findNodeByPath(parent.getChildren(), path) : null;\n    }\n\n    /**\n     * Returns the node underneath the given parents that matches the given path.\n     * The path is a '/' separated list of Node label prefixes describing the ancestor chain of the sought for Node\n     * relative to each of the given parent nodes. If there are several nodes that match the given path the method\n     * returns the first one unless the respective path segments has the special prefix \"last:\". In this case the\n     * method will return the last matching node.\n     * Example: \"per/last:so/fix\" will return the first node, whose label starts with \"fix\" under the last node,\n     * whose label starts with \"so\" under the first node, whose label starts with \"per\".\n     * If the given collections of parents is null or empty or no node is found the method returns null.\n     *\n     * @param parents the parent Nodes to look through\n     * @param path    the path to the Node being searched for\n     * @return the Node if found or null if not found\n     */\n    public static <V> Node<V> findNodeByPath(List<Node<V>> parents, @NotNull String path) {\n        if (parents != null && !parents.isEmpty()) {\n            int separatorIndex = path.indexOf('/');\n            String prefix = separatorIndex != -1 ? path.substring(0, separatorIndex) : path;\n            Iterable<Node<V>> iterable = parents;\n            if (prefix.startsWith(\"last:\")) {\n                prefix = prefix.substring(5);\n                iterable = Utils.reverse(parents);\n            }\n            for (Node<V> child : iterable) {\n                if (StringUtils.startsWith(child.getLabel(), prefix)) {\n                    return separatorIndex == -1 ? child : findNodeByPath(child, path.substring(separatorIndex + 1));\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Collects all Nodes underneath the given parent that match the given path.\n     * The path is a '/' separated list of Node label prefixes describing the ancestor chain of the sought for Nodes\n     * relative to the given parent.\n     *\n     * @param parent     the parent Node\n     * @param path       the path to the Nodes being searched for\n     * @param collection the collection to collect the found Nodes into\n     * @return the same collection instance passed as a parameter\n     */\n    public static <V, C extends Collection<Node<V>>> C collectNodesByPath(Node<V> parent,\n                                                                          @NotNull String path,\n                                                                          @NotNull C collection) {\n        return parent != null && hasChildren(parent) ?\n                collectNodesByPath(parent.getChildren(), path, collection) : collection;\n    }\n\n    /**\n     * Collects all Nodes underneath the given parents that match the given path.\n     * The path is a '/' separated list of Node label prefixes describing the ancestor chain of the sought for Nodes\n     * relative to each of the given parent nodes.\n     *\n     * @param parents    the parent Nodes to look through\n     * @param path       the path to the Nodes being searched for\n     * @param collection the collection to collect the found Nodes into\n     * @return the same collection instance passed as a parameter\n     */\n    public static <V, C extends Collection<Node<V>>> C collectNodesByPath(List<Node<V>> parents,\n                                                                          @NotNull String path,\n                                                                          @NotNull C collection) {\n        if (parents != null && !parents.isEmpty()) {\n            int separatorIndex = path.indexOf('/');\n            String prefix = separatorIndex != -1 ? path.substring(0, separatorIndex) : path;\n            Iterable<Node<V>> iterable = parents;\n            if (prefix.startsWith(\"last:\")) {\n                prefix = prefix.substring(5);\n                iterable = Utils.reverse(parents);\n            }\n            for (Node<V> child : iterable) {\n                if (StringUtils.startsWith(child.getLabel(), prefix)) {\n                    if (separatorIndex == -1) {\n                        collection.add(child);\n                    } else {\n                        collectNodesByPath(child, path.substring(separatorIndex + 1), collection);\n                    }\n                }\n            }\n        }\n        return collection;\n    }\n\n    /**\n     * Returns the first Node underneath the given parent for which the given predicate evaluates to true.\n     * If parent is null or no node is found the method returns null.\n     *\n     * @param parent    the parent Node\n     * @param predicate the predicate\n     * @return the Node if found or null if not found\n     */\n    public static <V> Node<V> findNode(Node<V> parent, @NotNull Predicate<Node<V>> predicate) {\n        if (parent != null) {\n            if (predicate.apply(parent)) return parent;\n            if (hasChildren(parent)) {\n                Node<V> found = findNode(parent.getChildren(), predicate);\n                if (found != null) return found;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Returns the first Node underneath the given parents for which the given predicate evaluates to true.\n     * If parents is null or empty or no node is found the method returns null.\n     *\n     * @param parents   the parent Nodes to look through\n     * @param predicate the predicate\n     * @return the Node if found or null if not found\n     */\n    public static <V> Node<V> findNode(List<Node<V>> parents, @NotNull Predicate<Node<V>> predicate) {\n        if (parents != null && !parents.isEmpty()) {\n            for (Node<V> child : parents) {\n                Node<V> found = findNode(child, predicate);\n                if (found != null) return found;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Returns the last Node underneath the given parent for which the given predicate evaluates to true.\n     * If parent is null or no node is found the method returns null.\n     *\n     * @param parent    the parent Node\n     * @param predicate the predicate\n     * @return the Node if found or null if not found\n     */\n    public static <V> Node<V> findLastNode(Node<V> parent, @NotNull Predicate<Node<V>> predicate) {\n        if (parent != null) {\n            if (predicate.apply(parent)) return parent;\n            if (hasChildren(parent)) {\n                Node<V> found = findLastNode(parent.getChildren(), predicate);\n                if (found != null) return found;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Returns the last Node underneath the given parents for which the given predicate evaluates to true.\n     * If parents is null or empty or no node is found the method returns null.\n     *\n     * @param parents   the parent Nodes to look through\n     * @param predicate the predicate\n     * @return the Node if found or null if not found\n     */\n    public static <V> Node<V> findLastNode(List<Node<V>> parents, @NotNull Predicate<Node<V>> predicate) {\n        if (parents != null && !parents.isEmpty()) {\n            for (Node<V> child : Utils.reverse(parents)) {\n                Node<V> found = findLastNode(child, predicate);\n                if (found != null) return found;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Collects all Nodes underneath the given parent for which the given predicate evaluates to true.\n     *\n     * @param parent     the parent Node\n     * @param predicate  the predicate\n     * @param collection the collection to collect the found Nodes into\n     * @return the same collection instance passed as a parameter\n     */\n    public static <V, C extends Collection<Node<V>>> C collectNodes(Node<V> parent,\n                                                                    @NotNull Predicate<Node<V>> predicate,\n                                                                    @NotNull C collection) {\n        return parent != null && hasChildren(parent) ?\n                collectNodes(parent.getChildren(), predicate, collection) : collection;\n    }\n\n    /**\n     * Collects all Nodes underneath the given parents for which the given predicate evaluates to true.\n     *\n     * @param parents    the parent Nodes to look through\n     * @param predicate  the predicate\n     * @param collection the collection to collect the found Nodes into\n     * @return the same collection instance passed as a parameter\n     */\n    public static <V, C extends Collection<Node<V>>> C collectNodes(List<Node<V>> parents,\n                                                                    @NotNull Predicate<Node<V>> predicate,\n                                                                    @NotNull C collection) {\n        if (parents != null && !parents.isEmpty()) {\n            for (Node<V> child : parents) {\n                if (predicate.apply(child)) {\n                    collection.add(child);\n                }\n                collectNodes(child, predicate, collection);\n            }\n        }\n        return collection;\n    }\n\n    /**\n     * Returns the input text matched by the given Node.\n     *\n     * @param node        the node\n     * @param inputBuffer the underlying inputBuffer\n     * @return null if node is null otherwise a string with the matched input text (which can be empty)\n     */\n    public static String getNodeText(Node<?> node, @NotNull InputBuffer inputBuffer) {\n        return node != null ? inputBuffer.extract(node.getStartLocation().index, node.getEndLocation().index) : null;\n    }\n\n    /**\n     * Returns the first input character matched by the given Node.\n     *\n     * @param node        the node\n     * @param inputBuffer the underlying inputBuffer\n     * @return null if node is null or did not match at least one character otherwise the first matched input char\n     */\n    public static Character getNodeChar(Node<?> node, InputBuffer inputBuffer) {\n        return node != null && node.getEndLocation().index > node.getStartLocation().index ?\n                inputBuffer.charAt(node.getStartLocation().index) : null;\n    }\n\n    /**\n     * Creates a readable string represenation of the parse tree in thee given ParsingResult object.\n     *\n     * @param parsingResult the parsing result containing the parse tree\n     * @return a new String\n     */\n    public static <V> String printNodeTree(@NotNull ParsingResult<V> parsingResult) {\n        return printTree(parsingResult.root, new NodeFormatter<V>(parsingResult.inputBuffer));\n    }\n\n}\n\n","Smelly Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.support;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.Node;\nimport org.parboiled.common.Predicate;\nimport org.parboiled.common.StringUtils;\nimport org.parboiled.common.Utils;\nimport static org.parboiled.trees.GraphUtils.hasChildren;\nimport static org.parboiled.trees.GraphUtils.printTree;\n\nimport java.util.Collection;\nimport java.util.List;\n\n/**\n * General utility methods for operating on parse trees.\n */\npublic class ParseTreeUtils {\n\n    private ParseTreeUtils() {}\n\n    /**\n     * Returns the first Node underneath the given parent that matches the given path.\n     * The path is a '/' separated list of Node label prefixes describing the ancestor chain of the sought for Node\n     * relative to the given parent.\n     * If parent is null or no node is found the method returns null.\n     *\n     * @param parent the parent Node\n     * @param path   the path to the Node being searched for\n     * @return the Node if found or null if not found\n     */\n    public static <V> Node<V> findNodeByPath(Node<V> parent, @NotNull String path) {\n        return parent != null && hasChildren(parent) ? findNodeByPath(parent.getChildren(), path) : null;\n    }\n\n    /**\n     * Returns the node underneath the given parents that matches the given path.\n     * The path is a '/' separated list of Node label prefixes describing the ancestor chain of the sought for Node\n     * relative to each of the given parent nodes. If there are several nodes that match the given path the method\n     * returns the first one unless the respective path segments has the special prefix \"last:\". In this case the\n     * method will return the last matching node.\n     * Example: \"per/last:so/fix\" will return the first node, whose label starts with \"fix\" under the last node,\n     * whose label starts with \"so\" under the first node, whose label starts with \"per\".\n     * If the given collections of parents is null or empty or no node is found the method returns null.\n     *\n     * @param parents the parent Nodes to look through\n     * @param path    the path to the Node being searched for\n     * @return the Node if found or null if not found\n     */\n    public static <V> Node<V> findNodeByPath(List<Node<V>> parents, @NotNull String path) {\n        if (parents != null && !parents.isEmpty()) {\n            int separatorIndex = path.indexOf('/');\n            String prefix = separatorIndex != -1 ? path.substring(0, separatorIndex) : path;\n            Iterable<Node<V>> iterable = parents;\n            if (prefix.startsWith(\"last:\")) {\n                prefix = prefix.substring(5);\n                iterable = Utils.reverse(parents);\n            }\n            for (Node<V> child : iterable) {\n                if (StringUtils.startsWith(child.getLabel(), prefix)) {\n                    return separatorIndex == -1 ? child : findNodeByPath(child, path.substring(separatorIndex + 1));\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Collects all Nodes underneath the given parent that match the given path.\n     * The path is a '/' separated list of Node label prefixes describing the ancestor chain of the sought for Nodes\n     * relative to the given parent.\n     *\n     * @param parent     the parent Node\n     * @param path       the path to the Nodes being searched for\n     * @param collection the collection to collect the found Nodes into\n     * @return the same collection instance passed as a parameter\n     */\n    public static <V, C extends Collection<Node<V>>> C collectNodesByPath(Node<V> parent,\n                                                                          @NotNull String path,\n                                                                          @NotNull C collection) {\n        return parent != null && hasChildren(parent) ?\n                collectNodesByPath(parent.getChildren(), path, collection) : collection;\n    }\n\n    /**\n     * Collects all Nodes underneath the given parents that match the given path.\n     * The path is a '/' separated list of Node label prefixes describing the ancestor chain of the sought for Nodes\n     * relative to each of the given parent nodes.\n     *\n     * @param parents    the parent Nodes to look through\n     * @param path       the path to the Nodes being searched for\n     * @param collection the collection to collect the found Nodes into\n     * @return the same collection instance passed as a parameter\n     */\n    public static <V, C extends Collection<Node<V>>> C collectNodesByPath(Collection<Node<V>> parents,\n                                                                          @NotNull String path,\n                                                                          @NotNull C collection) {\n        if (parents != null && !parents.isEmpty()) {\n            int separatorIndex = path.indexOf('/');\n            String prefix = separatorIndex != -1 ? path.substring(0, separatorIndex) : path;\n            for (Node<V> child : parents) {\n                if (StringUtils.startsWith(child.getLabel(), prefix)) {\n                    if (separatorIndex == -1) {\n                        collection.add(child);\n                    } else {\n                        collectNodesByPath(child, path.substring(separatorIndex + 1), collection);\n                    }\n                }\n            }\n        }\n        return collection;\n    }\n\n    /**\n     * Returns the first Node underneath the given parent for which the given predicate evaluates to true.\n     * If parent is null or no node is found the method returns null.\n     *\n     * @param parent    the parent Node\n     * @param predicate the predicate\n     * @return the Node if found or null if not found\n     */\n    public static <V> Node<V> findNode(Node<V> parent, @NotNull Predicate<Node<V>> predicate) {\n        if (parent != null) {\n            if (predicate.apply(parent)) return parent;\n            if (hasChildren(parent)) {\n                Node<V> found = findNode(parent.getChildren(), predicate);\n                if (found != null) return found;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Returns the first Node underneath the given parents for which the given predicate evaluates to true.\n     * If parents is null or empty or no node is found the method returns null.\n     *\n     * @param parents   the parent Nodes to look through\n     * @param predicate the predicate\n     * @return the Node if found or null if not found\n     */\n    public static <V> Node<V> findNode(Collection<Node<V>> parents, @NotNull Predicate<Node<V>> predicate) {\n        if (parents != null && !parents.isEmpty()) {\n            for (Node<V> child : parents) {\n                Node<V> found = findNode(child, predicate);\n                if (found != null) return found;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Collects all Nodes underneath the given parent that match the given label (prefix).\n     *\n     * @param parent      the parent Node\n     * @param labelPrefix the path to the Nodes being searched for\n     * @param collection  the collection to collect the found Nodes into\n     * @return the same collection instance passed as a parameter\n     */\n    public static <V, C extends Collection<Node<V>>> C collectNodesByLabel(Node<V> parent,\n                                                                           @NotNull String labelPrefix,\n                                                                           @NotNull C collection) {\n        return parent != null && hasChildren(parent) ?\n                collectNodesByPath(parent.getChildren(), labelPrefix, collection) : collection;\n    }\n\n    /**\n     * Collects all Nodes underneath the given parents that match the given label (prefix).\n     *\n     * @param parents     the parent Nodes to look through\n     * @param labelPrefix the path to the Nodes being searched for\n     * @param collection  the collection to collect the found Nodes into\n     * @return the same collection instance passed as a parameter\n     */\n    public static <V, C extends Collection<Node<V>>> C collectNodesByLabel(Collection<Node<V>> parents,\n                                                                           @NotNull String labelPrefix,\n                                                                           @NotNull C collection) {\n        if (parents != null && !parents.isEmpty()) {\n            for (Node<V> child : parents) {\n                if (StringUtils.startsWith(child.getLabel(), labelPrefix)) {\n                    collection.add(child);\n                }\n                collectNodesByPath(child, labelPrefix, collection);\n            }\n        }\n        return collection;\n    }\n\n    /**\n     * Returns the input text matched by the given Node.\n     *\n     * @param node        the node\n     * @param inputBuffer the underlying inputBuffer\n     * @return null if node is null otherwise a string with the matched input text (which can be empty)\n     */\n    public static String getNodeText(Node<?> node, @NotNull InputBuffer inputBuffer) {\n        return node != null ? inputBuffer.extract(node.getStartLocation().index, node.getEndLocation().index) : null;\n    }\n\n    /**\n     * Returns the first input character matched by the given Node.\n     *\n     * @param node        the node\n     * @param inputBuffer the underlying inputBuffer\n     * @return null if node is null or did not match at least one character otherwise the first matched input char\n     */\n    public static Character getNodeChar(Node<?> node, InputBuffer inputBuffer) {\n        return node != null && node.getEndLocation().index > node.getStartLocation().index ?\n                inputBuffer.charAt(node.getStartLocation().index) : null;\n    }\n\n    /**\n     * Creates a readable string represenation of the parse tree in thee given ParsingResult object.\n     *\n     * @param parsingResult the parsing result containing the parse tree\n     * @return a new String\n     */\n    public static <V> String printNodeTree(@NotNull ParsingResult<V> parsingResult) {\n        return printTree(parsingResult.root, new NodeFormatter<V>(parsingResult.inputBuffer));\n    }\n\n}\n\n","lineNo":116}
{"Refactored Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled;\n\nimport net.sf.cglib.proxy.Factory;\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.actionparameters.*;\nimport static org.parboiled.actionparameters.ActionParameterUtils.mixInParameter;\nimport org.parboiled.common.Converter;\nimport org.parboiled.common.AbstractConverter;\nimport static org.parboiled.common.Utils.arrayOf;\nimport org.parboiled.support.*;\n\nimport java.util.*;\n\n/**\n * Base class for custom parsers. Defines basic methods for rule and action parameter creation.\n *\n * @param <V> The type of the value field of the parse tree nodes created by this parser.\n * @param <A> The type of the parser Actions you would like to use in your rules. If you don't need any parser\n * actions (e.g. for very simple examples) you can just use the Actions interface directly.\n */\npublic abstract class BaseParser<V, A extends Actions<V>> {\n\n    /**\n     * Special object to be used for null arguments to action methods.\n     */\n    public static final Object NULL = new Object();\n\n    protected final Map<Character, Rule> charMatchers = new HashMap<Character, Rule>();\n    protected final Map<String, Rule> stringMatchers = new HashMap<String, Rule>();\n    protected final Stack<ActionParameter> actionParameters = new Stack<ActionParameter>();\n\n    /**\n     * The immutable reference to your parser actions.\n     */\n    public final A actions;\n\n    /**\n     * Constructs a new parser object using the given actions.\n     *\n     * @param actions the parser actions (can be null)\n     */\n    public BaseParser(A actions) {\n        this.actions = actions;\n    }\n\n    /**\n     * Runs the given parser rule against the given input string. Note that the rule must have been created by\n     * a rule creation method of this parser object, which must have been created with Parser.create(...).\n     *\n     * @param rule  the rule\n     * @param input the input string\n     * @return the ParsingResult for the run\n     */\n    @SuppressWarnings({\"unchecked\"})\n    public ParsingResult<V> parse(@NotNull Rule rule, @NotNull String input) {\n        Checks.ensure(rule instanceof StagingRule,\n                \"Illegal rule instance, please use Parboiled.createActions(...) for creating this parser\");\n        Checks.ensure(((StagingRule) rule).getParser() == this,\n                \"Illegal rule instance, it was not created by this parser\");\n\n        // prepare\n        InputBuffer inputBuffer = new InputBuffer(input);\n        InputLocation startLocation = new InputLocation(inputBuffer);\n        List<ParseError> parseErrors = new ArrayList<ParseError>();\n        Matcher<V> matcher = (Matcher<V>) rule.toMatcher();\n        MatcherContext<V> context = new MatcherContext<V>(startLocation, matcher, actions, parseErrors);\n\n        // the matcher tree has already been built during the call to Parboiled.parse(...), usually immediately\n        // before the invocation of this method, we need to signal to the ActionInterceptor that rule construction\n        // is over and all further action calls should not continue to createActions ActionMatchers but actually be\n        // \"routed through\" to the actual action method implementations\n        if (actions != null) {\n            ActionInterceptor actionInterceptor = (ActionInterceptor) ((Factory) actions).getCallback(1);\n            actionInterceptor.setParser(null);\n        }\n\n        // run the actual matcher tree\n        context.runMatcher(true);\n\n        return new ParsingResult<V>(context.getNode(), parseErrors, inputBuffer);\n    }\n\n    ////////////////////////////////// RULE CREATION ///////////////////////////////////\n\n    /**\n     * Explicitly creates a rule matching the given character.\n     * Normally you can just specify the character literal directly in you rule description. However, if you want\n     * to specify special rule attributes (like a label) you can also use this wrapper.\n     *\n     * @param c the char to match\n     * @return a new rule\n     */\n    public Rule ch(char c) {\n        return new CharMatcher(c);\n    }\n\n    /**\n     * Creates a rule matching a range of characters from cLow to cHigh (both inclusively).\n     *\n     * @param cLow  the start char of the range (inclusively)\n     * @param cHigh the end char of the range (inclusively)\n     * @return a new rule\n     */\n    public Rule charRange(char cLow, char cHigh) {\n        return cLow == cHigh ? ch(cLow) : new CharRangeMatcher(cLow, cHigh);\n    }\n\n    /**\n     * Explicitly creates a rule matching the given string.\n     * Normally you can just specify the string literal directly in you rule description. However, if you want\n     * to specify special rule attributes (like a label) you can also use this wrapper.\n     *\n     * @param string the string to match\n     * @return a new rule\n     */\n    public Rule string(@NotNull String string) {\n        Rule[] matchers = new Rule[string.length()];\n        for (int i = 0; i < string.length(); i++) matchers[i] = cachedChar(string.charAt(i));\n        return new SequenceMatcher(matchers, false).label(string);\n    }\n\n    /**\n     * Creates a new rule that successively tries all of the given subrules and succeeds when the first one of\n     * its subrules matches. If all subrules fail this rule fails as well.\n     *\n     * @param rule      the first subrule\n     * @param rule2     the second subrule\n     * @param moreRules the other subrules\n     * @return a new rule\n     */\n    public Rule firstOf(@NotNull Object rule, Object rule2, Object... moreRules) {\n        return new FirstOfMatcher(toRules(arrayOf(rule, arrayOf(rule2, moreRules)))).label(\"firstOf\");\n    }\n\n    /**\n     * Creates a new rule that tries repeated matches of its subrule and succeeds if the subrule matches at least once.\n     * If the subrule does not match at least once this rule fails.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule oneOrMore(@NotNull Object rule) {\n        return new OneOrMoreMatcher(toRule(rule)).label(\"oneOrMore\");\n    }\n\n    /**\n     * Creates a new rule that tries a match on its subrule and always succeeds, independently of the matching\n     * success of its subrule.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule optional(@NotNull Object rule) {\n        return new OptionalMatcher(toRule(rule)).label(\"optional\");\n    }\n\n    /**\n     * Creates a new rule that only succeeds if all of its subrule succeed, one after the other.\n     *\n     * @param rule      the first subrule\n     * @param rule2     the second subrule\n     * @param moreRules the other subrules\n     * @return a new rule\n     */\n    public Rule sequence(@NotNull Object rule, Object rule2, Object... moreRules) {\n        return new SequenceMatcher(toRules(arrayOf(rule, arrayOf(rule2, moreRules))), false).label(\"sequence\");\n    }\n\n    /**\n     * Creates a new rule that only succeeds if all of its subrules succeed, one after the other.\n     * However, after the first subrule has matched all further subrule matches are enforced, i.e. if one of them\n     * fails a ParseError will be created (and error recovery will be tried).\n     *\n     * @param rule      the first subrule\n     * @param rule2     the second subrule\n     * @param moreRules the other subrules\n     * @return a new rule\n     */\n    public Rule enforcedSequence(@NotNull Object rule, Object rule2, Object... moreRules) {\n        return new SequenceMatcher(toRules(arrayOf(rule, arrayOf(rule2, moreRules))), true).label(\"enforcedSequence\");\n    }\n\n    /**\n     * Creates a new rule that acts as a syntactic predicate, i.e. tests the given subrule against the current\n     * input position without actually matching any characters. Succeeds if the subrule succeeds and fails if the\n     * subrule rails.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule test(@NotNull Object rule) {\n        return new TestMatcher(toRule(rule), false);\n    }\n\n    /**\n     * Creates a new rule that acts as an inverse syntactic predicate, i.e. tests the given subrule against the current\n     * input position without actually matching any characters. Succeeds if the subrule fails and fails if the\n     * subrule succeeds.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule testNot(@NotNull Object rule) {\n        return new TestMatcher(toRule(rule), true);\n    }\n\n    /**\n     * Creates a new rule that tries repeated matches of its subrule.\n     * Succeeds always, even if the subrule doesn't match even once.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule zeroOrMore(@NotNull Object rule) {\n        return new ZeroOrMoreMatcher(toRule(rule)).label(\"zeroOrMore\");\n    }\n\n    /**\n     * Matches the EOI (end of input) character.\n     *\n     * @return a new rule\n     */\n    public Rule eoi() {\n        return ch(Chars.EOI);\n    }\n\n    /**\n     * Matches any character and therefore always succeeds.\n     *\n     * @return a new rule\n     */\n    public Rule any() {\n        return ch(Chars.ANY);\n    }\n\n    /**\n     * Matches nothing and therefore always succeeds.\n     *\n     * @return a new rule\n     */\n    public Rule empty() {\n        return ch(Chars.EMPTY);\n    }\n\n    /**\n     * Creates a special action rule that sets the value of the parse tree node to be created for the current rule\n     * to the value of the last node created during the current parsing run.\n     *\n     * @return a new rule\n     */\n    public Rule set() {\n        return set(lastValue());\n    }\n\n    /**\n     * Creates a special action rule that sets the value of the parse tree node to be created for the current rule\n     * to the given value.\n     *\n     * @param value the value to set\n     * @return a new rule\n     */\n    public Rule set(V value) {\n        return new SetValueMatcher<V>(value);\n    }\n\n    ////////////////////////////////// ACTION PARAMETERS ///////////////////////////////////\n\n    /**\n     * Changes the context scope of all arguments to the current parent scope.\n     * @param argument the arguments to change to context for\n     * @return the result of the arguments\n     */\n    public <T> T up(T argument) {\n        actionParameters.add(new UpParameter(argument));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the first Node found with the given prefix path.\n     * The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public Node<V> node(@NotNull String path) {\n        Object pathArg = mixInParameter(actionParameters, path);\n        actionParameters.add(new PathNodeParameter(pathArg));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to an array of Nodes found with the given prefix path.\n     * The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public List<Node<V>> nodes(@NotNull String path) {\n        Object pathArg = mixInParameter(actionParameters, path);\n        actionParameters.add(new PathNodesParameter(pathArg));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the last node created during this parsing run.\n     *\n     * @return the action parameter\n     */\n    public Node<V> lastNode() {\n        actionParameters.add(new LastNodeParameter());\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the tree value of the current rule level, i.e.,\n     * If there is an explicitly set value it is returned. Otherwise the last non-null child value, or, if there\n     * is no such value, null.\n     *\n     * @return the action parameter\n     */\n    public V value() {\n        actionParameters.add(new TreeValueParameter());\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the value of the first Node found with the given prefix path.\n     * The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public V value(String path) {\n        actionParameters.add(new ValueParameter<V>(node(path)));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to an array of node value for the Nodes found with the\n     * given prefix path. The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public List<V> values(String path) {\n        actionParameters.add(new ValuesParameter<V>(nodes(path)));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the value of the last node created during this parsing run.\n     *\n     * @return the action parameter\n     */\n    public V lastValue() {\n        actionParameters.add(new ValueParameter<V>(lastNode()));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the matched input text of the first Node found with the\n     * given prefix path. The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public String text(String path) {\n        actionParameters.add(new TextParameter<V>(node(path)));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to an array of input texts matched by the Nodes found with the\n     * given prefix path. The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public List<String> texts(String path) {\n        actionParameters.add(new TextsParameter<V>(nodes(path)));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the matched input text of the\n     * last node created during this parsing run.\n     *\n     * @return the action parameter\n     */\n    public String lastText() {\n        actionParameters.add(new TextParameter<V>(lastNode()));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the first character of the matched input text of the first Node\n     * found with the given prefix path.\n     * The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public Character ch(String path) {\n        actionParameters.add(new CharParameter<V>(node(path)));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to an array of the first characters of the input texts matched\n     * by the Nodes found with the given prefix path.\n     * The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public List<Character> chars(String path) {\n        actionParameters.add(new CharsParameter<V>(nodes(path)));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the first character of the matched input text of the\n     * last node created during this parsing run.\n     *\n     * @return the action parameter\n     */\n    public Character lastChar() {\n        actionParameters.add(new CharParameter<V>(lastNode()));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to an object using the given converter.\n     *\n     * @param text      the text (parameter) to convert\n     * @param converter the converter to use\n     * @return the action parameter\n     */\n    public <T> T convert(String text, @NotNull Converter<T> converter) {\n        Object textArg = mixInParameter(actionParameters, text);\n        actionParameters.add(new ConvertParameter<T>(textArg, converter));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to an Integer.\n     *\n     * @param text the text (parameter) to convert\n     * @return the action parameter\n     */\n    public Integer convertToInteger(String text) {\n        return convert(text, new AbstractConverter<Integer>(Integer.class) {\n            public Integer parse(String string) {\n                return Integer.parseInt(string);\n            }\n        });\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to a Long.\n     *\n     * @param text the text (parameter) to convert\n     * @return the action parameter\n     */\n    public Long convertToLong(String text) {\n        return convert(text, new AbstractConverter<Long>(Long.class) {\n            public Long parse(String string) {\n                return Long.parseLong(string);\n            }\n        });\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to a Float.\n     *\n     * @param text the text (parameter) to convert\n     * @return the action parameter\n     */\n    public Float convertToFloat(String text) {\n        return convert(text, new AbstractConverter<Float>(Float.class) {\n            public Float parse(String string) {\n                return Float.parseFloat(string);\n            }\n        });\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to an Double.\n     *\n     * @param text the text (parameter) to convert\n     * @return the action parameter\n     */\n    public Double convertToDouble(String text) {\n        return convert(text, new AbstractConverter<Double>(Double.class) {\n            public Double parse(String string) {\n                return Double.parseDouble(string);\n            }\n        });\n    }\n\n    ///************************* PRIVATE ***************************///\n\n    private Rule cachedChar(char c) {\n        Rule matcher = charMatchers.get(c);\n        if (matcher == null) {\n            matcher = ((AbstractMatcher) ch(c)).lock();\n            charMatchers.put(c, matcher);\n        }\n        return matcher;\n    }\n\n    private Rule cachedString(String string) {\n        Rule matcher = stringMatchers.get(string);\n        if (matcher == null) {\n            matcher = ((AbstractMatcher) string(string)).lock();\n            stringMatchers.put(string, matcher);\n        }\n        return matcher;\n    }\n\n    private Rule[] toRules(@NotNull Object[] objects) {\n        Rule[] rules = new Rule[objects.length];\n        for (int i = 0; i < objects.length; i++) {\n            rules[i] = toRule(objects[i]);\n        }\n        return rules;\n    }\n\n    private Rule toRule(Object obj) {\n        if (obj instanceof Rule) {\n            return (Rule) obj;\n        }\n        if (obj instanceof Character) {\n            return cachedChar((Character) obj);\n        }\n        if (obj instanceof String) {\n            return cachedString((String) obj);\n        }\n        if (obj == null) {\n            return newActionMatcher();\n        }\n        throw new ParserConstructionException(\"\\'\" + obj + \"\\' is not a valid Rule\");\n    }\n\n    private Rule newActionMatcher() {\n        ActionParameter parameter = (ActionParameter) mixInParameter(actionParameters, null);\n        Checks.ensure(parameter instanceof ActionCallParameter,\n                \"Illegal parser action, don't you want to call a method on your actions object?\");\n        ActionCallParameter actionCall = (ActionCallParameter) parameter;\n        actionCall.verifyReturnType(ActionResult.class);\n        return new ActionMatcher(actionCall);\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled;\n\nimport net.sf.cglib.proxy.Factory;\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.support.*;\nimport static org.parboiled.utils.Utils.arrayOf;\n\nimport java.util.*;\n\n/**\n * Base class for custom parsers. Defines basic methods for rule and action parameter creation.\n *\n * @param <V> The type of the value field of the parse tree nodes created by this parser.\n * @param <A> The type of the parser Actions you would like to use in your rules. If you don't need any parser\n * actions (e.g. for very simple examples) you can just use the Actions interface directly.\n */\npublic abstract class BaseParser<V, A extends Actions<V>> {\n\n    /**\n     * Special object to be used for null arguments to action methods.\n     */\n    public static final Object NULL = new Object();\n\n    private final Map<Character, Rule> charMatchers = new HashMap<Character, Rule>();\n    private final Map<String, Rule> stringMatchers = new HashMap<String, Rule>();\n    private final LinkedList<ActionParameter<V>> actionParameterStack = new LinkedList<ActionParameter<V>>();\n\n    /**\n     * The immutable reference to your parser actions.\n     */\n    public final A actions;\n\n    /**\n     * Constructs a new parser rules object using the given actions.\n     *\n     * @param actions the parser actions (can be null, if not required)\n     */\n    public BaseParser(A actions) {\n        this.actions = actions;\n    }\n\n    /**\n     * Runs the given parser rule against the given input string. Note that the rule must have been created by\n     * a rule creation method of this parser object, which must have been created with Parser.create(...).\n     *\n     * @param rule  the rule\n     * @param input the input string\n     * @return the ParsingResult for the run\n     */\n    @SuppressWarnings({\"unchecked\"})\n    public ParsingResult<V> parse(@NotNull Rule rule, @NotNull String input) {\n        Checks.ensure(rule instanceof StagingRule,\n                \"Illegal rule instance, please use Parboiled.createActions(...) for creating this parser\");\n        Checks.ensure(((StagingRule) rule).getParser() == this,\n                \"Illegal rule instance, it was not created by this parser\");\n\n        // prepare\n        InputBuffer inputBuffer = new InputBuffer(input);\n        InputLocation startLocation = new InputLocation(inputBuffer);\n        List<ParseError> parseErrors = new ArrayList<ParseError>();\n        Matcher<V> matcher = (Matcher<V>) rule.toMatcher();\n        MatcherContext<V> context = new MatcherContext<V>(null, startLocation, matcher, actions, parseErrors);\n\n        // the matcher tree has already been built during the call to Parboiled.parse(...), usually immediately\n        // before the invocation of this method, we need to signal to the ActionInterceptor that rule construction\n        // is over and all further action calls should not continue to createActions ActionMatchers but actually be\n        // \"routed through\" to the actual action method implementations\n        if (actions != null) {\n            ActionInterceptor actionInterceptor = (ActionInterceptor) ((Factory) actions).getCallback(1);\n            actionInterceptor.setParser(null);\n        }\n\n        // run the actual matcher tree\n        context.runMatcher(true);\n\n        return new ParsingResult<V>(context.getNode(), parseErrors, inputBuffer);\n    }\n\n    ////////////////////////////////// RULE CREATION ///////////////////////////////////\n\n    /**\n     * Explicitly creates a rule matching the given character.\n     * Normally you can just specify the character literal directly in you rule description. However, if you want\n     * to specify special rule attributes (like a label) you can also use this wrapper.\n     *\n     * @param c the char to match\n     * @return a new rule\n     */\n    public Rule ch(char c) {\n        return new CharMatcher(c);\n    }\n\n    /**\n     * Creates a rule matching a range of characters from cLow to cHigh (both inclusively).\n     *\n     * @param cLow  the start char of the range (inclusively)\n     * @param cHigh the end char of the range (inclusively)\n     * @return a new rule\n     */\n    public Rule charRange(char cLow, char cHigh) {\n        return cLow == cHigh ? ch(cLow) : new CharRangeMatcher(cLow, cHigh);\n    }\n\n    /**\n     * Explicitly creates a rule matching the given string.\n     * Normally you can just specify the string literal directly in you rule description. However, if you want\n     * to specify special rule attributes (like a label) you can also use this wrapper.\n     *\n     * @param string the string to match\n     * @return a new rule\n     */\n    public Rule string(@NotNull String string) {\n        Rule[] matchers = new Rule[string.length()];\n        for (int i = 0; i < string.length(); i++) matchers[i] = cachedChar(string.charAt(i));\n        return new SequenceMatcher(matchers, false).label(string);\n    }\n\n    /**\n     * Creates a new rule that successively tries all of the given subrules and succeeds when the first one of\n     * its subrules matches. If all subrules fail this rule fails as well.\n     *\n     * @param rule      the first subrule\n     * @param rule2     the second subrule\n     * @param moreRules the other subrules\n     * @return a new rule\n     */\n    public Rule firstOf(@NotNull Object rule, Object rule2, Object... moreRules) {\n        return new FirstOfMatcher(toRules(arrayOf(rule, arrayOf(rule2, moreRules)))).label(\"firstOf\");\n    }\n\n    /**\n     * Creates a new rule that tries repeated matches of its subrule and succeeds if the subrule matches at least once.\n     * If the subrule does not match at least once this rule fails.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule oneOrMore(@NotNull Object rule) {\n        return new OneOrMoreMatcher(toRule(rule)).label(\"oneOrMore\");\n    }\n\n    /**\n     * Creates a new rule that tries a match on its subrule and always succeeds, independently of the matching\n     * success of its subrule.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule optional(@NotNull Object rule) {\n        return new OptionalMatcher(toRule(rule)).label(\"optional\");\n    }\n\n    /**\n     * Creates a new rule that only succeeds if all of its subrule succeed, one after the other.\n     *\n     * @param rule      the first subrule\n     * @param rule2     the second subrule\n     * @param moreRules the other subrules\n     * @return a new rule\n     */\n    public Rule sequence(@NotNull Object rule, Object rule2, Object... moreRules) {\n        return new SequenceMatcher(toRules(arrayOf(rule, arrayOf(rule2, moreRules))), false).label(\"sequence\");\n    }\n\n    /**\n     * Creates a new rule that only succeeds if all of its subrules succeed, one after the other.\n     * However, after the first subrule has matched all further subrule matches are enforced, i.e. if one of them\n     * fails a ParseError will be created (and error recovery will be tried).\n     *\n     * @param rule      the first subrule\n     * @param rule2     the second subrule\n     * @param moreRules the other subrules\n     * @return a new rule\n     */\n    public Rule enforcedSequence(@NotNull Object rule, Object rule2, Object... moreRules) {\n        return new SequenceMatcher(toRules(arrayOf(rule, arrayOf(rule2, moreRules))), true).label(\"enforcedSequence\");\n    }\n\n    /**\n     * Creates a new rule that acts as a syntactic predicate, i.e. tests the given subrule against the current\n     * input position without actually matching any characters. Succeeds if the subrule succeeds and fails if the\n     * subrule rails.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule test(@NotNull Object rule) {\n        return new TestMatcher(toRule(rule), false);\n    }\n\n    /**\n     * Creates a new rule that acts as an inverse syntactic predicate, i.e. tests the given subrule against the current\n     * input position without actually matching any characters. Succeeds if the subrule fails and fails if the\n     * subrule succeeds.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule testNot(@NotNull Object rule) {\n        return new TestMatcher(toRule(rule), true);\n    }\n\n    /**\n     * Creates a new rule that tries repeated matches of its subrule.\n     * Succeeds always, even if the subrule doesn't match even once.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule zeroOrMore(@NotNull Object rule) {\n        return new ZeroOrMoreMatcher(toRule(rule)).label(\"zeroOrMore\");\n    }\n\n    /**\n     * Matches the EOI (end of input) character.\n     *\n     * @return a new rule\n     */\n    public Rule eoi() {\n        return ch(Chars.EOI);\n    }\n\n    /**\n     * Matches any character and therefore always succeeds.\n     *\n     * @return a new rule\n     */\n    public Rule any() {\n        return ch(Chars.ANY);\n    }\n\n    /**\n     * Matches nothing and therefore always succeeds.\n     *\n     * @return a new rule\n     */\n    public Rule empty() {\n        return ch(Chars.EMPTY);\n    }\n\n    ////////////////////////////////// ACTION PARAMETERS ///////////////////////////////////\n\n    /**\n     * Creates an action parameter that evaluates to the first Node found with the given prefix path.\n     * The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public Node<V> node(@NotNull String path) {\n        actionParameterStack.add(new ActionParameter.Node<V>(path));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to an array of Nodes found with the given prefix path.\n     * The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public Node<V>[] nodes(@NotNull String path) {\n        actionParameterStack.add(new ActionParameter.Nodes<V>(path));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the first Node found matching the given label prefix.\n     * Caution: Since this only identifies nodes by their label and not by their paths nodes from arbitrary tree\n     * depths might be returned, which can be unindended, especially in recursive rules.\n     *\n     * @param labelPrefix the label prefix to be searched for\n     * @return the action parameter\n     */\n    public Node<V> nodeWithLabel(@NotNull String labelPrefix) {\n        actionParameterStack.add(new ActionParameter.NodeWithLabel<V>(labelPrefix));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to an array of Nodes matching the given label prefix.\n     * Caution: Since this only identifies nodes by their label and not by their paths nodes from arbitrary tree\n     * depths might be returned, which can be unindended, especially in recursive rules.\n     *\n     * @param labelPrefix the label prefix to be searched for\n     * @return the action parameter\n     */\n    public Node<V>[] nodesWithLabel(@NotNull String labelPrefix) {\n        actionParameterStack.add(new ActionParameter.NodesWithLabel<V>(labelPrefix));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the value of the first Node found with the given prefix path.\n     * The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public V value(String path) {\n        actionParameterStack.add(new ActionParameter.Value<V>(path));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to an array of node value for the Nodes found with the\n     * given prefix path. The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public V[] values(String path) {\n        actionParameterStack.add(new ActionParameter.Values<V>(path));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the first non-null node value found in a depth-first tree\n     * search under the first node found with the given prefix path.\n     * The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public V firstValue(String path) {\n        actionParameterStack.add(new ActionParameter.FirstValue<V>(path));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the matched input text of the first Node found with the\n     * given prefix path. The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public String text(String path) {\n        actionParameterStack.add(new ActionParameter.Text<V>(path));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to an array of input texts matched by the Nodes found with the\n     * given prefix path. The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public String[] texts(String path) {\n        actionParameterStack.add(new ActionParameter.Texts<V>(path));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the first character of the matched input text of the first Node\n     * found with the given prefix path.\n     * The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public Character ch(String path) {\n        actionParameterStack.add(new ActionParameter.Char<V>(path));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to an array of the first characters of the input texts matched\n     * by the Nodes found with the given prefix path.\n     * The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public Character[] chars(String path) {\n        actionParameterStack.add(new ActionParameter.Chars<V>(path));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the first non-null action parameter passed as parameters.\n     *\n     * @param value      the first parameter\n     * @param value2     the second parameter\n     * @param moreValues more parameters\n     * @return the first non-null action parameter\n     */\n    @SuppressWarnings({\"unchecked\"})\n    public <T> T firstNonNull(T value, T value2, T... moreValues) {\n        Object[] args = new Object[moreValues.length + 2];\n        for (int i = args.length - 1; i >= 0; i--) {\n            Object arg = i == 0 ? value : i == 1 ? value2 : moreValues[i - 2];\n            if (arg == null) {\n                arg = actionParameterStack.removeLast();\n                Checks.ensure(arg != null, \"Illegal argument list for firstNonNull(): null values are not allowed!\");\n            }\n            args[i] = arg;\n        }\n        actionParameterStack.add(new ActionParameter.FirstOfNonNull<V>(args));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to an object using the given converter.\n     *\n     * @param text      the text (parameter) to convert\n     * @param converter the converter to use\n     * @return the action parameter\n     */\n    public <T> T convert(String text, @NotNull Converter<T> converter) {\n        Object arg = text;\n        if (text == null) {\n            arg = actionParameterStack.removeLast();\n            Checks.ensure(arg != null, \"Illegal argument list for convert(): null values are not allowed!\");\n        }\n        actionParameterStack.add(new ActionParameter.Convert<V, T>(arg, converter));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to an Integer.\n     *\n     * @param text the text (parameter) to convert\n     * @return the action parameter\n     */\n    public Integer convertToInteger(String text) {\n        return convert(text, new Converter<Integer>() {\n            public Integer parse(String string) {\n                return Integer.parseInt(string);\n            }\n        });\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to a Long.\n     *\n     * @param text the text (parameter) to convert\n     * @return the action parameter\n     */\n    public Long convertToLong(String text) {\n        return convert(text, new Converter<Long>() {\n            public Long parse(String string) {\n                return Long.parseLong(string);\n            }\n        });\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to a Float.\n     *\n     * @param text the text (parameter) to convert\n     * @return the action parameter\n     */\n    public Float convertToFloat(String text) {\n        return convert(text, new Converter<Float>() {\n            public Float parse(String string) {\n                return Float.parseFloat(string);\n            }\n        });\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to an Double.\n     *\n     * @param text the text (parameter) to convert\n     * @return the action parameter\n     */\n    public Double convertToDouble(String text) {\n        return convert(text, new Converter<Double>() {\n            public Double parse(String string) {\n                return Double.parseDouble(string);\n            }\n        });\n    }\n\n    ///************************* PACKAGE ***************************///\n\n    ActionParameter[] retrieveAndClearActionParameters() {\n        ActionParameter[] params = actionParameterStack.toArray(new ActionParameter[actionParameterStack.size()]);\n        actionParameterStack.clear();\n        return params;\n    }\n\n    ///************************* PRIVATE ***************************///\n\n    private Rule cachedChar(char c) {\n        Rule matcher = charMatchers.get(c);\n        if (matcher == null) {\n            matcher = ((AbstractMatcher) ch(c)).lock();\n            charMatchers.put(c, matcher);\n        }\n        return matcher;\n    }\n\n    private Rule cachedString(String string) {\n        Rule matcher = stringMatchers.get(string);\n        if (matcher == null) {\n            matcher = ((AbstractMatcher) string(string)).lock();\n            stringMatchers.put(string, matcher);\n        }\n        return matcher;\n    }\n\n    private Rule[] toRules(@NotNull Object[] objects) {\n        Rule[] rules = new Rule[objects.length];\n        for (int i = 0; i < objects.length; i++) {\n            rules[i] = toRule(objects[i]);\n        }\n        return rules;\n    }\n\n    private Rule toRule(Object obj) {\n        if (obj instanceof Rule) {\n            return (Rule) obj;\n        }\n        if (obj instanceof Character) {\n            return cachedChar((Character) obj);\n        }\n        if (obj instanceof String) {\n            return cachedString((String) obj);\n        }\n        throw new ParserConstructionException(\"\\'\" + obj + \"\\' is not a valid Rule\");\n    }\n\n}\n","lineNo":302}
{"Refactored Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled;\n\nimport net.sf.cglib.proxy.Factory;\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.actionparameters.*;\nimport static org.parboiled.actionparameters.ActionParameterUtils.mixInParameter;\nimport org.parboiled.common.Converter;\nimport org.parboiled.common.AbstractConverter;\nimport static org.parboiled.common.Utils.arrayOf;\nimport org.parboiled.support.*;\n\nimport java.util.*;\n\n/**\n * Base class for custom parsers. Defines basic methods for rule and action parameter creation.\n *\n * @param <V> The type of the value field of the parse tree nodes created by this parser.\n * @param <A> The type of the parser Actions you would like to use in your rules. If you don't need any parser\n * actions (e.g. for very simple examples) you can just use the Actions interface directly.\n */\npublic abstract class BaseParser<V, A extends Actions<V>> {\n\n    /**\n     * Special object to be used for null arguments to action methods.\n     */\n    public static final Object NULL = new Object();\n\n    protected final Map<Character, Rule> charMatchers = new HashMap<Character, Rule>();\n    protected final Map<String, Rule> stringMatchers = new HashMap<String, Rule>();\n    protected final Stack<ActionParameter> actionParameters = new Stack<ActionParameter>();\n\n    /**\n     * The immutable reference to your parser actions.\n     */\n    public final A actions;\n\n    /**\n     * Constructs a new parser object using the given actions.\n     *\n     * @param actions the parser actions (can be null)\n     */\n    public BaseParser(A actions) {\n        this.actions = actions;\n    }\n\n    /**\n     * Runs the given parser rule against the given input string. Note that the rule must have been created by\n     * a rule creation method of this parser object, which must have been created with Parser.create(...).\n     *\n     * @param rule  the rule\n     * @param input the input string\n     * @return the ParsingResult for the run\n     */\n    @SuppressWarnings({\"unchecked\"})\n    public ParsingResult<V> parse(@NotNull Rule rule, @NotNull String input) {\n        Checks.ensure(rule instanceof StagingRule,\n                \"Illegal rule instance, please use Parboiled.createActions(...) for creating this parser\");\n        Checks.ensure(((StagingRule) rule).getParser() == this,\n                \"Illegal rule instance, it was not created by this parser\");\n\n        // prepare\n        InputBuffer inputBuffer = new InputBuffer(input);\n        InputLocation startLocation = new InputLocation(inputBuffer);\n        List<ParseError> parseErrors = new ArrayList<ParseError>();\n        Matcher<V> matcher = (Matcher<V>) rule.toMatcher();\n        MatcherContext<V> context = new MatcherContext<V>(startLocation, matcher, actions, parseErrors);\n\n        // the matcher tree has already been built during the call to Parboiled.parse(...), usually immediately\n        // before the invocation of this method, we need to signal to the ActionInterceptor that rule construction\n        // is over and all further action calls should not continue to createActions ActionMatchers but actually be\n        // \"routed through\" to the actual action method implementations\n        if (actions != null) {\n            ActionInterceptor actionInterceptor = (ActionInterceptor) ((Factory) actions).getCallback(1);\n            actionInterceptor.setParser(null);\n        }\n\n        // run the actual matcher tree\n        context.runMatcher(true);\n\n        return new ParsingResult<V>(context.getNode(), parseErrors, inputBuffer);\n    }\n\n    ////////////////////////////////// RULE CREATION ///////////////////////////////////\n\n    /**\n     * Explicitly creates a rule matching the given character.\n     * Normally you can just specify the character literal directly in you rule description. However, if you want\n     * to specify special rule attributes (like a label) you can also use this wrapper.\n     *\n     * @param c the char to match\n     * @return a new rule\n     */\n    public Rule ch(char c) {\n        return new CharMatcher(c);\n    }\n\n    /**\n     * Creates a rule matching a range of characters from cLow to cHigh (both inclusively).\n     *\n     * @param cLow  the start char of the range (inclusively)\n     * @param cHigh the end char of the range (inclusively)\n     * @return a new rule\n     */\n    public Rule charRange(char cLow, char cHigh) {\n        return cLow == cHigh ? ch(cLow) : new CharRangeMatcher(cLow, cHigh);\n    }\n\n    /**\n     * Explicitly creates a rule matching the given string.\n     * Normally you can just specify the string literal directly in you rule description. However, if you want\n     * to specify special rule attributes (like a label) you can also use this wrapper.\n     *\n     * @param string the string to match\n     * @return a new rule\n     */\n    public Rule string(@NotNull String string) {\n        Rule[] matchers = new Rule[string.length()];\n        for (int i = 0; i < string.length(); i++) matchers[i] = cachedChar(string.charAt(i));\n        return new SequenceMatcher(matchers, false).label(string);\n    }\n\n    /**\n     * Creates a new rule that successively tries all of the given subrules and succeeds when the first one of\n     * its subrules matches. If all subrules fail this rule fails as well.\n     *\n     * @param rule      the first subrule\n     * @param rule2     the second subrule\n     * @param moreRules the other subrules\n     * @return a new rule\n     */\n    public Rule firstOf(@NotNull Object rule, Object rule2, Object... moreRules) {\n        return new FirstOfMatcher(toRules(arrayOf(rule, arrayOf(rule2, moreRules)))).label(\"firstOf\");\n    }\n\n    /**\n     * Creates a new rule that tries repeated matches of its subrule and succeeds if the subrule matches at least once.\n     * If the subrule does not match at least once this rule fails.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule oneOrMore(@NotNull Object rule) {\n        return new OneOrMoreMatcher(toRule(rule)).label(\"oneOrMore\");\n    }\n\n    /**\n     * Creates a new rule that tries a match on its subrule and always succeeds, independently of the matching\n     * success of its subrule.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule optional(@NotNull Object rule) {\n        return new OptionalMatcher(toRule(rule)).label(\"optional\");\n    }\n\n    /**\n     * Creates a new rule that only succeeds if all of its subrule succeed, one after the other.\n     *\n     * @param rule      the first subrule\n     * @param rule2     the second subrule\n     * @param moreRules the other subrules\n     * @return a new rule\n     */\n    public Rule sequence(@NotNull Object rule, Object rule2, Object... moreRules) {\n        return new SequenceMatcher(toRules(arrayOf(rule, arrayOf(rule2, moreRules))), false).label(\"sequence\");\n    }\n\n    /**\n     * Creates a new rule that only succeeds if all of its subrules succeed, one after the other.\n     * However, after the first subrule has matched all further subrule matches are enforced, i.e. if one of them\n     * fails a ParseError will be created (and error recovery will be tried).\n     *\n     * @param rule      the first subrule\n     * @param rule2     the second subrule\n     * @param moreRules the other subrules\n     * @return a new rule\n     */\n    public Rule enforcedSequence(@NotNull Object rule, Object rule2, Object... moreRules) {\n        return new SequenceMatcher(toRules(arrayOf(rule, arrayOf(rule2, moreRules))), true).label(\"enforcedSequence\");\n    }\n\n    /**\n     * Creates a new rule that acts as a syntactic predicate, i.e. tests the given subrule against the current\n     * input position without actually matching any characters. Succeeds if the subrule succeeds and fails if the\n     * subrule rails.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule test(@NotNull Object rule) {\n        return new TestMatcher(toRule(rule), false);\n    }\n\n    /**\n     * Creates a new rule that acts as an inverse syntactic predicate, i.e. tests the given subrule against the current\n     * input position without actually matching any characters. Succeeds if the subrule fails and fails if the\n     * subrule succeeds.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule testNot(@NotNull Object rule) {\n        return new TestMatcher(toRule(rule), true);\n    }\n\n    /**\n     * Creates a new rule that tries repeated matches of its subrule.\n     * Succeeds always, even if the subrule doesn't match even once.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule zeroOrMore(@NotNull Object rule) {\n        return new ZeroOrMoreMatcher(toRule(rule)).label(\"zeroOrMore\");\n    }\n\n    /**\n     * Matches the EOI (end of input) character.\n     *\n     * @return a new rule\n     */\n    public Rule eoi() {\n        return ch(Chars.EOI);\n    }\n\n    /**\n     * Matches any character and therefore always succeeds.\n     *\n     * @return a new rule\n     */\n    public Rule any() {\n        return ch(Chars.ANY);\n    }\n\n    /**\n     * Matches nothing and therefore always succeeds.\n     *\n     * @return a new rule\n     */\n    public Rule empty() {\n        return ch(Chars.EMPTY);\n    }\n\n    /**\n     * Creates a special action rule that sets the value of the parse tree node to be created for the current rule\n     * to the value of the last node created during the current parsing run.\n     *\n     * @return a new rule\n     */\n    public Rule set() {\n        return set(lastValue());\n    }\n\n    /**\n     * Creates a special action rule that sets the value of the parse tree node to be created for the current rule\n     * to the given value.\n     *\n     * @param value the value to set\n     * @return a new rule\n     */\n    public Rule set(V value) {\n        return new SetValueMatcher<V>(value);\n    }\n\n    ////////////////////////////////// ACTION PARAMETERS ///////////////////////////////////\n\n    /**\n     * Changes the context scope of all arguments to the current parent scope.\n     * @param argument the arguments to change to context for\n     * @return the result of the arguments\n     */\n    public <T> T up(T argument) {\n        actionParameters.add(new UpParameter(argument));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the first Node found with the given prefix path.\n     * The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public Node<V> node(@NotNull String path) {\n        Object pathArg = mixInParameter(actionParameters, path);\n        actionParameters.add(new PathNodeParameter(pathArg));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to an array of Nodes found with the given prefix path.\n     * The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public List<Node<V>> nodes(@NotNull String path) {\n        Object pathArg = mixInParameter(actionParameters, path);\n        actionParameters.add(new PathNodesParameter(pathArg));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the last node created during this parsing run.\n     *\n     * @return the action parameter\n     */\n    public Node<V> lastNode() {\n        actionParameters.add(new LastNodeParameter());\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the tree value of the current rule level, i.e.,\n     * If there is an explicitly set value it is returned. Otherwise the last non-null child value, or, if there\n     * is no such value, null.\n     *\n     * @return the action parameter\n     */\n    public V value() {\n        actionParameters.add(new TreeValueParameter());\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the value of the first Node found with the given prefix path.\n     * The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public V value(String path) {\n        actionParameters.add(new ValueParameter<V>(node(path)));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to an array of node value for the Nodes found with the\n     * given prefix path. The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public List<V> values(String path) {\n        actionParameters.add(new ValuesParameter<V>(nodes(path)));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the value of the last node created during this parsing run.\n     *\n     * @return the action parameter\n     */\n    public V lastValue() {\n        actionParameters.add(new ValueParameter<V>(lastNode()));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the matched input text of the first Node found with the\n     * given prefix path. The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public String text(String path) {\n        actionParameters.add(new TextParameter<V>(node(path)));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to an array of input texts matched by the Nodes found with the\n     * given prefix path. The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public List<String> texts(String path) {\n        actionParameters.add(new TextsParameter<V>(nodes(path)));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the matched input text of the\n     * last node created during this parsing run.\n     *\n     * @return the action parameter\n     */\n    public String lastText() {\n        actionParameters.add(new TextParameter<V>(lastNode()));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the first character of the matched input text of the first Node\n     * found with the given prefix path.\n     * The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public Character ch(String path) {\n        actionParameters.add(new CharParameter<V>(node(path)));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to an array of the first characters of the input texts matched\n     * by the Nodes found with the given prefix path.\n     * The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public List<Character> chars(String path) {\n        actionParameters.add(new CharsParameter<V>(nodes(path)));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the first character of the matched input text of the\n     * last node created during this parsing run.\n     *\n     * @return the action parameter\n     */\n    public Character lastChar() {\n        actionParameters.add(new CharParameter<V>(lastNode()));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to an object using the given converter.\n     *\n     * @param text      the text (parameter) to convert\n     * @param converter the converter to use\n     * @return the action parameter\n     */\n    public <T> T convert(String text, @NotNull Converter<T> converter) {\n        Object textArg = mixInParameter(actionParameters, text);\n        actionParameters.add(new ConvertParameter<T>(textArg, converter));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to an Integer.\n     *\n     * @param text the text (parameter) to convert\n     * @return the action parameter\n     */\n    public Integer convertToInteger(String text) {\n        return convert(text, new AbstractConverter<Integer>(Integer.class) {\n            public Integer parse(String string) {\n                return Integer.parseInt(string);\n            }\n        });\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to a Long.\n     *\n     * @param text the text (parameter) to convert\n     * @return the action parameter\n     */\n    public Long convertToLong(String text) {\n        return convert(text, new AbstractConverter<Long>(Long.class) {\n            public Long parse(String string) {\n                return Long.parseLong(string);\n            }\n        });\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to a Float.\n     *\n     * @param text the text (parameter) to convert\n     * @return the action parameter\n     */\n    public Float convertToFloat(String text) {\n        return convert(text, new AbstractConverter<Float>(Float.class) {\n            public Float parse(String string) {\n                return Float.parseFloat(string);\n            }\n        });\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to an Double.\n     *\n     * @param text the text (parameter) to convert\n     * @return the action parameter\n     */\n    public Double convertToDouble(String text) {\n        return convert(text, new AbstractConverter<Double>(Double.class) {\n            public Double parse(String string) {\n                return Double.parseDouble(string);\n            }\n        });\n    }\n\n    ///************************* PRIVATE ***************************///\n\n    private Rule cachedChar(char c) {\n        Rule matcher = charMatchers.get(c);\n        if (matcher == null) {\n            matcher = ((AbstractMatcher) ch(c)).lock();\n            charMatchers.put(c, matcher);\n        }\n        return matcher;\n    }\n\n    private Rule cachedString(String string) {\n        Rule matcher = stringMatchers.get(string);\n        if (matcher == null) {\n            matcher = ((AbstractMatcher) string(string)).lock();\n            stringMatchers.put(string, matcher);\n        }\n        return matcher;\n    }\n\n    private Rule[] toRules(@NotNull Object[] objects) {\n        Rule[] rules = new Rule[objects.length];\n        for (int i = 0; i < objects.length; i++) {\n            rules[i] = toRule(objects[i]);\n        }\n        return rules;\n    }\n\n    private Rule toRule(Object obj) {\n        if (obj instanceof Rule) {\n            return (Rule) obj;\n        }\n        if (obj instanceof Character) {\n            return cachedChar((Character) obj);\n        }\n        if (obj instanceof String) {\n            return cachedString((String) obj);\n        }\n        if (obj == null) {\n            return newActionMatcher();\n        }\n        throw new ParserConstructionException(\"\\'\" + obj + \"\\' is not a valid Rule\");\n    }\n\n    private Rule newActionMatcher() {\n        ActionParameter parameter = (ActionParameter) mixInParameter(actionParameters, null);\n        Checks.ensure(parameter instanceof ActionCallParameter,\n                \"Illegal parser action, don't you want to call a method on your actions object?\");\n        ActionCallParameter actionCall = (ActionCallParameter) parameter;\n        actionCall.verifyReturnType(ActionResult.class);\n        return new ActionMatcher(actionCall);\n    }\n\n}\n","Smelly Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled;\n\nimport net.sf.cglib.proxy.Factory;\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.support.*;\nimport static org.parboiled.utils.Utils.arrayOf;\n\nimport java.util.*;\n\n/**\n * Base class for custom parsers. Defines basic methods for rule and action parameter creation.\n *\n * @param <V> The type of the value field of the parse tree nodes created by this parser.\n * @param <A> The type of the parser Actions you would like to use in your rules. If you don't need any parser\n * actions (e.g. for very simple examples) you can just use the Actions interface directly.\n */\npublic abstract class BaseParser<V, A extends Actions<V>> {\n\n    /**\n     * Special object to be used for null arguments to action methods.\n     */\n    public static final Object NULL = new Object();\n\n    private final Map<Character, Rule> charMatchers = new HashMap<Character, Rule>();\n    private final Map<String, Rule> stringMatchers = new HashMap<String, Rule>();\n    private final LinkedList<ActionParameter<V>> actionParameterStack = new LinkedList<ActionParameter<V>>();\n\n    /**\n     * The immutable reference to your parser actions.\n     */\n    public final A actions;\n\n    /**\n     * Constructs a new parser rules object using the given actions.\n     *\n     * @param actions the parser actions (can be null, if not required)\n     */\n    public BaseParser(A actions) {\n        this.actions = actions;\n    }\n\n    /**\n     * Runs the given parser rule against the given input string. Note that the rule must have been created by\n     * a rule creation method of this parser object, which must have been created with Parser.create(...).\n     *\n     * @param rule  the rule\n     * @param input the input string\n     * @return the ParsingResult for the run\n     */\n    @SuppressWarnings({\"unchecked\"})\n    public ParsingResult<V> parse(@NotNull Rule rule, @NotNull String input) {\n        Checks.ensure(rule instanceof StagingRule,\n                \"Illegal rule instance, please use Parboiled.createActions(...) for creating this parser\");\n        Checks.ensure(((StagingRule) rule).getParser() == this,\n                \"Illegal rule instance, it was not created by this parser\");\n\n        // prepare\n        InputBuffer inputBuffer = new InputBuffer(input);\n        InputLocation startLocation = new InputLocation(inputBuffer);\n        List<ParseError> parseErrors = new ArrayList<ParseError>();\n        Matcher<V> matcher = (Matcher<V>) rule.toMatcher();\n        MatcherContext<V> context = new MatcherContext<V>(null, startLocation, matcher, actions, parseErrors);\n\n        // the matcher tree has already been built during the call to Parboiled.parse(...), usually immediately\n        // before the invocation of this method, we need to signal to the ActionInterceptor that rule construction\n        // is over and all further action calls should not continue to createActions ActionMatchers but actually be\n        // \"routed through\" to the actual action method implementations\n        if (actions != null) {\n            ActionInterceptor actionInterceptor = (ActionInterceptor) ((Factory) actions).getCallback(1);\n            actionInterceptor.setParser(null);\n        }\n\n        // run the actual matcher tree\n        context.runMatcher(true);\n\n        return new ParsingResult<V>(context.getNode(), parseErrors, inputBuffer);\n    }\n\n    ////////////////////////////////// RULE CREATION ///////////////////////////////////\n\n    /**\n     * Explicitly creates a rule matching the given character.\n     * Normally you can just specify the character literal directly in you rule description. However, if you want\n     * to specify special rule attributes (like a label) you can also use this wrapper.\n     *\n     * @param c the char to match\n     * @return a new rule\n     */\n    public Rule ch(char c) {\n        return new CharMatcher(c);\n    }\n\n    /**\n     * Creates a rule matching a range of characters from cLow to cHigh (both inclusively).\n     *\n     * @param cLow  the start char of the range (inclusively)\n     * @param cHigh the end char of the range (inclusively)\n     * @return a new rule\n     */\n    public Rule charRange(char cLow, char cHigh) {\n        return cLow == cHigh ? ch(cLow) : new CharRangeMatcher(cLow, cHigh);\n    }\n\n    /**\n     * Explicitly creates a rule matching the given string.\n     * Normally you can just specify the string literal directly in you rule description. However, if you want\n     * to specify special rule attributes (like a label) you can also use this wrapper.\n     *\n     * @param string the string to match\n     * @return a new rule\n     */\n    public Rule string(@NotNull String string) {\n        Rule[] matchers = new Rule[string.length()];\n        for (int i = 0; i < string.length(); i++) matchers[i] = cachedChar(string.charAt(i));\n        return new SequenceMatcher(matchers, false).label(string);\n    }\n\n    /**\n     * Creates a new rule that successively tries all of the given subrules and succeeds when the first one of\n     * its subrules matches. If all subrules fail this rule fails as well.\n     *\n     * @param rule      the first subrule\n     * @param rule2     the second subrule\n     * @param moreRules the other subrules\n     * @return a new rule\n     */\n    public Rule firstOf(@NotNull Object rule, Object rule2, Object... moreRules) {\n        return new FirstOfMatcher(toRules(arrayOf(rule, arrayOf(rule2, moreRules)))).label(\"firstOf\");\n    }\n\n    /**\n     * Creates a new rule that tries repeated matches of its subrule and succeeds if the subrule matches at least once.\n     * If the subrule does not match at least once this rule fails.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule oneOrMore(@NotNull Object rule) {\n        return new OneOrMoreMatcher(toRule(rule)).label(\"oneOrMore\");\n    }\n\n    /**\n     * Creates a new rule that tries a match on its subrule and always succeeds, independently of the matching\n     * success of its subrule.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule optional(@NotNull Object rule) {\n        return new OptionalMatcher(toRule(rule)).label(\"optional\");\n    }\n\n    /**\n     * Creates a new rule that only succeeds if all of its subrule succeed, one after the other.\n     *\n     * @param rule      the first subrule\n     * @param rule2     the second subrule\n     * @param moreRules the other subrules\n     * @return a new rule\n     */\n    public Rule sequence(@NotNull Object rule, Object rule2, Object... moreRules) {\n        return new SequenceMatcher(toRules(arrayOf(rule, arrayOf(rule2, moreRules))), false).label(\"sequence\");\n    }\n\n    /**\n     * Creates a new rule that only succeeds if all of its subrules succeed, one after the other.\n     * However, after the first subrule has matched all further subrule matches are enforced, i.e. if one of them\n     * fails a ParseError will be created (and error recovery will be tried).\n     *\n     * @param rule      the first subrule\n     * @param rule2     the second subrule\n     * @param moreRules the other subrules\n     * @return a new rule\n     */\n    public Rule enforcedSequence(@NotNull Object rule, Object rule2, Object... moreRules) {\n        return new SequenceMatcher(toRules(arrayOf(rule, arrayOf(rule2, moreRules))), true).label(\"enforcedSequence\");\n    }\n\n    /**\n     * Creates a new rule that acts as a syntactic predicate, i.e. tests the given subrule against the current\n     * input position without actually matching any characters. Succeeds if the subrule succeeds and fails if the\n     * subrule rails.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule test(@NotNull Object rule) {\n        return new TestMatcher(toRule(rule), false);\n    }\n\n    /**\n     * Creates a new rule that acts as an inverse syntactic predicate, i.e. tests the given subrule against the current\n     * input position without actually matching any characters. Succeeds if the subrule fails and fails if the\n     * subrule succeeds.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule testNot(@NotNull Object rule) {\n        return new TestMatcher(toRule(rule), true);\n    }\n\n    /**\n     * Creates a new rule that tries repeated matches of its subrule.\n     * Succeeds always, even if the subrule doesn't match even once.\n     *\n     * @param rule the subrule\n     * @return a new rule\n     */\n    public Rule zeroOrMore(@NotNull Object rule) {\n        return new ZeroOrMoreMatcher(toRule(rule)).label(\"zeroOrMore\");\n    }\n\n    /**\n     * Matches the EOI (end of input) character.\n     *\n     * @return a new rule\n     */\n    public Rule eoi() {\n        return ch(Chars.EOI);\n    }\n\n    /**\n     * Matches any character and therefore always succeeds.\n     *\n     * @return a new rule\n     */\n    public Rule any() {\n        return ch(Chars.ANY);\n    }\n\n    /**\n     * Matches nothing and therefore always succeeds.\n     *\n     * @return a new rule\n     */\n    public Rule empty() {\n        return ch(Chars.EMPTY);\n    }\n\n    ////////////////////////////////// ACTION PARAMETERS ///////////////////////////////////\n\n    /**\n     * Creates an action parameter that evaluates to the first Node found with the given prefix path.\n     * The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public Node<V> node(@NotNull String path) {\n        actionParameterStack.add(new ActionParameter.Node<V>(path));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to an array of Nodes found with the given prefix path.\n     * The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public Node<V>[] nodes(@NotNull String path) {\n        actionParameterStack.add(new ActionParameter.Nodes<V>(path));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the first Node found matching the given label prefix.\n     * Caution: Since this only identifies nodes by their label and not by their paths nodes from arbitrary tree\n     * depths might be returned, which can be unindended, especially in recursive rules.\n     *\n     * @param labelPrefix the label prefix to be searched for\n     * @return the action parameter\n     */\n    public Node<V> nodeWithLabel(@NotNull String labelPrefix) {\n        actionParameterStack.add(new ActionParameter.NodeWithLabel<V>(labelPrefix));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to an array of Nodes matching the given label prefix.\n     * Caution: Since this only identifies nodes by their label and not by their paths nodes from arbitrary tree\n     * depths might be returned, which can be unindended, especially in recursive rules.\n     *\n     * @param labelPrefix the label prefix to be searched for\n     * @return the action parameter\n     */\n    public Node<V>[] nodesWithLabel(@NotNull String labelPrefix) {\n        actionParameterStack.add(new ActionParameter.NodesWithLabel<V>(labelPrefix));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the value of the first Node found with the given prefix path.\n     * The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public V value(String path) {\n        actionParameterStack.add(new ActionParameter.Value<V>(path));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to an array of node value for the Nodes found with the\n     * given prefix path. The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public V[] values(String path) {\n        actionParameterStack.add(new ActionParameter.Values<V>(path));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the first non-null node value found in a depth-first tree\n     * search under the first node found with the given prefix path.\n     * The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public V firstValue(String path) {\n        actionParameterStack.add(new ActionParameter.FirstValue<V>(path));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the matched input text of the first Node found with the\n     * given prefix path. The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public String text(String path) {\n        actionParameterStack.add(new ActionParameter.Text<V>(path));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to an array of input texts matched by the Nodes found with the\n     * given prefix path. The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public String[] texts(String path) {\n        actionParameterStack.add(new ActionParameter.Texts<V>(path));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the first character of the matched input text of the first Node\n     * found with the given prefix path.\n     * The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public Character ch(String path) {\n        actionParameterStack.add(new ActionParameter.Char<V>(path));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to an array of the first characters of the input texts matched\n     * by the Nodes found with the given prefix path.\n     * The path is a '/' separated list of node label prefixes, relative to the current rule.\n     *\n     * @param path the path to search for\n     * @return the action parameter\n     */\n    public Character[] chars(String path) {\n        actionParameterStack.add(new ActionParameter.Chars<V>(path));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that evaluates to the first non-null action parameter passed as parameters.\n     *\n     * @param value      the first parameter\n     * @param value2     the second parameter\n     * @param moreValues more parameters\n     * @return the first non-null action parameter\n     */\n    @SuppressWarnings({\"unchecked\"})\n    public <T> T firstNonNull(T value, T value2, T... moreValues) {\n        Object[] args = new Object[moreValues.length + 2];\n        for (int i = args.length - 1; i >= 0; i--) {\n            Object arg = i == 0 ? value : i == 1 ? value2 : moreValues[i - 2];\n            if (arg == null) {\n                arg = actionParameterStack.removeLast();\n                Checks.ensure(arg != null, \"Illegal argument list for firstNonNull(): null values are not allowed!\");\n            }\n            args[i] = arg;\n        }\n        actionParameterStack.add(new ActionParameter.FirstOfNonNull<V>(args));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to an object using the given converter.\n     *\n     * @param text      the text (parameter) to convert\n     * @param converter the converter to use\n     * @return the action parameter\n     */\n    public <T> T convert(String text, @NotNull Converter<T> converter) {\n        Object arg = text;\n        if (text == null) {\n            arg = actionParameterStack.removeLast();\n            Checks.ensure(arg != null, \"Illegal argument list for convert(): null values are not allowed!\");\n        }\n        actionParameterStack.add(new ActionParameter.Convert<V, T>(arg, converter));\n        return null;\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to an Integer.\n     *\n     * @param text the text (parameter) to convert\n     * @return the action parameter\n     */\n    public Integer convertToInteger(String text) {\n        return convert(text, new Converter<Integer>() {\n            public Integer parse(String string) {\n                return Integer.parseInt(string);\n            }\n        });\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to a Long.\n     *\n     * @param text the text (parameter) to convert\n     * @return the action parameter\n     */\n    public Long convertToLong(String text) {\n        return convert(text, new Converter<Long>() {\n            public Long parse(String string) {\n                return Long.parseLong(string);\n            }\n        });\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to a Float.\n     *\n     * @param text the text (parameter) to convert\n     * @return the action parameter\n     */\n    public Float convertToFloat(String text) {\n        return convert(text, new Converter<Float>() {\n            public Float parse(String string) {\n                return Float.parseFloat(string);\n            }\n        });\n    }\n\n    /**\n     * Creates an action parameter that converts the given text parameter to an Double.\n     *\n     * @param text the text (parameter) to convert\n     * @return the action parameter\n     */\n    public Double convertToDouble(String text) {\n        return convert(text, new Converter<Double>() {\n            public Double parse(String string) {\n                return Double.parseDouble(string);\n            }\n        });\n    }\n\n    ///************************* PACKAGE ***************************///\n\n    ActionParameter[] retrieveAndClearActionParameters() {\n        ActionParameter[] params = actionParameterStack.toArray(new ActionParameter[actionParameterStack.size()]);\n        actionParameterStack.clear();\n        return params;\n    }\n\n    ///************************* PRIVATE ***************************///\n\n    private Rule cachedChar(char c) {\n        Rule matcher = charMatchers.get(c);\n        if (matcher == null) {\n            matcher = ((AbstractMatcher) ch(c)).lock();\n            charMatchers.put(c, matcher);\n        }\n        return matcher;\n    }\n\n    private Rule cachedString(String string) {\n        Rule matcher = stringMatchers.get(string);\n        if (matcher == null) {\n            matcher = ((AbstractMatcher) string(string)).lock();\n            stringMatchers.put(string, matcher);\n        }\n        return matcher;\n    }\n\n    private Rule[] toRules(@NotNull Object[] objects) {\n        Rule[] rules = new Rule[objects.length];\n        for (int i = 0; i < objects.length; i++) {\n            rules[i] = toRule(objects[i]);\n        }\n        return rules;\n    }\n\n    private Rule toRule(Object obj) {\n        if (obj instanceof Rule) {\n            return (Rule) obj;\n        }\n        if (obj instanceof Character) {\n            return cachedChar((Character) obj);\n        }\n        if (obj instanceof String) {\n            return cachedString((String) obj);\n        }\n        throw new ParserConstructionException(\"\\'\" + obj + \"\\' is not a valid Rule\");\n    }\n\n}\n","lineNo":315}
{"Refactored Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.support;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.Node;\nimport org.parboiled.common.Predicate;\nimport org.parboiled.common.StringUtils;\nimport org.parboiled.common.Utils;\nimport static org.parboiled.trees.GraphUtils.hasChildren;\nimport static org.parboiled.trees.GraphUtils.printTree;\n\nimport java.util.Collection;\nimport java.util.List;\n\n/**\n * General utility methods for operating on parse trees.\n */\npublic class ParseTreeUtils {\n\n    private ParseTreeUtils() {}\n\n    /**\n     * Returns the first Node underneath the given parent that matches the given path.\n     * The path is a '/' separated list of Node label prefixes describing the ancestor chain of the sought for Node\n     * relative to the given parent.\n     * If parent is null or no node is found the method returns null.\n     *\n     * @param parent the parent Node\n     * @param path   the path to the Node being searched for\n     * @return the Node if found or null if not found\n     */\n    public static <V> Node<V> findNodeByPath(Node<V> parent, @NotNull String path) {\n        return parent != null && hasChildren(parent) ? findNodeByPath(parent.getChildren(), path) : null;\n    }\n\n    /**\n     * Returns the node underneath the given parents that matches the given path.\n     * The path is a '/' separated list of Node label prefixes describing the ancestor chain of the sought for Node\n     * relative to each of the given parent nodes. If there are several nodes that match the given path the method\n     * returns the first one unless the respective path segments has the special prefix \"last:\". In this case the\n     * method will return the last matching node.\n     * Example: \"per/last:so/fix\" will return the first node, whose label starts with \"fix\" under the last node,\n     * whose label starts with \"so\" under the first node, whose label starts with \"per\".\n     * If the given collections of parents is null or empty or no node is found the method returns null.\n     *\n     * @param parents the parent Nodes to look through\n     * @param path    the path to the Node being searched for\n     * @return the Node if found or null if not found\n     */\n    public static <V> Node<V> findNodeByPath(List<Node<V>> parents, @NotNull String path) {\n        if (parents != null && !parents.isEmpty()) {\n            int separatorIndex = path.indexOf('/');\n            String prefix = separatorIndex != -1 ? path.substring(0, separatorIndex) : path;\n            Iterable<Node<V>> iterable = parents;\n            if (prefix.startsWith(\"last:\")) {\n                prefix = prefix.substring(5);\n                iterable = Utils.reverse(parents);\n            }\n            for (Node<V> child : iterable) {\n                if (StringUtils.startsWith(child.getLabel(), prefix)) {\n                    return separatorIndex == -1 ? child : findNodeByPath(child, path.substring(separatorIndex + 1));\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Collects all Nodes underneath the given parent that match the given path.\n     * The path is a '/' separated list of Node label prefixes describing the ancestor chain of the sought for Nodes\n     * relative to the given parent.\n     *\n     * @param parent     the parent Node\n     * @param path       the path to the Nodes being searched for\n     * @param collection the collection to collect the found Nodes into\n     * @return the same collection instance passed as a parameter\n     */\n    public static <V, C extends Collection<Node<V>>> C collectNodesByPath(Node<V> parent,\n                                                                          @NotNull String path,\n                                                                          @NotNull C collection) {\n        return parent != null && hasChildren(parent) ?\n                collectNodesByPath(parent.getChildren(), path, collection) : collection;\n    }\n\n    /**\n     * Collects all Nodes underneath the given parents that match the given path.\n     * The path is a '/' separated list of Node label prefixes describing the ancestor chain of the sought for Nodes\n     * relative to each of the given parent nodes.\n     *\n     * @param parents    the parent Nodes to look through\n     * @param path       the path to the Nodes being searched for\n     * @param collection the collection to collect the found Nodes into\n     * @return the same collection instance passed as a parameter\n     */\n    public static <V, C extends Collection<Node<V>>> C collectNodesByPath(Collection<Node<V>> parents,\n                                                                          @NotNull String path,\n                                                                          @NotNull C collection) {\n        if (parents != null && !parents.isEmpty()) {\n            int separatorIndex = path.indexOf('/');\n            String prefix = separatorIndex != -1 ? path.substring(0, separatorIndex) : path;\n            for (Node<V> child : parents) {\n                if (StringUtils.startsWith(child.getLabel(), prefix)) {\n                    if (separatorIndex == -1) {\n                        collection.add(child);\n                    } else {\n                        collectNodesByPath(child, path.substring(separatorIndex + 1), collection);\n                    }\n                }\n            }\n        }\n        return collection;\n    }\n\n    /**\n     * Returns the first Node underneath the given parent for which the given predicate evaluates to true.\n     * If parent is null or no node is found the method returns null.\n     *\n     * @param parent    the parent Node\n     * @param predicate the predicate\n     * @return the Node if found or null if not found\n     */\n    public static <V> Node<V> findNode(Node<V> parent, @NotNull Predicate<Node<V>> predicate) {\n        if (parent != null) {\n            if (predicate.apply(parent)) return parent;\n            if (hasChildren(parent)) {\n                Node<V> found = findNode(parent.getChildren(), predicate);\n                if (found != null) return found;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Returns the first Node underneath the given parents for which the given predicate evaluates to true.\n     * If parents is null or empty or no node is found the method returns null.\n     *\n     * @param parents   the parent Nodes to look through\n     * @param predicate the predicate\n     * @return the Node if found or null if not found\n     */\n    public static <V> Node<V> findNode(Collection<Node<V>> parents, @NotNull Predicate<Node<V>> predicate) {\n        if (parents != null && !parents.isEmpty()) {\n            for (Node<V> child : parents) {\n                Node<V> found = findNode(child, predicate);\n                if (found != null) return found;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Collects all Nodes underneath the given parent that match the given label (prefix).\n     *\n     * @param parent      the parent Node\n     * @param labelPrefix the path to the Nodes being searched for\n     * @param collection  the collection to collect the found Nodes into\n     * @return the same collection instance passed as a parameter\n     */\n    public static <V, C extends Collection<Node<V>>> C collectNodesByLabel(Node<V> parent,\n                                                                           @NotNull String labelPrefix,\n                                                                           @NotNull C collection) {\n        return parent != null && hasChildren(parent) ?\n                collectNodesByPath(parent.getChildren(), labelPrefix, collection) : collection;\n    }\n\n    /**\n     * Collects all Nodes underneath the given parents that match the given label (prefix).\n     *\n     * @param parents     the parent Nodes to look through\n     * @param labelPrefix the path to the Nodes being searched for\n     * @param collection  the collection to collect the found Nodes into\n     * @return the same collection instance passed as a parameter\n     */\n    public static <V, C extends Collection<Node<V>>> C collectNodesByLabel(Collection<Node<V>> parents,\n                                                                           @NotNull String labelPrefix,\n                                                                           @NotNull C collection) {\n        if (parents != null && !parents.isEmpty()) {\n            for (Node<V> child : parents) {\n                if (StringUtils.startsWith(child.getLabel(), labelPrefix)) {\n                    collection.add(child);\n                }\n                collectNodesByPath(child, labelPrefix, collection);\n            }\n        }\n        return collection;\n    }\n\n    /**\n     * Returns the input text matched by the given Node.\n     *\n     * @param node        the node\n     * @param inputBuffer the underlying inputBuffer\n     * @return null if node is null otherwise a string with the matched input text (which can be empty)\n     */\n    public static String getNodeText(Node<?> node, @NotNull InputBuffer inputBuffer) {\n        return node != null ? inputBuffer.extract(node.getStartLocation().index, node.getEndLocation().index) : null;\n    }\n\n    /**\n     * Returns the first input character matched by the given Node.\n     *\n     * @param node        the node\n     * @param inputBuffer the underlying inputBuffer\n     * @return null if node is null or did not match at least one character otherwise the first matched input char\n     */\n    public static Character getNodeChar(Node<?> node, InputBuffer inputBuffer) {\n        return node != null && node.getEndLocation().index > node.getStartLocation().index ?\n                inputBuffer.charAt(node.getStartLocation().index) : null;\n    }\n\n    /**\n     * Creates a readable string represenation of the parse tree in thee given ParsingResult object.\n     *\n     * @param parsingResult the parsing result containing the parse tree\n     * @return a new String\n     */\n    public static <V> String printNodeTree(@NotNull ParsingResult<V> parsingResult) {\n        return printTree(parsingResult.root, new NodeFormatter<V>(parsingResult.inputBuffer));\n    }\n\n}\n\n","Smelly Sample":"/*\n * Copyright (C) 2009 Mathias Doenitz\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.parboiled.support;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.Node;\nimport org.parboiled.ParsingResult;\nimport static org.parboiled.utils.DGraphUtils.hasChildren;\nimport static org.parboiled.utils.DGraphUtils.printTree;\nimport org.parboiled.utils.StringUtils;\n\nimport java.util.Collection;\n\n/**\n * General utility methods for operating on parse trees.\n */\npublic class ParseTreeUtils {\n\n    private ParseTreeUtils() {}\n\n    /**\n     * Returns the first Node underneath the given parent that matches the given path.\n     * The path is a '/' separated list of Node label prefixes describing the ancestor chain of the sought for Node\n     * relative to the given parent.\n     * If parent is null or no node is found the method returns null.\n     *\n     * @param parent the parent Node\n     * @param path   the path to the Node being searched for\n     * @return the Node if found or null if not found\n     */\n    public static <V> Node<V> findNodeByPath(Node<V> parent, @NotNull String path) {\n        return parent != null && hasChildren(parent) ? findNodeByPath(parent.getChildren(), path) : null;\n    }\n\n    /**\n     * Returns the first Node underneath the given parents that matches the given path.\n     * The path is a '/' separated list of Node label prefixes describing the ancestor chain of the sought for Node\n     * relative to each of the given parent nodes.\n     * If the given collections of parents is null or empty or no node is found the method returns null.\n     *\n     * @param parents the parent Nodes to look through\n     * @param path    the path to the Node being searched for\n     * @return the Node if found or null if not found\n     */\n    public static <V> Node<V> findNodeByPath(Collection<Node<V>> parents, @NotNull String path) {\n        if (parents != null && !parents.isEmpty()) {\n            int separatorIndex = path.indexOf('/');\n            String prefix = separatorIndex != -1 ? path.substring(0, separatorIndex) : path;\n            for (Node<V> child : parents) {\n                if (StringUtils.startsWith(child.getLabel(), prefix)) {\n                    return separatorIndex == -1 ? child : findNodeByPath(child, path.substring(separatorIndex + 1));\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Collects all Nodes underneath the given parent that match the given path.\n     * The path is a '/' separated list of Node label prefixes describing the ancestor chain of the sought for Nodes\n     * relative to the given parent.\n     *\n     * @param parent     the parent Node\n     * @param path       the path to the Nodes being searched for\n     * @param collection the collection to collect the found Nodes into\n     * @return the same collection instance passed as a parameter\n     */\n    public static <V, C extends Collection<Node<V>>> C collectNodesByPath(Node<V> parent,\n                                                                          @NotNull String path,\n                                                                          @NotNull C collection) {\n        return parent != null && hasChildren(parent) ?\n                collectNodesByPath(parent.getChildren(), path, collection) : collection;\n    }\n\n    /**\n     * Collects all Nodes underneath the given parents that match the given path.\n     * The path is a '/' separated list of Node label prefixes describing the ancestor chain of the sought for Nodes\n     * relative to each of the given parent nodes.\n     *\n     * @param parents    the parent Nodes to look through\n     * @param path       the path to the Nodes being searched for\n     * @param collection the collection to collect the found Nodes into\n     * @return the same collection instance passed as a parameter\n     */\n    public static <V, C extends Collection<Node<V>>> C collectNodesByPath(Collection<Node<V>> parents,\n                                                                          @NotNull String path,\n                                                                          @NotNull C collection) {\n        if (parents != null && !parents.isEmpty()) {\n            int separatorIndex = path.indexOf('/');\n            String prefix = separatorIndex != -1 ? path.substring(0, separatorIndex) : path;\n            for (Node<V> child : parents) {\n                if (StringUtils.startsWith(child.getLabel(), prefix)) {\n                    if (separatorIndex == -1) {\n                        collection.add(child);\n                    } else {\n                        collectNodesByPath(child, path.substring(separatorIndex + 1), collection);\n                    }\n                }\n            }\n        }\n        return collection;\n    }\n\n    /**\n     * Returns the first Node underneath the given parent for which the given predicate evaluates to true.\n     * If parent is null or no node is found the method returns null.\n     *\n     * @param parent the parent Node\n     * @param predicate the predicate\n     * @return the Node if found or null if not found\n     */\n    public static <V> Node<V> findNode(Node<V> parent, @NotNull Predicate<Node<V>> predicate) {\n        if (parent != null) {\n            if (predicate.apply(parent)) return parent;\n            if (hasChildren(parent)) {\n                Node<V> found = findNode(parent.getChildren(), predicate);\n                if (found != null) return found;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Returns the first Node underneath the given parents for which the given predicate evaluates to true.\n     * If parents is null or empty or no node is found the method returns null.\n     *\n     * @param parents the parent Nodes to look through\n     * @param predicate the predicate\n     * @return the Node if found or null if not found\n     */\n    public static <V> Node<V> findNode(Collection<Node<V>> parents, @NotNull Predicate<Node<V>> predicate) {\n        if (parents != null && !parents.isEmpty()) {\n            for (Node<V> child : parents) {\n                Node<V> found = findNode(child, predicate);\n                if (found != null) return found;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Collects all Nodes underneath the given parent that match the given label (prefix).\n     *\n     * @param parent      the parent Node\n     * @param labelPrefix the path to the Nodes being searched for\n     * @param collection  the collection to collect the found Nodes into\n     * @return the same collection instance passed as a parameter\n     */\n    public static <V, C extends Collection<Node<V>>> C collectNodesByLabel(Node<V> parent,\n                                                                           @NotNull String labelPrefix,\n                                                                           @NotNull C collection) {\n        return parent != null && hasChildren(parent) ?\n                collectNodesByPath(parent.getChildren(), labelPrefix, collection) : collection;\n    }\n\n    /**\n     * Collects all Nodes underneath the given parents that match the given label (prefix).\n     *\n     * @param parents     the parent Nodes to look through\n     * @param labelPrefix the path to the Nodes being searched for\n     * @param collection  the collection to collect the found Nodes into\n     * @return the same collection instance passed as a parameter\n     */\n    public static <V, C extends Collection<Node<V>>> C collectNodesByLabel(Collection<Node<V>> parents,\n                                                                     @NotNull String labelPrefix,\n                                                                     @NotNull C collection) {\n        if (parents != null && !parents.isEmpty()) {\n            for (Node<V> child : parents) {\n                if (StringUtils.startsWith(child.getLabel(), labelPrefix)) {\n                    collection.add(child);\n                }\n                collectNodesByPath(child, labelPrefix, collection);\n            }\n        }\n        return collection;\n    }\n\n    /**\n     * Returns the input text matched by the given Node.\n     *\n     * @param node        the node\n     * @param inputBuffer the underlying inputBuffer\n     * @return null if node is null otherwise a string with the matched input text (which can be empty)\n     */\n    public static String getNodeText(Node<?> node, @NotNull InputBuffer inputBuffer) {\n        return node != null ? inputBuffer.extract(node.getStartLocation().index, node.getEndLocation().index) : null;\n    }\n\n    /**\n     * Returns the first input character matched by the given Node.\n     *\n     * @param node        the node\n     * @param inputBuffer the underlying inputBuffer\n     * @return null if node is null or did not match at least one character otherwise the first matched input char\n     */\n    public static Character getNodeChar(Node<?> node, InputBuffer inputBuffer) {\n        return node != null && node.getEndLocation().index > node.getStartLocation().index ?\n                inputBuffer.charAt(node.getStartLocation().index) : null;\n    }\n\n    /**\n     * Creates a readable string represenation of the parse tree in thee given ParsingResult object.\n     *\n     * @param parsingResult the parsing result containing the parse tree\n     * @return a new String\n     */\n    public static <V> String printNodeTree(@NotNull ParsingResult<V> parsingResult) {\n        return printTree(parsingResult.root, new NodeFormatter<V>(parsingResult.inputBuffer));\n    }\n\n}\n\n","lineNo":69}
{"Refactored Sample":"package org.parboiled;\n\nimport net.sf.cglib.proxy.*;\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.support.Checks;\nimport org.parboiled.support.InputBuffer;\nimport org.parboiled.support.InputLocation;\nimport org.parboiled.support.ParseError;\nimport static org.parboiled.utils.Utils.arrayOf;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Main class providing the high-level entrypoints into the parboiled library.\n */\npublic class Parser {\n\n    private Parser() {}\n\n    /**\n     * Creates a parser object whose rule creation methods can then be used with the parse(...) method.\n     * Since parboiled needs to extends your parser object with certain extra logic (e.g. to prevent infinite recursions\n     * in recursive rule definitions) you cannot create your parser object yourself, but have to go through this method.\n     * Still your parser object can be of any type (even though it is usually derived from BaseParser) and can\n     * define arbitrary constructors.\n     * If you want to use an non-default constructor you also have to provide its arguments to this method.\n     *\n     * @param parserType            the type of the parser to create\n     * @param actions               the action object to use (if not null it must have been created with createActions(...)\n     * @param parserConstructorArgs optional arguments to the parser class constructor\n     * @return the ready to use parser instance\n     */\n    public static <A extends Actions, P extends BaseParser<A>> P create(@NotNull Class<P> parserType, A actions,\n                                                                        Object... parserConstructorArgs) {\n        ActionInterceptor actionInterceptor = null;\n        if (actions instanceof Factory) {\n            Callback actionsCallback = ((Factory) actions).getCallback(1);\n            if (actionsCallback instanceof ActionInterceptor) {\n                actionInterceptor = (ActionInterceptor) actionsCallback;\n            }\n        }\n\n        Checks.ensure(actions == null || actionInterceptor != null,\n                \"Illegal Actions instance, please use Parser.createActions(...) for creating your parser actions object\");\n\n        // intercept all no-arg Rule creation methods with a StagingInterceptor\n        P parser = create(parserType, new StagingInterceptor(), new CallbackFilter() {\n            public int accept(Method method) {\n                boolean isRuleCreatingMethod = method.getReturnType() == Rule.class;\n                boolean hasNoParameters = method.getParameterTypes().length == 0;\n                return isRuleCreatingMethod && hasNoParameters ? 1 : 0;\n            }\n        }, arrayOf(actions, parserConstructorArgs));\n\n        if (actions != null) {\n            // signal to the ActionInterceptor that we are in the rule construction phase by informing it\n            // about the parser object instance\n            //noinspection ConstantConditions\n            actionInterceptor.setParser(parser);\n        }\n        return parser;\n    }\n\n    /**\n     * Creates an action object whose actual action methods (the ones returning an ActionResult) can be directly used\n     * in your rule definitions.\n     * Since parboiled needs to extends your parser actions object with certain extra logic you cannot create your\n     * actions object yourself, but have to go through this method. Still your actions object can be of any base type\n     * (even though it is often times derived from BaseActions) and can define arbitrary constructors.\n     * If you want to use an non-default constructor you also have to provide its arguments to this method.\n     *\n     * @param actionsType     the type of the action object to create\n     * @param constructorArgs optional arguments to the class constructor\n     * @return the actions object for the parser creation\n     */\n    public static <A extends Actions> A createActions(@NotNull Class<A> actionsType, Object... constructorArgs) {\n        return create(actionsType, new ActionInterceptor(), new CallbackFilter() {\n            public int accept(Method method) {\n                // we need to intercept all methods that return an ActionResult, these are the \"real\" actions\n                return method.getReturnType() == ActionResult.class ? 1 : 0;\n            }\n        }, constructorArgs);\n    }\n\n    /**\n     * Runs the given parser rule against the given input string. Note that the rule must be created by a rule\n     * creation method from a parser object that was previously created with create(...).\n     *\n     * @param rule  the rule\n     * @param input the input string\n     * @return the ParsingResult for the run\n     */\n    @NotNull\n    public static ParsingResult parse(@NotNull Rule rule, @NotNull String input) {\n        Checks.ensure(rule instanceof StagingRule,\n                \"Illegal rule instance, please use Parser.createActions(...) for creating your parser object\");\n\n        // prepare\n        BaseParser<?> parser = ((StagingRule) rule).getParser();\n        InputBuffer inputBuffer = new InputBuffer(input);\n        InputLocation startLocation = new InputLocation(inputBuffer);\n        List<ParseError> parseErrors = new ArrayList<ParseError>();\n        Matcher matcher = rule.toMatcher();\n        MatcherContext context = new MatcherContext(null, startLocation, matcher, parser.actions, parseErrors);\n\n        // the matcher tree has already been built during the call to Parser.parse(...), usually immediately\n        // before the invocation of this method, we need to signal to the ActionInterceptor that rule construction\n        // is over and all further action calls should not continue to createActions ActionMatchers but actually be\n        // \"routed through\" to the actual action method implementations\n        if (parser.actions != null) {\n            ActionInterceptor actionInterceptor = (ActionInterceptor) ((Factory) parser.actions).getCallback(1);\n            actionInterceptor.setParser(null);\n        }\n\n        // run the actual matcher tree\n        context.runMatcher(true);\n\n        return new ParsingResult(context.getNode(), parseErrors, inputBuffer);\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    private static <T> T create(@NotNull Class<T> type, Callback interceptor, CallbackFilter filter,\n                                Object... constructorArguments) {\n        Enhancer e = new Enhancer();\n        e.setSuperclass(type);\n        e.setCallbackFilter(filter);\n        e.setCallbacks(new Callback[] {\n                NoOp.INSTANCE, // index 0: just call the underlying method directly\n                interceptor    // index 1: use the Interceptor\n        });\n        Constructor constructor = findConstructor(type, constructorArguments);\n        return (T) e.create(constructor.getParameterTypes(), constructorArguments);\n    }\n\n    private static Constructor findConstructor(Class<?> type, Object[] args) {\n        outer:\n        for (Constructor constructor : type.getConstructors()) {\n            Class<?>[] paramTypes = constructor.getParameterTypes();\n            if (paramTypes.length != args.length) continue;\n            for (int i = 0; i < args.length; i++) {\n                Object arg = args[i];\n                if (arg != null && !paramTypes[i].isAssignableFrom(arg.getClass())) continue outer;\n                if (arg == null && paramTypes[i].isPrimitive()) continue outer;\n            }\n            return constructor;\n        }\n        throw new RuntimeException(\"No constructor found for the given arguments\");\n    }\n\n}\n","Smelly Sample":"package org.parboiled;\n\nimport net.sf.cglib.proxy.*;\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.support.Checks;\nimport org.parboiled.support.InputBuffer;\nimport org.parboiled.support.InputLocation;\nimport org.parboiled.support.ParseError;\nimport org.parboiled.utils.Reflector;\nimport static org.parboiled.utils.Utils.arrayOf;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class Parser {\n\n    private Parser() {}\n\n    /**\n     * Creates a parser object (usually derived from BaseParser) whose Rule-creating, no-arg instance methods\n     * are extended with the following functionality:\n     * - Automatically locks all created Rules (which prevents further changes to their properties)\n     * - Automatically labels all created Rule objects with the name of the respective creation method\n     * - Caches Rules created by such methods, so subsequent calls return the same Rule instance\n     * - Prevents infinite recursions during rule construction by inserting proxy objects where required\n     * - Automatically injects WrapMatcher to allow for setting of custom properties for cached, locked Rules\n     *\n     * @param parserType            the type of the parser to create\n     * @param actions               the action object to use\n     * @param parserConstructorArgs optional arguments to the parser class constructor\n     * @return the parser ready to use parser instance\n     */\n    public static <A extends Actions, P extends BaseParser<A>> P create(@NotNull Class<P> parserType, A actions,\n                                                                        Object... parserConstructorArgs) {\n        Checks.ensure(actions == null || actions instanceof Factory,\n                \"Illegal Actions instance, please use Parser.create(...) for creating your parser actions object\");\n        P parser = create(parserType, new StagingInterceptor(), new CallbackFilter() {\n            public int accept(Method method) {\n                boolean isRuleCreatingMethod = method.getReturnType() == Rule.class;\n                boolean hasNoParameters = method.getParameterTypes().length == 0;\n                return isRuleCreatingMethod && hasNoParameters ? 1 : 0;\n            }\n        }, arrayOf(actions, parserConstructorArgs));\n\n        if (actions != null) {\n            // signal to the ActionInterceptor that we are in the rule construction phase by informing it\n            // about the parser object instance\n            //noinspection ConstantConditions\n            ((ActionInterceptor) ((Factory) actions).getCallback(1)).setParser(parser);\n        }\n        return parser;\n    }\n\n    /**\n     * Creates an action object (usually derived from BaseActions) whose actual action methods (the ones returning an\n     * ActionResult) are extended with the ability to create a binding that can be directly used as a matcher.\n     *\n     * @param actionsType     the type of the action object to create\n     * @param constructorArgs optional arguments to the class constructor\n     * @return the actions object for the parser creation\n     */\n    public static <A extends Actions> A create(@NotNull Class<A> actionsType, Object... constructorArgs) {\n        return create(actionsType, new ActionInterceptor(), new CallbackFilter() {\n            public int accept(Method method) {\n                // we need to intercept all methods that return an ActionResult, these are the \"real\" actions\n                return method.getReturnType() == ActionResult.class ? 1 : 0;\n            }\n        }, constructorArgs);\n    }\n\n    /**\n     * Runs the given parser rule against the given input string. Note that the rule must be created by a rule\n     * creation method from a parser object that was previously created with create().\n     *\n     * @param rule  the rule\n     * @param input the input string\n     * @return the ParsingResult for the run\n     */\n    @NotNull\n    public static ParsingResult parse(@NotNull Rule rule, @NotNull String input) {\n        Checks.ensure(rule instanceof StagingRule,\n                \"Illegal rule instance, please use Parser.create(...) for creating your parser object\");\n\n        // prepare\n        BaseParser<?> parser = ((StagingRule) rule).getParser();\n        InputBuffer inputBuffer = new InputBuffer(input);\n        InputLocation startLocation = new InputLocation(inputBuffer);\n        List<ParseError> parseErrors = new ArrayList<ParseError>();\n        Matcher matcher = rule.toMatcher();\n        MatcherContext context = new MatcherContext(null, startLocation, matcher, parser.actions, parseErrors);\n\n        // the matcher tree has already been built during the call to Parser.parse(...), usually immediately\n        // before the invocation of this method, we need to signal to the ActionInterceptor that rule construction\n        // is over and all further action calls should not continue to create ActionMatchers but actually be\n        // \"routed through\" to the actual action method implementations\n        if (parser.actions != null) {\n            ((ActionInterceptor) ((Factory) parser.actions).getCallback(1)).setParser(null);\n        }\n\n        // run the actual matcher tree\n        context.runMatcher(true);\n\n        return new ParsingResult(context.getNode(), parseErrors, inputBuffer);\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    private static <T> T create(@NotNull Class<T> type, Callback interceptor, CallbackFilter filter,\n                                Object... constructorArguments) {\n        Enhancer e = new Enhancer();\n        e.setSuperclass(type);\n        e.setCallbackFilter(filter);\n        e.setCallbacks(new Callback[] {\n                NoOp.INSTANCE, // index 0: just call the underlying method directly\n                interceptor    // index 1: use the Interceptor\n        });\n        Constructor constructor = Reflector.f(type).findConstructor(constructorArguments);\n        return (T) e.create(constructor.getParameterTypes(), constructorArguments);\n    }\n\n}\n","lineNo":114}
{"Refactored Sample":"package org.parboiled;\n\nimport org.jetbrains.annotations.NotNull;\n\nimport java.util.List;\nimport java.util.Set;\n\nclass SequenceMatcher extends AbstractMatcher implements FollowMatcher {\n\n    private final boolean enforced;\n\n    public SequenceMatcher(@NotNull Rule[] subRules, boolean enforced) {\n        super(subRules);\n        this.enforced = enforced;\n    }\n\n    public boolean match(@NotNull MatcherContext context, boolean enforced) {\n        List<Matcher> children = getChildren();\n        for (int i = 0; i < children.size(); i++) {\n            Matcher matcher = children.get(i);\n\n            // remember the current index in the context, so we can access it for building the current follower set\n            context.setTag(i);\n\n            boolean matched = context.runMatcher(matcher, enforced || (this.enforced && i > 0));\n            if (!matched) return false;\n        }\n        context.createNode();\n        return true;\n    }\n\n    public boolean collectFirstCharSet(@NotNull Set<Character> firstCharSet) {\n        return collectFirstCharSet(0, firstCharSet);\n    }\n\n    private boolean collectFirstCharSet(int startIndex, @NotNull Set<Character> firstCharSet) {\n        for (int i = startIndex; i < getChildren().size(); i++) {\n            if (getChildren().get(i).collectFirstCharSet(firstCharSet)) return true;\n        }\n        return false;\n    }\n\n    public boolean collectCurrentFollowerSet(MatcherContext context, @NotNull Set<Character> followerSet) {\n        int currentIndex = (Integer) context.getTag();\n        return collectFirstCharSet(currentIndex + 1, followerSet);\n    }\n\n}\n","Smelly Sample":"package org.parboiled;\n\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.utils.Preconditions;\n\nclass SequenceMatcher extends AbstractMatcher {\n\n    public SequenceMatcher(@NotNull Rule[] subRules) {\n        super(subRules);\n    }\n\n    public boolean match(@NotNull MatcherContext context, boolean enforced) {\n        for (Matcher matcher : getChildren()) {\n            boolean matched = context.runMatcher(matcher, enforced || matcher.isEnforced());\n            if (!matched) {\n                Preconditions.checkState(!enforced);\n                return false;\n            }\n        }\n        context.createNode();\n        return true;\n    }\n\n}\n","lineNo":18}
{"Refactored Sample":"package org.parboiled;\n\nimport com.google.common.base.Preconditions;\nimport org.apache.commons.lang.StringUtils;\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.support.InputLocation;\nimport org.parboiled.support.ParseError;\nimport org.parboiled.support.ParseTreeUtils;\nimport static org.parboiled.support.ParseTreeUtils.findNodeByPath;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nclass MatcherContextImpl implements MatcherContext {\n\n    private final MatcherContextImpl parent;\n    private final InputLocation startLocation;\n    private final Matcher matcher;\n    private final Actions actions;\n    private final List<ParseError> parseErrors;\n\n    private InputLocation currentLocation;\n    private Node node;\n    private List<Node> subNodes;\n    private String errorMessage;\n    private Object nodeValue;\n\n    public MatcherContextImpl(MatcherContextImpl parent, @NotNull InputLocation startLocation, @NotNull Matcher matcher,\n                              Actions actions, @NotNull List<ParseError> parseErrors) {\n\n        this.parent = parent;\n        this.startLocation = currentLocation = startLocation;\n        this.matcher = matcher;\n        this.actions = actions;\n        this.parseErrors = parseErrors;\n    }\n\n    public MatcherContextImpl getParent() {\n        return parent;\n    }\n\n    @NotNull\n    public InputLocation getStartLocation() {\n        return startLocation;\n    }\n\n    @NotNull\n    public Matcher getMatcher() {\n        return matcher;\n    }\n\n    @NotNull\n    public List<ParseError> getParseErrors() {\n        return Collections.unmodifiableList(parseErrors);\n    }\n\n    @NotNull\n    public InputLocation getCurrentLocation() {\n        return currentLocation;\n    }\n\n    public void setCurrentLocation(InputLocation currentLocation) {\n        this.currentLocation = currentLocation;\n    }\n\n    public Node getNode() {\n        return node;\n    }\n\n    public List<Node> getSubNodes() {\n        return subNodes;\n    }\n\n    public String getNodeText(Node node) {\n        return ParseTreeUtils.getNodeText(node, startLocation.inputBuffer);\n    }\n\n    public Character getNodeChar(Node node) {\n        return ParseTreeUtils.getNodeChar(node, startLocation.inputBuffer);\n    }\n\n    @NotNull\n    public String getPath() {\n        return parent == null ? \"\" : parent.getPath() + '/' + matcher.getLabel();\n    }\n\n    public Object getNodeValue() {\n        return nodeValue;\n    }\n\n    public void setNodeValue(Object value) {\n        this.nodeValue = value;\n    }\n\n    public boolean runMatcher(@NotNull Matcher matcher, boolean enforced) {\n        MatcherContextImpl innerContext = matcher instanceof ActionMatcher ? this :\n                new MatcherContextImpl(this, currentLocation, matcher, actions, parseErrors);\n        boolean matched = matcher.match(innerContext, enforced);\n        if (matched) {\n            currentLocation = innerContext.getCurrentLocation();\n        } else {\n            Preconditions.checkState(!enforced);\n        }\n        ParseError error = innerContext.getError(matcher);\n        if (error != null) parseErrors.add(error);\n        return matched;\n    }\n\n    private ParseError getError(Matcher matcher) {\n        return errorMessage == null ? null :\n                new ParseError(this, startLocation, currentLocation, matcher, node, errorMessage);\n    }\n\n    public void addUnexpectedInputError(@NotNull String expected) {\n        this.errorMessage = new StringBuilder()\n                .append(\"Invalid input, expected \")\n                .append(expected)\n                .append(ParseError.createMessageSuffix(startLocation, currentLocation))\n                .toString();\n    }\n\n    public void addActionError(@NotNull String errorMessage) {\n        this.errorMessage = errorMessage;\n    }\n\n    public void createNode() {\n        node = new NodeImpl(matcher.getLabel(), subNodes, startLocation, currentLocation, nodeValue);\n        if (parent != null) parent.addChildNode(node);\n    }\n\n    public void addChildNode(@NotNull Node node) {\n        if (subNodes == null) subNodes = new ArrayList<Node>();\n        subNodes.add(node);\n    }\n\n    public Node getNodeByPath(String path) {\n        if (subNodes != null && StringUtils.isNotEmpty(path)) {\n            for (Node node : subNodes) {\n                if (StringUtils.equals(node.getLabel(), path)) return node;\n                if (!path.startsWith(node.getLabel())) continue;\n                Node found = findNodeByPath(node, path.substring(path.indexOf('/') + 1));\n                if (found != null) return found;\n            }\n        }\n        return null;\n    }\n\n}\n","Smelly Sample":"package org.parboiled;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.Lists;\nimport org.apache.commons.lang.StringUtils;\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.support.InputBuffer;\nimport org.parboiled.support.InputLocation;\nimport org.parboiled.support.ParseError;\nimport org.parboiled.support.ParseTreeUtils;\nimport static org.parboiled.support.ParseTreeUtils.findNodeByPath;\n\nimport java.util.Collections;\nimport java.util.List;\n\nclass MatcherContextImpl implements MatcherContext {\n\n    private final InputBuffer inputBuffer;\n    private final List<ParseError> parseErrors = Lists.newArrayList();\n    private Node lastNodeCreated;\n\n    private String currentPath = \"\";\n    private Node currentNode;\n    private Matcher currentMatcher;\n    private List<Node> currentNodes;\n    private List<Node> currentParentNodes;\n    private InputLocation currentStart;\n    private String currentErrorMessage;\n    private Object currentValue;\n\n    public MatcherContextImpl(@NotNull InputBuffer inputBuffer) {\n        this.inputBuffer = inputBuffer;\n    }\n\n    @NotNull\n    public InputBuffer getInputBuffer() {\n        return inputBuffer;\n    }\n\n    @NotNull\n    public List<ParseError> getParseErrors() {\n        return Collections.unmodifiableList(parseErrors);\n    }\n\n    public Node getLastNodeCreated() {\n        return lastNodeCreated;\n    }\n\n    public boolean runMatcher(@NotNull Matcher matcher, boolean enforced) {\n        if (matcher instanceof ActionMatcher) {\n            // do not create a new frame for ActionMatcher, they want to operate on the level of the current Matcher\n            return doRunMatcher(matcher, enforced);\n        }\n\n        // save current \"frame\"\n        String previousPath = currentPath;\n        Node previousNode = currentNode;\n        Matcher previousMatcher = currentMatcher;\n        List<Node> previousParentNodes = currentParentNodes;\n        InputLocation previousStart = currentStart;\n        String previousErrorMessage = currentErrorMessage;\n        Object previousValue = currentValue;\n\n        // create new \"frame\"\n        currentPath += currentPath.length() > 0 ? '/' + matcher.getLabel() : matcher.getLabel();\n        currentNode = null;\n        currentMatcher = matcher;\n        currentParentNodes = currentNodes;\n        currentNodes = null;\n        currentStart = inputBuffer.getCurrentLocation();\n        currentErrorMessage = null;\n        currentValue = null;\n\n        boolean matched = doRunMatcher(matcher, enforced);\n\n        // discard current \"frame\" and restore to previous one\n        currentPath = previousPath;\n        currentNode = previousNode;\n        currentMatcher = previousMatcher;\n        currentNodes = currentParentNodes;\n        currentParentNodes = previousParentNodes;\n        currentStart = previousStart;\n        currentErrorMessage = previousErrorMessage;\n        currentValue = previousValue;\n        return matched;\n    }\n\n    private boolean doRunMatcher(Matcher matcher, boolean enforced) {\n        boolean matched = matcher.match(this, enforced);\n        if (!matched) {\n            Preconditions.checkState(!enforced);\n            inputBuffer.rewind(currentStart);\n        }\n        if (currentErrorMessage != null) {\n            parseErrors.add(new ParseError(this, currentStart, inputBuffer.getCurrentLocation(), currentMatcher,\n                    currentNode, currentErrorMessage));\n        }\n        return matched;\n    }\n\n    public void addUnexpectedInputError(@NotNull String expected) {\n        currentErrorMessage = new StringBuilder()\n                .append(\"Invalid input, expected \")\n                .append(expected)\n                .append(ParseError.createMessageSuffix(inputBuffer, currentStart,\n                        inputBuffer.getCurrentLocation()))\n                .toString();\n    }\n\n    public void addActionError(@NotNull String errorMessage) {\n        currentErrorMessage = errorMessage;\n    }\n\n    public void createNode() {\n        if (currentParentNodes == null) currentParentNodes = Lists.newArrayList();\n        currentNode = new NodeImpl(currentMatcher.getLabel(), currentNodes, currentStart,\n                inputBuffer.getCurrentLocation(), currentValue);\n        currentParentNodes.add(currentNode);\n        lastNodeCreated = currentNode;\n    }\n\n    public String getNodeText(Node node) {\n        return ParseTreeUtils.getNodeText(node, inputBuffer);\n    }\n\n    public Character getNodeChar(Node node) {\n        return ParseTreeUtils.getNodeChar(node, inputBuffer);\n    }\n\n    @NotNull\n    public List<Node> getCurrentNodes() {\n        return currentNodes != null ? ImmutableList.copyOf(currentNodes) : ImmutableList.<Node>of();\n    }\n\n    @NotNull\n    public List<Node> getCurrentParentNodes() {\n        return currentParentNodes != null ? ImmutableList.copyOf(currentParentNodes) : ImmutableList.<Node>of();\n    }\n\n    @NotNull\n    public String getCurrentPath() {\n        return currentPath;\n    }\n\n    public Node getNodeByPath(String path) {\n        if (currentNodes != null && StringUtils.isNotEmpty(path)) {\n            for (Node node : currentNodes) {\n                if (StringUtils.equals(node.getLabel(), path)) return node;\n                if (!path.startsWith(node.getLabel())) continue;\n                Node found = findNodeByPath(node, path.substring(path.indexOf('/') + 1));\n                if (found != null) return found;\n            }\n        }\n        return null;\n    }\n\n    public Object getNodeValue() {\n        return currentValue;\n    }\n\n    public void setNodeValue(Object value) {\n        this.currentValue = value;\n    }\n\n}\n","lineNo":97}
{"Refactored Sample":"package org.parboiled;\n\nimport com.google.common.base.Preconditions;\nimport org.apache.commons.lang.StringUtils;\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.support.InputLocation;\nimport org.parboiled.support.ParseError;\nimport org.parboiled.support.ParseTreeUtils;\nimport static org.parboiled.support.ParseTreeUtils.findNodeByPath;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nclass MatcherContextImpl implements MatcherContext {\n\n    private final MatcherContextImpl parent;\n    private final InputLocation startLocation;\n    private final Matcher matcher;\n    private final Actions actions;\n    private final List<ParseError> parseErrors;\n\n    private InputLocation currentLocation;\n    private Node node;\n    private List<Node> subNodes;\n    private String errorMessage;\n    private Object nodeValue;\n\n    public MatcherContextImpl(MatcherContextImpl parent, @NotNull InputLocation startLocation, @NotNull Matcher matcher,\n                              Actions actions, @NotNull List<ParseError> parseErrors) {\n\n        this.parent = parent;\n        this.startLocation = currentLocation = startLocation;\n        this.matcher = matcher;\n        this.actions = actions;\n        this.parseErrors = parseErrors;\n    }\n\n    public MatcherContextImpl getParent() {\n        return parent;\n    }\n\n    @NotNull\n    public InputLocation getStartLocation() {\n        return startLocation;\n    }\n\n    @NotNull\n    public Matcher getMatcher() {\n        return matcher;\n    }\n\n    @NotNull\n    public List<ParseError> getParseErrors() {\n        return Collections.unmodifiableList(parseErrors);\n    }\n\n    @NotNull\n    public InputLocation getCurrentLocation() {\n        return currentLocation;\n    }\n\n    public void setCurrentLocation(InputLocation currentLocation) {\n        this.currentLocation = currentLocation;\n    }\n\n    public Node getNode() {\n        return node;\n    }\n\n    public List<Node> getSubNodes() {\n        return subNodes;\n    }\n\n    public String getNodeText(Node node) {\n        return ParseTreeUtils.getNodeText(node, startLocation.inputBuffer);\n    }\n\n    public Character getNodeChar(Node node) {\n        return ParseTreeUtils.getNodeChar(node, startLocation.inputBuffer);\n    }\n\n    @NotNull\n    public String getPath() {\n        return parent == null ? \"\" : parent.getPath() + '/' + matcher.getLabel();\n    }\n\n    public Object getNodeValue() {\n        return nodeValue;\n    }\n\n    public void setNodeValue(Object value) {\n        this.nodeValue = value;\n    }\n\n    public boolean runMatcher(@NotNull Matcher matcher, boolean enforced) {\n        MatcherContextImpl innerContext = matcher instanceof ActionMatcher ? this :\n                new MatcherContextImpl(this, currentLocation, matcher, actions, parseErrors);\n        boolean matched = matcher.match(innerContext, enforced);\n        if (matched) {\n            currentLocation = innerContext.getCurrentLocation();\n        } else {\n            Preconditions.checkState(!enforced);\n        }\n        ParseError error = innerContext.getError(matcher);\n        if (error != null) parseErrors.add(error);\n        return matched;\n    }\n\n    private ParseError getError(Matcher matcher) {\n        return errorMessage == null ? null :\n                new ParseError(this, startLocation, currentLocation, matcher, node, errorMessage);\n    }\n\n    public void addUnexpectedInputError(@NotNull String expected) {\n        this.errorMessage = new StringBuilder()\n                .append(\"Invalid input, expected \")\n                .append(expected)\n                .append(ParseError.createMessageSuffix(startLocation, currentLocation))\n                .toString();\n    }\n\n    public void addActionError(@NotNull String errorMessage) {\n        this.errorMessage = errorMessage;\n    }\n\n    public void createNode() {\n        node = new NodeImpl(matcher.getLabel(), subNodes, startLocation, currentLocation, nodeValue);\n        if (parent != null) parent.addChildNode(node);\n    }\n\n    public void addChildNode(@NotNull Node node) {\n        if (subNodes == null) subNodes = new ArrayList<Node>();\n        subNodes.add(node);\n    }\n\n    public Node getNodeByPath(String path) {\n        if (subNodes != null && StringUtils.isNotEmpty(path)) {\n            for (Node node : subNodes) {\n                if (StringUtils.equals(node.getLabel(), path)) return node;\n                if (!path.startsWith(node.getLabel())) continue;\n                Node found = findNodeByPath(node, path.substring(path.indexOf('/') + 1));\n                if (found != null) return found;\n            }\n        }\n        return null;\n    }\n\n}\n","Smelly Sample":"package org.parboiled;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.Lists;\nimport org.apache.commons.lang.StringUtils;\nimport org.jetbrains.annotations.NotNull;\nimport org.parboiled.support.InputBuffer;\nimport org.parboiled.support.InputLocation;\nimport org.parboiled.support.ParseError;\nimport org.parboiled.support.ParseTreeUtils;\nimport static org.parboiled.support.ParseTreeUtils.findNodeByPath;\n\nimport java.util.Collections;\nimport java.util.List;\n\nclass MatcherContextImpl implements MatcherContext {\n\n    private final InputBuffer inputBuffer;\n    private final List<ParseError> parseErrors = Lists.newArrayList();\n    private Node lastNodeCreated;\n\n    private String currentPath = \"\";\n    private Node currentNode;\n    private Matcher currentMatcher;\n    private List<Node> currentNodes;\n    private List<Node> currentParentNodes;\n    private InputLocation currentStart;\n    private String currentErrorMessage;\n    private Object currentValue;\n\n    public MatcherContextImpl(@NotNull InputBuffer inputBuffer) {\n        this.inputBuffer = inputBuffer;\n    }\n\n    @NotNull\n    public InputBuffer getInputBuffer() {\n        return inputBuffer;\n    }\n\n    @NotNull\n    public List<ParseError> getParseErrors() {\n        return Collections.unmodifiableList(parseErrors);\n    }\n\n    public Node getLastNodeCreated() {\n        return lastNodeCreated;\n    }\n\n    public boolean runMatcher(@NotNull Matcher matcher, boolean enforced) {\n        if (matcher instanceof ActionMatcher) {\n            // do not create a new frame for ActionMatcher, they want to operate on the level of the current Matcher\n            return doRunMatcher(matcher, enforced);\n        }\n\n        // save current \"frame\"\n        String previousPath = currentPath;\n        Node previousNode = currentNode;\n        Matcher previousMatcher = currentMatcher;\n        List<Node> previousParentNodes = currentParentNodes;\n        InputLocation previousStart = currentStart;\n        String previousErrorMessage = currentErrorMessage;\n        Object previousValue = currentValue;\n\n        // create new \"frame\"\n        currentPath += currentPath.length() > 0 ? '/' + matcher.getLabel() : matcher.getLabel();\n        currentNode = null;\n        currentMatcher = matcher;\n        currentParentNodes = currentNodes;\n        currentNodes = null;\n        currentStart = inputBuffer.getCurrentLocation();\n        currentErrorMessage = null;\n        currentValue = null;\n\n        boolean matched = doRunMatcher(matcher, enforced);\n\n        // discard current \"frame\" and restore to previous one\n        currentPath = previousPath;\n        currentNode = previousNode;\n        currentMatcher = previousMatcher;\n        currentNodes = currentParentNodes;\n        currentParentNodes = previousParentNodes;\n        currentStart = previousStart;\n        currentErrorMessage = previousErrorMessage;\n        currentValue = previousValue;\n        return matched;\n    }\n\n    private boolean doRunMatcher(Matcher matcher, boolean enforced) {\n        boolean matched = matcher.match(this, enforced);\n        if (!matched) {\n            Preconditions.checkState(!enforced);\n            inputBuffer.rewind(currentStart);\n        }\n        if (currentErrorMessage != null) {\n            parseErrors.add(new ParseError(this, currentStart, inputBuffer.getCurrentLocation(), currentMatcher,\n                    currentNode, currentErrorMessage));\n        }\n        return matched;\n    }\n\n    public void addUnexpectedInputError(@NotNull String expected) {\n        currentErrorMessage = new StringBuilder()\n                .append(\"Invalid input, expected \")\n                .append(expected)\n                .append(ParseError.createMessageSuffix(inputBuffer, currentStart,\n                        inputBuffer.getCurrentLocation()))\n                .toString();\n    }\n\n    public void addActionError(@NotNull String errorMessage) {\n        currentErrorMessage = errorMessage;\n    }\n\n    public void createNode() {\n        if (currentParentNodes == null) currentParentNodes = Lists.newArrayList();\n        currentNode = new NodeImpl(currentMatcher.getLabel(), currentNodes, currentStart,\n                inputBuffer.getCurrentLocation(), currentValue);\n        currentParentNodes.add(currentNode);\n        lastNodeCreated = currentNode;\n    }\n\n    public String getNodeText(Node node) {\n        return ParseTreeUtils.getNodeText(node, inputBuffer);\n    }\n\n    public Character getNodeChar(Node node) {\n        return ParseTreeUtils.getNodeChar(node, inputBuffer);\n    }\n\n    @NotNull\n    public List<Node> getCurrentNodes() {\n        return currentNodes != null ? ImmutableList.copyOf(currentNodes) : ImmutableList.<Node>of();\n    }\n\n    @NotNull\n    public List<Node> getCurrentParentNodes() {\n        return currentParentNodes != null ? ImmutableList.copyOf(currentParentNodes) : ImmutableList.<Node>of();\n    }\n\n    @NotNull\n    public String getCurrentPath() {\n        return currentPath;\n    }\n\n    public Node getNodeByPath(String path) {\n        if (currentNodes != null && StringUtils.isNotEmpty(path)) {\n            for (Node node : currentNodes) {\n                if (StringUtils.equals(node.getLabel(), path)) return node;\n                if (!path.startsWith(node.getLabel())) continue;\n                Node found = findNodeByPath(node, path.substring(path.indexOf('/') + 1));\n                if (found != null) return found;\n            }\n        }\n        return null;\n    }\n\n    public Object getNodeValue() {\n        return currentValue;\n    }\n\n    public void setNodeValue(Object value) {\n        this.currentValue = value;\n    }\n\n}\n","lineNo":97}
