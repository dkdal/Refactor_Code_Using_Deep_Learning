{"Refactored Sample":"/*\n * Title:        DefaultFactory\n * Description:\n *\n * This software is published under the terms of the OpenSymphony Software\n * License version 1.1, of which a copy has been included with this\n * distribution in the LICENSE.txt file.\n */\n\npackage com.opensymphony.module.sitemesh.factory;\n\nimport com.opensymphony.module.sitemesh.Config;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.Text;\nimport org.xml.sax.SAXException;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\n\n/**\n * DefaultFactory, reads configuration from the <code>sitemesh.configfile<\/code> init param,\n * or <code>/WEB-INF/sitemesh.xml<\/code> if not specified, or uses the\n * default configuration if <code>sitemesh.xml<\/code> does not exist.\n *\n * <p>To use the <code>sitemesh.configfile<\/code> parameter, add the following to your web.xml:\n * <pre>\n * &lt;context-param&gt;\n *      &lt;param-name&gt;sitemesh.configfile&lt;/param-name&gt;\n *      &lt;param-value&gt;/WEB-INF/etc/sitemesh.xml&lt;/param-value&gt;\n *  &lt;/context-param&gt;\n * <\/pre>\n * <\/p>\n * \n * @author <a href=\"mailto:joe@truemesh.com\">Joe Walnes<\/a>\n * @author <a href=\"mailto:pathos@pandora.be\">Mathias Bogaert<\/a>\n * @version $Revision: 1.8 $\n */\npublic class DefaultFactory extends BaseFactory {\n    String configFileName;\n    private static final String DEFAULT_CONFIG_FILENAME = \"/WEB-INF/sitemesh.xml\";\n\n    File configFile;\n    long configLastModified;\n    private long configLastCheck = 0L;\n    public static long configCheckMillis = 3000L;\n    Map configProps = new HashMap();\n\n    String excludesFileName;\n    File excludesFile;\n\n    public DefaultFactory(Config config) {\n        super(config);\n\n        configFileName = config.getServletContext().getInitParameter(\"sitemesh.configfile\");\n        if (configFileName == null) {\n            configFileName = DEFAULT_CONFIG_FILENAME;\n        }\n\n        // configFilePath is null if loaded from war file\n        String initParamConfigFile = config.getConfigFile();\n        if (initParamConfigFile != null) {\n          configFileName = initParamConfigFile;\n        }\n\n        if (!configFileName.startsWith(\"classpath:\")) {\n            String configFilePath = config.getServletContext().getRealPath(configFileName);\n\n            if (configFilePath != null) { // disable config auto reloading for .war files\n                configFile = new File(configFilePath);\n            }\n        }\n        loadConfig();\n    }\n\n    /** Load configuration from file. */\n    private synchronized void loadConfig() {\n        try {\n            // Load and parse the sitemesh.xml file\n            Element root = loadSitemeshXML();\n\n            NodeList sections = root.getChildNodes();\n            // Loop through child elements of root node\n            for (int i = 0; i < sections.getLength(); i++) {\n                if (sections.item(i) instanceof Element) {\n                    Element curr = (Element)sections.item(i);\n                    NodeList children = curr.getChildNodes();\n\n                    if (\"config-refresh\".equalsIgnoreCase(curr.getTagName())) {\n                        String seconds = curr.getAttribute(\"seconds\");\n                        configCheckMillis = Long.parseLong(seconds) * 1000L;\n                    } else if (\"property\".equalsIgnoreCase(curr.getTagName())) {\n                        String name = curr.getAttribute(\"name\");\n                        String value = curr.getAttribute(\"value\");\n                        if (!\"\".equals(name) && !\"\".equals(value)) {\n                            configProps.put(\"${\" + name + \"}\", value);\n                        }\n                    }\n                    else if (\"page-parsers\".equalsIgnoreCase(curr.getTagName())) {\n                        // handle <page-parsers>\n                        loadPageParsers(children);\n                    }\n                    else if (\"decorator-mappers\".equalsIgnoreCase(curr.getTagName())) {\n                        // handle <decorator-mappers>\n                        loadDecoratorMappers(children);\n                    }\n                    else if (\"excludes\".equalsIgnoreCase(curr.getTagName())) {\n                        // handle <excludes>\n                        String fileName = replaceProperties(curr.getAttribute(\"file\"));\n                        if (!\"\".equals(fileName)) {\n                            excludesFileName = fileName;\n                            loadExcludes();\n                        }\n                    }\n                }\n            }\n        }\n        catch (ParserConfigurationException e) {\n            throw new FactoryException(\"Could not get XML parser\", e);\n        }\n        catch (IOException e) {\n            throw new FactoryException(\"Could not read config file : \" + configFileName, e);\n        }\n        catch (SAXException e) {\n            throw new FactoryException(\"Could not parse config file : \" + configFileName, e);\n        }\n    }\n\n    private Element loadSitemeshXML()\n            throws ParserConfigurationException, IOException, SAXException\n    {\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        DocumentBuilder builder = factory.newDocumentBuilder();\n\n        InputStream is = null;\n\n        if (configFile == null) {\n            if (!configFileName.startsWith(\"classpath:\")) {\n                is = config.getServletContext().getResourceAsStream(configFileName);\n            }\n        } else if (configFile.exists() && configFile.canRead()) {\n            is = configFile.toURI().toURL().openStream();\n        }\n\n        String classPathResource = configFileName.startsWith(\"classpath:\")? configFileName.replaceFirst(\"classpath:\",\"\") :\n                \"com/opensymphony/module/sitemesh/factory/sitemesh-default.xml\";\n        if (is == null){ // load the default sitemesh configuration\n            is = getClass().getClassLoader().getResourceAsStream(classPathResource);\n        }\n\n        if (is == null){ // load the default sitemesh configuration using another classloader\n            is = Thread.currentThread().getContextClassLoader().getResourceAsStream(classPathResource);\n        }\n\n        if (is == null){\n            throw new IllegalStateException(\"Cannot load default configuration from jar\");\n        }\n\n        if (configFile != null) configLastModified = configFile.lastModified();\n\n        Document doc = builder.parse(is);\n        Element root = doc.getDocumentElement();\n        // Verify root element\n        if (!\"sitemesh\".equalsIgnoreCase(root.getTagName())) {\n            throw new FactoryException(\"Root element of sitemesh configuration file not <sitemesh>\", null);\n        }\n        return root;\n    }\n\n    private void loadExcludes()\n            throws ParserConfigurationException, IOException, SAXException\n    {\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        DocumentBuilder builder = factory.newDocumentBuilder();\n\n        InputStream is = null;\n\n        if (excludesFile == null) {\n            is = config.getServletContext().getResourceAsStream(excludesFileName);\n        }\n        else if (excludesFile.exists() && excludesFile.canRead()) {\n            is = excludesFile.toURI().toURL().openStream();\n        }\n\n        if (is == null){\n            throw new IllegalStateException(\"Cannot load excludes configuration file \\\"\" + excludesFileName + \"\\\" as specified in \\\"sitemesh.xml\\\" or \\\"sitemesh-default.xml\\\"\");\n        }\n\n        Document document = builder.parse(is);\n        Element root = document.getDocumentElement();\n        NodeList sections = root.getChildNodes();\n\n        // Loop through child elements of root node looking for the <excludes> block\n        for (int i = 0; i < sections.getLength(); i++) {\n            if (sections.item(i) instanceof Element) {\n                Element curr = (Element)sections.item(i);\n                if (\"excludes\".equalsIgnoreCase(curr.getTagName())) {\n                    loadExcludeUrls(curr.getChildNodes());\n                }\n            }\n        }\n    }\n\n    /** Loop through children of 'page-parsers' element and add all 'parser' mappings. */\n    private void loadPageParsers(NodeList nodes) {\n        clearParserMappings();\n        for (int i = 0; i < nodes.getLength(); i++) {\n            if (nodes.item(i) instanceof Element) {\n                Element curr = (Element)nodes.item(i);\n\n                if (\"parser\".equalsIgnoreCase(curr.getTagName())) {\n                    String className = curr.getAttribute(\"class\");\n                    String contentType = curr.getAttribute(\"content-type\");\n                    mapParser(contentType, className);\n                }\n            }\n        }\n    }\n\n    private void loadDecoratorMappers(NodeList nodes) {\n        clearDecoratorMappers();\n        Properties emptyProps = new Properties();\n\n        pushDecoratorMapper(\"com.opensymphony.module.sitemesh.mapper.NullDecoratorMapper\", emptyProps);\n\n        // note, this works from the bottom node up.\n        for (int i = nodes.getLength() - 1; i > 0; i--) {\n            if (nodes.item(i) instanceof Element) {\n                Element curr = (Element)nodes.item(i);\n                if (\"mapper\".equalsIgnoreCase(curr.getTagName())) {\n                    String className = curr.getAttribute(\"class\");\n                    Properties props = new Properties();\n                    // build properties from <param> tags.\n                    NodeList children = curr.getChildNodes();\n                    for (int j = 0; j < children.getLength(); j++) {\n                        if (children.item(j) instanceof Element) {\n                            Element currC = (Element)children.item(j);\n                            if (\"param\".equalsIgnoreCase(currC.getTagName())) {\n                                String value = currC.getAttribute(\"value\");\n                                props.put(currC.getAttribute(\"name\"), replaceProperties(value));\n                            }\n                        }\n                    }\n                    // add mapper\n                    pushDecoratorMapper(className, props);\n                }\n            }\n        }\n\n        pushDecoratorMapper(\"com.opensymphony.module.sitemesh.mapper.InlineDecoratorMapper\", emptyProps);\n    }\n\n    /**\n     * Reads in all the url patterns to exclude from decoration.\n     */\n    private void loadExcludeUrls(NodeList nodes) {\n        clearExcludeUrls();\n        for (int i = 0; i < nodes.getLength(); i++) {\n            if (nodes.item(i) instanceof Element) {\n                Element p = (Element) nodes.item(i);\n                if (\"pattern\".equalsIgnoreCase(p.getTagName()) || \"url-pattern\".equalsIgnoreCase(p.getTagName())) {\n                    Text patternText = (Text) p.getFirstChild();\n                    if (patternText != null) {\n                        String pattern = patternText.getData().trim();\n                        if (pattern != null) {\n                            addExcludeUrl(pattern);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /** Check if configuration file has been modified, and if so reload it. */\n    public void refresh() {\n        long time = System.currentTimeMillis();\n        if (time - configLastCheck < configCheckMillis)\n            return;\n        configLastCheck = time;\n\n        if (configFile != null && configLastModified != configFile.lastModified()) loadConfig();\n    }\n\n    /**\n     * Replaces any properties that appear in the supplied string\n     * with their actual values\n     *\n     * @param str the string to replace the properties in\n     * @return the same string but with any properties expanded out to their\n     * actual values\n     */\n    private String replaceProperties(String str) {\n        Set props = configProps.entrySet();\n        for (Iterator it = props.iterator(); it.hasNext();)\n        {\n            Map.Entry entry = (Map.Entry) it.next();\n            String key = (String) entry.getKey();\n            int idx;\n            while ((idx = str.indexOf(key)) >= 0) {\n                StringBuilder buf = new StringBuilder(100);\n                buf.append(str.substring(0, idx));\n                buf.append(entry.getValue());\n                buf.append(str.substring(idx + key.length()));\n                str = buf.toString();\n            }\n        }\n        return str;\n    }\n}\n","Smelly Sample":"/*\n * Title:        DefaultFactory\n * Description:\n *\n * This software is published under the terms of the OpenSymphony Software\n * License version 1.1, of which a copy has been included with this\n * distribution in the LICENSE.txt file.\n */\n\npackage com.opensymphony.module.sitemesh.factory;\n\nimport com.opensymphony.module.sitemesh.Config;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.Text;\nimport org.xml.sax.SAXException;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\n\n/**\n * DefaultFactory, reads configuration from the <code>sitemesh.configfile<\/code> init param,\n * or <code>/WEB-INF/sitemesh.xml<\/code> if not specified, or uses the\n * default configuration if <code>sitemesh.xml<\/code> does not exist.\n *\n * <p>To use the <code>sitemesh.configfile<\/code> parameter, add the following to your web.xml:\n * <pre>\n * &lt;context-param&gt;\n *      &lt;param-name&gt;sitemesh.configfile&lt;/param-name&gt;\n *      &lt;param-value&gt;/WEB-INF/etc/sitemesh.xml&lt;/param-value&gt;\n *  &lt;/context-param&gt;\n * <\/pre>\n * <\/p>\n * \n * @author <a href=\"mailto:joe@truemesh.com\">Joe Walnes<\/a>\n * @author <a href=\"mailto:pathos@pandora.be\">Mathias Bogaert<\/a>\n * @version $Revision: 1.8 $\n */\npublic class DefaultFactory extends BaseFactory {\n    String configFileName;\n    private static final String DEFAULT_CONFIG_FILENAME = \"/WEB-INF/sitemesh.xml\";\n\n    File configFile;\n    long configLastModified;\n    private long configLastCheck = 0L;\n    public static long configCheckMillis = 3000L;\n    Map configProps = new HashMap();\n\n    String excludesFileName;\n    File excludesFile;\n\n    public DefaultFactory(Config config) {\n        super(config);\n\n        configFileName = config.getServletContext().getInitParameter(\"sitemesh.configfile\");\n        if (configFileName == null) {\n            configFileName = DEFAULT_CONFIG_FILENAME;\n        }\n\n        // configFilePath is null if loaded from war file\n        String initParamConfigFile = config.getConfigFile();\n        if(initParamConfigFile != null) {\n          configFileName = initParamConfigFile;\n        }\n        \n        String configFilePath = config.getServletContext().getRealPath(configFileName);\n\n        if (configFilePath != null) { // disable config auto reloading for .war files\n            configFile = new File(configFilePath);\n        }\n\n        loadConfig();\n    }\n\n    /** Load configuration from file. */\n    private synchronized void loadConfig() {\n        try {\n            // Load and parse the sitemesh.xml file\n            Element root = loadSitemeshXML();\n\n            NodeList sections = root.getChildNodes();\n            // Loop through child elements of root node\n            for (int i = 0; i < sections.getLength(); i++) {\n                if (sections.item(i) instanceof Element) {\n                    Element curr = (Element)sections.item(i);\n                    NodeList children = curr.getChildNodes();\n\n                    if (\"config-refresh\".equalsIgnoreCase(curr.getTagName())) {\n                        String seconds = curr.getAttribute(\"seconds\");\n                        configCheckMillis = Long.parseLong(seconds) * 1000L;\n                    } else if (\"property\".equalsIgnoreCase(curr.getTagName())) {\n                        String name = curr.getAttribute(\"name\");\n                        String value = curr.getAttribute(\"value\");\n                        if (!\"\".equals(name) && !\"\".equals(value)) {\n                            configProps.put(\"${\" + name + \"}\", value);\n                        }\n                    }\n                    else if (\"page-parsers\".equalsIgnoreCase(curr.getTagName())) {\n                        // handle <page-parsers>\n                        loadPageParsers(children);\n                    }\n                    else if (\"decorator-mappers\".equalsIgnoreCase(curr.getTagName())) {\n                        // handle <decorator-mappers>\n                        loadDecoratorMappers(children);\n                    }\n                    else if (\"excludes\".equalsIgnoreCase(curr.getTagName())) {\n                        // handle <excludes>\n                        String fileName = replaceProperties(curr.getAttribute(\"file\"));\n                        if (!\"\".equals(fileName)) {\n                            excludesFileName = fileName;\n                            loadExcludes();\n                        }\n                    }\n                }\n            }\n        }\n        catch (ParserConfigurationException e) {\n            throw new FactoryException(\"Could not get XML parser\", e);\n        }\n        catch (IOException e) {\n            throw new FactoryException(\"Could not read config file : \" + configFileName, e);\n        }\n        catch (SAXException e) {\n            throw new FactoryException(\"Could not parse config file : \" + configFileName, e);\n        }\n    }\n\n    private Element loadSitemeshXML()\n            throws ParserConfigurationException, IOException, SAXException\n    {\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        DocumentBuilder builder = factory.newDocumentBuilder();\n\n        InputStream is = null;\n\n        if (configFile == null) {\n            is = config.getServletContext().getResourceAsStream(configFileName);\n        }\n        else if (configFile.exists() && configFile.canRead()) {\n            is = configFile.toURI().toURL().openStream();\n        }\n\n        if (is == null){ // load the default sitemesh configuration\n            is = getClass().getClassLoader().getResourceAsStream(\"com/opensymphony/module/sitemesh/factory/sitemesh-default.xml\");\n        }\n\n        if (is == null){ // load the default sitemesh configuration using another classloader\n            is = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"com/opensymphony/module/sitemesh/factory/sitemesh-default.xml\");\n        }\n\n        if (is == null){\n            throw new IllegalStateException(\"Cannot load default configuration from jar\");\n        }\n\n        if (configFile != null) configLastModified = configFile.lastModified();\n\n        Document doc = builder.parse(is);\n        Element root = doc.getDocumentElement();\n        // Verify root element\n        if (!\"sitemesh\".equalsIgnoreCase(root.getTagName())) {\n            throw new FactoryException(\"Root element of sitemesh configuration file not <sitemesh>\", null);\n        }\n        return root;\n    }\n\n    private void loadExcludes()\n            throws ParserConfigurationException, IOException, SAXException\n    {\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        DocumentBuilder builder = factory.newDocumentBuilder();\n\n        InputStream is = null;\n\n        if (excludesFile == null) {\n            is = config.getServletContext().getResourceAsStream(excludesFileName);\n        }\n        else if (excludesFile.exists() && excludesFile.canRead()) {\n            is = excludesFile.toURI().toURL().openStream();\n        }\n\n        if (is == null){\n            throw new IllegalStateException(\"Cannot load excludes configuration file \\\"\" + excludesFileName + \"\\\" as specified in \\\"sitemesh.xml\\\" or \\\"sitemesh-default.xml\\\"\");\n        }\n\n        Document document = builder.parse(is);\n        Element root = document.getDocumentElement();\n        NodeList sections = root.getChildNodes();\n\n        // Loop through child elements of root node looking for the <excludes> block\n        for (int i = 0; i < sections.getLength(); i++) {\n            if (sections.item(i) instanceof Element) {\n                Element curr = (Element)sections.item(i);\n                if (\"excludes\".equalsIgnoreCase(curr.getTagName())) {\n                    loadExcludeUrls(curr.getChildNodes());\n                }\n            }\n        }\n    }\n\n    /** Loop through children of 'page-parsers' element and add all 'parser' mappings. */\n    private void loadPageParsers(NodeList nodes) {\n        clearParserMappings();\n        for (int i = 0; i < nodes.getLength(); i++) {\n            if (nodes.item(i) instanceof Element) {\n                Element curr = (Element)nodes.item(i);\n\n                if (\"parser\".equalsIgnoreCase(curr.getTagName())) {\n                    String className = curr.getAttribute(\"class\");\n                    String contentType = curr.getAttribute(\"content-type\");\n                    mapParser(contentType, className);\n                }\n            }\n        }\n    }\n\n    private void loadDecoratorMappers(NodeList nodes) {\n        clearDecoratorMappers();\n        Properties emptyProps = new Properties();\n\n        pushDecoratorMapper(\"com.opensymphony.module.sitemesh.mapper.NullDecoratorMapper\", emptyProps);\n\n        // note, this works from the bottom node up.\n        for (int i = nodes.getLength() - 1; i > 0; i--) {\n            if (nodes.item(i) instanceof Element) {\n                Element curr = (Element)nodes.item(i);\n                if (\"mapper\".equalsIgnoreCase(curr.getTagName())) {\n                    String className = curr.getAttribute(\"class\");\n                    Properties props = new Properties();\n                    // build properties from <param> tags.\n                    NodeList children = curr.getChildNodes();\n                    for (int j = 0; j < children.getLength(); j++) {\n                        if (children.item(j) instanceof Element) {\n                            Element currC = (Element)children.item(j);\n                            if (\"param\".equalsIgnoreCase(currC.getTagName())) {\n                                String value = currC.getAttribute(\"value\");\n                                props.put(currC.getAttribute(\"name\"), replaceProperties(value));\n                            }\n                        }\n                    }\n                    // add mapper\n                    pushDecoratorMapper(className, props);\n                }\n            }\n        }\n\n        pushDecoratorMapper(\"com.opensymphony.module.sitemesh.mapper.InlineDecoratorMapper\", emptyProps);\n    }\n\n    /**\n     * Reads in all the url patterns to exclude from decoration.\n     */\n    private void loadExcludeUrls(NodeList nodes) {\n        clearExcludeUrls();\n        for (int i = 0; i < nodes.getLength(); i++) {\n            if (nodes.item(i) instanceof Element) {\n                Element p = (Element) nodes.item(i);\n                if (\"pattern\".equalsIgnoreCase(p.getTagName()) || \"url-pattern\".equalsIgnoreCase(p.getTagName())) {\n                    Text patternText = (Text) p.getFirstChild();\n                    if (patternText != null) {\n                        String pattern = patternText.getData().trim();\n                        if (pattern != null) {\n                            addExcludeUrl(pattern);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /** Check if configuration file has been modified, and if so reload it. */\n    public void refresh() {\n        long time = System.currentTimeMillis();\n        if (time - configLastCheck < configCheckMillis)\n            return;\n        configLastCheck = time;\n\n        if (configFile != null && configLastModified != configFile.lastModified()) loadConfig();\n    }\n\n    /**\n     * Replaces any properties that appear in the supplied string\n     * with their actual values\n     *\n     * @param str the string to replace the properties in\n     * @return the same string but with any properties expanded out to their\n     * actual values\n     */\n    private String replaceProperties(String str) {\n        Set props = configProps.entrySet();\n        for (Iterator it = props.iterator(); it.hasNext();)\n        {\n            Map.Entry entry = (Map.Entry) it.next();\n            String key = (String) entry.getKey();\n            int idx;\n            while ((idx = str.indexOf(key)) >= 0) {\n                StringBuilder buf = new StringBuilder(100);\n                buf.append(str.substring(0, idx));\n                buf.append(entry.getValue());\n                buf.append(str.substring(idx + key.length()));\n                str = buf.toString();\n            }\n        }\n        return str;\n    }\n}\n","lineNo":151}
{"Refactored Sample":"package com.opensymphony.sitemesh.webapp;\n\nimport com.opensymphony.module.sitemesh.Config;\nimport com.opensymphony.module.sitemesh.Factory;\nimport com.opensymphony.module.sitemesh.scalability.ScalabilitySupport;\nimport com.opensymphony.module.sitemesh.scalability.ScalabilitySupportConfiguration;\nimport com.opensymphony.module.sitemesh.scalability.outputlength.MaxOutputLengthExceeded;\nimport com.opensymphony.module.sitemesh.scalability.secondarystorage.SecondaryStorage;\nimport com.opensymphony.sitemesh.Content;\nimport com.opensymphony.sitemesh.Decorator;\nimport com.opensymphony.sitemesh.DecoratorSelector;\nimport com.opensymphony.sitemesh.ContentProcessor;\nimport com.opensymphony.sitemesh.compatability.DecoratorMapper2DecoratorSelector;\nimport com.opensymphony.sitemesh.compatability.PageParser2ContentProcessor;\n\nimport javax.servlet.*;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n/**\n * Core Filter for integrating SiteMesh into a Java web application.\n *\n * @author Joe Walnes\n * @author Scott Farquhar\n * @since SiteMesh 3\n */\npublic class SiteMeshFilter implements Filter {\n\n    private FilterConfig filterConfig;\n    private ContainerTweaks containerTweaks;\n    private ScalabilitySupportConfiguration scalabilitySupportConfiguration;\n    private static final String ALREADY_APPLIED_KEY = \"com.opensymphony.sitemesh.APPLIED_ONCE\";\n\n    public void init(FilterConfig filterConfig) {\n        this.filterConfig = filterConfig;\n        containerTweaks = new ContainerTweaks();\n        scalabilitySupportConfiguration = new ScalabilitySupportConfiguration(filterConfig);\n    }\n\n    public void destroy() {\n        filterConfig = null;\n        containerTweaks = null;\n    }\n\n    /**\n     * Main method of the Filter.\n     * <p>Checks if the Filter has been applied this request. If not, parses the page\n     * and applies {@link com.opensymphony.module.sitemesh.Decorator} (if found).\n     */\n    public void doFilter(ServletRequest rq, ServletResponse rs, FilterChain chain)\n            throws IOException, ServletException {\n\n        HttpServletRequest request = (HttpServletRequest) rq;\n        HttpServletResponse response = (HttpServletResponse) rs;\n        ServletContext servletContext = filterConfig.getServletContext();\n\n        SiteMeshWebAppContext webAppContext = new SiteMeshWebAppContext(request, response, servletContext);\n\n        ContentProcessor contentProcessor = initContentProcessor(webAppContext);\n        DecoratorSelector decoratorSelector = initDecoratorSelector(webAppContext);\n\n        if (filterAlreadyAppliedForRequest(request)) {\n            // Prior to Servlet 2.4 spec, it was unspecified whether the filter should be called again upon an include().\n            chain.doFilter(request, response);\n            return;\n        }\n\n        if (!contentProcessor.handles(webAppContext)) {\n            // Optimization: If the content doesn't need to be processed, bypass SiteMesh.\n            chain.doFilter(request, response);\n            return;\n        }\n\n        if (containerTweaks.shouldAutoCreateSession()) {\n            // Some containers (such as Tomcat 4) will not allow sessions to be created in the decorator.\n            // (i.e after the response has been committed).\n            request.getSession(true);\n        }\n\n        ScalabilitySupport scalabilitySupport = scalabilitySupportConfiguration.getScalabilitySupport(request);\n        try {\n\n            Content content = obtainContent(contentProcessor, webAppContext,scalabilitySupport,request, response, chain);\n\n            if (content == null) {\n                return;\n            }\n\n            Decorator decorator = decoratorSelector.selectDecorator(content, webAppContext);\n            decorator.render(content, webAppContext);\n\n        } catch (MaxOutputLengthExceeded exceeded) {\n            //\n            // they have sent a response that is bigger than is what acceptable so\n            // we send back an HTTP code to indicate this\n            handleMaximumExceeded(scalabilitySupport, request, response, servletContext, exceeded);\n\n        } catch (IllegalStateException e) {\n            // Some containers (such as WebLogic) throw an IllegalStateException when an error page is served.\n            // It may be ok to ignore this. However, for safety it is propegated if possible.\n            if (!containerTweaks.shouldIgnoreIllegalStateExceptionOnErrorPage()) {\n                throw e;\n            }\n        } catch (RuntimeException e) {\n            if (containerTweaks.shouldLogUnhandledExceptions()) {\n                // Some containers (such as Tomcat 4) swallow RuntimeExceptions in filters.\n                servletContext.log(\"Unhandled exception occurred whilst decorating page\", e);\n            }\n            throw e;\n        } catch (ServletException e) {\n            request.setAttribute(ALREADY_APPLIED_KEY, null);\n            if (e.getCause() instanceof MaxOutputLengthExceeded) {\n                //\n                // they have sent a response that is bigger than is what acceptable so\n                // we send back an HTTP code to indicate this\n                handleMaximumExceeded(scalabilitySupport, request, response, servletContext, (MaxOutputLengthExceeded) e.getCause());\n            } else {\n                throw e;\n            }\n        } finally {\n            cleanupSecondaryStorage(scalabilitySupport.getSecondaryStorage(), servletContext);\n        }\n\n    }\n\n    private void handleMaximumExceeded(ScalabilitySupport scalabilitySupport, HttpServletRequest request, HttpServletResponse response, ServletContext servletContext, MaxOutputLengthExceeded exceeded) throws IOException\n    {\n        request.setAttribute(\"sitemesh.maximumOutputExceededLength\", exceeded.getMaxOutputLength());\n        if (scalabilitySupport.isMaxOutputLengthExceededThrown())\n        {\n            throw exceeded;\n        }\n        else\n        {\n            servletContext.log(\"Exceeded the maximum SiteMesh page output size\", exceeded);\n            response.sendError(exceeded.getMaximumOutputExceededHttpCode(), exceeded.getMessage());\n        }\n    }\n\n    private void cleanupSecondaryStorage(SecondaryStorage secondaryStorage, ServletContext servletContext)\n    {\n        // we want to cleanup without exception.  The request may already be in exception and we don't want to make\n        // make it any worse.  Also we have told the implementer NOT to propagate an exception and hence we are going to\n        // hold them to that contract\n        try\n        {\n            secondaryStorage.cleanUp();\n        }\n        catch (Exception e)\n        {\n            servletContext.log(\"Unable to clean up secondary storage properly.  Ignoring exception \", e);\n        }\n    }\n\n    protected ContentProcessor initContentProcessor(SiteMeshWebAppContext webAppContext) {\n        // TODO: Remove heavy coupling on horrible SM2 Factory\n        Factory factory = Factory.getInstance(new Config(filterConfig));\n        factory.refresh();\n        return new PageParser2ContentProcessor(factory);\n    }\n\n    protected DecoratorSelector initDecoratorSelector(SiteMeshWebAppContext webAppContext) {\n        // TODO: Remove heavy coupling on horrible SM2 Factory\n        Factory factory = Factory.getInstance(new Config(filterConfig));\n        factory.refresh();\n        return new DecoratorMapper2DecoratorSelector(factory.getDecoratorMapper());\n    }\n\n    /**\n     * Continue in filter-chain, writing all content to buffer and parsing\n     * into returned {@link com.opensymphony.module.sitemesh.Page} object. If\n     * {@link com.opensymphony.module.sitemesh.Page} is not parseable, null is returned.\n     */\n    private Content obtainContent(ContentProcessor contentProcessor, SiteMeshWebAppContext webAppContext, ScalabilitySupport scalabilitySupport,\n                                  HttpServletRequest request, HttpServletResponse response, FilterChain chain)\n            throws IOException, ServletException {\n\n        ContentBufferingResponse contentBufferingResponse = new ContentBufferingResponse(response, contentProcessor, webAppContext, scalabilitySupport);\n        chain.doFilter(request, contentBufferingResponse);\n        webAppContext.setUsingStream(contentBufferingResponse.isUsingStream());\n        return contentBufferingResponse.getContent();\n    }\n\n    private boolean filterAlreadyAppliedForRequest(HttpServletRequest request) {\n        if (request.getAttribute(ALREADY_APPLIED_KEY) == Boolean.TRUE) {\n            return true;\n        } else {\n            request.setAttribute(ALREADY_APPLIED_KEY, Boolean.TRUE);\n            return false;\n        }\n    }\n\n}\n","Smelly Sample":"package com.opensymphony.sitemesh.webapp;\n\nimport com.opensymphony.module.sitemesh.Config;\nimport com.opensymphony.module.sitemesh.Factory;\nimport com.opensymphony.module.sitemesh.scalability.ScalabilitySupport;\nimport com.opensymphony.module.sitemesh.scalability.ScalabilitySupportConfiguration;\nimport com.opensymphony.module.sitemesh.scalability.outputlength.MaxOutputLengthExceeded;\nimport com.opensymphony.sitemesh.Content;\nimport com.opensymphony.sitemesh.Decorator;\nimport com.opensymphony.sitemesh.DecoratorSelector;\nimport com.opensymphony.sitemesh.ContentProcessor;\nimport com.opensymphony.sitemesh.compatability.DecoratorMapper2DecoratorSelector;\nimport com.opensymphony.sitemesh.compatability.PageParser2ContentProcessor;\n\nimport javax.servlet.*;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n/**\n * Core Filter for integrating SiteMesh into a Java web application.\n *\n * @author Joe Walnes\n * @author Scott Farquhar\n * @since SiteMesh 3\n */\npublic class SiteMeshFilter implements Filter {\n\n    private FilterConfig filterConfig;\n    private ContainerTweaks containerTweaks;\n    private ScalabilitySupportConfiguration scalabilitySupportConfiguration;\n    private static final String ALREADY_APPLIED_KEY = \"com.opensymphony.sitemesh.APPLIED_ONCE\";\n\n    public void init(FilterConfig filterConfig) {\n        this.filterConfig = filterConfig;\n        containerTweaks = new ContainerTweaks();\n        scalabilitySupportConfiguration = new ScalabilitySupportConfiguration(filterConfig);\n    }\n\n    public void destroy() {\n        filterConfig = null;\n        containerTweaks = null;\n    }\n\n    /**\n     * Main method of the Filter.\n     * <p>Checks if the Filter has been applied this request. If not, parses the page\n     * and applies {@link com.opensymphony.module.sitemesh.Decorator} (if found).\n     */\n    public void doFilter(ServletRequest rq, ServletResponse rs, FilterChain chain)\n            throws IOException, ServletException {\n\n        HttpServletRequest request = (HttpServletRequest) rq;\n        HttpServletResponse response = (HttpServletResponse) rs;\n        ServletContext servletContext = filterConfig.getServletContext();\n\n        SiteMeshWebAppContext webAppContext = new SiteMeshWebAppContext(request, response, servletContext);\n\n        ContentProcessor contentProcessor = initContentProcessor(webAppContext);\n        DecoratorSelector decoratorSelector = initDecoratorSelector(webAppContext);\n\n        if (filterAlreadyAppliedForRequest(request)) {\n            // Prior to Servlet 2.4 spec, it was unspecified whether the filter should be called again upon an include().\n            chain.doFilter(request, response);\n            return;\n        }\n\n        if (!contentProcessor.handles(webAppContext)) {\n            // Optimization: If the content doesn't need to be processed, bypass SiteMesh.\n            chain.doFilter(request, response);\n            return;\n        }\n\n        if (containerTweaks.shouldAutoCreateSession()) {\n            // Some containers (such as Tomcat 4) will not allow sessions to be created in the decorator.\n            // (i.e after the response has been committed).\n            request.getSession(true);\n        }\n\n        try {\n\n            Content content = obtainContent(contentProcessor, webAppContext,\n                    scalabilitySupportConfiguration.getScalabilitySupport(request),\n                    request, response, chain);\n\n            if (content == null) {\n                return;\n            }\n\n            Decorator decorator = decoratorSelector.selectDecorator(content, webAppContext);\n            decorator.render(content, webAppContext);\n\n        } catch (MaxOutputLengthExceeded exceeded) {\n            //\n            // they have sent a response that is bigger than is what acceptable so\n            // we send back an HTTP code to indicate this\n            handleMaximumExceeded(request, response, servletContext, exceeded);\n\n        } catch (IllegalStateException e) {\n            // Some containers (such as WebLogic) throw an IllegalStateException when an error page is served.\n            // It may be ok to ignore this. However, for safety it is propegated if possible.\n            if (!containerTweaks.shouldIgnoreIllegalStateExceptionOnErrorPage()) {\n                throw e;\n            }\n        } catch (RuntimeException e) {\n            if (containerTweaks.shouldLogUnhandledExceptions()) {\n                // Some containers (such as Tomcat 4) swallow RuntimeExceptions in filters.\n                servletContext.log(\"Unhandled exception occurred whilst decorating page\", e);\n            }\n            throw e;\n        } catch (ServletException e) {\n            request.setAttribute(ALREADY_APPLIED_KEY, null);\n            if (e.getCause() instanceof MaxOutputLengthExceeded) {\n                //\n                // they have sent a response that is bigger than is what acceptable so\n                // we send back an HTTP code to indicate this\n                handleMaximumExceeded(request, response, servletContext, (MaxOutputLengthExceeded) e.getCause());\n            } else {\n                throw e;\n            }\n        }\n\n    }\n\n    private void handleMaximumExceeded(HttpServletRequest request, HttpServletResponse response, ServletContext servletContext, MaxOutputLengthExceeded exceeded) throws IOException\n    {\n        servletContext.log(\"Exceeded the maximum SiteMesh page output size\", exceeded);\n        request.setAttribute(\"sitemesh.maximumOutputExceededLength\",exceeded.getMaxOutputLength());\n        response.sendError(exceeded.getMaximumOutputExceededHttpCode(),exceeded.getMessage());\n    }\n\n    protected ContentProcessor initContentProcessor(SiteMeshWebAppContext webAppContext) {\n        // TODO: Remove heavy coupling on horrible SM2 Factory\n        Factory factory = Factory.getInstance(new Config(filterConfig));\n        factory.refresh();\n        return new PageParser2ContentProcessor(factory);\n    }\n\n    protected DecoratorSelector initDecoratorSelector(SiteMeshWebAppContext webAppContext) {\n        // TODO: Remove heavy coupling on horrible SM2 Factory\n        Factory factory = Factory.getInstance(new Config(filterConfig));\n        factory.refresh();\n        return new DecoratorMapper2DecoratorSelector(factory.getDecoratorMapper());\n    }\n\n    /**\n     * Continue in filter-chain, writing all content to buffer and parsing\n     * into returned {@link com.opensymphony.module.sitemesh.Page} object. If\n     * {@link com.opensymphony.module.sitemesh.Page} is not parseable, null is returned.\n     */\n    private Content obtainContent(ContentProcessor contentProcessor, SiteMeshWebAppContext webAppContext, ScalabilitySupport scalabilitySupport,\n                                  HttpServletRequest request, HttpServletResponse response, FilterChain chain)\n            throws IOException, ServletException {\n\n        ContentBufferingResponse contentBufferingResponse = new ContentBufferingResponse(response, contentProcessor, webAppContext, scalabilitySupport);\n        chain.doFilter(request, contentBufferingResponse);\n        // TODO: check if another servlet or filter put a page object in the request\n        //            Content result = request.getAttribute(PAGE);\n        //            if (result == null) {\n        //                // parse the page\n        //                result = pageResponse.getPage();\n        //            }\n        webAppContext.setUsingStream(contentBufferingResponse.isUsingStream());\n        return contentBufferingResponse.getContent();\n    }\n\n    private boolean filterAlreadyAppliedForRequest(HttpServletRequest request) {\n        if (request.getAttribute(ALREADY_APPLIED_KEY) == Boolean.TRUE) {\n            return true;\n        } else {\n            request.setAttribute(ALREADY_APPLIED_KEY, Boolean.TRUE);\n            return false;\n        }\n    }\n\n}\n","lineNo":81}
{"Refactored Sample":"package com.opensymphony.module.sitemesh.parser;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.Writer;\n\npublic class SuperFastPage extends AbstractPage {\n\n    private final int bodyStart;\n    private final int bodyLength;\n    private final int pageLength;\n\n\n    public SuperFastPage(char[] pageData, int pageLength, int bodyStart, int bodyLength) {\n        this.pageLength = pageLength;\n        this.bodyStart = bodyStart;\n        this.bodyLength = bodyLength;\n        this.pageData = pageData;\n    }\n\n    @Override\n    public void writePage(Writer out) throws IOException {\n        out.write(pageData, 0, pageLength);\n    }\n\n    @Override\n    public int getContentLength() {\n        // We encode it but not into a new buffer\n        CountingOutputStream counter = new CountingOutputStream();\n        try\n        {\n            OutputStreamWriter writer = new OutputStreamWriter(counter);\n            writePage(writer);\n            // We mush flush, because the writer will buffer\n            writer.flush();\n        } catch (IOException ioe) {\n            // Ignore, it's not possible with our OutputStream\n        }\n        return counter.getCount();\n    }\n\n    @Override\n    public void writeBody(Writer out) throws IOException {\n        out.write(pageData, bodyStart, bodyLength);\n    }\n\n    protected static class CountingOutputStream extends OutputStream {\n        private int count = 0;\n\n        @Override\n        public void write(int i) throws IOException {\n            count++;\n        }\n\n        public int getCount() {\n            return count;\n        }\n    }\n}\n","Smelly Sample":"package com.opensymphony.module.sitemesh.parser;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.Writer;\n\npublic class SuperFastPage extends AbstractPage {\n\n    private final int bodyStart;\n    private final int bodyLength;\n    private final int pageLength;\n\n\n    public SuperFastPage(char[] pageData, int pageLength, int bodyStart, int bodyLength) {\n        this.pageLength = pageLength;\n        this.bodyStart = bodyStart;\n        this.bodyLength = bodyLength;\n        this.pageData = pageData;\n    }\n\n    @Override\n    public void writePage(Writer out) throws IOException {\n        out.write(pageData, 0, pageLength);\n    }\n\n    @Override\n    public int getContentLength() {\n        // We encode it but not into a new buffer\n        CountingOutputStream counter = new CountingOutputStream();\n        try {\n            writePage(new OutputStreamWriter(counter));\n        } catch (IOException ioe) {\n            // Ignore, it's not possible with our OutputStream\n        }\n        return counter.getCount();\n    }\n\n    @Override\n    public void writeBody(Writer out) throws IOException {\n        out.write(pageData, bodyStart, bodyLength);\n    }\n\n    protected static class CountingOutputStream extends OutputStream {\n        private int count = 0;\n\n        @Override\n        public void write(int i) throws IOException {\n            count++;\n        }\n\n        public int getCount() {\n            return count;\n        }\n    }\n}\n","lineNo":33}
{"Refactored Sample":"package com.opensymphony.module.sitemesh.parser;\n\nimport java.io.CharArrayWriter;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport com.opensymphony.module.sitemesh.Page;\nimport com.opensymphony.module.sitemesh.PageParser;\n\n/**\n * Super fast page parser.  It uses a single buffer, and never copies anything, apart from the title, meta attributes\n * and body properties. This page parser makes several assumptions:\n * <p/>\n * <ul> <li>If the first tag is an html tag, it's an HTML page, otherwise, it's a fragment, and no head/title/etc\n * parsing will be done.<\/li> <\/ul>\n *\n * @since v2.4\n */\npublic class SuperFastSimplePageParser implements PageParser\n{\n    public Page parse(final char[] data) throws IOException\n    {\n        return parse(data, data.length);\n    }\n\n    public Page parse(final char[] data, final int length) throws IOException\n    {\n        int position = 0;\n        while (position < data.length)\n        {\n            if (data[position++] == '<')\n            {\n                if (position < data.length && data[position] == '!')\n                {\n                    // Ignore doctype\n                    continue;\n                }\n                if (compareLowerCase(data, length, position, \"html\"))\n                {\n                    // It's an HTML page, handle HTML pages\n                    return parseHtmlPage(data, length, position);\n                }\n                else\n                {\n                    // The whole thing is the body.\n                    return new SuperFastHtmlPage(data, length, 0, length, null);\n                }\n            }\n        }\n        // If we're here, we mustn't have found a tag\n        return new SuperFastHtmlPage(data, length, 0, length, null);\n    }\n\n    private Page parseHtmlPage(final char[] data, final int length, int position)\n    {\n        int bodyStart = -1;\n        int bodyLength = -1;\n        int headStart = -1;\n        int headLength = -1;\n        // Find head end and start, and body start\n        Map<String, String> bodyProperties = null;\n        while (position < length)\n        {\n            if (data[position++] == '<')\n            {\n                if (compareLowerCase(data, length, position, \"head\"))\n                {\n                    position = findEndOf(data, length, position + 4, \">\");\n                    headStart = position;\n                    // Find end of head\n                    position = findStartOf(data, length, position, \"<\/head>\");\n                    headLength = position - headStart;\n                    position += 7;\n                }\n                else if (compareLowerCase(data, length, position, \"body\"))\n                {\n                    HashSimpleMap map = new HashSimpleMap();\n                    bodyStart = parseProperties(data, length, position + 4, map);\n                    bodyProperties = map.getMap();\n                    break;\n                }\n            }\n        }\n\n        if (bodyStart < 0)\n        {\n            // No body found\n            bodyStart = length;\n            bodyLength = 0;\n        }\n        else\n        {\n            for (int i = length - 8; i > bodyStart; i--)\n            {\n                if (compareLowerCase(data, length, i, \"<\/body>\"))\n                {\n                    bodyLength = i - bodyStart;\n                    break;\n                }\n            }\n            if (bodyLength == -1)\n            {\n                bodyLength = length - bodyStart;\n            }\n        }\n\n        if (headLength > 0)\n        {\n            int idx = headStart;\n            int headEnd = headStart + headLength;\n            String title = null;\n\n            // Extract meta attributes out of head\n            Map<String, String> metaAttributes = new HashMap<String, String>();\n            while (idx < headEnd)\n            {\n                if (data[idx++] == '<')\n                {\n                    if (compareLowerCase(data, headEnd, idx, \"meta\"))\n                    {\n                        MetaTagSimpleMap map = new MetaTagSimpleMap();\n                        idx = parseProperties(data, headEnd, idx + 4, map);\n                        if (map.getName() != null && map.getContent() != null)\n                        {\n                            metaAttributes.put(map.getName(), map.getContent());\n                        }\n                    }\n                }\n            }\n\n            // We need a new head buffer because we have to remove the title and content tags from it\n            Map<String, String> pageProperties = new HashMap<String, String>();\n            CharArrayWriter head = new CharArrayWriter();\n            for (int i = headStart; i < headEnd; i++)\n            {\n                char c = data[i];\n                if (c == '<')\n                {\n                    if (compareLowerCase(data, headEnd, i + 1, \"title\"))\n                    {\n                        int titleStart = findEndOf(data, headEnd, i + 6, \">\");\n                        int titleEnd = findStartOf(data, headEnd, titleStart, \"<\");\n                        title = new String(data, titleStart, titleEnd - titleStart);\n                        i = titleEnd + \"<\/title>\".length() - 1;\n                    }\n                    else if (compareLowerCase(data, headEnd, i + 1, \"content\"))\n                    {\n                        ContentTagSimpleMap map = new ContentTagSimpleMap();\n                        int contentStart = parseProperties(data, headEnd, i + 8, map);\n                        int contentEnd = findStartOf(data, headEnd, contentStart, \"<\/content>\");\n                        pageProperties.put(map.getTag(), new String(data, contentStart, contentEnd - contentStart));\n                        i = contentEnd + \"<\/content>\".length() - 1;\n                    }\n                    else\n                    {\n                        head.append(c);\n                    }\n                }\n                else\n                {\n                    head.append(c);\n                }\n            }\n\n            return new SuperFastHtmlPage(data, length, bodyStart, bodyLength, bodyProperties, head.toCharArray(), title, metaAttributes, pageProperties);\n        }\n        else\n        {\n            return new SuperFastHtmlPage(data, length, bodyStart, bodyLength, bodyProperties);\n        }\n    }\n\n    private static boolean compareLowerCase(final char[] data, final int dataEnd, int position, String token)\n    {\n        int l = position + token.length();\n        if (l > dataEnd)\n        {\n            return false;\n        }\n        for (int i = 0; i < token.length(); i++)\n        {\n            // | 32 converts from ASCII uppercase to ASCII lowercase\n            char potential = data[position + i];\n            char needed = token.charAt(i);\n            if ((Character.isLetter(potential) && (potential | 32) != needed) || potential != needed)\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static int findEndOf(final char[] data, final int dataEnd, int position, String token)\n    {\n        for (int i = position; i < dataEnd - token.length(); i++)\n        {\n            if (compareLowerCase(data, dataEnd, i, token))\n            {\n                return i + token.length();\n            }\n        }\n        return dataEnd;\n    }\n\n    private static int findStartOf(final char[] data, final int dataEnd, int position, String token)\n    {\n        for (int i = position; i < dataEnd - token.length(); i++)\n        {\n            if (compareLowerCase(data, dataEnd, i, token))\n            {\n                return i;\n            }\n        }\n        return dataEnd;\n    }\n\n    /**\n     * Parse the properties of the current tag\n     *\n     * @param data the data\n     * @param dataEnd the end index of the data\n     * @param position our position in the data, this should be the first character after the tag name\n     * @param map to the map to parse the properties into\n     *\n     * @return The position of the first character after the tag\n     */\n    private static int parseProperties(char[] data, int dataEnd, int position, SimpleMap map)\n    {\n        int idx = position;\n\n        while (idx < dataEnd)\n        {\n            // Skip forward to the next non-whitespace character\n            while (idx < dataEnd && Character.isWhitespace(data[idx]))\n            {\n                idx++;\n            }\n\n            // Make sure its not the end of the data or the end of the tag\n            if (idx == dataEnd || data[idx] == '>' || data[idx] == '/')\n            {\n                break;\n            }\n\n            int startAttr = idx;\n\n            // Find the next equals\n            while (idx < dataEnd && !Character.isWhitespace(data[idx]) && data[idx] != '=' && data[idx] != '>')\n            {\n                idx++;\n            }\n\n            if (idx == dataEnd || data[idx] != '=')\n            {\n                continue;\n            }\n\n            String attrName = new String(data, startAttr, idx - startAttr);\n\n            idx++;\n            if (idx == dataEnd)\n            {\n                break;\n            }\n\n            int startValue = idx;\n            int endValue;\n            if (data[idx] == '\"')\n            {\n                idx++;\n                startValue = idx;\n                while (idx < dataEnd && data[idx] != '\"')\n                {\n                    idx++;\n                }\n                if (idx == dataEnd)\n                {\n                    break;\n                }\n                endValue = idx;\n                idx++;\n            }\n            else if (data[idx] == '\\'')\n            {\n                idx++;\n                startValue = idx;\n                while (idx < dataEnd && data[idx] != '\\'')\n                {\n                    idx++;\n                }\n                if (idx == dataEnd)\n                {\n                    break;\n                }\n                endValue = idx;\n                idx++;\n            }\n            else\n            {\n                while (idx < dataEnd && !Character.isWhitespace(data[idx]) && data[idx] != '/' && data[idx] != '>')\n                {\n                    idx++;\n                }\n                endValue = idx;\n            }\n            String attrValue = new String(data, startValue, endValue - startValue);\n            map.put(attrName, attrValue);\n        }\n        // Find the end of the tag\n        while (idx < dataEnd && data[idx] != '>')\n        {\n            idx++;\n        }\n        if (idx == dataEnd)\n        {\n            return idx;\n        }\n        else\n        {\n            // Return the first character after the end of the tag\n            return idx + 1;\n        }\n    }\n\n    public static interface SimpleMap\n    {\n        public void put(String key, String value);\n    }\n\n    public static class MetaTagSimpleMap implements SimpleMap\n    {\n        private String name;\n        private String content;\n\n        public void put(String key, String value)\n        {\n            if (key.equals(\"name\"))\n            {\n                name = value;\n            }\n            else if (key.equals(\"content\"))\n            {\n                content = value;\n            }\n        }\n\n        public String getName()\n        {\n            return name;\n        }\n\n        public String getContent()\n        {\n            return content;\n        }\n    }\n\n    public static class ContentTagSimpleMap implements SimpleMap\n    {\n        private String tag;\n\n        public void put(String key, String value)\n        {\n            if (key.equals(\"tag\"))\n            {\n                tag = value;\n            }\n        }\n\n        public String getTag()\n        {\n            return tag;\n        }\n    }\n\n    public static class HashSimpleMap implements SimpleMap\n    {\n        private final Map<String, String> map = new HashMap<String, String>();\n\n        public void put(String key, String value)\n        {\n            map.put(key, value);\n        }\n\n        public Map<String, String> getMap()\n        {\n            return map;\n        }\n    }\n}\n","Smelly Sample":"package com.opensymphony.module.sitemesh.parser;\n\nimport java.io.CharArrayWriter;\nimport java.io.IOException;\nimport java.nio.CharBuffer;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport com.opensymphony.module.sitemesh.Page;\nimport com.opensymphony.module.sitemesh.PageParser;\n\n/**\n * Super fast page parser.  It uses a single buffer, and never copies anything, apart from the title, meta attributes\n * and body properties. This page parser makes several assumptions:\n * <p/>\n * <ul> <li>If the first tag is an html tag, it's an HTML page, otherwise, it's a fragment, and no head/title/etc\n * parsing will be done.<\/li>\n * <\/ul>\n *\n * @since v2.4\n */\npublic class SuperFastSimplePageParser implements PageParser\n{\n    private static final Pattern META_PATTERN = Pattern.compile(\n            \"<meta\\\\s+([\\\\w-]+)=[\\\"']([^\\\"']*)[\\\"']\\\\s+([\\\\w-]+)=[\\\"']([^\\\"']*)[\\\"']\\\\s*/?>\", Pattern.CASE_INSENSITIVE);\n\n    public Page parse(final char[] data) throws IOException\n    {\n        return parse(data, data.length);\n    }\n    \n    public Page parse(final char[] data, final int length) throws IOException\n    {\n        int position = 0;\n        while (position < data.length)\n        {\n            if (data[position++] == '<')\n            {\n                if (position < data.length && data[position] == '!')\n                {\n                    // Ignore doctype\n                    continue;\n                }\n                if (compareLowerCase(data, length, position, \"html\"))\n                {\n                    // It's an HTML page, handle HTML pages\n                    return parseHtmlPage(data, length, position);\n                }\n                else\n                {\n                    // The whole thing is the body.\n                    return new SuperFastPage(data, length, 0, length);\n                }\n            }\n        }\n        // If we're here, we mustn't have found a tag\n        return new SuperFastPage(data, length, 0, length);\n    }\n\n    private Page parseHtmlPage(final char[] data, final int length, int position)\n    {\n        int bodyStart = -1;\n        int bodyLength = -1;\n        int headStart = -1;\n        int headLength = -1;\n        // Find head end and start, and body start\n        while (position < length)\n        {\n            if (data[position++] == '<')\n            {\n                if (compareLowerCase(data, length, position, \"head\"))\n                {\n                    position = findEndOf(data, length, position + 4, \">\");\n                    headStart = position;\n                    // Find end of head\n                    position = findStartOf(data, length, position, \"<\/head>\");\n                    headLength = position - headStart;\n                    position += 7;\n                }\n                else if (compareLowerCase(data, length, position, \"body\"))\n                {\n                    bodyStart = findEndOf(data, length, position + 4, \">\");\n                    break;\n                }\n            }\n        }\n\n        if (bodyStart < 0)\n        {\n            // No body found\n            bodyStart = length;\n            bodyLength = 0;\n        }\n        else\n        {\n            for (int i = length - 8; i > bodyStart; i--)\n            {\n                if (compareLowerCase(data, length, i, \"<\/body>\"))\n                {\n                    bodyLength = i - bodyStart;\n                    break;\n                }\n            }\n            if (bodyLength == -1)\n            {\n                bodyLength = length - bodyStart;\n            }\n        }\n\n        if (headLength > 0)\n        {\n            String title = null;\n            // Extract title and meta properties.  This should be a small amount of data, so regexs are fine\n            CharBuffer buffer = CharBuffer.wrap(data, headStart, headLength);\n            Matcher matcher = META_PATTERN.matcher(buffer);\n            Map<String, String> metaAttributes = new HashMap<String, String>();\n            while (matcher.find())\n            {\n                if (matcher.group(1).equals(\"content\"))\n                {\n                    metaAttributes.put(matcher.group(4), matcher.group(2));\n                }\n                else\n                {\n                    metaAttributes.put(matcher.group(2), matcher.group(4));                    \n                }\n            }\n\n            // We need a new head buffer because we have to remove the title from it\n            CharArrayWriter head = new CharArrayWriter();\n            for (int i = headStart; i < headStart + headLength; i++)\n            {\n                char c = data[i];\n                if (c == '<')\n                {\n                    if (compareLowerCase(data, headLength, i + 1, \"title\"))\n                    {\n                        int titleStart = findEndOf(data, headLength, i + 6, \">\");\n                        int titleEnd = findStartOf(data, headLength, titleStart, \"<\");\n                        title = new String(data, titleStart, titleEnd - titleStart);\n                        i = titleEnd + \"<\/title>\".length() - 1;\n                    }\n                    else\n                    {\n                        head.append(c);\n                    }\n                }\n                else\n                {\n                    head.append(c);\n                }\n            }\n\n            return new SuperFastHtmlPage(data, length, bodyStart, bodyLength, head.toCharArray(), title, metaAttributes);\n        }\n        else\n        {\n            return new SuperFastPage(data, length, bodyStart, bodyLength);\n        }\n    }\n\n    private static boolean compareLowerCase(final char[] data, final int length, int position, String token)\n    {\n        int l = position + token.length();\n        if (l > length)\n        {\n            return false;\n        }\n        for (int i = 0; i < token.length(); i++)\n        {\n            // | 32 converts from ASCII uppercase to ASCII lowercase\n            char potential = data[position + i];\n            char needed = token.charAt(i);\n            if ((Character.isLetter(potential) && (potential | 32) != needed) || potential != needed)\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static int findEndOf(final char[] data, final int length, int position, String token)\n    {\n        for (int i = position; i < length - token.length(); i++)\n        {\n            if (compareLowerCase(data, length, i, token))\n            {\n                return i + token.length();\n            }\n        }\n        return length;\n    }\n\n    private static int findStartOf(final char[] data, final int length, int position, String token)\n    {\n        for (int i = position; i < length - token.length(); i++)\n        {\n            if (compareLowerCase(data, length, i, token))\n            {\n                return i;\n            }\n        }\n        return length;\n    }\n}\n","lineNo":111}
{"Refactored Sample":"package com.opensymphony.sitemesh.compatability;\n\nimport com.opensymphony.module.sitemesh.DecoratorMapper;\nimport com.opensymphony.sitemesh.Content;\nimport com.opensymphony.sitemesh.Decorator;\nimport com.opensymphony.sitemesh.DecoratorSelector;\nimport com.opensymphony.sitemesh.SiteMeshContext;\nimport com.opensymphony.sitemesh.webapp.SiteMeshWebAppContext;\nimport com.opensymphony.sitemesh.webapp.decorator.NoDecorator;\n\nimport javax.servlet.http.HttpServletRequest;\n\n/**\n * Adapts a SiteMesh 2 {@link DecoratorMapper} to a SiteMesh 2 {@link DecoratorSelector}.\n *\n * @author Joe Walnes\n * @since SiteMesh 3\n */\npublic class DecoratorMapper2DecoratorSelector implements DecoratorSelector {\n\n    private final DecoratorMapper decoratorMapper;\n\n    public DecoratorMapper2DecoratorSelector(DecoratorMapper decoratorMapper) {\n        this.decoratorMapper = decoratorMapper;\n    }\n\n    public Decorator selectDecorator(Content content, SiteMeshContext context) {\n        SiteMeshWebAppContext webAppContext = (SiteMeshWebAppContext) context;\n        HttpServletRequest request = webAppContext.getRequest();\n        com.opensymphony.module.sitemesh.Decorator decorator =\n                decoratorMapper.getDecorator(request, new Content2HTMLPage(content, request));\n        if (decorator == null || decorator.getPage() == null) {\n            return new NoDecorator();\n        } else {\n            return new OldDecorator2NewDecorator(decorator);\n        }\n    }\n}\n","Smelly Sample":"package com.opensymphony.sitemesh.compatability;\n\nimport com.opensymphony.module.sitemesh.DecoratorMapper;\nimport com.opensymphony.sitemesh.Content;\nimport com.opensymphony.sitemesh.Decorator;\nimport com.opensymphony.sitemesh.DecoratorSelector;\nimport com.opensymphony.sitemesh.SiteMeshContext;\nimport com.opensymphony.sitemesh.webapp.SiteMeshWebAppContext;\nimport com.opensymphony.sitemesh.webapp.decorator.NoDecorator;\n\n/**\n * Adapts a SiteMesh 2 {@link DecoratorMapper} to a SiteMesh 2 {@link DecoratorSelector}.\n *\n * @author Joe Walnes\n * @since SiteMesh 3\n */\npublic class DecoratorMapper2DecoratorSelector implements DecoratorSelector {\n\n    private final DecoratorMapper decoratorMapper;\n\n    public DecoratorMapper2DecoratorSelector(DecoratorMapper decoratorMapper) {\n        this.decoratorMapper = decoratorMapper;\n    }\n\n    public Decorator selectDecorator(Content content, SiteMeshContext context) {\n        SiteMeshWebAppContext webAppContext = (SiteMeshWebAppContext) context;\n        com.opensymphony.module.sitemesh.Decorator decorator =\n                decoratorMapper.getDecorator(webAppContext.getRequest(), new Content2HTMLPage(content));\n        if (decorator == null || decorator.getPage() == null) {\n            return new NoDecorator();\n        } else {\n            return new OldDecorator2NewDecorator(decorator);\n        }\n    }\n}\n","lineNo":29}
{"Refactored Sample":"package com.opensymphony.module.sitemesh.html;\n\nimport java.util.Arrays;\n\nimport com.opensymphony.module.sitemesh.html.util.CharArray;\nimport com.opensymphony.module.sitemesh.html.tokenizer.Parser;\n\n\n/**\n * A CustomTag provides a mechanism to manipulate the contents of a Tag. The standard Tag implementations\n * are immutable, however CustomTag allows a copy to be taken of an immutable Tag that can then be manipulated.\n *\n * @see Tag\n *\n * @author Joe Walnes\n */\npublic class CustomTag implements Tag {\n\n    private String[] attributes = new String[10]; // name1, value1, name2, value2...\n    private int attributeCount = 0;\n    private String name;\n    private int type;\n\n\n    /**\n     * Type of tag: <br/>\n     * &lt;blah&gt; - Tag.OPEN<br/>\n     * &lt;/blah&gt; - Tag.CLOSE<br/>\n     * &lt;blah/&gt; - Tag.EMPTY<br/>\n     */\n    public CustomTag(String name, int type) {\n        setName(name);\n        setType(type);\n    }\n\n    /**\n     * Create a CustomTag based on an existing Tag - this takes a copy of the Tag.\n     */\n    public CustomTag(Tag tag) {\n        setName(tag.getName());\n        setType(tag.getType());\n        if(tag instanceof Parser.ReusableToken) {\n          Parser.ReusableToken orig = (Parser.ReusableToken)tag;\n          attributeCount = orig.attributeCount;\n          attributes = new String[attributeCount];\n          System.arraycopy(orig.attributes, 0, attributes, 0, attributeCount);\n        } else if(tag instanceof CustomTag) {\n          CustomTag orig = (CustomTag)tag;\n          attributeCount = orig.attributeCount;\n          attributes = new String[attributeCount];\n          System.arraycopy(orig.attributes, 0, attributes, 0, attributeCount);\n        } else {\n          int c = tag.getAttributeCount();\n          attributes = new String[c * 2];\n          for (int i = 0; i < c; i++) {\n              attributes[attributeCount++] = tag.getAttributeName(i);\n              attributes[attributeCount++] = tag.getAttributeValue(i);\n          }\n        }\n    }\n\n    public String getContents() {\n        CharArray c = new CharArray(64);\n        writeTo(c);\n        return c.toString();\n    }\n\n    public void writeTo(CharArray out) {\n        if (type == Tag.CLOSE) {\n            out.append(\"<\/\");\n        } else {\n            out.append('<');\n        }\n\n        out.append(name);\n        final int len = attributeCount;\n\n        for (int i = 0; i < len; i += 2) {\n            final String name = attributes[i];\n            final String value = attributes[i + 1];\n            if (value == null) {\n                out.append(' ').append(name);\n            } else {\n                out.append(' ').append(name).append(\"=\\\"\").append(value).append(\"\\\"\");\n            }\n        }\n\n        if (type == Tag.EMPTY) {\n            out.append(\"/>\");\n        } else {\n            out.append('>');\n        }\n    }\n\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof CustomTag)) return false;\n\n        final CustomTag customTag = (CustomTag) o;\n\n        if (type != customTag.type) return false;\n        if (attributes != null ? !Arrays.equals(attributes, customTag.attributes) : customTag.attributes != null) return false;\n        if (name != null ? !name.equals(customTag.name) : customTag.name != null) return false;\n\n        return true;\n    }\n\n    public int hashCode() {\n        int result = (attributes != null ? attributes.hashCode() : 0);\n        result = 29 * result + (name != null ? name.hashCode() : 0);\n        result = 29 * result + type;\n        return result;\n    }\n\n    public String toString() {\n        return getContents();\n    }\n\n    // ---------- Standard methods to implement Tag interface ------\n\n    public int getAttributeCount() {\n        return attributeCount / 2;\n    }\n\n    public int getAttributeIndex(String name, boolean caseSensitive) {\n        if (attributes == null) {\n            return -1;\n        }\n        final int len = attributeCount;\n        for (int i = 0; i < len; i += 2) {\n            final String current = attributes[i];\n            if (caseSensitive ? name.equals(current) : name.equalsIgnoreCase(current)) {\n                return i / 2;\n            }\n        }\n        return -1;\n    }\n\n    public String getAttributeName(int index) {\n        return attributes[index * 2];\n    }\n\n    public String getAttributeValue(int index) {\n        return attributes[index * 2 + 1];\n    }\n\n    public String getAttributeValue(String name, boolean caseSensitive) {\n        int attributeIndex = getAttributeIndex(name, caseSensitive);\n        if (attributeIndex == -1) {\n            return null;\n        } else {\n            return attributes[attributeIndex * 2 + 1];\n        }\n    }\n\n    public boolean hasAttribute(String name, boolean caseSensitive) {\n        return getAttributeIndex(name, caseSensitive) > -1;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Type of tag: <br/>\n     * &lt;blah&gt; - Tag.OPEN<br/>\n     * &lt;/blah&gt; - Tag.CLOSE<br/>\n     * &lt;blah/&gt; - Tag.EMPTY<br/>\n     */\n    public int getType() {\n        return type;\n    }\n\n    // ----------- Additional methods for changing a tag -----------\n\n    /**\n     * Change the name of the attribute.\n     */\n    public void setName(String name) {\n        if (name == null || name.length() == 0) {\n            throw new IllegalArgumentException(\"CustomTag requires a name\");\n        } else {\n            this.name = name;\n        }\n    }\n\n    /**\n     * Change the type of the tag.\n     *\n     * Type of tag: <br/>\n     * &lt;blah&gt; - Tag.OPEN<br/>\n     * &lt;/blah&gt; - Tag.CLOSE<br/>\n     * &lt;blah/&gt; - Tag.EMPTY<br/>\n     */\n    public void setType(int type) {\n        if (type == Tag.OPEN || type == Tag.CLOSE || type == Tag.EMPTY) {\n            this.type = type;\n        } else {\n            throw new IllegalArgumentException(\"CustomTag must be of type Tag.OPEN, Tag.CLOSE or Tag.EMPTY - was \" + type);\n        }\n    }\n\n    private void growAttributes() {\n        int newSize = attributes.length == 0 ? 4 : attributes.length * 2;\n        String[] newAttributes = new String[newSize];\n        System.arraycopy(attributes, 0, newAttributes, 0, attributes.length);\n        attributes = newAttributes;\n    }\n  \n    /**\n     * Add a new attribute. This does not check for the existence of an attribute with the same name,\n     * thus allowing duplicate attributes.\n     *\n     * @param name           Name of attribute to change.\n     * @param value          New value of attribute or null for an HTML style empty attribute.\n     * @return Index of new attribute.\n     */\n    public int addAttribute(String name, String value) {\n        if(attributeCount == attributes.length) {\n            growAttributes();\n        }\n        attributes[attributeCount++] = name;\n        attributes[attributeCount++] = value;\n        return (attributeCount / 2) - 1;\n    }\n\n    /**\n     * Change the value of an attribute, or add an attribute if it does not already exist.\n     *\n     * @param name           Name of attribute to change.\n     * @param caseSensitive  Whether the name should be treated as case sensitive when searching for an existing value.\n     * @param value          New value of attribute or null for an HTML style empty attribute.\n     */\n    public void setAttributeValue(String name, boolean caseSensitive, String value) {\n        int attributeIndex = getAttributeIndex(name, caseSensitive);\n        if (attributeIndex == -1) {\n            addAttribute(name, value);\n        } else {\n            attributes[attributeIndex * 2 + 1] = value;\n        }\n    }\n\n    /**\n     * Change the name of an existing attribute.\n     */\n    public void setAttributeName(int attributeIndex, String name) {\n        attributes[attributeIndex * 2] = name;\n    }\n\n    /**\n     * Change the value of an existing attribute. The value may be null for an HTML style empty attribute.\n     */\n    public void setAttributeValue(int attributeIndex, String value) {\n        attributes[(attributeIndex * 2) + 1] = value;\n    }\n\n    /**\n     * Remove an attribute.\n     */\n    public void removeAttribute(int attributeIndex) {\n        if(attributeIndex > attributeCount / 2) {\n            throw new ArrayIndexOutOfBoundsException(\"Cannot remove attribute at index \" + attributeIndex + \", max index is \" + attributeCount/2);\n        }\n        //shift everything down one and null the last two\n        String[] newAttributes = new String[attributes.length - 2];\n        System.arraycopy(attributes, 0, newAttributes, 0, attributeIndex * 2);\n        int next = (attributeIndex * 2) + 2;\n        System.arraycopy(attributes, next, newAttributes, attributeIndex * 2, attributes.length - next);\n        attributeCount = attributeCount - 2;\n        attributes = newAttributes;\n    }\n\n    /**\n     * Change the value of an attribute, or add an attribute if it does not already exist.\n     *\n     * @param name           Name of attribute to remove.\n     * @param caseSensitive  Whether the name should be treated as case sensitive.\n     */\n    public void removeAttribute(String name, boolean caseSensitive) {\n        int attributeIndex = getAttributeIndex(name, caseSensitive);\n        if (attributeIndex == -1) {\n            throw new IllegalArgumentException(\"Attribute \" + name + \" not found\");\n        } else {\n            removeAttribute(attributeIndex);\n        }\n    }\n}\n","Smelly Sample":"package com.opensymphony.module.sitemesh.html;\n\nimport java.util.Arrays;\n\nimport com.opensymphony.module.sitemesh.html.util.CharArray;\nimport com.opensymphony.module.sitemesh.html.tokenizer.Parser;\n\n\n/**\n * A CustomTag provides a mechanism to manipulate the contents of a Tag. The standard Tag implementations\n * are immutable, however CustomTag allows a copy to be taken of an immutable Tag that can then be manipulated.\n *\n * @see Tag\n *\n * @author Joe Walnes\n */\npublic class CustomTag implements Tag {\n\n    private String[] attributes = new String[10]; // name1, value1, name2, value2...\n    private int attributeCount = 0;\n    private String name;\n    private int type;\n\n\n    /**\n     * Type of tag: <br/>\n     * &lt;blah&gt; - Tag.OPEN<br/>\n     * &lt;/blah&gt; - Tag.CLOSE<br/>\n     * &lt;blah/&gt; - Tag.EMPTY<br/>\n     */\n    public CustomTag(String name, int type) {\n        setName(name);\n        setType(type);\n    }\n\n    /**\n     * Create a CustomTag based on an existing Tag - this takes a copy of the Tag.\n     */\n    public CustomTag(Tag tag) {\n        setName(tag.getName());\n        setType(tag.getType());\n        if(tag instanceof Parser.ReusableToken) {\n          Parser.ReusableToken orig = (Parser.ReusableToken)tag;\n          attributeCount = orig.attributeCount;\n          attributes = new String[attributeCount];\n          System.arraycopy(orig.attributes, 0, attributes, 0, attributeCount);\n        } else if(tag instanceof CustomTag) {\n          CustomTag orig = (CustomTag)tag;\n          attributeCount = orig.attributeCount;\n          attributes = new String[attributeCount];\n          System.arraycopy(orig.attributes, 0, attributes, 0, attributeCount);\n        } else {\n          int c = tag.getAttributeCount();\n          attributes = new String[c * 2];\n          for (int i = 0; i < c; i++) {\n              attributes[attributeCount++] = tag.getAttributeName(i);\n              attributes[attributeCount++] = tag.getAttributeValue(i);\n          }\n        }\n    }\n\n    public String getContents() {\n        CharArray c = new CharArray(64);\n        writeTo(c);\n        return c.toString();\n    }\n\n    public void writeTo(CharArray out) {\n        if (type == Tag.CLOSE) {\n            out.append(\"<\/\");\n        } else {\n            out.append('<');\n        }\n\n        out.append(name);\n        final int len = attributeCount;\n\n        for (int i = 0; i < len; i += 2) {\n            final String name = attributes[i];\n            final String value = attributes[i + 1];\n            if (value == null) {\n                out.append(' ').append(name);\n            } else {\n                out.append(' ').append(name).append(\"=\\\"\").append(value).append(\"\\\"\");\n            }\n        }\n\n        if (type == Tag.EMPTY) {\n            out.append(\"/>\");\n        } else {\n            out.append('>');\n        }\n    }\n\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof CustomTag)) return false;\n\n        final CustomTag customTag = (CustomTag) o;\n\n        if (type != customTag.type) return false;\n        if (attributes != null ? !Arrays.equals(attributes, customTag.attributes) : customTag.attributes != null) return false;\n        if (name != null ? !name.equals(customTag.name) : customTag.name != null) return false;\n\n        return true;\n    }\n\n    public int hashCode() {\n        int result = (attributes != null ? attributes.hashCode() : 0);\n        result = 29 * result + (name != null ? name.hashCode() : 0);\n        result = 29 * result + type;\n        return result;\n    }\n\n    public String toString() {\n        return getContents();\n    }\n\n    // ---------- Standard methods to implement Tag interface ------\n\n    public int getAttributeCount() {\n        return attributeCount / 2;\n    }\n\n    public int getAttributeIndex(String name, boolean caseSensitive) {\n        if (attributes == null) {\n            return -1;\n        }\n        final int len = attributeCount;\n        for (int i = 0; i < len; i += 2) {\n            final String current = attributes[i];\n            if (caseSensitive ? name.equals(current) : name.equalsIgnoreCase(current)) {\n                return i / 2;\n            }\n        }\n        return -1;\n    }\n\n    public String getAttributeName(int index) {\n        return attributes[index * 2];\n    }\n\n    public String getAttributeValue(int index) {\n        return attributes[index * 2 + 1];\n    }\n\n    public String getAttributeValue(String name, boolean caseSensitive) {\n        int attributeIndex = getAttributeIndex(name, caseSensitive);\n        if (attributeIndex == -1) {\n            return null;\n        } else {\n            return attributes[attributeIndex * 2 + 1];\n        }\n    }\n\n    public boolean hasAttribute(String name, boolean caseSensitive) {\n        return getAttributeIndex(name, caseSensitive) > -1;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Type of tag: <br/>\n     * &lt;blah&gt; - Tag.OPEN<br/>\n     * &lt;/blah&gt; - Tag.CLOSE<br/>\n     * &lt;blah/&gt; - Tag.EMPTY<br/>\n     */\n    public int getType() {\n        return type;\n    }\n\n    // ----------- Additional methods for changing a tag -----------\n\n    /**\n     * Change the name of the attribute.\n     */\n    public void setName(String name) {\n        if (name == null || name.length() == 0) {\n            throw new IllegalArgumentException(\"CustomTag requires a name\");\n        } else {\n            this.name = name;\n        }\n    }\n\n    /**\n     * Change the type of the tag.\n     *\n     * Type of tag: <br/>\n     * &lt;blah&gt; - Tag.OPEN<br/>\n     * &lt;/blah&gt; - Tag.CLOSE<br/>\n     * &lt;blah/&gt; - Tag.EMPTY<br/>\n     */\n    public void setType(int type) {\n        if (type == Tag.OPEN || type == Tag.CLOSE || type == Tag.EMPTY) {\n            this.type = type;\n        } else {\n            throw new IllegalArgumentException(\"CustomTag must be of type Tag.OPEN, Tag.CLOSE or Tag.EMPTY - was \" + type);\n        }\n    }\n\n    private void growAttributes() {\n        String[] newAttributes = new String[attributes.length * 2];\n        System.arraycopy(attributes, 0, newAttributes, 0, attributes.length);\n        attributes = newAttributes;\n    }\n  \n    /**\n     * Add a new attribute. This does not check for the existence of an attribute with the same name,\n     * thus allowing duplicate attributes.\n     *\n     * @param name           Name of attribute to change.\n     * @param value          New value of attribute or null for an HTML style empty attribute.\n     * @return Index of new attribute.\n     */\n    public int addAttribute(String name, String value) {\n        if(attributeCount == attributes.length) {\n            growAttributes();\n        }\n        attributes[attributeCount++] = name;\n        attributes[attributeCount++] = value;\n        return (attributeCount / 2) - 1;\n    }\n\n    /**\n     * Change the value of an attribute, or add an attribute if it does not already exist.\n     *\n     * @param name           Name of attribute to change.\n     * @param caseSensitive  Whether the name should be treated as case sensitive when searching for an existing value.\n     * @param value          New value of attribute or null for an HTML style empty attribute.\n     */\n    public void setAttributeValue(String name, boolean caseSensitive, String value) {\n        int attributeIndex = getAttributeIndex(name, caseSensitive);\n        if (attributeIndex == -1) {\n            addAttribute(name, value);\n        } else {\n            attributes[attributeIndex * 2 + 1] = value;\n        }\n    }\n\n    /**\n     * Change the name of an existing attribute.\n     */\n    public void setAttributeName(int attributeIndex, String name) {\n        attributes[attributeIndex * 2] = name;\n    }\n\n    /**\n     * Change the value of an existing attribute. The value may be null for an HTML style empty attribute.\n     */\n    public void setAttributeValue(int attributeIndex, String value) {\n        attributes[(attributeIndex * 2) + 1] = value;\n    }\n\n    /**\n     * Remove an attribute.\n     */\n    public void removeAttribute(int attributeIndex) {\n        if(attributeIndex > attributeCount / 2) {\n            throw new ArrayIndexOutOfBoundsException(\"Cannot remove attribute at index \" + attributeIndex + \", max index is \" + attributeCount/2);\n        }\n        //shift everything down one and null the last two\n        String[] newAttributes = new String[attributes.length - 2];\n        System.arraycopy(attributes, 0, newAttributes, 0, attributeIndex * 2);\n        int next = (attributeIndex * 2) + 2;\n        System.arraycopy(attributes, next, newAttributes, attributeIndex * 2, attributes.length - next);\n        attributeCount = attributeCount - 2;\n        attributes = newAttributes;\n    }\n\n    /**\n     * Change the value of an attribute, or add an attribute if it does not already exist.\n     *\n     * @param name           Name of attribute to remove.\n     * @param caseSensitive  Whether the name should be treated as case sensitive.\n     */\n    public void removeAttribute(String name, boolean caseSensitive) {\n        int attributeIndex = getAttributeIndex(name, caseSensitive);\n        if (attributeIndex == -1) {\n            throw new IllegalArgumentException(\"Attribute \" + name + \" not found\");\n        } else {\n            removeAttribute(attributeIndex);\n        }\n    }\n}\n","lineNo":204}
{"Refactored Sample":"/* This software is published under the terms of the OpenSymphony Software\n * License version 1.1, of which a copy has been included with this\n * distribution in the LICENSE.txt file. */\npackage com.opensymphony.module.sitemesh.filter;\n\nimport com.opensymphony.module.sitemesh.*;\nimport com.opensymphony.module.sitemesh.util.Container;\n\nimport javax.servlet.*;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\n/**\n * Main SiteMesh filter for applying Decorators to entire Pages.\n *\n * @author <a href=\"joe@truemesh.com\">Joe Walnes<\/a>\n * @author <a href=\"scott@atlassian.com\">Scott Farquhar<\/a>\n * @version $Revision: 1.14 $\n */\npublic class PageFilter implements Filter, RequestConstants {\n    protected FilterConfig filterConfig = null;\n    protected Factory factory = null;\n\n    /**\n     * Main method of the Filter.\n     *\n     * <p>Checks if the Filter has been applied this request. If not, parses the page\n     * and applies {@link com.opensymphony.module.sitemesh.Decorator} (if found).\n     */\n    public void doFilter(ServletRequest rq, ServletResponse rs, FilterChain chain)\n            throws IOException, ServletException {\n\n        HttpServletRequest request = (HttpServletRequest) rq;\n\n        if (rq.getAttribute(FILTER_APPLIED) != null || factory.isPathExcluded(extractRequestPath(request))) {\n            // ensure that filter is only applied once per request\n            chain.doFilter(rq, rs);\n        }\n        else {\n            request.setAttribute(FILTER_APPLIED, Boolean.TRUE);\n\n            factory.refresh();\n            DecoratorMapper decoratorMapper = factory.getDecoratorMapper();\n\n            // force creation of the session now because Tomcat 4 had problems with\n            // creating sessions after the response had been committed\n            if (Container.get() == Container.TOMCAT) {\n                request.getSession(true);\n            }\n            HttpServletResponse response = (HttpServletResponse) rs;\n\n            // parse data into Page object (or continue as normal if Page not parseable)\n            Page page = parsePage(request, response, chain);\n\n            if (page != null) {\n                page.setRequest(request);\n\n                Decorator decorator = decoratorMapper.getDecorator(request, page);\n                if (decorator != null && decorator.getPage() != null) {\n                    applyDecorator(page, decorator, request, response);\n                    return;\n                }\n\n                // if we got here, an exception occured or the decorator was null,\n                // what we don't want is an exception printed to the user, so\n                // we write the original page\n                writeOriginal(request, response, page);\n            }\n        }\n    }\n\n    private String extractRequestPath(HttpServletRequest request) {\n        String servletPath = request.getServletPath();\n        String pathInfo = request.getPathInfo();\n        String query = request.getQueryString();\n        return (servletPath == null ? \"\" : servletPath)\n                + (pathInfo == null ? \"\" : pathInfo)\n                + (query == null ? \"\" : (\"?\" + query));\n    }\n\n    /** Set FilterConfig, and get instance of {@link com.opensymphony.module.sitemesh.DecoratorMapper}. */\n    public void init(FilterConfig filterConfig) {\n        if (filterConfig != null) {\n            this.filterConfig = filterConfig;\n            factory = Factory.getInstance(new Config(filterConfig));\n        }\n        else {\n            destroy();\n        }\n    }\n\n    /** @deprecated Not needed in final version of Servlet 2.3 API - replaced by init(). */\n    // NOTE: SiteMesh doesn't work with Orion 1.5.2 without this method\n    public FilterConfig getFilterConfig() {\n        return filterConfig;\n    }\n\n    /** @deprecated Not needed in final version of Servlet 2.3 API - replaced by init(). */\n    // NOTE: SiteMesh doesn't work with Orion 1.5.2 without this method\n    public void setFilterConfig(FilterConfig filterConfig) {\n        init(filterConfig);\n    }\n\n    /** Shutdown filter. */\n    public void destroy() {\n        factory = null;\n    }\n\n    /**\n     * Continue in filter-chain, writing all content to buffer and parsing\n     * into returned {@link com.opensymphony.module.sitemesh.Page} object. If\n     * {@link com.opensymphony.module.sitemesh.Page} is not parseable, null is returned.\n     */\n    protected Page parsePage(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException {\n        try {\n            PageResponseWrapper pageResponse = new PageResponseWrapper(response, factory);\n            chain.doFilter(request, pageResponse);\n            // check if another servlet or filter put a page object to the request\n            Page result = (Page)request.getAttribute(PAGE);\n            if (result == null) {\n                // parse the page\n                result = pageResponse.getPage();\n            }\n            request.setAttribute(USING_STREAM, pageResponse.isUsingStream() ? Boolean.TRUE : Boolean.FALSE); // JDK 1.3 friendly\n            return result;\n        }\n        catch (IllegalStateException e) {\n            // weblogic throws an IllegalStateException when an error page is served.\n            // it's ok to ignore this, however for all other containers it should be thrown\n            // properly.\n            if (Container.get() != Container.WEBLOGIC) throw e;\n            return null;\n        }\n    }\n\n    /**\n     * Apply {@link com.opensymphony.module.sitemesh.Decorator} to\n     * {@link com.opensymphony.module.sitemesh.Page} and write to the response.\n     */\n    protected void applyDecorator(final Page page, Decorator decorator, HttpServletRequest request, final HttpServletResponse response) throws ServletException, IOException {\n        try {\n            request.setAttribute(PAGE, page);\n            ServletContext context = filterConfig.getServletContext();\n            // see if the URI path (webapp) is set\n            if (decorator.getURIPath() != null) {\n                // in a security conscious environment, the servlet container\n                // may return null for a given URL\n                if (context.getContext(decorator.getURIPath()) != null) {\n                    context = context.getContext(decorator.getURIPath());\n                }\n            }\n            // get the dispatcher for the decorator\n            RequestDispatcher dispatcher = context.getRequestDispatcher(decorator.getPage());\n            // create a wrapper around the response\n\n            writeDecorator(response, page, dispatcher, request);\n\n            // set the headers specified as decorator init params\n            // TODO: This looks weird. Is it used? Why would the headers be set after the the include? Hrmmmmm. -Joe\n            while (decorator.getInitParameterNames().hasNext()) {\n                String initParam = (String) decorator.getInitParameterNames().next();\n                if (initParam.startsWith(\"header.\")) {\n                    response.setHeader(initParam.substring(initParam.indexOf('.')), decorator.getInitParameter(initParam));\n                }\n            }\n\n            request.removeAttribute(PAGE);\n        }\n        catch (RuntimeException e) {\n            // added a print message here because otherwise Tomcat swallows\n            // the error and you never see it = bad!\n            if (Container.get() == Container.TOMCAT)\n                e.printStackTrace();\n\n            throw e;\n        }\n    }\n\n    protected void writeDecorator(HttpServletResponse response, Page page, RequestDispatcher dispatcher, HttpServletRequest request) throws ServletException, IOException {\n        dispatcher.include(request, response);\n    }\n\n    /** Write the original page data to the response. */\n    private void writeOriginal(HttpServletRequest request, HttpServletResponse response, Page page) throws IOException {\n        response.setContentLength(page.getContentLength());\n        if (request.getAttribute(USING_STREAM).equals(Boolean.TRUE))\n        {\n            PrintWriter writer = new PrintWriter(response.getOutputStream());\n            page.writePage(writer);\n            //flush writer to underlying outputStream\n            writer.flush();\n            response.getOutputStream().flush();\n        }\n        else\n        {\n            page.writePage(response.getWriter());\n            response.getWriter().flush();\n        }\n    }\n}\n","Smelly Sample":"/* This software is published under the terms of the OpenSymphony Software\n * License version 1.1, of which a copy has been included with this\n * distribution in the LICENSE.txt file. */\npackage com.opensymphony.module.sitemesh.filter;\n\nimport com.opensymphony.module.sitemesh.*;\nimport com.opensymphony.module.sitemesh.util.Container;\n\nimport javax.servlet.*;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\n/**\n * Main SiteMesh filter for applying Decorators to entire Pages.\n *\n * @author <a href=\"joe@truemesh.com\">Joe Walnes<\/a>\n * @author <a href=\"scott@atlassian.com\">Scott Farquhar<\/a>\n * @version $Revision: 1.13 $\n */\npublic class PageFilter implements Filter, RequestConstants {\n    protected FilterConfig filterConfig = null;\n    protected Factory factory = null;\n\n    /**\n     * Main method of the Filter.\n     *\n     * <p>Checks if the Filter has been applied this request. If not, parses the page\n     * and applies {@link com.opensymphony.module.sitemesh.Decorator} (if found).\n     */\n    public void doFilter(ServletRequest rq, ServletResponse rs, FilterChain chain)\n            throws IOException, ServletException {\n\n        HttpServletRequest request = (HttpServletRequest) rq;\n\n        if (rq.getAttribute(FILTER_APPLIED) != null || factory.isPathExcluded(extractRequestPath(request))) {\n            // ensure that filter is only applied once per request\n            chain.doFilter(rq, rs);\n        }\n        else {\n            request.setAttribute(FILTER_APPLIED, Boolean.TRUE);\n\n            // force creation of the session now because Tomcat 4 had problems with\n            // creating sessions after the response had been committed\n            if (Container.get() == Container.TOMCAT) {\n                request.getSession(true);\n            }\n            HttpServletResponse response = (HttpServletResponse) rs;\n\n            // parse data into Page object (or continue as normal if Page not parseable)\n            Page page = parsePage(request, response, chain);\n\n            if (page != null) {\n                page.setRequest(request);\n\n                Decorator decorator = factory.getDecoratorMapper().getDecorator(request, page);\n                if (decorator != null && decorator.getPage() != null) {\n                    applyDecorator(page, decorator, request, response);\n                    page = null;\n                    return;\n                }\n\n                // if we got here, an exception occured or the decorator was null,\n                // what we don't want is an exception printed to the user, so\n                // we write the original page\n                writeOriginal(request, response, page);\n                page = null;\n            }\n        }\n    }\n\n    private String extractRequestPath(HttpServletRequest request) {\n        String servletPath = request.getServletPath();\n        String pathInfo = request.getPathInfo();\n        String query = request.getQueryString();\n        return (servletPath == null ? \"\" : servletPath)\n                + (pathInfo == null ? \"\" : pathInfo)\n                + (query == null ? \"\" : (\"?\" + query));\n    }\n\n    /** Set FilterConfig, and get instance of {@link com.opensymphony.module.sitemesh.DecoratorMapper}. */\n    public void init(FilterConfig filterConfig) {\n        if (filterConfig != null) {\n            this.filterConfig = filterConfig;\n            factory = Factory.getInstance(new Config(filterConfig));\n        }\n        else {\n            destroy();\n        }\n    }\n\n    /** @deprecated Not needed in final version of Servlet 2.3 API - replaced by init(). */\n    // NOTE: SiteMesh doesn't work with Orion 1.5.2 without this method\n    public FilterConfig getFilterConfig() {\n        return filterConfig;\n    }\n\n    /** @deprecated Not needed in final version of Servlet 2.3 API - replaced by init(). */\n    // NOTE: SiteMesh doesn't work with Orion 1.5.2 without this method\n    public void setFilterConfig(FilterConfig filterConfig) {\n        init(filterConfig);\n    }\n\n    /** Shutdown filter. */\n    public void destroy() {\n        factory = null;\n    }\n\n    /**\n     * Continue in filter-chain, writing all content to buffer and parsing\n     * into returned {@link com.opensymphony.module.sitemesh.Page} object. If\n     * {@link com.opensymphony.module.sitemesh.Page} is not parseable, null is returned.\n     */\n    protected Page parsePage(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException {\n        try {\n            PageResponseWrapper pageResponse = new PageResponseWrapper(response, factory);\n            chain.doFilter(request, pageResponse);\n            // check if another servlet or filter put a page object to the request\n            Page result = (Page)request.getAttribute(PAGE);\n            if (result == null) {\n                // parse the page\n                result = pageResponse.getPage();\n            }\n            request.setAttribute(USING_STREAM, new Boolean(pageResponse.isUsingStream()));\n            return result;\n        }\n        catch (IllegalStateException e) {\n            // weblogic throws an IllegalStateException when an error page is served.\n            // it's ok to ignore this, however for all other containers it should be thrown\n            // properly.\n            if (Container.get() != Container.WEBLOGIC) throw e;\n            return null;\n        }\n    }\n\n    /**\n     * Apply {@link com.opensymphony.module.sitemesh.Decorator} to\n     * {@link com.opensymphony.module.sitemesh.Page} and write to the response.\n     */\n    protected void applyDecorator(Page page, Decorator decorator, HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        try {\n            request.setAttribute(PAGE, page);\n            ServletContext context = filterConfig.getServletContext();\n            // see if the URI path (webapp) is set\n            if (decorator.getURIPath() != null) {\n                // in a security conscious environment, the servlet container\n                // may return null for a given URL\n                if (context.getContext(decorator.getURIPath()) != null) {\n                    context = context.getContext(decorator.getURIPath());\n                }\n            }\n            // get the dispatcher for the decorator\n            RequestDispatcher dispatcher = context.getRequestDispatcher(decorator.getPage());\n            // create a wrapper around the response\n            dispatcher.include(request, response);\n\n            // set the headers specified as decorator init params\n            while (decorator.getInitParameterNames().hasNext()) {\n                String initParam = (String) decorator.getInitParameterNames().next();\n                if (initParam.startsWith(\"header.\")) {\n                    response.setHeader(initParam.substring(initParam.indexOf('.')), decorator.getInitParameter(initParam));\n                }\n            }\n\n            request.removeAttribute(PAGE);\n        }\n        catch (RuntimeException e) {\n            // added a print message here because otherwise Tomcat swallows\n            // the error and you never see it = bad!\n            if (Container.get() == Container.TOMCAT)\n                e.printStackTrace();\n\n            throw e;\n        }\n    }\n\n    /** Write the original page data to the response. */\n    private void writeOriginal(HttpServletRequest request, HttpServletResponse response, Page page) throws IOException {\n        response.setContentLength(page.getContentLength());\n        if (request.getAttribute(USING_STREAM).equals(Boolean.TRUE))\n        {\n            PrintWriter writer = new PrintWriter(response.getOutputStream());\n            page.writePage(writer);\n            //flush writer to underlying outputStream\n            writer.flush();\n            response.getOutputStream().flush();\n        }\n        else\n        {\n            page.writePage(response.getWriter());\n            response.getWriter().flush();\n        }\n    }\n}\n","lineNo":45}
{"Refactored Sample":"package testsuite.unittests;\n\nimport java.io.*;\nimport java.util.List;\nimport java.util.ArrayList;\n\nimport com.opensymphony.module.sitemesh.parser.FastPageParser;\nimport com.opensymphony.module.sitemesh.parser.HTMLPageParser;\nimport com.opensymphony.module.sitemesh.PageParser;\n\n/**\n * @author Hani Suleiman (hani@formicary.net)\n * Date: Nov 22 2003\n * Time: 12:09:26 AM\n */\npublic class ParserGrinder\n{\n  public static void main(String[] args) throws IOException, InterruptedException\n  {\n    if(args.length==0)\n    {\n      System.err.println(\"Usage: java \" + ParserGrinder.class.getName() + \" <html file>\");\n      System.exit(1);\n    }\n    File file = new File(args[0]);\n    if(!file.exists() || file.isDirectory())\n    {\n      System.err.println(\"File \" + args[0] + \" does not exist or is a directory\");\n      System.exit(1);\n    }\n    FileInputStream fis = new FileInputStream(file);\n    byte[] contents = new byte[(int)file.length()];\n    fis.read(contents);\n    String page = new String(contents);\n    final char[] chars = page.toCharArray();\n    //warm up parser\n\n    for(int i=0;i<10;i++)\n    {\n      PageParser parser = new HTMLPageParser();\n      //FastPageParser parser = new FastPageParser();\n      parser.parse(chars);\n    }\n\n    //now go crazy\n    final int threadCount = 5;\n    Thread[] threads = new Thread[threadCount];\n    final List[] lists = new ArrayList[threadCount];\n    final int passes = 50;\n    for(int i=0;i<threads.length;i++)\n    {\n      final int index = i;\n      lists[index] = new ArrayList(passes);\n      threads[index] = new Thread(new Runnable()\n      {\n        public void run()\n        {\n          for(int j=0;j<passes;j++)\n          {\n            PageParser parser = new HTMLPageParser();\n            //PageParser parser = new FastPageParser();\n            try\n            {\n              lists[index].add(parser.parse(chars));\n            }\n            catch(IOException e)\n            {\n              e.printStackTrace();\n            }\n          }\n        }\n      });\n    }\n    //we do this here instead of above just to not count the thread creation overhead\n    long now = System.currentTimeMillis();\n    long startMemory = Runtime.getRuntime().freeMemory();\n    System.out.println(\"startMemory=\" + startMemory);\n    for(int i=0;i<threads.length;i++)\n    {\n      threads[i].start();\n    }\n\n    for(int i = 0; i < threads.length; i++)\n    {\n      threads[i].join();\n    }\n    long timeTaken = System.currentTimeMillis() - now;\n    //System.gc();\n    long endMemory = Runtime.getRuntime().freeMemory();\n    System.out.println(\"time taken \" + timeTaken + \" for \" + (threads.length * passes) + \" parses. Memory used=\" + (endMemory-  startMemory));\n  }\n}\n","Smelly Sample":"package testsuite.unittests;\n\nimport java.io.*;\nimport java.util.List;\nimport java.util.ArrayList;\n\nimport com.opensymphony.module.sitemesh.parser.FastPageParser;\nimport com.opensymphony.module.sitemesh.parser.HTMLPageParser;\nimport com.opensymphony.module.sitemesh.PageParser;\n\n/**\n * @author Hani Suleiman (hani@formicary.net)\n * Date: Nov 22 2003\n * Time: 12:09:26 AM\n */\npublic class ParserGrinder\n{\n  public static void main(String[] args) throws IOException, InterruptedException\n  {\n    if(args.length==0)\n    {\n      System.err.println(\"Usage: java \" + ParserGrinder.class.getName() + \" <html file>\");\n      System.exit(1);\n    }\n    File file = new File(args[0]);\n    if(!file.exists() || file.isDirectory())\n    {\n      System.err.println(\"File \" + args[0] + \" does not exist or is a directory\");\n      System.exit(1);\n    }\n    FileInputStream fis = new FileInputStream(file);\n    byte[] contents = new byte[(int)file.length()];\n    fis.read(contents);\n    String page = new String(contents);\n    final char[] chars = page.toCharArray();\n    //warm up parser\n\n    for(int i=0;i<10;i++)\n    {\n      PageParser parser = new HTMLPageParser();\n      //FastPageParser parser = new FastPageParser();\n      parser.parse(chars);\n    }\n\n    //now go crazy\n    final int threadCount = 5;\n    Thread[] threads = new Thread[threadCount];\n    final List[] lists = new ArrayList[threadCount];\n    final int passes = 50;\n    for(int i=0;i<threads.length;i++)\n    {\n      final int index = i;\n      lists[index] = new ArrayList(passes);\n      threads[index] = new Thread(new Runnable()\n      {\n        public void run()\n        {\n          for(int j=0;j<passes;j++)\n          {\n            FastPageParser parser = new FastPageParser();\n            try\n            {\n              lists[index].add(parser.parse(chars));\n            }\n            catch(IOException e)\n            {\n              e.printStackTrace();\n            }\n          }\n        }\n      });\n    }\n    //we do this here instead of above just to not count the thread creation overhead\n    long now = System.currentTimeMillis();\n    long startMemory = Runtime.getRuntime().freeMemory();\n    System.out.println(\"startMemory=\" + startMemory);\n    for(int i=0;i<threads.length;i++)\n    {\n      threads[i].start();\n    }\n\n    for(int i = 0; i < threads.length; i++)\n    {\n      threads[i].join();\n    }\n    System.gc();\n    long endMemory = Runtime.getRuntime().freeMemory();\n    System.out.println(\"time taken \" + (System.currentTimeMillis()-now) + \" for \" + (threads.length * passes) + \" parses. Memory used=\" + (startMemory-endMemory));\n  }\n}\n","lineNo":87}
{"Refactored Sample":"package com.opensymphony.module.sitemesh.html;\n\nimport java.util.Arrays;\n\nimport com.opensymphony.module.sitemesh.html.util.CharArray;\nimport com.opensymphony.module.sitemesh.html.tokenizer.Parser;\n\n\n/**\n * A CustomTag provides a mechanism to manipulate the contents of a Tag. The standard Tag implementations\n * are immutable, however CustomTag allows a copy to be taken of an immutable Tag that can then be manipulated.\n *\n * @see Tag\n *\n * @author Joe Walnes\n */\npublic class CustomTag implements Tag {\n\n    private String[] attributes = new String[10]; // name1, value1, name2, value2...\n    private int attributeCount = 0;\n    private String name;\n    private int type;\n\n\n    /**\n     * Type of tag: <br/>\n     * &lt;blah&gt; - Tag.OPEN<br/>\n     * &lt;/blah&gt; - Tag.CLOSE<br/>\n     * &lt;blah/&gt; - Tag.EMPTY<br/>\n     */\n    public CustomTag(String name, int type) {\n        setName(name);\n        setType(type);\n    }\n\n    /**\n     * Create a CustomTag based on an existing Tag - this takes a copy of the Tag.\n     */\n    public CustomTag(Tag tag) {\n        setName(tag.getName());\n        setType(tag.getType());\n        if(tag instanceof Parser.ReusableToken) {\n          Parser.ReusableToken orig = (Parser.ReusableToken)tag;\n          attributeCount = orig.attributeCount;\n          attributes = new String[attributeCount];\n          System.arraycopy(orig.attributes, 0, attributes, 0, attributeCount);\n        } else if(tag instanceof CustomTag) {\n          CustomTag orig = (CustomTag)tag;\n          attributeCount = orig.attributeCount;\n          attributes = new String[attributeCount];\n          System.arraycopy(orig.attributes, 0, attributes, 0, attributeCount);\n        } else {\n          int c = tag.getAttributeCount();\n          attributes = new String[c * 2];\n          for (int i = 0; i < c; i++) {\n              attributes[attributeCount++] = tag.getAttributeName(i);\n              attributes[attributeCount++] = tag.getAttributeValue(i);\n          }\n        }\n    }\n\n    public String getContents() {\n        CharArray c = new CharArray(64);\n        writeTo(c);\n        return c.toString();\n    }\n\n    public void writeTo(CharArray out) {\n        if (type == Tag.CLOSE) {\n            out.append(\"<\/\");\n        } else {\n            out.append('<');\n        }\n\n        out.append(name);\n        final int len = attributeCount;\n\n        for (int i = 0; i < len; i += 2) {\n            final String name = attributes[i];\n            final String value = attributes[i + 1];\n            if (value == null) {\n                out.append(' ').append(name);\n            } else {\n                out.append(' ').append(name).append(\"=\\\"\").append(value).append(\"\\\"\");\n            }\n        }\n\n        if (type == Tag.EMPTY) {\n            out.append(\"/>\");\n        } else {\n            out.append('>');\n        }\n    }\n\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof CustomTag)) return false;\n\n        final CustomTag customTag = (CustomTag) o;\n\n        if (type != customTag.type) return false;\n        if (attributes != null ? !Arrays.equals(attributes, customTag.attributes) : customTag.attributes != null) return false;\n        if (name != null ? !name.equals(customTag.name) : customTag.name != null) return false;\n\n        return true;\n    }\n\n    public int hashCode() {\n        int result = (attributes != null ? attributes.hashCode() : 0);\n        result = 29 * result + (name != null ? name.hashCode() : 0);\n        result = 29 * result + type;\n        return result;\n    }\n\n    public String toString() {\n        return getContents();\n    }\n\n    // ---------- Standard methods to implement Tag interface ------\n\n    public int getAttributeCount() {\n        return attributeCount / 2;\n    }\n\n    public int getAttributeIndex(String name, boolean caseSensitive) {\n        if (attributes == null) {\n            return -1;\n        }\n        final int len = attributeCount;\n        for (int i = 0; i < len; i += 2) {\n            final String current = attributes[i];\n            if (caseSensitive ? name.equals(current) : name.equalsIgnoreCase(current)) {\n                return i / 2;\n            }\n        }\n        return -1;\n    }\n\n    public String getAttributeName(int index) {\n        return attributes[index * 2];\n    }\n\n    public String getAttributeValue(int index) {\n        return attributes[index * 2 + 1];\n    }\n\n    public String getAttributeValue(String name, boolean caseSensitive) {\n        int attributeIndex = getAttributeIndex(name, caseSensitive);\n        if (attributeIndex == -1) {\n            return null;\n        } else {\n            return attributes[attributeIndex * 2 + 1];\n        }\n    }\n\n    public boolean hasAttribute(String name, boolean caseSensitive) {\n        return getAttributeIndex(name, caseSensitive) > -1;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Type of tag: <br/>\n     * &lt;blah&gt; - Tag.OPEN<br/>\n     * &lt;/blah&gt; - Tag.CLOSE<br/>\n     * &lt;blah/&gt; - Tag.EMPTY<br/>\n     */\n    public int getType() {\n        return type;\n    }\n\n    // ----------- Additional methods for changing a tag -----------\n\n    /**\n     * Change the name of the attribute.\n     */\n    public void setName(String name) {\n        if (name == null || name.length() == 0) {\n            throw new IllegalArgumentException(\"CustomTag requires a name\");\n        } else {\n            this.name = name;\n        }\n    }\n\n    /**\n     * Change the type of the tag.\n     *\n     * Type of tag: <br/>\n     * &lt;blah&gt; - Tag.OPEN<br/>\n     * &lt;/blah&gt; - Tag.CLOSE<br/>\n     * &lt;blah/&gt; - Tag.EMPTY<br/>\n     */\n    public void setType(int type) {\n        if (type == Tag.OPEN || type == Tag.CLOSE || type == Tag.EMPTY) {\n            this.type = type;\n        } else {\n            throw new IllegalArgumentException(\"CustomTag must be of type Tag.OPEN, Tag.CLOSE or Tag.EMPTY - was \" + type);\n        }\n    }\n\n    private void growAttributes() {\n        String[] newAttributes = new String[attributes.length * 2];\n        System.arraycopy(attributes, 0, newAttributes, 0, attributes.length);\n        attributes = newAttributes;\n    }\n  \n    /**\n     * Add a new attribute. This does not check for the existence of an attribute with the same name,\n     * thus allowing duplicate attributes.\n     *\n     * @param name           Name of attribute to change.\n     * @param value          New value of attribute or null for an HTML style empty attribute.\n     * @return Index of new attribute.\n     */\n    public int addAttribute(String name, String value) {\n        if(attributeCount == attributes.length) {\n            growAttributes();\n        }\n        attributes[attributeCount++] = name;\n        attributes[attributeCount++] = value;\n        return (attributeCount / 2) - 1;\n    }\n\n    /**\n     * Change the value of an attribute, or add an attribute if it does not already exist.\n     *\n     * @param name           Name of attribute to change.\n     * @param caseSensitive  Whether the name should be treated as case sensitive when searching for an existing value.\n     * @param value          New value of attribute or null for an HTML style empty attribute.\n     */\n    public void setAttributeValue(String name, boolean caseSensitive, String value) {\n        int attributeIndex = getAttributeIndex(name, caseSensitive);\n        if (attributeIndex == -1) {\n            addAttribute(name, value);\n        } else {\n            attributes[attributeIndex * 2 + 1] = value;\n        }\n    }\n\n    /**\n     * Change the name of an existing attribute.\n     */\n    public void setAttributeName(int attributeIndex, String name) {\n        attributes[attributeIndex * 2] = name;\n    }\n\n    /**\n     * Change the value of an existing attribute. The value may be null for an HTML style empty attribute.\n     */\n    public void setAttributeValue(int attributeIndex, String value) {\n        attributes[(attributeIndex * 2) + 1] = value;\n    }\n\n    /**\n     * Remove an attribute.\n     */\n    public void removeAttribute(int attributeIndex) {\n        if(attributeIndex > attributeCount / 2) {\n            throw new ArrayIndexOutOfBoundsException(\"Cannot remove attribute at index \" + attributeIndex + \", max index is \" + attributeCount/2);\n        }\n        //shift everything down one and null the last two\n        String[] newAttributes = new String[attributes.length - 2];\n        System.arraycopy(attributes, 0, newAttributes, 0, attributeIndex * 2);\n        int next = (attributeIndex * 2) + 2;\n        System.arraycopy(attributes, next, newAttributes, attributeIndex * 2, attributes.length - next);\n        attributeCount = attributeCount - 2;\n        attributes = newAttributes;\n    }\n\n    /**\n     * Change the value of an attribute, or add an attribute if it does not already exist.\n     *\n     * @param name           Name of attribute to remove.\n     * @param caseSensitive  Whether the name should be treated as case sensitive.\n     */\n    public void removeAttribute(String name, boolean caseSensitive) {\n        int attributeIndex = getAttributeIndex(name, caseSensitive);\n        if (attributeIndex == -1) {\n            throw new IllegalArgumentException(\"Attribute \" + name + \" not found\");\n        } else {\n            removeAttribute(attributeIndex);\n        }\n    }\n}\n","Smelly Sample":"package com.opensymphony.module.sitemesh.html;\n\nimport java.util.Arrays;\n\nimport com.opensymphony.module.sitemesh.html.util.CharArray;\nimport com.opensymphony.module.sitemesh.html.tokenizer.Parser;\n\n\n/**\n * A CustomTag provides a mechanism to manipulate the contents of a Tag. The standard Tag implementations\n * are immutable, however CustomTag allows a copy to be taken of an immutable Tag that can then be manipulated.\n *\n * @see Tag\n *\n * @author Joe Walnes\n */\npublic class CustomTag implements Tag {\n\n    private String[] attributes = new String[10]; // name1, value1, name2, value2...\n    private int attributeCount = 0;\n    private String name;\n    private int type;\n\n\n    /**\n     * Type of tag: <br/>\n     * &lt;blah&gt; - Tag.OPEN<br/>\n     * &lt;/blah&gt; - Tag.CLOSE<br/>\n     * &lt;blah/&gt; - Tag.EMPTY<br/>\n     */\n    public CustomTag(String name, int type) {\n        setName(name);\n        setType(type);\n    }\n\n    /**\n     * Create a CustomTag based on an existing Tag - this takes a copy of the Tag.\n     */\n    public CustomTag(Tag tag) {\n        setName(tag.getName());\n        setType(tag.getType());\n        if(tag instanceof Parser.ReusableToken) {\n          Parser.ReusableToken orig = (Parser.ReusableToken)tag;\n          attributeCount = orig.attributeCount;\n          attributes = new String[attributeCount];\n          System.arraycopy(orig.attributes, 0, attributes, 0, attributeCount);\n        } else if(tag instanceof CustomTag) {\n          CustomTag orig = (CustomTag)tag;\n          attributeCount = orig.attributeCount;\n          attributes = new String[attributeCount];\n          System.arraycopy(orig.attributes, 0, attributes, 0, attributeCount);\n        } else {\n          int c = tag.getAttributeCount();\n          attributes = new String[c * 2];\n          for (int i = 0; i < c; i++) {\n              attributes[attributeCount++] = tag.getAttributeName(i);\n              attributes[attributeCount++] = tag.getAttributeValue(i);\n          }\n        }\n    }\n\n    public String getContents() {\n        CharArray c = new CharArray(64);\n        writeTo(c);\n        return c.toString();\n    }\n\n    public void writeTo(CharArray out) {\n        if (type == Tag.CLOSE) {\n            out.append(\"<\/\");\n        } else {\n            out.append('<');\n        }\n\n        out.append(name);\n        final int len = attributeCount;\n\n        for (int i = 0; i < len; i += 2) {\n            final String name = attributes[i];\n            final String value = attributes[i + 1];\n            if (value == null) {\n                out.append(' ').append(name);\n            } else {\n                out.append(' ').append(name).append(\"=\\\"\").append(value).append(\"\\\"\");\n            }\n        }\n\n        if (type == Tag.EMPTY) {\n            out.append(\"/>\");\n        } else {\n            out.append('>');\n        }\n    }\n\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof CustomTag)) return false;\n\n        final CustomTag customTag = (CustomTag) o;\n\n        if (type != customTag.type) return false;\n        if (attributes != null ? !Arrays.equals(attributes, customTag.attributes) : customTag.attributes != null) return false;\n        if (name != null ? !name.equals(customTag.name) : customTag.name != null) return false;\n\n        return true;\n    }\n\n    public int hashCode() {\n        int result = (attributes != null ? attributes.hashCode() : 0);\n        result = 29 * result + (name != null ? name.hashCode() : 0);\n        result = 29 * result + type;\n        return result;\n    }\n\n    public String toString() {\n        return getContents();\n    }\n\n    // ---------- Standard methods to implement Tag interface ------\n\n    public int getAttributeCount() {\n        return attributeCount / 2;\n    }\n\n    public int getAttributeIndex(String name, boolean caseSensitive) {\n        if (attributes == null) {\n            return -1;\n        }\n        final int len = attributeCount;\n        for (int i = 0; i < len; i += 2) {\n            final String current = attributes[i];\n            if (caseSensitive ? name.equals(current) : name.equalsIgnoreCase(current)) {\n                return i / 2;\n            }\n        }\n        return -1;\n    }\n\n    public String getAttributeName(int index) {\n        return attributes[index * 2];\n    }\n\n    public String getAttributeValue(int index) {\n        return attributes[index * 2 + 1];\n    }\n\n    public String getAttributeValue(String name, boolean caseSensitive) {\n        int attributeIndex = getAttributeIndex(name, caseSensitive);\n        if (attributeIndex == -1) {\n            return null;\n        } else {\n            return attributes[attributeIndex * 2 + 1];\n        }\n    }\n\n    public boolean hasAttribute(String name, boolean caseSensitive) {\n        return getAttributeIndex(name, caseSensitive) > -1;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Type of tag: <br/>\n     * &lt;blah&gt; - Tag.OPEN<br/>\n     * &lt;/blah&gt; - Tag.CLOSE<br/>\n     * &lt;blah/&gt; - Tag.EMPTY<br/>\n     */\n    public int getType() {\n        return type;\n    }\n\n    // ----------- Additional methods for changing a tag -----------\n\n    /**\n     * Change the name of the attribute.\n     */\n    public void setName(String name) {\n        if (name == null || name.length() == 0) {\n            throw new IllegalArgumentException(\"CustomTag requires a name\");\n        } else {\n            this.name = name;\n        }\n    }\n\n    /**\n     * Change the type of the tag.\n     *\n     * Type of tag: <br/>\n     * &lt;blah&gt; - Tag.OPEN<br/>\n     * &lt;/blah&gt; - Tag.CLOSE<br/>\n     * &lt;blah/&gt; - Tag.EMPTY<br/>\n     */\n    public void setType(int type) {\n        if (type == Tag.OPEN || type == Tag.CLOSE || type == Tag.EMPTY) {\n            this.type = type;\n        } else {\n            throw new IllegalArgumentException(\"CustomTag must be of type Tag.OPEN, Tag.CLOSE or Tag.EMPTY - was \" + type);\n        }\n    }\n\n    private void growAttributes() {\n        String[] newAttributes = new String[attributes.length * 2];\n        System.arraycopy(attributes, 0, newAttributes, 0, attributes.length);\n        attributes = newAttributes;\n    }\n  \n    /**\n     * Add a new attribute. This does not check for the existence of an attribute with the same name,\n     * thus allowing duplicate attributes.\n     *\n     * @param name           Name of attribute to change.\n     * @param value          New value of attribute or null for an HTML style empty attribute.\n     * @return Index of new attribute.\n     */\n    public int addAttribute(String name, String value) {\n        if(attributeCount == attributes.length) {\n            growAttributes();\n        }\n        attributes[attributeCount++] = name;\n        attributes[attributeCount++] = value;\n        return (attributeCount / 2) - 1;\n    }\n\n    /**\n     * Change the value of an attribute, or add an attribute if it does not already exist.\n     *\n     * @param name           Name of attribute to change.\n     * @param caseSensitive  Whether the name should be treated as case sensitive when searching for an existing value.\n     * @param value          New value of attribute or null for an HTML style empty attribute.\n     */\n    public void setAttributeValue(String name, boolean caseSensitive, String value) {\n        int attributeIndex = getAttributeIndex(name, caseSensitive);\n        if (attributeIndex == -1) {\n            addAttribute(name, value);\n        } else {\n            attributes[attributeIndex * 2 + 1] = value;\n        }\n    }\n\n    /**\n     * Change the name of an existing attribute.\n     */\n    public void setAttributeName(int attributeIndex, String name) {\n        attributes[attributeIndex * 2] = name;\n    }\n\n    /**\n     * Change the value of an existing attribute. The value may be null for an HTML style empty attribute.\n     */\n    public void setAttributeValue(int attributeIndex, String value) {\n        attributes[(attributeIndex * 2) + 1] = value;\n    }\n\n    /**\n     * Remove an attribute.\n     */\n    public void removeAttribute(int attributeIndex) {\n        if(attributeIndex > attributeCount / 2) {\n            throw new ArrayIndexOutOfBoundsException(\"Cannot remove attribute at index \" + attributeIndex + \", max index is \" + attributeCount/2);\n        }\n        //shift everything down one and null the last two\n        String[] newAttributes = new String[attributes.length - 2];\n        System.arraycopy(attributes, 0, newAttributes, 0, attributeIndex * 2);\n        System.arraycopy(attributes, (attributeIndex * 2) + 2, newAttributes, attributeIndex * 2, attributeIndex);\n    }\n\n    /**\n     * Change the value of an attribute, or add an attribute if it does not already exist.\n     *\n     * @param name           Name of attribute to remove.\n     * @param caseSensitive  Whether the name should be treated as case sensitive.\n     */\n    public void removeAttribute(String name, boolean caseSensitive) {\n        int attributeIndex = getAttributeIndex(name, caseSensitive);\n        if (attributeIndex == -1) {\n            throw new IllegalArgumentException(\"Attribute \" + name + \" not found\");\n        } else {\n            removeAttribute(attributeIndex);\n        }\n    }\n}\n","lineNo":266}
{"Refactored Sample":"package com.opensymphony.module.sitemesh.parser.rules;\n\nimport com.opensymphony.module.sitemesh.html.BasicRule;\nimport com.opensymphony.module.sitemesh.html.Tag;\nimport com.opensymphony.module.sitemesh.html.CustomTag;\n\n/**\n * Very simple rule for replacing all occurences of one tag with another.\n *\n * <p>For example, to convert all &lt;b&gt; tags to &lt;strong&gt;:<\/p>\n * <p>html.addRule(new TagReplaceRule(\"b\", \"strong\"));<\/p>\n *\n * @author Joe Walnes\n */\npublic class TagReplaceRule extends BasicRule {\n\n    private final String newTagName;\n\n    public TagReplaceRule(String originalTagName, String newTagName) {\n        super(originalTagName);\n        this.newTagName = newTagName;\n    }\n\n    public void process(Tag tag) {\n        CustomTag customTag = new CustomTag(tag);\n        customTag.setName(newTagName);\n        customTag.writeTo(currentBuffer());\n    }\n}\n","Smelly Sample":"package com.opensymphony.module.sitemesh.parser.rules;\n\nimport com.opensymphony.module.sitemesh.html.BasicRule;\nimport com.opensymphony.module.sitemesh.html.Tag;\nimport com.opensymphony.module.sitemesh.html.util.CharArray;\n\n/**\n * Very simple rule for replacing all occurences of one tag with another.\n *\n * <p>For example, to convert all &lt;b&gt; tags to &lt;strong&gt;:<\/p>\n * <p>html.addRule(new TagReplaceRule(\"b\", \"strong\"));<\/p>\n *\n * <p>Note, attributes are ignored.<\/p>\n *\n * @author Joe Walnes\n */\npublic class TagReplaceRule extends BasicRule {\n\n    private final String newTagName;\n\n    public TagReplaceRule(String originalTagName, String newTagName) {\n        super(originalTagName);\n        this.newTagName = newTagName;\n    }\n\n    public void process(Tag tag) {\n        // TODO: copy attributes as well\n        switch (tag.getType()) {\n            case Tag.OPEN:\n                currentBuffer().append(\"<\" + newTagName + \">\");\n                break;\n            case Tag.CLOSE:\n                currentBuffer().append(\"<\/\" + newTagName + \">\");\n                break;\n            case Tag.EMPTY:\n                currentBuffer().append(\"<\" + newTagName + \"/>\");\n                break;\n            default:\n                tag.writeTo(currentBuffer()); // leave as is\n        }\n    }\n}\n","lineNo":25}
{"Refactored Sample":"/*\n * IF YOU ARE HAVING TROUBLE COMPILING THIS CLASS, IT IS PROBABLY BECAUSE Lexer.java IS MISSING.\n *\n * Use 'ant jflex' to generate the file, which will reside in build/java\n */\n\npackage com.opensymphony.module.sitemesh.html.tokenizer;\n\nimport com.opensymphony.module.sitemesh.html.Tag;\nimport com.opensymphony.module.sitemesh.html.Text;\nimport com.opensymphony.module.sitemesh.html.util.CharArray;\nimport com.opensymphony.module.sitemesh.util.CharArrayReader;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Looks for patterns of tokens in the Lexer and translates these to calls to pass to the TokenHandler.\n *\n * @author Joe Walnes\n * @see TagTokenizer\n */\nclass Parser extends Lexer {\n\n    private final CharArray attributeBuffer = new CharArray(64);\n    private final ReusableToken reusableToken = new ReusableToken();\n\n    private int pushbackToken = -1;\n    private String pushbackText;\n\n    public final static short SLASH=257;\n    public final static short WHITESPACE=258;\n    public final static short EQUALS=259;\n    public final static short QUOTE=260;\n    public final static short WORD=261;\n    public final static short TEXT=262;\n    public final static short QUOTED=263;\n    public final static short LT=264;\n    public final static short GT=265;\n    public final static short LT_OPEN_MAGIC_COMMENT=266;\n    public final static short LT_CLOSE_MAGIC_COMMENT=267;\n\n    private final char[] input;\n\n    private TokenHandler handler;\n\n    private int position;\n    private int length;\n\n    private String name;\n    private int type;\n    private final List attributes = new ArrayList(); // name1, value1, name2, value2...\n\n    public Parser(char[] input, TokenHandler handler) {\n        super(new CharArrayReader(input));\n        this.input = input;\n        this.handler = handler;\n    }\n\n    private String text() {\n        if (pushbackToken == -1) {\n            return yytext();\n        } else {\n            return pushbackText;\n        }\n    }\n\n    private void skipWhiteSpace() throws IOException {\n        while (true) {\n            int next;\n            if (pushbackToken == -1) {\n                next = yylex();\n            } else {\n                next = pushbackToken;\n                pushbackToken = -1;\n            }\n            if (next != Parser.WHITESPACE) {\n                pushBack(next);\n                break;\n            }\n        }\n    }\n\n    private void pushBack(int next) {\n        if (pushbackToken != -1) {\n            reportError(\"Cannot pushback more than once\", line(), column());\n        }\n        pushbackToken = next;\n        if (next == Parser.WORD || next == Parser.QUOTED || next == Parser.SLASH || next == Parser.EQUALS) {\n            pushbackText = yytext();\n        } else {\n            pushbackText = null;\n        }\n    }\n\n    public void start() {\n        try {\n            while (true) {\n                int token;\n                if (pushbackToken == -1) {\n                    token = yylex();\n                } else {\n                    token = pushbackToken;\n                    pushbackToken = -1;\n                }\n                if (token == 0) {\n                    // EOF\n                    return;\n                } else if (token == Parser.TEXT) {\n                    // Got some text\n                    parsedText(position(), length());\n                } else if (token == Parser.LT) {\n                    // Token \"<\" - start of tag\n                    parseTag(Tag.OPEN);\n                } else if (token == Parser.LT_OPEN_MAGIC_COMMENT) {\n                    // Token \"<!--[\" - start of open magic comment\n                    parseTag(Tag.OPEN_MAGIC_COMMENT);\n                } else if (token == Parser.LT_CLOSE_MAGIC_COMMENT) {\n                    // Token \"<![\" - start of close magic comment\n                    parseTag(Tag.CLOSE_MAGIC_COMMENT);\n                } else {\n                    reportError(\"Unexpected token from lexer, was expecting TEXT or LT\", line(), column());\n                }\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private void parseTag(int type) throws IOException {\n        // Start parsing a TAG\n\n        int start = position();\n        skipWhiteSpace();\n        int token;\n        if (pushbackToken == -1) {\n            token = yylex();\n        } else {\n            token = pushbackToken;\n            pushbackToken = -1;\n        }\n        String name;\n\n        if (token == Parser.SLASH) {\n            // Token \"/\" - it's a closing tag\n            type = Tag.CLOSE;\n            if (pushbackToken == -1) {\n                token = yylex();\n            } else {\n                token = pushbackToken;\n                pushbackToken = -1;\n            }\n        }\n\n        if (token == Parser.WORD) {\n            // Token WORD - name of tag\n            name = text();\n            if (handler.shouldProcessTag(name)) {\n                parseFullTag(type, name, start);\n            } else {\n                resetLexerState();\n                pushBack(yylex()); // take and replace the next token, so the position is correct\n                parsedText(start, position() - start);\n            }\n        } else if (token == Parser.GT) {\n            // Token \">\" - an illegal <> or <  > tag. Ignore\n        } else if (token == 0) {\n            parsedText(start, position() - start); // eof\n        } else {\n            reportError(\"Could not recognise tag\", line(), column());\n        }\n    }\n\n    private void parseFullTag(int type, String name, int start) throws IOException {\n        int token;\n        while (true) {\n            skipWhiteSpace();\n            if (pushbackToken == -1) {\n                token = yylex();\n            } else {\n                token = pushbackToken;\n                pushbackToken = -1;\n            }\n            pushBack(token);\n\n            if (token == Parser.SLASH || token == Parser.GT) {\n                break; // no more attributes here\n            } else if (token == Parser.WORD) {\n                parseAttribute(); // start of an attribute\n            } else if (token == 0) {\n                parsedText(start, position() - start); // eof\n                return;\n            } else {\n                reportError(\"Illegal tag\", line(), column());\n                break;\n            }\n        }\n\n        if (pushbackToken == -1) {\n            token = yylex();\n        } else {\n            token = pushbackToken;\n            pushbackToken = -1;\n        }\n        if (token == Parser.SLASH) {\n            // Token \"/\" - it's an empty tag\n            type = Tag.EMPTY;\n            if (pushbackToken == -1) {\n                token = yylex();\n            } else {\n                token = pushbackToken;\n                pushbackToken = -1;\n            }\n        }\n\n        if (token == Parser.GT) {\n            // Token \">\" - YAY! end of tag.. process it!\n            parsedTag(type, name, start, position() - start + 1);\n        } else if (token == 0) {\n            parsedText(start, position() - start); // eof\n        } else {\n            reportError(\"Expected end of tag\", line(), column());\n            parsedTag(type, name, start, position() - start + 1);\n        }\n    }\n\n    private void parseAttribute() throws IOException {\n        int token;\n        if (pushbackToken == -1) {\n            token = yylex();\n        } else {\n            token = pushbackToken;\n            pushbackToken = -1;\n        }\n        // Token WORD - start of an attribute\n        String attributeName = text();\n        skipWhiteSpace();\n        if (pushbackToken == -1) {\n            token = yylex();\n        } else {\n            token = pushbackToken;\n            pushbackToken = -1;\n        }\n        if (token == Parser.EQUALS) {\n            // Token \"=\" - the attribute has a value\n            skipWhiteSpace();\n            if (pushbackToken == -1) {\n                token = yylex();\n            } else {\n                token = pushbackToken;\n                pushbackToken = -1;\n            }\n            if (token == Parser.QUOTED) {\n                // token QUOTED - a quoted literal as the attribute value\n                parsedAttribute(attributeName, text(), true);\n            } else if (token == Parser.WORD || token == Parser.SLASH) {\n                // unquoted word\n                attributeBuffer.clear();\n                attributeBuffer.append(text());\n                while (true) {\n                    int next;\n                    if (pushbackToken == -1) {\n                        next = yylex();\n                    } else {\n                        next = pushbackToken;\n                        pushbackToken = -1;\n                    }\n                    if (next == Parser.WORD || next == Parser.EQUALS || next == Parser.SLASH) {\n                        attributeBuffer.append(text());\n                    } else {\n                        pushBack(next);\n                        break;\n                    }\n                }\n                parsedAttribute(attributeName, attributeBuffer.toString(), false);\n            } else if (token == Parser.SLASH || token == Parser.GT) {\n                // no more attributes\n                pushBack(token);\n            } else if (token == 0) {\n                return;\n            } else {\n                reportError(\"Illegal attribute value\", line(), column());\n            }\n        } else if (token == Parser.SLASH || token == Parser.GT || token == Parser.WORD) {\n            // it was a value-less HTML style attribute\n            parsedAttribute(attributeName, null, false);\n            pushBack(token);\n        } else if (token == 0) {\n            return;\n        } else {\n            reportError(\"Illegal attribute name\", line(), column());\n        }\n    }\n\n    public void parsedText(int position, int length) {\n        this.position = position;\n        this.length = length;\n        handler.text((Text) reusableToken);\n    }\n\n    public void parsedTag(int type, String name, int start, int length) {\n        this.type = type;\n        this.name = name;\n        this.position = start;\n        this.length = length;\n        handler.tag((Tag) reusableToken);\n        attributes.clear();\n    }\n\n    public void parsedAttribute(String name, String value, boolean quoted) {\n        attributes.add(name);\n        if (quoted) {\n            attributes.add(value.substring(1, value.length() - 1));\n        } else {\n            attributes.add(value);\n        }\n    }\n\n    protected void reportError(String message, int line, int column) {\n        handler.warning(message, line, column);\n    }\n\n    private class ReusableToken implements Tag, Text {\n\n        public String getName() {\n            return name;\n        }\n\n        public int getType() {\n            return type;\n        }\n\n        public String getContents() {\n            return new String(input, position, length);\n        }\n\n        public void writeTo(CharArray out) {\n            out.append(input, position, length);\n        }\n\n        public int getAttributeCount() {\n            return attributes == null ? 0 : attributes.size() / 2;\n        }\n\n        public int getAttributeIndex(String name, boolean caseSensitive) {\n            // todo: optimize\n            if (attributes == null) {\n                return -1;\n            }\n            final int len = attributes.size();\n            for (int i = 0; i < len; i+=2) {\n                final String current = (String) attributes.get(i);\n                if (caseSensitive ? name.equals(current) : name.equalsIgnoreCase(current)) {\n                    return i / 2;\n                }\n            }\n            return -1;\n        }\n\n        public String getAttributeName(int index) {\n            return (String) attributes.get(index * 2);\n        }\n\n        public String getAttributeValue(int index) {\n            return (String) attributes.get(index * 2 + 1);\n        }\n\n        public String getAttributeValue(String name, boolean caseSensitive) {\n            int attributeIndex = getAttributeIndex(name, caseSensitive);\n            if (attributeIndex == -1) {\n                return null;\n            } else {\n                return (String) attributes.get(attributeIndex * 2 + 1);\n            }\n        }\n\n        public boolean hasAttribute(String name, boolean caseSensitive) {\n            return getAttributeIndex(name, caseSensitive) > -1;\n        }\n\n    }\n}\n","Smelly Sample":"/*\n * IF YOU ARE HAVING TROUBLE COMPILING THIS CLASS, IT IS PROBABLY BECAUSE Lexer.java IS MISSING.\n *\n * Use 'ant jflex' to generate the file, which will reside in build/java\n */\n\npackage com.opensymphony.module.sitemesh.html.tokenizer;\n\nimport com.opensymphony.module.sitemesh.html.Tag;\nimport com.opensymphony.module.sitemesh.html.Text;\nimport com.opensymphony.module.sitemesh.html.util.CharArray;\nimport com.opensymphony.module.sitemesh.util.CharArrayReader;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Looks for patterns of tokens in the Lexer and translates these to calls to pass to the TokenHandler.\n *\n * @author Joe Walnes\n * @see TagTokenizer\n */\nclass Parser extends Lexer {\n\n    private final CharArray attributeBuffer = new CharArray(64);\n    private final ReusableToken reusableToken = new ReusableToken();\n\n    private int pushbackToken = -1;\n    private String pushbackText;\n\n    public final static short SLASH=257;\n    public final static short WHITESPACE=258;\n    public final static short EQUALS=259;\n    public final static short QUOTE=260;\n    public final static short WORD=261;\n    public final static short TEXT=262;\n    public final static short QUOTED=263;\n    public final static short LT=264;\n    public final static short GT=265;\n    public final static short LT_OPEN_MAGIC_COMMENT=266;\n    public final static short LT_CLOSE_MAGIC_COMMENT=267;\n\n    private final char[] input;\n\n    private TokenHandler handler;\n\n    private int position;\n    private int length;\n\n    private String name;\n    private int type;\n    private final List attributes = new ArrayList();\n\n    public Parser(char[] input, TokenHandler handler) {\n        super(new CharArrayReader(input));\n        this.input = input;\n        this.handler = handler;\n    }\n\n    private String text() {\n        if (pushbackToken == -1) {\n            return yytext();\n        } else {\n            return pushbackText;\n        }\n    }\n\n    private void skipWhiteSpace() throws IOException {\n        while (true) {\n            int next;\n            if (pushbackToken == -1) {\n                next = yylex();\n            } else {\n                next = pushbackToken;\n                pushbackToken = -1;\n            }\n            if (next != Parser.WHITESPACE) {\n                pushBack(next);\n                break;\n            }\n        }\n    }\n\n    private void pushBack(int next) {\n        if (pushbackToken != -1) {\n            reportError(\"Cannot pushback more than once\", line(), column());\n        }\n        pushbackToken = next;\n        if (next == Parser.WORD || next == Parser.QUOTED || next == Parser.SLASH || next == Parser.EQUALS) {\n            pushbackText = yytext();\n        } else {\n            pushbackText = null;\n        }\n    }\n\n    public void start() {\n        try {\n            while (true) {\n                int token;\n                if (pushbackToken == -1) {\n                    token = yylex();\n                } else {\n                    token = pushbackToken;\n                    pushbackToken = -1;\n                }\n                if (token == 0) {\n                    // EOF\n                    return;\n                } else if (token == Parser.TEXT) {\n                    // Got some text\n                    parsedText(position(), length());\n                } else if (token == Parser.LT) {\n                    // Token \"<\" - start of tag\n                    parseTag(Tag.OPEN);\n                } else if (token == Parser.LT_OPEN_MAGIC_COMMENT) {\n                    // Token \"<!--[\" - start of open magic comment\n                    parseTag(Tag.OPEN_MAGIC_COMMENT);\n                } else if (token == Parser.LT_CLOSE_MAGIC_COMMENT) {\n                    // Token \"<![\" - start of close magic comment\n                    parseTag(Tag.CLOSE_MAGIC_COMMENT);\n                } else {\n                    reportError(\"Unexpected token from lexer, was expecting TEXT or LT\", line(), column());\n                }\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private void parseTag(int type) throws IOException {\n        // Start parsing a TAG\n\n        int start = position();\n        skipWhiteSpace();\n        int token;\n        if (pushbackToken == -1) {\n            token = yylex();\n        } else {\n            token = pushbackToken;\n            pushbackToken = -1;\n        }\n        String name;\n\n        if (token == Parser.SLASH) {\n            // Token \"/\" - it's a closing tag\n            type = Tag.CLOSE;\n            if (pushbackToken == -1) {\n                token = yylex();\n            } else {\n                token = pushbackToken;\n                pushbackToken = -1;\n            }\n        }\n\n        if (token == Parser.WORD) {\n            // Token WORD - name of tag\n            name = text();\n            if (handler.shouldProcessTag(name)) {\n                parseFullTag(type, name, start);\n            } else {\n                resetLexerState();\n                pushBack(yylex()); // take and replace the next token, so the position is correct\n                parsedText(start, position() - start);\n            }\n        } else if (token == Parser.GT) {\n            // Token \">\" - an illegal <> or <  > tag. Ignore\n        } else if (token == 0) {\n            parsedText(start, position() - start); // eof\n        } else {\n            reportError(\"Could not recognise tag\", line(), column());\n        }\n    }\n\n    private void parseFullTag(int type, String name, int start) throws IOException {\n        int token;\n        while (true) {\n            skipWhiteSpace();\n            if (pushbackToken == -1) {\n                token = yylex();\n            } else {\n                token = pushbackToken;\n                pushbackToken = -1;\n            }\n            pushBack(token);\n\n            if (token == Parser.SLASH || token == Parser.GT) {\n                break; // no more attributes here\n            } else if (token == Parser.WORD) {\n                parseAttribute(); // start of an attribute\n            } else if (token == 0) {\n                parsedText(start, position() - start); // eof\n                return;\n            } else {\n                reportError(\"Illegal tag\", line(), column());\n                break;\n            }\n        }\n\n        if (pushbackToken == -1) {\n            token = yylex();\n        } else {\n            token = pushbackToken;\n            pushbackToken = -1;\n        }\n        if (token == Parser.SLASH) {\n            // Token \"/\" - it's an empty tag\n            type = Tag.EMPTY;\n            if (pushbackToken == -1) {\n                token = yylex();\n            } else {\n                token = pushbackToken;\n                pushbackToken = -1;\n            }\n        }\n\n        if (token == Parser.GT) {\n            // Token \">\" - YAY! end of tag.. process it!\n            parsedTag(type, name, start, position() - start + 1);\n        } else if (token == 0) {\n            parsedText(start, position() - start); // eof\n        } else {\n            reportError(\"Expected end of tag\", line(), column());\n            parsedTag(type, name, start, position() - start + 1);\n        }\n    }\n\n    private void parseAttribute() throws IOException {\n        int token;\n        if (pushbackToken == -1) {\n            token = yylex();\n        } else {\n            token = pushbackToken;\n            pushbackToken = -1;\n        }\n        // Token WORD - start of an attribute\n        String attributeName = text();\n        skipWhiteSpace();\n        if (pushbackToken == -1) {\n            token = yylex();\n        } else {\n            token = pushbackToken;\n            pushbackToken = -1;\n        }\n        if (token == Parser.EQUALS) {\n            // Token \"=\" - the attribute has a value\n            skipWhiteSpace();\n            if (pushbackToken == -1) {\n                token = yylex();\n            } else {\n                token = pushbackToken;\n                pushbackToken = -1;\n            }\n            if (token == Parser.QUOTED) {\n                // token QUOTED - a quoted literal as the attribute value\n                parsedAttribute(attributeName, text(), true);\n            } else if (token == Parser.WORD || token == Parser.SLASH) {\n                // unquoted word\n                attributeBuffer.clear();\n                attributeBuffer.append(text());\n                while (true) {\n                    int next;\n                    if (pushbackToken == -1) {\n                        next = yylex();\n                    } else {\n                        next = pushbackToken;\n                        pushbackToken = -1;\n                    }\n                    if (next == Parser.WORD || next == Parser.EQUALS || next == Parser.SLASH) {\n                        attributeBuffer.append(text());\n                    } else {\n                        pushBack(next);\n                        break;\n                    }\n                }\n                parsedAttribute(attributeName, attributeBuffer.toString(), false);\n            } else if (token == Parser.SLASH || token == Parser.GT) {\n                // no more attributes\n                pushBack(token);\n            } else if (token == 0) {\n                return;\n            } else {\n                reportError(\"Illegal attribute value\", line(), column());\n            }\n        } else if (token == Parser.SLASH || token == Parser.GT || token == Parser.WORD) {\n            // it was a value-less HTML style attribute\n            parsedAttribute(attributeName, null, false);\n            pushBack(token);\n        } else if (token == 0) {\n            return;\n        } else {\n            reportError(\"Illegal attribute name\", line(), column());\n        }\n    }\n\n    public void parsedText(int position, int length) {\n        this.position = position;\n        this.length = length;\n        handler.text((Text) reusableToken);\n    }\n\n    public void parsedTag(int type, String name, int start, int length) {\n        this.type = type;\n        this.name = name;\n        this.position = start;\n        this.length = length;\n        handler.tag((Tag) reusableToken);\n        attributes.clear();\n    }\n\n    public void parsedAttribute(String name, String value, boolean quoted) {\n        attributes.add(name);\n        if (quoted) {\n            attributes.add(value.substring(1, value.length() - 1));\n        } else {\n            attributes.add(value);\n        }\n    }\n\n    protected void reportError(String message, int line, int column) {\n        handler.warning(message, line, column);\n    }\n\n    private class ReusableToken implements Tag, Text {\n\n        public String getName() {\n            return name;\n        }\n\n        public int getType() {\n            return type;\n        }\n\n        public String getContents() {\n            return new String(input, position, length);\n        }\n\n        public void writeTo(CharArray out) {\n            out.append(input, position, length);\n        }\n\n        public int getAttributeCount() {\n            return attributes == null ? 0 : attributes.size() / 2;\n        }\n\n        public int getAttributeIndex(String name, boolean caseSensitive) {\n            // todo: optimize\n            if (attributes == null) {\n                return -1;\n            }\n            final int len = attributes.size();\n            for (int i = 0; i < len; i+=2) {\n                final String current = (String) attributes.get(i);\n                if (caseSensitive ? name.equals(current) : name.equalsIgnoreCase(current)) {\n                    return i / 2;\n                }\n            }\n            return -1;\n        }\n\n        public String getAttributeName(int index) {\n            return (String) attributes.get(index * 2);\n        }\n\n        public String getAttributeValue(int index) {\n            return (String) attributes.get(index * 2 + 1);\n        }\n\n        public String getAttributeValue(String name, boolean caseSensitive) {\n            return (String) attributes.get(getAttributeIndex(name, caseSensitive) * 2 + 1);\n        }\n\n        public boolean hasAttribute(String name, boolean caseSensitive) {\n            return getAttributeIndex(name, caseSensitive) > -1;\n        }\n\n    }\n}\n","lineNo":370}
{"Refactored Sample":"package com.opensymphony.module.sitemesh.parser;\n\nimport com.opensymphony.module.sitemesh.HTMLPage;\nimport com.opensymphony.module.sitemesh.Page;\nimport com.opensymphony.module.sitemesh.PageParser;\nimport com.opensymphony.module.sitemesh.html.HTMLProcessor;\nimport com.opensymphony.module.sitemesh.html.State;\nimport com.opensymphony.module.sitemesh.html.StateTransitionRule;\nimport com.opensymphony.module.sitemesh.html.tokenizer.TagTokenizer;\nimport com.opensymphony.module.sitemesh.html.util.CharArray;\nimport com.opensymphony.module.sitemesh.parser.rules.BodyTagRule;\nimport com.opensymphony.module.sitemesh.parser.rules.ContentBlockExtractingRule;\nimport com.opensymphony.module.sitemesh.parser.rules.FramesetRule;\nimport com.opensymphony.module.sitemesh.parser.rules.HeadExtractingRule;\nimport com.opensymphony.module.sitemesh.parser.rules.HtmlAttributesRule;\nimport com.opensymphony.module.sitemesh.parser.rules.MSOfficeDocumentPropertiesRule;\nimport com.opensymphony.module.sitemesh.parser.rules.MetaTagRule;\nimport com.opensymphony.module.sitemesh.parser.rules.ParameterExtractingRule;\nimport com.opensymphony.module.sitemesh.parser.rules.TitleExtractingRule;\n\nimport java.io.IOException;\n\n/**\n * <b>WARNING - This is experimental - use at own risk!<\/b> Builds an HTMLPage object from an HTML document. This behaves\n * similarly to the FastPageParser, however it's a complete rewrite that is simpler to add custom features to such as\n * extraction and transformation of elements.\n *\n * @see TagTokenizer\n *\n * @author Joe Walnes\n */\npublic class HTMLPageParser implements PageParser {\n\n    public Page parse(char[] data) throws IOException {\n        CharArray head = new CharArray(64);\n        CharArray body = new CharArray(4096);\n\n        HTMLPage page = new TokenizedHTMLPage(data, body, head);\n\n        HTMLProcessor htmlProcessor = new HTMLProcessor(data, body);\n\n        State defaultState = htmlProcessor.defaultState();\n        State xmlState = new State();\n\n        defaultState.addRule(\"html\", new HtmlAttributesRule(page));\n        defaultState.addRule(\"head\", new HeadExtractingRule(head));\n        defaultState.addRule(\"meta\", new MetaTagRule(page));\n        defaultState.addRule(\"title\", new TitleExtractingRule(page));\n        defaultState.addRule(\"body\", new BodyTagRule(page, body));\n        defaultState.addRule(\"parameter\", new ParameterExtractingRule(page));\n        defaultState.addRule(\"content\", new ContentBlockExtractingRule(page));\n        defaultState.addRule(\"frame\", new FramesetRule(page));\n        defaultState.addRule(\"frameset\", new FramesetRule(page));\n        defaultState.addRule(\"xml\", new StateTransitionRule(xmlState, true));\n        defaultState.addRule(\"o:DocumentProperties\", new MSOfficeDocumentPropertiesRule(page));\n\n\n        // extended rules\n\n        htmlProcessor.process();\n\n        return page;\n    }\n\n}\n","Smelly Sample":"package com.opensymphony.module.sitemesh.parser;\n\nimport com.opensymphony.module.sitemesh.Page;\nimport com.opensymphony.module.sitemesh.PageParser;\nimport com.opensymphony.module.sitemesh.HTMLPage;\nimport com.opensymphony.module.sitemesh.html.HTMLProcessor;\nimport com.opensymphony.module.sitemesh.parser.rules.BodyTagRule;\nimport com.opensymphony.module.sitemesh.parser.rules.ContentBlockExtractingRule;\nimport com.opensymphony.module.sitemesh.parser.rules.FramesetRule;\nimport com.opensymphony.module.sitemesh.parser.rules.HeadExtractingRule;\nimport com.opensymphony.module.sitemesh.parser.rules.HtmlAttributesRule;\nimport com.opensymphony.module.sitemesh.parser.rules.MetaTagRule;\nimport com.opensymphony.module.sitemesh.parser.rules.ParameterExtractingRule;\nimport com.opensymphony.module.sitemesh.parser.rules.TitleExtractingRule;\nimport com.opensymphony.module.sitemesh.html.tokenizer.TagTokenizer;\nimport com.opensymphony.module.sitemesh.html.util.BufferStack;\nimport com.opensymphony.module.sitemesh.html.util.CharArray;\n\nimport java.io.IOException;\n\n/**\n * <b>WARNING - This is experimental - use at own risk!<\/b> Builds an HTMLPage object from an HTML document. This behaves\n * similarly to the FastPageParser, however it's a complete rewrite that is simpler to add custom features to such as\n * extraction and transformation of elements.\n *\n * @see TagTokenizer\n *\n * @author Joe Walnes\n */\npublic class HTMLPageParser implements PageParser {\n\n    public Page parse(char[] data) throws IOException {\n        CharArray head = new CharArray(64);\n        CharArray body = new CharArray(4096);\n\n        HTMLPage page = new TokenizedHTMLPage(data, body, head);\n\n        BufferStack bufferStack = new BufferStack();\n        bufferStack.pushBuffer(body);\n\n        HTMLProcessor htmlProcessor = new HTMLProcessor(data, bufferStack);\n        htmlProcessor.addRule(\"html\", new HtmlAttributesRule(page));\n        htmlProcessor.addRule(\"head\", new HeadExtractingRule(head));\n        htmlProcessor.addRule(\"meta\", new MetaTagRule(page));\n        htmlProcessor.addRule(\"title\", new TitleExtractingRule(page));\n        htmlProcessor.addRule(\"body\", new BodyTagRule(page, body));\n        htmlProcessor.addRule(\"parameter\", new ParameterExtractingRule(page));\n        htmlProcessor.addRule(\"content\", new ContentBlockExtractingRule(page));\n        htmlProcessor.addRule(\"frame\", new FramesetRule(page));\n        htmlProcessor.addRule(\"frameset\", new FramesetRule(page));\n\n        htmlProcessor.process();\n\n        return page;\n    }\n\n}\n","lineNo":42}
{"Refactored Sample":"/*\n * Title:        DefaultFactory\n * Description:\n *\n * This software is published under the terms of the OpenSymphony Software\n * License version 1.1, of which a copy has been included with this\n * distribution in the LICENSE.txt file.\n */\n\npackage com.opensymphony.module.sitemesh.factory;\n\nimport com.opensymphony.module.sitemesh.Config;\nimport com.opensymphony.module.sitemesh.DecoratorMapper;\nimport com.opensymphony.module.sitemesh.PageParser;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.Text;\nimport org.xml.sax.SAXException;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\n\n/**\n * DefaultFactory, reads configuration from <code>/WEB-INF/sitemesh.xml<\/code>, or uses the\n * default configuration if <code>sitemesh.xml<\/code> does not exist.\n *\n * @author <a href=\"mailto:joe@truemesh.com\">Joe Walnes<\/a>\n * @author <a href=\"mailto:pathos@pandora.be\">Mathias Bogaert<\/a>\n * @version $Revision: 1.3 $\n */\npublic class DefaultFactory extends BaseFactory {\n    String configFileName = \"/WEB-INF/sitemesh.xml\";\n    File configFile;\n    long configLastModified;\n    Map configProps = new HashMap();\n\n    String excludesFileName;\n    File excludesFile;\n\n    public DefaultFactory(Config config) {\n        super(config);\n\n        // configFilePath is null if loaded from war file\n        String configFilePath = config.getServletContext().getRealPath(configFileName);\n\n        if (configFilePath != null) { // disable config auto reloading for .war files\n            configFile = new File(configFilePath);\n        }\n\n        loadConfig();\n    }\n\n    /** Refresh config before delegating to superclass. */\n    public DecoratorMapper getDecoratorMapper() {\n        refresh();\n        return super.getDecoratorMapper();\n    }\n\n    /** Refresh config before delegating to superclass. */\n    public PageParser getPageParser(String contentType) {\n        refresh();\n        return super.getPageParser(contentType);\n    }\n\n    /** Refresh config before delegating to superclass. */\n    public boolean shouldParsePage(String contentType) {\n        refresh();\n        return super.shouldParsePage(contentType);\n    }\n\n    /**\n     * Returns <code>true<\/code> if the supplied path matches one of the exclude\n     * URLs specified in sitemesh.xml, otherwise returns <code>false<\/code>. This\n     * method refreshes the config before delgating to the superclass.\n     */\n    public boolean isPathExcluded(String path) {\n        refresh();\n        return super.isPathExcluded(path);\n    }\n\n    /** Load configuration from file. */\n    private synchronized void loadConfig() {\n        try {\n            // Load and parse the sitemesh.xml file\n            Element root = loadSitemeshXML();\n\n            NodeList sections = root.getChildNodes();\n            // Loop through child elements of root node\n            for (int i = 0; i < sections.getLength(); i++) {\n                if (sections.item(i) instanceof Element) {\n                    Element curr = (Element)sections.item(i);\n                    NodeList children = curr.getChildNodes();\n\n                    if (\"property\".equalsIgnoreCase(curr.getTagName())) {\n                        String name = curr.getAttribute(\"name\");\n                        String value = curr.getAttribute(\"value\");\n                        if (!\"\".equals(name) && !\"\".equals(value)) {\n                            configProps.put(\"${\" + name + \"}\", value);\n                        }\n                    }\n                    else if (\"page-parsers\".equalsIgnoreCase(curr.getTagName())) {\n                        // handle <page-parsers>\n                        loadPageParsers(children);\n                    }\n                    else if (\"decorator-mappers\".equalsIgnoreCase(curr.getTagName())) {\n                        // handle <decorator-mappers>\n                        loadDecoratorMappers(children);\n                    }\n                    else if (\"excludes\".equalsIgnoreCase(curr.getTagName())) {\n                        // handle <excludes>\n                        String fileName = replaceProperties(curr.getAttribute(\"file\"));\n                        if (!\"\".equals(fileName)) {\n                            excludesFileName = fileName;\n                            loadExcludes();\n                        }\n                    }\n                }\n            }\n        }\n        catch (ParserConfigurationException e) {\n            report(\"Could not get XML parser\", e);\n        }\n        catch (IOException e) {\n            report(\"Could not read config file : \" + configFileName, e);\n        }\n        catch (SAXException e) {\n            report(\"Could not parse config file : \" + configFileName, e);\n        }\n    }\n\n    private Element loadSitemeshXML()\n            throws ParserConfigurationException, IOException, SAXException\n    {\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        DocumentBuilder builder = factory.newDocumentBuilder();\n\n        InputStream is = null;\n\n        if (configFile == null) {\n            is = config.getServletContext().getResourceAsStream(configFileName);\n        }\n        else if (configFile.exists() && configFile.canRead()) {\n            is = configFile.toURL().openStream();\n        }\n\n        if (is == null){ // load the default sitemesh configuration\n            is = getClass().getClassLoader().getResourceAsStream(\"com/opensymphony/module/sitemesh/factory/sitemesh-default.xml\");\n        }\n\n        if (is == null){ // load the default sitemesh configuration using another classloader\n            is = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"com/opensymphony/module/sitemesh/factory/sitemesh-default.xml\");\n        }\n\n        if (is == null){\n            throw new IllegalStateException(\"Cannot load default configuration from jar\");\n        }\n\n        if (configFile != null) configLastModified = configFile.lastModified();\n\n        Document doc = builder.parse(is);\n        Element root = doc.getDocumentElement();\n        // Verify root element\n        if (!\"sitemesh\".equalsIgnoreCase(root.getTagName())) {\n            report(\"Root element of sitemesh configuration file not <sitemesh>\", null);\n        }\n        return root;\n    }\n\n    private void loadExcludes()\n            throws ParserConfigurationException, IOException, SAXException\n    {\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        DocumentBuilder builder = factory.newDocumentBuilder();\n\n        InputStream is = null;\n\n        if (excludesFile == null) {\n            is = config.getServletContext().getResourceAsStream(excludesFileName);\n        }\n        else if (excludesFile.exists() && excludesFile.canRead()) {\n            is = excludesFile.toURL().openStream();\n        }\n\n        if (is == null){\n            throw new IllegalStateException(\"Cannot load excludes configuration file from jar\");\n        }\n\n        Document document = builder.parse(is);\n        Element root = document.getDocumentElement();\n        NodeList sections = root.getChildNodes();\n\n        // Loop through child elements of root node looking for the <excludes> block\n        for (int i = 0; i < sections.getLength(); i++) {\n            if (sections.item(i) instanceof Element) {\n                Element curr = (Element)sections.item(i);\n                if (\"excludes\".equalsIgnoreCase(curr.getTagName())) {\n                    loadExcludeUrls(curr.getChildNodes());\n                }\n            }\n        }\n    }\n\n    /** Loop through children of 'page-parsers' element and add all 'parser' mappings. */\n    private void loadPageParsers(NodeList nodes) {\n        clearParserMappings();\n        for (int i = 0; i < nodes.getLength(); i++) {\n            if (nodes.item(i) instanceof Element) {\n                Element curr = (Element)nodes.item(i);\n\n                if (\"parser\".equalsIgnoreCase(curr.getTagName())) {\n                    String className = curr.getAttribute(\"class\");\n                    String contentType = curr.getAttribute(\"content-type\");\n                    mapParser(contentType, className);\n                }\n            }\n        }\n    }\n\n    private void loadDecoratorMappers(NodeList nodes) {\n        clearDecoratorMappers();\n        Properties emptyProps = new Properties();\n\n        pushDecoratorMapper(\"com.opensymphony.module.sitemesh.mapper.NullDecoratorMapper\", emptyProps);\n\n        // note, this works from the bottom node up.\n        for (int i = nodes.getLength() - 1; i > 0; i--) {\n            if (nodes.item(i) instanceof Element) {\n                Element curr = (Element)nodes.item(i);\n                if (\"mapper\".equalsIgnoreCase(curr.getTagName())) {\n                    String className = curr.getAttribute(\"class\");\n                    Properties props = new Properties();\n                    // build properties from <param> tags.\n                    NodeList children = curr.getChildNodes();\n                    for (int j = 0; j < children.getLength(); j++) {\n                        if (children.item(j) instanceof Element) {\n                            Element currC = (Element)children.item(j);\n                            if (\"param\".equalsIgnoreCase(currC.getTagName())) {\n                                String value = currC.getAttribute(\"value\");\n                                props.put(currC.getAttribute(\"name\"), replaceProperties(value));\n                            }\n                        }\n                    }\n                    // add mapper\n                    pushDecoratorMapper(className, props);\n                }\n            }\n        }\n\n        pushDecoratorMapper(\"com.opensymphony.module.sitemesh.mapper.InlineDecoratorMapper\", emptyProps);\n    }\n\n    /**\n     * Reads in all the url patterns to exclude from decoration.\n     */\n    private void loadExcludeUrls(NodeList nodes) {\n        clearExcludeUrls();\n        for (int i = 0; i < nodes.getLength(); i++) {\n            if (nodes.item(i) instanceof Element) {\n                Element p = (Element) nodes.item(i);\n                if (\"pattern\".equalsIgnoreCase(p.getTagName()) || \"url-pattern\".equalsIgnoreCase(p.getTagName())) {\n                    Text patternText = (Text) p.getFirstChild();\n                    if (patternText != null) {\n                        String pattern = patternText.getData().trim();\n                        if (pattern != null) {\n                            addExcludeUrl(pattern);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /** Check if configuration file has been modified, and if so reload it. */\n    private void refresh() {\n        if (configFile != null && configLastModified != configFile.lastModified()) loadConfig();\n    }\n\n    /**\n     * Replaces any properties that appear in the supplied string\n     * with their actual values\n     *\n     * @param str the string to replace the properties in\n     * @return the same string but with any properties expanded out to their\n     * actual values\n     */\n    private String replaceProperties(String str) {\n        Set props = configProps.entrySet();\n        for (Iterator it = props.iterator(); it.hasNext();)\n        {\n            Map.Entry entry = (Map.Entry) it.next();\n            String key = (String) entry.getKey();\n            int idx;\n            while ((idx = str.indexOf(key)) >= 0) {\n                StringBuffer buf = new StringBuffer(100);\n                buf.append(str.substring(0, idx));\n                buf.append(entry.getValue());\n                buf.append(str.substring(idx + key.length()));\n                str = buf.toString();\n            }\n        }\n        return str;\n    }\n}\n","Smelly Sample":"/*\n * Title:        DefaultFactory\n * Description:\n *\n * This software is published under the terms of the OpenSymphony Software\n * License version 1.1, of which a copy has been included with this\n * distribution in the LICENSE.txt file.\n */\n\npackage com.opensymphony.module.sitemesh.factory;\n\nimport com.opensymphony.module.sitemesh.Config;\nimport com.opensymphony.module.sitemesh.DecoratorMapper;\nimport com.opensymphony.module.sitemesh.PageParser;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.Text;\nimport org.xml.sax.SAXException;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Properties;\n\n/**\n * DefaultFactory, reads configuration from <code>/WEB-INF/sitemesh.xml<\/code>, or uses the\n * default configuration if <code>sitemesh.xml<\/code> does not exist.\n *\n * @author <a href=\"mailto:joe@truemesh.com\">Joe Walnes<\/a>\n * @author <a href=\"mailto:pathos@pandora.be\">Mathias Bogaert<\/a>\n * @version $Revision: 1.2 $\n */\npublic class DefaultFactory extends BaseFactory {\n    String configFileName = \"/WEB-INF/sitemesh.xml\";\n    File configFile;\n    long configLastModified;\n\n    public DefaultFactory(Config config) {\n        super(config);\n\n        // configFilePath is null if loaded from war file\n        String configFilePath = config.getServletContext().getRealPath(configFileName);\n\n        if (configFilePath != null) { // disable config auto reloading for .war files\n            configFile = new File(configFilePath);\n        }\n\n        loadConfig();\n    }\n\n    /** Refresh config before delegating to superclass. */\n    public DecoratorMapper getDecoratorMapper() {\n        refresh();\n        return super.getDecoratorMapper();\n    }\n\n    /** Refresh config before delegating to superclass. */\n    public PageParser getPageParser(String contentType) {\n        refresh();\n        return super.getPageParser(contentType);\n    }\n\n    /** Refresh config before delegating to superclass. */\n    public boolean shouldParsePage(String contentType) {\n        refresh();\n        return super.shouldParsePage(contentType);\n    }\n\n    /**\n     * Returns <code>true<\/code> if the supplied path matches one of the exclude\n     * URLs specified in sitemesh.xml, otherwise returns <code>false<\/code>. This\n     * method refreshes the config before delgating to the superclass.\n     */\n    public boolean isPathExcluded(String path) {\n        refresh();\n        return super.isPathExcluded(path);\n    }\n\n    /** Load configuration from file. */\n    private synchronized void loadConfig() {\n        try {\n            // Parse file\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n\n            InputStream is = null;\n\n            if (configFile == null) {\n                is = config.getServletContext().getResourceAsStream(configFileName);\n            }\n            else if (configFile.exists() && configFile.canRead()) {\n                is = configFile.toURL().openStream();\n            }\n\n            if (is == null){ // load the default sitemesh configuration\n                is = getClass().getClassLoader().getResourceAsStream(\"com/opensymphony/module/sitemesh/factory/sitemesh-default.xml\");\n            }\n\n            if (is == null){ // load the default sitemesh configuration using another classloader\n                is = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"com/opensymphony/module/sitemesh/factory/sitemesh-default.xml\");\n            }\n\n            if (is == null){\n                throw new IllegalStateException(\"Cannot load default configuration from jar\");\n            }\n\n            Document document = builder.parse(is);\n            Element root = document.getDocumentElement();\n\n            if (configFile != null) configLastModified = configFile.lastModified();\n\n            // Verify root element\n            if (!\"sitemesh\".equalsIgnoreCase(root.getTagName())) {\n                report(\"Root element of sitemesh configuration file not <sitemesh>\", null);\n            }\n            NodeList sections = root.getChildNodes();\n            // Loop through child elements of root node\n            for (int i = 0; i < sections.getLength(); i++) {\n                if (sections.item(i) instanceof Element) {\n                    Element curr = (Element)sections.item(i);\n                    NodeList children = curr.getChildNodes();\n\n                    if (\"page-parsers\".equalsIgnoreCase(curr.getTagName())) {\n                        // handle <page-parsers>\n                        loadPageParsers(children);\n                    }\n                    else if (\"decorator-mappers\".equalsIgnoreCase(curr.getTagName())) {\n                        // handle <decorator-mappers>\n                        loadDecoratorMappers(children);\n                    }\n                    else if (\"excludes\".equalsIgnoreCase(curr.getTagName())) {\n                        // handle <excludes>\n                        loadExcludeUrls(children);\n                    }\n                }\n            }\n        }\n        catch (ParserConfigurationException e) {\n            report(\"Could not get XML parser\", e);\n        }\n        catch (IOException e) {\n            report(\"Could not read config file : \" + configFileName, e);\n        }\n        catch (SAXException e) {\n            report(\"Could not parse config file : \" + configFileName, e);\n        }\n    }\n\n    /** Loop through children of 'page-parsers' element and add all 'parser' mappings. */\n    private void loadPageParsers(NodeList nodes) {\n        clearParserMappings();\n        for (int i = 0; i < nodes.getLength(); i++) {\n            if (nodes.item(i) instanceof Element) {\n                Element curr = (Element)nodes.item(i);\n\n                if (\"parser\".equalsIgnoreCase(curr.getTagName())) {\n                    String className = curr.getAttribute(\"class\");\n                    String contentType = curr.getAttribute(\"content-type\");\n                    mapParser(contentType, className);\n                }\n            }\n        }\n    }\n\n    private void loadDecoratorMappers(NodeList nodes) {\n        clearDecoratorMappers();\n        Properties emptyProps = new Properties();\n\n        pushDecoratorMapper(\"com.opensymphony.module.sitemesh.mapper.NullDecoratorMapper\", emptyProps);\n\n        // note, this works from the bottom node up.\n        for (int i = nodes.getLength() - 1; i > 0; i--) {\n            if (nodes.item(i) instanceof Element) {\n                Element curr = (Element)nodes.item(i);\n                if (\"mapper\".equalsIgnoreCase(curr.getTagName())) {\n                    String className = curr.getAttribute(\"class\");\n                    Properties props = new Properties();\n                    // build properties from <param> tags.\n                    NodeList children = curr.getChildNodes();\n                    for (int j = 0; j < children.getLength(); j++) {\n                        if (children.item(j) instanceof Element) {\n                            Element currC = (Element)children.item(j);\n                            if (\"param\".equalsIgnoreCase(currC.getTagName())) {\n                                props.put(currC.getAttribute(\"name\"), currC.getAttribute(\"value\"));\n                            }\n                        }\n                    }\n                    // add mapper\n                    pushDecoratorMapper(className, props);\n                }\n            }\n        }\n\n        pushDecoratorMapper(\"com.opensymphony.module.sitemesh.mapper.InlineDecoratorMapper\", emptyProps);\n    }\n\n    /**\n     * Reads in all the url patterns to exclude from decoration.\n     */\n    private void loadExcludeUrls(NodeList nodes) {\n        clearExcludeUrls();\n        for (int i = 0; i < nodes.getLength(); i++) {\n            if (nodes.item(i) instanceof Element) {\n                Element p = (Element) nodes.item(i);\n                if (\"pattern\".equalsIgnoreCase(p.getTagName()) || \"url-pattern\".equalsIgnoreCase(p.getTagName())) {\n                    Text patternText = (Text) p.getFirstChild();\n                    if (patternText != null) {\n                        String pattern = patternText.getData().trim();\n                        if (pattern != null) {\n                            addExcludeUrl(pattern);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /** Check if configuration file has been modified, and if so reload it. */\n    private void refresh() {\n        if (configFile != null && configLastModified != configFile.lastModified()) loadConfig();\n    }\n}\n","lineNo":245}
{"Refactored Sample":"package testsuite.sitemesh;\n\nimport com.meterware.httpunit.WebResponse;\nimport testsuite.tester.WebTest;\n\nimport java.io.IOException;\n\nimport org.xml.sax.SAXException;\n\npublic class ContentLengthTest extends WebTest {\n\n    public void testCompleteContentFromUndecoratedPageUsingWriter() throws Exception {\n        WebResponse rs = wc.getResponse(server.getBaseURL() + \"/outputservlet?out=writer\");\n        assertTrue(\"Document is not complete: \" + rs.getText(), rs.getText().trim().endsWith(\"<\/html>\"));\n    }\n\n    public void testCompleteContentFromUndecoratedPageUsingStream() throws Exception {\n        WebResponse rs = wc.getResponse(server.getBaseURL() + \"/outputservlet?out=stream\");\n        assertTrue(\"Document is not complete: \" + rs.getText(), rs.getText().trim().endsWith(\"<\/html>\"));\n    }\n\n    public void testContentMatchesContentLengthUsingWriter() throws Exception {\n        _testContentLength(\"/outputservlet?out=writer\");\n    }\n\n    public void testContentMatchesContentLengthUsingStream() throws Exception {\n        _testContentLength(\"/outputservlet?out=stream\");\n    }\n\n     private void _testContentLength(String url) throws IOException, SAXException {\n        WebResponse rs = wc.getResponse(server.getBaseURL() + url);\n        final String contentLengthHeader = rs.getHeaderField(\"Content-length\");\n        if (contentLengthHeader != null) {\n            final String contentLength = String.valueOf(rs.getText().getBytes().length);\n            assertEquals(\"Content Length Header was '\" + contentLengthHeader + \"' but content length was '\" + contentLength + \"'\",\n                    contentLengthHeader, contentLength);\n        }\n    }\n\n}\n","Smelly Sample":"package testsuite.sitemesh;\n\nimport com.meterware.httpunit.WebResponse;\nimport testsuite.tester.WebTest;\n\npublic class ContentLengthTest extends WebTest {\n\n    /**\n     * This seems to fail in Weblogic 7.0 SP4.  I have debugged the code, and can't see what the problem is. - SF 15/July/04\n     */\n    public void testCompleteContentFromUndecoratedPageUsingWriter() throws Exception {\n        WebResponse rs = wc.getResponse(server.getBaseURL() + \"/outputservlet?out=writer\");\n        assertTrue(\"Document is not complete: \" + rs.getText(), rs.getText().trim().endsWith(\"<\/html>\"));\n    }\n\n    public void testCompleteContentFromUndecoratedPageUsingStream() throws Exception {\n        WebResponse rs = wc.getResponse(server.getBaseURL() + \"/outputservlet?out=stream\");\n        assertTrue(\"Document is not complete: \" + rs.getText(), rs.getText().trim().endsWith(\"<\/html>\"));\n    }\n\n    public void testContentMatchesContentLengthUsingWriter() throws Exception {\n        WebResponse rs = wc.getResponse(server.getBaseURL() + \"/outputservlet?out=writer\");\n        if (rs.getHeaderField(\"Content-length\") != null) {\n            assertEquals(rs.getHeaderField(\"Content-length\"), String.valueOf(rs.getText().getBytes().length));\n        }\n    }\n\n    public void testContentMatchesContentLengthUsingStream() throws Exception {\n        WebResponse rs = wc.getResponse(server.getBaseURL() + \"/outputservlet?out=stream\");\n        if (rs.getHeaderField(\"Content-length\") != null) {\n            assertEquals(rs.getHeaderField(\"Content-length\"), String.valueOf(rs.getText().getBytes().length));\n        }\n    }\n\n}\n","lineNo":34}
{"Refactored Sample":"package testsuite.sitemesh;\n\nimport com.meterware.httpunit.WebResponse;\nimport testsuite.tester.WebTest;\n\nimport java.io.IOException;\n\nimport org.xml.sax.SAXException;\n\npublic class ContentLengthTest extends WebTest {\n\n    public void testCompleteContentFromUndecoratedPageUsingWriter() throws Exception {\n        WebResponse rs = wc.getResponse(server.getBaseURL() + \"/outputservlet?out=writer\");\n        assertTrue(\"Document is not complete: \" + rs.getText(), rs.getText().trim().endsWith(\"<\/html>\"));\n    }\n\n    public void testCompleteContentFromUndecoratedPageUsingStream() throws Exception {\n        WebResponse rs = wc.getResponse(server.getBaseURL() + \"/outputservlet?out=stream\");\n        assertTrue(\"Document is not complete: \" + rs.getText(), rs.getText().trim().endsWith(\"<\/html>\"));\n    }\n\n    public void testContentMatchesContentLengthUsingWriter() throws Exception {\n        _testContentLength(\"/outputservlet?out=writer\");\n    }\n\n    public void testContentMatchesContentLengthUsingStream() throws Exception {\n        _testContentLength(\"/outputservlet?out=stream\");\n    }\n\n     private void _testContentLength(String url) throws IOException, SAXException {\n        WebResponse rs = wc.getResponse(server.getBaseURL() + url);\n        final String contentLengthHeader = rs.getHeaderField(\"Content-length\");\n        if (contentLengthHeader != null) {\n            final String contentLength = String.valueOf(rs.getText().getBytes().length);\n            assertEquals(\"Content Length Header was '\" + contentLengthHeader + \"' but content length was '\" + contentLength + \"'\",\n                    contentLengthHeader, contentLength);\n        }\n    }\n\n}\n","Smelly Sample":"package testsuite.sitemesh;\n\nimport com.meterware.httpunit.WebResponse;\nimport testsuite.tester.WebTest;\n\npublic class ContentLengthTest extends WebTest {\n\n    /**\n     * This seems to fail in Weblogic 7.0 SP4.  I have debugged the code, and can't see what the problem is. - SF 15/July/04\n     */\n    public void testCompleteContentFromUndecoratedPageUsingWriter() throws Exception {\n        WebResponse rs = wc.getResponse(server.getBaseURL() + \"/outputservlet?out=writer\");\n        assertTrue(\"Document is not complete: \" + rs.getText(), rs.getText().trim().endsWith(\"<\/html>\"));\n    }\n\n    public void testCompleteContentFromUndecoratedPageUsingStream() throws Exception {\n        WebResponse rs = wc.getResponse(server.getBaseURL() + \"/outputservlet?out=stream\");\n        assertTrue(\"Document is not complete: \" + rs.getText(), rs.getText().trim().endsWith(\"<\/html>\"));\n    }\n\n    public void testContentMatchesContentLengthUsingWriter() throws Exception {\n        WebResponse rs = wc.getResponse(server.getBaseURL() + \"/outputservlet?out=writer\");\n        if (rs.getHeaderField(\"Content-length\") != null) {\n            assertEquals(rs.getHeaderField(\"Content-length\"), String.valueOf(rs.getText().getBytes().length));\n        }\n    }\n\n    public void testContentMatchesContentLengthUsingStream() throws Exception {\n        WebResponse rs = wc.getResponse(server.getBaseURL() + \"/outputservlet?out=stream\");\n        if (rs.getHeaderField(\"Content-length\") != null) {\n            assertEquals(rs.getHeaderField(\"Content-length\"), String.valueOf(rs.getText().getBytes().length));\n        }\n    }\n\n}\n","lineNo":34}
{"Refactored Sample":"package testsuite.sitemesh;\n\nimport com.meterware.httpunit.WebResponse;\nimport testsuite.tester.WebTest;\n\nimport java.io.IOException;\n\nimport org.xml.sax.SAXException;\n\npublic class ContentLengthTest extends WebTest {\n\n    public void testCompleteContentFromUndecoratedPageUsingWriter() throws Exception {\n        WebResponse rs = wc.getResponse(server.getBaseURL() + \"/outputservlet?out=writer\");\n        assertTrue(\"Document is not complete: \" + rs.getText(), rs.getText().trim().endsWith(\"<\/html>\"));\n    }\n\n    public void testCompleteContentFromUndecoratedPageUsingStream() throws Exception {\n        WebResponse rs = wc.getResponse(server.getBaseURL() + \"/outputservlet?out=stream\");\n        assertTrue(\"Document is not complete: \" + rs.getText(), rs.getText().trim().endsWith(\"<\/html>\"));\n    }\n\n    public void testContentMatchesContentLengthUsingWriter() throws Exception {\n        _testContentLength(\"/outputservlet?out=writer\");\n    }\n\n    public void testContentMatchesContentLengthUsingStream() throws Exception {\n        _testContentLength(\"/outputservlet?out=stream\");\n    }\n\n     private void _testContentLength(String url) throws IOException, SAXException {\n        WebResponse rs = wc.getResponse(server.getBaseURL() + url);\n        final String contentLengthHeader = rs.getHeaderField(\"Content-length\");\n        if (contentLengthHeader != null) {\n            final String contentLength = String.valueOf(rs.getText().getBytes().length);\n            assertEquals(\"Content Length Header was '\" + contentLengthHeader + \"' but content length was '\" + contentLength + \"'\",\n                    contentLengthHeader, contentLength);\n        }\n    }\n\n}\n","Smelly Sample":"package testsuite.sitemesh;\n\nimport com.meterware.httpunit.WebResponse;\nimport testsuite.tester.WebTest;\n\npublic class ContentLengthTest extends WebTest {\n\n    /**\n     * This seems to fail in Weblogic 7.0 SP4.  I have debugged the code, and can't see what the problem is. - SF 15/July/04\n     */\n    public void testCompleteContentFromUndecoratedPageUsingWriter() throws Exception {\n        WebResponse rs = wc.getResponse(server.getBaseURL() + \"/outputservlet?out=writer\");\n        assertTrue(\"Document is not complete: \" + rs.getText(), rs.getText().trim().endsWith(\"<\/html>\"));\n    }\n\n    public void testCompleteContentFromUndecoratedPageUsingStream() throws Exception {\n        WebResponse rs = wc.getResponse(server.getBaseURL() + \"/outputservlet?out=stream\");\n        assertTrue(\"Document is not complete: \" + rs.getText(), rs.getText().trim().endsWith(\"<\/html>\"));\n    }\n\n    public void testContentMatchesContentLengthUsingWriter() throws Exception {\n        WebResponse rs = wc.getResponse(server.getBaseURL() + \"/outputservlet?out=writer\");\n        if (rs.getHeaderField(\"Content-length\") != null) {\n            assertEquals(rs.getHeaderField(\"Content-length\"), String.valueOf(rs.getText().getBytes().length));\n        }\n    }\n\n    public void testContentMatchesContentLengthUsingStream() throws Exception {\n        WebResponse rs = wc.getResponse(server.getBaseURL() + \"/outputservlet?out=stream\");\n        if (rs.getHeaderField(\"Content-length\") != null) {\n            assertEquals(rs.getHeaderField(\"Content-length\"), String.valueOf(rs.getText().getBytes().length));\n        }\n    }\n\n}\n","lineNo":32}
{"Refactored Sample":"package testsuite.sitemesh;\n\nimport com.meterware.httpunit.WebResponse;\nimport testsuite.tester.WebTest;\n\nimport java.io.IOException;\n\nimport org.xml.sax.SAXException;\n\npublic class ContentLengthTest extends WebTest {\n\n    public void testCompleteContentFromUndecoratedPageUsingWriter() throws Exception {\n        WebResponse rs = wc.getResponse(server.getBaseURL() + \"/outputservlet?out=writer\");\n        assertTrue(\"Document is not complete: \" + rs.getText(), rs.getText().trim().endsWith(\"<\/html>\"));\n    }\n\n    public void testCompleteContentFromUndecoratedPageUsingStream() throws Exception {\n        WebResponse rs = wc.getResponse(server.getBaseURL() + \"/outputservlet?out=stream\");\n        assertTrue(\"Document is not complete: \" + rs.getText(), rs.getText().trim().endsWith(\"<\/html>\"));\n    }\n\n    public void testContentMatchesContentLengthUsingWriter() throws Exception {\n        _testContentLength(\"/outputservlet?out=writer\");\n    }\n\n    public void testContentMatchesContentLengthUsingStream() throws Exception {\n        _testContentLength(\"/outputservlet?out=stream\");\n    }\n\n     private void _testContentLength(String url) throws IOException, SAXException {\n        WebResponse rs = wc.getResponse(server.getBaseURL() + url);\n        final String contentLengthHeader = rs.getHeaderField(\"Content-length\");\n        if (contentLengthHeader != null) {\n            final String contentLength = String.valueOf(rs.getText().getBytes().length);\n            assertEquals(\"Content Length Header was '\" + contentLengthHeader + \"' but content length was '\" + contentLength + \"'\",\n                    contentLengthHeader, contentLength);\n        }\n    }\n\n}\n","Smelly Sample":"package testsuite.sitemesh;\n\nimport com.meterware.httpunit.WebResponse;\nimport testsuite.tester.WebTest;\n\npublic class ContentLengthTest extends WebTest {\n\n    /**\n     * This seems to fail in Weblogic 7.0 SP4.  I have debugged the code, and can't see what the problem is. - SF 15/July/04\n     */\n    public void testCompleteContentFromUndecoratedPageUsingWriter() throws Exception {\n        WebResponse rs = wc.getResponse(server.getBaseURL() + \"/outputservlet?out=writer\");\n        assertTrue(\"Document is not complete: \" + rs.getText(), rs.getText().trim().endsWith(\"<\/html>\"));\n    }\n\n    public void testCompleteContentFromUndecoratedPageUsingStream() throws Exception {\n        WebResponse rs = wc.getResponse(server.getBaseURL() + \"/outputservlet?out=stream\");\n        assertTrue(\"Document is not complete: \" + rs.getText(), rs.getText().trim().endsWith(\"<\/html>\"));\n    }\n\n    public void testContentMatchesContentLengthUsingWriter() throws Exception {\n        WebResponse rs = wc.getResponse(server.getBaseURL() + \"/outputservlet?out=writer\");\n        if (rs.getHeaderField(\"Content-length\") != null) {\n            assertEquals(rs.getHeaderField(\"Content-length\"), String.valueOf(rs.getText().getBytes().length));\n        }\n    }\n\n    public void testContentMatchesContentLengthUsingStream() throws Exception {\n        WebResponse rs = wc.getResponse(server.getBaseURL() + \"/outputservlet?out=stream\");\n        if (rs.getHeaderField(\"Content-length\") != null) {\n            assertEquals(rs.getHeaderField(\"Content-length\"), String.valueOf(rs.getText().getBytes().length));\n        }\n    }\n\n}\n","lineNo":32}
{"Refactored Sample":"/*\n * Title:        ConfigLoader\n * Description:\n *\n * This software is published under the terms of the OpenSymphony Software\n * License version 1.1, of which a copy has been included with this\n * distribution in the LICENSE.txt file.\n */\n\npackage com.opensymphony.module.sitemesh.mapper;\n\nimport com.opensymphony.module.sitemesh.Config;\nimport com.opensymphony.module.sitemesh.Decorator;\nimport org.w3c.dom.*;\nimport org.xml.sax.SAXException;\n\nimport javax.servlet.ServletException;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * The ConfigLoader reads a configuration XML file that contains Decorator definitions\n * (name, url, init-params) and path-mappings (pattern, name).\n *\n * <p>These can then be accessed by the getDecoratorByName() methods and getMappedName()\n * methods respectively.<\/p>\n *\n * <p>The DTD for the configuration file in old (deprecated) format is located at\n * <a href=\"http://www.opensymphony.com/dtds/sitemesh_1_0_decorators.dtd\">\n *  http://www.opensymphony.com/dtds/sitemesh_1_0_decorators.dtd\n * <\/a>.<\/p>\n *\n * <p>The DTD for the configuration file in new format is located at\n * <a href=\"http://www.opensymphony.com/dtds/sitemesh_1_5_decorators.dtd\">\n *  http://www.opensymphony.com/dtds/sitemesh_1_5_decorators.dtd\n * <\/a>.<\/p>\n *\n * <p>Editing the config file will cause it to be auto-reloaded.<\/p>\n *\n * <p>This class is used by ConfigDecoratorMapper, and uses PathMapper for pattern matching.<\/p>\n *\n * @author <a href=\"mailto:joe@truemesh.com\">Joe Walnes<\/a>\n * @author <a href=\"mailto:pathos@pandora.be\">Mathias Bogaert<\/a>\n * @version $Revision: 1.4 $\n *\n * @see com.opensymphony.module.sitemesh.mapper.ConfigDecoratorMapper\n * @see com.opensymphony.module.sitemesh.mapper.PathMapper\n */\npublic final class ConfigLoader {\n    private Map decorators = null;\n    private long configLastModified;\n\n    private File configFile = null;\n    private String configFileName = null;\n    private PathMapper pathMapper = null;\n\n    private Config config = null;\n\n    /** Create new ConfigLoader using supplied File. */\n    public ConfigLoader(File configFile) throws ServletException {\n        this.configFile = configFile;\n        this.configFileName = configFile.getName();\n        loadConfig();\n    }\n\n    /** Create new ConfigLoader using supplied filename and config. */\n    public ConfigLoader(String configFileName, Config config) throws ServletException {\n        this.config = config;\n        this.configFileName = configFileName;\n        if (config.getServletContext().getRealPath(configFileName) != null) {\n            this.configFile = new File(config.getServletContext().getRealPath(configFileName));\n        }\n        loadConfig();\n    }\n\n    /** Retrieve Decorator based on name specified in configuration file. */\n    public Decorator getDecoratorByName(String name) throws ServletException {\n        refresh();\n        return (Decorator)decorators.get(name);\n    }\n\n    /** Get name of Decorator mapped to given path. */\n    public String getMappedName(String path) throws ServletException {\n        refresh();\n        return pathMapper.get(path);\n    }\n\n    /** Load configuration from file. */\n    private synchronized void loadConfig() throws ServletException {\n        try {\n            // Build a document from the file\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n\n            Document document = null;\n            if (configFile != null && configFile.canRead()) {\n                // Keep time we read the file to check if the file was modified\n                configLastModified = configFile.lastModified();\n                document = builder.parse(configFile);\n            }\n            else {\n                document = builder.parse(config.getServletContext().getResourceAsStream(configFileName));\n            }\n\n            // Parse the configuration document\n            parseConfig(document);\n        }\n        catch (ParserConfigurationException e) {\n            throw new ServletException(\"Could not get XML parser\", e);\n        }\n        catch (IOException e) {\n            throw new ServletException(\"Could not read config file: \" + configFileName, e);\n        }\n        catch (SAXException e) {\n            throw new ServletException(\"Could not parse config file: \" + configFileName, e);\n        }\n    }\n\n    /** Parse configuration from XML document. */\n    private synchronized void parseConfig(Document document) {\n        Element root = document.getDocumentElement();\n\n        // get the default directory for the decorators\n        String defaultDir = getAttribute(root, \"defaultdir\");\n        if (defaultDir == null) defaultDir = getAttribute(root, \"defaultDir\");\n\n        // Clear previous config\n        pathMapper = new PathMapper();\n        decorators = new HashMap();\n\n        // Get decorators\n        NodeList decoratorNodes = root.getElementsByTagName(\"decorator\");\n        Element decoratorElement = null;\n\n        for (int i = 0; i < decoratorNodes.getLength(); i++) {\n            String name = null, page = null, uriPath = null, role = null;\n\n            // get the current decorator element\n            decoratorElement = (Element) decoratorNodes.item(i);\n\n            if (getAttribute(decoratorElement, \"name\") != null) {\n                // The new format is used\n                name = getAttribute(decoratorElement, \"name\");\n                page = getAttribute(decoratorElement, \"page\");\n                uriPath = getAttribute(decoratorElement, \"webapp\");\n                role = getAttribute(decoratorElement, \"role\");\n\n                // Append the defaultDir\n                if (defaultDir != null && page != null && page.length() > 0) {\n                    if (page.charAt(0) == '/') page = defaultDir + page;\n                    else                       page = defaultDir + '/' + page;\n                }\n\n                // The uriPath must begin with a slash\n                if (uriPath != null && uriPath.length() > 0) {\n                    if (uriPath.charAt(0) != '/') uriPath = '/' + uriPath;\n                }\n\n                // Get all <pattern>...<\/pattern> and <url-pattern>...<\/url-pattern> nodes and add a mapping\n               populatePathMapper(decoratorElement.getElementsByTagName(\"pattern\"), role, name);\n               populatePathMapper(decoratorElement.getElementsByTagName(\"url-pattern\"), role, name);\n            }\n            else {\n                // NOTE: Deprecated format\n                name = getContainedText(decoratorNodes.item(i), \"decorator-name\");\n                page = getContainedText(decoratorNodes.item(i), \"resource\");\n                // We have this here because the use of jsp-file is deprecated, but we still want\n                // it to work.\n                if (page == null) page = getContainedText(decoratorNodes.item(i), \"jsp-file\");\n            }\n\n            Map params = new HashMap();\n\n            NodeList paramNodes = decoratorElement.getElementsByTagName(\"init-param\");\n            for (int ii = 0; ii < paramNodes.getLength(); ii++) {\n                String paramName = getContainedText(paramNodes.item(ii), \"param-name\");\n                String paramValue = getContainedText(paramNodes.item(ii), \"param-value\");\n                params.put(paramName, paramValue);\n            }\n            storeDecorator(new DefaultDecorator(name, page, uriPath, role, params));\n        }\n\n        // Get (deprecated format) decorator-mappings\n        NodeList mappingNodes = root.getElementsByTagName(\"decorator-mapping\");\n        for (int i = 0; i < mappingNodes.getLength(); i++) {\n            Element n = (Element)mappingNodes.item(i);\n            String name = getContainedText(mappingNodes.item(i), \"decorator-name\");\n\n            // Get all <url-pattern>...<\/url-pattern> nodes and add a mapping\n            populatePathMapper(n.getElementsByTagName(\"url-pattern\"), null, name);\n        }\n    }\n\n   /**\n    * Extracts each URL pattern and adds it to the pathMapper map.\n    */\n   private void populatePathMapper(NodeList patternNodes, String role, String name) {\n      for (int j = 0; j < patternNodes.getLength(); j++) {\n          Element p = (Element)patternNodes.item(j);\n          Text patternText = (Text) p.getFirstChild();\n          if (patternText != null) {\n             String pattern = patternText.getData().trim();\n             if (pattern != null) {\n                 if (role != null) {\n                     // concatenate name and role to allow more\n                     // than one decorator per role\n                     pathMapper.put(name + role, pattern);\n                 }\n                 else {\n                     pathMapper.put(name, pattern);\n                 }\n             }\n         }\n      }\n   }\n\n   /** Override default behavior of element.getAttribute (returns the empty string) to return null. */\n    private static String getAttribute(Element element, String name) {\n        if (element != null && element.getAttribute(name) != null && element.getAttribute(name).trim() != \"\") {\n            return element.getAttribute(name).trim();\n        }\n        else {\n            return null;\n        }\n    }\n\n    /**\n     * With a given parent XML Element, find the text contents of the child element with\n     * supplied name.\n     */\n    private static String getContainedText(Node parent, String childTagName) {\n        try {\n            Node tag = ((Element)parent).getElementsByTagName(childTagName).item(0);\n            String text = ((Text)tag.getFirstChild()).getData();\n            return text;\n        }\n        catch (Exception e) {\n            return null;\n        }\n    }\n\n    /** Store Decorator in Map */\n    private void storeDecorator(Decorator d) {\n        if (d.getRole() != null) {\n            decorators.put(d.getName() + d.getRole(), d);\n        }\n        else {\n            decorators.put(d.getName(), d);\n        }\n    }\n\n    /** Check if configuration file has been updated, and if so, reload. */\n    private synchronized void refresh() throws ServletException {\n        if (configFile != null && configLastModified != configFile.lastModified()) loadConfig();\n    }\n}\n","Smelly Sample":"/*\n * Title:        ConfigLoader\n * Description:\n *\n * This software is published under the terms of the OpenSymphony Software\n * License version 1.1, of which a copy has been included with this\n * distribution in the LICENSE.txt file.\n */\n\npackage com.opensymphony.module.sitemesh.mapper;\n\nimport com.opensymphony.module.sitemesh.Config;\nimport com.opensymphony.module.sitemesh.Decorator;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.Text;\nimport org.xml.sax.SAXException;\n\nimport javax.servlet.ServletException;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * The ConfigLoader reads a configuration XML file that contains Decorator definitions\n * (name, url, init-params) and path-mappings (pattern, name).\n *\n * <p>These can then be accessed by the getDecoratorByName() methods and getMappedName()\n * methods respectively.<\/p>\n *\n * <p>The DTD for the configuration file in old (deprecated) format is located at\n * <a href=\"http://www.opensymphony.com/dtds/sitemesh_1_0_decorators.dtd\">\n *  http://www.opensymphony.com/dtds/sitemesh_1_0_decorators.dtd\n * <\/a>.<\/p>\n *\n * <p>The DTD for the configuration file in new format is located at\n * <a href=\"http://www.opensymphony.com/dtds/sitemesh_1_5_decorators.dtd\">\n *  http://www.opensymphony.com/dtds/sitemesh_1_5_decorators.dtd\n * <\/a>.<\/p>\n *\n * <p>Editing the config file will cause it to be auto-reloaded.<\/p>\n *\n * <p>This class is used by ConfigDecoratorMapper, and uses PathMapper for pattern matching.<\/p>\n *\n * @author <a href=\"mailto:joe@truemesh.com\">Joe Walnes<\/a>\n * @author <a href=\"mailto:pathos@pandora.be\">Mathias Bogaert<\/a>\n * @version $Revision: 1.3 $\n *\n * @see com.opensymphony.module.sitemesh.mapper.ConfigDecoratorMapper\n * @see com.opensymphony.module.sitemesh.mapper.PathMapper\n */\npublic final class ConfigLoader {\n    private Map decorators = null;\n    private long configLastModified;\n\n    private File configFile = null;\n    private String configFileName = null;\n    private PathMapper pathMapper = null;\n\n    private Config config = null;\n\n    /** Create new ConfigLoader using supplied File. */\n    public ConfigLoader(File configFile) throws ServletException {\n        this.configFile = configFile;\n        this.configFileName = configFile.getName();\n        loadConfig();\n    }\n\n    /** Create new ConfigLoader using supplied filename and config. */\n    public ConfigLoader(String configFileName, Config config) throws ServletException {\n        this.config = config;\n        this.configFileName = configFileName;\n        if (config.getServletContext().getRealPath(configFileName) != null) {\n            this.configFile = new File(config.getServletContext().getRealPath(configFileName));\n        }\n        loadConfig();\n    }\n\n    /** Retrieve Decorator based on name specified in configuration file. */\n    public Decorator getDecoratorByName(String name) throws ServletException {\n        refresh();\n        return (Decorator)decorators.get(name);\n    }\n\n    /** Get name of Decorator mapped to given path. */\n    public String getMappedName(String path) throws ServletException {\n        refresh();\n        return pathMapper.get(path);\n    }\n\n    /** Load configuration from file. */\n    private synchronized void loadConfig() throws ServletException {\n        try {\n            // Build a document from the file\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n\n            Document document = null;\n            if (configFile != null && configFile.canRead()) {\n                // Keep time we read the file to check if the file was modified\n                configLastModified = configFile.lastModified();\n                document = builder.parse(configFile);\n            }\n            else {\n                document = builder.parse(config.getServletContext().getResourceAsStream(configFileName));\n            }\n\n            // Parse the configuration document\n            parseConfig(document);\n        }\n        catch (ParserConfigurationException e) {\n            throw new ServletException(\"Could not get XML parser\", e);\n        }\n        catch (IOException e) {\n            throw new ServletException(\"Could not read config file: \" + configFileName, e);\n        }\n        catch (SAXException e) {\n            throw new ServletException(\"Could not parse config file: \" + configFileName, e);\n        }\n    }\n\n    /** Parse configuration from XML document. */\n    private synchronized void parseConfig(Document document) {\n        Element root = document.getDocumentElement();\n\n        // get the default directory for the decorators\n        String defaultDir = getAttribute(root, \"defaultdir\");\n        if (defaultDir == null) defaultDir = getAttribute(root, \"defaultDir\");\n\n        // Clear previous config\n        pathMapper = new PathMapper();\n        decorators = new HashMap();\n\n        // Get decorators\n        NodeList decoratorNodes = root.getElementsByTagName(\"decorator\");\n        Element decoratorElement = null;\n\n        for (int i = 0; i < decoratorNodes.getLength(); i++) {\n            String name = null, page = null, uriPath = null, role = null;\n\n            // get the current decorator element\n            decoratorElement = (Element) decoratorNodes.item(i);\n\n            if (getAttribute(decoratorElement, \"name\") != null) {\n                // The new format is used\n                name = getAttribute(decoratorElement, \"name\");\n                page = getAttribute(decoratorElement, \"page\");\n                uriPath = getAttribute(decoratorElement, \"webapp\");\n                role = getAttribute(decoratorElement, \"role\");\n\n                // Append the defaultDir\n                if (defaultDir != null && page != null && page.length() > 0) {\n                    if (page.charAt(0) == '/') page = defaultDir + page;\n                    else                       page = defaultDir + '/' + page;\n                }\n\n                // The uriPath must begin with a slash\n                if (uriPath != null && uriPath.length() > 0) {\n                    if (uriPath.charAt(0) != '/') uriPath = '/' + uriPath;\n                }\n\n                // Get all <pattern>...<\/pattern> nodes and add a mapping\n                NodeList patternNodes = decoratorElement.getElementsByTagName(\"pattern\");\n                for (int j = 0; j < patternNodes.getLength(); j++) {\n                    Element p = (Element)patternNodes.item(j);\n                    Text patternText = (Text) p.getFirstChild();\n                    if (patternText != null) {\n                    \tString pattern = patternText.getData().trim();\n\t                    if (role != null) {\n\t                        // concatenate name and role to allow more\n\t                        // than one decorator per role\n\t                        pathMapper.put(name + role, pattern);\n\t                    }\n\t                    else {\n\t                        pathMapper.put(name, pattern);\n\t                    }\n\t                }\n                }\n\n                // Get all <url-pattern>...<\/url-pattern> nodes and add a mapping\n                NodeList urlPatternNodes = decoratorElement.getElementsByTagName(\"url-pattern\");\n                for (int j = 0; j < urlPatternNodes.getLength(); j++) {\n                    Element p = (Element)urlPatternNodes.item(j);\n                    Text patternText = (Text) p.getFirstChild();\n                    if (patternText != null) {\n                    \tString pattern = patternText.getData().trim();\n                    \tif (role != null) {\n                        \t// concatenate name and role to allow more\n                        \t// than one decorator per role\n                        \tpathMapper.put(name + role, pattern);\n                    \t}\n                    \telse {\n                        \tpathMapper.put(name, pattern);\n                    \t}\n                    }\n                }\n            }\n            else {\n                // NOTE: Deprecated format\n                name = getContainedText(decoratorNodes.item(i), \"decorator-name\");\n                page = getContainedText(decoratorNodes.item(i), \"resource\");\n                // We have this here because the use of jsp-file is deprecated, but we still want\n                // it to work.\n                if (page == null) page = getContainedText(decoratorNodes.item(i), \"jsp-file\");\n            }\n\n            Map params = new HashMap();\n\n            NodeList paramNodes = decoratorElement.getElementsByTagName(\"init-param\");\n            for (int ii = 0; ii < paramNodes.getLength(); ii++) {\n                String paramName = getContainedText(paramNodes.item(ii), \"param-name\");\n                String paramValue = getContainedText(paramNodes.item(ii), \"param-value\");\n                params.put(paramName, paramValue);\n            }\n            storeDecorator(new DefaultDecorator(name, page, uriPath, role, params));\n        }\n\n        // Get (deprecated format) decorator-mappings\n        NodeList mappingNodes = root.getElementsByTagName(\"decorator-mapping\");\n        for (int i = 0; i < mappingNodes.getLength(); i++) {\n            Element n = (Element)mappingNodes.item(i);\n            String name = getContainedText(mappingNodes.item(i), \"decorator-name\");\n\n            // Get all <url-pattern>...<\/url-pattern> nodes and add a mapping\n            NodeList patternNodes = n.getElementsByTagName(\"url-pattern\");\n            for (int j = 0; j < patternNodes.getLength(); j++) {\n                Element p = (Element)patternNodes.item(j);\n                Text patternText = (Text) p.getFirstChild();\n                if (patternText != null) pathMapper.put(name, patternText.getData().trim());\n            }\n        }\n    }\n\n    /** Override default behavior of element.getAttribute (returns the empty string) to return null. */\n    private static String getAttribute(Element element, String name) {\n        if (element != null && element.getAttribute(name) != null && element.getAttribute(name).trim() != \"\") {\n            return element.getAttribute(name).trim();\n        }\n        else {\n            return null;\n        }\n    }\n\n    /**\n     * With a given parent XML Element, find the text contents of the child element with\n     * supplied name.\n     */\n    private static String getContainedText(Node parent, String childTagName) {\n        try {\n            Node tag = ((Element)parent).getElementsByTagName(childTagName).item(0);\n            String text = ((Text)tag.getFirstChild()).getData();\n            return text;\n        }\n        catch (Exception e) {\n            return null;\n        }\n    }\n\n    /** Store Decorator in Map */\n    private void storeDecorator(Decorator d) {\n        if (d.getRole() != null) {\n            decorators.put(d.getName() + d.getRole(), d);\n        }\n        else {\n            decorators.put(d.getName(), d);\n        }\n    }\n\n    /** Check if configuration file has been updated, and if so, reload. */\n    private synchronized void refresh() throws ServletException {\n        if (configFile != null && configLastModified != configFile.lastModified()) loadConfig();\n    }\n}\n","lineNo":207}
{"Refactored Sample":"/*\n * Title:        ConfigLoader\n * Description:\n *\n * This software is published under the terms of the OpenSymphony Software\n * License version 1.1, of which a copy has been included with this\n * distribution in the LICENSE.txt file.\n */\n\npackage com.opensymphony.module.sitemesh.mapper;\n\nimport com.opensymphony.module.sitemesh.Config;\nimport com.opensymphony.module.sitemesh.Decorator;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.Text;\nimport org.xml.sax.SAXException;\n\nimport javax.servlet.ServletException;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * The ConfigLoader reads a configuration XML file that contains Decorator definitions\n * (name, url, init-params) and path-mappings (pattern, name).\n *\n * <p>These can then be accessed by the getDecoratorByName() methods and getMappedName()\n * methods respectively.<\/p>\n *\n * <p>The DTD for the configuration file in old (deprecated) format is located at\n * <a href=\"http://www.opensymphony.com/dtds/sitemesh_1_0_decorators.dtd\">\n *  http://www.opensymphony.com/dtds/sitemesh_1_0_decorators.dtd\n * <\/a>.<\/p>\n *\n * <p>The DTD for the configuration file in new format is located at\n * <a href=\"http://www.opensymphony.com/dtds/sitemesh_1_5_decorators.dtd\">\n *  http://www.opensymphony.com/dtds/sitemesh_1_5_decorators.dtd\n * <\/a>.<\/p>\n *\n * <p>Editing the config file will cause it to be auto-reloaded.<\/p>\n *\n * <p>This class is used by ConfigDecoratorMapper, and uses PathMapper for pattern matching.<\/p>\n *\n * @author <a href=\"mailto:joe@truemesh.com\">Joe Walnes<\/a>\n * @author <a href=\"mailto:pathos@pandora.be\">Mathias Bogaert<\/a>\n * @version $Revision: 1.2 $\n *\n * @see com.opensymphony.module.sitemesh.mapper.ConfigDecoratorMapper\n * @see com.opensymphony.module.sitemesh.mapper.PathMapper\n */\npublic final class ConfigLoader {\n    private Map decorators = null;\n    private long configLastModified;\n\n    private File configFile = null;\n    private String configFileName = null;\n    private PathMapper pathMapper = null;\n\n    private Config config = null;\n\n    /** Create new ConfigLoader using supplied File. */\n    public ConfigLoader(File configFile) throws ServletException {\n        this.configFile = configFile;\n        this.configFileName = configFile.getName();\n        loadConfig();\n    }\n\n    /** Create new ConfigLoader using supplied filename and config. */\n    public ConfigLoader(String configFileName, Config config) throws ServletException {\n        this.config = config;\n        this.configFileName = configFileName;\n        if (config.getServletContext().getRealPath(configFileName) != null) {\n            this.configFile = new File(config.getServletContext().getRealPath(configFileName));\n        }\n        loadConfig();\n    }\n\n    /** Retrieve Decorator based on name specified in configuration file. */\n    public Decorator getDecoratorByName(String name) throws ServletException {\n        refresh();\n        return (Decorator)decorators.get(name);\n    }\n\n    /** Get name of Decorator mapped to given path. */\n    public String getMappedName(String path) throws ServletException {\n        refresh();\n        return pathMapper.get(path);\n    }\n\n    /** Load configuration from file. */\n    private synchronized void loadConfig() throws ServletException {\n        try {\n            // Build a document from the file\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n\n            Document document = null;\n            if (configFile != null && configFile.canRead()) {\n                // Keep time we read the file to check if the file was modified\n                configLastModified = configFile.lastModified();\n                document = builder.parse(configFile);\n            }\n            else {\n                document = builder.parse(config.getServletContext().getResourceAsStream(configFileName));\n            }\n\n            // Parse the configuration document\n            parseConfig(document);\n        }\n        catch (ParserConfigurationException e) {\n            throw new ServletException(\"Could not get XML parser\", e);\n        }\n        catch (IOException e) {\n            throw new ServletException(\"Could not read config file: \" + configFileName, e);\n        }\n        catch (SAXException e) {\n            throw new ServletException(\"Could not parse config file: \" + configFileName, e);\n        }\n    }\n\n    /** Parse configuration from XML document. */\n    private synchronized void parseConfig(Document document) {\n        Element root = document.getDocumentElement();\n\n        // get the default directory for the decorators\n        String defaultDir = getAttribute(root, \"defaultdir\");\n        if (defaultDir == null) defaultDir = getAttribute(root, \"defaultDir\");\n\n        // Clear previous config\n        pathMapper = new PathMapper();\n        decorators = new HashMap();\n\n        // Get decorators\n        NodeList decoratorNodes = root.getElementsByTagName(\"decorator\");\n        Element decoratorElement = null;\n\n        for (int i = 0; i < decoratorNodes.getLength(); i++) {\n            String name = null, page = null, uriPath = null, role = null;\n\n            // get the current decorator element\n            decoratorElement = (Element) decoratorNodes.item(i);\n\n            if (getAttribute(decoratorElement, \"name\") != null) {\n                // The new format is used\n                name = getAttribute(decoratorElement, \"name\");\n                page = getAttribute(decoratorElement, \"page\");\n                uriPath = getAttribute(decoratorElement, \"webapp\");\n                role = getAttribute(decoratorElement, \"role\");\n\n                // Append the defaultDir\n                if (defaultDir != null && page != null && page.length() > 0) {\n                    if (page.charAt(0) == '/') page = defaultDir + page;\n                    else                       page = defaultDir + '/' + page;\n                }\n\n                // The uriPath must begin with a slash\n                if (uriPath != null && uriPath.length() > 0) {\n                    if (uriPath.charAt(0) != '/') uriPath = '/' + uriPath;\n                }\n\n                // Get all <pattern>...<\/pattern> nodes and add a mapping\n                NodeList patternNodes = decoratorElement.getElementsByTagName(\"pattern\");\n                for (int j = 0; j < patternNodes.getLength(); j++) {\n                    Element p = (Element)patternNodes.item(j);\n                    Text patternText = (Text) p.getFirstChild();\n                    if (patternText != null) {\n                    \tString pattern = patternText.getData().trim();\n\t                    if (role != null) {\n\t                        // concatenate name and role to allow more\n\t                        // than one decorator per role\n\t                        pathMapper.put(name + role, pattern.trim());\n\t                    }\n\t                    else {\n\t                        pathMapper.put(name, pattern.trim());\n\t                    }\n\t                }\n                }\n\n                // Get all <url-pattern>...<\/url-pattern> nodes and add a mapping\n                NodeList urlPatternNodes = decoratorElement.getElementsByTagName(\"url-pattern\");\n                for (int j = 0; j < urlPatternNodes.getLength(); j++) {\n                    Element p = (Element)urlPatternNodes.item(j);\n                    Text patternText = (Text) p.getFirstChild();\n                    if (patternText != null) {\n                    \tString pattern = patternText.getData().trim();\n                    \tif (role != null) {\n                        \t// concatenate name and role to allow more\n                        \t// than one decorator per role\n                        \tpathMapper.put(name + role, pattern);\n                    \t}\n                    \telse {\n                        \tpathMapper.put(name, pattern);\n                    \t}\n                    }\n                }\n            }\n            else {\n                // NOTE: Deprecated format\n                name = getContainedText(decoratorNodes.item(i), \"decorator-name\");\n                page = getContainedText(decoratorNodes.item(i), \"resource\");\n                // We have this here because the use of jsp-file is deprecated, but we still want\n                // it to work.\n                if (page == null) page = getContainedText(decoratorNodes.item(i), \"jsp-file\");\n            }\n\n            Map params = new HashMap();\n\n            NodeList paramNodes = decoratorElement.getElementsByTagName(\"init-param\");\n            for (int ii = 0; ii < paramNodes.getLength(); ii++) {\n                String paramName = getContainedText(paramNodes.item(ii), \"param-name\");\n                String paramValue = getContainedText(paramNodes.item(ii), \"param-value\");\n                params.put(paramName, paramValue);\n            }\n            storeDecorator(new DefaultDecorator(name, page, uriPath, role, params));\n        }\n\n        // Get (deprecated format) decorator-mappings\n        NodeList mappingNodes = root.getElementsByTagName(\"decorator-mapping\");\n        for (int i = 0; i < mappingNodes.getLength(); i++) {\n            Element n = (Element)mappingNodes.item(i);\n            String name = getContainedText(mappingNodes.item(i), \"decorator-name\");\n\n            // Get all <url-pattern>...<\/url-pattern> nodes and add a mapping\n            NodeList patternNodes = n.getElementsByTagName(\"url-pattern\");\n            for (int j = 0; j < patternNodes.getLength(); j++) {\n                Element p = (Element)patternNodes.item(j);\n                Text patternText = (Text) p.getFirstChild();\n                if (patternText != null) pathMapper.put(name, patternText.getData().trim());\n            }\n        }\n    }\n\n    /** Override default behavior of element.getAttribute (returns the empty string) to return null. */\n    private static String getAttribute(Element element, String name) {\n        if (element != null && element.getAttribute(name) != null && element.getAttribute(name).trim() != \"\") {\n            return element.getAttribute(name).trim();\n        }\n        else {\n            return null;\n        }\n    }\n\n    /**\n     * With a given parent XML Element, find the text contents of the child element with\n     * supplied name.\n     */\n    private static String getContainedText(Node parent, String childTagName) {\n        try {\n            Node tag = ((Element)parent).getElementsByTagName(childTagName).item(0);\n            String text = ((Text)tag.getFirstChild()).getData();\n            return text;\n        }\n        catch (Exception e) {\n            return null;\n        }\n    }\n\n    /** Store Decorator in Map */\n    private void storeDecorator(Decorator d) {\n        if (d.getRole() != null) {\n            decorators.put(d.getName() + d.getRole(), d);\n        }\n        else {\n            decorators.put(d.getName(), d);\n        }\n    }\n\n    /** Check if configuration file has been updated, and if so, reload. */\n    private synchronized void refresh() throws ServletException {\n        if (configFile != null && configLastModified != configFile.lastModified()) loadConfig();\n    }\n}\n","Smelly Sample":"/*\n * Title:        ConfigLoader\n * Description:\n *\n * This software is published under the terms of the OpenSymphony Software\n * License version 1.1, of which a copy has been included with this\n * distribution in the LICENSE.txt file.\n */\n\npackage com.opensymphony.module.sitemesh.mapper;\n\nimport com.opensymphony.module.sitemesh.Config;\nimport com.opensymphony.module.sitemesh.Decorator;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.Text;\nimport org.xml.sax.SAXException;\n\nimport javax.servlet.ServletException;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * The ConfigLoader reads a configuration XML file that contains Decorator definitions\n * (name, url, init-params) and path-mappings (pattern, name).\n *\n * <p>These can then be accessed by the getDecoratorByName() methods and getMappedName()\n * methods respectively.<\/p>\n *\n * <p>The DTD for the configuration file in old (deprecated) format is located at\n * <a href=\"http://www.opensymphony.com/dtds/sitemesh_1_0_decorators.dtd\">\n *  http://www.opensymphony.com/dtds/sitemesh_1_0_decorators.dtd\n * <\/a>.<\/p>\n *\n * <p>The DTD for the configuration file in new format is located at\n * <a href=\"http://www.opensymphony.com/dtds/sitemesh_1_5_decorators.dtd\">\n *  http://www.opensymphony.com/dtds/sitemesh_1_5_decorators.dtd\n * <\/a>.<\/p>\n *\n * <p>Editing the config file will cause it to be auto-reloaded.<\/p>\n *\n * <p>This class is used by ConfigDecoratorMapper, and uses PathMapper for pattern matching.<\/p>\n *\n * @author <a href=\"mailto:joe@truemesh.com\">Joe Walnes<\/a>\n * @author <a href=\"mailto:pathos@pandora.be\">Mathias Bogaert<\/a>\n * @version $Revision: 1.1 $\n *\n * @see com.opensymphony.module.sitemesh.mapper.ConfigDecoratorMapper\n * @see com.opensymphony.module.sitemesh.mapper.PathMapper\n */\npublic final class ConfigLoader {\n    private Map decorators = null;\n    private long configLastModified;\n\n    private File configFile = null;\n    private String configFileName = null;\n    private PathMapper pathMapper = null;\n\n    private Config config = null;\n\n    /** Create new ConfigLoader using supplied File. */\n    public ConfigLoader(File configFile) throws ServletException {\n        this.configFile = configFile;\n        this.configFileName = configFile.getName();\n        loadConfig();\n    }\n\n    /** Create new ConfigLoader using supplied filename and config. */\n    public ConfigLoader(String configFileName, Config config) throws ServletException {\n        this.config = config;\n        this.configFileName = configFileName;\n        if (config.getServletContext().getRealPath(configFileName) != null) {\n            this.configFile = new File(config.getServletContext().getRealPath(configFileName));\n        }\n        loadConfig();\n    }\n\n    /** Retrieve Decorator based on name specified in configuration file. */\n    public Decorator getDecoratorByName(String name) throws ServletException {\n        refresh();\n        return (Decorator)decorators.get(name);\n    }\n\n    /** Get name of Decorator mapped to given path. */\n    public String getMappedName(String path) throws ServletException {\n        refresh();\n        return pathMapper.get(path);\n    }\n\n    /** Load configuration from file. */\n    private synchronized void loadConfig() throws ServletException {\n        try {\n            // Build a document from the file\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n\n            Document document = null;\n            if (configFile != null && configFile.canRead()) {\n                // Keep time we read the file to check if the file was modified\n                configLastModified = configFile.lastModified();\n                document = builder.parse(configFile);\n            }\n            else {\n                document = builder.parse(config.getServletContext().getResourceAsStream(configFileName));\n            }\n\n            // Parse the configuration document\n            parseConfig(document);\n        }\n        catch (ParserConfigurationException e) {\n            throw new ServletException(\"Could not get XML parser\", e);\n        }\n        catch (IOException e) {\n            throw new ServletException(\"Could not read config file: \" + configFileName, e);\n        }\n        catch (SAXException e) {\n            throw new ServletException(\"Could not parse config file: \" + configFileName, e);\n        }\n    }\n\n    /** Parse configuration from XML document. */\n    private synchronized void parseConfig(Document document) {\n        Element root = document.getDocumentElement();\n\n        // get the default directory for the decorators\n        String defaultDir = getAttribute(root, \"defaultdir\");\n        if (defaultDir == null) defaultDir = getAttribute(root, \"defaultDir\");\n\n        // Clear previous config\n        pathMapper = new PathMapper();\n        decorators = new HashMap();\n\n        // Get decorators\n        NodeList decoratorNodes = root.getElementsByTagName(\"decorator\");\n        Element decoratorElement = null;\n\n        for (int i = 0; i < decoratorNodes.getLength(); i++) {\n            String name = null, page = null, uriPath = null, role = null;\n\n            // get the current decorator element\n            decoratorElement = (Element) decoratorNodes.item(i);\n\n            if (getAttribute(decoratorElement, \"name\") != null) {\n                // The new format is used\n                name = getAttribute(decoratorElement, \"name\");\n                page = getAttribute(decoratorElement, \"page\");\n                uriPath = getAttribute(decoratorElement, \"webapp\");\n                role = getAttribute(decoratorElement, \"role\");\n\n                // Append the defaultDir\n                if (defaultDir != null && page != null && page.length() > 0) {\n                    if (page.charAt(0) == '/') page = defaultDir + page;\n                    else                       page = defaultDir + '/' + page;\n                }\n\n                // The uriPath must begin with a slash\n                if (uriPath != null && uriPath.length() > 0) {\n                    if (uriPath.charAt(0) != '/') uriPath = '/' + uriPath;\n                }\n\n                // Get all <pattern>...<\/pattern> nodes and add a mapping\n                NodeList patternNodes = decoratorElement.getElementsByTagName(\"pattern\");\n                for (int j = 0; j < patternNodes.getLength(); j++) {\n                    Element p = (Element)patternNodes.item(j);\n                    String pattern = ((Text)p.getFirstChild()).getData();\n                    if (role != null) {\n                        // concatenate name and role to allow more\n                        // than one decorator per role\n                        pathMapper.put(name + role, pattern);\n                    }\n                    else {\n                        pathMapper.put(name, pattern);\n                    }\n                }\n\n                // Get all <url-pattern>...<\/url-pattern> nodes and add a mapping\n                NodeList urlPatternNodes = decoratorElement.getElementsByTagName(\"url-pattern\");\n                for (int j = 0; j < urlPatternNodes.getLength(); j++) {\n                    Element p = (Element)urlPatternNodes.item(j);\n                    String pattern = ((Text)p.getFirstChild()).getData();\n                    if (role != null) {\n                        // concatenate name and role to allow more\n                        // than one decorator per role\n                        pathMapper.put(name + role, pattern);\n                    }\n                    else {\n                        pathMapper.put(name, pattern);\n                    }\n                }\n            }\n            else {\n                // NOTE: Deprecated format\n                name = getContainedText(decoratorNodes.item(i), \"decorator-name\");\n                page = getContainedText(decoratorNodes.item(i), \"resource\");\n                // We have this here because the use of jsp-file is deprecated, but we still want\n                // it to work.\n                if (page == null) page = getContainedText(decoratorNodes.item(i), \"jsp-file\");\n            }\n\n            Map params = new HashMap();\n\n            NodeList paramNodes = decoratorElement.getElementsByTagName(\"init-param\");\n            for (int ii = 0; ii < paramNodes.getLength(); ii++) {\n                String paramName = getContainedText(paramNodes.item(ii), \"param-name\");\n                String paramValue = getContainedText(paramNodes.item(ii), \"param-value\");\n                params.put(paramName, paramValue);\n            }\n            storeDecorator(new DefaultDecorator(name, page, uriPath, role, params));\n        }\n\n        // Get (deprecated format) decorator-mappings\n        NodeList mappingNodes = root.getElementsByTagName(\"decorator-mapping\");\n        for (int i = 0; i < mappingNodes.getLength(); i++) {\n            Element n = (Element)mappingNodes.item(i);\n            String name = getContainedText(mappingNodes.item(i), \"decorator-name\");\n\n            // Get all <url-pattern>...<\/url-pattern> nodes and add a mapping\n            NodeList patternNodes = n.getElementsByTagName(\"url-pattern\");\n            for (int j = 0; j < patternNodes.getLength(); j++) {\n                Element p = (Element)patternNodes.item(j);\n                String pattern = ((Text)p.getFirstChild()).getData();\n                pathMapper.put(name, pattern);\n            }\n        }\n    }\n\n    /** Override default behavior of element.getAttribute (returns the empty string) to return null. */\n    private static String getAttribute(Element element, String name) {\n        if (element != null && element.getAttribute(name) != null && element.getAttribute(name).trim() != \"\") {\n            return element.getAttribute(name).trim();\n        }\n        else {\n            return null;\n        }\n    }\n\n    /**\n     * With a given parent XML Element, find the text contents of the child element with\n     * supplied name.\n     */\n    private static String getContainedText(Node parent, String childTagName) {\n        try {\n            Node tag = ((Element)parent).getElementsByTagName(childTagName).item(0);\n            String text = ((Text)tag.getFirstChild()).getData();\n            return text;\n        }\n        catch (Exception e) {\n            return null;\n        }\n    }\n\n    /** Store Decorator in Map */\n    private void storeDecorator(Decorator d) {\n        if (d.getRole() != null) {\n            decorators.put(d.getName() + d.getRole(), d);\n        }\n        else {\n            decorators.put(d.getName(), d);\n        }\n    }\n\n    /** Check if configuration file has been updated, and if so, reload. */\n    private synchronized void refresh() throws ServletException {\n        if (configFile != null && configLastModified != configFile.lastModified()) loadConfig();\n    }\n}\n","lineNo":173}
{"Refactored Sample":"/*\n * Title:        ConfigLoader\n * Description:\n *\n * This software is published under the terms of the OpenSymphony Software\n * License version 1.1, of which a copy has been included with this\n * distribution in the LICENSE.txt file.\n */\n\npackage com.opensymphony.module.sitemesh.mapper;\n\nimport com.opensymphony.module.sitemesh.Config;\nimport com.opensymphony.module.sitemesh.Decorator;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.Text;\nimport org.xml.sax.SAXException;\n\nimport javax.servlet.ServletException;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * The ConfigLoader reads a configuration XML file that contains Decorator definitions\n * (name, url, init-params) and path-mappings (pattern, name).\n *\n * <p>These can then be accessed by the getDecoratorByName() methods and getMappedName()\n * methods respectively.<\/p>\n *\n * <p>The DTD for the configuration file in old (deprecated) format is located at\n * <a href=\"http://www.opensymphony.com/dtds/sitemesh_1_0_decorators.dtd\">\n *  http://www.opensymphony.com/dtds/sitemesh_1_0_decorators.dtd\n * <\/a>.<\/p>\n *\n * <p>The DTD for the configuration file in new format is located at\n * <a href=\"http://www.opensymphony.com/dtds/sitemesh_1_5_decorators.dtd\">\n *  http://www.opensymphony.com/dtds/sitemesh_1_5_decorators.dtd\n * <\/a>.<\/p>\n *\n * <p>Editing the config file will cause it to be auto-reloaded.<\/p>\n *\n * <p>This class is used by ConfigDecoratorMapper, and uses PathMapper for pattern matching.<\/p>\n *\n * @author <a href=\"mailto:joe@truemesh.com\">Joe Walnes<\/a>\n * @author <a href=\"mailto:pathos@pandora.be\">Mathias Bogaert<\/a>\n * @version $Revision: 1.2 $\n *\n * @see com.opensymphony.module.sitemesh.mapper.ConfigDecoratorMapper\n * @see com.opensymphony.module.sitemesh.mapper.PathMapper\n */\npublic final class ConfigLoader {\n    private Map decorators = null;\n    private long configLastModified;\n\n    private File configFile = null;\n    private String configFileName = null;\n    private PathMapper pathMapper = null;\n\n    private Config config = null;\n\n    /** Create new ConfigLoader using supplied File. */\n    public ConfigLoader(File configFile) throws ServletException {\n        this.configFile = configFile;\n        this.configFileName = configFile.getName();\n        loadConfig();\n    }\n\n    /** Create new ConfigLoader using supplied filename and config. */\n    public ConfigLoader(String configFileName, Config config) throws ServletException {\n        this.config = config;\n        this.configFileName = configFileName;\n        if (config.getServletContext().getRealPath(configFileName) != null) {\n            this.configFile = new File(config.getServletContext().getRealPath(configFileName));\n        }\n        loadConfig();\n    }\n\n    /** Retrieve Decorator based on name specified in configuration file. */\n    public Decorator getDecoratorByName(String name) throws ServletException {\n        refresh();\n        return (Decorator)decorators.get(name);\n    }\n\n    /** Get name of Decorator mapped to given path. */\n    public String getMappedName(String path) throws ServletException {\n        refresh();\n        return pathMapper.get(path);\n    }\n\n    /** Load configuration from file. */\n    private synchronized void loadConfig() throws ServletException {\n        try {\n            // Build a document from the file\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n\n            Document document = null;\n            if (configFile != null && configFile.canRead()) {\n                // Keep time we read the file to check if the file was modified\n                configLastModified = configFile.lastModified();\n                document = builder.parse(configFile);\n            }\n            else {\n                document = builder.parse(config.getServletContext().getResourceAsStream(configFileName));\n            }\n\n            // Parse the configuration document\n            parseConfig(document);\n        }\n        catch (ParserConfigurationException e) {\n            throw new ServletException(\"Could not get XML parser\", e);\n        }\n        catch (IOException e) {\n            throw new ServletException(\"Could not read config file: \" + configFileName, e);\n        }\n        catch (SAXException e) {\n            throw new ServletException(\"Could not parse config file: \" + configFileName, e);\n        }\n    }\n\n    /** Parse configuration from XML document. */\n    private synchronized void parseConfig(Document document) {\n        Element root = document.getDocumentElement();\n\n        // get the default directory for the decorators\n        String defaultDir = getAttribute(root, \"defaultdir\");\n        if (defaultDir == null) defaultDir = getAttribute(root, \"defaultDir\");\n\n        // Clear previous config\n        pathMapper = new PathMapper();\n        decorators = new HashMap();\n\n        // Get decorators\n        NodeList decoratorNodes = root.getElementsByTagName(\"decorator\");\n        Element decoratorElement = null;\n\n        for (int i = 0; i < decoratorNodes.getLength(); i++) {\n            String name = null, page = null, uriPath = null, role = null;\n\n            // get the current decorator element\n            decoratorElement = (Element) decoratorNodes.item(i);\n\n            if (getAttribute(decoratorElement, \"name\") != null) {\n                // The new format is used\n                name = getAttribute(decoratorElement, \"name\");\n                page = getAttribute(decoratorElement, \"page\");\n                uriPath = getAttribute(decoratorElement, \"webapp\");\n                role = getAttribute(decoratorElement, \"role\");\n\n                // Append the defaultDir\n                if (defaultDir != null && page != null && page.length() > 0) {\n                    if (page.charAt(0) == '/') page = defaultDir + page;\n                    else                       page = defaultDir + '/' + page;\n                }\n\n                // The uriPath must begin with a slash\n                if (uriPath != null && uriPath.length() > 0) {\n                    if (uriPath.charAt(0) != '/') uriPath = '/' + uriPath;\n                }\n\n                // Get all <pattern>...<\/pattern> nodes and add a mapping\n                NodeList patternNodes = decoratorElement.getElementsByTagName(\"pattern\");\n                for (int j = 0; j < patternNodes.getLength(); j++) {\n                    Element p = (Element)patternNodes.item(j);\n                    Text patternText = (Text) p.getFirstChild();\n                    if (patternText != null) {\n                    \tString pattern = patternText.getData().trim();\n\t                    if (role != null) {\n\t                        // concatenate name and role to allow more\n\t                        // than one decorator per role\n\t                        pathMapper.put(name + role, pattern.trim());\n\t                    }\n\t                    else {\n\t                        pathMapper.put(name, pattern.trim());\n\t                    }\n\t                }\n                }\n\n                // Get all <url-pattern>...<\/url-pattern> nodes and add a mapping\n                NodeList urlPatternNodes = decoratorElement.getElementsByTagName(\"url-pattern\");\n                for (int j = 0; j < urlPatternNodes.getLength(); j++) {\n                    Element p = (Element)urlPatternNodes.item(j);\n                    Text patternText = (Text) p.getFirstChild();\n                    if (patternText != null) {\n                    \tString pattern = patternText.getData().trim();\n                    \tif (role != null) {\n                        \t// concatenate name and role to allow more\n                        \t// than one decorator per role\n                        \tpathMapper.put(name + role, pattern);\n                    \t}\n                    \telse {\n                        \tpathMapper.put(name, pattern);\n                    \t}\n                    }\n                }\n            }\n            else {\n                // NOTE: Deprecated format\n                name = getContainedText(decoratorNodes.item(i), \"decorator-name\");\n                page = getContainedText(decoratorNodes.item(i), \"resource\");\n                // We have this here because the use of jsp-file is deprecated, but we still want\n                // it to work.\n                if (page == null) page = getContainedText(decoratorNodes.item(i), \"jsp-file\");\n            }\n\n            Map params = new HashMap();\n\n            NodeList paramNodes = decoratorElement.getElementsByTagName(\"init-param\");\n            for (int ii = 0; ii < paramNodes.getLength(); ii++) {\n                String paramName = getContainedText(paramNodes.item(ii), \"param-name\");\n                String paramValue = getContainedText(paramNodes.item(ii), \"param-value\");\n                params.put(paramName, paramValue);\n            }\n            storeDecorator(new DefaultDecorator(name, page, uriPath, role, params));\n        }\n\n        // Get (deprecated format) decorator-mappings\n        NodeList mappingNodes = root.getElementsByTagName(\"decorator-mapping\");\n        for (int i = 0; i < mappingNodes.getLength(); i++) {\n            Element n = (Element)mappingNodes.item(i);\n            String name = getContainedText(mappingNodes.item(i), \"decorator-name\");\n\n            // Get all <url-pattern>...<\/url-pattern> nodes and add a mapping\n            NodeList patternNodes = n.getElementsByTagName(\"url-pattern\");\n            for (int j = 0; j < patternNodes.getLength(); j++) {\n                Element p = (Element)patternNodes.item(j);\n                Text patternText = (Text) p.getFirstChild();\n                if (patternText != null) pathMapper.put(name, patternText.getData().trim());\n            }\n        }\n    }\n\n    /** Override default behavior of element.getAttribute (returns the empty string) to return null. */\n    private static String getAttribute(Element element, String name) {\n        if (element != null && element.getAttribute(name) != null && element.getAttribute(name).trim() != \"\") {\n            return element.getAttribute(name).trim();\n        }\n        else {\n            return null;\n        }\n    }\n\n    /**\n     * With a given parent XML Element, find the text contents of the child element with\n     * supplied name.\n     */\n    private static String getContainedText(Node parent, String childTagName) {\n        try {\n            Node tag = ((Element)parent).getElementsByTagName(childTagName).item(0);\n            String text = ((Text)tag.getFirstChild()).getData();\n            return text;\n        }\n        catch (Exception e) {\n            return null;\n        }\n    }\n\n    /** Store Decorator in Map */\n    private void storeDecorator(Decorator d) {\n        if (d.getRole() != null) {\n            decorators.put(d.getName() + d.getRole(), d);\n        }\n        else {\n            decorators.put(d.getName(), d);\n        }\n    }\n\n    /** Check if configuration file has been updated, and if so, reload. */\n    private synchronized void refresh() throws ServletException {\n        if (configFile != null && configLastModified != configFile.lastModified()) loadConfig();\n    }\n}\n","Smelly Sample":"/*\n * Title:        ConfigLoader\n * Description:\n *\n * This software is published under the terms of the OpenSymphony Software\n * License version 1.1, of which a copy has been included with this\n * distribution in the LICENSE.txt file.\n */\n\npackage com.opensymphony.module.sitemesh.mapper;\n\nimport com.opensymphony.module.sitemesh.Config;\nimport com.opensymphony.module.sitemesh.Decorator;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.Text;\nimport org.xml.sax.SAXException;\n\nimport javax.servlet.ServletException;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * The ConfigLoader reads a configuration XML file that contains Decorator definitions\n * (name, url, init-params) and path-mappings (pattern, name).\n *\n * <p>These can then be accessed by the getDecoratorByName() methods and getMappedName()\n * methods respectively.<\/p>\n *\n * <p>The DTD for the configuration file in old (deprecated) format is located at\n * <a href=\"http://www.opensymphony.com/dtds/sitemesh_1_0_decorators.dtd\">\n *  http://www.opensymphony.com/dtds/sitemesh_1_0_decorators.dtd\n * <\/a>.<\/p>\n *\n * <p>The DTD for the configuration file in new format is located at\n * <a href=\"http://www.opensymphony.com/dtds/sitemesh_1_5_decorators.dtd\">\n *  http://www.opensymphony.com/dtds/sitemesh_1_5_decorators.dtd\n * <\/a>.<\/p>\n *\n * <p>Editing the config file will cause it to be auto-reloaded.<\/p>\n *\n * <p>This class is used by ConfigDecoratorMapper, and uses PathMapper for pattern matching.<\/p>\n *\n * @author <a href=\"mailto:joe@truemesh.com\">Joe Walnes<\/a>\n * @author <a href=\"mailto:pathos@pandora.be\">Mathias Bogaert<\/a>\n * @version $Revision: 1.1 $\n *\n * @see com.opensymphony.module.sitemesh.mapper.ConfigDecoratorMapper\n * @see com.opensymphony.module.sitemesh.mapper.PathMapper\n */\npublic final class ConfigLoader {\n    private Map decorators = null;\n    private long configLastModified;\n\n    private File configFile = null;\n    private String configFileName = null;\n    private PathMapper pathMapper = null;\n\n    private Config config = null;\n\n    /** Create new ConfigLoader using supplied File. */\n    public ConfigLoader(File configFile) throws ServletException {\n        this.configFile = configFile;\n        this.configFileName = configFile.getName();\n        loadConfig();\n    }\n\n    /** Create new ConfigLoader using supplied filename and config. */\n    public ConfigLoader(String configFileName, Config config) throws ServletException {\n        this.config = config;\n        this.configFileName = configFileName;\n        if (config.getServletContext().getRealPath(configFileName) != null) {\n            this.configFile = new File(config.getServletContext().getRealPath(configFileName));\n        }\n        loadConfig();\n    }\n\n    /** Retrieve Decorator based on name specified in configuration file. */\n    public Decorator getDecoratorByName(String name) throws ServletException {\n        refresh();\n        return (Decorator)decorators.get(name);\n    }\n\n    /** Get name of Decorator mapped to given path. */\n    public String getMappedName(String path) throws ServletException {\n        refresh();\n        return pathMapper.get(path);\n    }\n\n    /** Load configuration from file. */\n    private synchronized void loadConfig() throws ServletException {\n        try {\n            // Build a document from the file\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n\n            Document document = null;\n            if (configFile != null && configFile.canRead()) {\n                // Keep time we read the file to check if the file was modified\n                configLastModified = configFile.lastModified();\n                document = builder.parse(configFile);\n            }\n            else {\n                document = builder.parse(config.getServletContext().getResourceAsStream(configFileName));\n            }\n\n            // Parse the configuration document\n            parseConfig(document);\n        }\n        catch (ParserConfigurationException e) {\n            throw new ServletException(\"Could not get XML parser\", e);\n        }\n        catch (IOException e) {\n            throw new ServletException(\"Could not read config file: \" + configFileName, e);\n        }\n        catch (SAXException e) {\n            throw new ServletException(\"Could not parse config file: \" + configFileName, e);\n        }\n    }\n\n    /** Parse configuration from XML document. */\n    private synchronized void parseConfig(Document document) {\n        Element root = document.getDocumentElement();\n\n        // get the default directory for the decorators\n        String defaultDir = getAttribute(root, \"defaultdir\");\n        if (defaultDir == null) defaultDir = getAttribute(root, \"defaultDir\");\n\n        // Clear previous config\n        pathMapper = new PathMapper();\n        decorators = new HashMap();\n\n        // Get decorators\n        NodeList decoratorNodes = root.getElementsByTagName(\"decorator\");\n        Element decoratorElement = null;\n\n        for (int i = 0; i < decoratorNodes.getLength(); i++) {\n            String name = null, page = null, uriPath = null, role = null;\n\n            // get the current decorator element\n            decoratorElement = (Element) decoratorNodes.item(i);\n\n            if (getAttribute(decoratorElement, \"name\") != null) {\n                // The new format is used\n                name = getAttribute(decoratorElement, \"name\");\n                page = getAttribute(decoratorElement, \"page\");\n                uriPath = getAttribute(decoratorElement, \"webapp\");\n                role = getAttribute(decoratorElement, \"role\");\n\n                // Append the defaultDir\n                if (defaultDir != null && page != null && page.length() > 0) {\n                    if (page.charAt(0) == '/') page = defaultDir + page;\n                    else                       page = defaultDir + '/' + page;\n                }\n\n                // The uriPath must begin with a slash\n                if (uriPath != null && uriPath.length() > 0) {\n                    if (uriPath.charAt(0) != '/') uriPath = '/' + uriPath;\n                }\n\n                // Get all <pattern>...<\/pattern> nodes and add a mapping\n                NodeList patternNodes = decoratorElement.getElementsByTagName(\"pattern\");\n                for (int j = 0; j < patternNodes.getLength(); j++) {\n                    Element p = (Element)patternNodes.item(j);\n                    String pattern = ((Text)p.getFirstChild()).getData();\n                    if (role != null) {\n                        // concatenate name and role to allow more\n                        // than one decorator per role\n                        pathMapper.put(name + role, pattern);\n                    }\n                    else {\n                        pathMapper.put(name, pattern);\n                    }\n                }\n\n                // Get all <url-pattern>...<\/url-pattern> nodes and add a mapping\n                NodeList urlPatternNodes = decoratorElement.getElementsByTagName(\"url-pattern\");\n                for (int j = 0; j < urlPatternNodes.getLength(); j++) {\n                    Element p = (Element)urlPatternNodes.item(j);\n                    String pattern = ((Text)p.getFirstChild()).getData();\n                    if (role != null) {\n                        // concatenate name and role to allow more\n                        // than one decorator per role\n                        pathMapper.put(name + role, pattern);\n                    }\n                    else {\n                        pathMapper.put(name, pattern);\n                    }\n                }\n            }\n            else {\n                // NOTE: Deprecated format\n                name = getContainedText(decoratorNodes.item(i), \"decorator-name\");\n                page = getContainedText(decoratorNodes.item(i), \"resource\");\n                // We have this here because the use of jsp-file is deprecated, but we still want\n                // it to work.\n                if (page == null) page = getContainedText(decoratorNodes.item(i), \"jsp-file\");\n            }\n\n            Map params = new HashMap();\n\n            NodeList paramNodes = decoratorElement.getElementsByTagName(\"init-param\");\n            for (int ii = 0; ii < paramNodes.getLength(); ii++) {\n                String paramName = getContainedText(paramNodes.item(ii), \"param-name\");\n                String paramValue = getContainedText(paramNodes.item(ii), \"param-value\");\n                params.put(paramName, paramValue);\n            }\n            storeDecorator(new DefaultDecorator(name, page, uriPath, role, params));\n        }\n\n        // Get (deprecated format) decorator-mappings\n        NodeList mappingNodes = root.getElementsByTagName(\"decorator-mapping\");\n        for (int i = 0; i < mappingNodes.getLength(); i++) {\n            Element n = (Element)mappingNodes.item(i);\n            String name = getContainedText(mappingNodes.item(i), \"decorator-name\");\n\n            // Get all <url-pattern>...<\/url-pattern> nodes and add a mapping\n            NodeList patternNodes = n.getElementsByTagName(\"url-pattern\");\n            for (int j = 0; j < patternNodes.getLength(); j++) {\n                Element p = (Element)patternNodes.item(j);\n                String pattern = ((Text)p.getFirstChild()).getData();\n                pathMapper.put(name, pattern);\n            }\n        }\n    }\n\n    /** Override default behavior of element.getAttribute (returns the empty string) to return null. */\n    private static String getAttribute(Element element, String name) {\n        if (element != null && element.getAttribute(name) != null && element.getAttribute(name).trim() != \"\") {\n            return element.getAttribute(name).trim();\n        }\n        else {\n            return null;\n        }\n    }\n\n    /**\n     * With a given parent XML Element, find the text contents of the child element with\n     * supplied name.\n     */\n    private static String getContainedText(Node parent, String childTagName) {\n        try {\n            Node tag = ((Element)parent).getElementsByTagName(childTagName).item(0);\n            String text = ((Text)tag.getFirstChild()).getData();\n            return text;\n        }\n        catch (Exception e) {\n            return null;\n        }\n    }\n\n    /** Store Decorator in Map */\n    private void storeDecorator(Decorator d) {\n        if (d.getRole() != null) {\n            decorators.put(d.getName() + d.getRole(), d);\n        }\n        else {\n            decorators.put(d.getName(), d);\n        }\n    }\n\n    /** Check if configuration file has been updated, and if so, reload. */\n    private synchronized void refresh() throws ServletException {\n        if (configFile != null && configLastModified != configFile.lastModified()) loadConfig();\n    }\n}\n","lineNo":191}
{"Refactored Sample":"/*\n * Title:        ConfigLoader\n * Description:\n *\n * This software is published under the terms of the OpenSymphony Software\n * License version 1.1, of which a copy has been included with this\n * distribution in the LICENSE.txt file.\n */\n\npackage com.opensymphony.module.sitemesh.mapper;\n\nimport com.opensymphony.module.sitemesh.Config;\nimport com.opensymphony.module.sitemesh.Decorator;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.Text;\nimport org.xml.sax.SAXException;\n\nimport javax.servlet.ServletException;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * The ConfigLoader reads a configuration XML file that contains Decorator definitions\n * (name, url, init-params) and path-mappings (pattern, name).\n *\n * <p>These can then be accessed by the getDecoratorByName() methods and getMappedName()\n * methods respectively.<\/p>\n *\n * <p>The DTD for the configuration file in old (deprecated) format is located at\n * <a href=\"http://www.opensymphony.com/dtds/sitemesh_1_0_decorators.dtd\">\n *  http://www.opensymphony.com/dtds/sitemesh_1_0_decorators.dtd\n * <\/a>.<\/p>\n *\n * <p>The DTD for the configuration file in new format is located at\n * <a href=\"http://www.opensymphony.com/dtds/sitemesh_1_5_decorators.dtd\">\n *  http://www.opensymphony.com/dtds/sitemesh_1_5_decorators.dtd\n * <\/a>.<\/p>\n *\n * <p>Editing the config file will cause it to be auto-reloaded.<\/p>\n *\n * <p>This class is used by ConfigDecoratorMapper, and uses PathMapper for pattern matching.<\/p>\n *\n * @author <a href=\"mailto:joe@truemesh.com\">Joe Walnes<\/a>\n * @author <a href=\"mailto:pathos@pandora.be\">Mathias Bogaert<\/a>\n * @version $Revision: 1.2 $\n *\n * @see com.opensymphony.module.sitemesh.mapper.ConfigDecoratorMapper\n * @see com.opensymphony.module.sitemesh.mapper.PathMapper\n */\npublic final class ConfigLoader {\n    private Map decorators = null;\n    private long configLastModified;\n\n    private File configFile = null;\n    private String configFileName = null;\n    private PathMapper pathMapper = null;\n\n    private Config config = null;\n\n    /** Create new ConfigLoader using supplied File. */\n    public ConfigLoader(File configFile) throws ServletException {\n        this.configFile = configFile;\n        this.configFileName = configFile.getName();\n        loadConfig();\n    }\n\n    /** Create new ConfigLoader using supplied filename and config. */\n    public ConfigLoader(String configFileName, Config config) throws ServletException {\n        this.config = config;\n        this.configFileName = configFileName;\n        if (config.getServletContext().getRealPath(configFileName) != null) {\n            this.configFile = new File(config.getServletContext().getRealPath(configFileName));\n        }\n        loadConfig();\n    }\n\n    /** Retrieve Decorator based on name specified in configuration file. */\n    public Decorator getDecoratorByName(String name) throws ServletException {\n        refresh();\n        return (Decorator)decorators.get(name);\n    }\n\n    /** Get name of Decorator mapped to given path. */\n    public String getMappedName(String path) throws ServletException {\n        refresh();\n        return pathMapper.get(path);\n    }\n\n    /** Load configuration from file. */\n    private synchronized void loadConfig() throws ServletException {\n        try {\n            // Build a document from the file\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n\n            Document document = null;\n            if (configFile != null && configFile.canRead()) {\n                // Keep time we read the file to check if the file was modified\n                configLastModified = configFile.lastModified();\n                document = builder.parse(configFile);\n            }\n            else {\n                document = builder.parse(config.getServletContext().getResourceAsStream(configFileName));\n            }\n\n            // Parse the configuration document\n            parseConfig(document);\n        }\n        catch (ParserConfigurationException e) {\n            throw new ServletException(\"Could not get XML parser\", e);\n        }\n        catch (IOException e) {\n            throw new ServletException(\"Could not read config file: \" + configFileName, e);\n        }\n        catch (SAXException e) {\n            throw new ServletException(\"Could not parse config file: \" + configFileName, e);\n        }\n    }\n\n    /** Parse configuration from XML document. */\n    private synchronized void parseConfig(Document document) {\n        Element root = document.getDocumentElement();\n\n        // get the default directory for the decorators\n        String defaultDir = getAttribute(root, \"defaultdir\");\n        if (defaultDir == null) defaultDir = getAttribute(root, \"defaultDir\");\n\n        // Clear previous config\n        pathMapper = new PathMapper();\n        decorators = new HashMap();\n\n        // Get decorators\n        NodeList decoratorNodes = root.getElementsByTagName(\"decorator\");\n        Element decoratorElement = null;\n\n        for (int i = 0; i < decoratorNodes.getLength(); i++) {\n            String name = null, page = null, uriPath = null, role = null;\n\n            // get the current decorator element\n            decoratorElement = (Element) decoratorNodes.item(i);\n\n            if (getAttribute(decoratorElement, \"name\") != null) {\n                // The new format is used\n                name = getAttribute(decoratorElement, \"name\");\n                page = getAttribute(decoratorElement, \"page\");\n                uriPath = getAttribute(decoratorElement, \"webapp\");\n                role = getAttribute(decoratorElement, \"role\");\n\n                // Append the defaultDir\n                if (defaultDir != null && page != null && page.length() > 0) {\n                    if (page.charAt(0) == '/') page = defaultDir + page;\n                    else                       page = defaultDir + '/' + page;\n                }\n\n                // The uriPath must begin with a slash\n                if (uriPath != null && uriPath.length() > 0) {\n                    if (uriPath.charAt(0) != '/') uriPath = '/' + uriPath;\n                }\n\n                // Get all <pattern>...<\/pattern> nodes and add a mapping\n                NodeList patternNodes = decoratorElement.getElementsByTagName(\"pattern\");\n                for (int j = 0; j < patternNodes.getLength(); j++) {\n                    Element p = (Element)patternNodes.item(j);\n                    Text patternText = (Text) p.getFirstChild();\n                    if (patternText != null) {\n                    \tString pattern = patternText.getData().trim();\n\t                    if (role != null) {\n\t                        // concatenate name and role to allow more\n\t                        // than one decorator per role\n\t                        pathMapper.put(name + role, pattern.trim());\n\t                    }\n\t                    else {\n\t                        pathMapper.put(name, pattern.trim());\n\t                    }\n\t                }\n                }\n\n                // Get all <url-pattern>...<\/url-pattern> nodes and add a mapping\n                NodeList urlPatternNodes = decoratorElement.getElementsByTagName(\"url-pattern\");\n                for (int j = 0; j < urlPatternNodes.getLength(); j++) {\n                    Element p = (Element)urlPatternNodes.item(j);\n                    Text patternText = (Text) p.getFirstChild();\n                    if (patternText != null) {\n                    \tString pattern = patternText.getData().trim();\n                    \tif (role != null) {\n                        \t// concatenate name and role to allow more\n                        \t// than one decorator per role\n                        \tpathMapper.put(name + role, pattern);\n                    \t}\n                    \telse {\n                        \tpathMapper.put(name, pattern);\n                    \t}\n                    }\n                }\n            }\n            else {\n                // NOTE: Deprecated format\n                name = getContainedText(decoratorNodes.item(i), \"decorator-name\");\n                page = getContainedText(decoratorNodes.item(i), \"resource\");\n                // We have this here because the use of jsp-file is deprecated, but we still want\n                // it to work.\n                if (page == null) page = getContainedText(decoratorNodes.item(i), \"jsp-file\");\n            }\n\n            Map params = new HashMap();\n\n            NodeList paramNodes = decoratorElement.getElementsByTagName(\"init-param\");\n            for (int ii = 0; ii < paramNodes.getLength(); ii++) {\n                String paramName = getContainedText(paramNodes.item(ii), \"param-name\");\n                String paramValue = getContainedText(paramNodes.item(ii), \"param-value\");\n                params.put(paramName, paramValue);\n            }\n            storeDecorator(new DefaultDecorator(name, page, uriPath, role, params));\n        }\n\n        // Get (deprecated format) decorator-mappings\n        NodeList mappingNodes = root.getElementsByTagName(\"decorator-mapping\");\n        for (int i = 0; i < mappingNodes.getLength(); i++) {\n            Element n = (Element)mappingNodes.item(i);\n            String name = getContainedText(mappingNodes.item(i), \"decorator-name\");\n\n            // Get all <url-pattern>...<\/url-pattern> nodes and add a mapping\n            NodeList patternNodes = n.getElementsByTagName(\"url-pattern\");\n            for (int j = 0; j < patternNodes.getLength(); j++) {\n                Element p = (Element)patternNodes.item(j);\n                Text patternText = (Text) p.getFirstChild();\n                if (patternText != null) pathMapper.put(name, patternText.getData().trim());\n            }\n        }\n    }\n\n    /** Override default behavior of element.getAttribute (returns the empty string) to return null. */\n    private static String getAttribute(Element element, String name) {\n        if (element != null && element.getAttribute(name) != null && element.getAttribute(name).trim() != \"\") {\n            return element.getAttribute(name).trim();\n        }\n        else {\n            return null;\n        }\n    }\n\n    /**\n     * With a given parent XML Element, find the text contents of the child element with\n     * supplied name.\n     */\n    private static String getContainedText(Node parent, String childTagName) {\n        try {\n            Node tag = ((Element)parent).getElementsByTagName(childTagName).item(0);\n            String text = ((Text)tag.getFirstChild()).getData();\n            return text;\n        }\n        catch (Exception e) {\n            return null;\n        }\n    }\n\n    /** Store Decorator in Map */\n    private void storeDecorator(Decorator d) {\n        if (d.getRole() != null) {\n            decorators.put(d.getName() + d.getRole(), d);\n        }\n        else {\n            decorators.put(d.getName(), d);\n        }\n    }\n\n    /** Check if configuration file has been updated, and if so, reload. */\n    private synchronized void refresh() throws ServletException {\n        if (configFile != null && configLastModified != configFile.lastModified()) loadConfig();\n    }\n}\n","Smelly Sample":"/*\n * Title:        ConfigLoader\n * Description:\n *\n * This software is published under the terms of the OpenSymphony Software\n * License version 1.1, of which a copy has been included with this\n * distribution in the LICENSE.txt file.\n */\n\npackage com.opensymphony.module.sitemesh.mapper;\n\nimport com.opensymphony.module.sitemesh.Config;\nimport com.opensymphony.module.sitemesh.Decorator;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.Text;\nimport org.xml.sax.SAXException;\n\nimport javax.servlet.ServletException;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * The ConfigLoader reads a configuration XML file that contains Decorator definitions\n * (name, url, init-params) and path-mappings (pattern, name).\n *\n * <p>These can then be accessed by the getDecoratorByName() methods and getMappedName()\n * methods respectively.<\/p>\n *\n * <p>The DTD for the configuration file in old (deprecated) format is located at\n * <a href=\"http://www.opensymphony.com/dtds/sitemesh_1_0_decorators.dtd\">\n *  http://www.opensymphony.com/dtds/sitemesh_1_0_decorators.dtd\n * <\/a>.<\/p>\n *\n * <p>The DTD for the configuration file in new format is located at\n * <a href=\"http://www.opensymphony.com/dtds/sitemesh_1_5_decorators.dtd\">\n *  http://www.opensymphony.com/dtds/sitemesh_1_5_decorators.dtd\n * <\/a>.<\/p>\n *\n * <p>Editing the config file will cause it to be auto-reloaded.<\/p>\n *\n * <p>This class is used by ConfigDecoratorMapper, and uses PathMapper for pattern matching.<\/p>\n *\n * @author <a href=\"mailto:joe@truemesh.com\">Joe Walnes<\/a>\n * @author <a href=\"mailto:pathos@pandora.be\">Mathias Bogaert<\/a>\n * @version $Revision: 1.1 $\n *\n * @see com.opensymphony.module.sitemesh.mapper.ConfigDecoratorMapper\n * @see com.opensymphony.module.sitemesh.mapper.PathMapper\n */\npublic final class ConfigLoader {\n    private Map decorators = null;\n    private long configLastModified;\n\n    private File configFile = null;\n    private String configFileName = null;\n    private PathMapper pathMapper = null;\n\n    private Config config = null;\n\n    /** Create new ConfigLoader using supplied File. */\n    public ConfigLoader(File configFile) throws ServletException {\n        this.configFile = configFile;\n        this.configFileName = configFile.getName();\n        loadConfig();\n    }\n\n    /** Create new ConfigLoader using supplied filename and config. */\n    public ConfigLoader(String configFileName, Config config) throws ServletException {\n        this.config = config;\n        this.configFileName = configFileName;\n        if (config.getServletContext().getRealPath(configFileName) != null) {\n            this.configFile = new File(config.getServletContext().getRealPath(configFileName));\n        }\n        loadConfig();\n    }\n\n    /** Retrieve Decorator based on name specified in configuration file. */\n    public Decorator getDecoratorByName(String name) throws ServletException {\n        refresh();\n        return (Decorator)decorators.get(name);\n    }\n\n    /** Get name of Decorator mapped to given path. */\n    public String getMappedName(String path) throws ServletException {\n        refresh();\n        return pathMapper.get(path);\n    }\n\n    /** Load configuration from file. */\n    private synchronized void loadConfig() throws ServletException {\n        try {\n            // Build a document from the file\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n\n            Document document = null;\n            if (configFile != null && configFile.canRead()) {\n                // Keep time we read the file to check if the file was modified\n                configLastModified = configFile.lastModified();\n                document = builder.parse(configFile);\n            }\n            else {\n                document = builder.parse(config.getServletContext().getResourceAsStream(configFileName));\n            }\n\n            // Parse the configuration document\n            parseConfig(document);\n        }\n        catch (ParserConfigurationException e) {\n            throw new ServletException(\"Could not get XML parser\", e);\n        }\n        catch (IOException e) {\n            throw new ServletException(\"Could not read config file: \" + configFileName, e);\n        }\n        catch (SAXException e) {\n            throw new ServletException(\"Could not parse config file: \" + configFileName, e);\n        }\n    }\n\n    /** Parse configuration from XML document. */\n    private synchronized void parseConfig(Document document) {\n        Element root = document.getDocumentElement();\n\n        // get the default directory for the decorators\n        String defaultDir = getAttribute(root, \"defaultdir\");\n        if (defaultDir == null) defaultDir = getAttribute(root, \"defaultDir\");\n\n        // Clear previous config\n        pathMapper = new PathMapper();\n        decorators = new HashMap();\n\n        // Get decorators\n        NodeList decoratorNodes = root.getElementsByTagName(\"decorator\");\n        Element decoratorElement = null;\n\n        for (int i = 0; i < decoratorNodes.getLength(); i++) {\n            String name = null, page = null, uriPath = null, role = null;\n\n            // get the current decorator element\n            decoratorElement = (Element) decoratorNodes.item(i);\n\n            if (getAttribute(decoratorElement, \"name\") != null) {\n                // The new format is used\n                name = getAttribute(decoratorElement, \"name\");\n                page = getAttribute(decoratorElement, \"page\");\n                uriPath = getAttribute(decoratorElement, \"webapp\");\n                role = getAttribute(decoratorElement, \"role\");\n\n                // Append the defaultDir\n                if (defaultDir != null && page != null && page.length() > 0) {\n                    if (page.charAt(0) == '/') page = defaultDir + page;\n                    else                       page = defaultDir + '/' + page;\n                }\n\n                // The uriPath must begin with a slash\n                if (uriPath != null && uriPath.length() > 0) {\n                    if (uriPath.charAt(0) != '/') uriPath = '/' + uriPath;\n                }\n\n                // Get all <pattern>...<\/pattern> nodes and add a mapping\n                NodeList patternNodes = decoratorElement.getElementsByTagName(\"pattern\");\n                for (int j = 0; j < patternNodes.getLength(); j++) {\n                    Element p = (Element)patternNodes.item(j);\n                    String pattern = ((Text)p.getFirstChild()).getData();\n                    if (role != null) {\n                        // concatenate name and role to allow more\n                        // than one decorator per role\n                        pathMapper.put(name + role, pattern);\n                    }\n                    else {\n                        pathMapper.put(name, pattern);\n                    }\n                }\n\n                // Get all <url-pattern>...<\/url-pattern> nodes and add a mapping\n                NodeList urlPatternNodes = decoratorElement.getElementsByTagName(\"url-pattern\");\n                for (int j = 0; j < urlPatternNodes.getLength(); j++) {\n                    Element p = (Element)urlPatternNodes.item(j);\n                    String pattern = ((Text)p.getFirstChild()).getData();\n                    if (role != null) {\n                        // concatenate name and role to allow more\n                        // than one decorator per role\n                        pathMapper.put(name + role, pattern);\n                    }\n                    else {\n                        pathMapper.put(name, pattern);\n                    }\n                }\n            }\n            else {\n                // NOTE: Deprecated format\n                name = getContainedText(decoratorNodes.item(i), \"decorator-name\");\n                page = getContainedText(decoratorNodes.item(i), \"resource\");\n                // We have this here because the use of jsp-file is deprecated, but we still want\n                // it to work.\n                if (page == null) page = getContainedText(decoratorNodes.item(i), \"jsp-file\");\n            }\n\n            Map params = new HashMap();\n\n            NodeList paramNodes = decoratorElement.getElementsByTagName(\"init-param\");\n            for (int ii = 0; ii < paramNodes.getLength(); ii++) {\n                String paramName = getContainedText(paramNodes.item(ii), \"param-name\");\n                String paramValue = getContainedText(paramNodes.item(ii), \"param-value\");\n                params.put(paramName, paramValue);\n            }\n            storeDecorator(new DefaultDecorator(name, page, uriPath, role, params));\n        }\n\n        // Get (deprecated format) decorator-mappings\n        NodeList mappingNodes = root.getElementsByTagName(\"decorator-mapping\");\n        for (int i = 0; i < mappingNodes.getLength(); i++) {\n            Element n = (Element)mappingNodes.item(i);\n            String name = getContainedText(mappingNodes.item(i), \"decorator-name\");\n\n            // Get all <url-pattern>...<\/url-pattern> nodes and add a mapping\n            NodeList patternNodes = n.getElementsByTagName(\"url-pattern\");\n            for (int j = 0; j < patternNodes.getLength(); j++) {\n                Element p = (Element)patternNodes.item(j);\n                String pattern = ((Text)p.getFirstChild()).getData();\n                pathMapper.put(name, pattern);\n            }\n        }\n    }\n\n    /** Override default behavior of element.getAttribute (returns the empty string) to return null. */\n    private static String getAttribute(Element element, String name) {\n        if (element != null && element.getAttribute(name) != null && element.getAttribute(name).trim() != \"\") {\n            return element.getAttribute(name).trim();\n        }\n        else {\n            return null;\n        }\n    }\n\n    /**\n     * With a given parent XML Element, find the text contents of the child element with\n     * supplied name.\n     */\n    private static String getContainedText(Node parent, String childTagName) {\n        try {\n            Node tag = ((Element)parent).getElementsByTagName(childTagName).item(0);\n            String text = ((Text)tag.getFirstChild()).getData();\n            return text;\n        }\n        catch (Exception e) {\n            return null;\n        }\n    }\n\n    /** Store Decorator in Map */\n    private void storeDecorator(Decorator d) {\n        if (d.getRole() != null) {\n            decorators.put(d.getName() + d.getRole(), d);\n        }\n        else {\n            decorators.put(d.getName(), d);\n        }\n    }\n\n    /** Check if configuration file has been updated, and if so, reload. */\n    private synchronized void refresh() throws ServletException {\n        if (configFile != null && configLastModified != configFile.lastModified()) loadConfig();\n    }\n}\n","lineNo":235}
{"Refactored Sample":"/*\n * Title:        AgentDecoratorMapper\n * Description:\n *\n * This software is published under the terms of the OpenSymphony Software\n * License version 1.1, of which a copy has been included with this\n * distribution in the LICENSE.txt file.\n */\n\npackage com.opensymphony.module.sitemesh.mapper;\n\nimport com.opensymphony.module.sitemesh.Config;\nimport com.opensymphony.module.sitemesh.Decorator;\nimport com.opensymphony.module.sitemesh.DecoratorMapper;\nimport com.opensymphony.module.sitemesh.Page;\n\nimport javax.servlet.http.HttpServletRequest;\nimport java.io.File;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Properties;\n\n/**\n * The AgentDecoratorMapper can determine the user-agent (i.e. web-browser)\n * requesting a page, and map to a suitable Decorator.\n *\n * <p>This can be useful for supplying different versions of the same content\n * for different browsers (e.g. vanilla HTML for Lynx, complex tables and frames\n * for Netscape, extra stuff for IE5, etc).<\/p>\n *\n * <p>This can also be used to enhance search-engine ratings by using a 'bait and\n * switch' system - this involves showing a search-engine friendly of the content\n * to spiders only.<\/p>\n *\n * <p>When AgentDecoratorMapper is in the chain, it will request the appropriate Decorator\n * from its parent. It will then add an extention to the filename of the Decorator, and\n * if that file exists it shall be used as the Decorator instead. For example, if the\n * Decorator path is <code>/blah.jsp<\/code> and the detected user-agent is <code>ie<\/code>,\n * the path <code>/blah-ie.jsp<\/code> shall be used.<\/p>\n *\n * <p>The agent mappings are configured by passing properties with <code>match.<\/code> as a prefix.\n * For example: 'match.MSIE'=ie , 'match.Lynx'=plain .<\/p>\n *\n * @author <a href=\"mailto:joe@truemesh.com\">Joe Walnes<\/a>\n * @version $Revision: 1.2 $\n *\n * @see com.opensymphony.module.sitemesh.DecoratorMapper\n */\npublic final class AgentDecoratorMapper extends AbstractDecoratorMapper {\n    private Map map = null;\n\n    public void init(Config config, Properties properties, DecoratorMapper parent) throws InstantiationException {\n        super.init(config, properties, parent);\n        map = new HashMap();\n        initMap(properties);\n    }\n\n    public Decorator getDecorator(HttpServletRequest request, Page page) {\n        try {\n            Decorator result = null;\n            final Decorator d = super.getDecorator(request, page);\n            String path = modifyPath(d.getPage(), getExt(request.getHeader(\"User-Agent\")));\n\n            File decFile = new File(config.getServletContext().getRealPath(path));\n\n            if (decFile.isFile()) {\n                result = new DefaultDecorator(d.getName(), path, null) {\n                    public String getInitParameter(String paramName) {\n                        return d.getInitParameter(paramName);\n                    }\n                };\n            }\n            return result == null ? super.getDecorator(request, page) : result;\n        }\n        catch (NullPointerException e) {\n            return super.getDecorator(request, page);\n        }\n    }\n\n    /** Get extention for user-agent. */\n    private String getExt(String userAgent) {\n        Iterator i = map.entrySet().iterator();\n        while (i.hasNext()) {\n            Map.Entry entry = (Map.Entry) i.next();\n            String curr = (String) entry.getKey();\n            if (userAgent.indexOf(curr) > -1) return (String) entry.getValue();\n        }\n        return null;\n    }\n\n    /** Change /abc/def.jsp into /abc/def-XYZ.jsp */\n    private static String modifyPath(String path, String ext) {\n        int dot = path.indexOf('.');\n        if (dot > -1) {\n            return path.substring(0, dot) + '-' + ext + path.substring(dot);\n        }\n        else {\n            return path + '-' + ext;\n        }\n    }\n\n    /** Initialize user-agent mappings. */\n    private void initMap(Properties props) {\n        Iterator i = props.entrySet().iterator();\n        while (i.hasNext()) {\n            Map.Entry entry = (Map.Entry) i.next();\n            String key = (String) entry.getKey();\n            if (key.startsWith(\"match.\")) {\n                String match = key.substring(6);\n                String ext = (String) entry.getValue();\n                map.put(match, ext);\n            }\n        }\n    }\n}\n","Smelly Sample":"/*\n * Title:        AgentDecoratorMapper\n * Description:\n *\n * This software is published under the terms of the OpenSymphony Software\n * License version 1.1, of which a copy has been included with this\n * distribution in the LICENSE.txt file.\n */\n\npackage com.opensymphony.module.sitemesh.mapper;\n\nimport com.opensymphony.module.sitemesh.Config;\nimport com.opensymphony.module.sitemesh.Decorator;\nimport com.opensymphony.module.sitemesh.DecoratorMapper;\nimport com.opensymphony.module.sitemesh.Page;\n\nimport javax.servlet.http.HttpServletRequest;\nimport java.io.File;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Properties;\n\n/**\n * The AgentDecoratorMapper can determine the user-agent (i.e. web-browser)\n * requesting a page, and map to a suitable Decorator.\n *\n * <p>This can be useful for supplying different versions of the same content\n * for different browsers (e.g. vanilla HTML for Lynx, complex tables and frames\n * for Netscape, extra stuff for IE5, etc).<\/p>\n *\n * <p>This can also be used to enhance search-engine ratings by using a 'bait and\n * switch' system - this involves showing a search-engine friendly of the content\n * to spiders only.<\/p>\n *\n * <p>When AgentDecoratorMapper is in the chain, it will request the appropriate Decorator\n * from its parent. It will then add an extention to the filename of the Decorator, and\n * if that file exists it shall be used as the Decorator instead. For example, if the\n * Decorator path is <code>/blah.jsp<\/code> and the detected user-agent is <code>ie<\/code>,\n * the path <code>/blah-ie.jsp<\/code> shall be used.<\/p>\n *\n * <p>The agent mappings are configured by passing properties with <code>match.<\/code> as a prefix.\n * For example: 'match.MSIE'=ie , 'match.Lynx'=plain .<\/p>\n *\n * @author <a href=\"mailto:joe@truemesh.com\">Joe Walnes<\/a>\n * @version $Revision: 1.1 $\n *\n * @see com.opensymphony.module.sitemesh.DecoratorMapper\n */\npublic final class AgentDecoratorMapper extends AbstractDecoratorMapper {\n    private Map map = null;\n\n    public void init(Config config, Properties properties, DecoratorMapper parent) throws InstantiationException {\n        super.init(config, properties, parent);\n        map = new HashMap();\n        initMap(properties);\n    }\n\n    public Decorator getDecorator(HttpServletRequest request, Page page) {\n        try {\n            Decorator result = null;\n            final Decorator d = super.getDecorator(request, page);\n            String path = modifyPath(d.getPage(), getExt(request.getHeader(\"User-Agent\")));\n\n            File decFile = new File(config.getServletContext().getRealPath(path));\n\n            if (decFile.isFile()) {\n                result = new DefaultDecorator(d.getName(), path, null) {\n                    public String getInitParameter(String paramName) {\n                        return d.getInitParameter(paramName);\n                    }\n                };\n            }\n            return result == null ? super.getDecorator(request, page) : result;\n        }\n        catch (NullPointerException e) {\n            return super.getDecorator(request, page);\n        }\n    }\n\n    /** Get extention for user-agent. */\n    private String getExt(String userAgent) {\n        Iterator i = map.keySet().iterator();\n        while (i.hasNext()) {\n            String curr = (String)i.next();\n            if (userAgent.indexOf(curr) > -1) return (String)map.get(curr);\n        }\n        return null;\n    }\n\n    /** Change /abc/def.jsp into /abc/def-XYZ.jsp */\n    private static String modifyPath(String path, String ext) {\n        int dot = path.indexOf('.');\n        if (dot > -1) {\n            return path.substring(0, dot) + '-' + ext + path.substring(dot);\n        }\n        else {\n            return path + '-' + ext;\n        }\n    }\n\n    /** Initialize user-agent mappings. */\n    private void initMap(Properties props) {\n        Iterator i = props.keySet().iterator();\n        while (i.hasNext()) {\n            String key = (String)i.next();\n            if (key.startsWith(\"match.\")) {\n                String match = key.substring(6);\n                String ext = props.getProperty(key);\n                map.put(match, ext);\n            }\n        }\n    }\n}\n","lineNo":85}
{"Refactored Sample":"/*\n * Title:        AgentDecoratorMapper\n * Description:\n *\n * This software is published under the terms of the OpenSymphony Software\n * License version 1.1, of which a copy has been included with this\n * distribution in the LICENSE.txt file.\n */\n\npackage com.opensymphony.module.sitemesh.mapper;\n\nimport com.opensymphony.module.sitemesh.Config;\nimport com.opensymphony.module.sitemesh.Decorator;\nimport com.opensymphony.module.sitemesh.DecoratorMapper;\nimport com.opensymphony.module.sitemesh.Page;\n\nimport javax.servlet.http.HttpServletRequest;\nimport java.io.File;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Properties;\n\n/**\n * The AgentDecoratorMapper can determine the user-agent (i.e. web-browser)\n * requesting a page, and map to a suitable Decorator.\n *\n * <p>This can be useful for supplying different versions of the same content\n * for different browsers (e.g. vanilla HTML for Lynx, complex tables and frames\n * for Netscape, extra stuff for IE5, etc).<\/p>\n *\n * <p>This can also be used to enhance search-engine ratings by using a 'bait and\n * switch' system - this involves showing a search-engine friendly of the content\n * to spiders only.<\/p>\n *\n * <p>When AgentDecoratorMapper is in the chain, it will request the appropriate Decorator\n * from its parent. It will then add an extention to the filename of the Decorator, and\n * if that file exists it shall be used as the Decorator instead. For example, if the\n * Decorator path is <code>/blah.jsp<\/code> and the detected user-agent is <code>ie<\/code>,\n * the path <code>/blah-ie.jsp<\/code> shall be used.<\/p>\n *\n * <p>The agent mappings are configured by passing properties with <code>match.<\/code> as a prefix.\n * For example: 'match.MSIE'=ie , 'match.Lynx'=plain .<\/p>\n *\n * @author <a href=\"mailto:joe@truemesh.com\">Joe Walnes<\/a>\n * @version $Revision: 1.2 $\n *\n * @see com.opensymphony.module.sitemesh.DecoratorMapper\n */\npublic final class AgentDecoratorMapper extends AbstractDecoratorMapper {\n    private Map map = null;\n\n    public void init(Config config, Properties properties, DecoratorMapper parent) throws InstantiationException {\n        super.init(config, properties, parent);\n        map = new HashMap();\n        initMap(properties);\n    }\n\n    public Decorator getDecorator(HttpServletRequest request, Page page) {\n        try {\n            Decorator result = null;\n            final Decorator d = super.getDecorator(request, page);\n            String path = modifyPath(d.getPage(), getExt(request.getHeader(\"User-Agent\")));\n\n            File decFile = new File(config.getServletContext().getRealPath(path));\n\n            if (decFile.isFile()) {\n                result = new DefaultDecorator(d.getName(), path, null) {\n                    public String getInitParameter(String paramName) {\n                        return d.getInitParameter(paramName);\n                    }\n                };\n            }\n            return result == null ? super.getDecorator(request, page) : result;\n        }\n        catch (NullPointerException e) {\n            return super.getDecorator(request, page);\n        }\n    }\n\n    /** Get extention for user-agent. */\n    private String getExt(String userAgent) {\n        Iterator i = map.entrySet().iterator();\n        while (i.hasNext()) {\n            Map.Entry entry = (Map.Entry) i.next();\n            String curr = (String) entry.getKey();\n            if (userAgent.indexOf(curr) > -1) return (String) entry.getValue();\n        }\n        return null;\n    }\n\n    /** Change /abc/def.jsp into /abc/def-XYZ.jsp */\n    private static String modifyPath(String path, String ext) {\n        int dot = path.indexOf('.');\n        if (dot > -1) {\n            return path.substring(0, dot) + '-' + ext + path.substring(dot);\n        }\n        else {\n            return path + '-' + ext;\n        }\n    }\n\n    /** Initialize user-agent mappings. */\n    private void initMap(Properties props) {\n        Iterator i = props.entrySet().iterator();\n        while (i.hasNext()) {\n            Map.Entry entry = (Map.Entry) i.next();\n            String key = (String) entry.getKey();\n            if (key.startsWith(\"match.\")) {\n                String match = key.substring(6);\n                String ext = (String) entry.getValue();\n                map.put(match, ext);\n            }\n        }\n    }\n}\n","Smelly Sample":"/*\n * Title:        AgentDecoratorMapper\n * Description:\n *\n * This software is published under the terms of the OpenSymphony Software\n * License version 1.1, of which a copy has been included with this\n * distribution in the LICENSE.txt file.\n */\n\npackage com.opensymphony.module.sitemesh.mapper;\n\nimport com.opensymphony.module.sitemesh.Config;\nimport com.opensymphony.module.sitemesh.Decorator;\nimport com.opensymphony.module.sitemesh.DecoratorMapper;\nimport com.opensymphony.module.sitemesh.Page;\n\nimport javax.servlet.http.HttpServletRequest;\nimport java.io.File;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Properties;\n\n/**\n * The AgentDecoratorMapper can determine the user-agent (i.e. web-browser)\n * requesting a page, and map to a suitable Decorator.\n *\n * <p>This can be useful for supplying different versions of the same content\n * for different browsers (e.g. vanilla HTML for Lynx, complex tables and frames\n * for Netscape, extra stuff for IE5, etc).<\/p>\n *\n * <p>This can also be used to enhance search-engine ratings by using a 'bait and\n * switch' system - this involves showing a search-engine friendly of the content\n * to spiders only.<\/p>\n *\n * <p>When AgentDecoratorMapper is in the chain, it will request the appropriate Decorator\n * from its parent. It will then add an extention to the filename of the Decorator, and\n * if that file exists it shall be used as the Decorator instead. For example, if the\n * Decorator path is <code>/blah.jsp<\/code> and the detected user-agent is <code>ie<\/code>,\n * the path <code>/blah-ie.jsp<\/code> shall be used.<\/p>\n *\n * <p>The agent mappings are configured by passing properties with <code>match.<\/code> as a prefix.\n * For example: 'match.MSIE'=ie , 'match.Lynx'=plain .<\/p>\n *\n * @author <a href=\"mailto:joe@truemesh.com\">Joe Walnes<\/a>\n * @version $Revision: 1.1 $\n *\n * @see com.opensymphony.module.sitemesh.DecoratorMapper\n */\npublic final class AgentDecoratorMapper extends AbstractDecoratorMapper {\n    private Map map = null;\n\n    public void init(Config config, Properties properties, DecoratorMapper parent) throws InstantiationException {\n        super.init(config, properties, parent);\n        map = new HashMap();\n        initMap(properties);\n    }\n\n    public Decorator getDecorator(HttpServletRequest request, Page page) {\n        try {\n            Decorator result = null;\n            final Decorator d = super.getDecorator(request, page);\n            String path = modifyPath(d.getPage(), getExt(request.getHeader(\"User-Agent\")));\n\n            File decFile = new File(config.getServletContext().getRealPath(path));\n\n            if (decFile.isFile()) {\n                result = new DefaultDecorator(d.getName(), path, null) {\n                    public String getInitParameter(String paramName) {\n                        return d.getInitParameter(paramName);\n                    }\n                };\n            }\n            return result == null ? super.getDecorator(request, page) : result;\n        }\n        catch (NullPointerException e) {\n            return super.getDecorator(request, page);\n        }\n    }\n\n    /** Get extention for user-agent. */\n    private String getExt(String userAgent) {\n        Iterator i = map.keySet().iterator();\n        while (i.hasNext()) {\n            String curr = (String)i.next();\n            if (userAgent.indexOf(curr) > -1) return (String)map.get(curr);\n        }\n        return null;\n    }\n\n    /** Change /abc/def.jsp into /abc/def-XYZ.jsp */\n    private static String modifyPath(String path, String ext) {\n        int dot = path.indexOf('.');\n        if (dot > -1) {\n            return path.substring(0, dot) + '-' + ext + path.substring(dot);\n        }\n        else {\n            return path + '-' + ext;\n        }\n    }\n\n    /** Initialize user-agent mappings. */\n    private void initMap(Properties props) {\n        Iterator i = props.keySet().iterator();\n        while (i.hasNext()) {\n            String key = (String)i.next();\n            if (key.startsWith(\"match.\")) {\n                String match = key.substring(6);\n                String ext = props.getProperty(key);\n                map.put(match, ext);\n            }\n        }\n    }\n}\n","lineNo":107}
{"Refactored Sample":"/*\n * Title:        LanguageDecoratorMapper\n * Description:\n *\n * This software is published under the terms of the OpenSymphony Software\n * License version 1.1, of which a copy has been included with this\n * distribution in the LICENSE.txt file.\n */\n\npackage com.opensymphony.module.sitemesh.mapper;\n\nimport com.opensymphony.module.sitemesh.Config;\nimport com.opensymphony.module.sitemesh.Decorator;\nimport com.opensymphony.module.sitemesh.DecoratorMapper;\nimport com.opensymphony.module.sitemesh.Page;\n\nimport javax.servlet.http.HttpServletRequest;\nimport java.io.File;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Properties;\n\n/**\n * The LanguageDecoratorMapper can determine the preferred language set in the\n * browser requesting a page, and map to a suitable Decorator (using the\n * \"Accept-Language\" HTTP header).\n *\n * <p>This can be useful for supplying different versions of the same content\n * for different languages.<\/p>\n *\n * <p>When LanguageDecoratorMapper is in the chain, it will request the appropriate Decorator\n * from its parent. It will then add an extention to the filename of the Decorator, and\n * if that file exists it shall be used as the Decorator instead. For example, if the\n * Decorator path is <code>/blah.jsp<\/code> and the detected preferred language is <code>en<\/code>,\n * the path <code>/blah-en.jsp<\/code> shall be used.<\/p>\n *\n * <p>The language mappings are configured by passing properties with <code>match.<\/code> as a prefix.\n * For example: 'match.en'=engl , 'match.nl'=dutch .<\/p>\n *\n * @author <a href=\"mailto:pathos@pandora.be\">Mathias Bogaert<\/a>\n *\n * @see com.opensymphony.module.sitemesh.DecoratorMapper\n */\npublic final class LanguageDecoratorMapper extends AbstractDecoratorMapper {\n    private Map map = null;\n\n    public void init(Config config, Properties properties, DecoratorMapper parent) throws InstantiationException {\n        super.init(config, properties, parent);\n        map = new HashMap();\n        initMap(properties);\n    }\n\n    public Decorator getDecorator(HttpServletRequest request, Page page) {\n        try {\n            Decorator result = null;\n            final Decorator d = super.getDecorator(request, page);\n            String path = modifyPath(d.getPage(), getExt(request.getHeader(\"Accept-Language\")));\n\n            File decFile = new File(config.getServletContext().getRealPath(path));\n\n            if (decFile.isFile()) {\n                result = new DefaultDecorator(d.getName(), path, null) {\n                    public String getInitParameter(String paramName) {\n                        return d.getInitParameter(paramName);\n                    }\n                };\n            }\n            return result == null ? super.getDecorator(request, page) : result;\n        }\n        catch (NullPointerException e) {\n            return super.getDecorator(request, page);\n        }\n    }\n\n    /** Get extention for the language. */\n    private String getExt(String acceptLanguage) {\n        Iterator i = map.entrySet().iterator();\n        while (i.hasNext()) {\n            Map.Entry entry = (Map.Entry) i.next();\n\n           // Get the first language (preferred one) in the header, and\n            // only check the first two chars (the acceptLanguage could be en-gb, but\n            // we don't support this for now).\n            if (acceptLanguage.substring(0, 2).equals(entry.getKey())) {\n                return (String) entry.getValue();\n            }\n\n            // When the user-agent has multiple accept-languages (separated by ;),\n            // these are ignored because the site creator may wish that if the\n            // preferred language is not supported, the page uses the default\n            // decorator (in the default language), and not in some other\n            // language given by the browser (most of them are specified by\n            // default at install).\n        }\n        return null;\n    }\n\n    /** Change /abc/def.jsp into /abc/def-XYZ.jsp */\n    private static String modifyPath(String path, String ext) {\n        int dot = path.indexOf('.');\n        if (dot > -1) {\n            return path.substring(0, dot) + '-' + ext + path.substring(dot);\n        }\n        else {\n            return path + '-' + ext;\n        }\n    }\n\n    /** Initialize language mappings. */\n    private void initMap(Properties props) {\n        Iterator i = props.entrySet().iterator();\n        while (i.hasNext()) {\n            Map.Entry entry = (Map.Entry) i.next();\n            String key = (String) entry.getKey();\n            if (key.startsWith(\"match.\")) {\n                String match = key.substring(6);\n               map.put(match, entry.getValue());\n            }\n        }\n    }\n}\n","Smelly Sample":"/*\n * Title:        LanguageDecoratorMapper\n * Description:\n *\n * This software is published under the terms of the OpenSymphony Software\n * License version 1.1, of which a copy has been included with this\n * distribution in the LICENSE.txt file.\n */\n\npackage com.opensymphony.module.sitemesh.mapper;\n\nimport com.opensymphony.module.sitemesh.Config;\nimport com.opensymphony.module.sitemesh.Decorator;\nimport com.opensymphony.module.sitemesh.DecoratorMapper;\nimport com.opensymphony.module.sitemesh.Page;\n\nimport javax.servlet.http.HttpServletRequest;\nimport java.io.File;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Properties;\n\n/**\n * The LanguageDecoratorMapper can determine the preferred language set in the\n * browser requesting a page, and map to a suitable Decorator (using the\n * \"Accept-Language\" HTTP header).\n *\n * <p>This can be useful for supplying different versions of the same content\n * for different languages.<\/p>\n *\n * <p>When LanguageDecoratorMapper is in the chain, it will request the appropriate Decorator\n * from its parent. It will then add an extention to the filename of the Decorator, and\n * if that file exists it shall be used as the Decorator instead. For example, if the\n * Decorator path is <code>/blah.jsp<\/code> and the detected preferred language is <code>en<\/code>,\n * the path <code>/blah-en.jsp<\/code> shall be used.<\/p>\n *\n * <p>The language mappings are configured by passing properties with <code>match.<\/code> as a prefix.\n * For example: 'match.en'=engl , 'match.nl'=dutch .<\/p>\n *\n * @author <a href=\"mailto:pathos@pandora.be\">Mathias Bogaert<\/a>\n *\n * @see com.opensymphony.module.sitemesh.DecoratorMapper\n */\npublic final class LanguageDecoratorMapper extends AbstractDecoratorMapper {\n    private Map map = null;\n\n    public void init(Config config, Properties properties, DecoratorMapper parent) throws InstantiationException {\n        super.init(config, properties, parent);\n        map = new HashMap();\n        initMap(properties);\n    }\n\n    public Decorator getDecorator(HttpServletRequest request, Page page) {\n        try {\n            Decorator result = null;\n            final Decorator d = super.getDecorator(request, page);\n            String path = modifyPath(d.getPage(), getExt(request.getHeader(\"Accept-Language\")));\n\n            File decFile = new File(config.getServletContext().getRealPath(path));\n\n            if (decFile.isFile()) {\n                result = new DefaultDecorator(d.getName(), path, null) {\n                    public String getInitParameter(String paramName) {\n                        return d.getInitParameter(paramName);\n                    }\n                };\n            }\n            return result == null ? super.getDecorator(request, page) : result;\n        }\n        catch (NullPointerException e) {\n            return super.getDecorator(request, page);\n        }\n    }\n\n    /** Get extention for the language. */\n    private String getExt(String acceptLanguage) {\n        Iterator i = map.keySet().iterator();\n        while (i.hasNext()) {\n            String current = (String)i.next();\n\n            // Get the first language (preferred one) in the header, and\n            // only check the first two chars (the acceptLanguage could be en-gb, but\n            // we don't support this for now).\n            if (acceptLanguage.substring(0, 2).equals(current)) {\n                return (String)map.get(current);\n            }\n\n            // When the user-agent has multiple accept-languages (separated by ;),\n            // these are ignored because the site creator may wish that if the\n            // preferred language is not supported, the page uses the default\n            // decorator (in the default language), and not in some other\n            // language given by the browser (most of them are specified by\n            // default at install).\n        }\n        return null;\n    }\n\n    /** Change /abc/def.jsp into /abc/def-XYZ.jsp */\n    private static String modifyPath(String path, String ext) {\n        int dot = path.indexOf('.');\n        if (dot > -1) {\n            return path.substring(0, dot) + '-' + ext + path.substring(dot);\n        }\n        else {\n            return path + '-' + ext;\n        }\n    }\n\n    /** Initialize language mappings. */\n    private void initMap(Properties props) {\n        Iterator i = props.keySet().iterator();\n        while (i.hasNext()) {\n            String key = (String)i.next();\n            if (key.startsWith(\"match.\")) {\n                String match = key.substring(6);\n                String ext = props.getProperty(key);\n                map.put(match, ext);\n            }\n        }\n    }\n}\n","lineNo":114}
{"Refactored Sample":"/*\n * Title:        PageDecoratorMapper\n * Description:\n *\n * This software is published under the terms of the OpenSymphony Software\n * License version 1.1, of which a copy has been included with this\n * distribution in the LICENSE.txt file.\n */\n\npackage com.opensymphony.module.sitemesh.mapper;\n\nimport com.opensymphony.module.sitemesh.Config;\nimport com.opensymphony.module.sitemesh.Decorator;\nimport com.opensymphony.module.sitemesh.DecoratorMapper;\nimport com.opensymphony.module.sitemesh.Page;\n\nimport javax.servlet.http.HttpServletRequest;\nimport java.util.*;\n\n/**\n * The PageDecoratorMapper allows the actual Page to determine the Decorator to be\n * used.\n *\n * <p>The 'meta.decorator' and 'decorator' properties of the page are accessed\n * and if any of them contain the name of a valid Decorator, that Decorator shall\n * be applied.<\/p>\n *\n * <p>As an example, if HTML is being used, the Decorator could be chosen by using\n * a <code>&lt;html decorator=\"mydecorator\"&gt;<\/code> root tag <i>or<\/i> by using a\n * <code>&lt;meta name=\"decorator\" content=\"mydecorator\"&gt;<\/code> tag in the header.<\/p>\n *\n * <p>The actual properties to query are specified by passing properties to the mapper using the\n * <code>property.?<\/code> prefix. As the properties are stored in a Map, each key has to be unique.\n * Example: property.1=decorator, property.2=meta.decorator .<\/p>\n *\n * @author <a href=\"mailto:joe@truemesh.com\">Joe Walnes<\/a>\n * @version $Revision: 1.2 $\n *\n * @see com.opensymphony.module.sitemesh.DecoratorMapper\n */\npublic class PageDecoratorMapper extends AbstractDecoratorMapper {\n    private List pageProps = null;\n\n    public void init(Config config, Properties properties, DecoratorMapper parent) throws InstantiationException {\n        super.init(config, properties, parent);\n        pageProps = new ArrayList();\n        Iterator i = properties.entrySet().iterator();\n        while (i.hasNext()) {\n            Map.Entry entry = (Map.Entry) i.next();\n            String key = (String) entry.getKey();\n            if (key.startsWith(\"property\")) {\n                pageProps.add(entry.getValue());\n            }\n        }\n    }\n\n    public Decorator getDecorator(HttpServletRequest request, Page page) {\n        Decorator result = null;\n        Iterator i = pageProps.iterator();\n        while (i.hasNext()) {\n            String propName = (String)i.next();\n            result = getByProperty(request, page, propName);\n            if (result != null) break;\n        }\n        return result == null ? super.getDecorator(request, page) : result;\n    }\n\n    private Decorator getByProperty(HttpServletRequest request, Page p, String name) {\n        if (p.isPropertySet(name)) {\n            return getNamedDecorator(request, p.getProperty(name));\n        }\n        return null;\n    }\n}\n","Smelly Sample":"/*\n * Title:        PageDecoratorMapper\n * Description:\n *\n * This software is published under the terms of the OpenSymphony Software\n * License version 1.1, of which a copy has been included with this\n * distribution in the LICENSE.txt file.\n */\n\npackage com.opensymphony.module.sitemesh.mapper;\n\nimport com.opensymphony.module.sitemesh.Config;\nimport com.opensymphony.module.sitemesh.Decorator;\nimport com.opensymphony.module.sitemesh.DecoratorMapper;\nimport com.opensymphony.module.sitemesh.Page;\n\nimport javax.servlet.http.HttpServletRequest;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Properties;\n\n/**\n * The PageDecoratorMapper allows the actual Page to determine the Decorator to be\n * used.\n *\n * <p>The 'meta.decorator' and 'decorator' properties of the page are accessed\n * and if any of them contain the name of a valid Decorator, that Decorator shall\n * be applied.<\/p>\n *\n * <p>As an example, if HTML is being used, the Decorator could be chosen by using\n * a <code>&lt;html decorator=\"mydecorator\"&gt;<\/code> root tag <i>or<\/i> by using a\n * <code>&lt;meta name=\"decorator\" content=\"mydecorator\"&gt;<\/code> tag in the header.<\/p>\n *\n * <p>The actual properties to query are specified by passing properties to the mapper using the\n * <code>property.?<\/code> prefix. As the properties are stored in a Map, each key has to be unique.\n * Example: property.1=decorator, property.2=meta.decorator .<\/p>\n *\n * @author <a href=\"mailto:joe@truemesh.com\">Joe Walnes<\/a>\n * @version $Revision: 1.1 $\n *\n * @see com.opensymphony.module.sitemesh.DecoratorMapper\n */\npublic class PageDecoratorMapper extends AbstractDecoratorMapper {\n    private List pageProps = null;\n\n    public void init(Config config, Properties properties, DecoratorMapper parent) throws InstantiationException {\n        super.init(config, properties, parent);\n        pageProps = new ArrayList();\n        Iterator i = properties.keySet().iterator();\n        while (i.hasNext()) {\n            String key = (String)i.next();\n            if (key.startsWith(\"property\")) {\n                pageProps.add(properties.getProperty(key));\n            }\n        }\n    }\n\n    public Decorator getDecorator(HttpServletRequest request, Page page) {\n        Decorator result = null;\n        Iterator i = pageProps.iterator();\n        while (i.hasNext()) {\n            String propName = (String)i.next();\n            result = getByProperty(request, page, propName);\n            if (result != null) break;\n        }\n        return result == null ? super.getDecorator(request, page) : result;\n    }\n\n    private Decorator getByProperty(HttpServletRequest request, Page p, String name) {\n        if (p.isPropertySet(name)) {\n            return getNamedDecorator(request, p.getProperty(name));\n        }\n        return null;\n    }\n}\n","lineNo":49}
{"Refactored Sample":"package testsuite.unittests;\n\nimport java.io.*;\nimport java.util.List;\nimport java.util.ArrayList;\n\nimport com.opensymphony.module.sitemesh.parser.FastPageParser;\n\n/**\n * @author Hani Suleiman (hani@formicary.net)\n * Date: Nov 22 2003\n * Time: 12:09:26 AM\n */\npublic class ParserGrinder\n{\n  public static void main(String[] args) throws IOException, InterruptedException\n  {\n    if(args.length==0)\n    {\n      System.err.println(\"Usage: java \" + ParserGrinder.class.getName() + \" <html file>\");\n      System.exit(1);\n    }\n    File file = new File(args[0]);\n    if(!file.exists() || file.isDirectory())\n    {\n      System.err.println(\"File \" + args[0] + \" does not exist or is a directory\");\n      System.exit(1);\n    }\n    FileInputStream fis = new FileInputStream(file);\n    byte[] contents = new byte[(int)file.length()];\n    fis.read(contents);\n    String page = new String(contents);\n    final char[] chars = page.toCharArray();\n    //warm up parser\n\n    for(int i=0;i<10;i++)\n    {\n      FastPageParser parser = new FastPageParser();\n      parser.parse(chars);\n    }\n\n    //now go crazy\n    final int threadCount = 5;\n    Thread[] threads = new Thread[threadCount];\n    final List[] lists = new ArrayList[threadCount];\n    final int passes = 50;\n    for(int i=0;i<threads.length;i++)\n    {\n      final int index = i;\n      lists[index] = new ArrayList(passes);\n      threads[index] = new Thread(new Runnable()\n      {\n        public void run()\n        {\n          for(int j=0;j<passes;j++)\n          {\n            FastPageParser parser = new FastPageParser();\n            try\n            {\n              lists[index].add(parser.parse(chars));\n            }\n            catch(IOException e)\n            {\n              e.printStackTrace();\n            }\n          }\n        }\n      });\n    }\n    //we do this here instead of above just to not count the thread creation overhead\n    long now = System.currentTimeMillis();\n    long startMemory = Runtime.getRuntime().freeMemory();\n    System.out.println(\"startMemory=\" + startMemory);\n    for(int i=0;i<threads.length;i++)\n    {\n      threads[i].start();\n    }\n\n    for(int i = 0; i < threads.length; i++)\n    {\n      threads[i].join();\n    }\n    System.gc();\n    long endMemory = Runtime.getRuntime().freeMemory();\n    System.out.println(\"time taken \" + (System.currentTimeMillis()-now) + \" for \" + (threads.length * passes) + \" parses. Memory used=\" + (startMemory-endMemory));\n  }\n}\n","Smelly Sample":"package testsuite.unittests;\n\nimport java.io.*;\n\nimport com.opensymphony.module.sitemesh.parser.FastPageParser;\n\n/**\n * @author Hani Suleiman (hani@formicary.net)\n * Date: Nov 22 2003\n * Time: 12:09:26 AM\n */\npublic class ParserGrinder\n{\n  public static void main(String[] args) throws IOException, InterruptedException\n  {\n    if(args.length==0)\n    {\n      System.err.println(\"Usage: java \" + ParserGrinder.class.getName() + \" <html file>\");\n      System.exit(1);\n    }\n    File file = new File(args[0]);\n    if(!file.exists() || file.isDirectory())\n    {\n      System.err.println(\"File \" + args[0] + \" does not exist or is a directory\");\n      System.exit(1);\n    }\n    FileInputStream fis = new FileInputStream(file);\n    byte[] contents = new byte[(int)file.length()];\n    fis.read(contents);\n    String page = new String(contents);\n    final char[] chars = page.toCharArray();\n    //warm up parser\n\n    for(int i=0;i<10;i++)\n    {\n      FastPageParser parser = new FastPageParser();\n      parser.parse(chars);\n    }\n\n    //now go crazy\n    Thread[] threads = new Thread[10];\n    final int passes = 200;\n    for(int i=0;i<threads.length;i++)\n    {\n      threads[i] = new Thread(new Runnable()\n      {\n        public void run()\n        {\n          for(int j=0;j<passes;j++)\n          {\n            FastPageParser parser = new FastPageParser();\n            try\n            {\n              parser.parse(chars);\n            }\n            catch(IOException e)\n            {\n              e.printStackTrace();\n            }\n          }\n        }\n      });\n    }\n    //we do this here instead of above just to not count the thread creation overhead\n    long now = System.currentTimeMillis();\n    for(int i=0;i<threads.length;i++)\n    {\n      threads[i].start();\n    }\n\n    for(int i = 0; i < threads.length; i++)\n    {\n      threads[i].join();\n    }\n    System.out.println(\"time taken \" + (System.currentTimeMillis()-now) + \" for \" + (threads.length * passes) + \" parses.\");\n  }\n}\n","lineNo":49}
